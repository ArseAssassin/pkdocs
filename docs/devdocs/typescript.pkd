---
name: TypeScript
slug: typescript
text_format: markdown
generator: src:devdocs
version: ''
copyright: |-
  © 2012-2024 Microsoft
  Licensed under the Apache License, Version 2.0.
  https://www.typescriptlang.org/docs/
homepage: https://www.typescriptlang.org
generator_command: doc src:devdocs use typescript

---
- name: allowArbitraryExtensions
  id: tsconfig/index#allowArbitraryExtensions-config
  summary: In TypeScript 5.0, when an import path ends in an extension that isn’t a known JavaScript or TypeScript file extension, the compiler will look for a declaration file for that path in the form of {file basename}.d.{extension}.ts
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Allow Arbitrary Extensions - `allowArbitraryExtensions`

    In TypeScript 5.0, when an import path ends in an extension that isn’t a known JavaScript or TypeScript file extension, the compiler will look for a declaration file for that path in the form of `{file basename}.d.{extension}.ts`. For example, if you are using a CSS loader in a bundler project, you might want to write (or generate) declaration files for those stylesheets:

    ``` css
    /* app.css */
    .cookie-banner {
      display: none;
    }
    ```

    ``` ts
    // app.d.css.ts
    declare const css: {
      cookieBanner: string;
    };
    export default css;
    ```

    ``` ts
    // App.tsx
    import styles from "./app.css";

    styles.cookieBanner; // string
    ```

    By default, this import will raise an error to let you know that TypeScript doesn’t understand this file type and your runtime might not support importing it. But if you’ve configured your runtime or bundler to handle it, you can suppress the error with the new `--allowArbitraryExtensions` compiler option.

    Note that historically, a similar effect has often been achievable by adding a declaration file named `app.css.d.ts` instead of `app.d.css.ts` - however, this just worked through Node’s `require` resolution rules for CommonJS. Strictly speaking, the former is interpreted as a declaration file for a JavaScript file named `app.css.js`. Because relative files imports need to include extensions in Node’s ESM support, TypeScript would error on our example in an ESM file under `--moduleResolution node16` or `nodenext`.

    For more information, read up [the proposal for this feature](https://github.com/microsoft/TypeScript/issues/50133) and [its corresponding pull request](https://github.com/microsoft/TypeScript/pull/51435).
- name: allowArbitraryExtensions
  id: tsconfig#allowArbitraryExtensions-config
  summary: In TypeScript 5.0, when an import path ends in an extension that isn’t a known JavaScript or TypeScript file extension, the compiler will look for a declaration file for that path in the form of {file basename}.d.{extension}.ts
  belongs_to: TSConfig Reference
  description: |-
    ### Allow Arbitrary Extensions - `allowArbitraryExtensions`

    In TypeScript 5.0, when an import path ends in an extension that isn’t a known JavaScript or TypeScript file extension, the compiler will look for a declaration file for that path in the form of `{file basename}.d.{extension}.ts`. For example, if you are using a CSS loader in a bundler project, you might want to write (or generate) declaration files for those stylesheets:

    ``` css
    /* app.css */
    .cookie-banner {
      display: none;
    }
    ```

    ``` ts
    // app.d.css.ts
    declare const css: {
      cookieBanner: string;
    };
    export default css;
    ```

    ``` ts
    // App.tsx
    import styles from "./app.css";

    styles.cookieBanner; // string
    ```

    By default, this import will raise an error to let you know that TypeScript doesn’t understand this file type and your runtime might not support importing it. But if you’ve configured your runtime or bundler to handle it, you can suppress the error with the new `--allowArbitraryExtensions` compiler option.

    Note that historically, a similar effect has often been achievable by adding a declaration file named `app.css.d.ts` instead of `app.d.css.ts` - however, this just worked through Node’s `require` resolution rules for CommonJS. Strictly speaking, the former is interpreted as a declaration file for a JavaScript file named `app.css.js`. Because relative files imports need to include extensions in Node’s ESM support, TypeScript would error on our example in an ESM file under `--moduleResolution node16` or `nodenext`.

    For more information, read up [the proposal for this feature](https://github.com/microsoft/TypeScript/issues/50133) and [its corresponding pull request](https://github.com/microsoft/TypeScript/pull/51435).
- name: allowImportingTsExtensions
  id: tsconfig#allowImportingTsExtensions-config
  summary: --allowImportingTsExtensions allows TypeScript files to import each other with a TypeScript-specific extension like .ts, .mts, or .tsx
  belongs_to: TSConfig Reference
  description: |-
    ### Allow Importing TS Extensions - `allowImportingTsExtensions`

    `--allowImportingTsExtensions` allows TypeScript files to import each other with a TypeScript-specific extension like `.ts`, `.mts`, or `.tsx`.

    This flag is only allowed when `--noEmit` or `--emitDeclarationOnly` is enabled, since these import paths would not be resolvable at runtime in JavaScript output files. The expectation here is that your resolver (e.g. your bundler, a runtime, or some other tool) is going to make these imports between `.ts` files work.
- name: allowImportingTsExtensions
  id: tsconfig/index#allowImportingTsExtensions-config
  summary: --allowImportingTsExtensions allows TypeScript files to import each other with a TypeScript-specific extension like .ts, .mts, or .tsx
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Allow Importing TS Extensions - `allowImportingTsExtensions`

    `--allowImportingTsExtensions` allows TypeScript files to import each other with a TypeScript-specific extension like `.ts`, `.mts`, or `.tsx`.

    This flag is only allowed when `--noEmit` or `--emitDeclarationOnly` is enabled, since these import paths would not be resolvable at runtime in JavaScript output files. The expectation here is that your resolver (e.g. your bundler, a runtime, or some other tool) is going to make these imports between `.ts` files work.
- name: allowJs
  id: tsconfig#allowJs-config
  summary: Allow JavaScript files to be imported inside your project, instead of just .ts and .tsx files
  belongs_to: TSConfig Reference
  description: |-
    ### Allow JS - `allowJs`

    Allow JavaScript files to be imported inside your project, instead of just `.ts` and `.tsx` files. For example, this JS file:

    ``` js
    // @filename: card.js
    export const defaultCardDeck = "Heart";
    ```

    When imported into a TypeScript file will raise an error:

    ``` ts
    // @filename: index.ts
    import { defaultCardDeck } from "./card";
     
    console.log(defaultCardDeck);
    ```

    Imports fine with `allowJs` enabled:

    ``` ts
    // @filename: index.ts
    import { defaultCardDeck } from "./card";
     
    console.log(defaultCardDeck);
    ```

    This flag can be used as a way to incrementally add TypeScript files into JS projects by allowing the `.ts` and `.tsx` files to live along-side existing JavaScript files.

    It can also be used along-side [`declaration`](#declaration) and [`emitDeclarationOnly`](#emitDeclarationOnly) to [create declarations for JS files](docs/handbook/declaration-files/dts-from-js).

    - Related:
      - [`checkJs`](#checkJs)

      - [`emitDeclarationOnly`](#emitDeclarationOnly)

    - Released:

      [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)
- name: allowJs
  id: tsconfig/index#allowJs-config
  summary: Allow JavaScript files to be imported inside your project, instead of just .ts and .tsx files
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Allow JS - `allowJs`

    Allow JavaScript files to be imported inside your project, instead of just `.ts` and `.tsx` files. For example, this JS file:

    ``` js
    // @filename: card.js
    export const defaultCardDeck = "Heart";
    ```

    When imported into a TypeScript file will raise an error:

    ``` ts
    // @filename: index.ts
    import { defaultCardDeck } from "./card";
     
    console.log(defaultCardDeck);
    ```

    Imports fine with `allowJs` enabled:

    ``` ts
    // @filename: index.ts
    import { defaultCardDeck } from "./card";
     
    console.log(defaultCardDeck);
    ```

    This flag can be used as a way to incrementally add TypeScript files into JS projects by allowing the `.ts` and `.tsx` files to live along-side existing JavaScript files.

    It can also be used along-side [`declaration`](#declaration) and [`emitDeclarationOnly`](#emitDeclarationOnly) to [create declarations for JS files](../docs/handbook/declaration-files/dts-from-js).

    - Related:
      - [`checkJs`](#checkJs)

      - [`emitDeclarationOnly`](#emitDeclarationOnly)

    - Released:

      [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)
- name: allowSyntheticDefaultImports
  id: tsconfig/index#allowSyntheticDefaultImports-config
  summary: When the module does not explicitly specify a default export
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Allow Synthetic Default Imports - `allowSyntheticDefaultImports`

    When set to true, `allowSyntheticDefaultImports` allows you to write an import like:

    ``` ts
    import React from "react";
    ```

    instead of:

    ``` ts
    import * as React from "react";
    ```

    When the module **does not** explicitly specify a default export.

    For example, without `allowSyntheticDefaultImports` as true:

    ``` ts
    // @filename: utilFunctions.js
    const getStringLength = (str) => str.length;
     
    module.exports = {
      getStringLength,
    };
     
    // @filename: index.ts
    import utils from "./utilFunctions";
     
    const count = utils.getStringLength("Check JS");
    ```

    This code raises an error because there isn’t a `default` object which you can import. Even though it feels like it should. For convenience, transpilers like Babel will automatically create a default if one isn’t created. Making the module look a bit more like:

    ``` js
    // @filename: utilFunctions.js
    const getStringLength = (str) => str.length;
    const allFunctions = {
      getStringLength,
    };

    module.exports = allFunctions;
    module.exports.default = allFunctions;
    ```

    This flag does not affect the JavaScript emitted by TypeScript, it’s only for the type checking. This option brings the behavior of TypeScript in-line with Babel, where extra code is emitted to make using a default export of a module more ergonomic.

    - Default:

      `true` if [`esModuleInterop`](#esModuleInterop) is enabled, [`module`](#module) is `system`, or [`moduleResolution`](#module-resolution) is `bundler`; `false` otherwise.

    - Related:
      - [`esModuleInterop`](#esModuleInterop)

    - Released:

      [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)
- name: allowSyntheticDefaultImports
  id: tsconfig#allowSyntheticDefaultImports-config
  summary: When the module does not explicitly specify a default export
  belongs_to: TSConfig Reference
  description: |-
    ### Allow Synthetic Default Imports - `allowSyntheticDefaultImports`

    When set to true, `allowSyntheticDefaultImports` allows you to write an import like:

    ``` ts
    import React from "react";
    ```

    instead of:

    ``` ts
    import * as React from "react";
    ```

    When the module **does not** explicitly specify a default export.

    For example, without `allowSyntheticDefaultImports` as true:

    ``` ts
    // @filename: utilFunctions.js
    const getStringLength = (str) => str.length;
     
    module.exports = {
      getStringLength,
    };
     
    // @filename: index.ts
    import utils from "./utilFunctions";
     
    const count = utils.getStringLength("Check JS");
    ```

    This code raises an error because there isn’t a `default` object which you can import. Even though it feels like it should. For convenience, transpilers like Babel will automatically create a default if one isn’t created. Making the module look a bit more like:

    ``` js
    // @filename: utilFunctions.js
    const getStringLength = (str) => str.length;
    const allFunctions = {
      getStringLength,
    };

    module.exports = allFunctions;
    module.exports.default = allFunctions;
    ```

    This flag does not affect the JavaScript emitted by TypeScript, it’s only for the type checking. This option brings the behavior of TypeScript in-line with Babel, where extra code is emitted to make using a default export of a module more ergonomic.

    - Default:

      `true` if [`esModuleInterop`](#esModuleInterop) is enabled, [`module`](#module) is `system`, or [`moduleResolution`](#module-resolution) is `bundler`; `false` otherwise.

    - Related:
      - [`esModuleInterop`](#esModuleInterop)

    - Released:

      [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)
- name: allowUmdGlobalAccess
  id: tsconfig/index#allowUmdGlobalAccess-config
  summary: When set to true, allowUmdGlobalAccess lets you access UMD exports as globals from inside module files
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Allow Umd Global Access - `allowUmdGlobalAccess`

    When set to true, `allowUmdGlobalAccess` lets you access UMD exports as globals from inside module files. A module file is a file that has imports and/or exports. Without this flag, using an export from a UMD module requires an import declaration.

    An example use case for this flag would be a web project where you know the particular library (like jQuery or Lodash) will always be available at runtime, but you can’t access it with an import.

    - Released:

      [3.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html)
- name: allowUmdGlobalAccess
  id: tsconfig#allowUmdGlobalAccess-config
  summary: When set to true, allowUmdGlobalAccess lets you access UMD exports as globals from inside module files
  belongs_to: TSConfig Reference
  description: |-
    ### Allow Umd Global Access - `allowUmdGlobalAccess`

    When set to true, `allowUmdGlobalAccess` lets you access UMD exports as globals from inside module files. A module file is a file that has imports and/or exports. Without this flag, using an export from a UMD module requires an import declaration.

    An example use case for this flag would be a web project where you know the particular library (like jQuery or Lodash) will always be available at runtime, but you can’t access it with an import.

    - Released:

      [3.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html)
- name: allowUnreachableCode
  id: tsconfig/index#allowUnreachableCode-config
  summary: This does not affect errors on the basis of code which appears to be unreachable due to type analysis
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Allow Unreachable Code - `allowUnreachableCode`

    When:

    - `undefined` (default) provide suggestions as warnings to editors
    - `true` unreachable code is ignored
    - `false` raises compiler errors about unreachable code

    These warnings are only about code which is provably unreachable due to the use of JavaScript syntax, for example:

    ``` ts
    function fn(n: number) {
      if (n > 5) {
        return true;
      } else {
        return false;
      }
      return true;
    }
    ```

    With `"allowUnreachableCode": false`:

    ``` ts
    function fn(n: number) {
      if (n > 5) {
        return true;
      } else {
        return false;
      }
      return true;
    }
    ```

    This does not affect errors on the basis of code which *appears* to be unreachable due to type analysis.

    - Released:

      [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)
- name: allowUnreachableCode
  id: tsconfig#allowUnreachableCode-config
  summary: This does not affect errors on the basis of code which appears to be unreachable due to type analysis
  belongs_to: TSConfig Reference
  description: |-
    ### Allow Unreachable Code - `allowUnreachableCode`

    When:

    - `undefined` (default) provide suggestions as warnings to editors
    - `true` unreachable code is ignored
    - `false` raises compiler errors about unreachable code

    These warnings are only about code which is provably unreachable due to the use of JavaScript syntax, for example:

    ``` ts
    function fn(n: number) {
      if (n > 5) {
        return true;
      } else {
        return false;
      }
      return true;
    }
    ```

    With `"allowUnreachableCode": false`:

    ``` ts
    function fn(n: number) {
      if (n > 5) {
        return true;
      } else {
        return false;
      }
      return true;
    }
    ```

    This does not affect errors on the basis of code which *appears* to be unreachable due to type analysis.

    - Released:

      [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)
- name: allowUnusedLabels
  id: tsconfig/index#allowUnusedLabels-config
  summary: null
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Allow Unused Labels - `allowUnusedLabels`

    When:

    - `undefined` (default) provide suggestions as warnings to editors
    - `true` unused labels are ignored
    - `false` raises compiler errors about unused labels

    Labels are very rare in JavaScript and typically indicate an attempt to write an object literal:

    ``` ts
    function verifyAge(age: number) {
      // Forgot 'return' statement
      if (age > 18) {
        verified: true;
      }
    }
    ```

    - Released:

      [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)
- name: allowUnusedLabels
  id: tsconfig#allowUnusedLabels-config
  summary: null
  belongs_to: TSConfig Reference
  description: |-
    ### Allow Unused Labels - `allowUnusedLabels`

    When:

    - `undefined` (default) provide suggestions as warnings to editors
    - `true` unused labels are ignored
    - `false` raises compiler errors about unused labels

    Labels are very rare in JavaScript and typically indicate an attempt to write an object literal:

    ``` ts
    function verifyAge(age: number) {
      // Forgot 'return' statement
      if (age > 18) {
        verified: true;
      }
    }
    ```

    - Released:

      [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)
- name: alwaysStrict
  id: tsconfig#alwaysStrict-config
  summary: Ensures that your files are parsed in the ECMAScript strict mode, and emit “use strict” for each source file
  belongs_to: TSConfig Reference
  description: |-
    ### Always Strict - `alwaysStrict`

    Ensures that your files are parsed in the ECMAScript strict mode, and emit “use strict” for each source file.

    [ECMAScript strict](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode) mode was introduced in ES5 and provides behavior tweaks to the runtime of the JavaScript engine to improve performance, and makes a set of errors throw instead of silently ignoring them.

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)

    - Released:

      [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html)
- name: alwaysStrict
  id: tsconfig/index#alwaysStrict-config
  summary: Ensures that your files are parsed in the ECMAScript strict mode, and emit “use strict” for each source file
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Always Strict - `alwaysStrict`

    Ensures that your files are parsed in the ECMAScript strict mode, and emit “use strict” for each source file.

    [ECMAScript strict](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode) mode was introduced in ES5 and provides behavior tweaks to the runtime of the JavaScript engine to improve performance, and makes a set of errors throw instead of silently ignoring them.

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)

    - Released:

      [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html)
- name: ASP.NET Core
  id: asp-net-core
  summary: First, install ASP.NET Core if you need it
  description: "# ASP.NET Core\n\n## Install ASP.NET Core and TypeScript\n\nFirst, install [ASP.NET Core](https://dotnet.microsoft.com/apps/aspnet) if you need it. This quick-start guide requires Visual Studio 2015 or 2017.\n\nNext, if your version of Visual Studio does not already have the latest TypeScript, you can [install it](https://www.typescriptlang.org/index.html#download-links).\n\n## Create a new project\n\n1.  Choose **File**\n2.  Choose **New Project** (Ctrl + Shift + N)\n3.  Search for **.NET Core** in the project search bar\n4.  Select **ASP.NET Core Web Application** and press the *Next* button\n\n5.  Name your project and solution. After select the *Create* button\n\n&nbsp;\n\n6.  In the last window, select the **Empty** template and press the *Create* button\n\nRun the application and make sure that it works.\n\n### Set up the server\n\nOpen **Dependencies \\> Manage NuGet Packages \\> Browse.** Search and install `Microsoft.AspNetCore.StaticFiles` and `Microsoft.TypeScript.MSBuild`:\n\nOpen up your `Startup.cs` file and edit your `Configure` function to look like this:\n\n``` typescript\npublic void Configure(IApplicationBuilder app, IHostEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n\n    app.UseDefaultFiles();\n    app.UseStaticFiles();\n}\n```\n\nYou may need to restart VS for the red squiggly lines below `UseDefaultFiles` and `UseStaticFiles` to disappear.\n\n## Add TypeScript\n\nNext we will add a new folder and call it `scripts`.\n\n## Add TypeScript code\n\nRight click on `scripts` and click **New Item**. Then choose **TypeScript File** and name the file `app.ts`\n\n### Add example code\n\nAdd the following code to the `app.ts` file.\n\n``` ts\nfunction sayHello() {\n  const compiler = (document.getElementById(\"compiler\") as HTMLInputElement)\n    .value;\n  const framework = (document.getElementById(\"framework\") as HTMLInputElement)\n    .value;\n  return `Hello from ${compiler} and ${framework}!`;\n}\n```\n\n## Set up the build\n\n*Configure the TypeScript compiler*\n\nFirst we need to tell TypeScript how to build. Right click on `scripts` and click **New Item**. Then choose **TypeScript Configuration File** and use the default name of `tsconfig.json`\n\nReplace the contents of the `tsconfig.json` file with:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"noEmitOnError\": true,\n    \"noImplicitAny\": true,\n    \"sourceMap\": true,\n    \"target\": \"es6\"\n  },\n  \"files\": [\"./app.ts\"],\n  \"compileOnSave\": true\n}\n```\n\n- [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) : Do not emit outputs if any errors were reported.\n- [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) : Raise error on expressions and declarations with an implied `any` type.\n- [`sourceMap`](https://www.typescriptlang.org/tsconfig#sourceMap) : Generates corresponding `.map` file.\n- [`target`](https://www.typescriptlang.org/tsconfig#target) : Specify ECMAScript target version.\n\nNote: `\"ESNext\"` targets latest supported\n\n[`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) is good idea whenever you’re writing new code — you can make sure that you don’t write any untyped code by mistake. `\"compileOnSave\"` makes it easy to update your code in a running web app.\n\n#### *Set up NPM*\n\nWe need to setup NPM so that JavaScript packages can be downloaded. Right click on the project and select **New Item**. Then choose **NPM Configuration File** and use the default name of `package.json`.\n\nInside the `\"devDependencies\"` section of the `package.json` file, add *gulp* and *del*\n\n``` typescript\n\"devDependencies\": {\n    \"gulp\": \"4.0.2\",\n    \"del\": \"5.1.0\"\n}\n```\n\nVisual Studio should start installing gulp and del as soon as you save the file. If not, right-click package.json and then Restore Packages.\n\nAfter you should see an `npm` folder in your solution explorer\n\n#### *Set up gulp*\n\nRight click on the project and click **New Item**. Then choose **JavaScript File** and use the name of `gulpfile.js`\n\n``` js\n/// <binding AfterBuild='default' Clean='clean' />\n/*\nThis file is the main entry point for defining Gulp tasks and using Gulp plugins.\nClick here to learn more. http://go.microsoft.com/fwlink/?LinkId=518007\n*/\n\nvar gulp = require(\"gulp\");\nvar del = require(\"del\");\n\nvar paths = {\n  scripts: [\"scripts/**/*.js\", \"scripts/**/*.ts\", \"scripts/**/*.map\"],\n};\n\ngulp.task(\"clean\", function () {\n  return del([\"wwwroot/scripts/**/*\"]);\n});\n\ngulp.task(\"default\", function (done) {\n    gulp.src(paths.scripts).pipe(gulp.dest(\"wwwroot/scripts\"));\n    done();\n});\n```\n\nThe first line tells Visual Studio to run the task ‘default’ after the build finishes. It will also run the ‘clean’ task when you ask Visual Studio to clean the build.\n\nNow right-click on `gulpfile.js` and click Task Runner Explorer.\n\nIf ‘default’ and ‘clean’ tasks don’t show up, refresh the explorer:\n\n## Write a HTML page\n\nRight click on the `wwwroot` folder (if you don’t see the folder try building the project) and add a New Item named `index.html` inside. Use the following code for `index.html`\n\n``` typescript\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <script src=\"scripts/app.js\"></script>\n    <title></title>\n</head>\n<body>\n    <div id=\"message\"></div>\n    <div>\n        Compiler: <input id=\"compiler\" value=\"TypeScript\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" /><br />\n        Framework: <input id=\"framework\" value=\"ASP.NET\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" />\n    </div>\n</body>\n</html>\n```\n\n## Test\n\n1.  Run the project\n2.  As you type on the boxes you should see the message appear/change!\n\n## Debug\n\n1.  In Edge, press F12 and click the Debugger tab.\n2.  Look in the first localhost folder, then scripts/app.ts\n3.  Put a breakpoint on the line with return.\n4.  Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.\n\nCongrats you’ve built your own .NET Core project with a TypeScript frontend.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/asp-net-core.html](https://www.typescriptlang.org/docs/handbook/asp-net-core.html)"
- name: 'ASP.NET Core: Add TypeScript'
  id: asp-net-core#add-typescript
  summary: Next we will add a new folder and call it scripts
  belongs_to: ASP.NET Core
  description: |-
    ## Add TypeScript

    Next we will add a new folder and call it `scripts`.
- name: 'ASP.NET Core: Add TypeScript code'
  id: asp-net-core#add-typescript-code
  summary: Right click on scripts and click New Item
  belongs_to: ASP.NET Core
  description: |-
    ## Add TypeScript code

    Right click on `scripts` and click **New Item**. Then choose **TypeScript File** and name the file `app.ts`

    ### Add example code

    Add the following code to the `app.ts` file.

    ``` ts
    function sayHello() {
      const compiler = (document.getElementById("compiler") as HTMLInputElement)
        .value;
      const framework = (document.getElementById("framework") as HTMLInputElement)
        .value;
      return `Hello from ${compiler} and ${framework}!`;
    }
    ```
- name: 'ASP.NET Core: Create a new project'
  id: asp-net-core#create-a-new-project
  summary: Name your project and solution
  belongs_to: ASP.NET Core
  description: |-
    ## Create a new project

    1.  Choose **File**
    2.  Choose **New Project** (Ctrl + Shift + N)
    3.  Search for **.NET Core** in the project search bar
    4.  Select **ASP.NET Core Web Application** and press the *Next* button

    5.  Name your project and solution. After select the *Create* button

    &nbsp;

    6.  In the last window, select the **Empty** template and press the *Create* button

    Run the application and make sure that it works.

    ### Set up the server

    Open **Dependencies \> Manage NuGet Packages \> Browse.** Search and install `Microsoft.AspNetCore.StaticFiles` and `Microsoft.TypeScript.MSBuild`:

    Open up your `Startup.cs` file and edit your `Configure` function to look like this:

    ``` typescript
    public void Configure(IApplicationBuilder app, IHostEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.UseDefaultFiles();
        app.UseStaticFiles();
    }
    ```

    You may need to restart VS for the red squiggly lines below `UseDefaultFiles` and `UseStaticFiles` to disappear.
- name: 'ASP.NET Core: Debug'
  id: asp-net-core#debug
  summary: Congrats you’ve built your own .NET Core project with a TypeScript frontend
  belongs_to: ASP.NET Core
  description: "## Debug\n\n1.  In Edge, press F12 and click the Debugger tab.\n2.  Look in the first localhost folder, then scripts/app.ts\n3.  Put a breakpoint on the line with return.\n4.  Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.\n\nCongrats you’ve built your own .NET Core project with a TypeScript frontend.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/asp-net-core.html](https://www.typescriptlang.org/docs/handbook/asp-net-core.html)"
- name: 'ASP.NET Core: Install ASP.NET Core and TypeScript'
  id: asp-net-core#install-aspnet-core-and-typescript
  summary: First, install ASP.NET Core if you need it
  belongs_to: ASP.NET Core
  description: |-
    ## Install ASP.NET Core and TypeScript

    First, install [ASP.NET Core](https://dotnet.microsoft.com/apps/aspnet) if you need it. This quick-start guide requires Visual Studio 2015 or 2017.

    Next, if your version of Visual Studio does not already have the latest TypeScript, you can [install it](https://www.typescriptlang.org/index.html#download-links).
- name: 'ASP.NET Core: Set up the build'
  id: asp-net-core#set-up-the-build
  summary: First we need to tell TypeScript how to build
  belongs_to: ASP.NET Core
  description: |-
    ## Set up the build

    *Configure the TypeScript compiler*

    First we need to tell TypeScript how to build. Right click on `scripts` and click **New Item**. Then choose **TypeScript Configuration File** and use the default name of `tsconfig.json`

    Replace the contents of the `tsconfig.json` file with:

    ``` typescript
    {
      "compilerOptions": {
        "noEmitOnError": true,
        "noImplicitAny": true,
        "sourceMap": true,
        "target": "es6"
      },
      "files": ["./app.ts"],
      "compileOnSave": true
    }
    ```

    - [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) : Do not emit outputs if any errors were reported.
    - [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) : Raise error on expressions and declarations with an implied `any` type.
    - [`sourceMap`](https://www.typescriptlang.org/tsconfig#sourceMap) : Generates corresponding `.map` file.
    - [`target`](https://www.typescriptlang.org/tsconfig#target) : Specify ECMAScript target version.

    Note: `"ESNext"` targets latest supported

    [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) is good idea whenever you’re writing new code — you can make sure that you don’t write any untyped code by mistake. `"compileOnSave"` makes it easy to update your code in a running web app.

    #### *Set up NPM*

    We need to setup NPM so that JavaScript packages can be downloaded. Right click on the project and select **New Item**. Then choose **NPM Configuration File** and use the default name of `package.json`.

    Inside the `"devDependencies"` section of the `package.json` file, add *gulp* and *del*

    ``` typescript
    "devDependencies": {
        "gulp": "4.0.2",
        "del": "5.1.0"
    }
    ```

    Visual Studio should start installing gulp and del as soon as you save the file. If not, right-click package.json and then Restore Packages.

    After you should see an `npm` folder in your solution explorer

    #### *Set up gulp*

    Right click on the project and click **New Item**. Then choose **JavaScript File** and use the name of `gulpfile.js`

    ``` js
    /// <binding AfterBuild='default' Clean='clean' />
    /*
    This file is the main entry point for defining Gulp tasks and using Gulp plugins.
    Click here to learn more. http://go.microsoft.com/fwlink/?LinkId=518007
    */

    var gulp = require("gulp");
    var del = require("del");

    var paths = {
      scripts: ["scripts/**/*.js", "scripts/**/*.ts", "scripts/**/*.map"],
    };

    gulp.task("clean", function () {
      return del(["wwwroot/scripts/**/*"]);
    });

    gulp.task("default", function (done) {
        gulp.src(paths.scripts).pipe(gulp.dest("wwwroot/scripts"));
        done();
    });
    ```

    The first line tells Visual Studio to run the task ‘default’ after the build finishes. It will also run the ‘clean’ task when you ask Visual Studio to clean the build.

    Now right-click on `gulpfile.js` and click Task Runner Explorer.

    If ‘default’ and ‘clean’ tasks don’t show up, refresh the explorer:
- name: 'ASP.NET Core: Test'
  id: asp-net-core#test
  summary: null
  belongs_to: ASP.NET Core
  description: |-
    ## Test

    1.  Run the project
    2.  As you type on the boxes you should see the message appear/change!

    &nbsp;
- name: 'ASP.NET Core: Write a HTML page'
  id: asp-net-core#write-a-html-page
  summary: Right click on the wwwroot folder (if you don’t see the folder try building the project) and add a New Item named index.html inside
  belongs_to: ASP.NET Core
  description: |-
    ## Write a HTML page

    Right click on the `wwwroot` folder (if you don’t see the folder try building the project) and add a New Item named `index.html` inside. Use the following code for `index.html`

    ``` typescript
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8" />
        <script src="scripts/app.js"></script>
        <title></title>
    </head>
    <body>
        <div id="message"></div>
        <div>
            Compiler: <input id="compiler" value="TypeScript" onkeyup="document.getElementById('message').innerText = sayHello()" /><br />
            Framework: <input id="framework" value="ASP.NET" onkeyup="document.getElementById('message').innerText = sayHello()" />
        </div>
    </body>
    </html>
    ```
- name: assumeChangesOnlyAffectDirectDependencies
  id: tsconfig#assumeChangesOnlyAffectDirectDependencies-config
  summary: When this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them
  belongs_to: TSConfig Reference
  description: |-
    ### Assume Changes Only Affect Direct Dependencies - `assumeChangesOnlyAffectDirectDependencies`

    When this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them.

    This can be considered a ‘fast & loose’ implementation of the watching algorithm, which can drastically reduce incremental rebuild times at the expense of having to run the full build occasionally to get all compiler error messages.

    - Released:

      [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)

    ## Watch Options

    You can configure the how TypeScript `--watch` works. This section is mainly for handling case where `fs.watch` and `fs.watchFile` have additional constraints like on Linux. You can read more at [Configuring Watch](docs/handbook/configuring-watch).
- name: assumeChangesOnlyAffectDirectDependencies
  id: tsconfig/index#assumeChangesOnlyAffectDirectDependencies-config
  summary: When this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Assume Changes Only Affect Direct Dependencies - `assumeChangesOnlyAffectDirectDependencies`

    When this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them.

    This can be considered a ‘fast & loose’ implementation of the watching algorithm, which can drastically reduce incremental rebuild times at the expense of having to run the full build occasionally to get all compiler error messages.

    - Released:

      [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)

    ## Watch Options

    You can configure the how TypeScript `--watch` works. This section is mainly for handling case where `fs.watch` and `fs.watchFile` have additional constraints like on Linux. You can read more at [Configuring Watch](../docs/handbook/configuring-watch).
- name: baseUrl
  id: tsconfig#baseUrl-config
  summary: Sets a base directory from which to resolve bare specifier module names
  belongs_to: TSConfig Reference
  description: |-
    ### Base URL - `baseUrl`

    Sets a base directory from which to resolve bare specifier module names. For example, in the directory structure:

    ``` typescript
    project
    ├── ex.ts
    ├── hello
    │   └── world.ts
    └── tsconfig.json
    ```

    With `"baseUrl": "./"`, TypeScript will look for files starting at the same folder as the `tsconfig.json`:

    ``` ts
    import { helloWorld } from "hello/world";

    console.log(helloWorld);
    ```

    This resolution has higher priority than lookups from `node_modules`.

    This feature was designed for use in conjunction with AMD module loaders in the browser, and is not recommended in any other context. As of TypeScript 4.1, `baseUrl` is no longer required to be set when using [`paths`](#paths).
- name: baseUrl
  id: tsconfig/index#baseUrl-config
  summary: Sets a base directory from which to resolve bare specifier module names
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Base URL - `baseUrl`

    Sets a base directory from which to resolve bare specifier module names. For example, in the directory structure:

    ``` typescript
    project
    ├── ex.ts
    ├── hello
    │   └── world.ts
    └── tsconfig.json
    ```

    With `"baseUrl": "./"`, TypeScript will look for files starting at the same folder as the `tsconfig.json`:

    ``` ts
    import { helloWorld } from "hello/world";

    console.log(helloWorld);
    ```

    This resolution has higher priority than lookups from `node_modules`.

    This feature was designed for use in conjunction with AMD module loaders in the browser, and is not recommended in any other context. As of TypeScript 4.1, `baseUrl` is no longer required to be set when using [`paths`](#paths).
- name: Basic Types
  id: basic-types
  summary: 'For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like'
  description: "# Basic Types\n\nThis handbook page has been replaced, [go to the new page](2/everyday-types)\n\nFor programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support the same types as you would expect in JavaScript, with an extra enumeration type thrown in to help things along.\n\n## Boolean\n\nThe most basic datatype is the simple true/false value, which JavaScript and TypeScript call a `boolean` value.\n\n``` ts\nlet isDone: boolean = false;\n```\n\n## Number\n\nAs in JavaScript, all numbers in TypeScript are either floating point values or BigIntegers. These floating point numbers get the type `number`, while BigIntegers get the type `bigint`. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.\n\n``` ts\nlet decimal: number = 6;\nlet hex: number = 0xf00d;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\nlet big: bigint = 100n;\n```\n\n## String\n\nAnother fundamental part of creating programs in JavaScript for webpages and servers alike is working with textual data. As in other languages, we use the type `string` to refer to these textual datatypes. Just like JavaScript, TypeScript also uses double quotes (`\"`) or single quotes (`'`) to surround string data.\n\n``` ts\nlet color: string = \"blue\";\ncolor = 'red';\n```\n\nYou can also use *template strings*, which can span multiple lines and have embedded expressions. These strings are surrounded by the backtick/backquote (`` ` ``) character, and embedded expressions are of the form `${ expr }`.\n\n``` ts\nlet fullName: string = `Bob Bobbington`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is ${fullName}.\n \nI'll be ${age + 1} years old next month.`;\n```\n\nThis is equivalent to declaring `sentence` like so:\n\n``` ts\nlet sentence: string =\n  \"Hello, my name is \" +\n  fullName +\n  \".\\n\\n\" +\n  \"I'll be \" +\n  (age + 1) +\n  \" years old next month.\";\n```\n\n## Array\n\nTypeScript, like JavaScript, allows you to work with arrays of values. Array types can be written in one of two ways. In the first, you use the type of the elements followed by `[]` to denote an array of that element type:\n\n``` ts\nlet list: number[] = [1, 2, 3];\n```\n\nThe second way uses a generic array type, `Array<elemType>`:\n\n``` ts\nlet list: Array<number> = [1, 2, 3];\n```\n\n## Tuple\n\nTuple types allow you to express an array with a fixed number of elements whose types are known, but need not be the same. For example, you may want to represent a value as a pair of a `string` and a `number`:\n\n``` ts\n// Declare a tuple type\nlet x: [string, number];\n// Initialize it\nx = [\"hello\", 10]; // OK\n// Initialize it incorrectly\nx = [10, \"hello\"]; // Error\n```\n\nWhen accessing an element with a known index, the correct type is retrieved:\n\n``` ts\n// OK\nconsole.log(x[0].substring(1));\n \nconsole.log(x[1].substring(1));\n```\n\nAccessing an element outside the set of known indices fails with an error:\n\n``` ts\nx[3] = \"world\";\n \nconsole.log(x[5].toString());\n```\n\n## Enum\n\nA helpful addition to the standard set of datatypes from JavaScript is the `enum`. As in languages like C#, an enum is a way of giving more friendly names to sets of numeric values.\n\n``` ts\nenum Color {\n  Red,\n  Green,\n  Blue,\n}\nlet c: Color = Color.Green;\n```\n\nBy default, enums begin numbering their members starting at `0`. You can change this by manually setting the value of one of its members. For example, we can start the previous example at `1` instead of `0`:\n\n``` ts\nenum Color {\n  Red = 1,\n  Green,\n  Blue,\n}\nlet c: Color = Color.Green;\n```\n\nOr, even manually set all the values in the enum:\n\n``` ts\nenum Color {\n  Red = 1,\n  Green = 2,\n  Blue = 4,\n}\nlet c: Color = Color.Green;\n```\n\nA handy feature of enums is that you can also go from a numeric value to the name of that value in the enum. For example, if we had the value `2` but weren’t sure what that mapped to in the `Color` enum above, we could look up the corresponding name:\n\n``` ts\nenum Color {\n  Red = 1,\n  Green,\n  Blue,\n}\nlet colorName: string = Color[2];\n \n// Displays 'Green'\nconsole.log(colorName);\n```\n\n## Unknown\n\nWe may need to describe the type of variables that we do not know when we are writing an application. These values may come from dynamic content – e.g. from the user – or we may want to intentionally accept all values in our API. In these cases, we want to provide a type that tells the compiler and future readers that this variable could be anything, so we give it the `unknown` type.\n\n``` ts\nlet notSure: unknown = 4;\nnotSure = \"maybe a string instead\";\n \n// OK, definitely a boolean\nnotSure = false;\n```\n\nIf you have a variable with an unknown type, you can narrow it to something more specific by doing `typeof` checks, comparison checks, or more advanced type guards that will be discussed in a later chapter:\n\n``` ts\ndeclare const maybe: unknown;\n// 'maybe' could be a string, object, boolean, undefined, or other types\nconst aNumber: number = maybe;\n \nif (maybe === true) {\n  // TypeScript knows that maybe is a boolean now\n  const aBoolean: boolean = maybe;\n  // So, it cannot be a string\n  const aString: string = maybe;\n}\n \nif (typeof maybe === \"string\") {\n  // TypeScript knows that maybe is a string\n  const aString: string = maybe;\n  // So, it cannot be a boolean\n  const aBoolean: boolean = maybe;\n}\n```\n\n## Any\n\nIn some situations, not all type information is available or its declaration would take an inappropriate amount of effort. These may occur for values from code that has been written without TypeScript or a 3rd party library. In these cases, we might want to opt-out of type checking. To do so, we label these values with the `any` type:\n\n``` ts\ndeclare function getValue(key: string): any;\n// OK, return value of 'getValue' is not checked\nconst str: string = getValue(\"myString\");\n```\n\nThe `any` type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation.\n\nUnlike `unknown`, variables of type `any` allow you to access arbitrary properties, even ones that don’t exist. These properties include functions and TypeScript will not check their existence or type:\n\n``` ts\nlet looselyTyped: any = 4;\n// OK, ifItExists might exist at runtime\nlooselyTyped.ifItExists();\n// OK, toFixed exists (but the compiler doesn't check)\nlooselyTyped.toFixed();\n \nlet strictlyTyped: unknown = 4;\nstrictlyTyped.toFixed();\n```\n\nThe `any` will continue to propagate through your objects:\n\n``` ts\nlet looselyTyped: any = {};\nlet d = looselyTyped.a.b.c.d;\n```\n\nAfter all, remember that all the convenience of `any` comes at the cost of losing type safety. Type safety is one of the main motivations for using TypeScript and you should try to avoid using `any` when not necessary.\n\n## Void\n\n`void` is a little like the opposite of `any`: the absence of having any type at all. You may commonly see this as the return type of functions that do not return a value:\n\n``` ts\nfunction warnUser(): void {\n  console.log(\"This is my warning message\");\n}\n```\n\nDeclaring variables of type `void` is not useful because you can only assign `null` (only if [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is not specified, see next section) or `undefined` to them:\n\n``` ts\nlet unusable: void = undefined;\n// OK if `--strictNullChecks` is not given\nunusable = null;\n```\n\n## Null and Undefined\n\nIn TypeScript, both `undefined` and `null` actually have their types named `undefined` and `null` respectively. Much like `void`, they’re not extremely useful on their own:\n\n``` ts\n// Not much else we can assign to these variables!\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\nBy default `null` and `undefined` are subtypes of all other types. That means you can assign `null` and `undefined` to something like `number`.\n\nHowever, when using the [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) flag, `null` and `undefined` are only assignable to `unknown`, `any` and their respective types (the one exception being that `undefined` is also assignable to `void`). This helps avoid *many* common errors. In cases where you want to pass in either a `string` or `null` or `undefined`, you can use the union type `string | null | undefined`.\n\nUnion types are an advanced topic that we’ll cover in a later chapter.\n\n> As a note: we encourage the use of [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) when possible, but for the purposes of this handbook, we will assume it is turned off.\n\n## Never\n\nThe `never` type represents the type of values that never occur. For instance, `never` is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns. Variables also acquire the type `never` when narrowed by any type guards that can never be true.\n\nThe `never` type is a subtype of, and assignable to, every type; however, *no* type is a subtype of, or assignable to, `never` (except `never` itself). Even `any` isn’t assignable to `never`.\n\nSome examples of functions returning `never`:\n\n``` ts\n// Function returning never must not have a reachable end point\nfunction error(message: string): never {\n  throw new Error(message);\n}\n \n// Inferred return type is never\nfunction fail() {\n  return error(\"Something failed\");\n}\n \n// Function returning never must not have a reachable end point\nfunction infiniteLoop(): never {\n  while (true) {}\n}\n```\n\n## Object\n\n`object` is a type that represents the non-primitive type, i.e. anything that is not `number`, `string`, `boolean`, `bigint`, `symbol`, `null`, or `undefined`.\n\nWith `object` type, APIs like `Object.create` can be better represented. For example:\n\n``` ts\ndeclare function create(o: object | null): void;\n \n// OK\ncreate({ prop: 0 });\ncreate(null);\ncreate(undefined); // with `--strictNullChecks` flag enabled, undefined is not a subtype of null\n \ncreate(42);\ncreate(\"string\");\ncreate(false);\n```\n\nGenerally, you won’t need to use this.\n\n## Type assertions\n\nSometimes you’ll end up in a situation where you’ll know more about a value than TypeScript does. Usually, this will happen when you know the type of some entity could be more specific than its current type.\n\n*Type assertions* are a way to tell the compiler “trust me, I know what I’m doing.” A type assertion is like a type cast in other languages, but it performs no special checking or restructuring of data. It has no runtime impact and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.\n\nType assertions have two forms.\n\nOne is the `as`-syntax:\n\n``` ts\nlet someValue: unknown = \"this is a string\";\n \nlet strLength: number = (someValue as string).length;\n```\n\nThe other version is the “angle-bracket” syntax:\n\n``` ts\nlet someValue: unknown = \"this is a string\";\n \nlet strLength: number = (<string>someValue).length;\n```\n\nThe two samples are equivalent. Using one over the other is mostly a choice of preference; however, when using TypeScript with JSX, only `as`-style assertions are allowed.\n\n## A note about `let`\n\nYou may have noticed that so far, we’ve been using the `let` keyword instead of JavaScript’s `var` keyword which you might be more familiar with. The `let` keyword is actually a newer JavaScript construct that TypeScript makes available. You can read in the Handbook Reference on [Variable Declarations](variable-declarations) more about how `let` and `const` fix a lot of the problems with `var`.\n\n## About `Number`, `String`, `Boolean`, `Symbol` and `Object`\n\nIt can be tempting to think that the types `Number`, `String`, `Boolean`, `Symbol`, or `Object` are the same as the lowercase versions recommended above. These types do not refer to the language primitives however, and almost never should be used as a type.\n\n``` ts\nfunction reverse(s: String): String {\n  return s.split(\"\").reverse().join(\"\");\n}\n \nreverse(\"hello world\");\n```\n\nInstead, use the types `number`, `string`, `boolean`, `object` and `symbol`.\n\n``` ts\nfunction reverse(s: string): string {\n  return s.split(\"\").reverse().join(\"\");\n}\n \nreverse(\"hello world\");\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html)"
- name: charset
  id: tsconfig#charset-config
  summary: In prior versions of TypeScript, this controlled what encoding was used when reading text files from disk
  belongs_to: TSConfig Reference
  description: |-
    ### Charset - `charset`

    In prior versions of TypeScript, this controlled what encoding was used when reading text files from disk. Today, TypeScript assumes UTF-8 encoding, but will correctly detect UTF-16 (BE and LE) or UTF-8 BOMs.

    - Deprecated

    - Default:

      `utf8`
- name: charset
  id: tsconfig/index#charset-config
  summary: In prior versions of TypeScript, this controlled what encoding was used when reading text files from disk
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Charset - `charset`

    In prior versions of TypeScript, this controlled what encoding was used when reading text files from disk. Today, TypeScript assumes UTF-8 encoding, but will correctly detect UTF-16 (BE and LE) or UTF-8 BOMs.

    - Deprecated

    - Default:

      `utf8`
- name: checkJs
  id: tsconfig#checkJs-config
  summary: Works in tandem with allowJs
  belongs_to: TSConfig Reference
  description: |-
    ### Check JS - `checkJs`

    Works in tandem with [`allowJs`](#allowJs). When `checkJs` is enabled then errors are reported in JavaScript files. This is the equivalent of including `// @ts-check` at the top of all JavaScript files which are included in your project.

    For example, this is incorrect JavaScript according to the `parseFloat` type definition which comes with TypeScript:

    ``` js
    // parseFloat only takes a string
    module.exports.pi = parseFloat(3.142);
    ```

    When imported into a TypeScript module:

    ``` ts
    // @filename: constants.js
    module.exports.pi = parseFloat(3.142);
     
    // @filename: index.ts
    import { pi } from "./constants";
    console.log(pi);
    ```

    You will not get any errors. However, if you turn on `checkJs` then you will get error messages from the JavaScript file.

    ``` ts
    // @filename: constants.js
    module.exports.pi = parseFloat(3.142);
     
    // @filename: index.ts
    import { pi } from "./constants";
    console.log(pi);
    ```

    - Related:
      - [`allowJs`](#allowJs)

      - [`emitDeclarationOnly`](#emitDeclarationOnly)

    - Released:

      [2.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html)
- name: checkJs
  id: tsconfig/index#checkJs-config
  summary: Works in tandem with allowJs
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Check JS - `checkJs`

    Works in tandem with [`allowJs`](#allowJs). When `checkJs` is enabled then errors are reported in JavaScript files. This is the equivalent of including `// @ts-check` at the top of all JavaScript files which are included in your project.

    For example, this is incorrect JavaScript according to the `parseFloat` type definition which comes with TypeScript:

    ``` js
    // parseFloat only takes a string
    module.exports.pi = parseFloat(3.142);
    ```

    When imported into a TypeScript module:

    ``` ts
    // @filename: constants.js
    module.exports.pi = parseFloat(3.142);
     
    // @filename: index.ts
    import { pi } from "./constants";
    console.log(pi);
    ```

    You will not get any errors. However, if you turn on `checkJs` then you will get error messages from the JavaScript file.

    ``` ts
    // @filename: constants.js
    module.exports.pi = parseFloat(3.142);
     
    // @filename: index.ts
    import { pi } from "./constants";
    console.log(pi);
    ```

    - Related:
      - [`allowJs`](#allowJs)

      - [`emitDeclarationOnly`](#emitDeclarationOnly)

    - Released:

      [2.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html)
- name: Classes
  id: 2/classes
  summary: TypeScript offers full support for the class keyword introduced in ES2015
  description: "# Classes\n\n> Background Reading:  \n> [Classes (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)\n\nTypeScript offers full support for the `class` keyword introduced in ES2015.\n\nAs with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types.\n\n## Class Members\n\nHere’s the most basic class - an empty one:\n\n``` ts\nclass Point {}\n```\n\nThis class isn’t very useful yet, so let’s start adding some members.\n\n### Fields\n\nA field declaration creates a public writeable property on a class:\n\n``` ts\nclass Point {\n  x: number;\n  y: number;\n}\n \nconst pt = new Point();\npt.x = 0;\npt.y = 0;\n```\n\nAs with other locations, the type annotation is optional, but will be an implicit `any` if not specified.\n\nFields can also have *initializers*; these will run automatically when the class is instantiated:\n\n``` ts\nclass Point {\n  x = 0;\n  y = 0;\n}\n \nconst pt = new Point();\n// Prints 0, 0\nconsole.log(`${pt.x}, ${pt.y}`);\n```\n\nJust like with `const`, `let`, and `var`, the initializer of a class property will be used to infer its type:\n\n``` ts\nconst pt = new Point();\npt.x = \"0\";\n```\n\n#### `--strictPropertyInitialization`\n\nThe [`strictPropertyInitialization`](https://www.typescriptlang.org/tsconfig#strictPropertyInitialization) setting controls whether class fields need to be initialized in the constructor.\n\n``` ts\nclass BadGreeter {\n  name: string;\n}\n```\n\n``` ts\nclass GoodGreeter {\n  name: string;\n \n  constructor() {\n    this.name = \"hello\";\n  }\n}\n```\n\nNote that the field needs to be initialized *in the constructor itself*. TypeScript does not analyze methods you invoke from the constructor to detect initializations, because a derived class might override those methods and fail to initialize the members.\n\nIf you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the *definite assignment assertion operator*, `!`:\n\n``` ts\nclass OKGreeter {\n  // Not initialized, but no error\n  name!: string;\n}\n```\n\n### `readonly`\n\nFields may be prefixed with the `readonly` modifier. This prevents assignments to the field outside of the constructor.\n\n``` ts\nclass Greeter {\n  readonly name: string = \"world\";\n \n  constructor(otherName?: string) {\n    if (otherName !== undefined) {\n      this.name = otherName;\n    }\n  }\n \n  err() {\n    this.name = \"not ok\";\n  }\n}\nconst g = new Greeter();\ng.name = \"also not ok\";\n```\n\n### Constructors\n\n> Background Reading:  \n> [Constructor (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor)  \n\nClass constructors are very similar to functions. You can add parameters with type annotations, default values, and overloads:\n\n``` ts\nclass Point {\n  x: number;\n  y: number;\n \n  // Normal signature with defaults\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n}\n```\n\n``` ts\nclass Point {\n  x: number = 0;\n  y: number = 0;\n \n  // Constructor overloads\n  constructor(x: number, y: number);\n  constructor(xy: string);\n  constructor(x: string | number, y: number = 0) {\n    // Code logic here\n  }\n}\n```\n\nThere are just a few differences between class constructor signatures and function signatures:\n\n- Constructors can’t have type parameters - these belong on the outer class declaration, which we’ll learn about later\n- Constructors can’t have return type annotations - the class instance type is always what’s returned\n\n#### Super Calls\n\nJust as in JavaScript, if you have a base class, you’ll need to call `super();` in your constructor body before using any `this.` members:\n\n``` ts\nclass Base {\n  k = 4;\n}\n \nclass Derived extends Base {\n  constructor() {\n    // Prints a wrong value in ES5; throws exception in ES6\n    console.log(this.k);\n    super();\n  }\n}\n```\n\nForgetting to call `super` is an easy mistake to make in JavaScript, but TypeScript will tell you when it’s necessary.\n\n### Methods\n\n> Background Reading:  \n> [Method definitions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions)  \n\nA function property on a class is called a *method*. Methods can use all the same type annotations as functions and constructors:\n\n``` ts\nclass Point {\n  x = 10;\n  y = 10;\n \n  scale(n: number): void {\n    this.x *= n;\n    this.y *= n;\n  }\n}\n```\n\nOther than the standard type annotations, TypeScript doesn’t add anything else new to methods.\n\nNote that inside a method body, it is still mandatory to access fields and other methods via `this.`. An unqualified name in a method body will always refer to something in the enclosing scope:\n\n``` ts\nlet x: number = 0;\n \nclass C {\n  x: string = \"hello\";\n \n  m() {\n    // This is trying to modify 'x' from line 1, not the class property\n    x = \"world\";\n  }\n}\n```\n\n### Getters / Setters\n\nClasses can also have *accessors*:\n\n``` ts\nclass C {\n  _length = 0;\n  get length() {\n    return this._length;\n  }\n  set length(value) {\n    this._length = value;\n  }\n}\n```\n\n> Note that a field-backed get/set pair with no extra logic is very rarely useful in JavaScript. It’s fine to expose public fields if you don’t need to add additional logic during the get/set operations.\n\nTypeScript has some special inference rules for accessors:\n\n- If `get` exists but no `set`, the property is automatically `readonly`\n- If the type of the setter parameter is not specified, it is inferred from the return type of the getter\n\nSince [TypeScript 4.3](https://devblogs.microsoft.com/typescript/announcing-typescript-4-3/), it is possible to have accessors with different types for getting and setting.\n\n``` ts\nclass Thing {\n  _size = 0;\n \n  get size(): number {\n    return this._size;\n  }\n \n  set size(value: string | number | boolean) {\n    let num = Number(value);\n \n    // Don't allow NaN, Infinity, etc\n \n    if (!Number.isFinite(num)) {\n      this._size = 0;\n      return;\n    }\n \n    this._size = num;\n  }\n}\n```\n\n### Index Signatures\n\nClasses can declare index signatures; these work the same as [Index Signatures for other object types](objects#index-signatures):\n\n``` ts\nclass MyClass {\n  [s: string]: boolean | ((s: string) => boolean);\n \n  check(s: string) {\n    return this[s] as boolean;\n  }\n}\n```\n\nBecause the index signature type needs to also capture the types of methods, it’s not easy to usefully use these types. Generally it’s better to store indexed data in another place instead of on the class instance itself.\n\n## Class Heritage\n\nLike other languages with object-oriented features, classes in JavaScript can inherit from base classes.\n\n### `implements` Clauses\n\nYou can use an `implements` clause to check that a class satisfies a particular `interface`. An error will be issued if a class fails to correctly implement it:\n\n``` ts\ninterface Pingable {\n  ping(): void;\n}\n \nclass Sonar implements Pingable {\n  ping() {\n    console.log(\"ping!\");\n  }\n}\n \nclass Ball implements Pingable {\n  pong() {\n    console.log(\"pong!\");\n  }\n}\n```\n\nClasses may also implement multiple interfaces, e.g. `class C implements A, B {`.\n\n#### Cautions\n\nIt’s important to understand that an `implements` clause is only a check that the class can be treated as the interface type. It doesn’t change the type of the class or its methods *at all*. A common source of error is to assume that an `implements` clause will change the class type - it doesn’t!\n\n``` ts\ninterface Checkable {\n  check(name: string): boolean;\n}\n \nclass NameChecker implements Checkable {\n  check(s) {\n    // Notice no error here\n    return s.toLowerCase() === \"ok\";\n  }\n}\n```\n\nIn this example, we perhaps expected that `s`’s type would be influenced by the `name: string` parameter of `check`. It is not - `implements` clauses don’t change how the class body is checked or its type inferred.\n\nSimilarly, implementing an interface with an optional property doesn’t create that property:\n\n``` ts\ninterface A {\n  x: number;\n  y?: number;\n}\nclass C implements A {\n  x = 0;\n}\nconst c = new C();\nc.y = 10;\n```\n\n### `extends` Clauses\n\n> Background Reading:  \n> [extends keyword (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends)  \n\nClasses may `extend` from a base class. A derived class has all the properties and methods of its base class, and can also define additional members.\n\n``` ts\nclass Animal {\n  move() {\n    console.log(\"Moving along!\");\n  }\n}\n \nclass Dog extends Animal {\n  woof(times: number) {\n    for (let i = 0; i < times; i++) {\n      console.log(\"woof!\");\n    }\n  }\n}\n \nconst d = new Dog();\n// Base class method\nd.move();\n// Derived class method\nd.woof(3);\n```\n\n#### Overriding Methods\n\n> Background Reading:  \n> [super keyword (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super)  \n\nA derived class can also override a base class field or property. You can use the `super.` syntax to access base class methods. Note that because JavaScript classes are a simple lookup object, there is no notion of a “super field”.\n\nTypeScript enforces that a derived class is always a subtype of its base class.\n\nFor example, here’s a legal way to override a method:\n\n``` ts\nclass Base {\n  greet() {\n    console.log(\"Hello, world!\");\n  }\n}\n \nclass Derived extends Base {\n  greet(name?: string) {\n    if (name === undefined) {\n      super.greet();\n    } else {\n      console.log(`Hello, ${name.toUpperCase()}`);\n    }\n  }\n}\n \nconst d = new Derived();\nd.greet();\nd.greet(\"reader\");\n```\n\nIt’s important that a derived class follow its base class contract. Remember that it’s very common (and always legal!) to refer to a derived class instance through a base class reference:\n\n``` ts\n// Alias the derived instance through a base class reference\nconst b: Base = d;\n// No problem\nb.greet();\n```\n\nWhat if `Derived` didn’t follow `Base`’s contract?\n\n``` ts\nclass Base {\n  greet() {\n    console.log(\"Hello, world!\");\n  }\n}\n \nclass Derived extends Base {\n  // Make this parameter required\n  greet(name: string) {\n    console.log(`Hello, ${name.toUpperCase()}`);\n  }\n}\n```\n\nIf we compiled this code despite the error, this sample would then crash:\n\n``` ts\nconst b: Base = new Derived();\n// Crashes because \"name\" will be undefined\nb.greet();\n```\n\n#### Type-only Field Declarations\n\nWhen `target >= ES2022` or [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields) is `true`, class fields are initialized after the parent class constructor completes, overwriting any value set by the parent class. This can be a problem when you only want to re-declare a more accurate type for an inherited field. To handle these cases, you can write `declare` to indicate to TypeScript that there should be no runtime effect for this field declaration.\n\n``` ts\ninterface Animal {\n  dateOfBirth: any;\n}\n \ninterface Dog extends Animal {\n  breed: any;\n}\n \nclass AnimalHouse {\n  resident: Animal;\n  constructor(animal: Animal) {\n    this.resident = animal;\n  }\n}\n \nclass DogHouse extends AnimalHouse {\n  // Does not emit JavaScript code,\n  // only ensures the types are correct\n  declare resident: Dog;\n  constructor(dog: Dog) {\n    super(dog);\n  }\n}\n```\n\n#### Initialization Order\n\nThe order that JavaScript classes initialize can be surprising in some cases. Let’s consider this code:\n\n``` ts\nclass Base {\n  name = \"base\";\n  constructor() {\n    console.log(\"My name is \" + this.name);\n  }\n}\n \nclass Derived extends Base {\n  name = \"derived\";\n}\n \n// Prints \"base\", not \"derived\"\nconst d = new Derived();\n```\n\nWhat happened here?\n\nThe order of class initialization, as defined by JavaScript, is:\n\n- The base class fields are initialized\n- The base class constructor runs\n- The derived class fields are initialized\n- The derived class constructor runs\n\nThis means that the base class constructor saw its own value for `name` during its own constructor, because the derived class field initializations hadn’t run yet.\n\n#### Inheriting Built-in Types\n\n> Note: If you don’t plan to inherit from built-in types like `Array`, `Error`, `Map`, etc. or your compilation target is explicitly set to `ES6`/`ES2015` or above, you may skip this section\n\nIn ES2015, constructors which return an object implicitly substitute the value of `this` for any callers of `super(...)`. It is necessary for generated constructor code to capture any potential return value of `super(...)` and replace it with `this`.\n\nAs a result, subclassing `Error`, `Array`, and others may no longer work as expected. This is due to the fact that constructor functions for `Error`, `Array`, and the like use ECMAScript 6’s `new.target` to adjust the prototype chain; however, there is no way to ensure a value for `new.target` when invoking a constructor in ECMAScript 5. Other downlevel compilers generally have the same limitation by default.\n\nFor a subclass like the following:\n\n``` ts\nclass MsgError extends Error {\n  constructor(m: string) {\n    super(m);\n  }\n  sayHello() {\n    return \"hello \" + this.message;\n  }\n}\n```\n\nyou may find that:\n\n- methods may be `undefined` on objects returned by constructing these subclasses, so calling `sayHello` will result in an error.\n- `instanceof` will be broken between instances of the subclass and their instances, so `(new MsgError()) instanceof MsgError` will return `false`.\n\nAs a recommendation, you can manually adjust the prototype immediately after any `super(...)` calls.\n\n``` ts\nclass MsgError extends Error {\n  constructor(m: string) {\n    super(m);\n \n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MsgError.prototype);\n  }\n \n  sayHello() {\n    return \"hello \" + this.message;\n  }\n}\n```\n\nHowever, any subclass of `MsgError` will have to manually set the prototype as well. For runtimes that don’t support [`Object.setPrototypeOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf), you may instead be able to use [`__proto__`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto).\n\nUnfortunately, [these workarounds will not work on Internet Explorer 10 and prior](https://msdn.microsoft.com/en-us/library/s4esdbwz(v=vs.94).aspx). One can manually copy methods from the prototype onto the instance itself (i.e. `MsgError.prototype` onto `this`), but the prototype chain itself cannot be fixed.\n\n## Member Visibility\n\nYou can use TypeScript to control whether certain methods or properties are visible to code outside the class.\n\n### `public`\n\nThe default visibility of class members is `public`. A `public` member can be accessed anywhere:\n\n``` ts\nclass Greeter {\n  public greet() {\n    console.log(\"hi!\");\n  }\n}\nconst g = new Greeter();\ng.greet();\n```\n\nBecause `public` is already the default visibility modifier, you don’t ever *need* to write it on a class member, but might choose to do so for style/readability reasons.\n\n### `protected`\n\n`protected` members are only visible to subclasses of the class they’re declared in.\n\n``` ts\nclass Greeter {\n  public greet() {\n    console.log(\"Hello, \" + this.getName());\n  }\n  protected getName() {\n    return \"hi\";\n  }\n}\n \nclass SpecialGreeter extends Greeter {\n  public howdy() {\n    // OK to access protected member here\n    console.log(\"Howdy, \" + this.getName());\n  }\n}\nconst g = new SpecialGreeter();\ng.greet(); // OK\ng.getName();\n```\n\n#### Exposure of `protected` members\n\nDerived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. This includes making `protected` members `public`:\n\n``` ts\nclass Base {\n  protected m = 10;\n}\nclass Derived extends Base {\n  // No modifier, so default is 'public'\n  m = 15;\n}\nconst d = new Derived();\nconsole.log(d.m); // OK\n```\n\nNote that `Derived` was already able to freely read and write `m`, so this doesn’t meaningfully alter the “security” of this situation. The main thing to note here is that in the derived class, we need to be careful to repeat the `protected` modifier if this exposure isn’t intentional.\n\n#### Cross-hierarchy `protected` access\n\nDifferent OOP languages disagree about whether it’s legal to access a `protected` member through a base class reference:\n\n``` ts\nclass Base {\n  protected x: number = 1;\n}\nclass Derived1 extends Base {\n  protected x: number = 5;\n}\nclass Derived2 extends Base {\n  f1(other: Derived2) {\n    other.x = 10;\n  }\n  f2(other: Derived1) {\n    other.x = 10;\n  }\n}\n```\n\nJava, for example, considers this to be legal. On the other hand, C# and C++ chose that this code should be illegal.\n\nTypeScript sides with C# and C++ here, because accessing `x` in `Derived2` should only be legal from `Derived2`’s subclasses, and `Derived1` isn’t one of them. Moreover, if accessing `x` through a `Derived1` reference is illegal (which it certainly should be!), then accessing it through a base class reference should never improve the situation.\n\nSee also [Why Can’t I Access A Protected Member From A Derived Class?](https://blogs.msdn.microsoft.com/ericlippert/2005/11/09/why-cant-i-access-a-protected-member-from-a-derived-class/) which explains more of C#‘s reasoning.\n\n### `private`\n\n`private` is like `protected`, but doesn’t allow access to the member even from subclasses:\n\n``` ts\nclass Base {\n  private x = 0;\n}\nconst b = new Base();\n// Can't access from outside the class\nconsole.log(b.x);\n```\n\n``` ts\nclass Derived extends Base {\n  showX() {\n    // Can't access in subclasses\n    console.log(this.x);\n  }\n}\n```\n\nBecause `private` members aren’t visible to derived classes, a derived class can’t increase their visibility:\n\n``` ts\nclass Base {\n  private x = 0;\n}\nclass Derived extends Base {\n  x = 1;\n}\n```\n\n#### Cross-instance `private` access\n\nDifferent OOP languages disagree about whether different instances of the same class may access each others’ `private` members. While languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not.\n\nTypeScript does allow cross-instance `private` access:\n\n``` ts\nclass A {\n  private x = 10;\n \n  public sameAs(other: A) {\n    // No error\n    return other.x === this.x;\n  }\n}\n```\n\n#### Caveats\n\nLike other aspects of TypeScript’s type system, `private` and `protected` [are only enforced during type checking](https://www.typescriptlang.org/play?removeComments=true&target=99&ts=4.3.4#code/PTAEGMBsEMGddAEQPYHNQBMCmVoCcsEAHPASwDdoAXLUAM1K0gwQFdZSA7dAKWkoDK4MkSoByBAGJQJLAwAeAWABQIUH0HDSoiTLKUaoUggAW+DHorUsAOlABJcQlhUy4KpACeoLJzrI8cCwMGxU1ABVPIiwhESpMZEJQTmR4lxFQaQxWMm4IZABbIlIYKlJkTlDlXHgkNFAAbxVQTIAjfABrAEEC5FZOeIBeUAAGAG5mmSw8WAroSFIqb2GAIjMiIk8VieVJ8Ar01ncAgAoASkaAXxVr3dUwGoQAYWpMHBgCYn1rekZmNg4eUi0Vi2icoBWJCsNBWoA6WE8AHcAiEwmBgTEtDovtDaMZQLM6PEoQZbA5wSk0q5SO4vD4-AEghZoJwLGYEIRwNBoqAzFRwCZCFUIlFMXECdSiAhId8YZgclx0PsiiVqOVOAAaUAFLAsxWgKiC35MFigfC0FKgSAVVDTSyk+W5dB4fplHVVR6gF7xJrKFotEk-HXIRE9PoDUDDcaTAPTWaceaLZYQlmoPBbHYx-KcQ7HPDnK43FQqfY5+IMDDISPJLCIuqoc47UsuUCofAME3Vzi1r3URvF5QV5A2STtPDdXqunZDgDaYlHnTDrrEAF0dm28B3mDZg6HJwN1+2-hg57ulwNV2NQGoZbjYfNrYiENBwEFaojFiZQK08C-4fFKTVCozWfTgfFgLkeT5AUqiAA).\n\nThis means that JavaScript runtime constructs like `in` or simple property lookup can still access a `private` or `protected` member:\n\n``` ts\nclass MySafe {\n  private secretKey = 12345;\n}\n```\n\n``` js\n// In a JavaScript file...\nconst s = new MySafe();\n// Will print 12345\nconsole.log(s.secretKey);\n```\n\n`private` also allows access using bracket notation during type checking. This makes `private`-declared fields potentially easier to access for things like unit tests, with the drawback that these fields are *soft private* and don’t strictly enforce privacy.\n\n``` ts\nclass MySafe {\n  private secretKey = 12345;\n}\n \nconst s = new MySafe();\n \n// Not allowed during type checking\nconsole.log(s.secretKey);\n \n// OK\nconsole.log(s[\"secretKey\"]);\n```\n\nUnlike TypeScripts’s `private`, JavaScript’s [private fields](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields) (`#`) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them *hard private*.\n\n``` ts\nclass Dog {\n  #barkAmount = 0;\n  personality = \"happy\";\n \n  constructor() {}\n}\n```\n\n``` ts\n\"use strict\";\nclass Dog {\n    #barkAmount = 0;\n    personality = \"happy\";\n    constructor() { }\n}\n \n```\n\nWhen compiling to ES2021 or less, TypeScript will use WeakMaps in place of `#`.\n\n``` ts\n\"use strict\";\nvar _Dog_barkAmount;\nclass Dog {\n    constructor() {\n        _Dog_barkAmount.set(this, 0);\n        this.personality = \"happy\";\n    }\n}\n_Dog_barkAmount = new WeakMap();\n \n```\n\nIf you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance.\n\n## Static Members\n\n> Background Reading:  \n> [Static Members (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static)  \n\nClasses may have `static` members. These members aren’t associated with a particular instance of the class. They can be accessed through the class constructor object itself:\n\n``` ts\nclass MyClass {\n  static x = 0;\n  static printX() {\n    console.log(MyClass.x);\n  }\n}\nconsole.log(MyClass.x);\nMyClass.printX();\n```\n\nStatic members can also use the same `public`, `protected`, and `private` visibility modifiers:\n\n``` ts\nclass MyClass {\n  private static x = 0;\n}\nconsole.log(MyClass.x);\n```\n\nStatic members are also inherited:\n\n``` ts\nclass Base {\n  static getGreeting() {\n    return \"Hello world\";\n  }\n}\nclass Derived extends Base {\n  myGreeting = Derived.getGreeting();\n}\n```\n\n### Special Static Names\n\nIt’s generally not safe/possible to overwrite properties from the `Function` prototype. Because classes are themselves functions that can be invoked with `new`, certain `static` names can’t be used. Function properties like `name`, `length`, and `call` aren’t valid to define as `static` members:\n\n``` ts\nclass S {\n  static name = \"S!\";\n}\n```\n\n### Why No Static Classes?\n\nTypeScript (and JavaScript) don’t have a construct called `static class` the same way as, for example, C# does.\n\nThose constructs *only* exist because those languages force all data and functions to be inside a class; because that restriction doesn’t exist in TypeScript, there’s no need for them. A class with only a single instance is typically just represented as a normal *object* in JavaScript/TypeScript.\n\nFor example, we don’t need a “static class” syntax in TypeScript because a regular object (or even top-level function) will do the job just as well:\n\n``` ts\n// Unnecessary \"static\" class\nclass MyStaticClass {\n  static doSomething() {}\n}\n \n// Preferred (alternative 1)\nfunction doSomething() {}\n \n// Preferred (alternative 2)\nconst MyHelperObject = {\n  dosomething() {},\n};\n```\n\n## `static` Blocks in Classes\n\nStatic blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals.\n\n``` ts\nclass Foo {\n    static #count = 0;\n \n    get count() {\n        return Foo.#count;\n    }\n \n    static {\n        try {\n            const lastInstances = loadLastInstances();\n            Foo.#count += lastInstances.length;\n        }\n        catch {}\n    }\n}\n```\n\n## Generic Classes\n\nClasses, much like interfaces, can be generic. When a generic class is instantiated with `new`, its type parameters are inferred the same way as in a function call:\n\n``` ts\nclass Box<Type> {\n  contents: Type;\n  constructor(value: Type) {\n    this.contents = value;\n  }\n}\n \nconst b = new Box(\"hello!\");\n```\n\nClasses can use generic constraints and defaults the same way as interfaces.\n\n### Type Parameters in Static Members\n\nThis code isn’t legal, and it may not be obvious why:\n\n``` ts\nclass Box<Type> {\n  static defaultValue: Type;\n}\n```\n\nRemember that types are always fully erased! At runtime, there’s only *one* `Box.defaultValue` property slot. This means that setting `Box<string>.defaultValue` (if that were possible) would *also* change `Box<number>.defaultValue` - not good. The `static` members of a generic class can never refer to the class’s type parameters.\n\n## `this` at Runtime in Classes\n\n> Background Reading:  \n> [this keyword (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)  \n\nIt’s important to remember that TypeScript doesn’t change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors.\n\nJavaScript’s handling of `this` is indeed unusual:\n\n``` ts\nclass MyClass {\n  name = \"MyClass\";\n  getName() {\n    return this.name;\n  }\n}\nconst c = new MyClass();\nconst obj = {\n  name: \"obj\",\n  getName: c.getName,\n};\n \n// Prints \"obj\", not \"MyClass\"\nconsole.log(obj.getName());\n```\n\nLong story short, by default, the value of `this` inside a function depends on *how the function was called*. In this example, because the function was called through the `obj` reference, its value of `this` was `obj` rather than the class instance.\n\nThis is rarely what you want to happen! TypeScript provides some ways to mitigate or prevent this kind of error.\n\n### Arrow Functions\n\n> Background Reading:  \n> [Arrow functions (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)  \n\nIf you have a function that will often be called in a way that loses its `this` context, it can make sense to use an arrow function property instead of a method definition:\n\n``` ts\nclass MyClass {\n  name = \"MyClass\";\n  getName = () => {\n    return this.name;\n  };\n}\nconst c = new MyClass();\nconst g = c.getName;\n// Prints \"MyClass\" instead of crashing\nconsole.log(g());\n```\n\nThis has some trade-offs:\n\n- The `this` value is guaranteed to be correct at runtime, even for code not checked with TypeScript\n- This will use more memory, because each class instance will have its own copy of each function defined this way\n- You can’t use `super.getName` in a derived class, because there’s no entry in the prototype chain to fetch the base class method from\n\n### `this` parameters\n\nIn a method or function definition, an initial parameter named `this` has special meaning in TypeScript. These parameters are erased during compilation:\n\n``` ts\n// TypeScript input with 'this' parameter\nfunction fn(this: SomeType, x: number) {\n  /* ... */\n}\n```\n\n``` js\n// JavaScript output\nfunction fn(x) {\n  /* ... */\n}\n```\n\nTypeScript checks that calling a function with a `this` parameter is done so with a correct context. Instead of using an arrow function, we can add a `this` parameter to method definitions to statically enforce that the method is called correctly:\n\n``` ts\nclass MyClass {\n  name = \"MyClass\";\n  getName(this: MyClass) {\n    return this.name;\n  }\n}\nconst c = new MyClass();\n// OK\nc.getName();\n \n// Error, would crash\nconst g = c.getName;\nconsole.log(g());\n```\n\nThis method makes the opposite trade-offs of the arrow function approach:\n\n- JavaScript callers might still use the class method incorrectly without realizing it\n- Only one function per class definition gets allocated, rather than one per class instance\n- Base method definitions can still be called via `super`.\n\n## `this` Types\n\nIn classes, a special type called `this` refers *dynamically* to the type of the current class. Let’s see how this is useful:\n\n``` ts\nclass Box {\n  contents: string = \"\";\n  set(value: string) {\n    this.contents = value;\n    return this;\n  }\n}\n```\n\nHere, TypeScript inferred the return type of `set` to be `this`, rather than `Box`. Now let’s make a subclass of `Box`:\n\n``` ts\nclass ClearableBox extends Box {\n  clear() {\n    this.contents = \"\";\n  }\n}\n \nconst a = new ClearableBox();\nconst b = a.set(\"hello\");\n```\n\nYou can also use `this` in a parameter type annotation:\n\n``` ts\nclass Box {\n  content: string = \"\";\n  sameAs(other: this) {\n    return other.content === this.content;\n  }\n}\n```\n\nThis is different from writing `other: Box` — if you have a derived class, its `sameAs` method will now only accept other instances of that same derived class:\n\n``` ts\nclass Box {\n  content: string = \"\";\n  sameAs(other: this) {\n    return other.content === this.content;\n  }\n}\n \nclass DerivedBox extends Box {\n  otherContent: string = \"?\";\n}\n \nconst base = new Box();\nconst derived = new DerivedBox();\nderived.sameAs(base);\n```\n\n### `this`-based type guards\n\nYou can use `this is Type` in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. `if` statements) the type of the target object would be narrowed to the specified `Type`.\n\n``` ts\nclass FileSystemObject {\n  isFile(): this is FileRep {\n    return this instanceof FileRep;\n  }\n  isDirectory(): this is Directory {\n    return this instanceof Directory;\n  }\n  isNetworked(): this is Networked & this {\n    return this.networked;\n  }\n  constructor(public path: string, private networked: boolean) {}\n}\n \nclass FileRep extends FileSystemObject {\n  constructor(path: string, public content: string) {\n    super(path, false);\n  }\n}\n \nclass Directory extends FileSystemObject {\n  children: FileSystemObject[];\n}\n \ninterface Networked {\n  host: string;\n}\n \nconst fso: FileSystemObject = new FileRep(\"foo/bar.txt\", \"foo\");\n \nif (fso.isFile()) {\n  fso.content;\n} else if (fso.isDirectory()) {\n  fso.children;\n} else if (fso.isNetworked()) {\n  fso.host;\n}\n```\n\nA common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an `undefined` from the value held inside box when `hasValue` has been verified to be true:\n\n``` ts\nclass Box<T> {\n  value?: T;\n \n  hasValue(): this is { value: T } {\n    return this.value !== undefined;\n  }\n}\n \nconst box = new Box<string>();\nbox.value = \"Gameboy\";\n \nbox.value;\n \nif (box.hasValue()) {\n  box.value;\n}\n```\n\n## Parameter Properties\n\nTypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called *parameter properties* and are created by prefixing a constructor argument with one of the visibility modifiers `public`, `private`, `protected`, or `readonly`. The resulting field gets those modifier(s):\n\n``` ts\nclass Params {\n  constructor(\n    public readonly x: number,\n    protected y: number,\n    private z: number\n  ) {\n    // No body necessary\n  }\n}\nconst a = new Params(1, 2, 3);\nconsole.log(a.x);\nconsole.log(a.z);\n```\n\n## Class Expressions\n\n> Background Reading:  \n> [Class expressions (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class)  \n\nClass expressions are very similar to class declarations. The only real difference is that class expressions don’t need a name, though we can refer to them via whatever identifier they ended up bound to:\n\n``` ts\nconst someClass = class<Type> {\n  content: Type;\n  constructor(value: Type) {\n    this.content = value;\n  }\n};\n \nconst m = new someClass(\"Hello, world\");\n```\n\n## Constructor Signatures\n\nJavaScript classes are instantiated with the `new` operator. Given the type of a class itself, the [InstanceType](../utility-types#instancetypetype) utility type models this operation.\n\n``` ts\nclass Point {\n  createdAt: number;\n  x: number;\n  y: number\n  constructor(x: number, y: number) {\n    this.createdAt = Date.now()\n    this.x = x;\n    this.y = y;\n  }\n}\ntype PointInstance = InstanceType<typeof Point>\n \nfunction moveRight(point: PointInstance) {\n  point.x += 5;\n}\n \nconst point = new Point(3, 4);\nmoveRight(point);\npoint.x; // => 8\n```\n\n## `abstract` Classes and Members\n\nClasses, methods, and fields in TypeScript may be *abstract*.\n\nAn *abstract method* or *abstract field* is one that hasn’t had an implementation provided. These members must exist inside an *abstract class*, which cannot be directly instantiated.\n\nThe role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesn’t have any abstract members, it is said to be *concrete*.\n\nLet’s look at an example:\n\n``` ts\nabstract class Base {\n  abstract getName(): string;\n \n  printName() {\n    console.log(\"Hello, \" + this.getName());\n  }\n}\n \nconst b = new Base();\n```\n\nWe can’t instantiate `Base` with `new` because it’s abstract. Instead, we need to make a derived class and implement the abstract members:\n\n``` ts\nclass Derived extends Base {\n  getName() {\n    return \"world\";\n  }\n}\n \nconst d = new Derived();\nd.printName();\n```\n\nNotice that if we forget to implement the base class’s abstract members, we’ll get an error:\n\n``` ts\nclass Derived extends Base {\n  // forgot to do anything\n}\n```\n\n### Abstract Construct Signatures\n\nSometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class.\n\nFor example, you might want to write this code:\n\n``` ts\nfunction greet(ctor: typeof Base) {\n  const instance = new ctor();\n  instance.printName();\n}\n```\n\nTypeScript is correctly telling you that you’re trying to instantiate an abstract class. After all, given the definition of `greet`, it’s perfectly legal to write this code, which would end up constructing an abstract class:\n\n``` ts\n// Bad!\ngreet(Base);\n```\n\nInstead, you want to write a function that accepts something with a construct signature:\n\n``` ts\nfunction greet(ctor: new () => Base) {\n  const instance = new ctor();\n  instance.printName();\n}\ngreet(Derived);\ngreet(Base);\n```\n\nNow TypeScript correctly tells you about which class constructor functions can be invoked - `Derived` can because it’s concrete, but `Base` cannot.\n\n## Relationships Between Classes\n\nIn most cases, classes in TypeScript are compared structurally, the same as other types.\n\nFor example, these two classes can be used in place of each other because they’re identical:\n\n``` ts\nclass Point1 {\n  x = 0;\n  y = 0;\n}\n \nclass Point2 {\n  x = 0;\n  y = 0;\n}\n \n// OK\nconst p: Point1 = new Point2();\n```\n\nSimilarly, subtype relationships between classes exist even if there’s no explicit inheritance:\n\n``` ts\nclass Person {\n  name: string;\n  age: number;\n}\n \nclass Employee {\n  name: string;\n  age: number;\n  salary: number;\n}\n \n// OK\nconst p: Person = new Employee();\n```\n\nThis sounds straightforward, but there are a few cases that seem stranger than others.\n\nEmpty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (don’t!), anything can be used in place of it:\n\n``` ts\nclass Empty {}\n \nfunction fn(x: Empty) {\n  // can't do anything with 'x', so I won't\n}\n \n// All OK!\nfn(window);\nfn({});\nfn(fn);\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/classes.html](https://www.typescriptlang.org/docs/handbook/2/classes.html)"
- name: Classes
  id: classes
  summary: Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes
  description: "# Classes\n\nThis handbook page has been replaced, [go to the new page](2/classes)\n\nTraditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers can build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.\n\n## Classes\n\nLet’s take a look at a simple class-based example:\n\n``` ts\nclass Greeter {\n  greeting: string;\n \n  constructor(message: string) {\n    this.greeting = message;\n  }\n \n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n \nlet greeter = new Greeter(\"world\");\n```\n\nThe syntax should look familiar if you’ve used C# or Java before. We declare a new class `Greeter`. This class has three members: a property called `greeting`, a constructor, and a method `greet`.\n\nYou’ll notice that in the class when we refer to one of the members of the class we prepend `this.`. This denotes that it’s a member access.\n\nIn the last line we construct an instance of the `Greeter` class using `new`. This calls into the constructor we defined earlier, creating a new object with the `Greeter` shape, and running the constructor to initialize it.\n\n## Inheritance\n\nIn TypeScript, we can use common object-oriented patterns. One of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.\n\nLet’s take a look at an example:\n\n``` ts\nclass Animal {\n  move(distanceInMeters: number = 0) {\n    console.log(`Animal moved ${distanceInMeters}m.`);\n  }\n}\n \nclass Dog extends Animal {\n  bark() {\n    console.log(\"Woof! Woof!\");\n  }\n}\n \nconst dog = new Dog();\ndog.bark();\ndog.move(10);\ndog.bark();\n```\n\nThis example shows the most basic inheritance feature: classes inherit properties and methods from base classes. Here, `Dog` is a *derived* class that derives from the `Animal` *base* class using the `extends` keyword. Derived classes are often called *subclasses*, and base classes are often called *superclasses*.\n\nBecause `Dog` extends the functionality from `Animal`, we were able to create an instance of `Dog` that could both `bark()` and `move()`.\n\nLet’s now look at a more complex example.\n\n``` ts\nclass Animal {\n  name: string;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n  move(distanceInMeters: number = 0) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\n \nclass Snake extends Animal {\n  constructor(name: string) {\n    super(name);\n  }\n  move(distanceInMeters = 5) {\n    console.log(\"Slithering...\");\n    super.move(distanceInMeters);\n  }\n}\n \nclass Horse extends Animal {\n  constructor(name: string) {\n    super(name);\n  }\n  move(distanceInMeters = 45) {\n    console.log(\"Galloping...\");\n    super.move(distanceInMeters);\n  }\n}\n \nlet sam = new Snake(\"Sammy the Python\");\nlet tom: Animal = new Horse(\"Tommy the Palomino\");\n \nsam.move();\ntom.move(34);\n```\n\nThis example covers a few other features we didn’t previously mention. Again, we see the `extends` keywords used to create two new subclasses of `Animal`: `Horse` and `Snake`.\n\nOne difference from the prior example is that each derived class that contains a constructor function *must* call `super()` which will execute the constructor of the base class. What’s more, before we *ever* access a property on `this` in a constructor body, we *have* to call `super()`. This is an important rule that TypeScript will enforce.\n\nThe example also shows how to override methods in the base class with methods that are specialized for the subclass. Here both `Snake` and `Horse` create a `move` method that overrides the `move` from `Animal`, giving it functionality specific to each class. Note that even though `tom` is declared as an `Animal`, since its value is a `Horse`, calling `tom.move(34)` will call the overriding method in `Horse`:\n\n``` typescript\nSlithering...\nSammy the Python moved 5m.\nGalloping...\nTommy the Palomino moved 34m.\n```\n\n## Public, private, and protected modifiers\n\n### Public by default\n\nIn our examples, we’ve been able to freely access the members that we declared throughout our programs. If you’re familiar with classes in other languages, you may have noticed in the above examples we haven’t had to use the word `public` to accomplish this; for instance, C# requires that each member be explicitly labeled `public` to be visible. In TypeScript, each member is `public` by default.\n\nYou may still mark a member `public` explicitly. We could have written the `Animal` class from the previous section in the following way:\n\n``` ts\nclass Animal {\n  public name: string;\n \n  public constructor(theName: string) {\n    this.name = theName;\n  }\n \n  public move(distanceInMeters: number) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\n```\n\n### ECMAScript Private Fields\n\nWith TypeScript 3.8, TypeScript supports the new JavaScript syntax for private fields:\n\n``` ts\nclass Animal {\n  #name: string;\n  constructor(theName: string) {\n    this.#name = theName;\n  }\n}\n \nnew Animal(\"Cat\").#name;\n```\n\nThis syntax is built into the JavaScript runtime and can have better guarantees about the isolation of each private field. Right now, the best documentation for these private fields is in the TypeScript 3.8 [release notes](https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#ecmascript-private-fields).\n\n### Understanding TypeScript’s `private`\n\nTypeScript also has its own way to declare a member as being marked `private`, it cannot be accessed from outside of its containing class. For example:\n\n``` ts\nclass Animal {\n  private name: string;\n \n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\n \nnew Animal(\"Cat\").name;\n```\n\nTypeScript is a structural type system. When we compare two different types, regardless of where they came from, if the types of all members are compatible, then we say the types themselves are compatible.\n\nHowever, when comparing types that have `private` and `protected` members, we treat these types differently. For two types to be considered compatible, if one of them has a `private` member, then the other must have a `private` member that originated in the same declaration. The same applies to `protected` members.\n\nLet’s look at an example to better see how this plays out in practice:\n\n``` ts\nclass Animal {\n  private name: string;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\n \nclass Rhino extends Animal {\n  constructor() {\n    super(\"Rhino\");\n  }\n}\n \nclass Employee {\n  private name: string;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\n \nlet animal = new Animal(\"Goat\");\nlet rhino = new Rhino();\nlet employee = new Employee(\"Bob\");\n \nanimal = rhino;\nanimal = employee;\n```\n\nIn this example, we have an `Animal` and a `Rhino`, with `Rhino` being a subclass of `Animal`. We also have a new class `Employee` that looks identical to `Animal` in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because `Animal` and `Rhino` share the `private` side of their shape from the same declaration of `private name: string` in `Animal`, they are compatible. However, this is not the case for `Employee`. When we try to assign from an `Employee` to `Animal` we get an error that these types are not compatible. Even though `Employee` also has a `private` member called `name`, it’s not the one we declared in `Animal`.\n\n### Understanding `protected`\n\nThe `protected` modifier acts much like the `private` modifier with the exception that members declared `protected` can also be accessed within deriving classes. For example,\n\n``` ts\nclass Person {\n  protected name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n \nclass Employee extends Person {\n  private department: string;\n \n  constructor(name: string, department: string) {\n    super(name);\n    this.department = department;\n  }\n \n  public getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n  }\n}\n \nlet howard = new Employee(\"Howard\", \"Sales\");\nconsole.log(howard.getElevatorPitch());\nconsole.log(howard.name);\n```\n\nNotice that while we can’t use `name` from outside of `Person`, we can still use it from within an instance method of `Employee` because `Employee` derives from `Person`.\n\nA constructor may also be marked `protected`. This means that the class cannot be instantiated outside of its containing class, but can be extended. For example,\n\n``` ts\nclass Person {\n  protected name: string;\n  protected constructor(theName: string) {\n    this.name = theName;\n  }\n}\n \n// Employee can extend Person\nclass Employee extends Person {\n  private department: string;\n \n  constructor(name: string, department: string) {\n    super(name);\n    this.department = department;\n  }\n \n  public getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n  }\n}\n \nlet howard = new Employee(\"Howard\", \"Sales\");\nlet john = new Person(\"John\");\n```\n\n## Readonly modifier\n\nYou can make properties readonly by using the `readonly` keyword. Readonly properties must be initialized at their declaration or in the constructor.\n\n``` ts\nclass Octopus {\n  readonly name: string;\n  readonly numberOfLegs: number = 8;\n \n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\n \nlet dad = new Octopus(\"Man with the 8 strong legs\");\ndad.name = \"Man with the 3-piece suit\";\n```\n\n## Parameter properties\n\nIn our last example, we had to declare a readonly member `name` and a constructor parameter `theName` in the `Octopus` class. This is needed in order to have the value of `theName` accessible after the `Octopus` constructor is executed. *Parameter properties* let you create and initialize a member in one place. Here’s a further revision of the previous `Octopus` class using a parameter property:\n\n``` ts\nclass Octopus {\n  readonly numberOfLegs: number = 8;\n  constructor(readonly name: string) {}\n}\n \nlet dad = new Octopus(\"Man with the 8 strong legs\");\ndad.name;\n```\n\nNotice how we dropped `theName` altogether and just use the shortened `readonly name: string` parameter on the constructor to create and initialize the `name` member. We’ve consolidated the declarations and assignment into one location.\n\nParameter properties are declared by prefixing a constructor parameter with an accessibility modifier or `readonly`, or both. Using `private` for a parameter property declares and initializes a private member; likewise, the same is done for `public`, `protected`, and `readonly`.\n\n## Accessors\n\nTypeScript supports getters/setters as a way of intercepting accesses to a member of an object. This gives you a way of having finer-grained control over how a member is accessed on each object.\n\nLet’s convert a simple class to use `get` and `set`. First, let’s start with an example without getters and setters.\n\n``` ts\nclass Employee {\n  fullName: string;\n}\n \nlet employee = new Employee();\nemployee.fullName = \"Bob Smith\";\n \nif (employee.fullName) {\n  console.log(employee.fullName);\n}\n```\n\nWhile allowing people to randomly set `fullName` directly is pretty handy, we may also want enforce some constraints when `fullName` is set.\n\nIn this version, we add a setter that checks the length of the `newName` to make sure it’s compatible with the max-length of our backing database field. If it isn’t we throw an error notifying client code that something went wrong.\n\nTo preserve existing functionality, we also add a simple getter that retrieves `fullName` unmodified.\n\n``` ts\nconst fullNameMaxLength = 10;\n \nclass Employee {\n  private _fullName: string = \"\";\n \n  get fullName(): string {\n    return this._fullName;\n  }\n \n  set fullName(newName: string) {\n    if (newName && newName.length > fullNameMaxLength) {\n      throw new Error(\"fullName has a max length of \" + fullNameMaxLength);\n    }\n \n    this._fullName = newName;\n  }\n}\n \nlet employee = new Employee();\nemployee.fullName = \"Bob Smith\";\n \nif (employee.fullName) {\n  console.log(employee.fullName);\n}\n```\n\nTo prove to ourselves that our accessor is now checking the length of values, we can attempt to assign a name longer than 10 characters and verify that we get an error.\n\nA couple of things to note about accessors:\n\nFirst, accessors require you to set the compiler to output ECMAScript 5 or higher. Downleveling to ECMAScript 3 is not supported. Second, accessors with a `get` and no `set` are automatically inferred to be `readonly`. This is helpful when generating a `.d.ts` file from your code, because users of your property can see that they can’t change it.\n\n## Static Properties\n\nUp to this point, we’ve only talked about the *instance* members of the class, those that show up on the object when it’s instantiated. We can also create *static* members of a class, those that are visible on the class itself rather than on the instances. In this example, we use `static` on the origin, as it’s a general value for all grids. Each instance accesses this value through prepending the name of the class. Similarly to prepending `this.` in front of instance accesses, here we prepend `Grid.` in front of static accesses.\n\n``` ts\nclass Grid {\n  static origin = { x: 0, y: 0 };\n \n  calculateDistanceFromOrigin(point: { x: number; y: number }) {\n    let xDist = point.x - Grid.origin.x;\n    let yDist = point.y - Grid.origin.y;\n    return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\n  }\n \n  constructor(public scale: number) {}\n}\n \nlet grid1 = new Grid(1.0); // 1x scale\nlet grid2 = new Grid(5.0); // 5x scale\n \nconsole.log(grid1.calculateDistanceFromOrigin({ x: 10, y: 10 }));\nconsole.log(grid2.calculateDistanceFromOrigin({ x: 10, y: 10 }));\n```\n\n## Abstract Classes\n\nAbstract classes are base classes from which other classes may be derived. They may not be instantiated directly. Unlike an interface, an abstract class may contain implementation details for its members. The `abstract` keyword is used to define abstract classes as well as abstract methods within an abstract class.\n\n``` ts\nabstract class Animal {\n  abstract makeSound(): void;\n \n  move(): void {\n    console.log(\"roaming the earth...\");\n  }\n}\n```\n\nMethods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. Both define the signature of a method without including a method body. However, abstract methods must include the `abstract` keyword and may optionally include access modifiers.\n\n``` ts\nabstract class Department {\n  constructor(public name: string) {}\n \n  printName(): void {\n    console.log(\"Department name: \" + this.name);\n  }\n \n  abstract printMeeting(): void; // must be implemented in derived classes\n}\n \nclass AccountingDepartment extends Department {\n  constructor() {\n    super(\"Accounting and Auditing\"); // constructors in derived classes must call super()\n  }\n \n  printMeeting(): void {\n    console.log(\"The Accounting Department meets each Monday at 10am.\");\n  }\n \n  generateReports(): void {\n    console.log(\"Generating accounting reports...\");\n  }\n}\n \nlet department: Department; // ok to create a reference to an abstract type\ndepartment = new Department(); // error: cannot create an instance of an abstract class\ndepartment = new AccountingDepartment(); // ok to create and assign a non-abstract subclass\ndepartment.printName();\ndepartment.printMeeting();\ndepartment.generateReports(); // error: department is not of type AccountingDepartment, cannot access generateReports\n```\n\n## Advanced Techniques\n\n## Constructor functions\n\nWhen you declare a class in TypeScript, you are actually creating multiple declarations at the same time. The first is the type of the *instance* of the class.\n\n``` ts\nclass Greeter {\n  greeting: string;\n \n  constructor(message: string) {\n    this.greeting = message;\n  }\n \n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n \nlet greeter: Greeter;\ngreeter = new Greeter(\"world\");\nconsole.log(greeter.greet()); // \"Hello, world\"\n```\n\nHere, when we say `let greeter: Greeter`, we’re using `Greeter` as the type of instances of the class `Greeter`. This is almost second nature to programmers from other object-oriented languages.\n\nWe’re also creating another value that we call the *constructor function*. This is the function that is called when we `new` up instances of the class. To see what this looks like in practice, let’s take a look at the JavaScript created by the above example:\n\n``` ts\nlet Greeter = (function () {\n  function Greeter(message) {\n    this.greeting = message;\n  }\n \n  Greeter.prototype.greet = function () {\n    return \"Hello, \" + this.greeting;\n  };\n \n  return Greeter;\n})();\n \nlet greeter;\ngreeter = new Greeter(\"world\");\nconsole.log(greeter.greet()); // \"Hello, world\"\n```\n\nHere, `let Greeter` is going to be assigned the constructor function. When we call `new` and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an *instance* side and a *static* side.\n\nLet’s modify the example a bit to show this difference:\n\n``` ts\nclass Greeter {\n  static standardGreeting = \"Hello, there\";\n  greeting: string;\n  greet() {\n    if (this.greeting) {\n      return \"Hello, \" + this.greeting;\n    } else {\n      return Greeter.standardGreeting;\n    }\n  }\n}\n \nlet greeter1: Greeter;\ngreeter1 = new Greeter();\nconsole.log(greeter1.greet()); // \"Hello, there\"\n \nlet greeterMaker: typeof Greeter = Greeter;\ngreeterMaker.standardGreeting = \"Hey there!\";\n \nlet greeter2: Greeter = new greeterMaker();\nconsole.log(greeter2.greet()); // \"Hey there!\"\n \nlet greeter3: Greeter;\ngreeter3 = new Greeter();\nconsole.log(greeter3.greet()); // \"Hey there!\"\n```\n\nIn this example, `greeter1` works similarly to before. We instantiate the `Greeter` class, and use this object. This we have seen before.\n\nNext, we then use the class directly. Here we create a new variable called `greeterMaker`. This variable will hold the class itself, or said another way its constructor function. Here we use `typeof Greeter`, that is “give me the type of the `Greeter` class itself” rather than the instance type. Or, more precisely, “give me the type of the symbol called `Greeter`,” which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the `Greeter` class. We show this by using `new` on `greeterMaker`, creating new instances of `Greeter` and invoking them as before. It is also good to mention that changing static property is frowned upon, here `greeter3` has `\"Hey there!\"` instead of `\"Hello, there\"` on `standardGreeting`.\n\n## Using a class as an interface\n\nAs we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces.\n\n``` ts\nclass Point {\n  x: number;\n  y: number;\n}\n \ninterface Point3d extends Point {\n  z: number;\n}\n \nlet point3d: Point3d = { x: 1, y: 2, z: 3 };\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/classes.html](https://www.typescriptlang.org/docs/handbook/classes.html)"
- name: 'Classes: abstract Classes and Members'
  id: 2/classes#abstract-classes-and-members
  summary: Classes, methods, and fields in TypeScript may be abstract
  belongs_to: Classes
  description: |-
    ## `abstract` Classes and Members

    Classes, methods, and fields in TypeScript may be *abstract*.

    An *abstract method* or *abstract field* is one that hasn’t had an implementation provided. These members must exist inside an *abstract class*, which cannot be directly instantiated.

    The role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesn’t have any abstract members, it is said to be *concrete*.

    Let’s look at an example:

    ``` ts
    abstract class Base {
      abstract getName(): string;
     
      printName() {
        console.log("Hello, " + this.getName());
      }
    }
     
    const b = new Base();
    ```

    We can’t instantiate `Base` with `new` because it’s abstract. Instead, we need to make a derived class and implement the abstract members:

    ``` ts
    class Derived extends Base {
      getName() {
        return "world";
      }
    }
     
    const d = new Derived();
    d.printName();
    ```

    Notice that if we forget to implement the base class’s abstract members, we’ll get an error:

    ``` ts
    class Derived extends Base {
      // forgot to do anything
    }
    ```

    ### Abstract Construct Signatures

    Sometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class.

    For example, you might want to write this code:

    ``` ts
    function greet(ctor: typeof Base) {
      const instance = new ctor();
      instance.printName();
    }
    ```

    TypeScript is correctly telling you that you’re trying to instantiate an abstract class. After all, given the definition of `greet`, it’s perfectly legal to write this code, which would end up constructing an abstract class:

    ``` ts
    // Bad!
    greet(Base);
    ```

    Instead, you want to write a function that accepts something with a construct signature:

    ``` ts
    function greet(ctor: new () => Base) {
      const instance = new ctor();
      instance.printName();
    }
    greet(Derived);
    greet(Base);
    ```

    Now TypeScript correctly tells you about which class constructor functions can be invoked - `Derived` can because it’s concrete, but `Base` cannot.
- name: 'Classes: Class Expressions'
  id: 2/classes#class-expressions
  summary: Class expressions are very similar to class declarations
  belongs_to: Classes
  description: "## Class Expressions\n\n> Background Reading:  \n> [Class expressions (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class)  \n\nClass expressions are very similar to class declarations. The only real difference is that class expressions don’t need a name, though we can refer to them via whatever identifier they ended up bound to:\n\n``` ts\nconst someClass = class<Type> {\n  content: Type;\n  constructor(value: Type) {\n    this.content = value;\n  }\n};\n \nconst m = new someClass(\"Hello, world\");\n```"
- name: 'Classes: Class Heritage'
  id: 2/classes#class-heritage
  summary: Like other languages with object-oriented features, classes in JavaScript can inherit from base classes
  belongs_to: Classes
  description: |-
    ## Class Heritage

    Like other languages with object-oriented features, classes in JavaScript can inherit from base classes.
- name: 'Classes: Class Members'
  id: 2/classes#class-members
  summary: This class isn’t very useful yet, so let’s start adding some members
  belongs_to: Classes
  description: |-
    ## Class Members

    Here’s the most basic class - an empty one:

    ``` ts
    class Point {}
    ```

    This class isn’t very useful yet, so let’s start adding some members.

    ### Fields

    A field declaration creates a public writeable property on a class:

    ``` ts
    class Point {
      x: number;
      y: number;
    }
     
    const pt = new Point();
    pt.x = 0;
    pt.y = 0;
    ```

    As with other locations, the type annotation is optional, but will be an implicit `any` if not specified.

    Fields can also have *initializers*; these will run automatically when the class is instantiated:

    ``` ts
    class Point {
      x = 0;
      y = 0;
    }
     
    const pt = new Point();
    // Prints 0, 0
    console.log(`${pt.x}, ${pt.y}`);
    ```

    Just like with `const`, `let`, and `var`, the initializer of a class property will be used to infer its type:

    ``` ts
    const pt = new Point();
    pt.x = "0";
    ```

    #### `--strictPropertyInitialization`

    The [`strictPropertyInitialization`](https://www.typescriptlang.org/tsconfig#strictPropertyInitialization) setting controls whether class fields need to be initialized in the constructor.

    ``` ts
    class BadGreeter {
      name: string;
    }
    ```

    ``` ts
    class GoodGreeter {
      name: string;
     
      constructor() {
        this.name = "hello";
      }
    }
    ```

    Note that the field needs to be initialized *in the constructor itself*. TypeScript does not analyze methods you invoke from the constructor to detect initializations, because a derived class might override those methods and fail to initialize the members.

    If you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the *definite assignment assertion operator*, `!`:

    ``` ts
    class OKGreeter {
      // Not initialized, but no error
      name!: string;
    }
    ```
- name: 'Classes: Constructor Signatures'
  id: 2/classes#constructor-signatures
  summary: JavaScript classes are instantiated with the new operator
  belongs_to: Classes
  description: |-
    ## Constructor Signatures

    JavaScript classes are instantiated with the `new` operator. Given the type of a class itself, the [InstanceType](../utility-types#instancetypetype) utility type models this operation.

    ``` ts
    class Point {
      createdAt: number;
      x: number;
      y: number
      constructor(x: number, y: number) {
        this.createdAt = Date.now()
        this.x = x;
        this.y = y;
      }
    }
    type PointInstance = InstanceType<typeof Point>
     
    function moveRight(point: PointInstance) {
      point.x += 5;
    }
     
    const point = new Point(3, 4);
    moveRight(point);
    point.x; // => 8
    ```
- name: 'Classes: extends Clauses'
  id: 2/classes#extends-clauses
  summary: Classes may extend from a base class
  belongs_to: Classes
  description: "### `extends` Clauses\n\n> Background Reading:  \n> [extends keyword (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends)  \n\nClasses may `extend` from a base class. A derived class has all the properties and methods of its base class, and can also define additional members.\n\n``` ts\nclass Animal {\n  move() {\n    console.log(\"Moving along!\");\n  }\n}\n \nclass Dog extends Animal {\n  woof(times: number) {\n    for (let i = 0; i < times; i++) {\n      console.log(\"woof!\");\n    }\n  }\n}\n \nconst d = new Dog();\n// Base class method\nd.move();\n// Derived class method\nd.woof(3);\n```\n\n#### Overriding Methods\n\n> Background Reading:  \n> [super keyword (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super)  \n\nA derived class can also override a base class field or property. You can use the `super.` syntax to access base class methods. Note that because JavaScript classes are a simple lookup object, there is no notion of a “super field”.\n\nTypeScript enforces that a derived class is always a subtype of its base class.\n\nFor example, here’s a legal way to override a method:\n\n``` ts\nclass Base {\n  greet() {\n    console.log(\"Hello, world!\");\n  }\n}\n \nclass Derived extends Base {\n  greet(name?: string) {\n    if (name === undefined) {\n      super.greet();\n    } else {\n      console.log(`Hello, ${name.toUpperCase()}`);\n    }\n  }\n}\n \nconst d = new Derived();\nd.greet();\nd.greet(\"reader\");\n```\n\nIt’s important that a derived class follow its base class contract. Remember that it’s very common (and always legal!) to refer to a derived class instance through a base class reference:\n\n``` ts\n// Alias the derived instance through a base class reference\nconst b: Base = d;\n// No problem\nb.greet();\n```\n\nWhat if `Derived` didn’t follow `Base`’s contract?\n\n``` ts\nclass Base {\n  greet() {\n    console.log(\"Hello, world!\");\n  }\n}\n \nclass Derived extends Base {\n  // Make this parameter required\n  greet(name: string) {\n    console.log(`Hello, ${name.toUpperCase()}`);\n  }\n}\n```\n\nIf we compiled this code despite the error, this sample would then crash:\n\n``` ts\nconst b: Base = new Derived();\n// Crashes because \"name\" will be undefined\nb.greet();\n```\n\n#### Type-only Field Declarations\n\nWhen `target >= ES2022` or [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields) is `true`, class fields are initialized after the parent class constructor completes, overwriting any value set by the parent class. This can be a problem when you only want to re-declare a more accurate type for an inherited field. To handle these cases, you can write `declare` to indicate to TypeScript that there should be no runtime effect for this field declaration.\n\n``` ts\ninterface Animal {\n  dateOfBirth: any;\n}\n \ninterface Dog extends Animal {\n  breed: any;\n}\n \nclass AnimalHouse {\n  resident: Animal;\n  constructor(animal: Animal) {\n    this.resident = animal;\n  }\n}\n \nclass DogHouse extends AnimalHouse {\n  // Does not emit JavaScript code,\n  // only ensures the types are correct\n  declare resident: Dog;\n  constructor(dog: Dog) {\n    super(dog);\n  }\n}\n```\n\n#### Initialization Order\n\nThe order that JavaScript classes initialize can be surprising in some cases. Let’s consider this code:\n\n``` ts\nclass Base {\n  name = \"base\";\n  constructor() {\n    console.log(\"My name is \" + this.name);\n  }\n}\n \nclass Derived extends Base {\n  name = \"derived\";\n}\n \n// Prints \"base\", not \"derived\"\nconst d = new Derived();\n```\n\nWhat happened here?\n\nThe order of class initialization, as defined by JavaScript, is:\n\n- The base class fields are initialized\n- The base class constructor runs\n- The derived class fields are initialized\n- The derived class constructor runs\n\nThis means that the base class constructor saw its own value for `name` during its own constructor, because the derived class field initializations hadn’t run yet.\n\n#### Inheriting Built-in Types\n\n> Note: If you don’t plan to inherit from built-in types like `Array`, `Error`, `Map`, etc. or your compilation target is explicitly set to `ES6`/`ES2015` or above, you may skip this section\n\nIn ES2015, constructors which return an object implicitly substitute the value of `this` for any callers of `super(...)`. It is necessary for generated constructor code to capture any potential return value of `super(...)` and replace it with `this`.\n\nAs a result, subclassing `Error`, `Array`, and others may no longer work as expected. This is due to the fact that constructor functions for `Error`, `Array`, and the like use ECMAScript 6’s `new.target` to adjust the prototype chain; however, there is no way to ensure a value for `new.target` when invoking a constructor in ECMAScript 5. Other downlevel compilers generally have the same limitation by default.\n\nFor a subclass like the following:\n\n``` ts\nclass MsgError extends Error {\n  constructor(m: string) {\n    super(m);\n  }\n  sayHello() {\n    return \"hello \" + this.message;\n  }\n}\n```\n\nyou may find that:\n\n- methods may be `undefined` on objects returned by constructing these subclasses, so calling `sayHello` will result in an error.\n- `instanceof` will be broken between instances of the subclass and their instances, so `(new MsgError()) instanceof MsgError` will return `false`.\n\nAs a recommendation, you can manually adjust the prototype immediately after any `super(...)` calls.\n\n``` ts\nclass MsgError extends Error {\n  constructor(m: string) {\n    super(m);\n \n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MsgError.prototype);\n  }\n \n  sayHello() {\n    return \"hello \" + this.message;\n  }\n}\n```\n\nHowever, any subclass of `MsgError` will have to manually set the prototype as well. For runtimes that don’t support [`Object.setPrototypeOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf), you may instead be able to use [`__proto__`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto).\n\nUnfortunately, [these workarounds will not work on Internet Explorer 10 and prior](https://msdn.microsoft.com/en-us/library/s4esdbwz(v=vs.94).aspx). One can manually copy methods from the prototype onto the instance itself (i.e. `MsgError.prototype` onto `this`), but the prototype chain itself cannot be fixed."
- name: 'Classes: Generic Classes'
  id: 2/classes#generic-classes
  summary: Classes, much like interfaces, can be generic
  belongs_to: Classes
  description: |-
    ## Generic Classes

    Classes, much like interfaces, can be generic. When a generic class is instantiated with `new`, its type parameters are inferred the same way as in a function call:

    ``` ts
    class Box<Type> {
      contents: Type;
      constructor(value: Type) {
        this.contents = value;
      }
    }
     
    const b = new Box("hello!");
    ```

    Classes can use generic constraints and defaults the same way as interfaces.

    ### Type Parameters in Static Members

    This code isn’t legal, and it may not be obvious why:

    ``` ts
    class Box<Type> {
      static defaultValue: Type;
    }
    ```

    Remember that types are always fully erased! At runtime, there’s only *one* `Box.defaultValue` property slot. This means that setting `Box<string>.defaultValue` (if that were possible) would *also* change `Box<number>.defaultValue` - not good. The `static` members of a generic class can never refer to the class’s type parameters.
- name: 'Classes: implements Clauses'
  id: 2/classes#implements-clauses
  summary: You can use an implements clause to check that a class satisfies a particular interface
  belongs_to: Classes
  description: |-
    ### `implements` Clauses

    You can use an `implements` clause to check that a class satisfies a particular `interface`. An error will be issued if a class fails to correctly implement it:

    ``` ts
    interface Pingable {
      ping(): void;
    }
     
    class Sonar implements Pingable {
      ping() {
        console.log("ping!");
      }
    }
     
    class Ball implements Pingable {
      pong() {
        console.log("pong!");
      }
    }
    ```

    Classes may also implement multiple interfaces, e.g. `class C implements A, B {`.

    #### Cautions

    It’s important to understand that an `implements` clause is only a check that the class can be treated as the interface type. It doesn’t change the type of the class or its methods *at all*. A common source of error is to assume that an `implements` clause will change the class type - it doesn’t!

    ``` ts
    interface Checkable {
      check(name: string): boolean;
    }
     
    class NameChecker implements Checkable {
      check(s) {
        // Notice no error here
        return s.toLowerCase() === "ok";
      }
    }
    ```

    In this example, we perhaps expected that `s`’s type would be influenced by the `name: string` parameter of `check`. It is not - `implements` clauses don’t change how the class body is checked or its type inferred.

    Similarly, implementing an interface with an optional property doesn’t create that property:

    ``` ts
    interface A {
      x: number;
      y?: number;
    }
    class C implements A {
      x = 0;
    }
    const c = new C();
    c.y = 10;
    ```
- name: 'Classes: Member Visibility'
  id: 2/classes#member-visibility
  summary: You can use TypeScript to control whether certain methods or properties are visible to code outside the class
  belongs_to: Classes
  description: |-
    ## Member Visibility

    You can use TypeScript to control whether certain methods or properties are visible to code outside the class.
- name: 'Classes: Parameter Properties'
  id: 2/classes#parameter-properties
  summary: TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value
  belongs_to: Classes
  description: |-
    ## Parameter Properties

    TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called *parameter properties* and are created by prefixing a constructor argument with one of the visibility modifiers `public`, `private`, `protected`, or `readonly`. The resulting field gets those modifier(s):

    ``` ts
    class Params {
      constructor(
        public readonly x: number,
        protected y: number,
        private z: number
      ) {
        // No body necessary
      }
    }
    const a = new Params(1, 2, 3);
    console.log(a.x);
    console.log(a.z);
    ```
- name: 'Classes: private'
  id: 2/classes#private
  summary: Different OOP languages disagree about whether different instances of the same class may access each others’ private members
  belongs_to: Classes
  description: |-
    ### `private`

    `private` is like `protected`, but doesn’t allow access to the member even from subclasses:

    ``` ts
    class Base {
      private x = 0;
    }
    const b = new Base();
    // Can't access from outside the class
    console.log(b.x);
    ```

    ``` ts
    class Derived extends Base {
      showX() {
        // Can't access in subclasses
        console.log(this.x);
      }
    }
    ```

    Because `private` members aren’t visible to derived classes, a derived class can’t increase their visibility:

    ``` ts
    class Base {
      private x = 0;
    }
    class Derived extends Base {
      x = 1;
    }
    ```

    #### Cross-instance `private` access

    Different OOP languages disagree about whether different instances of the same class may access each others’ `private` members. While languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not.

    TypeScript does allow cross-instance `private` access:

    ``` ts
    class A {
      private x = 10;
     
      public sameAs(other: A) {
        // No error
        return other.x === this.x;
      }
    }
    ```

    #### Caveats

    Like other aspects of TypeScript’s type system, `private` and `protected` [are only enforced during type checking](https://www.typescriptlang.org/play?removeComments=true&target=99&ts=4.3.4#code/PTAEGMBsEMGddAEQPYHNQBMCmVoCcsEAHPASwDdoAXLUAM1K0gwQFdZSA7dAKWkoDK4MkSoByBAGJQJLAwAeAWABQIUH0HDSoiTLKUaoUggAW+DHorUsAOlABJcQlhUy4KpACeoLJzrI8cCwMGxU1ABVPIiwhESpMZEJQTmR4lxFQaQxWMm4IZABbIlIYKlJkTlDlXHgkNFAAbxVQTIAjfABrAEEC5FZOeIBeUAAGAG5mmSw8WAroSFIqb2GAIjMiIk8VieVJ8Ar01ncAgAoASkaAXxVr3dUwGoQAYWpMHBgCYn1rekZmNg4eUi0Vi2icoBWJCsNBWoA6WE8AHcAiEwmBgTEtDovtDaMZQLM6PEoQZbA5wSk0q5SO4vD4-AEghZoJwLGYEIRwNBoqAzFRwCZCFUIlFMXECdSiAhId8YZgclx0PsiiVqOVOAAaUAFLAsxWgKiC35MFigfC0FKgSAVVDTSyk+W5dB4fplHVVR6gF7xJrKFotEk-HXIRE9PoDUDDcaTAPTWaceaLZYQlmoPBbHYx-KcQ7HPDnK43FQqfY5+IMDDISPJLCIuqoc47UsuUCofAME3Vzi1r3URvF5QV5A2STtPDdXqunZDgDaYlHnTDrrEAF0dm28B3mDZg6HJwN1+2-hg57ulwNV2NQGoZbjYfNrYiENBwEFaojFiZQK08C-4fFKTVCozWfTgfFgLkeT5AUqiAA).

    This means that JavaScript runtime constructs like `in` or simple property lookup can still access a `private` or `protected` member:

    ``` ts
    class MySafe {
      private secretKey = 12345;
    }
    ```

    ``` js
    // In a JavaScript file...
    const s = new MySafe();
    // Will print 12345
    console.log(s.secretKey);
    ```

    `private` also allows access using bracket notation during type checking. This makes `private`-declared fields potentially easier to access for things like unit tests, with the drawback that these fields are *soft private* and don’t strictly enforce privacy.

    ``` ts
    class MySafe {
      private secretKey = 12345;
    }
     
    const s = new MySafe();
     
    // Not allowed during type checking
    console.log(s.secretKey);
     
    // OK
    console.log(s["secretKey"]);
    ```

    Unlike TypeScripts’s `private`, JavaScript’s [private fields](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields) (`#`) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them *hard private*.

    ``` ts
    class Dog {
      #barkAmount = 0;
      personality = "happy";
     
      constructor() {}
    }
    ```

    ``` ts
    "use strict";
    class Dog {
        #barkAmount = 0;
        personality = "happy";
        constructor() { }
    }
     
    ```

    When compiling to ES2021 or less, TypeScript will use WeakMaps in place of `#`.

    ``` ts
    "use strict";
    var _Dog_barkAmount;
    class Dog {
        constructor() {
            _Dog_barkAmount.set(this, 0);
            this.personality = "happy";
        }
    }
    _Dog_barkAmount = new WeakMap();
     
    ```

    If you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance.
- name: 'Classes: protected'
  id: 2/classes#protected
  summary: protected members are only visible to subclasses of the class they’re declared in
  belongs_to: Classes
  description: |-
    ### `protected`

    `protected` members are only visible to subclasses of the class they’re declared in.

    ``` ts
    class Greeter {
      public greet() {
        console.log("Hello, " + this.getName());
      }
      protected getName() {
        return "hi";
      }
    }
     
    class SpecialGreeter extends Greeter {
      public howdy() {
        // OK to access protected member here
        console.log("Howdy, " + this.getName());
      }
    }
    const g = new SpecialGreeter();
    g.greet(); // OK
    g.getName();
    ```

    #### Exposure of `protected` members

    Derived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. This includes making `protected` members `public`:

    ``` ts
    class Base {
      protected m = 10;
    }
    class Derived extends Base {
      // No modifier, so default is 'public'
      m = 15;
    }
    const d = new Derived();
    console.log(d.m); // OK
    ```

    Note that `Derived` was already able to freely read and write `m`, so this doesn’t meaningfully alter the “security” of this situation. The main thing to note here is that in the derived class, we need to be careful to repeat the `protected` modifier if this exposure isn’t intentional.

    #### Cross-hierarchy `protected` access

    Different OOP languages disagree about whether it’s legal to access a `protected` member through a base class reference:

    ``` ts
    class Base {
      protected x: number = 1;
    }
    class Derived1 extends Base {
      protected x: number = 5;
    }
    class Derived2 extends Base {
      f1(other: Derived2) {
        other.x = 10;
      }
      f2(other: Derived1) {
        other.x = 10;
      }
    }
    ```

    Java, for example, considers this to be legal. On the other hand, C# and C++ chose that this code should be illegal.

    TypeScript sides with C# and C++ here, because accessing `x` in `Derived2` should only be legal from `Derived2`’s subclasses, and `Derived1` isn’t one of them. Moreover, if accessing `x` through a `Derived1` reference is illegal (which it certainly should be!), then accessing it through a base class reference should never improve the situation.

    See also [Why Can’t I Access A Protected Member From A Derived Class?](https://blogs.msdn.microsoft.com/ericlippert/2005/11/09/why-cant-i-access-a-protected-member-from-a-derived-class/) which explains more of C#‘s reasoning.
- name: 'Classes: public'
  id: 2/classes#public
  summary: The default visibility of class members is public
  belongs_to: Classes
  description: |-
    ### `public`

    The default visibility of class members is `public`. A `public` member can be accessed anywhere:

    ``` ts
    class Greeter {
      public greet() {
        console.log("hi!");
      }
    }
    const g = new Greeter();
    g.greet();
    ```

    Because `public` is already the default visibility modifier, you don’t ever *need* to write it on a class member, but might choose to do so for style/readability reasons.
- name: 'Classes: readonly'
  id: 2/classes#readonly
  summary: Fields may be prefixed with the readonly modifier
  belongs_to: Classes
  description: "### `readonly`\n\nFields may be prefixed with the `readonly` modifier. This prevents assignments to the field outside of the constructor.\n\n``` ts\nclass Greeter {\n  readonly name: string = \"world\";\n \n  constructor(otherName?: string) {\n    if (otherName !== undefined) {\n      this.name = otherName;\n    }\n  }\n \n  err() {\n    this.name = \"not ok\";\n  }\n}\nconst g = new Greeter();\ng.name = \"also not ok\";\n```\n\n### Constructors\n\n> Background Reading:  \n> [Constructor (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor)  \n\nClass constructors are very similar to functions. You can add parameters with type annotations, default values, and overloads:\n\n``` ts\nclass Point {\n  x: number;\n  y: number;\n \n  // Normal signature with defaults\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n}\n```\n\n``` ts\nclass Point {\n  x: number = 0;\n  y: number = 0;\n \n  // Constructor overloads\n  constructor(x: number, y: number);\n  constructor(xy: string);\n  constructor(x: string | number, y: number = 0) {\n    // Code logic here\n  }\n}\n```\n\nThere are just a few differences between class constructor signatures and function signatures:\n\n- Constructors can’t have type parameters - these belong on the outer class declaration, which we’ll learn about later\n- Constructors can’t have return type annotations - the class instance type is always what’s returned\n\n#### Super Calls\n\nJust as in JavaScript, if you have a base class, you’ll need to call `super();` in your constructor body before using any `this.` members:\n\n``` ts\nclass Base {\n  k = 4;\n}\n \nclass Derived extends Base {\n  constructor() {\n    // Prints a wrong value in ES5; throws exception in ES6\n    console.log(this.k);\n    super();\n  }\n}\n```\n\nForgetting to call `super` is an easy mistake to make in JavaScript, but TypeScript will tell you when it’s necessary.\n\n### Methods\n\n> Background Reading:  \n> [Method definitions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions)  \n\nA function property on a class is called a *method*. Methods can use all the same type annotations as functions and constructors:\n\n``` ts\nclass Point {\n  x = 10;\n  y = 10;\n \n  scale(n: number): void {\n    this.x *= n;\n    this.y *= n;\n  }\n}\n```\n\nOther than the standard type annotations, TypeScript doesn’t add anything else new to methods.\n\nNote that inside a method body, it is still mandatory to access fields and other methods via `this.`. An unqualified name in a method body will always refer to something in the enclosing scope:\n\n``` ts\nlet x: number = 0;\n \nclass C {\n  x: string = \"hello\";\n \n  m() {\n    // This is trying to modify 'x' from line 1, not the class property\n    x = \"world\";\n  }\n}\n```\n\n### Getters / Setters\n\nClasses can also have *accessors*:\n\n``` ts\nclass C {\n  _length = 0;\n  get length() {\n    return this._length;\n  }\n  set length(value) {\n    this._length = value;\n  }\n}\n```\n\n> Note that a field-backed get/set pair with no extra logic is very rarely useful in JavaScript. It’s fine to expose public fields if you don’t need to add additional logic during the get/set operations.\n\nTypeScript has some special inference rules for accessors:\n\n- If `get` exists but no `set`, the property is automatically `readonly`\n- If the type of the setter parameter is not specified, it is inferred from the return type of the getter\n\nSince [TypeScript 4.3](https://devblogs.microsoft.com/typescript/announcing-typescript-4-3/), it is possible to have accessors with different types for getting and setting.\n\n``` ts\nclass Thing {\n  _size = 0;\n \n  get size(): number {\n    return this._size;\n  }\n \n  set size(value: string | number | boolean) {\n    let num = Number(value);\n \n    // Don't allow NaN, Infinity, etc\n \n    if (!Number.isFinite(num)) {\n      this._size = 0;\n      return;\n    }\n \n    this._size = num;\n  }\n}\n```\n\n### Index Signatures\n\nClasses can declare index signatures; these work the same as [Index Signatures for other object types](objects#index-signatures):\n\n``` ts\nclass MyClass {\n  [s: string]: boolean | ((s: string) => boolean);\n \n  check(s: string) {\n    return this[s] as boolean;\n  }\n}\n```\n\nBecause the index signature type needs to also capture the types of methods, it’s not easy to usefully use these types. Generally it’s better to store indexed data in another place instead of on the class instance itself."
- name: 'Classes: Relationships Between Classes'
  id: 2/classes#relationships-between-classes
  summary: In most cases, classes in TypeScript are compared structurally, the same as other types
  belongs_to: Classes
  description: "## Relationships Between Classes\n\nIn most cases, classes in TypeScript are compared structurally, the same as other types.\n\nFor example, these two classes can be used in place of each other because they’re identical:\n\n``` ts\nclass Point1 {\n  x = 0;\n  y = 0;\n}\n \nclass Point2 {\n  x = 0;\n  y = 0;\n}\n \n// OK\nconst p: Point1 = new Point2();\n```\n\nSimilarly, subtype relationships between classes exist even if there’s no explicit inheritance:\n\n``` ts\nclass Person {\n  name: string;\n  age: number;\n}\n \nclass Employee {\n  name: string;\n  age: number;\n  salary: number;\n}\n \n// OK\nconst p: Person = new Employee();\n```\n\nThis sounds straightforward, but there are a few cases that seem stranger than others.\n\nEmpty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (don’t!), anything can be used in place of it:\n\n``` ts\nclass Empty {}\n \nfunction fn(x: Empty) {\n  // can't do anything with 'x', so I won't\n}\n \n// All OK!\nfn(window);\nfn({});\nfn(fn);\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/classes.html](https://www.typescriptlang.org/docs/handbook/2/classes.html)"
- name: 'Classes: static Blocks in Classes'
  id: 2/classes#static-blocks-in-classes
  summary: Static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class
  belongs_to: Classes
  description: |-
    ## `static` Blocks in Classes

    Static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals.

    ``` ts
    class Foo {
        static #count = 0;
     
        get count() {
            return Foo.#count;
        }
     
        static {
            try {
                const lastInstances = loadLastInstances();
                Foo.#count += lastInstances.length;
            }
            catch {}
        }
    }
    ```
- name: 'Classes: Static Members'
  id: 2/classes#static-members
  summary: Classes may have static members
  belongs_to: Classes
  description: "## Static Members\n\n> Background Reading:  \n> [Static Members (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static)  \n\nClasses may have `static` members. These members aren’t associated with a particular instance of the class. They can be accessed through the class constructor object itself:\n\n``` ts\nclass MyClass {\n  static x = 0;\n  static printX() {\n    console.log(MyClass.x);\n  }\n}\nconsole.log(MyClass.x);\nMyClass.printX();\n```\n\nStatic members can also use the same `public`, `protected`, and `private` visibility modifiers:\n\n``` ts\nclass MyClass {\n  private static x = 0;\n}\nconsole.log(MyClass.x);\n```\n\nStatic members are also inherited:\n\n``` ts\nclass Base {\n  static getGreeting() {\n    return \"Hello world\";\n  }\n}\nclass Derived extends Base {\n  myGreeting = Derived.getGreeting();\n}\n```\n\n### Special Static Names\n\nIt’s generally not safe/possible to overwrite properties from the `Function` prototype. Because classes are themselves functions that can be invoked with `new`, certain `static` names can’t be used. Function properties like `name`, `length`, and `call` aren’t valid to define as `static` members:\n\n``` ts\nclass S {\n  static name = \"S!\";\n}\n```\n\n### Why No Static Classes?\n\nTypeScript (and JavaScript) don’t have a construct called `static class` the same way as, for example, C# does.\n\nThose constructs *only* exist because those languages force all data and functions to be inside a class; because that restriction doesn’t exist in TypeScript, there’s no need for them. A class with only a single instance is typically just represented as a normal *object* in JavaScript/TypeScript.\n\nFor example, we don’t need a “static class” syntax in TypeScript because a regular object (or even top-level function) will do the job just as well:\n\n``` ts\n// Unnecessary \"static\" class\nclass MyStaticClass {\n  static doSomething() {}\n}\n \n// Preferred (alternative 1)\nfunction doSomething() {}\n \n// Preferred (alternative 2)\nconst MyHelperObject = {\n  dosomething() {},\n};\n```"
- name: 'Classes: this at Runtime in Classes'
  id: 2/classes#this-at-runtime-in-classes
  summary: It’s important to remember that TypeScript doesn’t change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors
  belongs_to: Classes
  description: "## `this` at Runtime in Classes\n\n> Background Reading:  \n> [this keyword (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)  \n\nIt’s important to remember that TypeScript doesn’t change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors.\n\nJavaScript’s handling of `this` is indeed unusual:\n\n``` ts\nclass MyClass {\n  name = \"MyClass\";\n  getName() {\n    return this.name;\n  }\n}\nconst c = new MyClass();\nconst obj = {\n  name: \"obj\",\n  getName: c.getName,\n};\n \n// Prints \"obj\", not \"MyClass\"\nconsole.log(obj.getName());\n```\n\nLong story short, by default, the value of `this` inside a function depends on *how the function was called*. In this example, because the function was called through the `obj` reference, its value of `this` was `obj` rather than the class instance.\n\nThis is rarely what you want to happen! TypeScript provides some ways to mitigate or prevent this kind of error.\n\n### Arrow Functions\n\n> Background Reading:  \n> [Arrow functions (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)  \n\nIf you have a function that will often be called in a way that loses its `this` context, it can make sense to use an arrow function property instead of a method definition:\n\n``` ts\nclass MyClass {\n  name = \"MyClass\";\n  getName = () => {\n    return this.name;\n  };\n}\nconst c = new MyClass();\nconst g = c.getName;\n// Prints \"MyClass\" instead of crashing\nconsole.log(g());\n```\n\nThis has some trade-offs:\n\n- The `this` value is guaranteed to be correct at runtime, even for code not checked with TypeScript\n- This will use more memory, because each class instance will have its own copy of each function defined this way\n- You can’t use `super.getName` in a derived class, because there’s no entry in the prototype chain to fetch the base class method from"
- name: 'Classes: this parameters'
  id: 2/classes#this-parameters
  summary: In a method or function definition, an initial parameter named this has special meaning in TypeScript
  belongs_to: Classes
  description: |-
    ### `this` parameters

    In a method or function definition, an initial parameter named `this` has special meaning in TypeScript. These parameters are erased during compilation:

    ``` ts
    // TypeScript input with 'this' parameter
    function fn(this: SomeType, x: number) {
      /* ... */
    }
    ```

    ``` js
    // JavaScript output
    function fn(x) {
      /* ... */
    }
    ```

    TypeScript checks that calling a function with a `this` parameter is done so with a correct context. Instead of using an arrow function, we can add a `this` parameter to method definitions to statically enforce that the method is called correctly:

    ``` ts
    class MyClass {
      name = "MyClass";
      getName(this: MyClass) {
        return this.name;
      }
    }
    const c = new MyClass();
    // OK
    c.getName();
     
    // Error, would crash
    const g = c.getName;
    console.log(g());
    ```

    This method makes the opposite trade-offs of the arrow function approach:

    - JavaScript callers might still use the class method incorrectly without realizing it
    - Only one function per class definition gets allocated, rather than one per class instance
    - Base method definitions can still be called via `super`.

    &nbsp;
- name: 'Classes: this Types'
  id: 2/classes#this-types
  summary: In classes, a special type called this refers dynamically to the type of the current class
  belongs_to: Classes
  description: |-
    ## `this` Types

    In classes, a special type called `this` refers *dynamically* to the type of the current class. Let’s see how this is useful:

    ``` ts
    class Box {
      contents: string = "";
      set(value: string) {
        this.contents = value;
        return this;
      }
    }
    ```

    Here, TypeScript inferred the return type of `set` to be `this`, rather than `Box`. Now let’s make a subclass of `Box`:

    ``` ts
    class ClearableBox extends Box {
      clear() {
        this.contents = "";
      }
    }
     
    const a = new ClearableBox();
    const b = a.set("hello");
    ```

    You can also use `this` in a parameter type annotation:

    ``` ts
    class Box {
      content: string = "";
      sameAs(other: this) {
        return other.content === this.content;
      }
    }
    ```

    This is different from writing `other: Box` — if you have a derived class, its `sameAs` method will now only accept other instances of that same derived class:

    ``` ts
    class Box {
      content: string = "";
      sameAs(other: this) {
        return other.content === this.content;
      }
    }
     
    class DerivedBox extends Box {
      otherContent: string = "?";
    }
     
    const base = new Box();
    const derived = new DerivedBox();
    derived.sameAs(base);
    ```
- name: 'Classes: this-based type guards'
  id: 2/classes#this-based-type-guards
  summary: You can use this is Type in the return position for methods in classes and interfaces
  belongs_to: Classes
  description: |-
    ### `this`-based type guards

    You can use `this is Type` in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. `if` statements) the type of the target object would be narrowed to the specified `Type`.

    ``` ts
    class FileSystemObject {
      isFile(): this is FileRep {
        return this instanceof FileRep;
      }
      isDirectory(): this is Directory {
        return this instanceof Directory;
      }
      isNetworked(): this is Networked & this {
        return this.networked;
      }
      constructor(public path: string, private networked: boolean) {}
    }
     
    class FileRep extends FileSystemObject {
      constructor(path: string, public content: string) {
        super(path, false);
      }
    }
     
    class Directory extends FileSystemObject {
      children: FileSystemObject[];
    }
     
    interface Networked {
      host: string;
    }
     
    const fso: FileSystemObject = new FileRep("foo/bar.txt", "foo");
     
    if (fso.isFile()) {
      fso.content;
    } else if (fso.isDirectory()) {
      fso.children;
    } else if (fso.isNetworked()) {
      fso.host;
    }
    ```

    A common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an `undefined` from the value held inside box when `hasValue` has been verified to be true:

    ``` ts
    class Box<T> {
      value?: T;
     
      hasValue(): this is { value: T } {
        return this.value !== undefined;
      }
    }
     
    const box = new Box<string>();
    box.value = "Gameboy";
     
    box.value;
     
    if (box.hasValue()) {
      box.value;
    }
    ```
- name: Compiler Options in MSBuild
  id: compiler-options-in-msbuild
  summary: When you have an MSBuild based project which utilizes TypeScript such as an ASP.NET Core project, you can configure TypeScript in two ways
  description: "# Compiler Options in MSBuild\n\n## Overview\n\nWhen you have an MSBuild based project which utilizes TypeScript such as an ASP.NET Core project, you can configure TypeScript in two ways. Either via a `tsconfig.json` or via the project settings.\n\n## Using a `tsconfig.json`\n\nWe recommend using a `tsconfig.json` for your project when possible. To add one to an existing project, add a new item to your project which is called a “TypeScript JSON Configuration File” in modern versions of Visual Studio.\n\nThe new `tsconfig.json` will then be used as the source of truth for TypeScript-specific build information like files and configuration. You can learn [about how TSConfigs works here](tsconfig-json) and there is a [comprehensive reference here](https://www.typescriptlang.org/tsconfig).\n\n## Using Project Settings\n\nYou can also define the configuration for TypeScript inside you project’s settings. This is done by editing the XML in your `.csproj` to define `PropertyGroups` which describe how the build can work:\n\n``` xml\n<PropertyGroup>\n  <TypeScriptNoEmitOnError>true</TypeScriptNoEmitOnError>\n  <TypeScriptNoImplicitReturns>true</TypeScriptNoImplicitReturns>\n</PropertyGroup>\n```\n\nThere is a series of mappings for common TypeScript settings, these are settings which map directly to [TypeScript cli options](compiler-options) and are used to help you write a more understandable project file. You can use the [TSConfig reference](https://www.typescriptlang.org/tsconfig) to get more information on what values and defaults are for each mapping.\n\n### CLI Mappings\n\n| MSBuild Config Name                                                                                                                            | TSC Flag                                                                                                          |     |\n|------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------|-----|\n| `<TypeScriptAllowJS>`                                                                                                                          | [`--allowJs`](https://www.typescriptlang.org/tsconfig/#allowJs)                                                   |     |\n| Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files.                                  |                                                                                                                   |     |\n| `<TypeScriptRemoveComments>`                                                                                                                   | [`--removeComments`](https://www.typescriptlang.org/tsconfig/#removeComments)                                     |     |\n| Disable emitting comments.                                                                                                                     |                                                                                                                   |     |\n| `<TypeScriptNoImplicitAny>`                                                                                                                    | [`--noImplicitAny`](https://www.typescriptlang.org/tsconfig/#noImplicitAny)                                       |     |\n| Enable error reporting for expressions and declarations with an implied `any` type..                                                           |                                                                                                                   |     |\n| `<TypeScriptGeneratesDeclarations>`                                                                                                            | [`--declaration`](https://www.typescriptlang.org/tsconfig/#declaration)                                           |     |\n| Generate .d.ts files from TypeScript and JavaScript files in your project.                                                                     |                                                                                                                   |     |\n| `<TypeScriptModuleKind>`                                                                                                                       | [`--module`](https://www.typescriptlang.org/tsconfig/#module)                                                     |     |\n| Specify what module code is generated.                                                                                                         |                                                                                                                   |     |\n| `<TypeScriptJSXEmit>`                                                                                                                          | [`--jsx`](https://www.typescriptlang.org/tsconfig/#jsx)                                                           |     |\n| Specify what JSX code is generated.                                                                                                            |                                                                                                                   |     |\n| `<TypeScriptOutDir>`                                                                                                                           | [`--outDir`](https://www.typescriptlang.org/tsconfig/#outDir)                                                     |     |\n| Specify an output folder for all emitted files.                                                                                                |                                                                                                                   |     |\n| `<TypeScriptSourceMap>`                                                                                                                        | [`--sourcemap`](https://www.typescriptlang.org/tsconfig/#sourcemap)                                               |     |\n| Create source map files for emitted JavaScript files.                                                                                          |                                                                                                                   |     |\n| `<TypeScriptTarget>`                                                                                                                           | [`--target`](https://www.typescriptlang.org/tsconfig/#target)                                                     |     |\n| Set the JavaScript language version for emitted JavaScript and include compatible library declarations.                                        |                                                                                                                   |     |\n| `<TypeScriptNoResolve>`                                                                                                                        | [`--noResolve`](https://www.typescriptlang.org/tsconfig/#noResolve)                                               |     |\n| Disallow `import`s, `require`s or `<reference>`s from expanding the number of files TypeScript should add to a project.                        |                                                                                                                   |     |\n| `<TypeScriptMapRoot>`                                                                                                                          | [`--mapRoot`](https://www.typescriptlang.org/tsconfig/#mapRoot)                                                   |     |\n| Specify the location where debugger should locate map files instead of generated locations.                                                    |                                                                                                                   |     |\n| `<TypeScriptSourceRoot>`                                                                                                                       | [`--sourceRoot`](https://www.typescriptlang.org/tsconfig/#sourceRoot)                                             |     |\n| Specify the root path for debuggers to find the reference source code.                                                                         |                                                                                                                   |     |\n| `<TypeScriptCharset>`                                                                                                                          | [`--charset`](https://www.typescriptlang.org/tsconfig/#charset)                                                   |     |\n| No longer supported. In early versions, manually set the text encoding for reading files.                                                      |                                                                                                                   |     |\n| `<TypeScriptEmitBOM>`                                                                                                                          | [`--emitBOM`](https://www.typescriptlang.org/tsconfig/#emitBOM)                                                   |     |\n| Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.                                                                           |                                                                                                                   |     |\n| `<TypeScriptNoLib>`                                                                                                                            | [`--noLib`](https://www.typescriptlang.org/tsconfig/#noLib)                                                       |     |\n| Disable including any library files, including the default lib.d.ts.                                                                           |                                                                                                                   |     |\n| `<TypeScriptPreserveConstEnums>`                                                                                                               | [`--preserveConstEnums`](https://www.typescriptlang.org/tsconfig/#preserveConstEnums)                             |     |\n| Disable erasing `const enum` declarations in generated code.                                                                                   |                                                                                                                   |     |\n| `<TypeScriptSuppressImplicitAnyIndexErrors>`                                                                                                   | [`--suppressImplicitAnyIndexErrors`](https://www.typescriptlang.org/tsconfig/#suppressImplicitAnyIndexErrors)     |     |\n| Suppress `noImplicitAny` errors when indexing objects that lack index signatures.                                                              |                                                                                                                   |     |\n| `<TypeScriptNoEmitHelpers>`                                                                                                                    | [`--noEmitHelpers`](https://www.typescriptlang.org/tsconfig/#noEmitHelpers)                                       |     |\n| Disable generating custom helper functions like `__extends` in compiled output.                                                                |                                                                                                                   |     |\n| `<TypeScriptInlineSourceMap>`                                                                                                                  | [`--inlineSourceMap`](https://www.typescriptlang.org/tsconfig/#inlineSourceMap)                                   |     |\n| Include sourcemap files inside the emitted JavaScript.                                                                                         |                                                                                                                   |     |\n| `<TypeScriptInlineSources>`                                                                                                                    | [`--inlineSources`](https://www.typescriptlang.org/tsconfig/#inlineSources)                                       |     |\n| Include source code in the sourcemaps inside the emitted JavaScript.                                                                           |                                                                                                                   |     |\n| `<TypeScriptNewLine>`                                                                                                                          | [`--newLine`](https://www.typescriptlang.org/tsconfig/#newLine)                                                   |     |\n| Set the newline character for emitting files.                                                                                                  |                                                                                                                   |     |\n| `<TypeScriptIsolatedModules>`                                                                                                                  | [`--isolatedModules`](https://www.typescriptlang.org/tsconfig/#isolatedModules)                                   |     |\n| Ensure that each file can be safely transpiled without relying on other imports.                                                               |                                                                                                                   |     |\n| `<TypeScriptEmitDecoratorMetadata>`                                                                                                            | [`--emitDecoratorMetadata`](https://www.typescriptlang.org/tsconfig/#emitDecoratorMetadata)                       |     |\n| Emit design-type metadata for decorated declarations in source files.                                                                          |                                                                                                                   |     |\n| `<TypeScriptRootDir>`                                                                                                                          | [`--rootDir`](https://www.typescriptlang.org/tsconfig/#rootDir)                                                   |     |\n| Specify the root folder within your source files.                                                                                              |                                                                                                                   |     |\n| `<TypeScriptExperimentalDecorators>`                                                                                                           | [`--experimentalDecorators`](https://www.typescriptlang.org/tsconfig/#experimentalDecorators)                     |     |\n| Enable experimental support for TC39 stage 2 draft decorators.                                                                                 |                                                                                                                   |     |\n| `<TypeScriptModuleResolution>`                                                                                                                 | [`--moduleResolution`](https://www.typescriptlang.org/tsconfig/#moduleResolution)                                 |     |\n| Specify how TypeScript looks up a file from a given module specifier.                                                                          |                                                                                                                   |     |\n| `<TypeScriptSuppressExcessPropertyErrors>`                                                                                                     | [`--suppressExcessPropertyErrors`](https://www.typescriptlang.org/tsconfig/#suppressExcessPropertyErrors)         |     |\n| Disable reporting of excess property errors during the creation of object literals.                                                            |                                                                                                                   |     |\n| `<TypeScriptReactNamespace>`                                                                                                                   | [`--reactNamespace`](https://www.typescriptlang.org/tsconfig/#reactNamespace)                                     |     |\n| Specify the object invoked for `createElement`. This only applies when targeting `react` JSX emit.                                             |                                                                                                                   |     |\n| `<TypeScriptSkipDefaultLibCheck>`                                                                                                              | [`--skipDefaultLibCheck`](https://www.typescriptlang.org/tsconfig/#skipDefaultLibCheck)                           |     |\n| Skip type checking .d.ts files that are included with TypeScript.                                                                              |                                                                                                                   |     |\n| `<TypeScriptAllowUnusedLabels>`                                                                                                                | [`--allowUnusedLabels`](https://www.typescriptlang.org/tsconfig/#allowUnusedLabels)                               |     |\n| Disable error reporting for unused labels.                                                                                                     |                                                                                                                   |     |\n| `<TypeScriptNoImplicitReturns>`                                                                                                                | [`--noImplicitReturns`](https://www.typescriptlang.org/tsconfig/#noImplicitReturns)                               |     |\n| Enable error reporting for codepaths that do not explicitly return in a function.                                                              |                                                                                                                   |     |\n| `<TypeScriptNoFallthroughCasesInSwitch>`                                                                                                       | [`--noFallthroughCasesInSwitch`](https://www.typescriptlang.org/tsconfig/#noFallthroughCasesInSwitch)             |     |\n| Enable error reporting for fallthrough cases in switch statements.                                                                             |                                                                                                                   |     |\n| `<TypeScriptAllowUnreachableCode>`                                                                                                             | [`--allowUnreachableCode`](https://www.typescriptlang.org/tsconfig/#allowUnreachableCode)                         |     |\n| Disable error reporting for unreachable code.                                                                                                  |                                                                                                                   |     |\n| `<TypeScriptForceConsistentCasingInFileNames>`                                                                                                 | [`--forceConsistentCasingInFileNames`](https://www.typescriptlang.org/tsconfig/#forceConsistentCasingInFileNames) |     |\n| Ensure that casing is correct in imports.                                                                                                      |                                                                                                                   |     |\n| `<TypeScriptAllowSyntheticDefaultImports>`                                                                                                     | [`--allowSyntheticDefaultImports`](https://www.typescriptlang.org/tsconfig/#allowSyntheticDefaultImports)         |     |\n| Allow 'import x from y' when a module doesn't have a default export.                                                                           |                                                                                                                   |     |\n| `<TypeScriptNoImplicitUseStrict>`                                                                                                              | [`--noImplicitUseStrict`](https://www.typescriptlang.org/tsconfig/#noImplicitUseStrict)                           |     |\n| Disable adding 'use strict' directives in emitted JavaScript files.                                                                            |                                                                                                                   |     |\n| `<TypeScriptLib>`                                                                                                                              | [`--lib`](https://www.typescriptlang.org/tsconfig/#lib)                                                           |     |\n| Specify a set of bundled library declaration files that describe the target runtime environment.                                               |                                                                                                                   |     |\n| `<TypeScriptBaseUrl>`                                                                                                                          | [`--baseUrl`](https://www.typescriptlang.org/tsconfig/#baseUrl)                                                   |     |\n| Specify the base directory to resolve bare specifier module names.                                                                             |                                                                                                                   |     |\n| `<TypeScriptDeclarationDir>`                                                                                                                   | [`--declarationDir`](https://www.typescriptlang.org/tsconfig/#declarationDir)                                     |     |\n| Specify the output directory for generated declaration files.                                                                                  |                                                                                                                   |     |\n| `<TypeScriptNoImplicitThis>`                                                                                                                   | [`--noImplicitThis`](https://www.typescriptlang.org/tsconfig/#noImplicitThis)                                     |     |\n| Enable error reporting when `this` is given the type `any`.                                                                                    |                                                                                                                   |     |\n| `<TypeScriptSkipLibCheck>`                                                                                                                     | [`--skipLibCheck`](https://www.typescriptlang.org/tsconfig/#skipLibCheck)                                         |     |\n| Skip type checking all .d.ts files.                                                                                                            |                                                                                                                   |     |\n| `<TypeScriptStrictNullChecks>`                                                                                                                 | [`--strictNullChecks`](https://www.typescriptlang.org/tsconfig/#strictNullChecks)                                 |     |\n| When type checking, take into account `null` and `undefined`.                                                                                  |                                                                                                                   |     |\n| `<TypeScriptNoUnusedLocals>`                                                                                                                   | [`--noUnusedLocals`](https://www.typescriptlang.org/tsconfig/#noUnusedLocals)                                     |     |\n| Enable error reporting when a local variables aren't read.                                                                                     |                                                                                                                   |     |\n| `<TypeScriptNoUnusedParameters>`                                                                                                               | [`--noUnusedParameters`](https://www.typescriptlang.org/tsconfig/#noUnusedParameters)                             |     |\n| Raise an error when a function parameter isn't read                                                                                            |                                                                                                                   |     |\n| `<TypeScriptAlwaysStrict>`                                                                                                                     | [`--alwaysStrict`](https://www.typescriptlang.org/tsconfig/#alwaysStrict)                                         |     |\n| Ensure 'use strict' is always emitted.                                                                                                         |                                                                                                                   |     |\n| `<TypeScriptImportHelpers>`                                                                                                                    | [`--importHelpers`](https://www.typescriptlang.org/tsconfig/#importHelpers)                                       |     |\n| Allow importing helper functions from tslib once per project, instead of including them per-file.                                              |                                                                                                                   |     |\n| `<TypeScriptJSXFactory>`                                                                                                                       | [`--jsxFactory`](https://www.typescriptlang.org/tsconfig/#jsxFactory)                                             |     |\n| Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'                                         |                                                                                                                   |     |\n| `<TypeScriptStripInternal>`                                                                                                                    | [`--stripInternal`](https://www.typescriptlang.org/tsconfig/#stripInternal)                                       |     |\n| Disable emitting declarations that have `@internal` in their JSDoc comments.                                                                   |                                                                                                                   |     |\n| `<TypeScriptCheckJs>`                                                                                                                          | [`--checkJs`](https://www.typescriptlang.org/tsconfig/#checkJs)                                                   |     |\n| Enable error reporting in type-checked JavaScript files.                                                                                       |                                                                                                                   |     |\n| `<TypeScriptDownlevelIteration>`                                                                                                               | [`--downlevelIteration`](https://www.typescriptlang.org/tsconfig/#downlevelIteration)                             |     |\n| Emit more compliant, but verbose and less performant JavaScript for iteration.                                                                 |                                                                                                                   |     |\n| `<TypeScriptStrict>`                                                                                                                           | [`--strict`](https://www.typescriptlang.org/tsconfig/#strict)                                                     |     |\n| Enable all strict type checking options.                                                                                                       |                                                                                                                   |     |\n| `<TypeScriptNoStrictGenericChecks>`                                                                                                            | [`--noStrictGenericChecks`](https://www.typescriptlang.org/tsconfig/#noStrictGenericChecks)                       |     |\n| Disable strict checking of generic signatures in function types.                                                                               |                                                                                                                   |     |\n| `<TypeScriptPreserveSymlinks>`                                                                                                                 | [`--preserveSymlinks`](https://www.typescriptlang.org/tsconfig/#preserveSymlinks)                                 |     |\n| Disable resolving symlinks to their realpath. This correlates to the same flag in node.                                                        |                                                                                                                   |     |\n| `<TypeScriptStrictFunctionTypes>`                                                                                                              | [`--strictFunctionTypes`](https://www.typescriptlang.org/tsconfig/#strictFunctionTypes)                           |     |\n| When assigning functions, check to ensure parameters and the return values are subtype-compatible.                                             |                                                                                                                   |     |\n| `<TypeScriptStrictPropertyInitialization>`                                                                                                     | [`--strictPropertyInitialization`](https://www.typescriptlang.org/tsconfig/#strictPropertyInitialization)         |     |\n| Check for class properties that are declared but not set in the constructor.                                                                   |                                                                                                                   |     |\n| `<TypeScriptESModuleInterop>`                                                                                                                  | [`--esModuleInterop`](https://www.typescriptlang.org/tsconfig/#esModuleInterop)                                   |     |\n| Emit additional JavaScript to ease support for importing CommonJS modules. This enables `allowSyntheticDefaultImports` for type compatibility. |                                                                                                                   |     |\n| `<TypeScriptEmitDeclarationOnly>`                                                                                                              | [`--emitDeclarationOnly`](https://www.typescriptlang.org/tsconfig/#emitDeclarationOnly)                           |     |\n| Only output d.ts files and not JavaScript files.                                                                                               |                                                                                                                   |     |\n| `<TypeScriptKeyofStringsOnly>`                                                                                                                 | [`--keyofStringsOnly`](https://www.typescriptlang.org/tsconfig/#keyofStringsOnly)                                 |     |\n| Make keyof only return strings instead of string, numbers or symbols. Legacy option.                                                           |                                                                                                                   |     |\n| `<TypeScriptUseDefineForClassFields>`                                                                                                          | [`--useDefineForClassFields`](https://www.typescriptlang.org/tsconfig/#useDefineForClassFields)                   |     |\n| Emit ECMAScript-standard-compliant class fields.                                                                                               |                                                                                                                   |     |\n| `<TypeScriptDeclarationMap>`                                                                                                                   | [`--declarationMap`](https://www.typescriptlang.org/tsconfig/#declarationMap)                                     |     |\n| Create sourcemaps for d.ts files.                                                                                                              |                                                                                                                   |     |\n| `<TypeScriptResolveJsonModule>`                                                                                                                | [`--resolveJsonModule`](https://www.typescriptlang.org/tsconfig/#resolveJsonModule)                               |     |\n| Enable importing .json files                                                                                                                   |                                                                                                                   |     |\n| `<TypeScriptStrictBindCallApply>`                                                                                                              | [`--strictBindCallApply`](https://www.typescriptlang.org/tsconfig/#strictBindCallApply)                           |     |\n| Check that the arguments for `bind`, `call`, and `apply` methods match the original function.                                                  |                                                                                                                   |     |\n| `<TypeScriptNoEmitOnError>`                                                                                                                    | [`--noEmitOnError`](https://www.typescriptlang.org/tsconfig/#noEmitOnError)                                       |     |\n| Disable emitting files if any type checking errors are reported.                                                                               |                                                                                                                   |     |\n\n### Additional Flags\n\nBecause the MSBuild system passes arguments directly to the TypeScript CLI, you can use the option `TypeScriptAdditionalFlags` to provide specific flags which don’t have a mapping above.\n\nFor example, this would turn on [`noPropertyAccessFromIndexSignature`](https://www.typescriptlang.org/tsconfig#noPropertyAccessFromIndexSignature):\n\n``` xml\n<TypeScriptAdditionalFlags> $(TypeScriptAdditionalFlags) --noPropertyAccessFromIndexSignature</TypeScriptAdditionalFlags>\n```\n\n### Debug and Release Builds\n\nYou can use PropertyGroup conditions to define different sets of configurations. For example, a common task is stripping comments and sourcemaps in production. In this example, we define a debug and release property group which have different TypeScript configurations:\n\n``` xml\n<PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\">\n  <TypeScriptRemoveComments>false</TypeScriptRemoveComments>\n  <TypeScriptSourceMap>true</TypeScriptSourceMap>\n</PropertyGroup>\n\n<PropertyGroup Condition=\"'$(Configuration)' == 'Release'\">\n  <TypeScriptRemoveComments>true</TypeScriptRemoveComments>\n  <TypeScriptSourceMap>false</TypeScriptSourceMap>\n</PropertyGroup>\n\n<Import\n    Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"\n    Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" />\n```\n\n### ToolsVersion\n\nThe value of `<TypeScriptToolsVersion>1.7</TypeScriptToolsVersion>` property in the project file identifies the compiler version to use to build (1.7 in this example). This allows a project to build against the same versions of the compiler on different machines.\n\nIf `TypeScriptToolsVersion` is not specified, the latest compiler version installed on the machine will be used to build.\n\nUsers using newer versions of TS, will see a prompt to upgrade their project on first load.\n\n### TypeScriptCompileBlocked\n\nIf you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set `<TypeScriptCompileBlocked>true</TypeScriptCompileBlocked>` in your project. This should give you all the editing support, but not the build when you hit F5.\n\n### TypeScriptEnableIncrementalMSBuild (TypeScript 4.2 Beta and later)\n\nBy default, MSBuild will attempt to only run the TypeScript compiler when the project’s source files have been updated since the last compilation. However, if this behavior is causing issues, such as when TypeScript’s [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) option is enabled, set `<TypeScriptEnableIncrementalMSBuild>false</TypeScriptEnableIncrementalMSBuild>` to ensure the TypeScript compiler is invoked with every run of MSBuild.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html)"
- name: 'Compiler Options in MSBuild: Overview'
  id: compiler-options-in-msbuild#overview
  summary: When you have an MSBuild based project which utilizes TypeScript such as an ASP.NET Core project, you can configure TypeScript in two ways
  belongs_to: Compiler Options in MSBuild
  description: |-
    ## Overview

    When you have an MSBuild based project which utilizes TypeScript such as an ASP.NET Core project, you can configure TypeScript in two ways. Either via a `tsconfig.json` or via the project settings.
- name: 'Compiler Options in MSBuild: Using a tsconfig.json'
  id: compiler-options-in-msbuild#using-a-tsconfigjson
  summary: We recommend using a tsconfig.json for your project when possible
  belongs_to: Compiler Options in MSBuild
  description: |-
    ## Using a `tsconfig.json`

    We recommend using a `tsconfig.json` for your project when possible. To add one to an existing project, add a new item to your project which is called a “TypeScript JSON Configuration File” in modern versions of Visual Studio.

    The new `tsconfig.json` will then be used as the source of truth for TypeScript-specific build information like files and configuration. You can learn [about how TSConfigs works here](tsconfig-json) and there is a [comprehensive reference here](https://www.typescriptlang.org/tsconfig).
- name: 'Compiler Options in MSBuild: Using Project Settings'
  id: compiler-options-in-msbuild#using-project-settings
  summary: You can also define the configuration for TypeScript inside you project’s settings
  belongs_to: Compiler Options in MSBuild
  description: "## Using Project Settings\n\nYou can also define the configuration for TypeScript inside you project’s settings. This is done by editing the XML in your `.csproj` to define `PropertyGroups` which describe how the build can work:\n\n``` xml\n<PropertyGroup>\n  <TypeScriptNoEmitOnError>true</TypeScriptNoEmitOnError>\n  <TypeScriptNoImplicitReturns>true</TypeScriptNoImplicitReturns>\n</PropertyGroup>\n```\n\nThere is a series of mappings for common TypeScript settings, these are settings which map directly to [TypeScript cli options](compiler-options) and are used to help you write a more understandable project file. You can use the [TSConfig reference](https://www.typescriptlang.org/tsconfig) to get more information on what values and defaults are for each mapping.\n\n### CLI Mappings\n\n| MSBuild Config Name                                                                                                                            | TSC Flag                                                                                                                |     |\n|------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------|-----|\n| `<TypeScriptAllowJS>`                                                                                                                          | ` `[`--allowJs`](https://www.typescriptlang.org/tsconfig/#allowJs)` `                                                   |     |\n| Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files.                                  |                                                                                                                         |     |\n| `<TypeScriptRemoveComments>`                                                                                                                   | ` `[`--removeComments`](https://www.typescriptlang.org/tsconfig/#removeComments)` `                                     |     |\n| Disable emitting comments.                                                                                                                     |                                                                                                                         |     |\n| `<TypeScriptNoImplicitAny>`                                                                                                                    | ` `[`--noImplicitAny`](https://www.typescriptlang.org/tsconfig/#noImplicitAny)` `                                       |     |\n| Enable error reporting for expressions and declarations with an implied `any` type..                                                           |                                                                                                                         |     |\n| `<TypeScriptGeneratesDeclarations>`                                                                                                            | ` `[`--declaration`](https://www.typescriptlang.org/tsconfig/#declaration)` `                                           |     |\n| Generate .d.ts files from TypeScript and JavaScript files in your project.                                                                     |                                                                                                                         |     |\n| `<TypeScriptModuleKind>`                                                                                                                       | ` `[`--module`](https://www.typescriptlang.org/tsconfig/#module)` `                                                     |     |\n| Specify what module code is generated.                                                                                                         |                                                                                                                         |     |\n| `<TypeScriptJSXEmit>`                                                                                                                          | ` `[`--jsx`](https://www.typescriptlang.org/tsconfig/#jsx)` `                                                           |     |\n| Specify what JSX code is generated.                                                                                                            |                                                                                                                         |     |\n| `<TypeScriptOutDir>`                                                                                                                           | ` `[`--outDir`](https://www.typescriptlang.org/tsconfig/#outDir)` `                                                     |     |\n| Specify an output folder for all emitted files.                                                                                                |                                                                                                                         |     |\n| `<TypeScriptSourceMap>`                                                                                                                        | ` `[`--sourcemap`](https://www.typescriptlang.org/tsconfig/#sourcemap)` `                                               |     |\n| Create source map files for emitted JavaScript files.                                                                                          |                                                                                                                         |     |\n| `<TypeScriptTarget>`                                                                                                                           | ` `[`--target`](https://www.typescriptlang.org/tsconfig/#target)` `                                                     |     |\n| Set the JavaScript language version for emitted JavaScript and include compatible library declarations.                                        |                                                                                                                         |     |\n| `<TypeScriptNoResolve>`                                                                                                                        | ` `[`--noResolve`](https://www.typescriptlang.org/tsconfig/#noResolve)` `                                               |     |\n| Disallow `import`s, `require`s or `<reference>`s from expanding the number of files TypeScript should add to a project.                        |                                                                                                                         |     |\n| `<TypeScriptMapRoot>`                                                                                                                          | ` `[`--mapRoot`](https://www.typescriptlang.org/tsconfig/#mapRoot)` `                                                   |     |\n| Specify the location where debugger should locate map files instead of generated locations.                                                    |                                                                                                                         |     |\n| `<TypeScriptSourceRoot>`                                                                                                                       | ` `[`--sourceRoot`](https://www.typescriptlang.org/tsconfig/#sourceRoot)` `                                             |     |\n| Specify the root path for debuggers to find the reference source code.                                                                         |                                                                                                                         |     |\n| `<TypeScriptCharset>`                                                                                                                          | ` `[`--charset`](https://www.typescriptlang.org/tsconfig/#charset)` `                                                   |     |\n| No longer supported. In early versions, manually set the text encoding for reading files.                                                      |                                                                                                                         |     |\n| `<TypeScriptEmitBOM>`                                                                                                                          | ` `[`--emitBOM`](https://www.typescriptlang.org/tsconfig/#emitBOM)` `                                                   |     |\n| Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.                                                                           |                                                                                                                         |     |\n| `<TypeScriptNoLib>`                                                                                                                            | ` `[`--noLib`](https://www.typescriptlang.org/tsconfig/#noLib)` `                                                       |     |\n| Disable including any library files, including the default lib.d.ts.                                                                           |                                                                                                                         |     |\n| `<TypeScriptPreserveConstEnums>`                                                                                                               | ` `[`--preserveConstEnums`](https://www.typescriptlang.org/tsconfig/#preserveConstEnums)` `                             |     |\n| Disable erasing `const enum` declarations in generated code.                                                                                   |                                                                                                                         |     |\n| `<TypeScriptSuppressImplicitAnyIndexErrors>`                                                                                                   | ` `[`--suppressImplicitAnyIndexErrors`](https://www.typescriptlang.org/tsconfig/#suppressImplicitAnyIndexErrors)` `     |     |\n| Suppress `noImplicitAny` errors when indexing objects that lack index signatures.                                                              |                                                                                                                         |     |\n| `<TypeScriptNoEmitHelpers>`                                                                                                                    | ` `[`--noEmitHelpers`](https://www.typescriptlang.org/tsconfig/#noEmitHelpers)` `                                       |     |\n| Disable generating custom helper functions like `__extends` in compiled output.                                                                |                                                                                                                         |     |\n| `<TypeScriptInlineSourceMap>`                                                                                                                  | ` `[`--inlineSourceMap`](https://www.typescriptlang.org/tsconfig/#inlineSourceMap)` `                                   |     |\n| Include sourcemap files inside the emitted JavaScript.                                                                                         |                                                                                                                         |     |\n| `<TypeScriptInlineSources>`                                                                                                                    | ` `[`--inlineSources`](https://www.typescriptlang.org/tsconfig/#inlineSources)` `                                       |     |\n| Include source code in the sourcemaps inside the emitted JavaScript.                                                                           |                                                                                                                         |     |\n| `<TypeScriptNewLine>`                                                                                                                          | ` `[`--newLine`](https://www.typescriptlang.org/tsconfig/#newLine)` `                                                   |     |\n| Set the newline character for emitting files.                                                                                                  |                                                                                                                         |     |\n| `<TypeScriptIsolatedModules>`                                                                                                                  | ` `[`--isolatedModules`](https://www.typescriptlang.org/tsconfig/#isolatedModules)` `                                   |     |\n| Ensure that each file can be safely transpiled without relying on other imports.                                                               |                                                                                                                         |     |\n| `<TypeScriptEmitDecoratorMetadata>`                                                                                                            | ` `[`--emitDecoratorMetadata`](https://www.typescriptlang.org/tsconfig/#emitDecoratorMetadata)` `                       |     |\n| Emit design-type metadata for decorated declarations in source files.                                                                          |                                                                                                                         |     |\n| `<TypeScriptRootDir>`                                                                                                                          | ` `[`--rootDir`](https://www.typescriptlang.org/tsconfig/#rootDir)` `                                                   |     |\n| Specify the root folder within your source files.                                                                                              |                                                                                                                         |     |\n| `<TypeScriptExperimentalDecorators>`                                                                                                           | ` `[`--experimentalDecorators`](https://www.typescriptlang.org/tsconfig/#experimentalDecorators)` `                     |     |\n| Enable experimental support for TC39 stage 2 draft decorators.                                                                                 |                                                                                                                         |     |\n| `<TypeScriptModuleResolution>`                                                                                                                 | ` `[`--moduleResolution`](https://www.typescriptlang.org/tsconfig/#moduleResolution)` `                                 |     |\n| Specify how TypeScript looks up a file from a given module specifier.                                                                          |                                                                                                                         |     |\n| `<TypeScriptSuppressExcessPropertyErrors>`                                                                                                     | ` `[`--suppressExcessPropertyErrors`](https://www.typescriptlang.org/tsconfig/#suppressExcessPropertyErrors)` `         |     |\n| Disable reporting of excess property errors during the creation of object literals.                                                            |                                                                                                                         |     |\n| `<TypeScriptReactNamespace>`                                                                                                                   | ` `[`--reactNamespace`](https://www.typescriptlang.org/tsconfig/#reactNamespace)` `                                     |     |\n| Specify the object invoked for `createElement`. This only applies when targeting `react` JSX emit.                                             |                                                                                                                         |     |\n| `<TypeScriptSkipDefaultLibCheck>`                                                                                                              | ` `[`--skipDefaultLibCheck`](https://www.typescriptlang.org/tsconfig/#skipDefaultLibCheck)` `                           |     |\n| Skip type checking .d.ts files that are included with TypeScript.                                                                              |                                                                                                                         |     |\n| `<TypeScriptAllowUnusedLabels>`                                                                                                                | ` `[`--allowUnusedLabels`](https://www.typescriptlang.org/tsconfig/#allowUnusedLabels)` `                               |     |\n| Disable error reporting for unused labels.                                                                                                     |                                                                                                                         |     |\n| `<TypeScriptNoImplicitReturns>`                                                                                                                | ` `[`--noImplicitReturns`](https://www.typescriptlang.org/tsconfig/#noImplicitReturns)` `                               |     |\n| Enable error reporting for codepaths that do not explicitly return in a function.                                                              |                                                                                                                         |     |\n| `<TypeScriptNoFallthroughCasesInSwitch>`                                                                                                       | ` `[`--noFallthroughCasesInSwitch`](https://www.typescriptlang.org/tsconfig/#noFallthroughCasesInSwitch)` `             |     |\n| Enable error reporting for fallthrough cases in switch statements.                                                                             |                                                                                                                         |     |\n| `<TypeScriptAllowUnreachableCode>`                                                                                                             | ` `[`--allowUnreachableCode`](https://www.typescriptlang.org/tsconfig/#allowUnreachableCode)` `                         |     |\n| Disable error reporting for unreachable code.                                                                                                  |                                                                                                                         |     |\n| `<TypeScriptForceConsistentCasingInFileNames>`                                                                                                 | ` `[`--forceConsistentCasingInFileNames`](https://www.typescriptlang.org/tsconfig/#forceConsistentCasingInFileNames)` ` |     |\n| Ensure that casing is correct in imports.                                                                                                      |                                                                                                                         |     |\n| `<TypeScriptAllowSyntheticDefaultImports>`                                                                                                     | ` `[`--allowSyntheticDefaultImports`](https://www.typescriptlang.org/tsconfig/#allowSyntheticDefaultImports)` `         |     |\n| Allow 'import x from y' when a module doesn't have a default export.                                                                           |                                                                                                                         |     |\n| `<TypeScriptNoImplicitUseStrict>`                                                                                                              | ` `[`--noImplicitUseStrict`](https://www.typescriptlang.org/tsconfig/#noImplicitUseStrict)` `                           |     |\n| Disable adding 'use strict' directives in emitted JavaScript files.                                                                            |                                                                                                                         |     |\n| `<TypeScriptLib>`                                                                                                                              | ` `[`--lib`](https://www.typescriptlang.org/tsconfig/#lib)` `                                                           |     |\n| Specify a set of bundled library declaration files that describe the target runtime environment.                                               |                                                                                                                         |     |\n| `<TypeScriptBaseUrl>`                                                                                                                          | ` `[`--baseUrl`](https://www.typescriptlang.org/tsconfig/#baseUrl)` `                                                   |     |\n| Specify the base directory to resolve bare specifier module names.                                                                             |                                                                                                                         |     |\n| `<TypeScriptDeclarationDir>`                                                                                                                   | ` `[`--declarationDir`](https://www.typescriptlang.org/tsconfig/#declarationDir)` `                                     |     |\n| Specify the output directory for generated declaration files.                                                                                  |                                                                                                                         |     |\n| `<TypeScriptNoImplicitThis>`                                                                                                                   | ` `[`--noImplicitThis`](https://www.typescriptlang.org/tsconfig/#noImplicitThis)` `                                     |     |\n| Enable error reporting when `this` is given the type `any`.                                                                                    |                                                                                                                         |     |\n| `<TypeScriptSkipLibCheck>`                                                                                                                     | ` `[`--skipLibCheck`](https://www.typescriptlang.org/tsconfig/#skipLibCheck)` `                                         |     |\n| Skip type checking all .d.ts files.                                                                                                            |                                                                                                                         |     |\n| `<TypeScriptStrictNullChecks>`                                                                                                                 | ` `[`--strictNullChecks`](https://www.typescriptlang.org/tsconfig/#strictNullChecks)` `                                 |     |\n| When type checking, take into account `null` and `undefined`.                                                                                  |                                                                                                                         |     |\n| `<TypeScriptNoUnusedLocals>`                                                                                                                   | ` `[`--noUnusedLocals`](https://www.typescriptlang.org/tsconfig/#noUnusedLocals)` `                                     |     |\n| Enable error reporting when a local variables aren't read.                                                                                     |                                                                                                                         |     |\n| `<TypeScriptNoUnusedParameters>`                                                                                                               | ` `[`--noUnusedParameters`](https://www.typescriptlang.org/tsconfig/#noUnusedParameters)` `                             |     |\n| Raise an error when a function parameter isn't read                                                                                            |                                                                                                                         |     |\n| `<TypeScriptAlwaysStrict>`                                                                                                                     | ` `[`--alwaysStrict`](https://www.typescriptlang.org/tsconfig/#alwaysStrict)` `                                         |     |\n| Ensure 'use strict' is always emitted.                                                                                                         |                                                                                                                         |     |\n| `<TypeScriptImportHelpers>`                                                                                                                    | ` `[`--importHelpers`](https://www.typescriptlang.org/tsconfig/#importHelpers)` `                                       |     |\n| Allow importing helper functions from tslib once per project, instead of including them per-file.                                              |                                                                                                                         |     |\n| `<TypeScriptJSXFactory>`                                                                                                                       | ` `[`--jsxFactory`](https://www.typescriptlang.org/tsconfig/#jsxFactory)` `                                             |     |\n| Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'                                         |                                                                                                                         |     |\n| `<TypeScriptStripInternal>`                                                                                                                    | ` `[`--stripInternal`](https://www.typescriptlang.org/tsconfig/#stripInternal)` `                                       |     |\n| Disable emitting declarations that have `@internal` in their JSDoc comments.                                                                   |                                                                                                                         |     |\n| `<TypeScriptCheckJs>`                                                                                                                          | ` `[`--checkJs`](https://www.typescriptlang.org/tsconfig/#checkJs)` `                                                   |     |\n| Enable error reporting in type-checked JavaScript files.                                                                                       |                                                                                                                         |     |\n| `<TypeScriptDownlevelIteration>`                                                                                                               | ` `[`--downlevelIteration`](https://www.typescriptlang.org/tsconfig/#downlevelIteration)` `                             |     |\n| Emit more compliant, but verbose and less performant JavaScript for iteration.                                                                 |                                                                                                                         |     |\n| `<TypeScriptStrict>`                                                                                                                           | ` `[`--strict`](https://www.typescriptlang.org/tsconfig/#strict)` `                                                     |     |\n| Enable all strict type checking options.                                                                                                       |                                                                                                                         |     |\n| `<TypeScriptNoStrictGenericChecks>`                                                                                                            | ` `[`--noStrictGenericChecks`](https://www.typescriptlang.org/tsconfig/#noStrictGenericChecks)` `                       |     |\n| Disable strict checking of generic signatures in function types.                                                                               |                                                                                                                         |     |\n| `<TypeScriptPreserveSymlinks>`                                                                                                                 | ` `[`--preserveSymlinks`](https://www.typescriptlang.org/tsconfig/#preserveSymlinks)` `                                 |     |\n| Disable resolving symlinks to their realpath. This correlates to the same flag in node.                                                        |                                                                                                                         |     |\n| `<TypeScriptStrictFunctionTypes>`                                                                                                              | ` `[`--strictFunctionTypes`](https://www.typescriptlang.org/tsconfig/#strictFunctionTypes)` `                           |     |\n| When assigning functions, check to ensure parameters and the return values are subtype-compatible.                                             |                                                                                                                         |     |\n| `<TypeScriptStrictPropertyInitialization>`                                                                                                     | ` `[`--strictPropertyInitialization`](https://www.typescriptlang.org/tsconfig/#strictPropertyInitialization)` `         |     |\n| Check for class properties that are declared but not set in the constructor.                                                                   |                                                                                                                         |     |\n| `<TypeScriptESModuleInterop>`                                                                                                                  | ` `[`--esModuleInterop`](https://www.typescriptlang.org/tsconfig/#esModuleInterop)` `                                   |     |\n| Emit additional JavaScript to ease support for importing CommonJS modules. This enables `allowSyntheticDefaultImports` for type compatibility. |                                                                                                                         |     |\n| `<TypeScriptEmitDeclarationOnly>`                                                                                                              | ` `[`--emitDeclarationOnly`](https://www.typescriptlang.org/tsconfig/#emitDeclarationOnly)` `                           |     |\n| Only output d.ts files and not JavaScript files.                                                                                               |                                                                                                                         |     |\n| `<TypeScriptKeyofStringsOnly>`                                                                                                                 | ` `[`--keyofStringsOnly`](https://www.typescriptlang.org/tsconfig/#keyofStringsOnly)` `                                 |     |\n| Make keyof only return strings instead of string, numbers or symbols. Legacy option.                                                           |                                                                                                                         |     |\n| `<TypeScriptUseDefineForClassFields>`                                                                                                          | ` `[`--useDefineForClassFields`](https://www.typescriptlang.org/tsconfig/#useDefineForClassFields)` `                   |     |\n| Emit ECMAScript-standard-compliant class fields.                                                                                               |                                                                                                                         |     |\n| `<TypeScriptDeclarationMap>`                                                                                                                   | ` `[`--declarationMap`](https://www.typescriptlang.org/tsconfig/#declarationMap)` `                                     |     |\n| Create sourcemaps for d.ts files.                                                                                                              |                                                                                                                         |     |\n| `<TypeScriptResolveJsonModule>`                                                                                                                | ` `[`--resolveJsonModule`](https://www.typescriptlang.org/tsconfig/#resolveJsonModule)` `                               |     |\n| Enable importing .json files                                                                                                                   |                                                                                                                         |     |\n| `<TypeScriptStrictBindCallApply>`                                                                                                              | ` `[`--strictBindCallApply`](https://www.typescriptlang.org/tsconfig/#strictBindCallApply)` `                           |     |\n| Check that the arguments for `bind`, `call`, and `apply` methods match the original function.                                                  |                                                                                                                         |     |\n| `<TypeScriptNoEmitOnError>`                                                                                                                    | ` `[`--noEmitOnError`](https://www.typescriptlang.org/tsconfig/#noEmitOnError)` `                                       |     |\n| Disable emitting files if any type checking errors are reported.                                                                               |                                                                                                                         |     |\n\n### Additional Flags\n\nBecause the MSBuild system passes arguments directly to the TypeScript CLI, you can use the option `TypeScriptAdditionalFlags` to provide specific flags which don’t have a mapping above.\n\nFor example, this would turn on [`noPropertyAccessFromIndexSignature`](https://www.typescriptlang.org/tsconfig#noPropertyAccessFromIndexSignature):\n\n``` xml\n<TypeScriptAdditionalFlags> $(TypeScriptAdditionalFlags) --noPropertyAccessFromIndexSignature</TypeScriptAdditionalFlags>\n```\n\n### Debug and Release Builds\n\nYou can use PropertyGroup conditions to define different sets of configurations. For example, a common task is stripping comments and sourcemaps in production. In this example, we define a debug and release property group which have different TypeScript configurations:\n\n``` xml\n<PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\">\n  <TypeScriptRemoveComments>false</TypeScriptRemoveComments>\n  <TypeScriptSourceMap>true</TypeScriptSourceMap>\n</PropertyGroup>\n\n<PropertyGroup Condition=\"'$(Configuration)' == 'Release'\">\n  <TypeScriptRemoveComments>true</TypeScriptRemoveComments>\n  <TypeScriptSourceMap>false</TypeScriptSourceMap>\n</PropertyGroup>\n\n<Import\n    Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"\n    Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" />\n```\n\n### ToolsVersion\n\nThe value of `<TypeScriptToolsVersion>1.7</TypeScriptToolsVersion>` property in the project file identifies the compiler version to use to build (1.7 in this example). This allows a project to build against the same versions of the compiler on different machines.\n\nIf `TypeScriptToolsVersion` is not specified, the latest compiler version installed on the machine will be used to build.\n\nUsers using newer versions of TS, will see a prompt to upgrade their project on first load.\n\n### TypeScriptCompileBlocked\n\nIf you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set `<TypeScriptCompileBlocked>true</TypeScriptCompileBlocked>` in your project. This should give you all the editing support, but not the build when you hit F5.\n\n### TypeScriptEnableIncrementalMSBuild (TypeScript 4.2 Beta and later)\n\nBy default, MSBuild will attempt to only run the TypeScript compiler when the project’s source files have been updated since the last compilation. However, if this behavior is causing issues, such as when TypeScript’s [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) option is enabled, set `<TypeScriptEnableIncrementalMSBuild>false</TypeScriptEnableIncrementalMSBuild>` to ensure the TypeScript compiler is invoked with every run of MSBuild.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html)"
- name: composite
  id: tsconfig#composite-config
  summary: The composite option enforces certain constraints which make it possible for build tools (including TypeScript itself, under --build mode) to quickly determine if a project has been built yet
  belongs_to: TSConfig Reference
  description: |-
    ### Composite - `composite`

    The `composite` option enforces certain constraints which make it possible for build tools (including TypeScript itself, under `--build` mode) to quickly determine if a project has been built yet.

    When this setting is on:

    - The [`rootDir`](#rootDir) setting, if not explicitly set, defaults to the directory containing the `tsconfig.json` file.

    - All implementation files must be matched by an [`include`](#include) pattern or listed in the [`files`](#files) array. If this constraint is violated, `tsc` will inform you which files weren’t specified.

    - [`declaration`](#declaration) defaults to `true`

    You can find documentation on TypeScript projects in [the handbook](docs/handbook/project-references).

    - Related:
      - [`incremental`](#incremental)

      - [`tsBuildInfoFile`](#tsBuildInfoFile)

    - Released:

      [3.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html)
- name: composite
  id: tsconfig/index#composite-config
  summary: The composite option enforces certain constraints which make it possible for build tools (including TypeScript itself, under --build mode) to quickly determine if a project has been built yet
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Composite - `composite`

    The `composite` option enforces certain constraints which make it possible for build tools (including TypeScript itself, under `--build` mode) to quickly determine if a project has been built yet.

    When this setting is on:

    - The [`rootDir`](#rootDir) setting, if not explicitly set, defaults to the directory containing the `tsconfig.json` file.

    - All implementation files must be matched by an [`include`](#include) pattern or listed in the [`files`](#files) array. If this constraint is violated, `tsc` will inform you which files weren’t specified.

    - [`declaration`](#declaration) defaults to `true`

    You can find documentation on TypeScript projects in [the handbook](../docs/handbook/project-references).

    - Related:
      - [`incremental`](#incremental)

      - [`tsBuildInfoFile`](#tsBuildInfoFile)

    - Released:

      [3.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html)
- name: Conditional Types
  id: 2/conditional-types
  summary: At the heart of most useful programs, we have to make decisions based on input
  description: "# Conditional Types\n\nAt the heart of most useful programs, we have to make decisions based on input. JavaScript programs are no different, but given the fact that values can be easily introspected, those decisions are also based on the types of the inputs. *Conditional types* help describe the relation between the types of inputs and outputs.\n\n``` ts\ninterface Animal {\n  live(): void;\n}\ninterface Dog extends Animal {\n  woof(): void;\n}\n \ntype Example1 = Dog extends Animal ? number : string;\n \ntype Example2 = RegExp extends Animal ? number : string;\n```\n\nConditional types take a form that looks a little like conditional expressions (`condition ? trueExpression : falseExpression`) in JavaScript:\n\n``` ts\n  SomeType extends OtherType ? TrueType : FalseType;\n```\n\nWhen the type on the left of the `extends` is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).\n\nFrom the examples above, conditional types might not immediately seem useful - we can tell ourselves whether or not `Dog extends Animal` and pick `number` or `string`! But the power of conditional types comes from using them with generics.\n\nFor example, let’s take the following `createLabel` function:\n\n``` ts\ninterface IdLabel {\n  id: number /* some fields */;\n}\ninterface NameLabel {\n  name: string /* other fields */;\n}\n \nfunction createLabel(id: number): IdLabel;\nfunction createLabel(name: string): NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel {\n  throw \"unimplemented\";\n}\n```\n\nThese overloads for createLabel describe a single JavaScript function that makes a choice based on the types of its inputs. Note a few things:\n\n1.  If a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.\n2.  We have to create three overloads: one for each case when we’re *sure* of the type (one for `string` and one for `number`), and one for the most general case (taking a `string | number`). For every new type `createLabel` can handle, the number of overloads grows exponentially.\n\nInstead, we can encode that logic in a conditional type:\n\n``` ts\ntype NameOrId<T extends number | string> = T extends number\n  ? IdLabel\n  : NameLabel;\n```\n\nWe can then use that conditional type to simplify our overloads down to a single function with no overloads.\n\n``` ts\nfunction createLabel<T extends number | string>(idOrName: T): NameOrId<T> {\n  throw \"unimplemented\";\n}\n \nlet a = createLabel(\"typescript\");\n \nlet b = createLabel(2.8);\n \nlet c = createLabel(Math.random() ? \"hello\" : 42);\n```\n\n### Conditional Type Constraints\n\nOften, the checks in a conditional type will provide us with some new information. Just like narrowing with type guards can give us a more specific type, the true branch of a conditional type will further constrain generics by the type we check against.\n\nFor example, let’s take the following:\n\n``` ts\ntype MessageOf<T> = T[\"message\"];\n```\n\nIn this example, TypeScript errors because `T` isn’t known to have a property called `message`. We could constrain `T`, and TypeScript would no longer complain:\n\n``` ts\ntype MessageOf<T extends { message: unknown }> = T[\"message\"];\n \ninterface Email {\n  message: string;\n}\n \ntype EmailMessageContents = MessageOf<Email>;\n```\n\nHowever, what if we wanted `MessageOf` to take any type, and default to something like `never` if a `message` property isn’t available? We can do this by moving the constraint out and introducing a conditional type:\n\n``` ts\ntype MessageOf<T> = T extends { message: unknown } ? T[\"message\"] : never;\n \ninterface Email {\n  message: string;\n}\n \ninterface Dog {\n  bark(): void;\n}\n \ntype EmailMessageContents = MessageOf<Email>;\n \ntype DogMessageContents = MessageOf<Dog>;\n```\n\nWithin the true branch, TypeScript knows that `T` *will* have a `message` property.\n\nAs another example, we could also write a type called `Flatten` that flattens array types to their element types, but leaves them alone otherwise:\n\n``` ts\ntype Flatten<T> = T extends any[] ? T[number] : T;\n \n// Extracts out the element type.\ntype Str = Flatten<string[]>;\n \n// Leaves the type alone.\ntype Num = Flatten<number>;\n```\n\nWhen `Flatten` is given an array type, it uses an indexed access with `number` to fetch out `string[]`’s element type. Otherwise, it just returns the type it was given.\n\n### Inferring Within Conditional Types\n\nWe just found ourselves using conditional types to apply constraints and then extract out types. This ends up being such a common operation that conditional types make it easier.\n\nConditional types provide us with a way to infer from types we compare against in the true branch using the `infer` keyword. For example, we could have inferred the element type in `Flatten` instead of fetching it out “manually” with an indexed access type:\n\n``` ts\ntype Flatten<Type> = Type extends Array<infer Item> ? Item : Type;\n```\n\nHere, we used the `infer` keyword to declaratively introduce a new generic type variable named `Item` instead of specifying how to retrieve the element type of `Type` within the true branch. This frees us from having to think about how to dig through and probing apart the structure of the types we’re interested in.\n\nWe can write some useful helper type aliases using the `infer` keyword. For example, for simple cases, we can extract the return type out from function types:\n\n``` ts\ntype GetReturnType<Type> = Type extends (...args: never[]) => infer Return\n  ? Return\n  : never;\n \ntype Num = GetReturnType<() => number>;\n \ntype Str = GetReturnType<(x: string) => string>;\n \ntype Bools = GetReturnType<(a: boolean, b: boolean) => boolean[]>;\n```\n\nWhen inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the *last* signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.\n\n``` ts\ndeclare function stringOrNum(x: string): number;\ndeclare function stringOrNum(x: number): string;\ndeclare function stringOrNum(x: string | number): string | number;\n \ntype T1 = ReturnType<typeof stringOrNum>;\n```\n\n## Distributive Conditional Types\n\nWhen conditional types act on a generic type, they become *distributive* when given a union type. For example, take the following:\n\n``` ts\ntype ToArray<Type> = Type extends any ? Type[] : never;\n```\n\nIf we plug a union type into `ToArray`, then the conditional type will be applied to each member of that union.\n\n``` ts\ntype ToArray<Type> = Type extends any ? Type[] : never;\n \ntype StrArrOrNumArr = ToArray<string | number>;\n```\n\nWhat happens here is that `ToArray` distributes on:\n\n``` ts\n  string | number;\n```\n\nand maps over each member type of the union, to what is effectively:\n\n``` ts\n  ToArray<string> | ToArray<number>;\n```\n\nwhich leaves us with:\n\n``` ts\n  string[] | number[];\n```\n\nTypically, distributivity is the desired behavior. To avoid that behavior, you can surround each side of the `extends` keyword with square brackets.\n\n``` ts\ntype ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;\n \n// 'ArrOfStrOrNum' is no longer a union.\ntype ArrOfStrOrNum = ToArrayNonDist<string | number>;\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/conditional-types.html](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)"
- name: 'Conditional Types: Distributive Conditional Types'
  id: 2/conditional-types#distributive-conditional-types
  summary: When conditional types act on a generic type, they become distributive when given a union type
  belongs_to: Conditional Types
  description: "## Distributive Conditional Types\n\nWhen conditional types act on a generic type, they become *distributive* when given a union type. For example, take the following:\n\n``` ts\ntype ToArray<Type> = Type extends any ? Type[] : never;\n```\n\nIf we plug a union type into `ToArray`, then the conditional type will be applied to each member of that union.\n\n``` ts\ntype ToArray<Type> = Type extends any ? Type[] : never;\n \ntype StrArrOrNumArr = ToArray<string | number>;\n```\n\nWhat happens here is that `ToArray` distributes on:\n\n``` ts\n  string | number;\n```\n\nand maps over each member type of the union, to what is effectively:\n\n``` ts\n  ToArray<string> | ToArray<number>;\n```\n\nwhich leaves us with:\n\n``` ts\n  string[] | number[];\n```\n\nTypically, distributivity is the desired behavior. To avoid that behavior, you can surround each side of the `extends` keyword with square brackets.\n\n``` ts\ntype ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;\n \n// 'ArrOfStrOrNum' is no longer a union.\ntype ArrOfStrOrNum = ToArrayNonDist<string | number>;\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/conditional-types.html](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)"
- name: Configuring Watch
  id: configuring-watch
  summary: As of TypeScript 3.8 and onward, the Typescript compiler exposes configuration which controls how it watches files and directories
  description: "# Configuring Watch\n\nAs of TypeScript 3.8 and onward, the Typescript compiler exposes configuration which controls how it watches files and directories. Prior to this version, configuration required the use of environment variables which are still available.\n\n## Background\n\nThe `--watch` implementation of the compiler relies on Node’s `fs.watch` and `fs.watchFile`. Each of these methods has pros and cons.\n\n`fs.watch` relies on file system events to broadcast changes in the watched files and directories. The implementation of this command is OS dependent and unreliable - on many operating systems, it does not work as expected. Additionally, some operating systems limit the number of watches which can exist simultaneously (e.g. some flavors of [Linux](https://man7.org/linux/man-pages/man7/inotify.7.html)). Heavy use of `fs.watch` in large codebases has the potential to exceed these limits and result in undesirable behavior. However, because this implementation relies on an events-based model, CPU use is comparatively light. The compiler typically uses `fs.watch` to watch directories (e.g. source directories included by compiler configuration files and directories in which module resolution failed, among others). TypeScript uses these to augment potential failures in individual file watchers. However, there is a key limitation of this strategy: recursive watching of directories is supported on Windows and macOS, but not on Linux. This suggested a need for additional strategies for file and directory watching.\n\n`fs.watchFile` uses polling and thus costs CPU cycles. However, `fs.watchFile` is by far the most reliable mechanism available to subscribe to the events from files and directories of interest. Under this strategy, the TypeScript compiler typically uses `fs.watchFile` to watch source files, config files, and files which appear missing based on reference statements. This means that the degree to which CPU usage will be higher when using `fs.watchFile` depends directly on number of files watched in the codebase.\n\n## Configuring file watching using a `tsconfig.json`\n\nThe suggested method of configuring watch behavior is through the new `watchOptions` section of `tsconfig.json`. We provide an example configuration below. See the following section for detailed descriptions of the settings available.\n\n``` typescript\n{\n  // Some typical compiler options\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"moduleResolution\": \"node\"\n    // ...\n  },\n\n  // NEW: Options for file/directory watching\n  \"watchOptions\": {\n    // Use native file system events for files and directories\n    \"watchFile\": \"useFsEvents\",\n    \"watchDirectory\": \"useFsEvents\",\n\n    // Poll files for updates more frequently\n    // when they're updated a lot.\n    \"fallbackPolling\": \"dynamicPriority\",\n\n    // Don't coalesce watch notification\n    \"synchronousWatchDirectory\": true,\n\n    // Finally, two additional settings for reducing the amount of possible\n    // files to track  work from these directories\n    \"excludeDirectories\": [\"**/node_modules\", \"_build\"],\n    \"excludeFiles\": [\"build/fileWhichChangesOften.ts\"]\n  }\n}\n```\n\nFor further details, see [the release notes for Typescript 3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#better-directory-watching-on-linux-and-watchoptions).\n\n## Configuring file watching using environment variable `TSC_WATCHFILE`\n\n| Option                                  | Description                                                                                                                                                                                |\n|-----------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `PriorityPollingInterval`               | Use `fs.watchFile`, but use different polling intervals for source files, config files and missing files                                                                                   |\n| `DynamicPriorityPolling`                | Use a dynamic queue where frequently modified files are polled at shorter intervals, and unchanged files are polled less frequently                                                        |\n| `UseFsEvents`                           | Use `fs.watch`. On operating systems that limit the number of active watches, fall back to `fs.watchFile` when a watcher fails to be created.                                              |\n| `UseFsEventsWithFallbackDynamicPolling` | Use `fs.watch`. On operating systems that limit the number of active watches, fall back to dynamic polling queues (as explained in `DynamicPriorityPolling`)                               |\n| `UseFsEventsOnParentDirectory`          | Use `fs.watch` on the *parent* directories of included files (yielding a compromise that results in lower CPU usage than pure `fs.watchFile` but potentially lower accuracy).              |\n| default (no value specified)            | If environment variable `TSC_NONPOLLING_WATCHER` is set to true, use `UseFsEventsOnParentDirectory`. Otherwise, watch files using `fs.watchFile` with `250ms` as the timeout for any file. |\n\n## Configuring directory watching using environment variable `TSC_WATCHDIRECTORY`\n\nFor directory watches on platforms which don’t natively allow recursive directory watching (i.e. non macOS and Windows operating systems) is supported through recursively creating directory watchers for each child directory using different options selected by `TSC_WATCHDIRECTORY`.\n\n**NOTE:** On platforms which support native recursive directory watching, the value of `TSC_WATCHDIRECTORY` is ignored.\n\n| Option                                          | Description                                                                                |\n|-------------------------------------------------|--------------------------------------------------------------------------------------------|\n| `RecursiveDirectoryUsingFsWatchFile`            | Use `fs.watchFile` to watch included directories and child directories.                    |\n| `RecursiveDirectoryUsingDynamicPriorityPolling` | Use a dynamic polling queue to poll changes to included directories and child directories. |\n| default (no value specified)                    | Use `fs.watch` to watch included directories and child directories.                        |\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/configuring-watch.html](https://www.typescriptlang.org/docs/handbook/configuring-watch.html)"
- name: 'Configuring Watch: Background'
  id: configuring-watch#background
  summary: The --watch implementation of the compiler relies on Node’s fs.watch and fs.watchFile
  belongs_to: Configuring Watch
  description: |-
    ## Background

    The `--watch` implementation of the compiler relies on Node’s `fs.watch` and `fs.watchFile`. Each of these methods has pros and cons.

    `fs.watch` relies on file system events to broadcast changes in the watched files and directories. The implementation of this command is OS dependent and unreliable - on many operating systems, it does not work as expected. Additionally, some operating systems limit the number of watches which can exist simultaneously (e.g. some flavors of [Linux](https://man7.org/linux/man-pages/man7/inotify.7.html)). Heavy use of `fs.watch` in large codebases has the potential to exceed these limits and result in undesirable behavior. However, because this implementation relies on an events-based model, CPU use is comparatively light. The compiler typically uses `fs.watch` to watch directories (e.g. source directories included by compiler configuration files and directories in which module resolution failed, among others). TypeScript uses these to augment potential failures in individual file watchers. However, there is a key limitation of this strategy: recursive watching of directories is supported on Windows and macOS, but not on Linux. This suggested a need for additional strategies for file and directory watching.

    `fs.watchFile` uses polling and thus costs CPU cycles. However, `fs.watchFile` is by far the most reliable mechanism available to subscribe to the events from files and directories of interest. Under this strategy, the TypeScript compiler typically uses `fs.watchFile` to watch source files, config files, and files which appear missing based on reference statements. This means that the degree to which CPU usage will be higher when using `fs.watchFile` depends directly on number of files watched in the codebase.
- name: 'Configuring Watch: Configuring directory watching using environment variable TSC_WATCHDIRECTORY'
  id: configuring-watch#configuring-directory-watching-using-environment-variable-tsc_watchdirectory
  summary: For directory watches on platforms which don’t natively allow recursive directory watching (i.e
  belongs_to: Configuring Watch
  description: "## Configuring directory watching using environment variable `TSC_WATCHDIRECTORY`\n\nFor directory watches on platforms which don’t natively allow recursive directory watching (i.e. non macOS and Windows operating systems) is supported through recursively creating directory watchers for each child directory using different options selected by `TSC_WATCHDIRECTORY`.\n\n**NOTE:** On platforms which support native recursive directory watching, the value of `TSC_WATCHDIRECTORY` is ignored.\n\n| Option                                          | Description                                                                                |\n|-------------------------------------------------|--------------------------------------------------------------------------------------------|\n| `RecursiveDirectoryUsingFsWatchFile`            | Use `fs.watchFile` to watch included directories and child directories.                    |\n| `RecursiveDirectoryUsingDynamicPriorityPolling` | Use a dynamic polling queue to poll changes to included directories and child directories. |\n| default (no value specified)                    | Use `fs.watch` to watch included directories and child directories.                        |\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/configuring-watch.html](https://www.typescriptlang.org/docs/handbook/configuring-watch.html)"
- name: 'Configuring Watch: Configuring file watching using a tsconfig.json'
  id: configuring-watch#configuring-file-watching-using-a-tsconfigjson
  summary: The suggested method of configuring watch behavior is through the new watchOptions section of tsconfig.json
  belongs_to: Configuring Watch
  description: |-
    ## Configuring file watching using a `tsconfig.json`

    The suggested method of configuring watch behavior is through the new `watchOptions` section of `tsconfig.json`. We provide an example configuration below. See the following section for detailed descriptions of the settings available.

    ``` typescript
    {
      // Some typical compiler options
      "compilerOptions": {
        "target": "es2020",
        "moduleResolution": "node"
        // ...
      },

      // NEW: Options for file/directory watching
      "watchOptions": {
        // Use native file system events for files and directories
        "watchFile": "useFsEvents",
        "watchDirectory": "useFsEvents",

        // Poll files for updates more frequently
        // when they're updated a lot.
        "fallbackPolling": "dynamicPriority",

        // Don't coalesce watch notification
        "synchronousWatchDirectory": true,

        // Finally, two additional settings for reducing the amount of possible
        // files to track  work from these directories
        "excludeDirectories": ["**/node_modules", "_build"],
        "excludeFiles": ["build/fileWhichChangesOften.ts"]
      }
    }
    ```

    For further details, see [the release notes for Typescript 3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#better-directory-watching-on-linux-and-watchoptions).
- name: 'Configuring Watch: Configuring file watching using environment variable TSC_WATCHFILE'
  id: configuring-watch#configuring-file-watching-using-environment-variable-tsc_watchfile
  summary: null
  belongs_to: Configuring Watch
  description: |-
    ## Configuring file watching using environment variable `TSC_WATCHFILE`

    | Option                                  | Description                                                                                                                                                                                |
    |-----------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | `PriorityPollingInterval`               | Use `fs.watchFile`, but use different polling intervals for source files, config files and missing files                                                                                   |
    | `DynamicPriorityPolling`                | Use a dynamic queue where frequently modified files are polled at shorter intervals, and unchanged files are polled less frequently                                                        |
    | `UseFsEvents`                           | Use `fs.watch`. On operating systems that limit the number of active watches, fall back to `fs.watchFile` when a watcher fails to be created.                                              |
    | `UseFsEventsWithFallbackDynamicPolling` | Use `fs.watch`. On operating systems that limit the number of active watches, fall back to dynamic polling queues (as explained in `DynamicPriorityPolling`)                               |
    | `UseFsEventsOnParentDirectory`          | Use `fs.watch` on the *parent* directories of included files (yielding a compromise that results in lower CPU usage than pure `fs.watchFile` but potentially lower accuracy).              |
    | default (no value specified)            | If environment variable `TSC_NONPOLLING_WATCHER` is set to true, use `UseFsEventsOnParentDirectory`. Otherwise, watch files using `fs.watchFile` with `250ms` as the timeout for any file. |
- name: Consumption
  id: declaration-files/consumption
  summary: Getting type declarations requires no tools apart from npm
  description: "# Consumption\n\n## Downloading\n\nGetting type declarations requires no tools apart from npm.\n\nAs an example, getting the declarations for a library like lodash takes nothing more than the following command\n\n``` shell\nnpm install --save-dev @types/lodash\n```\n\nIt is worth noting that if the npm package already includes its declaration file as described in [Publishing](publishing), downloading the corresponding `@types` package is not needed.\n\n## Consuming\n\nFrom there you’ll be able to use lodash in your TypeScript code with no fuss. This works for both modules and global code.\n\nFor example, once you’ve `npm install`-ed your type declarations, you can use imports and write\n\n``` ts\nimport * as _ from \"lodash\";\n_.padStart(\"Hello TypeScript!\", 20, \" \");\n```\n\nor if you’re not using modules, you can just use the global variable `_`.\n\n``` ts\n_.padStart(\"Hello TypeScript!\", 20, \" \");\n```\n\n## Searching\n\nFor the most part, type declaration packages should always have the same name as the package name on `npm`, but prefixed with `@types/`, but if you need, you can use the [Yarn package search](https://yarnpkg.com/) to find the package for your favorite library.\n\n> Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it. Please see the DefinitelyTyped [contribution guidelines page](https://definitelytyped.org/guides/contributing.html) for details.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html](https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html)"
- name: 'Consumption: Consuming'
  id: declaration-files/consumption#consuming
  summary: From there you’ll be able to use lodash in your TypeScript code with no fuss
  belongs_to: Consumption
  description: |-
    ## Consuming

    From there you’ll be able to use lodash in your TypeScript code with no fuss. This works for both modules and global code.

    For example, once you’ve `npm install`-ed your type declarations, you can use imports and write

    ``` ts
    import * as _ from "lodash";
    _.padStart("Hello TypeScript!", 20, " ");
    ```

    or if you’re not using modules, you can just use the global variable `_`.

    ``` ts
    _.padStart("Hello TypeScript!", 20, " ");
    ```
- name: 'Consumption: Downloading'
  id: declaration-files/consumption#downloading
  summary: Getting type declarations requires no tools apart from npm
  belongs_to: Consumption
  description: |-
    ## Downloading

    Getting type declarations requires no tools apart from npm.

    As an example, getting the declarations for a library like lodash takes nothing more than the following command

    ``` shell
    npm install --save-dev @types/lodash
    ```

    It is worth noting that if the npm package already includes its declaration file as described in [Publishing](publishing), downloading the corresponding `@types` package is not needed.
- name: 'Consumption: Searching'
  id: declaration-files/consumption#searching
  summary: For the most part, type declaration packages should always have the same name as the package name on npm, but prefixed with @types/, but if you need, you can use the Yarn package search to find the package for your favorite library
  belongs_to: Consumption
  description: "## Searching\n\nFor the most part, type declaration packages should always have the same name as the package name on `npm`, but prefixed with `@types/`, but if you need, you can use the [Yarn package search](https://yarnpkg.com/) to find the package for your favorite library.\n\n> Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it. Please see the DefinitelyTyped [contribution guidelines page](https://definitelytyped.org/guides/contributing.html) for details.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html](https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html)"
- name: Creating .d.ts Files from .js files
  id: declaration-files/dts-from-js
  summary: With TypeScript 3.7, TypeScript added support for generating .d.ts files from JavaScript using JSDoc syntax
  description: "# Creating .d.ts Files from .js files\n\n[With TypeScript 3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#--declaration-and---allowjs), TypeScript added support for generating .d.ts files from JavaScript using JSDoc syntax.\n\nThis set up means you can own the editor experience of TypeScript-powered editors without porting your project to TypeScript, or having to maintain .d.ts files in your codebase. TypeScript supports most JSDoc tags, you can find [the reference here](../type-checking-javascript-files#supported-jsdoc).\n\n## Setting up your Project to emit .d.ts files\n\nTo add creation of .d.ts files in your project, you will need to do up-to four steps:\n\n- Add TypeScript to your dev dependencies\n- Add a `tsconfig.json` to configure TypeScript\n- Run the TypeScript compiler to generate the corresponding d.ts files for JS files\n- (optional) Edit your package.json to reference the types\n\n### Adding TypeScript\n\nYou can learn how to do this in our [installation page](https://www.typescriptlang.org/download).\n\n### TSConfig\n\nThe TSConfig is a jsonc file which configures both your compiler flags, and declare where to find files. In this case, you will want a file like the following:\n\n``` typescript\n{\n  // Change this to match your project\n  \"include\": [\"src/**/*\"],\n\n  \"compilerOptions\": {\n    // Tells TypeScript to read JS files, as\n    // normally they are ignored as source files\n    \"allowJs\": true,\n    // Generate d.ts files\n    \"declaration\": true,\n    // This compiler run should\n    // only output d.ts files\n    \"emitDeclarationOnly\": true,\n    // Types should go into this directory.\n    // Removing this would place the .d.ts files\n    // next to the .js files\n    \"outDir\": \"dist\",\n    // go to js file when using IDE functions like\n    // \"Go to Definition\" in VSCode\n    \"declarationMap\": true\n  }\n}\n```\n\nYou can learn more about the options in the [tsconfig reference](https://www.typescriptlang.org/tsconfig). An alternative to using a TSConfig file is the CLI, this is the same behavior as a CLI command.\n\n``` shell\nnpx -p typescript tsc src/**/*.js --declaration --allowJs --emitDeclarationOnly --outDir types\n```\n\n## Run the compiler\n\nYou can learn how to do this in our [installation page](https://www.typescriptlang.org/download). You want to make sure these files are included in your package if you have the files in your project’s `.gitignore`.\n\n## Editing the package.json\n\nTypeScript replicates the node resolution for modules in a `package.json`, with an additional step for finding .d.ts files. Roughly, the resolution will first check the optional `types` field, then the `\"main\"` field, and finally will try `index.d.ts` in the root.\n\n| Package.json              | Location of default .d.ts      |\n|:--------------------------|:-------------------------------|\n| No “types” field          | checks “main”, then index.d.ts |\n| “types”: “main.d.ts”      | main.d.ts                      |\n| “types”: “./dist/main.js” | ./dist/main.d.ts               |\n\nIf absent, then “main” is used\n\n| Package.json             | Location of default .d.ts |\n|:-------------------------|:--------------------------|\n| No “main” field          | index.d.ts                |\n| “main”:“index.js”        | index.d.ts                |\n| “main”:“./dist/index.js” | ./dist/index.d.ts         |\n\n## Tips\n\nIf you’d like to write tests for your .d.ts files, try [tsd](https://github.com/SamVerschueren/tsd).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html](https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html)"
- name: 'Creating .d.ts Files from .js files: Editing the package.json'
  id: declaration-files/dts-from-js#editing-the-packagejson
  summary: TypeScript replicates the node resolution for modules in a package.json, with an additional step for finding .d.ts files
  belongs_to: Creating .d.ts Files from .js files
  description: |-
    ## Editing the package.json

    TypeScript replicates the node resolution for modules in a `package.json`, with an additional step for finding .d.ts files. Roughly, the resolution will first check the optional `types` field, then the `"main"` field, and finally will try `index.d.ts` in the root.

    | Package.json              | Location of default .d.ts      |
    |:--------------------------|:-------------------------------|
    | No “types” field          | checks “main”, then index.d.ts |
    | “types”: “main.d.ts”      | main.d.ts                      |
    | “types”: “./dist/main.js” | ./dist/main.d.ts               |

    If absent, then “main” is used

    | Package.json             | Location of default .d.ts |
    |:-------------------------|:--------------------------|
    | No “main” field          | index.d.ts                |
    | “main”:“index.js”        | index.d.ts                |
    | “main”:“./dist/index.js” | ./dist/index.d.ts         |
- name: 'Creating .d.ts Files from .js files: Run the compiler'
  id: declaration-files/dts-from-js#run-the-compiler
  summary: You can learn how to do this in our installation page
  belongs_to: Creating .d.ts Files from .js files
  description: |-
    ## Run the compiler

    You can learn how to do this in our [installation page](https://www.typescriptlang.org/download). You want to make sure these files are included in your package if you have the files in your project’s `.gitignore`.
- name: 'Creating .d.ts Files from .js files: Setting up your Project to emit .d.ts files'
  id: declaration-files/dts-from-js#setting-up-your-project-to-emit-dts-files
  summary: You can learn how to do this in our installation page
  belongs_to: Creating .d.ts Files from .js files
  description: |-
    ## Setting up your Project to emit .d.ts files

    To add creation of .d.ts files in your project, you will need to do up-to four steps:

    - Add TypeScript to your dev dependencies
    - Add a `tsconfig.json` to configure TypeScript
    - Run the TypeScript compiler to generate the corresponding d.ts files for JS files
    - (optional) Edit your package.json to reference the types

    ### Adding TypeScript

    You can learn how to do this in our [installation page](https://www.typescriptlang.org/download).

    ### TSConfig

    The TSConfig is a jsonc file which configures both your compiler flags, and declare where to find files. In this case, you will want a file like the following:

    ``` typescript
    {
      // Change this to match your project
      "include": ["src/**/*"],

      "compilerOptions": {
        // Tells TypeScript to read JS files, as
        // normally they are ignored as source files
        "allowJs": true,
        // Generate d.ts files
        "declaration": true,
        // This compiler run should
        // only output d.ts files
        "emitDeclarationOnly": true,
        // Types should go into this directory.
        // Removing this would place the .d.ts files
        // next to the .js files
        "outDir": "dist",
        // go to js file when using IDE functions like
        // "Go to Definition" in VSCode
        "declarationMap": true
      }
    }
    ```

    You can learn more about the options in the [tsconfig reference](https://www.typescriptlang.org/tsconfig). An alternative to using a TSConfig file is the CLI, this is the same behavior as a CLI command.

    ``` shell
    npx -p typescript tsc src/**/*.js --declaration --allowJs --emitDeclarationOnly --outDir types
    ```
- name: 'Creating .d.ts Files from .js files: Tips'
  id: declaration-files/dts-from-js#tips
  summary: If you’d like to write tests for your .d.ts files, try tsd
  belongs_to: Creating .d.ts Files from .js files
  description: "## Tips\n\nIf you’d like to write tests for your .d.ts files, try [tsd](https://github.com/SamVerschueren/tsd).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html](https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html)"
- name: Creating Types from Types
  id: 2/types-from-types
  summary: TypeScript’s type system is very powerful because it allows expressing types in terms of other types
  description: "# Creating Types from Types\n\nTypeScript’s type system is very powerful because it allows expressing types *in terms of other types*.\n\nThe simplest form of this idea is generics. Additionally, we have a wide variety of *type operators* available to use. It’s also possible to express types in terms of *values* that we already have.\n\nBy combining various type operators, we can express complex operations and values in a succinct, maintainable way. In this section we’ll cover ways to express a new type in terms of an existing type or value.\n\n- [Generics](generics) - Types which take parameters\n- [Keyof Type Operator](keyof-types) - Using the `keyof` operator to create new types\n- [Typeof Type Operator](typeof-types) - Using the `typeof` operator to create new types\n- [Indexed Access Types](indexed-access-types) - Using `Type['a']` syntax to access a subset of a type\n- [Conditional Types](conditional-types) - Types which act like if statements in the type system\n- [Mapped Types](mapped-types) - Creating types by mapping each property in an existing type\n- [Template Literal Types](template-literal-types) - Mapped types which change properties via template literal strings\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/types-from-types.html](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)"
- name: customConditions
  id: tsconfig/index#customConditions-config
  summary: --customConditions takes a list of additional conditions that should succeed when TypeScript resolves from an exports or imports field of a package.json
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Custom Conditions - `customConditions`

    `--customConditions` takes a list of additional [conditions](https://nodejs.org/api/packages.html#nested-conditions) that should succeed when TypeScript resolves from an [`exports`](https://nodejs.org/api/packages.html#exports) or [`imports`](https://nodejs.org/api/packages.html#imports) field of a `package.json`. These conditions are added to whatever existing conditions a resolver will use by default.

    For example, when this field is set in a `tsconfig.json` as so:

    ``` jsonc
    {
      "compilerOptions": {
        "target": "es2022",
        "moduleResolution": "bundler",
        "customConditions": ["my-condition"]
      }
    }
    ```

    Any time an `exports` or `imports` field is referenced in `package.json`, TypeScript will consider conditions called `my-condition`.

    So when importing from a package with the following `package.json`

    ``` jsonc
    {
      // ...
      "exports": {
        ".": {
          "my-condition": "./foo.mjs",
          "node": "./bar.mjs",
          "import": "./baz.mjs",
          "require": "./biz.mjs"
        }
      }
    }
    ```

    TypeScript will try to look for files corresponding to `foo.mjs`.

    This field is only valid under the `node16`, `nodenext`, and `bundler` options for [`--moduleResolution`](#moduleResolution).

    - Related:
      - [`moduleResolution`](#moduleResolution)

      - [`resolvePackageJsonExports`](#resolvePackageJsonExports)

      - [`resolvePackageJsonImports`](#resolvePackageJsonImports)
- name: customConditions
  id: tsconfig#customConditions-config
  summary: --customConditions takes a list of additional conditions that should succeed when TypeScript resolves from an exports or imports field of a package.json
  belongs_to: TSConfig Reference
  description: |-
    ### Custom Conditions - `customConditions`

    `--customConditions` takes a list of additional [conditions](https://nodejs.org/api/packages.html#nested-conditions) that should succeed when TypeScript resolves from an [`exports`](https://nodejs.org/api/packages.html#exports) or [`imports`](https://nodejs.org/api/packages.html#imports) field of a `package.json`. These conditions are added to whatever existing conditions a resolver will use by default.

    For example, when this field is set in a `tsconfig.json` as so:

    ``` jsonc
    {
      "compilerOptions": {
        "target": "es2022",
        "moduleResolution": "bundler",
        "customConditions": ["my-condition"]
      }
    }
    ```

    Any time an `exports` or `imports` field is referenced in `package.json`, TypeScript will consider conditions called `my-condition`.

    So when importing from a package with the following `package.json`

    ``` jsonc
    {
      // ...
      "exports": {
        ".": {
          "my-condition": "./foo.mjs",
          "node": "./bar.mjs",
          "import": "./baz.mjs",
          "require": "./biz.mjs"
        }
      }
    }
    ```

    TypeScript will try to look for files corresponding to `foo.mjs`.

    This field is only valid under the `node16`, `nodenext`, and `bundler` options for [`--moduleResolution`](#moduleResolution).

    - Related:
      - [`moduleResolution`](#moduleResolution)

      - [`resolvePackageJsonExports`](#resolvePackageJsonExports)

      - [`resolvePackageJsonImports`](#resolvePackageJsonImports)
- name: declaration
  id: tsconfig/index#declaration-config
  summary: Generate .d.ts files for every TypeScript or JavaScript file inside your project
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Declaration - `declaration`

    Generate `.d.ts` files for every TypeScript or JavaScript file inside your project. These `.d.ts` files are type definition files which describe the external API of your module. With `.d.ts` files, tools like TypeScript can provide intellisense and accurate types for un-typed code.

    When `declaration` is set to `true`, running the compiler with this TypeScript code:

    ``` ts
    export let helloWorld = "hi";
    ```

    Will generate an `index.js` file like this:

    ``` ts
    export let helloWorld = "hi";
     
    ```

    With a corresponding `helloWorld.d.ts`:

    ``` ts
    export declare let helloWorld: string;
     
    ```

    When working with `.d.ts` files for JavaScript files you may want to use [`emitDeclarationOnly`](#emitDeclarationOnly) or use [`outDir`](#outDir) to ensure that the JavaScript files are not overwritten.

    - Default:

      `true` if [`composite`](#composite); `false` otherwise.

    - Related:
      - [`declarationDir`](#declarationDir)

      - [`emitDeclarationOnly`](#emitDeclarationOnly)

    - Released:

      [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)
- name: declaration
  id: tsconfig#declaration-config
  summary: Generate .d.ts files for every TypeScript or JavaScript file inside your project
  belongs_to: TSConfig Reference
  description: |-
    ### Declaration - `declaration`

    Generate `.d.ts` files for every TypeScript or JavaScript file inside your project. These `.d.ts` files are type definition files which describe the external API of your module. With `.d.ts` files, tools like TypeScript can provide intellisense and accurate types for un-typed code.

    When `declaration` is set to `true`, running the compiler with this TypeScript code:

    ``` ts
    export let helloWorld = "hi";
    ```

    Will generate an `index.js` file like this:

    ``` ts
    export let helloWorld = "hi";
     
    ```

    With a corresponding `helloWorld.d.ts`:

    ``` ts
    export declare let helloWorld: string;
     
    ```

    When working with `.d.ts` files for JavaScript files you may want to use [`emitDeclarationOnly`](#emitDeclarationOnly) or use [`outDir`](#outDir) to ensure that the JavaScript files are not overwritten.

    - Default:

      `true` if [`composite`](#composite); `false` otherwise.

    - Related:
      - [`declarationDir`](#declarationDir)

      - [`emitDeclarationOnly`](#emitDeclarationOnly)

    - Released:

      [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)
- name: Declaration Merging
  id: declaration-merging
  summary: Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level
  description: "# Declaration Merging\n\n## Introduction\n\nSome of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of ‘declaration merging’. Understanding this concept will give you an advantage when working with existing JavaScript. It also opens the door to more advanced abstraction concepts.\n\nFor the purposes of this article, “declaration merging” means that the compiler merges two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Any number of declarations can be merged; it’s not limited to just two declarations.\n\n## Basic Concepts\n\nIn TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value. Namespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation. Type-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name. Lastly, value-creating declarations create values that are visible in the output JavaScript.\n\n| Declaration Type | Namespace | Type | Value |\n|------------------|:---------:|:----:|:-----:|\n| Namespace        |     X     |      |   X   |\n| Class            |           |  X   |   X   |\n| Enum             |           |  X   |   X   |\n| Interface        |           |  X   |       |\n| Type Alias       |           |  X   |       |\n| Function         |           |      |   X   |\n| Variable         |           |      |   X   |\n\nUnderstanding what is created with each declaration will help you understand what is merged when you perform a declaration merge.\n\n## Merging Interfaces\n\nThe simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.\n\n``` ts\ninterface Box {\n  height: number;\n  width: number;\n}\n\ninterface Box {\n  scale: number;\n}\n\nlet box: Box = { height: 5, width: 6, scale: 10 };\n```\n\nNon-function members of the interfaces should be unique. If they are not unique, they must be of the same type. The compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types.\n\nFor function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface `A` merging with later interface `A`, the second interface will have a higher precedence than the first.\n\nThat is, in the example:\n\n``` ts\ninterface Cloner {\n  clone(animal: Animal): Animal;\n}\n\ninterface Cloner {\n  clone(animal: Sheep): Sheep;\n}\n\ninterface Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n}\n```\n\nThe three interfaces will merge to create a single declaration as so:\n\n``` ts\ninterface Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n  clone(animal: Sheep): Sheep;\n  clone(animal: Animal): Animal;\n}\n```\n\nNotice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first.\n\nOne exception to this rule is specialized signatures. If a signature has a parameter whose type is a *single* string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.\n\nFor instance, the following interfaces will merge together:\n\n``` ts\ninterface Document {\n  createElement(tagName: any): Element;\n}\ninterface Document {\n  createElement(tagName: \"div\"): HTMLDivElement;\n  createElement(tagName: \"span\"): HTMLSpanElement;\n}\ninterface Document {\n  createElement(tagName: string): HTMLElement;\n  createElement(tagName: \"canvas\"): HTMLCanvasElement;\n}\n```\n\nThe resulting merged declaration of `Document` will be the following:\n\n``` ts\ninterface Document {\n  createElement(tagName: \"canvas\"): HTMLCanvasElement;\n  createElement(tagName: \"div\"): HTMLDivElement;\n  createElement(tagName: \"span\"): HTMLSpanElement;\n  createElement(tagName: string): HTMLElement;\n  createElement(tagName: any): Element;\n}\n```\n\n## Merging Namespaces\n\nSimilarly to interfaces, namespaces of the same name will also merge their members. Since namespaces create both a namespace and a value, we need to understand how both merge.\n\nTo merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside.\n\nTo merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first.\n\nThe declaration merge of `Animals` in this example:\n\n``` ts\nnamespace Animals {\n  export class Zebra {}\n}\n\nnamespace Animals {\n  export interface Legged {\n    numberOfLegs: number;\n  }\n  export class Dog {}\n}\n```\n\nis equivalent to:\n\n``` ts\nnamespace Animals {\n  export interface Legged {\n    numberOfLegs: number;\n  }\n\n  export class Zebra {}\n  export class Dog {}\n}\n```\n\nThis model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members.\n\nWe can see this more clearly in this example:\n\n``` ts\nnamespace Animal {\n  let haveMuscles = true;\n\n  export function animalsHaveMuscles() {\n    return haveMuscles;\n  }\n}\n\nnamespace Animal {\n  export function doAnimalsHaveMuscles() {\n    return haveMuscles; // Error, because haveMuscles is not accessible here\n  }\n}\n```\n\nBecause `haveMuscles` is not exported, only the `animalsHaveMuscles` function that shares the same un-merged namespace can see the symbol. The `doAnimalsHaveMuscles` function, even though it’s part of the merged `Animal` namespace can not see this un-exported member.\n\n## Merging Namespaces with Classes, Functions, and Enums\n\nNamespaces are flexible enough to also merge with other types of declarations. To do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages.\n\n### Merging Namespaces with Classes\n\nThis gives the user a way of describing inner classes.\n\n``` ts\nclass Album {\n  label: Album.AlbumLabel;\n}\nnamespace Album {\n  export class AlbumLabel {}\n}\n```\n\nThe visibility rules for merged members is the same as described in the [Merging Namespaces](declaration-merging#merging-namespaces) section, so we must export the `AlbumLabel` class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.\n\nIn addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions like this in a type-safe way.\n\n``` ts\nfunction buildLabel(name: string): string {\n  return buildLabel.prefix + name + buildLabel.suffix;\n}\n\nnamespace buildLabel {\n  export let suffix = \"\";\n  export let prefix = \"Hello, \";\n}\n\nconsole.log(buildLabel(\"Sam Smith\"));\n```\n\nSimilarly, namespaces can be used to extend enums with static members:\n\n``` ts\nenum Color {\n  red = 1,\n  green = 2,\n  blue = 4,\n}\n\nnamespace Color {\n  export function mixColor(colorName: string) {\n    if (colorName == \"yellow\") {\n      return Color.red + Color.green;\n    } else if (colorName == \"white\") {\n      return Color.red + Color.green + Color.blue;\n    } else if (colorName == \"magenta\") {\n      return Color.red + Color.blue;\n    } else if (colorName == \"cyan\") {\n      return Color.green + Color.blue;\n    }\n  }\n}\n```\n\n## Disallowed Merges\n\nNot all merges are allowed in TypeScript. Currently, classes can not merge with other classes or with variables. For information on mimicking class merging, see the [Mixins in TypeScript](mixins) section.\n\n## Module Augmentation\n\nAlthough JavaScript modules do not support merging, you can patch existing objects by importing and then updating them. Let’s look at a toy Observable example:\n\n``` ts\n// observable.ts\nexport class Observable<T> {\n  // ... implementation left as an exercise for the reader ...\n}\n\n// map.ts\nimport { Observable } from \"./observable\";\nObservable.prototype.map = function (f) {\n  // ... another exercise for the reader\n};\n```\n\nThis works fine in TypeScript too, but the compiler doesn’t know about `Observable.prototype.map`. You can use module augmentation to tell the compiler about it:\n\n``` ts\n// observable.ts\nexport class Observable<T> {\n  // ... implementation left as an exercise for the reader ...\n}\n\n// map.ts\nimport { Observable } from \"./observable\";\ndeclare module \"./observable\" {\n  interface Observable<T> {\n    map<U>(f: (x: T) => U): Observable<U>;\n  }\n}\nObservable.prototype.map = function (f) {\n  // ... another exercise for the reader\n};\n\n// consumer.ts\nimport { Observable } from \"./observable\";\nimport \"./map\";\nlet o: Observable<number>;\no.map((x) => x.toFixed());\n```\n\nThe module name is resolved the same way as module specifiers in `import`/`export`. See [Modules](modules/introduction) for more information. Then the declarations in an augmentation are merged as if they were declared in the same file as the original.\n\nHowever, there are two limitations to keep in mind:\n\n1.  You can’t declare new top-level declarations in the augmentation — just patches to existing declarations.\n2.  Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and `default` is a reserved word - see [\\#14080](https://github.com/Microsoft/TypeScript/issues/14080) for details)\n\n### Global augmentation\n\nYou can also add declarations to the global scope from inside a module:\n\n``` ts\n// observable.ts\nexport class Observable<T> {\n  // ... still no implementation ...\n}\n\ndeclare global {\n  interface Array<T> {\n    toObservable(): Observable<T>;\n  }\n}\n\nArray.prototype.toObservable = function () {\n  // ...\n};\n```\n\nGlobal augmentations have the same behavior and limits as module augmentations.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-merging.html](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)"
- name: 'Declaration Merging: Basic Concepts'
  id: declaration-merging#basic-concepts
  summary: 'In TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value'
  belongs_to: Declaration Merging
  description: |-
    ## Basic Concepts

    In TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value. Namespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation. Type-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name. Lastly, value-creating declarations create values that are visible in the output JavaScript.

    | Declaration Type | Namespace | Type | Value |
    |------------------|:---------:|:----:|:-----:|
    | Namespace        |     X     |      |   X   |
    | Class            |           |  X   |   X   |
    | Enum             |           |  X   |   X   |
    | Interface        |           |  X   |       |
    | Type Alias       |           |  X   |       |
    | Function         |           |      |   X   |
    | Variable         |           |      |   X   |

    Understanding what is created with each declaration will help you understand what is merged when you perform a declaration merge.
- name: 'Declaration Merging: Disallowed Merges'
  id: declaration-merging#disallowed-merges
  summary: Not all merges are allowed in TypeScript
  belongs_to: Declaration Merging
  description: |-
    ## Disallowed Merges

    Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes or with variables. For information on mimicking class merging, see the [Mixins in TypeScript](mixins) section.
- name: 'Declaration Merging: Introduction'
  id: declaration-merging#introduction
  summary: Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level
  belongs_to: Declaration Merging
  description: |-
    ## Introduction

    Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of ‘declaration merging’. Understanding this concept will give you an advantage when working with existing JavaScript. It also opens the door to more advanced abstraction concepts.

    For the purposes of this article, “declaration merging” means that the compiler merges two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Any number of declarations can be merged; it’s not limited to just two declarations.
- name: 'Declaration Merging: Merging Interfaces'
  id: declaration-merging#merging-interfaces
  summary: The simplest, and perhaps most common, type of declaration merging is interface merging
  belongs_to: Declaration Merging
  description: |-
    ## Merging Interfaces

    The simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.

    ``` ts
    interface Box {
      height: number;
      width: number;
    }

    interface Box {
      scale: number;
    }

    let box: Box = { height: 5, width: 6, scale: 10 };
    ```

    Non-function members of the interfaces should be unique. If they are not unique, they must be of the same type. The compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types.

    For function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface `A` merging with later interface `A`, the second interface will have a higher precedence than the first.

    That is, in the example:

    ``` ts
    interface Cloner {
      clone(animal: Animal): Animal;
    }

    interface Cloner {
      clone(animal: Sheep): Sheep;
    }

    interface Cloner {
      clone(animal: Dog): Dog;
      clone(animal: Cat): Cat;
    }
    ```

    The three interfaces will merge to create a single declaration as so:

    ``` ts
    interface Cloner {
      clone(animal: Dog): Dog;
      clone(animal: Cat): Cat;
      clone(animal: Sheep): Sheep;
      clone(animal: Animal): Animal;
    }
    ```

    Notice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first.

    One exception to this rule is specialized signatures. If a signature has a parameter whose type is a *single* string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.

    For instance, the following interfaces will merge together:

    ``` ts
    interface Document {
      createElement(tagName: any): Element;
    }
    interface Document {
      createElement(tagName: "div"): HTMLDivElement;
      createElement(tagName: "span"): HTMLSpanElement;
    }
    interface Document {
      createElement(tagName: string): HTMLElement;
      createElement(tagName: "canvas"): HTMLCanvasElement;
    }
    ```

    The resulting merged declaration of `Document` will be the following:

    ``` ts
    interface Document {
      createElement(tagName: "canvas"): HTMLCanvasElement;
      createElement(tagName: "div"): HTMLDivElement;
      createElement(tagName: "span"): HTMLSpanElement;
      createElement(tagName: string): HTMLElement;
      createElement(tagName: any): Element;
    }
    ```
- name: 'Declaration Merging: Merging Namespaces'
  id: declaration-merging#merging-namespaces
  summary: Similarly to interfaces, namespaces of the same name will also merge their members
  belongs_to: Declaration Merging
  description: |-
    ## Merging Namespaces

    Similarly to interfaces, namespaces of the same name will also merge their members. Since namespaces create both a namespace and a value, we need to understand how both merge.

    To merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside.

    To merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first.

    The declaration merge of `Animals` in this example:

    ``` ts
    namespace Animals {
      export class Zebra {}
    }

    namespace Animals {
      export interface Legged {
        numberOfLegs: number;
      }
      export class Dog {}
    }
    ```

    is equivalent to:

    ``` ts
    namespace Animals {
      export interface Legged {
        numberOfLegs: number;
      }

      export class Zebra {}
      export class Dog {}
    }
    ```

    This model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members.

    We can see this more clearly in this example:

    ``` ts
    namespace Animal {
      let haveMuscles = true;

      export function animalsHaveMuscles() {
        return haveMuscles;
      }
    }

    namespace Animal {
      export function doAnimalsHaveMuscles() {
        return haveMuscles; // Error, because haveMuscles is not accessible here
      }
    }
    ```

    Because `haveMuscles` is not exported, only the `animalsHaveMuscles` function that shares the same un-merged namespace can see the symbol. The `doAnimalsHaveMuscles` function, even though it’s part of the merged `Animal` namespace can not see this un-exported member.
- name: 'Declaration Merging: Merging Namespaces with Classes, Functions, and Enums'
  id: declaration-merging#merging-namespaces-with-classes-functions-and-enums
  summary: Namespaces are flexible enough to also merge with other types of declarations
  belongs_to: Declaration Merging
  description: |-
    ## Merging Namespaces with Classes, Functions, and Enums

    Namespaces are flexible enough to also merge with other types of declarations. To do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages.

    ### Merging Namespaces with Classes

    This gives the user a way of describing inner classes.

    ``` ts
    class Album {
      label: Album.AlbumLabel;
    }
    namespace Album {
      export class AlbumLabel {}
    }
    ```

    The visibility rules for merged members is the same as described in the [Merging Namespaces](declaration-merging#merging-namespaces) section, so we must export the `AlbumLabel` class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.

    In addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions like this in a type-safe way.

    ``` ts
    function buildLabel(name: string): string {
      return buildLabel.prefix + name + buildLabel.suffix;
    }

    namespace buildLabel {
      export let suffix = "";
      export let prefix = "Hello, ";
    }

    console.log(buildLabel("Sam Smith"));
    ```

    Similarly, namespaces can be used to extend enums with static members:

    ``` ts
    enum Color {
      red = 1,
      green = 2,
      blue = 4,
    }

    namespace Color {
      export function mixColor(colorName: string) {
        if (colorName == "yellow") {
          return Color.red + Color.green;
        } else if (colorName == "white") {
          return Color.red + Color.green + Color.blue;
        } else if (colorName == "magenta") {
          return Color.red + Color.blue;
        } else if (colorName == "cyan") {
          return Color.green + Color.blue;
        }
      }
    }
    ```
- name: 'Declaration Merging: Module Augmentation'
  id: declaration-merging#module-augmentation
  summary: Although JavaScript modules do not support merging, you can patch existing objects by importing and then updating them
  belongs_to: Declaration Merging
  description: "## Module Augmentation\n\nAlthough JavaScript modules do not support merging, you can patch existing objects by importing and then updating them. Let’s look at a toy Observable example:\n\n``` ts\n// observable.ts\nexport class Observable<T> {\n  // ... implementation left as an exercise for the reader ...\n}\n\n// map.ts\nimport { Observable } from \"./observable\";\nObservable.prototype.map = function (f) {\n  // ... another exercise for the reader\n};\n```\n\nThis works fine in TypeScript too, but the compiler doesn’t know about `Observable.prototype.map`. You can use module augmentation to tell the compiler about it:\n\n``` ts\n// observable.ts\nexport class Observable<T> {\n  // ... implementation left as an exercise for the reader ...\n}\n\n// map.ts\nimport { Observable } from \"./observable\";\ndeclare module \"./observable\" {\n  interface Observable<T> {\n    map<U>(f: (x: T) => U): Observable<U>;\n  }\n}\nObservable.prototype.map = function (f) {\n  // ... another exercise for the reader\n};\n\n// consumer.ts\nimport { Observable } from \"./observable\";\nimport \"./map\";\nlet o: Observable<number>;\no.map((x) => x.toFixed());\n```\n\nThe module name is resolved the same way as module specifiers in `import`/`export`. See [Modules](modules/introduction) for more information. Then the declarations in an augmentation are merged as if they were declared in the same file as the original.\n\nHowever, there are two limitations to keep in mind:\n\n1.  You can’t declare new top-level declarations in the augmentation — just patches to existing declarations.\n2.  Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and `default` is a reserved word - see [\\#14080](https://github.com/Microsoft/TypeScript/issues/14080) for details)\n\n### Global augmentation\n\nYou can also add declarations to the global scope from inside a module:\n\n``` ts\n// observable.ts\nexport class Observable<T> {\n  // ... still no implementation ...\n}\n\ndeclare global {\n  interface Array<T> {\n    toObservable(): Observable<T>;\n  }\n}\n\nArray.prototype.toObservable = function () {\n  // ...\n};\n```\n\nGlobal augmentations have the same behavior and limits as module augmentations.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-merging.html](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)"
- name: Declaration Reference
  id: declaration-files/by-example
  summary: The purpose of this guide is to teach you how to write a high-quality definition file
  description: "# Declaration Reference\n\nThe purpose of this guide is to teach you how to write a high-quality definition file. This guide is structured by showing documentation for some API, along with sample usage of that API, and explaining how to write the corresponding declaration.\n\nThese examples are ordered in approximately increasing order of complexity.\n\n## Objects with Properties\n\n*Documentation*\n\n> The global variable `myLib` has a function `makeGreeting` for creating greetings, and a property `numberOfGreetings` indicating the number of greetings made so far.\n\n*Code*\n\n``` ts\nlet result = myLib.makeGreeting(\"hello, world\");\nconsole.log(\"The computed greeting is:\" + result);\n\nlet count = myLib.numberOfGreetings;\n```\n\n*Declaration*\n\nUse `declare namespace` to describe types or values accessed by dotted notation.\n\n``` ts\ndeclare namespace myLib {\n  function makeGreeting(s: string): string;\n  let numberOfGreetings: number;\n}\n```\n\n## Overloaded Functions\n\n*Documentation*\n\nThe `getWidget` function accepts a number and returns a Widget, or accepts a string and returns a Widget array.\n\n*Code*\n\n``` ts\nlet x: Widget = getWidget(43);\n\nlet arr: Widget[] = getWidget(\"all of them\");\n```\n\n*Declaration*\n\n``` ts\ndeclare function getWidget(n: number): Widget;\ndeclare function getWidget(s: string): Widget[];\n```\n\n## Reusable Types (Interfaces)\n\n*Documentation*\n\n> When specifying a greeting, you must pass a `GreetingSettings` object. This object has the following properties:\n>\n> 1 - greeting: Mandatory string\n>\n> 2 - duration: Optional length of time (in milliseconds)\n>\n> 3 - color: Optional string, e.g. ‘#ff00ff’\n\n*Code*\n\n``` ts\ngreet({\n  greeting: \"hello world\",\n  duration: 4000\n});\n```\n\n*Declaration*\n\nUse an `interface` to define a type with properties.\n\n``` ts\ninterface GreetingSettings {\n  greeting: string;\n  duration?: number;\n  color?: string;\n}\n\ndeclare function greet(setting: GreetingSettings): void;\n```\n\n## Reusable Types (Type Aliases)\n\n*Documentation*\n\n> Anywhere a greeting is expected, you can provide a `string`, a function returning a `string`, or a `Greeter` instance.\n\n*Code*\n\n``` ts\nfunction getGreeting() {\n  return \"howdy\";\n}\nclass MyGreeter extends Greeter {}\n\ngreet(\"hello\");\ngreet(getGreeting);\ngreet(new MyGreeter());\n```\n\n*Declaration*\n\nYou can use a type alias to make a shorthand for a type:\n\n``` ts\ntype GreetingLike = string | (() => string) | MyGreeter;\n\ndeclare function greet(g: GreetingLike): void;\n```\n\n## Organizing Types\n\n*Documentation*\n\n> The `greeter` object can log to a file or display an alert. You can provide LogOptions to `.log(...)` and alert options to `.alert(...)`\n\n*Code*\n\n``` ts\nconst g = new Greeter(\"Hello\");\ng.log({ verbose: true });\ng.alert({ modal: false, title: \"Current Greeting\" });\n```\n\n*Declaration*\n\nUse namespaces to organize types.\n\n``` ts\ndeclare namespace GreetingLib {\n  interface LogOptions {\n    verbose?: boolean;\n  }\n  interface AlertOptions {\n    modal: boolean;\n    title?: string;\n    color?: string;\n  }\n}\n```\n\nYou can also create nested namespaces in one declaration:\n\n``` ts\ndeclare namespace GreetingLib.Options {\n  // Refer to via GreetingLib.Options.Log\n  interface Log {\n    verbose?: boolean;\n  }\n  interface Alert {\n    modal: boolean;\n    title?: string;\n    color?: string;\n  }\n}\n```\n\n## Classes\n\n*Documentation*\n\n> You can create a greeter by instantiating the `Greeter` object, or create a customized greeter by extending from it.\n\n*Code*\n\n``` ts\nconst myGreeter = new Greeter(\"hello, world\");\nmyGreeter.greeting = \"howdy\";\nmyGreeter.showGreeting();\n\nclass SpecialGreeter extends Greeter {\n  constructor() {\n    super(\"Very special greetings\");\n  }\n}\n```\n\n*Declaration*\n\nUse `declare class` to describe a class or class-like object. Classes can have properties and methods as well as a constructor.\n\n``` ts\ndeclare class Greeter {\n  constructor(greeting: string);\n\n  greeting: string;\n  showGreeting(): void;\n}\n```\n\n## Global Variables\n\n*Documentation*\n\n> The global variable `foo` contains the number of widgets present.\n\n*Code*\n\n``` ts\nconsole.log(\"Half the number of widgets is \" + foo / 2);\n```\n\n*Declaration*\n\nUse `declare var` to declare variables. If the variable is read-only, you can use `declare const`. You can also use `declare let` if the variable is block-scoped.\n\n``` ts\n/** The number of widgets present */\ndeclare var foo: number;\n```\n\n## Global Functions\n\n*Documentation*\n\n> You can call the function `greet` with a string to show a greeting to the user.\n\n*Code*\n\n``` ts\ngreet(\"hello, world\");\n```\n\n*Declaration*\n\nUse `declare function` to declare functions.\n\n``` ts\ndeclare function greet(greeting: string): void;\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)"
- name: 'Declaration Reference: Classes'
  id: declaration-files/by-example#classes
  summary: You can create a greeter by instantiating the Greeter object, or create a customized greeter by extending from it
  belongs_to: Declaration Reference
  description: |-
    ## Classes

    *Documentation*

    > You can create a greeter by instantiating the `Greeter` object, or create a customized greeter by extending from it.

    *Code*

    ``` ts
    const myGreeter = new Greeter("hello, world");
    myGreeter.greeting = "howdy";
    myGreeter.showGreeting();

    class SpecialGreeter extends Greeter {
      constructor() {
        super("Very special greetings");
      }
    }
    ```

    *Declaration*

    Use `declare class` to describe a class or class-like object. Classes can have properties and methods as well as a constructor.

    ``` ts
    declare class Greeter {
      constructor(greeting: string);

      greeting: string;
      showGreeting(): void;
    }
    ```
- name: 'Declaration Reference: Global Functions'
  id: declaration-files/by-example#global-functions
  summary: You can call the function greet with a string to show a greeting to the user
  belongs_to: Declaration Reference
  description: "## Global Functions\n\n*Documentation*\n\n> You can call the function `greet` with a string to show a greeting to the user.\n\n*Code*\n\n``` ts\ngreet(\"hello, world\");\n```\n\n*Declaration*\n\nUse `declare function` to declare functions.\n\n``` ts\ndeclare function greet(greeting: string): void;\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)"
- name: 'Declaration Reference: Global Variables'
  id: declaration-files/by-example#global-variables
  summary: The global variable foo contains the number of widgets present
  belongs_to: Declaration Reference
  description: |-
    ## Global Variables

    *Documentation*

    > The global variable `foo` contains the number of widgets present.

    *Code*

    ``` ts
    console.log("Half the number of widgets is " + foo / 2);
    ```

    *Declaration*

    Use `declare var` to declare variables. If the variable is read-only, you can use `declare const`. You can also use `declare let` if the variable is block-scoped.

    ``` ts
    /** The number of widgets present */
    declare var foo: number;
    ```
- name: 'Declaration Reference: Objects with Properties'
  id: declaration-files/by-example#objects-with-properties
  summary: The global variable myLib has a function makeGreeting for creating greetings, and a property numberOfGreetings indicating the number of greetings made so far
  belongs_to: Declaration Reference
  description: |-
    ## Objects with Properties

    *Documentation*

    > The global variable `myLib` has a function `makeGreeting` for creating greetings, and a property `numberOfGreetings` indicating the number of greetings made so far.

    *Code*

    ``` ts
    let result = myLib.makeGreeting("hello, world");
    console.log("The computed greeting is:" + result);

    let count = myLib.numberOfGreetings;
    ```

    *Declaration*

    Use `declare namespace` to describe types or values accessed by dotted notation.

    ``` ts
    declare namespace myLib {
      function makeGreeting(s: string): string;
      let numberOfGreetings: number;
    }
    ```
- name: 'Declaration Reference: Organizing Types'
  id: declaration-files/by-example#organizing-types
  summary: The greeter object can log to a file or display an alert
  belongs_to: Declaration Reference
  description: |-
    ## Organizing Types

    *Documentation*

    > The `greeter` object can log to a file or display an alert. You can provide LogOptions to `.log(...)` and alert options to `.alert(...)`

    *Code*

    ``` ts
    const g = new Greeter("Hello");
    g.log({ verbose: true });
    g.alert({ modal: false, title: "Current Greeting" });
    ```

    *Declaration*

    Use namespaces to organize types.

    ``` ts
    declare namespace GreetingLib {
      interface LogOptions {
        verbose?: boolean;
      }
      interface AlertOptions {
        modal: boolean;
        title?: string;
        color?: string;
      }
    }
    ```

    You can also create nested namespaces in one declaration:

    ``` ts
    declare namespace GreetingLib.Options {
      // Refer to via GreetingLib.Options.Log
      interface Log {
        verbose?: boolean;
      }
      interface Alert {
        modal: boolean;
        title?: string;
        color?: string;
      }
    }
    ```
- name: 'Declaration Reference: Overloaded Functions'
  id: declaration-files/by-example#overloaded-functions
  summary: The getWidget function accepts a number and returns a Widget, or accepts a string and returns a Widget array
  belongs_to: Declaration Reference
  description: |-
    ## Overloaded Functions

    *Documentation*

    The `getWidget` function accepts a number and returns a Widget, or accepts a string and returns a Widget array.

    *Code*

    ``` ts
    let x: Widget = getWidget(43);

    let arr: Widget[] = getWidget("all of them");
    ```

    *Declaration*

    ``` ts
    declare function getWidget(n: number): Widget;
    declare function getWidget(s: string): Widget[];
    ```
- name: 'Declaration Reference: Reusable Types (Interfaces)'
  id: declaration-files/by-example#reusable-types-interfaces
  summary: When specifying a greeting, you must pass a GreetingSettings object
  belongs_to: Declaration Reference
  description: |-
    ## Reusable Types (Interfaces)

    *Documentation*

    > When specifying a greeting, you must pass a `GreetingSettings` object. This object has the following properties:
    >
    > 1 - greeting: Mandatory string
    >
    > 2 - duration: Optional length of time (in milliseconds)
    >
    > 3 - color: Optional string, e.g. ‘#ff00ff’

    *Code*

    ``` ts
    greet({
      greeting: "hello world",
      duration: 4000
    });
    ```

    *Declaration*

    Use an `interface` to define a type with properties.

    ``` ts
    interface GreetingSettings {
      greeting: string;
      duration?: number;
      color?: string;
    }

    declare function greet(setting: GreetingSettings): void;
    ```
- name: 'Declaration Reference: Reusable Types (Type Aliases)'
  id: declaration-files/by-example#reusable-types-type-aliases
  summary: Anywhere a greeting is expected, you can provide a string, a function returning a string, or a Greeter instance
  belongs_to: Declaration Reference
  description: |-
    ## Reusable Types (Type Aliases)

    *Documentation*

    > Anywhere a greeting is expected, you can provide a `string`, a function returning a `string`, or a `Greeter` instance.

    *Code*

    ``` ts
    function getGreeting() {
      return "howdy";
    }
    class MyGreeter extends Greeter {}

    greet("hello");
    greet(getGreeting);
    greet(new MyGreeter());
    ```

    *Declaration*

    You can use a type alias to make a shorthand for a type:

    ``` ts
    type GreetingLike = string | (() => string) | MyGreeter;

    declare function greet(g: GreetingLike): void;
    ```
- name: declarationDir
  id: tsconfig/index#declarationDir-config
  summary: Offers a way to configure the root directory for where declaration files are emitted
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Declaration Dir - `declarationDir`

    Offers a way to configure the root directory for where declaration files are emitted.

    ``` typescript
    example
    ├── index.ts
    ├── package.json
    └── tsconfig.json
    ```

    with this `tsconfig.json`:

    ``` typescript
    {
      "compilerOptions": {
        "declaration": true,
        "declarationDir": "./types"
      }
    }
    ```

    Would place the d.ts for the `index.ts` in a `types` folder:

    ``` typescript
    example
    ├── index.js
    ├── index.ts
    ├── package.json
    ├── tsconfig.json
    └── types
        └── index.d.ts
    ```

    - Related:
      - [`declaration`](#declaration)

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: declarationDir
  id: tsconfig#declarationDir-config
  summary: Offers a way to configure the root directory for where declaration files are emitted
  belongs_to: TSConfig Reference
  description: |-
    ### Declaration Dir - `declarationDir`

    Offers a way to configure the root directory for where declaration files are emitted.

    ``` typescript
    example
    ├── index.ts
    ├── package.json
    └── tsconfig.json
    ```

    with this `tsconfig.json`:

    ``` typescript
    {
      "compilerOptions": {
        "declaration": true,
        "declarationDir": "./types"
      }
    }
    ```

    Would place the d.ts for the `index.ts` in a `types` folder:

    ``` typescript
    example
    ├── index.js
    ├── index.ts
    ├── package.json
    ├── tsconfig.json
    └── types
        └── index.d.ts
    ```

    - Related:
      - [`declaration`](#declaration)

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: declarationMap
  id: tsconfig/index#declarationMap-config
  summary: Generates a source map for .d.ts files which map back to the original .ts source file
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Declaration Map - `declarationMap`

    Generates a source map for `.d.ts` files which map back to the original `.ts` source file. This will allow editors such as VS Code to go to the original `.ts` file when using features like *Go to Definition*.

    You should strongly consider turning this on if you’re using project references.

    - Released:

      [2.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html)
- name: declarationMap
  id: tsconfig#declarationMap-config
  summary: Generates a source map for .d.ts files which map back to the original .ts source file
  belongs_to: TSConfig Reference
  description: |-
    ### Declaration Map - `declarationMap`

    Generates a source map for `.d.ts` files which map back to the original `.ts` source file. This will allow editors such as VS Code to go to the original `.ts` file when using features like *Go to Definition*.

    You should strongly consider turning this on if you’re using project references.

    - Released:

      [2.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html)
- name: Decorators
  id: decorators
  summary: NOTE This document refers to an experimental stage 2 decorators implementation
  description: "# Decorators\n\n> NOTE This document refers to an experimental stage 2 decorators implementation. Stage 3 decorator support is available since Typescript 5.0. See: [Decorators in Typescript 5.0](https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#decorators)\n\n## Introduction\n\nWith the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members.\n\n> Further Reading (stage 2): [A Complete Guide to TypeScript Decorators](https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator/)\n\nTo enable experimental support for decorators, you must enable the [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators) compiler option either on the command line or in your `tsconfig.json`:\n\n**Command Line**:\n\n``` shell\ntsc --target ES5 --experimentalDecorators\n```\n\n**tsconfig.json**:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}\n```\n\n## Decorators\n\nA *Decorator* is a special kind of declaration that can be attached to a [class declaration](#class-decorators), [method](#method-decorators), [accessor](#accessor-decorators), [property](#property-decorators), or [parameter](#parameter-decorators). Decorators use the form `@expression`, where `expression` must evaluate to a function that will be called at runtime with information about the decorated declaration.\n\nFor example, given the decorator `@sealed` we might write the `sealed` function as follows:\n\n``` ts\nfunction sealed(target) {\n  // do something with 'target' ...\n}\n```\n\n## Decorator Factories\n\nIf we want to customize how a decorator is applied to a declaration, we can write a decorator factory. A *Decorator Factory* is simply a function that returns the expression that will be called by the decorator at runtime.\n\nWe can write a decorator factory in the following fashion:\n\n``` ts\nfunction color(value: string) {\n  // this is the decorator factory, it sets up\n  // the returned decorator function\n  return function (target) {\n    // this is the decorator\n    // do something with 'target' and 'value'...\n  };\n}\n```\n\n## Decorator Composition\n\nMultiple decorators can be applied to a declaration, for example on a single line:\n\n``` ts\n@f @g x\n```\n\nOn multiple lines:\n\n``` ts\n@f\n@g\nx\n```\n\nWhen multiple decorators apply to a single declaration, their evaluation is similar to [function composition in mathematics](https://wikipedia.org/wiki/Function_composition). In this model, when composing functions *f* and *g*, the resulting composite (*f* ∘ *g*)(*x*) is equivalent to *f*(*g*(*x*)).\n\nAs such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:\n\n1.  The expressions for each decorator are evaluated top-to-bottom.\n2.  The results are then called as functions from bottom-to-top.\n\nIf we were to use [decorator factories](#decorator-factories), we can observe this evaluation order with the following example:\n\n``` ts\nfunction first() {\n  console.log(\"first(): factory evaluated\");\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    console.log(\"first(): called\");\n  };\n}\n \nfunction second() {\n  console.log(\"second(): factory evaluated\");\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    console.log(\"second(): called\");\n  };\n}\n \nclass ExampleClass {\n  @first()\n  @second()\n  method() {}\n}\n```\n\nWhich would print this output to the console:\n\n``` shell\nfirst(): factory evaluated\nsecond(): factory evaluated\nsecond(): called\nfirst(): called\n```\n\n## Decorator Evaluation\n\nThere is a well defined order to how decorators applied to various declarations inside of a class are applied:\n\n1.  *Parameter Decorators*, followed by *Method*, *Accessor*, or *Property Decorators* are applied for each instance member.\n2.  *Parameter Decorators*, followed by *Method*, *Accessor*, or *Property Decorators* are applied for each static member.\n3.  *Parameter Decorators* are applied for the constructor.\n4.  *Class Decorators* are applied for the class.\n\n## Class Decorators\n\nA *Class Decorator* is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a `declare` class).\n\nThe expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.\n\nIf the class decorator returns a value, it will replace the class declaration with the provided constructor function.\n\n> NOTE Should you choose to return a new constructor function, you must take care to maintain the original prototype. The logic that applies decorators at runtime will **not** do this for you.\n\nThe following is an example of a class decorator (`@sealed`) applied to a `BugReport` class:\n\n``` ts\n@sealed\nclass BugReport {\n  type = \"report\";\n  title: string;\n \n  constructor(t: string) {\n    this.title = t;\n  }\n}\n```\n\nWe can define the `@sealed` decorator using the following function declaration:\n\n``` ts\nfunction sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n```\n\nWhen `@sealed` is executed, it will seal both the constructor and its prototype, and will therefore prevent any further functionality from being added to or removed from this class during runtime by accessing `BugReport.prototype` or by defining properties on `BugReport` itself (note that ES2015 classes are really just syntactic sugar to prototype-based constructor functions). This decorator does **not** prevent classes from sub-classing `BugReport`.\n\nNext we have an example of how to override the constructor to set new defaults.\n\n``` ts\nfunction reportableClassDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {\n  return class extends constructor {\n    reportingURL = \"http://www...\";\n  };\n}\n \n@reportableClassDecorator\nclass BugReport {\n  type = \"report\";\n  title: string;\n \n  constructor(t: string) {\n    this.title = t;\n  }\n}\n \nconst bug = new BugReport(\"Needs dark mode\");\nconsole.log(bug.title); // Prints \"Needs dark mode\"\nconsole.log(bug.type); // Prints \"report\"\n \n// Note that the decorator _does not_ change the TypeScript type\n// and so the new property `reportingURL` is not known\n// to the type system:\nbug.reportingURL;\n```\n\n## Method Decorators\n\nA *Method Decorator* is declared just before a method declaration. The decorator is applied to the *Property Descriptor* for the method, and can be used to observe, modify, or replace a method definition. A method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a `declare` class).\n\nThe expression for the method decorator will be called as a function at runtime, with the following three arguments:\n\n1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n2.  The name of the member.\n3.  The *Property Descriptor* for the member.\n\n> NOTE The *Property Descriptor* will be `undefined` if your script target is less than `ES5`.\n\nIf the method decorator returns a value, it will be used as the *Property Descriptor* for the method.\n\n> NOTE The return value is ignored if your script target is less than `ES5`.\n\nThe following is an example of a method decorator (`@enumerable`) applied to a method on the `Greeter` class:\n\n``` ts\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n \n  @enumerable(false)\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n```\n\nWe can define the `@enumerable` decorator using the following function declaration:\n\n``` ts\nfunction enumerable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.enumerable = value;\n  };\n}\n```\n\nThe `@enumerable(false)` decorator here is a [decorator factory](#decorator-factories). When the `@enumerable(false)` decorator is called, it modifies the `enumerable` property of the property descriptor.\n\n## Accessor Decorators\n\nAn *Accessor Decorator* is declared just before an accessor declaration. The accessor decorator is applied to the *Property Descriptor* for the accessor and can be used to observe, modify, or replace an accessor’s definitions. An accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a `declare` class).\n\n> NOTE TypeScript disallows decorating both the `get` and `set` accessor for a single member. Instead, all decorators for the member must be applied to the first accessor specified in document order. This is because decorators apply to a *Property Descriptor*, which combines both the `get` and `set` accessor, not each declaration separately.\n\nThe expression for the accessor decorator will be called as a function at runtime, with the following three arguments:\n\n1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n2.  The name of the member.\n3.  The *Property Descriptor* for the member.\n\n> NOTE The *Property Descriptor* will be `undefined` if your script target is less than `ES5`.\n\nIf the accessor decorator returns a value, it will be used as the *Property Descriptor* for the member.\n\n> NOTE The return value is ignored if your script target is less than `ES5`.\n\nThe following is an example of an accessor decorator (`@configurable`) applied to a member of the `Point` class:\n\n``` ts\nclass Point {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n    this._x = x;\n    this._y = y;\n  }\n \n  @configurable(false)\n  get x() {\n    return this._x;\n  }\n \n  @configurable(false)\n  get y() {\n    return this._y;\n  }\n}\n```\n\nWe can define the `@configurable` decorator using the following function declaration:\n\n``` ts\nfunction configurable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.configurable = value;\n  };\n}\n```\n\n## Property Decorators\n\nA *Property Decorator* is declared just before a property declaration. A property decorator cannot be used in a declaration file, or in any other ambient context (such as in a `declare` class).\n\nThe expression for the property decorator will be called as a function at runtime, with the following two arguments:\n\n1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n2.  The name of the member.\n\n> NOTE A *Property Descriptor* is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript. This is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too. As such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.\n\nWe can use this information to record metadata about the property, as in the following example:\n\n``` ts\nclass Greeter {\n  @format(\"Hello, %s\")\n  greeting: string;\n\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  greet() {\n    let formatString = getFormat(this, \"greeting\");\n    return formatString.replace(\"%s\", this.greeting);\n  }\n}\n```\n\nWe can then define the `@format` decorator and `getFormat` functions using the following function declarations:\n\n``` ts\nimport \"reflect-metadata\";\n\nconst formatMetadataKey = Symbol(\"format\");\n\nfunction format(formatString: string) {\n  return Reflect.metadata(formatMetadataKey, formatString);\n}\n\nfunction getFormat(target: any, propertyKey: string) {\n  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}\n```\n\nThe `@format(\"Hello, %s\")` decorator here is a [decorator factory](#decorator-factories). When `@format(\"Hello, %s\")` is called, it adds a metadata entry for the property using the `Reflect.metadata` function from the `reflect-metadata` library. When `getFormat` is called, it reads the metadata value for the format.\n\n> NOTE This example requires the `reflect-metadata` library. See [Metadata](#metadata) for more information about the `reflect-metadata` library.\n\n## Parameter Decorators\n\nA *Parameter Decorator* is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a `declare` class).\n\nThe expression for the parameter decorator will be called as a function at runtime, with the following three arguments:\n\n1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n2.  The name of the member.\n3.  The ordinal index of the parameter in the function’s parameter list.\n\n> NOTE A parameter decorator can only be used to observe that a parameter has been declared on a method.\n\nThe return value of the parameter decorator is ignored.\n\nThe following is an example of a parameter decorator (`@required`) applied to parameter of a member of the `BugReport` class:\n\n``` ts\nclass BugReport {\n  type = \"report\";\n  title: string;\n \n  constructor(t: string) {\n    this.title = t;\n  }\n \n  @validate\n  print(@required verbose: boolean) {\n    if (verbose) {\n      return `type: ${this.type}\\ntitle: ${this.title}`;\n    } else {\n     return this.title; \n    }\n  }\n}\n```\n\nWe can then define the `@required` and `@validate` decorators using the following function declarations:\n\n``` ts\nimport \"reflect-metadata\";\nconst requiredMetadataKey = Symbol(\"required\");\n \nfunction required(target: Object, propertyKey: string | symbol, parameterIndex: number) {\n  let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n  existingRequiredParameters.push(parameterIndex);\n  Reflect.defineMetadata( requiredMetadataKey, existingRequiredParameters, target, propertyKey);\n}\n \nfunction validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {\n  let method = descriptor.value!;\n \n  descriptor.value = function () {\n    let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);\n    if (requiredParameters) {\n      for (let parameterIndex of requiredParameters) {\n        if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {\n          throw new Error(\"Missing required argument.\");\n        }\n      }\n    }\n    return method.apply(this, arguments);\n  };\n}\n```\n\nThe `@required` decorator adds a metadata entry that marks the parameter as required. The `@validate` decorator then wraps the existing `print` method in a function that validates the arguments before invoking the original method.\n\n> NOTE This example requires the `reflect-metadata` library. See [Metadata](#metadata) for more information about the `reflect-metadata` library.\n\n## Metadata\n\nSome examples use the `reflect-metadata` library which adds a polyfill for an [experimental metadata API](https://github.com/rbuckton/ReflectDecorators). This library is not yet part of the ECMAScript (JavaScript) standard. However, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.\n\nYou can install this library via npm:\n\n``` shell\nnpm i reflect-metadata --save\n```\n\nTypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators. To enable this experimental support, you must set the [`emitDecoratorMetadata`](https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata) compiler option either on the command line or in your `tsconfig.json`:\n\n**Command Line**:\n\n``` shell\ntsc --target ES5 --experimentalDecorators --emitDecoratorMetadata\n```\n\n**tsconfig.json**:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n```\n\nWhen enabled, as long as the `reflect-metadata` library has been imported, additional design-time type information will be exposed at runtime.\n\nWe can see this in action in the following example:\n\n``` ts\nimport \"reflect-metadata\";\n \nclass Point {\n  constructor(public x: number, public y: number) {}\n}\n \nclass Line {\n  private _start: Point;\n  private _end: Point;\n \n  @validate\n  set start(value: Point) {\n    this._start = value;\n  }\n \n  get start() {\n    return this._start;\n  }\n \n  @validate\n  set end(value: Point) {\n    this._end = value;\n  }\n \n  get end() {\n    return this._end;\n  }\n}\n \nfunction validate<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>) {\n  let set = descriptor.set!;\n  \n  descriptor.set = function (value: T) {\n    let type = Reflect.getMetadata(\"design:type\", target, propertyKey);\n \n    if (!(value instanceof type)) {\n      throw new TypeError(`Invalid type, got ${typeof value} not ${type.name}.`);\n    }\n \n    set.call(this, value);\n  };\n}\n \nconst line = new Line()\nline.start = new Point(0, 0)\n \n// @ts-ignore\n// line.end = {}\n \n// Fails at runtime with:\n// > Invalid type, got object not Point\n \n```\n\nThe TypeScript compiler will inject design-time type information using the `@Reflect.metadata` decorator. You could consider it the equivalent of the following TypeScript:\n\n``` ts\nclass Line {\n  private _start: Point;\n  private _end: Point;\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set start(value: Point) {\n    this._start = value;\n  }\n  get start() {\n    return this._start;\n  }\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set end(value: Point) {\n    this._end = value;\n  }\n  get end() {\n    return this._end;\n  }\n}\n```\n\n> NOTE Decorator metadata is an experimental feature and may introduce breaking changes in future releases.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/decorators.html](https://www.typescriptlang.org/docs/handbook/decorators.html)"
- name: 'Decorators: Accessor Decorators'
  id: decorators#accessor-decorators
  summary: An Accessor Decorator is declared just before an accessor declaration
  belongs_to: Decorators
  description: |-
    ## Accessor Decorators

    An *Accessor Decorator* is declared just before an accessor declaration. The accessor decorator is applied to the *Property Descriptor* for the accessor and can be used to observe, modify, or replace an accessor’s definitions. An accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a `declare` class).

    > NOTE TypeScript disallows decorating both the `get` and `set` accessor for a single member. Instead, all decorators for the member must be applied to the first accessor specified in document order. This is because decorators apply to a *Property Descriptor*, which combines both the `get` and `set` accessor, not each declaration separately.

    The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:

    1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.
    2.  The name of the member.
    3.  The *Property Descriptor* for the member.

    > NOTE The *Property Descriptor* will be `undefined` if your script target is less than `ES5`.

    If the accessor decorator returns a value, it will be used as the *Property Descriptor* for the member.

    > NOTE The return value is ignored if your script target is less than `ES5`.

    The following is an example of an accessor decorator (`@configurable`) applied to a member of the `Point` class:

    ``` ts
    class Point {
      private _x: number;
      private _y: number;
      constructor(x: number, y: number) {
        this._x = x;
        this._y = y;
      }
     
      @configurable(false)
      get x() {
        return this._x;
      }
     
      @configurable(false)
      get y() {
        return this._y;
      }
    }
    ```

    We can define the `@configurable` decorator using the following function declaration:

    ``` ts
    function configurable(value: boolean) {
      return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.configurable = value;
      };
    }
    ```
- name: 'Decorators: Class Decorators'
  id: decorators#class-decorators
  summary: A Class Decorator is declared just before a class declaration
  belongs_to: Decorators
  description: |-
    ## Class Decorators

    A *Class Decorator* is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a `declare` class).

    The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.

    If the class decorator returns a value, it will replace the class declaration with the provided constructor function.

    > NOTE Should you choose to return a new constructor function, you must take care to maintain the original prototype. The logic that applies decorators at runtime will **not** do this for you.

    The following is an example of a class decorator (`@sealed`) applied to a `BugReport` class:

    ``` ts
    @sealed
    class BugReport {
      type = "report";
      title: string;
     
      constructor(t: string) {
        this.title = t;
      }
    }
    ```

    We can define the `@sealed` decorator using the following function declaration:

    ``` ts
    function sealed(constructor: Function) {
      Object.seal(constructor);
      Object.seal(constructor.prototype);
    }
    ```

    When `@sealed` is executed, it will seal both the constructor and its prototype, and will therefore prevent any further functionality from being added to or removed from this class during runtime by accessing `BugReport.prototype` or by defining properties on `BugReport` itself (note that ES2015 classes are really just syntactic sugar to prototype-based constructor functions). This decorator does **not** prevent classes from sub-classing `BugReport`.

    Next we have an example of how to override the constructor to set new defaults.

    ``` ts
    function reportableClassDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {
      return class extends constructor {
        reportingURL = "http://www...";
      };
    }
     
    @reportableClassDecorator
    class BugReport {
      type = "report";
      title: string;
     
      constructor(t: string) {
        this.title = t;
      }
    }
     
    const bug = new BugReport("Needs dark mode");
    console.log(bug.title); // Prints "Needs dark mode"
    console.log(bug.type); // Prints "report"
     
    // Note that the decorator _does not_ change the TypeScript type
    // and so the new property `reportingURL` is not known
    // to the type system:
    bug.reportingURL;
    ```
- name: 'Decorators: Decorator Composition'
  id: decorators#decorator-composition
  summary: When multiple decorators apply to a single declaration, their evaluation is similar to function composition in mathematics
  belongs_to: Decorators
  description: |-
    ## Decorator Composition

    Multiple decorators can be applied to a declaration, for example on a single line:

    ``` ts
    @f @g x
    ```

    On multiple lines:

    ``` ts
    @f
    @g
    x
    ```

    When multiple decorators apply to a single declaration, their evaluation is similar to [function composition in mathematics](https://wikipedia.org/wiki/Function_composition). In this model, when composing functions *f* and *g*, the resulting composite (*f* ∘ *g*)(*x*) is equivalent to *f*(*g*(*x*)).

    As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:

    1.  The expressions for each decorator are evaluated top-to-bottom.
    2.  The results are then called as functions from bottom-to-top.

    If we were to use [decorator factories](#decorator-factories), we can observe this evaluation order with the following example:

    ``` ts
    function first() {
      console.log("first(): factory evaluated");
      return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("first(): called");
      };
    }
     
    function second() {
      console.log("second(): factory evaluated");
      return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("second(): called");
      };
    }
     
    class ExampleClass {
      @first()
      @second()
      method() {}
    }
    ```

    Which would print this output to the console:

    ``` shell
    first(): factory evaluated
    second(): factory evaluated
    second(): called
    first(): called
    ```
- name: 'Decorators: Decorator Evaluation'
  id: decorators#decorator-evaluation
  summary: null
  belongs_to: Decorators
  description: |-
    ## Decorator Evaluation

    There is a well defined order to how decorators applied to various declarations inside of a class are applied:

    1.  *Parameter Decorators*, followed by *Method*, *Accessor*, or *Property Decorators* are applied for each instance member.
    2.  *Parameter Decorators*, followed by *Method*, *Accessor*, or *Property Decorators* are applied for each static member.
    3.  *Parameter Decorators* are applied for the constructor.
    4.  *Class Decorators* are applied for the class.
- name: 'Decorators: Decorator Factories'
  id: decorators#decorator-factories
  summary: If we want to customize how a decorator is applied to a declaration, we can write a decorator factory
  belongs_to: Decorators
  description: |-
    ## Decorator Factories

    If we want to customize how a decorator is applied to a declaration, we can write a decorator factory. A *Decorator Factory* is simply a function that returns the expression that will be called by the decorator at runtime.

    We can write a decorator factory in the following fashion:

    ``` ts
    function color(value: string) {
      // this is the decorator factory, it sets up
      // the returned decorator function
      return function (target) {
        // this is the decorator
        // do something with 'target' and 'value'...
      };
    }
    ```
- name: 'Decorators: Decorators'
  id: decorators#decorators
  summary: A Decorator is a special kind of declaration that can be attached to a class declaration, method, accessor, property, or parameter
  belongs_to: Decorators
  description: |-
    ## Decorators

    A *Decorator* is a special kind of declaration that can be attached to a [class declaration](#class-decorators), [method](#method-decorators), [accessor](#accessor-decorators), [property](#property-decorators), or [parameter](#parameter-decorators). Decorators use the form `@expression`, where `expression` must evaluate to a function that will be called at runtime with information about the decorated declaration.

    For example, given the decorator `@sealed` we might write the `sealed` function as follows:

    ``` ts
    function sealed(target) {
      // do something with 'target' ...
    }
    ```
- name: 'Decorators: Introduction'
  id: decorators#introduction
  summary: With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members
  belongs_to: Decorators
  description: |-
    ## Introduction

    With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members.

    > Further Reading (stage 2): [A Complete Guide to TypeScript Decorators](https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator/)

    To enable experimental support for decorators, you must enable the [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators) compiler option either on the command line or in your `tsconfig.json`:

    **Command Line**:

    ``` shell
    tsc --target ES5 --experimentalDecorators
    ```

    **tsconfig.json**:

    ``` typescript
    {
      "compilerOptions": {
        "target": "ES5",
        "experimentalDecorators": true
      }
    }
    ```
- name: 'Decorators: Metadata'
  id: decorators#metadata
  summary: Some examples use the reflect-metadata library which adds a polyfill for an experimental metadata API
  belongs_to: Decorators
  description: "## Metadata\n\nSome examples use the `reflect-metadata` library which adds a polyfill for an [experimental metadata API](https://github.com/rbuckton/ReflectDecorators). This library is not yet part of the ECMAScript (JavaScript) standard. However, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.\n\nYou can install this library via npm:\n\n``` shell\nnpm i reflect-metadata --save\n```\n\nTypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators. To enable this experimental support, you must set the [`emitDecoratorMetadata`](https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata) compiler option either on the command line or in your `tsconfig.json`:\n\n**Command Line**:\n\n``` shell\ntsc --target ES5 --experimentalDecorators --emitDecoratorMetadata\n```\n\n**tsconfig.json**:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n```\n\nWhen enabled, as long as the `reflect-metadata` library has been imported, additional design-time type information will be exposed at runtime.\n\nWe can see this in action in the following example:\n\n``` ts\nimport \"reflect-metadata\";\n \nclass Point {\n  constructor(public x: number, public y: number) {}\n}\n \nclass Line {\n  private _start: Point;\n  private _end: Point;\n \n  @validate\n  set start(value: Point) {\n    this._start = value;\n  }\n \n  get start() {\n    return this._start;\n  }\n \n  @validate\n  set end(value: Point) {\n    this._end = value;\n  }\n \n  get end() {\n    return this._end;\n  }\n}\n \nfunction validate<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>) {\n  let set = descriptor.set!;\n  \n  descriptor.set = function (value: T) {\n    let type = Reflect.getMetadata(\"design:type\", target, propertyKey);\n \n    if (!(value instanceof type)) {\n      throw new TypeError(`Invalid type, got ${typeof value} not ${type.name}.`);\n    }\n \n    set.call(this, value);\n  };\n}\n \nconst line = new Line()\nline.start = new Point(0, 0)\n \n// @ts-ignore\n// line.end = {}\n \n// Fails at runtime with:\n// > Invalid type, got object not Point\n \n```\n\nThe TypeScript compiler will inject design-time type information using the `@Reflect.metadata` decorator. You could consider it the equivalent of the following TypeScript:\n\n``` ts\nclass Line {\n  private _start: Point;\n  private _end: Point;\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set start(value: Point) {\n    this._start = value;\n  }\n  get start() {\n    return this._start;\n  }\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set end(value: Point) {\n    this._end = value;\n  }\n  get end() {\n    return this._end;\n  }\n}\n```\n\n> NOTE Decorator metadata is an experimental feature and may introduce breaking changes in future releases.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/decorators.html](https://www.typescriptlang.org/docs/handbook/decorators.html)"
- name: 'Decorators: Method Decorators'
  id: decorators#method-decorators
  summary: A Method Decorator is declared just before a method declaration
  belongs_to: Decorators
  description: |-
    ## Method Decorators

    A *Method Decorator* is declared just before a method declaration. The decorator is applied to the *Property Descriptor* for the method, and can be used to observe, modify, or replace a method definition. A method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a `declare` class).

    The expression for the method decorator will be called as a function at runtime, with the following three arguments:

    1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.
    2.  The name of the member.
    3.  The *Property Descriptor* for the member.

    > NOTE The *Property Descriptor* will be `undefined` if your script target is less than `ES5`.

    If the method decorator returns a value, it will be used as the *Property Descriptor* for the method.

    > NOTE The return value is ignored if your script target is less than `ES5`.

    The following is an example of a method decorator (`@enumerable`) applied to a method on the `Greeter` class:

    ``` ts
    class Greeter {
      greeting: string;
      constructor(message: string) {
        this.greeting = message;
      }
     
      @enumerable(false)
      greet() {
        return "Hello, " + this.greeting;
      }
    }
    ```

    We can define the `@enumerable` decorator using the following function declaration:

    ``` ts
    function enumerable(value: boolean) {
      return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.enumerable = value;
      };
    }
    ```

    The `@enumerable(false)` decorator here is a [decorator factory](#decorator-factories). When the `@enumerable(false)` decorator is called, it modifies the `enumerable` property of the property descriptor.
- name: 'Decorators: Parameter Decorators'
  id: decorators#parameter-decorators
  summary: A Parameter Decorator is declared just before a parameter declaration
  belongs_to: Decorators
  description: "## Parameter Decorators\n\nA *Parameter Decorator* is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a `declare` class).\n\nThe expression for the parameter decorator will be called as a function at runtime, with the following three arguments:\n\n1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n2.  The name of the member.\n3.  The ordinal index of the parameter in the function’s parameter list.\n\n> NOTE A parameter decorator can only be used to observe that a parameter has been declared on a method.\n\nThe return value of the parameter decorator is ignored.\n\nThe following is an example of a parameter decorator (`@required`) applied to parameter of a member of the `BugReport` class:\n\n``` ts\nclass BugReport {\n  type = \"report\";\n  title: string;\n \n  constructor(t: string) {\n    this.title = t;\n  }\n \n  @validate\n  print(@required verbose: boolean) {\n    if (verbose) {\n      return `type: ${this.type}\\ntitle: ${this.title}`;\n    } else {\n     return this.title; \n    }\n  }\n}\n```\n\nWe can then define the `@required` and `@validate` decorators using the following function declarations:\n\n``` ts\nimport \"reflect-metadata\";\nconst requiredMetadataKey = Symbol(\"required\");\n \nfunction required(target: Object, propertyKey: string | symbol, parameterIndex: number) {\n  let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n  existingRequiredParameters.push(parameterIndex);\n  Reflect.defineMetadata( requiredMetadataKey, existingRequiredParameters, target, propertyKey);\n}\n \nfunction validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {\n  let method = descriptor.value!;\n \n  descriptor.value = function () {\n    let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);\n    if (requiredParameters) {\n      for (let parameterIndex of requiredParameters) {\n        if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {\n          throw new Error(\"Missing required argument.\");\n        }\n      }\n    }\n    return method.apply(this, arguments);\n  };\n}\n```\n\nThe `@required` decorator adds a metadata entry that marks the parameter as required. The `@validate` decorator then wraps the existing `print` method in a function that validates the arguments before invoking the original method.\n\n> NOTE This example requires the `reflect-metadata` library. See [Metadata](#metadata) for more information about the `reflect-metadata` library."
- name: 'Decorators: Property Decorators'
  id: decorators#property-decorators
  summary: A Property Decorator is declared just before a property declaration
  belongs_to: Decorators
  description: |-
    ## Property Decorators

    A *Property Decorator* is declared just before a property declaration. A property decorator cannot be used in a declaration file, or in any other ambient context (such as in a `declare` class).

    The expression for the property decorator will be called as a function at runtime, with the following two arguments:

    1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.
    2.  The name of the member.

    > NOTE A *Property Descriptor* is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript. This is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too. As such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.

    We can use this information to record metadata about the property, as in the following example:

    ``` ts
    class Greeter {
      @format("Hello, %s")
      greeting: string;

      constructor(message: string) {
        this.greeting = message;
      }

      greet() {
        let formatString = getFormat(this, "greeting");
        return formatString.replace("%s", this.greeting);
      }
    }
    ```

    We can then define the `@format` decorator and `getFormat` functions using the following function declarations:

    ``` ts
    import "reflect-metadata";

    const formatMetadataKey = Symbol("format");

    function format(formatString: string) {
      return Reflect.metadata(formatMetadataKey, formatString);
    }

    function getFormat(target: any, propertyKey: string) {
      return Reflect.getMetadata(formatMetadataKey, target, propertyKey);
    }
    ```

    The `@format("Hello, %s")` decorator here is a [decorator factory](#decorator-factories). When `@format("Hello, %s")` is called, it adds a metadata entry for the property using the `Reflect.metadata` function from the `reflect-metadata` library. When `getFormat` is called, it reads the metadata value for the format.

    > NOTE This example requires the `reflect-metadata` library. See [Metadata](#metadata) for more information about the `reflect-metadata` library.
- name: Deep Dive
  id: declaration-files/deep-dive
  summary: Structuring modules to give the exact API shape you want can be tricky
  description: "# Deep Dive\n\n## Declaration File Theory: A Deep Dive\n\nStructuring modules to give the exact API shape you want can be tricky. For example, we might want a module that can be invoked with or without `new` to produce different types, has a variety of named types exposed in a hierarchy, and has some properties on the module object as well.\n\nBy reading this guide, you’ll have the tools to write complex declaration files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.\n\n## Key Concepts\n\nYou can fully understand how to make any shape of declaration by understanding some key concepts of how TypeScript works.\n\n### Types\n\nIf you’re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a *type* is introduced with:\n\n- A type alias declaration (`type sn = number | string;`)\n- An interface declaration (`interface I { x: number[]; }`)\n- A class declaration (`class C { }`)\n- An enum declaration (`enum E { A, B, C }`)\n- An `import` declaration which refers to a type\n\nEach of these declaration forms creates a new type name.\n\n### Values\n\nAs with types, you probably already understand what a value is. Values are runtime names that we can reference in expressions. For example `let x = 5;` creates a value called `x`.\n\nAgain, being explicit, the following things create values:\n\n- `let`, `const`, and `var` declarations\n- A `namespace` or `module` declaration which contains a value\n- An `enum` declaration\n- A `class` declaration\n- An `import` declaration which refers to a value\n- A `function` declaration\n\n### Namespaces\n\nTypes can exist in *namespaces*. For example, if we have the declaration `let x: A.B.C`, we say that the type `C` comes from the `A.B` namespace.\n\nThis distinction is subtle and important — here, `A.B` is not necessarily a type or a value.\n\n## Simple Combinations: One name, multiple meanings\n\nGiven a name `A`, we might find up to three different meanings for `A`: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration `let m: A.A = A;`, `A` is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations!\n\nThis may seem confusing, but it’s actually very convenient as long as we don’t excessively overload things. Let’s look at some useful aspects of this combining behavior.\n\n### Built-in Combinations\n\nAstute readers will notice that, for example, `class` appeared in both the *type* and *value* lists. The declaration `class C { }` creates two things: a *type* `C` which refers to the instance shape of the class, and a *value* `C` which refers to the constructor function of the class. Enum declarations behave similarly.\n\n### User Combinations\n\nLet’s say we wrote a module file `foo.d.ts`:\n\n``` ts\nexport var SomeVar: { a: SomeType };\nexport interface SomeType {\n  count: number;\n}\n```\n\nThen consumed it:\n\n``` ts\nimport * as foo from \"./foo\";\nlet x: foo.SomeType = foo.SomeVar.a;\nconsole.log(x.count);\n```\n\nThis works well enough, but we might imagine that `SomeType` and `SomeVar` were very closely related such that you’d like them to have the same name. We can use combining to present these two different objects (the value and the type) under the same name `Bar`:\n\n``` ts\nexport var Bar: { a: Bar };\nexport interface Bar {\n  count: number;\n}\n```\n\nThis presents a very good opportunity for destructuring in the consuming code:\n\n``` ts\nimport { Bar } from \"./foo\";\nlet x: Bar = Bar.a;\nconsole.log(x.count);\n```\n\nAgain, we’ve used `Bar` as both a type and a value here. Note that we didn’t have to declare the `Bar` value as being of the `Bar` type — they’re independent.\n\n## Advanced Combinations\n\nSome kinds of declarations can be combined across multiple declarations. For example, `class C { }` and `interface C { }` can co-exist and both contribute properties to the `C` types.\n\nThis is legal as long as it does not create a conflict. A general rule of thumb is that values always conflict with other values of the same name unless they are declared as `namespace`s, types will conflict if they are declared with a type alias declaration (`type s = string`), and namespaces never conflict.\n\nLet’s see how this can be used.\n\n### Adding using an `interface`\n\nWe can add additional members to an `interface` with another `interface` declaration:\n\n``` ts\ninterface Foo {\n  x: number;\n}\n// ... elsewhere ...\ninterface Foo {\n  y: number;\n}\nlet a: Foo = ...;\nconsole.log(a.x + a.y); // OK\n```\n\nThis also works with classes:\n\n``` ts\nclass Foo {\n  x: number;\n}\n// ... elsewhere ...\ninterface Foo {\n  y: number;\n}\nlet a: Foo = ...;\nconsole.log(a.x + a.y); // OK\n```\n\nNote that we cannot add to type aliases (`type s = string;`) using an interface.\n\n### Adding using a `namespace`\n\nA `namespace` declaration can be used to add new types, values, and namespaces in any way which does not create a conflict.\n\nFor example, we can add a static member to a class:\n\n``` ts\nclass C {}\n// ... elsewhere ...\nnamespace C {\n  export let x: number;\n}\nlet y = C.x; // OK\n```\n\nNote that in this example, we added a value to the *static* side of `C` (its constructor function). This is because we added a *value*, and the container for all values is another value (types are contained by namespaces, and namespaces are contained by other namespaces).\n\nWe could also add a namespaced type to a class:\n\n``` ts\nclass C {}\n// ... elsewhere ...\nnamespace C {\n  export interface D {}\n}\nlet y: C.D; // OK\n```\n\nIn this example, there wasn’t a namespace `C` until we wrote the `namespace` declaration for it. The meaning `C` as a namespace doesn’t conflict with the value or type meanings of `C` created by the class.\n\nFinally, we could perform many different merges using `namespace` declarations. This isn’t a particularly realistic example, but shows all sorts of interesting behavior:\n\n``` ts\nnamespace X {\n  export interface Y {}\n  export class Z {}\n}\n\n// ... elsewhere ...\nnamespace X {\n  export var Y: number;\n  export namespace Z {\n    export class C {}\n  }\n}\ntype X = string;\n```\n\nIn this example, the first block creates the following name meanings:\n\n- A value `X` (because the `namespace` declaration contains a value, `Z`)\n- A namespace `X` (because the `namespace` declaration contains a type, `Y`)\n- A type `Y` in the `X` namespace\n- A type `Z` in the `X` namespace (the instance shape of the class)\n- A value `Z` that is a property of the `X` value (the constructor function of the class)\n\nThe second block creates the following name meanings:\n\n- A value `Y` (of type `number`) that is a property of the `X` value\n- A namespace `Z`\n- A value `Z` that is a property of the `X` value\n- A type `C` in the `X.Z` namespace\n- A value `C` that is a property of the `X.Z` value\n- A type `X`\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html)"
- name: 'Deep Dive: Adding using a namespace'
  id: declaration-files/deep-dive#adding-using-a-namespace
  summary: A namespace declaration can be used to add new types, values, and namespaces in any way which does not create a conflict
  belongs_to: Deep Dive
  description: "### Adding using a `namespace`\n\nA `namespace` declaration can be used to add new types, values, and namespaces in any way which does not create a conflict.\n\nFor example, we can add a static member to a class:\n\n``` ts\nclass C {}\n// ... elsewhere ...\nnamespace C {\n  export let x: number;\n}\nlet y = C.x; // OK\n```\n\nNote that in this example, we added a value to the *static* side of `C` (its constructor function). This is because we added a *value*, and the container for all values is another value (types are contained by namespaces, and namespaces are contained by other namespaces).\n\nWe could also add a namespaced type to a class:\n\n``` ts\nclass C {}\n// ... elsewhere ...\nnamespace C {\n  export interface D {}\n}\nlet y: C.D; // OK\n```\n\nIn this example, there wasn’t a namespace `C` until we wrote the `namespace` declaration for it. The meaning `C` as a namespace doesn’t conflict with the value or type meanings of `C` created by the class.\n\nFinally, we could perform many different merges using `namespace` declarations. This isn’t a particularly realistic example, but shows all sorts of interesting behavior:\n\n``` ts\nnamespace X {\n  export interface Y {}\n  export class Z {}\n}\n\n// ... elsewhere ...\nnamespace X {\n  export var Y: number;\n  export namespace Z {\n    export class C {}\n  }\n}\ntype X = string;\n```\n\nIn this example, the first block creates the following name meanings:\n\n- A value `X` (because the `namespace` declaration contains a value, `Z`)\n- A namespace `X` (because the `namespace` declaration contains a type, `Y`)\n- A type `Y` in the `X` namespace\n- A type `Z` in the `X` namespace (the instance shape of the class)\n- A value `Z` that is a property of the `X` value (the constructor function of the class)\n\nThe second block creates the following name meanings:\n\n- A value `Y` (of type `number`) that is a property of the `X` value\n- A namespace `Z`\n- A value `Z` that is a property of the `X` value\n- A type `C` in the `X.Z` namespace\n- A value `C` that is a property of the `X.Z` value\n- A type `X`\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html)"
- name: 'Deep Dive: Adding using an interface'
  id: declaration-files/deep-dive#adding-using-an-interface
  summary: Note that we cannot add to type aliases (type s = string;) using an interface
  belongs_to: Deep Dive
  description: |-
    ### Adding using an `interface`

    We can add additional members to an `interface` with another `interface` declaration:

    ``` ts
    interface Foo {
      x: number;
    }
    // ... elsewhere ...
    interface Foo {
      y: number;
    }
    let a: Foo = ...;
    console.log(a.x + a.y); // OK
    ```

    This also works with classes:

    ``` ts
    class Foo {
      x: number;
    }
    // ... elsewhere ...
    interface Foo {
      y: number;
    }
    let a: Foo = ...;
    console.log(a.x + a.y); // OK
    ```

    Note that we cannot add to type aliases (`type s = string;`) using an interface.
- name: 'Deep Dive: Advanced Combinations'
  id: declaration-files/deep-dive#advanced-combinations
  summary: Some kinds of declarations can be combined across multiple declarations
  belongs_to: Deep Dive
  description: |-
    ## Advanced Combinations

    Some kinds of declarations can be combined across multiple declarations. For example, `class C { }` and `interface C { }` can co-exist and both contribute properties to the `C` types.

    This is legal as long as it does not create a conflict. A general rule of thumb is that values always conflict with other values of the same name unless they are declared as `namespace`s, types will conflict if they are declared with a type alias declaration (`type s = string`), and namespaces never conflict.

    Let’s see how this can be used.
- name: 'Deep Dive: Declaration File Theory: A Deep Dive'
  id: declaration-files/deep-dive#declaration-file-theory-a-deep-dive
  summary: Structuring modules to give the exact API shape you want can be tricky
  belongs_to: Deep Dive
  description: |-
    ## Declaration File Theory: A Deep Dive

    Structuring modules to give the exact API shape you want can be tricky. For example, we might want a module that can be invoked with or without `new` to produce different types, has a variety of named types exposed in a hierarchy, and has some properties on the module object as well.

    By reading this guide, you’ll have the tools to write complex declaration files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.
- name: 'Deep Dive: Key Concepts'
  id: declaration-files/deep-dive#key-concepts
  summary: You can fully understand how to make any shape of declaration by understanding some key concepts of how TypeScript works
  belongs_to: Deep Dive
  description: |-
    ## Key Concepts

    You can fully understand how to make any shape of declaration by understanding some key concepts of how TypeScript works.

    ### Types

    If you’re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a *type* is introduced with:

    - A type alias declaration (`type sn = number | string;`)
    - An interface declaration (`interface I { x: number[]; }`)
    - A class declaration (`class C { }`)
    - An enum declaration (`enum E { A, B, C }`)
    - An `import` declaration which refers to a type

    Each of these declaration forms creates a new type name.

    ### Values

    As with types, you probably already understand what a value is. Values are runtime names that we can reference in expressions. For example `let x = 5;` creates a value called `x`.

    Again, being explicit, the following things create values:

    - `let`, `const`, and `var` declarations
    - A `namespace` or `module` declaration which contains a value
    - An `enum` declaration
    - A `class` declaration
    - An `import` declaration which refers to a value
    - A `function` declaration

    ### Namespaces

    Types can exist in *namespaces*. For example, if we have the declaration `let x: A.B.C`, we say that the type `C` comes from the `A.B` namespace.

    This distinction is subtle and important — here, `A.B` is not necessarily a type or a value.
- name: 'Deep Dive: Simple Combinations: One name, multiple meanings'
  id: declaration-files/deep-dive#simple-combinations-one-name-multiple-meanings
  summary: 'Given a name A, we might find up to three different meanings for A: a type, a value or a namespace'
  belongs_to: Deep Dive
  description: |-
    ## Simple Combinations: One name, multiple meanings

    Given a name `A`, we might find up to three different meanings for `A`: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration `let m: A.A = A;`, `A` is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations!

    This may seem confusing, but it’s actually very convenient as long as we don’t excessively overload things. Let’s look at some useful aspects of this combining behavior.

    ### Built-in Combinations

    Astute readers will notice that, for example, `class` appeared in both the *type* and *value* lists. The declaration `class C { }` creates two things: a *type* `C` which refers to the instance shape of the class, and a *value* `C` which refers to the constructor function of the class. Enum declarations behave similarly.

    ### User Combinations

    Let’s say we wrote a module file `foo.d.ts`:

    ``` ts
    export var SomeVar: { a: SomeType };
    export interface SomeType {
      count: number;
    }
    ```

    Then consumed it:

    ``` ts
    import * as foo from "./foo";
    let x: foo.SomeType = foo.SomeVar.a;
    console.log(x.count);
    ```

    This works well enough, but we might imagine that `SomeType` and `SomeVar` were very closely related such that you’d like them to have the same name. We can use combining to present these two different objects (the value and the type) under the same name `Bar`:

    ``` ts
    export var Bar: { a: Bar };
    export interface Bar {
      count: number;
    }
    ```

    This presents a very good opportunity for destructuring in the consuming code:

    ``` ts
    import { Bar } from "./foo";
    let x: Bar = Bar.a;
    console.log(x.count);
    ```

    Again, we’ve used `Bar` as both a type and a value here. Note that we didn’t have to declare the `Bar` value as being of the `Bar` type — they’re independent.
- name: diagnostics
  id: tsconfig/index#diagnostics-config
  summary: Used to output diagnostic information for debugging
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Diagnostics - `diagnostics`

    Used to output diagnostic information for debugging. This command is a subset of [`extendedDiagnostics`](#extendedDiagnostics) which are more user-facing results, and easier to interpret.

    If you have been asked by a TypeScript compiler engineer to give the results using this flag in a compile, in which there is no harm in using [`extendedDiagnostics`](#extendedDiagnostics) instead.

    - Deprecated
    - Related:
      - [`extendedDiagnostics`](#extendedDiagnostics)
- name: diagnostics
  id: tsconfig#diagnostics-config
  summary: Used to output diagnostic information for debugging
  belongs_to: TSConfig Reference
  description: |-
    ### Diagnostics - `diagnostics`

    Used to output diagnostic information for debugging. This command is a subset of [`extendedDiagnostics`](#extendedDiagnostics) which are more user-facing results, and easier to interpret.

    If you have been asked by a TypeScript compiler engineer to give the results using this flag in a compile, in which there is no harm in using [`extendedDiagnostics`](#extendedDiagnostics) instead.

    - Deprecated
    - Related:
      - [`extendedDiagnostics`](#extendedDiagnostics)
- name: disableFilenameBasedTypeAcquisition
  id: tsconfig#type-disableFilenameBasedTypeAcquisition-config
  summary: TypeScript’s type acquisition can infer what types should be added based on filenames in a project
  belongs_to: TSConfig Reference
  description: "### Disable Filename Based Type Acquisition - `disableFilenameBasedTypeAcquisition`\n\nTypeScript’s type acquisition can infer what types should be added based on filenames in a project. This means that having a file like `jquery.js` in your project would automatically download the types for JQuery from DefinitelyTyped.\n\nYou can disable this via `disableFilenameBasedTypeAcquisition`.\n\n``` json\n{\n  \"typeAcquisition\": {\n    \"disableFilenameBasedTypeAcquisition\": true\n  }\n}\n```\n\n- Released:\n\n  [4.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/tsconfig](https://www.typescriptlang.org/tsconfig)"
- name: disableFilenameBasedTypeAcquisition
  id: tsconfig/index#type-disableFilenameBasedTypeAcquisition-config
  summary: TypeScript’s type acquisition can infer what types should be added based on filenames in a project
  belongs_to: Intro to the TSConfig Reference
  description: "### Disable Filename Based Type Acquisition - `disableFilenameBasedTypeAcquisition`\n\nTypeScript’s type acquisition can infer what types should be added based on filenames in a project. This means that having a file like `jquery.js` in your project would automatically download the types for JQuery from DefinitelyTyped.\n\nYou can disable this via `disableFilenameBasedTypeAcquisition`.\n\n``` json\n{\n  \"typeAcquisition\": {\n    \"disableFilenameBasedTypeAcquisition\": true\n  }\n}\n```\n\n- Released:\n\n  [4.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/tsconfig/](https://www.typescriptlang.org/tsconfig/)"
- name: disableReferencedProjectLoad
  id: tsconfig/index#disableReferencedProjectLoad-config
  summary: If your project is large, you can use the flag disableReferencedProjectLoad to disable the automatic loading of all projects
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Disable Referenced Project Load - `disableReferencedProjectLoad`

    In multi-project TypeScript programs, TypeScript will load all of the available projects into memory in order to provide accurate results for editor responses which require a full knowledge graph like ‘Find All References’.

    If your project is large, you can use the flag `disableReferencedProjectLoad` to disable the automatic loading of all projects. Instead, projects are loaded dynamically as you open files through your editor.

    - Released:

      [4.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html)
- name: disableReferencedProjectLoad
  id: tsconfig#disableReferencedProjectLoad-config
  summary: If your project is large, you can use the flag disableReferencedProjectLoad to disable the automatic loading of all projects
  belongs_to: TSConfig Reference
  description: |-
    ### Disable Referenced Project Load - `disableReferencedProjectLoad`

    In multi-project TypeScript programs, TypeScript will load all of the available projects into memory in order to provide accurate results for editor responses which require a full knowledge graph like ‘Find All References’.

    If your project is large, you can use the flag `disableReferencedProjectLoad` to disable the automatic loading of all projects. Instead, projects are loaded dynamically as you open files through your editor.

    - Released:

      [4.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html)
- name: disableSizeLimit
  id: tsconfig#disableSizeLimit-config
  summary: To avoid a possible memory bloat issues when working with very large JavaScript projects, there is an upper limit to the amount of memory TypeScript will allocate
  belongs_to: TSConfig Reference
  description: |-
    ### Disable Size Limit - `disableSizeLimit`

    To avoid a possible memory bloat issues when working with very large JavaScript projects, there is an upper limit to the amount of memory TypeScript will allocate. Turning this flag on will remove the limit.
- name: disableSizeLimit
  id: tsconfig/index#disableSizeLimit-config
  summary: To avoid a possible memory bloat issues when working with very large JavaScript projects, there is an upper limit to the amount of memory TypeScript will allocate
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Disable Size Limit - `disableSizeLimit`

    To avoid a possible memory bloat issues when working with very large JavaScript projects, there is an upper limit to the amount of memory TypeScript will allocate. Turning this flag on will remove the limit.
- name: disableSolutionSearching
  id: tsconfig/index#disableSolutionSearching-config
  summary: When working with composite TypeScript projects, this option provides a way to declare that you do not want a project to be included when using features like find all references or jump to definition in an editor
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Disable Solution Searching - `disableSolutionSearching`

    When working with [composite TypeScript projects](../docs/handbook/project-references), this option provides a way to declare that you do not want a project to be included when using features like *find all references* or *jump to definition* in an editor.

    This flag is something you can use to increase responsiveness in large composite projects.

    - Released:

      [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)
- name: disableSolutionSearching
  id: tsconfig#disableSolutionSearching-config
  summary: When working with composite TypeScript projects, this option provides a way to declare that you do not want a project to be included when using features like find all references or jump to definition in an editor
  belongs_to: TSConfig Reference
  description: |-
    ### Disable Solution Searching - `disableSolutionSearching`

    When working with [composite TypeScript projects](docs/handbook/project-references), this option provides a way to declare that you do not want a project to be included when using features like *find all references* or *jump to definition* in an editor.

    This flag is something you can use to increase responsiveness in large composite projects.

    - Released:

      [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)
- name: disableSourceOfProjectReferenceRedirect
  id: tsconfig/index#disableSourceOfProjectReferenceRedirect-config
  summary: When working with composite TypeScript projects, this option provides a way to go back to the pre-3.7 behavior where d.ts files were used to as the boundaries between modules
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Disable Source Project Reference Redirect - `disableSourceOfProjectReferenceRedirect`

    When working with [composite TypeScript projects](../docs/handbook/project-references), this option provides a way to go [back to the pre-3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#build-free-editing-with-project-references) behavior where d.ts files were used to as the boundaries between modules. In 3.7 the source of truth is now your TypeScript files.

    - Released:

      [3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)
- name: disableSourceOfProjectReferenceRedirect
  id: tsconfig#disableSourceOfProjectReferenceRedirect-config
  summary: When working with composite TypeScript projects, this option provides a way to go back to the pre-3.7 behavior where d.ts files were used to as the boundaries between modules
  belongs_to: TSConfig Reference
  description: |-
    ### Disable Source Project Reference Redirect - `disableSourceOfProjectReferenceRedirect`

    When working with [composite TypeScript projects](docs/handbook/project-references), this option provides a way to go [back to the pre-3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#build-free-editing-with-project-references) behavior where d.ts files were used to as the boundaries between modules. In 3.7 the source of truth is now your TypeScript files.

    - Released:

      [3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)
- name: Do's and Don'ts
  id: declaration-files/do-s-and-don-ts
  summary: ❌ Don’t ever use the types Number, String, Boolean, Symbol, or Object These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code
  description: "# Do's and Don'ts\n\n## General Types\n\n### `Number`, `String`, `Boolean`, `Symbol` and `Object`\n\n❌ **Don’t** ever use the types `Number`, `String`, `Boolean`, `Symbol`, or `Object` These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.\n\n``` ts\n/* WRONG */\nfunction reverse(s: String): String;\n```\n\n✅ **Do** use the types `number`, `string`, `boolean`, and `symbol`.\n\n``` ts\n/* OK */\nfunction reverse(s: string): string;\n```\n\nInstead of `Object`, use the non-primitive `object` type ([added in TypeScript 2.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type)).\n\n### Generics\n\n❌ **Don’t** ever have a generic type which doesn’t use its type parameter. See more details in [TypeScript FAQ page](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot--).\n\n### any\n\n❌ **Don’t** use `any` as a type unless you are in the process of migrating a JavaScript project to TypeScript. The compiler *effectively* treats `any` as “please turn off type checking for this thing”. It is similar to putting an `@ts-ignore` comment around every usage of the variable. This can be very helpful when you are first migrating a JavaScript project to TypeScript as you can set the type for stuff you haven’t migrated yet as `any`, but in a full TypeScript project you are disabling type checking for any parts of your program that use it.\n\nIn cases where you don’t know what type you want to accept, or when you want to accept anything because you will be blindly passing it through without interacting with it, you can use [`unknown`](https://www.typescriptlang.org/play/#example/unknown-and-never).\n\n## Callback Types\n\n### Return Types of Callbacks\n\n❌ **Don’t** use the return type `any` for callbacks whose value will be ignored:\n\n``` ts\n/* WRONG */\nfunction fn(x: () => any) {\n  x();\n}\n```\n\n✅ **Do** use the return type `void` for callbacks whose value will be ignored:\n\n``` ts\n/* OK */\nfunction fn(x: () => void) {\n  x();\n}\n```\n\n❔ **Why:** Using `void` is safer because it prevents you from accidentally using the return value of `x` in an unchecked way:\n\n``` ts\nfunction fn(x: () => void) {\n  var k = x(); // oops! meant to do something else\n  k.doSomething(); // error, but would be OK if the return type had been 'any'\n}\n```\n\n### Optional Parameters in Callbacks\n\n❌ **Don’t** use optional parameters in callbacks unless you really mean it:\n\n``` ts\n/* WRONG */\ninterface Fetcher {\n  getObject(done: (data: unknown, elapsedTime?: number) => void): void;\n}\n```\n\nThis has a very specific meaning: the `done` callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the `elapsedTime` parameter, but there’s no need to make the parameter optional to accomplish this — it’s always legal to provide a callback that accepts fewer arguments.\n\n✅ **Do** write callback parameters as non-optional:\n\n``` ts\n/* OK */\ninterface Fetcher {\n  getObject(done: (data: unknown, elapsedTime: number) => void): void;\n}\n```\n\n### Overloads and Callbacks\n\n❌ **Don’t** write separate overloads that differ only on callback arity:\n\n``` ts\n/* WRONG */\ndeclare function beforeAll(action: () => void, timeout?: number): void;\ndeclare function beforeAll(\n  action: (done: DoneFn) => void,\n  timeout?: number\n): void;\n```\n\n✅ **Do** write a single overload using the maximum arity:\n\n``` ts\n/* OK */\ndeclare function beforeAll(\n  action: (done: DoneFn) => void,\n  timeout?: number\n): void;\n```\n\n❔ **Why:** It’s always legal for a callback to disregard a parameter, so there’s no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.\n\n## Function Overloads\n\n### Ordering\n\n❌ **Don’t** put more general overloads before more specific overloads:\n\n``` ts\n/* WRONG */\ndeclare function fn(x: unknown): unknown;\ndeclare function fn(x: HTMLElement): number;\ndeclare function fn(x: HTMLDivElement): string;\n\nvar myElem: HTMLDivElement;\nvar x = fn(myElem); // x: unknown, wat?\n```\n\n✅ **Do** sort overloads by putting the more general signatures after more specific signatures:\n\n``` ts\n/* OK */\ndeclare function fn(x: HTMLDivElement): string;\ndeclare function fn(x: HTMLElement): number;\ndeclare function fn(x: unknown): unknown;\n\nvar myElem: HTMLDivElement;\nvar x = fn(myElem); // x: string, :)\n```\n\n❔ **Why:** TypeScript chooses the *first matching overload* when resolving function calls. When an earlier overload is “more general” than a later one, the later one is effectively hidden and cannot be called.\n\n### Use Optional Parameters\n\n❌ **Don’t** write several overloads that differ only in trailing parameters:\n\n``` ts\n/* WRONG */\ninterface Example {\n  diff(one: string): number;\n  diff(one: string, two: string): number;\n  diff(one: string, two: string, three: boolean): number;\n}\n```\n\n✅ **Do** use optional parameters whenever possible:\n\n``` ts\n/* OK */\ninterface Example {\n  diff(one: string, two?: string, three?: boolean): number;\n}\n```\n\nNote that this collapsing should only occur when all overloads have the same return type.\n\n❔ **Why:** This is important for two reasons.\n\nTypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source, *and extraneous arguments are allowed*. This code, for example, exposes a bug only when the signature is correctly written using optional parameters:\n\n``` ts\nfunction fn(x: (a: string, b: number, c: number) => void) {}\nvar x: Example;\n// When written with overloads, OK -- used first overload\n// When written with optionals, correctly an error\nfn(x.diff);\n```\n\nThe second reason is when a consumer uses the “strict null checking” feature of TypeScript. Because unspecified parameters appear as `undefined` in JavaScript, it’s usually fine to pass an explicit `undefined` to a function with optional arguments. This code, for example, should be OK under strict nulls:\n\n``` ts\nvar x: Example;\n// When written with overloads, incorrectly an error because of passing 'undefined' to 'string'\n// When written with optionals, correctly OK\nx.diff(\"something\", true ? undefined : \"hour\");\n```\n\n### Use Union Types\n\n❌ **Don’t** write overloads that differ by type in only one argument position:\n\n``` ts\n/* WRONG */\ninterface Moment {\n  utcOffset(): number;\n  utcOffset(b: number): Moment;\n  utcOffset(b: string): Moment;\n}\n```\n\n✅ **Do** use union types whenever possible:\n\n``` ts\n/* OK */\ninterface Moment {\n  utcOffset(): number;\n  utcOffset(b: number | string): Moment;\n}\n```\n\nNote that we didn’t make `b` optional here because the return types of the signatures differ.\n\n❔ **Why:** This is important for people who are “passing through” a value to your function:\n\n``` ts\nfunction fn(x: string): Moment;\nfunction fn(x: number): Moment;\nfunction fn(x: number | string) {\n  // When written with separate overloads, incorrectly an error\n  // When written with union types, correctly OK\n  return moment().utcOffset(x);\n}\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)"
- name: 'Do''s and Don''ts: Callback Types'
  id: declaration-files/do-s-and-don-ts#callback-types
  summary: 'This has a very specific meaning: the done callback might be invoked with 1 argument or might be invoked with 2 arguments'
  belongs_to: Do's and Don'ts
  description: |-
    ## Callback Types

    ### Return Types of Callbacks

    ❌ **Don’t** use the return type `any` for callbacks whose value will be ignored:

    ``` ts
    /* WRONG */
    function fn(x: () => any) {
      x();
    }
    ```

    ✅ **Do** use the return type `void` for callbacks whose value will be ignored:

    ``` ts
    /* OK */
    function fn(x: () => void) {
      x();
    }
    ```

    ❔ **Why:** Using `void` is safer because it prevents you from accidentally using the return value of `x` in an unchecked way:

    ``` ts
    function fn(x: () => void) {
      var k = x(); // oops! meant to do something else
      k.doSomething(); // error, but would be OK if the return type had been 'any'
    }
    ```

    ### Optional Parameters in Callbacks

    ❌ **Don’t** use optional parameters in callbacks unless you really mean it:

    ``` ts
    /* WRONG */
    interface Fetcher {
      getObject(done: (data: unknown, elapsedTime?: number) => void): void;
    }
    ```

    This has a very specific meaning: the `done` callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the `elapsedTime` parameter, but there’s no need to make the parameter optional to accomplish this — it’s always legal to provide a callback that accepts fewer arguments.

    ✅ **Do** write callback parameters as non-optional:

    ``` ts
    /* OK */
    interface Fetcher {
      getObject(done: (data: unknown, elapsedTime: number) => void): void;
    }
    ```

    ### Overloads and Callbacks

    ❌ **Don’t** write separate overloads that differ only on callback arity:

    ``` ts
    /* WRONG */
    declare function beforeAll(action: () => void, timeout?: number): void;
    declare function beforeAll(
      action: (done: DoneFn) => void,
      timeout?: number
    ): void;
    ```

    ✅ **Do** write a single overload using the maximum arity:

    ``` ts
    /* OK */
    declare function beforeAll(
      action: (done: DoneFn) => void,
      timeout?: number
    ): void;
    ```

    ❔ **Why:** It’s always legal for a callback to disregard a parameter, so there’s no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.
- name: 'Do''s and Don''ts: Function Overloads'
  id: declaration-files/do-s-and-don-ts#function-overloads
  summary: '❔ Why: TypeScript chooses the first matching overload when resolving function calls'
  belongs_to: Do's and Don'ts
  description: "## Function Overloads\n\n### Ordering\n\n❌ **Don’t** put more general overloads before more specific overloads:\n\n``` ts\n/* WRONG */\ndeclare function fn(x: unknown): unknown;\ndeclare function fn(x: HTMLElement): number;\ndeclare function fn(x: HTMLDivElement): string;\n\nvar myElem: HTMLDivElement;\nvar x = fn(myElem); // x: unknown, wat?\n```\n\n✅ **Do** sort overloads by putting the more general signatures after more specific signatures:\n\n``` ts\n/* OK */\ndeclare function fn(x: HTMLDivElement): string;\ndeclare function fn(x: HTMLElement): number;\ndeclare function fn(x: unknown): unknown;\n\nvar myElem: HTMLDivElement;\nvar x = fn(myElem); // x: string, :)\n```\n\n❔ **Why:** TypeScript chooses the *first matching overload* when resolving function calls. When an earlier overload is “more general” than a later one, the later one is effectively hidden and cannot be called.\n\n### Use Optional Parameters\n\n❌ **Don’t** write several overloads that differ only in trailing parameters:\n\n``` ts\n/* WRONG */\ninterface Example {\n  diff(one: string): number;\n  diff(one: string, two: string): number;\n  diff(one: string, two: string, three: boolean): number;\n}\n```\n\n✅ **Do** use optional parameters whenever possible:\n\n``` ts\n/* OK */\ninterface Example {\n  diff(one: string, two?: string, three?: boolean): number;\n}\n```\n\nNote that this collapsing should only occur when all overloads have the same return type.\n\n❔ **Why:** This is important for two reasons.\n\nTypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source, *and extraneous arguments are allowed*. This code, for example, exposes a bug only when the signature is correctly written using optional parameters:\n\n``` ts\nfunction fn(x: (a: string, b: number, c: number) => void) {}\nvar x: Example;\n// When written with overloads, OK -- used first overload\n// When written with optionals, correctly an error\nfn(x.diff);\n```\n\nThe second reason is when a consumer uses the “strict null checking” feature of TypeScript. Because unspecified parameters appear as `undefined` in JavaScript, it’s usually fine to pass an explicit `undefined` to a function with optional arguments. This code, for example, should be OK under strict nulls:\n\n``` ts\nvar x: Example;\n// When written with overloads, incorrectly an error because of passing 'undefined' to 'string'\n// When written with optionals, correctly OK\nx.diff(\"something\", true ? undefined : \"hour\");\n```\n\n### Use Union Types\n\n❌ **Don’t** write overloads that differ by type in only one argument position:\n\n``` ts\n/* WRONG */\ninterface Moment {\n  utcOffset(): number;\n  utcOffset(b: number): Moment;\n  utcOffset(b: string): Moment;\n}\n```\n\n✅ **Do** use union types whenever possible:\n\n``` ts\n/* OK */\ninterface Moment {\n  utcOffset(): number;\n  utcOffset(b: number | string): Moment;\n}\n```\n\nNote that we didn’t make `b` optional here because the return types of the signatures differ.\n\n❔ **Why:** This is important for people who are “passing through” a value to your function:\n\n``` ts\nfunction fn(x: string): Moment;\nfunction fn(x: number): Moment;\nfunction fn(x: number | string) {\n  // When written with separate overloads, incorrectly an error\n  // When written with union types, correctly OK\n  return moment().utcOffset(x);\n}\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)"
- name: 'Do''s and Don''ts: General Types'
  id: declaration-files/do-s-and-don-ts#general-types
  summary: null
  belongs_to: Do's and Don'ts
  description: '## General Types'
- name: 'Do''s and Don''ts: Number, String, Boolean, Symbol and Object'
  id: declaration-files/do-s-and-don-ts#number-string-boolean-symbol-and-object
  summary: ❌ Don’t ever use the types Number, String, Boolean, Symbol, or Object These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code
  belongs_to: Do's and Don'ts
  description: |-
    ### `Number`, `String`, `Boolean`, `Symbol` and `Object`

    ❌ **Don’t** ever use the types `Number`, `String`, `Boolean`, `Symbol`, or `Object` These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.

    ``` ts
    /* WRONG */
    function reverse(s: String): String;
    ```

    ✅ **Do** use the types `number`, `string`, `boolean`, and `symbol`.

    ``` ts
    /* OK */
    function reverse(s: string): string;
    ```

    Instead of `Object`, use the non-primitive `object` type ([added in TypeScript 2.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type)).

    ### Generics

    ❌ **Don’t** ever have a generic type which doesn’t use its type parameter. See more details in [TypeScript FAQ page](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot--).

    ### any

    ❌ **Don’t** use `any` as a type unless you are in the process of migrating a JavaScript project to TypeScript. The compiler *effectively* treats `any` as “please turn off type checking for this thing”. It is similar to putting an `@ts-ignore` comment around every usage of the variable. This can be very helpful when you are first migrating a JavaScript project to TypeScript as you can set the type for stuff you haven’t migrated yet as `any`, but in a full TypeScript project you are disabling type checking for any parts of your program that use it.

    In cases where you don’t know what type you want to accept, or when you want to accept anything because you will be blindly passing it through without interacting with it, you can use [`unknown`](https://www.typescriptlang.org/play/#example/unknown-and-never).
- name: DOM Manipulation
  id: dom-manipulation
  summary: In the 20+ years since its standardization, JavaScript has come a very long way
  description: "# DOM Manipulation\n\n## DOM Manipulation\n\n### *An exploration into the `HTMLElement` type*\n\nIn the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers.\n\nWebsites are made up of HTML and/or XML documents. These documents are static, they do not change. The *Document Object Model (DOM)* is a programming interface implemented by browsers to make static websites functional. The DOM API can be used to change the document structure, style, and content. The API is so powerful that countless frontend frameworks (jQuery, React, Angular, etc.) have been developed around it to make dynamic websites even easier to develop.\n\nTypeScript is a typed superset of JavaScript, and it ships type definitions for the DOM API. These definitions are readily available in any default TypeScript project. Of the 20,000+ lines of definitions in *lib.dom.d.ts*, one stands out among the rest: `HTMLElement`. This type is the backbone for DOM manipulation with TypeScript.\n\n> You can explore the source code for the [DOM type definitions](https://github.com/microsoft/TypeScript/blob/main/src/lib/dom.generated.d.ts)\n\n## Basic Example\n\nGiven a simplified *index.html* file:\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head><title>TypeScript Dom Manipulation</title></head>\n  <body>\n    <div id=\"app\"></div>\n    <!-- Assume index.js is the compiled output of index.ts -->\n    <script src=\"index.js\"></script>\n  </body>\n</html>\n```\n\nLet’s explore a TypeScript script that adds a `<p>Hello, World!</p>` element to the `#app` element.\n\n``` ts\n// 1. Select the div element using the id property\nconst app = document.getElementById(\"app\");\n\n// 2. Create a new <p></p> element programmatically\nconst p = document.createElement(\"p\");\n\n// 3. Add the text content\np.textContent = \"Hello, World!\";\n\n// 4. Append the p element to the div element\napp?.appendChild(p);\n```\n\nAfter compiling and running the *index.html* page, the resulting HTML will be:\n\n``` html\n<div id=\"app\">\n  <p>Hello, World!</p>\n</div>\n```\n\n## The `Document` Interface\n\nThe first line of the TypeScript code uses a global variable `document`. Inspecting the variable shows it is defined by the `Document` interface from the *lib.dom.d.ts* file. The code snippet contains calls to two methods, `getElementById` and `createElement`.\n\n### `Document.getElementById`\n\nThe definition for this method is as follows:\n\n``` ts\ngetElementById(elementId: string): HTMLElement | null;\n```\n\nPass it an element id string and it will return either `HTMLElement` or `null`. This method introduces one of the most important types, `HTMLElement`. It serves as the base interface for every other element interface. For example, the `p` variable in the code example is of type `HTMLParagraphElement`. Also, take note that this method can return `null`. This is because the method can’t be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the new *optional chaining* operator is used to call `appendChild`.\n\n### `Document.createElement`\n\nThe definition for this method is (I have omitted the *deprecated* definition):\n\n``` ts\ncreateElement<K extends keyof HTMLElementTagNameMap>(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K];\ncreateElement(tagName: string, options?: ElementCreationOptions): HTMLElement;\n```\n\nThis is an overloaded function definition. The second overload is simplest and works a lot like the `getElementById` method does. Pass it any `string` and it will return a standard HTMLElement. This definition is what enables developers to create unique HTML element tags.\n\nFor example `document.createElement('xyz')` returns a `<xyz></xyz>` element, clearly not an element that is specified by the HTML specification.\n\n> For those interested, you can interact with custom tag elements using the `document.getElementsByTagName`\n\nFor the first definition of `createElement`, it is using some advanced generic patterns. It is best understood broken down into chunks, starting with the generic expression: `<K extends keyof HTMLElementTagNameMap>`. This expression defines a generic parameter `K` that is *constrained* to the keys of the interface `HTMLElementTagNameMap`. The map interface contains every specified HTML tag name and its corresponding type interface. For example here are the first 5 mapped values:\n\n``` ts\ninterface HTMLElementTagNameMap {\n    \"a\": HTMLAnchorElement;\n    \"abbr\": HTMLElement;\n    \"address\": HTMLElement;\n    \"applet\": HTMLAppletElement;\n    \"area\": HTMLAreaElement;\n        ...\n}\n```\n\nSome elements do not exhibit unique properties and so they just return `HTMLElement`, but other types do have unique properties and methods so they return their specific interface (which will extend from or implement `HTMLElement`).\n\nNow, for the remainder of the `createElement` definition: `(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]`. The first argument `tagName` is defined as the generic parameter `K`. The TypeScript interpreter is smart enough to *infer* the generic parameter from this argument. This means that the developer does not have to specify the generic parameter when using the method; whatever value is passed to the `tagName` argument will be inferred as `K` and thus can be used throughout the remainder of the definition. This is exactly what happens; the return value `HTMLElementTagNameMap[K]` takes the `tagName` argument and uses it to return the corresponding type. This definition is how the `p` variable from the code snippet gets a type of `HTMLParagraphElement`. And if the code was `document.createElement('a')`, then it would be an element of type `HTMLAnchorElement`.\n\n## The `Node` interface\n\nThe `document.getElementById` function returns an `HTMLElement`. `HTMLElement` interface extends the `Element` interface which extends the `Node` interface. This prototypal extension allows for all `HTMLElements` to utilize a subset of standard methods. In the code snippet, we use a property defined on the `Node` interface to append the new `p` element to the website.\n\n### `Node.appendChild`\n\nThe last line of the code snippet is `app?.appendChild(p)`. The previous, `document.getElementById`, section detailed that the *optional chaining* operator is used here because `app` can potentially be null at runtime. The `appendChild` method is defined by:\n\n``` ts\nappendChild<T extends Node>(newChild: T): T;\n```\n\nThis method works similarly to the `createElement` method as the generic parameter `T` is inferred from the `newChild` argument. `T` is *constrained* to another base interface `Node`.\n\n## Difference between `children` and `childNodes`\n\nPreviously, this document details the `HTMLElement` interface extends from `Element` which extends from `Node`. In the DOM API there is a concept of *children* elements. For example in the following HTML, the `p` tags are children of the `div` element\n\n``` typescript+html\n<div>\n  <p>Hello, World</p>\n  <p>TypeScript!</p>\n</div>;\n\nconst div = document.getElementsByTagName(\"div\")[0];\n\ndiv.children;\n// HTMLCollection(2) [p, p]\n\ndiv.childNodes;\n// NodeList(2) [p, p]\n```\n\nAfter capturing the `div` element, the `children` prop will return an `HTMLCollection` list containing the `HTMLParagraphElements`. The `childNodes` property will return a similar `NodeList` list of nodes. Each `p` tag will still be of type `HTMLParagraphElements`, but the `NodeList` can contain additional *HTML nodes* that the `HTMLCollection` list cannot.\n\nModify the HTML by removing one of the `p` tags, but keep the text.\n\n``` typescript+html\n<div>\n  <p>Hello, World</p>\n  TypeScript!\n</div>;\n\nconst div = document.getElementsByTagName(\"div\")[0];\n\ndiv.children;\n// HTMLCollection(1) [p]\n\ndiv.childNodes;\n// NodeList(2) [p, text]\n```\n\nSee how both lists change. `children` now only contains the `<p>Hello, World</p>` element, and the `childNodes` contains a `text` node rather than two `p` nodes. The `text` part of the `NodeList` is the literal `Node` containing the text `TypeScript!`. The `children` list does not contain this `Node` because it is not considered an `HTMLElement`.\n\n## The `querySelector` and `querySelectorAll` methods\n\nBoth of these methods are great tools for getting lists of dom elements that fit a more unique set of constraints. They are defined in *lib.dom.d.ts* as:\n\n``` ts\n/**\n * Returns the first element that is a descendant of node that matches selectors.\n */\nquerySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;\nquerySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;\nquerySelector<E extends Element = Element>(selectors: string): E | null;\n\n/**\n * Returns all element descendants of node that match selectors.\n */\nquerySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;\nquerySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>;\nquerySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;\n```\n\nThe `querySelectorAll` definition is similar to `getElementsByTagName`, except it returns a new type: `NodeListOf`. This return type is essentially a custom implementation of the standard JavaScript list element. Arguably, replacing `NodeListOf<E>` with `E[]` would result in a very similar user experience. `NodeListOf` only implements the following properties and methods: `length`, `item(index)`, `forEach((value, key, parent) => void)`, and numeric indexing. Additionally, this method returns a list of *elements*, not *nodes*, which is what `NodeList` was returning from the `.childNodes` method. While this may appear as a discrepancy, take note that interface `Element` extends from `Node`.\n\nTo see these methods in action modify the existing code to:\n\n``` typescript+html\n<ul>\n  <li>First :)</li>\n  <li>Second!</li>\n  <li>Third times a charm.</li>\n</ul>;\n\nconst first = document.querySelector(\"li\"); // returns the first li element\nconst all = document.querySelectorAll(\"li\"); // returns the list of all li elements\n```\n\n## Interested in learning more?\n\nThe best part about the *lib.dom.d.ts* type definitions is that they are reflective of the types annotated in the Mozilla Developer Network (MDN) documentation site. For example, the `HTMLElement` interface is documented by this [HTMLElement page](https://developer.mozilla.org/docs/Web/API/HTMLElement) on MDN. These pages list all available properties, methods, and sometimes even examples. Another great aspect of the pages is that they provide links to the corresponding standard documents. Here is the link to the [W3C Recommendation for HTMLElement](https://www.w3.org/TR/html52/dom.html#htmlelement).\n\nSources:\n\n- [ECMA-262 Standard](http://www.ecma-international.org/ecma-262/10.0/index.html)\n- [Introduction to the DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/dom-manipulation.html](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html)"
- name: 'DOM Manipulation: An exploration into the HTMLElement type'
  id: dom-manipulation#an-exploration-into-the-htmlelement-type
  summary: In the 20+ years since its standardization, JavaScript has come a very long way
  belongs_to: DOM Manipulation
  description: |-
    ### *An exploration into the `HTMLElement` type*

    In the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers.

    Websites are made up of HTML and/or XML documents. These documents are static, they do not change. The *Document Object Model (DOM)* is a programming interface implemented by browsers to make static websites functional. The DOM API can be used to change the document structure, style, and content. The API is so powerful that countless frontend frameworks (jQuery, React, Angular, etc.) have been developed around it to make dynamic websites even easier to develop.

    TypeScript is a typed superset of JavaScript, and it ships type definitions for the DOM API. These definitions are readily available in any default TypeScript project. Of the 20,000+ lines of definitions in *lib.dom.d.ts*, one stands out among the rest: `HTMLElement`. This type is the backbone for DOM manipulation with TypeScript.

    > You can explore the source code for the [DOM type definitions](https://github.com/microsoft/TypeScript/blob/main/src/lib/dom.generated.d.ts)
- name: 'DOM Manipulation: Basic Example'
  id: dom-manipulation#basic-example
  summary: 'Let’s explore a TypeScript script that adds a <p>Hello, World!</p> element to the #app element'
  belongs_to: DOM Manipulation
  description: |-
    ## Basic Example

    Given a simplified *index.html* file:

    ``` html
    <!DOCTYPE html>
    <html lang="en">
      <head><title>TypeScript Dom Manipulation</title></head>
      <body>
        <div id="app"></div>
        <!-- Assume index.js is the compiled output of index.ts -->
        <script src="index.js"></script>
      </body>
    </html>
    ```

    Let’s explore a TypeScript script that adds a `<p>Hello, World!</p>` element to the `#app` element.

    ``` ts
    // 1. Select the div element using the id property
    const app = document.getElementById("app");

    // 2. Create a new <p></p> element programmatically
    const p = document.createElement("p");

    // 3. Add the text content
    p.textContent = "Hello, World!";

    // 4. Append the p element to the div element
    app?.appendChild(p);
    ```

    After compiling and running the *index.html* page, the resulting HTML will be:

    ``` html
    <div id="app">
      <p>Hello, World!</p>
    </div>
    ```
- name: 'DOM Manipulation: Difference between children and childNodes'
  id: dom-manipulation#difference-between-children-and-childnodes
  summary: Previously, this document details the HTMLElement interface extends from Element which extends from Node
  belongs_to: DOM Manipulation
  description: |-
    ## Difference between `children` and `childNodes`

    Previously, this document details the `HTMLElement` interface extends from `Element` which extends from `Node`. In the DOM API there is a concept of *children* elements. For example in the following HTML, the `p` tags are children of the `div` element

    ``` typescript+html
    <div>
      <p>Hello, World</p>
      <p>TypeScript!</p>
    </div>;

    const div = document.getElementsByTagName("div")[0];

    div.children;
    // HTMLCollection(2) [p, p]

    div.childNodes;
    // NodeList(2) [p, p]
    ```

    After capturing the `div` element, the `children` prop will return an `HTMLCollection` list containing the `HTMLParagraphElements`. The `childNodes` property will return a similar `NodeList` list of nodes. Each `p` tag will still be of type `HTMLParagraphElements`, but the `NodeList` can contain additional *HTML nodes* that the `HTMLCollection` list cannot.

    Modify the HTML by removing one of the `p` tags, but keep the text.

    ``` typescript+html
    <div>
      <p>Hello, World</p>
      TypeScript!
    </div>;

    const div = document.getElementsByTagName("div")[0];

    div.children;
    // HTMLCollection(1) [p]

    div.childNodes;
    // NodeList(2) [p, text]
    ```

    See how both lists change. `children` now only contains the `<p>Hello, World</p>` element, and the `childNodes` contains a `text` node rather than two `p` nodes. The `text` part of the `NodeList` is the literal `Node` containing the text `TypeScript!`. The `children` list does not contain this `Node` because it is not considered an `HTMLElement`.
- name: 'DOM Manipulation: Document.createElement'
  id: dom-manipulation#documentcreateelement
  summary: This is an overloaded function definition
  belongs_to: DOM Manipulation
  description: |-
    ### `Document.createElement`

    The definition for this method is (I have omitted the *deprecated* definition):

    ``` ts
    createElement<K extends keyof HTMLElementTagNameMap>(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K];
    createElement(tagName: string, options?: ElementCreationOptions): HTMLElement;
    ```

    This is an overloaded function definition. The second overload is simplest and works a lot like the `getElementById` method does. Pass it any `string` and it will return a standard HTMLElement. This definition is what enables developers to create unique HTML element tags.

    For example `document.createElement('xyz')` returns a `<xyz></xyz>` element, clearly not an element that is specified by the HTML specification.

    > For those interested, you can interact with custom tag elements using the `document.getElementsByTagName`

    For the first definition of `createElement`, it is using some advanced generic patterns. It is best understood broken down into chunks, starting with the generic expression: `<K extends keyof HTMLElementTagNameMap>`. This expression defines a generic parameter `K` that is *constrained* to the keys of the interface `HTMLElementTagNameMap`. The map interface contains every specified HTML tag name and its corresponding type interface. For example here are the first 5 mapped values:

    ``` ts
    interface HTMLElementTagNameMap {
        "a": HTMLAnchorElement;
        "abbr": HTMLElement;
        "address": HTMLElement;
        "applet": HTMLAppletElement;
        "area": HTMLAreaElement;
            ...
    }
    ```

    Some elements do not exhibit unique properties and so they just return `HTMLElement`, but other types do have unique properties and methods so they return their specific interface (which will extend from or implement `HTMLElement`).

    Now, for the remainder of the `createElement` definition: `(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]`. The first argument `tagName` is defined as the generic parameter `K`. The TypeScript interpreter is smart enough to *infer* the generic parameter from this argument. This means that the developer does not have to specify the generic parameter when using the method; whatever value is passed to the `tagName` argument will be inferred as `K` and thus can be used throughout the remainder of the definition. This is exactly what happens; the return value `HTMLElementTagNameMap[K]` takes the `tagName` argument and uses it to return the corresponding type. This definition is how the `p` variable from the code snippet gets a type of `HTMLParagraphElement`. And if the code was `document.createElement('a')`, then it would be an element of type `HTMLAnchorElement`.
- name: 'DOM Manipulation: Document.getElementById'
  id: dom-manipulation#documentgetelementbyid
  summary: Pass it an element id string and it will return either HTMLElement or null
  belongs_to: DOM Manipulation
  description: |-
    ### `Document.getElementById`

    The definition for this method is as follows:

    ``` ts
    getElementById(elementId: string): HTMLElement | null;
    ```

    Pass it an element id string and it will return either `HTMLElement` or `null`. This method introduces one of the most important types, `HTMLElement`. It serves as the base interface for every other element interface. For example, the `p` variable in the code example is of type `HTMLParagraphElement`. Also, take note that this method can return `null`. This is because the method can’t be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the new *optional chaining* operator is used to call `appendChild`.
- name: 'DOM Manipulation: DOM Manipulation'
  id: dom-manipulation#dom-manipulation
  summary: null
  belongs_to: DOM Manipulation
  description: '## DOM Manipulation'
- name: 'DOM Manipulation: Interested in learning more?'
  id: dom-manipulation#interested-in-learning-more
  summary: The best part about the lib.dom.d.ts type definitions is that they are reflective of the types annotated in the Mozilla Developer Network (MDN) documentation site
  belongs_to: DOM Manipulation
  description: "## Interested in learning more?\n\nThe best part about the *lib.dom.d.ts* type definitions is that they are reflective of the types annotated in the Mozilla Developer Network (MDN) documentation site. For example, the `HTMLElement` interface is documented by this [HTMLElement page](https://developer.mozilla.org/docs/Web/API/HTMLElement) on MDN. These pages list all available properties, methods, and sometimes even examples. Another great aspect of the pages is that they provide links to the corresponding standard documents. Here is the link to the [W3C Recommendation for HTMLElement](https://www.w3.org/TR/html52/dom.html#htmlelement).\n\nSources:\n\n- [ECMA-262 Standard](http://www.ecma-international.org/ecma-262/10.0/index.html)\n- [Introduction to the DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/dom-manipulation.html](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html)"
- name: 'DOM Manipulation: Node.appendChild'
  id: dom-manipulation#nodeappendchild
  summary: The last line of the code snippet is app?.appendChild(p). The previous, document.getElementById, section detailed that the optional chaining operator is used here because app can potentially be null at runtime
  belongs_to: DOM Manipulation
  description: |-
    ### `Node.appendChild`

    The last line of the code snippet is `app?.appendChild(p)`. The previous, `document.getElementById`, section detailed that the *optional chaining* operator is used here because `app` can potentially be null at runtime. The `appendChild` method is defined by:

    ``` ts
    appendChild<T extends Node>(newChild: T): T;
    ```

    This method works similarly to the `createElement` method as the generic parameter `T` is inferred from the `newChild` argument. `T` is *constrained* to another base interface `Node`.
- name: 'DOM Manipulation: The Document Interface'
  id: dom-manipulation#the-document-interface
  summary: The first line of the TypeScript code uses a global variable document
  belongs_to: DOM Manipulation
  description: |-
    ## The `Document` Interface

    The first line of the TypeScript code uses a global variable `document`. Inspecting the variable shows it is defined by the `Document` interface from the *lib.dom.d.ts* file. The code snippet contains calls to two methods, `getElementById` and `createElement`.
- name: 'DOM Manipulation: The Node interface'
  id: dom-manipulation#the-node-interface
  summary: The document.getElementById function returns an HTMLElement
  belongs_to: DOM Manipulation
  description: |-
    ## The `Node` interface

    The `document.getElementById` function returns an `HTMLElement`. `HTMLElement` interface extends the `Element` interface which extends the `Node` interface. This prototypal extension allows for all `HTMLElements` to utilize a subset of standard methods. In the code snippet, we use a property defined on the `Node` interface to append the new `p` element to the website.
- name: 'DOM Manipulation: The querySelector and querySelectorAll methods'
  id: dom-manipulation#the-queryselector-and-queryselectorall-methods
  summary: Both of these methods are great tools for getting lists of dom elements that fit a more unique set of constraints
  belongs_to: DOM Manipulation
  description: |-
    ## The `querySelector` and `querySelectorAll` methods

    Both of these methods are great tools for getting lists of dom elements that fit a more unique set of constraints. They are defined in *lib.dom.d.ts* as:

    ``` ts
    /**
     * Returns the first element that is a descendant of node that matches selectors.
     */
    querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;
    querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;
    querySelector<E extends Element = Element>(selectors: string): E | null;

    /**
     * Returns all element descendants of node that match selectors.
     */
    querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;
    querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>;
    querySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;
    ```

    The `querySelectorAll` definition is similar to `getElementsByTagName`, except it returns a new type: `NodeListOf`. This return type is essentially a custom implementation of the standard JavaScript list element. Arguably, replacing `NodeListOf<E>` with `E[]` would result in a very similar user experience. `NodeListOf` only implements the following properties and methods: `length`, `item(index)`, `forEach((value, key, parent) => void)`, and numeric indexing. Additionally, this method returns a list of *elements*, not *nodes*, which is what `NodeList` was returning from the `.childNodes` method. While this may appear as a discrepancy, take note that interface `Element` extends from `Node`.

    To see these methods in action modify the existing code to:

    ``` typescript+html
    <ul>
      <li>First :)</li>
      <li>Second!</li>
      <li>Third times a charm.</li>
    </ul>;

    const first = document.querySelector("li"); // returns the first li element
    const all = document.querySelectorAll("li"); // returns the list of all li elements
    ```
- name: downlevelIteration
  id: tsconfig#downlevelIteration-config
  summary: Downleveling is TypeScript’s term for transpiling to an older version of JavaScript
  belongs_to: TSConfig Reference
  description: |-
    ### Downlevel Iteration - `downlevelIteration`

    Downleveling is TypeScript’s term for transpiling to an older version of JavaScript. This flag is to enable support for a more accurate implementation of how modern JavaScript iterates through new concepts in older JavaScript runtimes.

    ECMAScript 6 added several new iteration primitives: the `for / of` loop (`for (el of arr)`), Array spread (`[a, ...b]`), argument spread (`fn(...args)`), and `Symbol.iterator`. `downlevelIteration` allows for these iteration primitives to be used more accurately in ES5 environments if a `Symbol.iterator` implementation is present.

    #### Example: Effects on `for / of`

    With this TypeScript code:

    ``` ts
    const str = "Hello!";
    for (const s of str) {
      console.log(s);
    }
    ```

    Without `downlevelIteration` enabled, a `for / of` loop on any object is downleveled to a traditional `for` loop:

    ``` ts
    "use strict";
    var str = "Hello!";
    for (var _i = 0, str_1 = str; _i < str_1.length; _i++) {
        var s = str_1[_i];
        console.log(s);
    }
     
    ```

    This is often what people expect, but it’s not 100% compliant with ECMAScript iteration protocol. Certain strings, such as emoji (😜), have a `.length` of 2 (or even more!), but should iterate as 1 unit in a `for-of` loop. See [this blog post by Jonathan New](https://blog.jonnew.com/posts/poo-dot-length-equals-two) for a longer explanation.

    When `downlevelIteration` is enabled, TypeScript will use a helper function that checks for a `Symbol.iterator` implementation (either native or polyfill). If this implementation is missing, you’ll fall back to index-based iteration.

    ``` ts
    "use strict";
    var __values = (this && this.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var e_1, _a;
    var str = "Hello!";
    try {
        for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {
            var s = str_1_1.value;
            console.log(s);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
     
    ```

    You can use [tslib](https://www.npmjs.com/package/tslib) via [`importHelpers`](#importHelpers) to reduce the amount of inline JavaScript too:

    ``` ts
    "use strict";
    var __values = (this && this.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var e_1, _a;
    var str = "Hello!";
    try {
        for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {
            var s = str_1_1.value;
            console.log(s);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
     
    ```

    **Note:** enabling `downlevelIteration` does not improve compliance if `Symbol.iterator` is not present in the runtime.

    #### Example: Effects on Array Spreads

    This is an array spread:

    ``` js
    // Make a new array whose elements are 1 followed by the elements of arr2
    const arr = [1, ...arr2];
    ```

    Based on the description, it sounds easy to downlevel to ES5:

    ``` js
    // The same, right?
    const arr = [1].concat(arr2);
    ```

    However, this is observably different in certain rare cases.

    For example, if a source array is missing one or more items (contains a hole), the spread syntax will replace each empty item with `undefined`, whereas `.concat` will leave them intact.

    ``` js
    // Make an array where the element at index 1 is missing
    let arrayWithHole = ["a", , "c"];
    let spread = [...arrayWithHole];
    let concatenated = [].concat(arrayWithHole);

    console.log(arrayWithHole);
    // [ 'a', <1 empty item>, 'c' ]
    console.log(spread);
    // [ 'a', undefined, 'c' ]
    console.log(concatenated);
    // [ 'a', <1 empty item>, 'c' ]
    ```

    Just as with `for / of`, `downlevelIteration` will use `Symbol.iterator` (if present) to more accurately emulate ES 6 behavior.

    - Related:
      - [`importHelpers`](#importHelpers)

    - Released:

      [2.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html)
- name: downlevelIteration
  id: tsconfig/index#downlevelIteration-config
  summary: Downleveling is TypeScript’s term for transpiling to an older version of JavaScript
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Downlevel Iteration - `downlevelIteration`

    Downleveling is TypeScript’s term for transpiling to an older version of JavaScript. This flag is to enable support for a more accurate implementation of how modern JavaScript iterates through new concepts in older JavaScript runtimes.

    ECMAScript 6 added several new iteration primitives: the `for / of` loop (`for (el of arr)`), Array spread (`[a, ...b]`), argument spread (`fn(...args)`), and `Symbol.iterator`. `downlevelIteration` allows for these iteration primitives to be used more accurately in ES5 environments if a `Symbol.iterator` implementation is present.

    #### Example: Effects on `for / of`

    With this TypeScript code:

    ``` ts
    const str = "Hello!";
    for (const s of str) {
      console.log(s);
    }
    ```

    Without `downlevelIteration` enabled, a `for / of` loop on any object is downleveled to a traditional `for` loop:

    ``` ts
    "use strict";
    var str = "Hello!";
    for (var _i = 0, str_1 = str; _i < str_1.length; _i++) {
        var s = str_1[_i];
        console.log(s);
    }
     
    ```

    This is often what people expect, but it’s not 100% compliant with ECMAScript iteration protocol. Certain strings, such as emoji (😜), have a `.length` of 2 (or even more!), but should iterate as 1 unit in a `for-of` loop. See [this blog post by Jonathan New](https://blog.jonnew.com/posts/poo-dot-length-equals-two) for a longer explanation.

    When `downlevelIteration` is enabled, TypeScript will use a helper function that checks for a `Symbol.iterator` implementation (either native or polyfill). If this implementation is missing, you’ll fall back to index-based iteration.

    ``` ts
    "use strict";
    var __values = (this && this.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var e_1, _a;
    var str = "Hello!";
    try {
        for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {
            var s = str_1_1.value;
            console.log(s);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
     
    ```

    You can use [tslib](https://www.npmjs.com/package/tslib) via [`importHelpers`](#importHelpers) to reduce the amount of inline JavaScript too:

    ``` ts
    "use strict";
    var __values = (this && this.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var e_1, _a;
    var str = "Hello!";
    try {
        for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {
            var s = str_1_1.value;
            console.log(s);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
     
    ```

    **Note:** enabling `downlevelIteration` does not improve compliance if `Symbol.iterator` is not present in the runtime.

    #### Example: Effects on Array Spreads

    This is an array spread:

    ``` js
    // Make a new array whose elements are 1 followed by the elements of arr2
    const arr = [1, ...arr2];
    ```

    Based on the description, it sounds easy to downlevel to ES5:

    ``` js
    // The same, right?
    const arr = [1].concat(arr2);
    ```

    However, this is observably different in certain rare cases.

    For example, if a source array is missing one or more items (contains a hole), the spread syntax will replace each empty item with `undefined`, whereas `.concat` will leave them intact.

    ``` js
    // Make an array where the element at index 1 is missing
    let arrayWithHole = ["a", , "c"];
    let spread = [...arrayWithHole];
    let concatenated = [].concat(arrayWithHole);

    console.log(arrayWithHole);
    // [ 'a', <1 empty item>, 'c' ]
    console.log(spread);
    // [ 'a', undefined, 'c' ]
    console.log(concatenated);
    // [ 'a', <1 empty item>, 'c' ]
    ```

    Just as with `for / of`, `downlevelIteration` will use `Symbol.iterator` (if present) to more accurately emulate ES 6 behavior.

    - Related:
      - [`importHelpers`](#importHelpers)

    - Released:

      [2.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html)
- name: Download TypeScript
  id: download/index
  summary: 'TypeScript can be installed through three installation routes depending on how you intend to use it: an npm module, a NuGet package or a Visual Studio Extension'
  description: "# Download TypeScript\n\n# Download TypeScript\n\nTypeScript can be installed through three installation routes depending on how you intend to use it: an npm module, a NuGet package or a Visual Studio Extension.\n\nIf you are using Node.js, you want the npm version. If you are using MSBuild in your project, you want the NuGet package or Visual Studio extension.\n\n## TypeScript in Your Project\n\nHaving TypeScript set up on a per-project basis lets you have many projects with many different versions of TypeScript, this keeps each project working consistently.\n\n### via npm\n\nTypeScript is available as a [package on the npm registry](https://www.npmjs.com/package/typescript) available as `\"typescript\"`.\n\nYou will need a copy of [Node.js](https://nodejs.org/en/ \"Link to the node.js project\") as an environment to run the package. Then you use a dependency manager like [npm](https://www.npmjs.com/ \"Link to the npm package manager\"), [yarn](https://yarnpkg.com/ \"Link to the yarn package manager\") or [pnpm](https://pnpm.js.org/ \"Link to the pnpm package manager\") to download TypeScript into your project.\n\n`npm install typescript --save-dev`  \n  \n\nAll of these dependency managers support lockfiles, ensuring that everyone on your team is using the same version of the language. You can then run the TypeScript compiler using one of the following commands:\n\n`npx tsc`  \n  \n\n### with Visual Studio\n\nFor most project types, you can get TypeScript as a package in Nuget for your MSBuild projects, for example an ASP.NET Core app.\n\nWhen using Nuget, you can [install TypeScript through Visual Studio](https://learn.microsoft.com/visualstudio/javascript/tutorial-aspnet-with-typescript) using:\n\n- The Manage NuGet Packages window (which you can get to by right-clicking on a project node)\n- The Nuget Package Manager Console (found in Tools \\> NuGet Package Manager \\> Package Manager Console) and then running:  \n  `Install-Package Microsoft.TypeScript.MSBuild`\n\nFor project types which don't support Nuget, you can use the [TypeScript Visual Studio extension](https://marketplace.visualstudio.com/items?itemName=TypeScriptTeam.typescript-553). You can [install the extension](https://learn.microsoft.com/visualstudio/ide/finding-and-using-visual-studio-extensions) using `Extensions > Manage Extensions` in Visual Studio.\n\nThe examples below are for more advanced use cases.\n\n## Globally Installing TypeScript\n\nIt can be handy to have TypeScript available across all projects, often to test one-off ideas. Long-term, codebases should prefer a project-wide installation over a global install so that they can benefit from reproducible builds across different machines.\n\n### via npm\n\nYou can use npm to install TypeScript globally, this means that you can use the `tsc` command anywhere in your terminal.\n\nTo do this, run `npm install -g typescript`. This will install the latest version (currently 5.5).\n\n### via Visual Studio Marketplace\n\nYou can install TypeScript as a Visual Studio extension, which will allow you to use TypeScript across many MSBuild projects in Visual Studio.\n\nThe latest version is available [in the Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=TypeScriptTeam.typescript-553 \"Link to the Visual Studio Marketplace for the TypeScript MSBuild extension\").\n\n## Working with TypeScript-compatible transpilers\n\nThere are other tools which convert TypeScript files to JavaScript files. You might use these tools for speed or consistency with your existing build tooling.\n\nEach of these projects handle the file conversion, but do not handle the type-checking aspects of the TypeScript compiler. So it's likely that you will still need to keep the above TypeScript dependency around, and you will want to enable [`isolatedModules`](../tsconfig/index#isolatedModules).\n\n### Babel\n\n[Babel](https://babeljs.io/) is a very popular JavaScript transpiler which supports TypeScript files via the plugin [@babel/plugin-transform-typescript](https://babeljs.io/docs/en/babel-preset-typescript#docsNav).\n\n### swc\n\n[swc](https://swc-project.github.io/docs/installation/) is a fast transpiler created in Rust which supports many of Babel's features including TypeScript.\n\n### Sucrase\n\n[Sucrase](https://github.com/alangpierce/sucrase#sucrase/) is a Babel fork focused on speed for using in development mode. Sucrase supports TypeScript natively.\n\n## Next Steps\n\n#### Get Started\n\n- [JS to TS](../docs/handbook/typescript-in-5-minutes)\n- [New to Programming](../docs/handbook/typescript-from-scratch)\n- [OOP to JS](../docs/handbook/typescript-in-5-minutes-oop)\n- [Functional to JS](../docs/handbook/typescript-in-5-minutes-func)\n- [Installation](index)\n\n#### Handbook\n\n- [Everyday Types](../docs/handbook/2/everyday-types)\n- [Creating Types from Types](../docs/handbook/2/types-from-types)\n- [Object Types](../docs/handbook/2/objects)\n- [Variable Declarations](../docs/handbook/variable-declarations)\n- [More on Functions](../docs/handbook/2/functions)\n\n#### Tools\n\n- [Playground](https://www.typescriptlang.org/play/)\n- [TSConfig Reference](../tsconfig/index)\n\n#### Release Notes\n\n- [What's new in 5.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html)\n\n#### Tutorials\n\n- [ASP.NET](../docs/handbook/asp-net-core)\n- [Migrating from JS](../docs/handbook/migrating-from-javascript)\n- [Working with the DOM](../docs/handbook/dom-manipulation)\n- [React & Webpack](../docs/handbook/react-&-webpack)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/download/](https://www.typescriptlang.org/download/)"
- name: emitBOM
  id: tsconfig#emitBOM-config
  summary: Controls whether TypeScript will emit a byte order mark (BOM) when writing output files
  belongs_to: TSConfig Reference
  description: |-
    ### Emit BOM - `emitBOM`

    Controls whether TypeScript will emit a [byte order mark (BOM)](https://wikipedia.org/wiki/Byte_order_mark) when writing output files. Some runtime environments require a BOM to correctly interpret a JavaScript files; others require that it is not present. The default value of `false` is generally best unless you have a reason to change it.
- name: emitBOM
  id: tsconfig/index#emitBOM-config
  summary: Controls whether TypeScript will emit a byte order mark (BOM) when writing output files
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Emit BOM - `emitBOM`

    Controls whether TypeScript will emit a [byte order mark (BOM)](https://wikipedia.org/wiki/Byte_order_mark) when writing output files. Some runtime environments require a BOM to correctly interpret a JavaScript files; others require that it is not present. The default value of `false` is generally best unless you have a reason to change it.
- name: emitDeclarationOnly
  id: tsconfig/index#emitDeclarationOnly-config
  summary: Only emit .d.ts files; do not emit .js files
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Emit Declaration Only - `emitDeclarationOnly`

    *Only* emit `.d.ts` files; do not emit `.js` files.

    This setting is useful in two cases:

    - You are using a transpiler other than TypeScript to generate your JavaScript.
    - You are using TypeScript to only generate `d.ts` files for your consumers.

    - Related:
      - [`declaration`](#declaration)

    - Released:

      [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html)
- name: emitDeclarationOnly
  id: tsconfig#emitDeclarationOnly-config
  summary: Only emit .d.ts files; do not emit .js files
  belongs_to: TSConfig Reference
  description: |-
    ### Emit Declaration Only - `emitDeclarationOnly`

    *Only* emit `.d.ts` files; do not emit `.js` files.

    This setting is useful in two cases:

    - You are using a transpiler other than TypeScript to generate your JavaScript.
    - You are using TypeScript to only generate `d.ts` files for your consumers.

    - Related:
      - [`declaration`](#declaration)

    - Released:

      [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html)
- name: emitDecoratorMetadata
  id: tsconfig/index#emitDecoratorMetadata-config
  summary: Enables experimental support for emitting type metadata for decorators which works with the module reflect-metadata
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Emit Decorator Metadata - `emitDecoratorMetadata`

    Enables experimental support for emitting type metadata for decorators which works with the module [`reflect-metadata`](https://www.npmjs.com/package/reflect-metadata).

    For example, here is the TypeScript

    ``` ts
    function LogMethod(
      target: any,
      propertyKey: string | symbol,
      descriptor: PropertyDescriptor
    ) {
      console.log(target);
      console.log(propertyKey);
      console.log(descriptor);
    }
     
    class Demo {
      @LogMethod
      public foo(bar: number) {
        // do nothing
      }
    }
     
    const demo = new Demo();
    ```

    With `emitDecoratorMetadata` not set to true (default) the emitted JavaScript is:

    ``` ts
    "use strict";
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    function LogMethod(target, propertyKey, descriptor) {
        console.log(target);
        console.log(propertyKey);
        console.log(descriptor);
    }
    class Demo {
        foo(bar) {
            // do nothing
        }
    }
    __decorate([
        LogMethod
    ], Demo.prototype, "foo", null);
    const demo = new Demo();
     
    ```

    With `emitDecoratorMetadata` set to true the emitted JavaScript is:

    ``` ts
    "use strict";
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    function LogMethod(target, propertyKey, descriptor) {
        console.log(target);
        console.log(propertyKey);
        console.log(descriptor);
    }
    class Demo {
        foo(bar) {
            // do nothing
        }
    }
    __decorate([
        LogMethod,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Number]),
        __metadata("design:returntype", void 0)
    ], Demo.prototype, "foo", null);
    const demo = new Demo();
     
    ```

    - Related:
      - [`experimentalDecorators`](#experimentalDecorators)
- name: emitDecoratorMetadata
  id: tsconfig#emitDecoratorMetadata-config
  summary: Enables experimental support for emitting type metadata for decorators which works with the module reflect-metadata
  belongs_to: TSConfig Reference
  description: |-
    ### Emit Decorator Metadata - `emitDecoratorMetadata`

    Enables experimental support for emitting type metadata for decorators which works with the module [`reflect-metadata`](https://www.npmjs.com/package/reflect-metadata).

    For example, here is the TypeScript

    ``` ts
    function LogMethod(
      target: any,
      propertyKey: string | symbol,
      descriptor: PropertyDescriptor
    ) {
      console.log(target);
      console.log(propertyKey);
      console.log(descriptor);
    }
     
    class Demo {
      @LogMethod
      public foo(bar: number) {
        // do nothing
      }
    }
     
    const demo = new Demo();
    ```

    With `emitDecoratorMetadata` not set to true (default) the emitted JavaScript is:

    ``` ts
    "use strict";
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    function LogMethod(target, propertyKey, descriptor) {
        console.log(target);
        console.log(propertyKey);
        console.log(descriptor);
    }
    class Demo {
        foo(bar) {
            // do nothing
        }
    }
    __decorate([
        LogMethod
    ], Demo.prototype, "foo", null);
    const demo = new Demo();
     
    ```

    With `emitDecoratorMetadata` set to true the emitted JavaScript is:

    ``` ts
    "use strict";
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    function LogMethod(target, propertyKey, descriptor) {
        console.log(target);
        console.log(propertyKey);
        console.log(descriptor);
    }
    class Demo {
        foo(bar) {
            // do nothing
        }
    }
    __decorate([
        LogMethod,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Number]),
        __metadata("design:returntype", void 0)
    ], Demo.prototype, "foo", null);
    const demo = new Demo();
     
    ```

    - Related:
      - [`experimentalDecorators`](#experimentalDecorators)
- name: enable
  id: tsconfig/index#type-enable-config
  summary: null
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Enable - `enable`

    Disables automatic type acquisition in JavaScript projects:

    ``` json
    {
      "typeAcquisition": {
        "enable": false
      }
    }
    ```
- name: enable
  id: tsconfig#type-enable-config
  summary: null
  belongs_to: TSConfig Reference
  description: |-
    ### Enable - `enable`

    Disables automatic type acquisition in JavaScript projects:

    ``` json
    {
      "typeAcquisition": {
        "enable": false
      }
    }
    ```
- name: Enums
  id: enums
  summary: Enums are one of the few features TypeScript has which is not a type-level extension of JavaScript
  description: "# Enums\n\nEnums are one of the few features TypeScript has which is not a type-level extension of JavaScript.\n\nEnums allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.\n\n## Numeric enums\n\nWe’ll first start off with numeric enums, which are probably more familiar if you’re coming from other languages. An enum can be defined using the `enum` keyword.\n\n``` ts\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right,\n}\n```\n\nAbove, we have a numeric enum where `Up` is initialized with `1`. All of the following members are auto-incremented from that point on. In other words, `Direction.Up` has the value `1`, `Down` has `2`, `Left` has `3`, and `Right` has `4`.\n\nIf we wanted, we could leave off the initializers entirely:\n\n``` ts\nenum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n```\n\nHere, `Up` would have the value `0`, `Down` would have `1`, etc. This auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum.\n\nUsing an enum is simple: just access any member as a property off of the enum itself, and declare types using the name of the enum:\n\n``` ts\nenum UserResponse {\n  No = 0,\n  Yes = 1,\n}\n \nfunction respond(recipient: string, message: UserResponse): void {\n  // ...\n}\n \nrespond(\"Princess Caroline\", UserResponse.Yes);\n```\n\nNumeric enums can be mixed in [computed and constant members (see below)](#computed-and-constant-members). The short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members. In other words, the following isn’t allowed:\n\n``` ts\nenum E {\n  A = getSomeValue(),\n  B,\n}\n```\n\n## String enums\n\nString enums are a similar concept, but have some subtle [runtime differences](#enums-at-runtime) as documented below. In a string enum, each member has to be constant-initialized with a string literal, or with another string enum member.\n\n``` ts\nenum Direction {\n  Up = \"UP\",\n  Down = \"DOWN\",\n  Left = \"LEFT\",\n  Right = \"RIGHT\",\n}\n```\n\nWhile string enums don’t have auto-incrementing behavior, string enums have the benefit that they “serialize” well. In other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn’t convey any useful meaning on its own (though [reverse mapping](#reverse-mappings) can often help). String enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself.\n\n## Heterogeneous enums\n\nTechnically enums can be mixed with string and numeric members, but it’s not clear why you would ever want to do so:\n\n``` ts\nenum BooleanLikeHeterogeneousEnum {\n  No = 0,\n  Yes = \"YES\",\n}\n```\n\nUnless you’re really trying to take advantage of JavaScript’s runtime behavior in a clever way, it’s advised that you don’t do this.\n\n## Computed and constant members\n\nEach enum member has a value associated with it which can be either *constant* or *computed*. An enum member is considered constant if:\n\n- It is the first member in the enum and it has no initializer, in which case it’s assigned the value `0`:\n\n  ``` ts\n  // E.X is constant:\n  enum E {\n    X,\n  }\n  ```\n\n- It does not have an initializer and the preceding enum member was a *numeric* constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.\n\n  ``` ts\n  // All enum members in 'E1' and 'E2' are constant.\n   \n  enum E1 {\n    X,\n    Y,\n    Z,\n  }\n   \n  enum E2 {\n    A = 1,\n    B,\n    C,\n  }\n  ```\n\n- The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:\n\n  1.  a literal enum expression (basically a string literal or a numeric literal)\n  2.  a reference to previously defined constant enum member (which can originate from a different enum)\n  3.  a parenthesized constant enum expression\n  4.  one of the `+`, `-`, `~` unary operators applied to constant enum expression\n  5.  `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^` binary operators with constant enum expressions as operands\n\n  It is a compile time error for constant enum expressions to be evaluated to `NaN` or `Infinity`.\n\nIn all other cases enum member is considered computed.\n\n``` ts\nenum FileAccess {\n  // constant members\n  None,\n  Read = 1 << 1,\n  Write = 1 << 2,\n  ReadWrite = Read | Write,\n  // computed member\n  G = \"123\".length,\n}\n```\n\n## Union enums and enum member types\n\nThere is a special subset of constant enum members that aren’t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to\n\n- any string literal (e.g. `\"foo\"`, `\"bar\"`, `\"baz\"`)\n- any numeric literal (e.g. `1`, `100`)\n- a unary minus applied to any numeric literal (e.g. `-1`, `-100`)\n\nWhen all members in an enum have literal enum values, some special semantics come into play.\n\nThe first is that enum members also become types as well! For example, we can say that certain members can *only* have the value of an enum member:\n\n``` ts\nenum ShapeKind {\n  Circle,\n  Square,\n}\n \ninterface Circle {\n  kind: ShapeKind.Circle;\n  radius: number;\n}\n \ninterface Square {\n  kind: ShapeKind.Square;\n  sideLength: number;\n}\n \nlet c: Circle = {\n  kind: ShapeKind.Square,\n  radius: 100,\n};\n```\n\nThe other change is that enum types themselves effectively become a *union* of each enum member. With union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch bugs where we might be comparing values incorrectly. For example:\n\n``` ts\nenum E {\n  Foo,\n  Bar,\n}\n \nfunction f(x: E) {\n  if (x !== E.Foo || x !== E.Bar) {\n    //\n  }\n}\n```\n\nIn that example, we first checked whether `x` was *not* `E.Foo`. If that check succeeds, then our `||` will short-circuit, and the body of the ‘if’ will run. However, if the check didn’t succeed, then `x` can *only* be `E.Foo`, so it doesn’t make sense to see whether it’s *not* equal to `E.Bar`.\n\n## Enums at runtime\n\nEnums are real objects that exist at runtime. For example, the following enum\n\n``` ts\nenum E {\n  X,\n  Y,\n  Z,\n}\n```\n\ncan actually be passed around to functions\n\n``` ts\nenum E {\n  X,\n  Y,\n  Z,\n}\n \nfunction f(obj: { X: number }) {\n  return obj.X;\n}\n \n// Works, since 'E' has a property named 'X' which is a number.\nf(E);\n```\n\n## Enums at compile time\n\nEven though Enums are real objects that exist at runtime, the `keyof` keyword works differently than you might expect for typical objects. Instead, use `keyof typeof` to get a Type that represents all Enum keys as strings.\n\n``` ts\nenum LogLevel {\n  ERROR,\n  WARN,\n  INFO,\n  DEBUG,\n}\n \n/**\n * This is equivalent to:\n * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';\n */\ntype LogLevelStrings = keyof typeof LogLevel;\n \nfunction printImportant(key: LogLevelStrings, message: string) {\n  const num = LogLevel[key];\n  if (num <= LogLevel.WARN) {\n    console.log(\"Log level key is:\", key);\n    console.log(\"Log level value is:\", num);\n    console.log(\"Log level message is:\", message);\n  }\n}\nprintImportant(\"ERROR\", \"This is a message\");\n```\n\n### Reverse mappings\n\nIn addition to creating an object with property names for members, numeric enums members also get a *reverse mapping* from enum values to enum names. For example, in this example:\n\n``` ts\nenum Enum {\n  A,\n}\n \nlet a = Enum.A;\nlet nameOfA = Enum[a]; // \"A\"\n```\n\nTypeScript compiles this down to the following JavaScript:\n\n``` ts\n\"use strict\";\nvar Enum;\n(function (Enum) {\n    Enum[Enum[\"A\"] = 0] = \"A\";\n})(Enum || (Enum = {}));\nlet a = Enum.A;\nlet nameOfA = Enum[a]; // \"A\"\n \n```\n\nIn this generated code, an enum is compiled into an object that stores both forward (`name` -\\> `value`) and reverse (`value` -\\> `name`) mappings. References to other enum members are always emitted as property accesses and never inlined.\n\nKeep in mind that string enum members *do not* get a reverse mapping generated at all.\n\n### `const` enums\n\nIn most cases, enums are a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it’s possible to use `const` enums. Const enums are defined using the `const` modifier on our enums:\n\n``` ts\nconst enum Enum {\n  A = 1,\n  B = A * 2,\n}\n```\n\nConst enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.\n\n``` ts\nconst enum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n \nlet directions = [\n  Direction.Up,\n  Direction.Down,\n  Direction.Left,\n  Direction.Right,\n];\n```\n\nin generated code will become\n\n``` ts\n\"use strict\";\nlet directions = [\n    0 /* Direction.Up */,\n    1 /* Direction.Down */,\n    2 /* Direction.Left */,\n    3 /* Direction.Right */,\n];\n \n```\n\n#### Const enum pitfalls\n\nInlining enum values is straightforward at first, but comes with subtle implications. These pitfalls pertain to *ambient* const enums only (basically const enums in `.d.ts` files) and sharing them between projects, but if you are publishing or consuming `.d.ts` files, these pitfalls likely apply to you, because `tsc --declaration` transforms `.ts` files into `.d.ts` files.\n\n1.  For the reasons laid out in the [`isolatedModules` documentation](https://www.typescriptlang.org/tsconfig#references-to-const-enum-members), that mode is fundamentally incompatible with ambient const enums. This means if you publish ambient const enums, downstream consumers will not be able to use [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules) and those enum values at the same time.\n2.  You can easily inline values from version A of a dependency at compile time, and import version B at runtime. Version A and B’s enums can have different values, if you are not very careful, resulting in [surprising bugs](https://github.com/microsoft/TypeScript/issues/5219#issue-110947903), like taking the wrong branches of `if` statements. These bugs are especially pernicious because it is common to run automated tests at roughly the same time as projects are built, with the same dependency versions, which misses these bugs completely.\n3.  [`importsNotUsedAsValues: \"preserve\"`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues) will not elide imports for const enums used as values, but ambient const enums do not guarantee that runtime `.js` files exist. The unresolvable imports cause errors at runtime. The usual way to unambiguously elide imports, [type-only imports](modules/reference#type-only-imports-and-exports), [does not allow const enum values](https://github.com/microsoft/TypeScript/issues/40344), currently.\n\nHere are two approaches to avoiding these pitfalls:\n\n1.  Do not use const enums at all. You can easily [ban const enums](https://typescript-eslint.io/linting/troubleshooting#how-can-i-ban-specific-language-feature) with the help of a linter. Obviously this avoids any issues with const enums, but prevents your project from inlining its own enums. Unlike inlining enums from other projects, inlining a project’s own enums is not problematic and has performance implications.\n\n2.  Do not publish ambient const enums, by deconstifying them with the help of [`preserveConstEnums`](https://www.typescriptlang.org/tsconfig#preserveConstEnums). This is the approach taken internally by the [TypeScript project itself](https://github.com/microsoft/TypeScript/pull/5422). [`preserveConstEnums`](https://www.typescriptlang.org/tsconfig#preserveConstEnums) emits the same JavaScript for const enums as plain enums. You can then safely strip the `const` modifier from `.d.ts` files [in a build step](https://github.com/microsoft/TypeScript/blob/1a981d1df1810c868a66b3828497f049a944951c/Gulpfile.js#L144).\n\n    This way downstream consumers will not inline enums from your project, avoiding the pitfalls above, but a project can still inline its own enums, unlike banning const enums entirely.\n\n## Ambient enums\n\nAmbient enums are used to describe the shape of already existing enum types.\n\n``` ts\ndeclare enum Enum {\n  A = 1,\n  B,\n  C = 2,\n}\n```\n\nOne important difference between ambient and non-ambient enums is that, in regular enums, members that don’t have an initializer will be considered constant if its preceding enum member is considered constant. By contrast, an ambient (and non-const) enum member that does not have an initializer is *always* considered computed.\n\n## Objects vs Enums\n\nIn modern TypeScript, you may not need an enum when an object with `as const` could suffice:\n\n``` ts\nconst enum EDirection {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n \nconst ODirection = {\n  Up: 0,\n  Down: 1,\n  Left: 2,\n  Right: 3,\n} as const;\n \nEDirection.Up;\n \nODirection.Up;\n \n// Using the enum as a parameter\nfunction walk(dir: EDirection) {}\n \n// It requires an extra line to pull out the values\ntype Direction = typeof ODirection[keyof typeof ODirection];\nfunction run(dir: Direction) {}\n \nwalk(EDirection.Left);\nrun(ODirection.Right);\n```\n\nThe biggest argument in favour of this format over TypeScript’s `enum` is that it keeps your codebase aligned with the state of JavaScript, and [when/if](https://github.com/rbuckton/proposal-enum) enums are added to JavaScript then you can move to the additional syntax.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/enums.html](https://www.typescriptlang.org/docs/handbook/enums.html)"
- name: 'Enums: Ambient enums'
  id: enums#ambient-enums
  summary: Ambient enums are used to describe the shape of already existing enum types
  belongs_to: Enums
  description: |-
    ## Ambient enums

    Ambient enums are used to describe the shape of already existing enum types.

    ``` ts
    declare enum Enum {
      A = 1,
      B,
      C = 2,
    }
    ```

    One important difference between ambient and non-ambient enums is that, in regular enums, members that don’t have an initializer will be considered constant if its preceding enum member is considered constant. By contrast, an ambient (and non-const) enum member that does not have an initializer is *always* considered computed.
- name: 'Enums: Computed and constant members'
  id: enums#computed-and-constant-members
  summary: Each enum member has a value associated with it which can be either constant or computed
  belongs_to: Enums
  description: |-
    ## Computed and constant members

    Each enum member has a value associated with it which can be either *constant* or *computed*. An enum member is considered constant if:

    - It is the first member in the enum and it has no initializer, in which case it’s assigned the value `0`:

      ``` ts
      // E.X is constant:
      enum E {
        X,
      }
      ```

    - It does not have an initializer and the preceding enum member was a *numeric* constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.

      ``` ts
      // All enum members in 'E1' and 'E2' are constant.
       
      enum E1 {
        X,
        Y,
        Z,
      }
       
      enum E2 {
        A = 1,
        B,
        C,
      }
      ```

    - The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:

      1.  a literal enum expression (basically a string literal or a numeric literal)
      2.  a reference to previously defined constant enum member (which can originate from a different enum)
      3.  a parenthesized constant enum expression
      4.  one of the `+`, `-`, `~` unary operators applied to constant enum expression
      5.  `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^` binary operators with constant enum expressions as operands

      It is a compile time error for constant enum expressions to be evaluated to `NaN` or `Infinity`.

    In all other cases enum member is considered computed.

    ``` ts
    enum FileAccess {
      // constant members
      None,
      Read = 1 << 1,
      Write = 1 << 2,
      ReadWrite = Read | Write,
      // computed member
      G = "123".length,
    }
    ```
- name: 'Enums: const enums'
  id: enums#const-enums
  summary: In most cases, enums are a perfectly valid solution
  belongs_to: Enums
  description: |-
    ### `const` enums

    In most cases, enums are a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it’s possible to use `const` enums. Const enums are defined using the `const` modifier on our enums:

    ``` ts
    const enum Enum {
      A = 1,
      B = A * 2,
    }
    ```

    Const enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.

    ``` ts
    const enum Direction {
      Up,
      Down,
      Left,
      Right,
    }
     
    let directions = [
      Direction.Up,
      Direction.Down,
      Direction.Left,
      Direction.Right,
    ];
    ```

    in generated code will become

    ``` ts
    "use strict";
    let directions = [
        0 /* Direction.Up */,
        1 /* Direction.Down */,
        2 /* Direction.Left */,
        3 /* Direction.Right */,
    ];
     
    ```

    #### Const enum pitfalls

    Inlining enum values is straightforward at first, but comes with subtle implications. These pitfalls pertain to *ambient* const enums only (basically const enums in `.d.ts` files) and sharing them between projects, but if you are publishing or consuming `.d.ts` files, these pitfalls likely apply to you, because `tsc --declaration` transforms `.ts` files into `.d.ts` files.

    1.  For the reasons laid out in the [`isolatedModules` documentation](https://www.typescriptlang.org/tsconfig#references-to-const-enum-members), that mode is fundamentally incompatible with ambient const enums. This means if you publish ambient const enums, downstream consumers will not be able to use [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules) and those enum values at the same time.
    2.  You can easily inline values from version A of a dependency at compile time, and import version B at runtime. Version A and B’s enums can have different values, if you are not very careful, resulting in [surprising bugs](https://github.com/microsoft/TypeScript/issues/5219#issue-110947903), like taking the wrong branches of `if` statements. These bugs are especially pernicious because it is common to run automated tests at roughly the same time as projects are built, with the same dependency versions, which misses these bugs completely.
    3.  [`importsNotUsedAsValues: "preserve"`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues) will not elide imports for const enums used as values, but ambient const enums do not guarantee that runtime `.js` files exist. The unresolvable imports cause errors at runtime. The usual way to unambiguously elide imports, [type-only imports](modules/reference#type-only-imports-and-exports), [does not allow const enum values](https://github.com/microsoft/TypeScript/issues/40344), currently.

    Here are two approaches to avoiding these pitfalls:

    1.  Do not use const enums at all. You can easily [ban const enums](https://typescript-eslint.io/linting/troubleshooting#how-can-i-ban-specific-language-feature) with the help of a linter. Obviously this avoids any issues with const enums, but prevents your project from inlining its own enums. Unlike inlining enums from other projects, inlining a project’s own enums is not problematic and has performance implications.

    2.  Do not publish ambient const enums, by deconstifying them with the help of [`preserveConstEnums`](https://www.typescriptlang.org/tsconfig#preserveConstEnums). This is the approach taken internally by the [TypeScript project itself](https://github.com/microsoft/TypeScript/pull/5422). [`preserveConstEnums`](https://www.typescriptlang.org/tsconfig#preserveConstEnums) emits the same JavaScript for const enums as plain enums. You can then safely strip the `const` modifier from `.d.ts` files [in a build step](https://github.com/microsoft/TypeScript/blob/1a981d1df1810c868a66b3828497f049a944951c/Gulpfile.js#L144).

        This way downstream consumers will not inline enums from your project, avoiding the pitfalls above, but a project can still inline its own enums, unlike banning const enums entirely.
- name: 'Enums: Enums at compile time'
  id: enums#enums-at-compile-time
  summary: Even though Enums are real objects that exist at runtime, the keyof keyword works differently than you might expect for typical objects
  belongs_to: Enums
  description: |-
    ## Enums at compile time

    Even though Enums are real objects that exist at runtime, the `keyof` keyword works differently than you might expect for typical objects. Instead, use `keyof typeof` to get a Type that represents all Enum keys as strings.

    ``` ts
    enum LogLevel {
      ERROR,
      WARN,
      INFO,
      DEBUG,
    }
     
    /**
     * This is equivalent to:
     * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';
     */
    type LogLevelStrings = keyof typeof LogLevel;
     
    function printImportant(key: LogLevelStrings, message: string) {
      const num = LogLevel[key];
      if (num <= LogLevel.WARN) {
        console.log("Log level key is:", key);
        console.log("Log level value is:", num);
        console.log("Log level message is:", message);
      }
    }
    printImportant("ERROR", "This is a message");
    ```

    ### Reverse mappings

    In addition to creating an object with property names for members, numeric enums members also get a *reverse mapping* from enum values to enum names. For example, in this example:

    ``` ts
    enum Enum {
      A,
    }
     
    let a = Enum.A;
    let nameOfA = Enum[a]; // "A"
    ```

    TypeScript compiles this down to the following JavaScript:

    ``` ts
    "use strict";
    var Enum;
    (function (Enum) {
        Enum[Enum["A"] = 0] = "A";
    })(Enum || (Enum = {}));
    let a = Enum.A;
    let nameOfA = Enum[a]; // "A"
     
    ```

    In this generated code, an enum is compiled into an object that stores both forward (`name` -\> `value`) and reverse (`value` -\> `name`) mappings. References to other enum members are always emitted as property accesses and never inlined.

    Keep in mind that string enum members *do not* get a reverse mapping generated at all.
- name: 'Enums: Enums at runtime'
  id: enums#enums-at-runtime
  summary: Enums are real objects that exist at runtime
  belongs_to: Enums
  description: |-
    ## Enums at runtime

    Enums are real objects that exist at runtime. For example, the following enum

    ``` ts
    enum E {
      X,
      Y,
      Z,
    }
    ```

    can actually be passed around to functions

    ``` ts
    enum E {
      X,
      Y,
      Z,
    }
     
    function f(obj: { X: number }) {
      return obj.X;
    }
     
    // Works, since 'E' has a property named 'X' which is a number.
    f(E);
    ```
- name: 'Enums: Heterogeneous enums'
  id: enums#heterogeneous-enums
  summary: Unless you’re really trying to take advantage of JavaScript’s runtime behavior in a clever way, it’s advised that you don’t do this
  belongs_to: Enums
  description: |-
    ## Heterogeneous enums

    Technically enums can be mixed with string and numeric members, but it’s not clear why you would ever want to do so:

    ``` ts
    enum BooleanLikeHeterogeneousEnum {
      No = 0,
      Yes = "YES",
    }
    ```

    Unless you’re really trying to take advantage of JavaScript’s runtime behavior in a clever way, it’s advised that you don’t do this.
- name: 'Enums: Numeric enums'
  id: enums#numeric-enums
  summary: We’ll first start off with numeric enums, which are probably more familiar if you’re coming from other languages
  belongs_to: Enums
  description: |-
    ## Numeric enums

    We’ll first start off with numeric enums, which are probably more familiar if you’re coming from other languages. An enum can be defined using the `enum` keyword.

    ``` ts
    enum Direction {
      Up = 1,
      Down,
      Left,
      Right,
    }
    ```

    Above, we have a numeric enum where `Up` is initialized with `1`. All of the following members are auto-incremented from that point on. In other words, `Direction.Up` has the value `1`, `Down` has `2`, `Left` has `3`, and `Right` has `4`.

    If we wanted, we could leave off the initializers entirely:

    ``` ts
    enum Direction {
      Up,
      Down,
      Left,
      Right,
    }
    ```

    Here, `Up` would have the value `0`, `Down` would have `1`, etc. This auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum.

    Using an enum is simple: just access any member as a property off of the enum itself, and declare types using the name of the enum:

    ``` ts
    enum UserResponse {
      No = 0,
      Yes = 1,
    }
     
    function respond(recipient: string, message: UserResponse): void {
      // ...
    }
     
    respond("Princess Caroline", UserResponse.Yes);
    ```

    Numeric enums can be mixed in [computed and constant members (see below)](#computed-and-constant-members). The short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members. In other words, the following isn’t allowed:

    ``` ts
    enum E {
      A = getSomeValue(),
      B,
    }
    ```
- name: 'Enums: Objects vs Enums'
  id: enums#objects-vs-enums
  summary: The biggest argument in favour of this format over TypeScript’s enum is that it keeps your codebase aligned with the state of JavaScript, and when/if enums are added to JavaScript then you can move to the additional syntax
  belongs_to: Enums
  description: "## Objects vs Enums\n\nIn modern TypeScript, you may not need an enum when an object with `as const` could suffice:\n\n``` ts\nconst enum EDirection {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n \nconst ODirection = {\n  Up: 0,\n  Down: 1,\n  Left: 2,\n  Right: 3,\n} as const;\n \nEDirection.Up;\n \nODirection.Up;\n \n// Using the enum as a parameter\nfunction walk(dir: EDirection) {}\n \n// It requires an extra line to pull out the values\ntype Direction = typeof ODirection[keyof typeof ODirection];\nfunction run(dir: Direction) {}\n \nwalk(EDirection.Left);\nrun(ODirection.Right);\n```\n\nThe biggest argument in favour of this format over TypeScript’s `enum` is that it keeps your codebase aligned with the state of JavaScript, and [when/if](https://github.com/rbuckton/proposal-enum) enums are added to JavaScript then you can move to the additional syntax.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/enums.html](https://www.typescriptlang.org/docs/handbook/enums.html)"
- name: 'Enums: String enums'
  id: enums#string-enums
  summary: String enums are a similar concept, but have some subtle runtime differences as documented below
  belongs_to: Enums
  description: |-
    ## String enums

    String enums are a similar concept, but have some subtle [runtime differences](#enums-at-runtime) as documented below. In a string enum, each member has to be constant-initialized with a string literal, or with another string enum member.

    ``` ts
    enum Direction {
      Up = "UP",
      Down = "DOWN",
      Left = "LEFT",
      Right = "RIGHT",
    }
    ```

    While string enums don’t have auto-incrementing behavior, string enums have the benefit that they “serialize” well. In other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn’t convey any useful meaning on its own (though [reverse mapping](#reverse-mappings) can often help). String enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself.
- name: 'Enums: Union enums and enum member types'
  id: enums#union-enums-and-enum-member-types
  summary: 'There is a special subset of constant enum members that aren’t calculated: literal enum members'
  belongs_to: Enums
  description: |-
    ## Union enums and enum member types

    There is a special subset of constant enum members that aren’t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to

    - any string literal (e.g. `"foo"`, `"bar"`, `"baz"`)
    - any numeric literal (e.g. `1`, `100`)
    - a unary minus applied to any numeric literal (e.g. `-1`, `-100`)

    When all members in an enum have literal enum values, some special semantics come into play.

    The first is that enum members also become types as well! For example, we can say that certain members can *only* have the value of an enum member:

    ``` ts
    enum ShapeKind {
      Circle,
      Square,
    }
     
    interface Circle {
      kind: ShapeKind.Circle;
      radius: number;
    }
     
    interface Square {
      kind: ShapeKind.Square;
      sideLength: number;
    }
     
    let c: Circle = {
      kind: ShapeKind.Square,
      radius: 100,
    };
    ```

    The other change is that enum types themselves effectively become a *union* of each enum member. With union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch bugs where we might be comparing values incorrectly. For example:

    ``` ts
    enum E {
      Foo,
      Bar,
    }
     
    function f(x: E) {
      if (x !== E.Foo || x !== E.Bar) {
        //
      }
    }
    ```

    In that example, we first checked whether `x` was *not* `E.Foo`. If that check succeeds, then our `||` will short-circuit, and the body of the ‘if’ will run. However, if the check didn’t succeed, then `x` can *only* be `E.Foo`, so it doesn’t make sense to see whether it’s *not* equal to `E.Bar`.
- name: esModuleInterop
  id: tsconfig#esModuleInterop-config
  summary: By default (with esModuleInterop false or not set) TypeScript treats CommonJS/AMD/UMD modules similar to ES6 modules
  belongs_to: TSConfig Reference
  description: |-
    ### ES Module Interop - `esModuleInterop`

    By default (with `esModuleInterop` false or not set) TypeScript treats CommonJS/AMD/UMD modules similar to ES6 modules. In doing this, there are two parts in particular which turned out to be flawed assumptions:

    - a namespace import like `import * as moment from "moment"` acts the same as `const moment = require("moment")`

    - a default import like `import moment from "moment"` acts the same as `const moment = require("moment").default`

    This mis-match causes these two issues:

    - the ES6 modules spec states that a namespace import (`import * as x`) can only be an object, by having TypeScript treating it the same as `= require("x")` then TypeScript allowed for the import to be treated as a function and be callable. That’s not valid according to the spec.

    - while accurate to the ES6 modules spec, most libraries with CommonJS/AMD/UMD modules didn’t conform as strictly as TypeScript’s implementation.

    Turning on `esModuleInterop` will fix both of these problems in the code transpiled by TypeScript. The first changes the behavior in the compiler, the second is fixed by two new helper functions which provide a shim to ensure compatibility in the emitted JavaScript:

    ``` ts
    import * as fs from "fs";
    import _ from "lodash";

    fs.readFileSync("file.txt", "utf8");
    _.chunk(["a", "b", "c", "d"], 2);
    ```

    With `esModuleInterop` disabled:

    ``` ts
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs = require("fs");
    const lodash_1 = require("lodash");
    fs.readFileSync("file.txt", "utf8");
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
     
    ```

    With `esModuleInterop` set to `true`:

    ``` ts
    "use strict";
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs = __importStar(require("fs"));
    const lodash_1 = __importDefault(require("lodash"));
    fs.readFileSync("file.txt", "utf8");
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
     
    ```

    *Note*: The namespace import `import * as fs from "fs"` only accounts for properties which [are owned](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty) (basically properties set on the object and not via the prototype chain) on the imported object. If the module you’re importing defines its API using inherited properties, you need to use the default import form (`import fs from "fs"`), or disable `esModuleInterop`.

    *Note*: You can make JS emit terser by enabling [`importHelpers`](#importHelpers):

    ``` ts
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require("tslib");
    const fs = tslib_1.__importStar(require("fs"));
    const lodash_1 = tslib_1.__importDefault(require("lodash"));
    fs.readFileSync("file.txt", "utf8");
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
     
    ```

    Enabling `esModuleInterop` will also enable [`allowSyntheticDefaultImports`](#allowSyntheticDefaultImports).

    - Recommended

    - Default:

      `true` if [`module`](#module) is `node16` or `nodenext`; `false` otherwise.

    - Related:
      - [`allowSyntheticDefaultImports`](#allowSyntheticDefaultImports)

    - Released:

      [2.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html)
- name: esModuleInterop
  id: tsconfig/index#esModuleInterop-config
  summary: By default (with esModuleInterop false or not set) TypeScript treats CommonJS/AMD/UMD modules similar to ES6 modules
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### ES Module Interop - `esModuleInterop`

    By default (with `esModuleInterop` false or not set) TypeScript treats CommonJS/AMD/UMD modules similar to ES6 modules. In doing this, there are two parts in particular which turned out to be flawed assumptions:

    - a namespace import like `import * as moment from "moment"` acts the same as `const moment = require("moment")`

    - a default import like `import moment from "moment"` acts the same as `const moment = require("moment").default`

    This mis-match causes these two issues:

    - the ES6 modules spec states that a namespace import (`import * as x`) can only be an object, by having TypeScript treating it the same as `= require("x")` then TypeScript allowed for the import to be treated as a function and be callable. That’s not valid according to the spec.

    - while accurate to the ES6 modules spec, most libraries with CommonJS/AMD/UMD modules didn’t conform as strictly as TypeScript’s implementation.

    Turning on `esModuleInterop` will fix both of these problems in the code transpiled by TypeScript. The first changes the behavior in the compiler, the second is fixed by two new helper functions which provide a shim to ensure compatibility in the emitted JavaScript:

    ``` ts
    import * as fs from "fs";
    import _ from "lodash";

    fs.readFileSync("file.txt", "utf8");
    _.chunk(["a", "b", "c", "d"], 2);
    ```

    With `esModuleInterop` disabled:

    ``` ts
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs = require("fs");
    const lodash_1 = require("lodash");
    fs.readFileSync("file.txt", "utf8");
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
     
    ```

    With `esModuleInterop` set to `true`:

    ``` ts
    "use strict";
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs = __importStar(require("fs"));
    const lodash_1 = __importDefault(require("lodash"));
    fs.readFileSync("file.txt", "utf8");
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
     
    ```

    *Note*: The namespace import `import * as fs from "fs"` only accounts for properties which [are owned](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty) (basically properties set on the object and not via the prototype chain) on the imported object. If the module you’re importing defines its API using inherited properties, you need to use the default import form (`import fs from "fs"`), or disable `esModuleInterop`.

    *Note*: You can make JS emit terser by enabling [`importHelpers`](#importHelpers):

    ``` ts
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require("tslib");
    const fs = tslib_1.__importStar(require("fs"));
    const lodash_1 = tslib_1.__importDefault(require("lodash"));
    fs.readFileSync("file.txt", "utf8");
    lodash_1.default.chunk(["a", "b", "c", "d"], 2);
     
    ```

    Enabling `esModuleInterop` will also enable [`allowSyntheticDefaultImports`](#allowSyntheticDefaultImports).

    - Recommended

    - Default:

      `true` if [`module`](#module) is `node16` or `nodenext`; `false` otherwise.

    - Related:
      - [`allowSyntheticDefaultImports`](#allowSyntheticDefaultImports)

    - Released:

      [2.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html)
- name: Everyday Types
  id: 2/everyday-types
  summary: In this chapter, we’ll cover some of the most common types of values you’ll find in JavaScript code, and explain the corresponding ways to describe those types in TypeScript
  description: "# Everyday Types\n\nIn this chapter, we’ll cover some of the most common types of values you’ll find in JavaScript code, and explain the corresponding ways to describe those types in TypeScript. This isn’t an exhaustive list, and future chapters will describe more ways to name and use other types.\n\nTypes can also appear in many more *places* than just type annotations. As we learn about the types themselves, we’ll also learn about the places where we can refer to these types to form new constructs.\n\nWe’ll start by reviewing the most basic and common types you might encounter when writing JavaScript or TypeScript code. These will later form the core building blocks of more complex types.\n\n## The primitives: `string`, `number`, and `boolean`\n\nJavaScript has three very commonly used [primitives](https://developer.mozilla.org/en-US/docs/Glossary/Primitive): `string`, `number`, and `boolean`. Each has a corresponding type in TypeScript. As you might expect, these are the same names you’d see if you used the JavaScript `typeof` operator on a value of those types:\n\n- `string` represents string values like `\"Hello, world\"`\n- `number` is for numbers like `42`. JavaScript does not have a special runtime value for integers, so there’s no equivalent to `int` or `float` - everything is simply `number`\n- `boolean` is for the two values `true` and `false`\n\n> The type names `String`, `Number`, and `Boolean` (starting with capital letters) are legal, but refer to some special built-in types that will very rarely appear in your code. *Always* use `string`, `number`, or `boolean` for types.\n\n## Arrays\n\nTo specify the type of an array like `[1, 2, 3]`, you can use the syntax `number[]`; this syntax works for any type (e.g. `string[]` is an array of strings, and so on). You may also see this written as `Array<number>`, which means the same thing. We’ll learn more about the syntax `T<U>` when we cover *generics*.\n\n> Note that `[number]` is a different thing; refer to the section on [Tuples](objects#tuple-types).\n\n## `any`\n\nTypeScript also has a special type, `any`, that you can use whenever you don’t want a particular value to cause typechecking errors.\n\nWhen a value is of type `any`, you can access any properties of it (which will in turn be of type `any`), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:\n\n``` ts\nlet obj: any = { x: 0 };\n// None of the following lines of code will throw compiler errors.\n// Using `any` disables all further type checking, and it is assumed\n// you know the environment better than TypeScript.\nobj.foo();\nobj();\nobj.bar = 100;\nobj = \"hello\";\nconst n: number = obj;\n```\n\nThe `any` type is useful when you don’t want to write out a long type just to convince TypeScript that a particular line of code is okay.\n\n### `noImplicitAny`\n\nWhen you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to `any`.\n\nYou usually want to avoid this, though, because `any` isn’t type-checked. Use the compiler flag [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) to flag any implicit `any` as an error.\n\n## Type Annotations on Variables\n\nWhen you declare a variable using `const`, `var`, or `let`, you can optionally add a type annotation to explicitly specify the type of the variable:\n\n``` ts\nlet myName: string = \"Alice\";\n```\n\n> TypeScript doesn’t use “types on the left”-style declarations like `int x = 0;` Type annotations will always go *after* the thing being typed.\n\nIn most cases, though, this isn’t needed. Wherever possible, TypeScript tries to automatically *infer* the types in your code. For example, the type of a variable is inferred based on the type of its initializer:\n\n``` ts\n// No type annotation needed -- 'myName' inferred as type 'string'\nlet myName = \"Alice\";\n```\n\nFor the most part you don’t need to explicitly learn the rules of inference. If you’re starting out, try using fewer type annotations than you think - you might be surprised how few you need for TypeScript to fully understand what’s going on.\n\n## Functions\n\nFunctions are the primary means of passing data around in JavaScript. TypeScript allows you to specify the types of both the input and output values of functions.\n\n### Parameter Type Annotations\n\nWhen you declare a function, you can add type annotations after each parameter to declare what types of parameters the function accepts. Parameter type annotations go after the parameter name:\n\n``` ts\n// Parameter type annotation\nfunction greet(name: string) {\n  console.log(\"Hello, \" + name.toUpperCase() + \"!!\");\n}\n```\n\nWhen a parameter has a type annotation, arguments to that function will be checked:\n\n``` ts\n// Would be a runtime error if executed!\ngreet(42);\n```\n\n> Even if you don’t have type annotations on your parameters, TypeScript will still check that you passed the right number of arguments.\n\n### Return Type Annotations\n\nYou can also add return type annotations. Return type annotations appear after the parameter list:\n\n``` ts\nfunction getFavoriteNumber(): number {\n  return 26;\n}\n```\n\nMuch like variable type annotations, you usually don’t need a return type annotation because TypeScript will infer the function’s return type based on its `return` statements. The type annotation in the above example doesn’t change anything. Some codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference.\n\n#### Functions Which Return Promises\n\nIf you want to annotate the return type of a function which returns a promise, you should use the `Promise` type:\n\n``` ts\nasync function getFavoriteNumber(): Promise<number> {\n  return 26;\n}\n```\n\n### Anonymous Functions\n\nAnonymous functions are a little bit different from function declarations. When a function appears in a place where TypeScript can determine how it’s going to be called, the parameters of that function are automatically given types.\n\nHere’s an example:\n\n``` ts\nconst names = [\"Alice\", \"Bob\", \"Eve\"];\n \n// Contextual typing for function - parameter s inferred to have type string\nnames.forEach(function (s) {\n  console.log(s.toUpperCase());\n});\n \n// Contextual typing also applies to arrow functions\nnames.forEach((s) => {\n  console.log(s.toUpperCase());\n});\n```\n\nEven though the parameter `s` didn’t have a type annotation, TypeScript used the types of the `forEach` function, along with the inferred type of the array, to determine the type `s` will have.\n\nThis process is called *contextual typing* because the *context* that the function occurred within informs what type it should have.\n\nSimilar to the inference rules, you don’t need to explicitly learn how this happens, but understanding that it *does* happen can help you notice when type annotations aren’t needed. Later, we’ll see more examples of how the context that a value occurs in can affect its type.\n\n## Object Types\n\nApart from primitives, the most common sort of type you’ll encounter is an *object type*. This refers to any JavaScript value with properties, which is almost all of them! To define an object type, we simply list its properties and their types.\n\nFor example, here’s a function that takes a point-like object:\n\n``` ts\n// The parameter's type annotation is an object type\nfunction printCoord(pt: { x: number; y: number }) {\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\nprintCoord({ x: 3, y: 7 });\n```\n\nHere, we annotated the parameter with a type with two properties - `x` and `y` - which are both of type `number`. You can use `,` or `;` to separate the properties, and the last separator is optional either way.\n\nThe type part of each property is also optional. If you don’t specify a type, it will be assumed to be `any`.\n\n### Optional Properties\n\nObject types can also specify that some or all of their properties are *optional*. To do this, add a `?` after the property name:\n\n``` ts\nfunction printName(obj: { first: string; last?: string }) {\n  // ...\n}\n// Both OK\nprintName({ first: \"Bob\" });\nprintName({ first: \"Alice\", last: \"Alisson\" });\n```\n\nIn JavaScript, if you access a property that doesn’t exist, you’ll get the value `undefined` rather than a runtime error. Because of this, when you *read* from an optional property, you’ll have to check for `undefined` before using it.\n\n``` ts\nfunction printName(obj: { first: string; last?: string }) {\n  // Error - might crash if 'obj.last' wasn't provided!\n  console.log(obj.last.toUpperCase());\n  if (obj.last !== undefined) {\n    // OK\n    console.log(obj.last.toUpperCase());\n  }\n \n  // A safe alternative using modern JavaScript syntax:\n  console.log(obj.last?.toUpperCase());\n}\n```\n\n## Union Types\n\nTypeScript’s type system allows you to build new types out of existing ones using a large variety of operators. Now that we know how to write a few types, it’s time to start *combining* them in interesting ways.\n\n### Defining a Union Type\n\nThe first way to combine types you might see is a *union* type. A union type is a type formed from two or more other types, representing values that may be *any one* of those types. We refer to each of these types as the union’s *members*.\n\nLet’s write a function that can operate on strings or numbers:\n\n``` ts\nfunction printId(id: number | string) {\n  console.log(\"Your ID is: \" + id);\n}\n// OK\nprintId(101);\n// OK\nprintId(\"202\");\n// Error\nprintId({ myID: 22342 });\n```\n\n### Working with Union Types\n\nIt’s easy to *provide* a value matching a union type - simply provide a type matching any of the union’s members. If you *have* a value of a union type, how do you work with it?\n\nTypeScript will only allow an operation if it is valid for *every* member of the union. For example, if you have the union `string | number`, you can’t use methods that are only available on `string`:\n\n``` ts\nfunction printId(id: number | string) {\n  console.log(id.toUpperCase());\n}\n```\n\nThe solution is to *narrow* the union with code, the same as you would in JavaScript without type annotations. *Narrowing* occurs when TypeScript can deduce a more specific type for a value based on the structure of the code.\n\nFor example, TypeScript knows that only a `string` value will have a `typeof` value `\"string\"`:\n\n``` ts\nfunction printId(id: number | string) {\n  if (typeof id === \"string\") {\n    // In this branch, id is of type 'string'\n    console.log(id.toUpperCase());\n  } else {\n    // Here, id is of type 'number'\n    console.log(id);\n  }\n}\n```\n\nAnother example is to use a function like `Array.isArray`:\n\n``` ts\nfunction welcomePeople(x: string[] | string) {\n  if (Array.isArray(x)) {\n    // Here: 'x' is 'string[]'\n    console.log(\"Hello, \" + x.join(\" and \"));\n  } else {\n    // Here: 'x' is 'string'\n    console.log(\"Welcome lone traveler \" + x);\n  }\n}\n```\n\nNotice that in the `else` branch, we don’t need to do anything special - if `x` wasn’t a `string[]`, then it must have been a `string`.\n\nSometimes you’ll have a union where all the members have something in common. For example, both arrays and strings have a `slice` method. If every member in a union has a property in common, you can use that property without narrowing:\n\n``` ts\n// Return type is inferred as number[] | string\nfunction getFirstThree(x: number[] | string) {\n  return x.slice(0, 3);\n}\n```\n\n> It might be confusing that a *union* of types appears to have the *intersection* of those types’ properties. This is not an accident - the name *union* comes from type theory. The *union* `number | string` is composed by taking the union *of the values* from each type. Notice that given two sets with corresponding facts about each set, only the *intersection* of those facts applies to the *union* of the sets themselves. For example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearing hats, after combining those rooms, the only thing we know about *every* person is that they must be wearing a hat.\n\n## Type Aliases\n\nWe’ve been using object types and union types by writing them directly in type annotations. This is convenient, but it’s common to want to use the same type more than once and refer to it by a single name.\n\nA *type alias* is exactly that - a *name* for any *type*. The syntax for a type alias is:\n\n``` ts\ntype Point = {\n  x: number;\n  y: number;\n};\n \n// Exactly the same as the earlier example\nfunction printCoord(pt: Point) {\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\n \nprintCoord({ x: 100, y: 100 });\n```\n\nYou can actually use a type alias to give a name to any type at all, not just an object type. For example, a type alias can name a union type:\n\n``` ts\ntype ID = number | string;\n```\n\nNote that aliases are *only* aliases - you cannot use type aliases to create different/distinct “versions” of the same type. When you use the alias, it’s exactly as if you had written the aliased type. In other words, this code might *look* illegal, but is OK according to TypeScript because both types are aliases for the same type:\n\n``` ts\ntype UserInputSanitizedString = string;\n \nfunction sanitizeInput(str: string): UserInputSanitizedString {\n  return sanitize(str);\n}\n \n// Create a sanitized input\nlet userInput = sanitizeInput(getInput());\n \n// Can still be re-assigned with a string though\nuserInput = \"new input\";\n```\n\n## Interfaces\n\nAn *interface declaration* is another way to name an object type:\n\n``` ts\ninterface Point {\n  x: number;\n  y: number;\n}\n \nfunction printCoord(pt: Point) {\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\n \nprintCoord({ x: 100, y: 100 });\n```\n\nJust like when we used a type alias above, the example works just as if we had used an anonymous object type. TypeScript is only concerned with the *structure* of the value we passed to `printCoord` - it only cares that it has the expected properties. Being concerned only with the structure and capabilities of types is why we call TypeScript a *structurally typed* type system.\n\n### Differences Between Type Aliases and Interfaces\n\nType aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an `interface` are available in `type`, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.\n\n[TABLE]\n\nYou’ll learn more about these concepts in later chapters, so don’t worry if you don’t understand all of these right away.\n\n- Prior to TypeScript version 4.2, type alias names [*may* appear in error messages](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA), sometimes in place of the equivalent anonymous type (which may or may not be desirable). Interfaces will always be named in error messages.\n- Type aliases may not participate [in declaration merging, but interfaces can](https://www.typescriptlang.org/play?#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA).\n- Interfaces may only be used to [declare the shapes of objects, not rename primitives](https://www.typescriptlang.org/play?#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA).\n- Interface names will [*always* appear in their original form](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA) in error messages, but *only* when they are used by name.\n- Using interfaces with `extends` [can often be more performant for the compiler](https://github.com/microsoft/TypeScript/wiki/Performance#preferring-interfaces-over-intersections) than type aliases with intersections\n\nFor the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration. If you would like a heuristic, use `interface` until you need to use features from `type`.\n\n## Type Assertions\n\nSometimes you will have information about the type of a value that TypeScript can’t know about.\n\nFor example, if you’re using `document.getElementById`, TypeScript only knows that this will return *some* kind of `HTMLElement`, but you might know that your page will always have an `HTMLCanvasElement` with a given ID.\n\nIn this situation, you can use a *type assertion* to specify a more specific type:\n\n``` ts\nconst myCanvas = document.getElementById(\"main_canvas\") as HTMLCanvasElement;\n```\n\nLike a type annotation, type assertions are removed by the compiler and won’t affect the runtime behavior of your code.\n\nYou can also use the angle-bracket syntax (except if the code is in a `.tsx` file), which is equivalent:\n\n``` ts\nconst myCanvas = <HTMLCanvasElement>document.getElementById(\"main_canvas\");\n```\n\n> Reminder: Because type assertions are removed at compile-time, there is no runtime checking associated with a type assertion. There won’t be an exception or `null` generated if the type assertion is wrong.\n\nTypeScript only allows type assertions which convert to a *more specific* or *less specific* version of a type. This rule prevents “impossible” coercions like:\n\n``` ts\nconst x = \"hello\" as number;\n```\n\nSometimes this rule can be too conservative and will disallow more complex coercions that might be valid. If this happens, you can use two assertions, first to `any` (or `unknown`, which we’ll introduce later), then to the desired type:\n\n``` ts\nconst a = expr as any as T;\n```\n\n## Literal Types\n\nIn addition to the general types `string` and `number`, we can refer to *specific* strings and numbers in type positions.\n\nOne way to think about this is to consider how JavaScript comes with different ways to declare a variable. Both `var` and `let` allow for changing what is held inside the variable, and `const` does not. This is reflected in how TypeScript creates types for literals.\n\n``` ts\nlet changingString = \"Hello World\";\nchangingString = \"Olá Mundo\";\n// Because `changingString` can represent any possible string, that\n// is how TypeScript describes it in the type system\nchangingString;\n \nconst constantString = \"Hello World\";\n// Because `constantString` can only represent 1 possible string, it\n// has a literal type representation\nconstantString;\n```\n\nBy themselves, literal types aren’t very valuable:\n\n``` ts\nlet x: \"hello\" = \"hello\";\n// OK\nx = \"hello\";\n// ...\nx = \"howdy\";\n```\n\nIt’s not much use to have a variable that can only have one value!\n\nBut by *combining* literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values:\n\n``` ts\nfunction printText(s: string, alignment: \"left\" | \"right\" | \"center\") {\n  // ...\n}\nprintText(\"Hello, world\", \"left\");\nprintText(\"G'day, mate\", \"centre\");\n```\n\nNumeric literal types work the same way:\n\n``` ts\nfunction compare(a: string, b: string): -1 | 0 | 1 {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n```\n\nOf course, you can combine these with non-literal types:\n\n``` ts\ninterface Options {\n  width: number;\n}\nfunction configure(x: Options | \"auto\") {\n  // ...\n}\nconfigure({ width: 100 });\nconfigure(\"auto\");\nconfigure(\"automatic\");\n```\n\nThere’s one more kind of literal type: boolean literals. There are only two boolean literal types, and as you might guess, they are the types `true` and `false`. The type `boolean` itself is actually just an alias for the union `true | false`.\n\n### Literal Inference\n\nWhen you initialize a variable with an object, TypeScript assumes that the properties of that object might change values later. For example, if you wrote code like this:\n\n``` ts\nconst obj = { counter: 0 };\nif (someCondition) {\n  obj.counter = 1;\n}\n```\n\nTypeScript doesn’t assume the assignment of `1` to a field which previously had `0` is an error. Another way of saying this is that `obj.counter` must have the type `number`, not `0`, because types are used to determine both *reading* and *writing* behavior.\n\nThe same applies to strings:\n\n``` ts\ndeclare function handleRequest(url: string, method: \"GET\" | \"POST\"): void;\n \nconst req = { url: \"https://example.com\", method: \"GET\" };\nhandleRequest(req.url, req.method);\n```\n\nIn the above example `req.method` is inferred to be `string`, not `\"GET\"`. Because code can be evaluated between the creation of `req` and the call of `handleRequest` which could assign a new string like `\"GUESS\"` to `req.method`, TypeScript considers this code to have an error.\n\nThere are two ways to work around this.\n\n1.  You can change the inference by adding a type assertion in either location:\n\n    ``` ts\n    // Change 1:\n    const req = { url: \"https://example.com\", method: \"GET\" as \"GET\" };\n    // Change 2\n    handleRequest(req.url, req.method as \"GET\");\n    ```\n\n    Change 1 means “I intend for `req.method` to always have the *literal type* `\"GET\"`”, preventing the possible assignment of `\"GUESS\"` to that field after. Change 2 means “I know for other reasons that `req.method` has the value `\"GET\"`“.\n\n2.  You can use `as const` to convert the entire object to be type literals:\n\n    ``` ts\n    const req = { url: \"https://example.com\", method: \"GET\" } as const;\n    handleRequest(req.url, req.method);\n    ```\n\nThe `as const` suffix acts like `const` but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like `string` or `number`.\n\n## `null` and `undefined`\n\nJavaScript has two primitive values used to signal absent or uninitialized value: `null` and `undefined`.\n\nTypeScript has two corresponding *types* by the same names. How these types behave depends on whether you have the [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) option on.\n\n### `strictNullChecks` off\n\nWith [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) *off*, values that might be `null` or `undefined` can still be accessed normally, and the values `null` and `undefined` can be assigned to a property of any type. This is similar to how languages without null checks (e.g. C#, Java) behave. The lack of checking for these values tends to be a major source of bugs; we always recommend people turn [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) on if it’s practical to do so in their codebase.\n\n### `strictNullChecks` on\n\nWith [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) *on*, when a value is `null` or `undefined`, you will need to test for those values before using methods or properties on that value. Just like checking for `undefined` before using an optional property, we can use *narrowing* to check for values that might be `null`:\n\n``` ts\nfunction doSomething(x: string | null) {\n  if (x === null) {\n    // do nothing\n  } else {\n    console.log(\"Hello, \" + x.toUpperCase());\n  }\n}\n```\n\n### Non-null Assertion Operator (Postfix `!`)\n\nTypeScript also has a special syntax for removing `null` and `undefined` from a type without doing any explicit checking. Writing `!` after any expression is effectively a type assertion that the value isn’t `null` or `undefined`:\n\n``` ts\nfunction liveDangerously(x?: number | null) {\n  // No error\n  console.log(x!.toFixed());\n}\n```\n\nJust like other type assertions, this doesn’t change the runtime behavior of your code, so it’s important to only use `!` when you know that the value *can’t* be `null` or `undefined`.\n\n## Enums\n\nEnums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants. Unlike most TypeScript features, this is *not* a type-level addition to JavaScript but something added to the language and runtime. Because of this, it’s a feature which you should know exists, but maybe hold off on using unless you are sure. You can read more about enums in the [Enum reference page](../enums).\n\n## Less Common Primitives\n\nIt’s worth mentioning the rest of the primitives in JavaScript which are represented in the type system. Though we will not go into depth here.\n\n#### `bigint`\n\nFrom ES2020 onwards, there is a primitive in JavaScript used for very large integers, `BigInt`:\n\n``` ts\n// Creating a bigint via the BigInt function\nconst oneHundred: bigint = BigInt(100);\n \n// Creating a BigInt via the literal syntax\nconst anotherHundred: bigint = 100n;\n```\n\nYou can learn more about BigInt in [the TypeScript 3.2 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint).\n\n#### `symbol`\n\nThere is a primitive in JavaScript used to create a globally unique reference via the function `Symbol()`:\n\n``` ts\nconst firstName = Symbol(\"name\");\nconst secondName = Symbol(\"name\");\n \nif (firstName === secondName) {\n  // Can't ever happen\n}\n```\n\nYou can learn more about them in [Symbols reference page](../symbols).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/everyday-types.html](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)"
- name: 'Everyday Types: any'
  id: 2/everyday-types#any
  summary: TypeScript also has a special type, any, that you can use whenever you don’t want a particular value to cause typechecking errors
  belongs_to: Everyday Types
  description: |-
    ## `any`

    TypeScript also has a special type, `any`, that you can use whenever you don’t want a particular value to cause typechecking errors.

    When a value is of type `any`, you can access any properties of it (which will in turn be of type `any`), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:

    ``` ts
    let obj: any = { x: 0 };
    // None of the following lines of code will throw compiler errors.
    // Using `any` disables all further type checking, and it is assumed
    // you know the environment better than TypeScript.
    obj.foo();
    obj();
    obj.bar = 100;
    obj = "hello";
    const n: number = obj;
    ```

    The `any` type is useful when you don’t want to write out a long type just to convince TypeScript that a particular line of code is okay.
- name: 'Everyday Types: Arrays'
  id: 2/everyday-types#arrays
  summary: To specify the type of an array like [1, 2, 3], you can use the syntax number[]; this syntax works for any type (e.g
  belongs_to: Everyday Types
  description: |-
    ## Arrays

    To specify the type of an array like `[1, 2, 3]`, you can use the syntax `number[]`; this syntax works for any type (e.g. `string[]` is an array of strings, and so on). You may also see this written as `Array<number>`, which means the same thing. We’ll learn more about the syntax `T<U>` when we cover *generics*.

    > Note that `[number]` is a different thing; refer to the section on [Tuples](objects#tuple-types).
- name: 'Everyday Types: Enums'
  id: 2/everyday-types#enums
  summary: Enums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants
  belongs_to: Everyday Types
  description: |-
    ## Enums

    Enums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants. Unlike most TypeScript features, this is *not* a type-level addition to JavaScript but something added to the language and runtime. Because of this, it’s a feature which you should know exists, but maybe hold off on using unless you are sure. You can read more about enums in the [Enum reference page](../enums).
- name: 'Everyday Types: Functions'
  id: 2/everyday-types#functions
  summary: Functions are the primary means of passing data around in JavaScript
  belongs_to: Everyday Types
  description: |-
    ## Functions

    Functions are the primary means of passing data around in JavaScript. TypeScript allows you to specify the types of both the input and output values of functions.

    ### Parameter Type Annotations

    When you declare a function, you can add type annotations after each parameter to declare what types of parameters the function accepts. Parameter type annotations go after the parameter name:

    ``` ts
    // Parameter type annotation
    function greet(name: string) {
      console.log("Hello, " + name.toUpperCase() + "!!");
    }
    ```

    When a parameter has a type annotation, arguments to that function will be checked:

    ``` ts
    // Would be a runtime error if executed!
    greet(42);
    ```

    > Even if you don’t have type annotations on your parameters, TypeScript will still check that you passed the right number of arguments.

    ### Return Type Annotations

    You can also add return type annotations. Return type annotations appear after the parameter list:

    ``` ts
    function getFavoriteNumber(): number {
      return 26;
    }
    ```

    Much like variable type annotations, you usually don’t need a return type annotation because TypeScript will infer the function’s return type based on its `return` statements. The type annotation in the above example doesn’t change anything. Some codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference.

    #### Functions Which Return Promises

    If you want to annotate the return type of a function which returns a promise, you should use the `Promise` type:

    ``` ts
    async function getFavoriteNumber(): Promise<number> {
      return 26;
    }
    ```

    ### Anonymous Functions

    Anonymous functions are a little bit different from function declarations. When a function appears in a place where TypeScript can determine how it’s going to be called, the parameters of that function are automatically given types.

    Here’s an example:

    ``` ts
    const names = ["Alice", "Bob", "Eve"];
     
    // Contextual typing for function - parameter s inferred to have type string
    names.forEach(function (s) {
      console.log(s.toUpperCase());
    });
     
    // Contextual typing also applies to arrow functions
    names.forEach((s) => {
      console.log(s.toUpperCase());
    });
    ```

    Even though the parameter `s` didn’t have a type annotation, TypeScript used the types of the `forEach` function, along with the inferred type of the array, to determine the type `s` will have.

    This process is called *contextual typing* because the *context* that the function occurred within informs what type it should have.

    Similar to the inference rules, you don’t need to explicitly learn how this happens, but understanding that it *does* happen can help you notice when type annotations aren’t needed. Later, we’ll see more examples of how the context that a value occurs in can affect its type.
- name: 'Everyday Types: Interfaces'
  id: 2/everyday-types#interfaces
  summary: Just like when we used a type alias above, the example works just as if we had used an anonymous object type
  belongs_to: Everyday Types
  description: |-
    ## Interfaces

    An *interface declaration* is another way to name an object type:

    ``` ts
    interface Point {
      x: number;
      y: number;
    }
     
    function printCoord(pt: Point) {
      console.log("The coordinate's x value is " + pt.x);
      console.log("The coordinate's y value is " + pt.y);
    }
     
    printCoord({ x: 100, y: 100 });
    ```

    Just like when we used a type alias above, the example works just as if we had used an anonymous object type. TypeScript is only concerned with the *structure* of the value we passed to `printCoord` - it only cares that it has the expected properties. Being concerned only with the structure and capabilities of types is why we call TypeScript a *structurally typed* type system.

    ### Differences Between Type Aliases and Interfaces

    Type aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an `interface` are available in `type`, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.

    [TABLE]

    You’ll learn more about these concepts in later chapters, so don’t worry if you don’t understand all of these right away.

    - Prior to TypeScript version 4.2, type alias names [*may* appear in error messages](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA), sometimes in place of the equivalent anonymous type (which may or may not be desirable). Interfaces will always be named in error messages.
    - Type aliases may not participate [in declaration merging, but interfaces can](https://www.typescriptlang.org/play?#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA).
    - Interfaces may only be used to [declare the shapes of objects, not rename primitives](https://www.typescriptlang.org/play?#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA).
    - Interface names will [*always* appear in their original form](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA) in error messages, but *only* when they are used by name.
    - Using interfaces with `extends` [can often be more performant for the compiler](https://github.com/microsoft/TypeScript/wiki/Performance#preferring-interfaces-over-intersections) than type aliases with intersections

    For the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration. If you would like a heuristic, use `interface` until you need to use features from `type`.
- name: 'Everyday Types: Less Common Primitives'
  id: 2/everyday-types#less-common-primitives
  summary: It’s worth mentioning the rest of the primitives in JavaScript which are represented in the type system
  belongs_to: Everyday Types
  description: "## Less Common Primitives\n\nIt’s worth mentioning the rest of the primitives in JavaScript which are represented in the type system. Though we will not go into depth here.\n\n#### `bigint`\n\nFrom ES2020 onwards, there is a primitive in JavaScript used for very large integers, `BigInt`:\n\n``` ts\n// Creating a bigint via the BigInt function\nconst oneHundred: bigint = BigInt(100);\n \n// Creating a BigInt via the literal syntax\nconst anotherHundred: bigint = 100n;\n```\n\nYou can learn more about BigInt in [the TypeScript 3.2 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint).\n\n#### `symbol`\n\nThere is a primitive in JavaScript used to create a globally unique reference via the function `Symbol()`:\n\n``` ts\nconst firstName = Symbol(\"name\");\nconst secondName = Symbol(\"name\");\n \nif (firstName === secondName) {\n  // Can't ever happen\n}\n```\n\nYou can learn more about them in [Symbols reference page](../symbols).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/everyday-types.html](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)"
- name: 'Everyday Types: Literal Types'
  id: 2/everyday-types#literal-types
  summary: In addition to the general types string and number, we can refer to specific strings and numbers in type positions
  belongs_to: Everyday Types
  description: |-
    ## Literal Types

    In addition to the general types `string` and `number`, we can refer to *specific* strings and numbers in type positions.

    One way to think about this is to consider how JavaScript comes with different ways to declare a variable. Both `var` and `let` allow for changing what is held inside the variable, and `const` does not. This is reflected in how TypeScript creates types for literals.

    ``` ts
    let changingString = "Hello World";
    changingString = "Olá Mundo";
    // Because `changingString` can represent any possible string, that
    // is how TypeScript describes it in the type system
    changingString;
     
    const constantString = "Hello World";
    // Because `constantString` can only represent 1 possible string, it
    // has a literal type representation
    constantString;
    ```

    By themselves, literal types aren’t very valuable:

    ``` ts
    let x: "hello" = "hello";
    // OK
    x = "hello";
    // ...
    x = "howdy";
    ```

    It’s not much use to have a variable that can only have one value!

    But by *combining* literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values:

    ``` ts
    function printText(s: string, alignment: "left" | "right" | "center") {
      // ...
    }
    printText("Hello, world", "left");
    printText("G'day, mate", "centre");
    ```

    Numeric literal types work the same way:

    ``` ts
    function compare(a: string, b: string): -1 | 0 | 1 {
      return a === b ? 0 : a > b ? 1 : -1;
    }
    ```

    Of course, you can combine these with non-literal types:

    ``` ts
    interface Options {
      width: number;
    }
    function configure(x: Options | "auto") {
      // ...
    }
    configure({ width: 100 });
    configure("auto");
    configure("automatic");
    ```

    There’s one more kind of literal type: boolean literals. There are only two boolean literal types, and as you might guess, they are the types `true` and `false`. The type `boolean` itself is actually just an alias for the union `true | false`.

    ### Literal Inference

    When you initialize a variable with an object, TypeScript assumes that the properties of that object might change values later. For example, if you wrote code like this:

    ``` ts
    const obj = { counter: 0 };
    if (someCondition) {
      obj.counter = 1;
    }
    ```

    TypeScript doesn’t assume the assignment of `1` to a field which previously had `0` is an error. Another way of saying this is that `obj.counter` must have the type `number`, not `0`, because types are used to determine both *reading* and *writing* behavior.

    The same applies to strings:

    ``` ts
    declare function handleRequest(url: string, method: "GET" | "POST"): void;
     
    const req = { url: "https://example.com", method: "GET" };
    handleRequest(req.url, req.method);
    ```

    In the above example `req.method` is inferred to be `string`, not `"GET"`. Because code can be evaluated between the creation of `req` and the call of `handleRequest` which could assign a new string like `"GUESS"` to `req.method`, TypeScript considers this code to have an error.

    There are two ways to work around this.

    1.  You can change the inference by adding a type assertion in either location:

        ``` ts
        // Change 1:
        const req = { url: "https://example.com", method: "GET" as "GET" };
        // Change 2
        handleRequest(req.url, req.method as "GET");
        ```

        Change 1 means “I intend for `req.method` to always have the *literal type* `"GET"`”, preventing the possible assignment of `"GUESS"` to that field after. Change 2 means “I know for other reasons that `req.method` has the value `"GET"`“.

    2.  You can use `as const` to convert the entire object to be type literals:

        ``` ts
        const req = { url: "https://example.com", method: "GET" } as const;
        handleRequest(req.url, req.method);
        ```

    The `as const` suffix acts like `const` but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like `string` or `number`.
- name: 'Everyday Types: noImplicitAny'
  id: 2/everyday-types#noimplicitany
  summary: When you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to any
  belongs_to: Everyday Types
  description: |-
    ### `noImplicitAny`

    When you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to `any`.

    You usually want to avoid this, though, because `any` isn’t type-checked. Use the compiler flag [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) to flag any implicit `any` as an error.
- name: 'Everyday Types: Non-null Assertion Operator (Postfix !)'
  id: 2/everyday-types#non-null-assertion-operator-postfix-
  summary: TypeScript also has a special syntax for removing null and undefined from a type without doing any explicit checking
  belongs_to: Everyday Types
  description: |-
    ### Non-null Assertion Operator (Postfix `!`)

    TypeScript also has a special syntax for removing `null` and `undefined` from a type without doing any explicit checking. Writing `!` after any expression is effectively a type assertion that the value isn’t `null` or `undefined`:

    ``` ts
    function liveDangerously(x?: number | null) {
      // No error
      console.log(x!.toFixed());
    }
    ```

    Just like other type assertions, this doesn’t change the runtime behavior of your code, so it’s important to only use `!` when you know that the value *can’t* be `null` or `undefined`.
- name: 'Everyday Types: null and undefined'
  id: 2/everyday-types#null-and-undefined
  summary: 'JavaScript has two primitive values used to signal absent or uninitialized value: null and undefined'
  belongs_to: Everyday Types
  description: |-
    ## `null` and `undefined`

    JavaScript has two primitive values used to signal absent or uninitialized value: `null` and `undefined`.

    TypeScript has two corresponding *types* by the same names. How these types behave depends on whether you have the [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) option on.
- name: 'Everyday Types: Object Types'
  id: 2/everyday-types#object-types
  summary: Apart from primitives, the most common sort of type you’ll encounter is an object type
  belongs_to: Everyday Types
  description: |-
    ## Object Types

    Apart from primitives, the most common sort of type you’ll encounter is an *object type*. This refers to any JavaScript value with properties, which is almost all of them! To define an object type, we simply list its properties and their types.

    For example, here’s a function that takes a point-like object:

    ``` ts
    // The parameter's type annotation is an object type
    function printCoord(pt: { x: number; y: number }) {
      console.log("The coordinate's x value is " + pt.x);
      console.log("The coordinate's y value is " + pt.y);
    }
    printCoord({ x: 3, y: 7 });
    ```

    Here, we annotated the parameter with a type with two properties - `x` and `y` - which are both of type `number`. You can use `,` or `;` to separate the properties, and the last separator is optional either way.

    The type part of each property is also optional. If you don’t specify a type, it will be assumed to be `any`.

    ### Optional Properties

    Object types can also specify that some or all of their properties are *optional*. To do this, add a `?` after the property name:

    ``` ts
    function printName(obj: { first: string; last?: string }) {
      // ...
    }
    // Both OK
    printName({ first: "Bob" });
    printName({ first: "Alice", last: "Alisson" });
    ```

    In JavaScript, if you access a property that doesn’t exist, you’ll get the value `undefined` rather than a runtime error. Because of this, when you *read* from an optional property, you’ll have to check for `undefined` before using it.

    ``` ts
    function printName(obj: { first: string; last?: string }) {
      // Error - might crash if 'obj.last' wasn't provided!
      console.log(obj.last.toUpperCase());
      if (obj.last !== undefined) {
        // OK
        console.log(obj.last.toUpperCase());
      }
     
      // A safe alternative using modern JavaScript syntax:
      console.log(obj.last?.toUpperCase());
    }
    ```
- name: 'Everyday Types: strictNullChecks off'
  id: 2/everyday-types#strictnullchecks-off
  summary: With strictNullChecks off, values that might be null or undefined can still be accessed normally, and the values null and undefined can be assigned to a property of any type
  belongs_to: Everyday Types
  description: |-
    ### `strictNullChecks` off

    With [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) *off*, values that might be `null` or `undefined` can still be accessed normally, and the values `null` and `undefined` can be assigned to a property of any type. This is similar to how languages without null checks (e.g. C#, Java) behave. The lack of checking for these values tends to be a major source of bugs; we always recommend people turn [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) on if it’s practical to do so in their codebase.
- name: 'Everyday Types: strictNullChecks on'
  id: 2/everyday-types#strictnullchecks-on
  summary: With strictNullChecks on, when a value is null or undefined, you will need to test for those values before using methods or properties on that value
  belongs_to: Everyday Types
  description: |-
    ### `strictNullChecks` on

    With [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) *on*, when a value is `null` or `undefined`, you will need to test for those values before using methods or properties on that value. Just like checking for `undefined` before using an optional property, we can use *narrowing* to check for values that might be `null`:

    ``` ts
    function doSomething(x: string | null) {
      if (x === null) {
        // do nothing
      } else {
        console.log("Hello, " + x.toUpperCase());
      }
    }
    ```
- name: 'Everyday Types: The primitives: string, number, and boolean'
  id: 2/everyday-types#the-primitives-string-number-and-boolean
  summary: 'JavaScript has three very commonly used primitives: string, number, and boolean'
  belongs_to: Everyday Types
  description: |-
    ## The primitives: `string`, `number`, and `boolean`

    JavaScript has three very commonly used [primitives](https://developer.mozilla.org/en-US/docs/Glossary/Primitive): `string`, `number`, and `boolean`. Each has a corresponding type in TypeScript. As you might expect, these are the same names you’d see if you used the JavaScript `typeof` operator on a value of those types:

    - `string` represents string values like `"Hello, world"`
    - `number` is for numbers like `42`. JavaScript does not have a special runtime value for integers, so there’s no equivalent to `int` or `float` - everything is simply `number`
    - `boolean` is for the two values `true` and `false`

    > The type names `String`, `Number`, and `Boolean` (starting with capital letters) are legal, but refer to some special built-in types that will very rarely appear in your code. *Always* use `string`, `number`, or `boolean` for types.
- name: 'Everyday Types: Type Aliases'
  id: 2/everyday-types#type-aliases
  summary: We’ve been using object types and union types by writing them directly in type annotations
  belongs_to: Everyday Types
  description: |-
    ## Type Aliases

    We’ve been using object types and union types by writing them directly in type annotations. This is convenient, but it’s common to want to use the same type more than once and refer to it by a single name.

    A *type alias* is exactly that - a *name* for any *type*. The syntax for a type alias is:

    ``` ts
    type Point = {
      x: number;
      y: number;
    };
     
    // Exactly the same as the earlier example
    function printCoord(pt: Point) {
      console.log("The coordinate's x value is " + pt.x);
      console.log("The coordinate's y value is " + pt.y);
    }
     
    printCoord({ x: 100, y: 100 });
    ```

    You can actually use a type alias to give a name to any type at all, not just an object type. For example, a type alias can name a union type:

    ``` ts
    type ID = number | string;
    ```

    Note that aliases are *only* aliases - you cannot use type aliases to create different/distinct “versions” of the same type. When you use the alias, it’s exactly as if you had written the aliased type. In other words, this code might *look* illegal, but is OK according to TypeScript because both types are aliases for the same type:

    ``` ts
    type UserInputSanitizedString = string;
     
    function sanitizeInput(str: string): UserInputSanitizedString {
      return sanitize(str);
    }
     
    // Create a sanitized input
    let userInput = sanitizeInput(getInput());
     
    // Can still be re-assigned with a string though
    userInput = "new input";
    ```
- name: 'Everyday Types: Type Annotations on Variables'
  id: 2/everyday-types#type-annotations-on-variables
  summary: TypeScript doesn’t use “types on the left”-style declarations like int x = 0; Type annotations will always go after the thing being typed
  belongs_to: Everyday Types
  description: |-
    ## Type Annotations on Variables

    When you declare a variable using `const`, `var`, or `let`, you can optionally add a type annotation to explicitly specify the type of the variable:

    ``` ts
    let myName: string = "Alice";
    ```

    > TypeScript doesn’t use “types on the left”-style declarations like `int x = 0;` Type annotations will always go *after* the thing being typed.

    In most cases, though, this isn’t needed. Wherever possible, TypeScript tries to automatically *infer* the types in your code. For example, the type of a variable is inferred based on the type of its initializer:

    ``` ts
    // No type annotation needed -- 'myName' inferred as type 'string'
    let myName = "Alice";
    ```

    For the most part you don’t need to explicitly learn the rules of inference. If you’re starting out, try using fewer type annotations than you think - you might be surprised how few you need for TypeScript to fully understand what’s going on.
- name: 'Everyday Types: Type Assertions'
  id: 2/everyday-types#type-assertions
  summary: Sometimes you will have information about the type of a value that TypeScript can’t know about
  belongs_to: Everyday Types
  description: |-
    ## Type Assertions

    Sometimes you will have information about the type of a value that TypeScript can’t know about.

    For example, if you’re using `document.getElementById`, TypeScript only knows that this will return *some* kind of `HTMLElement`, but you might know that your page will always have an `HTMLCanvasElement` with a given ID.

    In this situation, you can use a *type assertion* to specify a more specific type:

    ``` ts
    const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;
    ```

    Like a type annotation, type assertions are removed by the compiler and won’t affect the runtime behavior of your code.

    You can also use the angle-bracket syntax (except if the code is in a `.tsx` file), which is equivalent:

    ``` ts
    const myCanvas = <HTMLCanvasElement>document.getElementById("main_canvas");
    ```

    > Reminder: Because type assertions are removed at compile-time, there is no runtime checking associated with a type assertion. There won’t be an exception or `null` generated if the type assertion is wrong.

    TypeScript only allows type assertions which convert to a *more specific* or *less specific* version of a type. This rule prevents “impossible” coercions like:

    ``` ts
    const x = "hello" as number;
    ```

    Sometimes this rule can be too conservative and will disallow more complex coercions that might be valid. If this happens, you can use two assertions, first to `any` (or `unknown`, which we’ll introduce later), then to the desired type:

    ``` ts
    const a = expr as any as T;
    ```
- name: 'Everyday Types: Union Types'
  id: 2/everyday-types#union-types
  summary: TypeScript’s type system allows you to build new types out of existing ones using a large variety of operators
  belongs_to: Everyday Types
  description: |-
    ## Union Types

    TypeScript’s type system allows you to build new types out of existing ones using a large variety of operators. Now that we know how to write a few types, it’s time to start *combining* them in interesting ways.

    ### Defining a Union Type

    The first way to combine types you might see is a *union* type. A union type is a type formed from two or more other types, representing values that may be *any one* of those types. We refer to each of these types as the union’s *members*.

    Let’s write a function that can operate on strings or numbers:

    ``` ts
    function printId(id: number | string) {
      console.log("Your ID is: " + id);
    }
    // OK
    printId(101);
    // OK
    printId("202");
    // Error
    printId({ myID: 22342 });
    ```

    ### Working with Union Types

    It’s easy to *provide* a value matching a union type - simply provide a type matching any of the union’s members. If you *have* a value of a union type, how do you work with it?

    TypeScript will only allow an operation if it is valid for *every* member of the union. For example, if you have the union `string | number`, you can’t use methods that are only available on `string`:

    ``` ts
    function printId(id: number | string) {
      console.log(id.toUpperCase());
    }
    ```

    The solution is to *narrow* the union with code, the same as you would in JavaScript without type annotations. *Narrowing* occurs when TypeScript can deduce a more specific type for a value based on the structure of the code.

    For example, TypeScript knows that only a `string` value will have a `typeof` value `"string"`:

    ``` ts
    function printId(id: number | string) {
      if (typeof id === "string") {
        // In this branch, id is of type 'string'
        console.log(id.toUpperCase());
      } else {
        // Here, id is of type 'number'
        console.log(id);
      }
    }
    ```

    Another example is to use a function like `Array.isArray`:

    ``` ts
    function welcomePeople(x: string[] | string) {
      if (Array.isArray(x)) {
        // Here: 'x' is 'string[]'
        console.log("Hello, " + x.join(" and "));
      } else {
        // Here: 'x' is 'string'
        console.log("Welcome lone traveler " + x);
      }
    }
    ```

    Notice that in the `else` branch, we don’t need to do anything special - if `x` wasn’t a `string[]`, then it must have been a `string`.

    Sometimes you’ll have a union where all the members have something in common. For example, both arrays and strings have a `slice` method. If every member in a union has a property in common, you can use that property without narrowing:

    ``` ts
    // Return type is inferred as number[] | string
    function getFirstThree(x: number[] | string) {
      return x.slice(0, 3);
    }
    ```

    > It might be confusing that a *union* of types appears to have the *intersection* of those types’ properties. This is not an accident - the name *union* comes from type theory. The *union* `number | string` is composed by taking the union *of the values* from each type. Notice that given two sets with corresponding facts about each set, only the *intersection* of those facts applies to the *union* of the sets themselves. For example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearing hats, after combining those rooms, the only thing we know about *every* person is that they must be wearing a hat.
- name: exactOptionalPropertyTypes
  id: tsconfig#exactOptionalPropertyTypes-config
  summary: With exactOptionalPropertyTypes enabled, TypeScript applies stricter rules around how it handles properties on type or interfaces which have a ? prefix
  belongs_to: TSConfig Reference
  description: |-
    ### Exact Optional Property Types - `exactOptionalPropertyTypes`

    With exactOptionalPropertyTypes enabled, TypeScript applies stricter rules around how it handles properties on `type` or `interfaces` which have a `?` prefix.

    For example, this interface declares that there is a property which can be one of two strings: ‘dark’ or ‘light’ or it should not be in the object.

    ``` ts
    interface UserDefaults {
      // The absence of a value represents 'system'
      colorThemeOverride?: "dark" | "light";
    }
    ```

    Without this flag enabled, there are three values which you can set `colorThemeOverride` to be: “dark”, “light” and `undefined`.

    Setting the value to `undefined` will allow most JavaScript runtime checks for the existence to fail, which is effectively falsy. However, this isn’t quite accurate; `colorThemeOverride: undefined` is not the same as `colorThemeOverride` not being defined. For example, `"colorThemeOverride" in settings` would have different behavior with `undefined` as the key compared to not being defined.

    `exactOptionalPropertyTypes` makes TypeScript truly enforce the definition provided as an optional property:

    ``` ts
    const settings = getUserSettings();
    settings.colorThemeOverride = "dark";
    settings.colorThemeOverride = "light";
     
    // But not:
    settings.colorThemeOverride = undefined;
    ```

    - Recommended

    - Released:

      [4.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html)
- name: exactOptionalPropertyTypes
  id: tsconfig/index#exactOptionalPropertyTypes-config
  summary: With exactOptionalPropertyTypes enabled, TypeScript applies stricter rules around how it handles properties on type or interfaces which have a ? prefix
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Exact Optional Property Types - `exactOptionalPropertyTypes`

    With exactOptionalPropertyTypes enabled, TypeScript applies stricter rules around how it handles properties on `type` or `interfaces` which have a `?` prefix.

    For example, this interface declares that there is a property which can be one of two strings: ‘dark’ or ‘light’ or it should not be in the object.

    ``` ts
    interface UserDefaults {
      // The absence of a value represents 'system'
      colorThemeOverride?: "dark" | "light";
    }
    ```

    Without this flag enabled, there are three values which you can set `colorThemeOverride` to be: “dark”, “light” and `undefined`.

    Setting the value to `undefined` will allow most JavaScript runtime checks for the existence to fail, which is effectively falsy. However, this isn’t quite accurate; `colorThemeOverride: undefined` is not the same as `colorThemeOverride` not being defined. For example, `"colorThemeOverride" in settings` would have different behavior with `undefined` as the key compared to not being defined.

    `exactOptionalPropertyTypes` makes TypeScript truly enforce the definition provided as an optional property:

    ``` ts
    const settings = getUserSettings();
    settings.colorThemeOverride = "dark";
    settings.colorThemeOverride = "light";
     
    // But not:
    settings.colorThemeOverride = undefined;
    ```

    - Recommended

    - Released:

      [4.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html)
- name: exclude
  id: tsconfig/index#type-exclude-config
  summary: Offers a config for disabling the type-acquisition for a certain module in JavaScript projects
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Exclude - `exclude`

    Offers a config for disabling the type-acquisition for a certain module in JavaScript projects. This can be useful for projects which include other libraries in testing infrastructure which aren’t needed in the main application.

    ``` json
    {
      "typeAcquisition": {
        "exclude": ["jest", "mocha"]
      }
    }
    ```
- name: exclude
  id: tsconfig#type-exclude-config
  summary: Offers a config for disabling the type-acquisition for a certain module in JavaScript projects
  belongs_to: TSConfig Reference
  description: |-
    ### Exclude - `exclude`

    Offers a config for disabling the type-acquisition for a certain module in JavaScript projects. This can be useful for projects which include other libraries in testing infrastructure which aren’t needed in the main application.

    ``` json
    {
      "typeAcquisition": {
        "exclude": ["jest", "mocha"]
      }
    }
    ```
- name: exclude
  id: tsconfig/index#exclude-config
  summary: Specifies an array of filenames or patterns that should be skipped when resolving include
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Exclude - `exclude`

    Specifies an array of filenames or patterns that should be skipped when resolving [`include`](#include).

    **Important**: `exclude`*only* changes which files are included as a result of the [`include`](#include) setting. A file specified by `exclude` can still become part of your codebase due to an `import` statement in your code, a `types` inclusion, a `/// <reference` directive, or being specified in the [`files`](#files) list.

    It is not a mechanism that **prevents** a file from being included in the codebase - it simply changes what the [`include`](#include) setting finds.

    - Default:

      node_modules bower_components jspm_packages [`outDir`](#outDir)

    - Related:
      - [`include`](#include)

      - [`files`](#files)
- name: exclude
  id: tsconfig#exclude-config
  summary: Specifies an array of filenames or patterns that should be skipped when resolving include
  belongs_to: TSConfig Reference
  description: |-
    ### Exclude - `exclude`

    Specifies an array of filenames or patterns that should be skipped when resolving [`include`](#include).

    **Important**: `exclude`*only* changes which files are included as a result of the [`include`](#include) setting. A file specified by `exclude` can still become part of your codebase due to an `import` statement in your code, a `types` inclusion, a `/// <reference` directive, or being specified in the [`files`](#files) list.

    It is not a mechanism that **prevents** a file from being included in the codebase - it simply changes what the [`include`](#include) setting finds.

    - Default:

      node_modules bower_components jspm_packages [`outDir`](#outDir)

    - Related:
      - [`include`](#include)

      - [`files`](#files)
- name: excludeDirectories
  id: tsconfig#watch-excludeDirectories-config
  summary: You can use excludeFiles to drastically reduce the number of files which are watched during --watch
  belongs_to: TSConfig Reference
  description: |-
    ### Exclude Directories - `excludeDirectories`

    You can use [`excludeFiles`](#excludeFiles) to drastically reduce the number of files which are watched during `--watch`. This can be a useful way to reduce the number of open file which TypeScript tracks on Linux.

    ``` typescript
    {
      "watchOptions": {
        "excludeDirectories": ["**/node_modules", "_build", "temp/*"]
      }
    }
    ```
- name: excludeDirectories
  id: tsconfig/index#watch-excludeDirectories-config
  summary: You can use excludeFiles to drastically reduce the number of files which are watched during --watch
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Exclude Directories - `excludeDirectories`

    You can use [`excludeFiles`](#excludeFiles) to drastically reduce the number of files which are watched during `--watch`. This can be a useful way to reduce the number of open file which TypeScript tracks on Linux.

    ``` typescript
    {
      "watchOptions": {
        "excludeDirectories": ["**/node_modules", "_build", "temp/*"]
      }
    }
    ```
- name: excludeFiles
  id: tsconfig/index#watch-excludeFiles-config
  summary: You can use excludeFiles to remove a set of specific files from the files which are watched
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Exclude Files - `excludeFiles`

    You can use `excludeFiles` to remove a set of specific files from the files which are watched.

    ``` typescript
    {
      "watchOptions": {
        "excludeFiles": ["temp/file.ts"]
      }
    }
    ```

    ## Type Acquisition

    Type Acquisition is only important for JavaScript projects. In TypeScript projects you need to include the types in your projects explicitly. However, for JavaScript projects, the TypeScript tooling will download types for your modules in the background and outside of your node_modules folder.
- name: excludeFiles
  id: tsconfig#watch-excludeFiles-config
  summary: You can use excludeFiles to remove a set of specific files from the files which are watched
  belongs_to: TSConfig Reference
  description: |-
    ### Exclude Files - `excludeFiles`

    You can use `excludeFiles` to remove a set of specific files from the files which are watched.

    ``` typescript
    {
      "watchOptions": {
        "excludeFiles": ["temp/file.ts"]
      }
    }
    ```

    ## Type Acquisition

    Type Acquisition is only important for JavaScript projects. In TypeScript projects you need to include the types in your projects explicitly. However, for JavaScript projects, the TypeScript tooling will download types for your modules in the background and outside of your node_modules folder.
- name: experimentalDecorators
  id: tsconfig/index#experimentalDecorators-config
  summary: Enables experimental support for decorators, which is a version of decorators that predates the TC39 standardization process
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Experimental Decorators - `experimentalDecorators`

    Enables [experimental support for decorators](https://github.com/tc39/proposal-decorators), which is a version of decorators that predates the TC39 standardization process.

    Decorators are a language feature which hasn’t yet been fully ratified into the JavaScript specification. This means that the implementation version in TypeScript may differ from the implementation in JavaScript when it it decided by TC39.

    You can find out more about decorator support in TypeScript in [the handbook](../docs/handbook/decorators).

    - Related:
      - [`emitDecoratorMetadata`](#emitDecoratorMetadata)
- name: experimentalDecorators
  id: tsconfig#experimentalDecorators-config
  summary: Enables experimental support for decorators, which is a version of decorators that predates the TC39 standardization process
  belongs_to: TSConfig Reference
  description: |-
    ### Experimental Decorators - `experimentalDecorators`

    Enables [experimental support for decorators](https://github.com/tc39/proposal-decorators), which is a version of decorators that predates the TC39 standardization process.

    Decorators are a language feature which hasn’t yet been fully ratified into the JavaScript specification. This means that the implementation version in TypeScript may differ from the implementation in JavaScript when it it decided by TC39.

    You can find out more about decorator support in TypeScript in [the handbook](docs/handbook/decorators).

    - Related:
      - [`emitDecoratorMetadata`](#emitDecoratorMetadata)
- name: explainFiles
  id: tsconfig/index#explainFiles-config
  summary: Print names of files which TypeScript sees as a part of your project and the reason they are part of the compilation
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Explain Files - `explainFiles`

    Print names of files which TypeScript sees as a part of your project and the reason they are part of the compilation.

    For example, with this project of just a single `index.ts` file

    ``` shell
    example
    ├── index.ts
    ├── package.json
    └── tsconfig.json
    ```

    Using a `tsconfig.json` which has `explainFiles` set to true:

    ``` json
    {
      "compilerOptions": {
        "target": "es5",
        "module": "commonjs",
        "explainFiles": true
      }
    }
    ```

    Running TypeScript against this folder would have output like this:

    ``` typescript
    ❯ tsc
    node_modules/typescript/lib/lib.d.ts
      Default library for target 'es5'
    node_modules/typescript/lib/lib.es5.d.ts
      Library referenced via 'es5' from file 'node_modules/typescript/lib/lib.d.ts'
    node_modules/typescript/lib/lib.dom.d.ts
      Library referenced via 'dom' from file 'node_modules/typescript/lib/lib.d.ts'
    node_modules/typescript/lib/lib.webworker.importscripts.d.ts
      Library referenced via 'webworker.importscripts' from file 'node_modules/typescript/lib/lib.d.ts'
    node_modules/typescript/lib/lib.scripthost.d.ts
      Library referenced via 'scripthost' from file 'node_modules/typescript/lib/lib.d.ts'
    index.ts
      Matched by include pattern '**/*' in 'tsconfig.json'
    ```

    The output above show:

    - The initial lib.d.ts lookup based on [`target`](#target), and the chain of `.d.ts` files which are referenced
    - The `index.ts` file located via the default pattern of [`include`](#include)

    This option is intended for debugging how a file has become a part of your compile.

    - Released:

      [4.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html)
- name: explainFiles
  id: tsconfig#explainFiles-config
  summary: Print names of files which TypeScript sees as a part of your project and the reason they are part of the compilation
  belongs_to: TSConfig Reference
  description: |-
    ### Explain Files - `explainFiles`

    Print names of files which TypeScript sees as a part of your project and the reason they are part of the compilation.

    For example, with this project of just a single `index.ts` file

    ``` shell
    example
    ├── index.ts
    ├── package.json
    └── tsconfig.json
    ```

    Using a `tsconfig.json` which has `explainFiles` set to true:

    ``` json
    {
      "compilerOptions": {
        "target": "es5",
        "module": "commonjs",
        "explainFiles": true
      }
    }
    ```

    Running TypeScript against this folder would have output like this:

    ``` typescript
    ❯ tsc
    node_modules/typescript/lib/lib.d.ts
      Default library for target 'es5'
    node_modules/typescript/lib/lib.es5.d.ts
      Library referenced via 'es5' from file 'node_modules/typescript/lib/lib.d.ts'
    node_modules/typescript/lib/lib.dom.d.ts
      Library referenced via 'dom' from file 'node_modules/typescript/lib/lib.d.ts'
    node_modules/typescript/lib/lib.webworker.importscripts.d.ts
      Library referenced via 'webworker.importscripts' from file 'node_modules/typescript/lib/lib.d.ts'
    node_modules/typescript/lib/lib.scripthost.d.ts
      Library referenced via 'scripthost' from file 'node_modules/typescript/lib/lib.d.ts'
    index.ts
      Matched by include pattern '**/*' in 'tsconfig.json'
    ```

    The output above show:

    - The initial lib.d.ts lookup based on [`target`](#target), and the chain of `.d.ts` files which are referenced
    - The `index.ts` file located via the default pattern of [`include`](#include)

    This option is intended for debugging how a file has become a part of your compile.

    - Released:

      [4.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html)
- name: extendedDiagnostics
  id: tsconfig/index#extendedDiagnostics-config
  summary: You can use this flag to discover where TypeScript is spending its time when compiling
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Extended Diagnostics - `extendedDiagnostics`

    You can use this flag to discover where TypeScript is spending its time when compiling. This is a tool used for understanding the performance characteristics of your codebase overall.

    You can learn more about how to measure and understand the output in the performance [section of the wiki](https://github.com/microsoft/TypeScript/wiki/Performance).

    - Related:
      - [`diagnostics`](#diagnostics)
- name: extendedDiagnostics
  id: tsconfig#extendedDiagnostics-config
  summary: You can use this flag to discover where TypeScript is spending its time when compiling
  belongs_to: TSConfig Reference
  description: |-
    ### Extended Diagnostics - `extendedDiagnostics`

    You can use this flag to discover where TypeScript is spending its time when compiling. This is a tool used for understanding the performance characteristics of your codebase overall.

    You can learn more about how to measure and understand the output in the performance [section of the wiki](https://github.com/microsoft/TypeScript/wiki/Performance).

    - Related:
      - [`diagnostics`](#diagnostics)
- name: extends
  id: tsconfig/index#extends-config
  summary: The value of extends is a string which contains a path to another configuration file to inherit from
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Extends - `extends`

    The value of `extends` is a string which contains a path to another configuration file to inherit from. The path may use Node.js style resolution.

    The configuration from the base file are loaded first, then overridden by those in the inheriting config file. All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.

    It’s worth noting that [`files`](#files), [`include`](#include), and [`exclude`](#exclude) from the inheriting config file *overwrite* those from the base config file, and that circularity between configuration files is not allowed.

    Currently, the only top-level property that is excluded from inheritance is [`references`](#references).

    ##### Example

    `configs/base.json`:

    ``` typescript
    {
      "compilerOptions": {
        "noImplicitAny": true,
        "strictNullChecks": true
      }
    }
    ```

    `tsconfig.json`:

    ``` typescript
    {
      "extends": "./configs/base",
      "files": ["main.ts", "supplemental.ts"]
    }
    ```

    `tsconfig.nostrictnull.json`:

    ``` typescript
    {
      "extends": "./tsconfig",
      "compilerOptions": {
        "strictNullChecks": false
      }
    }
    ```

    Properties with relative paths found in the configuration file, which aren’t excluded from inheritance, will be resolved relative to the configuration file they originated in.

    - Default:

      `false`

    - Released:

      [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html)
- name: extends
  id: tsconfig#extends-config
  summary: The value of extends is a string which contains a path to another configuration file to inherit from
  belongs_to: TSConfig Reference
  description: |-
    ### Extends - `extends`

    The value of `extends` is a string which contains a path to another configuration file to inherit from. The path may use Node.js style resolution.

    The configuration from the base file are loaded first, then overridden by those in the inheriting config file. All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.

    It’s worth noting that [`files`](#files), [`include`](#include), and [`exclude`](#exclude) from the inheriting config file *overwrite* those from the base config file, and that circularity between configuration files is not allowed.

    Currently, the only top-level property that is excluded from inheritance is [`references`](#references).

    ##### Example

    `configs/base.json`:

    ``` typescript
    {
      "compilerOptions": {
        "noImplicitAny": true,
        "strictNullChecks": true
      }
    }
    ```

    `tsconfig.json`:

    ``` typescript
    {
      "extends": "./configs/base",
      "files": ["main.ts", "supplemental.ts"]
    }
    ```

    `tsconfig.nostrictnull.json`:

    ``` typescript
    {
      "extends": "./tsconfig",
      "compilerOptions": {
        "strictNullChecks": false
      }
    }
    ```

    Properties with relative paths found in the configuration file, which aren’t excluded from inheritance, will be resolved relative to the configuration file they originated in.

    - Default:

      `false`

    - Released:

      [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html)
- name: fallbackPolling
  id: tsconfig#watch-fallbackPolling-config
  summary: When using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn’t support native file watchers
  belongs_to: TSConfig Reference
  description: |-
    ### Fallback Polling - `fallbackPolling`

    When using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn’t support native file watchers.

    - `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.
    - `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.
    - `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.
    - `synchronousWatchDirectory`: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in `node_modules` from running `npm install`), but you might want to disable it with this flag for some less-common setups.

    - Allowed:
      - `fixedinterval`

      - `priorityinterval`

      - `dynamicpriority`

      - `fixedchunksize`

    - Released:

      [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)
- name: fallbackPolling
  id: tsconfig/index#watch-fallbackPolling-config
  summary: When using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn’t support native file watchers
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Fallback Polling - `fallbackPolling`

    When using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn’t support native file watchers.

    - `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.
    - `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.
    - `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.
    - `synchronousWatchDirectory`: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in `node_modules` from running `npm install`), but you might want to disable it with this flag for some less-common setups.

    - Allowed:
      - `fixedinterval`

      - `priorityinterval`

      - `dynamicpriority`

      - `fixedchunksize`

    - Released:

      [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)
- name: files
  id: tsconfig/index#files-config
  summary: Specifies an allowlist of files to include in the program
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Files - `files`

    Specifies an allowlist of files to include in the program. An error occurs if any of the files can’t be found.

    ``` typescript
    {
      "compilerOptions": {},
      "files": [
        "core.ts",
        "sys.ts",
        "types.ts",
        "scanner.ts",
        "parser.ts",
        "utilities.ts",
        "binder.ts",
        "checker.ts",
        "tsc.ts"
      ]
    }
    ```

    This is useful when you only have a small number of files and don’t need to use a glob to reference many files. If you need that then use [`include`](#include).

    - Default:

      `false`

    - Related:
      - [`include`](#include)

      - [`exclude`](#exclude)
- name: files
  id: tsconfig#files-config
  summary: Specifies an allowlist of files to include in the program
  belongs_to: TSConfig Reference
  description: |-
    ### Files - `files`

    Specifies an allowlist of files to include in the program. An error occurs if any of the files can’t be found.

    ``` typescript
    {
      "compilerOptions": {},
      "files": [
        "core.ts",
        "sys.ts",
        "types.ts",
        "scanner.ts",
        "parser.ts",
        "utilities.ts",
        "binder.ts",
        "checker.ts",
        "tsc.ts"
      ]
    }
    ```

    This is useful when you only have a small number of files and don’t need to use a glob to reference many files. If you need that then use [`include`](#include).

    - Default:

      `false`

    - Related:
      - [`include`](#include)

      - [`exclude`](#exclude)
- name: forceConsistentCasingInFileNames
  id: tsconfig#forceConsistentCasingInFileNames-config
  summary: TypeScript follows the case sensitivity rules of the file system it’s running on
  belongs_to: TSConfig Reference
  description: |-
    ### Force Consistent Casing In File Names - `forceConsistentCasingInFileNames`

    TypeScript follows the case sensitivity rules of the file system it’s running on. This can be problematic if some developers are working in a case-sensitive file system and others aren’t. If a file attempts to import `fileManager.ts` by specifying `./FileManager.ts` the file will be found in a case-insensitive file system, but not on a case-sensitive file system.

    When this option is set, TypeScript will issue an error if a program tries to include a file by a casing different from the casing on disk.

    - Recommended

    - Default:

      `true`
- name: forceConsistentCasingInFileNames
  id: tsconfig/index#forceConsistentCasingInFileNames-config
  summary: TypeScript follows the case sensitivity rules of the file system it’s running on
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Force Consistent Casing In File Names - `forceConsistentCasingInFileNames`

    TypeScript follows the case sensitivity rules of the file system it’s running on. This can be problematic if some developers are working in a case-sensitive file system and others aren’t. If a file attempts to import `fileManager.ts` by specifying `./FileManager.ts` the file will be found in a case-insensitive file system, but not on a case-sensitive file system.

    When this option is set, TypeScript will issue an error if a program tries to include a file by a casing different from the casing on disk.

    - Recommended

    - Default:

      `true`
- name: Functions
  id: functions
  summary: Functions are the fundamental building block of any application in JavaScript
  description: "# Functions\n\nThis handbook page has been replaced, [go to the new page](2/functions)\n\nFunctions are the fundamental building block of any application in JavaScript. They’re how you build up layers of abstraction, mimicking classes, information hiding, and modules. In TypeScript, while there are classes, namespaces, and modules, functions still play the key role in describing how to *do* things. TypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with.\n\n## Functions\n\nTo begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function. This allows you to choose the most appropriate approach for your application, whether you’re building a list of functions in an API or a one-off function to hand off to another function.\n\nTo quickly recap what these two approaches look like in JavaScript:\n\n``` ts\n// Named function\nfunction add(x, y) {\n  return x + y;\n}\n \n// Anonymous function\nlet myAdd = function (x, y) {\n  return x + y;\n};\n```\n\nJust as in JavaScript, functions can refer to variables outside of the function body. When they do so, they’re said to *capture* these variables. While understanding how this works (and the trade-offs when using this technique) is outside of the scope of this article, having a firm understanding how this mechanic works is an important piece of working with JavaScript and TypeScript.\n\n``` ts\nlet z = 100;\n \nfunction addToZ(x, y) {\n  return x + y + z;\n}\n```\n\n## Function Types\n\n### Typing the function\n\nLet’s add types to our simple examples from earlier:\n\n``` ts\nfunction add(x: number, y: number): number {\n  return x + y;\n}\n \nlet myAdd = function (x: number, y: number): number {\n  return x + y;\n};\n```\n\nWe can add types to each of the parameters and then to the function itself to add a return type. TypeScript can figure the return type out by looking at the return statements, so we can also optionally leave this off in many cases.\n\n### Writing the function type\n\nNow that we’ve typed the function, let’s write the full type of the function out by looking at each piece of the function type.\n\n``` ts\nlet myAdd: (x: number, y: number) => number = function (\n  x: number,\n  y: number\n): number {\n  return x + y;\n};\n```\n\nA function’s type has the same two parts: the type of the arguments and the return type. When writing out the whole function type, both parts are required. We write out the parameter types just like a parameter list, giving each parameter a name and a type. This name is just to help with readability. We could have instead written:\n\n``` ts\nlet myAdd: (baseValue: number, increment: number) => number = function (\n  x: number,\n  y: number\n): number {\n  return x + y;\n};\n```\n\nAs long as the parameter types line up, it’s considered a valid type for the function, regardless of the names you give the parameters in the function type.\n\nThe second part is the return type. We make it clear which is the return type by using an arrow (`=>`) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn’t return a value, you would use `void` instead of leaving it off.\n\nOf note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the “hidden state” of any function and do not make up its API.\n\n### Inferring the types\n\nIn playing with the example, you may notice that the TypeScript compiler can figure out the type even if you only have types on one side of the equation:\n\n``` ts\n// The parameters 'x' and 'y' have the type number\nlet myAdd = function (x: number, y: number): number {\n  return x + y;\n};\n \n// myAdd has the full function type\nlet myAdd2: (baseValue: number, increment: number) => number = function (x, y) {\n  return x + y;\n};\n```\n\nThis is called “contextual typing”, a form of type inference. This helps cut down on the amount of effort to keep your program typed.\n\n## Optional and Default Parameters\n\nIn TypeScript, every parameter is assumed to be required by the function. This doesn’t mean that it can’t be given `null` or `undefined`, but rather, when the function is called, the compiler will check that the user has provided a value for each parameter. The compiler also assumes that these parameters are the only parameters that will be passed to the function. In short, the number of arguments given to a function has to match the number of parameters the function expects.\n\n``` ts\nfunction buildName(firstName: string, lastName: string) {\n  return firstName + \" \" + lastName;\n}\n \nlet result1 = buildName(\"Bob\"); // error, too few parameters\nlet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameters\nlet result3 = buildName(\"Bob\", \"Adams\"); // ah, just right\n```\n\nIn JavaScript, every parameter is optional, and users may leave them off as they see fit. When they do, their value is `undefined`. We can get this functionality in TypeScript by adding a `?` to the end of parameters we want to be optional. For example, let’s say we want the last name parameter from above to be optional:\n\n``` ts\nfunction buildName(firstName: string, lastName?: string) {\n  if (lastName) return firstName + \" \" + lastName;\n  else return firstName;\n}\n \nlet result1 = buildName(\"Bob\"); // works correctly now\nlet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameters\nlet result3 = buildName(\"Bob\", \"Adams\"); // ah, just right\n```\n\nAny optional parameters must follow required parameters. Had we wanted to make the first name optional, rather than the last name, we would need to change the order of parameters in the function, putting the first name last in the list.\n\nIn TypeScript, we can also set a value that a parameter will be assigned if the user does not provide one, or if the user passes `undefined` in its place. These are called default-initialized parameters. Let’s take the previous example and default the last name to `\"Smith\"`.\n\n``` ts\nfunction buildName(firstName: string, lastName = \"Smith\") {\n  return firstName + \" \" + lastName;\n}\n \nlet result1 = buildName(\"Bob\"); // works correctly now, returns \"Bob Smith\"\nlet result2 = buildName(\"Bob\", undefined); // still works, also returns \"Bob Smith\"\nlet result3 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameters\nlet result4 = buildName(\"Bob\", \"Adams\"); // ah, just right\n```\n\nDefault-initialized parameters that come after all required parameters are treated as optional, and just like optional parameters, can be omitted when calling their respective function. This means optional parameters and trailing default parameters will share commonality in their types, so both\n\n``` ts\nfunction buildName(firstName: string, lastName?: string) {\n  // ...\n}\n```\n\nand\n\n``` ts\nfunction buildName(firstName: string, lastName = \"Smith\") {\n  // ...\n}\n```\n\nshare the same type `(firstName: string, lastName?: string) => string`. The default value of `lastName` disappears in the type, only leaving behind the fact that the parameter is optional.\n\nUnlike plain optional parameters, default-initialized parameters don’t *need* to occur after required parameters. If a default-initialized parameter comes before a required parameter, users need to explicitly pass `undefined` to get the default initialized value. For example, we could write our last example with only a default initializer on `firstName`:\n\n``` ts\nfunction buildName(firstName = \"Will\", lastName: string) {\n  return firstName + \" \" + lastName;\n}\n \nlet result1 = buildName(\"Bob\"); // error, too few parameters\nlet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameters\nlet result3 = buildName(\"Bob\", \"Adams\"); // okay and returns \"Bob Adams\"\nlet result4 = buildName(undefined, \"Adams\"); // okay and returns \"Will Adams\"\n```\n\n### Rest Parameters\n\nRequired, optional, and default parameters all have one thing in common: they talk about one parameter at a time. Sometimes, you want to work with multiple parameters as a group, or you may not know how many parameters a function will ultimately take. In JavaScript, you can work with the arguments directly using the `arguments` variable that is visible inside every function body.\n\nIn TypeScript, you can gather these arguments together into a variable:\n\n``` ts\nfunction buildName(firstName: string, ...restOfName: string[]) {\n  return firstName + \" \" + restOfName.join(\" \");\n}\n \n// employeeName will be \"Joseph Samuel Lucas MacKinzie\"\nlet employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\");\n```\n\n*Rest parameters* are treated as a boundless number of optional parameters. When passing arguments for a rest parameter, you can use as many as you want; you can even pass none. The compiler will build an array of the arguments passed in with the name given after the ellipsis (`...`), allowing you to use it in your function.\n\nThe ellipsis is also used in the type of the function with rest parameters:\n\n``` ts\nfunction buildName(firstName: string, ...restOfName: string[]) {\n  return firstName + \" \" + restOfName.join(\" \");\n}\n \nlet buildNameFun: (fname: string, ...rest: string[]) => string = buildName;\n```\n\n## `this`\n\nLearning how to use `this` in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use `this` and how to spot when it’s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of `this` with a couple of techniques. If you need to learn how `this` works in JavaScript, though, first read Yehuda Katz’s [Understanding JavaScript Function Invocation and “this”](http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/). Yehuda’s article explains the inner workings of `this` very well, so we’ll just cover the basics here.\n\n### `this` and arrow functions\n\nIn JavaScript, `this` is a variable that’s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument.\n\nLet’s look at an example:\n\n``` ts\nlet deck = {\n  suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n  cards: Array(52),\n  createCardPicker: function () {\n    return function () {\n      let pickedCard = Math.floor(Math.random() * 52);\n      let pickedSuit = Math.floor(pickedCard / 13);\n \n      return { suit: this.suits[pickedSuit], card: pickedCard % 13 };\n    };\n  },\n};\n \nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n \nalert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit);\n```\n\nNotice that `createCardPicker` is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the `this` being used in the function created by `createCardPicker` will be set to `window` instead of our `deck` object. That’s because we call `cardPicker()` on its own. A top-level non-method syntax call like this will use `window` for `this`. (Note: under strict mode, `this` will be `undefined` rather than `window`).\n\nWe can fix this by making sure the function is bound to the correct `this` before we return the function to be used later. This way, regardless of how it’s later used, it will still be able to see the original `deck` object. To do this, we change the function expression to use the ECMAScript 6 arrow syntax. Arrow functions capture the `this` where the function is created rather than where it is invoked:\n\n``` ts\nlet deck = {\n  suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n  cards: Array(52),\n  createCardPicker: function () {\n    // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52);\n      let pickedSuit = Math.floor(pickedCard / 13);\n \n      return { suit: this.suits[pickedSuit], card: pickedCard % 13 };\n    };\n  },\n};\n \nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n \nalert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit);\n```\n\nEven better, TypeScript will warn you when you make this mistake if you pass the [`noImplicitThis`](https://www.typescriptlang.org/tsconfig#noImplicitThis) flag to the compiler. It will point out that `this` in `this.suits[pickedSuit]` is of type `any`.\n\n### `this` parameters\n\nUnfortunately, the type of `this.suits[pickedSuit]` is still `any`. That’s because `this` comes from the function expression inside the object literal. To fix this, you can provide an explicit `this` parameter. `this` parameters are fake parameters that come first in the parameter list of a function:\n\n``` ts\nfunction f(this: void) {\n  // make sure `this` is unusable in this standalone function\n}\n```\n\nLet’s add a couple of interfaces to our example above, `Card` and `Deck`, to make the types clearer and easier to reuse:\n\n``` ts\ninterface Card {\n  suit: string;\n  card: number;\n}\n \ninterface Deck {\n  suits: string[];\n  cards: number[];\n  createCardPicker(this: Deck): () => Card;\n}\n \nlet deck: Deck = {\n  suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n  cards: Array(52),\n  // NOTE: The function now explicitly specifies that its callee must be of type Deck\n  createCardPicker: function (this: Deck) {\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52);\n      let pickedSuit = Math.floor(pickedCard / 13);\n \n      return { suit: this.suits[pickedSuit], card: pickedCard % 13 };\n    };\n  },\n};\n \nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n \nalert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit);\n```\n\nNow TypeScript knows that `createCardPicker` expects to be called on a `Deck` object. That means that `this` is of type `Deck` now, not `any`, so [`noImplicitThis`](https://www.typescriptlang.org/tsconfig#noImplicitThis) will not cause any errors.\n\n#### `this` parameters in callbacks\n\nYou can also run into errors with `this` in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, `this` will be `undefined`. With some work you can use `this` parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with `this`:\n\n``` ts\ninterface UIElement {\n  addClickListener(onclick: (this: void, e: Event) => void): void;\n}\n```\n\n`this: void` means that `addClickListener` expects `onclick` to be a function that does not require a `this` type. Second, annotate your calling code with `this`:\n\n``` ts\nclass Handler {\n  info: string;\n  onClickBad(this: Handler, e: Event) {\n    // oops, used `this` here. using this callback would crash at runtime\n    this.info = e.message;\n  }\n}\n \nlet h = new Handler();\nuiElement.addClickListener(h.onClickBad); // error!\n```\n\nWith `this` annotated, you make it explicit that `onClickBad` must be called on an instance of `Handler`. Then TypeScript will detect that `addClickListener` requires a function that has `this: void`. To fix the error, change the type of `this`:\n\n``` ts\nclass Handler {\n  info: string;\n  onClickGood(this: void, e: Event) {\n    // can't use `this` here because it's of type void!\n    console.log(\"clicked!\");\n  }\n}\n \nlet h = new Handler();\nuiElement.addClickListener(h.onClickGood);\n```\n\nBecause `onClickGood` specifies its `this` type as `void`, it is legal to pass to `addClickListener`. Of course, this also means that it can’t use `this.info`. If you want both then you’ll have to use an arrow function:\n\n``` ts\nclass Handler {\n  info: string;\n  onClickGood = (e: Event) => {\n    this.info = e.message;\n  };\n}\n```\n\nThis works because arrow functions use the outer `this`, so you can always pass them to something that expects `this: void`. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler’s prototype. They are shared between all objects of type Handler.\n\n## Overloads\n\nJavaScript is inherently a very dynamic language. It’s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in.\n\n``` ts\nlet suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];\n \nfunction pickCard(x: any): any {\n  // Check to see if we're working with an object/array\n  // if so, they gave us the deck and we'll pick the card\n  if (typeof x == \"object\") {\n    let pickedCard = Math.floor(Math.random() * x.length);\n    return pickedCard;\n  }\n  // Otherwise just let them pick the card\n  else if (typeof x == \"number\") {\n    let pickedSuit = Math.floor(x / 13);\n    return { suit: suits[pickedSuit], card: x % 13 };\n  }\n}\n \nlet myDeck = [\n  { suit: \"diamonds\", card: 2 },\n  { suit: \"spades\", card: 10 },\n  { suit: \"hearts\", card: 4 },\n];\n \nlet pickedCard1 = myDeck[pickCard(myDeck)];\nalert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);\n \nlet pickedCard2 = pickCard(15);\nalert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit);\n```\n\nHere, the `pickCard` function will return two different things based on what the user has passed in. If the users passes in an object that represents the deck, the function will pick the card. If the user picks the card, we tell them which card they’ve picked. But how do we describe this to the type system?\n\nThe answer is to supply multiple function types for the same function as a list of overloads. This list is what the compiler will use to resolve function calls. Let’s create a list of overloads that describe what our `pickCard` accepts and what it returns.\n\n``` ts\nlet suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];\n \nfunction pickCard(x: { suit: string; card: number }[]): number;\nfunction pickCard(x: number): { suit: string; card: number };\nfunction pickCard(x: any): any {\n  // Check to see if we're working with an object/array\n  // if so, they gave us the deck and we'll pick the card\n  if (typeof x == \"object\") {\n    let pickedCard = Math.floor(Math.random() * x.length);\n    return pickedCard;\n  }\n  // Otherwise just let them pick the card\n  else if (typeof x == \"number\") {\n    let pickedSuit = Math.floor(x / 13);\n    return { suit: suits[pickedSuit], card: x % 13 };\n  }\n}\n \nlet myDeck = [\n  { suit: \"diamonds\", card: 2 },\n  { suit: \"spades\", card: 10 },\n  { suit: \"hearts\", card: 4 },\n];\n \nlet pickedCard1 = myDeck[pickCard(myDeck)];\nalert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);\n \nlet pickedCard2 = pickCard(15);\nalert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit);\n```\n\nWith this change, the overloads now give us type checked calls to the `pickCard` function.\n\nIn order for the compiler to pick the correct type check, it follows a similar process to the underlying JavaScript. It looks at the overload list and, proceeding with the first overload, attempts to call the function with the provided parameters. If it finds a match, it picks this overload as the correct overload. For this reason, it’s customary to order overloads from most specific to least specific.\n\nNote that the `function pickCard(x): any` piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling `pickCard` with any other parameter types would cause an error.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/functions.html](https://www.typescriptlang.org/docs/handbook/functions.html)"
- name: generateCpuProfile
  id: tsconfig#generateCpuProfile-config
  summary: This option gives you the chance to have TypeScript emit a v8 CPU profile during the compiler run
  belongs_to: TSConfig Reference
  description: |-
    ### Generate CPU Profile - `generateCpuProfile`

    This option gives you the chance to have TypeScript emit a v8 CPU profile during the compiler run. The CPU profile can provide insight into why your builds may be slow.

    This option can only be used from the CLI via: `--generateCpuProfile tsc-output.cpuprofile`.

    ``` shell
    npm run tsc --generateCpuProfile tsc-output.cpuprofile
    ```

    This file can be opened in a chromium based browser like Chrome or Edge Developer in [the CPU profiler](https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution) section. You can learn more about understanding the compilers performance in the [TypeScript wiki section on performance](https://github.com/microsoft/TypeScript/wiki/Performance).

    - Default:

      `profile.cpuprofile`

    - Released:

      [3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)
- name: generateCpuProfile
  id: tsconfig/index#generateCpuProfile-config
  summary: This option gives you the chance to have TypeScript emit a v8 CPU profile during the compiler run
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Generate CPU Profile - `generateCpuProfile`

    This option gives you the chance to have TypeScript emit a v8 CPU profile during the compiler run. The CPU profile can provide insight into why your builds may be slow.

    This option can only be used from the CLI via: `--generateCpuProfile tsc-output.cpuprofile`.

    ``` shell
    npm run tsc --generateCpuProfile tsc-output.cpuprofile
    ```

    This file can be opened in a chromium based browser like Chrome or Edge Developer in [the CPU profiler](https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution) section. You can learn more about understanding the compilers performance in the [TypeScript wiki section on performance](https://github.com/microsoft/TypeScript/wiki/Performance).

    - Default:

      `profile.cpuprofile`

    - Released:

      [3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)
- name: Generics
  id: generics
  summary: A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable
  description: "# Generics\n\nThis handbook page has been replaced, [go to the new page](2/generics)\n\nA major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems.\n\nIn languages like C# and Java, one of the main tools in the toolbox for creating reusable components is *generics*, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.\n\n## Hello World of Generics\n\nTo start off, let’s do the “hello world” of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the `echo` command.\n\nWithout generics, we would either have to give the identity function a specific type:\n\n``` ts\nfunction identity(arg: number): number {\n  return arg;\n}\n```\n\nOr, we could describe the identity function using the `any` type:\n\n``` ts\nfunction identity(arg: any): any {\n  return arg;\n}\n```\n\nWhile using `any` is certainly generic in that it will cause the function to accept any and all types for the type of `arg`, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.\n\nInstead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a *type variable*, a special kind of variable that works on types rather than values.\n\n``` ts\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n```\n\nWe’ve now added a type variable `T` to the identity function. This `T` allows us to capture the type the user provides (e.g. `number`), so that we can use that information later. Here, we use `T` again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.\n\nWe say that this version of the `identity` function is generic, as it works over a range of types. Unlike using `any`, it’s also just as precise (ie, it doesn’t lose any information) as the first `identity` function that used numbers for the argument and return type.\n\nOnce we’ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:\n\n``` ts\nlet output = identity<string>(\"myString\");\n```\n\nHere we explicitly set `T` to be `string` as one of the arguments to the function call, denoted using the `<>` around the arguments rather than `()`.\n\nThe second way is also perhaps the most common. Here we use *type argument inference* — that is, we want the compiler to set the value of `T` for us automatically based on the type of the argument we pass in:\n\n``` ts\nlet output = identity(\"myString\");\n```\n\nNotice that we didn’t have to explicitly pass the type in the angle brackets (`<>`); the compiler just looked at the value `\"myString\"`, and set `T` to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.\n\n## Working with Generic Type Variables\n\nWhen you begin to use generics, you’ll notice that when you create generic functions like `identity`, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.\n\nLet’s take our `identity` function from earlier:\n\n``` ts\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n```\n\nWhat if we want to also log the length of the argument `arg` to the console with each call? We might be tempted to write this:\n\n``` ts\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n```\n\nWhen we do, the compiler will give us an error that we’re using the `.length` member of `arg`, but nowhere have we said that `arg` has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a `number` instead, which does not have a `.length` member.\n\nLet’s say that we’ve actually intended this function to work on arrays of `T` rather than `T` directly. Since we’re working with arrays, the `.length` member should be available. We can describe this just like we would create arrays of other types:\n\n``` ts\nfunction loggingIdentity<T>(arg: T[]): T[] {\n  console.log(arg.length);\n  return arg;\n}\n```\n\nYou can read the type of `loggingIdentity` as “the generic function `loggingIdentity` takes a type parameter `T`, and an argument `arg` which is an array of `T`s, and returns an array of `T`s.” If we passed in an array of numbers, we’d get an array of numbers back out, as `T` would bind to `number`. This allows us to use our generic type variable `T` as part of the types we’re working with, rather than the whole type, giving us greater flexibility.\n\nWe can alternatively write the sample example this way:\n\n``` ts\nfunction loggingIdentity<T>(arg: Array<T>): Array<T> {\n  console.log(arg.length); // Array has a .length, so no more error\n  return arg;\n}\n```\n\nYou may already be familiar with this style of type from other languages. In the next section, we’ll cover how you can create your own generic types like `Array<T>`.\n\n## Generic Types\n\nIn previous sections, we created generic identity functions that worked over a range of types. In this section, we’ll explore the type of the functions themselves and how to create generic interfaces.\n\nThe type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:\n\n``` ts\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n \nlet myIdentity: <T>(arg: T) => T = identity;\n```\n\nWe could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up.\n\n``` ts\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n \nlet myIdentity: <U>(arg: U) => U = identity;\n```\n\nWe can also write the generic type as a call signature of an object literal type:\n\n``` ts\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n \nlet myIdentity: { <T>(arg: T): T } = identity;\n```\n\nWhich leads us to writing our first generic interface. Let’s take the object literal from the previous example and move it to an interface:\n\n``` ts\ninterface GenericIdentityFn {\n  <T>(arg: T): T;\n}\n \nfunction identity<T>(arg: T): T {\n  return arg;\n}\n \nlet myIdentity: GenericIdentityFn = identity;\n```\n\nIn a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we’re generic over (e.g. `Dictionary<string>` rather than just `Dictionary`). This makes the type parameter visible to all the other members of the interface.\n\n``` ts\ninterface GenericIdentityFn<T> {\n  (arg: T): T;\n}\n \nfunction identity<T>(arg: T): T {\n  return arg;\n}\n \nlet myIdentity: GenericIdentityFn<number> = identity;\n```\n\nNotice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use `GenericIdentityFn`, we now will also need to specify the corresponding type argument (here: `number`), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.\n\nIn addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.\n\n## Generic Classes\n\nA generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (`<>`) following the name of the class.\n\n``` ts\nclass GenericNumber<T> {\n  zeroValue: T;\n  add: (x: T, y: T) => T;\n}\n \nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function (x, y) {\n  return x + y;\n};\n```\n\nThis is a pretty literal use of the `GenericNumber` class, but you may have noticed that nothing is restricting it to only use the `number` type. We could have instead used `string` or even more complex objects.\n\n``` ts\nlet stringNumeric = new GenericNumber<string>();\nstringNumeric.zeroValue = \"\";\nstringNumeric.add = function (x, y) {\n  return x + y;\n};\n \nconsole.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));\n```\n\nJust as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.\n\nAs we covered in [our section on classes](classes), a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class’s type parameter.\n\n## Generic Constraints\n\nIf you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our `loggingIdentity` example, we wanted to be able to access the `.length` property of `arg`, but the compiler could not prove that every type had a `.length` property, so it warns us that we can’t make this assumption.\n\n``` ts\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n```\n\nInstead of working with any and all types, we’d like to constrain this function to work with any and all types that also have the `.length` property. As long as the type has this member, we’ll allow it, but it’s required to have at least this member. To do so, we must list our requirement as a constraint on what T can be.\n\nTo do so, we’ll create an interface that describes our constraint. Here, we’ll create an interface that has a single `.length` property and then we’ll use this interface and the `extends` keyword to denote our constraint:\n\n``` ts\ninterface Lengthwise {\n  length: number;\n}\n \nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length); // Now we know it has a .length property, so no more error\n  return arg;\n}\n```\n\nBecause the generic function is now constrained, it will no longer work over any and all types:\n\n``` ts\nloggingIdentity(3);\n```\n\nInstead, we need to pass in values whose type has all the required properties:\n\n``` ts\nloggingIdentity({ length: 10, value: 3 });\n```\n\n### Using Type Parameters in Generic Constraints\n\nYou can declare a type parameter that is constrained by another type parameter. For example, here we’d like to get a property from an object given its name. We’d like to ensure that we’re not accidentally grabbing a property that does not exist on the `obj`, so we’ll place a constraint between the two types:\n\n``` ts\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\n  return obj[key];\n}\n \nlet x = { a: 1, b: 2, c: 3, d: 4 };\n \ngetProperty(x, \"a\");\ngetProperty(x, \"m\");\n```\n\n### Using Class Types in Generics\n\nWhen creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,\n\n``` ts\nfunction create<T>(c: { new (): T }): T {\n  return new c();\n}\n```\n\nA more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.\n\n``` ts\nclass BeeKeeper {\n  hasMask: boolean;\n}\n \nclass ZooKeeper {\n  nametag: string;\n}\n \nclass Animal {\n  numLegs: number;\n}\n \nclass Bee extends Animal {\n  keeper: BeeKeeper;\n}\n \nclass Lion extends Animal {\n  keeper: ZooKeeper;\n}\n \nfunction createInstance<A extends Animal>(c: new () => A): A {\n  return new c();\n}\n \ncreateInstance(Lion).keeper.nametag;\ncreateInstance(Bee).keeper.hasMask;\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/generics.html](https://www.typescriptlang.org/docs/handbook/generics.html)"
- name: Generics
  id: 2/generics
  summary: A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable
  description: "# Generics\n\nA major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems.\n\nIn languages like C# and Java, one of the main tools in the toolbox for creating reusable components is *generics*, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.\n\n## Hello World of Generics\n\nTo start off, let’s do the “hello world” of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the `echo` command.\n\nWithout generics, we would either have to give the identity function a specific type:\n\n``` ts\nfunction identity(arg: number): number {\n  return arg;\n}\n```\n\nOr, we could describe the identity function using the `any` type:\n\n``` ts\nfunction identity(arg: any): any {\n  return arg;\n}\n```\n\nWhile using `any` is certainly generic in that it will cause the function to accept any and all types for the type of `arg`, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.\n\nInstead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a *type variable*, a special kind of variable that works on types rather than values.\n\n``` ts\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n```\n\nWe’ve now added a type variable `Type` to the identity function. This `Type` allows us to capture the type the user provides (e.g. `number`), so that we can use that information later. Here, we use `Type` again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.\n\nWe say that this version of the `identity` function is generic, as it works over a range of types. Unlike using `any`, it’s also just as precise (i.e., it doesn’t lose any information) as the first `identity` function that used numbers for the argument and return type.\n\nOnce we’ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:\n\n``` ts\nlet output = identity<string>(\"myString\");\n```\n\nHere we explicitly set `Type` to be `string` as one of the arguments to the function call, denoted using the `<>` around the arguments rather than `()`.\n\nThe second way is also perhaps the most common. Here we use *type argument inference* — that is, we want the compiler to set the value of `Type` for us automatically based on the type of the argument we pass in:\n\n``` ts\nlet output = identity(\"myString\");\n```\n\nNotice that we didn’t have to explicitly pass the type in the angle brackets (`<>`); the compiler just looked at the value `\"myString\"`, and set `Type` to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.\n\n## Working with Generic Type Variables\n\nWhen you begin to use generics, you’ll notice that when you create generic functions like `identity`, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.\n\nLet’s take our `identity` function from earlier:\n\n``` ts\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n```\n\nWhat if we want to also log the length of the argument `arg` to the console with each call? We might be tempted to write this:\n\n``` ts\nfunction loggingIdentity<Type>(arg: Type): Type {\n  console.log(arg.length);\n  return arg;\n}\n```\n\nWhen we do, the compiler will give us an error that we’re using the `.length` member of `arg`, but nowhere have we said that `arg` has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a `number` instead, which does not have a `.length` member.\n\nLet’s say that we’ve actually intended this function to work on arrays of `Type` rather than `Type` directly. Since we’re working with arrays, the `.length` member should be available. We can describe this just like we would create arrays of other types:\n\n``` ts\nfunction loggingIdentity<Type>(arg: Type[]): Type[] {\n  console.log(arg.length);\n  return arg;\n}\n```\n\nYou can read the type of `loggingIdentity` as “the generic function `loggingIdentity` takes a type parameter `Type`, and an argument `arg` which is an array of `Type`s, and returns an array of `Type`s.” If we passed in an array of numbers, we’d get an array of numbers back out, as `Type` would bind to `number`. This allows us to use our generic type variable `Type` as part of the types we’re working with, rather than the whole type, giving us greater flexibility.\n\nWe can alternatively write the sample example this way:\n\n``` ts\nfunction loggingIdentity<Type>(arg: Array<Type>): Array<Type> {\n  console.log(arg.length); // Array has a .length, so no more error\n  return arg;\n}\n```\n\nYou may already be familiar with this style of type from other languages. In the next section, we’ll cover how you can create your own generic types like `Array<Type>`.\n\n## Generic Types\n\nIn previous sections, we created generic identity functions that worked over a range of types. In this section, we’ll explore the type of the functions themselves and how to create generic interfaces.\n\nThe type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:\n\n``` ts\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n \nlet myIdentity: <Type>(arg: Type) => Type = identity;\n```\n\nWe could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up.\n\n``` ts\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n \nlet myIdentity: <Input>(arg: Input) => Input = identity;\n```\n\nWe can also write the generic type as a call signature of an object literal type:\n\n``` ts\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n \nlet myIdentity: { <Type>(arg: Type): Type } = identity;\n```\n\nWhich leads us to writing our first generic interface. Let’s take the object literal from the previous example and move it to an interface:\n\n``` ts\ninterface GenericIdentityFn {\n  <Type>(arg: Type): Type;\n}\n \nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n \nlet myIdentity: GenericIdentityFn = identity;\n```\n\nIn a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we’re generic over (e.g. `Dictionary<string>` rather than just `Dictionary`). This makes the type parameter visible to all the other members of the interface.\n\n``` ts\ninterface GenericIdentityFn<Type> {\n  (arg: Type): Type;\n}\n \nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n \nlet myIdentity: GenericIdentityFn<number> = identity;\n```\n\nNotice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use `GenericIdentityFn`, we now will also need to specify the corresponding type argument (here: `number`), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.\n\nIn addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.\n\n## Generic Classes\n\nA generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (`<>`) following the name of the class.\n\n``` ts\nclass GenericNumber<NumType> {\n  zeroValue: NumType;\n  add: (x: NumType, y: NumType) => NumType;\n}\n \nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function (x, y) {\n  return x + y;\n};\n```\n\nThis is a pretty literal use of the `GenericNumber` class, but you may have noticed that nothing is restricting it to only use the `number` type. We could have instead used `string` or even more complex objects.\n\n``` ts\nlet stringNumeric = new GenericNumber<string>();\nstringNumeric.zeroValue = \"\";\nstringNumeric.add = function (x, y) {\n  return x + y;\n};\n \nconsole.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));\n```\n\nJust as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.\n\nAs we cover in [our section on classes](classes), a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class’s type parameter.\n\n## Generic Constraints\n\nIf you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have *some* knowledge about what capabilities that set of types will have. In our `loggingIdentity` example, we wanted to be able to access the `.length` property of `arg`, but the compiler could not prove that every type had a `.length` property, so it warns us that we can’t make this assumption.\n\n``` ts\nfunction loggingIdentity<Type>(arg: Type): Type {\n  console.log(arg.length);\n  return arg;\n}\n```\n\nInstead of working with any and all types, we’d like to constrain this function to work with any and all types that *also* have the `.length` property. As long as the type has this member, we’ll allow it, but it’s required to have at least this member. To do so, we must list our requirement as a constraint on what `Type` can be.\n\nTo do so, we’ll create an interface that describes our constraint. Here, we’ll create an interface that has a single `.length` property and then we’ll use this interface and the `extends` keyword to denote our constraint:\n\n``` ts\ninterface Lengthwise {\n  length: number;\n}\n \nfunction loggingIdentity<Type extends Lengthwise>(arg: Type): Type {\n  console.log(arg.length); // Now we know it has a .length property, so no more error\n  return arg;\n}\n```\n\nBecause the generic function is now constrained, it will no longer work over any and all types:\n\n``` ts\nloggingIdentity(3);\n```\n\nInstead, we need to pass in values whose type has all the required properties:\n\n``` ts\nloggingIdentity({ length: 10, value: 3 });\n```\n\n## Using Type Parameters in Generic Constraints\n\nYou can declare a type parameter that is constrained by another type parameter. For example, here we’d like to get a property from an object given its name. We’d like to ensure that we’re not accidentally grabbing a property that does not exist on the `obj`, so we’ll place a constraint between the two types:\n\n``` ts\nfunction getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {\n  return obj[key];\n}\n \nlet x = { a: 1, b: 2, c: 3, d: 4 };\n \ngetProperty(x, \"a\");\ngetProperty(x, \"m\");\n```\n\n## Using Class Types in Generics\n\nWhen creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,\n\n``` ts\nfunction create<Type>(c: { new (): Type }): Type {\n  return new c();\n}\n```\n\nA more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.\n\n``` ts\nclass BeeKeeper {\n  hasMask: boolean = true;\n}\n \nclass ZooKeeper {\n  nametag: string = \"Mikle\";\n}\n \nclass Animal {\n  numLegs: number = 4;\n}\n \nclass Bee extends Animal {\n  numLegs = 6;\n  keeper: BeeKeeper = new BeeKeeper();\n}\n \nclass Lion extends Animal {\n  keeper: ZooKeeper = new ZooKeeper();\n}\n \nfunction createInstance<A extends Animal>(c: new () => A): A {\n  return new c();\n}\n \ncreateInstance(Lion).keeper.nametag;\ncreateInstance(Bee).keeper.hasMask;\n```\n\nThis pattern is used to power the [mixins](../mixins) design pattern.\n\n## Generic Parameter Defaults\n\nBy declaring a default for a generic type parameter, you make it optional to specify the corresponding type argument. For example, a function which creates a new `HTMLElement`. Calling the function with no arguments generates a `HTMLDivElement`; calling the function with an element as the first argument generates an element of the argument’s type. You can optionally pass a list of children as well. Previously you would have to define the function as:\n\n``` ts\ndeclare function create(): Container<HTMLDivElement, HTMLDivElement[]>;\ndeclare function create<T extends HTMLElement>(element: T): Container<T, T[]>;\ndeclare function create<T extends HTMLElement, U extends HTMLElement>(\n  element: T,\n  children: U[]\n): Container<T, U[]>;\n```\n\nWith generic parameter defaults we can reduce it to:\n\n``` ts\ndeclare function create<T extends HTMLElement = HTMLDivElement, U extends HTMLElement[] = T[]>(\n  element?: T,\n  children?: U\n): Container<T, U>;\n \nconst div = create();\n \nconst p = create(new HTMLParagraphElement());\n```\n\nA generic parameter default follows the following rules:\n\n- A type parameter is deemed optional if it has a default.\n- Required type parameters must not follow optional type parameters.\n- Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.\n- When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.\n- If a default type is specified and inference cannot choose a candidate, the default type is inferred.\n- A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.\n- A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/generics.html](https://www.typescriptlang.org/docs/handbook/2/generics.html)"
- name: 'Generics: Generic Classes'
  id: 2/generics#generic-classes
  summary: A generic class has a similar shape to a generic interface
  belongs_to: Generics
  description: |-
    ## Generic Classes

    A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (`<>`) following the name of the class.

    ``` ts
    class GenericNumber<NumType> {
      zeroValue: NumType;
      add: (x: NumType, y: NumType) => NumType;
    }
     
    let myGenericNumber = new GenericNumber<number>();
    myGenericNumber.zeroValue = 0;
    myGenericNumber.add = function (x, y) {
      return x + y;
    };
    ```

    This is a pretty literal use of the `GenericNumber` class, but you may have noticed that nothing is restricting it to only use the `number` type. We could have instead used `string` or even more complex objects.

    ``` ts
    let stringNumeric = new GenericNumber<string>();
    stringNumeric.zeroValue = "";
    stringNumeric.add = function (x, y) {
      return x + y;
    };
     
    console.log(stringNumeric.add(stringNumeric.zeroValue, "test"));
    ```

    Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.

    As we cover in [our section on classes](classes), a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class’s type parameter.
- name: 'Generics: Generic Constraints'
  id: 2/generics#generic-constraints
  summary: If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have
  belongs_to: Generics
  description: |-
    ## Generic Constraints

    If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have *some* knowledge about what capabilities that set of types will have. In our `loggingIdentity` example, we wanted to be able to access the `.length` property of `arg`, but the compiler could not prove that every type had a `.length` property, so it warns us that we can’t make this assumption.

    ``` ts
    function loggingIdentity<Type>(arg: Type): Type {
      console.log(arg.length);
      return arg;
    }
    ```

    Instead of working with any and all types, we’d like to constrain this function to work with any and all types that *also* have the `.length` property. As long as the type has this member, we’ll allow it, but it’s required to have at least this member. To do so, we must list our requirement as a constraint on what `Type` can be.

    To do so, we’ll create an interface that describes our constraint. Here, we’ll create an interface that has a single `.length` property and then we’ll use this interface and the `extends` keyword to denote our constraint:

    ``` ts
    interface Lengthwise {
      length: number;
    }
     
    function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {
      console.log(arg.length); // Now we know it has a .length property, so no more error
      return arg;
    }
    ```

    Because the generic function is now constrained, it will no longer work over any and all types:

    ``` ts
    loggingIdentity(3);
    ```

    Instead, we need to pass in values whose type has all the required properties:

    ``` ts
    loggingIdentity({ length: 10, value: 3 });
    ```
- name: 'Generics: Generic Parameter Defaults'
  id: 2/generics#generic-parameter-defaults
  summary: By declaring a default for a generic type parameter, you make it optional to specify the corresponding type argument
  belongs_to: Generics
  description: "## Generic Parameter Defaults\n\nBy declaring a default for a generic type parameter, you make it optional to specify the corresponding type argument. For example, a function which creates a new `HTMLElement`. Calling the function with no arguments generates a `HTMLDivElement`; calling the function with an element as the first argument generates an element of the argument’s type. You can optionally pass a list of children as well. Previously you would have to define the function as:\n\n``` ts\ndeclare function create(): Container<HTMLDivElement, HTMLDivElement[]>;\ndeclare function create<T extends HTMLElement>(element: T): Container<T, T[]>;\ndeclare function create<T extends HTMLElement, U extends HTMLElement>(\n  element: T,\n  children: U[]\n): Container<T, U[]>;\n```\n\nWith generic parameter defaults we can reduce it to:\n\n``` ts\ndeclare function create<T extends HTMLElement = HTMLDivElement, U extends HTMLElement[] = T[]>(\n  element?: T,\n  children?: U\n): Container<T, U>;\n \nconst div = create();\n \nconst p = create(new HTMLParagraphElement());\n```\n\nA generic parameter default follows the following rules:\n\n- A type parameter is deemed optional if it has a default.\n- Required type parameters must not follow optional type parameters.\n- Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.\n- When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.\n- If a default type is specified and inference cannot choose a candidate, the default type is inferred.\n- A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.\n- A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/generics.html](https://www.typescriptlang.org/docs/handbook/2/generics.html)"
- name: 'Generics: Generic Types'
  id: 2/generics#generic-types
  summary: In previous sections, we created generic identity functions that worked over a range of types
  belongs_to: Generics
  description: |-
    ## Generic Types

    In previous sections, we created generic identity functions that worked over a range of types. In this section, we’ll explore the type of the functions themselves and how to create generic interfaces.

    The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:

    ``` ts
    function identity<Type>(arg: Type): Type {
      return arg;
    }
     
    let myIdentity: <Type>(arg: Type) => Type = identity;
    ```

    We could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up.

    ``` ts
    function identity<Type>(arg: Type): Type {
      return arg;
    }
     
    let myIdentity: <Input>(arg: Input) => Input = identity;
    ```

    We can also write the generic type as a call signature of an object literal type:

    ``` ts
    function identity<Type>(arg: Type): Type {
      return arg;
    }
     
    let myIdentity: { <Type>(arg: Type): Type } = identity;
    ```

    Which leads us to writing our first generic interface. Let’s take the object literal from the previous example and move it to an interface:

    ``` ts
    interface GenericIdentityFn {
      <Type>(arg: Type): Type;
    }
     
    function identity<Type>(arg: Type): Type {
      return arg;
    }
     
    let myIdentity: GenericIdentityFn = identity;
    ```

    In a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we’re generic over (e.g. `Dictionary<string>` rather than just `Dictionary`). This makes the type parameter visible to all the other members of the interface.

    ``` ts
    interface GenericIdentityFn<Type> {
      (arg: Type): Type;
    }
     
    function identity<Type>(arg: Type): Type {
      return arg;
    }
     
    let myIdentity: GenericIdentityFn<number> = identity;
    ```

    Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use `GenericIdentityFn`, we now will also need to specify the corresponding type argument (here: `number`), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.

    In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.
- name: 'Generics: Hello World of Generics'
  id: 2/generics#hello-world-of-generics
  summary: 'To start off, let’s do the “hello world” of generics: the identity function'
  belongs_to: Generics
  description: |-
    ## Hello World of Generics

    To start off, let’s do the “hello world” of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the `echo` command.

    Without generics, we would either have to give the identity function a specific type:

    ``` ts
    function identity(arg: number): number {
      return arg;
    }
    ```

    Or, we could describe the identity function using the `any` type:

    ``` ts
    function identity(arg: any): any {
      return arg;
    }
    ```

    While using `any` is certainly generic in that it will cause the function to accept any and all types for the type of `arg`, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.

    Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a *type variable*, a special kind of variable that works on types rather than values.

    ``` ts
    function identity<Type>(arg: Type): Type {
      return arg;
    }
    ```

    We’ve now added a type variable `Type` to the identity function. This `Type` allows us to capture the type the user provides (e.g. `number`), so that we can use that information later. Here, we use `Type` again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.

    We say that this version of the `identity` function is generic, as it works over a range of types. Unlike using `any`, it’s also just as precise (i.e., it doesn’t lose any information) as the first `identity` function that used numbers for the argument and return type.

    Once we’ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:

    ``` ts
    let output = identity<string>("myString");
    ```

    Here we explicitly set `Type` to be `string` as one of the arguments to the function call, denoted using the `<>` around the arguments rather than `()`.

    The second way is also perhaps the most common. Here we use *type argument inference* — that is, we want the compiler to set the value of `Type` for us automatically based on the type of the argument we pass in:

    ``` ts
    let output = identity("myString");
    ```

    Notice that we didn’t have to explicitly pass the type in the angle brackets (`<>`); the compiler just looked at the value `"myString"`, and set `Type` to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.
- name: 'Generics: Using Class Types in Generics'
  id: 2/generics#using-class-types-in-generics
  summary: When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions
  belongs_to: Generics
  description: |-
    ## Using Class Types in Generics

    When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,

    ``` ts
    function create<Type>(c: { new (): Type }): Type {
      return new c();
    }
    ```

    A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.

    ``` ts
    class BeeKeeper {
      hasMask: boolean = true;
    }
     
    class ZooKeeper {
      nametag: string = "Mikle";
    }
     
    class Animal {
      numLegs: number = 4;
    }
     
    class Bee extends Animal {
      numLegs = 6;
      keeper: BeeKeeper = new BeeKeeper();
    }
     
    class Lion extends Animal {
      keeper: ZooKeeper = new ZooKeeper();
    }
     
    function createInstance<A extends Animal>(c: new () => A): A {
      return new c();
    }
     
    createInstance(Lion).keeper.nametag;
    createInstance(Bee).keeper.hasMask;
    ```

    This pattern is used to power the [mixins](../mixins) design pattern.
- name: 'Generics: Using Type Parameters in Generic Constraints'
  id: 2/generics#using-type-parameters-in-generic-constraints
  summary: You can declare a type parameter that is constrained by another type parameter
  belongs_to: Generics
  description: |-
    ## Using Type Parameters in Generic Constraints

    You can declare a type parameter that is constrained by another type parameter. For example, here we’d like to get a property from an object given its name. We’d like to ensure that we’re not accidentally grabbing a property that does not exist on the `obj`, so we’ll place a constraint between the two types:

    ``` ts
    function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
      return obj[key];
    }
     
    let x = { a: 1, b: 2, c: 3, d: 4 };
     
    getProperty(x, "a");
    getProperty(x, "m");
    ```
- name: 'Generics: Working with Generic Type Variables'
  id: 2/generics#working-with-generic-type-variables
  summary: When you begin to use generics, you’ll notice that when you create generic functions like identity, the compiler will enforce that you use any generically typed parameters in the body of the function correctly
  belongs_to: Generics
  description: |-
    ## Working with Generic Type Variables

    When you begin to use generics, you’ll notice that when you create generic functions like `identity`, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.

    Let’s take our `identity` function from earlier:

    ``` ts
    function identity<Type>(arg: Type): Type {
      return arg;
    }
    ```

    What if we want to also log the length of the argument `arg` to the console with each call? We might be tempted to write this:

    ``` ts
    function loggingIdentity<Type>(arg: Type): Type {
      console.log(arg.length);
      return arg;
    }
    ```

    When we do, the compiler will give us an error that we’re using the `.length` member of `arg`, but nowhere have we said that `arg` has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a `number` instead, which does not have a `.length` member.

    Let’s say that we’ve actually intended this function to work on arrays of `Type` rather than `Type` directly. Since we’re working with arrays, the `.length` member should be available. We can describe this just like we would create arrays of other types:

    ``` ts
    function loggingIdentity<Type>(arg: Type[]): Type[] {
      console.log(arg.length);
      return arg;
    }
    ```

    You can read the type of `loggingIdentity` as “the generic function `loggingIdentity` takes a type parameter `Type`, and an argument `arg` which is an array of `Type`s, and returns an array of `Type`s.” If we passed in an array of numbers, we’d get an array of numbers back out, as `Type` would bind to `number`. This allows us to use our generic type variable `Type` as part of the types we’re working with, rather than the whole type, giving us greater flexibility.

    We can alternatively write the sample example this way:

    ``` ts
    function loggingIdentity<Type>(arg: Array<Type>): Array<Type> {
      console.log(arg.length); // Array has a .length, so no more error
      return arg;
    }
    ```

    You may already be familiar with this style of type from other languages. In the next section, we’ll cover how you can create your own generic types like `Array<Type>`.
- name: Global .d.ts
  id: declaration-files/templates/global-d-ts
  summary: A global library is one that can be accessed from the global scope (i.e
  description: "# Global .d.ts\n\n## Global Libraries\n\nA *global* library is one that can be accessed from the global scope (i.e. without using any form of `import`). Many libraries simply expose one or more global variables for use. For example, if you were using [jQuery](https://jquery.com/), the `$` variable can be used by simply referring to it:\n\n``` ts\n$(() => {\n  console.log(\"hello!\");\n});\n```\n\nYou’ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:\n\n``` html\n<script src=\"http://a.great.cdn.for/someLib.js\"></script>\n```\n\nToday, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn’t actually UMD.\n\n## Identifying a Global Library from Code\n\nGlobal library code is usually extremely simple. A global “Hello, world” library might look like this:\n\n``` js\nfunction createGreeting(s) {\n  return \"Hello, \" + s;\n}\n```\n\nor like this:\n\n``` js\nwindow.createGreeting = function (s) {\n  return \"Hello, \" + s;\n};\n```\n\nWhen looking at the code of a global library, you’ll usually see:\n\n- Top-level `var` statements or `function` declarations\n- One or more assignments to `window.someName`\n- Assumptions that DOM primitives like `document` or `window` exist\n\nYou *won’t* see:\n\n- Checks for, or usage of, module loaders like `require` or `define`\n- CommonJS/Node.js-style imports of the form `var fs = require(\"fs\");`\n- Calls to `define(...)`\n- Documentation describing how to `require` or import the library\n\n## Examples of Global Libraries\n\nBecause it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have *no* dependencies) may still be global.\n\n## Global Library Template\n\nYou can see an example DTS below:\n\n``` ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ If this library is callable (e.g. can be invoked as myLib(3)),\n *~ include those call signatures here.\n *~ Otherwise, delete this section.\n */\ndeclare function myLib(a: string): string;\ndeclare function myLib(a: number): number;\n\n/*~ If you want the name of this library to be a valid type name,\n *~ you can do so here.\n *~\n *~ For example, this allows us to write 'var x: myLib';\n *~ Be sure this actually makes sense! If it doesn't, just\n *~ delete this declaration and add types inside the namespace below.\n */\ninterface myLib {\n  name: string;\n  length: number;\n  extras?: string[];\n}\n\n/*~ If your library has properties exposed on a global variable,\n *~ place them here.\n *~ You should also place types (interfaces and type alias) here.\n */\ndeclare namespace myLib {\n  //~ We can write 'myLib.timeout = 50;'\n  let timeout: number;\n\n  //~ We can access 'myLib.version', but not change it\n  const version: string;\n\n  //~ There's some class we can create via 'let c = new myLib.Cat(42)'\n  //~ Or reference e.g. 'function f(c: myLib.Cat) { ... }\n  class Cat {\n    constructor(n: number);\n\n    //~ We can read 'c.age' from a 'Cat' instance\n    readonly age: number;\n\n    //~ We can invoke 'c.purr()' from a 'Cat' instance\n    purr(): void;\n  }\n\n  //~ We can declare a variable as\n  //~   'var s: myLib.CatSettings = { weight: 5, name: \"Maru\" };'\n  interface CatSettings {\n    weight: number;\n    name: string;\n    tailLength?: number;\n  }\n\n  //~ We can write 'const v: myLib.VetID = 42;'\n  //~  or 'const v: myLib.VetID = \"bob\";'\n  type VetID = string | number;\n\n  //~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'\n  function checkCat(c: Cat, s?: VetID);\n}\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html)"
- name: 'Global .d.ts: Examples of Global Libraries'
  id: declaration-files/templates/global-d-ts#examples-of-global-libraries
  summary: Because it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style
  belongs_to: Global .d.ts
  description: |-
    ## Examples of Global Libraries

    Because it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have *no* dependencies) may still be global.
- name: 'Global .d.ts: Global Libraries'
  id: declaration-files/templates/global-d-ts#global-libraries
  summary: A global library is one that can be accessed from the global scope (i.e
  belongs_to: Global .d.ts
  description: |-
    ## Global Libraries

    A *global* library is one that can be accessed from the global scope (i.e. without using any form of `import`). Many libraries simply expose one or more global variables for use. For example, if you were using [jQuery](https://jquery.com/), the `$` variable can be used by simply referring to it:

    ``` ts
    $(() => {
      console.log("hello!");
    });
    ```

    You’ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:

    ``` html
    <script src="http://a.great.cdn.for/someLib.js"></script>
    ```

    Today, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn’t actually UMD.
- name: 'Global .d.ts: Global Library Template'
  id: declaration-files/templates/global-d-ts#global-library-template
  summary: © 2012-2024 Microsoft Licensed under the Apache License, Version 2.0
  belongs_to: Global .d.ts
  description: "## Global Library Template\n\nYou can see an example DTS below:\n\n``` ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ If this library is callable (e.g. can be invoked as myLib(3)),\n *~ include those call signatures here.\n *~ Otherwise, delete this section.\n */\ndeclare function myLib(a: string): string;\ndeclare function myLib(a: number): number;\n\n/*~ If you want the name of this library to be a valid type name,\n *~ you can do so here.\n *~\n *~ For example, this allows us to write 'var x: myLib';\n *~ Be sure this actually makes sense! If it doesn't, just\n *~ delete this declaration and add types inside the namespace below.\n */\ninterface myLib {\n  name: string;\n  length: number;\n  extras?: string[];\n}\n\n/*~ If your library has properties exposed on a global variable,\n *~ place them here.\n *~ You should also place types (interfaces and type alias) here.\n */\ndeclare namespace myLib {\n  //~ We can write 'myLib.timeout = 50;'\n  let timeout: number;\n\n  //~ We can access 'myLib.version', but not change it\n  const version: string;\n\n  //~ There's some class we can create via 'let c = new myLib.Cat(42)'\n  //~ Or reference e.g. 'function f(c: myLib.Cat) { ... }\n  class Cat {\n    constructor(n: number);\n\n    //~ We can read 'c.age' from a 'Cat' instance\n    readonly age: number;\n\n    //~ We can invoke 'c.purr()' from a 'Cat' instance\n    purr(): void;\n  }\n\n  //~ We can declare a variable as\n  //~   'var s: myLib.CatSettings = { weight: 5, name: \"Maru\" };'\n  interface CatSettings {\n    weight: number;\n    name: string;\n    tailLength?: number;\n  }\n\n  //~ We can write 'const v: myLib.VetID = 42;'\n  //~  or 'const v: myLib.VetID = \"bob\";'\n  type VetID = string | number;\n\n  //~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'\n  function checkCat(c: Cat, s?: VetID);\n}\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html)"
- name: 'Global .d.ts: Identifying a Global Library from Code'
  id: declaration-files/templates/global-d-ts#identifying-a-global-library-from-code
  summary: Global library code is usually extremely simple
  belongs_to: Global .d.ts
  description: |-
    ## Identifying a Global Library from Code

    Global library code is usually extremely simple. A global “Hello, world” library might look like this:

    ``` js
    function createGreeting(s) {
      return "Hello, " + s;
    }
    ```

    or like this:

    ``` js
    window.createGreeting = function (s) {
      return "Hello, " + s;
    };
    ```

    When looking at the code of a global library, you’ll usually see:

    - Top-level `var` statements or `function` declarations
    - One or more assignments to `window.someName`
    - Assumptions that DOM primitives like `document` or `window` exist

    You *won’t* see:

    - Checks for, or usage of, module loaders like `require` or `define`
    - CommonJS/Node.js-style imports of the form `var fs = require("fs");`
    - Calls to `define(...)`
    - Documentation describing how to `require` or import the library
- name: 'Global: Modifying Module'
  id: declaration-files/templates/global-modifying-module-d-ts
  summary: A global-modifying module alters existing values in the global scope when they are imported
  description: "# Global: Modifying Module\n\n## *Global-modifying Modules*\n\nA *global-modifying module* alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to `String.prototype` when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.\n\n## Identifying global-modifying modules\n\nGlobal-modifying modules are generally easy to identify from their documentation. In general, they’re similar to global plugins, but need a `require` call to activate their effects.\n\nYou might see documentation like this:\n\n``` js\n// 'require' call that doesn't use its return value\nvar unused = require(\"magic-string-time\");\n/* or */\nrequire(\"magic-string-time\");\n\nvar x = \"hello, world\";\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\n\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\n```\n\nHere is an example\n\n``` ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the global-modifying module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ Note: If your global-modifying module is callable or constructable, you'll\n *~ need to combine the patterns here with those in the module-class or module-function\n *~ template files\n */\ndeclare global {\n  /*~ Here, declare things that go in the global namespace, or augment\n   *~ existing declarations in the global namespace\n   */\n  interface String {\n    fancyFormat(opts: StringFormatOptions): string;\n  }\n}\n\n/*~ If your module exports types or values, write them as usual */\nexport interface StringFormatOptions {\n  fancinessLevel: number;\n}\n\n/*~ For example, declaring a method on the module (in addition to its global side effects) */\nexport function doSomething(): void;\n\n/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */\nexport {};\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html)"
- name: 'Global: Modifying Module: Global-modifying Modules'
  id: declaration-files/templates/global-modifying-module-d-ts#global-modifying-modules
  summary: A global-modifying module alters existing values in the global scope when they are imported
  belongs_to: 'Global: Modifying Module'
  description: |-
    ## *Global-modifying Modules*

    A *global-modifying module* alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to `String.prototype` when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.
- name: 'Global: Modifying Module: Identifying global-modifying modules'
  id: declaration-files/templates/global-modifying-module-d-ts#identifying-global-modifying-modules
  summary: Global-modifying modules are generally easy to identify from their documentation
  belongs_to: 'Global: Modifying Module'
  description: "## Identifying global-modifying modules\n\nGlobal-modifying modules are generally easy to identify from their documentation. In general, they’re similar to global plugins, but need a `require` call to activate their effects.\n\nYou might see documentation like this:\n\n``` js\n// 'require' call that doesn't use its return value\nvar unused = require(\"magic-string-time\");\n/* or */\nrequire(\"magic-string-time\");\n\nvar x = \"hello, world\";\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\n\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\n```\n\nHere is an example\n\n``` ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the global-modifying module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ Note: If your global-modifying module is callable or constructable, you'll\n *~ need to combine the patterns here with those in the module-class or module-function\n *~ template files\n */\ndeclare global {\n  /*~ Here, declare things that go in the global namespace, or augment\n   *~ existing declarations in the global namespace\n   */\n  interface String {\n    fancyFormat(opts: StringFormatOptions): string;\n  }\n}\n\n/*~ If your module exports types or values, write them as usual */\nexport interface StringFormatOptions {\n  fancinessLevel: number;\n}\n\n/*~ For example, declaring a method on the module (in addition to its global side effects) */\nexport function doSomething(): void;\n\n/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */\nexport {};\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html)"
- name: 'Global: Plugin'
  id: declaration-files/templates/global-plugin-d-ts
  summary: A UMD module is one that can either be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as Moment.js, are written this way
  description: "# Global: Plugin\n\n## *UMD*\n\nA *UMD* module is one that can *either* be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as [Moment.js](http://momentjs.com/), are written this way. For example, in Node.js or using RequireJS, you would write:\n\n``` ts\nimport moment = require(\"moment\");\nconsole.log(moment.format());\n```\n\nwhereas in a vanilla browser environment you would write:\n\n``` js\nconsole.log(moment.format());\n```\n\n### Identifying a UMD library\n\n[UMD modules](https://github.com/umdjs/umd) check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:\n\n``` js\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"libName\"], factory);\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory(require(\"libName\"));\n    } else {\n        root.returnExports = factory(root.libName);\n    }\n}(this, function (b) {\n```\n\nIf you see tests for `typeof define`, `typeof window`, or `typeof module` in the code of a library, especially at the top of the file, it’s almost always a UMD library.\n\nDocumentation for UMD libraries will also often demonstrate a “Using in Node.js” example showing `require`, and a “Using in the browser” example showing using a `<script>` tag to load the script.\n\n### Examples of UMD libraries\n\nMost popular libraries are now available as UMD packages. Examples include [jQuery](https://jquery.com/), [Moment.js](http://momentjs.com/), [lodash](https://lodash.com/), and many more.\n\n### Template\n\nThere are three templates available for modules, [`module.d.ts`](module-d-ts), [`module-class.d.ts`](module-class-d-ts) and [`module-function.d.ts`](module-function-d-ts).\n\nUse [`module-function.d.ts`](module-function-d-ts) if your module can be *called* like a function:\n\n``` js\nvar x = require(\"foo\");\n// Note: calling 'x' as a function\nvar y = x(42);\n```\n\nBe sure to read the [footnote “The Impact of ES6 on Module Call Signatures”](#the-impact-of-es6-on-module-plugins)\n\nUse [`module-class.d.ts`](module-class-d-ts) if your module can be *constructed* using `new`:\n\n``` js\nvar x = require(\"bar\");\n// Note: using 'new' operator on the imported variable\nvar y = new x(\"hello\");\n```\n\nThe same [footnote](#the-impact-of-es6-on-module-plugins) applies to these modules.\n\nIf your module is not callable or constructable, use the [`module.d.ts`](module-d-ts) file.\n\n## *Module Plugin* or *UMD Plugin*\n\nA *module plugin* changes the shape of another module (either UMD or module). For example, in Moment.js, `moment-range` adds a new `range` method to the `moment` object.\n\nFor the purposes of writing a declaration file, you’ll write the same code whether the module being changed is a plain module or UMD module.\n\n### Template\n\nUse the [`module-plugin.d.ts`](module-plugin-d-ts) template.\n\n## *Global Plugin*\n\nA *global plugin* is global code that changes the shape of some global. As with *global-modifying modules*, these raise the possibility of runtime conflict.\n\nFor example, some libraries add new functions to `Array.prototype` or `String.prototype`.\n\n### Identifying global plugins\n\nGlobal plugins are generally easy to identify from their documentation.\n\nYou’ll see examples that look like this:\n\n``` js\nvar x = \"hello, world\";\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\n\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\n```\n\n### Template\n\nUse the [`global-plugin.d.ts`](global-plugin-d-ts) template.\n\n## *Global-modifying Modules*\n\nA *global-modifying module* alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to `String.prototype` when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.\n\n### Identifying global-modifying modules\n\nGlobal-modifying modules are generally easy to identify from their documentation. In general, they’re similar to global plugins, but need a `require` call to activate their effects.\n\nYou might see documentation like this:\n\n``` js\n// 'require' call that doesn't use its return value\nvar unused = require(\"magic-string-time\");\n/* or */\nrequire(\"magic-string-time\");\n\nvar x = \"hello, world\";\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\n\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\n```\n\n### Template\n\nUse the [`global-modifying-module.d.ts`](global-modifying-module-d-ts) template.\n\n## Consuming Dependencies\n\nThere are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.\n\n### Dependencies on Global Libraries\n\nIf your library depends on a global library, use a `/// <reference types=\"...\" />` directive:\n\n``` ts\n/// <reference types=\"someLib\" />\n\nfunction getThing(): someLib.thing;\n```\n\n### Dependencies on Modules\n\nIf your library depends on a module, use an `import` statement:\n\n``` ts\nimport * as moment from \"moment\";\n\nfunction getThing(): moment;\n```\n\n### Dependencies on UMD libraries\n\n#### From a Global Library\n\nIf your global library depends on a UMD module, use a `/// <reference types` directive:\n\n``` ts\n/// <reference types=\"moment\" />\n\nfunction getThing(): moment;\n```\n\n#### From a Module or UMD Library\n\nIf your module or UMD library depends on a UMD library, use an `import` statement:\n\n``` ts\nimport * as someLib from \"someLib\";\n```\n\nDo *not* use a `/// <reference` directive to declare a dependency to a UMD library!\n\n## Footnotes\n\n### Preventing Name Conflicts\n\nNote that it’s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.\n\nA simple rule to follow is to only declare types *namespaced* by whatever global variable the library defines. For example, if the library defines the global value ‘cats’, you should write\n\n``` ts\ndeclare namespace cats {\n  interface KittySettings {}\n}\n```\n\nBut *not*\n\n``` ts\n// at top-level\ninterface CatsKittySettings {}\n```\n\nThis guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.\n\n### The Impact of ES6 on Module Plugins\n\nSome plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.\n\n### The Impact of ES6 on Module Call Signatures\n\nMany popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:\n\n``` ts\nimport exp = require(\"express\");\nvar app = exp();\n```\n\nIn ES6 module loaders, the top-level object (here imported as `exp`) can only have properties; the top-level module object is *never* callable. The most common solution here is to define a `default` export for a callable/constructable object; some module loader shims will automatically detect this situation and replace the top-level object with the `default` export.\n\n### Library file layout\n\nThe layout of your declaration files should mirror the layout of the library.\n\nA library can consist of multiple modules, such as\n\n``` typescript\nmyLib\n  +---- index.js\n  +---- foo.js\n  +---- bar\n         +---- index.js\n         +---- baz.js\n```\n\nThese could be imported as\n\n``` js\nvar a = require(\"myLib\");\nvar b = require(\"myLib/foo\");\nvar c = require(\"myLib/bar\");\nvar d = require(\"myLib/bar/baz\");\n```\n\nYour declaration files should thus be\n\n``` typescript\n@types/myLib\n  +---- index.d.ts\n  +---- foo.d.ts\n  +---- bar\n         +---- index.d.ts\n         +---- baz.d.ts\n```\n\n``` ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This template shows how to write a global plugin. */\n\n/*~ Write a declaration for the original type and add new members.\n *~ For example, this adds a 'toBinaryString' method with overloads to\n *~ the built-in number type.\n */\ninterface Number {\n  toBinaryString(opts?: MyLibrary.BinaryFormatOptions): string;\n\n  toBinaryString(\n    callback: MyLibrary.BinaryFormatCallback,\n    opts?: MyLibrary.BinaryFormatOptions\n  ): string;\n}\n\n/*~ If you need to declare several types, place them inside a namespace\n *~ to avoid adding too many things to the global namespace.\n */\ndeclare namespace MyLibrary {\n  type BinaryFormatCallback = (n: number) => string;\n  interface BinaryFormatOptions {\n    prefix?: string;\n    padding: number;\n  }\n}\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-plugin-d-ts.html](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-plugin-d-ts.html)"
- name: 'Global: Plugin: Consuming Dependencies'
  id: declaration-files/templates/global-plugin-d-ts#consuming-dependencies
  summary: There are several kinds of dependencies your library might have
  belongs_to: 'Global: Plugin'
  description: |-
    ## Consuming Dependencies

    There are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.

    ### Dependencies on Global Libraries

    If your library depends on a global library, use a `/// <reference types="..." />` directive:

    ``` ts
    /// <reference types="someLib" />

    function getThing(): someLib.thing;
    ```

    ### Dependencies on Modules

    If your library depends on a module, use an `import` statement:

    ``` ts
    import * as moment from "moment";

    function getThing(): moment;
    ```

    ### Dependencies on UMD libraries

    #### From a Global Library

    If your global library depends on a UMD module, use a `/// <reference types` directive:

    ``` ts
    /// <reference types="moment" />

    function getThing(): moment;
    ```

    #### From a Module or UMD Library

    If your module or UMD library depends on a UMD library, use an `import` statement:

    ``` ts
    import * as someLib from "someLib";
    ```

    Do *not* use a `/// <reference` directive to declare a dependency to a UMD library!
- name: 'Global: Plugin: Footnotes'
  id: declaration-files/templates/global-plugin-d-ts#footnotes
  summary: Note that it’s possible to define many types in the global scope when writing a global declaration file
  belongs_to: 'Global: Plugin'
  description: "## Footnotes\n\n### Preventing Name Conflicts\n\nNote that it’s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.\n\nA simple rule to follow is to only declare types *namespaced* by whatever global variable the library defines. For example, if the library defines the global value ‘cats’, you should write\n\n``` ts\ndeclare namespace cats {\n  interface KittySettings {}\n}\n```\n\nBut *not*\n\n``` ts\n// at top-level\ninterface CatsKittySettings {}\n```\n\nThis guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.\n\n### The Impact of ES6 on Module Plugins\n\nSome plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.\n\n### The Impact of ES6 on Module Call Signatures\n\nMany popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:\n\n``` ts\nimport exp = require(\"express\");\nvar app = exp();\n```\n\nIn ES6 module loaders, the top-level object (here imported as `exp`) can only have properties; the top-level module object is *never* callable. The most common solution here is to define a `default` export for a callable/constructable object; some module loader shims will automatically detect this situation and replace the top-level object with the `default` export.\n\n### Library file layout\n\nThe layout of your declaration files should mirror the layout of the library.\n\nA library can consist of multiple modules, such as\n\n``` typescript\nmyLib\n  +---- index.js\n  +---- foo.js\n  +---- bar\n         +---- index.js\n         +---- baz.js\n```\n\nThese could be imported as\n\n``` js\nvar a = require(\"myLib\");\nvar b = require(\"myLib/foo\");\nvar c = require(\"myLib/bar\");\nvar d = require(\"myLib/bar/baz\");\n```\n\nYour declaration files should thus be\n\n``` typescript\n@types/myLib\n  +---- index.d.ts\n  +---- foo.d.ts\n  +---- bar\n         +---- index.d.ts\n         +---- baz.d.ts\n```\n\n``` ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This template shows how to write a global plugin. */\n\n/*~ Write a declaration for the original type and add new members.\n *~ For example, this adds a 'toBinaryString' method with overloads to\n *~ the built-in number type.\n */\ninterface Number {\n  toBinaryString(opts?: MyLibrary.BinaryFormatOptions): string;\n\n  toBinaryString(\n    callback: MyLibrary.BinaryFormatCallback,\n    opts?: MyLibrary.BinaryFormatOptions\n  ): string;\n}\n\n/*~ If you need to declare several types, place them inside a namespace\n *~ to avoid adding too many things to the global namespace.\n */\ndeclare namespace MyLibrary {\n  type BinaryFormatCallback = (n: number) => string;\n  interface BinaryFormatOptions {\n    prefix?: string;\n    padding: number;\n  }\n}\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-plugin-d-ts.html](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-plugin-d-ts.html)"
- name: 'Global: Plugin: Global Plugin'
  id: declaration-files/templates/global-plugin-d-ts#global-plugin
  summary: A global plugin is global code that changes the shape of some global
  belongs_to: 'Global: Plugin'
  description: |-
    ## *Global Plugin*

    A *global plugin* is global code that changes the shape of some global. As with *global-modifying modules*, these raise the possibility of runtime conflict.

    For example, some libraries add new functions to `Array.prototype` or `String.prototype`.

    ### Identifying global plugins

    Global plugins are generally easy to identify from their documentation.

    You’ll see examples that look like this:

    ``` js
    var x = "hello, world";
    // Creates new methods on built-in types
    console.log(x.startsWithHello());

    var y = [1, 2, 3];
    // Creates new methods on built-in types
    console.log(y.reverseAndSort());
    ```

    ### Template

    Use the [`global-plugin.d.ts`](global-plugin-d-ts) template.
- name: 'Global: Plugin: Global-modifying Modules'
  id: declaration-files/templates/global-plugin-d-ts#global-modifying-modules
  summary: A global-modifying module alters existing values in the global scope when they are imported
  belongs_to: 'Global: Plugin'
  description: |-
    ## *Global-modifying Modules*

    A *global-modifying module* alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to `String.prototype` when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.

    ### Identifying global-modifying modules

    Global-modifying modules are generally easy to identify from their documentation. In general, they’re similar to global plugins, but need a `require` call to activate their effects.

    You might see documentation like this:

    ``` js
    // 'require' call that doesn't use its return value
    var unused = require("magic-string-time");
    /* or */
    require("magic-string-time");

    var x = "hello, world";
    // Creates new methods on built-in types
    console.log(x.startsWithHello());

    var y = [1, 2, 3];
    // Creates new methods on built-in types
    console.log(y.reverseAndSort());
    ```

    ### Template

    Use the [`global-modifying-module.d.ts`](global-modifying-module-d-ts) template.
- name: 'Global: Plugin: Module Plugin or UMD Plugin'
  id: declaration-files/templates/global-plugin-d-ts#module-plugin-or-umd-plugin
  summary: A module plugin changes the shape of another module (either UMD or module). For example, in Moment.js, moment-range adds a new range method to the moment object
  belongs_to: 'Global: Plugin'
  description: |-
    ## *Module Plugin* or *UMD Plugin*

    A *module plugin* changes the shape of another module (either UMD or module). For example, in Moment.js, `moment-range` adds a new `range` method to the `moment` object.

    For the purposes of writing a declaration file, you’ll write the same code whether the module being changed is a plain module or UMD module.

    ### Template

    Use the [`module-plugin.d.ts`](module-plugin-d-ts) template.
- name: 'Global: Plugin: UMD'
  id: declaration-files/templates/global-plugin-d-ts#umd
  summary: A UMD module is one that can either be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as Moment.js, are written this way
  belongs_to: 'Global: Plugin'
  description: |-
    ## *UMD*

    A *UMD* module is one that can *either* be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as [Moment.js](http://momentjs.com/), are written this way. For example, in Node.js or using RequireJS, you would write:

    ``` ts
    import moment = require("moment");
    console.log(moment.format());
    ```

    whereas in a vanilla browser environment you would write:

    ``` js
    console.log(moment.format());
    ```

    ### Identifying a UMD library

    [UMD modules](https://github.com/umdjs/umd) check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:

    ``` js
    (function (root, factory) {
        if (typeof define === "function" && define.amd) {
            define(["libName"], factory);
        } else if (typeof module === "object" && module.exports) {
            module.exports = factory(require("libName"));
        } else {
            root.returnExports = factory(root.libName);
        }
    }(this, function (b) {
    ```

    If you see tests for `typeof define`, `typeof window`, or `typeof module` in the code of a library, especially at the top of the file, it’s almost always a UMD library.

    Documentation for UMD libraries will also often demonstrate a “Using in Node.js” example showing `require`, and a “Using in the browser” example showing using a `<script>` tag to load the script.

    ### Examples of UMD libraries

    Most popular libraries are now available as UMD packages. Examples include [jQuery](https://jquery.com/), [Moment.js](http://momentjs.com/), [lodash](https://lodash.com/), and many more.

    ### Template

    There are three templates available for modules, [`module.d.ts`](module-d-ts), [`module-class.d.ts`](module-class-d-ts) and [`module-function.d.ts`](module-function-d-ts).

    Use [`module-function.d.ts`](module-function-d-ts) if your module can be *called* like a function:

    ``` js
    var x = require("foo");
    // Note: calling 'x' as a function
    var y = x(42);
    ```

    Be sure to read the [footnote “The Impact of ES6 on Module Call Signatures”](#the-impact-of-es6-on-module-plugins)

    Use [`module-class.d.ts`](module-class-d-ts) if your module can be *constructed* using `new`:

    ``` js
    var x = require("bar");
    // Note: using 'new' operator on the imported variable
    var y = new x("hello");
    ```

    The same [footnote](#the-impact-of-es6-on-module-plugins) applies to these modules.

    If your module is not callable or constructable, use the [`module.d.ts`](module-d-ts) file.
- name: Gulp
  id: gulp
  summary: This quick start guide will teach you how to build TypeScript with gulp and then add Browserify, terser, or Watchify to the gulp pipeline
  description: "# Gulp\n\nThis quick start guide will teach you how to build TypeScript with [gulp](https://gulpjs.com) and then add [Browserify](https://browserify.org), [terser](https://terser.org), or [Watchify](https://github.com/substack/watchify) to the gulp pipeline. This guide also shows how to add [Babel](https://babeljs.io/) functionality using [Babelify](https://github.com/babel/babelify).\n\nWe assume that you’re already using [Node.js](https://nodejs.org/) with [npm](https://www.npmjs.com/).\n\n## Minimal project\n\nLet’s start out with a new directory. We’ll name it `proj` for now, but you can change it to whatever you want.\n\n``` shell\nmkdir proj\ncd proj\n```\n\nTo start, we’re going to structure our project in the following way:\n\n``` typescript\nproj/\n   ├─ src/\n   └─ dist/\n```\n\nTypeScript files will start out in your `src` folder, run through the TypeScript compiler and end up in `dist`.\n\nLet’s scaffold this out:\n\n``` shell\nmkdir src\nmkdir dist\n```\n\n### Initialize the project\n\nNow we’ll turn this folder into an npm package.\n\n``` shell\nnpm init\n```\n\nYou’ll be given a series of prompts. You can use the defaults except for your entry point. For your entry point, use `./dist/main.js`. You can always go back and change these in the `package.json` file that’s been generated for you.\n\n### Install our dependencies\n\nNow we can use `npm install` to install packages. First install `gulp-cli` globally (if you use a Unix system, you may need to prefix the `npm install` commands in this guide with `sudo`).\n\n``` shell\nnpm install -g gulp-cli\n```\n\nThen install `typescript`, `gulp` and `gulp-typescript` in your project’s dev dependencies. [Gulp-typescript](https://www.npmjs.com/package/gulp-typescript) is a gulp plugin for TypeScript.\n\n``` shell\nnpm install --save-dev typescript gulp@4.0.0 gulp-typescript\n```\n\n### Write a simple example\n\nLet’s write a Hello World program. In `src`, create the file `main.ts`:\n\n``` ts\nfunction hello(compiler: string) {\n  console.log(`Hello from ${compiler}`);\n}\nhello(\"TypeScript\");\n```\n\nIn the project root, `proj`, create the file `tsconfig.json`:\n\n``` typescript\n{\n  \"files\": [\"src/main.ts\"],\n  \"compilerOptions\": {\n    \"noImplicitAny\": true,\n    \"target\": \"es5\"\n  }\n}\n```\n\n### Create a `gulpfile.js`\n\nIn the project root, create the file `gulpfile.js`:\n\n``` js\nvar gulp = require(\"gulp\");\nvar ts = require(\"gulp-typescript\");\nvar tsProject = ts.createProject(\"tsconfig.json\");\n\ngulp.task(\"default\", function () {\n  return tsProject.src().pipe(tsProject()).js.pipe(gulp.dest(\"dist\"));\n});\n```\n\n### Test the resulting app\n\n``` shell\ngulp\nnode dist/main.js\n```\n\nThe program should print “Hello from TypeScript!“.\n\n## Add modules to the code\n\nBefore we get to Browserify, let’s build our code out and add modules to the mix. This is the structure you’re more likely to use for a real app.\n\nCreate a file called `src/greet.ts`:\n\n``` ts\nexport function sayHello(name: string) {\n  return `Hello from ${name}`;\n}\n```\n\nNow change the code in `src/main.ts` to import `sayHello` from `greet.ts`:\n\n``` ts\nimport { sayHello } from \"./greet\";\n\nconsole.log(sayHello(\"TypeScript\"));\n```\n\nFinally, add `src/greet.ts` to `tsconfig.json`:\n\n``` typescript\n{\n  \"files\": [\"src/main.ts\", \"src/greet.ts\"],\n  \"compilerOptions\": {\n    \"noImplicitAny\": true,\n    \"target\": \"es5\"\n  }\n}\n```\n\nMake sure that the modules work by running `gulp` and then testing in Node:\n\n``` shell\ngulp\nnode dist/main.js\n```\n\nNotice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses. We’ll stick with CommonJS for this tutorial, but you could set `module` in the options object to change this.\n\n## Browserify\n\nNow let’s move this project from Node to the browser. To do this, we’d like to bundle all our modules into one JavaScript file. Fortunately, that’s exactly what Browserify does. Even better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit. That means our TypeScript and Node setup will transfer to the browser basically unchanged.\n\nFirst, install browserify, [tsify](https://www.npmjs.com/package/tsify), and vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands called [vinyl](https://github.com/gulpjs/vinyl).\n\n``` shell\nnpm install --save-dev browserify tsify vinyl-source-stream\n```\n\n### Create a page\n\nCreate a file in `src` named `index.html`:\n\n``` html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Hello World!</title>\n  </head>\n  <body>\n    <p id=\"greeting\">Loading ...</p>\n    <script src=\"bundle.js\"></script>\n  </body>\n</html>\n```\n\nNow change `main.ts` to update the page:\n\n``` ts\nimport { sayHello } from \"./greet\";\n\nfunction showHello(divName: string, name: string) {\n  const elt = document.getElementById(divName);\n  elt.innerText = sayHello(name);\n}\n\nshowHello(\"greeting\", \"TypeScript\");\n```\n\nCalling `showHello` calls `sayHello` to change the paragraph’s text. Now change your gulpfile to the following:\n\n``` js\nvar gulp = require(\"gulp\");\nvar browserify = require(\"browserify\");\nvar source = require(\"vinyl-source-stream\");\nvar tsify = require(\"tsify\");\nvar paths = {\n  pages: [\"src/*.html\"],\n};\n\ngulp.task(\"copy-html\", function () {\n  return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));\n});\n\ngulp.task(\n  \"default\",\n  gulp.series(gulp.parallel(\"copy-html\"), function () {\n    return browserify({\n      basedir: \".\",\n      debug: true,\n      entries: [\"src/main.ts\"],\n      cache: {},\n      packageCache: {},\n    })\n      .plugin(tsify)\n      .bundle()\n      .pipe(source(\"bundle.js\"))\n      .pipe(gulp.dest(\"dist\"));\n  })\n);\n```\n\nThis adds the `copy-html` task and adds it as a dependency of `default`. That means any time `default` is run, `copy-html` has to run first. We’ve also changed `default` to call Browserify with the tsify plugin instead of gulp-typescript. Conveniently, they both allow us to pass the same options object to the TypeScript compiler.\n\nAfter calling `bundle` we use `source` (our alias for vinyl-source-stream) to name our output bundle `bundle.js`.\n\nTest the page by running gulp and then opening `dist/index.html` in a browser. You should see “Hello from TypeScript” on the page.\n\nNotice that we specified `debug: true` to Browserify. This causes tsify to emit source maps inside the bundled JavaScript file. Source maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript. You can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside `main.ts`. When you refresh the page the breakpoint should pause the page and let you debug `greet.ts`.\n\n## Watchify, Babel, and Terser\n\nNow that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins.\n\n- Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file. This lets you keep an edit-save-refresh cycle going in the browser.\n\n- Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3. This lets you add extensive and customized transformations that TypeScript doesn’t support.\n\n- Terser compacts your code so that it takes less time to download.\n\n### Watchify\n\nWe’ll start with Watchify to provide background compilation:\n\n``` shell\nnpm install --save-dev watchify fancy-log\n```\n\nNow change your gulpfile to the following:\n\n``` js\nvar gulp = require(\"gulp\");\nvar browserify = require(\"browserify\");\nvar source = require(\"vinyl-source-stream\");\nvar watchify = require(\"watchify\");\nvar tsify = require(\"tsify\");\nvar fancy_log = require(\"fancy-log\");\nvar paths = {\n  pages: [\"src/*.html\"],\n};\n\nvar watchedBrowserify = watchify(\n  browserify({\n    basedir: \".\",\n    debug: true,\n    entries: [\"src/main.ts\"],\n    cache: {},\n    packageCache: {},\n  }).plugin(tsify)\n);\n\ngulp.task(\"copy-html\", function () {\n  return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));\n});\n\nfunction bundle() {\n  return watchedBrowserify\n    .bundle()\n    .on(\"error\", fancy_log)\n    .pipe(source(\"bundle.js\"))\n    .pipe(gulp.dest(\"dist\"));\n}\n\ngulp.task(\"default\", gulp.series(gulp.parallel(\"copy-html\"), bundle));\nwatchedBrowserify.on(\"update\", bundle);\nwatchedBrowserify.on(\"log\", fancy_log);\n```\n\nThere are basically three changes here, but they require you to refactor your code a bit.\n\n1.  We wrapped our `browserify` instance in a call to `watchify`, and then held on to the result.\n2.  We called `watchedBrowserify.on('update', bundle);` so that Browserify will run the `bundle` function every time one of your TypeScript files changes.\n3.  We called `watchedBrowserify.on('log', fancy_log);` to log to the console.\n\nTogether (1) and (2) mean that we have to move our call to `browserify` out of the `default` task. And we have to give the function for `default` a name since both Watchify and Gulp need to call it. Adding logging with (3) is optional but very useful for debugging your setup.\n\nNow when you run Gulp, it should start and stay running. Try changing the code for `showHello` in `main.ts` and saving it. You should see output that looks like this:\n\n``` shell\nproj$ gulp\n[10:34:20] Using gulpfile ~/src/proj/gulpfile.js\n[10:34:20] Starting 'copy-html'...\n[10:34:20] Finished 'copy-html' after 26 ms\n[10:34:20] Starting 'default'...\n[10:34:21] 2824 bytes written (0.13 seconds)\n[10:34:21] Finished 'default' after 1.36 s\n[10:35:22] 2261 bytes written (0.02 seconds)\n[10:35:24] 2808 bytes written (0.05 seconds)\n```\n\n### Terser\n\nFirst install Terser. Since the point of Terser is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working.\n\n``` shell\nnpm install --save-dev gulp-terser vinyl-buffer gulp-sourcemaps\n```\n\nNow change your gulpfile to the following:\n\n``` js\nvar gulp = require(\"gulp\");\nvar browserify = require(\"browserify\");\nvar source = require(\"vinyl-source-stream\");\nvar terser = require(\"gulp-terser\");\nvar tsify = require(\"tsify\");\nvar sourcemaps = require(\"gulp-sourcemaps\");\nvar buffer = require(\"vinyl-buffer\");\nvar paths = {\n  pages: [\"src/*.html\"],\n};\n\ngulp.task(\"copy-html\", function () {\n  return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));\n});\n\ngulp.task(\n  \"default\",\n  gulp.series(gulp.parallel(\"copy-html\"), function () {\n    return browserify({\n      basedir: \".\",\n      debug: true,\n      entries: [\"src/main.ts\"],\n      cache: {},\n      packageCache: {},\n    })\n      .plugin(tsify)\n      .bundle()\n      .pipe(source(\"bundle.js\"))\n      .pipe(buffer())\n      .pipe(sourcemaps.init({ loadMaps: true }))\n      .pipe(terser())\n      .pipe(sourcemaps.write(\"./\"))\n      .pipe(gulp.dest(\"dist\"));\n  })\n);\n```\n\nNotice that `terser` itself has just one call — the calls to `buffer` and `sourcemaps` exist to make sure sourcemaps keep working. These calls give us a separate sourcemap file instead of using inline sourcemaps like before. Now you can run Gulp and check that `bundle.js` does get minified into an unreadable mess:\n\n``` shell\ngulp\ncat dist/bundle.js\n```\n\n### Babel\n\nFirst install Babelify and the Babel preset for ES2015. Like Terser, Babelify mangles code, so we’ll need vinyl-buffer and gulp-sourcemaps. By default Babelify will only process files with extensions of `.js`, `.es`, `.es6` and `.jsx` so we need to add the `.ts` extension as an option to Babelify.\n\n``` shell\nnpm install --save-dev babelify@8 babel-core babel-preset-es2015 vinyl-buffer gulp-sourcemaps\n```\n\nNow change your gulpfile to the following:\n\n``` js\nvar gulp = require(\"gulp\");\nvar browserify = require(\"browserify\");\nvar source = require(\"vinyl-source-stream\");\nvar tsify = require(\"tsify\");\nvar sourcemaps = require(\"gulp-sourcemaps\");\nvar buffer = require(\"vinyl-buffer\");\nvar paths = {\n  pages: [\"src/*.html\"],\n};\n\ngulp.task(\"copy-html\", function () {\n  return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));\n});\n\ngulp.task(\n  \"default\",\n  gulp.series(gulp.parallel(\"copy-html\"), function () {\n    return browserify({\n      basedir: \".\",\n      debug: true,\n      entries: [\"src/main.ts\"],\n      cache: {},\n      packageCache: {},\n    })\n      .plugin(tsify)\n      .transform(\"babelify\", {\n        presets: [\"es2015\"],\n        extensions: [\".ts\"],\n      })\n      .bundle()\n      .pipe(source(\"bundle.js\"))\n      .pipe(buffer())\n      .pipe(sourcemaps.init({ loadMaps: true }))\n      .pipe(sourcemaps.write(\"./\"))\n      .pipe(gulp.dest(\"dist\"));\n  })\n);\n```\n\nWe also need to have TypeScript target ES2015. Babel will then produce ES5 from the ES2015 code that TypeScript emits. Let’s modify `tsconfig.json`:\n\n``` typescript\n{\n  \"files\": [\"src/main.ts\"],\n  \"compilerOptions\": {\n    \"noImplicitAny\": true,\n    \"target\": \"es2015\"\n  }\n}\n```\n\nBabel’s ES5 output should be very similar to TypeScript’s output for such a simple script.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/gulp.html](https://www.typescriptlang.org/docs/handbook/gulp.html)"
- name: 'Gulp: Add modules to the code'
  id: gulp#add-modules-to-the-code
  summary: Before we get to Browserify, let’s build our code out and add modules to the mix
  belongs_to: Gulp
  description: |-
    ## Add modules to the code

    Before we get to Browserify, let’s build our code out and add modules to the mix. This is the structure you’re more likely to use for a real app.

    Create a file called `src/greet.ts`:

    ``` ts
    export function sayHello(name: string) {
      return `Hello from ${name}`;
    }
    ```

    Now change the code in `src/main.ts` to import `sayHello` from `greet.ts`:

    ``` ts
    import { sayHello } from "./greet";

    console.log(sayHello("TypeScript"));
    ```

    Finally, add `src/greet.ts` to `tsconfig.json`:

    ``` typescript
    {
      "files": ["src/main.ts", "src/greet.ts"],
      "compilerOptions": {
        "noImplicitAny": true,
        "target": "es5"
      }
    }
    ```

    Make sure that the modules work by running `gulp` and then testing in Node:

    ``` shell
    gulp
    node dist/main.js
    ```

    Notice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses. We’ll stick with CommonJS for this tutorial, but you could set `module` in the options object to change this.
- name: 'Gulp: Browserify'
  id: gulp#browserify
  summary: Now let’s move this project from Node to the browser
  belongs_to: Gulp
  description: |-
    ## Browserify

    Now let’s move this project from Node to the browser. To do this, we’d like to bundle all our modules into one JavaScript file. Fortunately, that’s exactly what Browserify does. Even better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit. That means our TypeScript and Node setup will transfer to the browser basically unchanged.

    First, install browserify, [tsify](https://www.npmjs.com/package/tsify), and vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands called [vinyl](https://github.com/gulpjs/vinyl).

    ``` shell
    npm install --save-dev browserify tsify vinyl-source-stream
    ```

    ### Create a page

    Create a file in `src` named `index.html`:

    ``` html
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8" />
        <title>Hello World!</title>
      </head>
      <body>
        <p id="greeting">Loading ...</p>
        <script src="bundle.js"></script>
      </body>
    </html>
    ```

    Now change `main.ts` to update the page:

    ``` ts
    import { sayHello } from "./greet";

    function showHello(divName: string, name: string) {
      const elt = document.getElementById(divName);
      elt.innerText = sayHello(name);
    }

    showHello("greeting", "TypeScript");
    ```

    Calling `showHello` calls `sayHello` to change the paragraph’s text. Now change your gulpfile to the following:

    ``` js
    var gulp = require("gulp");
    var browserify = require("browserify");
    var source = require("vinyl-source-stream");
    var tsify = require("tsify");
    var paths = {
      pages: ["src/*.html"],
    };

    gulp.task("copy-html", function () {
      return gulp.src(paths.pages).pipe(gulp.dest("dist"));
    });

    gulp.task(
      "default",
      gulp.series(gulp.parallel("copy-html"), function () {
        return browserify({
          basedir: ".",
          debug: true,
          entries: ["src/main.ts"],
          cache: {},
          packageCache: {},
        })
          .plugin(tsify)
          .bundle()
          .pipe(source("bundle.js"))
          .pipe(gulp.dest("dist"));
      })
    );
    ```

    This adds the `copy-html` task and adds it as a dependency of `default`. That means any time `default` is run, `copy-html` has to run first. We’ve also changed `default` to call Browserify with the tsify plugin instead of gulp-typescript. Conveniently, they both allow us to pass the same options object to the TypeScript compiler.

    After calling `bundle` we use `source` (our alias for vinyl-source-stream) to name our output bundle `bundle.js`.

    Test the page by running gulp and then opening `dist/index.html` in a browser. You should see “Hello from TypeScript” on the page.

    Notice that we specified `debug: true` to Browserify. This causes tsify to emit source maps inside the bundled JavaScript file. Source maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript. You can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside `main.ts`. When you refresh the page the breakpoint should pause the page and let you debug `greet.ts`.
- name: 'Gulp: Create a gulpfile.js'
  id: gulp#create-a-gulpfilejs
  summary: null
  belongs_to: Gulp
  description: |-
    ### Create a `gulpfile.js`

    In the project root, create the file `gulpfile.js`:

    ``` js
    var gulp = require("gulp");
    var ts = require("gulp-typescript");
    var tsProject = ts.createProject("tsconfig.json");

    gulp.task("default", function () {
      return tsProject.src().pipe(tsProject()).js.pipe(gulp.dest("dist"));
    });
    ```

    ### Test the resulting app

    ``` shell
    gulp
    node dist/main.js
    ```

    The program should print “Hello from TypeScript!“.
- name: 'Gulp: Minimal project'
  id: gulp#minimal-project
  summary: Let’s start out with a new directory
  belongs_to: Gulp
  description: |-
    ## Minimal project

    Let’s start out with a new directory. We’ll name it `proj` for now, but you can change it to whatever you want.

    ``` shell
    mkdir proj
    cd proj
    ```

    To start, we’re going to structure our project in the following way:

    ``` typescript
    proj/
       ├─ src/
       └─ dist/
    ```

    TypeScript files will start out in your `src` folder, run through the TypeScript compiler and end up in `dist`.

    Let’s scaffold this out:

    ``` shell
    mkdir src
    mkdir dist
    ```

    ### Initialize the project

    Now we’ll turn this folder into an npm package.

    ``` shell
    npm init
    ```

    You’ll be given a series of prompts. You can use the defaults except for your entry point. For your entry point, use `./dist/main.js`. You can always go back and change these in the `package.json` file that’s been generated for you.

    ### Install our dependencies

    Now we can use `npm install` to install packages. First install `gulp-cli` globally (if you use a Unix system, you may need to prefix the `npm install` commands in this guide with `sudo`).

    ``` shell
    npm install -g gulp-cli
    ```

    Then install `typescript`, `gulp` and `gulp-typescript` in your project’s dev dependencies. [Gulp-typescript](https://www.npmjs.com/package/gulp-typescript) is a gulp plugin for TypeScript.

    ``` shell
    npm install --save-dev typescript gulp@4.0.0 gulp-typescript
    ```

    ### Write a simple example

    Let’s write a Hello World program. In `src`, create the file `main.ts`:

    ``` ts
    function hello(compiler: string) {
      console.log(`Hello from ${compiler}`);
    }
    hello("TypeScript");
    ```

    In the project root, `proj`, create the file `tsconfig.json`:

    ``` typescript
    {
      "files": ["src/main.ts"],
      "compilerOptions": {
        "noImplicitAny": true,
        "target": "es5"
      }
    }
    ```
- name: 'Gulp: Watchify, Babel, and Terser'
  id: gulp#watchify-babel-and-terser
  summary: Now that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins
  belongs_to: Gulp
  description: "## Watchify, Babel, and Terser\n\nNow that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins.\n\n- Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file. This lets you keep an edit-save-refresh cycle going in the browser.\n\n- Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3. This lets you add extensive and customized transformations that TypeScript doesn’t support.\n\n- Terser compacts your code so that it takes less time to download.\n\n### Watchify\n\nWe’ll start with Watchify to provide background compilation:\n\n``` shell\nnpm install --save-dev watchify fancy-log\n```\n\nNow change your gulpfile to the following:\n\n``` js\nvar gulp = require(\"gulp\");\nvar browserify = require(\"browserify\");\nvar source = require(\"vinyl-source-stream\");\nvar watchify = require(\"watchify\");\nvar tsify = require(\"tsify\");\nvar fancy_log = require(\"fancy-log\");\nvar paths = {\n  pages: [\"src/*.html\"],\n};\n\nvar watchedBrowserify = watchify(\n  browserify({\n    basedir: \".\",\n    debug: true,\n    entries: [\"src/main.ts\"],\n    cache: {},\n    packageCache: {},\n  }).plugin(tsify)\n);\n\ngulp.task(\"copy-html\", function () {\n  return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));\n});\n\nfunction bundle() {\n  return watchedBrowserify\n    .bundle()\n    .on(\"error\", fancy_log)\n    .pipe(source(\"bundle.js\"))\n    .pipe(gulp.dest(\"dist\"));\n}\n\ngulp.task(\"default\", gulp.series(gulp.parallel(\"copy-html\"), bundle));\nwatchedBrowserify.on(\"update\", bundle);\nwatchedBrowserify.on(\"log\", fancy_log);\n```\n\nThere are basically three changes here, but they require you to refactor your code a bit.\n\n1.  We wrapped our `browserify` instance in a call to `watchify`, and then held on to the result.\n2.  We called `watchedBrowserify.on('update', bundle);` so that Browserify will run the `bundle` function every time one of your TypeScript files changes.\n3.  We called `watchedBrowserify.on('log', fancy_log);` to log to the console.\n\nTogether (1) and (2) mean that we have to move our call to `browserify` out of the `default` task. And we have to give the function for `default` a name since both Watchify and Gulp need to call it. Adding logging with (3) is optional but very useful for debugging your setup.\n\nNow when you run Gulp, it should start and stay running. Try changing the code for `showHello` in `main.ts` and saving it. You should see output that looks like this:\n\n``` shell\nproj$ gulp\n[10:34:20] Using gulpfile ~/src/proj/gulpfile.js\n[10:34:20] Starting 'copy-html'...\n[10:34:20] Finished 'copy-html' after 26 ms\n[10:34:20] Starting 'default'...\n[10:34:21] 2824 bytes written (0.13 seconds)\n[10:34:21] Finished 'default' after 1.36 s\n[10:35:22] 2261 bytes written (0.02 seconds)\n[10:35:24] 2808 bytes written (0.05 seconds)\n```\n\n### Terser\n\nFirst install Terser. Since the point of Terser is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working.\n\n``` shell\nnpm install --save-dev gulp-terser vinyl-buffer gulp-sourcemaps\n```\n\nNow change your gulpfile to the following:\n\n``` js\nvar gulp = require(\"gulp\");\nvar browserify = require(\"browserify\");\nvar source = require(\"vinyl-source-stream\");\nvar terser = require(\"gulp-terser\");\nvar tsify = require(\"tsify\");\nvar sourcemaps = require(\"gulp-sourcemaps\");\nvar buffer = require(\"vinyl-buffer\");\nvar paths = {\n  pages: [\"src/*.html\"],\n};\n\ngulp.task(\"copy-html\", function () {\n  return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));\n});\n\ngulp.task(\n  \"default\",\n  gulp.series(gulp.parallel(\"copy-html\"), function () {\n    return browserify({\n      basedir: \".\",\n      debug: true,\n      entries: [\"src/main.ts\"],\n      cache: {},\n      packageCache: {},\n    })\n      .plugin(tsify)\n      .bundle()\n      .pipe(source(\"bundle.js\"))\n      .pipe(buffer())\n      .pipe(sourcemaps.init({ loadMaps: true }))\n      .pipe(terser())\n      .pipe(sourcemaps.write(\"./\"))\n      .pipe(gulp.dest(\"dist\"));\n  })\n);\n```\n\nNotice that `terser` itself has just one call — the calls to `buffer` and `sourcemaps` exist to make sure sourcemaps keep working. These calls give us a separate sourcemap file instead of using inline sourcemaps like before. Now you can run Gulp and check that `bundle.js` does get minified into an unreadable mess:\n\n``` shell\ngulp\ncat dist/bundle.js\n```\n\n### Babel\n\nFirst install Babelify and the Babel preset for ES2015. Like Terser, Babelify mangles code, so we’ll need vinyl-buffer and gulp-sourcemaps. By default Babelify will only process files with extensions of `.js`, `.es`, `.es6` and `.jsx` so we need to add the `.ts` extension as an option to Babelify.\n\n``` shell\nnpm install --save-dev babelify@8 babel-core babel-preset-es2015 vinyl-buffer gulp-sourcemaps\n```\n\nNow change your gulpfile to the following:\n\n``` js\nvar gulp = require(\"gulp\");\nvar browserify = require(\"browserify\");\nvar source = require(\"vinyl-source-stream\");\nvar tsify = require(\"tsify\");\nvar sourcemaps = require(\"gulp-sourcemaps\");\nvar buffer = require(\"vinyl-buffer\");\nvar paths = {\n  pages: [\"src/*.html\"],\n};\n\ngulp.task(\"copy-html\", function () {\n  return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));\n});\n\ngulp.task(\n  \"default\",\n  gulp.series(gulp.parallel(\"copy-html\"), function () {\n    return browserify({\n      basedir: \".\",\n      debug: true,\n      entries: [\"src/main.ts\"],\n      cache: {},\n      packageCache: {},\n    })\n      .plugin(tsify)\n      .transform(\"babelify\", {\n        presets: [\"es2015\"],\n        extensions: [\".ts\"],\n      })\n      .bundle()\n      .pipe(source(\"bundle.js\"))\n      .pipe(buffer())\n      .pipe(sourcemaps.init({ loadMaps: true }))\n      .pipe(sourcemaps.write(\"./\"))\n      .pipe(gulp.dest(\"dist\"));\n  })\n);\n```\n\nWe also need to have TypeScript target ES2015. Babel will then produce ES5 from the ES2015 code that TypeScript emits. Let’s modify `tsconfig.json`:\n\n``` typescript\n{\n  \"files\": [\"src/main.ts\"],\n  \"compilerOptions\": {\n    \"noImplicitAny\": true,\n    \"target\": \"es2015\"\n  }\n}\n```\n\nBabel’s ES5 output should be very similar to TypeScript’s output for such a simple script.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/gulp.html](https://www.typescriptlang.org/docs/handbook/gulp.html)"
- name: importHelpers
  id: tsconfig#importHelpers-config
  summary: For certain downleveling operations, TypeScript uses some helper code for operations like extending class, spreading arrays or objects, and async operations
  belongs_to: TSConfig Reference
  description: |-
    ### Import Helpers - `importHelpers`

    For certain downleveling operations, TypeScript uses some helper code for operations like extending class, spreading arrays or objects, and async operations. By default, these helpers are inserted into files which use them. This can result in code duplication if the same helper is used in many different modules.

    If the `importHelpers` flag is on, these helper functions are instead imported from the [tslib](https://www.npmjs.com/package/tslib) module. You will need to ensure that the `tslib` module is able to be imported at runtime. This only affects modules; global script files will not attempt to import modules.

    For example, with this TypeScript:

    ``` ts
    export function fn(arr: number[]) {
      const arr2 = [1, ...arr];
    }
    ```

    Turning on [`downlevelIteration`](#downlevelIteration) and `importHelpers` is still false:

    ``` ts
    var __read = (this && this.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    export function fn(arr) {
        var arr2 = __spreadArray([1], __read(arr), false);
    }
     
    ```

    Then turning on both [`downlevelIteration`](#downlevelIteration) and `importHelpers`:

    ``` ts
    import { __read, __spreadArray } from "tslib";
    export function fn(arr) {
        var arr2 = __spreadArray([1], __read(arr), false);
    }
     
    ```

    You can use [`noEmitHelpers`](#noEmitHelpers) when you provide your own implementations of these functions.

    - Related:
      - [`noEmitHelpers`](#noEmitHelpers)

      - [`downlevelIteration`](#downlevelIteration)
- name: importHelpers
  id: tsconfig/index#importHelpers-config
  summary: For certain downleveling operations, TypeScript uses some helper code for operations like extending class, spreading arrays or objects, and async operations
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Import Helpers - `importHelpers`

    For certain downleveling operations, TypeScript uses some helper code for operations like extending class, spreading arrays or objects, and async operations. By default, these helpers are inserted into files which use them. This can result in code duplication if the same helper is used in many different modules.

    If the `importHelpers` flag is on, these helper functions are instead imported from the [tslib](https://www.npmjs.com/package/tslib) module. You will need to ensure that the `tslib` module is able to be imported at runtime. This only affects modules; global script files will not attempt to import modules.

    For example, with this TypeScript:

    ``` ts
    export function fn(arr: number[]) {
      const arr2 = [1, ...arr];
    }
    ```

    Turning on [`downlevelIteration`](#downlevelIteration) and `importHelpers` is still false:

    ``` ts
    var __read = (this && this.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    export function fn(arr) {
        var arr2 = __spreadArray([1], __read(arr), false);
    }
     
    ```

    Then turning on both [`downlevelIteration`](#downlevelIteration) and `importHelpers`:

    ``` ts
    import { __read, __spreadArray } from "tslib";
    export function fn(arr) {
        var arr2 = __spreadArray([1], __read(arr), false);
    }
     
    ```

    You can use [`noEmitHelpers`](#noEmitHelpers) when you provide your own implementations of these functions.

    - Related:
      - [`noEmitHelpers`](#noEmitHelpers)

      - [`downlevelIteration`](#downlevelIteration)
- name: importsNotUsedAsValues
  id: tsconfig#importsNotUsedAsValues-config
  summary: Deprecated in favor of verbatimModuleSyntax
  belongs_to: TSConfig Reference
  description: |-
    ### Imports Not Used As Values - `importsNotUsedAsValues`

    Deprecated in favor of [`verbatimModuleSyntax`](#verbatimModuleSyntax).

    This flag controls how `import` works, there are 3 different options:

    - `remove`: The default behavior of dropping `import` statements which only reference types.

    - `preserve`: Preserves all `import` statements whose values or types are never used. This can cause imports/side-effects to be preserved.

    - `error`: This preserves all imports (the same as the preserve option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.

    This flag works because you can use `import type` to explicitly create an `import` statement which should never be emitted into JavaScript.

    - Default:

      `remove`

    - Allowed:
      - `remove`

      - `preserve`

      - `error`

    - Related:
      - [`preserveValueImports`](#preserveValueImports)

      - [`verbatimModuleSyntax`](#verbatimModuleSyntax)

    - Released:

      [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)
- name: importsNotUsedAsValues
  id: tsconfig/index#importsNotUsedAsValues-config
  summary: Deprecated in favor of verbatimModuleSyntax
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Imports Not Used As Values - `importsNotUsedAsValues`

    Deprecated in favor of [`verbatimModuleSyntax`](#verbatimModuleSyntax).

    This flag controls how `import` works, there are 3 different options:

    - `remove`: The default behavior of dropping `import` statements which only reference types.

    - `preserve`: Preserves all `import` statements whose values or types are never used. This can cause imports/side-effects to be preserved.

    - `error`: This preserves all imports (the same as the preserve option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.

    This flag works because you can use `import type` to explicitly create an `import` statement which should never be emitted into JavaScript.

    - Default:

      `remove`

    - Allowed:
      - `remove`

      - `preserve`

      - `error`

    - Related:
      - [`preserveValueImports`](#preserveValueImports)

      - [`verbatimModuleSyntax`](#verbatimModuleSyntax)

    - Released:

      [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)
- name: include
  id: tsconfig/index#include-config
  summary: Specifies an array of filenames or patterns to include in the program
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Include - `include`

    Specifies an array of filenames or patterns to include in the program. These filenames are resolved relative to the directory containing the `tsconfig.json` file.

    ``` json
    {
      "include": ["src/**/*", "tests/**/*"]
    }
    ```

    Which would include:

    ``` typescript
    .
    ├── scripts                ⨯
    │   ├── lint.ts            ⨯
    │   ├── update_deps.ts     ⨯
    │   └── utils.ts           ⨯
    ├── src                    ✓
    │   ├── client             ✓
    │   │    ├── index.ts      ✓
    │   │    └── utils.ts      ✓
    │   ├── server             ✓
    │   │    └── index.ts      ✓
    ├── tests                  ✓
    │   ├── app.test.ts        ✓
    │   ├── utils.ts           ✓
    │   └── tests.d.ts         ✓
    ├── package.json
    ├── tsconfig.json
    └── yarn.lock
    ```

    `include` and `exclude` support wildcard characters to make glob patterns:

    - `*` matches zero or more characters (excluding directory separators)
    - `?` matches any one character (excluding directory separators)
    - `**/` matches any directory nested to any level

    If the last path segment in a pattern does not contain a file extension or wildcard character, then it is treated as a directory, and files with supported extensions inside that directory are included (e.g. `.ts`, `.tsx`, and `.d.ts` by default, with `.js` and `.jsx` if [`allowJs`](#allowJs) is set to true).

    - Default:

      `[]` if [`files`](#files) is specified; `**/*` otherwise.

    - Related:
      - [`files`](#files)

      - [`exclude`](#exclude)

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: include
  id: tsconfig/index#type-include-config
  summary: If you have a JavaScript project where TypeScript needs additional guidance to understand global dependencies, or have disabled the built-in inference via disableFilenameBasedTypeAcquisition
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Include - `include`

    If you have a JavaScript project where TypeScript needs additional guidance to understand global dependencies, or have disabled the built-in inference via [`disableFilenameBasedTypeAcquisition`](#disableFilenameBasedTypeAcquisition).

    You can use `include` to specify which types should be used from DefinitelyTyped:

    ``` json
    {
      "typeAcquisition": {
        "include": ["jquery"]
      }
    }
    ```
- name: include
  id: tsconfig#include-config
  summary: Specifies an array of filenames or patterns to include in the program
  belongs_to: TSConfig Reference
  description: |-
    ### Include - `include`

    Specifies an array of filenames or patterns to include in the program. These filenames are resolved relative to the directory containing the `tsconfig.json` file.

    ``` json
    {
      "include": ["src/**/*", "tests/**/*"]
    }
    ```

    Which would include:

    ``` typescript
    .
    ├── scripts                ⨯
    │   ├── lint.ts            ⨯
    │   ├── update_deps.ts     ⨯
    │   └── utils.ts           ⨯
    ├── src                    ✓
    │   ├── client             ✓
    │   │    ├── index.ts      ✓
    │   │    └── utils.ts      ✓
    │   ├── server             ✓
    │   │    └── index.ts      ✓
    ├── tests                  ✓
    │   ├── app.test.ts        ✓
    │   ├── utils.ts           ✓
    │   └── tests.d.ts         ✓
    ├── package.json
    ├── tsconfig.json
    └── yarn.lock
    ```

    `include` and `exclude` support wildcard characters to make glob patterns:

    - `*` matches zero or more characters (excluding directory separators)
    - `?` matches any one character (excluding directory separators)
    - `**/` matches any directory nested to any level

    If the last path segment in a pattern does not contain a file extension or wildcard character, then it is treated as a directory, and files with supported extensions inside that directory are included (e.g. `.ts`, `.tsx`, and `.d.ts` by default, with `.js` and `.jsx` if [`allowJs`](#allowJs) is set to true).

    - Default:

      `[]` if [`files`](#files) is specified; `**/*` otherwise.

    - Related:
      - [`files`](#files)

      - [`exclude`](#exclude)

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: include
  id: tsconfig#type-include-config
  summary: If you have a JavaScript project where TypeScript needs additional guidance to understand global dependencies, or have disabled the built-in inference via disableFilenameBasedTypeAcquisition
  belongs_to: TSConfig Reference
  description: |-
    ### Include - `include`

    If you have a JavaScript project where TypeScript needs additional guidance to understand global dependencies, or have disabled the built-in inference via [`disableFilenameBasedTypeAcquisition`](#disableFilenameBasedTypeAcquisition).

    You can use `include` to specify which types should be used from DefinitelyTyped:

    ``` json
    {
      "typeAcquisition": {
        "include": ["jquery"]
      }
    }
    ```
- name: incremental
  id: tsconfig/index#incremental-config
  summary: Tells TypeScript to save information about the project graph from the last compilation to files stored on disk
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Incremental - `incremental`

    Tells TypeScript to save information about the project graph from the last compilation to files stored on disk. This creates a series of `.tsbuildinfo` files in the same folder as your compilation output. They are not used by your JavaScript at runtime and can be safely deleted. You can read more about the flag in the [3.4 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#faster-subsequent-builds-with-the---incremental-flag).

    To control which folders you want to the files to be built to, use the config option [`tsBuildInfoFile`](#tsBuildInfoFile).

    - Default:

      `true` if [`composite`](#composite); `false` otherwise.

    - Related:
      - [`composite`](#composite)

      - [`tsBuildInfoFile`](#tsBuildInfoFile)

    - Released:

      [3.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html)
- name: incremental
  id: tsconfig#incremental-config
  summary: Tells TypeScript to save information about the project graph from the last compilation to files stored on disk
  belongs_to: TSConfig Reference
  description: |-
    ### Incremental - `incremental`

    Tells TypeScript to save information about the project graph from the last compilation to files stored on disk. This creates a series of `.tsbuildinfo` files in the same folder as your compilation output. They are not used by your JavaScript at runtime and can be safely deleted. You can read more about the flag in the [3.4 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#faster-subsequent-builds-with-the---incremental-flag).

    To control which folders you want to the files to be built to, use the config option [`tsBuildInfoFile`](#tsBuildInfoFile).

    - Default:

      `true` if [`composite`](#composite); `false` otherwise.

    - Related:
      - [`composite`](#composite)

      - [`tsBuildInfoFile`](#tsBuildInfoFile)

    - Released:

      [3.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html)
- name: Indexed Access Types
  id: 2/indexed-access-types
  summary: Another example of indexing with an arbitrary type is using number to get the type of an array’s elements
  description: "# Indexed Access Types\n\nWe can use an *indexed access type* to look up a specific property on another type:\n\n``` ts\ntype Person = { age: number; name: string; alive: boolean };\ntype Age = Person[\"age\"];\n```\n\nThe indexing type is itself a type, so we can use unions, `keyof`, or other types entirely:\n\n``` ts\ntype I1 = Person[\"age\" | \"name\"];\n \ntype I2 = Person[keyof Person];\n \ntype AliveOrName = \"alive\" | \"name\";\ntype I3 = Person[AliveOrName];\n```\n\nYou’ll even see an error if you try to index a property that doesn’t exist:\n\n``` ts\ntype I1 = Person[\"alve\"];\n```\n\nAnother example of indexing with an arbitrary type is using `number` to get the type of an array’s elements. We can combine this with `typeof` to conveniently capture the element type of an array literal:\n\n``` ts\nconst MyArray = [\n  { name: \"Alice\", age: 15 },\n  { name: \"Bob\", age: 23 },\n  { name: \"Eve\", age: 38 },\n];\n \ntype Person = typeof MyArray[number];\ntype Age = typeof MyArray[number][\"age\"];\n// Or\ntype Age2 = Person[\"age\"];\n```\n\nYou can only use types when indexing, meaning you can’t use a `const` to make a variable reference:\n\n``` ts\nconst key = \"age\";\ntype Age = Person[key];\n```\n\nHowever, you can use a type alias for a similar style of refactor:\n\n``` ts\ntype key = \"age\";\ntype Age = Person[key];\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)"
- name: inlineSourceMap
  id: tsconfig#inlineSourceMap-config
  summary: When set, instead of writing out a .js.map file to provide source maps, TypeScript will embed the source map content in the .js files
  belongs_to: TSConfig Reference
  description: |-
    ### Inline Source Map - `inlineSourceMap`

    When set, instead of writing out a `.js.map` file to provide source maps, TypeScript will embed the source map content in the `.js` files. Although this results in larger JS files, it can be convenient in some scenarios. For example, you might want to debug JS files on a webserver that doesn’t allow `.map` files to be served.

    Mutually exclusive with [`sourceMap`](#sourceMap).

    For example, with this TypeScript:

    ``` ts
    const helloWorld = "hi";
    console.log(helloWorld);
    ```

    Converts to this JavaScript:

    ``` ts
    "use strict";
    const helloWorld = "hi";
    console.log(helloWorld);
     
    ```

    Then enable building it with `inlineSourceMap` enabled there is a comment at the bottom of the file which includes a source-map for the file.

    ``` ts
    "use strict";
    const helloWorld = "hi";
    console.log(helloWorld);
    //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMifQ==
    ```

    - Released:

      [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)
- name: inlineSourceMap
  id: tsconfig/index#inlineSourceMap-config
  summary: When set, instead of writing out a .js.map file to provide source maps, TypeScript will embed the source map content in the .js files
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Inline Source Map - `inlineSourceMap`

    When set, instead of writing out a `.js.map` file to provide source maps, TypeScript will embed the source map content in the `.js` files. Although this results in larger JS files, it can be convenient in some scenarios. For example, you might want to debug JS files on a webserver that doesn’t allow `.map` files to be served.

    Mutually exclusive with [`sourceMap`](#sourceMap).

    For example, with this TypeScript:

    ``` ts
    const helloWorld = "hi";
    console.log(helloWorld);
    ```

    Converts to this JavaScript:

    ``` ts
    "use strict";
    const helloWorld = "hi";
    console.log(helloWorld);
     
    ```

    Then enable building it with `inlineSourceMap` enabled there is a comment at the bottom of the file which includes a source-map for the file.

    ``` ts
    "use strict";
    const helloWorld = "hi";
    console.log(helloWorld);
    //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMifQ==
    ```

    - Released:

      [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)
- name: inlineSources
  id: tsconfig#inlineSources-config
  summary: When set, TypeScript will include the original content of the .ts file as an embedded string in the source map (using the source map’s sourcesContent property). This is often useful in the same cases as inlineSourceMap
  belongs_to: TSConfig Reference
  description: |-
    ### Inline Sources - `inlineSources`

    When set, TypeScript will include the original content of the `.ts` file as an embedded string in the source map (using the source map’s `sourcesContent` property). This is often useful in the same cases as [`inlineSourceMap`](#inlineSourceMap).

    Requires either [`sourceMap`](#sourceMap) or [`inlineSourceMap`](#inlineSourceMap) to be set.

    For example, with this TypeScript:

    ``` ts
    const helloWorld = "hi";
    console.log(helloWorld);
    ```

    By default converts to this JavaScript:

    ``` ts
    "use strict";
    const helloWorld = "hi";
    console.log(helloWorld);
     
    ```

    Then enable building it with `inlineSources` and [`inlineSourceMap`](#inlineSourceMap) enabled there is a comment at the bottom of the file which includes a source-map for the file. Note that the end is different from the example in [`inlineSourceMap`](#inlineSourceMap) because the source-map now contains the original source code also.

    ``` ts
    "use strict";
    const helloWorld = "hi";
    console.log(helloWorld);
    //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoZWxsb1dvcmxkID0gXCJoaVwiO1xuY29uc29sZS5sb2coaGVsbG9Xb3JsZCk7Il19
    ```

    - Released:

      [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)
- name: inlineSources
  id: tsconfig/index#inlineSources-config
  summary: When set, TypeScript will include the original content of the .ts file as an embedded string in the source map (using the source map’s sourcesContent property). This is often useful in the same cases as inlineSourceMap
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Inline Sources - `inlineSources`

    When set, TypeScript will include the original content of the `.ts` file as an embedded string in the source map (using the source map’s `sourcesContent` property). This is often useful in the same cases as [`inlineSourceMap`](#inlineSourceMap).

    Requires either [`sourceMap`](#sourceMap) or [`inlineSourceMap`](#inlineSourceMap) to be set.

    For example, with this TypeScript:

    ``` ts
    const helloWorld = "hi";
    console.log(helloWorld);
    ```

    By default converts to this JavaScript:

    ``` ts
    "use strict";
    const helloWorld = "hi";
    console.log(helloWorld);
     
    ```

    Then enable building it with `inlineSources` and [`inlineSourceMap`](#inlineSourceMap) enabled there is a comment at the bottom of the file which includes a source-map for the file. Note that the end is different from the example in [`inlineSourceMap`](#inlineSourceMap) because the source-map now contains the original source code also.

    ``` ts
    "use strict";
    const helloWorld = "hi";
    console.log(helloWorld);
    //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoZWxsb1dvcmxkID0gXCJoaVwiO1xuY29uc29sZS5sb2coaGVsbG9Xb3JsZCk7Il19
    ```

    - Released:

      [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)
- name: Integrating with Build Tools
  id: integrating-with-build-tools
  summary: Note that both typescript and tslib are peer dependencies of this plugin that need to be installed separately
  description: "# Integrating with Build Tools\n\n## Babel\n\n### Install\n\n``` shell\nnpm install @babel/cli @babel/core @babel/preset-typescript --save-dev\n```\n\n### .babelrc\n\n``` js\n{\n  \"presets\": [\"@babel/preset-typescript\"]\n}\n```\n\n### Using Command Line Interface\n\n``` shell\n./node_modules/.bin/babel --out-file bundle.js src/index.ts\n```\n\n### package.json\n\n``` js\n{\n  \"scripts\": {\n    \"build\": \"babel --out-file bundle.js main.ts\"\n  },\n}\n```\n\n### Execute Babel from the command line\n\n``` shell\nnpm run build\n```\n\n## Browserify\n\n### Install\n\n``` shell\nnpm install tsify\n```\n\n### Using Command Line Interface\n\n``` shell\nbrowserify main.ts -p [ tsify --noImplicitAny ] > bundle.js\n```\n\n### Using API\n\n``` js\nvar browserify = require(\"browserify\");\nvar tsify = require(\"tsify\");\n\nbrowserify()\n  .add(\"main.ts\")\n  .plugin(\"tsify\", { noImplicitAny: true })\n  .bundle()\n  .pipe(process.stdout);\n```\n\nMore details: [smrq/tsify](https://github.com/smrq/tsify)\n\n## Grunt\n\n### Using `grunt-ts` (no longer maintained)\n\n#### Install\n\n``` shell\nnpm install grunt-ts --save-dev\n```\n\n#### Basic Gruntfile.js\n\n``` js\nmodule.exports = function (grunt) {\n  grunt.initConfig({\n    ts: {\n      default: {\n        src: [\"**/*.ts\", \"!node_modules/**/*.ts\"],\n      },\n    },\n  });\n  grunt.loadNpmTasks(\"grunt-ts\");\n  grunt.registerTask(\"default\", [\"ts\"]);\n};\n```\n\nMore details: [TypeStrong/grunt-ts](https://github.com/TypeStrong/grunt-ts)\n\n### Using `grunt-browserify` combined with `tsify`\n\n#### Install\n\n``` shell\nnpm install grunt-browserify tsify --save-dev\n```\n\n#### Basic Gruntfile.js\n\n``` js\nmodule.exports = function (grunt) {\n  grunt.initConfig({\n    browserify: {\n      all: {\n        src: \"src/main.ts\",\n        dest: \"dist/main.js\",\n        options: {\n          plugin: [\"tsify\"],\n        },\n      },\n    },\n  });\n  grunt.loadNpmTasks(\"grunt-browserify\");\n  grunt.registerTask(\"default\", [\"browserify\"]);\n};\n```\n\nMore details: [jmreidy/grunt-browserify](https://github.com/jmreidy/grunt-browserify), [TypeStrong/tsify](https://github.com/TypeStrong/tsify)\n\n## Gulp\n\n### Install\n\n``` shell\nnpm install gulp-typescript\n```\n\n### Basic gulpfile.js\n\n``` js\nvar gulp = require(\"gulp\");\nvar ts = require(\"gulp-typescript\");\n\ngulp.task(\"default\", function () {\n  var tsResult = gulp.src(\"src/*.ts\").pipe(\n    ts({\n      noImplicitAny: true,\n      out: \"output.js\",\n    })\n  );\n  return tsResult.js.pipe(gulp.dest(\"built/local\"));\n});\n```\n\nMore details: [ivogabe/gulp-typescript](https://github.com/ivogabe/gulp-typescript)\n\n## Jspm\n\n### Install\n\n``` shell\nnpm install -g jspm@beta\n```\n\n*Note: Currently TypeScript support in jspm is in 0.16beta*\n\nMore details: [TypeScriptSamples/jspm](https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm)\n\n## MSBuild\n\nUpdate project file to include locally installed `Microsoft.TypeScript.Default.props` (at the top) and `Microsoft.TypeScript.targets` (at the bottom) files:\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <!-- Include default props at the top -->\n  <Import\n      Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props\"\n      Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props')\" />\n\n  <!-- TypeScript configurations go here -->\n  <PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\">\n    <TypeScriptRemoveComments>false</TypeScriptRemoveComments>\n    <TypeScriptSourceMap>true</TypeScriptSourceMap>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)' == 'Release'\">\n    <TypeScriptRemoveComments>true</TypeScriptRemoveComments>\n    <TypeScriptSourceMap>false</TypeScriptSourceMap>\n  </PropertyGroup>\n\n  <!-- Include default targets at the bottom -->\n  <Import\n      Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"\n      Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" />\n</Project>\n```\n\nMore details about defining MSBuild compiler options: [Setting Compiler Options in MSBuild projects](compiler-options-in-msbuild)\n\n## NuGet\n\n- Right-Click -\\> Manage NuGet Packages\n- Search for `Microsoft.TypeScript.MSBuild`\n- Hit `Install`\n- When install is complete, rebuild!\n\nMore details can be found at [Package Manager Dialog](http://docs.nuget.org/Consume/Package-Manager-Dialog) and [using nightly builds with NuGet](https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild)\n\n## Rollup\n\n### Install\n\n``` typescript\nnpm install @rollup/plugin-typescript --save-dev\n```\n\nNote that both `typescript` and `tslib` are peer dependencies of this plugin that need to be installed separately.\n\n### Usage\n\nCreate a `rollup.config.js` [configuration file](https://www.rollupjs.org/guide/en/#configuration-files) and import the plugin:\n\n``` js\n// rollup.config.js\nimport typescript from '@rollup/plugin-typescript';\n\nexport default {\n  input: 'src/index.ts',\n  output: {\n    dir: 'output',\n    format: 'cjs'\n  },\n  plugins: [typescript()]\n};\n```\n\n## Svelte Compiler\n\n### Install\n\n``` typescript\nnpm install --save-dev svelte-preprocess\n```\n\nNote that `typescript` is an optional peer dependencies of this plugin and needs to be installed separately. `tslib` is not provided either.\n\nYou may also consider [`svelte-check`](https://www.npmjs.com/package/svelte-check) for CLI type checking.\n\n### Usage\n\nCreate a `svelte.config.js` configuration file and import the plugin:\n\n``` js\n// svelte.config.js\nimport preprocess from 'svelte-preprocess';\n\nconst config = {\n  // Consult https://github.com/sveltejs/svelte-preprocess\n  // for more information about preprocessors\n  preprocess: preprocess()\n};\n\nexport default config;\n```\n\nYou can now specify that script blocks are written in TypeScript:\n\n``` typescript\n<script lang=\"ts\">\n```\n\n## Vite\n\nVite supports importing `.ts` files out-of-the-box. It only performs transpilation and not type checking. It also requires that some `compilerOptions` have certain values. See the [Vite docs](https://vitejs.dev/guide/features.html#typescript) for more details.\n\n## Webpack\n\n### Install\n\n``` shell\nnpm install ts-loader --save-dev\n```\n\n### Basic webpack.config.js when using Webpack 5 or 4\n\n``` js\nconst path = require('path');\n\nmodule.exports = {\n  entry: './src/index.ts',\n  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/,\n        use: 'ts-loader',\n        exclude: /node_modules/,\n      },\n    ],\n  },\n  resolve: {\n    extensions: ['.tsx', '.ts', '.js'],\n  },\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n};\n```\n\nSee [more details on ts-loader here](https://www.npmjs.com/package/ts-loader).\n\nAlternatives:\n\n- [awesome-typescript-loader](https://www.npmjs.com/package/awesome-typescript-loader)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html)"
- name: 'Integrating with Build Tools: Babel'
  id: integrating-with-build-tools#babel
  summary: null
  belongs_to: Integrating with Build Tools
  description: |-
    ## Babel

    ### Install

    ``` shell
    npm install @babel/cli @babel/core @babel/preset-typescript --save-dev
    ```

    ### .babelrc

    ``` js
    {
      "presets": ["@babel/preset-typescript"]
    }
    ```

    ### Using Command Line Interface

    ``` shell
    ./node_modules/.bin/babel --out-file bundle.js src/index.ts
    ```

    ### package.json

    ``` js
    {
      "scripts": {
        "build": "babel --out-file bundle.js main.ts"
      },
    }
    ```

    ### Execute Babel from the command line

    ``` shell
    npm run build
    ```
- name: 'Integrating with Build Tools: Browserify'
  id: integrating-with-build-tools#browserify
  summary: null
  belongs_to: Integrating with Build Tools
  description: |-
    ## Browserify

    ### Install

    ``` shell
    npm install tsify
    ```

    ### Using Command Line Interface

    ``` shell
    browserify main.ts -p [ tsify --noImplicitAny ] > bundle.js
    ```

    ### Using API

    ``` js
    var browserify = require("browserify");
    var tsify = require("tsify");

    browserify()
      .add("main.ts")
      .plugin("tsify", { noImplicitAny: true })
      .bundle()
      .pipe(process.stdout);
    ```

    More details: [smrq/tsify](https://github.com/smrq/tsify)
- name: 'Integrating with Build Tools: Grunt'
  id: integrating-with-build-tools#grunt
  summary: null
  belongs_to: Integrating with Build Tools
  description: '## Grunt'
- name: 'Integrating with Build Tools: Gulp'
  id: integrating-with-build-tools#gulp
  summary: null
  belongs_to: Integrating with Build Tools
  description: |-
    ## Gulp

    ### Install

    ``` shell
    npm install gulp-typescript
    ```

    ### Basic gulpfile.js

    ``` js
    var gulp = require("gulp");
    var ts = require("gulp-typescript");

    gulp.task("default", function () {
      var tsResult = gulp.src("src/*.ts").pipe(
        ts({
          noImplicitAny: true,
          out: "output.js",
        })
      );
      return tsResult.js.pipe(gulp.dest("built/local"));
    });
    ```

    More details: [ivogabe/gulp-typescript](https://github.com/ivogabe/gulp-typescript)
- name: 'Integrating with Build Tools: Jspm'
  id: integrating-with-build-tools#jspm
  summary: null
  belongs_to: Integrating with Build Tools
  description: |-
    ## Jspm

    ### Install

    ``` shell
    npm install -g jspm@beta
    ```

    *Note: Currently TypeScript support in jspm is in 0.16beta*

    More details: [TypeScriptSamples/jspm](https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm)
- name: 'Integrating with Build Tools: MSBuild'
  id: integrating-with-build-tools#msbuild
  summary: null
  belongs_to: Integrating with Build Tools
  description: |-
    ## MSBuild

    Update project file to include locally installed `Microsoft.TypeScript.Default.props` (at the top) and `Microsoft.TypeScript.targets` (at the bottom) files:

    ``` xml
    <?xml version="1.0" encoding="utf-8"?>
    <Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
      <!-- Include default props at the top -->
      <Import
          Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.Default.props"
          Condition="Exists('$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.Default.props')" />

      <!-- TypeScript configurations go here -->
      <PropertyGroup Condition="'$(Configuration)' == 'Debug'">
        <TypeScriptRemoveComments>false</TypeScriptRemoveComments>
        <TypeScriptSourceMap>true</TypeScriptSourceMap>
      </PropertyGroup>
      <PropertyGroup Condition="'$(Configuration)' == 'Release'">
        <TypeScriptRemoveComments>true</TypeScriptRemoveComments>
        <TypeScriptSourceMap>false</TypeScriptSourceMap>
      </PropertyGroup>

      <!-- Include default targets at the bottom -->
      <Import
          Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets"
          Condition="Exists('$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets')" />
    </Project>
    ```

    More details about defining MSBuild compiler options: [Setting Compiler Options in MSBuild projects](compiler-options-in-msbuild)
- name: 'Integrating with Build Tools: NuGet'
  id: integrating-with-build-tools#nuget
  summary: null
  belongs_to: Integrating with Build Tools
  description: |-
    ## NuGet

    - Right-Click -\> Manage NuGet Packages
    - Search for `Microsoft.TypeScript.MSBuild`
    - Hit `Install`
    - When install is complete, rebuild!

    More details can be found at [Package Manager Dialog](http://docs.nuget.org/Consume/Package-Manager-Dialog) and [using nightly builds with NuGet](https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild)
- name: 'Integrating with Build Tools: Rollup'
  id: integrating-with-build-tools#rollup
  summary: Note that both typescript and tslib are peer dependencies of this plugin that need to be installed separately
  belongs_to: Integrating with Build Tools
  description: |-
    ## Rollup

    ### Install

    ``` typescript
    npm install @rollup/plugin-typescript --save-dev
    ```

    Note that both `typescript` and `tslib` are peer dependencies of this plugin that need to be installed separately.

    ### Usage

    Create a `rollup.config.js` [configuration file](https://www.rollupjs.org/guide/en/#configuration-files) and import the plugin:

    ``` js
    // rollup.config.js
    import typescript from '@rollup/plugin-typescript';

    export default {
      input: 'src/index.ts',
      output: {
        dir: 'output',
        format: 'cjs'
      },
      plugins: [typescript()]
    };
    ```
- name: 'Integrating with Build Tools: Svelte Compiler'
  id: integrating-with-build-tools#svelte-compiler
  summary: Note that typescript is an optional peer dependencies of this plugin and needs to be installed separately
  belongs_to: Integrating with Build Tools
  description: |-
    ## Svelte Compiler

    ### Install

    ``` typescript
    npm install --save-dev svelte-preprocess
    ```

    Note that `typescript` is an optional peer dependencies of this plugin and needs to be installed separately. `tslib` is not provided either.

    You may also consider [`svelte-check`](https://www.npmjs.com/package/svelte-check) for CLI type checking.

    ### Usage

    Create a `svelte.config.js` configuration file and import the plugin:

    ``` js
    // svelte.config.js
    import preprocess from 'svelte-preprocess';

    const config = {
      // Consult https://github.com/sveltejs/svelte-preprocess
      // for more information about preprocessors
      preprocess: preprocess()
    };

    export default config;
    ```

    You can now specify that script blocks are written in TypeScript:

    ``` typescript
    <script lang="ts">
    ```
- name: 'Integrating with Build Tools: Using grunt-browserify combined with tsify'
  id: integrating-with-build-tools#using-grunt-browserify-combined-with-tsify
  summary: null
  belongs_to: Integrating with Build Tools
  description: |-
    ### Using `grunt-browserify` combined with `tsify`

    #### Install

    ``` shell
    npm install grunt-browserify tsify --save-dev
    ```

    #### Basic Gruntfile.js

    ``` js
    module.exports = function (grunt) {
      grunt.initConfig({
        browserify: {
          all: {
            src: "src/main.ts",
            dest: "dist/main.js",
            options: {
              plugin: ["tsify"],
            },
          },
        },
      });
      grunt.loadNpmTasks("grunt-browserify");
      grunt.registerTask("default", ["browserify"]);
    };
    ```

    More details: [jmreidy/grunt-browserify](https://github.com/jmreidy/grunt-browserify), [TypeStrong/tsify](https://github.com/TypeStrong/tsify)
- name: 'Integrating with Build Tools: Using grunt-ts (no longer maintained)'
  id: integrating-with-build-tools#using-grunt-ts-no-longer-maintained
  summary: null
  belongs_to: Integrating with Build Tools
  description: |-
    ### Using `grunt-ts` (no longer maintained)

    #### Install

    ``` shell
    npm install grunt-ts --save-dev
    ```

    #### Basic Gruntfile.js

    ``` js
    module.exports = function (grunt) {
      grunt.initConfig({
        ts: {
          default: {
            src: ["**/*.ts", "!node_modules/**/*.ts"],
          },
        },
      });
      grunt.loadNpmTasks("grunt-ts");
      grunt.registerTask("default", ["ts"]);
    };
    ```

    More details: [TypeStrong/grunt-ts](https://github.com/TypeStrong/grunt-ts)
- name: 'Integrating with Build Tools: Vite'
  id: integrating-with-build-tools#vite
  summary: Vite supports importing .ts files out-of-the-box
  belongs_to: Integrating with Build Tools
  description: |-
    ## Vite

    Vite supports importing `.ts` files out-of-the-box. It only performs transpilation and not type checking. It also requires that some `compilerOptions` have certain values. See the [Vite docs](https://vitejs.dev/guide/features.html#typescript) for more details.
- name: 'Integrating with Build Tools: Webpack'
  id: integrating-with-build-tools#webpack
  summary: See more details on ts-loader here
  belongs_to: Integrating with Build Tools
  description: "## Webpack\n\n### Install\n\n``` shell\nnpm install ts-loader --save-dev\n```\n\n### Basic webpack.config.js when using Webpack 5 or 4\n\n``` js\nconst path = require('path');\n\nmodule.exports = {\n  entry: './src/index.ts',\n  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/,\n        use: 'ts-loader',\n        exclude: /node_modules/,\n      },\n    ],\n  },\n  resolve: {\n    extensions: ['.tsx', '.ts', '.js'],\n  },\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n};\n```\n\nSee [more details on ts-loader here](https://www.npmjs.com/package/ts-loader).\n\nAlternatives:\n\n- [awesome-typescript-loader](https://www.npmjs.com/package/awesome-typescript-loader)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html)"
- name: Interfaces
  id: interfaces
  summary: One of TypeScript’s core principles is that type checking focuses on the shape that values have
  description: "# Interfaces\n\nThis handbook page has been replaced, [go to the new page](2/objects)\n\nOne of TypeScript’s core principles is that type checking focuses on the *shape* that values have. This is sometimes called “duck typing” or “structural subtyping”. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.\n\n## Our First Interface\n\nThe easiest way to see how interfaces work is to start with a simple example:\n\n``` ts\nfunction printLabel(labeledObj: { label: string }) {\n  console.log(labeledObj.label);\n}\n \nlet myObj = { size: 10, label: \"Size 10 Object\" };\nprintLabel(myObj);\n```\n\nThe type checker checks the call to `printLabel`. The `printLabel` function has a single parameter that requires that the object passed in has a property called `label` of type `string`. Notice that our object actually has more properties than this, but the compiler only checks that *at least* the ones required are present and match the types required. There are some cases where TypeScript isn’t as lenient, which we’ll cover in a bit.\n\nWe can write the same example again, this time using an interface to describe the requirement of having the `label` property that is a string:\n\n``` ts\ninterface LabeledValue {\n  label: string;\n}\n \nfunction printLabel(labeledObj: LabeledValue) {\n  console.log(labeledObj.label);\n}\n \nlet myObj = { size: 10, label: \"Size 10 Object\" };\nprintLabel(myObj);\n```\n\nThe interface `LabeledValue` is a name we can now use to describe the requirement in the previous example. It still represents having a single property called `label` that is of type `string`. Notice we didn’t have to explicitly say that the object we pass to `printLabel` implements this interface like we might have to in other languages. Here, it’s only the shape that matters. If the object we pass to the function meets the requirements listed, then it’s allowed.\n\nIt’s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.\n\n## Optional Properties\n\nNot all properties of an interface may be required. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like “option bags” where you pass an object to a function that only has a couple of properties filled in.\n\nHere’s an example of this pattern:\n\n``` ts\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n \nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  let newSquare = { color: \"white\", area: 100 };\n  if (config.color) {\n    newSquare.color = config.color;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n \nlet mySquare = createSquare({ color: \"black\" });\n```\n\nInterfaces with optional properties are written similar to other interfaces, with each optional property denoted by a `?` at the end of the property name in the declaration.\n\nThe advantage of optional properties is that you can describe these possibly available properties while still also preventing use of properties that are not part of the interface. For example, had we mistyped the name of the `color` property in `createSquare`, we would get an error message letting us know:\n\n``` ts\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n \nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  let newSquare = { color: \"white\", area: 100 };\n  if (config.clor) {\n    // Error: Property 'clor' does not exist on type 'SquareConfig'\n    newSquare.color = config.clor;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n \nlet mySquare = createSquare({ color: \"black\" });\n```\n\n## Readonly properties\n\nSome properties should only be modifiable when an object is first created. You can specify this by putting `readonly` before the name of the property:\n\n``` ts\ninterface Point {\n  readonly x: number;\n  readonly y: number;\n}\n```\n\nYou can construct a `Point` by assigning an object literal. After the assignment, `x` and `y` can’t be changed.\n\n``` ts\nlet p1: Point = { x: 10, y: 20 };\np1.x = 5; // error!\n```\n\nTypeScript comes with a `ReadonlyArray<T>` type that is the same as `Array<T>` with all mutating methods removed, so you can make sure you don’t change your arrays after creation:\n\n``` ts\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\n \nro[0] = 12; // error!\nro.push(5); // error!\nro.length = 100; // error!\na = ro; // error!\n```\n\nOn the last line of the snippet you can see that even assigning the entire `ReadonlyArray` back to a normal array is illegal. You can still override it with a type assertion, though:\n\n``` ts\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\n \na = ro as number[];\n```\n\n### `readonly` vs `const`\n\nThe easiest way to remember whether to use `readonly` or `const` is to ask whether you’re using it on a variable or a property. Variables use `const` whereas properties use `readonly`.\n\n## Excess Property Checks\n\nIn our first example using interfaces, TypeScript lets us pass `{ size: number; label: string; }` to something that only expected a `{ label: string; }`. We also just learned about optional properties, and how they’re useful when describing so-called “option bags”.\n\nHowever, combining the two naively would allow an error to sneak in. For example, taking our last example using `createSquare`:\n\n``` ts\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n \nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  return {\n    color: config.color || \"red\",\n    area: config.width ? config.width * config.width : 20,\n  };\n}\n \nlet mySquare = createSquare({ colour: \"red\", width: 100 });\n```\n\nNotice the given argument to `createSquare` is spelled *`colour`* instead of `color`. In plain JavaScript, this sort of thing fails silently.\n\nYou could argue that this program is correctly typed, since the `width` properties are compatible, there’s no `color` property present, and the extra `colour` property is insignificant.\n\nHowever, TypeScript takes the stance that there’s probably a bug in this code. Object literals get special treatment and undergo *excess property checking* when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the “target type” doesn’t have, you’ll get an error:\n\n``` ts\nlet mySquare = createSquare({ colour: \"red\", width: 100 });\n```\n\nGetting around these checks is actually really simple. The easiest method is to just use a type assertion:\n\n``` ts\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);\n```\n\nHowever, a better approach might be to add a string index signature if you’re sure that the object can have some extra properties that are used in some special way. If `SquareConfig` can have `color` and `width` properties with the above types, but could *also* have any number of other properties, then we could define it like so:\n\n``` ts\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n  [propName: string]: any;\n}\n```\n\nWe’ll discuss index signatures in a bit, but here we’re saying a `SquareConfig` can have any number of properties, and as long as they aren’t `color` or `width`, their types don’t matter.\n\nOne final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since `squareOptions` won’t undergo excess property checks, the compiler won’t give you an error.\n\n``` ts\nlet squareOptions = { colour: \"red\", width: 100 };\nlet mySquare = createSquare(squareOptions);\n```\n\nThe above workaround will work as long as you have a common property between `squareOptions` and `SquareConfig`. In this example, it was the property `width`. It will however, fail if the variable does not have any common object property. For example:\n\n``` ts\nlet squareOptions = { colour: \"red\" };\nlet mySquare = createSquare(squareOptions);\n```\n\nKeep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it’s okay to pass an object with both a `color` or `colour` property to `createSquare`, you should fix up the definition of `SquareConfig` to reflect that.\n\n## Function Types\n\nInterfaces are capable of describing the wide range of shapes that JavaScript objects can take. In addition to describing an object with properties, interfaces are also capable of describing function types.\n\nTo describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.\n\n``` ts\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n```\n\nOnce defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.\n\n``` ts\nlet mySearch: SearchFunc;\n \nmySearch = function (source: string, subString: string): boolean {\n  let result = source.search(subString);\n  return result > -1;\n};\n```\n\nFor function types to correctly type check, the names of the parameters do not need to match. We could have, for example, written the above example like this:\n\n``` ts\nlet mySearch: SearchFunc;\n \nmySearch = function (src: string, sub: string): boolean {\n  let result = src.search(sub);\n  return result > -1;\n};\n```\n\nFunction parameters are checked one at a time, with the type in each corresponding parameter position checked against each other. If you do not want to specify types at all, TypeScript’s contextual typing can infer the argument types since the function value is assigned directly to a variable of type `SearchFunc`. Here, also, the return type of our function expression is implied by the values it returns (here `false` and `true`).\n\n``` ts\nlet mySearch: SearchFunc;\n \nmySearch = function (src, sub) {\n  let result = src.search(sub);\n  return result > -1;\n};\n```\n\nHad the function expression returned numbers or strings, the type checker would have made an error that indicates return type doesn’t match the return type described in the `SearchFunc` interface.\n\n``` ts\nlet mySearch: SearchFunc;\n \nmySearch = function (src, sub) {\n  let result = src.search(sub);\n  return \"string\";\n};\n```\n\n## Indexable Types\n\nSimilarly to how we can use interfaces to describe function types, we can also describe types that we can “index into” like `a[10]`, or `ageMap[\"daniel\"]`. Indexable types have an *index signature* that describes the types we can use to index into the object, along with the corresponding return types when indexing.\n\nLet’s take an example:\n\n``` ts\ninterface StringArray {\n  [index: number]: string;\n}\n \nlet myArray: StringArray;\nmyArray = [\"Bob\", \"Fred\"];\n \nlet myStr: string = myArray[0];\n```\n\nAbove, we have a `StringArray` interface that has an index signature. This index signature states that when a `StringArray` is indexed with a `number`, it will return a `string`.\n\nThere are four types of supported index signatures: string, number, symbol and template strings. It is possible to support many types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer.\n\nThis is because when indexing with a `number`, JavaScript will actually convert that to a `string` before indexing into an object. That means that indexing with `100` (a `number`) is the same thing as indexing with `\"100\"` (a `string`), so the two need to be consistent.\n\n``` ts\ninterface Animal {\n  name: string;\n}\n \ninterface Dog extends Animal {\n  breed: string;\n}\n \n// Error: indexing with a numeric string might get you a completely separate type of Animal!\ninterface NotOkay {\n  [x: number]: Animal;\n  [x: string]: Dog;\n}\n```\n\nWhile string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. This is because a string index declares that `obj.property` is also available as `obj[\"property\"]`. In the following example, `name`’s type does not match the string index’s type, and the type checker gives an error:\n\n``` ts\ninterface NumberDictionary {\n  [index: string]: number;\n \n  length: number; // ok, length is a number\n  name: string; // error, the type of 'name' is not a subtype of the indexer\n}\n```\n\nHowever, properties of different types are acceptable if the index signature is a union of the property types:\n\n``` ts\ninterface NumberOrStringDictionary {\n  [index: string]: number | string;\n \n  length: number; // ok, length is a number\n  name: string; // ok, name is a string\n}\n```\n\nFinally, you can make index signatures `readonly` in order to prevent assignment to their indices:\n\n``` ts\ninterface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\n \nlet myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];\nmyArray[2] = \"Mallory\"; // error!\n```\n\nYou can’t set `myArray[2]` because the index signature is `readonly`.\n\n### Indexable Types with Template Strings\n\nA template string can be used to indicate that a particular pattern is allowed, but not all. For example, a HTTP headers object may have a set list of known headers and support any [custom defined properties](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) which are prefixed with `x-`.\n\n``` ts\ninterface HeadersResponse {\n  \"content-type\": string,\n  date: string,\n  \"content-length\": string\n \n  // Permit any property starting with 'x-'.\n  [headerName: `x-${string}`]: string;\n}\n \nfunction handleResponse(r: HeadersResponse) {\n  // Handle known, and x- prefixed\n  const type = r[\"content-type\"]\n  const poweredBy = r[\"x-powered-by\"]\n \n  // Unknown keys without the prefix raise errors\n  const origin = r.origin\n}\n```\n\n## Class Types\n\n### Implementing an interface\n\nOne of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.\n\n``` ts\ninterface ClockInterface {\n  currentTime: Date;\n}\n \nclass Clock implements ClockInterface {\n  currentTime: Date = new Date();\n  constructor(h: number, m: number) {}\n}\n```\n\nYou can also describe methods in an interface that are implemented in the class, as we do with `setTime` in the below example:\n\n``` ts\ninterface ClockInterface {\n  currentTime: Date;\n  setTime(d: Date): void;\n}\n \nclass Clock implements ClockInterface {\n  currentTime: Date = new Date();\n  setTime(d: Date) {\n    this.currentTime = d;\n  }\n  constructor(h: number, m: number) {}\n}\n```\n\nInterfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.\n\n### Difference between the static and instance sides of classes\n\nWhen working with classes and interfaces, it helps to keep in mind that a class has *two* types: the type of the static side and the type of the instance side. You may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:\n\n``` ts\ninterface ClockConstructor {\n  new (hour: number, minute: number);\n}\n \nclass Clock implements ClockConstructor {\n  currentTime: Date;\n  constructor(h: number, m: number) {}\n}\n```\n\nThis is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.\n\nInstead, you would need to work with the static side of the class directly. In this example, we define two interfaces, `ClockConstructor` for the constructor and `ClockInterface` for the instance methods. Then, for convenience, we define a constructor function `createClock` that creates instances of the type that is passed to it:\n\n``` ts\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface;\n}\n \ninterface ClockInterface {\n  tick(): void;\n}\n \nfunction createClock(\n  ctor: ClockConstructor,\n  hour: number,\n  minute: number\n): ClockInterface {\n  return new ctor(hour, minute);\n}\n \nclass DigitalClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log(\"beep beep\");\n  }\n}\n \nclass AnalogClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log(\"tick tock\");\n  }\n}\n \nlet digital = createClock(DigitalClock, 12, 17);\nlet analog = createClock(AnalogClock, 7, 32);\n```\n\nBecause `createClock`’s first parameter is of type `ClockConstructor`, in `createClock(AnalogClock, 7, 32)`, it checks that `AnalogClock` has the correct constructor signature.\n\nAnother simple way is to use class expressions:\n\n``` ts\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface;\n}\n \ninterface ClockInterface {\n  tick(): void;\n}\n \nconst Clock: ClockConstructor = class Clock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log(\"beep beep\");\n  }\n};\n \nlet clock = new Clock(12, 17);\nclock.tick();\n```\n\n## Extending Interfaces\n\nLike classes, interfaces can extend each other. This allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components.\n\n``` ts\ninterface Shape {\n  color: string;\n}\n \ninterface Square extends Shape {\n  sideLength: number;\n}\n \nlet square = {} as Square;\nsquare.color = \"blue\";\nsquare.sideLength = 10;\n```\n\nAn interface can extend multiple interfaces, creating a combination of all of the interfaces.\n\n``` ts\ninterface Shape {\n  color: string;\n}\n \ninterface PenStroke {\n  penWidth: number;\n}\n \ninterface Square extends Shape, PenStroke {\n  sideLength: number;\n}\n \nlet square = {} as Square;\nsquare.color = \"blue\";\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n```\n\n## Hybrid Types\n\nAs we mentioned earlier, interfaces can describe the rich types present in real world JavaScript. Because of JavaScript’s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above.\n\nOne such example is an object that acts as both a function and an object, with additional properties:\n\n``` ts\ninterface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n \nfunction getCounter(): Counter {\n  let counter = function (start: number) {} as Counter;\n  counter.interval = 123;\n  counter.reset = function () {};\n  return counter;\n}\n \nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n```\n\nWhen interacting with 3rd-party JavaScript, you may need to use patterns like the above to fully describe the shape of the type.\n\n## Interfaces Extending Classes\n\nWhen an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it.\n\nThis is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don’t have to be related besides inheriting from the base class. For example:\n\n``` ts\nclass Control {\n  private state: any;\n}\n \ninterface SelectableControl extends Control {\n  select(): void;\n}\n \nclass Button extends Control implements SelectableControl {\n  select() {}\n}\n \nclass TextBox extends Control {\n  select() {}\n}\n \nclass ImageControl implements SelectableControl {\n  private state: any;\n  select() {}\n}\n```\n\nIn the above example, `SelectableControl` contains all of the members of `Control`, including the private `state` property. Since `state` is a private member it is only possible for descendants of `Control` to implement `SelectableControl`. This is because only descendants of `Control` will have a `state` private member that originates in the same declaration, which is a requirement for private members to be compatible.\n\nWithin the `Control` class it is possible to access the `state` private member through an instance of `SelectableControl`. Effectively, a `SelectableControl` acts like a `Control` that is known to have a `select` method. The `Button` and `TextBox` classes are subtypes of `SelectableControl` (because they both inherit from `Control` and have a `select` method). The `ImageControl` class has its own `state` private member rather than extending `Control`, so it cannot implement `SelectableControl`.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/interfaces.html](https://www.typescriptlang.org/docs/handbook/interfaces.html)"
- name: Intro to the TSConfig Reference
  id: tsconfig/index
  summary: Starting up are the root options in the TSConfig - these options relate to how your TypeScript or JavaScript project is set up
  description: "# Intro to the TSConfig Reference\n\n[](#)\n\n## Intro to the TSConfig Reference\n\nA TSConfig file in a directory indicates that the directory is the root of a TypeScript or JavaScript project...\n\n## Compiler Options\n\n##### Top Level\n\n1.  [`files`](#files)`, `\n2.  [`extends`](#extends)`, `\n3.  [`include`](#include)`, `\n4.  [`exclude`](#exclude)` and `\n5.  [`references`](#references)\n\n#### [`\"compilerOptions\"`](#compilerOptions)\n\n##### Type Checking\n\n1.  [`allowUnreachableCode`](#allowUnreachableCode)`, `\n2.  [`allowUnusedLabels`](#allowUnusedLabels)`, `\n3.  [`alwaysStrict`](#alwaysStrict)`, `\n4.  [`exactOptionalPropertyTypes`](#exactOptionalPropertyTypes)`, `\n5.  [`noFallthroughCasesInSwitch`](#noFallthroughCasesInSwitch)`, `\n6.  [`noImplicitAny`](#noImplicitAny)`, `\n7.  [`noImplicitOverride`](#noImplicitOverride)`, `\n8.  [`noImplicitReturns`](#noImplicitReturns)`, `\n9.  [`noImplicitThis`](#noImplicitThis)`, `\n10. [`noPropertyAccessFromIndexSignature`](#noPropertyAccessFromIndexSignature)`, `\n11. [`noUncheckedIndexedAccess`](#noUncheckedIndexedAccess)`, `\n12. [`noUnusedLocals`](#noUnusedLocals)`, `\n13. [`noUnusedParameters`](#noUnusedParameters)`, `\n14. [`strict`](#strict)`, `\n15. [`strictBindCallApply`](#strictBindCallApply)`, `\n16. [`strictFunctionTypes`](#strictFunctionTypes)`, `\n17. [`strictNullChecks`](#strictNullChecks)`, `\n18. [`strictPropertyInitialization`](#strictPropertyInitialization)` and `\n19. [`useUnknownInCatchVariables`](#useUnknownInCatchVariables)\n\n##### Modules\n\n1.  [`allowArbitraryExtensions`](#allowArbitraryExtensions)`, `\n2.  [`allowImportingTsExtensions`](#allowImportingTsExtensions)`, `\n3.  [`allowUmdGlobalAccess`](#allowUmdGlobalAccess)`, `\n4.  [`baseUrl`](#baseUrl)`, `\n5.  [`customConditions`](#customConditions)`, `\n6.  [`module`](#module)`, `\n7.  [`moduleResolution`](#moduleResolution)`, `\n8.  [`moduleSuffixes`](#moduleSuffixes)`, `\n9.  [`noResolve`](#noResolve)`, `\n10. [`paths`](#paths)`, `\n11. [`resolveJsonModule`](#resolveJsonModule)`, `\n12. [`resolvePackageJsonExports`](#resolvePackageJsonExports)`, `\n13. [`resolvePackageJsonImports`](#resolvePackageJsonImports)`, `\n14. [`rootDir`](#rootDir)`, `\n15. [`rootDirs`](#rootDirs)`, `\n16. [`typeRoots`](#typeRoots)` and `\n17. [`types`](#types)\n\n##### Emit\n\n1.  [`declaration`](#declaration)`, `\n2.  [`declarationDir`](#declarationDir)`, `\n3.  [`declarationMap`](#declarationMap)`, `\n4.  [`downlevelIteration`](#downlevelIteration)`, `\n5.  [`emitBOM`](#emitBOM)`, `\n6.  [`emitDeclarationOnly`](#emitDeclarationOnly)`, `\n7.  [`importHelpers`](#importHelpers)`, `\n8.  [`inlineSourceMap`](#inlineSourceMap)`, `\n9.  [`inlineSources`](#inlineSources)`, `\n10. [`mapRoot`](#mapRoot)`, `\n11. [`newLine`](#newLine)`, `\n12. [`noEmit`](#noEmit)`, `\n13. [`noEmitHelpers`](#noEmitHelpers)`, `\n14. [`noEmitOnError`](#noEmitOnError)`, `\n15. [`outDir`](#outDir)`, `\n16. [`outFile`](#outFile)`, `\n17. [`preserveConstEnums`](#preserveConstEnums)`, `\n18. [`removeComments`](#removeComments)`, `\n19. [`sourceMap`](#sourceMap)`, `\n20. [`sourceRoot`](#sourceRoot)` and `\n21. [`stripInternal`](#stripInternal)\n\n##### JavaScript Support\n\n1.  [`allowJs`](#allowJs)`, `\n2.  [`checkJs`](#checkJs)` and `\n3.  [`maxNodeModuleJsDepth`](#maxNodeModuleJsDepth)\n\n##### Editor Support\n\n1.  [`disableSizeLimit`](#disableSizeLimit)` and `\n2.  [`plugins`](#plugins)\n\n##### Interop Constraints\n\n1.  [`allowSyntheticDefaultImports`](#allowSyntheticDefaultImports)`, `\n2.  [`esModuleInterop`](#esModuleInterop)`, `\n3.  [`forceConsistentCasingInFileNames`](#forceConsistentCasingInFileNames)`, `\n4.  [`isolatedDeclarations`](#isolatedDeclarations)`, `\n5.  [`isolatedModules`](#isolatedModules)`, `\n6.  [`preserveSymlinks`](#preserveSymlinks)` and `\n7.  [`verbatimModuleSyntax`](#verbatimModuleSyntax)\n\n##### Backwards Compatibility\n\n1.  [`charset`](#charset)`, `\n2.  [`importsNotUsedAsValues`](#importsNotUsedAsValues)`, `\n3.  [`keyofStringsOnly`](#keyofStringsOnly)`, `\n4.  [`noImplicitUseStrict`](#noImplicitUseStrict)`, `\n5.  [`noStrictGenericChecks`](#noStrictGenericChecks)`, `\n6.  [`out`](#out)`, `\n7.  [`preserveValueImports`](#preserveValueImports)`, `\n8.  [`suppressExcessPropertyErrors`](#suppressExcessPropertyErrors)` and `\n9.  [`suppressImplicitAnyIndexErrors`](#suppressImplicitAnyIndexErrors)\n\n##### Language and Environment\n\n1.  [`emitDecoratorMetadata`](#emitDecoratorMetadata)`, `\n2.  [`experimentalDecorators`](#experimentalDecorators)`, `\n3.  [`jsx`](#jsx)`, `\n4.  [`jsxFactory`](#jsxFactory)`, `\n5.  [`jsxFragmentFactory`](#jsxFragmentFactory)`, `\n6.  [`jsxImportSource`](#jsxImportSource)`, `\n7.  [`lib`](#lib)`, `\n8.  [`moduleDetection`](#moduleDetection)`, `\n9.  [`noLib`](#noLib)`, `\n10. [`reactNamespace`](#reactNamespace)`, `\n11. [`target`](#target)` and `\n12. [`useDefineForClassFields`](#useDefineForClassFields)\n\n##### Compiler Diagnostics\n\n1.  [`diagnostics`](#diagnostics)`, `\n2.  [`explainFiles`](#explainFiles)`, `\n3.  [`extendedDiagnostics`](#extendedDiagnostics)`, `\n4.  [`generateCpuProfile`](#generateCpuProfile)`, `\n5.  [`listEmittedFiles`](#listEmittedFiles)`, `\n6.  [`listFiles`](#listFiles)`, `\n7.  [`noCheck`](#noCheck)` and `\n8.  [`traceResolution`](#traceResolution)\n\n##### Projects\n\n1.  [`composite`](#composite)`, `\n2.  [`disableReferencedProjectLoad`](#disableReferencedProjectLoad)`, `\n3.  [`disableSolutionSearching`](#disableSolutionSearching)`, `\n4.  [`disableSourceOfProjectReferenceRedirect`](#disableSourceOfProjectReferenceRedirect)`, `\n5.  [`incremental`](#incremental)` and `\n6.  [`tsBuildInfoFile`](#tsBuildInfoFile)\n\n##### Output Formatting\n\n1.  [`noErrorTruncation`](#noErrorTruncation)`, `\n2.  [`preserveWatchOutput`](#preserveWatchOutput)` and `\n3.  [`pretty`](#pretty)\n\n##### Completeness\n\n1.  [`skipDefaultLibCheck`](#skipDefaultLibCheck)` and `\n2.  [`skipLibCheck`](#skipLibCheck)\n\n##### Command Line\n\n##### Watch Options\n\n1.  [`assumeChangesOnlyAffectDirectDependencies`](#assumeChangesOnlyAffectDirectDependencies)\n\n#### [`\"watchOptions\"`](#watchOptions)\n\n##### watchOptions\n\n1.  [`watchFile`](#watch-watchFile)`, `\n2.  [`watchDirectory`](#watch-watchDirectory)`, `\n3.  [`fallbackPolling`](#watch-fallbackPolling)`, `\n4.  [`synchronousWatchDirectory`](#watch-synchronousWatchDirectory)`, `\n5.  [`excludeDirectories`](#watch-excludeDirectories)` and `\n6.  [`excludeFiles`](#watch-excludeFiles)\n\n#### [`\"typeAcquisition\"`](#typeAcquisition)\n\n##### typeAcquisition\n\n1.  [`enable`](#type-enable)`, `\n2.  [`include`](#type-include)`, `\n3.  [`exclude`](#type-exclude)` and `\n4.  [`disableFilenameBasedTypeAcquisition`](#type-disableFilenameBasedTypeAcquisition)\n\n### Root Fields\n\nStarting up are the root options in the TSConfig - these options relate to how your TypeScript or JavaScript project is set up.\n\n### Files - `files`\n\nSpecifies an allowlist of files to include in the program. An error occurs if any of the files can’t be found.\n\n``` typescript\n{\n  \"compilerOptions\": {},\n  \"files\": [\n    \"core.ts\",\n    \"sys.ts\",\n    \"types.ts\",\n    \"scanner.ts\",\n    \"parser.ts\",\n    \"utilities.ts\",\n    \"binder.ts\",\n    \"checker.ts\",\n    \"tsc.ts\"\n  ]\n}\n```\n\nThis is useful when you only have a small number of files and don’t need to use a glob to reference many files. If you need that then use [`include`](#include).\n\n- Default:\n\n  `false`\n\n- Related:\n  - [`include`](#include)\n\n  - [`exclude`](#exclude)\n\n### Extends - `extends`\n\nThe value of `extends` is a string which contains a path to another configuration file to inherit from. The path may use Node.js style resolution.\n\nThe configuration from the base file are loaded first, then overridden by those in the inheriting config file. All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.\n\nIt’s worth noting that [`files`](#files), [`include`](#include), and [`exclude`](#exclude) from the inheriting config file *overwrite* those from the base config file, and that circularity between configuration files is not allowed.\n\nCurrently, the only top-level property that is excluded from inheritance is [`references`](#references).\n\n##### Example\n\n`configs/base.json`:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true\n  }\n}\n```\n\n`tsconfig.json`:\n\n``` typescript\n{\n  \"extends\": \"./configs/base\",\n  \"files\": [\"main.ts\", \"supplemental.ts\"]\n}\n```\n\n`tsconfig.nostrictnull.json`:\n\n``` typescript\n{\n  \"extends\": \"./tsconfig\",\n  \"compilerOptions\": {\n    \"strictNullChecks\": false\n  }\n}\n```\n\nProperties with relative paths found in the configuration file, which aren’t excluded from inheritance, will be resolved relative to the configuration file they originated in.\n\n- Default:\n\n  `false`\n\n- Released:\n\n  [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html)\n\n### Include - `include`\n\nSpecifies an array of filenames or patterns to include in the program. These filenames are resolved relative to the directory containing the `tsconfig.json` file.\n\n``` json\n{\n  \"include\": [\"src/**/*\", \"tests/**/*\"]\n}\n```\n\nWhich would include:\n\n``` typescript\n.\n├── scripts                ⨯\n│   ├── lint.ts            ⨯\n│   ├── update_deps.ts     ⨯\n│   └── utils.ts           ⨯\n├── src                    ✓\n│   ├── client             ✓\n│   │    ├── index.ts      ✓\n│   │    └── utils.ts      ✓\n│   ├── server             ✓\n│   │    └── index.ts      ✓\n├── tests                  ✓\n│   ├── app.test.ts        ✓\n│   ├── utils.ts           ✓\n│   └── tests.d.ts         ✓\n├── package.json\n├── tsconfig.json\n└── yarn.lock\n```\n\n`include` and `exclude` support wildcard characters to make glob patterns:\n\n- `*` matches zero or more characters (excluding directory separators)\n- `?` matches any one character (excluding directory separators)\n- `**/` matches any directory nested to any level\n\nIf the last path segment in a pattern does not contain a file extension or wildcard character, then it is treated as a directory, and files with supported extensions inside that directory are included (e.g. `.ts`, `.tsx`, and `.d.ts` by default, with `.js` and `.jsx` if [`allowJs`](#allowJs) is set to true).\n\n- Default:\n\n  `[]` if [`files`](#files) is specified; `**/*` otherwise.\n\n- Related:\n  - [`files`](#files)\n\n  - [`exclude`](#exclude)\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### Exclude - `exclude`\n\nSpecifies an array of filenames or patterns that should be skipped when resolving [`include`](#include).\n\n**Important**: `exclude` *only* changes which files are included as a result of the [`include`](#include) setting. A file specified by `exclude` can still become part of your codebase due to an `import` statement in your code, a `types` inclusion, a `/// <reference` directive, or being specified in the [`files`](#files) list.\n\nIt is not a mechanism that **prevents** a file from being included in the codebase - it simply changes what the [`include`](#include) setting finds.\n\n- Default:\n\n  node_modules bower_components jspm_packages [`outDir`](#outDir)\n\n- Related:\n  - [`include`](#include)\n\n  - [`files`](#files)\n\n### References - `references`\n\nProject references are a way to structure your TypeScript programs into smaller pieces. Using Project References can greatly improve build and editor interaction times, enforce logical separation between components, and organize your code in new and improved ways.\n\nYou can read more about how references works in the [Project References](../docs/handbook/project-references) section of the handbook\n\n- Default:\n\n  `false`\n\n### Compiler Options\n\nThese options make up the bulk of TypeScript’s configuration and it covers how the language should work.\n\n- [Type Checking](#Type_Checking_6248)\n- [Modules](#Modules_6244)\n- [Emit](#Emit_6246)\n- [JavaScript Support](#JavaScript_Support_6247)\n- [Editor Support](#Editor_Support_6249)\n- [Interop Constraints](#Interop_Constraints_6252)\n- [Backwards Compatibility](#Backwards_Compatibility_6253)\n- [Language and Environment](#Language_and_Environment_6254)\n- [Compiler Diagnostics](#Compiler_Diagnostics_6251)\n- [Projects](#Projects_6255)\n- [Output Formatting](#Output_Formatting_6256)\n- [Completeness](#Completeness_6257)\n- [Command Line](#Command_line_Options_6171)\n- [Watch Options](#Watch_and_Build_Modes_6250)\n\n## Type Checking\n\n### Allow Unreachable Code - `allowUnreachableCode`\n\nWhen:\n\n- `undefined` (default) provide suggestions as warnings to editors\n- `true` unreachable code is ignored\n- `false` raises compiler errors about unreachable code\n\nThese warnings are only about code which is provably unreachable due to the use of JavaScript syntax, for example:\n\n``` ts\nfunction fn(n: number) {\n  if (n > 5) {\n    return true;\n  } else {\n    return false;\n  }\n  return true;\n}\n```\n\nWith `\"allowUnreachableCode\": false`:\n\n``` ts\nfunction fn(n: number) {\n  if (n > 5) {\n    return true;\n  } else {\n    return false;\n  }\n  return true;\n}\n```\n\nThis does not affect errors on the basis of code which *appears* to be unreachable due to type analysis.\n\n- Released:\n\n  [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)\n\n### Allow Unused Labels - `allowUnusedLabels`\n\nWhen:\n\n- `undefined` (default) provide suggestions as warnings to editors\n- `true` unused labels are ignored\n- `false` raises compiler errors about unused labels\n\nLabels are very rare in JavaScript and typically indicate an attempt to write an object literal:\n\n``` ts\nfunction verifyAge(age: number) {\n  // Forgot 'return' statement\n  if (age > 18) {\n    verified: true;\n  }\n}\n```\n\n- Released:\n\n  [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)\n\n### Always Strict - `alwaysStrict`\n\nEnsures that your files are parsed in the ECMAScript strict mode, and emit “use strict” for each source file.\n\n[ECMAScript strict](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode) mode was introduced in ES5 and provides behavior tweaks to the runtime of the JavaScript engine to improve performance, and makes a set of errors throw instead of silently ignoring them.\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n- Released:\n\n  [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html)\n\n### Exact Optional Property Types - `exactOptionalPropertyTypes`\n\nWith exactOptionalPropertyTypes enabled, TypeScript applies stricter rules around how it handles properties on `type` or `interfaces` which have a `?` prefix.\n\nFor example, this interface declares that there is a property which can be one of two strings: ‘dark’ or ‘light’ or it should not be in the object.\n\n``` ts\ninterface UserDefaults {\n  // The absence of a value represents 'system'\n  colorThemeOverride?: \"dark\" | \"light\";\n}\n```\n\nWithout this flag enabled, there are three values which you can set `colorThemeOverride` to be: “dark”, “light” and `undefined`.\n\nSetting the value to `undefined` will allow most JavaScript runtime checks for the existence to fail, which is effectively falsy. However, this isn’t quite accurate; `colorThemeOverride: undefined` is not the same as `colorThemeOverride` not being defined. For example, `\"colorThemeOverride\" in settings` would have different behavior with `undefined` as the key compared to not being defined.\n\n`exactOptionalPropertyTypes` makes TypeScript truly enforce the definition provided as an optional property:\n\n``` ts\nconst settings = getUserSettings();\nsettings.colorThemeOverride = \"dark\";\nsettings.colorThemeOverride = \"light\";\n \n// But not:\nsettings.colorThemeOverride = undefined;\n```\n\n- Recommended\n\n- Released:\n\n  [4.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html)\n\n### No Fallthrough Cases In Switch - `noFallthroughCasesInSwitch`\n\nReport errors for fallthrough cases in switch statements. Ensures that any non-empty case inside a switch statement includes either `break`, `return`, or `throw`. This means you won’t accidentally ship a case fallthrough bug.\n\n``` ts\nconst a: number = 6;\n \nswitch (a) {\n  case 0:\n    console.log(\"even\");\n  case 1:\n    console.log(\"odd\");\n    break;\n}\n```\n\n- Released:\n\n  [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)\n\n### No Implicit Any - `noImplicitAny`\n\nIn some cases where no type annotations are present, TypeScript will fall back to a type of `any` for a variable when it cannot infer the type.\n\nThis can cause some errors to be missed, for example:\n\n``` ts\nfunction fn(s) {\n  // No error?\n  console.log(s.subtr(3));\n}\nfn(42);\n```\n\nTurning on `noImplicitAny` however TypeScript will issue an error whenever it would have inferred `any`:\n\n``` ts\nfunction fn(s) {\n  console.log(s.subtr(3));\n}\n```\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n### No Implicit Override - `noImplicitOverride`\n\nWhen working with classes which use inheritance, it’s possible for a sub-class to get “out of sync” with the functions it overloads when they are renamed in the base class.\n\nFor example, imagine you are modeling a music album syncing system:\n\n``` ts\nclass Album {\n  download() {\n    // Default behavior\n  }\n}\n \nclass SharedAlbum extends Album {\n  download() {\n    // Override to get info from many sources\n  }\n}\n```\n\nThen when you add support for machine-learning generated playlists, you refactor the `Album` class to have a ‘setup’ function instead:\n\n``` ts\nclass Album {\n  setup() {\n    // Default behavior\n  }\n}\n \nclass MLAlbum extends Album {\n  setup() {\n    // Override to get info from algorithm\n  }\n}\n \nclass SharedAlbum extends Album {\n  download() {\n    // Override to get info from many sources\n  }\n}\n```\n\nIn this case, TypeScript has provided no warning that `download` on `SharedAlbum` *expected* to override a function in the base class.\n\nUsing `noImplicitOverride` you can ensure that the sub-classes never go out of sync, by ensuring that functions which override include the keyword `override`.\n\nThe following example has `noImplicitOverride` enabled, and you can see the error received when `override` is missing:\n\n``` ts\nclass Album {\n  setup() {}\n}\n \nclass MLAlbum extends Album {\n  override setup() {}\n}\n \nclass SharedAlbum extends Album {\n  setup() {}\n}\n```\n\n- Released:\n\n  [4.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html)\n\n### No Implicit Returns - `noImplicitReturns`\n\nWhen enabled, TypeScript will check all code paths in a function to ensure they return a value.\n\n``` ts\nfunction lookupHeadphonesManufacturer(color: \"blue\" | \"black\"): string {\n  if (color === \"blue\") {\n    return \"beats\";\n  } else {\n    (\"bose\");\n  }\n}\n```\n\n- Released:\n\n  [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)\n\n### No Implicit This - `noImplicitThis`\n\nRaise error on ‘this’ expressions with an implied ‘any’ type.\n\nFor example, the class below returns a function which tries to access `this.width` and `this.height` – but the context for `this` inside the function inside `getAreaFunction` is not the instance of the Rectangle.\n\n``` ts\nclass Rectangle {\n  width: number;\n  height: number;\n \n  constructor(width: number, height: number) {\n    this.width = width;\n    this.height = height;\n  }\n \n  getAreaFunction() {\n    return function () {\n      return this.width * this.height;\n    };\n  }\n}\n```\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### No Property Access From Index Signature - `noPropertyAccessFromIndexSignature`\n\nThis setting ensures consistency between accessing a field via the “dot” (`obj.key`) syntax, and “indexed” (`obj[\"key\"]`) and the way which the property is declared in the type.\n\nWithout this flag, TypeScript will allow you to use the dot syntax to access fields which are not defined:\n\n``` ts\ninterface GameSettings {\n  // Known up-front properties\n  speed: \"fast\" | \"medium\" | \"slow\";\n  quality: \"high\" | \"low\";\n \n  // Assume anything unknown to the interface\n  // is a string.\n  [key: string]: string;\n}\n \nconst settings = getSettings();\nsettings.speed;\nsettings.quality;\n \n// Unknown key accessors are allowed on\n// this object, and are `string`\nsettings.username;\n```\n\nTurning the flag on will raise an error because the unknown field uses dot syntax instead of indexed syntax.\n\n``` ts\nconst settings = getSettings();\nsettings.speed;\nsettings.quality;\n \n// This would need to be settings[\"username\"];\nsettings.username;\n```\n\nThe goal of this flag is to signal intent in your calling syntax about how certain you are this property exists.\n\n- Released:\n\n  [4.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html)\n\n### No Unchecked Indexed Access - `noUncheckedIndexedAccess`\n\nTypeScript has a way to describe objects which have unknown keys but known values on an object, via index signatures.\n\n``` ts\ninterface EnvironmentVars {\n  NAME: string;\n  OS: string;\n \n  // Unknown properties are covered by this index signature.\n  [propName: string]: string;\n}\n \ndeclare const env: EnvironmentVars;\n \n// Declared as existing\nconst sysName = env.NAME;\nconst os = env.OS;\n \n// Not declared, but because of the index\n// signature, then it is considered a string\nconst nodeEnv = env.NODE_ENV;\n```\n\nTurning on `noUncheckedIndexedAccess` will add `undefined` to any un-declared field in the type.\n\n``` ts\ndeclare const env: EnvironmentVars;\n \n// Declared as existing\nconst sysName = env.NAME;\nconst os = env.OS;\n \n// Not declared, but because of the index\n// signature, then it is considered a string\nconst nodeEnv = env.NODE_ENV;\n```\n\n- Released:\n\n  [4.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html)\n\n### No Unused Locals - `noUnusedLocals`\n\nReport errors on unused local variables.\n\n``` ts\nconst createKeyboard = (modelID: number) => {\n  const defaultModelID = 23;\n  return { type: \"keyboard\", modelID };\n};\n```\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### No Unused Parameters - `noUnusedParameters`\n\nReport errors on unused parameters in functions.\n\n``` ts\nconst createDefaultKeyboard = (modelID: number) => {\n  const defaultModelID = 23;\n  return { type: \"keyboard\", modelID: defaultModelID };\n};\n```\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### Strict - `strict`\n\nThe `strict` flag enables a wide range of type checking behavior that results in stronger guarantees of program correctness. Turning this on is equivalent to enabling all of the *strict mode family* options, which are outlined below. You can then turn off individual strict mode family checks as needed.\n\nFuture versions of TypeScript may introduce additional stricter checking under this flag, so upgrades of TypeScript might result in new type errors in your program. When appropriate and possible, a corresponding flag will be added to disable that behavior.\n\n- Recommended\n\n- Related:\n  - [`alwaysStrict`](#alwaysStrict)\n\n  - [`strictNullChecks`](#strictNullChecks)\n\n  - [`strictBindCallApply`](#strictBindCallApply)\n\n  - [`strictFunctionTypes`](#strictFunctionTypes)\n\n  - [`strictPropertyInitialization`](#strictPropertyInitialization)\n\n  - [`noImplicitAny`](#noImplicitAny)\n\n  - [`noImplicitThis`](#noImplicitThis)\n\n  - [`useUnknownInCatchVariables`](#useUnknownInCatchVariables)\n\n- Released:\n\n  [2.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html)\n\n### Strict Bind Call Apply - `strictBindCallApply`\n\nWhen set, TypeScript will check that the built-in methods of functions `call`, `bind`, and `apply` are invoked with correct argument for the underlying function:\n\n``` ts\n// With strictBindCallApply on\nfunction fn(x: string) {\n  return parseInt(x);\n}\n \nconst n1 = fn.call(undefined, \"10\");\n \nconst n2 = fn.call(undefined, false);\n```\n\nOtherwise, these functions accept any arguments and will return `any`:\n\n``` ts\n// With strictBindCallApply off\nfunction fn(x: string) {\n  return parseInt(x);\n}\n \n// Note: No error; return type is 'any'\nconst n = fn.call(undefined, false);\n```\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n- Released:\n\n  [3.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html)\n\n### Strict Function Types - `strictFunctionTypes`\n\nWhen enabled, this flag causes functions parameters to be checked more correctly.\n\nHere’s a basic example with `strictFunctionTypes` off:\n\n``` ts\nfunction fn(x: string) {\n  console.log(\"Hello, \" + x.toLowerCase());\n}\n \ntype StringOrNumberFunc = (ns: string | number) => void;\n \n// Unsafe assignment\nlet func: StringOrNumberFunc = fn;\n// Unsafe call - will crash\nfunc(10);\n```\n\nWith `strictFunctionTypes` *on*, the error is correctly detected:\n\n``` ts\nfunction fn(x: string) {\n  console.log(\"Hello, \" + x.toLowerCase());\n}\n \ntype StringOrNumberFunc = (ns: string | number) => void;\n \n// Unsafe assignment is prevented\nlet func: StringOrNumberFunc = fn;\n```\n\nDuring development of this feature, we discovered a large number of inherently unsafe class hierarchies, including some in the DOM. Because of this, the setting only applies to functions written in *function* syntax, not to those in *method* syntax:\n\n``` ts\ntype Methodish = {\n  func(x: string | number): void;\n};\n \nfunction fn(x: string) {\n  console.log(\"Hello, \" + x.toLowerCase());\n}\n \n// Ultimately an unsafe assignment, but not detected\nconst m: Methodish = {\n  func: fn,\n};\nm.func(10);\n```\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n- Released:\n\n  [2.6](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html)\n\n### Strict Null Checks - `strictNullChecks`\n\nWhen `strictNullChecks` is `false`, `null` and `undefined` are effectively ignored by the language. This can lead to unexpected errors at runtime.\n\nWhen `strictNullChecks` is `true`, `null` and `undefined` have their own distinct types and you’ll get a type error if you try to use them where a concrete value is expected.\n\nFor example with this TypeScript code, `users.find` has no guarantee that it will actually find a user, but you can write code as though it will:\n\n``` ts\ndeclare const loggedInUsername: string;\n \nconst users = [\n  { name: \"Oby\", age: 12 },\n  { name: \"Heera\", age: 32 },\n];\n \nconst loggedInUser = users.find((u) => u.name === loggedInUsername);\nconsole.log(loggedInUser.age);\n```\n\nSetting `strictNullChecks` to `true` will raise an error that you have not made a guarantee that the `loggedInUser` exists before trying to use it.\n\n``` ts\ndeclare const loggedInUsername: string;\n \nconst users = [\n  { name: \"Oby\", age: 12 },\n  { name: \"Heera\", age: 32 },\n];\n \nconst loggedInUser = users.find((u) => u.name === loggedInUsername);\nconsole.log(loggedInUser.age);\n```\n\nThe second example failed because the array’s `find` function looks a bit like this simplification:\n\n``` ts\n// When strictNullChecks: true\ntype Array = {\n  find(predicate: (value: any, index: number) => boolean): S | undefined;\n};\n\n// When strictNullChecks: false the undefined is removed from the type system,\n// allowing you to write code which assumes it always found a result\ntype Array = {\n  find(predicate: (value: any, index: number) => boolean): S;\n};\n```\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### Strict Property Initialization - `strictPropertyInitialization`\n\nWhen set to true, TypeScript will raise an error when a class property was declared but not set in the constructor.\n\n``` ts\nclass UserAccount {\n  name: string;\n  accountType = \"user\";\n \n  email: string;\n  address: string | undefined;\n \n  constructor(name: string) {\n    this.name = name;\n    // Note that this.email is not set\n  }\n}\n```\n\nIn the above case:\n\n- `this.name` is set specifically.\n- `this.accountType` is set by default.\n- `this.email` is not set and raises an error.\n- `this.address` is declared as potentially `undefined` which means it does not have to be set.\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n- Released:\n\n  [2.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html)\n\n### Use Unknown In Catch Variables - `useUnknownInCatchVariables`\n\nIn TypeScript 4.0, support was added to allow changing the type of the variable in a catch clause from `any` to `unknown`. Allowing for code like:\n\n``` ts\ntry {\n  // ...\n} catch (err: unknown) {\n  // We have to verify err is an\n  // error before using it as one.\n  if (err instanceof Error) {\n    console.log(err.message);\n  }\n}\n```\n\nThis pattern ensures that error handling code becomes more comprehensive because you cannot guarantee that the object being thrown *is* a Error subclass ahead of time. With the flag `useUnknownInCatchVariables` enabled, then you do not need the additional syntax (`: unknown`) nor a linter rule to try enforce this behavior.\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n- Released:\n\n  [4.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html)\n\n## Modules\n\n### Allow Arbitrary Extensions - `allowArbitraryExtensions`\n\nIn TypeScript 5.0, when an import path ends in an extension that isn’t a known JavaScript or TypeScript file extension, the compiler will look for a declaration file for that path in the form of `{file basename}.d.{extension}.ts`. For example, if you are using a CSS loader in a bundler project, you might want to write (or generate) declaration files for those stylesheets:\n\n``` css\n/* app.css */\n.cookie-banner {\n  display: none;\n}\n```\n\n``` ts\n// app.d.css.ts\ndeclare const css: {\n  cookieBanner: string;\n};\nexport default css;\n```\n\n``` ts\n// App.tsx\nimport styles from \"./app.css\";\n\nstyles.cookieBanner; // string\n```\n\nBy default, this import will raise an error to let you know that TypeScript doesn’t understand this file type and your runtime might not support importing it. But if you’ve configured your runtime or bundler to handle it, you can suppress the error with the new `--allowArbitraryExtensions` compiler option.\n\nNote that historically, a similar effect has often been achievable by adding a declaration file named `app.css.d.ts` instead of `app.d.css.ts` - however, this just worked through Node’s `require` resolution rules for CommonJS. Strictly speaking, the former is interpreted as a declaration file for a JavaScript file named `app.css.js`. Because relative files imports need to include extensions in Node’s ESM support, TypeScript would error on our example in an ESM file under `--moduleResolution node16` or `nodenext`.\n\nFor more information, read up [the proposal for this feature](https://github.com/microsoft/TypeScript/issues/50133) and [its corresponding pull request](https://github.com/microsoft/TypeScript/pull/51435).\n\n### Allow Importing TS Extensions - `allowImportingTsExtensions`\n\n`--allowImportingTsExtensions` allows TypeScript files to import each other with a TypeScript-specific extension like `.ts`, `.mts`, or `.tsx`.\n\nThis flag is only allowed when `--noEmit` or `--emitDeclarationOnly` is enabled, since these import paths would not be resolvable at runtime in JavaScript output files. The expectation here is that your resolver (e.g. your bundler, a runtime, or some other tool) is going to make these imports between `.ts` files work.\n\n### Allow Umd Global Access - `allowUmdGlobalAccess`\n\nWhen set to true, `allowUmdGlobalAccess` lets you access UMD exports as globals from inside module files. A module file is a file that has imports and/or exports. Without this flag, using an export from a UMD module requires an import declaration.\n\nAn example use case for this flag would be a web project where you know the particular library (like jQuery or Lodash) will always be available at runtime, but you can’t access it with an import.\n\n- Released:\n\n  [3.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html)\n\n### Base URL - `baseUrl`\n\nSets a base directory from which to resolve bare specifier module names. For example, in the directory structure:\n\n``` typescript\nproject\n├── ex.ts\n├── hello\n│   └── world.ts\n└── tsconfig.json\n```\n\nWith `\"baseUrl\": \"./\"`, TypeScript will look for files starting at the same folder as the `tsconfig.json`:\n\n``` ts\nimport { helloWorld } from \"hello/world\";\n\nconsole.log(helloWorld);\n```\n\nThis resolution has higher priority than lookups from `node_modules`.\n\nThis feature was designed for use in conjunction with AMD module loaders in the browser, and is not recommended in any other context. As of TypeScript 4.1, `baseUrl` is no longer required to be set when using [`paths`](#paths).\n\n### Custom Conditions - `customConditions`\n\n`--customConditions` takes a list of additional [conditions](https://nodejs.org/api/packages.html#nested-conditions) that should succeed when TypeScript resolves from an [`exports`](https://nodejs.org/api/packages.html#exports) or [`imports`](https://nodejs.org/api/packages.html#imports) field of a `package.json`. These conditions are added to whatever existing conditions a resolver will use by default.\n\nFor example, when this field is set in a `tsconfig.json` as so:\n\n``` jsonc\n{\n  \"compilerOptions\": {\n    \"target\": \"es2022\",\n    \"moduleResolution\": \"bundler\",\n    \"customConditions\": [\"my-condition\"]\n  }\n}\n```\n\nAny time an `exports` or `imports` field is referenced in `package.json`, TypeScript will consider conditions called `my-condition`.\n\nSo when importing from a package with the following `package.json`\n\n``` jsonc\n{\n  // ...\n  \"exports\": {\n    \".\": {\n      \"my-condition\": \"./foo.mjs\",\n      \"node\": \"./bar.mjs\",\n      \"import\": \"./baz.mjs\",\n      \"require\": \"./biz.mjs\"\n    }\n  }\n}\n```\n\nTypeScript will try to look for files corresponding to `foo.mjs`.\n\nThis field is only valid under the `node16`, `nodenext`, and `bundler` options for [`--moduleResolution`](#moduleResolution).\n\n- Related:\n  - [`moduleResolution`](#moduleResolution)\n\n  - [`resolvePackageJsonExports`](#resolvePackageJsonExports)\n\n  - [`resolvePackageJsonImports`](#resolvePackageJsonImports)\n\n### Module - `module`\n\nSets the module system for the program. See the [theory behind TypeScript’s `module` option](../docs/handbook/modules/theory#the-module-output-format) and [its reference page](../docs/handbook/modules/reference#the-module-compiler-option) for more information. You very likely want `\"nodenext\"` for modern Node.js projects and `preserve` or `esnext` for code that will be bundled.\n\nChanging `module` affects [`moduleResolution`](#moduleResolution) which [also has a reference page](../docs/handbook/modules/reference#the-moduleresolution-compiler-option).\n\nHere’s some example output for this file:\n\n``` ts\n// @filename: index.ts\nimport { valueOfPi } from \"./constants\";\n \nexport const twoPi = valueOfPi * 2;\n```\n\n#### `CommonJS`\n\n``` ts\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.twoPi = void 0;\nconst constants_1 = require(\"./constants\");\nexports.twoPi = constants_1.valueOfPi * 2;\n \n```\n\n#### `UMD`\n\n``` ts\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./constants\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.twoPi = void 0;\n    const constants_1 = require(\"./constants\");\n    exports.twoPi = constants_1.valueOfPi * 2;\n});\n \n```\n\n#### `AMD`\n\n``` ts\ndefine([\"require\", \"exports\", \"./constants\"], function (require, exports, constants_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.twoPi = void 0;\n    exports.twoPi = constants_1.valueOfPi * 2;\n});\n \n```\n\n#### `System`\n\n``` ts\nSystem.register([\"./constants\"], function (exports_1, context_1) {\n    \"use strict\";\n    var constants_1, twoPi;\n    var __moduleName = context_1 && context_1.id;\n    return {\n        setters: [\n            function (constants_1_1) {\n                constants_1 = constants_1_1;\n            }\n        ],\n        execute: function () {\n            exports_1(\"twoPi\", twoPi = constants_1.valueOfPi * 2);\n        }\n    };\n});\n \n```\n\n#### `ESNext`\n\n``` ts\nimport { valueOfPi } from \"./constants\";\nexport const twoPi = valueOfPi * 2;\n \n```\n\n#### `ES2015`/`ES6`/`ES2020`/`ES2022`\n\n``` ts\nimport { valueOfPi } from \"./constants\";\nexport const twoPi = valueOfPi * 2;\n \n```\n\nIn addition to the base functionality of `ES2015`/`ES6`, `ES2020` adds support for [dynamic `import`s](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import), and [`import.meta`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta) while `ES2022` further adds support for [top level `await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#top_level_await).\n\n#### `node16`/`nodenext`\n\nAvailable from 4.7+, the `node16` and `nodenext` modes integrate with Node’s [native ECMAScript Module support](https://nodejs.org/api/esm.html). The emitted JavaScript uses either `CommonJS` or `ES2020` output depending on the file extension and the value of the `type` setting in the nearest `package.json`. Module resolution also works differently. You can learn more in the [handbook](../docs/handbook/modules/reference#node16-nodenext) and [Modules Reference](../docs/handbook/modules/reference#node16-nodenext).\n\n#### `preserve`\n\nIn `--module preserve` ([added](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-bundler-and---module-preserve) in TypeScript 5.4), ECMAScript imports and exports written in input files are preserved in the output, and CommonJS-style `import x = require(\"...\")` and `export = ...` statements are emitted as CommonJS `require` and `module.exports`. In other words, the format of each individual import or export statement is preserved, rather than being coerced into a single format for the whole compilation (or even a whole file).\n\n``` ts\nimport { valueOfPi } from \"./constants\";\nconst constants = require(\"./constants\");\nexport const piSquared = valueOfPi * constants.valueOfPi;\n \n```\n\nWhile it’s rare to need to mix imports and require calls in the same file, this `module` mode best reflects the capabilities of most modern bundlers, as well as the Bun runtime.\n\n> Why care about TypeScript’s `module` emit with a bundler or with Bun, where you’re likely also setting `noEmit`? TypeScript’s type checking and module resolution behavior are affected by the module format that it *would* emit. Setting `module` gives TypeScript information about how your bundler or runtime will process imports and exports, which ensures that the types you see on imported values accurately reflect what will happen at runtime or after bundling.\n\n#### `None`\n\n``` ts\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.twoPi = void 0;\nconst constants_1 = require(\"./constants\");\nexports.twoPi = constants_1.valueOfPi * 2;\n \n```\n\n- Default:\n\n  `CommonJS` if [`target`](#target) is `ES3` or `ES5`; `ES6`/`ES2015` otherwise.\n\n- Allowed:\n  - `none`\n\n  - `commonjs`\n\n  - `amd`\n\n  - `umd`\n\n  - `system`\n\n  - `es6`/`es2015`\n\n  - `es2020`\n\n  - `es2022`\n\n  - `esnext`\n\n  - `node16`\n\n  - `nodenext`\n\n  - `preserve`\n\n- Related:\n  - [`moduleResolution`](#moduleResolution)\n\n  - [`esModuleInterop`](#esModuleInterop)\n\n  - [`allowImportingTsExtensions`](#allowImportingTsExtensions)\n\n  - [`allowArbitraryExtensions`](#allowArbitraryExtensions)\n\n  - [`resolveJsonModule`](#resolveJsonModule)\n\n- Released:\n\n  [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)\n\n### Module Resolution - `moduleResolution`\n\nSpecify the module resolution strategy:\n\n- `'node16'` or `'nodenext'` for modern versions of Node.js. Node.js v12 and later supports both ECMAScript imports and CommonJS `require`, which resolve using different algorithms. These `moduleResolution` values, when combined with the corresponding [`module`](#module) values, picks the right algorithm for each resolution based on whether Node.js will see an `import` or `require` in the output JavaScript code.\n- `'node10'` (previously called `'node'`) for Node.js versions older than v10, which only support CommonJS `require`. You probably won’t need to use `node10` in modern code.\n- `'bundler'` for use with bundlers. Like `node16` and `nodenext`, this mode supports package.json `\"imports\"` and `\"exports\"`, but unlike the Node.js resolution modes, `bundler` never requires file extensions on relative paths in imports.\n- `'classic'` was used in TypeScript before the release of 1.6. `classic` should not be used.\n\nThere are reference pages explaining the [theory behind TypeScript’s module resolution](../docs/handbook/modules/theory#module-resolution) and the [details of each option](../docs/handbook/modules/reference#the-moduleresolution-compiler-option).\n\n- Default:\n\n  `Classic` if [`module`](#module) is `AMD`, `UMD`, `System`, or `ES6`/`ES2015`; Matches if [`module`](#module) is `node16` or `nodenext`; `Node` otherwise.\n\n- Allowed:\n  - `classic`\n\n  - `node10`/`node`\n\n  - `node16`\n\n  - `nodenext`\n\n  - `bundler`\n\n- Related:\n  - [`module`](#module)\n\n  - [`paths`](#paths)\n\n  - [`baseUrl`](#baseUrl)\n\n  - [`rootDirs`](#rootDirs)\n\n  - [`moduleSuffixes`](#moduleSuffixes)\n\n  - [`customConditions`](#customConditions)\n\n  - [`resolvePackageJsonExports`](#resolvePackageJsonExports)\n\n  - [`resolvePackageJsonImports`](#resolvePackageJsonImports)\n\n### Module Suffixes - `moduleSuffixes`\n\nProvides a way to override the default list of file name suffixes to search when resolving a module.\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"moduleSuffixes\": [\".ios\", \".native\", \"\"]\n  }\n}\n```\n\nGiven the above configuration, an import like the following:\n\n``` ts\nimport * as foo from \"./foo\";\n```\n\nTypeScript will look for the relative files `./foo.ios.ts`, `./foo.native.ts`, and finally `./foo.ts`.\n\nNote the empty string `\"\"` in [`moduleSuffixes`](#moduleSuffixes) which is necessary for TypeScript to also look-up `./foo.ts`.\n\nThis feature can be useful for React Native projects where each target platform can use a separate tsconfig.json with differing `moduleSuffixes`.\n\n- Released:\n\n  [4.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html)\n\n### No Resolve - `noResolve`\n\nBy default, TypeScript will examine the initial set of files for `import` and `<reference` directives and add these resolved files to your program.\n\nIf `noResolve` is set, this process doesn’t happen. However, `import` statements are still checked to see if they resolve to a valid module, so you’ll need to make sure this is satisfied by some other means.\n\n### Paths - `paths`\n\nA series of entries which re-map imports to lookup locations relative to the [`baseUrl`](#baseUrl) if set, or to the tsconfig file itself otherwise. There is a larger coverage of `paths` in [the `moduleResolution` reference page](../docs/handbook/modules/reference#paths).\n\n`paths` lets you declare how TypeScript should resolve an import in your `require`/`import`s.\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"jquery\": [\"./vendor/jquery/dist/jquery\"]\n    }\n  }\n}\n```\n\nThis would allow you to be able to write `import \"jquery\"`, and get all of the correct typing locally.\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"paths\": {\n        \"app/*\": [\"./src/app/*\"],\n        \"config/*\": [\"./src/app/_config/*\"],\n        \"environment/*\": [\"./src/environments/*\"],\n        \"shared/*\": [\"./src/app/_shared/*\"],\n        \"helpers/*\": [\"./src/helpers/*\"],\n        \"tests/*\": [\"./src/tests/*\"]\n    },\n}\n```\n\nIn this case, you can tell the TypeScript file resolver to support a number of custom prefixes to find code.\n\nNote that this feature does not change how import paths are emitted by `tsc`, so `paths` should only be used to inform TypeScript that another tool has this mapping and will use it at runtime or when bundling.\n\n### Resolve JSON Module - `resolveJsonModule`\n\nAllows importing modules with a `.json` extension, which is a common practice in node projects. This includes generating a type for the `import` based on the static JSON shape.\n\nTypeScript does not support resolving JSON files by default:\n\n``` ts\n// @filename: settings.json\n{\n    \"repo\": \"TypeScript\",\n    \"dry\": false,\n    \"debug\": false\n}\n// @filename: index.ts\nimport settings from \"./settings.json\";\n \nsettings.debug === true;\nsettings.dry === 2;\n```\n\nEnabling the option allows importing JSON, and validating the types in that JSON file.\n\n``` ts\n// @filename: settings.json\n{\n    \"repo\": \"TypeScript\",\n    \"dry\": false,\n    \"debug\": false\n}\n// @filename: index.ts\nimport settings from \"./settings.json\";\n \nsettings.debug === true;\nsettings.dry === 2;\n```\n\n### Resolve package.json Exports - `resolvePackageJsonExports`\n\n`--resolvePackageJsonExports` forces TypeScript to consult [the `exports` field of `package.json` files](https://nodejs.org/api/packages.html#exports) if it ever reads from a package in `node_modules`.\n\nThis option defaults to `true` under the `node16`, `nodenext`, and `bundler` options for [`--moduleResolution`](#moduleResolution).\n\n- Default:\n\n  `true` when [`moduleResolution`](#moduleResolution) is `node16`, `nodenext`, or `bundler`; otherwise `false`\n\n- Related:\n  - [`moduleResolution`](#moduleResolution)\n\n  - [`customConditions`](#customConditions)\n\n  - [`resolvePackageJsonImports`](#resolvePackageJsonImports)\n\n### Resolve package.json Imports - `resolvePackageJsonImports`\n\n`--resolvePackageJsonImports` forces TypeScript to consult [the `imports` field of `package.json` files](https://nodejs.org/api/packages.html#imports) when performing a lookup that starts with `#` from a file whose ancestor directory contains a `package.json`.\n\nThis option defaults to `true` under the `node16`, `nodenext`, and `bundler` options for [`--moduleResolution`](#moduleResolution).\n\n- Default:\n\n  `true` when [`moduleResolution`](#moduleResolution) is `node16`, `nodenext`, or `bundler`; otherwise `false`\n\n- Related:\n  - [`moduleResolution`](#moduleResolution)\n\n  - [`customConditions`](#customConditions)\n\n  - [`resolvePackageJsonExports`](#resolvePackageJsonExports)\n\n### Root Dir - `rootDir`\n\n**Default**: The longest common path of all non-declaration input files. If [`composite`](#composite) is set, the default is instead the directory containing the `tsconfig.json` file.\n\nWhen TypeScript compiles files, it keeps the same directory structure in the output directory as exists in the input directory.\n\nFor example, let’s say you have some input files:\n\n``` typescript\nMyProj\n├── tsconfig.json\n├── core\n│   ├── a.ts\n│   ├── b.ts\n│   ├── sub\n│   │   ├── c.ts\n├── types.d.ts\n```\n\nThe inferred value for `rootDir` is the longest common path of all non-declaration input files, which in this case is `core/`.\n\nIf your [`outDir`](#outDir) was `dist`, TypeScript would write this tree:\n\n``` typescript\nMyProj\n├── dist\n│   ├── a.js\n│   ├── b.js\n│   ├── sub\n│   │   ├── c.js\n```\n\nHowever, you may have intended for `core` to be part of the output directory structure. By setting `rootDir: \".\"` in `tsconfig.json`, TypeScript would write this tree:\n\n``` typescript\nMyProj\n├── dist\n│   ├── core\n│   │   ├── a.js\n│   │   ├── b.js\n│   │   ├── sub\n│   │   │   ├── c.js\n```\n\nImportantly, `rootDir` **does not affect which files become part of the compilation**. It has no interaction with the [`include`](#include), [`exclude`](#exclude), or [`files`](#files) `tsconfig.json` settings.\n\nNote that TypeScript will never write an output file to a directory outside of [`outDir`](#outDir), and will never skip emitting a file. For this reason, `rootDir` also enforces that all files which need to be emitted are underneath the `rootDir` path.\n\nFor example, let’s say you had this tree:\n\n``` typescript\nMyProj\n├── tsconfig.json\n├── core\n│   ├── a.ts\n│   ├── b.ts\n├── helpers.ts\n```\n\nIt would be an error to specify `rootDir` as `core` *and* [`include`](#include) as `*` because it creates a file (`helpers.ts`) that would need to be emitted *outside* the [`outDir`](#outDir) (i.e. `../helpers.js`).\n\n- Default:\n\n  Computed from the list of input files.\n\n- Released:\n\n  [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)\n\n### Root Dirs - `rootDirs`\n\nUsing `rootDirs`, you can inform the compiler that there are many “virtual” directories acting as a single root. This allows the compiler to resolve relative module imports within these “virtual” directories, as if they were merged in to one directory.\n\nFor example:\n\n``` typescript\n src\n └── views\n     └── view1.ts (can import \"./template1\", \"./view2`)\n     └── view2.ts (can import \"./template1\", \"./view1`)\n\n generated\n └── templates\n         └── views\n             └── template1.ts (can import \"./view1\", \"./view2\")\n```\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src/views\", \"generated/templates/views\"]\n  }\n}\n```\n\nThis does not affect how TypeScript emits JavaScript, it only emulates the assumption that they will be able to work via those relative paths at runtime.\n\n`rootDirs` can be used to provide a separate “type layer” to files that are not TypeScript or JavaScript by providing a home for generated `.d.ts` files in another folder. This technique is useful for bundled applications where you use `import` of files that aren’t necessarily code:\n\n``` shell\n src\n └── index.ts\n └── css\n     └── main.css\n     └── navigation.css\n\n generated\n └── css\n     └── main.css.d.ts\n     └── navigation.css.d.ts\n```\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src\", \"generated\"]\n  }\n}\n```\n\nThis technique lets you generate types ahead of time for the non-code source files. Imports then work naturally based off the source file’s location. For example `./src/index.ts` can import the file `./src/css/main.css` and TypeScript will be aware of the bundler’s behavior for that filetype via the corresponding generated declaration file.\n\n``` ts\n// @filename: index.ts\nimport { appClass } from \"./main.css\";\n```\n\n- Default:\n\n  Computed from the list of input files.\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### Type Roots - `typeRoots`\n\nBy default all *visible* ”`@types`” packages are included in your compilation. Packages in `node_modules/@types` of any enclosing folder are considered *visible*. For example, that means packages within `./node_modules/@types/`, `../node_modules/@types/`, `../../node_modules/@types/`, and so on.\n\nIf `typeRoots` is specified, *only* packages under `typeRoots` will be included. For example:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"typeRoots\": [\"./typings\", \"./vendor/types\"]\n  }\n}\n```\n\nThis config file will include *all* packages under `./typings` and `./vendor/types`, and no packages from `./node_modules/@types`. All paths are relative to the `tsconfig.json`.\n\n- Related:\n  - [`types`](#types)\n\n### Types - `types`\n\nBy default all *visible* ”`@types`” packages are included in your compilation. Packages in `node_modules/@types` of any enclosing folder are considered *visible*. For example, that means packages within `./node_modules/@types/`, `../node_modules/@types/`, `../../node_modules/@types/`, and so on.\n\nIf `types` is specified, only packages listed will be included in the global scope. For instance:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"types\": [\"node\", \"jest\", \"express\"]\n  }\n}\n```\n\nThis `tsconfig.json` file will *only* include `./node_modules/@types/node`, `./node_modules/@types/jest` and `./node_modules/@types/express`. Other packages under `node_modules/@types/*` will not be included.\n\n### What does this affect?\n\nThis option does not affect how `@types/*` are included in your application code, for example if you had the above `compilerOptions` example with code like:\n\n``` ts\nimport * as moment from \"moment\";\n\nmoment().format(\"MMMM Do YYYY, h:mm:ss a\");\n```\n\nThe `moment` import would be fully typed.\n\nWhen you have this option set, by not including a module in the `types` array it:\n\n- Will not add globals to your project (e.g `process` in node, or `expect` in Jest)\n- Will not have exports appear as auto-import recommendations\n\nThis feature differs from [`typeRoots`](#typeRoots) in that it is about specifying only the exact types you want included, whereas [`typeRoots`](#typeRoots) supports saying you want particular folders.\n\n- Related:\n  - [`typeRoots`](#typeRoots)\n\n## Emit\n\n### Declaration - `declaration`\n\nGenerate `.d.ts` files for every TypeScript or JavaScript file inside your project. These `.d.ts` files are type definition files which describe the external API of your module. With `.d.ts` files, tools like TypeScript can provide intellisense and accurate types for un-typed code.\n\nWhen `declaration` is set to `true`, running the compiler with this TypeScript code:\n\n``` ts\nexport let helloWorld = \"hi\";\n```\n\nWill generate an `index.js` file like this:\n\n``` ts\nexport let helloWorld = \"hi\";\n \n```\n\nWith a corresponding `helloWorld.d.ts`:\n\n``` ts\nexport declare let helloWorld: string;\n \n```\n\nWhen working with `.d.ts` files for JavaScript files you may want to use [`emitDeclarationOnly`](#emitDeclarationOnly) or use [`outDir`](#outDir) to ensure that the JavaScript files are not overwritten.\n\n- Default:\n\n  `true` if [`composite`](#composite); `false` otherwise.\n\n- Related:\n  - [`declarationDir`](#declarationDir)\n\n  - [`emitDeclarationOnly`](#emitDeclarationOnly)\n\n- Released:\n\n  [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)\n\n### Declaration Dir - `declarationDir`\n\nOffers a way to configure the root directory for where declaration files are emitted.\n\n``` typescript\nexample\n├── index.ts\n├── package.json\n└── tsconfig.json\n```\n\nwith this `tsconfig.json`:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"declaration\": true,\n    \"declarationDir\": \"./types\"\n  }\n}\n```\n\nWould place the d.ts for the `index.ts` in a `types` folder:\n\n``` typescript\nexample\n├── index.js\n├── index.ts\n├── package.json\n├── tsconfig.json\n└── types\n    └── index.d.ts\n```\n\n- Related:\n  - [`declaration`](#declaration)\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### Declaration Map - `declarationMap`\n\nGenerates a source map for `.d.ts` files which map back to the original `.ts` source file. This will allow editors such as VS Code to go to the original `.ts` file when using features like *Go to Definition*.\n\nYou should strongly consider turning this on if you’re using project references.\n\n- Released:\n\n  [2.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html)\n\n### Downlevel Iteration - `downlevelIteration`\n\nDownleveling is TypeScript’s term for transpiling to an older version of JavaScript. This flag is to enable support for a more accurate implementation of how modern JavaScript iterates through new concepts in older JavaScript runtimes.\n\nECMAScript 6 added several new iteration primitives: the `for / of` loop (`for (el of arr)`), Array spread (`[a, ...b]`), argument spread (`fn(...args)`), and `Symbol.iterator`. `downlevelIteration` allows for these iteration primitives to be used more accurately in ES5 environments if a `Symbol.iterator` implementation is present.\n\n#### Example: Effects on `for / of`\n\nWith this TypeScript code:\n\n``` ts\nconst str = \"Hello!\";\nfor (const s of str) {\n  console.log(s);\n}\n```\n\nWithout `downlevelIteration` enabled, a `for / of` loop on any object is downleveled to a traditional `for` loop:\n\n``` ts\n\"use strict\";\nvar str = \"Hello!\";\nfor (var _i = 0, str_1 = str; _i < str_1.length; _i++) {\n    var s = str_1[_i];\n    console.log(s);\n}\n \n```\n\nThis is often what people expect, but it’s not 100% compliant with ECMAScript iteration protocol. Certain strings, such as emoji (😜), have a `.length` of 2 (or even more!), but should iterate as 1 unit in a `for-of` loop. See [this blog post by Jonathan New](https://blog.jonnew.com/posts/poo-dot-length-equals-two) for a longer explanation.\n\nWhen `downlevelIteration` is enabled, TypeScript will use a helper function that checks for a `Symbol.iterator` implementation (either native or polyfill). If this implementation is missing, you’ll fall back to index-based iteration.\n\n``` ts\n\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar e_1, _a;\nvar str = \"Hello!\";\ntry {\n    for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {\n        var s = str_1_1.value;\n        console.log(s);\n    }\n}\ncatch (e_1_1) { e_1 = { error: e_1_1 }; }\nfinally {\n    try {\n        if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);\n    }\n    finally { if (e_1) throw e_1.error; }\n}\n \n```\n\nYou can use [tslib](https://www.npmjs.com/package/tslib) via [`importHelpers`](#importHelpers) to reduce the amount of inline JavaScript too:\n\n``` ts\n\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar e_1, _a;\nvar str = \"Hello!\";\ntry {\n    for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {\n        var s = str_1_1.value;\n        console.log(s);\n    }\n}\ncatch (e_1_1) { e_1 = { error: e_1_1 }; }\nfinally {\n    try {\n        if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);\n    }\n    finally { if (e_1) throw e_1.error; }\n}\n \n```\n\n**Note:** enabling `downlevelIteration` does not improve compliance if `Symbol.iterator` is not present in the runtime.\n\n#### Example: Effects on Array Spreads\n\nThis is an array spread:\n\n``` js\n// Make a new array whose elements are 1 followed by the elements of arr2\nconst arr = [1, ...arr2];\n```\n\nBased on the description, it sounds easy to downlevel to ES5:\n\n``` js\n// The same, right?\nconst arr = [1].concat(arr2);\n```\n\nHowever, this is observably different in certain rare cases.\n\nFor example, if a source array is missing one or more items (contains a hole), the spread syntax will replace each empty item with `undefined`, whereas `.concat` will leave them intact.\n\n``` js\n// Make an array where the element at index 1 is missing\nlet arrayWithHole = [\"a\", , \"c\"];\nlet spread = [...arrayWithHole];\nlet concatenated = [].concat(arrayWithHole);\n\nconsole.log(arrayWithHole);\n// [ 'a', <1 empty item>, 'c' ]\nconsole.log(spread);\n// [ 'a', undefined, 'c' ]\nconsole.log(concatenated);\n// [ 'a', <1 empty item>, 'c' ]\n```\n\nJust as with `for / of`, `downlevelIteration` will use `Symbol.iterator` (if present) to more accurately emulate ES 6 behavior.\n\n- Related:\n  - [`importHelpers`](#importHelpers)\n\n- Released:\n\n  [2.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html)\n\n### Emit BOM - `emitBOM`\n\nControls whether TypeScript will emit a [byte order mark (BOM)](https://wikipedia.org/wiki/Byte_order_mark) when writing output files. Some runtime environments require a BOM to correctly interpret a JavaScript files; others require that it is not present. The default value of `false` is generally best unless you have a reason to change it.\n\n### Emit Declaration Only - `emitDeclarationOnly`\n\n*Only* emit `.d.ts` files; do not emit `.js` files.\n\nThis setting is useful in two cases:\n\n- You are using a transpiler other than TypeScript to generate your JavaScript.\n- You are using TypeScript to only generate `d.ts` files for your consumers.\n\n- Related:\n  - [`declaration`](#declaration)\n\n- Released:\n\n  [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html)\n\n### Import Helpers - `importHelpers`\n\nFor certain downleveling operations, TypeScript uses some helper code for operations like extending class, spreading arrays or objects, and async operations. By default, these helpers are inserted into files which use them. This can result in code duplication if the same helper is used in many different modules.\n\nIf the `importHelpers` flag is on, these helper functions are instead imported from the [tslib](https://www.npmjs.com/package/tslib) module. You will need to ensure that the `tslib` module is able to be imported at runtime. This only affects modules; global script files will not attempt to import modules.\n\nFor example, with this TypeScript:\n\n``` ts\nexport function fn(arr: number[]) {\n  const arr2 = [1, ...arr];\n}\n```\n\nTurning on [`downlevelIteration`](#downlevelIteration) and `importHelpers` is still false:\n\n``` ts\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nexport function fn(arr) {\n    var arr2 = __spreadArray([1], __read(arr), false);\n}\n \n```\n\nThen turning on both [`downlevelIteration`](#downlevelIteration) and `importHelpers`:\n\n``` ts\nimport { __read, __spreadArray } from \"tslib\";\nexport function fn(arr) {\n    var arr2 = __spreadArray([1], __read(arr), false);\n}\n \n```\n\nYou can use [`noEmitHelpers`](#noEmitHelpers) when you provide your own implementations of these functions.\n\n- Related:\n  - [`noEmitHelpers`](#noEmitHelpers)\n\n  - [`downlevelIteration`](#downlevelIteration)\n\n### Inline Source Map - `inlineSourceMap`\n\nWhen set, instead of writing out a `.js.map` file to provide source maps, TypeScript will embed the source map content in the `.js` files. Although this results in larger JS files, it can be convenient in some scenarios. For example, you might want to debug JS files on a webserver that doesn’t allow `.map` files to be served.\n\nMutually exclusive with [`sourceMap`](#sourceMap).\n\nFor example, with this TypeScript:\n\n``` ts\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n```\n\nConverts to this JavaScript:\n\n``` ts\n\"use strict\";\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n \n```\n\nThen enable building it with `inlineSourceMap` enabled there is a comment at the bottom of the file which includes a source-map for the file.\n\n``` ts\n\"use strict\";\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMifQ==\n```\n\n- Released:\n\n  [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)\n\n### Inline Sources - `inlineSources`\n\nWhen set, TypeScript will include the original content of the `.ts` file as an embedded string in the source map (using the source map’s `sourcesContent` property). This is often useful in the same cases as [`inlineSourceMap`](#inlineSourceMap).\n\nRequires either [`sourceMap`](#sourceMap) or [`inlineSourceMap`](#inlineSourceMap) to be set.\n\nFor example, with this TypeScript:\n\n``` ts\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n```\n\nBy default converts to this JavaScript:\n\n``` ts\n\"use strict\";\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n \n```\n\nThen enable building it with `inlineSources` and [`inlineSourceMap`](#inlineSourceMap) enabled there is a comment at the bottom of the file which includes a source-map for the file. Note that the end is different from the example in [`inlineSourceMap`](#inlineSourceMap) because the source-map now contains the original source code also.\n\n``` ts\n\"use strict\";\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoZWxsb1dvcmxkID0gXCJoaVwiO1xuY29uc29sZS5sb2coaGVsbG9Xb3JsZCk7Il19\n```\n\n- Released:\n\n  [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)\n\n### Map Root - `mapRoot`\n\nSpecify the location where debugger should locate map files instead of generated locations. This string is treated verbatim inside the source-map, for example:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"sourceMap\": true,\n    \"mapRoot\": \"https://my-website.com/debug/sourcemaps/\"\n  }\n}\n```\n\nWould declare that `index.js` will have sourcemaps at `https://my-website.com/debug/sourcemaps/index.js.map`.\n\n### New Line - `newLine`\n\nSpecify the end of line sequence to be used when emitting files: ‘CRLF’ (dos) or ‘LF’ (unix).\n\n- Default:\n\n  `lf`\n\n- Allowed:\n  - `crlf`\n\n  - `lf`\n\n- Released:\n\n  [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)\n\n### No Emit - `noEmit`\n\nDo not emit compiler output files like JavaScript source code, source-maps or declarations.\n\nThis makes room for another tool like [Babel](https://babeljs.io), or [swc](https://github.com/swc-project/swc) to handle converting the TypeScript file to a file which can run inside a JavaScript environment.\n\nYou can then use TypeScript as a tool for providing editor integration, and as a source code type-checker.\n\n### No Emit Helpers - `noEmitHelpers`\n\nInstead of importing helpers with [`importHelpers`](#importHelpers), you can provide implementations in the global scope for the helpers you use and completely turn off emitting of helper functions.\n\nFor example, using this `async` function in ES5 requires a `await`-like function and `generator`-like function to run:\n\n``` ts\nconst getAPI = async (url: string) => {\n  // Get API\n  return {};\n};\n```\n\nWhich creates quite a lot of JavaScript:\n\n``` ts\n\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n        // Get API\n        return [2 /*return*/, {}];\n    });\n}); };\n \n```\n\nWhich can be switched out with your own globals via this flag:\n\n``` ts\n\"use strict\";\nvar getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n        // Get API\n        return [2 /*return*/, {}];\n    });\n}); };\n \n```\n\n- Related:\n  - [`importHelpers`](#importHelpers)\n\n- Released:\n\n  [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)\n\n### No Emit On Error - `noEmitOnError`\n\nDo not emit compiler output files like JavaScript source code, source-maps or declarations if any errors were reported.\n\nThis defaults to `false`, making it easier to work with TypeScript in a watch-like environment where you may want to see results of changes to your code in another environment before making sure all errors are resolved.\n\n- Released:\n\n  [1.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html)\n\n### Out Dir - `outDir`\n\nIf specified, `.js` (as well as `.d.ts`, `.js.map`, etc.) files will be emitted into this directory. The directory structure of the original source files is preserved; see [`rootDir`](#rootDir) if the computed root is not what you intended.\n\nIf not specified, `.js` files will be emitted in the same directory as the `.ts` files they were generated from:\n\n``` shell\n$ tsc\n\nexample\n├── index.js\n└── index.ts\n```\n\nWith a `tsconfig.json` like this:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"outDir\": \"dist\"\n  }\n}\n```\n\nRunning `tsc` with these settings moves the files into the specified `dist` folder:\n\n``` shell\n$ tsc\n\nexample\n├── dist\n│   └── index.js\n├── index.ts\n└── tsconfig.json\n```\n\n- Related:\n  - [`out`](#out)\n\n  - [`outFile`](#outFile)\n\n### Out File - `outFile`\n\nIf specified, all *global* (non-module) files will be concatenated into the single output file specified.\n\nIf `module` is `system` or `amd`, all module files will also be concatenated into this file after all global content.\n\nNote: `outFile` cannot be used unless `module` is `None`, `System`, or `AMD`. This option *cannot* be used to bundle CommonJS or ES6 modules.\n\n- Related:\n  - [`out`](#out)\n\n  - [`outDir`](#outDir)\n\n- Released:\n\n  [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)\n\n### Preserve Const Enums - `preserveConstEnums`\n\nDo not erase `const enum` declarations in generated code. `const enum`s provide a way to reduce the overall memory footprint of your application at runtime by emitting the enum value instead of a reference.\n\nFor example with this TypeScript:\n\n``` ts\nconst enum Album {\n  JimmyEatWorldFutures = 1,\n  TubRingZooHypothesis = 2,\n  DogFashionDiscoAdultery = 3,\n}\n \nconst selectedAlbum = Album.JimmyEatWorldFutures;\nif (selectedAlbum === Album.JimmyEatWorldFutures) {\n  console.log(\"That is a great choice.\");\n}\n```\n\nThe default `const enum` behavior is to convert any `Album.Something` to the corresponding number literal, and to remove a reference to the enum from the JavaScript completely.\n\n``` ts\n\"use strict\";\nconst selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;\nif (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {\n    console.log(\"That is a great choice.\");\n}\n \n```\n\nWith `preserveConstEnums` set to `true`, the `enum` exists at runtime and the numbers are still emitted.\n\n``` ts\n\"use strict\";\nvar Album;\n(function (Album) {\n    Album[Album[\"JimmyEatWorldFutures\"] = 1] = \"JimmyEatWorldFutures\";\n    Album[Album[\"TubRingZooHypothesis\"] = 2] = \"TubRingZooHypothesis\";\n    Album[Album[\"DogFashionDiscoAdultery\"] = 3] = \"DogFashionDiscoAdultery\";\n})(Album || (Album = {}));\nconst selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;\nif (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {\n    console.log(\"That is a great choice.\");\n}\n \n```\n\nThis essentially makes such `const enums` a source-code feature only, with no runtime traces.\n\n- Default:\n\n  `true` if [`isolatedModules`](#isolatedModules); `false` otherwise.\n\n### Remove Comments - `removeComments`\n\nStrips all comments from TypeScript files when converting into JavaScript. Defaults to `false`.\n\nFor example, this is a TypeScript file which has a JSDoc comment:\n\n``` ts\n/** The translation of 'Hello world' into Portuguese */\nexport const helloWorldPTBR = \"Olá Mundo\";\n```\n\nWhen `removeComments` is set to `true`:\n\n``` ts\nexport const helloWorldPTBR = \"Olá Mundo\";\n \n```\n\nWithout setting `removeComments` or having it as `false`:\n\n``` ts\n/** The translation of 'Hello world' into Portuguese */\nexport const helloWorldPTBR = \"Olá Mundo\";\n \n```\n\nThis means that your comments will show up in the JavaScript code.\n\n### Source Map - `sourceMap`\n\nEnables the generation of [sourcemap files](https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map). These files allow debuggers and other tools to display the original TypeScript source code when actually working with the emitted JavaScript files. Source map files are emitted as `.js.map` (or `.jsx.map`) files next to the corresponding `.js` output file.\n\nThe `.js` files will in turn contain a sourcemap comment to indicate where the files are to external tools, for example:\n\n``` ts\n// helloWorld.ts\nexport declare const helloWorld = \"hi\";\n```\n\nCompiling with `sourceMap` set to `true` creates the following JavaScript file:\n\n``` js\n// helloWorld.js\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.helloWorld = \"hi\";\n//# sourceMappingURL=// helloWorld.js.map\n```\n\nAnd this also generates this json map:\n\n``` json\n// helloWorld.js.map\n{\n  \"version\": 3,\n  \"file\": \"ex.js\",\n  \"sourceRoot\": \"\",\n  \"sources\": [\"../ex.ts\"],\n  \"names\": [],\n  \"mappings\": \";;AAAa,QAAA,UAAU,GAAG,IAAI,CAAA\"\n}\n```\n\n### Source Root - `sourceRoot`\n\nSpecify the location where a debugger should locate TypeScript files instead of relative source locations. This string is treated verbatim inside the source-map where you can use a path or a URL:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"sourceMap\": true,\n    \"sourceRoot\": \"https://my-website.com/debug/source/\"\n  }\n}\n```\n\nWould declare that `index.js` will have a source file at `https://my-website.com/debug/source/index.ts`.\n\n### Strip Internal - `stripInternal`\n\nDo not emit declarations for code that has an `@internal` annotation in its JSDoc comment. This is an internal compiler option; use at your own risk, because the compiler does not check that the result is valid. If you are searching for a tool to handle additional levels of visibility within your `d.ts` files, look at [api-extractor](https://api-extractor.com).\n\n``` ts\n/**\n * Days available in a week\n * @internal\n */\nexport const daysInAWeek = 7;\n \n/** Calculate how much someone earns in a week */\nexport function weeklySalary(dayRate: number) {\n  return daysInAWeek * dayRate;\n}\n```\n\nWith the flag set to `false` (default):\n\n``` ts\n/**\n * Days available in a week\n * @internal\n */\nexport declare const daysInAWeek = 7;\n/** Calculate how much someone earns in a week */\nexport declare function weeklySalary(dayRate: number): number;\n \n```\n\nWith `stripInternal` set to `true` the `d.ts` emitted will be redacted.\n\n``` ts\n/** Calculate how much someone earns in a week */\nexport declare function weeklySalary(dayRate: number): number;\n \n```\n\nThe JavaScript output is still the same.\n\n- Internal\n\n## JavaScript Support\n\n### Allow JS - `allowJs`\n\nAllow JavaScript files to be imported inside your project, instead of just `.ts` and `.tsx` files. For example, this JS file:\n\n``` js\n// @filename: card.js\nexport const defaultCardDeck = \"Heart\";\n```\n\nWhen imported into a TypeScript file will raise an error:\n\n``` ts\n// @filename: index.ts\nimport { defaultCardDeck } from \"./card\";\n \nconsole.log(defaultCardDeck);\n```\n\nImports fine with `allowJs` enabled:\n\n``` ts\n// @filename: index.ts\nimport { defaultCardDeck } from \"./card\";\n \nconsole.log(defaultCardDeck);\n```\n\nThis flag can be used as a way to incrementally add TypeScript files into JS projects by allowing the `.ts` and `.tsx` files to live along-side existing JavaScript files.\n\nIt can also be used along-side [`declaration`](#declaration) and [`emitDeclarationOnly`](#emitDeclarationOnly) to [create declarations for JS files](../docs/handbook/declaration-files/dts-from-js).\n\n- Related:\n  - [`checkJs`](#checkJs)\n\n  - [`emitDeclarationOnly`](#emitDeclarationOnly)\n\n- Released:\n\n  [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)\n\n### Check JS - `checkJs`\n\nWorks in tandem with [`allowJs`](#allowJs). When `checkJs` is enabled then errors are reported in JavaScript files. This is the equivalent of including `// @ts-check` at the top of all JavaScript files which are included in your project.\n\nFor example, this is incorrect JavaScript according to the `parseFloat` type definition which comes with TypeScript:\n\n``` js\n// parseFloat only takes a string\nmodule.exports.pi = parseFloat(3.142);\n```\n\nWhen imported into a TypeScript module:\n\n``` ts\n// @filename: constants.js\nmodule.exports.pi = parseFloat(3.142);\n \n// @filename: index.ts\nimport { pi } from \"./constants\";\nconsole.log(pi);\n```\n\nYou will not get any errors. However, if you turn on `checkJs` then you will get error messages from the JavaScript file.\n\n``` ts\n// @filename: constants.js\nmodule.exports.pi = parseFloat(3.142);\n \n// @filename: index.ts\nimport { pi } from \"./constants\";\nconsole.log(pi);\n```\n\n- Related:\n  - [`allowJs`](#allowJs)\n\n  - [`emitDeclarationOnly`](#emitDeclarationOnly)\n\n- Released:\n\n  [2.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html)\n\n### Max Node Module JS Depth - `maxNodeModuleJsDepth`\n\nThe maximum dependency depth to search under `node_modules` and load JavaScript files.\n\nThis flag can only be used when [`allowJs`](#allowJs) is enabled, and is used if you want to have TypeScript infer types for all of the JavaScript inside your `node_modules`.\n\nIdeally this should stay at 0 (the default), and `d.ts` files should be used to explicitly define the shape of modules. However, there are cases where you may want to turn this on at the expense of speed and potential accuracy.\n\n## Editor Support\n\n### Disable Size Limit - `disableSizeLimit`\n\nTo avoid a possible memory bloat issues when working with very large JavaScript projects, there is an upper limit to the amount of memory TypeScript will allocate. Turning this flag on will remove the limit.\n\n### Plugins - `plugins`\n\nList of language service plugins to run inside the editor.\n\nLanguage service plugins are a way to provide additional information to a user based on existing TypeScript files. They can enhance existing messages between TypeScript and an editor, or to provide their own error messages.\n\nFor example:\n\n- [ts-sql-plugin](https://github.com/xialvjun/ts-sql-plugin#readme) — Adds SQL linting with a template strings SQL builder.\n- [typescript-styled-plugin](https://github.com/Microsoft/typescript-styled-plugin) — Provides CSS linting inside template strings .\n- [typescript-eslint-language-service](https://github.com/Quramy/typescript-eslint-language-service) — Provides eslint error messaging and fix-its inside the compiler’s output.\n- [ts-graphql-plugin](https://github.com/Quramy/ts-graphql-plugin) — Provides validation and auto-completion inside GraphQL query template strings.\n\nVS Code has the ability for a extension to [automatically include language service plugins](https://code.visualstudio.com/api/references/contribution-points#contributes.typescriptServerPlugins), and so you may have some running in your editor without needing to define them in your `tsconfig.json`.\n\n## Interop Constraints\n\n### Allow Synthetic Default Imports - `allowSyntheticDefaultImports`\n\nWhen set to true, `allowSyntheticDefaultImports` allows you to write an import like:\n\n``` ts\nimport React from \"react\";\n```\n\ninstead of:\n\n``` ts\nimport * as React from \"react\";\n```\n\nWhen the module **does not** explicitly specify a default export.\n\nFor example, without `allowSyntheticDefaultImports` as true:\n\n``` ts\n// @filename: utilFunctions.js\nconst getStringLength = (str) => str.length;\n \nmodule.exports = {\n  getStringLength,\n};\n \n// @filename: index.ts\nimport utils from \"./utilFunctions\";\n \nconst count = utils.getStringLength(\"Check JS\");\n```\n\nThis code raises an error because there isn’t a `default` object which you can import. Even though it feels like it should. For convenience, transpilers like Babel will automatically create a default if one isn’t created. Making the module look a bit more like:\n\n``` js\n// @filename: utilFunctions.js\nconst getStringLength = (str) => str.length;\nconst allFunctions = {\n  getStringLength,\n};\n\nmodule.exports = allFunctions;\nmodule.exports.default = allFunctions;\n```\n\nThis flag does not affect the JavaScript emitted by TypeScript, it’s only for the type checking. This option brings the behavior of TypeScript in-line with Babel, where extra code is emitted to make using a default export of a module more ergonomic.\n\n- Default:\n\n  `true` if [`esModuleInterop`](#esModuleInterop) is enabled, [`module`](#module) is `system`, or [`moduleResolution`](#module-resolution) is `bundler`; `false` otherwise.\n\n- Related:\n  - [`esModuleInterop`](#esModuleInterop)\n\n- Released:\n\n  [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)\n\n### ES Module Interop - `esModuleInterop`\n\nBy default (with `esModuleInterop` false or not set) TypeScript treats CommonJS/AMD/UMD modules similar to ES6 modules. In doing this, there are two parts in particular which turned out to be flawed assumptions:\n\n- a namespace import like `import * as moment from \"moment\"` acts the same as `const moment = require(\"moment\")`\n\n- a default import like `import moment from \"moment\"` acts the same as `const moment = require(\"moment\").default`\n\nThis mis-match causes these two issues:\n\n- the ES6 modules spec states that a namespace import (`import * as x`) can only be an object, by having TypeScript treating it the same as `= require(\"x\")` then TypeScript allowed for the import to be treated as a function and be callable. That’s not valid according to the spec.\n\n- while accurate to the ES6 modules spec, most libraries with CommonJS/AMD/UMD modules didn’t conform as strictly as TypeScript’s implementation.\n\nTurning on `esModuleInterop` will fix both of these problems in the code transpiled by TypeScript. The first changes the behavior in the compiler, the second is fixed by two new helper functions which provide a shim to ensure compatibility in the emitted JavaScript:\n\n``` ts\nimport * as fs from \"fs\";\nimport _ from \"lodash\";\n\nfs.readFileSync(\"file.txt\", \"utf8\");\n_.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n```\n\nWith `esModuleInterop` disabled:\n\n``` ts\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst lodash_1 = require(\"lodash\");\nfs.readFileSync(\"file.txt\", \"utf8\");\nlodash_1.default.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n \n```\n\nWith `esModuleInterop` set to `true`:\n\n``` ts\n\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = __importStar(require(\"fs\"));\nconst lodash_1 = __importDefault(require(\"lodash\"));\nfs.readFileSync(\"file.txt\", \"utf8\");\nlodash_1.default.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n \n```\n\n*Note*: The namespace import `import * as fs from \"fs\"` only accounts for properties which [are owned](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty) (basically properties set on the object and not via the prototype chain) on the imported object. If the module you’re importing defines its API using inherited properties, you need to use the default import form (`import fs from \"fs\"`), or disable `esModuleInterop`.\n\n*Note*: You can make JS emit terser by enabling [`importHelpers`](#importHelpers):\n\n``` ts\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst fs = tslib_1.__importStar(require(\"fs\"));\nconst lodash_1 = tslib_1.__importDefault(require(\"lodash\"));\nfs.readFileSync(\"file.txt\", \"utf8\");\nlodash_1.default.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n \n```\n\nEnabling `esModuleInterop` will also enable [`allowSyntheticDefaultImports`](#allowSyntheticDefaultImports).\n\n- Recommended\n\n- Default:\n\n  `true` if [`module`](#module) is `node16` or `nodenext`; `false` otherwise.\n\n- Related:\n  - [`allowSyntheticDefaultImports`](#allowSyntheticDefaultImports)\n\n- Released:\n\n  [2.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html)\n\n### Force Consistent Casing In File Names - `forceConsistentCasingInFileNames`\n\nTypeScript follows the case sensitivity rules of the file system it’s running on. This can be problematic if some developers are working in a case-sensitive file system and others aren’t. If a file attempts to import `fileManager.ts` by specifying `./FileManager.ts` the file will be found in a case-insensitive file system, but not on a case-sensitive file system.\n\nWhen this option is set, TypeScript will issue an error if a program tries to include a file by a casing different from the casing on disk.\n\n- Recommended\n\n- Default:\n\n  `true`\n\n### isolatedDeclarations - `isolatedDeclarations`\n\nRequire sufficient annotation on exports so other tools can trivially generate declaration files.\n\nFor more information, see the [5.5 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#isolated-declarations)\n\n### Isolated Modules - `isolatedModules`\n\nWhile you can use TypeScript to produce JavaScript code from TypeScript code, it’s also common to use other transpilers such as [Babel](https://babeljs.io) to do this. However, other transpilers only operate on a single file at a time, which means they can’t apply code transforms that depend on understanding the full type system. This restriction also applies to TypeScript’s `ts.transpileModule` API which is used by some build tools.\n\nThese limitations can cause runtime problems with some TypeScript features like `const enum`s and `namespace`s. Setting the `isolatedModules` flag tells TypeScript to warn you if you write certain code that can’t be correctly interpreted by a single-file transpilation process.\n\nIt does not change the behavior of your code, or otherwise change the behavior of TypeScript’s checking and emitting process.\n\nSome examples of code which does not work when `isolatedModules` is enabled.\n\n#### Exports of Non-Value Identifiers\n\nIn TypeScript, you can import a *type* and then subsequently export it:\n\n``` ts\nimport { someType, someFunction } from \"someModule\";\n \nsomeFunction();\n \nexport { someType, someFunction };\n```\n\nBecause there’s no value for `someType`, the emitted `export` will not try to export it (this would be a runtime error in JavaScript):\n\n``` js\nexport { someFunction };\n```\n\nSingle-file transpilers don’t know whether `someType` produces a value or not, so it’s an error to export a name that only refers to a type.\n\n#### Non-Module Files\n\nIf `isolatedModules` is set, namespaces are only allowed in *modules* (which means it has some form of `import`/`export`). An error occurs if a namespace is found in a non-module file:\n\n``` ts\nnamespace Instantiated {\n  export const x = 1;\n}\n```\n\nThis restriction doesn’t apply to `.d.ts` files.\n\n#### References to `const enum` members\n\nIn TypeScript, when you reference a `const enum` member, the reference is replaced by its actual value in the emitted JavaScript. Changing this TypeScript:\n\n``` ts\ndeclare const enum Numbers {\n  Zero = 0,\n  One = 1,\n}\nconsole.log(Numbers.Zero + Numbers.One);\n```\n\nTo this JavaScript:\n\n``` ts\n\"use strict\";\nconsole.log(0 + 1);\n \n```\n\nWithout knowledge of the values of these members, other transpilers can’t replace the references to `Numbers`, which would be a runtime error if left alone (since there are no `Numbers` object at runtime). Because of this, when `isolatedModules` is set, it is an error to reference an ambient `const enum` member.\n\n- Default:\n\n  `true` if [`verbatimModuleSyntax`](#verbatimModuleSyntax); `false` otherwise.\n\n### Preserve Symlinks - `preserveSymlinks`\n\nThis is to reflect the same flag in Node.js; which does not resolve the real path of symlinks.\n\nThis flag also exhibits the opposite behavior to Webpack’s `resolve.symlinks` option (i.e. setting TypeScript’s `preserveSymlinks` to true parallels setting Webpack’s `resolve.symlinks` to false, and vice-versa).\n\nWith this enabled, references to modules and packages (e.g. `import`s and `/// <reference type=\"...\" />` directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to.\n\n### Verbatim Module Syntax - `verbatimModuleSyntax`\n\nBy default, TypeScript does something called *import elision*. Basically, if you write something like\n\n``` ts\nimport { Car } from \"./car\";\n\nexport function drive(car: Car) {\n  // ...\n}\n```\n\nTypeScript detects that you’re only using an import for types and drops the import entirely. Your output JavaScript might look something like this:\n\n``` js\nexport function drive(car) {\n  // ...\n}\n```\n\nMost of the time this is good, because if `Car` isn’t a value that’s exported from `./car`, we’ll get a runtime error.\n\nBut it does add a layer of complexity for certain edge cases. For example, notice there’s no statement like `import \"./car\";` - the import was dropped entirely. That actually makes a difference for modules that have side-effects or not.\n\nTypeScript’s emit strategy for JavaScript also has another few layers of complexity - import elision isn’t always just driven by how an import is used - it often consults how a value is declared as well. So it’s not always clear whether code like the following\n\n``` ts\nexport { Car } from \"./car\";\n```\n\nshould be preserved or dropped. If `Car` is declared with something like a `class`, then it can be preserved in the resulting JavaScript file. But if `Car` is only declared as a `type` alias or `interface`, then the JavaScript file shouldn’t export `Car` at all.\n\nWhile TypeScript might be able to make these emit decisions based on information from across files, not every compiler can.\n\nThe `type` modifier on imports and exports helps with these situations a bit. We can make it explicit whether an import or export is only being used for type analysis, and can be dropped entirely in JavaScript files by using the `type` modifier.\n\n``` ts\n// This statement can be dropped entirely in JS output\nimport type * as car from \"./car\";\n\n// The named import/export 'Car' can be dropped in JS output\nimport { type Car } from \"./car\";\nexport { type Car } from \"./car\";\n```\n\n`type` modifiers are not quite useful on their own - by default, module elision will still drop imports, and nothing forces you to make the distinction between `type` and plain imports and exports. So TypeScript has the flag `--importsNotUsedAsValues` to make sure you use the `type` modifier, `--preserveValueImports` to prevent *some* module elision behavior, and `--isolatedModules` to make sure that your TypeScript code works across different compilers. Unfortunately, understanding the fine details of those 3 flags is hard, and there are still some edge cases with unexpected behavior.\n\nTypeScript 5.0 introduces a new option called `--verbatimModuleSyntax` to simplify the situation. The rules are much simpler - any imports or exports without a `type` modifier are left around. Anything that uses the `type` modifier is dropped entirely.\n\n``` ts\n// Erased away entirely.\nimport type { A } from \"a\";\n\n// Rewritten to 'import { b } from \"bcd\";'\nimport { b, type c, type d } from \"bcd\";\n\n// Rewritten to 'import {} from \"xyz\";'\nimport { type xyz } from \"xyz\";\n```\n\nWith this new option, what you see is what you get.\n\nThat does have some implications when it comes to module interop though. Under this flag, ECMAScript `import`s and `export`s won’t be rewritten to `require` calls when your settings or file extension implied a different module system. Instead, you’ll get an error. If you need to emit code that uses `require` and `module.exports`, you’ll have to use TypeScript’s module syntax that predates ES2015:\n\n[TABLE]\n\nWhile this is a limitation, it does help make some issues more obvious. For example, it’s very common to forget to set the [`type` field in `package.json`](https://nodejs.org/api/packages.html#type) under `--module node16`. As a result, developers would start writing CommonJS modules instead of an ES modules without realizing it, giving surprising lookup rules and JavaScript output. This new flag ensures that you’re intentional about the file type you’re using because the syntax is intentionally different.\n\nBecause `--verbatimModuleSyntax` provides a more consistent story than `--importsNotUsedAsValues` and `--preserveValueImports`, those two existing flags are being deprecated in its favor.\n\nFor more details, read up on [the original pull request](https://github.com/microsoft/TypeScript/pull/52203) and [its proposal issue](https://github.com/microsoft/TypeScript/issues/51479).\n\n## Backwards Compatibility\n\n### Charset - `charset`\n\nIn prior versions of TypeScript, this controlled what encoding was used when reading text files from disk. Today, TypeScript assumes UTF-8 encoding, but will correctly detect UTF-16 (BE and LE) or UTF-8 BOMs.\n\n- Deprecated\n\n- Default:\n\n  `utf8`\n\n### Imports Not Used As Values - `importsNotUsedAsValues`\n\nDeprecated in favor of [`verbatimModuleSyntax`](#verbatimModuleSyntax).\n\nThis flag controls how `import` works, there are 3 different options:\n\n- `remove`: The default behavior of dropping `import` statements which only reference types.\n\n- `preserve`: Preserves all `import` statements whose values or types are never used. This can cause imports/side-effects to be preserved.\n\n- `error`: This preserves all imports (the same as the preserve option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.\n\nThis flag works because you can use `import type` to explicitly create an `import` statement which should never be emitted into JavaScript.\n\n- Default:\n\n  `remove`\n\n- Allowed:\n  - `remove`\n\n  - `preserve`\n\n  - `error`\n\n- Related:\n  - [`preserveValueImports`](#preserveValueImports)\n\n  - [`verbatimModuleSyntax`](#verbatimModuleSyntax)\n\n- Released:\n\n  [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)\n\n### Keyof Strings Only - `keyofStringsOnly`\n\nThis flag changes the `keyof` type operator to return `string` instead of `string | number` when applied to a type with a string index signature.\n\nThis flag is used to help people keep this behavior from [before TypeScript 2.9’s release](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types).\n\n- Deprecated\n\n- Released:\n\n  [2.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html)\n\n### No Implicit Use Strict - `noImplicitUseStrict`\n\nYou shouldn’t need this. By default, when emitting a module file to a non-ES6 target, TypeScript emits a `\"use strict\";` prologue at the top of the file. This setting disables the prologue.\n\n### No Strict Generic Checks - `noStrictGenericChecks`\n\nTypeScript will unify type parameters when comparing two generic functions.\n\n``` ts\ntype A = <T, U>(x: T, y: U) => [T, U];\ntype B = <S>(x: S, y: S) => [S, S];\n \nfunction f(a: A, b: B) {\n  b = a; // Ok\n  a = b; // Error\n}\n```\n\nThis flag can be used to remove that check.\n\n- Released:\n\n  [2.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html)\n\n### Out - `out`\n\nUse [`outFile`](#outFile) instead.\n\nThe `out` option computes the final file location in a way that is not predictable or consistent. This option is retained for backward compatibility only and is deprecated.\n\n- Deprecated\n- Related:\n  - [`outDir`](#outDir)\n\n  - [`outFile`](#outFile)\n\n### Preserve Value Imports - `preserveValueImports`\n\nDeprecated in favor of [`verbatimModuleSyntax`](#verbatimModuleSyntax).\n\nThere are some cases where TypeScript can’t detect that you’re using an import. For example, take the following code:\n\n``` ts\nimport { Animal } from \"./animal.js\";\n\neval(\"console.log(new Animal().isDangerous())\");\n```\n\nor code using ‘Compiles to HTML’ languages like Svelte or Vue. `preserveValueImports` will prevent TypeScript from removing the import, even if it appears unused.\n\nWhen combined with [`isolatedModules`](#isolatedModules): imported types *must* be marked as type-only because compilers that process single files at a time have no way of knowing whether imports are values that appear unused, or a type that must be removed in order to avoid a runtime crash.\n\n- Related:\n  - [`isolatedModules`](#isolatedModules)\n\n  - [`importsNotUsedAsValues`](#importsNotUsedAsValues)\n\n  - [`verbatimModuleSyntax`](#verbatimModuleSyntax)\n\n- Released:\n\n  [4.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html)\n\n### Suppress Excess Property Errors - `suppressExcessPropertyErrors`\n\nThis disables reporting of excess property errors, such as the one shown in the following example:\n\n``` ts\ntype Point = { x: number; y: number };\nconst p: Point = { x: 1, y: 3, m: 10 };\n```\n\nThis flag was added to help people migrate to the stricter checking of new object literals in [TypeScript 1.6](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#stricter-object-literal-assignment-checks).\n\nWe don’t recommend using this flag in a modern codebase, you can suppress one-off cases where you need it using `// @ts-ignore`.\n\n### Suppress Implicit Any Index Errors - `suppressImplicitAnyIndexErrors`\n\nTurning `suppressImplicitAnyIndexErrors` on suppresses reporting the error about implicit anys when indexing into objects, as shown in the following example:\n\n``` ts\nconst obj = { x: 10 };\nconsole.log(obj[\"foo\"]);\n```\n\nUsing `suppressImplicitAnyIndexErrors` is quite a drastic approach. It is recommended to use a `@ts-ignore` comment instead:\n\n``` ts\nconst obj = { x: 10 };\n// @ts-ignore\nconsole.log(obj[\"foo\"]);\n```\n\n- Related:\n  - [`noImplicitAny`](#noImplicitAny)\n\n## Language and Environment\n\n### Emit Decorator Metadata - `emitDecoratorMetadata`\n\nEnables experimental support for emitting type metadata for decorators which works with the module [`reflect-metadata`](https://www.npmjs.com/package/reflect-metadata).\n\nFor example, here is the TypeScript\n\n``` ts\nfunction LogMethod(\n  target: any,\n  propertyKey: string | symbol,\n  descriptor: PropertyDescriptor\n) {\n  console.log(target);\n  console.log(propertyKey);\n  console.log(descriptor);\n}\n \nclass Demo {\n  @LogMethod\n  public foo(bar: number) {\n    // do nothing\n  }\n}\n \nconst demo = new Demo();\n```\n\nWith `emitDecoratorMetadata` not set to true (default) the emitted JavaScript is:\n\n``` ts\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nfunction LogMethod(target, propertyKey, descriptor) {\n    console.log(target);\n    console.log(propertyKey);\n    console.log(descriptor);\n}\nclass Demo {\n    foo(bar) {\n        // do nothing\n    }\n}\n__decorate([\n    LogMethod\n], Demo.prototype, \"foo\", null);\nconst demo = new Demo();\n \n```\n\nWith `emitDecoratorMetadata` set to true the emitted JavaScript is:\n\n``` ts\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nfunction LogMethod(target, propertyKey, descriptor) {\n    console.log(target);\n    console.log(propertyKey);\n    console.log(descriptor);\n}\nclass Demo {\n    foo(bar) {\n        // do nothing\n    }\n}\n__decorate([\n    LogMethod,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Number]),\n    __metadata(\"design:returntype\", void 0)\n], Demo.prototype, \"foo\", null);\nconst demo = new Demo();\n \n```\n\n- Related:\n  - [`experimentalDecorators`](#experimentalDecorators)\n\n### Experimental Decorators - `experimentalDecorators`\n\nEnables [experimental support for decorators](https://github.com/tc39/proposal-decorators), which is a version of decorators that predates the TC39 standardization process.\n\nDecorators are a language feature which hasn’t yet been fully ratified into the JavaScript specification. This means that the implementation version in TypeScript may differ from the implementation in JavaScript when it it decided by TC39.\n\nYou can find out more about decorator support in TypeScript in [the handbook](../docs/handbook/decorators).\n\n- Related:\n  - [`emitDecoratorMetadata`](#emitDecoratorMetadata)\n\n### JSX - `jsx`\n\nControls how JSX constructs are emitted in JavaScript files. This only affects output of JS files that started in `.tsx` files.\n\n- `react-jsx`: Emit `.js` files with the JSX changed to `_jsx` calls optimized for production\n- `react-jsxdev`: Emit `.js` files with the JSX changed to `_jsx` calls for development only\n- `preserve`: Emit `.jsx` files with the JSX unchanged\n- `react-native`: Emit `.js` files with the JSX unchanged\n- `react`: Emit `.js` files with JSX changed to the equivalent `React.createElement` calls\n\n### For example\n\nThis sample code:\n\n``` typescript+html\nexport const HelloWorld = () => <h1>Hello world</h1>;\n```\n\nReact: `\"react-jsx\"`^([\\[1\\]](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html))\n\n``` typescript+html\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport const HelloWorld = () => _jsx(\"h1\", { children: \"Hello world\" });\n \n```\n\nReact dev transform: `\"react-jsxdev\"`^([\\[1\\]](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html))\n\n``` typescript+html\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst _jsxFileName = \"/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/index.tsx\";\nexport const HelloWorld = () => _jsxDEV(\"h1\", { children: \"Hello world\" }, void 0, false, { fileName: _jsxFileName, lineNumber: 9, columnNumber: 32 }, this);\n \n```\n\nPreserve: `\"preserve\"`\n\n``` typescript+html\nimport React from 'react';\nexport const HelloWorld = () => <h1>Hello world</h1>;\n \n```\n\nReact Native: `\"react-native\"`\n\n``` typescript+html\nimport React from 'react';\nexport const HelloWorld = () => <h1>Hello world</h1>;\n \n```\n\nLegacy React runtime: `\"react\"`\n\n``` typescript+html\nimport React from 'react';\nexport const HelloWorld = () => React.createElement(\"h1\", null, \"Hello world\");\n \n```\n\nThis option can be used on a per-file basis too using an `@jsxRuntime` comment.\n\nAlways use the classic runtime (`\"react\"`) for this file:\n\n``` typescript+html\n/* @jsxRuntime classic */\nexport const HelloWorld = () => <h1>Hello world</h1>;\n```\n\nAlways use the automatic runtime (`\"react-jsx\"`) for this file:\n\n``` typescript+html\n/* @jsxRuntime automatic */\nexport const HelloWorld = () => <h1>Hello world</h1>;\n```\n\n- Allowed:\n  - `preserve`\n\n  - `react`\n\n  - `react-native`\n\n  - `react-jsx`\n\n  - `react-jsxdev`\n\n- Related:\n  - [`jsxFactory`](#jsxFactory)\n\n  - [`jsxFragmentFactory`](#jsxFragmentFactory)\n\n  - [`jsxImportSource`](#jsxImportSource)\n\n- Released:\n\n  [2.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html)\n\n### JSX Factory - `jsxFactory`\n\nChanges the function called in `.js` files when compiling JSX Elements using the classic JSX runtime. The most common change is to use `\"h\"` or `\"preact.h\"` instead of the default `\"React.createElement\"` if using `preact`.\n\nFor example, this TSX file:\n\n``` typescript+html\nimport { h } from \"preact\";\n\nconst HelloWorld = () => <div>Hello</div>;\n```\n\nWith `jsxFactory: \"h\"` looks like:\n\n``` typescript+html\nconst preact_1 = require(\"preact\");\nconst HelloWorld = () => (0, preact_1.h)(\"div\", null, \"Hello\");\n \n```\n\nThis option can be used on a per-file basis too similar to [Babel’s `/** @jsx h */` directive](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#custom).\n\n``` typescript+html\n/** @jsx h */\nimport { h } from \"preact\";\n \nconst HelloWorld = () => <div>Hello</div>;\n```\n\nThe factory chosen will also affect where the `JSX` namespace is looked up (for type checking information) before falling back to the global one.\n\nIf the factory is defined as `React.createElement` (the default), the compiler will check for `React.JSX` before checking for a global `JSX`. If the factory is defined as `h`, it will check for `h.JSX` before a global `JSX`.\n\n- Default:\n\n  `React.createElement`\n\n- Allowed:\n  - Any identifier or dotted identifier.\n\n- Related:\n  - [`jsx`](#jsx)\n\n  - [`jsxFragmentFactory`](#jsxFragmentFactory)\n\n  - [`jsxImportSource`](#jsxImportSource)\n\n### JSX Fragment Factory - `jsxFragmentFactory`\n\nSpecify the JSX fragment factory function to use when targeting react JSX emit with [`jsxFactory`](#jsxFactory) compiler option is specified, e.g. `Fragment`.\n\nFor example with this TSConfig:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"commonjs\",\n    \"jsx\": \"react\",\n    \"jsxFactory\": \"h\",\n    \"jsxFragmentFactory\": \"Fragment\"\n  }\n}\n```\n\nThis TSX file:\n\n``` typescript+html\nimport { h, Fragment } from \"preact\";\n\nconst HelloWorld = () => (\n  <>\n    <div>Hello</div>\n  </>\n);\n```\n\nWould look like:\n\n``` typescript+html\nconst preact_1 = require(\"preact\");\nconst HelloWorld = () => ((0, preact_1.h)(preact_1.Fragment, null,\n    (0, preact_1.h)(\"div\", null, \"Hello\")));\n \n```\n\nThis option can be used on a per-file basis too similar to [Babel’s `/* @jsxFrag h */` directive](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#fragments).\n\nFor example:\n\n``` typescript+html\n/** @jsx h */\n/** @jsxFrag Fragment */\n \nimport { h, Fragment } from \"preact\";\n \nconst HelloWorld = () => (\n  <>\n    <div>Hello</div>\n  </>\n);\n```\n\n- Default:\n\n  `React.Fragment`\n\n- Related:\n  - [`jsx`](#jsx)\n\n  - [`jsxFactory`](#jsxFactory)\n\n  - [`jsxImportSource`](#jsxImportSource)\n\n- Released:\n\n  [4.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html)\n\n### JSX Import Source - `jsxImportSource`\n\nDeclares the module specifier to be used for importing the `jsx` and `jsxs` factory functions when using [`jsx`](#jsx) as `\"react-jsx\"` or `\"react-jsxdev\"` which were introduced in TypeScript 4.1.\n\nWith [React 17](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html) the library supports a new form of JSX transformation via a separate import.\n\nFor example with this code:\n\n``` typescript+html\nimport React from \"react\";\n\nfunction App() {\n  return <h1>Hello World</h1>;\n}\n```\n\nUsing this TSConfig:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"commonjs\",\n    \"jsx\": \"react-jsx\"\n  }\n}\n```\n\nThe emitted JavaScript from TypeScript is:\n\n``` typescript+html\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nfunction App() {\n    return (0, jsx_runtime_1.jsx)(\"h1\", { children: \"Hello World\" });\n}\n \n```\n\nFor example if you wanted to use `\"jsxImportSource\": \"preact\"`, you need a tsconfig like:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"commonjs\",\n    \"jsx\": \"react-jsx\",\n    \"jsxImportSource\": \"preact\",\n    \"types\": [\"preact\"]\n  }\n}\n```\n\nWhich generates code like:\n\n``` typescript+html\nfunction App() {\n    return (0, jsx_runtime_1.jsx)(\"h1\", { children: \"Hello World\" });\n}\n \n```\n\nAlternatively, you can use a per-file pragma to set this option, for example:\n\n``` typescript+html\n/** @jsxImportSource preact */\n\nexport function App() {\n  return <h1>Hello World</h1>;\n}\n```\n\nWould add `preact/jsx-runtime` as an import for the `_jsx` factory.\n\n*Note:* In order for this to work like you would expect, your `tsx` file must include an `export` or `import` so that it is considered a module.\n\n- Default:\n\n  `react`\n\n- Related:\n  - [`jsx`](#jsx)\n\n  - [`jsxFactory`](#jsxFactory)\n\n- Released:\n\n  [4.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html)\n\n### Lib - `lib`\n\nTypeScript includes a default set of type definitions for built-in JS APIs (like `Math`), as well as type definitions for things found in browser environments (like `document`). TypeScript also includes APIs for newer JS features matching the [`target`](#target) you specify; for example the definition for `Map` is available if [`target`](#target) is `ES6` or newer.\n\nYou may want to change these for a few reasons:\n\n- Your program doesn’t run in a browser, so you don’t want the `\"dom\"` type definitions\n- Your runtime platform provides certain JavaScript API objects (maybe through polyfills), but doesn’t yet support the full syntax of a given ECMAScript version\n- You have polyfills or native implementations for some, but not all, of a higher level ECMAScript version\n\nIn TypeScript 4.5, lib files can be overridden by npm modules, find out more [in the blog](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5-beta/#supporting-lib-from-node_modules).\n\n### High Level libraries\n\n| Name         | Contents                                                                                                                                          |\n|--------------|---------------------------------------------------------------------------------------------------------------------------------------------------|\n| `ES5`        | Core definitions for all ES3 and ES5 functionality                                                                                                |\n| `ES2015`     | Additional APIs available in ES2015 (also known as ES6) - `array.find`, `Promise`, `Proxy`, `Symbol`, `Map`, `Set`, `Reflect`, etc.               |\n| `ES6`        | Alias for “ES2015”                                                                                                                                |\n| `ES2016`     | Additional APIs available in ES2016 - `array.include`, etc.                                                                                       |\n| `ES7`        | Alias for “ES2016”                                                                                                                                |\n| `ES2017`     | Additional APIs available in ES2017 - `Object.entries`, `Object.values`, `Atomics`, `SharedArrayBuffer`, `date.formatToParts`, typed arrays, etc. |\n| `ES2018`     | Additional APIs available in ES2018 - `async` iterables, `promise.finally`, `Intl.PluralRules`, `regexp.groups`, etc.                             |\n| `ES2019`     | Additional APIs available in ES2019 - `array.flat`, `array.flatMap`, `Object.fromEntries`, `string.trimStart`, `string.trimEnd`, etc.             |\n| `ES2020`     | Additional APIs available in ES2020 - `string.matchAll`, etc.                                                                                     |\n| `ES2021`     | Additional APIs available in ES2021 - `promise.any`, `string.replaceAll` etc.                                                                     |\n| `ES2022`     | Additional APIs available in ES2022 - `array.at`, `RegExp.hasIndices`, etc.                                                                       |\n| `ES2023`     | Additional APIs available in ES2023 - `array.with`, `array.findLast`, `array.findLastIndex`, `array.toSorted`, `array.toReversed`, etc.           |\n| `ESNext`     | Additional APIs available in ESNext - This changes as the JavaScript specification evolves                                                        |\n| `DOM`        | [DOM](https://developer.mozilla.org/docs/Glossary/DOM) definitions - `window`, `document`, etc.                                                   |\n| `WebWorker`  | APIs available in [WebWorker](https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers) contexts                              |\n| `ScriptHost` | APIs for the [Windows Script Hosting System](https://wikipedia.org/wiki/Windows_Script_Host)                                                      |\n\n### Individual library components\n\n| Name                      |\n|---------------------------|\n| `DOM.Iterable`            |\n| `ES2015.Core`             |\n| `ES2015.Collection`       |\n| `ES2015.Generator`        |\n| `ES2015.Iterable`         |\n| `ES2015.Promise`          |\n| `ES2015.Proxy`            |\n| `ES2015.Reflect`          |\n| `ES2015.Symbol`           |\n| `ES2015.Symbol.WellKnown` |\n| `ES2016.Array.Include`    |\n| `ES2017.object`           |\n| `ES2017.Intl`             |\n| `ES2017.SharedMemory`     |\n| `ES2017.String`           |\n| `ES2017.TypedArrays`      |\n| `ES2018.Intl`             |\n| `ES2018.Promise`          |\n| `ES2018.RegExp`           |\n| `ES2019.Array`            |\n| `ES2019.Object`           |\n| `ES2019.String`           |\n| `ES2019.Symbol`           |\n| `ES2020.String`           |\n| `ES2020.Symbol.wellknown` |\n| `ES2021.Promise`          |\n| `ES2021.String`           |\n| `ES2021.WeakRef`          |\n| `ESNext.AsyncIterable`    |\n| `ESNext.Array`            |\n| `ESNext.Intl`             |\n| `ESNext.Symbol`           |\n\nThis list may be out of date, you can see the full list in the [TypeScript source code](https://github.com/microsoft/TypeScript/tree/main/src/lib).\n\n- Related:\n  - [`noLib`](#noLib)\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### Module Detection - `moduleDetection`\n\nThis setting controls how TypeScript determines whether a file is a [script or a module](../docs/handbook/modules/theory#scripts-and-modules-in-javascript).\n\nThere are three choices:\n\n- `\"auto\"` (default) - TypeScript will not only look for import and export statements, but it will also check whether the `\"type\"` field in a `package.json` is set to `\"module\"` when running with [`module`](#module): `nodenext` or `node16`, and check whether the current file is a JSX file when running under [`jsx`](#jsx): `react-jsx`.\n\n- `\"legacy\"` - The same behavior as 4.6 and prior, usings import and export statements to determine whether a file is a module.\n\n- `\"force\"` - Ensures that every non-declaration file is treated as a module.\n\n- Default:\n\n  \"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.\n\n- Allowed:\n  - `legacy`\n\n  - `auto`\n\n  - `force`\n\n- Released:\n\n  [4.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html)\n\n### No Lib - `noLib`\n\nDisables the automatic inclusion of any library files. If this option is set, `lib` is ignored.\n\nTypeScript *cannot* compile anything without a set of interfaces for key primitives like: `Array`, `Boolean`, `Function`, `IArguments`, `Number`, `Object`, `RegExp`, and `String`. It is expected that if you use `noLib` you will be including your own type definitions for these.\n\n- Related:\n  - [`lib`](#lib)\n\n### React Namespace - `reactNamespace`\n\nUse [`jsxFactory`](#jsxFactory) instead. Specify the object invoked for `createElement` when targeting `react` for TSX files.\n\n- Default:\n\n  `React`\n\n### Target - `target`\n\nModern browsers support all ES6 features, so `ES6` is a good choice. You might choose to set a lower target if your code is deployed to older environments, or a higher target if your code is guaranteed to run in newer environments.\n\nThe `target` setting changes which JS features are downleveled and which are left intact. For example, an arrow function `() => this` will be turned into an equivalent `function` expression if `target` is ES5 or lower.\n\nChanging `target` also changes the default value of [`lib`](#lib). You may “mix and match” `target` and `lib` settings as desired, but you could just set `target` for convenience.\n\nFor developer platforms like Node there are baselines for the `target`, depending on the type of platform and its version. You can find a set of community organized TSConfigs at [tsconfig/bases](https://github.com/tsconfig/bases#centralized-recommendations-for-tsconfig-bases), which has configurations for common platforms and their versions.\n\nThe special `ESNext` value refers to the highest version your version of TypeScript supports. This setting should be used with caution, since it doesn’t mean the same thing between different TypeScript versions and can make upgrades less predictable.\n\n- Default:\n\n  `ES3`\n\n- Allowed:\n  - `es3`\n\n  - `es5`\n\n  - `es6`/`es2015`\n\n  - `es2016`\n\n  - `es2017`\n\n  - `es2018`\n\n  - `es2019`\n\n  - `es2020`\n\n  - `es2021`\n\n  - `es2022`\n\n  - `es2023`\n\n  - `esnext`\n\n- Released:\n\n  [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)\n\n### Use Define For Class Fields - `useDefineForClassFields`\n\nThis flag is used as part of migrating to the upcoming standard version of class fields. TypeScript introduced class fields many years before it was ratified in TC39. The latest version of the upcoming specification has a different runtime behavior to TypeScript’s implementation but the same syntax.\n\nThis flag switches to the upcoming ECMA runtime behavior.\n\nYou can read more about the transition in [the 3.7 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier).\n\n- Default:\n\n  `true` if [`target`](#target) is `ES2022` or higher, including `ESNext`; `false` otherwise.\n\n- Released:\n\n  [3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)\n\n## Compiler Diagnostics\n\n### Diagnostics - `diagnostics`\n\nUsed to output diagnostic information for debugging. This command is a subset of [`extendedDiagnostics`](#extendedDiagnostics) which are more user-facing results, and easier to interpret.\n\nIf you have been asked by a TypeScript compiler engineer to give the results using this flag in a compile, in which there is no harm in using [`extendedDiagnostics`](#extendedDiagnostics) instead.\n\n- Deprecated\n- Related:\n  - [`extendedDiagnostics`](#extendedDiagnostics)\n\n### Explain Files - `explainFiles`\n\nPrint names of files which TypeScript sees as a part of your project and the reason they are part of the compilation.\n\nFor example, with this project of just a single `index.ts` file\n\n``` shell\nexample\n├── index.ts\n├── package.json\n└── tsconfig.json\n```\n\nUsing a `tsconfig.json` which has `explainFiles` set to true:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"commonjs\",\n    \"explainFiles\": true\n  }\n}\n```\n\nRunning TypeScript against this folder would have output like this:\n\n``` typescript\n❯ tsc\nnode_modules/typescript/lib/lib.d.ts\n  Default library for target 'es5'\nnode_modules/typescript/lib/lib.es5.d.ts\n  Library referenced via 'es5' from file 'node_modules/typescript/lib/lib.d.ts'\nnode_modules/typescript/lib/lib.dom.d.ts\n  Library referenced via 'dom' from file 'node_modules/typescript/lib/lib.d.ts'\nnode_modules/typescript/lib/lib.webworker.importscripts.d.ts\n  Library referenced via 'webworker.importscripts' from file 'node_modules/typescript/lib/lib.d.ts'\nnode_modules/typescript/lib/lib.scripthost.d.ts\n  Library referenced via 'scripthost' from file 'node_modules/typescript/lib/lib.d.ts'\nindex.ts\n  Matched by include pattern '**/*' in 'tsconfig.json'\n```\n\nThe output above show:\n\n- The initial lib.d.ts lookup based on [`target`](#target), and the chain of `.d.ts` files which are referenced\n- The `index.ts` file located via the default pattern of [`include`](#include)\n\nThis option is intended for debugging how a file has become a part of your compile.\n\n- Released:\n\n  [4.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html)\n\n### Extended Diagnostics - `extendedDiagnostics`\n\nYou can use this flag to discover where TypeScript is spending its time when compiling. This is a tool used for understanding the performance characteristics of your codebase overall.\n\nYou can learn more about how to measure and understand the output in the performance [section of the wiki](https://github.com/microsoft/TypeScript/wiki/Performance).\n\n- Related:\n  - [`diagnostics`](#diagnostics)\n\n### Generate CPU Profile - `generateCpuProfile`\n\nThis option gives you the chance to have TypeScript emit a v8 CPU profile during the compiler run. The CPU profile can provide insight into why your builds may be slow.\n\nThis option can only be used from the CLI via: `--generateCpuProfile tsc-output.cpuprofile`.\n\n``` shell\nnpm run tsc --generateCpuProfile tsc-output.cpuprofile\n```\n\nThis file can be opened in a chromium based browser like Chrome or Edge Developer in [the CPU profiler](https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution) section. You can learn more about understanding the compilers performance in the [TypeScript wiki section on performance](https://github.com/microsoft/TypeScript/wiki/Performance).\n\n- Default:\n\n  `profile.cpuprofile`\n\n- Released:\n\n  [3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)\n\n### List Emitted Files - `listEmittedFiles`\n\nPrint names of generated files part of the compilation to the terminal.\n\nThis flag is useful in two cases:\n\n- You want to transpile TypeScript as a part of a build chain in the terminal where the filenames are processed in the next command.\n- You are not sure that TypeScript has included a file you expected, as a part of debugging the [file inclusion settings](#Project_Files_0).\n\nFor example:\n\n``` typescript\nexample\n├── index.ts\n├── package.json\n└── tsconfig.json\n```\n\nWith:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"declaration\": true,\n    \"listEmittedFiles\": true\n  }\n}\n```\n\nWould echo paths like:\n\n``` typescript\n$ npm run tsc\n\npath/to/example/index.js\npath/to/example/index.d.ts\n```\n\nNormally, TypeScript would return silently on success.\n\n### List Files - `listFiles`\n\nPrint names of files part of the compilation. This is useful when you are not sure that TypeScript has included a file you expected.\n\nFor example:\n\n``` typescript\nexample\n├── index.ts\n├── package.json\n└── tsconfig.json\n```\n\nWith:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"listFiles\": true\n  }\n}\n```\n\nWould echo paths like:\n\n``` typescript\n$ npm run tsc\npath/to/example/node_modules/typescript/lib/lib.d.ts\npath/to/example/node_modules/typescript/lib/lib.es5.d.ts\npath/to/example/node_modules/typescript/lib/lib.dom.d.ts\npath/to/example/node_modules/typescript/lib/lib.webworker.importscripts.d.ts\npath/to/example/node_modules/typescript/lib/lib.scripthost.d.ts\npath/to/example/index.ts\n```\n\nNote if using TypeScript 4.2, prefer [`explainFiles`](#explainFiles) which offers an explanation of why a file was added too.\n\n- Related:\n  - [`explainFiles`](#explainFiles)\n\n### noCheck - `noCheck`\n\nDisable full type checking (only critical parse and emit errors will be reported).\n\n### Trace Resolution - `traceResolution`\n\nWhen you are trying to debug why a module isn’t being included. You can set `traceResolution` to `true` to have TypeScript print information about its resolution process for each processed file.\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n## Projects\n\n### Composite - `composite`\n\nThe `composite` option enforces certain constraints which make it possible for build tools (including TypeScript itself, under `--build` mode) to quickly determine if a project has been built yet.\n\nWhen this setting is on:\n\n- The [`rootDir`](#rootDir) setting, if not explicitly set, defaults to the directory containing the `tsconfig.json` file.\n\n- All implementation files must be matched by an [`include`](#include) pattern or listed in the [`files`](#files) array. If this constraint is violated, `tsc` will inform you which files weren’t specified.\n\n- [`declaration`](#declaration) defaults to `true`\n\nYou can find documentation on TypeScript projects in [the handbook](../docs/handbook/project-references).\n\n- Related:\n  - [`incremental`](#incremental)\n\n  - [`tsBuildInfoFile`](#tsBuildInfoFile)\n\n- Released:\n\n  [3.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html)\n\n### Disable Referenced Project Load - `disableReferencedProjectLoad`\n\nIn multi-project TypeScript programs, TypeScript will load all of the available projects into memory in order to provide accurate results for editor responses which require a full knowledge graph like ‘Find All References’.\n\nIf your project is large, you can use the flag `disableReferencedProjectLoad` to disable the automatic loading of all projects. Instead, projects are loaded dynamically as you open files through your editor.\n\n- Released:\n\n  [4.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html)\n\n### Disable Solution Searching - `disableSolutionSearching`\n\nWhen working with [composite TypeScript projects](../docs/handbook/project-references), this option provides a way to declare that you do not want a project to be included when using features like *find all references* or *jump to definition* in an editor.\n\nThis flag is something you can use to increase responsiveness in large composite projects.\n\n- Released:\n\n  [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)\n\n### Disable Source Project Reference Redirect - `disableSourceOfProjectReferenceRedirect`\n\nWhen working with [composite TypeScript projects](../docs/handbook/project-references), this option provides a way to go [back to the pre-3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#build-free-editing-with-project-references) behavior where d.ts files were used to as the boundaries between modules. In 3.7 the source of truth is now your TypeScript files.\n\n- Released:\n\n  [3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)\n\n### Incremental - `incremental`\n\nTells TypeScript to save information about the project graph from the last compilation to files stored on disk. This creates a series of `.tsbuildinfo` files in the same folder as your compilation output. They are not used by your JavaScript at runtime and can be safely deleted. You can read more about the flag in the [3.4 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#faster-subsequent-builds-with-the---incremental-flag).\n\nTo control which folders you want to the files to be built to, use the config option [`tsBuildInfoFile`](#tsBuildInfoFile).\n\n- Default:\n\n  `true` if [`composite`](#composite); `false` otherwise.\n\n- Related:\n  - [`composite`](#composite)\n\n  - [`tsBuildInfoFile`](#tsBuildInfoFile)\n\n- Released:\n\n  [3.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html)\n\n### TS Build Info File - `tsBuildInfoFile`\n\nThis setting lets you specify a file for storing incremental compilation information as a part of composite projects which enables faster building of larger TypeScript codebases. You can read more about composite projects [in the handbook](../docs/handbook/project-references).\n\nThe default depends on a combination of other settings:\n\n- If `outFile` is set, the default is `<outFile>.tsbuildinfo`.\n- If `rootDir` and `outDir` are set, then the file is `<outDir>/<relative path to config from rootDir>/<config name>.tsbuildinfo` For example, if `rootDir` is `src`, `outDir` is `dest`, and the config is `./tsconfig.json`, then the default is `./tsconfig.tsbuildinfo` as the relative path from `src/` to `./tsconfig.json` is `../`.\n- If `outDir` is set, then the default is `<outDir>/<config name>.tsbuildInfo`\n- Otherwise, the default is `<config name>.tsbuildInfo`\n\n- Default:\n\n  `.tsbuildinfo`\n\n- Related:\n  - [`incremental`](#incremental)\n\n  - [`composite`](#composite)\n\n- Released:\n\n  [3.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html)\n\n## Output Formatting\n\n### No Error Truncation - `noErrorTruncation`\n\nDo not truncate error messages.\n\nWith `false`, the default.\n\n``` ts\nvar x: {\n  propertyWithAnExceedinglyLongName1: string;\n  propertyWithAnExceedinglyLongName2: string;\n  propertyWithAnExceedinglyLongName3: string;\n  propertyWithAnExceedinglyLongName4: string;\n  propertyWithAnExceedinglyLongName5: string;\n  propertyWithAnExceedinglyLongName6: string;\n  propertyWithAnExceedinglyLongName7: string;\n  propertyWithAnExceedinglyLongName8: string;\n};\n \n// String representation of type of 'x' should be truncated in error message\nvar s: string = x;\n```\n\nWith `true`\n\n``` ts\nvar x: {\n  propertyWithAnExceedinglyLongName1: string;\n  propertyWithAnExceedinglyLongName2: string;\n  propertyWithAnExceedinglyLongName3: string;\n  propertyWithAnExceedinglyLongName4: string;\n  propertyWithAnExceedinglyLongName5: string;\n  propertyWithAnExceedinglyLongName6: string;\n  propertyWithAnExceedinglyLongName7: string;\n  propertyWithAnExceedinglyLongName8: string;\n};\n \n// String representation of type of 'x' should be truncated in error message\nvar s: string = x;\n```\n\n### Preserve Watch Output - `preserveWatchOutput`\n\nWhether to keep outdated console output in watch mode instead of clearing the screen every time a change happened.\n\n- Internal\n\n### Pretty - `pretty`\n\nStylize errors and messages using color and context, this is on by default — offers you a chance to have less terse, single colored messages from the compiler.\n\n- Default:\n\n  `true`\n\n## Completeness\n\n### Skip Default Lib Check - `skipDefaultLibCheck`\n\nUse [`skipLibCheck`](#skipLibCheck) instead. Skip type checking of default library declaration files.\n\n### Skip Lib Check - `skipLibCheck`\n\nSkip type checking of declaration files.\n\nThis can save time during compilation at the expense of type-system accuracy. For example, two libraries could define two copies of the same `type` in an inconsistent way. Rather than doing a full check of all `d.ts` files, TypeScript will type check the code you specifically refer to in your app’s source code.\n\nA common case where you might think to use `skipLibCheck` is when there are two copies of a library’s types in your `node_modules`. In these cases, you should consider using a feature like [yarn’s resolutions](https://yarnpkg.com/lang/en/docs/selective-version-resolutions/) to ensure there is only one copy of that dependency in your tree or investigate how to ensure there is only one copy by understanding the dependency resolution to fix the issue without additional tooling.\n\nAnother possibility is when you are migrating between TypeScript releases and the changes cause breakages in node_modules and the JS standard libraries which you do not want to deal with during the TypeScript update.\n\nNote, that if these issues come from the TypeScript standard library you can replace the library using [TypeScript 4.5’s lib replacement](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#supporting-lib-from-node_modules) technique.\n\n- Recommended\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n## Command Line\n\n## Watch Options\n\nTypeScript 3.8 shipped a new strategy for watching directories, which is crucial for efficiently picking up changes to `node_modules`.\n\nOn operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on `node_modules` and many of its subdirectories to detect changes in dependencies. This is because the number of available file watchers is often eclipsed by the number of files in `node_modules`, whereas there are way fewer directories to track.\n\nBecause every project might work better under different strategies, and this new approach might not work well for your workflows, TypeScript 3.8 introduces a new `watchOptions` field which allows users to tell the compiler/language service which watching strategies should be used to keep track of files and directories.\n\n### Assume Changes Only Affect Direct Dependencies - `assumeChangesOnlyAffectDirectDependencies`\n\nWhen this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them.\n\nThis can be considered a ‘fast & loose’ implementation of the watching algorithm, which can drastically reduce incremental rebuild times at the expense of having to run the full build occasionally to get all compiler error messages.\n\n- Released:\n\n  [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)\n\n## Watch Options\n\nYou can configure the how TypeScript `--watch` works. This section is mainly for handling case where `fs.watch` and `fs.watchFile` have additional constraints like on Linux. You can read more at [Configuring Watch](../docs/handbook/configuring-watch).\n\n### Watch File - `watchFile`\n\nThe strategy for how individual files are watched.\n\n- `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.\n- `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.\n- `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.\n- `useFsEvents` (the default): Attempt to use the operating system/file system’s native events for file changes.\n- `useFsEventsOnParentDirectory`: Attempt to use the operating system/file system’s native events to listen for changes on a file’s parent directory\n\n- Allowed:\n  - `fixedpollinginterval`\n\n  - `prioritypollinginterval`\n\n  - `dynamicprioritypolling`\n\n  - `fixedchunksizepolling`\n\n  - `usefsevents`\n\n  - `usefseventsonparentdirectory`\n\n- Released:\n\n  [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)\n\n### Watch Directory - `watchDirectory`\n\nThe strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality.\n\n- `fixedPollingInterval`: Check every directory for changes several times a second at a fixed interval.\n- `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified directories will be checked less often.\n- `useFsEvents` (the default): Attempt to use the operating system/file system’s native events for directory changes.\n\n- Allowed:\n  - `usefsevents`\n\n  - `fixedpollinginterval`\n\n  - `dynamicprioritypolling`\n\n  - `fixedchunksizepolling`\n\n- Released:\n\n  [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)\n\n### Fallback Polling - `fallbackPolling`\n\nWhen using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn’t support native file watchers.\n\n- `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.\n- `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.\n- `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.\n- `synchronousWatchDirectory`: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in `node_modules` from running `npm install`), but you might want to disable it with this flag for some less-common setups.\n\n- Allowed:\n  - `fixedinterval`\n\n  - `priorityinterval`\n\n  - `dynamicpriority`\n\n  - `fixedchunksize`\n\n- Released:\n\n  [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)\n\n### Synchronous Watch Directory - `synchronousWatchDirectory`\n\nSynchronously call callbacks and update the state of directory watchers on platforms that don\\`t support recursive watching natively. Instead of giving a small timeout to allow for potentially multiple edits to occur on a file.\n\n``` typescript\n{\n  \"watchOptions\": {\n    \"synchronousWatchDirectory\": true\n  }\n}\n```\n\n### Exclude Directories - `excludeDirectories`\n\nYou can use [`excludeFiles`](#excludeFiles) to drastically reduce the number of files which are watched during `--watch`. This can be a useful way to reduce the number of open file which TypeScript tracks on Linux.\n\n``` typescript\n{\n  \"watchOptions\": {\n    \"excludeDirectories\": [\"**/node_modules\", \"_build\", \"temp/*\"]\n  }\n}\n```\n\n### Exclude Files - `excludeFiles`\n\nYou can use `excludeFiles` to remove a set of specific files from the files which are watched.\n\n``` typescript\n{\n  \"watchOptions\": {\n    \"excludeFiles\": [\"temp/file.ts\"]\n  }\n}\n```\n\n## Type Acquisition\n\nType Acquisition is only important for JavaScript projects. In TypeScript projects you need to include the types in your projects explicitly. However, for JavaScript projects, the TypeScript tooling will download types for your modules in the background and outside of your node_modules folder.\n\n### Enable - `enable`\n\nDisables automatic type acquisition in JavaScript projects:\n\n``` json\n{\n  \"typeAcquisition\": {\n    \"enable\": false\n  }\n}\n```\n\n### Include - `include`\n\nIf you have a JavaScript project where TypeScript needs additional guidance to understand global dependencies, or have disabled the built-in inference via [`disableFilenameBasedTypeAcquisition`](#disableFilenameBasedTypeAcquisition).\n\nYou can use `include` to specify which types should be used from DefinitelyTyped:\n\n``` json\n{\n  \"typeAcquisition\": {\n    \"include\": [\"jquery\"]\n  }\n}\n```\n\n### Exclude - `exclude`\n\nOffers a config for disabling the type-acquisition for a certain module in JavaScript projects. This can be useful for projects which include other libraries in testing infrastructure which aren’t needed in the main application.\n\n``` json\n{\n  \"typeAcquisition\": {\n    \"exclude\": [\"jest\", \"mocha\"]\n  }\n}\n```\n\n### Disable Filename Based Type Acquisition - `disableFilenameBasedTypeAcquisition`\n\nTypeScript’s type acquisition can infer what types should be added based on filenames in a project. This means that having a file like `jquery.js` in your project would automatically download the types for JQuery from DefinitelyTyped.\n\nYou can disable this via `disableFilenameBasedTypeAcquisition`.\n\n``` json\n{\n  \"typeAcquisition\": {\n    \"disableFilenameBasedTypeAcquisition\": true\n  }\n}\n```\n\n- Released:\n\n  [4.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/tsconfig/](https://www.typescriptlang.org/tsconfig/)"
- name: Introduction
  id: declaration-files/introduction
  summary: The Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File
  description: "# Introduction\n\nThe Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started.\n\nIf you haven’t already, you should read the [TypeScript Handbook](../2/basic-types) to familiarize yourself with basic concepts, especially types and modules.\n\nThe most common case for learning how .d.ts files work is that you’re typing an npm package with no types. In that case, you can jump straight to [Modules .d.ts](templates/module-d-ts).\n\nThe Declaration Files section is broken down into the following sections.\n\nWe are often faced with writing a declaration file when we only have examples of the underlying library to guide us. The [Declaration Reference](by-example) section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.\n\nThe [Library Structures](library-structures) guide helps you understand common library formats and how to write a proper declaration file for each format. If you’re editing an existing file, you probably don’t need to read this section. Authors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file.\n\nIn the Template section you’ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.\n\nMany common mistakes in declaration files can be easily avoided. The [Do’s and Don’ts](do-s-and-don-ts) section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.\n\nFor seasoned authors interested in the underlying mechanics of how declaration files work, the [Deep Dive](deep-dive) section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.\n\nThe [Publishing](publishing) section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.\n\nFor JavaScript library users, the [Consumption](consumption) section offers a few simple steps to locate and install corresponding declaration files.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)"
- name: 'Introduction: Declaration Reference'
  id: declaration-files/introduction#declaration-reference
  summary: The Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File
  belongs_to: Introduction
  description: "# Introduction\n\nThe Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started.\n\nIf you haven’t already, you should read the [TypeScript Handbook](../2/basic-types) to familiarize yourself with basic concepts, especially types and modules.\n\nThe most common case for learning how .d.ts files work is that you’re typing an npm package with no types. In that case, you can jump straight to [Modules .d.ts](templates/module-d-ts).\n\nThe Declaration Files section is broken down into the following sections.\n\nWe are often faced with writing a declaration file when we only have examples of the underlying library to guide us. The [Declaration Reference](by-example) section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.\n\nThe [Library Structures](library-structures) guide helps you understand common library formats and how to write a proper declaration file for each format. If you’re editing an existing file, you probably don’t need to read this section. Authors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file.\n\nIn the Template section you’ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.\n\nMany common mistakes in declaration files can be easily avoided. The [Do’s and Don’ts](do-s-and-don-ts) section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.\n\nFor seasoned authors interested in the underlying mechanics of how declaration files work, the [Deep Dive](deep-dive) section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.\n\nThe [Publishing](publishing) section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.\n\nFor JavaScript library users, the [Consumption](consumption) section offers a few simple steps to locate and install corresponding declaration files.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)"
- name: 'Introduction: Deep Dive'
  id: declaration-files/introduction#deep-dive
  summary: The Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File
  belongs_to: Introduction
  description: "# Introduction\n\nThe Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started.\n\nIf you haven’t already, you should read the [TypeScript Handbook](../2/basic-types) to familiarize yourself with basic concepts, especially types and modules.\n\nThe most common case for learning how .d.ts files work is that you’re typing an npm package with no types. In that case, you can jump straight to [Modules .d.ts](templates/module-d-ts).\n\nThe Declaration Files section is broken down into the following sections.\n\nWe are often faced with writing a declaration file when we only have examples of the underlying library to guide us. The [Declaration Reference](by-example) section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.\n\nThe [Library Structures](library-structures) guide helps you understand common library formats and how to write a proper declaration file for each format. If you’re editing an existing file, you probably don’t need to read this section. Authors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file.\n\nIn the Template section you’ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.\n\nMany common mistakes in declaration files can be easily avoided. The [Do’s and Don’ts](do-s-and-don-ts) section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.\n\nFor seasoned authors interested in the underlying mechanics of how declaration files work, the [Deep Dive](deep-dive) section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.\n\nThe [Publishing](publishing) section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.\n\nFor JavaScript library users, the [Consumption](consumption) section offers a few simple steps to locate and install corresponding declaration files.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)"
- name: 'Introduction: Do’s and Don’ts'
  id: declaration-files/introduction#dos-and-donts
  summary: The Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File
  belongs_to: Introduction
  description: "# Introduction\n\nThe Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started.\n\nIf you haven’t already, you should read the [TypeScript Handbook](../2/basic-types) to familiarize yourself with basic concepts, especially types and modules.\n\nThe most common case for learning how .d.ts files work is that you’re typing an npm package with no types. In that case, you can jump straight to [Modules .d.ts](templates/module-d-ts).\n\nThe Declaration Files section is broken down into the following sections.\n\nWe are often faced with writing a declaration file when we only have examples of the underlying library to guide us. The [Declaration Reference](by-example) section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.\n\nThe [Library Structures](library-structures) guide helps you understand common library formats and how to write a proper declaration file for each format. If you’re editing an existing file, you probably don’t need to read this section. Authors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file.\n\nIn the Template section you’ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.\n\nMany common mistakes in declaration files can be easily avoided. The [Do’s and Don’ts](do-s-and-don-ts) section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.\n\nFor seasoned authors interested in the underlying mechanics of how declaration files work, the [Deep Dive](deep-dive) section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.\n\nThe [Publishing](publishing) section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.\n\nFor JavaScript library users, the [Consumption](consumption) section offers a few simple steps to locate and install corresponding declaration files.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)"
- name: 'Introduction: Find and Install Declaration Files'
  id: declaration-files/introduction#find-and-install-declaration-files
  summary: The Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File
  belongs_to: Introduction
  description: "# Introduction\n\nThe Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started.\n\nIf you haven’t already, you should read the [TypeScript Handbook](../2/basic-types) to familiarize yourself with basic concepts, especially types and modules.\n\nThe most common case for learning how .d.ts files work is that you’re typing an npm package with no types. In that case, you can jump straight to [Modules .d.ts](templates/module-d-ts).\n\nThe Declaration Files section is broken down into the following sections.\n\nWe are often faced with writing a declaration file when we only have examples of the underlying library to guide us. The [Declaration Reference](by-example) section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.\n\nThe [Library Structures](library-structures) guide helps you understand common library formats and how to write a proper declaration file for each format. If you’re editing an existing file, you probably don’t need to read this section. Authors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file.\n\nIn the Template section you’ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.\n\nMany common mistakes in declaration files can be easily avoided. The [Do’s and Don’ts](do-s-and-don-ts) section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.\n\nFor seasoned authors interested in the underlying mechanics of how declaration files work, the [Deep Dive](deep-dive) section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.\n\nThe [Publishing](publishing) section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.\n\nFor JavaScript library users, the [Consumption](consumption) section offers a few simple steps to locate and install corresponding declaration files.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)"
- name: 'Introduction: Library Structures'
  id: declaration-files/introduction#library-structures
  summary: The Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File
  belongs_to: Introduction
  description: "# Introduction\n\nThe Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started.\n\nIf you haven’t already, you should read the [TypeScript Handbook](../2/basic-types) to familiarize yourself with basic concepts, especially types and modules.\n\nThe most common case for learning how .d.ts files work is that you’re typing an npm package with no types. In that case, you can jump straight to [Modules .d.ts](templates/module-d-ts).\n\nThe Declaration Files section is broken down into the following sections.\n\nWe are often faced with writing a declaration file when we only have examples of the underlying library to guide us. The [Declaration Reference](by-example) section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.\n\nThe [Library Structures](library-structures) guide helps you understand common library formats and how to write a proper declaration file for each format. If you’re editing an existing file, you probably don’t need to read this section. Authors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file.\n\nIn the Template section you’ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.\n\nMany common mistakes in declaration files can be easily avoided. The [Do’s and Don’ts](do-s-and-don-ts) section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.\n\nFor seasoned authors interested in the underlying mechanics of how declaration files work, the [Deep Dive](deep-dive) section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.\n\nThe [Publishing](publishing) section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.\n\nFor JavaScript library users, the [Consumption](consumption) section offers a few simple steps to locate and install corresponding declaration files.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)"
- name: 'Introduction: Publish to npm'
  id: declaration-files/introduction#publish-to-npm
  summary: The Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File
  belongs_to: Introduction
  description: "# Introduction\n\nThe Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started.\n\nIf you haven’t already, you should read the [TypeScript Handbook](../2/basic-types) to familiarize yourself with basic concepts, especially types and modules.\n\nThe most common case for learning how .d.ts files work is that you’re typing an npm package with no types. In that case, you can jump straight to [Modules .d.ts](templates/module-d-ts).\n\nThe Declaration Files section is broken down into the following sections.\n\nWe are often faced with writing a declaration file when we only have examples of the underlying library to guide us. The [Declaration Reference](by-example) section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.\n\nThe [Library Structures](library-structures) guide helps you understand common library formats and how to write a proper declaration file for each format. If you’re editing an existing file, you probably don’t need to read this section. Authors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file.\n\nIn the Template section you’ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.\n\nMany common mistakes in declaration files can be easily avoided. The [Do’s and Don’ts](do-s-and-don-ts) section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.\n\nFor seasoned authors interested in the underlying mechanics of how declaration files work, the [Deep Dive](deep-dive) section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.\n\nThe [Publishing](publishing) section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.\n\nFor JavaScript library users, the [Consumption](consumption) section offers a few simple steps to locate and install corresponding declaration files.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)"
- name: isolatedDeclarations
  id: tsconfig/index#isolatedDeclarations-config
  summary: Require sufficient annotation on exports so other tools can trivially generate declaration files
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### isolatedDeclarations - `isolatedDeclarations`

    Require sufficient annotation on exports so other tools can trivially generate declaration files.

    For more information, see the [5.5 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#isolated-declarations)
- name: isolatedDeclarations
  id: tsconfig#isolatedDeclarations-config
  summary: Require sufficient annotation on exports so other tools can trivially generate declaration files
  belongs_to: TSConfig Reference
  description: |-
    ### isolatedDeclarations - `isolatedDeclarations`

    Require sufficient annotation on exports so other tools can trivially generate declaration files.

    For more information, see the [5.5 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#isolated-declarations)
- name: isolatedModules
  id: tsconfig#isolatedModules-config
  summary: While you can use TypeScript to produce JavaScript code from TypeScript code, it’s also common to use other transpilers such as Babel to do this
  belongs_to: TSConfig Reference
  description: |-
    ### Isolated Modules - `isolatedModules`

    While you can use TypeScript to produce JavaScript code from TypeScript code, it’s also common to use other transpilers such as [Babel](https://babeljs.io) to do this. However, other transpilers only operate on a single file at a time, which means they can’t apply code transforms that depend on understanding the full type system. This restriction also applies to TypeScript’s `ts.transpileModule` API which is used by some build tools.

    These limitations can cause runtime problems with some TypeScript features like `const enum`s and `namespace`s. Setting the `isolatedModules` flag tells TypeScript to warn you if you write certain code that can’t be correctly interpreted by a single-file transpilation process.

    It does not change the behavior of your code, or otherwise change the behavior of TypeScript’s checking and emitting process.

    Some examples of code which does not work when `isolatedModules` is enabled.

    #### Exports of Non-Value Identifiers

    In TypeScript, you can import a *type* and then subsequently export it:

    ``` ts
    import { someType, someFunction } from "someModule";
     
    someFunction();
     
    export { someType, someFunction };
    ```

    Because there’s no value for `someType`, the emitted `export` will not try to export it (this would be a runtime error in JavaScript):

    ``` js
    export { someFunction };
    ```

    Single-file transpilers don’t know whether `someType` produces a value or not, so it’s an error to export a name that only refers to a type.

    #### Non-Module Files

    If `isolatedModules` is set, namespaces are only allowed in *modules* (which means it has some form of `import`/`export`). An error occurs if a namespace is found in a non-module file:

    ``` ts
    namespace Instantiated {
      export const x = 1;
    }
    ```

    This restriction doesn’t apply to `.d.ts` files.

    #### References to `const enum` members

    In TypeScript, when you reference a `const enum` member, the reference is replaced by its actual value in the emitted JavaScript. Changing this TypeScript:

    ``` ts
    declare const enum Numbers {
      Zero = 0,
      One = 1,
    }
    console.log(Numbers.Zero + Numbers.One);
    ```

    To this JavaScript:

    ``` ts
    "use strict";
    console.log(0 + 1);
     
    ```

    Without knowledge of the values of these members, other transpilers can’t replace the references to `Numbers`, which would be a runtime error if left alone (since there are no `Numbers` object at runtime). Because of this, when `isolatedModules` is set, it is an error to reference an ambient `const enum` member.

    - Default:

      `true` if [`verbatimModuleSyntax`](#verbatimModuleSyntax); `false` otherwise.
- name: isolatedModules
  id: tsconfig/index#isolatedModules-config
  summary: While you can use TypeScript to produce JavaScript code from TypeScript code, it’s also common to use other transpilers such as Babel to do this
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Isolated Modules - `isolatedModules`

    While you can use TypeScript to produce JavaScript code from TypeScript code, it’s also common to use other transpilers such as [Babel](https://babeljs.io) to do this. However, other transpilers only operate on a single file at a time, which means they can’t apply code transforms that depend on understanding the full type system. This restriction also applies to TypeScript’s `ts.transpileModule` API which is used by some build tools.

    These limitations can cause runtime problems with some TypeScript features like `const enum`s and `namespace`s. Setting the `isolatedModules` flag tells TypeScript to warn you if you write certain code that can’t be correctly interpreted by a single-file transpilation process.

    It does not change the behavior of your code, or otherwise change the behavior of TypeScript’s checking and emitting process.

    Some examples of code which does not work when `isolatedModules` is enabled.

    #### Exports of Non-Value Identifiers

    In TypeScript, you can import a *type* and then subsequently export it:

    ``` ts
    import { someType, someFunction } from "someModule";
     
    someFunction();
     
    export { someType, someFunction };
    ```

    Because there’s no value for `someType`, the emitted `export` will not try to export it (this would be a runtime error in JavaScript):

    ``` js
    export { someFunction };
    ```

    Single-file transpilers don’t know whether `someType` produces a value or not, so it’s an error to export a name that only refers to a type.

    #### Non-Module Files

    If `isolatedModules` is set, namespaces are only allowed in *modules* (which means it has some form of `import`/`export`). An error occurs if a namespace is found in a non-module file:

    ``` ts
    namespace Instantiated {
      export const x = 1;
    }
    ```

    This restriction doesn’t apply to `.d.ts` files.

    #### References to `const enum` members

    In TypeScript, when you reference a `const enum` member, the reference is replaced by its actual value in the emitted JavaScript. Changing this TypeScript:

    ``` ts
    declare const enum Numbers {
      Zero = 0,
      One = 1,
    }
    console.log(Numbers.Zero + Numbers.One);
    ```

    To this JavaScript:

    ``` ts
    "use strict";
    console.log(0 + 1);
     
    ```

    Without knowledge of the values of these members, other transpilers can’t replace the references to `Numbers`, which would be a runtime error if left alone (since there are no `Numbers` object at runtime). Because of this, when `isolatedModules` is set, it is an error to reference an ambient `const enum` member.

    - Default:

      `true` if [`verbatimModuleSyntax`](#verbatimModuleSyntax); `false` otherwise.
- name: Iterators and Generators
  id: iterators-and-generators
  summary: An object is deemed iterable if it has an implementation for the Symbol.iterator property
  description: "# Iterators and Generators\n\n## Iterables\n\nAn object is deemed iterable if it has an implementation for the [`Symbol.iterator`](symbols#symboliterator) property. Some built-in types like `Array`, `Map`, `Set`, `String`, `Int32Array`, `Uint32Array`, etc. have their `Symbol.iterator` property already implemented. `Symbol.iterator` function on an object is responsible for returning the list of values to iterate on.\n\n### `Iterable` interface\n\n`Iterable` is a type we can use if we want to take in types listed above which are iterable. Here is an example:\n\n``` ts\nfunction toArray<X>(xs: Iterable<X>): X[] {\n  return [...xs]\n}\n```\n\n### `for..of` statements\n\n`for..of` loops over an iterable object, invoking the `Symbol.iterator` property on the object. Here is a simple `for..of` loop on an array:\n\n``` ts\nlet someArray = [1, \"string\", false];\n\nfor (let entry of someArray) {\n  console.log(entry); // 1, \"string\", false\n}\n```\n\n### `for..of` vs. `for..in` statements\n\nBoth `for..of` and `for..in` statements iterate over lists; the values iterated on are different though, `for..in` returns a list of *keys* on the object being iterated, whereas `for..of` returns a list of *values* of the numeric properties of the object being iterated.\n\nHere is an example that demonstrates this distinction:\n\n``` ts\nlet list = [4, 5, 6];\n\nfor (let i in list) {\n  console.log(i); // \"0\", \"1\", \"2\",\n}\n\nfor (let i of list) {\n  console.log(i); // 4, 5, 6\n}\n```\n\nAnother distinction is that `for..in` operates on any object; it serves as a way to inspect properties on this object. `for..of` on the other hand, is mainly interested in values of iterable objects. Built-in objects like `Map` and `Set` implement `Symbol.iterator` property allowing access to stored values.\n\n``` ts\nlet pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);\npets[\"species\"] = \"mammals\";\n\nfor (let pet in pets) {\n  console.log(pet); // \"species\"\n}\n\nfor (let pet of pets) {\n  console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"\n}\n```\n\n### Code generation\n\n#### Targeting ES5 and ES3\n\nWhen targeting an ES5 or ES3-compliant engine, iterators are only allowed on values of `Array` type. It is an error to use `for..of` loops on non-Array values, even if these non-Array values implement the `Symbol.iterator` property.\n\nThe compiler will generate a simple `for` loop for a `for..of` loop, for instance:\n\n``` ts\nlet numbers = [1, 2, 3];\nfor (let num of numbers) {\n  console.log(num);\n}\n```\n\nwill be generated as:\n\n``` js\nvar numbers = [1, 2, 3];\nfor (var _i = 0; _i < numbers.length; _i++) {\n  var num = numbers[_i];\n  console.log(num);\n}\n```\n\n#### Targeting ECMAScript 2015 and higher\n\nWhen targeting an ECMAScript 2015-compliant engine, the compiler will generate `for..of` loops to target the built-in iterator implementation in the engine.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html)"
- name: 'Iterators and Generators: for..of statements'
  id: iterators-and-generators#forof-statements
  summary: for..of loops over an iterable object, invoking the Symbol.iterator property on the object
  belongs_to: Iterators and Generators
  description: |-
    ### `for..of` statements

    `for..of` loops over an iterable object, invoking the `Symbol.iterator` property on the object. Here is a simple `for..of` loop on an array:

    ``` ts
    let someArray = [1, "string", false];

    for (let entry of someArray) {
      console.log(entry); // 1, "string", false
    }
    ```
- name: 'Iterators and Generators: for..of vs. for..in statements'
  id: iterators-and-generators#forof-vs-forin-statements
  summary: Both for..of and for..in statements iterate over lists; the values iterated on are different though, for..in returns a list of keys on the object being iterated, whereas for..of returns a list of values of the numeric properties of the object being iterated
  belongs_to: Iterators and Generators
  description: "### `for..of` vs. `for..in` statements\n\nBoth `for..of` and `for..in` statements iterate over lists; the values iterated on are different though, `for..in` returns a list of *keys* on the object being iterated, whereas `for..of` returns a list of *values* of the numeric properties of the object being iterated.\n\nHere is an example that demonstrates this distinction:\n\n``` ts\nlet list = [4, 5, 6];\n\nfor (let i in list) {\n  console.log(i); // \"0\", \"1\", \"2\",\n}\n\nfor (let i of list) {\n  console.log(i); // 4, 5, 6\n}\n```\n\nAnother distinction is that `for..in` operates on any object; it serves as a way to inspect properties on this object. `for..of` on the other hand, is mainly interested in values of iterable objects. Built-in objects like `Map` and `Set` implement `Symbol.iterator` property allowing access to stored values.\n\n``` ts\nlet pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);\npets[\"species\"] = \"mammals\";\n\nfor (let pet in pets) {\n  console.log(pet); // \"species\"\n}\n\nfor (let pet of pets) {\n  console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"\n}\n```\n\n### Code generation\n\n#### Targeting ES5 and ES3\n\nWhen targeting an ES5 or ES3-compliant engine, iterators are only allowed on values of `Array` type. It is an error to use `for..of` loops on non-Array values, even if these non-Array values implement the `Symbol.iterator` property.\n\nThe compiler will generate a simple `for` loop for a `for..of` loop, for instance:\n\n``` ts\nlet numbers = [1, 2, 3];\nfor (let num of numbers) {\n  console.log(num);\n}\n```\n\nwill be generated as:\n\n``` js\nvar numbers = [1, 2, 3];\nfor (var _i = 0; _i < numbers.length; _i++) {\n  var num = numbers[_i];\n  console.log(num);\n}\n```\n\n#### Targeting ECMAScript 2015 and higher\n\nWhen targeting an ECMAScript 2015-compliant engine, the compiler will generate `for..of` loops to target the built-in iterator implementation in the engine.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html)"
- name: 'Iterators and Generators: Iterable interface'
  id: iterators-and-generators#iterable-interface
  summary: Iterable is a type we can use if we want to take in types listed above which are iterable
  belongs_to: Iterators and Generators
  description: |-
    ### `Iterable` interface

    `Iterable` is a type we can use if we want to take in types listed above which are iterable. Here is an example:

    ``` ts
    function toArray<X>(xs: Iterable<X>): X[] {
      return [...xs]
    }
    ```
- name: 'Iterators and Generators: Iterables'
  id: iterators-and-generators#iterables
  summary: An object is deemed iterable if it has an implementation for the Symbol.iterator property
  belongs_to: Iterators and Generators
  description: |-
    ## Iterables

    An object is deemed iterable if it has an implementation for the [`Symbol.iterator`](symbols#symboliterator) property. Some built-in types like `Array`, `Map`, `Set`, `String`, `Int32Array`, `Uint32Array`, etc. have their `Symbol.iterator` property already implemented. `Symbol.iterator` function on an object is responsible for returning the list of values to iterate on.
- name: JS Projects Utilizing TypeScript
  id: intro-to-js-ts
  summary: Each step represents a move towards a safer type-system, but not every project needs that level of verification
  description: "# JS Projects Utilizing TypeScript\n\nThe type system in TypeScript has different levels of strictness when working with a codebase:\n\n- A type-system based only on inference with JavaScript code\n- Incremental typing in JavaScript [via JSDoc](jsdoc-supported-types)\n- Using `// @ts-check` in a JavaScript file\n- TypeScript code\n- TypeScript with [`strict`](https://www.typescriptlang.org/tsconfig#strict) enabled\n\nEach step represents a move towards a safer type-system, but not every project needs that level of verification.\n\n## TypeScript with JavaScript\n\nThis is when you use an editor which uses TypeScript to provide tooling like auto-complete, jump to symbol and refactoring tools like rename. The [homepage](https://www.typescriptlang.org/) has a list of editors which have TypeScript plugins.\n\n## Providing Type Hints in JS via JSDoc\n\nIn a `.js` file, types can often be inferred. When types can’t be inferred, they can be specified using JSDoc syntax.\n\nJSDoc annotations come before a declaration will be used to set the type of that declaration. For example:\n\n``` js\n/** @type {number} */\nvar x;\n \nx = 0; // OK\nx = false; // OK?!\n```\n\nYou can find the full list of supported JSDoc patterns [in JSDoc Supported Types](jsdoc-supported-types).\n\n## `@ts-check`\n\nThe last line of the previous code sample would raise an error in TypeScript, but it doesn’t by default in a JS project. To enable errors in your JavaScript files add: `// @ts-check` to the first line in your `.js` files to have TypeScript raise it as an error.\n\n``` js\n// @ts-check\n/** @type {number} */\nvar x;\n \nx = 0; // OK\nx = false; // Not OK\n```\n\nIf you have a lot of JavaScript files you want to add errors to then you can switch to using a [`jsconfig.json`](tsconfig-json). You can skip checking some files by adding a `// @ts-nocheck` comment to files.\n\nTypeScript may offer you errors which you disagree with, in those cases you can ignore errors on specific lines by adding `// @ts-ignore` or `// @ts-expect-error` on the preceding line.\n\n``` js\n// @ts-check\n/** @type {number} */\nvar x;\n \nx = 0; // OK\n// @ts-expect-error\nx = false; // Not OK\n```\n\nTo learn more about how JavaScript is interpreted by TypeScript read [How TS Type Checks JS](type-checking-javascript-files)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html](https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html)"
- name: 'JS Projects Utilizing TypeScript: @ts-check'
  id: intro-to-js-ts#ts-check
  summary: The last line of the previous code sample would raise an error in TypeScript, but it doesn’t by default in a JS project
  belongs_to: JS Projects Utilizing TypeScript
  description: "## `@ts-check`\n\nThe last line of the previous code sample would raise an error in TypeScript, but it doesn’t by default in a JS project. To enable errors in your JavaScript files add: `// @ts-check` to the first line in your `.js` files to have TypeScript raise it as an error.\n\n``` js\n// @ts-check\n/** @type {number} */\nvar x;\n \nx = 0; // OK\nx = false; // Not OK\n```\n\nIf you have a lot of JavaScript files you want to add errors to then you can switch to using a [`jsconfig.json`](tsconfig-json). You can skip checking some files by adding a `// @ts-nocheck` comment to files.\n\nTypeScript may offer you errors which you disagree with, in those cases you can ignore errors on specific lines by adding `// @ts-ignore` or `// @ts-expect-error` on the preceding line.\n\n``` js\n// @ts-check\n/** @type {number} */\nvar x;\n \nx = 0; // OK\n// @ts-expect-error\nx = false; // Not OK\n```\n\nTo learn more about how JavaScript is interpreted by TypeScript read [How TS Type Checks JS](type-checking-javascript-files)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html](https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html)"
- name: 'JS Projects Utilizing TypeScript: Providing Type Hints in JS via JSDoc'
  id: intro-to-js-ts#providing-type-hints-in-js-via-jsdoc
  summary: In a .js file, types can often be inferred
  belongs_to: JS Projects Utilizing TypeScript
  description: |-
    ## Providing Type Hints in JS via JSDoc

    In a `.js` file, types can often be inferred. When types can’t be inferred, they can be specified using JSDoc syntax.

    JSDoc annotations come before a declaration will be used to set the type of that declaration. For example:

    ``` js
    /** @type {number} */
    var x;
     
    x = 0; // OK
    x = false; // OK?!
    ```

    You can find the full list of supported JSDoc patterns [in JSDoc Supported Types](jsdoc-supported-types).
- name: 'JS Projects Utilizing TypeScript: TypeScript with JavaScript'
  id: intro-to-js-ts#typescript-with-javascript
  summary: This is when you use an editor which uses TypeScript to provide tooling like auto-complete, jump to symbol and refactoring tools like rename
  belongs_to: JS Projects Utilizing TypeScript
  description: |-
    ## TypeScript with JavaScript

    This is when you use an editor which uses TypeScript to provide tooling like auto-complete, jump to symbol and refactoring tools like rename. The [homepage](https://www.typescriptlang.org/) has a list of editors which have TypeScript plugins.
- name: JSDoc Reference
  id: jsdoc-supported-types
  summary: The list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files
  description: "# JSDoc Reference\n\nThe list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files.\n\nNote:\n\n- Any tags which are not explicitly listed below (such as `@async`) are not yet supported.\n- Only documentation tags are supported in TypeScript files. The rest of the tags are only supported in JavaScript files.\n\n#### Types\n\n- [`@type`](#type)\n- [`@param`](#param-and-returns) (or [`@arg`](#param-and-returns) or [`@argument`](#param-and-returns))\n- [`@returns`](#param-and-returns) (or [`@return`](#param-and-returns))\n- [`@typedef`](#typedef-callback-and-param)\n- [`@callback`](#typedef-callback-and-param)\n- [`@template`](#template)\n- [`@satisfies`](#satisfies)\n\n#### Classes\n\n- [Property Modifiers](#property-modifiers) `@public`, `@private`, `@protected`, `@readonly`\n- [`@override`](#override)\n- [`@extends`](#extends) (or [`@augments`](#extends))\n- [`@implements`](#implements)\n- [`@class`](#constructor) (or [`@constructor`](#constructor))\n- [`@this`](#this)\n\n#### Documentation\n\nDocumentation tags work in both TypeScript and JavaScript.\n\n- [`@deprecated`](#deprecated)\n- [`@see`](#see)\n- [`@link`](#link)\n\n#### Other\n\n- [`@enum`](#enum)\n- [`@author`](#author)\n- [Other supported patterns](#other-supported-patterns)\n- [Unsupported patterns](#unsupported-patterns)\n- [Unsupported tags](#unsupported-tags)\n\nThe meaning is usually the same, or a superset, of the meaning of the tag given at [jsdoc.app](https://jsdoc.app). The code below describes the differences and gives some example usage of each tag.\n\n**Note:** You can use [the playground to explore JSDoc support](https://www.typescriptlang.org/play?useJavaScript=truee=4#example/jsdoc-support).\n\n## Types\n\n### `@type`\n\nYou can reference types with the “@type” tag. The type can be:\n\n1.  Primitive, like `string` or `number`.\n2.  Declared in a TypeScript declaration, either global or imported.\n3.  Declared in a JSDoc [`@typedef`](#typedef-callback-and-param) tag.\n\nYou can use most JSDoc type syntax and any TypeScript syntax, from [the most basic like `string`](2/basic-types) to [the most advanced, like conditional types](2/conditional-types).\n\n``` js\n/**\n * @type {string}\n */\nvar s;\n \n/** @type {Window} */\nvar win;\n \n/** @type {PromiseLike<string>} */\nvar promisedString;\n \n// You can specify an HTML Element with DOM properties\n/** @type {HTMLElement} */\nvar myElement = document.querySelector(selector);\nelement.dataset.myData = \"\";\n```\n\n`@type` can specify a union type — for example, something can be either a string or a boolean.\n\n``` js\n/**\n * @type {string | boolean}\n */\nvar sb;\n```\n\nYou can specify array types using a variety of syntaxes:\n\n``` js\n/** @type {number[]} */\nvar ns;\n/** @type {Array.<number>} */\nvar jsdoc;\n/** @type {Array<number>} */\nvar nas;\n```\n\nYou can also specify object literal types. For example, an object with properties ‘a’ (string) and ‘b’ (number) uses the following syntax:\n\n``` js\n/** @type {{ a: string, b: number }} */\nvar var9;\n```\n\nYou can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or TypeScript syntax.\n\n``` js\n/**\n * A map-like object that maps arbitrary `string` properties to `number`s.\n *\n * @type {Object.<string, number>}\n */\nvar stringToNumber;\n \n/** @type {Object.<number, object>} */\nvar arrayLike;\n```\n\nThe preceding two types are equivalent to the TypeScript types `{ [x: string]: number }` and `{ [x: number]: any }`. The compiler understands both syntaxes.\n\nYou can specify function types using either TypeScript or Google Closure syntax:\n\n``` js\n/** @type {function(string, boolean): number} Closure syntax */\nvar sbn;\n/** @type {(s: string, b: boolean) => number} TypeScript syntax */\nvar sbn2;\n```\n\nOr you can just use the unspecified `Function` type:\n\n``` js\n/** @type {Function} */\nvar fn7;\n/** @type {function} */\nvar fn6;\n```\n\nOther types from Closure also work:\n\n``` js\n/**\n * @type {*} - can be 'any' type\n */\nvar star;\n/**\n * @type {?} - unknown type (same as 'any')\n */\nvar question;\n```\n\n#### Casts\n\nTypeScript borrows cast syntax from Google Closure. This lets you cast types to other types by adding a `@type` tag before any parenthesized expression.\n\n``` js\n/**\n * @type {number | string}\n */\nvar numberOrString = Math.random() < 0.5 ? \"hello\" : 100;\nvar typeAssertedNumber = /** @type {number} */ (numberOrString);\n```\n\nYou can even cast to `const` just like TypeScript:\n\n``` js\nlet one = /** @type {const} */(1);\n```\n\n#### Import types\n\nYou can import declarations from other files using import types. This syntax is TypeScript-specific and differs from the JSDoc standard:\n\n``` js\n// @filename: types.d.ts\nexport type Pet = {\n  name: string,\n};\n \n// @filename: main.js\n/**\n * @param {import(\"./types\").Pet} p\n */\nfunction walk(p) {\n  console.log(`Walking ${p.name}...`);\n}\n```\n\nimport types can be used in type alias declarations:\n\n``` js\n/**\n * @typedef {import(\"./types\").Pet} Pet\n */\n \n/**\n * @type {Pet}\n */\nvar myPet;\nmyPet.name;\n```\n\nimport types can be used to get the type of a value from a module if you don’t know the type, or if it has a large type that is annoying to type:\n\n``` js\n/**\n * @type {typeof import(\"./accounts\").userAccount}\n */\nvar x = require(\"./accounts\").userAccount;\n```\n\n### `@param` and `@returns`\n\n`@param` uses the same type syntax as `@type`, but adds a parameter name. The parameter may also be declared optional by surrounding the name with square brackets:\n\n``` js\n// Parameters may be declared in a variety of syntactic forms\n/**\n * @param {string}  p1 - A string param.\n * @param {string=} p2 - An optional param (Google Closure syntax)\n * @param {string} [p3] - Another optional param (JSDoc syntax).\n * @param {string} [p4=\"test\"] - An optional param with a default value\n * @returns {string} This is the result\n */\nfunction stringsStringStrings(p1, p2, p3, p4) {\n  // TODO\n}\n```\n\nLikewise, for the return type of a function:\n\n``` js\n/**\n * @return {PromiseLike<string>}\n */\nfunction ps() {}\n \n/**\n * @returns {{ a: string, b: number }} - May use '@returns' as well as '@return'\n */\nfunction ab() {}\n```\n\n### `@typedef`, `@callback`, and `@param`\n\nYou can define complex types with `@typedef`. Similar syntax works with `@param`.\n\n``` js\n/**\n * @typedef {Object} SpecialType - creates a new type named 'SpecialType'\n * @property {string} prop1 - a string property of SpecialType\n * @property {number} prop2 - a number property of SpecialType\n * @property {number=} prop3 - an optional number property of SpecialType\n * @prop {number} [prop4] - an optional number property of SpecialType\n * @prop {number} [prop5=42] - an optional number property of SpecialType with default\n */\n \n/** @type {SpecialType} */\nvar specialTypeObject;\nspecialTypeObject.prop3;\n```\n\nYou can use either `object` or `Object` on the first line.\n\n``` js\n/**\n * @typedef {object} SpecialType1 - creates a new type named 'SpecialType1'\n * @property {string} prop1 - a string property of SpecialType1\n * @property {number} prop2 - a number property of SpecialType1\n * @property {number=} prop3 - an optional number property of SpecialType1\n */\n \n/** @type {SpecialType1} */\nvar specialTypeObject1;\n```\n\n`@param` allows a similar syntax for one-off type specifications. Note that the nested property names must be prefixed with the name of the parameter:\n\n``` js\n/**\n * @param {Object} options - The shape is the same as SpecialType above\n * @param {string} options.prop1\n * @param {number} options.prop2\n * @param {number=} options.prop3\n * @param {number} [options.prop4]\n * @param {number} [options.prop5=42]\n */\nfunction special(options) {\n  return (options.prop4 || 1001) + options.prop5;\n}\n```\n\n`@callback` is similar to `@typedef`, but it specifies a function type instead of an object type:\n\n``` js\n/**\n * @callback Predicate\n * @param {string} data\n * @param {number} [index]\n * @returns {boolean}\n */\n \n/** @type {Predicate} */\nconst ok = (s) => !(s.length % 2);\n```\n\nOf course, any of these types can be declared using TypeScript syntax in a single-line `@typedef`:\n\n``` js\n/** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */\n/** @typedef {(data: string, index?: number) => boolean} Predicate */\n```\n\n### `@template`\n\nYou can declare type parameters with the `@template` tag. This lets you make functions, classes, or types that are generic:\n\n``` js\n/**\n * @template T\n * @param {T} x - A generic parameter that flows through to the return type\n * @returns {T}\n */\nfunction id(x) {\n  return x;\n}\n \nconst a = id(\"string\");\nconst b = id(123);\nconst c = id({});\n```\n\nUse comma or multiple tags to declare multiple type parameters:\n\n``` js\n/**\n * @template T,U,V\n * @template W,X\n */\n```\n\nYou can also specify a type constraint before the type parameter name. Only the first type parameter in a list is constrained:\n\n``` js\n/**\n * @template {string} K - K must be a string or string literal\n * @template {{ serious(): string }} Seriousalizable - must have a serious method\n * @param {K} key\n * @param {Seriousalizable} object\n */\nfunction seriousalize(key, object) {\n  // ????\n}\n```\n\nFinally, you can specify a default for a type parameter:\n\n``` js\n/** @template [T=object] */\nclass Cache {\n    /** @param {T} initial */\n    constructor(initial) {\n    }\n}\nlet c = new Cache()\n```\n\n### `@satisfies`\n\n`@satisfies` provides access to the postfix [operator `satisfies`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html) in TypeScript. Satisfies is used to declare that a value implements a type but does not affect the type of the value.\n\n``` js\n// @ts-check\n/**\n * @typedef {\"hello world\" | \"Hello, world\"} WelcomeMessage\n */\n \n/** @satisfies {WelcomeMessage} */\nconst message = \"hello world\"\n \n/** @satisfies {WelcomeMessage} */\nconst failingMessage = \"Hello world!\"\n \n/** @type {WelcomeMessage} */\nconst messageUsingType = \"hello world\"\n```\n\n## Classes\n\nClasses can be declared as ES6 classes.\n\n``` js\nclass C {\n  /**\n   * @param {number} data\n   */\n  constructor(data) {\n    // property types can be inferred\n    this.name = \"foo\";\n \n    // or set explicitly\n    /** @type {string | null} */\n    this.title = null;\n \n    // or simply annotated, if they're set elsewhere\n    /** @type {number} */\n    this.size;\n \n    this.initialize(data); // Should error, initializer expects a string\n  }\n  /**\n   * @param {string} s\n   */\n  initialize = function (s) {\n    this.size = s.length;\n  };\n}\n \nvar c = new C(0);\n \n// C should only be called with new, but\n// because it is JavaScript, this is allowed and\n// considered an 'any'.\nvar result = C(1);\n```\n\nThey can also be declared as constructor functions; use [`@constructor`](#constructor) along with [`@this`](#this) for this.\n\n### Property Modifiers\n\n`@public`, `@private`, and `@protected` work exactly like `public`, `private`, and `protected` in TypeScript:\n\n``` js\n// @ts-check\n \nclass Car {\n  constructor() {\n    /** @private */\n    this.identifier = 100;\n  }\n \n  printIdentifier() {\n    console.log(this.identifier);\n  }\n}\n \nconst c = new Car();\nconsole.log(c.identifier);\n```\n\n- `@public` is always implied and can be left off, but means that a property can be reached from anywhere.\n- `@private` means that a property can only be used within the containing class.\n- `@protected` means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.\n\n`@public`, `@private`, and `@protected` do not work in constructor functions.\n\n### `@readonly`\n\nThe `@readonly` modifier ensures that a property is only ever written to during initialization.\n\n``` js\n// @ts-check\n \nclass Car {\n  constructor() {\n    /** @readonly */\n    this.identifier = 100;\n  }\n \n  printIdentifier() {\n    console.log(this.identifier);\n  }\n}\n \nconst c = new Car();\nconsole.log(c.identifier);\n```\n\n### `@override`\n\n`@override` works the same way as in TypeScript; use it on methods that override a method from a base class:\n\n``` js\nexport class C {\n  m() { }\n}\nclass D extends C {\n  /** @override */\n  m() { }\n}\n```\n\nSet `noImplicitOverride: true` in tsconfig to check overrides.\n\n### `@extends`\n\nWhen JavaScript classes extend a generic base class, there is no JavaScript syntax for passing a type argument. The `@extends` tag allows this:\n\n``` js\n/**\n * @template T\n * @extends {Set<T>}\n */\nclass SortableSet extends Set {\n  // ...\n}\n```\n\nNote that `@extends` only works with classes. Currently, there is no way for a constructor function to extend a class.\n\n### `@implements`\n\nIn the same way, there is no JavaScript syntax for implementing a TypeScript interface. The `@implements` tag works just like in TypeScript:\n\n``` js\n/** @implements {Print} */\nclass TextBook {\n  print() {\n    // TODO\n  }\n}\n```\n\n### `@constructor`\n\nThe compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a `@constructor` tag:\n\n``` js\n/**\n * @constructor\n * @param {number} data\n */\nfunction C(data) {\n  // property types can be inferred\n  this.name = \"foo\";\n \n  // or set explicitly\n  /** @type {string | null} */\n  this.title = null;\n \n  // or simply annotated, if they're set elsewhere\n  /** @type {number} */\n  this.size;\n \n  this.initialize(data);\n}\n/**\n * @param {string} s\n */\nC.prototype.initialize = function (s) {\n  this.size = s.length;\n};\n \nvar c = new C(0);\nc.size;\n \nvar result = C(1);\n```\n\n> Note: Error messages only show up in JS codebases with [a JSConfig](tsconfig-json) and [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs) enabled.\n\nWith `@constructor`, `this` is checked inside the constructor function `C`, so you will get suggestions for the `initialize` method and an error if you pass it a number. Your editor may also show warnings if you call `C` instead of constructing it.\n\nUnfortunately, this means that constructor functions that are also callable cannot use `@constructor`.\n\n### `@this`\n\nThe compiler can usually figure out the type of `this` when it has some context to work with. When it doesn’t, you can explicitly specify the type of `this` with `@this`:\n\n``` js\n/**\n * @this {HTMLElement}\n * @param {*} e\n */\nfunction callbackForLater(e) {\n  this.clientHeight = parseInt(e); // should be fine!\n}\n```\n\n## Documentation\n\n### `@deprecated`\n\nWhen a function, method, or property is deprecated you can let users know by marking it with a `/** @deprecated */` JSDoc comment. That information is surfaced in completion lists and as a suggestion diagnostic that editors can handle specially. In an editor like VS Code, deprecated values are typically displayed in a strike-through style ~~like this~~.\n\n``` js\n/** @deprecated */\nconst apiV1 = {};\nconst apiV2 = {};\n \napiV;\n \n \n```\n\n### `@see`\n\n`@see` lets you link to other names in your program:\n\n``` ts\ntype Box<T> = { t: T }\n/** @see Box for implementation details */\ntype Boxify<T> = { [K in keyof T]: Box<T> };\n```\n\nSome editors will turn `Box` into a link to make it easy to jump there and back.\n\n### `@link`\n\n`@link` is like `@see`, except that it can be used inside other tags:\n\n``` ts\ntype Box<T> = { t: T }\n/** @returns A {@link Box} containing the parameter. */\nfunction box<U>(u: U): Box<U> {\n  return { t: u };\n}\n```\n\n## Other\n\n### `@enum`\n\nThe `@enum` tag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in JavaScript, it does not allow other members. `@enum` is intended for compatibility with Google Closure’s `@enum` tag.\n\n``` js\n/** @enum {number} */\nconst JSDocState = {\n  BeginningOfLine: 0,\n  SawAsterisk: 1,\n  SavingComments: 2,\n};\n \nJSDocState.SawAsterisk;\n```\n\nNote that `@enum` is quite different from, and much simpler than, TypeScript’s `enum`. However, unlike TypeScript’s enums, `@enum` can have any type:\n\n``` js\n/** @enum {function(number): number} */\nconst MathFuncs = {\n  add1: (n) => n + 1,\n  id: (n) => -n,\n  sub1: (n) => n - 1,\n};\n \nMathFuncs.add1;\n```\n\n### `@author`\n\nYou can specify the author of an item with `@author`:\n\n``` ts\n/**\n * Welcome to awesome.ts\n * @author Ian Awesome <i.am.awesome@example.com>\n */\n```\n\nRemember to surround the email address with angle brackets. Otherwise, `@example` will be parsed as a new tag.\n\n### Other supported patterns\n\n``` js\nvar someObj = {\n  /**\n   * @param {string} param1 - JSDocs on property assignments work\n   */\n  x: function (param1) {},\n};\n \n/**\n * As do jsdocs on variable assignments\n * @return {Window}\n */\nlet someFunc = function () {};\n \n/**\n * And class methods\n * @param {string} greeting The greeting to use\n */\nFoo.prototype.sayHi = (greeting) => console.log(\"Hi!\");\n \n/**\n * And arrow function expressions\n * @param {number} x - A multiplier\n */\nlet myArrow = (x) => x * x;\n \n/**\n * Which means it works for function components in JSX too\n * @param {{a: string, b: number}} props - Some param\n */\nvar fc = (props) => <div>{props.a.charAt(0)}</div>;\n \n/**\n * A parameter can be a class constructor, using Google Closure syntax.\n *\n * @param {{new(...args: any[]): object}} C - The class to register\n */\nfunction registerClass(C) {}\n \n/**\n * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')\n */\nfunction fn10(p1) {}\n \n/**\n * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')\n */\nfunction fn9(p1) {\n  return p1.join();\n}\n```\n\n### Unsupported patterns\n\nPostfix equals on a property type in an object literal type doesn’t specify an optional property:\n\n``` js\n/**\n * @type {{ a: string, b: number= }}\n */\nvar wrong;\n/**\n * Use postfix question on the property name instead:\n * @type {{ a: string, b?: number }}\n */\nvar right;\n```\n\nNullable types only have meaning if [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is on:\n\n``` js\n/**\n * @type {?number}\n * With strictNullChecks: true  -- number | null\n * With strictNullChecks: false -- number\n */\nvar nullable;\n```\n\nThe TypeScript-native syntax is a union type:\n\n``` js\n/**\n * @type {number | null}\n * With strictNullChecks: true  -- number | null\n * With strictNullChecks: false -- number\n */\nvar unionNullable;\n```\n\nNon-nullable types have no meaning and are treated just as their original type:\n\n``` js\n/**\n * @type {!number}\n * Just has type number\n */\nvar normal;\n```\n\nUnlike JSDoc’s type system, TypeScript only allows you to mark types as containing null or not. There is no explicit non-nullability — if strictNullChecks is on, then `number` is not nullable. If it is off, then `number` is nullable.\n\n### Unsupported tags\n\nTypeScript ignores any unsupported JSDoc tags.\n\nThe following tags have open issues to support them:\n\n- `@memberof` ([issue \\#7237](https://github.com/Microsoft/TypeScript/issues/7237))\n- `@yields` ([issue \\#23857](https://github.com/Microsoft/TypeScript/issues/23857))\n- `@member` ([issue \\#56674](https://github.com/microsoft/TypeScript/issues/56674))\n\n### Legacy type synonyms\n\nA number of common types are given aliases for compatibility with old JavaScript code. Some of the aliases are the same as existing types, although most of those are rarely used. For example, `String` is treated as an alias for `string`. Even though `String` is a type in TypeScript, old JSDoc often uses it to mean `string`. Besides, in TypeScript, the capitalized versions of primitive types are wrapper types — almost always a mistake to use. So the compiler treats these types as synonyms based on usage in old JSDoc:\n\n- `String -> string`\n- `Number -> number`\n- `Boolean -> boolean`\n- `Void -> void`\n- `Undefined -> undefined`\n- `Null -> null`\n- `function -> Function`\n- `array -> Array<any>`\n- `promise -> Promise<any>`\n- `Object -> any`\n- `object -> any`\n\nThe last four aliases are turned off when `noImplicitAny: true`:\n\n- `object` and `Object` are built-in types, although `Object` is rarely used.\n- `array` and `promise` are not built-in, but might be declared somewhere in your program.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)"
- name: 'JSDoc Reference: @author'
  id: jsdoc-supported-types#author
  summary: Remember to surround the email address with angle brackets
  belongs_to: JSDoc Reference
  description: "### `@author`\n\nYou can specify the author of an item with `@author`:\n\n``` ts\n/**\n * Welcome to awesome.ts\n * @author Ian Awesome <i.am.awesome@example.com>\n */\n```\n\nRemember to surround the email address with angle brackets. Otherwise, `@example` will be parsed as a new tag.\n\n### Other supported patterns\n\n``` js\nvar someObj = {\n  /**\n   * @param {string} param1 - JSDocs on property assignments work\n   */\n  x: function (param1) {},\n};\n \n/**\n * As do jsdocs on variable assignments\n * @return {Window}\n */\nlet someFunc = function () {};\n \n/**\n * And class methods\n * @param {string} greeting The greeting to use\n */\nFoo.prototype.sayHi = (greeting) => console.log(\"Hi!\");\n \n/**\n * And arrow function expressions\n * @param {number} x - A multiplier\n */\nlet myArrow = (x) => x * x;\n \n/**\n * Which means it works for function components in JSX too\n * @param {{a: string, b: number}} props - Some param\n */\nvar fc = (props) => <div>{props.a.charAt(0)}</div>;\n \n/**\n * A parameter can be a class constructor, using Google Closure syntax.\n *\n * @param {{new(...args: any[]): object}} C - The class to register\n */\nfunction registerClass(C) {}\n \n/**\n * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')\n */\nfunction fn10(p1) {}\n \n/**\n * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')\n */\nfunction fn9(p1) {\n  return p1.join();\n}\n```\n\n### Unsupported patterns\n\nPostfix equals on a property type in an object literal type doesn’t specify an optional property:\n\n``` js\n/**\n * @type {{ a: string, b: number= }}\n */\nvar wrong;\n/**\n * Use postfix question on the property name instead:\n * @type {{ a: string, b?: number }}\n */\nvar right;\n```\n\nNullable types only have meaning if [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is on:\n\n``` js\n/**\n * @type {?number}\n * With strictNullChecks: true  -- number | null\n * With strictNullChecks: false -- number\n */\nvar nullable;\n```\n\nThe TypeScript-native syntax is a union type:\n\n``` js\n/**\n * @type {number | null}\n * With strictNullChecks: true  -- number | null\n * With strictNullChecks: false -- number\n */\nvar unionNullable;\n```\n\nNon-nullable types have no meaning and are treated just as their original type:\n\n``` js\n/**\n * @type {!number}\n * Just has type number\n */\nvar normal;\n```\n\nUnlike JSDoc’s type system, TypeScript only allows you to mark types as containing null or not. There is no explicit non-nullability — if strictNullChecks is on, then `number` is not nullable. If it is off, then `number` is nullable.\n\n### Unsupported tags\n\nTypeScript ignores any unsupported JSDoc tags.\n\nThe following tags have open issues to support them:\n\n- `@memberof` ([issue \\#7237](https://github.com/Microsoft/TypeScript/issues/7237))\n- `@yields` ([issue \\#23857](https://github.com/Microsoft/TypeScript/issues/23857))\n- `@member` ([issue \\#56674](https://github.com/microsoft/TypeScript/issues/56674))\n\n### Legacy type synonyms\n\nA number of common types are given aliases for compatibility with old JavaScript code. Some of the aliases are the same as existing types, although most of those are rarely used. For example, `String` is treated as an alias for `string`. Even though `String` is a type in TypeScript, old JSDoc often uses it to mean `string`. Besides, in TypeScript, the capitalized versions of primitive types are wrapper types — almost always a mistake to use. So the compiler treats these types as synonyms based on usage in old JSDoc:\n\n- `String -> string`\n- `Number -> number`\n- `Boolean -> boolean`\n- `Void -> void`\n- `Undefined -> undefined`\n- `Null -> null`\n- `function -> Function`\n- `array -> Array<any>`\n- `promise -> Promise<any>`\n- `Object -> any`\n- `object -> any`\n\nThe last four aliases are turned off when `noImplicitAny: true`:\n\n- `object` and `Object` are built-in types, although `Object` is rarely used.\n- `array` and `promise` are not built-in, but might be declared somewhere in your program.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)"
- name: 'JSDoc Reference: @constructor'
  id: jsdoc-supported-types#constructor
  summary: 'Note: Error messages only show up in JS codebases with a JSConfig and checkJs enabled'
  belongs_to: JSDoc Reference
  description: |-
    ### `@constructor`

    The compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a `@constructor` tag:

    ``` js
    /**
     * @constructor
     * @param {number} data
     */
    function C(data) {
      // property types can be inferred
      this.name = "foo";
     
      // or set explicitly
      /** @type {string | null} */
      this.title = null;
     
      // or simply annotated, if they're set elsewhere
      /** @type {number} */
      this.size;
     
      this.initialize(data);
    }
    /**
     * @param {string} s
     */
    C.prototype.initialize = function (s) {
      this.size = s.length;
    };
     
    var c = new C(0);
    c.size;
     
    var result = C(1);
    ```

    > Note: Error messages only show up in JS codebases with [a JSConfig](tsconfig-json) and [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs) enabled.

    With `@constructor`, `this` is checked inside the constructor function `C`, so you will get suggestions for the `initialize` method and an error if you pass it a number. Your editor may also show warnings if you call `C` instead of constructing it.

    Unfortunately, this means that constructor functions that are also callable cannot use `@constructor`.
- name: 'JSDoc Reference: @deprecated'
  id: jsdoc-supported-types#deprecated
  summary: When a function, method, or property is deprecated you can let users know by marking it with a /** @deprecated */ JSDoc comment
  belongs_to: JSDoc Reference
  description: |-
    ### `@deprecated`

    When a function, method, or property is deprecated you can let users know by marking it with a `/** @deprecated */` JSDoc comment. That information is surfaced in completion lists and as a suggestion diagnostic that editors can handle specially. In an editor like VS Code, deprecated values are typically displayed in a strike-through style ~~like this~~.

    ``` js
    /** @deprecated */
    const apiV1 = {};
    const apiV2 = {};
     
    apiV;
     
     
    ```
- name: 'JSDoc Reference: @enum'
  id: jsdoc-supported-types#enum
  summary: The @enum tag allows you to create an object literal whose members are all of a specified type
  belongs_to: JSDoc Reference
  description: |-
    ### `@enum`

    The `@enum` tag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in JavaScript, it does not allow other members. `@enum` is intended for compatibility with Google Closure’s `@enum` tag.

    ``` js
    /** @enum {number} */
    const JSDocState = {
      BeginningOfLine: 0,
      SawAsterisk: 1,
      SavingComments: 2,
    };
     
    JSDocState.SawAsterisk;
    ```

    Note that `@enum` is quite different from, and much simpler than, TypeScript’s `enum`. However, unlike TypeScript’s enums, `@enum` can have any type:

    ``` js
    /** @enum {function(number): number} */
    const MathFuncs = {
      add1: (n) => n + 1,
      id: (n) => -n,
      sub1: (n) => n - 1,
    };
     
    MathFuncs.add1;
    ```
- name: 'JSDoc Reference: @extends'
  id: jsdoc-supported-types#extends
  summary: When JavaScript classes extend a generic base class, there is no JavaScript syntax for passing a type argument
  belongs_to: JSDoc Reference
  description: |-
    ### `@extends`

    When JavaScript classes extend a generic base class, there is no JavaScript syntax for passing a type argument. The `@extends` tag allows this:

    ``` js
    /**
     * @template T
     * @extends {Set<T>}
     */
    class SortableSet extends Set {
      // ...
    }
    ```

    Note that `@extends` only works with classes. Currently, there is no way for a constructor function to extend a class.
- name: 'JSDoc Reference: @implements'
  id: jsdoc-supported-types#implements
  summary: In the same way, there is no JavaScript syntax for implementing a TypeScript interface
  belongs_to: JSDoc Reference
  description: |-
    ### `@implements`

    In the same way, there is no JavaScript syntax for implementing a TypeScript interface. The `@implements` tag works just like in TypeScript:

    ``` js
    /** @implements {Print} */
    class TextBook {
      print() {
        // TODO
      }
    }
    ```
- name: 'JSDoc Reference: @link'
  id: jsdoc-supported-types#link
  summary: null
  belongs_to: JSDoc Reference
  description: |-
    ### `@link`

    `@link` is like `@see`, except that it can be used inside other tags:

    ``` ts
    type Box<T> = { t: T }
    /** @returns A {@link Box} containing the parameter. */
    function box<U>(u: U): Box<U> {
      return { t: u };
    }
    ```
- name: 'JSDoc Reference: @override'
  id: jsdoc-supported-types#override
  summary: 'Set noImplicitOverride: true in tsconfig to check overrides'
  belongs_to: JSDoc Reference
  description: |-
    ### `@override`

    `@override` works the same way as in TypeScript; use it on methods that override a method from a base class:

    ``` js
    export class C {
      m() { }
    }
    class D extends C {
      /** @override */
      m() { }
    }
    ```

    Set `noImplicitOverride: true` in tsconfig to check overrides.
- name: 'JSDoc Reference: @param and @returns'
  id: jsdoc-supported-types#param-and-returns
  summary: '@param uses the same type syntax as @type, but adds a parameter name'
  belongs_to: JSDoc Reference
  description: |-
    ### `@param` and `@returns`

    `@param` uses the same type syntax as `@type`, but adds a parameter name. The parameter may also be declared optional by surrounding the name with square brackets:

    ``` js
    // Parameters may be declared in a variety of syntactic forms
    /**
     * @param {string}  p1 - A string param.
     * @param {string=} p2 - An optional param (Google Closure syntax)
     * @param {string} [p3] - Another optional param (JSDoc syntax).
     * @param {string} [p4="test"] - An optional param with a default value
     * @returns {string} This is the result
     */
    function stringsStringStrings(p1, p2, p3, p4) {
      // TODO
    }
    ```

    Likewise, for the return type of a function:

    ``` js
    /**
     * @return {PromiseLike<string>}
     */
    function ps() {}
     
    /**
     * @returns {{ a: string, b: number }} - May use '@returns' as well as '@return'
     */
    function ab() {}
    ```
- name: 'JSDoc Reference: @readonly'
  id: jsdoc-supported-types#readonly
  summary: The @readonly modifier ensures that a property is only ever written to during initialization
  belongs_to: JSDoc Reference
  description: |-
    ### `@readonly`

    The `@readonly` modifier ensures that a property is only ever written to during initialization.

    ``` js
    // @ts-check
     
    class Car {
      constructor() {
        /** @readonly */
        this.identifier = 100;
      }
     
      printIdentifier() {
        console.log(this.identifier);
      }
    }
     
    const c = new Car();
    console.log(c.identifier);
    ```
- name: 'JSDoc Reference: @satisfies'
  id: jsdoc-supported-types#satisfies
  summary: '@satisfies provides access to the postfix operator satisfies in TypeScript'
  belongs_to: JSDoc Reference
  description: |-
    ### `@satisfies`

    `@satisfies` provides access to the postfix [operator `satisfies`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html) in TypeScript. Satisfies is used to declare that a value implements a type but does not affect the type of the value.

    ``` js
    // @ts-check
    /**
     * @typedef {"hello world" | "Hello, world"} WelcomeMessage
     */
     
    /** @satisfies {WelcomeMessage} */
    const message = "hello world"
     
    /** @satisfies {WelcomeMessage} */
    const failingMessage = "Hello world!"
     
    /** @type {WelcomeMessage} */
    const messageUsingType = "hello world"
    ```
- name: 'JSDoc Reference: @see'
  id: jsdoc-supported-types#see
  summary: Some editors will turn Box into a link to make it easy to jump there and back
  belongs_to: JSDoc Reference
  description: |-
    ### `@see`

    `@see` lets you link to other names in your program:

    ``` ts
    type Box<T> = { t: T }
    /** @see Box for implementation details */
    type Boxify<T> = { [K in keyof T]: Box<T> };
    ```

    Some editors will turn `Box` into a link to make it easy to jump there and back.
- name: 'JSDoc Reference: @template'
  id: jsdoc-supported-types#template
  summary: You can declare type parameters with the @template tag
  belongs_to: JSDoc Reference
  description: |-
    ### `@template`

    You can declare type parameters with the `@template` tag. This lets you make functions, classes, or types that are generic:

    ``` js
    /**
     * @template T
     * @param {T} x - A generic parameter that flows through to the return type
     * @returns {T}
     */
    function id(x) {
      return x;
    }
     
    const a = id("string");
    const b = id(123);
    const c = id({});
    ```

    Use comma or multiple tags to declare multiple type parameters:

    ``` js
    /**
     * @template T,U,V
     * @template W,X
     */
    ```

    You can also specify a type constraint before the type parameter name. Only the first type parameter in a list is constrained:

    ``` js
    /**
     * @template {string} K - K must be a string or string literal
     * @template {{ serious(): string }} Seriousalizable - must have a serious method
     * @param {K} key
     * @param {Seriousalizable} object
     */
    function seriousalize(key, object) {
      // ????
    }
    ```

    Finally, you can specify a default for a type parameter:

    ``` js
    /** @template [T=object] */
    class Cache {
        /** @param {T} initial */
        constructor(initial) {
        }
    }
    let c = new Cache()
    ```
- name: 'JSDoc Reference: @this'
  id: jsdoc-supported-types#this
  summary: The compiler can usually figure out the type of this when it has some context to work with
  belongs_to: JSDoc Reference
  description: |-
    ### `@this`

    The compiler can usually figure out the type of `this` when it has some context to work with. When it doesn’t, you can explicitly specify the type of `this` with `@this`:

    ``` js
    /**
     * @this {HTMLElement}
     * @param {*} e
     */
    function callbackForLater(e) {
      this.clientHeight = parseInt(e); // should be fine!
    }
    ```
- name: 'JSDoc Reference: @type'
  id: jsdoc-supported-types#type
  summary: You can reference types with the “@type” tag
  belongs_to: JSDoc Reference
  description: |-
    ### `@type`

    You can reference types with the “@type” tag. The type can be:

    1.  Primitive, like `string` or `number`.
    2.  Declared in a TypeScript declaration, either global or imported.
    3.  Declared in a JSDoc [`@typedef`](#typedef-callback-and-param) tag.

    You can use most JSDoc type syntax and any TypeScript syntax, from [the most basic like `string`](2/basic-types) to [the most advanced, like conditional types](2/conditional-types).

    ``` js
    /**
     * @type {string}
     */
    var s;
     
    /** @type {Window} */
    var win;
     
    /** @type {PromiseLike<string>} */
    var promisedString;
     
    // You can specify an HTML Element with DOM properties
    /** @type {HTMLElement} */
    var myElement = document.querySelector(selector);
    element.dataset.myData = "";
    ```

    `@type` can specify a union type — for example, something can be either a string or a boolean.

    ``` js
    /**
     * @type {string | boolean}
     */
    var sb;
    ```

    You can specify array types using a variety of syntaxes:

    ``` js
    /** @type {number[]} */
    var ns;
    /** @type {Array.<number>} */
    var jsdoc;
    /** @type {Array<number>} */
    var nas;
    ```

    You can also specify object literal types. For example, an object with properties ‘a’ (string) and ‘b’ (number) uses the following syntax:

    ``` js
    /** @type {{ a: string, b: number }} */
    var var9;
    ```

    You can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or TypeScript syntax.

    ``` js
    /**
     * A map-like object that maps arbitrary `string` properties to `number`s.
     *
     * @type {Object.<string, number>}
     */
    var stringToNumber;
     
    /** @type {Object.<number, object>} */
    var arrayLike;
    ```

    The preceding two types are equivalent to the TypeScript types `{ [x: string]: number }` and `{ [x: number]: any }`. The compiler understands both syntaxes.

    You can specify function types using either TypeScript or Google Closure syntax:

    ``` js
    /** @type {function(string, boolean): number} Closure syntax */
    var sbn;
    /** @type {(s: string, b: boolean) => number} TypeScript syntax */
    var sbn2;
    ```

    Or you can just use the unspecified `Function` type:

    ``` js
    /** @type {Function} */
    var fn7;
    /** @type {function} */
    var fn6;
    ```

    Other types from Closure also work:

    ``` js
    /**
     * @type {*} - can be 'any' type
     */
    var star;
    /**
     * @type {?} - unknown type (same as 'any')
     */
    var question;
    ```

    #### Casts

    TypeScript borrows cast syntax from Google Closure. This lets you cast types to other types by adding a `@type` tag before any parenthesized expression.

    ``` js
    /**
     * @type {number | string}
     */
    var numberOrString = Math.random() < 0.5 ? "hello" : 100;
    var typeAssertedNumber = /** @type {number} */ (numberOrString);
    ```

    You can even cast to `const` just like TypeScript:

    ``` js
    let one = /** @type {const} */(1);
    ```

    #### Import types

    You can import declarations from other files using import types. This syntax is TypeScript-specific and differs from the JSDoc standard:

    ``` js
    // @filename: types.d.ts
    export type Pet = {
      name: string,
    };
     
    // @filename: main.js
    /**
     * @param {import("./types").Pet} p
     */
    function walk(p) {
      console.log(`Walking ${p.name}...`);
    }
    ```

    import types can be used in type alias declarations:

    ``` js
    /**
     * @typedef {import("./types").Pet} Pet
     */
     
    /**
     * @type {Pet}
     */
    var myPet;
    myPet.name;
    ```

    import types can be used to get the type of a value from a module if you don’t know the type, or if it has a large type that is annoying to type:

    ``` js
    /**
     * @type {typeof import("./accounts").userAccount}
     */
    var x = require("./accounts").userAccount;
    ```
- name: 'JSDoc Reference: @typedef, @callback, and @param'
  id: jsdoc-supported-types#typedef-callback-and-param
  summary: You can define complex types with @typedef
  belongs_to: JSDoc Reference
  description: |-
    ### `@typedef`, `@callback`, and `@param`

    You can define complex types with `@typedef`. Similar syntax works with `@param`.

    ``` js
    /**
     * @typedef {Object} SpecialType - creates a new type named 'SpecialType'
     * @property {string} prop1 - a string property of SpecialType
     * @property {number} prop2 - a number property of SpecialType
     * @property {number=} prop3 - an optional number property of SpecialType
     * @prop {number} [prop4] - an optional number property of SpecialType
     * @prop {number} [prop5=42] - an optional number property of SpecialType with default
     */
     
    /** @type {SpecialType} */
    var specialTypeObject;
    specialTypeObject.prop3;
    ```

    You can use either `object` or `Object` on the first line.

    ``` js
    /**
     * @typedef {object} SpecialType1 - creates a new type named 'SpecialType1'
     * @property {string} prop1 - a string property of SpecialType1
     * @property {number} prop2 - a number property of SpecialType1
     * @property {number=} prop3 - an optional number property of SpecialType1
     */
     
    /** @type {SpecialType1} */
    var specialTypeObject1;
    ```

    `@param` allows a similar syntax for one-off type specifications. Note that the nested property names must be prefixed with the name of the parameter:

    ``` js
    /**
     * @param {Object} options - The shape is the same as SpecialType above
     * @param {string} options.prop1
     * @param {number} options.prop2
     * @param {number=} options.prop3
     * @param {number} [options.prop4]
     * @param {number} [options.prop5=42]
     */
    function special(options) {
      return (options.prop4 || 1001) + options.prop5;
    }
    ```

    `@callback` is similar to `@typedef`, but it specifies a function type instead of an object type:

    ``` js
    /**
     * @callback Predicate
     * @param {string} data
     * @param {number} [index]
     * @returns {boolean}
     */
     
    /** @type {Predicate} */
    const ok = (s) => !(s.length % 2);
    ```

    Of course, any of these types can be declared using TypeScript syntax in a single-line `@typedef`:

    ``` js
    /** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */
    /** @typedef {(data: string, index?: number) => boolean} Predicate */
    ```
- name: 'JSDoc Reference: Classes'
  id: jsdoc-supported-types#classes-1
  summary: Classes can be declared as ES6 classes
  belongs_to: JSDoc Reference
  description: |-
    ## Classes

    Classes can be declared as ES6 classes.

    ``` js
    class C {
      /**
       * @param {number} data
       */
      constructor(data) {
        // property types can be inferred
        this.name = "foo";
     
        // or set explicitly
        /** @type {string | null} */
        this.title = null;
     
        // or simply annotated, if they're set elsewhere
        /** @type {number} */
        this.size;
     
        this.initialize(data); // Should error, initializer expects a string
      }
      /**
       * @param {string} s
       */
      initialize = function (s) {
        this.size = s.length;
      };
    }
     
    var c = new C(0);
     
    // C should only be called with new, but
    // because it is JavaScript, this is allowed and
    // considered an 'any'.
    var result = C(1);
    ```

    They can also be declared as constructor functions; use [`@constructor`](#constructor) along with [`@this`](#this) for this.

    ### Property Modifiers

    `@public`, `@private`, and `@protected` work exactly like `public`, `private`, and `protected` in TypeScript:

    ``` js
    // @ts-check
     
    class Car {
      constructor() {
        /** @private */
        this.identifier = 100;
      }
     
      printIdentifier() {
        console.log(this.identifier);
      }
    }
     
    const c = new Car();
    console.log(c.identifier);
    ```

    - `@public` is always implied and can be left off, but means that a property can be reached from anywhere.
    - `@private` means that a property can only be used within the containing class.
    - `@protected` means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.

    `@public`, `@private`, and `@protected` do not work in constructor functions.
- name: 'JSDoc Reference: Documentation'
  id: jsdoc-supported-types#documentation-1
  summary: null
  belongs_to: JSDoc Reference
  description: '## Documentation'
- name: 'JSDoc Reference: Other'
  id: jsdoc-supported-types#other-1
  summary: null
  belongs_to: JSDoc Reference
  description: '## Other'
- name: 'JSDoc Reference: Types'
  id: jsdoc-supported-types#types-1
  summary: null
  belongs_to: JSDoc Reference
  description: '## Types'
- name: jsx
  id: tsconfig#jsx-config
  summary: Controls how JSX constructs are emitted in JavaScript files
  belongs_to: TSConfig Reference
  description: |-
    ### JSX - `jsx`

    Controls how JSX constructs are emitted in JavaScript files. This only affects output of JS files that started in `.tsx` files.

    - `react-jsx`: Emit `.js` files with the JSX changed to `_jsx` calls optimized for production
    - `react-jsxdev`: Emit `.js` files with the JSX changed to `_jsx` calls for development only
    - `preserve`: Emit `.jsx` files with the JSX unchanged
    - `react-native`: Emit `.js` files with the JSX unchanged
    - `react`: Emit `.js` files with JSX changed to the equivalent `React.createElement` calls

    ### For example

    This sample code:

    ``` typescript+html
    export const HelloWorld = () => <h1>Hello world</h1>;
    ```

    React: `"react-jsx"`^([\[1\]](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html))

    ``` typescript+html
    import { jsx as _jsx } from "react/jsx-runtime";
    export const HelloWorld = () => _jsx("h1", { children: "Hello world" });
     
    ```

    React dev transform: `"react-jsxdev"`^([\[1\]](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html))

    ``` typescript+html
    import { jsxDEV as _jsxDEV } from "react/jsx-dev-runtime";
    const _jsxFileName = "/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/index.tsx";
    export const HelloWorld = () => _jsxDEV("h1", { children: "Hello world" }, void 0, false, { fileName: _jsxFileName, lineNumber: 9, columnNumber: 32 }, this);
     
    ```

    Preserve: `"preserve"`

    ``` typescript+html
    import React from 'react';
    export const HelloWorld = () => <h1>Hello world</h1>;
     
    ```

    React Native: `"react-native"`

    ``` typescript+html
    import React from 'react';
    export const HelloWorld = () => <h1>Hello world</h1>;
     
    ```

    Legacy React runtime: `"react"`

    ``` typescript+html
    import React from 'react';
    export const HelloWorld = () => React.createElement("h1", null, "Hello world");
     
    ```

    This option can be used on a per-file basis too using an `@jsxRuntime` comment.

    Always use the classic runtime (`"react"`) for this file:

    ``` typescript+html
    /* @jsxRuntime classic */
    export const HelloWorld = () => <h1>Hello world</h1>;
    ```

    Always use the automatic runtime (`"react-jsx"`) for this file:

    ``` typescript+html
    /* @jsxRuntime automatic */
    export const HelloWorld = () => <h1>Hello world</h1>;
    ```

    - Allowed:
      - `preserve`

      - `react`

      - `react-native`

      - `react-jsx`

      - `react-jsxdev`

    - Related:
      - [`jsxFactory`](#jsxFactory)

      - [`jsxFragmentFactory`](#jsxFragmentFactory)

      - [`jsxImportSource`](#jsxImportSource)

    - Released:

      [2.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html)
- name: jsx
  id: tsconfig/index#jsx-config
  summary: Controls how JSX constructs are emitted in JavaScript files
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### JSX - `jsx`

    Controls how JSX constructs are emitted in JavaScript files. This only affects output of JS files that started in `.tsx` files.

    - `react-jsx`: Emit `.js` files with the JSX changed to `_jsx` calls optimized for production
    - `react-jsxdev`: Emit `.js` files with the JSX changed to `_jsx` calls for development only
    - `preserve`: Emit `.jsx` files with the JSX unchanged
    - `react-native`: Emit `.js` files with the JSX unchanged
    - `react`: Emit `.js` files with JSX changed to the equivalent `React.createElement` calls

    ### For example

    This sample code:

    ``` typescript+html
    export const HelloWorld = () => <h1>Hello world</h1>;
    ```

    React: `"react-jsx"`^([\[1\]](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html))

    ``` typescript+html
    import { jsx as _jsx } from "react/jsx-runtime";
    export const HelloWorld = () => _jsx("h1", { children: "Hello world" });
     
    ```

    React dev transform: `"react-jsxdev"`^([\[1\]](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html))

    ``` typescript+html
    import { jsxDEV as _jsxDEV } from "react/jsx-dev-runtime";
    const _jsxFileName = "/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/index.tsx";
    export const HelloWorld = () => _jsxDEV("h1", { children: "Hello world" }, void 0, false, { fileName: _jsxFileName, lineNumber: 9, columnNumber: 32 }, this);
     
    ```

    Preserve: `"preserve"`

    ``` typescript+html
    import React from 'react';
    export const HelloWorld = () => <h1>Hello world</h1>;
     
    ```

    React Native: `"react-native"`

    ``` typescript+html
    import React from 'react';
    export const HelloWorld = () => <h1>Hello world</h1>;
     
    ```

    Legacy React runtime: `"react"`

    ``` typescript+html
    import React from 'react';
    export const HelloWorld = () => React.createElement("h1", null, "Hello world");
     
    ```

    This option can be used on a per-file basis too using an `@jsxRuntime` comment.

    Always use the classic runtime (`"react"`) for this file:

    ``` typescript+html
    /* @jsxRuntime classic */
    export const HelloWorld = () => <h1>Hello world</h1>;
    ```

    Always use the automatic runtime (`"react-jsx"`) for this file:

    ``` typescript+html
    /* @jsxRuntime automatic */
    export const HelloWorld = () => <h1>Hello world</h1>;
    ```

    - Allowed:
      - `preserve`

      - `react`

      - `react-native`

      - `react-jsx`

      - `react-jsxdev`

    - Related:
      - [`jsxFactory`](#jsxFactory)

      - [`jsxFragmentFactory`](#jsxFragmentFactory)

      - [`jsxImportSource`](#jsxImportSource)

    - Released:

      [2.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html)
- name: JSX
  id: jsx
  summary: JSX is an embeddable XML-like syntax
  description: "# JSX\n\n[JSX](https://facebook.github.io/jsx/) is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific. JSX rose to popularity with the [React](https://reactjs.org/) framework, but has since seen other implementations as well. TypeScript supports embedding, type checking, and compiling JSX directly to JavaScript.\n\n## Basic usage\n\nIn order to use JSX you must do two things.\n\n1.  Name your files with a `.tsx` extension\n2.  Enable the [`jsx`](https://www.typescriptlang.org/tsconfig#jsx) option\n\nTypeScript ships with several JSX modes: `preserve`, `react` (classic runtime), `react-jsx` (automatic runtime), `react-jsxdev` (automatic development runtime), and `react-native`. The `preserve` mode will keep the JSX as part of the output to be further consumed by another transform step (e.g. [Babel](https://babeljs.io/)). Additionally the output will have a `.jsx` file extension. The `react` mode will emit `React.createElement`, does not need to go through a JSX transformation before use, and the output will have a `.js` file extension. The `react-native` mode is the equivalent of `preserve` in that it keeps all JSX, but the output will instead have a `.js` file extension.\n\n| Mode           | Input     | Output                                            | Output File Extension |\n|----------------|-----------|---------------------------------------------------|-----------------------|\n| `preserve`     | `<div />` | `<div />`                                         | `.jsx`                |\n| `react`        | `<div />` | `React.createElement(\"div\")`                      | `.js`                 |\n| `react-native` | `<div />` | `<div />`                                         | `.js`                 |\n| `react-jsx`    | `<div />` | `_jsx(\"div\", {}, void 0);`                        | `.js`                 |\n| `react-jsxdev` | `<div />` | `_jsxDEV(\"div\", {}, void 0, false, {...}, this);` | `.js`                 |\n\nYou can specify this mode using either the [`jsx`](https://www.typescriptlang.org/tsconfig#jsx) command line flag or the corresponding option [`jsx` in your tsconfig.json](https://www.typescriptlang.org/tsconfig#jsx) file.\n\n> \\*Note: You can specify the JSX factory function to use when targeting react JSX emit with [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory) option (defaults to `React.createElement`)\n\n## The `as` operator\n\nRecall how to write a type assertion:\n\n``` ts\nconst foo = <foo>bar;\n```\n\nThis asserts the variable `bar` to have the type `foo`. Since TypeScript also uses angle brackets for type assertions, combining it with JSX’s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in `.tsx` files.\n\nSince the above syntax cannot be used in `.tsx` files, an alternate type assertion operator should be used: `as`. The example can easily be rewritten with the `as` operator.\n\n``` ts\nconst foo = bar as foo;\n```\n\nThe `as` operator is available in both `.ts` and `.tsx` files, and is identical in behavior to the angle-bracket type assertion style.\n\n## Type Checking\n\nIn order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements. Given a JSX expression `<expr />`, `expr` may either refer to something intrinsic to the environment (e.g. a `div` or `span` in a DOM environment) or to a custom component that you’ve created. This is important for two reasons:\n\n1.  For React, intrinsic elements are emitted as strings (`React.createElement(\"div\")`), whereas a component you’ve created is not (`React.createElement(MyComponent)`).\n2.  The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known *intrinsically* whereas components will likely want to specify their own set of attributes.\n\nTypeScript uses the [same convention that React does](http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components) for distinguishing between these. An intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter.\n\n### The `JSX` namespace\n\nJSX in TypeScript is typed by the `JSX` namespace. The `JSX` namespace may be defined in various places, depending on the `jsx` compiler option.\n\nThe `jsx` options `preserve`, `react`, and `react-native` use the type definitions for classic runtime. This means a variable needs to be in scope that’s determined by the `jsxFactory` compiler option. The `JSX` namespace should be specified on the top-most identifier of the JSX factory. For example, React uses the default factory `React.createElement`. This means its `JSX` namespace should be defined as `React.JSX`.\n\n``` ts\nexport function createElement(): any;\n\nexport namespace JSX {\n  // …\n}\n```\n\nAnd the user should always import React as `React`.\n\n``` ts\nimport * as React from 'react';\n```\n\nPreact uses the JSX factory `h`. That means its types should be defined as the `h.JSX`.\n\n``` ts\nexport function h(props: any): any;\n\nexport namespace h.JSX {\n  // …\n}\n```\n\nThe user should use a named import to import `h`.\n\n``` ts\nimport { h } from 'preact';\n```\n\nFor the `jsx` options `react-jsx` and `react-jsxdev`, the `JSX` namespace should be exported from the matching entry points. For `react-jsx` this is `${jsxImportSource}/jsx-runtime`. For `react-jsxdev`, this is `${jsxImportSource}/jsx-dev-runtime`. Since these don’t use a file extension, you must use the [`exports`](https://nodejs.org/api/packages.html#exports) field in `package.json` map in order to support ESM users.\n\n``` json\n{\n  \"exports\": {\n    \"./jsx-runtime\": \"./jsx-runtime.js\",\n    \"./jsx-dev-runtime\": \"./jsx-dev-runtime.js\",\n  }\n}\n```\n\nThen in `jsx-runtime.d.ts` and `jsx-dev-runtime.d.ts`:\n\n``` ts\nexport namespace JSX {\n  // …\n}\n```\n\nNote that while exporting the `JSX` namespace is sufficient for type checking, the production runtime needs the `jsx`, `jsxs`, and `Fragment` exports at runtime, and the development runtime needs `jsxDEV` and `Fragment`. Ideally you add types for those too.\n\nIf the `JSX` namespace isn’t available in the appropriate location, both the classic and the automatic runtime fall back to the global `JSX` namespace.\n\n### Intrinsic elements\n\nIntrinsic elements are looked up on the special interface `JSX.IntrinsicElements`. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface *is* present, then the name of the intrinsic element is looked up as a property on the `JSX.IntrinsicElements` interface. For example:\n\n``` typescript+html\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: any;\n  }\n}\n\n<foo />; // ok\n<bar />; // error\n```\n\nIn the above example, `<foo />` will work fine but `<bar />` will result in an error since it has not been specified on `JSX.IntrinsicElements`.\n\n> Note: You can also specify a catch-all string indexer on `JSX.IntrinsicElements` as follows:\n\n``` ts\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    [elemName: string]: any;\n  }\n}\n```\n\n### Value-based elements\n\nValue-based elements are simply looked up by identifiers that are in scope.\n\n``` typescript+html\nimport MyComponent from \"./myComponent\";\n\n<MyComponent />; // ok\n<SomeOtherComponent />; // error\n```\n\nThere are two ways to define a value-based element:\n\n1.  Function Component (FC)\n2.  Class Component\n\nBecause these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error.\n\n#### Function Component\n\nAs the name suggests, the component is defined as a JavaScript function where its first argument is a `props` object. TS enforces that its return type must be assignable to `JSX.Element`.\n\n``` typescript+html\ninterface FooProp {\n  name: string;\n  X: number;\n  Y: number;\n}\n\ndeclare function AnotherComponent(prop: { name: string });\nfunction ComponentFoo(prop: FooProp) {\n  return <AnotherComponent name={prop.name} />;\n}\n\nconst Button = (prop: { value: string }, context: { color: string }) => (\n  <button />\n);\n```\n\nBecause a Function Component is simply a JavaScript function, function overloads may be used here as well:\n\n``` ts\ninterface ClickableProps {\n  children: JSX.Element[] | JSX.Element;\n}\n \ninterface HomeProps extends ClickableProps {\n  home: JSX.Element;\n}\n \ninterface SideProps extends ClickableProps {\n  side: JSX.Element | string;\n}\n \nfunction MainButton(prop: HomeProps): JSX.Element;\nfunction MainButton(prop: SideProps): JSX.Element;\nfunction MainButton(prop: ClickableProps): JSX.Element {\n  // ...\n}\n```\n\n> Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type `SFC` and its alias `StatelessComponent` were deprecated.\n\n#### Class Component\n\nIt is possible to define the type of a class component. However, to do so it is best to understand two new terms: the *element class type* and the *element instance type*.\n\nGiven `<Expr />`, the *element class type* is the type of `Expr`. So in the example above, if `MyComponent` was an ES6 class the class type would be that class’s constructor and statics. If `MyComponent` was a factory function, the class type would be that function.\n\nOnce the class type is established, the instance type is determined by the union of the return types of the class type’s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.\n\n``` ts\nclass MyComponent {\n  render() {}\n}\n\n// use a construct signature\nconst myComponent = new MyComponent();\n\n// element class type => MyComponent\n// element instance type => { render: () => void }\n\nfunction MyFactoryFunction() {\n  return {\n    render: () => {},\n  };\n}\n\n// use a call signature\nconst myComponent = MyFactoryFunction();\n\n// element class type => MyFactoryFunction\n// element instance type => { render: () => void }\n```\n\nThe element instance type is interesting because it must be assignable to `JSX.ElementClass` or it will result in an error. By default `JSX.ElementClass` is `{}`, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.\n\n``` typescript+html\ndeclare namespace JSX {\n  interface ElementClass {\n    render: any;\n  }\n}\n\nclass MyComponent {\n  render() {}\n}\nfunction MyFactoryFunction() {\n  return { render: () => {} };\n}\n\n<MyComponent />; // ok\n<MyFactoryFunction />; // ok\n\nclass NotAValidComponent {}\nfunction NotAValidFactoryFunction() {\n  return {};\n}\n\n<NotAValidComponent />; // error\n<NotAValidFactoryFunction />; // error\n```\n\n### Attribute type checking\n\nThe first step to type checking attributes is to determine the *element attributes type*. This is slightly different between intrinsic and value-based elements.\n\nFor intrinsic elements, it is the type of the property on `JSX.IntrinsicElements`\n\n``` typescript+html\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: { bar?: boolean };\n  }\n}\n\n// element attributes type for 'foo' is '{bar?: boolean}'\n<foo bar />;\n```\n\nFor value-based elements, it is a bit more complex. It is determined by the type of a property on the *element instance type* that was previously determined. Which property to use is determined by `JSX.ElementAttributesProperty`. It should be declared with a single property. The name of that property is then used. As of TypeScript 2.8, if `JSX.ElementAttributesProperty` is not provided, the type of first parameter of the class element’s constructor or Function Component’s call will be used instead.\n\n``` typescript+html\ndeclare namespace JSX {\n  interface ElementAttributesProperty {\n    props; // specify the property name to use\n  }\n}\n\nclass MyComponent {\n  // specify the property on the element instance type\n  props: {\n    foo?: string;\n  };\n}\n\n// element attributes type for 'MyComponent' is '{foo?: string}'\n<MyComponent foo=\"bar\" />;\n```\n\nThe element attribute type is used to type check the attributes in the JSX. Optional and required properties are supported.\n\n``` typescript+html\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: { requiredProp: string; optionalProp?: number };\n  }\n}\n\n<foo requiredProp=\"bar\" />; // ok\n<foo requiredProp=\"bar\" optionalProp={0} />; // ok\n<foo />; // error, requiredProp is missing\n<foo requiredProp={0} />; // error, requiredProp should be a string\n<foo requiredProp=\"bar\" unknownProp />; // error, unknownProp does not exist\n<foo requiredProp=\"bar\" some-unknown-prop />; // ok, because 'some-unknown-prop' is not a valid identifier\n```\n\n> Note: If an attribute name is not a valid JS identifier (like a `data-*` attribute), it is not considered to be an error if it is not found in the element attributes type.\n\nAdditionally, the `JSX.IntrinsicAttributes` interface can be used to specify extra properties used by the JSX framework which are not generally used by the components’ props or arguments - for instance `key` in React. Specializing further, the generic `JSX.IntrinsicClassAttributes<T>` type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow the `ref` attribute of type `Ref<T>`. Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag.\n\nThe spread operator also works:\n\n``` typescript+html\nconst props = { requiredProp: \"bar\" };\n<foo {...props} />; // ok\n\nconst badProps = {};\n<foo {...badProps} />; // error\n```\n\n### Children Type Checking\n\nIn TypeScript 2.3, TS introduced type checking of *children*. *children* is a special property in an *element attributes type* where child *JSXExpression*s are taken to be inserted into the attributes. Similar to how TS uses `JSX.ElementAttributesProperty` to determine the name of *props*, TS uses `JSX.ElementChildrenAttribute` to determine the name of *children* within those props. `JSX.ElementChildrenAttribute` should be declared with a single property.\n\n``` ts\ndeclare namespace JSX {\n  interface ElementChildrenAttribute {\n    children: {}; // specify children name to use\n  }\n}\n```\n\n``` typescript+html\n<div>\n  <h1>Hello</h1>\n</div>;\n\n<div>\n  <h1>Hello</h1>\n  World\n</div>;\n\nconst CustomComp = (props) => <div>{props.children}</div>\n<CustomComp>\n  <div>Hello World</div>\n  {\"This is just a JS expression...\" + 1000}\n</CustomComp>\n```\n\nYou can specify the type of *children* like any other attribute. This will override the default type from, e.g. the [React typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react) if you use them.\n\n``` typescript+html\ninterface PropsType {\n  children: JSX.Element\n  name: string\n}\n\nclass Component extends React.Component<PropsType, {}> {\n  render() {\n    return (\n      <h2>\n        {this.props.children}\n      </h2>\n    )\n  }\n}\n\n// OK\n<Component name=\"foo\">\n  <h1>Hello World</h1>\n</Component>\n\n// Error: children is of type JSX.Element not array of JSX.Element\n<Component name=\"bar\">\n  <h1>Hello World</h1>\n  <h2>Hello World</h2>\n</Component>\n\n// Error: children is of type JSX.Element not array of JSX.Element or string.\n<Component name=\"baz\">\n  <h1>Hello</h1>\n  World\n</Component>\n```\n\n## The JSX result type\n\nBy default the result of a JSX expression is typed as `any`. You can customize the type by specifying the `JSX.Element` interface. However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface. It is a black box.\n\n## The JSX function return type\n\nBy default, function components must return `JSX.Element | null`. However, this doesn’t always represent runtime behaviour. As of TypeScript 5.1, you can specify `JSX.ElementType` to override what is a valid JSX component type. Note that this doesn’t define what props are valid. The type of props is always defined by the first argument of the component that’s passed. The default looks something like this:\n\n``` ts\nnamespace JSX {\n    export type ElementType =\n        // All the valid lowercase tags\n        keyof IntrinsicAttributes\n        // Function components\n        (props: any) => Element\n        // Class components\n        new (props: any) => ElementClass;\n    export interface IntrinsicAttributes extends /*...*/ {}\n    export type Element = /*...*/;\n    export type ElementClass = /*...*/;\n}\n```\n\n## Embedding Expressions\n\nJSX allows you to embed expressions between tags by surrounding the expressions with curly braces (`{ }`).\n\n``` typescript+html\nconst a = (\n  <div>\n    {[\"foo\", \"bar\"].map((i) => (\n      <span>{i / 2}</span>\n    ))}\n  </div>\n);\n```\n\nThe above code will result in an error since you cannot divide a string by a number. The output, when using the `preserve` option, looks like:\n\n``` typescript+html\nconst a = (\n  <div>\n    {[\"foo\", \"bar\"].map(function (i) {\n      return <span>{i / 2}</span>;\n    })}\n  </div>\n);\n```\n\n## React integration\n\nTo use JSX with React you should use the [React typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react). These typings define the `JSX` namespace appropriately for use with React.\n\n``` typescript+html\n/// <reference path=\"react.d.ts\" />\n\ninterface Props {\n  foo: string;\n}\n\nclass MyComponent extends React.Component<Props, {}> {\n  render() {\n    return <span>{this.props.foo}</span>;\n  }\n}\n\n<MyComponent foo=\"bar\" />; // ok\n<MyComponent foo={0} />; // error\n```\n\n### Configuring JSX\n\nThere are multiple compiler flags which can be used to customize your JSX, which work as both a compiler flag and via inline per-file pragmas. To learn more see their tsconfig reference pages:\n\n- [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)\n- [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)\n- [`jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/jsx.html](https://www.typescriptlang.org/docs/handbook/jsx.html)"
- name: 'JSX: Basic usage'
  id: jsx#basic-usage
  summary: In order to use JSX you must do two things
  belongs_to: JSX
  description: |-
    ## Basic usage

    In order to use JSX you must do two things.

    1.  Name your files with a `.tsx` extension
    2.  Enable the [`jsx`](https://www.typescriptlang.org/tsconfig#jsx) option

    TypeScript ships with several JSX modes: `preserve`, `react` (classic runtime), `react-jsx` (automatic runtime), `react-jsxdev` (automatic development runtime), and `react-native`. The `preserve` mode will keep the JSX as part of the output to be further consumed by another transform step (e.g. [Babel](https://babeljs.io/)). Additionally the output will have a `.jsx` file extension. The `react` mode will emit `React.createElement`, does not need to go through a JSX transformation before use, and the output will have a `.js` file extension. The `react-native` mode is the equivalent of `preserve` in that it keeps all JSX, but the output will instead have a `.js` file extension.

    | Mode           | Input     | Output                                            | Output File Extension |
    |----------------|-----------|---------------------------------------------------|-----------------------|
    | `preserve`     | `<div />` | `<div />`                                         | `.jsx`                |
    | `react`        | `<div />` | `React.createElement("div")`                      | `.js`                 |
    | `react-native` | `<div />` | `<div />`                                         | `.js`                 |
    | `react-jsx`    | `<div />` | `_jsx("div", {}, void 0);`                        | `.js`                 |
    | `react-jsxdev` | `<div />` | `_jsxDEV("div", {}, void 0, false, {...}, this);` | `.js`                 |

    You can specify this mode using either the [`jsx`](https://www.typescriptlang.org/tsconfig#jsx) command line flag or the corresponding option [`jsx` in your tsconfig.json](https://www.typescriptlang.org/tsconfig#jsx) file.

    > \*Note: You can specify the JSX factory function to use when targeting react JSX emit with [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory) option (defaults to `React.createElement`)
- name: 'JSX: Embedding Expressions'
  id: jsx#embedding-expressions
  summary: The above code will result in an error since you cannot divide a string by a number
  belongs_to: JSX
  description: |-
    ## Embedding Expressions

    JSX allows you to embed expressions between tags by surrounding the expressions with curly braces (`{ }`).

    ``` typescript+html
    const a = (
      <div>
        {["foo", "bar"].map((i) => (
          <span>{i / 2}</span>
        ))}
      </div>
    );
    ```

    The above code will result in an error since you cannot divide a string by a number. The output, when using the `preserve` option, looks like:

    ``` typescript+html
    const a = (
      <div>
        {["foo", "bar"].map(function (i) {
          return <span>{i / 2}</span>;
        })}
      </div>
    );
    ```
- name: 'JSX: React integration'
  id: jsx#react-integration
  summary: To use JSX with React you should use the React typings
  belongs_to: JSX
  description: "## React integration\n\nTo use JSX with React you should use the [React typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react). These typings define the `JSX` namespace appropriately for use with React.\n\n``` typescript+html\n/// <reference path=\"react.d.ts\" />\n\ninterface Props {\n  foo: string;\n}\n\nclass MyComponent extends React.Component<Props, {}> {\n  render() {\n    return <span>{this.props.foo}</span>;\n  }\n}\n\n<MyComponent foo=\"bar\" />; // ok\n<MyComponent foo={0} />; // error\n```\n\n### Configuring JSX\n\nThere are multiple compiler flags which can be used to customize your JSX, which work as both a compiler flag and via inline per-file pragmas. To learn more see their tsconfig reference pages:\n\n- [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)\n- [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)\n- [`jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/jsx.html](https://www.typescriptlang.org/docs/handbook/jsx.html)"
- name: 'JSX: The as operator'
  id: jsx#the-as-operator
  summary: This asserts the variable bar to have the type foo
  belongs_to: JSX
  description: |-
    ## The `as` operator

    Recall how to write a type assertion:

    ``` ts
    const foo = <foo>bar;
    ```

    This asserts the variable `bar` to have the type `foo`. Since TypeScript also uses angle brackets for type assertions, combining it with JSX’s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in `.tsx` files.

    Since the above syntax cannot be used in `.tsx` files, an alternate type assertion operator should be used: `as`. The example can easily be rewritten with the `as` operator.

    ``` ts
    const foo = bar as foo;
    ```

    The `as` operator is available in both `.ts` and `.tsx` files, and is identical in behavior to the angle-bracket type assertion style.
- name: 'JSX: The JSX function return type'
  id: jsx#the-jsx-function-return-type
  summary: By default, function components must return JSX.Element | null
  belongs_to: JSX
  description: |-
    ## The JSX function return type

    By default, function components must return `JSX.Element | null`. However, this doesn’t always represent runtime behaviour. As of TypeScript 5.1, you can specify `JSX.ElementType` to override what is a valid JSX component type. Note that this doesn’t define what props are valid. The type of props is always defined by the first argument of the component that’s passed. The default looks something like this:

    ``` ts
    namespace JSX {
        export type ElementType =
            // All the valid lowercase tags
            keyof IntrinsicAttributes
            // Function components
            (props: any) => Element
            // Class components
            new (props: any) => ElementClass;
        export interface IntrinsicAttributes extends /*...*/ {}
        export type Element = /*...*/;
        export type ElementClass = /*...*/;
    }
    ```
- name: 'JSX: The JSX namespace'
  id: jsx#the-jsx-namespace
  summary: JSX in TypeScript is typed by the JSX namespace
  belongs_to: JSX
  description: |-
    ### The `JSX` namespace

    JSX in TypeScript is typed by the `JSX` namespace. The `JSX` namespace may be defined in various places, depending on the `jsx` compiler option.

    The `jsx` options `preserve`, `react`, and `react-native` use the type definitions for classic runtime. This means a variable needs to be in scope that’s determined by the `jsxFactory` compiler option. The `JSX` namespace should be specified on the top-most identifier of the JSX factory. For example, React uses the default factory `React.createElement`. This means its `JSX` namespace should be defined as `React.JSX`.

    ``` ts
    export function createElement(): any;

    export namespace JSX {
      // …
    }
    ```

    And the user should always import React as `React`.

    ``` ts
    import * as React from 'react';
    ```

    Preact uses the JSX factory `h`. That means its types should be defined as the `h.JSX`.

    ``` ts
    export function h(props: any): any;

    export namespace h.JSX {
      // …
    }
    ```

    The user should use a named import to import `h`.

    ``` ts
    import { h } from 'preact';
    ```

    For the `jsx` options `react-jsx` and `react-jsxdev`, the `JSX` namespace should be exported from the matching entry points. For `react-jsx` this is `${jsxImportSource}/jsx-runtime`. For `react-jsxdev`, this is `${jsxImportSource}/jsx-dev-runtime`. Since these don’t use a file extension, you must use the [`exports`](https://nodejs.org/api/packages.html#exports) field in `package.json` map in order to support ESM users.

    ``` json
    {
      "exports": {
        "./jsx-runtime": "./jsx-runtime.js",
        "./jsx-dev-runtime": "./jsx-dev-runtime.js",
      }
    }
    ```

    Then in `jsx-runtime.d.ts` and `jsx-dev-runtime.d.ts`:

    ``` ts
    export namespace JSX {
      // …
    }
    ```

    Note that while exporting the `JSX` namespace is sufficient for type checking, the production runtime needs the `jsx`, `jsxs`, and `Fragment` exports at runtime, and the development runtime needs `jsxDEV` and `Fragment`. Ideally you add types for those too.

    If the `JSX` namespace isn’t available in the appropriate location, both the classic and the automatic runtime fall back to the global `JSX` namespace.

    ### Intrinsic elements

    Intrinsic elements are looked up on the special interface `JSX.IntrinsicElements`. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface *is* present, then the name of the intrinsic element is looked up as a property on the `JSX.IntrinsicElements` interface. For example:

    ``` typescript+html
    declare namespace JSX {
      interface IntrinsicElements {
        foo: any;
      }
    }

    <foo />; // ok
    <bar />; // error
    ```

    In the above example, `<foo />` will work fine but `<bar />` will result in an error since it has not been specified on `JSX.IntrinsicElements`.

    > Note: You can also specify a catch-all string indexer on `JSX.IntrinsicElements` as follows:

    ``` ts
    declare namespace JSX {
      interface IntrinsicElements {
        [elemName: string]: any;
      }
    }
    ```

    ### Value-based elements

    Value-based elements are simply looked up by identifiers that are in scope.

    ``` typescript+html
    import MyComponent from "./myComponent";

    <MyComponent />; // ok
    <SomeOtherComponent />; // error
    ```

    There are two ways to define a value-based element:

    1.  Function Component (FC)
    2.  Class Component

    Because these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error.

    #### Function Component

    As the name suggests, the component is defined as a JavaScript function where its first argument is a `props` object. TS enforces that its return type must be assignable to `JSX.Element`.

    ``` typescript+html
    interface FooProp {
      name: string;
      X: number;
      Y: number;
    }

    declare function AnotherComponent(prop: { name: string });
    function ComponentFoo(prop: FooProp) {
      return <AnotherComponent name={prop.name} />;
    }

    const Button = (prop: { value: string }, context: { color: string }) => (
      <button />
    );
    ```

    Because a Function Component is simply a JavaScript function, function overloads may be used here as well:

    ``` ts
    interface ClickableProps {
      children: JSX.Element[] | JSX.Element;
    }
     
    interface HomeProps extends ClickableProps {
      home: JSX.Element;
    }
     
    interface SideProps extends ClickableProps {
      side: JSX.Element | string;
    }
     
    function MainButton(prop: HomeProps): JSX.Element;
    function MainButton(prop: SideProps): JSX.Element;
    function MainButton(prop: ClickableProps): JSX.Element {
      // ...
    }
    ```

    > Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type `SFC` and its alias `StatelessComponent` were deprecated.

    #### Class Component

    It is possible to define the type of a class component. However, to do so it is best to understand two new terms: the *element class type* and the *element instance type*.

    Given `<Expr />`, the *element class type* is the type of `Expr`. So in the example above, if `MyComponent` was an ES6 class the class type would be that class’s constructor and statics. If `MyComponent` was a factory function, the class type would be that function.

    Once the class type is established, the instance type is determined by the union of the return types of the class type’s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.

    ``` ts
    class MyComponent {
      render() {}
    }

    // use a construct signature
    const myComponent = new MyComponent();

    // element class type => MyComponent
    // element instance type => { render: () => void }

    function MyFactoryFunction() {
      return {
        render: () => {},
      };
    }

    // use a call signature
    const myComponent = MyFactoryFunction();

    // element class type => MyFactoryFunction
    // element instance type => { render: () => void }
    ```

    The element instance type is interesting because it must be assignable to `JSX.ElementClass` or it will result in an error. By default `JSX.ElementClass` is `{}`, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.

    ``` typescript+html
    declare namespace JSX {
      interface ElementClass {
        render: any;
      }
    }

    class MyComponent {
      render() {}
    }
    function MyFactoryFunction() {
      return { render: () => {} };
    }

    <MyComponent />; // ok
    <MyFactoryFunction />; // ok

    class NotAValidComponent {}
    function NotAValidFactoryFunction() {
      return {};
    }

    <NotAValidComponent />; // error
    <NotAValidFactoryFunction />; // error
    ```

    ### Attribute type checking

    The first step to type checking attributes is to determine the *element attributes type*. This is slightly different between intrinsic and value-based elements.

    For intrinsic elements, it is the type of the property on `JSX.IntrinsicElements`

    ``` typescript+html
    declare namespace JSX {
      interface IntrinsicElements {
        foo: { bar?: boolean };
      }
    }

    // element attributes type for 'foo' is '{bar?: boolean}'
    <foo bar />;
    ```

    For value-based elements, it is a bit more complex. It is determined by the type of a property on the *element instance type* that was previously determined. Which property to use is determined by `JSX.ElementAttributesProperty`. It should be declared with a single property. The name of that property is then used. As of TypeScript 2.8, if `JSX.ElementAttributesProperty` is not provided, the type of first parameter of the class element’s constructor or Function Component’s call will be used instead.

    ``` typescript+html
    declare namespace JSX {
      interface ElementAttributesProperty {
        props; // specify the property name to use
      }
    }

    class MyComponent {
      // specify the property on the element instance type
      props: {
        foo?: string;
      };
    }

    // element attributes type for 'MyComponent' is '{foo?: string}'
    <MyComponent foo="bar" />;
    ```

    The element attribute type is used to type check the attributes in the JSX. Optional and required properties are supported.

    ``` typescript+html
    declare namespace JSX {
      interface IntrinsicElements {
        foo: { requiredProp: string; optionalProp?: number };
      }
    }

    <foo requiredProp="bar" />; // ok
    <foo requiredProp="bar" optionalProp={0} />; // ok
    <foo />; // error, requiredProp is missing
    <foo requiredProp={0} />; // error, requiredProp should be a string
    <foo requiredProp="bar" unknownProp />; // error, unknownProp does not exist
    <foo requiredProp="bar" some-unknown-prop />; // ok, because 'some-unknown-prop' is not a valid identifier
    ```

    > Note: If an attribute name is not a valid JS identifier (like a `data-*` attribute), it is not considered to be an error if it is not found in the element attributes type.

    Additionally, the `JSX.IntrinsicAttributes` interface can be used to specify extra properties used by the JSX framework which are not generally used by the components’ props or arguments - for instance `key` in React. Specializing further, the generic `JSX.IntrinsicClassAttributes<T>` type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow the `ref` attribute of type `Ref<T>`. Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag.

    The spread operator also works:

    ``` typescript+html
    const props = { requiredProp: "bar" };
    <foo {...props} />; // ok

    const badProps = {};
    <foo {...badProps} />; // error
    ```

    ### Children Type Checking

    In TypeScript 2.3, TS introduced type checking of *children*. *children* is a special property in an *element attributes type* where child *JSXExpression*s are taken to be inserted into the attributes. Similar to how TS uses `JSX.ElementAttributesProperty` to determine the name of *props*, TS uses `JSX.ElementChildrenAttribute` to determine the name of *children* within those props. `JSX.ElementChildrenAttribute` should be declared with a single property.

    ``` ts
    declare namespace JSX {
      interface ElementChildrenAttribute {
        children: {}; // specify children name to use
      }
    }
    ```

    ``` typescript+html
    <div>
      <h1>Hello</h1>
    </div>;

    <div>
      <h1>Hello</h1>
      World
    </div>;

    const CustomComp = (props) => <div>{props.children}</div>
    <CustomComp>
      <div>Hello World</div>
      {"This is just a JS expression..." + 1000}
    </CustomComp>
    ```

    You can specify the type of *children* like any other attribute. This will override the default type from, e.g. the [React typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react) if you use them.

    ``` typescript+html
    interface PropsType {
      children: JSX.Element
      name: string
    }

    class Component extends React.Component<PropsType, {}> {
      render() {
        return (
          <h2>
            {this.props.children}
          </h2>
        )
      }
    }

    // OK
    <Component name="foo">
      <h1>Hello World</h1>
    </Component>

    // Error: children is of type JSX.Element not array of JSX.Element
    <Component name="bar">
      <h1>Hello World</h1>
      <h2>Hello World</h2>
    </Component>

    // Error: children is of type JSX.Element not array of JSX.Element or string.
    <Component name="baz">
      <h1>Hello</h1>
      World
    </Component>
    ```
- name: 'JSX: The JSX result type'
  id: jsx#the-jsx-result-type
  summary: By default the result of a JSX expression is typed as any
  belongs_to: JSX
  description: |-
    ## The JSX result type

    By default the result of a JSX expression is typed as `any`. You can customize the type by specifying the `JSX.Element` interface. However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface. It is a black box.
- name: 'JSX: Type Checking'
  id: jsx#type-checking
  summary: In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements
  belongs_to: JSX
  description: |-
    ## Type Checking

    In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements. Given a JSX expression `<expr />`, `expr` may either refer to something intrinsic to the environment (e.g. a `div` or `span` in a DOM environment) or to a custom component that you’ve created. This is important for two reasons:

    1.  For React, intrinsic elements are emitted as strings (`React.createElement("div")`), whereas a component you’ve created is not (`React.createElement(MyComponent)`).
    2.  The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known *intrinsically* whereas components will likely want to specify their own set of attributes.

    TypeScript uses the [same convention that React does](http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components) for distinguishing between these. An intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter.
- name: jsxFactory
  id: tsconfig/index#jsxFactory-config
  summary: Changes the function called in .js files when compiling JSX Elements using the classic JSX runtime
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### JSX Factory - `jsxFactory`

    Changes the function called in `.js` files when compiling JSX Elements using the classic JSX runtime. The most common change is to use `"h"` or `"preact.h"` instead of the default `"React.createElement"` if using `preact`.

    For example, this TSX file:

    ``` typescript+html
    import { h } from "preact";

    const HelloWorld = () => <div>Hello</div>;
    ```

    With `jsxFactory: "h"` looks like:

    ``` typescript+html
    const preact_1 = require("preact");
    const HelloWorld = () => (0, preact_1.h)("div", null, "Hello");
     
    ```

    This option can be used on a per-file basis too similar to [Babel’s `/** @jsx h */` directive](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#custom).

    ``` typescript+html
    /** @jsx h */
    import { h } from "preact";
     
    const HelloWorld = () => <div>Hello</div>;
    ```

    The factory chosen will also affect where the `JSX` namespace is looked up (for type checking information) before falling back to the global one.

    If the factory is defined as `React.createElement` (the default), the compiler will check for `React.JSX` before checking for a global `JSX`. If the factory is defined as `h`, it will check for `h.JSX` before a global `JSX`.

    - Default:

      `React.createElement`

    - Allowed:
      - Any identifier or dotted identifier.

    - Related:
      - [`jsx`](#jsx)

      - [`jsxFragmentFactory`](#jsxFragmentFactory)

      - [`jsxImportSource`](#jsxImportSource)
- name: jsxFactory
  id: tsconfig#jsxFactory-config
  summary: Changes the function called in .js files when compiling JSX Elements using the classic JSX runtime
  belongs_to: TSConfig Reference
  description: |-
    ### JSX Factory - `jsxFactory`

    Changes the function called in `.js` files when compiling JSX Elements using the classic JSX runtime. The most common change is to use `"h"` or `"preact.h"` instead of the default `"React.createElement"` if using `preact`.

    For example, this TSX file:

    ``` typescript+html
    import { h } from "preact";

    const HelloWorld = () => <div>Hello</div>;
    ```

    With `jsxFactory: "h"` looks like:

    ``` typescript+html
    const preact_1 = require("preact");
    const HelloWorld = () => (0, preact_1.h)("div", null, "Hello");
     
    ```

    This option can be used on a per-file basis too similar to [Babel’s `/** @jsx h */` directive](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#custom).

    ``` typescript+html
    /** @jsx h */
    import { h } from "preact";
     
    const HelloWorld = () => <div>Hello</div>;
    ```

    The factory chosen will also affect where the `JSX` namespace is looked up (for type checking information) before falling back to the global one.

    If the factory is defined as `React.createElement` (the default), the compiler will check for `React.JSX` before checking for a global `JSX`. If the factory is defined as `h`, it will check for `h.JSX` before a global `JSX`.

    - Default:

      `React.createElement`

    - Allowed:
      - Any identifier or dotted identifier.

    - Related:
      - [`jsx`](#jsx)

      - [`jsxFragmentFactory`](#jsxFragmentFactory)

      - [`jsxImportSource`](#jsxImportSource)
- name: jsxFragmentFactory
  id: tsconfig/index#jsxFragmentFactory-config
  summary: Specify the JSX fragment factory function to use when targeting react JSX emit with jsxFactory compiler option is specified, e.g
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### JSX Fragment Factory - `jsxFragmentFactory`

    Specify the JSX fragment factory function to use when targeting react JSX emit with [`jsxFactory`](#jsxFactory) compiler option is specified, e.g. `Fragment`.

    For example with this TSConfig:

    ``` typescript
    {
      "compilerOptions": {
        "target": "esnext",
        "module": "commonjs",
        "jsx": "react",
        "jsxFactory": "h",
        "jsxFragmentFactory": "Fragment"
      }
    }
    ```

    This TSX file:

    ``` typescript+html
    import { h, Fragment } from "preact";

    const HelloWorld = () => (
      <>
        <div>Hello</div>
      </>
    );
    ```

    Would look like:

    ``` typescript+html
    const preact_1 = require("preact");
    const HelloWorld = () => ((0, preact_1.h)(preact_1.Fragment, null,
        (0, preact_1.h)("div", null, "Hello")));
     
    ```

    This option can be used on a per-file basis too similar to [Babel’s `/* @jsxFrag h */` directive](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#fragments).

    For example:

    ``` typescript+html
    /** @jsx h */
    /** @jsxFrag Fragment */
     
    import { h, Fragment } from "preact";
     
    const HelloWorld = () => (
      <>
        <div>Hello</div>
      </>
    );
    ```

    - Default:

      `React.Fragment`

    - Related:
      - [`jsx`](#jsx)

      - [`jsxFactory`](#jsxFactory)

      - [`jsxImportSource`](#jsxImportSource)

    - Released:

      [4.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html)
- name: jsxFragmentFactory
  id: tsconfig#jsxFragmentFactory-config
  summary: Specify the JSX fragment factory function to use when targeting react JSX emit with jsxFactory compiler option is specified, e.g
  belongs_to: TSConfig Reference
  description: |-
    ### JSX Fragment Factory - `jsxFragmentFactory`

    Specify the JSX fragment factory function to use when targeting react JSX emit with [`jsxFactory`](#jsxFactory) compiler option is specified, e.g. `Fragment`.

    For example with this TSConfig:

    ``` typescript
    {
      "compilerOptions": {
        "target": "esnext",
        "module": "commonjs",
        "jsx": "react",
        "jsxFactory": "h",
        "jsxFragmentFactory": "Fragment"
      }
    }
    ```

    This TSX file:

    ``` typescript+html
    import { h, Fragment } from "preact";

    const HelloWorld = () => (
      <>
        <div>Hello</div>
      </>
    );
    ```

    Would look like:

    ``` typescript+html
    const preact_1 = require("preact");
    const HelloWorld = () => ((0, preact_1.h)(preact_1.Fragment, null,
        (0, preact_1.h)("div", null, "Hello")));
     
    ```

    This option can be used on a per-file basis too similar to [Babel’s `/* @jsxFrag h */` directive](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#fragments).

    For example:

    ``` typescript+html
    /** @jsx h */
    /** @jsxFrag Fragment */
     
    import { h, Fragment } from "preact";
     
    const HelloWorld = () => (
      <>
        <div>Hello</div>
      </>
    );
    ```

    - Default:

      `React.Fragment`

    - Related:
      - [`jsx`](#jsx)

      - [`jsxFactory`](#jsxFactory)

      - [`jsxImportSource`](#jsxImportSource)

    - Released:

      [4.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html)
- name: jsxImportSource
  id: tsconfig#jsxImportSource-config
  summary: Declares the module specifier to be used for importing the jsx and jsxs factory functions when using jsx as "react-jsx" or "react-jsxdev" which were introduced in TypeScript 4.1
  belongs_to: TSConfig Reference
  description: |-
    ### JSX Import Source - `jsxImportSource`

    Declares the module specifier to be used for importing the `jsx` and `jsxs` factory functions when using [`jsx`](#jsx) as `"react-jsx"` or `"react-jsxdev"` which were introduced in TypeScript 4.1.

    With [React 17](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html) the library supports a new form of JSX transformation via a separate import.

    For example with this code:

    ``` typescript+html
    import React from "react";

    function App() {
      return <h1>Hello World</h1>;
    }
    ```

    Using this TSConfig:

    ``` typescript
    {
      "compilerOptions": {
        "target": "esnext",
        "module": "commonjs",
        "jsx": "react-jsx"
      }
    }
    ```

    The emitted JavaScript from TypeScript is:

    ``` typescript+html
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const jsx_runtime_1 = require("react/jsx-runtime");
    function App() {
        return (0, jsx_runtime_1.jsx)("h1", { children: "Hello World" });
    }
     
    ```

    For example if you wanted to use `"jsxImportSource": "preact"`, you need a tsconfig like:

    ``` typescript
    {
      "compilerOptions": {
        "target": "esnext",
        "module": "commonjs",
        "jsx": "react-jsx",
        "jsxImportSource": "preact",
        "types": ["preact"]
      }
    }
    ```

    Which generates code like:

    ``` typescript+html
    function App() {
        return (0, jsx_runtime_1.jsx)("h1", { children: "Hello World" });
    }
     
    ```

    Alternatively, you can use a per-file pragma to set this option, for example:

    ``` typescript+html
    /** @jsxImportSource preact */

    export function App() {
      return <h1>Hello World</h1>;
    }
    ```

    Would add `preact/jsx-runtime` as an import for the `_jsx` factory.

    *Note:* In order for this to work like you would expect, your `tsx` file must include an `export` or `import` so that it is considered a module.

    - Default:

      `react`

    - Related:
      - [`jsx`](#jsx)

      - [`jsxFactory`](#jsxFactory)

    - Released:

      [4.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html)
- name: jsxImportSource
  id: tsconfig/index#jsxImportSource-config
  summary: Declares the module specifier to be used for importing the jsx and jsxs factory functions when using jsx as "react-jsx" or "react-jsxdev" which were introduced in TypeScript 4.1
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### JSX Import Source - `jsxImportSource`

    Declares the module specifier to be used for importing the `jsx` and `jsxs` factory functions when using [`jsx`](#jsx) as `"react-jsx"` or `"react-jsxdev"` which were introduced in TypeScript 4.1.

    With [React 17](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html) the library supports a new form of JSX transformation via a separate import.

    For example with this code:

    ``` typescript+html
    import React from "react";

    function App() {
      return <h1>Hello World</h1>;
    }
    ```

    Using this TSConfig:

    ``` typescript
    {
      "compilerOptions": {
        "target": "esnext",
        "module": "commonjs",
        "jsx": "react-jsx"
      }
    }
    ```

    The emitted JavaScript from TypeScript is:

    ``` typescript+html
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const jsx_runtime_1 = require("react/jsx-runtime");
    function App() {
        return (0, jsx_runtime_1.jsx)("h1", { children: "Hello World" });
    }
     
    ```

    For example if you wanted to use `"jsxImportSource": "preact"`, you need a tsconfig like:

    ``` typescript
    {
      "compilerOptions": {
        "target": "esnext",
        "module": "commonjs",
        "jsx": "react-jsx",
        "jsxImportSource": "preact",
        "types": ["preact"]
      }
    }
    ```

    Which generates code like:

    ``` typescript+html
    function App() {
        return (0, jsx_runtime_1.jsx)("h1", { children: "Hello World" });
    }
     
    ```

    Alternatively, you can use a per-file pragma to set this option, for example:

    ``` typescript+html
    /** @jsxImportSource preact */

    export function App() {
      return <h1>Hello World</h1>;
    }
    ```

    Would add `preact/jsx-runtime` as an import for the `_jsx` factory.

    *Note:* In order for this to work like you would expect, your `tsx` file must include an `export` or `import` so that it is considered a module.

    - Default:

      `react`

    - Related:
      - [`jsx`](#jsx)

      - [`jsxFactory`](#jsxFactory)

    - Released:

      [4.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html)
- name: Keyof Type Operator
  id: 2/keyof-types
  summary: The keyof operator takes an object type and produces a string or numeric literal union of its keys
  description: "# Keyof Type Operator\n\n## The `keyof` type operator\n\nThe `keyof` operator takes an object type and produces a string or numeric literal union of its keys. The following type `P` is the same type as `type P = \"x\" | \"y\"`:\n\n``` ts\ntype Point = { x: number; y: number };\ntype P = keyof Point;\n```\n\nIf the type has a `string` or `number` index signature, `keyof` will return those types instead:\n\n``` ts\ntype Arrayish = { [n: number]: unknown };\ntype A = keyof Arrayish;\n \ntype Mapish = { [k: string]: boolean };\ntype M = keyof Mapish;\n```\n\nNote that in this example, `M` is `string | number` — this is because JavaScript object keys are always coerced to a string, so `obj[0]` is always the same as `obj[\"0\"]`.\n\n`keyof` types become especially useful when combined with mapped types, which we’ll learn more about later.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/keyof-types.html](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)"
- name: 'Keyof Type Operator: The keyof type operator'
  id: 2/keyof-types#the-keyof-type-operator
  summary: The keyof operator takes an object type and produces a string or numeric literal union of its keys
  belongs_to: Keyof Type Operator
  description: "## The `keyof` type operator\n\nThe `keyof` operator takes an object type and produces a string or numeric literal union of its keys. The following type `P` is the same type as `type P = \"x\" | \"y\"`:\n\n``` ts\ntype Point = { x: number; y: number };\ntype P = keyof Point;\n```\n\nIf the type has a `string` or `number` index signature, `keyof` will return those types instead:\n\n``` ts\ntype Arrayish = { [n: number]: unknown };\ntype A = keyof Arrayish;\n \ntype Mapish = { [k: string]: boolean };\ntype M = keyof Mapish;\n```\n\nNote that in this example, `M` is `string | number` — this is because JavaScript object keys are always coerced to a string, so `obj[0]` is always the same as `obj[\"0\"]`.\n\n`keyof` types become especially useful when combined with mapped types, which we’ll learn more about later.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/keyof-types.html](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)"
- name: keyofStringsOnly
  id: tsconfig/index#keyofStringsOnly-config
  summary: This flag changes the keyof type operator to return string instead of string | number when applied to a type with a string index signature
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Keyof Strings Only - `keyofStringsOnly`

    This flag changes the `keyof` type operator to return `string` instead of `string | number` when applied to a type with a string index signature.

    This flag is used to help people keep this behavior from [before TypeScript 2.9’s release](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types).

    - Deprecated

    - Released:

      [2.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html)
- name: keyofStringsOnly
  id: tsconfig#keyofStringsOnly-config
  summary: This flag changes the keyof type operator to return string instead of string | number when applied to a type with a string index signature
  belongs_to: TSConfig Reference
  description: |-
    ### Keyof Strings Only - `keyofStringsOnly`

    This flag changes the `keyof` type operator to return `string` instead of `string | number` when applied to a type with a string index signature.

    This flag is used to help people keep this behavior from [before TypeScript 2.9’s release](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types).

    - Deprecated

    - Released:

      [2.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html)
- name: lib
  id: tsconfig#lib-config
  summary: TypeScript includes a default set of type definitions for built-in JS APIs (like Math), as well as type definitions for things found in browser environments (like document). TypeScript also includes APIs for newer JS features matching the target you specify; for example the definition for Map is available if target is ES6 or newer
  belongs_to: TSConfig Reference
  description: |-
    ### Lib - `lib`

    TypeScript includes a default set of type definitions for built-in JS APIs (like `Math`), as well as type definitions for things found in browser environments (like `document`). TypeScript also includes APIs for newer JS features matching the [`target`](#target) you specify; for example the definition for `Map` is available if [`target`](#target) is `ES6` or newer.

    You may want to change these for a few reasons:

    - Your program doesn’t run in a browser, so you don’t want the `"dom"` type definitions
    - Your runtime platform provides certain JavaScript API objects (maybe through polyfills), but doesn’t yet support the full syntax of a given ECMAScript version
    - You have polyfills or native implementations for some, but not all, of a higher level ECMAScript version

    In TypeScript 4.5, lib files can be overridden by npm modules, find out more [in the blog](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5-beta/#supporting-lib-from-node_modules).

    ### High Level libraries

    | Name         | Contents                                                                                                                                          |
    |--------------|---------------------------------------------------------------------------------------------------------------------------------------------------|
    | `ES5`        | Core definitions for all ES3 and ES5 functionality                                                                                                |
    | `ES2015`     | Additional APIs available in ES2015 (also known as ES6) - `array.find`, `Promise`, `Proxy`, `Symbol`, `Map`, `Set`, `Reflect`, etc.               |
    | `ES6`        | Alias for “ES2015”                                                                                                                                |
    | `ES2016`     | Additional APIs available in ES2016 - `array.include`, etc.                                                                                       |
    | `ES7`        | Alias for “ES2016”                                                                                                                                |
    | `ES2017`     | Additional APIs available in ES2017 - `Object.entries`, `Object.values`, `Atomics`, `SharedArrayBuffer`, `date.formatToParts`, typed arrays, etc. |
    | `ES2018`     | Additional APIs available in ES2018 - `async` iterables, `promise.finally`, `Intl.PluralRules`, `regexp.groups`, etc.                             |
    | `ES2019`     | Additional APIs available in ES2019 - `array.flat`, `array.flatMap`, `Object.fromEntries`, `string.trimStart`, `string.trimEnd`, etc.             |
    | `ES2020`     | Additional APIs available in ES2020 - `string.matchAll`, etc.                                                                                     |
    | `ES2021`     | Additional APIs available in ES2021 - `promise.any`, `string.replaceAll` etc.                                                                     |
    | `ES2022`     | Additional APIs available in ES2022 - `array.at`, `RegExp.hasIndices`, etc.                                                                       |
    | `ES2023`     | Additional APIs available in ES2023 - `array.with`, `array.findLast`, `array.findLastIndex`, `array.toSorted`, `array.toReversed`, etc.           |
    | `ESNext`     | Additional APIs available in ESNext - This changes as the JavaScript specification evolves                                                        |
    | `DOM`        | [DOM](https://developer.mozilla.org/docs/Glossary/DOM) definitions - `window`, `document`, etc.                                                   |
    | `WebWorker`  | APIs available in [WebWorker](https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers) contexts                              |
    | `ScriptHost` | APIs for the [Windows Script Hosting System](https://wikipedia.org/wiki/Windows_Script_Host)                                                      |

    ### Individual library components

    | Name                      |
    |---------------------------|
    | `DOM.Iterable`            |
    | `ES2015.Core`             |
    | `ES2015.Collection`       |
    | `ES2015.Generator`        |
    | `ES2015.Iterable`         |
    | `ES2015.Promise`          |
    | `ES2015.Proxy`            |
    | `ES2015.Reflect`          |
    | `ES2015.Symbol`           |
    | `ES2015.Symbol.WellKnown` |
    | `ES2016.Array.Include`    |
    | `ES2017.object`           |
    | `ES2017.Intl`             |
    | `ES2017.SharedMemory`     |
    | `ES2017.String`           |
    | `ES2017.TypedArrays`      |
    | `ES2018.Intl`             |
    | `ES2018.Promise`          |
    | `ES2018.RegExp`           |
    | `ES2019.Array`            |
    | `ES2019.Object`           |
    | `ES2019.String`           |
    | `ES2019.Symbol`           |
    | `ES2020.String`           |
    | `ES2020.Symbol.wellknown` |
    | `ES2021.Promise`          |
    | `ES2021.String`           |
    | `ES2021.WeakRef`          |
    | `ESNext.AsyncIterable`    |
    | `ESNext.Array`            |
    | `ESNext.Intl`             |
    | `ESNext.Symbol`           |

    This list may be out of date, you can see the full list in the [TypeScript source code](https://github.com/microsoft/TypeScript/tree/main/src/lib).

    - Related:
      - [`noLib`](#noLib)

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: lib
  id: tsconfig/index#lib-config
  summary: TypeScript includes a default set of type definitions for built-in JS APIs (like Math), as well as type definitions for things found in browser environments (like document). TypeScript also includes APIs for newer JS features matching the target you specify; for example the definition for Map is available if target is ES6 or newer
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Lib - `lib`

    TypeScript includes a default set of type definitions for built-in JS APIs (like `Math`), as well as type definitions for things found in browser environments (like `document`). TypeScript also includes APIs for newer JS features matching the [`target`](#target) you specify; for example the definition for `Map` is available if [`target`](#target) is `ES6` or newer.

    You may want to change these for a few reasons:

    - Your program doesn’t run in a browser, so you don’t want the `"dom"` type definitions
    - Your runtime platform provides certain JavaScript API objects (maybe through polyfills), but doesn’t yet support the full syntax of a given ECMAScript version
    - You have polyfills or native implementations for some, but not all, of a higher level ECMAScript version

    In TypeScript 4.5, lib files can be overridden by npm modules, find out more [in the blog](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5-beta/#supporting-lib-from-node_modules).

    ### High Level libraries

    | Name         | Contents                                                                                                                                          |
    |--------------|---------------------------------------------------------------------------------------------------------------------------------------------------|
    | `ES5`        | Core definitions for all ES3 and ES5 functionality                                                                                                |
    | `ES2015`     | Additional APIs available in ES2015 (also known as ES6) - `array.find`, `Promise`, `Proxy`, `Symbol`, `Map`, `Set`, `Reflect`, etc.               |
    | `ES6`        | Alias for “ES2015”                                                                                                                                |
    | `ES2016`     | Additional APIs available in ES2016 - `array.include`, etc.                                                                                       |
    | `ES7`        | Alias for “ES2016”                                                                                                                                |
    | `ES2017`     | Additional APIs available in ES2017 - `Object.entries`, `Object.values`, `Atomics`, `SharedArrayBuffer`, `date.formatToParts`, typed arrays, etc. |
    | `ES2018`     | Additional APIs available in ES2018 - `async` iterables, `promise.finally`, `Intl.PluralRules`, `regexp.groups`, etc.                             |
    | `ES2019`     | Additional APIs available in ES2019 - `array.flat`, `array.flatMap`, `Object.fromEntries`, `string.trimStart`, `string.trimEnd`, etc.             |
    | `ES2020`     | Additional APIs available in ES2020 - `string.matchAll`, etc.                                                                                     |
    | `ES2021`     | Additional APIs available in ES2021 - `promise.any`, `string.replaceAll` etc.                                                                     |
    | `ES2022`     | Additional APIs available in ES2022 - `array.at`, `RegExp.hasIndices`, etc.                                                                       |
    | `ES2023`     | Additional APIs available in ES2023 - `array.with`, `array.findLast`, `array.findLastIndex`, `array.toSorted`, `array.toReversed`, etc.           |
    | `ESNext`     | Additional APIs available in ESNext - This changes as the JavaScript specification evolves                                                        |
    | `DOM`        | [DOM](https://developer.mozilla.org/docs/Glossary/DOM) definitions - `window`, `document`, etc.                                                   |
    | `WebWorker`  | APIs available in [WebWorker](https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers) contexts                              |
    | `ScriptHost` | APIs for the [Windows Script Hosting System](https://wikipedia.org/wiki/Windows_Script_Host)                                                      |

    ### Individual library components

    | Name                      |
    |---------------------------|
    | `DOM.Iterable`            |
    | `ES2015.Core`             |
    | `ES2015.Collection`       |
    | `ES2015.Generator`        |
    | `ES2015.Iterable`         |
    | `ES2015.Promise`          |
    | `ES2015.Proxy`            |
    | `ES2015.Reflect`          |
    | `ES2015.Symbol`           |
    | `ES2015.Symbol.WellKnown` |
    | `ES2016.Array.Include`    |
    | `ES2017.object`           |
    | `ES2017.Intl`             |
    | `ES2017.SharedMemory`     |
    | `ES2017.String`           |
    | `ES2017.TypedArrays`      |
    | `ES2018.Intl`             |
    | `ES2018.Promise`          |
    | `ES2018.RegExp`           |
    | `ES2019.Array`            |
    | `ES2019.Object`           |
    | `ES2019.String`           |
    | `ES2019.Symbol`           |
    | `ES2020.String`           |
    | `ES2020.Symbol.wellknown` |
    | `ES2021.Promise`          |
    | `ES2021.String`           |
    | `ES2021.WeakRef`          |
    | `ESNext.AsyncIterable`    |
    | `ESNext.Array`            |
    | `ESNext.Intl`             |
    | `ESNext.Symbol`           |

    This list may be out of date, you can see the full list in the [TypeScript source code](https://github.com/microsoft/TypeScript/tree/main/src/lib).

    - Related:
      - [`noLib`](#noLib)

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: Library Structures
  id: declaration-files/library-structures
  summary: Broadly speaking, the way you structure your declaration file depends on how the library is consumed
  description: "# Library Structures\n\nBroadly speaking, the way you *structure* your declaration file depends on how the library is consumed. There are many ways of offering a library for consumption in JavaScript, and you’ll need to write your declaration file to match it. This guide covers how to identify common library patterns, and how to write declaration files which correspond to that pattern.\n\nEach type of major library structuring pattern has a corresponding file in the [Templates](templates) section. You can start with these templates to help you get going faster.\n\n## Identifying Kinds of Libraries\n\nFirst, we’ll review the kinds of libraries TypeScript declaration files can represent. We’ll briefly show how each kind of library is *used*, how it is *written*, and list some example libraries from the real world.\n\nIdentifying the structure of a library is the first step in writing its declaration file. We’ll give hints on how to identify structure both based on its *usage* and its *code*. Depending on the library’s documentation and organization, one might be easier than the other. We recommend using whichever is more comfortable to you.\n\n### What should you look for?\n\nQuestion to ask yourself while looking at a library you are trying to type.\n\n1.  How do you obtain the library?\n\n    For example, can you *only* get it through npm or only from a CDN?\n\n2.  How would you import it?\n\n    Does it add a global object? Does it use `require` or `import`/`export` statements?\n\n### Smaller samples for different types of libraries\n\n### Modular Libraries\n\nAlmost every modern Node.js library falls into the module family. These type of libraries only work in a JS environment with a module loader. For example, `express` only works in Node.js and must be loaded using the CommonJS `require` function.\n\nECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of *importing* a *module*. In JavaScript CommonJS (Node.js), for example, you would write\n\n``` js\nvar fs = require(\"fs\");\n```\n\nIn TypeScript or ES6, the `import` keyword serves the same purpose:\n\n``` ts\nimport * as fs from \"fs\";\n```\n\nYou’ll typically see modular libraries include one of these lines in their documentation:\n\n``` js\nvar someLib = require(\"someLib\");\n```\n\nor\n\n``` js\ndefine(..., ['someLib'], function(someLib) {\n\n});\n```\n\nAs with global modules, you might see these examples in the documentation of [a UMD](#umd) module, so be sure to check the code or documentation.\n\n#### Identifying a Module Library from Code\n\nModular libraries will typically have at least some of the following:\n\n- Unconditional calls to `require` or `define`\n- Declarations like `import * as a from 'b';` or `export c;`\n- Assignments to `exports` or `module.exports`\n\nThey will rarely have:\n\n- Assignments to properties of `window` or `global`\n\n#### Templates For Modules\n\nThere are four templates available for modules, [`module.d.ts`](templates/module-d-ts), [`module-class.d.ts`](templates/module-class-d-ts), [`module-function.d.ts`](templates/module-function-d-ts) and [`module-plugin.d.ts`](templates/module-plugin-d-ts).\n\nYou should first read [`module.d.ts`](templates/module-d-ts) for an overview on the way they all work.\n\nThen use the template [`module-function.d.ts`](templates/module-function-d-ts) if your module can be *called* like a function:\n\n``` js\nconst x = require(\"foo\");\n// Note: calling 'x' as a function\nconst y = x(42);\n```\n\nUse the template [`module-class.d.ts`](templates/module-class-d-ts) if your module can be *constructed* using `new`:\n\n``` js\nconst x = require(\"bar\");\n// Note: using 'new' operator on the imported variable\nconst y = new x(\"hello\");\n```\n\nIf you have a module which when imported, makes changes to other modules use template [`module-plugin.d.ts`](templates/module-plugin-d-ts):\n\n``` js\nconst jest = require(\"jest\");\nrequire(\"jest-matchers-files\");\n```\n\n### Global Libraries\n\nA *global* library is one that can be accessed from the global scope (i.e. without using any form of `import`). Many libraries simply expose one or more global variables for use. For example, if you were using [jQuery](https://jquery.com/), the `$` variable can be used by simply referring to it:\n\n``` ts\n$(() => {\n  console.log(\"hello!\");\n});\n```\n\nYou’ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:\n\n``` html\n<script src=\"http://a.great.cdn.for/someLib.js\"></script>\n```\n\nToday, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn’t actually UMD.\n\n#### Identifying a Global Library from Code\n\nGlobal library code is usually extremely simple. A global “Hello, world” library might look like this:\n\n``` js\nfunction createGreeting(s) {\n  return \"Hello, \" + s;\n}\n```\n\nor like this:\n\n``` js\n// Web\nwindow.createGreeting = function (s) {\n  return \"Hello, \" + s;\n};\n\n// Node\nglobal.createGreeting = function (s) {\n  return \"Hello, \" + s;\n};\n\n// Potentially any runtime\nglobalThis.createGreeting = function (s) {\n  return \"Hello, \" + s;\n};\n```\n\nWhen looking at the code of a global library, you’ll usually see:\n\n- Top-level `var` statements or `function` declarations\n- One or more assignments to `window.someName`\n- Assumptions that DOM primitives like `document` or `window` exist\n\nYou *won’t* see:\n\n- Checks for, or usage of, module loaders like `require` or `define`\n- CommonJS/Node.js-style imports of the form `var fs = require(\"fs\");`\n- Calls to `define(...)`\n- Documentation describing how to `require` or import the library\n\n#### Examples of Global Libraries\n\nBecause it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have *no* dependencies) may still be global.\n\n#### Global Library Template\n\nThe template file [`global.d.ts`](templates/global-d-ts) defines an example library `myLib`. Be sure to read the [“Preventing Name Conflicts” footnote](#preventing-name-conflicts).\n\n### *UMD*\n\nA *UMD* module is one that can *either* be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as [Moment.js](https://momentjs.com/), are written this way. For example, in Node.js or using RequireJS, you would write:\n\n``` ts\nimport moment = require(\"moment\");\nconsole.log(moment.format());\n```\n\nwhereas in a vanilla browser environment you would write:\n\n``` js\nconsole.log(moment.format());\n```\n\n#### Identifying a UMD library\n\n[UMD modules](https://github.com/umdjs/umd) check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:\n\n``` js\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"libName\"], factory);\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory(require(\"libName\"));\n    } else {\n        root.returnExports = factory(root.libName);\n    }\n}(this, function (b) {\n```\n\nIf you see tests for `typeof define`, `typeof window`, or `typeof module` in the code of a library, especially at the top of the file, it’s almost always a UMD library.\n\nDocumentation for UMD libraries will also often demonstrate a “Using in Node.js” example showing `require`, and a “Using in the browser” example showing using a `<script>` tag to load the script.\n\n#### Examples of UMD libraries\n\nMost popular libraries are now available as UMD packages. Examples include [jQuery](https://jquery.com/), [Moment.js](https://momentjs.com/), [lodash](https://lodash.com/), and many more.\n\n#### Template\n\nUse the [`module-plugin.d.ts`](templates/module-plugin-d-ts) template.\n\n## Consuming Dependencies\n\nThere are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.\n\n### Dependencies on Global Libraries\n\nIf your library depends on a global library, use a `/// <reference types=\"...\" />` directive:\n\n``` ts\n/// <reference types=\"someLib\" />\n\nfunction getThing(): someLib.thing;\n```\n\n### Dependencies on Modules\n\nIf your library depends on a module, use an `import` statement:\n\n``` ts\nimport * as moment from \"moment\";\n\nfunction getThing(): moment;\n```\n\n### Dependencies on UMD libraries\n\n#### From a Global Library\n\nIf your global library depends on a UMD module, use a `/// <reference types` directive:\n\n``` ts\n/// <reference types=\"moment\" />\n\nfunction getThing(): moment;\n```\n\n#### From a Module or UMD Library\n\nIf your module or UMD library depends on a UMD library, use an `import` statement:\n\n``` ts\nimport * as someLib from \"someLib\";\n```\n\nDo *not* use a `/// <reference` directive to declare a dependency to a UMD library!\n\n## Footnotes\n\n### Preventing Name Conflicts\n\nNote that it’s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.\n\nA simple rule to follow is to only declare types *namespaced* by whatever global variable the library defines. For example, if the library defines the global value ‘cats’, you should write\n\n``` ts\ndeclare namespace cats {\n  interface KittySettings {}\n}\n```\n\nBut *not*\n\n``` ts\n// at top-level\ninterface CatsKittySettings {}\n```\n\nThis guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.\n\n### The Impact of ES6 on Module Call Signatures\n\nMany popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:\n\n``` ts\nimport exp = require(\"express\");\nvar app = exp();\n```\n\nIn ES6-compliant module loaders, the top-level object (here imported as `exp`) can only have properties; the top-level module object can *never* be callable.\n\nThe most common solution here is to define a `default` export for a callable/constructable object; module loaders commonly detect this situation automatically and replace the top-level object with the `default` export. TypeScript can handle this for you, if you have [`\"esModuleInterop\": true`](https://www.typescriptlang.org/tsconfig/#esModuleInterop) in your tsconfig.json.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html)"
- name: 'Library Structures: Consuming Dependencies'
  id: declaration-files/library-structures#consuming-dependencies
  summary: There are several kinds of dependencies your library might have
  belongs_to: Library Structures
  description: |-
    ## Consuming Dependencies

    There are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.

    ### Dependencies on Global Libraries

    If your library depends on a global library, use a `/// <reference types="..." />` directive:

    ``` ts
    /// <reference types="someLib" />

    function getThing(): someLib.thing;
    ```

    ### Dependencies on Modules

    If your library depends on a module, use an `import` statement:

    ``` ts
    import * as moment from "moment";

    function getThing(): moment;
    ```

    ### Dependencies on UMD libraries

    #### From a Global Library

    If your global library depends on a UMD module, use a `/// <reference types` directive:

    ``` ts
    /// <reference types="moment" />

    function getThing(): moment;
    ```

    #### From a Module or UMD Library

    If your module or UMD library depends on a UMD library, use an `import` statement:

    ``` ts
    import * as someLib from "someLib";
    ```

    Do *not* use a `/// <reference` directive to declare a dependency to a UMD library!
- name: 'Library Structures: Footnotes'
  id: declaration-files/library-structures#footnotes
  summary: Note that it’s possible to define many types in the global scope when writing a global declaration file
  belongs_to: Library Structures
  description: "## Footnotes\n\n### Preventing Name Conflicts\n\nNote that it’s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.\n\nA simple rule to follow is to only declare types *namespaced* by whatever global variable the library defines. For example, if the library defines the global value ‘cats’, you should write\n\n``` ts\ndeclare namespace cats {\n  interface KittySettings {}\n}\n```\n\nBut *not*\n\n``` ts\n// at top-level\ninterface CatsKittySettings {}\n```\n\nThis guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.\n\n### The Impact of ES6 on Module Call Signatures\n\nMany popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:\n\n``` ts\nimport exp = require(\"express\");\nvar app = exp();\n```\n\nIn ES6-compliant module loaders, the top-level object (here imported as `exp`) can only have properties; the top-level module object can *never* be callable.\n\nThe most common solution here is to define a `default` export for a callable/constructable object; module loaders commonly detect this situation automatically and replace the top-level object with the `default` export. TypeScript can handle this for you, if you have [`\"esModuleInterop\": true`](https://www.typescriptlang.org/tsconfig/#esModuleInterop) in your tsconfig.json.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html)"
- name: 'Library Structures: Identifying Kinds of Libraries'
  id: declaration-files/library-structures#identifying-kinds-of-libraries
  summary: First, we’ll review the kinds of libraries TypeScript declaration files can represent
  belongs_to: Library Structures
  description: |-
    ## Identifying Kinds of Libraries

    First, we’ll review the kinds of libraries TypeScript declaration files can represent. We’ll briefly show how each kind of library is *used*, how it is *written*, and list some example libraries from the real world.

    Identifying the structure of a library is the first step in writing its declaration file. We’ll give hints on how to identify structure both based on its *usage* and its *code*. Depending on the library’s documentation and organization, one might be easier than the other. We recommend using whichever is more comfortable to you.

    ### What should you look for?

    Question to ask yourself while looking at a library you are trying to type.

    1.  How do you obtain the library?

        For example, can you *only* get it through npm or only from a CDN?

    2.  How would you import it?

        Does it add a global object? Does it use `require` or `import`/`export` statements?

    ### Smaller samples for different types of libraries

    ### Modular Libraries

    Almost every modern Node.js library falls into the module family. These type of libraries only work in a JS environment with a module loader. For example, `express` only works in Node.js and must be loaded using the CommonJS `require` function.

    ECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of *importing* a *module*. In JavaScript CommonJS (Node.js), for example, you would write

    ``` js
    var fs = require("fs");
    ```

    In TypeScript or ES6, the `import` keyword serves the same purpose:

    ``` ts
    import * as fs from "fs";
    ```

    You’ll typically see modular libraries include one of these lines in their documentation:

    ``` js
    var someLib = require("someLib");
    ```

    or

    ``` js
    define(..., ['someLib'], function(someLib) {

    });
    ```

    As with global modules, you might see these examples in the documentation of [a UMD](#umd) module, so be sure to check the code or documentation.

    #### Identifying a Module Library from Code

    Modular libraries will typically have at least some of the following:

    - Unconditional calls to `require` or `define`
    - Declarations like `import * as a from 'b';` or `export c;`
    - Assignments to `exports` or `module.exports`

    They will rarely have:

    - Assignments to properties of `window` or `global`

    #### Templates For Modules

    There are four templates available for modules, [`module.d.ts`](templates/module-d-ts), [`module-class.d.ts`](templates/module-class-d-ts), [`module-function.d.ts`](templates/module-function-d-ts) and [`module-plugin.d.ts`](templates/module-plugin-d-ts).

    You should first read [`module.d.ts`](templates/module-d-ts) for an overview on the way they all work.

    Then use the template [`module-function.d.ts`](templates/module-function-d-ts) if your module can be *called* like a function:

    ``` js
    const x = require("foo");
    // Note: calling 'x' as a function
    const y = x(42);
    ```

    Use the template [`module-class.d.ts`](templates/module-class-d-ts) if your module can be *constructed* using `new`:

    ``` js
    const x = require("bar");
    // Note: using 'new' operator on the imported variable
    const y = new x("hello");
    ```

    If you have a module which when imported, makes changes to other modules use template [`module-plugin.d.ts`](templates/module-plugin-d-ts):

    ``` js
    const jest = require("jest");
    require("jest-matchers-files");
    ```

    ### Global Libraries

    A *global* library is one that can be accessed from the global scope (i.e. without using any form of `import`). Many libraries simply expose one or more global variables for use. For example, if you were using [jQuery](https://jquery.com/), the `$` variable can be used by simply referring to it:

    ``` ts
    $(() => {
      console.log("hello!");
    });
    ```

    You’ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:

    ``` html
    <script src="http://a.great.cdn.for/someLib.js"></script>
    ```

    Today, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn’t actually UMD.

    #### Identifying a Global Library from Code

    Global library code is usually extremely simple. A global “Hello, world” library might look like this:

    ``` js
    function createGreeting(s) {
      return "Hello, " + s;
    }
    ```

    or like this:

    ``` js
    // Web
    window.createGreeting = function (s) {
      return "Hello, " + s;
    };

    // Node
    global.createGreeting = function (s) {
      return "Hello, " + s;
    };

    // Potentially any runtime
    globalThis.createGreeting = function (s) {
      return "Hello, " + s;
    };
    ```

    When looking at the code of a global library, you’ll usually see:

    - Top-level `var` statements or `function` declarations
    - One or more assignments to `window.someName`
    - Assumptions that DOM primitives like `document` or `window` exist

    You *won’t* see:

    - Checks for, or usage of, module loaders like `require` or `define`
    - CommonJS/Node.js-style imports of the form `var fs = require("fs");`
    - Calls to `define(...)`
    - Documentation describing how to `require` or import the library

    #### Examples of Global Libraries

    Because it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have *no* dependencies) may still be global.

    #### Global Library Template

    The template file [`global.d.ts`](templates/global-d-ts) defines an example library `myLib`. Be sure to read the [“Preventing Name Conflicts” footnote](#preventing-name-conflicts).

    ### *UMD*

    A *UMD* module is one that can *either* be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as [Moment.js](https://momentjs.com/), are written this way. For example, in Node.js or using RequireJS, you would write:

    ``` ts
    import moment = require("moment");
    console.log(moment.format());
    ```

    whereas in a vanilla browser environment you would write:

    ``` js
    console.log(moment.format());
    ```

    #### Identifying a UMD library

    [UMD modules](https://github.com/umdjs/umd) check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:

    ``` js
    (function (root, factory) {
        if (typeof define === "function" && define.amd) {
            define(["libName"], factory);
        } else if (typeof module === "object" && module.exports) {
            module.exports = factory(require("libName"));
        } else {
            root.returnExports = factory(root.libName);
        }
    }(this, function (b) {
    ```

    If you see tests for `typeof define`, `typeof window`, or `typeof module` in the code of a library, especially at the top of the file, it’s almost always a UMD library.

    Documentation for UMD libraries will also often demonstrate a “Using in Node.js” example showing `require`, and a “Using in the browser” example showing using a `<script>` tag to load the script.

    #### Examples of UMD libraries

    Most popular libraries are now available as UMD packages. Examples include [jQuery](https://jquery.com/), [Moment.js](https://momentjs.com/), [lodash](https://lodash.com/), and many more.

    #### Template

    Use the [`module-plugin.d.ts`](templates/module-plugin-d-ts) template.
- name: listEmittedFiles
  id: tsconfig#listEmittedFiles-config
  summary: Print names of generated files part of the compilation to the terminal
  belongs_to: TSConfig Reference
  description: |-
    ### List Emitted Files - `listEmittedFiles`

    Print names of generated files part of the compilation to the terminal.

    This flag is useful in two cases:

    - You want to transpile TypeScript as a part of a build chain in the terminal where the filenames are processed in the next command.
    - You are not sure that TypeScript has included a file you expected, as a part of debugging the [file inclusion settings](#Project_Files_0).

    For example:

    ``` typescript
    example
    ├── index.ts
    ├── package.json
    └── tsconfig.json
    ```

    With:

    ``` typescript
    {
      "compilerOptions": {
        "declaration": true,
        "listEmittedFiles": true
      }
    }
    ```

    Would echo paths like:

    ``` typescript
    $ npm run tsc

    path/to/example/index.js
    path/to/example/index.d.ts
    ```

    Normally, TypeScript would return silently on success.
- name: listEmittedFiles
  id: tsconfig/index#listEmittedFiles-config
  summary: Print names of generated files part of the compilation to the terminal
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### List Emitted Files - `listEmittedFiles`

    Print names of generated files part of the compilation to the terminal.

    This flag is useful in two cases:

    - You want to transpile TypeScript as a part of a build chain in the terminal where the filenames are processed in the next command.
    - You are not sure that TypeScript has included a file you expected, as a part of debugging the [file inclusion settings](#Project_Files_0).

    For example:

    ``` typescript
    example
    ├── index.ts
    ├── package.json
    └── tsconfig.json
    ```

    With:

    ``` typescript
    {
      "compilerOptions": {
        "declaration": true,
        "listEmittedFiles": true
      }
    }
    ```

    Would echo paths like:

    ``` typescript
    $ npm run tsc

    path/to/example/index.js
    path/to/example/index.d.ts
    ```

    Normally, TypeScript would return silently on success.
- name: listFiles
  id: tsconfig/index#listFiles-config
  summary: Print names of files part of the compilation
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### List Files - `listFiles`

    Print names of files part of the compilation. This is useful when you are not sure that TypeScript has included a file you expected.

    For example:

    ``` typescript
    example
    ├── index.ts
    ├── package.json
    └── tsconfig.json
    ```

    With:

    ``` typescript
    {
      "compilerOptions": {
        "listFiles": true
      }
    }
    ```

    Would echo paths like:

    ``` typescript
    $ npm run tsc
    path/to/example/node_modules/typescript/lib/lib.d.ts
    path/to/example/node_modules/typescript/lib/lib.es5.d.ts
    path/to/example/node_modules/typescript/lib/lib.dom.d.ts
    path/to/example/node_modules/typescript/lib/lib.webworker.importscripts.d.ts
    path/to/example/node_modules/typescript/lib/lib.scripthost.d.ts
    path/to/example/index.ts
    ```

    Note if using TypeScript 4.2, prefer [`explainFiles`](#explainFiles) which offers an explanation of why a file was added too.

    - Related:
      - [`explainFiles`](#explainFiles)
- name: listFiles
  id: tsconfig#listFiles-config
  summary: Print names of files part of the compilation
  belongs_to: TSConfig Reference
  description: |-
    ### List Files - `listFiles`

    Print names of files part of the compilation. This is useful when you are not sure that TypeScript has included a file you expected.

    For example:

    ``` typescript
    example
    ├── index.ts
    ├── package.json
    └── tsconfig.json
    ```

    With:

    ``` typescript
    {
      "compilerOptions": {
        "listFiles": true
      }
    }
    ```

    Would echo paths like:

    ``` typescript
    $ npm run tsc
    path/to/example/node_modules/typescript/lib/lib.d.ts
    path/to/example/node_modules/typescript/lib/lib.es5.d.ts
    path/to/example/node_modules/typescript/lib/lib.dom.d.ts
    path/to/example/node_modules/typescript/lib/lib.webworker.importscripts.d.ts
    path/to/example/node_modules/typescript/lib/lib.scripthost.d.ts
    path/to/example/index.ts
    ```

    Note if using TypeScript 4.2, prefer [`explainFiles`](#explainFiles) which offers an explanation of why a file was added too.

    - Related:
      - [`explainFiles`](#explainFiles)
- name: Mapped Types
  id: 2/mapped-types
  summary: When you don’t want to repeat yourself, sometimes a type needs to be based on another type
  description: "# Mapped Types\n\nWhen you don’t want to repeat yourself, sometimes a type needs to be based on another type.\n\nMapped types build on the syntax for index signatures, which are used to declare the types of properties which have not been declared ahead of time:\n\n``` ts\ntype OnlyBoolsAndHorses = {\n  [key: string]: boolean | Horse;\n};\n \nconst conforms: OnlyBoolsAndHorses = {\n  del: true,\n  rodney: false,\n};\n```\n\nA mapped type is a generic type which uses a union of `PropertyKey`s (frequently created [via a `keyof`](indexed-access-types)) to iterate through keys to create a type:\n\n``` ts\ntype OptionsFlags<Type> = {\n  [Property in keyof Type]: boolean;\n};\n```\n\nIn this example, `OptionsFlags` will take all the properties from the type `Type` and change their values to be a boolean.\n\n``` ts\ntype Features = {\n  darkMode: () => void;\n  newUserProfile: () => void;\n};\n \ntype FeatureOptions = OptionsFlags<Features>;\n```\n\n### Mapping Modifiers\n\nThere are two additional modifiers which can be applied during mapping: `readonly` and `?` which affect mutability and optionality respectively.\n\nYou can remove or add these modifiers by prefixing with `-` or `+`. If you don’t add a prefix, then `+` is assumed.\n\n``` ts\n// Removes 'readonly' attributes from a type's properties\ntype CreateMutable<Type> = {\n  -readonly [Property in keyof Type]: Type[Property];\n};\n \ntype LockedAccount = {\n  readonly id: string;\n  readonly name: string;\n};\n \ntype UnlockedAccount = CreateMutable<LockedAccount>;\n```\n\n``` ts\n// Removes 'optional' attributes from a type's properties\ntype Concrete<Type> = {\n  [Property in keyof Type]-?: Type[Property];\n};\n \ntype MaybeUser = {\n  id: string;\n  name?: string;\n  age?: number;\n};\n \ntype User = Concrete<MaybeUser>;\n```\n\n## Key Remapping via `as`\n\nIn TypeScript 4.1 and onwards, you can re-map keys in mapped types with an `as` clause in a mapped type:\n\n``` ts\ntype MappedTypeWithNewProperties<Type> = {\n    [Properties in keyof Type as NewKeyType]: Type[Properties]\n}\n```\n\nYou can leverage features like [template literal types](template-literal-types) to create new property names from prior ones:\n\n``` ts\ntype Getters<Type> = {\n    [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]\n};\n \ninterface Person {\n    name: string;\n    age: number;\n    location: string;\n}\n \ntype LazyPerson = Getters<Person>;\n```\n\nYou can filter out keys by producing `never` via a conditional type:\n\n``` ts\n// Remove the 'kind' property\ntype RemoveKindField<Type> = {\n    [Property in keyof Type as Exclude<Property, \"kind\">]: Type[Property]\n};\n \ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n \ntype KindlessCircle = RemoveKindField<Circle>;\n```\n\nYou can map over arbitrary unions, not just unions of `string | number | symbol`, but unions of any type:\n\n``` ts\ntype EventConfig<Events extends { kind: string }> = {\n    [E in Events as E[\"kind\"]]: (event: E) => void;\n}\n \ntype SquareEvent = { kind: \"square\", x: number, y: number };\ntype CircleEvent = { kind: \"circle\", radius: number };\n \ntype Config = EventConfig<SquareEvent | CircleEvent>\n```\n\n### Further Exploration\n\nMapped types work well with other features in this type manipulation section, for example here is [a mapped type using a conditional type](conditional-types) which returns either a `true` or `false` depending on whether an object has the property `pii` set to the literal `true`:\n\n``` ts\ntype ExtractPII<Type> = {\n  [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;\n};\n \ntype DBFields = {\n  id: { format: \"incrementing\" };\n  name: { type: string; pii: true };\n};\n \ntype ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/mapped-types.html](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)"
- name: 'Mapped Types: Key Remapping via as'
  id: 2/mapped-types#key-remapping-via-as
  summary: © 2012-2024 Microsoft Licensed under the Apache License, Version 2.0
  belongs_to: Mapped Types
  description: "## Key Remapping via `as`\n\nIn TypeScript 4.1 and onwards, you can re-map keys in mapped types with an `as` clause in a mapped type:\n\n``` ts\ntype MappedTypeWithNewProperties<Type> = {\n    [Properties in keyof Type as NewKeyType]: Type[Properties]\n}\n```\n\nYou can leverage features like [template literal types](template-literal-types) to create new property names from prior ones:\n\n``` ts\ntype Getters<Type> = {\n    [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]\n};\n \ninterface Person {\n    name: string;\n    age: number;\n    location: string;\n}\n \ntype LazyPerson = Getters<Person>;\n```\n\nYou can filter out keys by producing `never` via a conditional type:\n\n``` ts\n// Remove the 'kind' property\ntype RemoveKindField<Type> = {\n    [Property in keyof Type as Exclude<Property, \"kind\">]: Type[Property]\n};\n \ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n \ntype KindlessCircle = RemoveKindField<Circle>;\n```\n\nYou can map over arbitrary unions, not just unions of `string | number | symbol`, but unions of any type:\n\n``` ts\ntype EventConfig<Events extends { kind: string }> = {\n    [E in Events as E[\"kind\"]]: (event: E) => void;\n}\n \ntype SquareEvent = { kind: \"square\", x: number, y: number };\ntype CircleEvent = { kind: \"circle\", radius: number };\n \ntype Config = EventConfig<SquareEvent | CircleEvent>\n```\n\n### Further Exploration\n\nMapped types work well with other features in this type manipulation section, for example here is [a mapped type using a conditional type](conditional-types) which returns either a `true` or `false` depending on whether an object has the property `pii` set to the literal `true`:\n\n``` ts\ntype ExtractPII<Type> = {\n  [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;\n};\n \ntype DBFields = {\n  id: { format: \"incrementing\" };\n  name: { type: string; pii: true };\n};\n \ntype ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/mapped-types.html](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)"
- name: mapRoot
  id: tsconfig/index#mapRoot-config
  summary: Specify the location where debugger should locate map files instead of generated locations
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Map Root - `mapRoot`

    Specify the location where debugger should locate map files instead of generated locations. This string is treated verbatim inside the source-map, for example:

    ``` typescript
    {
      "compilerOptions": {
        "sourceMap": true,
        "mapRoot": "https://my-website.com/debug/sourcemaps/"
      }
    }
    ```

    Would declare that `index.js` will have sourcemaps at `https://my-website.com/debug/sourcemaps/index.js.map`.
- name: mapRoot
  id: tsconfig#mapRoot-config
  summary: Specify the location where debugger should locate map files instead of generated locations
  belongs_to: TSConfig Reference
  description: |-
    ### Map Root - `mapRoot`

    Specify the location where debugger should locate map files instead of generated locations. This string is treated verbatim inside the source-map, for example:

    ``` typescript
    {
      "compilerOptions": {
        "sourceMap": true,
        "mapRoot": "https://my-website.com/debug/sourcemaps/"
      }
    }
    ```

    Would declare that `index.js` will have sourcemaps at `https://my-website.com/debug/sourcemaps/index.js.map`.
- name: maxNodeModuleJsDepth
  id: tsconfig#maxNodeModuleJsDepth-config
  summary: The maximum dependency depth to search under node_modules and load JavaScript files
  belongs_to: TSConfig Reference
  description: |-
    ### Max Node Module JS Depth - `maxNodeModuleJsDepth`

    The maximum dependency depth to search under `node_modules` and load JavaScript files.

    This flag can only be used when [`allowJs`](#allowJs) is enabled, and is used if you want to have TypeScript infer types for all of the JavaScript inside your `node_modules`.

    Ideally this should stay at 0 (the default), and `d.ts` files should be used to explicitly define the shape of modules. However, there are cases where you may want to turn this on at the expense of speed and potential accuracy.

    ## Editor Support
- name: maxNodeModuleJsDepth
  id: tsconfig/index#maxNodeModuleJsDepth-config
  summary: The maximum dependency depth to search under node_modules and load JavaScript files
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Max Node Module JS Depth - `maxNodeModuleJsDepth`

    The maximum dependency depth to search under `node_modules` and load JavaScript files.

    This flag can only be used when [`allowJs`](#allowJs) is enabled, and is used if you want to have TypeScript infer types for all of the JavaScript inside your `node_modules`.

    Ideally this should stay at 0 (the default), and `d.ts` files should be used to explicitly define the shape of modules. However, there are cases where you may want to turn this on at the expense of speed and potential accuracy.

    ## Editor Support
- name: Migrating from JavaScript
  id: migrating-from-javascript
  summary: TypeScript doesn’t exist in a vacuum
  description: "# Migrating from JavaScript\n\nTypeScript doesn’t exist in a vacuum. It was built with the JavaScript ecosystem in mind, and a lot of JavaScript exists today. Converting a JavaScript codebase over to TypeScript is, while somewhat tedious, usually not challenging. In this tutorial, we’re going to look at how you might start out. We assume you’ve read enough of the handbook to write new TypeScript code.\n\nIf you’re looking to convert a React project, we recommend looking at the [React Conversion Guide](https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide) first.\n\n## Setting up your Directories\n\nIf you’re writing in plain JavaScript, it’s likely that you’re running your JavaScript directly, where your `.js` files are in a `src`, `lib`, or `dist` directory, and then run as desired.\n\nIf that’s the case, the files that you’ve written are going to be used as inputs to TypeScript, and you’ll run the outputs it produces. During our JS to TS migration, we’ll need to separate our input files to prevent TypeScript from overwriting them. If your output files need to reside in a specific directory, then that will be your output directory.\n\nYou might also be running some intermediate steps on your JavaScript, such as bundling or using another transpiler like Babel. In this case, you might already have a folder structure like this set up.\n\nFrom this point on, we’re going to assume that your directory is set up something like this:\n\n``` typescript\nprojectRoot\n├── src\n│   ├── file1.js\n│   └── file2.js\n├── built\n└── tsconfig.json\n```\n\nIf you have a `tests` folder outside of your `src` directory, you might have one `tsconfig.json` in `src`, and one in `tests` as well.\n\n## Writing a Configuration File\n\nTypeScript uses a file called `tsconfig.json` for managing your project’s options, such as which files you want to include, and what sorts of checking you want to perform. Let’s create a bare-bones one for our project:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./built\",\n    \"allowJs\": true,\n    \"target\": \"es5\"\n  },\n  \"include\": [\"./src/**/*\"]\n}\n```\n\nHere we’re specifying a few things to TypeScript:\n\n1.  Read in any files it understands in the `src` directory (with [`include`](https://www.typescriptlang.org/tsconfig#include)).\n2.  Accept JavaScript files as inputs (with [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs)).\n3.  Emit all of the output files in `built` (with [`outDir`](https://www.typescriptlang.org/tsconfig#outDir)).\n4.  Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using [`target`](https://www.typescriptlang.org/tsconfig#target)).\n\nAt this point, if you try running `tsc` at the root of your project, you should see output files in the `built` directory. The layout of files in `built` should look identical to the layout of `src`. You should now have TypeScript working with your project.\n\n## Early Benefits\n\nEven at this point you can get some great benefits from TypeScript understanding your project. If you open up an editor like [VS Code](https://code.visualstudio.com) or [Visual Studio](https://visualstudio.com), you’ll see that you can often get some tooling support like completion. You can also catch certain bugs with options like:\n\n- [`noImplicitReturns`](https://www.typescriptlang.org/tsconfig#noImplicitReturns) which prevents you from forgetting to return at the end of a function.\n- [`noFallthroughCasesInSwitch`](https://www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch) which is helpful if you never want to forget a `break` statement between `case`s in a `switch` block.\n\nTypeScript will also warn about unreachable code and labels, which you can disable with [`allowUnreachableCode`](https://www.typescriptlang.org/tsconfig#allowUnreachableCode) and [`allowUnusedLabels`](https://www.typescriptlang.org/tsconfig#allowUnusedLabels) respectively.\n\n## Integrating with Build Tools\n\nYou might have some more build steps in your pipeline. Perhaps you concatenate something to each of your files. Each build tool is different, but we’ll do our best to cover the gist of things.\n\n### Gulp\n\nIf you’re using Gulp in some fashion, we have a tutorial on [using Gulp](gulp) with TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify. You can read more there.\n\n### Webpack\n\nWebpack integration is pretty simple. You can use `ts-loader`, a TypeScript loader, combined with `source-map-loader` for easier debugging. Simply run\n\n``` shell\nnpm install ts-loader source-map-loader\n```\n\nand merge in options from the following into your `webpack.config.js` file:\n\n``` js\nmodule.exports = {\n  entry: \"./src/index.ts\",\n  output: {\n    filename: \"./dist/bundle.js\",\n  },\n\n  // Enable sourcemaps for debugging webpack's output.\n  devtool: \"source-map\",\n\n  resolve: {\n    // Add '.ts' and '.tsx' as resolvable extensions.\n    extensions: [\"\", \".webpack.js\", \".web.js\", \".ts\", \".tsx\", \".js\"],\n  },\n\n  module: {\n    rules: [\n      // All files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'.\n      { test: /\\.tsx?$/, loader: \"ts-loader\" },\n\n      // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.\n      { test: /\\.js$/, loader: \"source-map-loader\" },\n    ],\n  },\n\n  // Other options...\n};\n```\n\nIt’s important to note that ts-loader will need to run before any other loader that deals with `.js` files.\n\nYou can see an example of using Webpack in our [tutorial on React and Webpack](https://www.typescriptlang.org/docs/handbook/react-&-webpack.html).\n\n## Moving to TypeScript Files\n\nAt this point, you’re probably ready to start using TypeScript files. The first step is to rename one of your `.js` files to `.ts`. If your file uses JSX, you’ll need to rename it to `.tsx`.\n\nFinished with that step? Great! You’ve successfully migrated a file from JavaScript to TypeScript!\n\nOf course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run `tsc --pretty`), you might see red squiggles on certain lines. You should think of these the same way you’d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.\n\nIf that sounds too lax for you, you can tighten that behavior up. If, for instance, you *don’t* want TypeScript to compile to JavaScript in the face of errors, you can use the [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) option. In that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want.\n\nIf you plan on using the stricter settings that are available, it’s best to turn them on now (see [Getting Stricter Checks](#getting-stricter-checks) below). For instance, if you never want TypeScript to silently infer `any` for a type without you explicitly saying so, you can use [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) before you start modifying your files. While it might feel somewhat overwhelming, the long-term gains become apparent much more quickly.\n\n### Weeding out Errors\n\nLike we mentioned, it’s not unexpected to get error messages after conversion. The important thing is to actually go one by one through these and decide how to deal with the errors. Often these will be legitimate bugs, but sometimes you’ll have to explain what you’re trying to do a little better to TypeScript.\n\n#### Importing from Modules\n\nYou might start out getting a bunch of errors like `Cannot find name 'require'.`, and `Cannot find name 'define'.`. In these cases, it’s likely that you’re using modules. While you can just convince TypeScript that these exist by writing out\n\n``` ts\n// For Node/CommonJS\ndeclare function require(path: string): any;\n```\n\nor\n\n``` ts\n// For RequireJS/AMD\ndeclare function define(...args: any[]): any;\n```\n\nit’s better to get rid of those calls and use TypeScript syntax for imports.\n\nFirst, you’ll need to enable some module system by setting TypeScript’s [`module`](https://www.typescriptlang.org/tsconfig#module) option. Valid options are `commonjs`, `amd`, `system`, and `umd`.\n\nIf you had the following Node/CommonJS code:\n\n``` js\nvar foo = require(\"foo\");\n\nfoo.doStuff();\n```\n\nor the following RequireJS/AMD code:\n\n``` js\ndefine([\"foo\"], function (foo) {\n  foo.doStuff();\n});\n```\n\nthen you would write the following TypeScript code:\n\n``` ts\nimport foo = require(\"foo\");\n\nfoo.doStuff();\n```\n\n#### Getting Declaration Files\n\nIf you started converting over to TypeScript imports, you’ll probably run into errors like `Cannot find module 'foo'.`. The issue here is that you likely don’t have *declaration files* to describe your library. Luckily this is pretty easy. If TypeScript complains about a package like `lodash`, you can just write\n\n``` shell\nnpm install -S @types/lodash\n```\n\nIf you’re using a module option other than `commonjs`, you’ll need to set your [`moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution) option to `node`.\n\nAfter that, you’ll be able to import lodash with no issues, and get accurate completions.\n\n#### Exporting from Modules\n\nTypically, exporting from a module involves adding properties to a value like `exports` or `module.exports`. TypeScript allows you to use top-level export statements. For instance, if you exported a function like so:\n\n``` js\nmodule.exports.feedPets = function (pets) {\n  // ...\n};\n```\n\nyou could write that out as the following:\n\n``` ts\nexport function feedPets(pets) {\n  // ...\n}\n```\n\nSometimes you’ll entirely overwrite the exports object. This is a common pattern people use to make their modules immediately callable like in this snippet:\n\n``` js\nvar express = require(\"express\");\nvar app = express();\n```\n\nYou might have previously written that like so:\n\n``` js\nfunction foo() {\n  // ...\n}\nmodule.exports = foo;\n```\n\nIn TypeScript, you can model this with the `export =` construct.\n\n``` ts\nfunction foo() {\n  // ...\n}\nexport = foo;\n```\n\n#### Too many/too few arguments\n\nYou’ll sometimes find yourself calling a function with too many/few arguments. Typically, this is a bug, but in some cases, you might have declared a function that uses the `arguments` object instead of writing out any parameters:\n\n``` js\nfunction myCoolFunction() {\n  if (arguments.length == 2 && !Array.isArray(arguments[1])) {\n    var f = arguments[0];\n    var arr = arguments[1];\n    // ...\n  }\n  // ...\n}\n\nmyCoolFunction(\n  function (x) {\n    console.log(x);\n  },\n  [1, 2, 3, 4]\n);\nmyCoolFunction(\n  function (x) {\n    console.log(x);\n  },\n  1,\n  2,\n  3,\n  4\n);\n```\n\nIn this case, we need to use TypeScript to tell any of our callers about the ways `myCoolFunction` can be called using function overloads.\n\n``` ts\nfunction myCoolFunction(f: (x: number) => void, nums: number[]): void;\nfunction myCoolFunction(f: (x: number) => void, ...nums: number[]): void;\nfunction myCoolFunction() {\n  if (arguments.length == 2 && !Array.isArray(arguments[1])) {\n    var f = arguments[0];\n    var arr = arguments[1];\n    // ...\n  }\n  // ...\n}\n```\n\nWe added two overload signatures to `myCoolFunction`. The first checks states that `myCoolFunction` takes a function (which takes a `number`), and then a list of `number`s. The second one says that it will take a function as well, and then uses a rest parameter (`...nums`) to state that any number of arguments after that need to be `number`s.\n\n#### Sequentially Added Properties\n\nSome people find it more aesthetically pleasing to create an object and add properties immediately after like so:\n\n``` js\nvar options = {};\noptions.color = \"red\";\noptions.volume = 11;\n```\n\nTypeScript will say that you can’t assign to `color` and `volume` because it first figured out the type of `options` as `{}` which doesn’t have any properties. If you instead moved the declarations into the object literal themselves, you’d get no errors:\n\n``` ts\nlet options = {\n  color: \"red\",\n  volume: 11,\n};\n```\n\nYou could also define the type of `options` and add a type assertion on the object literal.\n\n``` ts\ninterface Options {\n  color: string;\n  volume: number;\n}\n\nlet options = {} as Options;\noptions.color = \"red\";\noptions.volume = 11;\n```\n\nAlternatively, you can just say `options` has the type `any` which is the easiest thing to do, but which will benefit you the least.\n\n#### `any`, `Object`, and `{}`\n\nYou might be tempted to use `Object` or `{}` to say that a value can have any property on it because `Object` is, for most purposes, the most general type. However **`any` is actually the type you want to use** in those situations, since it’s the most *flexible* type.\n\nFor instance, if you have something that’s typed as `Object` you won’t be able to call methods like `toLowerCase()` on it. Being more general usually means you can do less with a type, but `any` is special in that it is the most general type while still allowing you to do anything with it. That means you can call it, construct it, access properties on it, etc. Keep in mind though, whenever you use `any`, you lose out on most of the error checking and editor support that TypeScript gives you.\n\nIf a decision ever comes down to `Object` and `{}`, you should prefer `{}`. While they are mostly the same, technically `{}` is a more general type than `Object` in certain esoteric cases.\n\n### Getting Stricter Checks\n\nTypeScript comes with certain checks to give you more safety and analysis of your program. Once you’ve converted your codebase to TypeScript, you can start enabling these checks for greater safety.\n\n#### No Implicit `any`\n\nThere are certain cases where TypeScript can’t figure out what certain types should be. To be as lenient as possible, it will decide to use the type `any` in its place. While this is great for migration, using `any` means that you’re not getting any type safety, and you won’t get the same tooling support you’d get elsewhere. You can tell TypeScript to flag these locations down and give an error with the [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) option.\n\n#### Strict `null` & `undefined` Checks\n\nBy default, TypeScript assumes that `null` and `undefined` are in the domain of every type. That means anything declared with the type `number` could be `null` or `undefined`. Since `null` and `undefined` are such a frequent source of bugs in JavaScript and TypeScript, TypeScript has the [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) option to spare you the stress of worrying about these issues.\n\nWhen [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is enabled, `null` and `undefined` get their own types called `null` and `undefined` respectively. Whenever anything is *possibly* `null`, you can use a union type with the original type. So for instance, if something could be a `number` or `null`, you’d write the type out as `number | null`.\n\nIf you ever have a value that TypeScript thinks is possibly `null`/`undefined`, but you know better, you can use the postfix `!` operator to tell it otherwise.\n\n``` ts\ndeclare var foo: string[] | null;\n\nfoo.length; // error - 'foo' is possibly 'null'\n\nfoo!.length; // okay - 'foo!' just has type 'string[]'\n```\n\nAs a heads up, when using [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks), your dependencies may need to be updated to use [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) as well.\n\n#### No Implicit `any` for `this`\n\nWhen you use the `this` keyword outside of classes, it has the type `any` by default. For instance, imagine a `Point` class, and imagine a function that we wish to add as a method:\n\n``` ts\nclass Point {\n  constructor(public x, public y) {}\n  getDistance(p: Point) {\n    let dx = p.x - this.x;\n    let dy = p.y - this.y;\n    return Math.sqrt(dx ** 2 + dy ** 2);\n  }\n}\n// ...\n\n// Reopen the interface.\ninterface Point {\n  distanceFromOrigin(): number;\n}\nPoint.prototype.distanceFromOrigin = function () {\n  return this.getDistance({ x: 0, y: 0 });\n};\n```\n\nThis has the same problems we mentioned above - we could easily have misspelled `getDistance` and not gotten an error. For this reason, TypeScript has the [`noImplicitThis`](https://www.typescriptlang.org/tsconfig#noImplicitThis) option. When that option is set, TypeScript will issue an error when `this` is used without an explicit (or inferred) type. The fix is to use a `this`-parameter to give an explicit type in the interface or in the function itself:\n\n``` ts\nPoint.prototype.distanceFromOrigin = function (this: Point) {\n  return this.getDistance({ x: 0, y: 0 });\n};\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html)"
- name: 'Migrating from JavaScript: Early Benefits'
  id: migrating-from-javascript#early-benefits
  summary: Even at this point you can get some great benefits from TypeScript understanding your project
  belongs_to: Migrating from JavaScript
  description: |-
    ## Early Benefits

    Even at this point you can get some great benefits from TypeScript understanding your project. If you open up an editor like [VS Code](https://code.visualstudio.com) or [Visual Studio](https://visualstudio.com), you’ll see that you can often get some tooling support like completion. You can also catch certain bugs with options like:

    - [`noImplicitReturns`](https://www.typescriptlang.org/tsconfig#noImplicitReturns) which prevents you from forgetting to return at the end of a function.
    - [`noFallthroughCasesInSwitch`](https://www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch) which is helpful if you never want to forget a `break` statement between `case`s in a `switch` block.

    TypeScript will also warn about unreachable code and labels, which you can disable with [`allowUnreachableCode`](https://www.typescriptlang.org/tsconfig#allowUnreachableCode) and [`allowUnusedLabels`](https://www.typescriptlang.org/tsconfig#allowUnusedLabels) respectively.
- name: 'Migrating from JavaScript: Integrating with Build Tools'
  id: migrating-from-javascript#integrating-with-build-tools
  summary: You might have some more build steps in your pipeline
  belongs_to: Migrating from JavaScript
  description: |-
    ## Integrating with Build Tools

    You might have some more build steps in your pipeline. Perhaps you concatenate something to each of your files. Each build tool is different, but we’ll do our best to cover the gist of things.

    ### Gulp

    If you’re using Gulp in some fashion, we have a tutorial on [using Gulp](gulp) with TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify. You can read more there.

    ### Webpack

    Webpack integration is pretty simple. You can use `ts-loader`, a TypeScript loader, combined with `source-map-loader` for easier debugging. Simply run

    ``` shell
    npm install ts-loader source-map-loader
    ```

    and merge in options from the following into your `webpack.config.js` file:

    ``` js
    module.exports = {
      entry: "./src/index.ts",
      output: {
        filename: "./dist/bundle.js",
      },

      // Enable sourcemaps for debugging webpack's output.
      devtool: "source-map",

      resolve: {
        // Add '.ts' and '.tsx' as resolvable extensions.
        extensions: ["", ".webpack.js", ".web.js", ".ts", ".tsx", ".js"],
      },

      module: {
        rules: [
          // All files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'.
          { test: /\.tsx?$/, loader: "ts-loader" },

          // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.
          { test: /\.js$/, loader: "source-map-loader" },
        ],
      },

      // Other options...
    };
    ```

    It’s important to note that ts-loader will need to run before any other loader that deals with `.js` files.

    You can see an example of using Webpack in our [tutorial on React and Webpack](https://www.typescriptlang.org/docs/handbook/react-&-webpack.html).
- name: 'Migrating from JavaScript: Moving to TypeScript Files'
  id: migrating-from-javascript#moving-to-typescript-files
  summary: At this point, you’re probably ready to start using TypeScript files
  belongs_to: Migrating from JavaScript
  description: "## Moving to TypeScript Files\n\nAt this point, you’re probably ready to start using TypeScript files. The first step is to rename one of your `.js` files to `.ts`. If your file uses JSX, you’ll need to rename it to `.tsx`.\n\nFinished with that step? Great! You’ve successfully migrated a file from JavaScript to TypeScript!\n\nOf course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run `tsc --pretty`), you might see red squiggles on certain lines. You should think of these the same way you’d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.\n\nIf that sounds too lax for you, you can tighten that behavior up. If, for instance, you *don’t* want TypeScript to compile to JavaScript in the face of errors, you can use the [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) option. In that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want.\n\nIf you plan on using the stricter settings that are available, it’s best to turn them on now (see [Getting Stricter Checks](#getting-stricter-checks) below). For instance, if you never want TypeScript to silently infer `any` for a type without you explicitly saying so, you can use [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) before you start modifying your files. While it might feel somewhat overwhelming, the long-term gains become apparent much more quickly.\n\n### Weeding out Errors\n\nLike we mentioned, it’s not unexpected to get error messages after conversion. The important thing is to actually go one by one through these and decide how to deal with the errors. Often these will be legitimate bugs, but sometimes you’ll have to explain what you’re trying to do a little better to TypeScript.\n\n#### Importing from Modules\n\nYou might start out getting a bunch of errors like `Cannot find name 'require'.`, and `Cannot find name 'define'.`. In these cases, it’s likely that you’re using modules. While you can just convince TypeScript that these exist by writing out\n\n``` ts\n// For Node/CommonJS\ndeclare function require(path: string): any;\n```\n\nor\n\n``` ts\n// For RequireJS/AMD\ndeclare function define(...args: any[]): any;\n```\n\nit’s better to get rid of those calls and use TypeScript syntax for imports.\n\nFirst, you’ll need to enable some module system by setting TypeScript’s [`module`](https://www.typescriptlang.org/tsconfig#module) option. Valid options are `commonjs`, `amd`, `system`, and `umd`.\n\nIf you had the following Node/CommonJS code:\n\n``` js\nvar foo = require(\"foo\");\n\nfoo.doStuff();\n```\n\nor the following RequireJS/AMD code:\n\n``` js\ndefine([\"foo\"], function (foo) {\n  foo.doStuff();\n});\n```\n\nthen you would write the following TypeScript code:\n\n``` ts\nimport foo = require(\"foo\");\n\nfoo.doStuff();\n```\n\n#### Getting Declaration Files\n\nIf you started converting over to TypeScript imports, you’ll probably run into errors like `Cannot find module 'foo'.`. The issue here is that you likely don’t have *declaration files* to describe your library. Luckily this is pretty easy. If TypeScript complains about a package like `lodash`, you can just write\n\n``` shell\nnpm install -S @types/lodash\n```\n\nIf you’re using a module option other than `commonjs`, you’ll need to set your [`moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution) option to `node`.\n\nAfter that, you’ll be able to import lodash with no issues, and get accurate completions.\n\n#### Exporting from Modules\n\nTypically, exporting from a module involves adding properties to a value like `exports` or `module.exports`. TypeScript allows you to use top-level export statements. For instance, if you exported a function like so:\n\n``` js\nmodule.exports.feedPets = function (pets) {\n  // ...\n};\n```\n\nyou could write that out as the following:\n\n``` ts\nexport function feedPets(pets) {\n  // ...\n}\n```\n\nSometimes you’ll entirely overwrite the exports object. This is a common pattern people use to make their modules immediately callable like in this snippet:\n\n``` js\nvar express = require(\"express\");\nvar app = express();\n```\n\nYou might have previously written that like so:\n\n``` js\nfunction foo() {\n  // ...\n}\nmodule.exports = foo;\n```\n\nIn TypeScript, you can model this with the `export =` construct.\n\n``` ts\nfunction foo() {\n  // ...\n}\nexport = foo;\n```\n\n#### Too many/too few arguments\n\nYou’ll sometimes find yourself calling a function with too many/few arguments. Typically, this is a bug, but in some cases, you might have declared a function that uses the `arguments` object instead of writing out any parameters:\n\n``` js\nfunction myCoolFunction() {\n  if (arguments.length == 2 && !Array.isArray(arguments[1])) {\n    var f = arguments[0];\n    var arr = arguments[1];\n    // ...\n  }\n  // ...\n}\n\nmyCoolFunction(\n  function (x) {\n    console.log(x);\n  },\n  [1, 2, 3, 4]\n);\nmyCoolFunction(\n  function (x) {\n    console.log(x);\n  },\n  1,\n  2,\n  3,\n  4\n);\n```\n\nIn this case, we need to use TypeScript to tell any of our callers about the ways `myCoolFunction` can be called using function overloads.\n\n``` ts\nfunction myCoolFunction(f: (x: number) => void, nums: number[]): void;\nfunction myCoolFunction(f: (x: number) => void, ...nums: number[]): void;\nfunction myCoolFunction() {\n  if (arguments.length == 2 && !Array.isArray(arguments[1])) {\n    var f = arguments[0];\n    var arr = arguments[1];\n    // ...\n  }\n  // ...\n}\n```\n\nWe added two overload signatures to `myCoolFunction`. The first checks states that `myCoolFunction` takes a function (which takes a `number`), and then a list of `number`s. The second one says that it will take a function as well, and then uses a rest parameter (`...nums`) to state that any number of arguments after that need to be `number`s.\n\n#### Sequentially Added Properties\n\nSome people find it more aesthetically pleasing to create an object and add properties immediately after like so:\n\n``` js\nvar options = {};\noptions.color = \"red\";\noptions.volume = 11;\n```\n\nTypeScript will say that you can’t assign to `color` and `volume` because it first figured out the type of `options` as `{}` which doesn’t have any properties. If you instead moved the declarations into the object literal themselves, you’d get no errors:\n\n``` ts\nlet options = {\n  color: \"red\",\n  volume: 11,\n};\n```\n\nYou could also define the type of `options` and add a type assertion on the object literal.\n\n``` ts\ninterface Options {\n  color: string;\n  volume: number;\n}\n\nlet options = {} as Options;\noptions.color = \"red\";\noptions.volume = 11;\n```\n\nAlternatively, you can just say `options` has the type `any` which is the easiest thing to do, but which will benefit you the least.\n\n#### `any`, `Object`, and `{}`\n\nYou might be tempted to use `Object` or `{}` to say that a value can have any property on it because `Object` is, for most purposes, the most general type. However **`any` is actually the type you want to use** in those situations, since it’s the most *flexible* type.\n\nFor instance, if you have something that’s typed as `Object` you won’t be able to call methods like `toLowerCase()` on it. Being more general usually means you can do less with a type, but `any` is special in that it is the most general type while still allowing you to do anything with it. That means you can call it, construct it, access properties on it, etc. Keep in mind though, whenever you use `any`, you lose out on most of the error checking and editor support that TypeScript gives you.\n\nIf a decision ever comes down to `Object` and `{}`, you should prefer `{}`. While they are mostly the same, technically `{}` is a more general type than `Object` in certain esoteric cases.\n\n### Getting Stricter Checks\n\nTypeScript comes with certain checks to give you more safety and analysis of your program. Once you’ve converted your codebase to TypeScript, you can start enabling these checks for greater safety.\n\n#### No Implicit `any`\n\nThere are certain cases where TypeScript can’t figure out what certain types should be. To be as lenient as possible, it will decide to use the type `any` in its place. While this is great for migration, using `any` means that you’re not getting any type safety, and you won’t get the same tooling support you’d get elsewhere. You can tell TypeScript to flag these locations down and give an error with the [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) option.\n\n#### Strict `null` & `undefined` Checks\n\nBy default, TypeScript assumes that `null` and `undefined` are in the domain of every type. That means anything declared with the type `number` could be `null` or `undefined`. Since `null` and `undefined` are such a frequent source of bugs in JavaScript and TypeScript, TypeScript has the [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) option to spare you the stress of worrying about these issues.\n\nWhen [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is enabled, `null` and `undefined` get their own types called `null` and `undefined` respectively. Whenever anything is *possibly* `null`, you can use a union type with the original type. So for instance, if something could be a `number` or `null`, you’d write the type out as `number | null`.\n\nIf you ever have a value that TypeScript thinks is possibly `null`/`undefined`, but you know better, you can use the postfix `!` operator to tell it otherwise.\n\n``` ts\ndeclare var foo: string[] | null;\n\nfoo.length; // error - 'foo' is possibly 'null'\n\nfoo!.length; // okay - 'foo!' just has type 'string[]'\n```\n\nAs a heads up, when using [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks), your dependencies may need to be updated to use [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) as well.\n\n#### No Implicit `any` for `this`\n\nWhen you use the `this` keyword outside of classes, it has the type `any` by default. For instance, imagine a `Point` class, and imagine a function that we wish to add as a method:\n\n``` ts\nclass Point {\n  constructor(public x, public y) {}\n  getDistance(p: Point) {\n    let dx = p.x - this.x;\n    let dy = p.y - this.y;\n    return Math.sqrt(dx ** 2 + dy ** 2);\n  }\n}\n// ...\n\n// Reopen the interface.\ninterface Point {\n  distanceFromOrigin(): number;\n}\nPoint.prototype.distanceFromOrigin = function () {\n  return this.getDistance({ x: 0, y: 0 });\n};\n```\n\nThis has the same problems we mentioned above - we could easily have misspelled `getDistance` and not gotten an error. For this reason, TypeScript has the [`noImplicitThis`](https://www.typescriptlang.org/tsconfig#noImplicitThis) option. When that option is set, TypeScript will issue an error when `this` is used without an explicit (or inferred) type. The fix is to use a `this`-parameter to give an explicit type in the interface or in the function itself:\n\n``` ts\nPoint.prototype.distanceFromOrigin = function (this: Point) {\n  return this.getDistance({ x: 0, y: 0 });\n};\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html)"
- name: 'Migrating from JavaScript: Setting up your Directories'
  id: migrating-from-javascript#setting-up-your-directories
  summary: If you’re writing in plain JavaScript, it’s likely that you’re running your JavaScript directly, where your .js files are in a src, lib, or dist directory, and then run as desired
  belongs_to: Migrating from JavaScript
  description: |-
    ## Setting up your Directories

    If you’re writing in plain JavaScript, it’s likely that you’re running your JavaScript directly, where your `.js` files are in a `src`, `lib`, or `dist` directory, and then run as desired.

    If that’s the case, the files that you’ve written are going to be used as inputs to TypeScript, and you’ll run the outputs it produces. During our JS to TS migration, we’ll need to separate our input files to prevent TypeScript from overwriting them. If your output files need to reside in a specific directory, then that will be your output directory.

    You might also be running some intermediate steps on your JavaScript, such as bundling or using another transpiler like Babel. In this case, you might already have a folder structure like this set up.

    From this point on, we’re going to assume that your directory is set up something like this:

    ``` typescript
    projectRoot
    ├── src
    │   ├── file1.js
    │   └── file2.js
    ├── built
    └── tsconfig.json
    ```

    If you have a `tests` folder outside of your `src` directory, you might have one `tsconfig.json` in `src`, and one in `tests` as well.
- name: 'Migrating from JavaScript: Writing a Configuration File'
  id: migrating-from-javascript#writing-a-configuration-file
  summary: TypeScript uses a file called tsconfig.json for managing your project’s options, such as which files you want to include, and what sorts of checking you want to perform
  belongs_to: Migrating from JavaScript
  description: |-
    ## Writing a Configuration File

    TypeScript uses a file called `tsconfig.json` for managing your project’s options, such as which files you want to include, and what sorts of checking you want to perform. Let’s create a bare-bones one for our project:

    ``` json
    {
      "compilerOptions": {
        "outDir": "./built",
        "allowJs": true,
        "target": "es5"
      },
      "include": ["./src/**/*"]
    }
    ```

    Here we’re specifying a few things to TypeScript:

    1.  Read in any files it understands in the `src` directory (with [`include`](https://www.typescriptlang.org/tsconfig#include)).
    2.  Accept JavaScript files as inputs (with [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs)).
    3.  Emit all of the output files in `built` (with [`outDir`](https://www.typescriptlang.org/tsconfig#outDir)).
    4.  Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using [`target`](https://www.typescriptlang.org/tsconfig#target)).

    At this point, if you try running `tsc` at the root of your project, you should see output files in the `built` directory. The layout of files in `built` should look identical to the layout of `src`. You should now have TypeScript working with your project.
- name: Mixins
  id: mixins
  summary: Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes
  description: "# Mixins\n\nAlong with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes. You may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community.\n\n## How Does A Mixin Work?\n\nThe pattern relies on using generics with class inheritance to extend a base class. TypeScript’s best mixin support is done via the class expression pattern. You can read more about how this pattern works in JavaScript [here](https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/).\n\nTo get started, we’ll need a class which will have the mixins applied on top of:\n\n``` ts\nclass Sprite {\n  name = \"\";\n  x = 0;\n  y = 0;\n \n  constructor(name: string) {\n    this.name = name;\n  }\n}\n```\n\nThen you need a type and a factory function which returns a class expression extending the base class.\n\n``` ts\n// To get started, we need a type which we'll use to extend\n// other classes from. The main responsibility is to declare\n// that the type being passed in is a class.\n \ntype Constructor = new (...args: any[]) => {};\n \n// This mixin adds a scale property, with getters and setters\n// for changing it with an encapsulated private property:\n \nfunction Scale<TBase extends Constructor>(Base: TBase) {\n  return class Scaling extends Base {\n    // Mixins may not declare private/protected properties\n    // however, you can use ES2020 private fields\n    _scale = 1;\n \n    setScale(scale: number) {\n      this._scale = scale;\n    }\n \n    get scale(): number {\n      return this._scale;\n    }\n  };\n}\n```\n\nWith these all set up, then you can create a class which represents the base class with mixins applied:\n\n``` ts\n// Compose a new class from the Sprite class,\n// with the Mixin Scale applier:\nconst EightBitSprite = Scale(Sprite);\n \nconst flappySprite = new EightBitSprite(\"Bird\");\nflappySprite.setScale(0.8);\nconsole.log(flappySprite.scale);\n```\n\n## Constrained Mixins\n\nIn the above form, the mixin’s have no underlying knowledge of the class which can make it hard to create the design you want.\n\nTo model this, we modify the original constructor type to accept a generic argument.\n\n``` ts\n// This was our previous constructor:\ntype Constructor = new (...args: any[]) => {};\n// Now we use a generic version which can apply a constraint on\n// the class which this mixin is applied to\ntype GConstructor<T = {}> = new (...args: any[]) => T;\n```\n\nThis allows for creating classes which only work with constrained base classes:\n\n``` ts\ntype Positionable = GConstructor<{ setPos: (x: number, y: number) => void }>;\ntype Spritable = GConstructor<Sprite>;\ntype Loggable = GConstructor<{ print: () => void }>;\n```\n\nThen you can create mixins which only work when you have a particular base to build on:\n\n``` ts\nfunction Jumpable<TBase extends Positionable>(Base: TBase) {\n  return class Jumpable extends Base {\n    jump() {\n      // This mixin will only work if it is passed a base\n      // class which has setPos defined because of the\n      // Positionable constraint.\n      this.setPos(0, 20);\n    }\n  };\n}\n```\n\n## Alternative Pattern\n\nPrevious versions of this document recommended a way to write mixins where you created both the runtime and type hierarchies separately, then merged them at the end:\n\n``` ts\n// Each mixin is a traditional ES class\nclass Jumpable {\n  jump() {}\n}\n \nclass Duckable {\n  duck() {}\n}\n \n// Including the base\nclass Sprite {\n  x = 0;\n  y = 0;\n}\n \n// Then you create an interface which merges\n// the expected mixins with the same name as your base\ninterface Sprite extends Jumpable, Duckable {}\n// Apply the mixins into the base class via\n// the JS at runtime\napplyMixins(Sprite, [Jumpable, Duckable]);\n \nlet player = new Sprite();\nplayer.jump();\nconsole.log(player.x, player.y);\n \n// This can live anywhere in your codebase:\nfunction applyMixins(derivedCtor: any, constructors: any[]) {\n  constructors.forEach((baseCtor) => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {\n      Object.defineProperty(\n        derivedCtor.prototype,\n        name,\n        Object.getOwnPropertyDescriptor(baseCtor.prototype, name) ||\n          Object.create(null)\n      );\n    });\n  });\n}\n```\n\nThis pattern relies less on the compiler, and more on your codebase to ensure both runtime and type-system are correctly kept in sync.\n\n## Constraints\n\nThe mixin pattern is supported natively inside the TypeScript compiler by code flow analysis. There are a few cases where you can hit the edges of the native support.\n\n#### Decorators and Mixins [`#4881`](https://github.com/microsoft/TypeScript/issues/4881)\n\nYou cannot use decorators to provide mixins via code flow analysis:\n\n``` ts\n// A decorator function which replicates the mixin pattern:\nconst Pausable = (target: typeof Player) => {\n  return class Pausable extends target {\n    shouldFreeze = false;\n  };\n};\n \n@Pausable\nclass Player {\n  x = 0;\n  y = 0;\n}\n \n// The Player class does not have the decorator's type merged:\nconst player = new Player();\nplayer.shouldFreeze;\n \n// The runtime aspect could be manually replicated via\n// type composition or interface merging.\ntype FreezablePlayer = Player & { shouldFreeze: boolean };\n \nconst playerTwo = (new Player() as unknown) as FreezablePlayer;\nplayerTwo.shouldFreeze;\n```\n\n#### Static Property Mixins [`#17829`](https://github.com/microsoft/TypeScript/issues/17829)\n\nMore of a gotcha than a constraint. The class expression pattern creates singletons, so they can’t be mapped at the type system to support different variable types.\n\nYou can work around this by using functions to return your classes which differ based on a generic:\n\n``` ts\nfunction base<T>() {\n  class Base {\n    static prop: T;\n  }\n  return Base;\n}\n \nfunction derived<T>() {\n  class Derived extends base<T>() {\n    static anotherProp: T;\n  }\n  return Derived;\n}\n \nclass Spec extends derived<string>() {}\n \nSpec.prop; // string\nSpec.anotherProp; // string\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/mixins.html](https://www.typescriptlang.org/docs/handbook/mixins.html)"
- name: 'Mixins: Alternative Pattern'
  id: mixins#alternative-pattern
  summary: This pattern relies less on the compiler, and more on your codebase to ensure both runtime and type-system are correctly kept in sync
  belongs_to: Mixins
  description: |-
    ## Alternative Pattern

    Previous versions of this document recommended a way to write mixins where you created both the runtime and type hierarchies separately, then merged them at the end:

    ``` ts
    // Each mixin is a traditional ES class
    class Jumpable {
      jump() {}
    }
     
    class Duckable {
      duck() {}
    }
     
    // Including the base
    class Sprite {
      x = 0;
      y = 0;
    }
     
    // Then you create an interface which merges
    // the expected mixins with the same name as your base
    interface Sprite extends Jumpable, Duckable {}
    // Apply the mixins into the base class via
    // the JS at runtime
    applyMixins(Sprite, [Jumpable, Duckable]);
     
    let player = new Sprite();
    player.jump();
    console.log(player.x, player.y);
     
    // This can live anywhere in your codebase:
    function applyMixins(derivedCtor: any, constructors: any[]) {
      constructors.forEach((baseCtor) => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
          Object.defineProperty(
            derivedCtor.prototype,
            name,
            Object.getOwnPropertyDescriptor(baseCtor.prototype, name) ||
              Object.create(null)
          );
        });
      });
    }
    ```

    This pattern relies less on the compiler, and more on your codebase to ensure both runtime and type-system are correctly kept in sync.
- name: 'Mixins: Constrained Mixins'
  id: mixins#constrained-mixins
  summary: In the above form, the mixin’s have no underlying knowledge of the class which can make it hard to create the design you want
  belongs_to: Mixins
  description: |-
    ## Constrained Mixins

    In the above form, the mixin’s have no underlying knowledge of the class which can make it hard to create the design you want.

    To model this, we modify the original constructor type to accept a generic argument.

    ``` ts
    // This was our previous constructor:
    type Constructor = new (...args: any[]) => {};
    // Now we use a generic version which can apply a constraint on
    // the class which this mixin is applied to
    type GConstructor<T = {}> = new (...args: any[]) => T;
    ```

    This allows for creating classes which only work with constrained base classes:

    ``` ts
    type Positionable = GConstructor<{ setPos: (x: number, y: number) => void }>;
    type Spritable = GConstructor<Sprite>;
    type Loggable = GConstructor<{ print: () => void }>;
    ```

    Then you can create mixins which only work when you have a particular base to build on:

    ``` ts
    function Jumpable<TBase extends Positionable>(Base: TBase) {
      return class Jumpable extends Base {
        jump() {
          // This mixin will only work if it is passed a base
          // class which has setPos defined because of the
          // Positionable constraint.
          this.setPos(0, 20);
        }
      };
    }
    ```
- name: 'Mixins: Constraints'
  id: mixins#constraints
  summary: The mixin pattern is supported natively inside the TypeScript compiler by code flow analysis
  belongs_to: Mixins
  description: "## Constraints\n\nThe mixin pattern is supported natively inside the TypeScript compiler by code flow analysis. There are a few cases where you can hit the edges of the native support.\n\n#### Decorators and Mixins [`#4881`](https://github.com/microsoft/TypeScript/issues/4881)\n\nYou cannot use decorators to provide mixins via code flow analysis:\n\n``` ts\n// A decorator function which replicates the mixin pattern:\nconst Pausable = (target: typeof Player) => {\n  return class Pausable extends target {\n    shouldFreeze = false;\n  };\n};\n \n@Pausable\nclass Player {\n  x = 0;\n  y = 0;\n}\n \n// The Player class does not have the decorator's type merged:\nconst player = new Player();\nplayer.shouldFreeze;\n \n// The runtime aspect could be manually replicated via\n// type composition or interface merging.\ntype FreezablePlayer = Player & { shouldFreeze: boolean };\n \nconst playerTwo = (new Player() as unknown) as FreezablePlayer;\nplayerTwo.shouldFreeze;\n```\n\n#### Static Property Mixins [`#17829`](https://github.com/microsoft/TypeScript/issues/17829)\n\nMore of a gotcha than a constraint. The class expression pattern creates singletons, so they can’t be mapped at the type system to support different variable types.\n\nYou can work around this by using functions to return your classes which differ based on a generic:\n\n``` ts\nfunction base<T>() {\n  class Base {\n    static prop: T;\n  }\n  return Base;\n}\n \nfunction derived<T>() {\n  class Derived extends base<T>() {\n    static anotherProp: T;\n  }\n  return Derived;\n}\n \nclass Spec extends derived<string>() {}\n \nSpec.prop; // string\nSpec.anotherProp; // string\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/mixins.html](https://www.typescriptlang.org/docs/handbook/mixins.html)"
- name: 'Mixins: How Does A Mixin Work?'
  id: mixins#how-does-a-mixin-work
  summary: The pattern relies on using generics with class inheritance to extend a base class
  belongs_to: Mixins
  description: |-
    ## How Does A Mixin Work?

    The pattern relies on using generics with class inheritance to extend a base class. TypeScript’s best mixin support is done via the class expression pattern. You can read more about how this pattern works in JavaScript [here](https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/).

    To get started, we’ll need a class which will have the mixins applied on top of:

    ``` ts
    class Sprite {
      name = "";
      x = 0;
      y = 0;
     
      constructor(name: string) {
        this.name = name;
      }
    }
    ```

    Then you need a type and a factory function which returns a class expression extending the base class.

    ``` ts
    // To get started, we need a type which we'll use to extend
    // other classes from. The main responsibility is to declare
    // that the type being passed in is a class.
     
    type Constructor = new (...args: any[]) => {};
     
    // This mixin adds a scale property, with getters and setters
    // for changing it with an encapsulated private property:
     
    function Scale<TBase extends Constructor>(Base: TBase) {
      return class Scaling extends Base {
        // Mixins may not declare private/protected properties
        // however, you can use ES2020 private fields
        _scale = 1;
     
        setScale(scale: number) {
          this._scale = scale;
        }
     
        get scale(): number {
          return this._scale;
        }
      };
    }
    ```

    With these all set up, then you can create a class which represents the base class with mixins applied:

    ``` ts
    // Compose a new class from the Sprite class,
    // with the Mixin Scale applier:
    const EightBitSprite = Scale(Sprite);
     
    const flappySprite = new EightBitSprite("Bird");
    flappySprite.setScale(0.8);
    console.log(flappySprite.scale);
    ```
- name: module
  id: tsconfig#module-config
  summary: Sets the module system for the program
  belongs_to: TSConfig Reference
  description: |-
    ### Module - `module`

    Sets the module system for the program. See the [theory behind TypeScript’s `module` option](docs/handbook/modules/theory#the-module-output-format) and [its reference page](docs/handbook/modules/reference#the-module-compiler-option) for more information. You very likely want `"nodenext"` for modern Node.js projects and `preserve` or `esnext` for code that will be bundled.

    Changing `module` affects [`moduleResolution`](#moduleResolution) which [also has a reference page](docs/handbook/modules/reference#the-moduleresolution-compiler-option).

    Here’s some example output for this file:

    ``` ts
    // @filename: index.ts
    import { valueOfPi } from "./constants";
     
    export const twoPi = valueOfPi * 2;
    ```

    #### `CommonJS`

    ``` ts
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.twoPi = void 0;
    const constants_1 = require("./constants");
    exports.twoPi = constants_1.valueOfPi * 2;
     
    ```

    #### `UMD`

    ``` ts
    (function (factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
            var v = factory(require, exports);
            if (v !== undefined) module.exports = v;
        }
        else if (typeof define === "function" && define.amd) {
            define(["require", "exports", "./constants"], factory);
        }
    })(function (require, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.twoPi = void 0;
        const constants_1 = require("./constants");
        exports.twoPi = constants_1.valueOfPi * 2;
    });
     
    ```

    #### `AMD`

    ``` ts
    define(["require", "exports", "./constants"], function (require, exports, constants_1) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.twoPi = void 0;
        exports.twoPi = constants_1.valueOfPi * 2;
    });
     
    ```

    #### `System`

    ``` ts
    System.register(["./constants"], function (exports_1, context_1) {
        "use strict";
        var constants_1, twoPi;
        var __moduleName = context_1 && context_1.id;
        return {
            setters: [
                function (constants_1_1) {
                    constants_1 = constants_1_1;
                }
            ],
            execute: function () {
                exports_1("twoPi", twoPi = constants_1.valueOfPi * 2);
            }
        };
    });
     
    ```

    #### `ESNext`

    ``` ts
    import { valueOfPi } from "./constants";
    export const twoPi = valueOfPi * 2;
     
    ```

    #### `ES2015`/`ES6`/`ES2020`/`ES2022`

    ``` ts
    import { valueOfPi } from "./constants";
    export const twoPi = valueOfPi * 2;
     
    ```

    In addition to the base functionality of `ES2015`/`ES6`, `ES2020` adds support for [dynamic `import`s](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import), and [`import.meta`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta) while `ES2022` further adds support for [top level `await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#top_level_await).

    #### `node16`/`nodenext`

    Available from 4.7+, the `node16` and `nodenext` modes integrate with Node’s [native ECMAScript Module support](https://nodejs.org/api/esm.html). The emitted JavaScript uses either `CommonJS` or `ES2020` output depending on the file extension and the value of the `type` setting in the nearest `package.json`. Module resolution also works differently. You can learn more in the [handbook](docs/handbook/modules/reference#node16-nodenext) and [Modules Reference](docs/handbook/modules/reference#node16-nodenext).

    #### `preserve`

    In `--module preserve` ([added](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-bundler-and---module-preserve) in TypeScript 5.4), ECMAScript imports and exports written in input files are preserved in the output, and CommonJS-style `import x = require("...")` and `export = ...` statements are emitted as CommonJS `require` and `module.exports`. In other words, the format of each individual import or export statement is preserved, rather than being coerced into a single format for the whole compilation (or even a whole file).

    ``` ts
    import { valueOfPi } from "./constants";
    const constants = require("./constants");
    export const piSquared = valueOfPi * constants.valueOfPi;
     
    ```

    While it’s rare to need to mix imports and require calls in the same file, this `module` mode best reflects the capabilities of most modern bundlers, as well as the Bun runtime.

    > Why care about TypeScript’s `module` emit with a bundler or with Bun, where you’re likely also setting `noEmit`? TypeScript’s type checking and module resolution behavior are affected by the module format that it *would* emit. Setting `module` gives TypeScript information about how your bundler or runtime will process imports and exports, which ensures that the types you see on imported values accurately reflect what will happen at runtime or after bundling.

    #### `None`

    ``` ts
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.twoPi = void 0;
    const constants_1 = require("./constants");
    exports.twoPi = constants_1.valueOfPi * 2;
     
    ```

    - Default:

      `CommonJS` if [`target`](#target) is `ES3` or `ES5`; `ES6`/`ES2015` otherwise.

    - Allowed:
      - `none`

      - `commonjs`

      - `amd`

      - `umd`

      - `system`

      - `es6`/`es2015`

      - `es2020`

      - `es2022`

      - `esnext`

      - `node16`

      - `nodenext`

      - `preserve`

    - Related:
      - [`moduleResolution`](#moduleResolution)

      - [`esModuleInterop`](#esModuleInterop)

      - [`allowImportingTsExtensions`](#allowImportingTsExtensions)

      - [`allowArbitraryExtensions`](#allowArbitraryExtensions)

      - [`resolveJsonModule`](#resolveJsonModule)

    - Released:

      [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)
- name: module
  id: tsconfig/index#module-config
  summary: Sets the module system for the program
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Module - `module`

    Sets the module system for the program. See the [theory behind TypeScript’s `module` option](../docs/handbook/modules/theory#the-module-output-format) and [its reference page](../docs/handbook/modules/reference#the-module-compiler-option) for more information. You very likely want `"nodenext"` for modern Node.js projects and `preserve` or `esnext` for code that will be bundled.

    Changing `module` affects [`moduleResolution`](#moduleResolution) which [also has a reference page](../docs/handbook/modules/reference#the-moduleresolution-compiler-option).

    Here’s some example output for this file:

    ``` ts
    // @filename: index.ts
    import { valueOfPi } from "./constants";
     
    export const twoPi = valueOfPi * 2;
    ```

    #### `CommonJS`

    ``` ts
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.twoPi = void 0;
    const constants_1 = require("./constants");
    exports.twoPi = constants_1.valueOfPi * 2;
     
    ```

    #### `UMD`

    ``` ts
    (function (factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
            var v = factory(require, exports);
            if (v !== undefined) module.exports = v;
        }
        else if (typeof define === "function" && define.amd) {
            define(["require", "exports", "./constants"], factory);
        }
    })(function (require, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.twoPi = void 0;
        const constants_1 = require("./constants");
        exports.twoPi = constants_1.valueOfPi * 2;
    });
     
    ```

    #### `AMD`

    ``` ts
    define(["require", "exports", "./constants"], function (require, exports, constants_1) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.twoPi = void 0;
        exports.twoPi = constants_1.valueOfPi * 2;
    });
     
    ```

    #### `System`

    ``` ts
    System.register(["./constants"], function (exports_1, context_1) {
        "use strict";
        var constants_1, twoPi;
        var __moduleName = context_1 && context_1.id;
        return {
            setters: [
                function (constants_1_1) {
                    constants_1 = constants_1_1;
                }
            ],
            execute: function () {
                exports_1("twoPi", twoPi = constants_1.valueOfPi * 2);
            }
        };
    });
     
    ```

    #### `ESNext`

    ``` ts
    import { valueOfPi } from "./constants";
    export const twoPi = valueOfPi * 2;
     
    ```

    #### `ES2015`/`ES6`/`ES2020`/`ES2022`

    ``` ts
    import { valueOfPi } from "./constants";
    export const twoPi = valueOfPi * 2;
     
    ```

    In addition to the base functionality of `ES2015`/`ES6`, `ES2020` adds support for [dynamic `import`s](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import), and [`import.meta`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta) while `ES2022` further adds support for [top level `await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#top_level_await).

    #### `node16`/`nodenext`

    Available from 4.7+, the `node16` and `nodenext` modes integrate with Node’s [native ECMAScript Module support](https://nodejs.org/api/esm.html). The emitted JavaScript uses either `CommonJS` or `ES2020` output depending on the file extension and the value of the `type` setting in the nearest `package.json`. Module resolution also works differently. You can learn more in the [handbook](../docs/handbook/modules/reference#node16-nodenext) and [Modules Reference](../docs/handbook/modules/reference#node16-nodenext).

    #### `preserve`

    In `--module preserve` ([added](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-bundler-and---module-preserve) in TypeScript 5.4), ECMAScript imports and exports written in input files are preserved in the output, and CommonJS-style `import x = require("...")` and `export = ...` statements are emitted as CommonJS `require` and `module.exports`. In other words, the format of each individual import or export statement is preserved, rather than being coerced into a single format for the whole compilation (or even a whole file).

    ``` ts
    import { valueOfPi } from "./constants";
    const constants = require("./constants");
    export const piSquared = valueOfPi * constants.valueOfPi;
     
    ```

    While it’s rare to need to mix imports and require calls in the same file, this `module` mode best reflects the capabilities of most modern bundlers, as well as the Bun runtime.

    > Why care about TypeScript’s `module` emit with a bundler or with Bun, where you’re likely also setting `noEmit`? TypeScript’s type checking and module resolution behavior are affected by the module format that it *would* emit. Setting `module` gives TypeScript information about how your bundler or runtime will process imports and exports, which ensures that the types you see on imported values accurately reflect what will happen at runtime or after bundling.

    #### `None`

    ``` ts
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.twoPi = void 0;
    const constants_1 = require("./constants");
    exports.twoPi = constants_1.valueOfPi * 2;
     
    ```

    - Default:

      `CommonJS` if [`target`](#target) is `ES3` or `ES5`; `ES6`/`ES2015` otherwise.

    - Allowed:
      - `none`

      - `commonjs`

      - `amd`

      - `umd`

      - `system`

      - `es6`/`es2015`

      - `es2020`

      - `es2022`

      - `esnext`

      - `node16`

      - `nodenext`

      - `preserve`

    - Related:
      - [`moduleResolution`](#moduleResolution)

      - [`esModuleInterop`](#esModuleInterop)

      - [`allowImportingTsExtensions`](#allowImportingTsExtensions)

      - [`allowArbitraryExtensions`](#allowArbitraryExtensions)

      - [`resolveJsonModule`](#resolveJsonModule)

    - Released:

      [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)
- name: 'Module: Class'
  id: declaration-files/templates/module-class-d-ts
  summary: © 2012-2024 Microsoft Licensed under the Apache License, Version 2.0
  description: "# Module: Class\n\nFor example, when you want to work with JavaScript code which looks like:\n\n``` ts\nconst Greeter = require(\"super-greeter\");\n\nconst greeter = new Greeter();\ngreeter.greet();\n```\n\nTo handle both importing via UMD and modules:\n\n``` ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file for class modules.\n *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n// Note that ES6 modules cannot directly export class objects.\n// This file should be imported using the CommonJS-style:\n//   import x = require('[~THE MODULE~]');\n//\n// Alternatively, if --allowSyntheticDefaultImports or\n// --esModuleInterop is turned on, this file can also be\n// imported as a default import:\n//   import x from '[~THE MODULE~]';\n//\n// Refer to the TypeScript documentation at\n// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require\n// to understand common workarounds for this limitation of ES6 modules.\n\n/*~ If this module is a UMD module that exposes a global variable 'myClassLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace \"super-greeter\";\n\n/*~ This declaration specifies that the class constructor function\n *~ is the exported object from the file\n */\nexport = Greeter;\n\n/*~ Write your module's methods and properties in this class */\ndeclare class Greeter {\n  constructor(customGreeting?: string);\n\n  greet: void;\n\n  myMethod(opts: MyClass.MyClassMethodOptions): number;\n}\n\n/*~ If you want to expose types from your module as well, you can\n *~ place them in this block.\n *~\n *~ Note that if you decide to include this namespace, the module can be\n *~ incorrectly imported as a namespace object, unless\n *~ --esModuleInterop is turned on:\n *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!\n */\ndeclare namespace MyClass {\n  export interface MyClassMethodOptions {\n    width?: number;\n    height?: number;\n  }\n}\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html)"
- name: 'Module: Function'
  id: declaration-files/templates/module-function-d-ts
  summary: © 2012-2024 Microsoft Licensed under the Apache License, Version 2.0
  description: "# Module: Function\n\nFor example, when you want to work with JavaScript code which looks like:\n\n``` ts\nimport greeter from \"super-greeter\";\n\ngreeter(2);\ngreeter(\"Hello world\");\n```\n\nTo handle both importing via UMD and modules:\n\n``` ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file for function modules.\n *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n// Note that ES6 modules cannot directly export class objects.\n// This file should be imported using the CommonJS-style:\n//   import x = require('[~THE MODULE~]');\n//\n// Alternatively, if --allowSyntheticDefaultImports or\n// --esModuleInterop is turned on, this file can also be\n// imported as a default import:\n//   import x from '[~THE MODULE~]';\n//\n// Refer to the TypeScript documentation at\n// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require\n// to understand common workarounds for this limitation of ES6 modules.\n\n/*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myFuncLib;\n\n/*~ This declaration specifies that the function\n *~ is the exported object from the file\n */\nexport = Greeter;\n\n/*~ This example shows how to have multiple overloads for your function */\ndeclare function Greeter(name: string): Greeter.NamedReturnType;\ndeclare function Greeter(length: number): Greeter.LengthReturnType;\n\n/*~ If you want to expose types from your module as well, you can\n *~ place them in this block. Often you will want to describe the\n *~ shape of the return type of the function; that type should\n *~ be declared in here, as this example shows.\n *~\n *~ Note that if you decide to include this namespace, the module can be\n *~ incorrectly imported as a namespace object, unless\n *~ --esModuleInterop is turned on:\n *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!\n */\ndeclare namespace Greeter {\n  export interface LengthReturnType {\n    width: number;\n    height: number;\n  }\n  export interface NamedReturnType {\n    firstName: string;\n    lastName: string;\n  }\n\n  /*~ If the module also has properties, declare them here. For example,\n   *~ this declaration says that this code is legal:\n   *~   import f = require('super-greeter');\n   *~   console.log(f.defaultName);\n   */\n  export const defaultName: string;\n  export let defaultLength: number;\n}\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html)"
- name: 'Module: Plugin'
  id: declaration-files/templates/module-plugin-d-ts
  summary: For example, when you want to work with JavaScript code which extends another library
  description: "# Module: Plugin\n\nFor example, when you want to work with JavaScript code which extends another library.\n\n``` ts\nimport { greeter } from \"super-greeter\";\n\n// Normal Greeter API\ngreeter(2);\ngreeter(\"Hello world\");\n\n// Now we extend the object with a new function at runtime\nimport \"hyper-super-greeter\";\ngreeter.hyperGreet();\n```\n\nThe definition for “super-greeter”:\n\n``` ts\n/*~ This example shows how to have multiple overloads for your function */\nexport interface GreeterFunction {\n  (name: string): void\n  (time: number): void\n}\n\n/*~ This example shows how to export a function specified by an interface */\nexport const greeter: GreeterFunction;\n```\n\nWe can extend the existing module like the following:\n\n``` ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module plugin template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ On this line, import the module which this module adds to */\nimport { greeter } from \"super-greeter\";\n\n/*~ Here, declare the same module as the one you imported above\n *~ then we expand the existing declaration of the greeter function\n */\nexport module \"super-greeter\" {\n  export interface GreeterFunction {\n    /** Greets even better! */\n    hyperGreet(): void;\n  }\n}\n```\n\nThis uses [declaration merging](../../declaration-merging)\n\n## The Impact of ES6 on Module Plugins\n\nSome plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html)"
- name: 'Module: Plugin: The Impact of ES6 on Module Plugins'
  id: declaration-files/templates/module-plugin-d-ts#the-impact-of-es6-on-module-plugins
  summary: Some plugins add or modify top-level exports on existing modules
  belongs_to: 'Module: Plugin'
  description: "## The Impact of ES6 on Module Plugins\n\nSome plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html)"
- name: moduleDetection
  id: tsconfig#moduleDetection-config
  summary: This setting controls how TypeScript determines whether a file is a script or a module
  belongs_to: TSConfig Reference
  description: |-
    ### Module Detection - `moduleDetection`

    This setting controls how TypeScript determines whether a file is a [script or a module](docs/handbook/modules/theory#scripts-and-modules-in-javascript).

    There are three choices:

    - `"auto"` (default) - TypeScript will not only look for import and export statements, but it will also check whether the `"type"` field in a `package.json` is set to `"module"` when running with [`module`](#module): `nodenext` or `node16`, and check whether the current file is a JSX file when running under [`jsx`](#jsx): `react-jsx`.

    - `"legacy"` - The same behavior as 4.6 and prior, usings import and export statements to determine whether a file is a module.

    - `"force"` - Ensures that every non-declaration file is treated as a module.

    - Default:

      "auto": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.

    - Allowed:
      - `legacy`

      - `auto`

      - `force`

    - Released:

      [4.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html)
- name: moduleDetection
  id: tsconfig/index#moduleDetection-config
  summary: This setting controls how TypeScript determines whether a file is a script or a module
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Module Detection - `moduleDetection`

    This setting controls how TypeScript determines whether a file is a [script or a module](../docs/handbook/modules/theory#scripts-and-modules-in-javascript).

    There are three choices:

    - `"auto"` (default) - TypeScript will not only look for import and export statements, but it will also check whether the `"type"` field in a `package.json` is set to `"module"` when running with [`module`](#module): `nodenext` or `node16`, and check whether the current file is a JSX file when running under [`jsx`](#jsx): `react-jsx`.

    - `"legacy"` - The same behavior as 4.6 and prior, usings import and export statements to determine whether a file is a module.

    - `"force"` - Ensures that every non-declaration file is treated as a module.

    - Default:

      "auto": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.

    - Allowed:
      - `legacy`

      - `auto`

      - `force`

    - Released:

      [4.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html)
- name: moduleResolution
  id: tsconfig/index#moduleResolution-config
  summary: There are reference pages explaining the theory behind TypeScript’s module resolution and the details of each option
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Module Resolution - `moduleResolution`

    Specify the module resolution strategy:

    - `'node16'` or `'nodenext'` for modern versions of Node.js. Node.js v12 and later supports both ECMAScript imports and CommonJS `require`, which resolve using different algorithms. These `moduleResolution` values, when combined with the corresponding [`module`](#module) values, picks the right algorithm for each resolution based on whether Node.js will see an `import` or `require` in the output JavaScript code.
    - `'node10'` (previously called `'node'`) for Node.js versions older than v10, which only support CommonJS `require`. You probably won’t need to use `node10` in modern code.
    - `'bundler'` for use with bundlers. Like `node16` and `nodenext`, this mode supports package.json `"imports"` and `"exports"`, but unlike the Node.js resolution modes, `bundler` never requires file extensions on relative paths in imports.
    - `'classic'` was used in TypeScript before the release of 1.6. `classic` should not be used.

    There are reference pages explaining the [theory behind TypeScript’s module resolution](../docs/handbook/modules/theory#module-resolution) and the [details of each option](../docs/handbook/modules/reference#the-moduleresolution-compiler-option).

    - Default:

      `Classic` if [`module`](#module) is `AMD`, `UMD`, `System`, or `ES6`/`ES2015`; Matches if [`module`](#module) is `node16` or `nodenext`; `Node` otherwise.

    - Allowed:
      - `classic`

      - `node10`/`node`

      - `node16`

      - `nodenext`

      - `bundler`

    - Related:
      - [`module`](#module)

      - [`paths`](#paths)

      - [`baseUrl`](#baseUrl)

      - [`rootDirs`](#rootDirs)

      - [`moduleSuffixes`](#moduleSuffixes)

      - [`customConditions`](#customConditions)

      - [`resolvePackageJsonExports`](#resolvePackageJsonExports)

      - [`resolvePackageJsonImports`](#resolvePackageJsonImports)
- name: moduleResolution
  id: tsconfig#moduleResolution-config
  summary: There are reference pages explaining the theory behind TypeScript’s module resolution and the details of each option
  belongs_to: TSConfig Reference
  description: |-
    ### Module Resolution - `moduleResolution`

    Specify the module resolution strategy:

    - `'node16'` or `'nodenext'` for modern versions of Node.js. Node.js v12 and later supports both ECMAScript imports and CommonJS `require`, which resolve using different algorithms. These `moduleResolution` values, when combined with the corresponding [`module`](#module) values, picks the right algorithm for each resolution based on whether Node.js will see an `import` or `require` in the output JavaScript code.
    - `'node10'` (previously called `'node'`) for Node.js versions older than v10, which only support CommonJS `require`. You probably won’t need to use `node10` in modern code.
    - `'bundler'` for use with bundlers. Like `node16` and `nodenext`, this mode supports package.json `"imports"` and `"exports"`, but unlike the Node.js resolution modes, `bundler` never requires file extensions on relative paths in imports.
    - `'classic'` was used in TypeScript before the release of 1.6. `classic` should not be used.

    There are reference pages explaining the [theory behind TypeScript’s module resolution](docs/handbook/modules/theory#module-resolution) and the [details of each option](docs/handbook/modules/reference#the-moduleresolution-compiler-option).

    - Default:

      `Classic` if [`module`](#module) is `AMD`, `UMD`, `System`, or `ES6`/`ES2015`; Matches if [`module`](#module) is `node16` or `nodenext`; `Node` otherwise.

    - Allowed:
      - `classic`

      - `node10`/`node`

      - `node16`

      - `nodenext`

      - `bundler`

    - Related:
      - [`module`](#module)

      - [`paths`](#paths)

      - [`baseUrl`](#baseUrl)

      - [`rootDirs`](#rootDirs)

      - [`moduleSuffixes`](#moduleSuffixes)

      - [`customConditions`](#customConditions)

      - [`resolvePackageJsonExports`](#resolvePackageJsonExports)

      - [`resolvePackageJsonImports`](#resolvePackageJsonImports)
- name: Modules
  id: 2/modules
  summary: JavaScript has a long history of different ways to handle modularizing code
  description: "# Modules\n\nJavaScript has a long history of different ways to handle modularizing code. Having been around since 2012, TypeScript has implemented support for a lot of these formats, but over time the community and the JavaScript specification has converged on a format called ES Modules (or ES6 modules). You might know it as the `import`/`export` syntax.\n\nES Modules was added to the JavaScript spec in 2015, and by 2020 had broad support in most web browsers and JavaScript runtimes.\n\nFor focus, the handbook will cover both ES Modules and its popular pre-cursor CommonJS `module.exports =` syntax, and you can find information about the other module patterns in the reference section under [Modules](../modules/introduction).\n\n## How JavaScript Modules are Defined\n\nIn TypeScript, just as in ECMAScript 2015, any file containing a top-level `import` or `export` is considered a module.\n\nConversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).\n\nModules are executed within their own scope, not in the global scope. This means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the export forms. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the import forms.\n\n## Non-modules\n\nBefore we start, it’s important to understand what TypeScript considers a module. The JavaScript specification declares that any JavaScript files without an `import` declaration, `export`, or top-level `await` should be considered a script and not a module.\n\nInside a script file variables and types are declared to be in the shared global scope, and it’s assumed that you’ll either use the [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) compiler option to join multiple input files into one output file, or use multiple `<script>` tags in your HTML to load these files (in the correct order!).\n\nIf you have a file that doesn’t currently have any `import`s or `export`s, but you want to be treated as a module, add the line:\n\n``` ts\nexport {};\n```\n\nwhich will change the file to be a module exporting nothing. This syntax works regardless of your module target.\n\n## Modules in TypeScript\n\n> Additional Reading:  \n> [Impatient JS (Modules)](https://exploringjs.com/impatient-js/ch_modules.html#overview-syntax-of-ecmascript-modules)  \n> [MDN: JavaScript Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)  \n\nThere are three main things to consider when writing module-based code in TypeScript:\n\n- **Syntax**: What syntax do I want to use to import and export things?\n- **Module Resolution**: What is the relationship between module names (or paths) and files on disk?\n- **Module Output Target**: What should my emitted JavaScript module look like?\n\n### ES Module Syntax\n\nA file can declare a main export via `export default`:\n\n``` ts\n// @filename: hello.ts\nexport default function helloWorld() {\n  console.log(\"Hello, world!\");\n}\n```\n\nThis is then imported via:\n\n``` ts\nimport helloWorld from \"./hello.js\";\nhelloWorld();\n```\n\nIn addition to the default export, you can have more than one export of variables and functions via the `export` by omitting `default`:\n\n``` ts\n// @filename: maths.ts\nexport var pi = 3.14;\nexport let squareTwo = 1.41;\nexport const phi = 1.61;\n \nexport class RandomNumberGenerator {}\n \nexport function absolute(num: number) {\n  if (num < 0) return num * -1;\n  return num;\n}\n```\n\nThese can be used in another file via the `import` syntax:\n\n``` ts\nimport { pi, phi, absolute } from \"./maths.js\";\n \nconsole.log(pi);\nconst absPhi = absolute(phi);\n```\n\n### Additional Import Syntax\n\nAn import can be renamed using a format like `import {old as new}`:\n\n``` ts\nimport { pi as π } from \"./maths.js\";\n \nconsole.log(π);\n```\n\nYou can mix and match the above syntax into a single `import`:\n\n``` ts\n// @filename: maths.ts\nexport const pi = 3.14;\nexport default class RandomNumberGenerator {}\n \n// @filename: app.ts\nimport RandomNumberGenerator, { pi as π } from \"./maths.js\";\n \nRandomNumberGenerator;\n \nconsole.log(π);\n```\n\nYou can take all of the exported objects and put them into a single namespace using `* as name`:\n\n``` ts\n// @filename: app.ts\nimport * as math from \"./maths.js\";\n \nconsole.log(math.pi);\nconst positivePhi = math.absolute(math.phi);\n```\n\nYou can import a file and *not* include any variables into your current module via `import \"./file\"`:\n\n``` ts\n// @filename: app.ts\nimport \"./maths.js\";\n \nconsole.log(\"3.14\");\n```\n\nIn this case, the `import` does nothing. However, all of the code in `maths.ts` was evaluated, which could trigger side-effects which affect other objects.\n\n#### TypeScript Specific ES Module Syntax\n\nTypes can be exported and imported using the same syntax as JavaScript values:\n\n``` ts\n// @filename: animal.ts\nexport type Cat = { breed: string; yearOfBirth: number };\n \nexport interface Dog {\n  breeds: string[];\n  yearOfBirth: number;\n}\n \n// @filename: app.ts\nimport { Cat, Dog } from \"./animal.js\";\ntype Animals = Cat | Dog;\n```\n\nTypeScript has extended the `import` syntax with two concepts for declaring an import of a type:\n\n###### `import type`\n\nWhich is an import statement which can *only* import types:\n\n``` ts\n// @filename: animal.ts\nexport type Cat = { breed: string; yearOfBirth: number };\nexport type Dog = { breeds: string[]; yearOfBirth: number };\nexport const createCatName = () => \"fluffy\";\n \n// @filename: valid.ts\nimport type { Cat, Dog } from \"./animal.js\";\nexport type Animals = Cat | Dog;\n \n// @filename: app.ts\nimport type { createCatName } from \"./animal.js\";\nconst name = createCatName();\n```\n\n###### Inline `type` imports\n\nTypeScript 4.5 also allows for individual imports to be prefixed with `type` to indicate that the imported reference is a type:\n\n``` ts\n// @filename: app.ts\nimport { createCatName, type Cat, type Dog } from \"./animal.js\";\n \nexport type Animals = Cat | Dog;\nconst name = createCatName();\n```\n\nTogether these allow a non-TypeScript transpiler like Babel, swc or esbuild to know what imports can be safely removed.\n\n#### ES Module Syntax with CommonJS Behavior\n\nTypeScript has ES Module syntax which *directly* correlates to a CommonJS and AMD `require`. Imports using ES Module are *for most cases* the same as the `require` from those environments, but this syntax ensures you have a 1 to 1 match in your TypeScript file with the CommonJS output:\n\n``` ts\nimport fs = require(\"fs\");\nconst code = fs.readFileSync(\"hello.ts\", \"utf8\");\n```\n\nYou can learn more about this syntax in the [modules reference page](../modules/introduction#export--and-import--require).\n\n## CommonJS Syntax\n\nCommonJS is the format which most modules on npm are delivered in. Even if you are writing using the ES Modules syntax above, having a brief understanding of how CommonJS syntax works will help you debug easier.\n\n#### Exporting\n\nIdentifiers are exported via setting the `exports` property on a global called `module`.\n\n``` ts\nfunction absolute(num: number) {\n  if (num < 0) return num * -1;\n  return num;\n}\n \nmodule.exports = {\n  pi: 3.14,\n  squareTwo: 1.41,\n  phi: 1.61,\n  absolute,\n};\n```\n\nThen these files can be imported via a `require` statement:\n\n``` ts\nconst maths = require(\"./maths\");\nmaths.pi;\n```\n\nOr you can simplify a bit using the destructuring feature in JavaScript:\n\n``` ts\nconst { squareTwo } = require(\"./maths\");\nsquareTwo;\n```\n\n### CommonJS and ES Modules interop\n\nThere is a mis-match in features between CommonJS and ES Modules regarding the distinction between a default import and a module namespace object import. TypeScript has a compiler flag to reduce the friction between the two different sets of constraints with [`esModuleInterop`](https://www.typescriptlang.org/tsconfig#esModuleInterop).\n\n## TypeScript’s Module Resolution Options\n\nModule resolution is the process of taking a string from the `import` or `require` statement, and determining what file that string refers to.\n\nTypeScript includes two resolution strategies: Classic and Node. Classic, the default when the compiler option [`module`](https://www.typescriptlang.org/tsconfig#module) is not `commonjs`, is included for backwards compatibility. The Node strategy replicates how Node.js works in CommonJS mode, with additional checks for `.ts` and `.d.ts`.\n\nThere are many TSConfig flags which influence the module strategy within TypeScript: [`moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution), [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl), [`paths`](https://www.typescriptlang.org/tsconfig#paths), [`rootDirs`](https://www.typescriptlang.org/tsconfig#rootDirs).\n\nFor the full details on how these strategies work, you can consult the [Module Resolution](../modules/reference#the-moduleresolution-compiler-option) reference page.\n\n## TypeScript’s Module Output Options\n\nThere are two options which affect the emitted JavaScript output:\n\n- [`target`](https://www.typescriptlang.org/tsconfig#target) which determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intact\n- [`module`](https://www.typescriptlang.org/tsconfig#module) which determines what code is used for modules to interact with each other\n\nWhich [`target`](https://www.typescriptlang.org/tsconfig#target) you use is determined by the features available in the JavaScript runtime you expect to run the TypeScript code in. That could be: the oldest web browser you support, the lowest version of Node.js you expect to run on or could come from unique constraints from your runtime - like Electron for example.\n\nAll communication between modules happens via a module loader, the compiler option [`module`](https://www.typescriptlang.org/tsconfig#module) determines which one is used. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it.\n\nFor example, here is a TypeScript file using ES Modules syntax, showcasing a few different options for [`module`](https://www.typescriptlang.org/tsconfig#module):\n\n``` ts\nimport { valueOfPi } from \"./constants.js\";\n \nexport const twoPi = valueOfPi * 2;\n```\n\n#### `ES2020`\n\n``` ts\nimport { valueOfPi } from \"./constants.js\";\nexport const twoPi = valueOfPi * 2;\n \n```\n\n#### `CommonJS`\n\n``` ts\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.twoPi = void 0;\nconst constants_js_1 = require(\"./constants.js\");\nexports.twoPi = constants_js_1.valueOfPi * 2;\n \n```\n\n#### `UMD`\n\n``` ts\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./constants.js\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.twoPi = void 0;\n    const constants_js_1 = require(\"./constants.js\");\n    exports.twoPi = constants_js_1.valueOfPi * 2;\n});\n \n```\n\n> Note that ES2020 is effectively the same as the original `index.ts`.\n\nYou can see all of the available options and what their emitted JavaScript code looks like in the [TSConfig Reference for `module`](https://www.typescriptlang.org/tsconfig#module).\n\n## TypeScript namespaces\n\nTypeScript has its own module format called `namespaces` which pre-dates the ES Modules standard. This syntax has a lot of useful features for creating complex definition files, and still sees active use [in DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped). While not deprecated, the majority of the features in namespaces exist in ES Modules and we recommend you use that to align with JavaScript’s direction. You can learn more about namespaces in [the namespaces reference page](../namespaces).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/modules.html](https://www.typescriptlang.org/docs/handbook/2/modules.html)"
- name: Modules - Choosing Compiler Options
  id: modules/guides/choosing-compiler-options
  summary: A single tsconfig.json can only represent a single environment, both in terms of what globals are available and in terms of how modules behave
  description: "# Modules - Choosing Compiler Options\n\n## I’m writing an app\n\nA single tsconfig.json can only represent a single environment, both in terms of what globals are available and in terms of how modules behave. If your app contains server code, DOM code, web worker code, test code, and code to be shared by all of those, each of those should have its own tsconfig.json, connected with [project references](../../project-references#handbook-content). Then, use this guide once for each tsconfig.json. For library-like projects within an app, especially ones that need to run in multiple runtime environments, use the “[I’m writing a library](#im-writing-a-library)” section.\n\n### I’m using a bundler\n\nIn addition to adopting the following settings, it’s also recommended *not* to set `{ \"type\": \"module\" }` or use `.mts` files in bundler projects for now. [Some bundlers](https://andrewbranch.github.io/interop-test/#synthesizing-default-exports-for-cjs-modules) adopt different ESM/CJS interop behavior under these circumstances, which TypeScript cannot currently analyze with `\"moduleResolution\": \"bundler\"`. See [issue \\#54102](https://github.com/microsoft/TypeScript/issues/54102) for more information.\n\n``` json\n{\n  \"compilerOptions\": {\n    // This is not a complete template; it only\n    // shows relevant module-related settings.\n    // Be sure to set other important options\n    // like `target`, `lib`, and `strict`.\n\n    // Required\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"esModuleInterop\": true,\n\n    // Consult your bundler’s documentation\n    \"customConditions\": [\"module\"],\n\n    // Recommended\n    \"noEmit\": true, // or `emitDeclarationOnly`\n    \"allowImportingTsExtensions\": true,\n    \"allowArbitraryExtensions\": true,\n    \"verbatimModuleSyntax\": true, // or `isolatedModules`\n  }\n}\n```\n\n### I’m compiling and running the outputs in Node.js\n\nRemember to set `\"type\": \"module\"` or use `.mts` files if you intend to emit ES modules.\n\n``` json\n{\n  \"compilerOptions\": {\n    // This is not a complete template; it only\n    // shows relevant module-related settings.\n    // Be sure to set other important options\n    // like `target`, `lib`, and `strict`.\n\n    // Required\n    \"module\": \"nodenext\",\n\n    // Implied by `\"module\": \"nodenext\"`:\n    // \"moduleResolution\": \"nodenext\",\n    // \"esModuleInterop\": true,\n    // \"target\": \"esnext\",\n\n    // Recommended\n    \"verbatimModuleSyntax\": true,\n  }\n}\n```\n\n### I’m using ts-node\n\nts-node attempts to be compatible with the same code and the same tsconfig.json settings that can be used to [compile and run the JS outputs in Node.js](#im-compiling-and-running-the-outputs-in-node). Refer to [ts-node documentation](https://typestrong.org/ts-node/) for more details.\n\n### I’m using tsx\n\nWhereas ts-node makes minimal modifications to Node.js’s module system by default, [tsx](https://github.com/esbuild-kit/tsx) behaves more like a bundler, allowing extensionless/index module specifiers and arbitrary mixing of ESM and CJS. Use the same settings for tsx as you [would for a bundler](#im-using-a-bundler).\n\n### I’m writing ES modules for the browser, with no bundler or module compiler\n\nTypeScript does not currently have options dedicated to this scenario, but you can approximate them by using a combination of the `nodenext` ESM module resolution algorithm and `paths` as a substitute for URL and import map support.\n\n``` json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    // This is not a complete template; it only\n    // shows relevant module-related settings.\n    // Be sure to set other important options\n    // like `target`, `lib`, and `strict`.\n\n    // Combined with `\"type\": \"module\"` in a local package.json,\n    // this enforces including file extensions on relative path imports.\n    \"module\": \"nodenext\",\n    \"paths\": {\n      // Point TS to local types for remote URLs:\n      \"https://esm.sh/lodash@4.17.21\": [\"./node_modules/@types/lodash/index.d.ts\"],\n      // Optional: point bare specifier imports to an empty file\n      // to prohibit importing from node_modules specifiers not listed here:\n      \"*\": [\"./empty-file.ts\"]\n    }\n  }\n}\n```\n\nThis setup allows explicitly listed HTTPS imports to use locally-installed type declaration files, while erroring on imports that would normally resolve in node_modules:\n\n``` ts\nimport {} from \"lodash\";\n//             ^^^^^^^^\n// File '/project/empty-file.ts' is not a module. ts(2306)\n```\n\nAlternatively, you can use [import maps](https://github.com/WICG/import-maps) to explicitly map a list of bare specifiers to URLs in the browser, while relying on `nodenext`’s default node_modules lookups, or on `paths`, to direct TypeScript to type declaration files for those bare specifier imports:\n\n``` html\n<script type=\"importmap\">\n{\n  \"imports\": {\n    \"lodash\": \"https://esm.sh/lodash@4.17.21\"\n  }\n}\n</script>\n```\n\n``` ts\nimport {} from \"lodash\";\n// Browser: https://esm.sh/lodash@4.17.21\n// TypeScript: ./node_modules/@types/lodash/index.d.ts\n```\n\n## I’m writing a library\n\nChoosing compilation settings as a library author is a fundamentally different process from choosing settings as an app author. When writing an app, settings are chosen that reflect the runtime environment or bundler—typically a single entity with known behavior. When writing a library, you would ideally check your code under *all possible* library consumer compilation settings. Since this is impractical, you can instead use the strictest possible settings, since satisfying those tends to satisfy all others.\n\n``` json\n{\n  \"compilerOptions\": {\n    \"module\": \"node16\",\n    \"target\": \"es2020\", // set to the *lowest* target you support\n    \"strict\": true,\n    \"verbatimModuleSyntax\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"declarationMap\": true\n  }\n}\n```\n\nLet’s examine why we picked each of these settings:\n\n- **`module: \"node16\"`**. When a codebase is compatible with Node.js’s module system, it almost always works in bundlers as well. If you’re using a third-party emitter to emit ESM outputs, ensure that you set `\"type\": \"module\"` in your package.json so TypeScript checks your code as ESM, which uses a stricter module resolution algorithm in Node.js than CommonJS does. As an example, let’s look at what would happen if a library were to compile with `\"moduleResolution\": \"bundler\"`:\n\n  ``` ts\n  export * from \"./utils\";\n  ```\n\n  Assuming `./utils.ts` (or `./utils/index.ts`) exists, a bundler would be fine with this code, so `\"moduleResolution\": \"bundler\"` doesn’t complain. Compiled with `\"module\": \"esnext\"`, the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:\n\n  ``` typescript\n  Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js\n  Did you mean to import ./utils.js?\n  ```\n\n  On the other hand, if we had written:\n\n  ``` ts\n  export * from \"./utils.js\";\n  ```\n\n  This would produce output that works both in Node.js *and* in bundlers.\n\n  In short, `\"moduleResolution\": \"bundler\"` is infectious, allowing code that only works in bundlers to be produced. Likewise, `\"moduleResolution\": \"nodenext\"` is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers.\n\n- **`target: \"es2020\"`**. Setting this value to the *lowest* ECMAScript version that you intend to support ensures the emitted code will not use language features introduced in a later version. Since `target` also implies a corresponding value for `lib`, this also ensures you don’t access globals that may not be available in older environments.\n\n- **`strict: true`**. Without this, you may write type-level code that ends up in your output `.d.ts` files and errors when a consumer compiles with `strict` enabled. For example, this `extends` clause:\n\n  ``` ts\n  export interface Super {\n    foo: string;\n  }\n  export interface Sub extends Super {\n    foo: string | undefined;\n  }\n  ```\n\n  is only an error under `strictNullChecks`. On the other hand, it’s very difficult to write code that errors only when `strict` is *disabled*, so it’s highly recommended for libraries to compile with `strict`.\n\n- **`verbatimModuleSyntax: true`**. This setting protects against a few module-related pitfalls that can cause problems for library consumers. First, it prevents writing any import statements that could be interpreted ambiguously based on the user’s value of `esModuleInterop` or `allowSyntheticDefaultImports`. Previously, it was often suggested that libraries compile without `esModuleInterop`, since its use in libraries could force users to adopt it too. However, it’s also possible to write imports that only work *without* `esModuleInterop`, so neither value for the setting guarantees portability for libraries. `verbatimModuleSyntax` does provide such a guarantee.^([1](#fn-1)) Second, it prevents the use of `export default` in modules that will be emitted as CommonJS, which can require bundler users and Node.js ESM users to consume the module differently. See the appendix on [ESM/CJS Interop](../appendices/esm-cjs-interop#library-code-needs-special-considerations) for more details.\n\n- **`declaration: true`** emits type declaration files alongside the output JavaScript. This is needed for consumers of the library to have any type information.\n\n- **`sourceMap: true`** and **`declarationMap: true`** emit source maps for the output JavaScript and type declaration files, respectively. These are only useful if the library also ships its source (`.ts`) files. By shipping source maps and source files, consumers of the library will be able to debug the library code somewhat more easily. By shipping declaration maps and source files, consumers will be able to see the original TypeScript sources when they run Go To Definition on imports from the libraries. Both of these represent a tradeoff between developer experience and library size, so it’s up to you whether to include them.\n\n### Considerations for bundling libraries\n\nIf you’re using a bundler to emit your library, then all your (non-externalized) imports will be processed by the bundler with known behavior, not by your users’ unknowable environments. In this case, you can use `\"module\": \"esnext\"` and `\"moduleResolution\": \"bundler\"`, but only with two caveats:\n\n1.  TypeScript cannot model module resolution when some files are bundled and some are externalized. When bundling libraries with dependencies, it’s common to bundle the first-party library source code into a single file, but leave imports of external dependencies as real imports in the bundled output. This essentially means module resolution is split between the bundler and the end user’s environment. To model this in TypeScript, you would want to process bundled imports with `\"moduleResolution\": \"bundler\"` and externalized imports with `\"moduleResolution\": \"nodenext\"` (or with multiple options to check that everything will work in a range of end-user environments). But TypeScript cannot be configured to use two different module resolution settings in the same compilation. As a consequence, using `\"moduleResolution\": \"bundler\"` may allow imports of externalized dependencies that would work in a bundler but are unsafe in Node.js. On the other hand, using `\"moduleResolution\": \"nodenext\"` may impose overly strict requirements on bundled imports.\n\n2.  You must ensure that your declaration files get bundled as well. Recall the [first rule of declaration files](../theory#the-role-of-declaration-files): every declaration file represents exactly one JavaScript file. If you use `\"moduleResolution\": \"bundler\"` and use a bundler to emit an ESM bundle while using `tsc` to emit many individual declaration files, your declaration files may cause errors when consumed under `\"module\": \"nodenext\"`. For example, an input file like:\n\n    ``` ts\n    import { Component } from \"./extensionless-relative-import\";\n    ```\n\n    will have its import erased by the JS bundler, but produce a declaration file with an identical import statement. That import statement, however, will contain an invalid module specifier in Node.js, since it’s missing a file extension. For Node.js users, TypeScript will error on the declaration file and infect types referencing `Component` with `any`, assuming the dependency will crash at runtime.\n\n    If your TypeScript bundler does not produce bundled declaration files, use `\"moduleResolution\": \"nodenext\"` to ensure that the imports preserved in your declaration files will be compatible with end-users’ TypeScript settings. Even better, consider not bundling your library.\n\n### Notes on dual-emit solutions\n\nA single TypeScript compilation (whether emitting or just type checking) assumes that each input file will only produce one output file. Even if `tsc` isn’t emitting anything, the type checking it performs on imported names rely on knowledge about how the output file will behave at runtime, based on the module- and emit-related options set in the tsconfig.json. While third-party emitters are generally safe to use in combination with `tsc` type checking as long as `tsc` can be configured to understand what the other emitter will emit, any solution that emits two different sets of outputs with different module formats while only type checking once leaves (at least) one of the outputs unchecked. Because external dependencies may expose different APIs to CommonJS and ESM consumers, there’s no configuration you can use to guarantee in a single compilation that both outputs will be type-safe. In practice, most dependencies follow best practices and dual-emit outputs work. Running tests and [static analysis](https://npmjs.com/package/@arethetypeswrong/cli) against all output bundles before publishing significantly reduces the chance of a serious problem going unnoticed.\n\n------------------------------------------------------------------------\n\n1.  `verbatimModuleSyntax` can only work when the JS emitter emits the same module kind as `tsc` would given the tsconfig.json, source file extension, and package.json `\"type\"`. The option works by enforcing that the `import`/`require` written is identical to the `import`/`require` emitted. Any configuration that produces both an ESM and a CJS output from the same source file is fundamentally incompatible with `verbatimModuleSyntax`, since its whole purpose is to prevent you from writing `import` anywhere that a `require` would be emitted. `verbatimModuleSyntax` can also be defeated by configuring a third-party emitter to emit a different module kind than `tsc` would—for example, by setting `\"module\": \"esnext\"` in tsconfig.json while configuring Babel to emit CommonJS.[↩](#fnref-1)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html)"
- name: 'Modules - Choosing Compiler Options: I’m writing a library'
  id: modules/guides/choosing-compiler-options#im-writing-a-library
  summary: Choosing compilation settings as a library author is a fundamentally different process from choosing settings as an app author
  belongs_to: Modules - Choosing Compiler Options
  description: "## I’m writing a library\n\nChoosing compilation settings as a library author is a fundamentally different process from choosing settings as an app author. When writing an app, settings are chosen that reflect the runtime environment or bundler—typically a single entity with known behavior. When writing a library, you would ideally check your code under *all possible* library consumer compilation settings. Since this is impractical, you can instead use the strictest possible settings, since satisfying those tends to satisfy all others.\n\n``` json\n{\n  \"compilerOptions\": {\n    \"module\": \"node16\",\n    \"target\": \"es2020\", // set to the *lowest* target you support\n    \"strict\": true,\n    \"verbatimModuleSyntax\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"declarationMap\": true\n  }\n}\n```\n\nLet’s examine why we picked each of these settings:\n\n- **`module: \"node16\"`**. When a codebase is compatible with Node.js’s module system, it almost always works in bundlers as well. If you’re using a third-party emitter to emit ESM outputs, ensure that you set `\"type\": \"module\"` in your package.json so TypeScript checks your code as ESM, which uses a stricter module resolution algorithm in Node.js than CommonJS does. As an example, let’s look at what would happen if a library were to compile with `\"moduleResolution\": \"bundler\"`:\n\n  ``` ts\n  export * from \"./utils\";\n  ```\n\n  Assuming `./utils.ts` (or `./utils/index.ts`) exists, a bundler would be fine with this code, so `\"moduleResolution\": \"bundler\"` doesn’t complain. Compiled with `\"module\": \"esnext\"`, the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:\n\n  ``` typescript\n  Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js\n  Did you mean to import ./utils.js?\n  ```\n\n  On the other hand, if we had written:\n\n  ``` ts\n  export * from \"./utils.js\";\n  ```\n\n  This would produce output that works both in Node.js *and* in bundlers.\n\n  In short, `\"moduleResolution\": \"bundler\"` is infectious, allowing code that only works in bundlers to be produced. Likewise, `\"moduleResolution\": \"nodenext\"` is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers.\n\n- **`target: \"es2020\"`**. Setting this value to the *lowest* ECMAScript version that you intend to support ensures the emitted code will not use language features introduced in a later version. Since `target` also implies a corresponding value for `lib`, this also ensures you don’t access globals that may not be available in older environments.\n\n- **`strict: true`**. Without this, you may write type-level code that ends up in your output `.d.ts` files and errors when a consumer compiles with `strict` enabled. For example, this `extends` clause:\n\n  ``` ts\n  export interface Super {\n    foo: string;\n  }\n  export interface Sub extends Super {\n    foo: string | undefined;\n  }\n  ```\n\n  is only an error under `strictNullChecks`. On the other hand, it’s very difficult to write code that errors only when `strict` is *disabled*, so it’s highly recommended for libraries to compile with `strict`.\n\n- **`verbatimModuleSyntax: true`**. This setting protects against a few module-related pitfalls that can cause problems for library consumers. First, it prevents writing any import statements that could be interpreted ambiguously based on the user’s value of `esModuleInterop` or `allowSyntheticDefaultImports`. Previously, it was often suggested that libraries compile without `esModuleInterop`, since its use in libraries could force users to adopt it too. However, it’s also possible to write imports that only work *without* `esModuleInterop`, so neither value for the setting guarantees portability for libraries. `verbatimModuleSyntax` does provide such a guarantee.^([1](#fn-1)) Second, it prevents the use of `export default` in modules that will be emitted as CommonJS, which can require bundler users and Node.js ESM users to consume the module differently. See the appendix on [ESM/CJS Interop](../appendices/esm-cjs-interop#library-code-needs-special-considerations) for more details.\n\n- **`declaration: true`** emits type declaration files alongside the output JavaScript. This is needed for consumers of the library to have any type information.\n\n- **`sourceMap: true`** and **`declarationMap: true`** emit source maps for the output JavaScript and type declaration files, respectively. These are only useful if the library also ships its source (`.ts`) files. By shipping source maps and source files, consumers of the library will be able to debug the library code somewhat more easily. By shipping declaration maps and source files, consumers will be able to see the original TypeScript sources when they run Go To Definition on imports from the libraries. Both of these represent a tradeoff between developer experience and library size, so it’s up to you whether to include them.\n\n### Considerations for bundling libraries\n\nIf you’re using a bundler to emit your library, then all your (non-externalized) imports will be processed by the bundler with known behavior, not by your users’ unknowable environments. In this case, you can use `\"module\": \"esnext\"` and `\"moduleResolution\": \"bundler\"`, but only with two caveats:\n\n1.  TypeScript cannot model module resolution when some files are bundled and some are externalized. When bundling libraries with dependencies, it’s common to bundle the first-party library source code into a single file, but leave imports of external dependencies as real imports in the bundled output. This essentially means module resolution is split between the bundler and the end user’s environment. To model this in TypeScript, you would want to process bundled imports with `\"moduleResolution\": \"bundler\"` and externalized imports with `\"moduleResolution\": \"nodenext\"` (or with multiple options to check that everything will work in a range of end-user environments). But TypeScript cannot be configured to use two different module resolution settings in the same compilation. As a consequence, using `\"moduleResolution\": \"bundler\"` may allow imports of externalized dependencies that would work in a bundler but are unsafe in Node.js. On the other hand, using `\"moduleResolution\": \"nodenext\"` may impose overly strict requirements on bundled imports.\n\n2.  You must ensure that your declaration files get bundled as well. Recall the [first rule of declaration files](../theory#the-role-of-declaration-files): every declaration file represents exactly one JavaScript file. If you use `\"moduleResolution\": \"bundler\"` and use a bundler to emit an ESM bundle while using `tsc` to emit many individual declaration files, your declaration files may cause errors when consumed under `\"module\": \"nodenext\"`. For example, an input file like:\n\n    ``` ts\n    import { Component } from \"./extensionless-relative-import\";\n    ```\n\n    will have its import erased by the JS bundler, but produce a declaration file with an identical import statement. That import statement, however, will contain an invalid module specifier in Node.js, since it’s missing a file extension. For Node.js users, TypeScript will error on the declaration file and infect types referencing `Component` with `any`, assuming the dependency will crash at runtime.\n\n    If your TypeScript bundler does not produce bundled declaration files, use `\"moduleResolution\": \"nodenext\"` to ensure that the imports preserved in your declaration files will be compatible with end-users’ TypeScript settings. Even better, consider not bundling your library.\n\n### Notes on dual-emit solutions\n\nA single TypeScript compilation (whether emitting or just type checking) assumes that each input file will only produce one output file. Even if `tsc` isn’t emitting anything, the type checking it performs on imported names rely on knowledge about how the output file will behave at runtime, based on the module- and emit-related options set in the tsconfig.json. While third-party emitters are generally safe to use in combination with `tsc` type checking as long as `tsc` can be configured to understand what the other emitter will emit, any solution that emits two different sets of outputs with different module formats while only type checking once leaves (at least) one of the outputs unchecked. Because external dependencies may expose different APIs to CommonJS and ESM consumers, there’s no configuration you can use to guarantee in a single compilation that both outputs will be type-safe. In practice, most dependencies follow best practices and dual-emit outputs work. Running tests and [static analysis](https://npmjs.com/package/@arethetypeswrong/cli) against all output bundles before publishing significantly reduces the chance of a serious problem going unnoticed.\n\n------------------------------------------------------------------------\n\n1.  `verbatimModuleSyntax` can only work when the JS emitter emits the same module kind as `tsc` would given the tsconfig.json, source file extension, and package.json `\"type\"`. The option works by enforcing that the `import`/`require` written is identical to the `import`/`require` emitted. Any configuration that produces both an ESM and a CJS output from the same source file is fundamentally incompatible with `verbatimModuleSyntax`, since its whole purpose is to prevent you from writing `import` anywhere that a `require` would be emitted. `verbatimModuleSyntax` can also be defeated by configuring a third-party emitter to emit a different module kind than `tsc` would—for example, by setting `\"module\": \"esnext\"` in tsconfig.json while configuring Babel to emit CommonJS.[↩](#fnref-1)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html)"
- name: 'Modules - Choosing Compiler Options: I’m writing an app'
  id: modules/guides/choosing-compiler-options#im-writing-an-app
  summary: A single tsconfig.json can only represent a single environment, both in terms of what globals are available and in terms of how modules behave
  belongs_to: Modules - Choosing Compiler Options
  description: |-
    ## I’m writing an app

    A single tsconfig.json can only represent a single environment, both in terms of what globals are available and in terms of how modules behave. If your app contains server code, DOM code, web worker code, test code, and code to be shared by all of those, each of those should have its own tsconfig.json, connected with [project references](../../project-references#handbook-content). Then, use this guide once for each tsconfig.json. For library-like projects within an app, especially ones that need to run in multiple runtime environments, use the “[I’m writing a library](#im-writing-a-library)” section.

    ### I’m using a bundler

    In addition to adopting the following settings, it’s also recommended *not* to set `{ "type": "module" }` or use `.mts` files in bundler projects for now. [Some bundlers](https://andrewbranch.github.io/interop-test/#synthesizing-default-exports-for-cjs-modules) adopt different ESM/CJS interop behavior under these circumstances, which TypeScript cannot currently analyze with `"moduleResolution": "bundler"`. See [issue \#54102](https://github.com/microsoft/TypeScript/issues/54102) for more information.

    ``` json
    {
      "compilerOptions": {
        // This is not a complete template; it only
        // shows relevant module-related settings.
        // Be sure to set other important options
        // like `target`, `lib`, and `strict`.

        // Required
        "module": "esnext",
        "moduleResolution": "bundler",
        "esModuleInterop": true,

        // Consult your bundler’s documentation
        "customConditions": ["module"],

        // Recommended
        "noEmit": true, // or `emitDeclarationOnly`
        "allowImportingTsExtensions": true,
        "allowArbitraryExtensions": true,
        "verbatimModuleSyntax": true, // or `isolatedModules`
      }
    }
    ```

    ### I’m compiling and running the outputs in Node.js

    Remember to set `"type": "module"` or use `.mts` files if you intend to emit ES modules.

    ``` json
    {
      "compilerOptions": {
        // This is not a complete template; it only
        // shows relevant module-related settings.
        // Be sure to set other important options
        // like `target`, `lib`, and `strict`.

        // Required
        "module": "nodenext",

        // Implied by `"module": "nodenext"`:
        // "moduleResolution": "nodenext",
        // "esModuleInterop": true,
        // "target": "esnext",

        // Recommended
        "verbatimModuleSyntax": true,
      }
    }
    ```

    ### I’m using ts-node

    ts-node attempts to be compatible with the same code and the same tsconfig.json settings that can be used to [compile and run the JS outputs in Node.js](#im-compiling-and-running-the-outputs-in-node). Refer to [ts-node documentation](https://typestrong.org/ts-node/) for more details.

    ### I’m using tsx

    Whereas ts-node makes minimal modifications to Node.js’s module system by default, [tsx](https://github.com/esbuild-kit/tsx) behaves more like a bundler, allowing extensionless/index module specifiers and arbitrary mixing of ESM and CJS. Use the same settings for tsx as you [would for a bundler](#im-using-a-bundler).

    ### I’m writing ES modules for the browser, with no bundler or module compiler

    TypeScript does not currently have options dedicated to this scenario, but you can approximate them by using a combination of the `nodenext` ESM module resolution algorithm and `paths` as a substitute for URL and import map support.

    ``` json
    // tsconfig.json
    {
      "compilerOptions": {
        // This is not a complete template; it only
        // shows relevant module-related settings.
        // Be sure to set other important options
        // like `target`, `lib`, and `strict`.

        // Combined with `"type": "module"` in a local package.json,
        // this enforces including file extensions on relative path imports.
        "module": "nodenext",
        "paths": {
          // Point TS to local types for remote URLs:
          "https://esm.sh/lodash@4.17.21": ["./node_modules/@types/lodash/index.d.ts"],
          // Optional: point bare specifier imports to an empty file
          // to prohibit importing from node_modules specifiers not listed here:
          "*": ["./empty-file.ts"]
        }
      }
    }
    ```

    This setup allows explicitly listed HTTPS imports to use locally-installed type declaration files, while erroring on imports that would normally resolve in node_modules:

    ``` ts
    import {} from "lodash";
    //             ^^^^^^^^
    // File '/project/empty-file.ts' is not a module. ts(2306)
    ```

    Alternatively, you can use [import maps](https://github.com/WICG/import-maps) to explicitly map a list of bare specifiers to URLs in the browser, while relying on `nodenext`’s default node_modules lookups, or on `paths`, to direct TypeScript to type declaration files for those bare specifier imports:

    ``` html
    <script type="importmap">
    {
      "imports": {
        "lodash": "https://esm.sh/lodash@4.17.21"
      }
    }
    </script>
    ```

    ``` ts
    import {} from "lodash";
    // Browser: https://esm.sh/lodash@4.17.21
    // TypeScript: ./node_modules/@types/lodash/index.d.ts
    ```
- name: Modules - ESM/CJS Interoperability
  id: modules/appendices/esm-cjs-interop
  summary: It’s 2015, and you’re writing an ESM-to-CJS transpiler
  description: "# Modules - ESM/CJS Interoperability\n\nIt’s 2015, and you’re writing an ESM-to-CJS transpiler. There’s no specification for how to do this; all you have is a specification of how ES modules are supposed to interact with each other, knowledge of how CommonJS modules interact with each other, and a knack for figuring things out. Consider an exporting ES module:\n\n``` ts\nexport const A = {};\nexport const B = {};\nexport default \"Hello, world!\";\n```\n\nHow would you turn this into a CommonJS module? Recalling that default exports are just named exports with special syntax, there seems to be only one choice:\n\n``` ts\nexports.A = {};\nexports.B = {};\nexports.default = \"Hello, world!\";\n```\n\nThis is a nice analog, and it lets you implement a similar on the importing side:\n\n``` ts\nimport hello, { A, B } from \"./module\";\nconsole.log(hello, A, B);\n\n// transpiles to:\n\nconst module_1 = require(\"./module\");\nconsole.log(module_1.default, module_1.A, module_1.B);\n```\n\nSo far, everything in CJS-world matches up one-to-one with everything in ESM-world. Extending the equivalence above one step further, we can see that we also have:\n\n``` ts\nimport * as mod from \"./module\";\nconsole.log(mod.default, mod.A, mod.B);\n\n// transpiles to:\n\nconst mod = require(\"./module\");\nconsole.log(mod.default, mod.A, mod.B);\n```\n\nYou might notice that in this scheme, there’s no way to write an ESM export that produces an output where `exports` is assigned a function, class, or primitive:\n\n``` ts\n// @Filename: exports-function.js\nmodule.exports = function hello() {\n  console.log(\"Hello, world!\");\n};\n```\n\nBut existing CommonJS modules frequently take this form. How might an ESM import, processed with our transpiler, access this module? We just established that a namespace import (`import *`) transpiles to a plain `require` call, so we can support an input like:\n\n``` ts\nimport * as hello from \"./exports-function\";\nhello();\n\n// transpiles to:\n\nconst hello = require(\"./exports-function\");\nhello();\n```\n\nOur output works at runtime, but we have a compliance problem: according to the JavaScript specification, a namespace import always resolves to a [*Module Namespace Object*](https://tc39.es/ecma262/#sec-module-namespace-objects), that is, an object whose members are the exports of the module. In this case, `require` would return the function `hello`, but `import *` can never return a function. The correspondence we assumed appears invalid.\n\nIt’s worth taking a step back here and clarifying what the *goal* is. As soon as modules landed in the ES2015 specification, transpilers emerged with support for downleveling ESM to CJS, allowing users to adopt the new syntax long before runtimes implemented support for it. There was even a sense that writing ESM code was a good way to “future-proof” new projects. For this to be true, there needed to be a seamless migration path from executing the transpilers’ CJS output to executing the ESM input natively once runtimes developed support for it. The goal was to find a way to downlevel ESM to CJS that would allow any or all of those transpiled outputs to be replaced by their true ESM inputs in a future runtime, with no observable change in behavior.\n\nBy following the specification, it was easy enough for transpilers to find a set of transformations that made the semantics of their transpiled CommonJS outputs match the specified semantics of their ESM inputs (arrows represent imports):\n\nHowever, CommonJS modules (written as CommonJS, not as ESM transpiled to CommonJS) were already well-established in the Node.js ecosystem, so it was inevitable that modules written as ESM and transpiled to CJS would start “importing” modules written as CommonJS. The behavior for this interoperability, though, was not specified by ES2015, and didn’t yet exist in any real runtime.\n\nEven if transpiler authors did nothing, a behavior would emerge from the existing semantics between the `require` calls they emitted in transpiled code and the `exports` defined in existing CJS modules. And to allow users to transition seamlessly from transpiled ESM to true ESM once their runtime supported it, that behavior would have to match the one the runtime chose to implement.\n\nGuessing what interop behavior runtimes would support wasn’t limited to ESM importing “true CJS” modules either. Whether ESM would be able to recognize ESM-transpiled-from-CJS as distinct from CJS, and whether CJS would be able to `require` ES modules, were also unspecified. Even whether ESM imports would use the same module resolution algorithm as CJS `require` calls was unknowable. All these variables would have to be predicted correctly in order to give transpiler users a seamless migration path toward native ESM.\n\n## `allowSyntheticDefaultImports` and `esModuleInterop`\n\nLet’s return to our specification compliance problem, where `import *` transpiles to `require`:\n\n``` ts\n// Invalid according to the spec:\nimport * as hello from \"./exports-function\";\nhello();\n\n// but the transpilation works:\nconst hello = require(\"./exports-function\");\nhello();\n```\n\nWhen TypeScript first added support for writing and transpiling ES modules, the compiler addressed this problem by issuing an error on any namespace import of a module whose `exports` was not a namespace-like object:\n\n``` ts\nimport * as hello from \"./exports-function\";\n// TS2497              ^^^^^^^^^^^^^^^^^^^^\n// External module '\"./exports-function\"' resolves to a non-module entity\n// and cannot be imported using this construct.\n```\n\nThe only workaround was for users to go back to using the older TypeScript import syntax representing a CommonJS `require`:\n\n``` ts\nimport hello = require(\"./exports-function\");\n```\n\nForcing users to revert to non-ESM syntax was essentially an admission that “we don’t know how or if a CJS module like `\"./exports-function\"` will be accessible with ESM imports in the future, but we know it *can’t* be with `import *`, even though it will work at runtime in the transpilation scheme we’re using.” It doesn’t meet the goal of allowing this file to be migrated to real ESM without changes, but neither does the alternative of allowing the `import *` to link to a function. This is still the behavior in TypeScript today when `allowSyntheticDefaultImports` and `esModuleInterop` are disabled.\n\n> Unfortunately, this is a slight oversimplification—TypeScript didn’t fully avoid the compliance issue with this error, because it allowed namespace imports of functions to work, and retain their call signatures, as long as the function declaration merged with a namespace declaration—even if the namespace was empty. So while a module exporting a bare function was recognized as a “non-module entity”:\n>\n> ``` ts\n> declare function $(selector: string): any;\n> export = $; // Cannot `import *` this 👍\n> ```\n>\n> A should-be-meaningless change allowed the invalid import to type check without errors:\n>\n> ``` ts\n> declare namespace $ {}\n> declare function $(selector: string): any;\n> export = $; // Allowed to `import *` this and call it 😱\n> ```\n\nMeanwhile, other transpilers were coming up with a way to solve the same problem. The thought process went something like this:\n\n1.  To import a CJS module that exports a function or a primitive, we clearly need to use a default import. A namespace import would be illegal, and named imports don’t make sense here.\n\n2.  Most likely, this means that runtimes implementing ESM/CJS interop will choose to make default imports of CJS modules *always* link directly to the whole `exports`, rather than only doing so if the `exports` is a function or primitive.\n\n3.  So, a default import of a true CJS module should work just like a `require` call. But we’ll need a way to disambiguate true CJS modules from our transpiled CJS modules, so we can still transpile `export default \"hello\"` to `exports.default = \"hello\"` and have a default import of *that* module link to `exports.default`. Basically, a default import of one of our own transpiled modules needs to work one way (to simulate ESM-to-ESM imports), while a default import of any other existing CJS module needs to work another way (to simulate how we think ESM-to-CJS imports will work).\n\n4.  When we transpile an ES module to CJS, let’s add a special extra field to the output:\n\n    ``` ts\n    exports.A = {};\n    exports.B = {};\n    exports.default = \"Hello, world!\";\n    // Extra special flag!\n    exports.__esModule = true;\n    ```\n\n    that we can check for when we transpile a default import:\n\n    ``` ts\n    // import hello from \"./module\";\n    const _mod = require(\"./module\");\n    const hello = _mod.__esModule ? _mod.default : _mod;\n    ```\n\nThe `__esModule` flag first appeared in Traceur, then in Babel, SystemJS, and Webpack shortly after. TypeScript added the `allowSyntheticDefaultImports` in 1.8 to allow the type checker to link default imports directly to the `exports`, rather than the `exports.default`, of any module types that lacked an `export default` declaration. The flag didn’t modify how imports or exports were emitted, but it allowed default imports to reflect how other transpilers would treat them. Namely, it allowed a default import to be used to resolve to “non-module entities,” where `import *` was an error:\n\n``` ts\n// Error:\nimport * as hello from \"./exports-function\";\n\n// Old workaround:\nimport hello = require(\"./exports-function\");\n\n// New way, with `allowSyntheticDefaultImports`:\nimport hello from \"./exports-function\";\n```\n\nThis was usually enough to let Babel and Webpack users write code that already worked in those systems without TypeScript complaining, but it was only a partial solution, leaving a few issues unsolved:\n\n1.  Babel and others varied their default import behavior on whether an `__esModule` property was found on the target module, but `allowSyntheticDefaultImports` only enabled a *fallback* behavior when no default export was found in the target module’s types. This created an inconsistency if the target module had an `__esModule` flag but *no* default export. Transpilers and bundlers would still link a default import of such a module to its `exports.default`, which would be `undefined`, and would ideally be an error in TypeScript, since real ESM imports cause errors if they can’t be linked. But with `allowSyntheticDefaultImports`, TypeScript would think a default import of such an import links to the whole `exports` object, allowing named exports to be accessed as its properties.\n\n2.  `allowSyntheticDefaultImports` didn’t change how namespace imports were typed, creating an odd inconsistency where both could be used and would have the same type:\n\n    ``` ts\n    // @Filename: exportEqualsObject.d.ts\n    declare const obj: object;\n    export = obj;\n\n    // @Filename: main.ts\n    import objDefault from \"./exportEqualsObject\";\n    import * as objNamespace from \"./exportEqualsObject\";\n\n    // This should be true at runtime, but TypeScript gives an error:\n    objNamespace.default === objDefault;\n    //           ^^^^^^^ Property 'default' does not exist on type 'typeof import(\"./exportEqualsObject\")'.\n    ```\n\n3.  Most importantly, `allowSyntheticDefaultImports` did not change the JavaScript emitted by `tsc`. So while the flag enabled more accurate checking as long as the code was fed into another tool like Babel or Webpack, it created a real danger for users who were emitting `--module commonjs` with `tsc` and running in Node.js. If they encountered an error with `import *`, it may have appeared as if enabling `allowSyntheticDefaultImports` would fix it, but in fact it only silenced the build-time error while emitting code that would crash in Node.\n\nTypeScript introduced the `esModuleInterop` flag in 2.7, which refined the type checking of imports to address the remaining inconsistencies between TypeScript’s analysis and the interop behavior used in existing transpilers and bundlers, and critically, adopted the same `__esModule`-conditional CommonJS emit that transpilers had adopted years before. (Another new emit helper for `import *` ensured the result was always an object, with call signatures stripped, fully resolving the specification compliance issue that the aforementioned “resolves to a non-module entity” error didn’t quite sidestep.) Finally, with the new flag enabled, TypeScript’s type checking, TypeScript’s emit, and the rest of the transpiling and bundling ecosystem were in agreement on a CJS/ESM interop scheme that was spec-legal and, perhaps, plausibly adoptable by Node.\n\n## Interop in Node.js\n\nNode.js shipped support for ES modules unflagged in v12. Like the bundlers and transpilers began doing years before, Node.js gave CommonJS modules a “synthetic default export” of their `exports` object, allowing the entire module contents to be accessed with a default import from ESM:\n\n``` ts\n// @Filename: export.cjs\nmodule.exports = { hello: \"world\" };\n\n// @Filename: import.mjs\nimport greeting from \"./export.cjs\";\ngreeting.hello; // \"world\"\n```\n\nThat’s one win for seamless migration! Unfortunately, the similarities mostly end there.\n\n### No `__esModule` detection (the “double default” problem)\n\nNode.js wasn’t able to respect the `__esModule` marker to vary its default import behavior. So a transpiled module with a “default export” behaves one way when “imported” by another transpiled module, and another way when imported by a true ES module in Node.js:\n\n``` ts\n// @Filename: node_modules/dependency/index.js\nexports.__esModule = true;\nexports.default = function doSomething() { /*...*/ }\n\n// @Filename: transpile-vs-run-directly.{js/mjs}\nimport doSomething from \"dependency\";\n// Works after transpilation, but not a function in Node.js ESM:\ndoSomething();\n// Doesn't exist after trasnpilation, but works in Node.js ESM:\ndoSomething.default();\n```\n\nWhile the transpiled default import only makes the synthetic default export if the target module lacks an `__esModule` flag, Node.js *always* synthesizes a default export, creating a “double default” on the transpiled module.\n\n### Unreliable named exports\n\nIn addition to making a CommonJS module’s `exports` object available as a default import, Node.js attempts to find properties of `exports` to make available as named imports. This behavior matches bundlers and transpilers when it works; however, Node.js uses [syntactic analysis](https://github.com/nodejs/cjs-module-lexer) to synthesize named exports before any code executes, whereas transpiled modules resolve their named imports at runtime. The result is that imports from CJS modules that work in transpiled modules may not work in Node.js:\n\n``` ts\n// @Filename: named-exports.cjs\nexports.hello = \"world\";\nexports[\"worl\" + \"d\"] = \"hello\";\n\n// @Filename: transpile-vs-run-directly.{js/mjs}\nimport { hello, world } from \"./named-exports.cjs\";\n// `hello` works, but `world` is missing in Node.js 💥\n\nimport mod from \"./named-exports.cjs\";\nmod.world;\n// Accessing properties from the default always works ✅\n```\n\n### Cannot `require` a true ES module\n\nTrue CommonJS modules can `require` an ESM-transpiled-to-CJS module, since they’re both CommonJS at runtime. But in Node.js, `require` crashes if it resolves to an ES module. This means published libraries cannot migrate from transpiled modules to true ESM without breaking their CommonJS (true or transpiled) consumers:\n\n``` ts\n// @Filename: node_modules/dependency/index.js\nexport function doSomething() { /* ... */ }\n\n// @Filename: dependent.js\nimport { doSomething } from \"dependency\";\n// ✅ Works if dependent and dependency are both transpiled\n// ✅ Works if dependent and dependency are both true ESM\n// ✅ Works if dependent is true ESM and dependency is transpiled\n// 💥 Crashes if dependent is transpiled and dependency is true ESM\n```\n\n### Different module resolution algorithms\n\nNode.js introduced a new module resolution algorithm for resolving ESM imports that differed significantly from the long-standing algorithm for resolving `require` calls. While not directly related to interop between CJS and ES modules, this difference was one more reason why a seamless migration from transpiled modules to true ESM might not be possible:\n\n``` ts\n// @Filename: add.js\nexport function add(a, b) {\n  return a + b;\n}\n\n// @Filename: math.js\nexport * from \"./add\";\n//            ^^^^^^^\n// Works when transpiled to CJS,\n// but would have to be \"./add.js\"\n// in Node.js ESM.\n```\n\n## Conclusions\n\nClearly, a seamless migration from transpiled modules to ESM isn’t possible, at least in Node.js. Where does this leave us?\n\n### Setting the right `module` compiler option is critical\n\nSince interoperability rules differ between hosts, TypeScript can’t offer correct checking behavior unless it understands what kind of module is represented by each file it sees, and what set of rules to apply to them. This is the purpose of the `module` compiler option. (In particular, code that is intended to run in Node.js is subject to stricter rules than code that will be processed by a bundler. The compiler’s output is not checked for Node.js compatibility unless `module` is set to `node16` or `nodenext`.)\n\n### Applications with CommonJS code should always enable `esModuleInterop`\n\nIn a TypeScript *application* (as opposed to a library that others may consume) where `tsc` is used to emit JavaScript files, whether `esModuleInterop` is enabled doesn’t have major consequences. The way you write imports for certain kinds of modules will change, but TypeScript’s checking and emit are in sync, so error-free code should be safe to run in either mode. The downside of leaving `esModuleInterop` disabled in this case is that it allows you to write JavaScript code with semantics that clearly violate the ECMAScript specification, confusing intuitions about namespace imports and making it harder to migrate to running ES modules in the future.\n\nIn an application that gets processed by a third-party transpiler or bundler, on the other hand, enabling `esModuleInterop` is more important. All major bundlers and transpilers use an `esModuleInterop`-like emit strategy, so TypeScript needs to adjust its checking to match. (The compiler always reasons about what will happen in the JavaScript files that `tsc` would emit, so even if another tool is being used in place of `tsc`, emit-affecting compiler options should still be set to match the output of that tool as closely as possible.)\n\n`allowSyntheticDefaultImports` without `esModuleInterop` should be avoided. It changes the compiler’s checking behavior without changing the code emitted by `tsc`, allowing potentially unsafe JavaScript to be emitted. Additionally, the checking changes it introduces are an incomplete version of the ones introduced by `esModuleInterop`. Even if `tsc` isn’t being used for emit, it’s better to enable `esModuleInterop` than `allowSyntheticDefaultImports`.\n\nSome people object to the inclusion of the `__importDefault` and `__importStar` helper functions included in `tsc`’s JavaScript output when `esModuleInterop` is enabled, either because it marginally increases the output size on disk or because the interop algorithm employed by the helpers seems to misrepresent Node.js’s interop behavior by checking for `__esModule`, leading to the hazards discussed earlier. Both of these objections can be addressed, at least partially, without accepting the flawed checking behavior exhibited with `esModuleInterop` disabled. First, the `importHelpers` compiler option can be used to import the helper functions from `tslib` rather than inlining them into each file that needs them. To discuss the second objection, let’s look at a final example:\n\n``` ts\n// @Filename: node_modules/transpiled-dependency/index.js\nexports.__esModule = true;\nexports.default = function doSomething() { /* ... */ };\nexports.something = \"something\";\n\n// @Filename: node_modules/true-cjs-dependency/index.js\nmodule.exports = function doSomethingElse() { /* ... */ };\n\n// @Filename: src/sayHello.ts\nexport default function sayHello() { /* ... */ }\nexport const hello = \"hello\";\n\n// @Filename: src/main.ts\nimport doSomething from \"transpiled-dependency\";\nimport doSomethingElse from \"true-cjs-dependency\";\nimport sayHello from \"./sayHello.js\";\n```\n\nAssume we’re compiling `src` to CommonJS for use in Node.js. Without `allowSyntheticDefaultImports` or `esModuleInterop`, the import of `doSomethingElse` from `\"true-cjs-dependency\"` is an error, and the others are not. To fix the error without changing any compiler options, you could change the import to `import doSomethingElse = require(\"true-cjs-dependency\")`. However, depending on how the types for the module (not shown) are written, you may also be able to write and call a namespace import, which would be a language-level specification violation. With `esModuleInterop`, none of the imports shown are errors (and all are callable), but the invalid namespace import would be caught.\n\nWhat would change if we decided to migrate `src` to true ESM in Node.js (say, add `\"type\": \"module\"` to our root package.json)? The first import, `doSomething` from `\"transpiled-dependency\"`, would no longer be callable—it exhibits the “double default” problem, where we’d have to call `doSomething.default()` rather than `doSomething()`. (TypeScript understands and catches this under `--module node16` and `nodenext`.) But notably, the *second* import of `doSomethingElse`, which needed `esModuleInterop` to work when compiling to CommonJS, works fine in true ESM.\n\nIf there’s something to complain about here, it’s not what `esModuleInterop` does with the second import. The changes it makes, both allowing the default import and preventing callable namespace imports, are exactly in line with Node.js’s real ESM/CJS interop strategy, and made migration to real ESM easier. The problem, if there is one, is that `esModuleInterop` seems to fail at giving us a seamless migration path for the *first* import. But this problem was not introduced by enabling `esModuleInterop`; the first import was completely unaffected by it. Unfortunately, this problem cannot be solved without breaking the semantic contract between `main.ts` and `sayHello.ts`, because the CommonJS output of `sayHello.ts` looks structurally identical to `transpiled-dependency/index.js`. If `esModuleInterop` changed the way the transpiled import of `doSomething` works to be identical to the way it would work in Node.js ESM, it would change the behavior of the `sayHello` import in the same way, making the input code violate ESM semantics (thus still preventing the `src` directory from being migrated to ESM without changes).\n\nAs we’ve seen, there is no seamless migration path from transpiled modules to true ESM. But `esModuleInterop` is one step in the right direction. For those who still prefer to minimize module syntax transformations and the inclusion of the import helper functions, enabling `verbatimModuleSyntax` is a better choice than disabling `esModuleInterop`. `verbatimModuleSyntax` enforces that the `import mod = require(\"mod\")` and `export = ns` syntax be used in CommonJS-emitting files, avoiding all the kinds of import ambiguity we’ve discussed, at the cost of ease of migration to true ESM.\n\n### Library code needs special considerations\n\nLibraries that ship as CommonJS should avoid using default exports, since the way those transpiled exports can be accessed varies between different tools and runtimes, and some of those ways will look confusing to users. A default export, transpiled to CommonJS by `tsc`, is accessible in Node.js as the default property of a default import:\n\n``` js\nimport pkg from \"pkg\";\npkg.default();\n```\n\nin most bundlers or transpiled ESM as the default import itself:\n\n``` js\nimport pkg from \"pkg\";\npkg();\n```\n\nand in vanilla CommonJS as the default property of a `require` call:\n\n``` js\nconst pkg = require(\"pkg\");\npkg.default();\n```\n\nUsers will detect a misconfigured module smell if they have to access the `.default` property of a default import, and if they’re trying to write code that will run both in Node.js and a bundler, they might be stuck. Some third-party TypeScript transpilers expose options that change the way default exports are emitted to mitigate this difference, but they don’t produce their own declaration (`.d.ts`) files, so that creates a mismatch between the runtime behavior and the type checking, further confusing and frustrating users. Instead of using default exports, libraries that need to ship as CommonJS should use `export =` for modules that have a single main export, or named exports for modules that have multiple exports:\n\n``` diff\n- export default function doSomething() { /* ... */ }\n+ export = function doSomething() { /* ... */ }\n```\n\nLibraries (that ship declaration files) should also take extra care to ensure the types they write are error-free under a wide range of compiler options. For example, it’s possible to write one interface that extends another in such a way that it only compiles successfully when `strictNullChecks` is disabled. If a library were to publish types like that, it would force all their users to disable `strictNullChecks` too. `esModuleInterop` can allow type declarations to contain similarly “infectious” default imports:\n\n``` ts\n// @Filename: /node_modules/dependency/index.d.ts\nimport express from \"express\";\ndeclare function doSomething(req: express.Request): any;\nexport = doSomething;\n```\n\nSuppose this default import *only* works with `esModuleInterop` enabled, and causes an error when a user without that option references this file. The user should *probably* enable `esModuleInterop` anyway, but it’s generally seen as bad form for libraries to make their configurations infectious like this. It would be much better for the library to ship a declaration file like:\n\n``` ts\nimport express = require(\"express\");\n// ...\n```\n\nExamples like this have led to conventional wisdom that says libraries should *not* enable `esModuleInterop`. This advice is a reasonable start, but we’ve looked at examples where the type of a namespace import changes, potentially *introducing* an error, when enabling `esModuleInterop`. So whether libraries compile with or without `esModuleInterop`, they run the risk of writing syntax that makes their choice infectious.\n\nLibrary authors who want to go above and beyond to ensure maximum compatibility would do well to validate their declaration files against a matrix of compiler options. But using `verbatimModuleSyntax` completely sidesteps the issue with `esModuleInterop` by forcing CommonJS-emitting files to use CommonJS-style import and export syntax. Additionally, since `esModuleInterop` only affects CommonJS, as more libraries move to ESM-only publishing over time, the relevance of this issue will decline.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html)"
- name: 'Modules - ESM/CJS Interoperability: allowSyntheticDefaultImports and esModuleInterop'
  id: modules/appendices/esm-cjs-interop#allowsyntheticdefaultimports-and-esmoduleinterop
  summary: Forcing users to revert to non-ESM syntax was essentially an admission that “we don’t know how or if a CJS module like "./exports-function" will be accessible with ESM imports in the future, but we know it can’t be with import *, even though it will work at runtime in the transpilation scheme we’re using.” It doesn’t meet the goal of allowing this file to be migrated to real ESM without changes, but neither does the alternative of allowing the import * to link to a function
  belongs_to: Modules - ESM/CJS Interoperability
  description: |-
    ## `allowSyntheticDefaultImports` and `esModuleInterop`

    Let’s return to our specification compliance problem, where `import *` transpiles to `require`:

    ``` ts
    // Invalid according to the spec:
    import * as hello from "./exports-function";
    hello();

    // but the transpilation works:
    const hello = require("./exports-function");
    hello();
    ```

    When TypeScript first added support for writing and transpiling ES modules, the compiler addressed this problem by issuing an error on any namespace import of a module whose `exports` was not a namespace-like object:

    ``` ts
    import * as hello from "./exports-function";
    // TS2497              ^^^^^^^^^^^^^^^^^^^^
    // External module '"./exports-function"' resolves to a non-module entity
    // and cannot be imported using this construct.
    ```

    The only workaround was for users to go back to using the older TypeScript import syntax representing a CommonJS `require`:

    ``` ts
    import hello = require("./exports-function");
    ```

    Forcing users to revert to non-ESM syntax was essentially an admission that “we don’t know how or if a CJS module like `"./exports-function"` will be accessible with ESM imports in the future, but we know it *can’t* be with `import *`, even though it will work at runtime in the transpilation scheme we’re using.” It doesn’t meet the goal of allowing this file to be migrated to real ESM without changes, but neither does the alternative of allowing the `import *` to link to a function. This is still the behavior in TypeScript today when `allowSyntheticDefaultImports` and `esModuleInterop` are disabled.

    > Unfortunately, this is a slight oversimplification—TypeScript didn’t fully avoid the compliance issue with this error, because it allowed namespace imports of functions to work, and retain their call signatures, as long as the function declaration merged with a namespace declaration—even if the namespace was empty. So while a module exporting a bare function was recognized as a “non-module entity”:
    >
    > ``` ts
    > declare function $(selector: string): any;
    > export = $; // Cannot `import *` this 👍
    > ```
    >
    > A should-be-meaningless change allowed the invalid import to type check without errors:
    >
    > ``` ts
    > declare namespace $ {}
    > declare function $(selector: string): any;
    > export = $; // Allowed to `import *` this and call it 😱
    > ```

    Meanwhile, other transpilers were coming up with a way to solve the same problem. The thought process went something like this:

    1.  To import a CJS module that exports a function or a primitive, we clearly need to use a default import. A namespace import would be illegal, and named imports don’t make sense here.

    2.  Most likely, this means that runtimes implementing ESM/CJS interop will choose to make default imports of CJS modules *always* link directly to the whole `exports`, rather than only doing so if the `exports` is a function or primitive.

    3.  So, a default import of a true CJS module should work just like a `require` call. But we’ll need a way to disambiguate true CJS modules from our transpiled CJS modules, so we can still transpile `export default "hello"` to `exports.default = "hello"` and have a default import of *that* module link to `exports.default`. Basically, a default import of one of our own transpiled modules needs to work one way (to simulate ESM-to-ESM imports), while a default import of any other existing CJS module needs to work another way (to simulate how we think ESM-to-CJS imports will work).

    4.  When we transpile an ES module to CJS, let’s add a special extra field to the output:

        ``` ts
        exports.A = {};
        exports.B = {};
        exports.default = "Hello, world!";
        // Extra special flag!
        exports.__esModule = true;
        ```

        that we can check for when we transpile a default import:

        ``` ts
        // import hello from "./module";
        const _mod = require("./module");
        const hello = _mod.__esModule ? _mod.default : _mod;
        ```

    The `__esModule` flag first appeared in Traceur, then in Babel, SystemJS, and Webpack shortly after. TypeScript added the `allowSyntheticDefaultImports` in 1.8 to allow the type checker to link default imports directly to the `exports`, rather than the `exports.default`, of any module types that lacked an `export default` declaration. The flag didn’t modify how imports or exports were emitted, but it allowed default imports to reflect how other transpilers would treat them. Namely, it allowed a default import to be used to resolve to “non-module entities,” where `import *` was an error:

    ``` ts
    // Error:
    import * as hello from "./exports-function";

    // Old workaround:
    import hello = require("./exports-function");

    // New way, with `allowSyntheticDefaultImports`:
    import hello from "./exports-function";
    ```

    This was usually enough to let Babel and Webpack users write code that already worked in those systems without TypeScript complaining, but it was only a partial solution, leaving a few issues unsolved:

    1.  Babel and others varied their default import behavior on whether an `__esModule` property was found on the target module, but `allowSyntheticDefaultImports` only enabled a *fallback* behavior when no default export was found in the target module’s types. This created an inconsistency if the target module had an `__esModule` flag but *no* default export. Transpilers and bundlers would still link a default import of such a module to its `exports.default`, which would be `undefined`, and would ideally be an error in TypeScript, since real ESM imports cause errors if they can’t be linked. But with `allowSyntheticDefaultImports`, TypeScript would think a default import of such an import links to the whole `exports` object, allowing named exports to be accessed as its properties.

    2.  `allowSyntheticDefaultImports` didn’t change how namespace imports were typed, creating an odd inconsistency where both could be used and would have the same type:

        ``` ts
        // @Filename: exportEqualsObject.d.ts
        declare const obj: object;
        export = obj;

        // @Filename: main.ts
        import objDefault from "./exportEqualsObject";
        import * as objNamespace from "./exportEqualsObject";

        // This should be true at runtime, but TypeScript gives an error:
        objNamespace.default === objDefault;
        //           ^^^^^^^ Property 'default' does not exist on type 'typeof import("./exportEqualsObject")'.
        ```

    3.  Most importantly, `allowSyntheticDefaultImports` did not change the JavaScript emitted by `tsc`. So while the flag enabled more accurate checking as long as the code was fed into another tool like Babel or Webpack, it created a real danger for users who were emitting `--module commonjs` with `tsc` and running in Node.js. If they encountered an error with `import *`, it may have appeared as if enabling `allowSyntheticDefaultImports` would fix it, but in fact it only silenced the build-time error while emitting code that would crash in Node.

    TypeScript introduced the `esModuleInterop` flag in 2.7, which refined the type checking of imports to address the remaining inconsistencies between TypeScript’s analysis and the interop behavior used in existing transpilers and bundlers, and critically, adopted the same `__esModule`-conditional CommonJS emit that transpilers had adopted years before. (Another new emit helper for `import *` ensured the result was always an object, with call signatures stripped, fully resolving the specification compliance issue that the aforementioned “resolves to a non-module entity” error didn’t quite sidestep.) Finally, with the new flag enabled, TypeScript’s type checking, TypeScript’s emit, and the rest of the transpiling and bundling ecosystem were in agreement on a CJS/ESM interop scheme that was spec-legal and, perhaps, plausibly adoptable by Node.
- name: 'Modules - ESM/CJS Interoperability: Applications with CommonJS code should always enable esModuleInterop'
  id: modules/appendices/esm-cjs-interop#applications-with-commonjs-code-should-always-enable-esmoduleinterop
  summary: In a TypeScript application (as opposed to a library that others may consume) where tsc is used to emit JavaScript files, whether esModuleInterop is enabled doesn’t have major consequences
  belongs_to: Modules - ESM/CJS Interoperability
  description: "### Applications with CommonJS code should always enable `esModuleInterop`\n\nIn a TypeScript *application* (as opposed to a library that others may consume) where `tsc` is used to emit JavaScript files, whether `esModuleInterop` is enabled doesn’t have major consequences. The way you write imports for certain kinds of modules will change, but TypeScript’s checking and emit are in sync, so error-free code should be safe to run in either mode. The downside of leaving `esModuleInterop` disabled in this case is that it allows you to write JavaScript code with semantics that clearly violate the ECMAScript specification, confusing intuitions about namespace imports and making it harder to migrate to running ES modules in the future.\n\nIn an application that gets processed by a third-party transpiler or bundler, on the other hand, enabling `esModuleInterop` is more important. All major bundlers and transpilers use an `esModuleInterop`-like emit strategy, so TypeScript needs to adjust its checking to match. (The compiler always reasons about what will happen in the JavaScript files that `tsc` would emit, so even if another tool is being used in place of `tsc`, emit-affecting compiler options should still be set to match the output of that tool as closely as possible.)\n\n`allowSyntheticDefaultImports` without `esModuleInterop` should be avoided. It changes the compiler’s checking behavior without changing the code emitted by `tsc`, allowing potentially unsafe JavaScript to be emitted. Additionally, the checking changes it introduces are an incomplete version of the ones introduced by `esModuleInterop`. Even if `tsc` isn’t being used for emit, it’s better to enable `esModuleInterop` than `allowSyntheticDefaultImports`.\n\nSome people object to the inclusion of the `__importDefault` and `__importStar` helper functions included in `tsc`’s JavaScript output when `esModuleInterop` is enabled, either because it marginally increases the output size on disk or because the interop algorithm employed by the helpers seems to misrepresent Node.js’s interop behavior by checking for `__esModule`, leading to the hazards discussed earlier. Both of these objections can be addressed, at least partially, without accepting the flawed checking behavior exhibited with `esModuleInterop` disabled. First, the `importHelpers` compiler option can be used to import the helper functions from `tslib` rather than inlining them into each file that needs them. To discuss the second objection, let’s look at a final example:\n\n``` ts\n// @Filename: node_modules/transpiled-dependency/index.js\nexports.__esModule = true;\nexports.default = function doSomething() { /* ... */ };\nexports.something = \"something\";\n\n// @Filename: node_modules/true-cjs-dependency/index.js\nmodule.exports = function doSomethingElse() { /* ... */ };\n\n// @Filename: src/sayHello.ts\nexport default function sayHello() { /* ... */ }\nexport const hello = \"hello\";\n\n// @Filename: src/main.ts\nimport doSomething from \"transpiled-dependency\";\nimport doSomethingElse from \"true-cjs-dependency\";\nimport sayHello from \"./sayHello.js\";\n```\n\nAssume we’re compiling `src` to CommonJS for use in Node.js. Without `allowSyntheticDefaultImports` or `esModuleInterop`, the import of `doSomethingElse` from `\"true-cjs-dependency\"` is an error, and the others are not. To fix the error without changing any compiler options, you could change the import to `import doSomethingElse = require(\"true-cjs-dependency\")`. However, depending on how the types for the module (not shown) are written, you may also be able to write and call a namespace import, which would be a language-level specification violation. With `esModuleInterop`, none of the imports shown are errors (and all are callable), but the invalid namespace import would be caught.\n\nWhat would change if we decided to migrate `src` to true ESM in Node.js (say, add `\"type\": \"module\"` to our root package.json)? The first import, `doSomething` from `\"transpiled-dependency\"`, would no longer be callable—it exhibits the “double default” problem, where we’d have to call `doSomething.default()` rather than `doSomething()`. (TypeScript understands and catches this under `--module node16` and `nodenext`.) But notably, the *second* import of `doSomethingElse`, which needed `esModuleInterop` to work when compiling to CommonJS, works fine in true ESM.\n\nIf there’s something to complain about here, it’s not what `esModuleInterop` does with the second import. The changes it makes, both allowing the default import and preventing callable namespace imports, are exactly in line with Node.js’s real ESM/CJS interop strategy, and made migration to real ESM easier. The problem, if there is one, is that `esModuleInterop` seems to fail at giving us a seamless migration path for the *first* import. But this problem was not introduced by enabling `esModuleInterop`; the first import was completely unaffected by it. Unfortunately, this problem cannot be solved without breaking the semantic contract between `main.ts` and `sayHello.ts`, because the CommonJS output of `sayHello.ts` looks structurally identical to `transpiled-dependency/index.js`. If `esModuleInterop` changed the way the transpiled import of `doSomething` works to be identical to the way it would work in Node.js ESM, it would change the behavior of the `sayHello` import in the same way, making the input code violate ESM semantics (thus still preventing the `src` directory from being migrated to ESM without changes).\n\nAs we’ve seen, there is no seamless migration path from transpiled modules to true ESM. But `esModuleInterop` is one step in the right direction. For those who still prefer to minimize module syntax transformations and the inclusion of the import helper functions, enabling `verbatimModuleSyntax` is a better choice than disabling `esModuleInterop`. `verbatimModuleSyntax` enforces that the `import mod = require(\"mod\")` and `export = ns` syntax be used in CommonJS-emitting files, avoiding all the kinds of import ambiguity we’ve discussed, at the cost of ease of migration to true ESM.\n\n### Library code needs special considerations\n\nLibraries that ship as CommonJS should avoid using default exports, since the way those transpiled exports can be accessed varies between different tools and runtimes, and some of those ways will look confusing to users. A default export, transpiled to CommonJS by `tsc`, is accessible in Node.js as the default property of a default import:\n\n``` js\nimport pkg from \"pkg\";\npkg.default();\n```\n\nin most bundlers or transpiled ESM as the default import itself:\n\n``` js\nimport pkg from \"pkg\";\npkg();\n```\n\nand in vanilla CommonJS as the default property of a `require` call:\n\n``` js\nconst pkg = require(\"pkg\");\npkg.default();\n```\n\nUsers will detect a misconfigured module smell if they have to access the `.default` property of a default import, and if they’re trying to write code that will run both in Node.js and a bundler, they might be stuck. Some third-party TypeScript transpilers expose options that change the way default exports are emitted to mitigate this difference, but they don’t produce their own declaration (`.d.ts`) files, so that creates a mismatch between the runtime behavior and the type checking, further confusing and frustrating users. Instead of using default exports, libraries that need to ship as CommonJS should use `export =` for modules that have a single main export, or named exports for modules that have multiple exports:\n\n``` diff\n- export default function doSomething() { /* ... */ }\n+ export = function doSomething() { /* ... */ }\n```\n\nLibraries (that ship declaration files) should also take extra care to ensure the types they write are error-free under a wide range of compiler options. For example, it’s possible to write one interface that extends another in such a way that it only compiles successfully when `strictNullChecks` is disabled. If a library were to publish types like that, it would force all their users to disable `strictNullChecks` too. `esModuleInterop` can allow type declarations to contain similarly “infectious” default imports:\n\n``` ts\n// @Filename: /node_modules/dependency/index.d.ts\nimport express from \"express\";\ndeclare function doSomething(req: express.Request): any;\nexport = doSomething;\n```\n\nSuppose this default import *only* works with `esModuleInterop` enabled, and causes an error when a user without that option references this file. The user should *probably* enable `esModuleInterop` anyway, but it’s generally seen as bad form for libraries to make their configurations infectious like this. It would be much better for the library to ship a declaration file like:\n\n``` ts\nimport express = require(\"express\");\n// ...\n```\n\nExamples like this have led to conventional wisdom that says libraries should *not* enable `esModuleInterop`. This advice is a reasonable start, but we’ve looked at examples where the type of a namespace import changes, potentially *introducing* an error, when enabling `esModuleInterop`. So whether libraries compile with or without `esModuleInterop`, they run the risk of writing syntax that makes their choice infectious.\n\nLibrary authors who want to go above and beyond to ensure maximum compatibility would do well to validate their declaration files against a matrix of compiler options. But using `verbatimModuleSyntax` completely sidesteps the issue with `esModuleInterop` by forcing CommonJS-emitting files to use CommonJS-style import and export syntax. Additionally, since `esModuleInterop` only affects CommonJS, as more libraries move to ESM-only publishing over time, the relevance of this issue will decline.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html)"
- name: 'Modules - ESM/CJS Interoperability: Cannot require a true ES module'
  id: modules/appendices/esm-cjs-interop#cannot-require-a-true-es-module
  summary: True CommonJS modules can require an ESM-transpiled-to-CJS module, since they’re both CommonJS at runtime
  belongs_to: Modules - ESM/CJS Interoperability
  description: |-
    ### Cannot `require` a true ES module

    True CommonJS modules can `require` an ESM-transpiled-to-CJS module, since they’re both CommonJS at runtime. But in Node.js, `require` crashes if it resolves to an ES module. This means published libraries cannot migrate from transpiled modules to true ESM without breaking their CommonJS (true or transpiled) consumers:

    ``` ts
    // @Filename: node_modules/dependency/index.js
    export function doSomething() { /* ... */ }

    // @Filename: dependent.js
    import { doSomething } from "dependency";
    // ✅ Works if dependent and dependency are both transpiled
    // ✅ Works if dependent and dependency are both true ESM
    // ✅ Works if dependent is true ESM and dependency is transpiled
    // 💥 Crashes if dependent is transpiled and dependency is true ESM
    ```

    ### Different module resolution algorithms

    Node.js introduced a new module resolution algorithm for resolving ESM imports that differed significantly from the long-standing algorithm for resolving `require` calls. While not directly related to interop between CJS and ES modules, this difference was one more reason why a seamless migration from transpiled modules to true ESM might not be possible:

    ``` ts
    // @Filename: add.js
    export function add(a, b) {
      return a + b;
    }

    // @Filename: math.js
    export * from "./add";
    //            ^^^^^^^
    // Works when transpiled to CJS,
    // but would have to be "./add.js"
    // in Node.js ESM.
    ```
- name: 'Modules - ESM/CJS Interoperability: Conclusions'
  id: modules/appendices/esm-cjs-interop#conclusions
  summary: Clearly, a seamless migration from transpiled modules to ESM isn’t possible, at least in Node.js
  belongs_to: Modules - ESM/CJS Interoperability
  description: |-
    ## Conclusions

    Clearly, a seamless migration from transpiled modules to ESM isn’t possible, at least in Node.js. Where does this leave us?
- name: 'Modules - ESM/CJS Interoperability: Interop in Node.js'
  id: modules/appendices/esm-cjs-interop#interop-in-nodejs
  summary: Node.js shipped support for ES modules unflagged in v12
  belongs_to: Modules - ESM/CJS Interoperability
  description: |-
    ## Interop in Node.js

    Node.js shipped support for ES modules unflagged in v12. Like the bundlers and transpilers began doing years before, Node.js gave CommonJS modules a “synthetic default export” of their `exports` object, allowing the entire module contents to be accessed with a default import from ESM:

    ``` ts
    // @Filename: export.cjs
    module.exports = { hello: "world" };

    // @Filename: import.mjs
    import greeting from "./export.cjs";
    greeting.hello; // "world"
    ```

    That’s one win for seamless migration! Unfortunately, the similarities mostly end there.
- name: 'Modules - ESM/CJS Interoperability: No __esModule detection (the “double default” problem)'
  id: modules/appendices/esm-cjs-interop#no-__esmodule-detection-the-double-default-problem
  summary: Node.js wasn’t able to respect the __esModule marker to vary its default import behavior
  belongs_to: Modules - ESM/CJS Interoperability
  description: |-
    ### No `__esModule` detection (the “double default” problem)

    Node.js wasn’t able to respect the `__esModule` marker to vary its default import behavior. So a transpiled module with a “default export” behaves one way when “imported” by another transpiled module, and another way when imported by a true ES module in Node.js:

    ``` ts
    // @Filename: node_modules/dependency/index.js
    exports.__esModule = true;
    exports.default = function doSomething() { /*...*/ }

    // @Filename: transpile-vs-run-directly.{js/mjs}
    import doSomething from "dependency";
    // Works after transpilation, but not a function in Node.js ESM:
    doSomething();
    // Doesn't exist after trasnpilation, but works in Node.js ESM:
    doSomething.default();
    ```

    While the transpiled default import only makes the synthetic default export if the target module lacks an `__esModule` flag, Node.js *always* synthesizes a default export, creating a “double default” on the transpiled module.

    ### Unreliable named exports

    In addition to making a CommonJS module’s `exports` object available as a default import, Node.js attempts to find properties of `exports` to make available as named imports. This behavior matches bundlers and transpilers when it works; however, Node.js uses [syntactic analysis](https://github.com/nodejs/cjs-module-lexer) to synthesize named exports before any code executes, whereas transpiled modules resolve their named imports at runtime. The result is that imports from CJS modules that work in transpiled modules may not work in Node.js:

    ``` ts
    // @Filename: named-exports.cjs
    exports.hello = "world";
    exports["worl" + "d"] = "hello";

    // @Filename: transpile-vs-run-directly.{js/mjs}
    import { hello, world } from "./named-exports.cjs";
    // `hello` works, but `world` is missing in Node.js 💥

    import mod from "./named-exports.cjs";
    mod.world;
    // Accessing properties from the default always works ✅
    ```
- name: 'Modules - ESM/CJS Interoperability: Setting the right module compiler option is critical'
  id: modules/appendices/esm-cjs-interop#setting-the-right-module-compiler-option-is-critical
  summary: Since interoperability rules differ between hosts, TypeScript can’t offer correct checking behavior unless it understands what kind of module is represented by each file it sees, and what set of rules to apply to them
  belongs_to: Modules - ESM/CJS Interoperability
  description: |-
    ### Setting the right `module` compiler option is critical

    Since interoperability rules differ between hosts, TypeScript can’t offer correct checking behavior unless it understands what kind of module is represented by each file it sees, and what set of rules to apply to them. This is the purpose of the `module` compiler option. (In particular, code that is intended to run in Node.js is subject to stricter rules than code that will be processed by a bundler. The compiler’s output is not checked for Node.js compatibility unless `module` is set to `node16` or `nodenext`.)
- name: Modules - Introduction
  id: modules/introduction
  summary: © 2012-2024 Microsoft Licensed under the Apache License, Version 2.0
  description: "# Modules - Introduction\n\nThis document is divided into four sections:\n\n1.  The first section develops the [**theory**](theory) behind how TypeScript approaches modules. If you want to be able to write the correct module-related compiler options for any situation, reason about how to integrate TypeScript with other tools, or understand how TypeScript processes dependency packages, this is the place to start. While there are guides and reference pages on these topics, building an understanding of these fundamentals will make reading the guides easier, and give you a mental framework for dealing with real-world problems not specifically covered here.\n2.  The [**guides**](guides/choosing-compiler-options) show how to accomplish specific real-world tasks, starting with picking the right compilation settings for a new project. The guides are a good place to start both for beginners who want to get up and running as quickly as possible and for experts who already have a good grasp of the theory but want concrete guidance on a complicated task.\n3.  The [**reference**](reference) section provides a more detailed look at the syntaxes and configurations presented in previous sections.\n4.  The [**appendices**](appendices/esm-cjs-interop) cover complicated topics that deserve additional explanation in more detail than the theory or reference sections allow.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/modules/introduction.html](https://www.typescriptlang.org/docs/handbook/modules/introduction.html)"
- name: Modules - Reference
  id: modules/reference
  summary: The TypeScript compiler recognizes standard ECMAScript module syntax in TypeScript and JavaScript files and many forms of CommonJS syntax in JavaScript files
  description: "# Modules - Reference\n\n## Module syntax\n\nThe TypeScript compiler recognizes standard [ECMAScript module syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) in TypeScript and JavaScript files and many forms of [CommonJS syntax](../type-checking-javascript-files#commonjs-modules-are-supported) in JavaScript files.\n\nThere are also a few TypeScript-specific syntax extensions that can be used in TypeScript files and/or JSDoc comments.\n\n### Importing and exporting TypeScript-specific declarations\n\nType aliases, interfaces, enums, and namespaces can be exported from a module with an `export` modifier, like any standard JavaScript declaration:\n\n``` ts\n// Standard JavaScript syntax...\nexport function f() {}\n// ...extended to type declarations\nexport type SomeType = /* ... */;\nexport interface SomeInterface { /* ... */ }\n```\n\nThey can also be referenced in named exports, even alongside references to standard JavaScript declarations:\n\n``` ts\nexport { f, SomeType, SomeInterface };\n```\n\nExported types (and other TypeScript-specific declarations) can be imported with standard ECMAScript imports:\n\n``` ts\nimport { f, SomeType, SomeInterface } from \"./module.js\";\n```\n\nWhen using namespace imports or exports, exported types are available on the namespace when referenced in a type position:\n\n``` ts\nimport * as mod from \"./module.js\";\nmod.f();\nmod.SomeType; // Property 'SomeType' does not exist on type 'typeof import(\"./module.js\")'\nlet x: mod.SomeType; // Ok\n```\n\n### Type-only imports and exports\n\nWhen emitting imports and exports to JavaScript, by default, TypeScript automatically elides (does not emit) imports that are only used in type positions and exports that only refer to types. Type-only imports and exports can be used to force this behavior and make the elision explicit. Import declarations written with `import type`, export declarations written with `export type { ... }`, and import or export specifiers prefixed with the `type` keyword are all guaranteed to be elided from the output JavaScript.\n\n``` ts\n// @Filename: main.ts\nimport { f, type SomeInterface } from \"./module.js\";\nimport type { SomeType } from \"./module.js\";\n\nclass C implements SomeInterface {\n  constructor(p: SomeType) {\n    f();\n  }\n}\n\nexport type { C };\n\n// @Filename: main.js\nimport { f } from \"./module.js\";\n\nclass C {\n  constructor(p) {\n    f();\n  }\n}\n```\n\nEven values can be imported with `import type`, but since they won’t exist in the output JavaScript, they can only be used in non-emitting positions:\n\n``` ts\nimport type { f } from \"./module.js\";\nf(); // 'f' cannot be used as a value because it was imported using 'import type'\nlet otherFunction: typeof f = () => {}; // Ok\n```\n\nA type-only import declaration may not declare both a default import and named bindings, since it appears ambiguous whether `type` applies to the default import or to the entire import declaration. Instead, split the import declaration into two, or use `default` as a named binding:\n\n``` ts\nimport type fs, { BigIntOptions } from \"fs\";\n//          ^^^^^^^^^^^^^^^^^^^^^\n// Error: A type-only import can specify a default import or named bindings, but not both.\n\nimport type { default as fs, BigIntOptions } from \"fs\"; // Ok\n```\n\n### `import()` types\n\nTypeScript provides a type syntax similar to JavaScript’s dynamic `import` for referencing the type of a module without writing an import declaration:\n\n``` ts\n// Access an exported type:\ntype WriteFileOptions = import(\"fs\").WriteFileOptions;\n// Access the type of an exported value:\ntype WriteFileFunction = typeof import(\"fs\").writeFile;\n```\n\nThis is especially useful in JSDoc comments in JavaScript files, where it’s not possible to import types otherwise:\n\n``` ts\n/** @type {import(\"webpack\").Configuration} */\nmodule.exports = {\n  // ...\n}\n```\n\n### `export =` and `import = require()`\n\nWhen emitting CommonJS modules, TypeScript files can use a direct analog of `module.exports = ...` and `const mod = require(\"...\")` JavaScript syntax:\n\n``` ts\n// @Filename: main.ts\nimport fs = require(\"fs\");\nexport = fs.readFileSync(\"...\");\n\n// @Filename: main.js\n\"use strict\";\nconst fs = require(\"fs\");\nmodule.exports = fs.readFileSync(\"...\");\n```\n\nThis syntax was used over its JavaScript counterparts since variable declarations and property assignments could not refer to TypeScript types, whereas special TypeScript syntax could:\n\n``` ts\n// @Filename: a.ts\ninterface Options { /* ... */ }\nmodule.exports = Options; // Error: 'Options' only refers to a type, but is being used as a value here.\nexport = Options; // Ok\n\n// @Filename: b.ts\nconst Options = require(\"./a\");\nconst options: Options = { /* ... */ }; // Error: 'Options' refers to a value, but is being used as a type here.\n\n// @Filename: c.ts\nimport Options = require(\"./a\");\nconst options: Options = { /* ... */ }; // Ok\n```\n\n### Ambient modules\n\nTypeScript supports a syntax in script (non-module) files for declaring a module that exists in the runtime but has no corresponding file. These *ambient modules* usually represent runtime-provided modules, like `\"fs\"` or `\"path\"` in Node.js:\n\n``` ts\ndeclare module \"path\" {\n  export function normalize(p: string): string;\n  export function join(...paths: any[]): string;\n  export var sep: string;\n}\n```\n\nOnce an ambient module is loaded into a TypeScript program, TypeScript will recognize imports of the declared module in other files:\n\n``` ts\n// 👇 Ensure the ambient module is loaded -\n//    may be unnecessary if path.d.ts is included\n//    by the project tsconfig.json somehow.\n/// <reference path=\"path.d.ts\" />\n\nimport { normalize, join } from \"path\";\n```\n\nAmbient module declarations are easy to confuse with [module augmentations](../declaration-merging#module-augmentation) since they use identical syntax. This module declaration syntax becomes a module augmentation when the file is a module, meaning it has a top-level `import` or `export` statement (or is affected by [`--moduleDetection force` or `auto`](https://www.typescriptlang.org/tsconfig#moduleDetection)):\n\n``` ts\n// Not an ambient module declaration anymore!\nexport {};\ndeclare module \"path\" {\n  export function normalize(p: string): string;\n  export function join(...paths: any[]): string;\n  export var sep: string;\n}\n```\n\nAmbient modules may use imports inside the module declaration body to refer to other modules without turning the containing file into a module (which would make the ambient module declaration a module augmentation):\n\n``` ts\ndeclare module \"m\" {\n  // Moving this outside \"m\" would totally change the meaning of the file!\n  import { SomeType } from \"other\";\n  export function f(): SomeType;\n}\n```\n\nA *pattern* ambient module contains a single `*` wildcard character in its name, matching zero or more characters in import paths. This can be useful for declaring modules provided by custom loaders:\n\n``` ts\ndeclare module \"*.html\" {\n  const content: string;\n  export default content;\n}\n```\n\n## The `module` compiler option\n\nThis section discusses the details of each `module` compiler option value. See the [*Module output format*](theory#the-module-output-format) theory section for more background on what the option is and how it fits into the overall compilation process. In brief, the `module` compiler option was historically only used to control the output module format of emitted JavaScript files. The more recent `node16` and `nodenext` values, however, describe a wide range of characteristics of Node.js’s module system, including what module formats are supported, how the module format of each file is determined, and how different module formats interoperate.\n\n### `node16`, `nodenext`\n\nNode.js supports both CommonJS and ECMAScript modules, with specific rules for which format each file can be and how the two formats are allowed to interoperate. `node16` and `nodenext` describe the full range of behavior for Node.js’s dual-format module system, and **emit files in either CommonJS or ESM format**. This is different from every other `module` option, which are runtime-agnostic and force all output files into a single format, leaving it to the user to ensure the output is valid for their runtime.\n\n> A common misconception is that `node16` and `nodenext` only emit ES modules. In reality, `node16` and `nodenext` describe versions of Node.js that *support* ES modules, not just projects that *use* ES modules. Both ESM and CommonJS emit are supported, based on the [detected module format](#module-format-detection) of each file. Because `node16` and `nodenext` are the only `module` options that reflect the complexities of Node.js’s dual module system, they are the **only correct `module` options** for all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not.\n\n`node16` and `nodenext` are currently identical, with the exception that they [imply different `target` option values](#implied-and-enforced-options). If Node.js makes significant changes to its module system in the future, `node16` will be frozen while `nodenext` will be updated to reflect the new behavior.\n\n#### Module format detection\n\n- `.mts`/`.mjs`/`.d.mts` files are always ES modules.\n- `.cts`/`.cjs`/`.d.cts` files are always CommonJS modules.\n- `.ts`/`.tsx`/`.js`/`.jsx`/`.d.ts` files are ES modules if the nearest ancestor package.json file contains `\"type\": \"module\"`, otherwise CommonJS modules.\n\nThe detected module format of input `.ts`/`.tsx`/`.mts`/`.cts` files determines the module format of the emitted JavaScript files. So, for example, a project consisting entirely of `.ts` files will emit all CommonJS modules by default under `--module nodenext`, and can be made to emit all ES modules by adding `\"type\": \"module\"` to the project package.json.\n\n#### Interoperability rules\n\n- **When an ES module references a CommonJS module:**\n  - The `module.exports` of the CommonJS module is available as a default import to the ES module.\n  - Properties (other than `default`) of the CommonJS module’s `module.exports` may or may not be available as named imports to the ES module. Node.js attempts to make them available via [static analysis](https://github.com/nodejs/cjs-module-lexer). TypeScript cannot know from a declaration file whether that static analysis will succeed, and optimistically assumes it will. This limits TypeScript’s ability to catch named imports that may crash at runtime. See [\\#54018](https://github.com/microsoft/TypeScript/issues/54018) for more details.\n- **When a CommonJS module references an ES module:**\n  - `require` cannot reference an ES module. For TypeScript, this includes `import` statements in files that are [detected](#module-format-detection) to be CommonJS modules, since those `import` statements will be transformed to `require` calls in the emitted JavaScript.\n  - A dynamic `import()` call may be used to import an ES module. It returns a Promise of the module’s Module Namespace Object (what you’d get from `import * as ns from \"./module.js\"` from another ES module).\n\n#### Emit\n\nThe emit format of each file is determined by the [detected module format](#module-format-detection) of each file. ESM emit is similar to [`--module esnext`](#es2015-es2020-es2022-esnext), but has a special transformation for `import x = require(\"...\")`, which is not allowed in `--module esnext`:\n\n``` ts\n// @Filename: main.ts\nimport x = require(\"mod\");\n```\n\n``` js\n// @Filename: main.js\nimport { createRequire as _createRequire } from \"module\";\nconst __require = _createRequire(import.meta.url);\nconst x = __require(\"mod\");\n```\n\nCommonJS emit is similar to [`--module commonjs`](#commonjs), but dynamic `import()` calls are not transformed. Emit here is shown with `esModuleInterop` enabled:\n\n``` ts\n// @Filename: main.ts\nimport fs from \"fs\"; // transformed\nconst dynamic = import(\"mod\"); // not transformed\n```\n\n``` js\n// @Filename: main.js\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs_1 = __importDefault(require(\"fs\")); // transformed\nconst dynamic = import(\"mod\"); // not transformed\n```\n\n#### Implied and enforced options\n\n- `--module nodenext` or `node16` implies and enforces the `moduleResolution` with the same name.\n- `--module nodenext` implies `--target esnext`.\n- `--module node16` implies `--target es2022`.\n- `--module nodenext` or `node16` implies `--esModuleInterop`.\n\n#### Summary\n\n- `node16` and `nodenext` are the only correct `module` options for all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not.\n- `node16` and `nodenext` emit files in either CommonJS or ESM format, based on the [detected module format](#module-format-detection) of each file.\n- Node.js’s interoperability rules between ESM and CJS are reflected in type checking.\n- ESM emit transforms `import x = require(\"...\")` to a `require` call constructed from a `createRequire` import.\n- CommonJS emit leaves dynamic `import()` calls untransformed, so CommonJS modules can asynchronously import ES modules.\n\n### `preserve`\n\nIn `--module preserve` ([added](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-bundler-and---module-preserve) in TypeScript 5.4), ECMAScript imports and exports written in input files are preserved in the output, and CommonJS-style `import x = require(\"...\")` and `export = ...` statements are emitted as CommonJS `require` and `module.exports`. In other words, the format of each individual import or export statement is preserved, rather than being coerced into a single format for the whole compilation (or even a whole file).\n\nWhile it’s rare to need to mix imports and require calls in the same file, this `module` mode best reflects the capabilities of most modern bundlers, as well as the Bun runtime.\n\n> Why care about TypeScript’s `module` emit with a bundler or with Bun, where you’re likely also setting `noEmit`? TypeScript’s type checking and module resolution behavior are affected by the module format that it *would* emit. Setting `module` gives TypeScript information about how your bundler or runtime will process imports and exports, which ensures that the types you see on imported values accurately reflect what will happen at runtime or after bundling. See [`--moduleResolution bundler`](#bundler) for more discussion.\n\n#### Examples\n\n``` ts\nimport x, { y, z } from \"mod\";\nimport mod = require(\"mod\");\nconst dynamic = import(\"mod\");\n\nexport const e1 = 0;\nexport default \"default export\";\n```\n\n``` js\nimport x, { y, z } from \"mod\";\nconst mod = require(\"mod\");\nconst dynamic = import(\"mod\");\n\nexport const e1 = 0;\nexport default \"default export\";\n```\n\n#### Implied and enforced options\n\n- `--module preserve` implies `--moduleResolution bundler`.\n- `--module preserve` implies `--esModuleInterop`.\n\n> The option `--esModuleInterop` is enabled by default in `--module preserve` only for its [type checking](appendices/esm-cjs-interop#allowsyntheticdefaultimports-and-esmoduleinterop) behavior. Since imports never transform into require calls in `--module preserve`, `--esModuleInterop` does not affect the emitted JavaScript.\n\n### `es2015`, `es2020`, `es2022`, `esnext`\n\n#### Summary\n\n- Use `esnext` with `--moduleResolution bundler` for bundlers, Bun, and tsx.\n- Do not use for Node.js. Use `node16` or `nodenext` with `\"type\": \"module\"` in package.json to emit ES modules for Node.js.\n- `import mod = require(\"mod\")` is not allowed in non-declaration files.\n- `es2020` adds support for `import.meta` properties.\n- `es2022` adds support for top-level `await`.\n- `esnext` is a moving target that may include support for Stage 3 proposals to ECMAScript modules.\n- Emitted files are ES modules, but dependencies may be any format.\n\n#### Examples\n\n``` ts\n// @Filename: main.ts\nimport x, { y, z } from \"mod\";\nimport * as mod from \"mod\";\nconst dynamic = import(\"mod\");\nconsole.log(x, y, z, mod, dynamic);\n\nexport const e1 = 0;\nexport default \"default export\";\n```\n\n``` js\n// @Filename: main.js\nimport x, { y, z } from \"mod\";\nimport * as mod from \"mod\";\nconst dynamic = import(\"mod\");\nconsole.log(x, y, z, mod, dynamic);\n\nexport const e1 = 0;\nexport default \"default export\";\n```\n\n### `commonjs`\n\n#### Summary\n\n- You probably shouldn’t use this. Use `node16` or `nodenext` to emit CommonJS modules for Node.js.\n- Emitted files are CommonJS modules, but dependencies may be any format.\n- Dynamic `import()` is transformed to a Promise of a `require()` call.\n- `esModuleInterop` affects the output code for default and namespace imports.\n\n#### Examples\n\n> Output is shown with `esModuleInterop: false`.\n\n``` ts\n// @Filename: main.ts\nimport x, { y, z } from \"mod\";\nimport * as mod from \"mod\";\nconst dynamic = import(\"mod\");\nconsole.log(x, y, z, mod, dynamic);\n\nexport const e1 = 0;\nexport default \"default export\";\n```\n\n``` js\n// @Filename: main.js\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.e1 = void 0;\nconst mod_1 = require(\"mod\");\nconst mod = require(\"mod\");\nconst dynamic = Promise.resolve().then(() => require(\"mod\"));\n\nconsole.log(mod_1.default, mod_1.y, mod_1.z, mod);\nexports.e1 = 0;\nexports.default = \"default export\";\n```\n\n``` ts\n// @Filename: main.ts\nimport mod = require(\"mod\");\nconsole.log(mod);\n\nexport = {\n    p1: true,\n    p2: false\n};\n```\n\n``` js\n// @Filename: main.js\n\"use strict\";\nconst mod = require(\"mod\");\nconsole.log(mod);\n\nmodule.exports = {\n    p1: true,\n    p2: false\n};\n```\n\n### `system`\n\n#### Summary\n\n- Designed for use with the [SystemJS module loader](https://github.com/systemjs/systemjs).\n\n#### Examples\n\n``` ts\n// @Filename: main.ts\nimport x, { y, z } from \"mod\";\nimport * as mod from \"mod\";\nconst dynamic = import(\"mod\");\nconsole.log(x, y, z, mod, dynamic);\n\nexport const e1 = 0;\nexport default \"default export\";\n```\n\n``` js\n// @Filename: main.js\nSystem.register([\"mod\"], function (exports_1, context_1) {\n    \"use strict\";\n    var mod_1, mod, dynamic, e1;\n    var __moduleName = context_1 && context_1.id;\n    return {\n        setters: [\n            function (mod_1_1) {\n                mod_1 = mod_1_1;\n                mod = mod_1_1;\n            }\n        ],\n        execute: function () {\n            dynamic = context_1.import(\"mod\");\n            console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);\n            exports_1(\"e1\", e1 = 0);\n            exports_1(\"default\", \"default export\");\n        }\n    };\n});\n```\n\n### `amd`\n\n#### Summary\n\n- Designed for AMD loaders like RequireJS.\n- You probably shouldn’t use this. Use a bundler instead.\n- Emitted files are AMD modules, but dependencies may be any format.\n- Supports `outFile`.\n\n#### Examples\n\n``` ts\n// @Filename: main.ts\nimport x, { y, z } from \"mod\";\nimport * as mod from \"mod\";\nconst dynamic = import(\"mod\");\nconsole.log(x, y, z, mod, dynamic);\n\nexport const e1 = 0;\nexport default \"default export\";\n```\n\n``` js\n// @Filename: main.js\ndefine([\"require\", \"exports\", \"mod\", \"mod\"], function (require, exports, mod_1, mod) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.e1 = void 0;\n    const dynamic = new Promise((resolve_1, reject_1) => { require([\"mod\"], resolve_1, reject_1); });\n\n    console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);\n    exports.e1 = 0;\n    exports.default = \"default export\";\n});\n```\n\n### `umd`\n\n#### Summary\n\n- Designed for AMD or CommonJS loaders.\n- Does not expose a global variable like most other UMD wrappers.\n- You probably shouldn’t use this. Use a bundler instead.\n- Emitted files are UMD modules, but dependencies may be any format.\n\n#### Examples\n\n``` ts\n// @Filename: main.ts\nimport x, { y, z } from \"mod\";\nimport * as mod from \"mod\";\nconst dynamic = import(\"mod\");\nconsole.log(x, y, z, mod, dynamic);\n\nexport const e1 = 0;\nexport default \"default export\";\n```\n\n``` js\n// @Filename: main.js\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"mod\", \"mod\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var __syncRequire = typeof module === \"object\" && typeof module.exports === \"object\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.e1 = void 0;\n    const mod_1 = require(\"mod\");\n    const mod = require(\"mod\");\n    const dynamic = __syncRequire ? Promise.resolve().then(() => require(\"mod\")) : new Promise((resolve_1, reject_1) => { require([\"mod\"], resolve_1, reject_1); });\n\n    console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);\n    exports.e1 = 0;\n    exports.default = \"default export\";\n});\n```\n\n## The `moduleResolution` compiler option\n\nThis section describes module resolution features and processes shared by multiple `moduleResolution` modes, then specifies the details of each mode. See the [*Module resolution*](theory#module-resolution) theory section for more background on what the option is and how it fits into the overall compilation process. In brief, `moduleResolution` controls how TypeScript resolves *module specifiers* (string literals in `import`/`export`/`require` statements) to files on disk, and should be set to match the module resolver used by the target runtime or bundler.\n\n### Common features and processes\n\n#### File extension substitution\n\nTypeScript always wants to resolve internally to a file that can provide type information, while ensuring that the runtime or bundler can use the same path to resolve to a file that provides a JavaScript implementation. For any module specifier that would, according to the `moduleResolution` algorithm specified, trigger a lookup of a JavaScript file in the runtime or bundler, TypeScript will first try to find a TypeScript implementation file or type declaration file with the same name and analagous file extension.\n\n| Runtime lookup | TypeScript lookup \\#1 | TypeScript lookup \\#2 | TypeScript lookup \\#3 | TypeScript lookup \\#4 | TypeScript lookup \\#5 |\n|----------------|-----------------------|-----------------------|-----------------------|-----------------------|-----------------------|\n| `/mod.js`      | `/mod.ts`             | `/mod.tsx`            | `/mod.d.ts`           | `/mod.js`             | `./mod.jsx`           |\n| `/mod.mjs`     | `/mod.mts`            | `/mod.d.mts`          | `/mod.mjs`            |                       |                       |\n| `/mod.cjs`     | `/mod.cts`            | `/mod.d.cts`          | `/mod.cjs`            |                       |                       |\n\nNote that this behavior is independent of the actual module specifier written in the import. This means that TypeScript can resolve to a `.ts` or `.d.ts` file even if the module specifier explicitly uses a `.js` file extension:\n\n``` ts\nimport x from \"./mod.js\";\n// Runtime lookup: \"./mod.js\"\n// TypeScript lookup #1: \"./mod.ts\"\n// TypeScript lookup #2: \"./mod.d.ts\"\n// TypeScript lookup #3: \"./mod.js\"\n```\n\nSee [*TypeScript imitates the host’s module resolution, but with types*](theory#typescript-imitates-the-hosts-module-resolution-but-with-types) for an explanation of why TypeScript’s module resolution works this way.\n\n#### Relative file path resolution\n\nAll of TypeScript’s `moduleResolution` algorithms support referencing a module by a relative path that includes a file extension (which will be substituted according to the [rules above](#file-extension-substitution)):\n\n``` ts\n// @Filename: a.ts\nexport {};\n\n// @Filename: b.ts\nimport {} from \"./a.js\"; // ✅ Works in every `moduleResolution`\n```\n\n#### Extensionless relative paths\n\nIn some cases, the runtime or bundler allows omitting a `.js` file extension from a relative path. TypeScript supports this behavior where the `moduleResolution` setting and the context indicate that the runtime or bundler supports it:\n\n``` ts\n// @Filename: a.ts\nexport {};\n\n// @Filename: b.ts\nimport {} from \"./a\";\n```\n\nIf TypeScript determines that the runtime will perform a lookup for `./a.js` given the module specifier `\"./a\"`, then `./a.js` will undergo [extension substitution](#file-extension-substitution), and resolve to the file `a.ts` in this example.\n\nExtensionless relative paths are not supported in `import` paths in Node.js, and are not always supported in file paths specified in package.json files. TypeScript currently never supports omitting a `.mjs`/`.mts` or `.cjs`/`.cts` file extension, even though some runtimes and bundlers do.\n\n#### Directory modules (index file resolution)\n\nIn some cases, a directory, rather than a file, can be referenced as a module. In the simplest and most common case, this involves the runtime or bundler looking for an `index.js` file in a directory. TypeScript supports this behavior where the `moduleResolution` setting and the context indicate that the runtime or bundler supports it:\n\n``` ts\n// @Filename: dir/index.ts\nexport {};\n\n// @Filename: b.ts\nimport {} from \"./dir\";\n```\n\nIf TypeScript determines that the runtime will perform a lookup for `./dir/index.js` given the module specifier `\"./dir\"`, then `./dir/index.js` will undergo [extension substitution](#file-extension-substitution), and resolve to the file `dir/index.ts` in this example.\n\nDirectory modules may also contain a package.json file, where resolution of the [`\"main\"` and `\"types\"`](#packagejson-main-and-types) fields are supported, and take precedence over `index.js` lookups. The [`\"typesVersions\"`](#packagejson-typesversions) field is also supported in directory modules.\n\nNote that directory modules are not the same as [`node_modules` packages](#node_modules-package-lookups) and only support a subset of the features available to packages, and are not supported at all in some contexts. Node.js considers them a [legacy feature](https://nodejs.org/dist/latest-v20.x/docs/api/modules.html#folders-as-modules).\n\n#### `paths`\n\n##### Overview\n\nTypeScript offers a way to override the compiler’s module resolution for bare specifiers with the `paths` compiler option. While the feature was originally designed to be used with the AMD module loader (a means of running modules in the browser before ESM existed or bundlers were widely used), it still has uses today when a runtime or bundler supports module resolution features that TypeScript does not model. For example, when running Node.js with `--experimental-network-imports`, you can manually specify a local type definition file for a specific `https://` import:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"module\": \"nodenext\",\n    \"paths\": {\n      \"https://esm.sh/lodash@4.17.21\": [\"./node_modules/@types/lodash/index.d.ts\"]\n    }\n  }\n}\n```\n\n``` ts\n// Typed by ./node_modules/@types/lodash/index.d.ts due to `paths` entry\nimport { add } from \"https://esm.sh/lodash@4.17.21\";\n```\n\nIt’s also common for apps built with bundlers to define convenience path aliases in their bundler configuration, and then inform TypeScript of those aliases with `paths`:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"paths\": {\n      \"@app/*\": [\"./src/*\"]\n    }\n  }\n}\n```\n\n##### `paths` does not affect emit\n\nThe `paths` option does *not* change the import path in the code emitted by TypeScript. Consequently, it’s very easy to create path aliases that appear to work in TypeScript but will crash at runtime:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"module\": \"nodenext\",\n    \"paths\": {\n      \"node-has-no-idea-what-this-is\": [\"./oops.ts\"]\n    }\n  }\n}\n```\n\n``` ts\n// TypeScript: ✅\n// Node.js: 💥\nimport {} from \"node-has-no-idea-what-this-is\";\n```\n\nWhile it’s ok for bundled apps to set up `paths`, it’s very important that published libraries do *not*, since the emitted JavaScript will not work for consumers of the library without those users setting up the same aliases for both TypeScript and their bundler. Both libraries and apps can consider [package.json `\"imports\"`](#packagejson-imports-and-self-name-imports) as a standard replacement for convenience `paths` aliases.\n\n##### `paths` should not point to monorepo packages or node_modules packages\n\nWhile module specifiers that match `paths` aliases are bare specifiers, once the alias is resolved, module resolution proceeds on the resolved path as a relative path. Consequently, resolution features that happen for [`node_modules` package lookups](#node_modules-package-lookups), including package.json `\"exports\"` field support, do not take effect when a `paths` alias is matched. This can lead to surprising behavior if `paths` is used to point to a `node_modules` package:\n\n``` ts\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"pkg\": [\"./node_modules/pkg/dist/index.d.ts\"],\n      \"pkg/*\": [\"./node_modules/pkg/*\"]\n    }\n  }\n}\n```\n\nWhile this configuration may simulate some of the behavior of package resolution, it overrides any `main`, `types`, `exports`, and `typesVersions` the package’s `package.json` file defines, and imports from the package may fail at runtime.\n\nThe same caveat applies to packages referencing each other in a monorepo. Instead of using `paths` to make TypeScript artificially resolve `\"@my-scope/lib\"` to a sibling package, it’s best to use workspaces via [npm](https://docs.npmjs.com/cli/v7/using-npm/workspaces), [yarn](https://classic.yarnpkg.com/en/docs/workspaces/), or [pnpm](https://pnpm.io/workspaces) to symlink your packages into `node_modules`, so both TypeScript and the runtime or bundler perform real `node_modules` package lookups. This is especially important if the monorepo packages will be published to npm—the packages will reference each other via `node_modules` package lookups once installed by users, and using workspaces allows you to test that behavior during local development.\n\n##### Relationship to `baseUrl`\n\nWhen [`baseUrl`](#baseurl) is provided, the values in each `paths` array are resolved relative to the `baseUrl`. Otherwise, they are resolved relative to the `tsconfig.json` file that defines them.\n\n##### Wildcard substitutions\n\n`paths` patterns can contain a single `*` wildcard, which matches any string. The `*` token can then be used in the file path values to substitute the matched string:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@app/*\": [\"./src/*\"]\n    }\n  }\n}\n```\n\nWhen resolving an import of `\"@app/components/Button\"`, TypeScript will match on `@app/*`, binding `*` to `components/Button`, and then attempt to resolve the path `./src/components/Button` relative to the `tsconfig.json` path. The remainder of this lookup will follow the same rules as any other [relative path lookup](#relative-file-path-resolution) according to the `moduleResolution` setting.\n\nWhen multiple patterns match a module specifier, the pattern with the longest matching prefix before any `*` token is used:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"*\": [\"./src/foo/one.ts\"],\n      \"foo/*\": [\"./src/foo/two.ts\"],\n      \"foo/bar\": [\"./src/foo/three.ts\"]\n    }\n  }\n}\n```\n\nWhen resolving an import of `\"foo/bar\"`, all three `paths` patterns match, but the last is used because `\"foo/bar\"` is longer than `\"foo/\"` and `\"\"`.\n\n##### Fallbacks\n\nMultiple file paths can be provided for a path mapping. If resolution fails for one path, the next one in the array will be attempted until resolution succeeds or the end of the array is reached.\n\n``` json\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"*\": [\"./vendor/*\", \"./types/*\"]\n    }\n  }\n}\n```\n\n#### `baseUrl`\n\n> `baseUrl` was designed for use with AMD module loaders. If you aren’t using an AMD module loader, you probably shouldn’t use `baseUrl`. Since TypeScript 4.1, `baseUrl` is no longer required to use [`paths`](#paths) and should not be used just to set the directory `paths` values are resolved from.\n\nThe `baseUrl` compiler option can be combined with any `moduleResolution` mode and specifies a directory that bare specifiers (module specifiers that don’t begin with `./`, `../`, or `/`) are resolved from. `baseUrl` has a higher precedence than [`node_modules` package lookups](#node_modules-package-lookups) in `moduleResolution` modes that support them.\n\nWhen performing a `baseUrl` lookup, resolution proceeds with the same rules as other relative path resolutions. For example, in a `moduleResolution` mode that supports [extensionless relative paths](#extensionless-relative-paths) a module specifier `\"some-file\"` may resolve to `/src/some-file.ts` if `baseUrl` is set to `/src`.\n\nResolution of relative module specifiers are never affected by the `baseUrl` option.\n\n#### `node_modules` package lookups\n\nNode.js treats module specifiers that aren’t relative paths, absolute paths, or URLs as references to packages that it looks up in `node_modules` subdirectories. Bundlers conveniently adopted this behavior to allow their users to use the same dependency management system, and often even the same dependencies, as they would in Node.js. All of TypeScript’s `moduleResolution` options except `classic` support `node_modules` lookups. (`classic` supports lookups in `node_modules/@types` when other means of resolution fail, but never looks for packages in `node_modules` directly.) Every `node_modules` package lookup has the following structure (beginning after higher precedence bare specifier rules, like `paths`, `baseUrl`, self-name imports, and package.json `\"imports\"` lookups have been exhausted):\n\n1.  For each ancestor directory of the importing file, if a `node_modules` directory exists within it:\n    1.  If a directory with the same name as the package exists within `node_modules`:\n        1.  Attempt to resolve types from the package directory.\n        2.  If a result is found, return it and stop the search.\n    2.  If a directory with the same name as the package exists within `node_modules/@types`:\n        1.  Attempt to resolve types from the `@types` package directory.\n        2.  If a result is found, return it and stop the search.\n2.  Repeat the previous search through all `node_modules` directories, but this time, allow JavaScript files as a result, and do not search in `@types` directories.\n\nAll `moduleResolution` modes (except `classic`) follow this pattern, while the details of how they resolve from a package directory, once located, differ, and are explained in the following sections.\n\n#### package.json `\"exports\"`\n\nWhen `moduleResolution` is set to `node16`, `nodenext`, or `bundler`, and `resolvePackageJsonExports` is not disabled, TypeScript follows Node.js’s [package.json `\"exports\"` spec](https://nodejs.org/api/packages.html#packages_package_entry_points) when resolving from a package directory triggered by a [bare specifier `node_modules` package lookup](#node_modules-package-lookups).\n\nTypeScript’s implementation for resolving a module specifier through `\"exports\"` to a file path follows Node.js exactly. Once a file path is resolved, however, TypeScript will still [try multiple file extensions](#file-extension-substitution) in order to prioritize finding types.\n\nWhen resolving through [conditional `\"exports\"`](https://nodejs.org/api/packages.html#conditional-exports), TypeScript always matches the `\"types\"` and `\"default\"` conditions if present. Additionally, TypeScript will match a versioned types condition in the form `\"types@{selector}\"` (where `{selector}` is a `\"typesVersions\"`-compatible version selector) according to the same version-matching rules implemented in [`\"typesVersions\"`](#packagejson-typesversions). Other non-configurable conditions are dependent on the `moduleResolution` mode and specified in the following sections. Additional conditions can be configured to match with the `customConditions` compiler option.\n\nNote that the presence of `\"exports\"` prevents any subpaths not explicitly listed or matched by a pattern in `\"exports\"` from being resolved.\n\n##### Example: subpaths, conditions, and extension substitution\n\nScenario: `\"pkg/subpath\"` is requested with conditions `[\"types\", \"node\", \"require\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\n``` json\n{\n  \"name\": \"pkg\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./index.mjs\",\n      \"require\": \"./index.cjs\"\n    },\n    \"./subpath\": {\n      \"import\": \"./subpath/index.mjs\",\n      \"require\": \"./subpath/index.cjs\"\n    }\n  }\n}\n```\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  Does `\"exports\"` have a `\"./subpath\"` entry? **Yes.**\n3.  The value at `exports[\"./subpath\"]` is an object—it must be specifying conditions.\n4.  Does the first condition `\"import\"` match this request? **No.**\n5.  Does the second condition `\"require\"` match this request? **Yes.**\n6.  Does the path `\"./subpath/index.cjs\"` have a recognized TypeScript file extension? **No, so use extension substitution.**\n7.  Via [extension substitution](#file-extension-substitution), try the following paths, returning the first one that exists, or `undefined` otherwise:\n    1.  `./subpath/index.cts`\n    2.  `./subpath/index.d.cts`\n    3.  `./subpath/index.cjs`\n\nIf `./subpath/index.cts` or `./subpath.d.cts` exists, resolution is complete. Otherwise, resolution searches `node_modules/@types/pkg` and other `node_modules` directories in an attempt to resolve types, according to the [`node_modules` package lookups](#node_modules-package-lookups) rules. If no types are found, a second pass through all `node_modules` resolves to `./subpath/index.cjs` (assuming it exists), which counts as a successful resolution, but one that does not provide types, leading to `any`-typed imports and a `noImplicitAny` error if enabled.\n\n##### Example: explicit `\"types\"` condition\n\nScenario: `\"pkg/subpath\"` is requested with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\n``` json\n{\n  \"name\": \"pkg\",\n  \"exports\": {\n    \"./subpath\": {\n      \"import\": {\n        \"types\": \"./types/subpath/index.d.mts\",\n        \"default\": \"./es/subpath/index.mjs\"\n      },\n      \"require\": {\n        \"types\": \"./types/subpath/index.d.cts\",\n        \"default\": \"./cjs/subpath/index.cjs\"\n      }\n    }\n  }\n}\n```\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  Does `\"exports\"` have a `\"./subpath\"` entry? **Yes.**\n3.  The value at `exports[\"./subpath\"]` is an object—it must be specifying conditions.\n4.  Does the first condition `\"import\"` match this request? **Yes.**\n5.  The value at `exports[\"./subpath\"].import` is an object—it must be specifying conditions.\n6.  Does the first condition `\"types\"` match this request? **Yes.**\n7.  Does the path `\"./types/subpath/index.d.mts\"` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n8.  Return the path `\"./types/subpath/index.d.mts\"` if the file exists, `undefined` otherwise.\n\n##### Example: versioned `\"types\"` condition\n\nScenario: using TypeScript 4.7.5, `\"pkg/subpath\"` is requested with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\n``` json\n{\n  \"name\": \"pkg\",\n  \"exports\": {\n    \"./subpath\": {\n      \"types@>=5.2\": \"./ts5.2/subpath/index.d.ts\",\n      \"types@>=4.6\": \"./ts4.6/subpath/index.d.ts\",\n      \"types\": \"./tsold/subpath/index.d.ts\",\n      \"default\": \"./dist/subpath/index.js\"\n    }\n  }\n}\n```\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  Does `\"exports\"` have a `\"./subpath\"` entry? **Yes.**\n3.  The value at `exports[\"./subpath\"]` is an object—it must be specifying conditions.\n4.  Does the first condition `\"types@>=5.2\"` match this request? **No, 4.7.5 is not greater than or equal to 5.2.**\n5.  Does the second condition `\"types@>=4.6\"` match this request? **Yes, 4.7.5 is greater than or equal to 4.6.**\n6.  Does the path `\"./ts4.6/subpath/index.d.ts\"` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n7.  Return the path `\"./ts4.6/subpath/index.d.ts\"` if the file exists, `undefined` otherwise.\n\n##### Example: subpath patterns\n\nScenario: `\"pkg/wildcard.js\"` is requested with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\n``` json\n{\n  \"name\": \"pkg\",\n  \"type\": \"module\",\n  \"exports\": {\n    \"./*.js\": {\n      \"types\": \"./types/*.d.ts\",\n      \"default\": \"./dist/*.js\"\n    }\n  }\n}\n```\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  Does `\"exports\"` have a `\"./wildcard.js\"` entry? **No.**\n3.  Does any key with a `*` in it match `\"./wildcard.js\"`? **Yes, `\"./*.js\"` matches and sets `wildcard` to be the substitution.**\n4.  The value at `exports[\"./*.js\"]` is an object—it must be specifying conditions.\n5.  Does the first condition `\"types\"` match this request? **Yes.**\n6.  In `./types/*.d.ts`, replace `*` with the substitution `wildcard`. **`./types/wildcard.d.ts`**\n7.  Does the path `\"./types/wildcard.d.ts\"` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n8.  Return the path `\"./types/wildcard.d.ts\"` if the file exists, `undefined` otherwise.\n\n##### Example: `\"exports\"` block other subpaths\n\nScenario: `\"pkg/dist/index.js\"` is requested in a package directory with the following package.json:\n\n``` json\n{\n  \"name\": \"pkg\",\n  \"main\": \"./dist/index.js\",\n  \"exports\": \"./dist/index.js\"\n}\n```\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  The value at `exports` is a string—it must be a file path for the package root (`\".\"`).\n3.  Is the request `\"pkg/dist/index.js\"` for the package root? **No, it has a subpath `dist/index.js`.**\n4.  Resolution fails; return `undefined`.\n\nWithout `\"exports\"`, the request could have succeeded, but the presence of `\"exports\"` prevents resolving any subpaths that cannot be matched through `\"exports\"`.\n\n#### package.json `\"typesVersions\"`\n\nA [`node_modules` package](#node_modules-package-lookups) or [directory module](#directory-modules-index-file-resolution) may specify a `\"typesVersions\"` field in its package.json to redirect TypeScript’s resolution process according to the TypeScript compiler version, and for `node_modules` packages, according to the subpath being resolved. This allows package authors to include new TypeScript syntax in one set of type definitions while providing another set for backward compatibility with older TypeScript versions (through a tool like [downlevel-dts](https://github.com/sandersn/downlevel-dts)). `\"typesVersions\"` is supported in all `moduleResolution` modes; however, the field is not read in situations when [package.json `\"exports\"`](#packagejson-exports) are read.\n\n##### Example: redirect all requests to a subdirectory\n\nScenario: a module imports `\"pkg\"` using TypeScript 5.2, where `node_modules/pkg/package.json` is:\n\n``` json\n{\n  \"name\": \"pkg\",\n  \"version\": \"1.0.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    \">=3.1\": {\n      \"*\": [\"ts3.1/*\"]\n    }\n  }\n}\n```\n\nResolution process:\n\n1.  (Depending on compiler options) Does `\"exports\"` exist? **No.**\n2.  Does `\"typesVersions\"` exist? **Yes.**\n3.  Is the TypeScript version `>=3.1`? **Yes. Remember the mapping `\"*\": [\"ts3.1/*\"]`.**\n4.  Are we resolving a subpath after the package name? **No, just the root `\"pkg\"`.**\n5.  Does `\"types\"` exist? **Yes.**\n6.  Does any key in `\"typesVersions\"` match `./index.d.ts`? **Yes, `\"*\"` matches and sets `index.d.ts` to be the substitution.**\n7.  In `ts3.1/*`, replace `*` with the substitution `./index.d.ts`: **`ts3.1/index.d.ts`**.\n8.  Does the path `./ts3.1/index.d.ts` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n9.  Return the path `./ts3.1/index.d.ts` if the file exists, `undefined` otherwise.\n\n##### Example: redirect requests for a specific file\n\nScenario: a module imports `\"pkg\"` using TypeScript 3.9, where `node_modules/pkg/package.json` is:\n\n``` json\n{\n  \"name\": \"pkg\",\n  \"version\": \"1.0.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    \"<4.0\": { \"index.d.ts\": [\"index.v3.d.ts\"] }\n  }\n}\n```\n\nResolution process:\n\n1.  (Depending on compiler options) Does `\"exports\"` exist? **No.**\n2.  Does `\"typesVersions\"` exist? **Yes.**\n3.  Is the TypeScript version `<4.0`? **Yes. Remember the mapping `\"index.d.ts\": [\"index.v3.d.ts\"]`.**\n4.  Are we resolving a subpath after the package name? **No, just the root `\"pkg\"`.**\n5.  Does `\"types\"` exist? **Yes.**\n6.  Does any key in `\"typesVersions\"` match `./index.d.ts`? **Yes, `\"index.d.ts\"` matches.**\n7.  Does the path `./index.v3.d.ts` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n8.  Return the path `./index.v3.d.ts` if the file exists, `undefined` otherwise.\n\n#### package.json `\"main\"` and `\"types\"`\n\nIf a directory’s [package.json `\"exports\"`](#packagejson-exports) field is not read (either due to compiler options, or because it is not present, or because the directory is being resolved as a [directory module](#directory-modules-index-file-resolution) instead of a [`node_modules` package](#node_modules-package-lookups)) and the module specifier does not have a subpath after the package name or package.json-containing directory, TypeScript will attempt to resolve from these package.json fields, in order, in an attempt to find the main module for the package or directory:\n\n- `\"types\"`\n- `\"typings\"` (legacy)\n- `\"main\"`\n\nThe declaration file found at `\"types\"` is assumed to be an accurate representation of the implementation file found at `\"main\"`. If `\"types\"` and `\"typings\"` are not present or cannot be resolved, TypeScript will read the `\"main\"` field and perform [extension substitution](#file-extension-substitution) to find a declaration file.\n\nWhen publishing a typed package to npm, it’s recommended to include a `\"types\"` field even if [extension substitution](#file-extension-substitution) or [package.json `\"exports\"`](#packagejson-exports) make it unnecessary, because npm shows a TS icon on the package registry listing only if the package.json contains a `\"types\"` field.\n\n#### Package-relative file paths\n\nIf neither [package.json `\"exports\"`](#packagejson-exports) nor [package.json `\"typesVersions\"`](#packagejson-typesversions) apply, subpaths of a bare package specifier resolve relative to the package directory, according to applicable [relative path](#relative-file-path-resolution) resolution rules. In modes that respect \\[package.json `\"exports\"`\\], this behavior is blocked by the mere presence of the `\"exports\"` field in the package’s package.json, even if the import fails to resolve through `\"exports\"`, as demonstrated in [an example above](#example-exports-block-other-subpaths). On the other hand, if the import fails to resolve through `\"typesVersions\"`, a package-relative file path resolution is attempted as a fallback.\n\nWhen package-relative paths are supported, they resolve under the same rules as any other relative path considering the `moduleResolution` mode and context. For example, in [`--moduleResolution nodenext`](#node16-nodenext-1), [directory modules](#directory-modules-index-file-resolution) and [extensionless paths](#extensionless-relative-paths) are only supported in `require` calls, not in `import`s:\n\n``` ts\n// @Filename: module.mts\nimport \"pkg/dist/foo\";                // ❌ import, needs `.js` extension\nimport \"pkg/dist/foo.js\";             // ✅\nimport foo = require(\"pkg/dist/foo\"); // ✅ require, no extension needed\n```\n\n#### package.json `\"imports\"` and self-name imports\n\nWhen `moduleResolution` is set to `node16`, `nodenext`, or `bundler`, and `resolvePackageJsonImports` is not disabled, TypeScript will attempt to resolve import paths beginning with `#` through the `\"imports\"` field of the nearest ancestor package.json of the importing file. Similarly, when [package.json `\"exports\"` lookups](#packagejson-exports) are enabled, TypeScript will attempt to resolve import paths beginning with the current package name—that is, the value in the `\"name\"` field of the nearest ancestor package.json of the importing file—through the `\"exports\"` field of that package.json. Both of these features allow files in a package to import other files in the same package, replacing a relative import path.\n\nTypeScript follows Node.js’s resolution algorithm for [`\"imports\"`](https://nodejs.org/api/packages.html#subpath-imports) and [self references](https://nodejs.org/api/packages.html#self-referencing-a-package-using-its-name) exactly up until a file path is resolved. At that point, TypeScript’s resolution algorithm forks based on whether the package.json containing the `\"imports\"` or `\"exports\"` being resolved belongs to a `node_modules` dependency or the local project being compiled (i.e., its directory contains the tsconfig.json file for the project that contains the importing file):\n\n- If the package.json is in `node_modules`, TypeScript will apply [extension substitution](#file-extension-substitution) to the file path if it doesn’t already have a recognized TypeScript file extension, and check for the existence of the resulting file paths.\n- If the package.json is part of the local project, an additional remapping step is performed in order to find the *input* TypeScript implementation file that will eventually produce the output JavaScript or declaration file path that was resolved from `\"imports\"`. Without this step, any compilation that resolves an `\"imports\"` path would be referencing output files from the *previous compilation* instead of other input files that are intended to be included in the current compilation. This remapping uses the `outDir`/`declarationDir` and `rootDir` from the tsconfig.json, so using `\"imports\"` usually requires an explicit `rootDir` to be set.\n\nThis variation allows package authors to write `\"imports\"` and `\"exports\"` fields that reference only the compilation outputs that will be published to npm, while still allowing local development to use the original TypeScript source files.\n\n##### Example: local project with conditions\n\nScenario: `\"/src/main.mts\"` imports `\"#utils\"` with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a project directory with a tsconfig.json and package.json:\n\n``` json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"moduleResolution\": \"node16\",\n    \"resolvePackageJsonImports\": true,\n    \"rootDir\": \"./src\",\n    \"outDir\": \"./dist\"\n  }\n}\n```\n\n``` json\n// package.json\n{\n  \"name\": \"pkg\",\n  \"imports\": {\n    \"#utils\": {\n      \"import\": \"./dist/utils.d.mts\",\n      \"require\": \"./dist/utils.d.cts\"\n    }\n  }\n}\n```\n\nResolution process:\n\n1.  Import path starts with `#`, try to resolve through `\"imports\"`.\n2.  Does `\"imports\"` exist in the nearest ancestor package.json? **Yes.**\n3.  Does `\"#utils\"` exist in the `\"imports\"` object? **Yes.**\n4.  The value at `imports[\"#utils\"]` is an object—it must be specifying conditions.\n5.  Does the first condition `\"import\"` match this request? **Yes.**\n6.  Should we attempt to map the output path to an input path? **Yes, because:**\n    - Is the package.json in `node_modules`? **No, it’s in the local project.**\n    - Is the tsconfig.json within the package.json directory? **Yes.**\n7.  In `./dist/utils.d.mts`, replace the `outDir` prefix with `rootDir`. **`./src/utils.d.mts`**\n8.  Replace the output extension `.d.mts` with the corresponding input extension `.mts`. **`./src/utils.mts`**\n9.  Return the path `\"./src/utils.mts\"` if the file exists.\n10. Otherwise, return the path `\"./dist/utils.d.mts\"` if the file exists.\n\n##### Example: `node_modules` dependency with subpath pattern\n\nScenario: `\"/node_modules/pkg/main.mts\"` imports `\"#internal/utils\"` with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) with the package.json:\n\n``` json\n// /node_modules/pkg/package.json\n{\n  \"name\": \"pkg\",\n  \"imports\": {\n    \"#internal/*\": {\n      \"import\": \"./dist/internal/*.mjs\",\n      \"require\": \"./dist/internal/*.cjs\"\n    }\n  }\n}\n```\n\nResolution process:\n\n1.  Import path starts with `#`, try to resolve through `\"imports\"`.\n2.  Does `\"imports\"` exist in the nearest ancestor package.json? **Yes.**\n3.  Does `\"#internal/utils\"` exist in the `\"imports\"` object? **No, check for pattern matches.**\n4.  Does any key with a `*` match `\"#internal/utils\"`? **Yes, `\"#internal/*\"` matches and sets `utils` to be the substitution.**\n5.  The value at `imports[\"#internal/*\"]` is an object—it must be specifying conditions.\n6.  Does the first condition `\"import\"` match this request? **Yes.**\n7.  Should we attempt to map the output path to an input path? **No, because the package.json is in `node_modules`.**\n8.  In `./dist/internal/*.mjs`, replace `*` with the substitution `utils`. **`./dist/internal/utils.mjs`**\n9.  Does the path `./dist/internal/utils.mjs` have a recognized TypeScript file extension? **No, try extension substitution.**\n10. Via [extension substitution](#file-extension-substitution), try the following paths, returning the first one that exists, or `undefined` otherwise:\n    1.  `./dist/internal/utils.mts`\n    2.  `./dist/internal/utils.d.mts`\n    3.  `./dist/internal/utils.mjs`\n\n### `node16`, `nodenext`\n\nThese modes reflect the module resolution behavior of Node.js v12 and later. (`node16` and `nodenext` are currently identical, but if Node.js makes significant changes to its module system in the future, `node16` will be frozen while `nodenext` will be updated to reflect the new behavior.) In Node.js, the resolution algorithm for ECMAScript imports is significantly different from the algorithm for CommonJS `require` calls. For each module specifier being resolved, the syntax and the [module format of the importing file](#module-format-detection) are first used to determine whether the module specifier will be in an `import` or `require` in the emitted JavaScript. That information is then passed into the module resolver to determine which resolution algorithm to use (and whether to use the `\"import\"` or `\"require\"` condition for package.json [`\"exports\"`](#packagejson-exports) or [`\"imports\"`](#packagejson-imports-and-self-name-imports)).\n\n> TypeScript files that are [determined to be in CommonJS format](#module-format-detection) may still use `import` and `export` syntax by default, but the emitted JavaScript will use `require` and `module.exports` instead. This means that it’s common to see `import` statements that are resolved using the `require` algorithm. If this causes confusion, the `verbatimModuleSyntax` compiler option can be enabled, which prohibits the use of `import` statements that would be emitted as `require` calls.\n\nNote that dynamic `import()` calls are always resolved using the `import` algorithm, according to Node.js’s behavior. However, `import()` types are resolved according to the format of the importing file (for backward compatibility with existing CommonJS-format type declarations):\n\n``` ts\n// @Filename: module.mts\nimport x from \"./mod.js\";             // `import` algorithm due to file format (emitted as-written)\nimport(\"./mod.js\");                   // `import` algorithm due to syntax (emitted as-written)\ntype Mod = typeof import(\"./mod.js\"); // `import` algorithm due to file format\nimport mod = require(\"./mod\");        // `require` algorithm due to syntax (emitted as `require`)\n\n// @Filename: commonjs.cts\nimport x from \"./mod\";                // `require` algorithm due to file format (emitted as `require`)\nimport(\"./mod.js\");                   // `import` algorithm due to syntax (emitted as-written)\ntype Mod = typeof import(\"./mod\");    // `require` algorithm due to file format\nimport mod = require(\"./mod\");        // `require` algorithm due to syntax (emitted as `require`)\n```\n\n#### Implied and enforced options\n\n- `--moduleResolution node16` and `nodenext` must be paired with their [corresponding `module` value](#node16-nodenext).\n\n#### Supported features\n\nFeatures are listed in order of precedence.\n\n|                                                                                              | `import`                             | `require`                             |\n|----------------------------------------------------------------------------------------------|--------------------------------------|---------------------------------------|\n| [`paths`](#paths)                                                                            | ✅                                   | ✅                                    |\n| [`baseUrl`](#baseurl)                                                                        | ✅                                   | ✅                                    |\n| [`node_modules` package lookups](#node_modules-package-lookups)                              | ✅                                   | ✅                                    |\n| [package.json `\"exports\"`](#packagejson-exports)                                             | ✅ matches `types`, `node`, `import` | ✅ matches `types`, `node`, `require` |\n| [package.json `\"imports\"` and self-name imports](#packagejson-imports-and-self-name-imports) | ✅ matches `types`, `node`, `import` | ✅ matches `types`, `node`, `require` |\n| [package.json `\"typesVersions\"`](#packagejson-typesversions)                                 | ✅                                   | ✅                                    |\n| [Package-relative paths](#package-relative-file-paths)                                       | ✅ when `exports` not present        | ✅ when `exports` not present         |\n| [Full relative paths](#relative-file-path-resolution)                                        | ✅                                   | ✅                                    |\n| [Extensionless relative paths](#extensionless-relative-paths)                                | ❌                                   | ✅                                    |\n| [Directory modules](#directory-modules-index-file-resolution)                                | ❌                                   | ✅                                    |\n\n### `bundler`\n\n`--moduleResolution bundler` attempts to model the module resolution behavior common to most JavaScript bundlers. In short, this means supporting all the behaviors traditionally associated with Node.js’s CommonJS `require` resolution algorithm like [`node_modules` lookups](#node_modules-package-lookups), [directory modules](#directory-modules-index-file-resolution), and [extensionless paths](#extensionless-relative-paths), while also supporting newer Node.js resolution features like [package.json `\"exports\"`](#packagejson-exports) and [package.json `\"imports\"`](#packagejson-imports-and-self-name-imports).\n\nIt’s instructive to think about the similarities and differences between `--moduleResolution bundler` and `--moduleResolution nodenext`, particularly in how they decide what conditions to use when resolving package.json `\"exports\"` or `\"imports\"`. Consider an import statement in a `.ts` file:\n\n``` ts\n// index.ts\nimport { foo } from \"pkg\";\n```\n\nRecall that in `--module nodenext --moduleResolution nodenext`, the `--module` setting first [determines](#module-format-detection) whether the import will be emitted to the `.js` file as an `import` or `require` call, then passes that information to TypeScript’s module resolver, which decides whether to match `\"import\"` or `\"require\"` conditions in `\"pkg\"`’s package.json `\"exports\"` accordingly. Let’s assume that there’s no package.json in scope of this file. The file extension is `.ts`, so the output file extension will be `.js`, which Node.js will interpret as CommonJS, so TypeScript will emit this `import` as a `require` call. So, the module resolver will use the `require` condition as it resolves `\"exports\"` from `\"pkg\"`.\n\nThe same process happens in `--moduleResolution bundler`, but the rules for deciding whether to emit an `import` or `require` call for this import statement will be different, since `--moduleResolution bundler` necessitates using [`--module esnext`](#es2015-es2020-es2022-esnext) or [`--module preserve`](#preserve). In both of those modes, ESM `import` declarations always emit as ESM `import` declarations, so TypeScript’s module resolver will receive that information and use the `\"import\"` condition as it resolves `\"exports\"` from `\"pkg\"`.\n\nThis explanation may be somewhat unintuitive, since `--moduleResolution bundler` is usually used in combination with `--noEmit`—bundlers typically process raw `.ts` files and perform module resolution on untransformed `import`s or `require`s. However, for consistency, TypeScript still uses the hypothetical emit decided by `module` to inform module resolution and type checking. This makes [`--module preserve`](#preserve) the best choice whenever a runtime or bundler is operating on raw `.ts` files, since it implies no transformation. Under `--module preserve --moduleResolution bundler`, you can write imports and requires in the same file that will resolve with the `import` and `require` conditions, respectively:\n\n``` ts\n// index.ts\nimport pkg1 from \"pkg\";       // Resolved with \"import\" condition\nimport pkg2 = require(\"pkg\"); // Resolved with \"require\" condition\n```\n\n#### Implied and enforced options\n\n- `--moduleResolution bundler` must be paired with `--module esnext` or `--module preserve`.\n- `--moduleResolution bundler` implies `--allowSyntheticDefaultImports`.\n\n#### Supported features\n\n- [`paths`](#paths) ✅\n- [`baseUrl`](#baseurl) ✅\n- [`node_modules` package lookups](#node_modules-package-lookups) ✅\n- [package.json `\"exports\"`](#packagejson-exports) ✅ matches `types`, `import`/`require` depending on syntax\n- [package.json `\"imports\"` and self-name imports](#packagejson-imports-and-self-name-imports) ✅ matches `types`, `import`/`require` depending on syntax\n- [package.json `\"typesVersions\"`](#packagejson-typesversions) ✅\n- [Package-relative paths](#package-relative-file-paths) ✅ when `exports` not present\n- [Full relative paths](#relative-file-path-resolution) ✅\n- [Extensionless relative paths](#extensionless-relative-paths) ✅\n- [Directory modules](#directory-modules-index-file-resolution) ✅\n\n### `node10` (formerly known as `node`)\n\n`--moduleResolution node` was renamed to `node10` (keeping `node` as an alias for backward compatibility) in TypeScript 5.0. It reflects the CommonJS module resolution algorithm as it existed in Node.js versions earlier than v12. It should no longer be used.\n\n#### Supported features\n\n- [`paths`](#paths) ✅\n- [`baseUrl`](#baseurl) ✅\n- [`node_modules` package lookups](#node_modules-package-lookups) ✅\n- [package.json `\"exports\"`](#packagejson-exports) ❌\n- [package.json `\"imports\"` and self-name imports](#packagejson-imports-and-self-name-imports) ❌\n- [package.json `\"typesVersions\"`](#packagejson-typesversions) ✅\n- [Package-relative paths](#package-relative-file-paths) ✅\n- [Full relative paths](#relative-file-path-resolution) ✅\n- [Extensionless relative paths](#extensionless-relative-paths) ✅\n- [Directory modules](#directory-modules-index-file-resolution) ✅\n\n### `classic`\n\nDo not use `classic`.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/modules/reference.html](https://www.typescriptlang.org/docs/handbook/modules/reference.html)"
- name: 'Modules - Reference: amd'
  id: modules/reference#amd
  summary: null
  belongs_to: Modules - Reference
  description: |-
    ### `amd`

    #### Summary

    - Designed for AMD loaders like RequireJS.
    - You probably shouldn’t use this. Use a bundler instead.
    - Emitted files are AMD modules, but dependencies may be any format.
    - Supports `outFile`.

    #### Examples

    ``` ts
    // @Filename: main.ts
    import x, { y, z } from "mod";
    import * as mod from "mod";
    const dynamic = import("mod");
    console.log(x, y, z, mod, dynamic);

    export const e1 = 0;
    export default "default export";
    ```

    ``` js
    // @Filename: main.js
    define(["require", "exports", "mod", "mod"], function (require, exports, mod_1, mod) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.e1 = void 0;
        const dynamic = new Promise((resolve_1, reject_1) => { require(["mod"], resolve_1, reject_1); });

        console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);
        exports.e1 = 0;
        exports.default = "default export";
    });
    ```
- name: 'Modules - Reference: bundler'
  id: modules/reference#bundler
  summary: --moduleResolution bundler attempts to model the module resolution behavior common to most JavaScript bundlers
  belongs_to: Modules - Reference
  description: |-
    ### `bundler`

    `--moduleResolution bundler` attempts to model the module resolution behavior common to most JavaScript bundlers. In short, this means supporting all the behaviors traditionally associated with Node.js’s CommonJS `require` resolution algorithm like [`node_modules` lookups](#node_modules-package-lookups), [directory modules](#directory-modules-index-file-resolution), and [extensionless paths](#extensionless-relative-paths), while also supporting newer Node.js resolution features like [package.json `"exports"`](#packagejson-exports) and [package.json `"imports"`](#packagejson-imports-and-self-name-imports).

    It’s instructive to think about the similarities and differences between `--moduleResolution bundler` and `--moduleResolution nodenext`, particularly in how they decide what conditions to use when resolving package.json `"exports"` or `"imports"`. Consider an import statement in a `.ts` file:

    ``` ts
    // index.ts
    import { foo } from "pkg";
    ```

    Recall that in `--module nodenext --moduleResolution nodenext`, the `--module` setting first [determines](#module-format-detection) whether the import will be emitted to the `.js` file as an `import` or `require` call, then passes that information to TypeScript’s module resolver, which decides whether to match `"import"` or `"require"` conditions in `"pkg"`’s package.json `"exports"` accordingly. Let’s assume that there’s no package.json in scope of this file. The file extension is `.ts`, so the output file extension will be `.js`, which Node.js will interpret as CommonJS, so TypeScript will emit this `import` as a `require` call. So, the module resolver will use the `require` condition as it resolves `"exports"` from `"pkg"`.

    The same process happens in `--moduleResolution bundler`, but the rules for deciding whether to emit an `import` or `require` call for this import statement will be different, since `--moduleResolution bundler` necessitates using [`--module esnext`](#es2015-es2020-es2022-esnext) or [`--module preserve`](#preserve). In both of those modes, ESM `import` declarations always emit as ESM `import` declarations, so TypeScript’s module resolver will receive that information and use the `"import"` condition as it resolves `"exports"` from `"pkg"`.

    This explanation may be somewhat unintuitive, since `--moduleResolution bundler` is usually used in combination with `--noEmit`—bundlers typically process raw `.ts` files and perform module resolution on untransformed `import`s or `require`s. However, for consistency, TypeScript still uses the hypothetical emit decided by `module` to inform module resolution and type checking. This makes [`--module preserve`](#preserve) the best choice whenever a runtime or bundler is operating on raw `.ts` files, since it implies no transformation. Under `--module preserve --moduleResolution bundler`, you can write imports and requires in the same file that will resolve with the `import` and `require` conditions, respectively:

    ``` ts
    // index.ts
    import pkg1 from "pkg";       // Resolved with "import" condition
    import pkg2 = require("pkg"); // Resolved with "require" condition
    ```

    #### Implied and enforced options

    - `--moduleResolution bundler` must be paired with `--module esnext` or `--module preserve`.
    - `--moduleResolution bundler` implies `--allowSyntheticDefaultImports`.

    #### Supported features

    - [`paths`](#paths) ✅
    - [`baseUrl`](#baseurl) ✅
    - [`node_modules` package lookups](#node_modules-package-lookups) ✅
    - [package.json `"exports"`](#packagejson-exports) ✅ matches `types`, `import`/`require` depending on syntax
    - [package.json `"imports"` and self-name imports](#packagejson-imports-and-self-name-imports) ✅ matches `types`, `import`/`require` depending on syntax
    - [package.json `"typesVersions"`](#packagejson-typesversions) ✅
    - [Package-relative paths](#package-relative-file-paths) ✅ when `exports` not present
    - [Full relative paths](#relative-file-path-resolution) ✅
    - [Extensionless relative paths](#extensionless-relative-paths) ✅
    - [Directory modules](#directory-modules-index-file-resolution) ✅

    &nbsp;
- name: 'Modules - Reference: classic'
  id: modules/reference#classic
  summary: Do not use classic
  belongs_to: Modules - Reference
  description: "### `classic`\n\nDo not use `classic`.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/modules/reference.html](https://www.typescriptlang.org/docs/handbook/modules/reference.html)"
- name: 'Modules - Reference: commonjs'
  id: modules/reference#commonjs
  summary: 'Output is shown with esModuleInterop: false'
  belongs_to: Modules - Reference
  description: |-
    ### `commonjs`

    #### Summary

    - You probably shouldn’t use this. Use `node16` or `nodenext` to emit CommonJS modules for Node.js.
    - Emitted files are CommonJS modules, but dependencies may be any format.
    - Dynamic `import()` is transformed to a Promise of a `require()` call.
    - `esModuleInterop` affects the output code for default and namespace imports.

    #### Examples

    > Output is shown with `esModuleInterop: false`.

    ``` ts
    // @Filename: main.ts
    import x, { y, z } from "mod";
    import * as mod from "mod";
    const dynamic = import("mod");
    console.log(x, y, z, mod, dynamic);

    export const e1 = 0;
    export default "default export";
    ```

    ``` js
    // @Filename: main.js
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.e1 = void 0;
    const mod_1 = require("mod");
    const mod = require("mod");
    const dynamic = Promise.resolve().then(() => require("mod"));

    console.log(mod_1.default, mod_1.y, mod_1.z, mod);
    exports.e1 = 0;
    exports.default = "default export";
    ```

    ``` ts
    // @Filename: main.ts
    import mod = require("mod");
    console.log(mod);

    export = {
        p1: true,
        p2: false
    };
    ```

    ``` js
    // @Filename: main.js
    "use strict";
    const mod = require("mod");
    console.log(mod);

    module.exports = {
        p1: true,
        p2: false
    };
    ```
- name: 'Modules - Reference: es2015, es2020, es2022, esnext'
  id: modules/reference#es2015-es2020-es2022-esnext
  summary: null
  belongs_to: Modules - Reference
  description: |-
    ### `es2015`, `es2020`, `es2022`, `esnext`

    #### Summary

    - Use `esnext` with `--moduleResolution bundler` for bundlers, Bun, and tsx.
    - Do not use for Node.js. Use `node16` or `nodenext` with `"type": "module"` in package.json to emit ES modules for Node.js.
    - `import mod = require("mod")` is not allowed in non-declaration files.
    - `es2020` adds support for `import.meta` properties.
    - `es2022` adds support for top-level `await`.
    - `esnext` is a moving target that may include support for Stage 3 proposals to ECMAScript modules.
    - Emitted files are ES modules, but dependencies may be any format.

    #### Examples

    ``` ts
    // @Filename: main.ts
    import x, { y, z } from "mod";
    import * as mod from "mod";
    const dynamic = import("mod");
    console.log(x, y, z, mod, dynamic);

    export const e1 = 0;
    export default "default export";
    ```

    ``` js
    // @Filename: main.js
    import x, { y, z } from "mod";
    import * as mod from "mod";
    const dynamic = import("mod");
    console.log(x, y, z, mod, dynamic);

    export const e1 = 0;
    export default "default export";
    ```
- name: 'Modules - Reference: export = and import = require()'
  id: modules/reference#export--and-import--require
  summary: TypeScript supports a syntax in script (non-module) files for declaring a module that exists in the runtime but has no corresponding file
  belongs_to: Modules - Reference
  description: |-
    ### `export =` and `import = require()`

    When emitting CommonJS modules, TypeScript files can use a direct analog of `module.exports = ...` and `const mod = require("...")` JavaScript syntax:

    ``` ts
    // @Filename: main.ts
    import fs = require("fs");
    export = fs.readFileSync("...");

    // @Filename: main.js
    "use strict";
    const fs = require("fs");
    module.exports = fs.readFileSync("...");
    ```

    This syntax was used over its JavaScript counterparts since variable declarations and property assignments could not refer to TypeScript types, whereas special TypeScript syntax could:

    ``` ts
    // @Filename: a.ts
    interface Options { /* ... */ }
    module.exports = Options; // Error: 'Options' only refers to a type, but is being used as a value here.
    export = Options; // Ok

    // @Filename: b.ts
    const Options = require("./a");
    const options: Options = { /* ... */ }; // Error: 'Options' refers to a value, but is being used as a type here.

    // @Filename: c.ts
    import Options = require("./a");
    const options: Options = { /* ... */ }; // Ok
    ```

    ### Ambient modules

    TypeScript supports a syntax in script (non-module) files for declaring a module that exists in the runtime but has no corresponding file. These *ambient modules* usually represent runtime-provided modules, like `"fs"` or `"path"` in Node.js:

    ``` ts
    declare module "path" {
      export function normalize(p: string): string;
      export function join(...paths: any[]): string;
      export var sep: string;
    }
    ```

    Once an ambient module is loaded into a TypeScript program, TypeScript will recognize imports of the declared module in other files:

    ``` ts
    // 👇 Ensure the ambient module is loaded -
    //    may be unnecessary if path.d.ts is included
    //    by the project tsconfig.json somehow.
    /// <reference path="path.d.ts" />

    import { normalize, join } from "path";
    ```

    Ambient module declarations are easy to confuse with [module augmentations](../declaration-merging#module-augmentation) since they use identical syntax. This module declaration syntax becomes a module augmentation when the file is a module, meaning it has a top-level `import` or `export` statement (or is affected by [`--moduleDetection force` or `auto`](https://www.typescriptlang.org/tsconfig#moduleDetection)):

    ``` ts
    // Not an ambient module declaration anymore!
    export {};
    declare module "path" {
      export function normalize(p: string): string;
      export function join(...paths: any[]): string;
      export var sep: string;
    }
    ```

    Ambient modules may use imports inside the module declaration body to refer to other modules without turning the containing file into a module (which would make the ambient module declaration a module augmentation):

    ``` ts
    declare module "m" {
      // Moving this outside "m" would totally change the meaning of the file!
      import { SomeType } from "other";
      export function f(): SomeType;
    }
    ```

    A *pattern* ambient module contains a single `*` wildcard character in its name, matching zero or more characters in import paths. This can be useful for declaring modules provided by custom loaders:

    ``` ts
    declare module "*.html" {
      const content: string;
      export default content;
    }
    ```
- name: 'Modules - Reference: import() types'
  id: modules/reference#import-types
  summary: null
  belongs_to: Modules - Reference
  description: |-
    ### `import()` types

    TypeScript provides a type syntax similar to JavaScript’s dynamic `import` for referencing the type of a module without writing an import declaration:

    ``` ts
    // Access an exported type:
    type WriteFileOptions = import("fs").WriteFileOptions;
    // Access the type of an exported value:
    type WriteFileFunction = typeof import("fs").writeFile;
    ```

    This is especially useful in JSDoc comments in JavaScript files, where it’s not possible to import types otherwise:

    ``` ts
    /** @type {import("webpack").Configuration} */
    module.exports = {
      // ...
    }
    ```
- name: 'Modules - Reference: Module syntax'
  id: modules/reference#module-syntax
  summary: The TypeScript compiler recognizes standard ECMAScript module syntax in TypeScript and JavaScript files and many forms of CommonJS syntax in JavaScript files
  belongs_to: Modules - Reference
  description: |-
    ## Module syntax

    The TypeScript compiler recognizes standard [ECMAScript module syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) in TypeScript and JavaScript files and many forms of [CommonJS syntax](../type-checking-javascript-files#commonjs-modules-are-supported) in JavaScript files.

    There are also a few TypeScript-specific syntax extensions that can be used in TypeScript files and/or JSDoc comments.

    ### Importing and exporting TypeScript-specific declarations

    Type aliases, interfaces, enums, and namespaces can be exported from a module with an `export` modifier, like any standard JavaScript declaration:

    ``` ts
    // Standard JavaScript syntax...
    export function f() {}
    // ...extended to type declarations
    export type SomeType = /* ... */;
    export interface SomeInterface { /* ... */ }
    ```

    They can also be referenced in named exports, even alongside references to standard JavaScript declarations:

    ``` ts
    export { f, SomeType, SomeInterface };
    ```

    Exported types (and other TypeScript-specific declarations) can be imported with standard ECMAScript imports:

    ``` ts
    import { f, SomeType, SomeInterface } from "./module.js";
    ```

    When using namespace imports or exports, exported types are available on the namespace when referenced in a type position:

    ``` ts
    import * as mod from "./module.js";
    mod.f();
    mod.SomeType; // Property 'SomeType' does not exist on type 'typeof import("./module.js")'
    let x: mod.SomeType; // Ok
    ```

    ### Type-only imports and exports

    When emitting imports and exports to JavaScript, by default, TypeScript automatically elides (does not emit) imports that are only used in type positions and exports that only refer to types. Type-only imports and exports can be used to force this behavior and make the elision explicit. Import declarations written with `import type`, export declarations written with `export type { ... }`, and import or export specifiers prefixed with the `type` keyword are all guaranteed to be elided from the output JavaScript.

    ``` ts
    // @Filename: main.ts
    import { f, type SomeInterface } from "./module.js";
    import type { SomeType } from "./module.js";

    class C implements SomeInterface {
      constructor(p: SomeType) {
        f();
      }
    }

    export type { C };

    // @Filename: main.js
    import { f } from "./module.js";

    class C {
      constructor(p) {
        f();
      }
    }
    ```

    Even values can be imported with `import type`, but since they won’t exist in the output JavaScript, they can only be used in non-emitting positions:

    ``` ts
    import type { f } from "./module.js";
    f(); // 'f' cannot be used as a value because it was imported using 'import type'
    let otherFunction: typeof f = () => {}; // Ok
    ```

    A type-only import declaration may not declare both a default import and named bindings, since it appears ambiguous whether `type` applies to the default import or to the entire import declaration. Instead, split the import declaration into two, or use `default` as a named binding:

    ``` ts
    import type fs, { BigIntOptions } from "fs";
    //          ^^^^^^^^^^^^^^^^^^^^^
    // Error: A type-only import can specify a default import or named bindings, but not both.

    import type { default as fs, BigIntOptions } from "fs"; // Ok
    ```
- name: 'Modules - Reference: node10 (formerly known as node)'
  id: modules/reference#node10-formerly-known-as-node
  summary: --moduleResolution node was renamed to node10 (keeping node as an alias for backward compatibility) in TypeScript 5.0
  belongs_to: Modules - Reference
  description: |-
    ### `node10` (formerly known as `node`)

    `--moduleResolution node` was renamed to `node10` (keeping `node` as an alias for backward compatibility) in TypeScript 5.0. It reflects the CommonJS module resolution algorithm as it existed in Node.js versions earlier than v12. It should no longer be used.

    #### Supported features

    - [`paths`](#paths) ✅
    - [`baseUrl`](#baseurl) ✅
    - [`node_modules` package lookups](#node_modules-package-lookups) ✅
    - [package.json `"exports"`](#packagejson-exports) ❌
    - [package.json `"imports"` and self-name imports](#packagejson-imports-and-self-name-imports) ❌
    - [package.json `"typesVersions"`](#packagejson-typesversions) ✅
    - [Package-relative paths](#package-relative-file-paths) ✅
    - [Full relative paths](#relative-file-path-resolution) ✅
    - [Extensionless relative paths](#extensionless-relative-paths) ✅
    - [Directory modules](#directory-modules-index-file-resolution) ✅

    &nbsp;
- name: 'Modules - Reference: node16, nodenext'
  id: modules/reference#node16-nodenext-1
  summary: These modes reflect the module resolution behavior of Node.js v12 and later
  belongs_to: Modules - Reference
  description: |-
    ### `node16`, `nodenext`

    These modes reflect the module resolution behavior of Node.js v12 and later. (`node16` and `nodenext` are currently identical, but if Node.js makes significant changes to its module system in the future, `node16` will be frozen while `nodenext` will be updated to reflect the new behavior.) In Node.js, the resolution algorithm for ECMAScript imports is significantly different from the algorithm for CommonJS `require` calls. For each module specifier being resolved, the syntax and the [module format of the importing file](#module-format-detection) are first used to determine whether the module specifier will be in an `import` or `require` in the emitted JavaScript. That information is then passed into the module resolver to determine which resolution algorithm to use (and whether to use the `"import"` or `"require"` condition for package.json [`"exports"`](#packagejson-exports) or [`"imports"`](#packagejson-imports-and-self-name-imports)).

    > TypeScript files that are [determined to be in CommonJS format](#module-format-detection) may still use `import` and `export` syntax by default, but the emitted JavaScript will use `require` and `module.exports` instead. This means that it’s common to see `import` statements that are resolved using the `require` algorithm. If this causes confusion, the `verbatimModuleSyntax` compiler option can be enabled, which prohibits the use of `import` statements that would be emitted as `require` calls.

    Note that dynamic `import()` calls are always resolved using the `import` algorithm, according to Node.js’s behavior. However, `import()` types are resolved according to the format of the importing file (for backward compatibility with existing CommonJS-format type declarations):

    ``` ts
    // @Filename: module.mts
    import x from "./mod.js";             // `import` algorithm due to file format (emitted as-written)
    import("./mod.js");                   // `import` algorithm due to syntax (emitted as-written)
    type Mod = typeof import("./mod.js"); // `import` algorithm due to file format
    import mod = require("./mod");        // `require` algorithm due to syntax (emitted as `require`)

    // @Filename: commonjs.cts
    import x from "./mod";                // `require` algorithm due to file format (emitted as `require`)
    import("./mod.js");                   // `import` algorithm due to syntax (emitted as-written)
    type Mod = typeof import("./mod");    // `require` algorithm due to file format
    import mod = require("./mod");        // `require` algorithm due to syntax (emitted as `require`)
    ```

    #### Implied and enforced options

    - `--moduleResolution node16` and `nodenext` must be paired with their [corresponding `module` value](#node16-nodenext).

    #### Supported features

    Features are listed in order of precedence.

    |                                                                                              | `import`                             | `require`                             |
    |----------------------------------------------------------------------------------------------|--------------------------------------|---------------------------------------|
    | [`paths`](#paths)                                                                            | ✅                                   | ✅                                    |
    | [`baseUrl`](#baseurl)                                                                        | ✅                                   | ✅                                    |
    | [`node_modules` package lookups](#node_modules-package-lookups)                              | ✅                                   | ✅                                    |
    | [package.json `"exports"`](#packagejson-exports)                                             | ✅ matches `types`, `node`, `import` | ✅ matches `types`, `node`, `require` |
    | [package.json `"imports"` and self-name imports](#packagejson-imports-and-self-name-imports) | ✅ matches `types`, `node`, `import` | ✅ matches `types`, `node`, `require` |
    | [package.json `"typesVersions"`](#packagejson-typesversions)                                 | ✅                                   | ✅                                    |
    | [Package-relative paths](#package-relative-file-paths)                                       | ✅ when `exports` not present        | ✅ when `exports` not present         |
    | [Full relative paths](#relative-file-path-resolution)                                        | ✅                                   | ✅                                    |
    | [Extensionless relative paths](#extensionless-relative-paths)                                | ❌                                   | ✅                                    |
    | [Directory modules](#directory-modules-index-file-resolution)                                | ❌                                   | ✅                                    |
- name: 'Modules - Reference: node16, nodenext'
  id: modules/reference#node16-nodenext
  summary: Node.js supports both CommonJS and ECMAScript modules, with specific rules for which format each file can be and how the two formats are allowed to interoperate
  belongs_to: Modules - Reference
  description: |-
    ### `node16`, `nodenext`

    Node.js supports both CommonJS and ECMAScript modules, with specific rules for which format each file can be and how the two formats are allowed to interoperate. `node16` and `nodenext` describe the full range of behavior for Node.js’s dual-format module system, and **emit files in either CommonJS or ESM format**. This is different from every other `module` option, which are runtime-agnostic and force all output files into a single format, leaving it to the user to ensure the output is valid for their runtime.

    > A common misconception is that `node16` and `nodenext` only emit ES modules. In reality, `node16` and `nodenext` describe versions of Node.js that *support* ES modules, not just projects that *use* ES modules. Both ESM and CommonJS emit are supported, based on the [detected module format](#module-format-detection) of each file. Because `node16` and `nodenext` are the only `module` options that reflect the complexities of Node.js’s dual module system, they are the **only correct `module` options** for all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not.

    `node16` and `nodenext` are currently identical, with the exception that they [imply different `target` option values](#implied-and-enforced-options). If Node.js makes significant changes to its module system in the future, `node16` will be frozen while `nodenext` will be updated to reflect the new behavior.

    #### Module format detection

    - `.mts`/`.mjs`/`.d.mts` files are always ES modules.
    - `.cts`/`.cjs`/`.d.cts` files are always CommonJS modules.
    - `.ts`/`.tsx`/`.js`/`.jsx`/`.d.ts` files are ES modules if the nearest ancestor package.json file contains `"type": "module"`, otherwise CommonJS modules.

    The detected module format of input `.ts`/`.tsx`/`.mts`/`.cts` files determines the module format of the emitted JavaScript files. So, for example, a project consisting entirely of `.ts` files will emit all CommonJS modules by default under `--module nodenext`, and can be made to emit all ES modules by adding `"type": "module"` to the project package.json.

    #### Interoperability rules

    - **When an ES module references a CommonJS module:**
      - The `module.exports` of the CommonJS module is available as a default import to the ES module.
      - Properties (other than `default`) of the CommonJS module’s `module.exports` may or may not be available as named imports to the ES module. Node.js attempts to make them available via [static analysis](https://github.com/nodejs/cjs-module-lexer). TypeScript cannot know from a declaration file whether that static analysis will succeed, and optimistically assumes it will. This limits TypeScript’s ability to catch named imports that may crash at runtime. See [\#54018](https://github.com/microsoft/TypeScript/issues/54018) for more details.
    - **When a CommonJS module references an ES module:**
      - `require` cannot reference an ES module. For TypeScript, this includes `import` statements in files that are [detected](#module-format-detection) to be CommonJS modules, since those `import` statements will be transformed to `require` calls in the emitted JavaScript.
      - A dynamic `import()` call may be used to import an ES module. It returns a Promise of the module’s Module Namespace Object (what you’d get from `import * as ns from "./module.js"` from another ES module).

    #### Emit

    The emit format of each file is determined by the [detected module format](#module-format-detection) of each file. ESM emit is similar to [`--module esnext`](#es2015-es2020-es2022-esnext), but has a special transformation for `import x = require("...")`, which is not allowed in `--module esnext`:

    ``` ts
    // @Filename: main.ts
    import x = require("mod");
    ```

    ``` js
    // @Filename: main.js
    import { createRequire as _createRequire } from "module";
    const __require = _createRequire(import.meta.url);
    const x = __require("mod");
    ```

    CommonJS emit is similar to [`--module commonjs`](#commonjs), but dynamic `import()` calls are not transformed. Emit here is shown with `esModuleInterop` enabled:

    ``` ts
    // @Filename: main.ts
    import fs from "fs"; // transformed
    const dynamic = import("mod"); // not transformed
    ```

    ``` js
    // @Filename: main.js
    "use strict";
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs_1 = __importDefault(require("fs")); // transformed
    const dynamic = import("mod"); // not transformed
    ```

    #### Implied and enforced options

    - `--module nodenext` or `node16` implies and enforces the `moduleResolution` with the same name.
    - `--module nodenext` implies `--target esnext`.
    - `--module node16` implies `--target es2022`.
    - `--module nodenext` or `node16` implies `--esModuleInterop`.

    #### Summary

    - `node16` and `nodenext` are the only correct `module` options for all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not.
    - `node16` and `nodenext` emit files in either CommonJS or ESM format, based on the [detected module format](#module-format-detection) of each file.
    - Node.js’s interoperability rules between ESM and CJS are reflected in type checking.
    - ESM emit transforms `import x = require("...")` to a `require` call constructed from a `createRequire` import.
    - CommonJS emit leaves dynamic `import()` calls untransformed, so CommonJS modules can asynchronously import ES modules.
- name: 'Modules - Reference: preserve'
  id: modules/reference#preserve
  summary: In --module preserve (added in TypeScript 5.4), ECMAScript imports and exports written in input files are preserved in the output, and CommonJS-style import x = require("...") and export = ... statements are emitted as CommonJS require and module.exports
  belongs_to: Modules - Reference
  description: |-
    ### `preserve`

    In `--module preserve` ([added](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-bundler-and---module-preserve) in TypeScript 5.4), ECMAScript imports and exports written in input files are preserved in the output, and CommonJS-style `import x = require("...")` and `export = ...` statements are emitted as CommonJS `require` and `module.exports`. In other words, the format of each individual import or export statement is preserved, rather than being coerced into a single format for the whole compilation (or even a whole file).

    While it’s rare to need to mix imports and require calls in the same file, this `module` mode best reflects the capabilities of most modern bundlers, as well as the Bun runtime.

    > Why care about TypeScript’s `module` emit with a bundler or with Bun, where you’re likely also setting `noEmit`? TypeScript’s type checking and module resolution behavior are affected by the module format that it *would* emit. Setting `module` gives TypeScript information about how your bundler or runtime will process imports and exports, which ensures that the types you see on imported values accurately reflect what will happen at runtime or after bundling. See [`--moduleResolution bundler`](#bundler) for more discussion.

    #### Examples

    ``` ts
    import x, { y, z } from "mod";
    import mod = require("mod");
    const dynamic = import("mod");

    export const e1 = 0;
    export default "default export";
    ```

    ``` js
    import x, { y, z } from "mod";
    const mod = require("mod");
    const dynamic = import("mod");

    export const e1 = 0;
    export default "default export";
    ```

    #### Implied and enforced options

    - `--module preserve` implies `--moduleResolution bundler`.
    - `--module preserve` implies `--esModuleInterop`.

    > The option `--esModuleInterop` is enabled by default in `--module preserve` only for its [type checking](appendices/esm-cjs-interop#allowsyntheticdefaultimports-and-esmoduleinterop) behavior. Since imports never transform into require calls in `--module preserve`, `--esModuleInterop` does not affect the emitted JavaScript.
- name: 'Modules - Reference: system'
  id: modules/reference#system
  summary: null
  belongs_to: Modules - Reference
  description: |-
    ### `system`

    #### Summary

    - Designed for use with the [SystemJS module loader](https://github.com/systemjs/systemjs).

    #### Examples

    ``` ts
    // @Filename: main.ts
    import x, { y, z } from "mod";
    import * as mod from "mod";
    const dynamic = import("mod");
    console.log(x, y, z, mod, dynamic);

    export const e1 = 0;
    export default "default export";
    ```

    ``` js
    // @Filename: main.js
    System.register(["mod"], function (exports_1, context_1) {
        "use strict";
        var mod_1, mod, dynamic, e1;
        var __moduleName = context_1 && context_1.id;
        return {
            setters: [
                function (mod_1_1) {
                    mod_1 = mod_1_1;
                    mod = mod_1_1;
                }
            ],
            execute: function () {
                dynamic = context_1.import("mod");
                console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);
                exports_1("e1", e1 = 0);
                exports_1("default", "default export");
            }
        };
    });
    ```
- name: 'Modules - Reference: The module compiler option'
  id: modules/reference#the-module-compiler-option
  summary: This section discusses the details of each module compiler option value
  belongs_to: Modules - Reference
  description: |-
    ## The `module` compiler option

    This section discusses the details of each `module` compiler option value. See the [*Module output format*](theory#the-module-output-format) theory section for more background on what the option is and how it fits into the overall compilation process. In brief, the `module` compiler option was historically only used to control the output module format of emitted JavaScript files. The more recent `node16` and `nodenext` values, however, describe a wide range of characteristics of Node.js’s module system, including what module formats are supported, how the module format of each file is determined, and how different module formats interoperate.
- name: 'Modules - Reference: The moduleResolution compiler option'
  id: modules/reference#the-moduleresolution-compiler-option
  summary: This section describes module resolution features and processes shared by multiple moduleResolution modes, then specifies the details of each mode
  belongs_to: Modules - Reference
  description: |-
    ## The `moduleResolution` compiler option

    This section describes module resolution features and processes shared by multiple `moduleResolution` modes, then specifies the details of each mode. See the [*Module resolution*](theory#module-resolution) theory section for more background on what the option is and how it fits into the overall compilation process. In brief, `moduleResolution` controls how TypeScript resolves *module specifiers* (string literals in `import`/`export`/`require` statements) to files on disk, and should be set to match the module resolver used by the target runtime or bundler.

    ### Common features and processes

    #### File extension substitution

    TypeScript always wants to resolve internally to a file that can provide type information, while ensuring that the runtime or bundler can use the same path to resolve to a file that provides a JavaScript implementation. For any module specifier that would, according to the `moduleResolution` algorithm specified, trigger a lookup of a JavaScript file in the runtime or bundler, TypeScript will first try to find a TypeScript implementation file or type declaration file with the same name and analagous file extension.

    | Runtime lookup | TypeScript lookup \#1 | TypeScript lookup \#2 | TypeScript lookup \#3 | TypeScript lookup \#4 | TypeScript lookup \#5 |
    |----------------|-----------------------|-----------------------|-----------------------|-----------------------|-----------------------|
    | `/mod.js`      | `/mod.ts`             | `/mod.tsx`            | `/mod.d.ts`           | `/mod.js`             | `./mod.jsx`           |
    | `/mod.mjs`     | `/mod.mts`            | `/mod.d.mts`          | `/mod.mjs`            |                       |                       |
    | `/mod.cjs`     | `/mod.cts`            | `/mod.d.cts`          | `/mod.cjs`            |                       |                       |

    Note that this behavior is independent of the actual module specifier written in the import. This means that TypeScript can resolve to a `.ts` or `.d.ts` file even if the module specifier explicitly uses a `.js` file extension:

    ``` ts
    import x from "./mod.js";
    // Runtime lookup: "./mod.js"
    // TypeScript lookup #1: "./mod.ts"
    // TypeScript lookup #2: "./mod.d.ts"
    // TypeScript lookup #3: "./mod.js"
    ```

    See [*TypeScript imitates the host’s module resolution, but with types*](theory#typescript-imitates-the-hosts-module-resolution-but-with-types) for an explanation of why TypeScript’s module resolution works this way.

    #### Relative file path resolution

    All of TypeScript’s `moduleResolution` algorithms support referencing a module by a relative path that includes a file extension (which will be substituted according to the [rules above](#file-extension-substitution)):

    ``` ts
    // @Filename: a.ts
    export {};

    // @Filename: b.ts
    import {} from "./a.js"; // ✅ Works in every `moduleResolution`
    ```

    #### Extensionless relative paths

    In some cases, the runtime or bundler allows omitting a `.js` file extension from a relative path. TypeScript supports this behavior where the `moduleResolution` setting and the context indicate that the runtime or bundler supports it:

    ``` ts
    // @Filename: a.ts
    export {};

    // @Filename: b.ts
    import {} from "./a";
    ```

    If TypeScript determines that the runtime will perform a lookup for `./a.js` given the module specifier `"./a"`, then `./a.js` will undergo [extension substitution](#file-extension-substitution), and resolve to the file `a.ts` in this example.

    Extensionless relative paths are not supported in `import` paths in Node.js, and are not always supported in file paths specified in package.json files. TypeScript currently never supports omitting a `.mjs`/`.mts` or `.cjs`/`.cts` file extension, even though some runtimes and bundlers do.

    #### Directory modules (index file resolution)

    In some cases, a directory, rather than a file, can be referenced as a module. In the simplest and most common case, this involves the runtime or bundler looking for an `index.js` file in a directory. TypeScript supports this behavior where the `moduleResolution` setting and the context indicate that the runtime or bundler supports it:

    ``` ts
    // @Filename: dir/index.ts
    export {};

    // @Filename: b.ts
    import {} from "./dir";
    ```

    If TypeScript determines that the runtime will perform a lookup for `./dir/index.js` given the module specifier `"./dir"`, then `./dir/index.js` will undergo [extension substitution](#file-extension-substitution), and resolve to the file `dir/index.ts` in this example.

    Directory modules may also contain a package.json file, where resolution of the [`"main"` and `"types"`](#packagejson-main-and-types) fields are supported, and take precedence over `index.js` lookups. The [`"typesVersions"`](#packagejson-typesversions) field is also supported in directory modules.

    Note that directory modules are not the same as [`node_modules` packages](#node_modules-package-lookups) and only support a subset of the features available to packages, and are not supported at all in some contexts. Node.js considers them a [legacy feature](https://nodejs.org/dist/latest-v20.x/docs/api/modules.html#folders-as-modules).

    #### `paths`

    ##### Overview

    TypeScript offers a way to override the compiler’s module resolution for bare specifiers with the `paths` compiler option. While the feature was originally designed to be used with the AMD module loader (a means of running modules in the browser before ESM existed or bundlers were widely used), it still has uses today when a runtime or bundler supports module resolution features that TypeScript does not model. For example, when running Node.js with `--experimental-network-imports`, you can manually specify a local type definition file for a specific `https://` import:

    ``` json
    {
      "compilerOptions": {
        "module": "nodenext",
        "paths": {
          "https://esm.sh/lodash@4.17.21": ["./node_modules/@types/lodash/index.d.ts"]
        }
      }
    }
    ```

    ``` ts
    // Typed by ./node_modules/@types/lodash/index.d.ts due to `paths` entry
    import { add } from "https://esm.sh/lodash@4.17.21";
    ```

    It’s also common for apps built with bundlers to define convenience path aliases in their bundler configuration, and then inform TypeScript of those aliases with `paths`:

    ``` json
    {
      "compilerOptions": {
        "module": "esnext",
        "moduleResolution": "bundler",
        "paths": {
          "@app/*": ["./src/*"]
        }
      }
    }
    ```

    ##### `paths` does not affect emit

    The `paths` option does *not* change the import path in the code emitted by TypeScript. Consequently, it’s very easy to create path aliases that appear to work in TypeScript but will crash at runtime:

    ``` json
    {
      "compilerOptions": {
        "module": "nodenext",
        "paths": {
          "node-has-no-idea-what-this-is": ["./oops.ts"]
        }
      }
    }
    ```

    ``` ts
    // TypeScript: ✅
    // Node.js: 💥
    import {} from "node-has-no-idea-what-this-is";
    ```

    While it’s ok for bundled apps to set up `paths`, it’s very important that published libraries do *not*, since the emitted JavaScript will not work for consumers of the library without those users setting up the same aliases for both TypeScript and their bundler. Both libraries and apps can consider [package.json `"imports"`](#packagejson-imports-and-self-name-imports) as a standard replacement for convenience `paths` aliases.

    ##### `paths` should not point to monorepo packages or node_modules packages

    While module specifiers that match `paths` aliases are bare specifiers, once the alias is resolved, module resolution proceeds on the resolved path as a relative path. Consequently, resolution features that happen for [`node_modules` package lookups](#node_modules-package-lookups), including package.json `"exports"` field support, do not take effect when a `paths` alias is matched. This can lead to surprising behavior if `paths` is used to point to a `node_modules` package:

    ``` ts
    {
      "compilerOptions": {
        "paths": {
          "pkg": ["./node_modules/pkg/dist/index.d.ts"],
          "pkg/*": ["./node_modules/pkg/*"]
        }
      }
    }
    ```

    While this configuration may simulate some of the behavior of package resolution, it overrides any `main`, `types`, `exports`, and `typesVersions` the package’s `package.json` file defines, and imports from the package may fail at runtime.

    The same caveat applies to packages referencing each other in a monorepo. Instead of using `paths` to make TypeScript artificially resolve `"@my-scope/lib"` to a sibling package, it’s best to use workspaces via [npm](https://docs.npmjs.com/cli/v7/using-npm/workspaces), [yarn](https://classic.yarnpkg.com/en/docs/workspaces/), or [pnpm](https://pnpm.io/workspaces) to symlink your packages into `node_modules`, so both TypeScript and the runtime or bundler perform real `node_modules` package lookups. This is especially important if the monorepo packages will be published to npm—the packages will reference each other via `node_modules` package lookups once installed by users, and using workspaces allows you to test that behavior during local development.

    ##### Relationship to `baseUrl`

    When [`baseUrl`](#baseurl) is provided, the values in each `paths` array are resolved relative to the `baseUrl`. Otherwise, they are resolved relative to the `tsconfig.json` file that defines them.

    ##### Wildcard substitutions

    `paths` patterns can contain a single `*` wildcard, which matches any string. The `*` token can then be used in the file path values to substitute the matched string:

    ``` json
    {
      "compilerOptions": {
        "paths": {
          "@app/*": ["./src/*"]
        }
      }
    }
    ```

    When resolving an import of `"@app/components/Button"`, TypeScript will match on `@app/*`, binding `*` to `components/Button`, and then attempt to resolve the path `./src/components/Button` relative to the `tsconfig.json` path. The remainder of this lookup will follow the same rules as any other [relative path lookup](#relative-file-path-resolution) according to the `moduleResolution` setting.

    When multiple patterns match a module specifier, the pattern with the longest matching prefix before any `*` token is used:

    ``` json
    {
      "compilerOptions": {
        "paths": {
          "*": ["./src/foo/one.ts"],
          "foo/*": ["./src/foo/two.ts"],
          "foo/bar": ["./src/foo/three.ts"]
        }
      }
    }
    ```

    When resolving an import of `"foo/bar"`, all three `paths` patterns match, but the last is used because `"foo/bar"` is longer than `"foo/"` and `""`.

    ##### Fallbacks

    Multiple file paths can be provided for a path mapping. If resolution fails for one path, the next one in the array will be attempted until resolution succeeds or the end of the array is reached.

    ``` json
    {
      "compilerOptions": {
        "paths": {
          "*": ["./vendor/*", "./types/*"]
        }
      }
    }
    ```

    #### `baseUrl`

    > `baseUrl` was designed for use with AMD module loaders. If you aren’t using an AMD module loader, you probably shouldn’t use `baseUrl`. Since TypeScript 4.1, `baseUrl` is no longer required to use [`paths`](#paths) and should not be used just to set the directory `paths` values are resolved from.

    The `baseUrl` compiler option can be combined with any `moduleResolution` mode and specifies a directory that bare specifiers (module specifiers that don’t begin with `./`, `../`, or `/`) are resolved from. `baseUrl` has a higher precedence than [`node_modules` package lookups](#node_modules-package-lookups) in `moduleResolution` modes that support them.

    When performing a `baseUrl` lookup, resolution proceeds with the same rules as other relative path resolutions. For example, in a `moduleResolution` mode that supports [extensionless relative paths](#extensionless-relative-paths) a module specifier `"some-file"` may resolve to `/src/some-file.ts` if `baseUrl` is set to `/src`.

    Resolution of relative module specifiers are never affected by the `baseUrl` option.

    #### `node_modules` package lookups

    Node.js treats module specifiers that aren’t relative paths, absolute paths, or URLs as references to packages that it looks up in `node_modules` subdirectories. Bundlers conveniently adopted this behavior to allow their users to use the same dependency management system, and often even the same dependencies, as they would in Node.js. All of TypeScript’s `moduleResolution` options except `classic` support `node_modules` lookups. (`classic` supports lookups in `node_modules/@types` when other means of resolution fail, but never looks for packages in `node_modules` directly.) Every `node_modules` package lookup has the following structure (beginning after higher precedence bare specifier rules, like `paths`, `baseUrl`, self-name imports, and package.json `"imports"` lookups have been exhausted):

    1.  For each ancestor directory of the importing file, if a `node_modules` directory exists within it:
        1.  If a directory with the same name as the package exists within `node_modules`:
            1.  Attempt to resolve types from the package directory.
            2.  If a result is found, return it and stop the search.
        2.  If a directory with the same name as the package exists within `node_modules/@types`:
            1.  Attempt to resolve types from the `@types` package directory.
            2.  If a result is found, return it and stop the search.
    2.  Repeat the previous search through all `node_modules` directories, but this time, allow JavaScript files as a result, and do not search in `@types` directories.

    All `moduleResolution` modes (except `classic`) follow this pattern, while the details of how they resolve from a package directory, once located, differ, and are explained in the following sections.

    #### package.json `"exports"`

    When `moduleResolution` is set to `node16`, `nodenext`, or `bundler`, and `resolvePackageJsonExports` is not disabled, TypeScript follows Node.js’s [package.json `"exports"` spec](https://nodejs.org/api/packages.html#packages_package_entry_points) when resolving from a package directory triggered by a [bare specifier `node_modules` package lookup](#node_modules-package-lookups).

    TypeScript’s implementation for resolving a module specifier through `"exports"` to a file path follows Node.js exactly. Once a file path is resolved, however, TypeScript will still [try multiple file extensions](#file-extension-substitution) in order to prioritize finding types.

    When resolving through [conditional `"exports"`](https://nodejs.org/api/packages.html#conditional-exports), TypeScript always matches the `"types"` and `"default"` conditions if present. Additionally, TypeScript will match a versioned types condition in the form `"types@{selector}"` (where `{selector}` is a `"typesVersions"`-compatible version selector) according to the same version-matching rules implemented in [`"typesVersions"`](#packagejson-typesversions). Other non-configurable conditions are dependent on the `moduleResolution` mode and specified in the following sections. Additional conditions can be configured to match with the `customConditions` compiler option.

    Note that the presence of `"exports"` prevents any subpaths not explicitly listed or matched by a pattern in `"exports"` from being resolved.

    ##### Example: subpaths, conditions, and extension substitution

    Scenario: `"pkg/subpath"` is requested with conditions `["types", "node", "require"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:

    ``` json
    {
      "name": "pkg",
      "exports": {
        ".": {
          "import": "./index.mjs",
          "require": "./index.cjs"
        },
        "./subpath": {
          "import": "./subpath/index.mjs",
          "require": "./subpath/index.cjs"
        }
      }
    }
    ```

    Resolution process within the package directory:

    1.  Does `"exports"` exist? **Yes.**
    2.  Does `"exports"` have a `"./subpath"` entry? **Yes.**
    3.  The value at `exports["./subpath"]` is an object—it must be specifying conditions.
    4.  Does the first condition `"import"` match this request? **No.**
    5.  Does the second condition `"require"` match this request? **Yes.**
    6.  Does the path `"./subpath/index.cjs"` have a recognized TypeScript file extension? **No, so use extension substitution.**
    7.  Via [extension substitution](#file-extension-substitution), try the following paths, returning the first one that exists, or `undefined` otherwise:
        1.  `./subpath/index.cts`
        2.  `./subpath/index.d.cts`
        3.  `./subpath/index.cjs`

    If `./subpath/index.cts` or `./subpath.d.cts` exists, resolution is complete. Otherwise, resolution searches `node_modules/@types/pkg` and other `node_modules` directories in an attempt to resolve types, according to the [`node_modules` package lookups](#node_modules-package-lookups) rules. If no types are found, a second pass through all `node_modules` resolves to `./subpath/index.cjs` (assuming it exists), which counts as a successful resolution, but one that does not provide types, leading to `any`-typed imports and a `noImplicitAny` error if enabled.

    ##### Example: explicit `"types"` condition

    Scenario: `"pkg/subpath"` is requested with conditions `["types", "node", "import"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:

    ``` json
    {
      "name": "pkg",
      "exports": {
        "./subpath": {
          "import": {
            "types": "./types/subpath/index.d.mts",
            "default": "./es/subpath/index.mjs"
          },
          "require": {
            "types": "./types/subpath/index.d.cts",
            "default": "./cjs/subpath/index.cjs"
          }
        }
      }
    }
    ```

    Resolution process within the package directory:

    1.  Does `"exports"` exist? **Yes.**
    2.  Does `"exports"` have a `"./subpath"` entry? **Yes.**
    3.  The value at `exports["./subpath"]` is an object—it must be specifying conditions.
    4.  Does the first condition `"import"` match this request? **Yes.**
    5.  The value at `exports["./subpath"].import` is an object—it must be specifying conditions.
    6.  Does the first condition `"types"` match this request? **Yes.**
    7.  Does the path `"./types/subpath/index.d.mts"` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**
    8.  Return the path `"./types/subpath/index.d.mts"` if the file exists, `undefined` otherwise.

    ##### Example: versioned `"types"` condition

    Scenario: using TypeScript 4.7.5, `"pkg/subpath"` is requested with conditions `["types", "node", "import"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:

    ``` json
    {
      "name": "pkg",
      "exports": {
        "./subpath": {
          "types@>=5.2": "./ts5.2/subpath/index.d.ts",
          "types@>=4.6": "./ts4.6/subpath/index.d.ts",
          "types": "./tsold/subpath/index.d.ts",
          "default": "./dist/subpath/index.js"
        }
      }
    }
    ```

    Resolution process within the package directory:

    1.  Does `"exports"` exist? **Yes.**
    2.  Does `"exports"` have a `"./subpath"` entry? **Yes.**
    3.  The value at `exports["./subpath"]` is an object—it must be specifying conditions.
    4.  Does the first condition `"types@>=5.2"` match this request? **No, 4.7.5 is not greater than or equal to 5.2.**
    5.  Does the second condition `"types@>=4.6"` match this request? **Yes, 4.7.5 is greater than or equal to 4.6.**
    6.  Does the path `"./ts4.6/subpath/index.d.ts"` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**
    7.  Return the path `"./ts4.6/subpath/index.d.ts"` if the file exists, `undefined` otherwise.

    ##### Example: subpath patterns

    Scenario: `"pkg/wildcard.js"` is requested with conditions `["types", "node", "import"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:

    ``` json
    {
      "name": "pkg",
      "type": "module",
      "exports": {
        "./*.js": {
          "types": "./types/*.d.ts",
          "default": "./dist/*.js"
        }
      }
    }
    ```

    Resolution process within the package directory:

    1.  Does `"exports"` exist? **Yes.**
    2.  Does `"exports"` have a `"./wildcard.js"` entry? **No.**
    3.  Does any key with a `*` in it match `"./wildcard.js"`? **Yes, `"./*.js"` matches and sets `wildcard` to be the substitution.**
    4.  The value at `exports["./*.js"]` is an object—it must be specifying conditions.
    5.  Does the first condition `"types"` match this request? **Yes.**
    6.  In `./types/*.d.ts`, replace `*` with the substitution `wildcard`. **`./types/wildcard.d.ts`**
    7.  Does the path `"./types/wildcard.d.ts"` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**
    8.  Return the path `"./types/wildcard.d.ts"` if the file exists, `undefined` otherwise.

    ##### Example: `"exports"` block other subpaths

    Scenario: `"pkg/dist/index.js"` is requested in a package directory with the following package.json:

    ``` json
    {
      "name": "pkg",
      "main": "./dist/index.js",
      "exports": "./dist/index.js"
    }
    ```

    Resolution process within the package directory:

    1.  Does `"exports"` exist? **Yes.**
    2.  The value at `exports` is a string—it must be a file path for the package root (`"."`).
    3.  Is the request `"pkg/dist/index.js"` for the package root? **No, it has a subpath `dist/index.js`.**
    4.  Resolution fails; return `undefined`.

    Without `"exports"`, the request could have succeeded, but the presence of `"exports"` prevents resolving any subpaths that cannot be matched through `"exports"`.

    #### package.json `"typesVersions"`

    A [`node_modules` package](#node_modules-package-lookups) or [directory module](#directory-modules-index-file-resolution) may specify a `"typesVersions"` field in its package.json to redirect TypeScript’s resolution process according to the TypeScript compiler version, and for `node_modules` packages, according to the subpath being resolved. This allows package authors to include new TypeScript syntax in one set of type definitions while providing another set for backward compatibility with older TypeScript versions (through a tool like [downlevel-dts](https://github.com/sandersn/downlevel-dts)). `"typesVersions"` is supported in all `moduleResolution` modes; however, the field is not read in situations when [package.json `"exports"`](#packagejson-exports) are read.

    ##### Example: redirect all requests to a subdirectory

    Scenario: a module imports `"pkg"` using TypeScript 5.2, where `node_modules/pkg/package.json` is:

    ``` json
    {
      "name": "pkg",
      "version": "1.0.0",
      "types": "./index.d.ts",
      "typesVersions": {
        ">=3.1": {
          "*": ["ts3.1/*"]
        }
      }
    }
    ```

    Resolution process:

    1.  (Depending on compiler options) Does `"exports"` exist? **No.**
    2.  Does `"typesVersions"` exist? **Yes.**
    3.  Is the TypeScript version `>=3.1`? **Yes. Remember the mapping `"*": ["ts3.1/*"]`.**
    4.  Are we resolving a subpath after the package name? **No, just the root `"pkg"`.**
    5.  Does `"types"` exist? **Yes.**
    6.  Does any key in `"typesVersions"` match `./index.d.ts`? **Yes, `"*"` matches and sets `index.d.ts` to be the substitution.**
    7.  In `ts3.1/*`, replace `*` with the substitution `./index.d.ts`: **`ts3.1/index.d.ts`**.
    8.  Does the path `./ts3.1/index.d.ts` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**
    9.  Return the path `./ts3.1/index.d.ts` if the file exists, `undefined` otherwise.

    ##### Example: redirect requests for a specific file

    Scenario: a module imports `"pkg"` using TypeScript 3.9, where `node_modules/pkg/package.json` is:

    ``` json
    {
      "name": "pkg",
      "version": "1.0.0",
      "types": "./index.d.ts",
      "typesVersions": {
        "<4.0": { "index.d.ts": ["index.v3.d.ts"] }
      }
    }
    ```

    Resolution process:

    1.  (Depending on compiler options) Does `"exports"` exist? **No.**
    2.  Does `"typesVersions"` exist? **Yes.**
    3.  Is the TypeScript version `<4.0`? **Yes. Remember the mapping `"index.d.ts": ["index.v3.d.ts"]`.**
    4.  Are we resolving a subpath after the package name? **No, just the root `"pkg"`.**
    5.  Does `"types"` exist? **Yes.**
    6.  Does any key in `"typesVersions"` match `./index.d.ts`? **Yes, `"index.d.ts"` matches.**
    7.  Does the path `./index.v3.d.ts` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**
    8.  Return the path `./index.v3.d.ts` if the file exists, `undefined` otherwise.

    #### package.json `"main"` and `"types"`

    If a directory’s [package.json `"exports"`](#packagejson-exports) field is not read (either due to compiler options, or because it is not present, or because the directory is being resolved as a [directory module](#directory-modules-index-file-resolution) instead of a [`node_modules` package](#node_modules-package-lookups)) and the module specifier does not have a subpath after the package name or package.json-containing directory, TypeScript will attempt to resolve from these package.json fields, in order, in an attempt to find the main module for the package or directory:

    - `"types"`
    - `"typings"` (legacy)
    - `"main"`

    The declaration file found at `"types"` is assumed to be an accurate representation of the implementation file found at `"main"`. If `"types"` and `"typings"` are not present or cannot be resolved, TypeScript will read the `"main"` field and perform [extension substitution](#file-extension-substitution) to find a declaration file.

    When publishing a typed package to npm, it’s recommended to include a `"types"` field even if [extension substitution](#file-extension-substitution) or [package.json `"exports"`](#packagejson-exports) make it unnecessary, because npm shows a TS icon on the package registry listing only if the package.json contains a `"types"` field.

    #### Package-relative file paths

    If neither [package.json `"exports"`](#packagejson-exports) nor [package.json `"typesVersions"`](#packagejson-typesversions) apply, subpaths of a bare package specifier resolve relative to the package directory, according to applicable [relative path](#relative-file-path-resolution) resolution rules. In modes that respect \[package.json `"exports"`\], this behavior is blocked by the mere presence of the `"exports"` field in the package’s package.json, even if the import fails to resolve through `"exports"`, as demonstrated in [an example above](#example-exports-block-other-subpaths). On the other hand, if the import fails to resolve through `"typesVersions"`, a package-relative file path resolution is attempted as a fallback.

    When package-relative paths are supported, they resolve under the same rules as any other relative path considering the `moduleResolution` mode and context. For example, in [`--moduleResolution nodenext`](#node16-nodenext-1), [directory modules](#directory-modules-index-file-resolution) and [extensionless paths](#extensionless-relative-paths) are only supported in `require` calls, not in `import`s:

    ``` ts
    // @Filename: module.mts
    import "pkg/dist/foo";                // ❌ import, needs `.js` extension
    import "pkg/dist/foo.js";             // ✅
    import foo = require("pkg/dist/foo"); // ✅ require, no extension needed
    ```

    #### package.json `"imports"` and self-name imports

    When `moduleResolution` is set to `node16`, `nodenext`, or `bundler`, and `resolvePackageJsonImports` is not disabled, TypeScript will attempt to resolve import paths beginning with `#` through the `"imports"` field of the nearest ancestor package.json of the importing file. Similarly, when [package.json `"exports"` lookups](#packagejson-exports) are enabled, TypeScript will attempt to resolve import paths beginning with the current package name—that is, the value in the `"name"` field of the nearest ancestor package.json of the importing file—through the `"exports"` field of that package.json. Both of these features allow files in a package to import other files in the same package, replacing a relative import path.

    TypeScript follows Node.js’s resolution algorithm for [`"imports"`](https://nodejs.org/api/packages.html#subpath-imports) and [self references](https://nodejs.org/api/packages.html#self-referencing-a-package-using-its-name) exactly up until a file path is resolved. At that point, TypeScript’s resolution algorithm forks based on whether the package.json containing the `"imports"` or `"exports"` being resolved belongs to a `node_modules` dependency or the local project being compiled (i.e., its directory contains the tsconfig.json file for the project that contains the importing file):

    - If the package.json is in `node_modules`, TypeScript will apply [extension substitution](#file-extension-substitution) to the file path if it doesn’t already have a recognized TypeScript file extension, and check for the existence of the resulting file paths.
    - If the package.json is part of the local project, an additional remapping step is performed in order to find the *input* TypeScript implementation file that will eventually produce the output JavaScript or declaration file path that was resolved from `"imports"`. Without this step, any compilation that resolves an `"imports"` path would be referencing output files from the *previous compilation* instead of other input files that are intended to be included in the current compilation. This remapping uses the `outDir`/`declarationDir` and `rootDir` from the tsconfig.json, so using `"imports"` usually requires an explicit `rootDir` to be set.

    This variation allows package authors to write `"imports"` and `"exports"` fields that reference only the compilation outputs that will be published to npm, while still allowing local development to use the original TypeScript source files.

    ##### Example: local project with conditions

    Scenario: `"/src/main.mts"` imports `"#utils"` with conditions `["types", "node", "import"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a project directory with a tsconfig.json and package.json:

    ``` json
    // tsconfig.json
    {
      "compilerOptions": {
        "moduleResolution": "node16",
        "resolvePackageJsonImports": true,
        "rootDir": "./src",
        "outDir": "./dist"
      }
    }
    ```

    ``` json
    // package.json
    {
      "name": "pkg",
      "imports": {
        "#utils": {
          "import": "./dist/utils.d.mts",
          "require": "./dist/utils.d.cts"
        }
      }
    }
    ```

    Resolution process:

    1.  Import path starts with `#`, try to resolve through `"imports"`.
    2.  Does `"imports"` exist in the nearest ancestor package.json? **Yes.**
    3.  Does `"#utils"` exist in the `"imports"` object? **Yes.**
    4.  The value at `imports["#utils"]` is an object—it must be specifying conditions.
    5.  Does the first condition `"import"` match this request? **Yes.**
    6.  Should we attempt to map the output path to an input path? **Yes, because:**
        - Is the package.json in `node_modules`? **No, it’s in the local project.**
        - Is the tsconfig.json within the package.json directory? **Yes.**
    7.  In `./dist/utils.d.mts`, replace the `outDir` prefix with `rootDir`. **`./src/utils.d.mts`**
    8.  Replace the output extension `.d.mts` with the corresponding input extension `.mts`. **`./src/utils.mts`**
    9.  Return the path `"./src/utils.mts"` if the file exists.
    10. Otherwise, return the path `"./dist/utils.d.mts"` if the file exists.

    ##### Example: `node_modules` dependency with subpath pattern

    Scenario: `"/node_modules/pkg/main.mts"` imports `"#internal/utils"` with conditions `["types", "node", "import"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) with the package.json:

    ``` json
    // /node_modules/pkg/package.json
    {
      "name": "pkg",
      "imports": {
        "#internal/*": {
          "import": "./dist/internal/*.mjs",
          "require": "./dist/internal/*.cjs"
        }
      }
    }
    ```

    Resolution process:

    1.  Import path starts with `#`, try to resolve through `"imports"`.
    2.  Does `"imports"` exist in the nearest ancestor package.json? **Yes.**
    3.  Does `"#internal/utils"` exist in the `"imports"` object? **No, check for pattern matches.**
    4.  Does any key with a `*` match `"#internal/utils"`? **Yes, `"#internal/*"` matches and sets `utils` to be the substitution.**
    5.  The value at `imports["#internal/*"]` is an object—it must be specifying conditions.
    6.  Does the first condition `"import"` match this request? **Yes.**
    7.  Should we attempt to map the output path to an input path? **No, because the package.json is in `node_modules`.**
    8.  In `./dist/internal/*.mjs`, replace `*` with the substitution `utils`. **`./dist/internal/utils.mjs`**
    9.  Does the path `./dist/internal/utils.mjs` have a recognized TypeScript file extension? **No, try extension substitution.**
    10. Via [extension substitution](#file-extension-substitution), try the following paths, returning the first one that exists, or `undefined` otherwise:
        1.  `./dist/internal/utils.mts`
        2.  `./dist/internal/utils.d.mts`
        3.  `./dist/internal/utils.mjs`

    &nbsp;
- name: 'Modules - Reference: umd'
  id: modules/reference#umd
  summary: null
  belongs_to: Modules - Reference
  description: |-
    ### `umd`

    #### Summary

    - Designed for AMD or CommonJS loaders.
    - Does not expose a global variable like most other UMD wrappers.
    - You probably shouldn’t use this. Use a bundler instead.
    - Emitted files are UMD modules, but dependencies may be any format.

    #### Examples

    ``` ts
    // @Filename: main.ts
    import x, { y, z } from "mod";
    import * as mod from "mod";
    const dynamic = import("mod");
    console.log(x, y, z, mod, dynamic);

    export const e1 = 0;
    export default "default export";
    ```

    ``` js
    // @Filename: main.js
    (function (factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
            var v = factory(require, exports);
            if (v !== undefined) module.exports = v;
        }
        else if (typeof define === "function" && define.amd) {
            define(["require", "exports", "mod", "mod"], factory);
        }
    })(function (require, exports) {
        "use strict";
        var __syncRequire = typeof module === "object" && typeof module.exports === "object";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.e1 = void 0;
        const mod_1 = require("mod");
        const mod = require("mod");
        const dynamic = __syncRequire ? Promise.resolve().then(() => require("mod")) : new Promise((resolve_1, reject_1) => { require(["mod"], resolve_1, reject_1); });

        console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);
        exports.e1 = 0;
        exports.default = "default export";
    });
    ```
- name: Modules - Theory
  id: modules/theory
  summary: This approach had some downsides, especially as web pages grew larger and more complex
  description: "# Modules - Theory\n\n## Scripts and modules in JavaScript\n\nIn the early days of JavaScript, when the language only ran in browsers, there were no modules, but it was still possible to split the JavaScript for a web page into multiple files by using multiple `script` tags in HTML:\n\n``` html\n<html>\n  <head>\n    <script src=\"a.js\"></script>\n    <script src=\"b.js\"></script>\n  </head>\n  <body></body>\n</html>\n```\n\nThis approach had some downsides, especially as web pages grew larger and more complex. In particular, all scripts loaded onto the same page share the same scope—appropriately called the “global scope”—meaning the scripts had to be very careful not to overwrite each others’ variables and functions.\n\nAny system that solves this problem by giving files their own scope while still providing a way to make bits of code available to other files can be called a “module system.” (It may sound obvious to say that each file in a module system is called a “module,” but the term is often used to contrast with *script* files, which run outside a module system, in a global scope.)\n\n> There are [many module systems](https://github.com/myshov/history-of-javascript/tree/master/4_evolution_of_js_modularity), and TypeScript [supports emitting several](https://www.typescriptlang.org/tsconfig/#module), but this documentation will focus on the two most important systems today: ECMAScript modules (ESM) and CommonJS (CJS).\n>\n> ECMAScript Modules (ESM) is the module system built into the language, supported in modern browsers and in Node.js since v12. It uses dedicated `import` and `export` syntax:\n>\n> ``` js\n> // a.js\n> export default \"Hello from a.js\";\n> ```\n>\n> ``` js\n> // b.js\n> import a from \"./a.js\";\n> console.log(a); // 'Hello from a.js'\n> ```\n>\n> CommonJS (CJS) is the module system that originally shipped in Node.js, before ESM was part of the language specification. It’s still supported in Node.js alongside ESM. It uses plain JavaScript objects and functions named `exports` and `require`:\n>\n> ``` js\n> // a.js\n> exports.message = \"Hello from a.js\";\n> ```\n>\n> ``` js\n> // b.js\n> const a = require(\"./a\");\n> console.log(a.message); // 'Hello from a.js'\n> ```\n\nAccordingly, when TypeScript detects that a file is a CommonJS or ECMAScript module, it starts by assuming that file will have its own scope. Beyond that, though, the compiler’s job gets a little more complicated.\n\n## TypeScript’s job concerning modules\n\nThe TypeScript compiler’s chief goal is to prevent certain kinds of runtime errors by catching them at compile time. With or without modules involved, the compiler needs to know about the code’s intended runtime environment—what globals are available, for example. When modules are involved, there are several additional questions the compiler needs to answer in order to do its job. Let’s use a few lines of input code as an example to think about all the information needed to analyze it:\n\n``` ts\nimport sayHello from \"greetings\";\nsayHello(\"world\");\n```\n\nTo check this file, the compiler needs to know the type of `sayHello` (is it a function that can accept one string argument?), which opens quite a few additional questions:\n\n1.  Will the module system load this TypeScript file directly, or will it load a JavaScript file that I (or another compiler) generate from this TypeScript file?\n2.  What *kind* of module does the module system expect to find, given the file name it will load and its location on disk?\n3.  If output JavaScript is being emitted, how will the module syntax present in this file be transformed in the output code?\n4.  Where will the module system look to find the module specified by `\"greetings\"`? Will the lookup succeed?\n5.  What kind of module is the file resolved by that lookup?\n6.  Does the module system allow the kind of module detected in (2) to reference the kind of module detected in (5) with the syntax decided in (3)?\n7.  Once the `\"greetings\"` module has been analyzed, what piece of that module is bound to `sayHello`?\n\nNotice that all of these questions depend on characteristics of the *host*—the system that ultimately consumes the output JavaScript (or raw TypeScript, as the case may be) to direct its module loading behavior, typically either a runtime (like Node.js) or bundler (like Webpack).\n\nThe ECMAScript specification defines how ESM imports and exports link up with each other, but it doesn’t specify how the file lookup in (4), known as *module resolution*, happens, and it doesn’t say anything about other module systems like CommonJS. So runtimes and bundlers, especially those that want to support both ESM and CJS, have a lot of freedom to design their own rules. Consequently, the way TypeScript should answer the questions above can vary dramatically depending on where the code is intended to run. There’s no single right answer, so the compiler must be told the rules through configuration options.\n\nThe other key idea to keep in mind is that TypeScript almost always thinks about these questions in terms of its *output* JavaScript files, not its *input* TypeScript (or JavaScript!) files. Today, some runtimes and bundlers support loading TypeScript files directly, and in those cases, it doesn’t make sense to think about separate input and output files. Most of this document discusses cases where TypeScript files are compiled to JavaScript files, which in turn are loaded by the runtime module system. Examining these cases is essential for building an understanding of the compiler’s options and behavior—it’s easier to start there and simplify when thinking about esbuild, Bun, and other [TypeScript-first runtimes and bundlers](#module-resolution-for-bundlers-typescript-runtimes-and-nodejs-loaders). So for now, we can summarize TypeScript’s job when it comes to modules in terms of output files:\n\nUnderstand the **rules of the host** enough\n\n1.  to compile files into a valid **output module format**,\n2.  to ensure that imports in those **outputs** will **resolve successfully**, and\n3.  to know what **type** to assign to **imported names**.\n\n## Who is the host?\n\nBefore we move on, it’s worth making sure we’re on the same page about the term *host*, because it will come up frequently. We defined it before as “the system that ultimately consumes the output code to direct its module loading behavior.” In other words, it’s the system outside of TypeScript that TypeScript’s module analysis tries to model:\n\n- When the output code (whether produced by `tsc` or a third-party transpiler) is run directly in a runtime like Node.js, the runtime is the host.\n- When there is no “output code” because a runtime consumes TypeScript files directly, the runtime is still the host.\n- When a bundler consumes TypeScript inputs or outputs and produces a bundle, the bundler is the host, because it looked at the original set of imports/requires, looked up what files they referenced, and produced a new file or set of files where the original imports and requires are erased or transformed beyond recognition. (That bundle itself might comprise modules, and the runtime that runs it will be its host, but TypeScript doesn’t know about anything that happens post-bundler.)\n- If another transpiler, optimizer, or formatter runs on TypeScript’s outputs, it’s *not* a host that TypeScript cares about, as long as it leaves the imports and exports it sees alone.\n- When loading modules in a web browser, the behaviors TypeScript needs to model are actually split between the web server and the module system running in the browser. The browser’s JavaScript engine (or a script-based module-loading framework like RequireJS) controls what module formats are accepted, while the web server decides what file to send when one module triggers a request to load another.\n- The TypeScript compiler itself is not a host, because it does not provide any behavior related to modules beyond trying to model other hosts.\n\n## The module output format\n\nIn any project, the first question about modules we need to answer is what kinds of modules the host expects, so TypeScript can set its output format for each file to match. Sometimes, the host only *supports* one kind of module—ESM in the browser, or CJS in Node.js v11 and earlier, for example. Node.js v12 and later accepts both CJS and ES modules, but uses file extensions and `package.json` files to determine what format each file should be, and throws an error if the file’s contents don’t match the expected format.\n\nThe `module` compiler option provides this information to the compiler. Its primary purpose is to control the module format of any JavaScript that gets emitted during compilation, but it also serves to inform the compiler about how the module kind of each file should be detected, how different module kinds are allowed to import each other, and whether features like `import.meta` and top-level `await` are available. So, even if a TypeScript project is using `noEmit`, choosing the right setting for `module` still matters. As we established earlier, the compiler needs an accurate understanding of the module system so it can type check (and provide IntelliSense for) imports. See [*Choosing compiler options*](guides/choosing-compiler-options) for guidance on choosing the right `module` setting for your project.\n\nThe available `module` settings are\n\n- [**`node16`**](reference#node16-nodenext): Reflects the module system of Node.js v16+, which supports ES modules and CJS modules side-by-side with particular interoperability and detection rules.\n- [**`nodenext`**](reference#node16-nodenext): Currently identical to `node16`, but will be a moving target reflecting the latest Node.js versions as Node.js’s module system evolves.\n- [**`es2015`**](reference#es2015-es2020-es2022-esnext): Reflects the ES2015 language specification for JavaScript modules (the version that first introduced `import` and `export` to the language).\n- [**`es2020`**](reference#es2015-es2020-es2022-esnext): Adds support for `import.meta` and `export * as ns from \"mod\"` to `es2015`.\n- [**`es2022`**](reference#es2015-es2020-es2022-esnext): Adds support for top-level `await` to `es2020`.\n- [**`esnext`**](reference#es2015-es2020-es2022-esnext): Currently identical to `es2022`, but will be a moving target reflecting the latest ECMAScript specifications, as well as module-related Stage 3+ proposals that are expected to be included in upcoming specification versions.\n- **[`commonjs`](reference#commonjs), [`system`](reference#system), [`amd`](reference#amd), and [`umd`](reference#umd)**: Each emits everything in the module system named, and assumes everything can be successfully imported into that module system. These are no longer recommended for new projects and will not be covered in detail by this documentation.\n\n> Node.js’s rules for module format detection and interoperability make it incorrect to specify `module` as `esnext` or `commonjs` for projects that run in Node.js, even if all files emitted by `tsc` are ESM or CJS, respectively. The only correct `module` settings for projects that intend to run in Node.js are `node16` and `nodenext`. While the emitted JavaScript for an all-ESM Node.js project might look identical between compilations using `esnext` and `nodenext`, the type checking can differ. See the [reference section on `nodenext`](reference#node16-nodenext) for more details.\n\n### Module format detection\n\nNode.js understands both ES modules and CJS modules, but the format of each file is determined by its file extension and the `type` field of the first `package.json` file found in a search of the file’s directory and all ancestor directories:\n\n- `.mjs` and `.cjs` files are always interpreted as ES modules and CJS modules, respectively.\n- `.js` files are interpreted as ES modules if the nearest `package.json` file contains a `type` field with the value `\"module\"`. If there is no `package.json` file, or if the `type` field is missing or has any other value, `.js` files are interpreted as CJS modules.\n\nIf a file is determined to be an ES module by these rules, Node.js will not inject the CommonJS `module` and `require` objects into the file’s scope during evaluation, so a file that tries to use them will cause a crash. Conversely, if a file is determined to be a CJS module, `import` and `export` declarations in the file will cause a syntax error crash.\n\nWhen the `module` compiler option is set to `node16` or `nodenext`, TypeScript applies this same algorithm to the project’s *input* files to determine the module kind of each corresponding *output* file. Let’s look at how module formats are detected in an example project that uses `--module nodenext`:\n\n| Input file name                  | Contents               | Output file name | Module kind | Reason                                  |\n|----------------------------------|------------------------|------------------|-------------|-----------------------------------------|\n| `/package.json`                  | `{}`                   |                  |             |                                         |\n| `/main.mts`                      |                        | `/main.mjs`      | ESM         | File extension                          |\n| `/utils.cts`                     |                        | `/utils.cjs`     | CJS         | File extension                          |\n| `/example.ts`                    |                        | `/example.js`    | CJS         | No `\"type\": \"module\"` in `package.json` |\n| `/node_modules/pkg/package.json` | `{ \"type\": \"module\" }` |                  |             |                                         |\n| `/node_modules/pkg/index.d.ts`   |                        |                  | ESM         | `\"type\": \"module\"` in `package.json`    |\n| `/node_modules/pkg/index.d.cts`  |                        |                  | CJS         | File extension                          |\n\nWhen the input file extension is `.mts` or `.cts`, TypeScript knows to treat that file as an ES module or CJS module, respectively, because Node.js will treat the output `.mjs` file as an ES module or the output `.cjs` file as a CJS module. When the input file extension is `.ts`, TypeScript has to consult the nearest `package.json` file to determine the module format, because this is what Node.js will do when it encounters the output `.js` file. (Notice that the same rules apply to the `.d.cts` and `.d.ts` declaration files in the `pkg` dependency: though they will not produce an output file as part of this compilation, the presence of a `.d.ts` file *implies* the existence of a corresponding `.js` file—perhaps created when the author of the `pkg` library ran `tsc` on an input `.ts` file of their own—which Node.js must interpret as an ES module, due to its `.js` extension and the presence of the `\"type\": \"module\"` field in `/node_modules/pkg/package.json`. Declaration files are covered in more detail in a [later section](#the-role-of-declaration-files).)\n\nThe detected module format of input files is used by TypeScript to ensure it emits the output syntax that Node.js expects in each output file. If TypeScript were to emit `/example.js` with `import` and `export` statements in it, Node.js would crash when parsing the file. If TypeScript were to emit `/main.mjs` with `require` calls, Node.js would crash during evaluation. Beyond emit, the module format is also used to determine rules for type checking and module resolution, which we’ll discuss in the following sections.\n\nIt’s worth mentioning again that TypeScript’s behavior in `--module node16` and `--module nodenext` is entirely motivated by Node.js’s behavior. Since TypeScript’s goal is to catch potential runtime errors at compile time, it needs a very accurate model of what will happen at runtime. This fairly complex set of rules for module kind detection is *necessary* for checking code that will run in Node.js, but may be overly strict or just incorrect if applied to non-Node.js hosts.\n\n### Input module syntax\n\nIt’s important to note that the *input* module syntax seen in input source files is somewhat decoupled from the output module syntax emitted to JS files. That is, a file with an ESM import:\n\n``` ts\nimport { sayHello } from \"greetings\";\nsayHello(\"world\");\n```\n\nmight be emitted in ESM format exactly as-is, or might be emitted as CommonJS:\n\n``` ts\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst greetings_1 = require(\"greetings\");\n(0, greetings_1.sayHello)(\"world\");\n```\n\ndepending on the `module` compiler option (and any applicable [module format detection](#module-format-detection) rules, if the `module` option supports more than one kind of module). In general, this means that looking at the contents of an input file isn’t enough to determine whether it’s an ES module or a CJS module.\n\n> Today, most TypeScript files are authored using ESM syntax (`import` and `export` statements) regardless of the output format. This is largely a legacy of the long road ESM has taken to widespread support. ECMAScript modules were standardized in 2015, were supported in most browsers by 2017, and landed in Node.js v12 in 2019. During much of this window, it was clear that ESM was the future of JavaScript modules, but very few runtimes could consume it. Tools like Babel made it possible for JavaScript to be authored in ESM and downleveled to another module format that could be used in Node.js or browsers. TypeScript followed suit, adding support for ES module syntax and softly discouraging the use of the original CommonJS-inspired `import fs = require(\"fs\")` syntax in [the 1.5 release](https://devblogs.microsoft.com/typescript/announcing-typescript-1-5/).\n>\n> The upside of this “author ESM, output anything” strategy was that TypeScript could use standard JavaScript syntax, making the authoring experience familiar to newcomers, and (theoretically) making it easy for projects to start targeting ESM outputs in the future. There are three significant downsides, which became fully apparent only after ESM and CJS modules were allowed to coexist and interoperate in Node.js:\n>\n> 1.  Early assumptions about how ESM/CJS interoperability would work in Node.js turned out to be wrong, and today, interoperability rules differ between Node.js and bundlers. Consequently, the configuration space for modules in TypeScript is large.\n> 2.  When the syntax in input files all looks like ESM, it’s easy for an author or code reviewer to lose track of what kind of module a file is at runtime. And because of Node.js’s interoperability rules, what kind of module each file is became very important.\n> 3.  When input files are written in ESM, the syntax in type declaration outputs (`.d.ts` files) looks like ESM too. But because the corresponding JavaScript files could have been emitted in any module format, TypeScript can’t tell what kind of module a file is just by looking at the contents of its type declarations. And again, because of the nature of ESM/CJS interoperability, TypeScript *has* to know what kind of module everything is in order to provide correct types and prevent imports that will crash.\n>\n> In TypeScript 5.0, a new compiler option called `verbatimModuleSyntax` was introduced to help TypeScript authors know exactly how their `import` and `export` statements will be emitted. When enabled, the flag requires imports and exports in input files to be written in the form that will undergo the least amount of transformation before emit. So if a file will be emitted as ESM, imports and exports must be written in ESM syntax; if a file will be emitted as CJS, it must be written in the CommonJS-inspired TypeScript syntax (`import fs = require(\"fs\")` and `export = {}`). This setting is particularly recommended for Node.js projects that use mostly ESM, but have a select few CJS files. It is not recommended for projects that currently target CJS, but may want to target ESM in the future.\n\n### ESM and CJS interoperability\n\nCan an ES module `import` a CommonJS module? If so, does a default import link to `exports` or `exports.default`? Can a CommonJS module `require` an ES module? CommonJS isn’t part of the ECMAScript specification, so runtimes, bundlers, and transpilers have been free to make up their own answers to these questions since ESM was standardized in 2015, and as such no standard set of interoperability rules exist. Today, most runtimes and bundlers broadly fall into one of three categories:\n\n1.  **ESM-only.** Some runtimes, like browser engines, only support what’s actually a part of the language: ECMAScript Modules.\n2.  **Bundler-like.** Before any major JavaScript engine could run ES modules, Babel allowed developers to write them by transpiling them to CommonJS. The way these ESM-transpiled-to-CJS files interacted with hand-written-CJS files implied a set of permissive interoperability rules that have become the de facto standard for bundlers and transpilers.\n3.  **Node.js.** In Node.js, CommonJS modules cannot load ES modules synchronously (with `require`); they can only load them asynchronously with dynamic `import()` calls. ES modules can default-import CJS modules, which always binds to `exports`. (This means that a default import of a Babel-like CJS output with `__esModule` behaves differently between Node.js and some bundlers.)\n\nTypeScript needs to know which of these rule sets to assume in order to provide correct types on (particularly `default`) imports and to error on imports that will crash at runtime. When the `module` compiler option is set to `node16` or `nodenext`, Node.js’s rules are enforced. All other `module` settings, combined with the [`esModuleInterop`](reference#esModuleInterop) option, result in bundler-like interop in TypeScript. (While using `--module esnext` does prevent you from *writing* CommonJS modules, it does not prevent you from *importing* them as dependencies. There’s currently no TypeScript setting that can guard against an ES module importing a CommonJS module, as would be appropriate for direct-to-browser code.)\n\n### Module specifiers are not transformed\n\nWhile the `module` compiler option can transform imports and exports in input files to different module formats in output files, the module *specifier* (the string `from` which you `import`, or pass to `require`) is always emitted as-written. For example, an input like:\n\n``` ts\nimport { add } from \"./math.mjs\";\nadd(1, 2);\n```\n\nmight be emitted as either:\n\n``` ts\nimport { add } from \"./math.mjs\";\nadd(1, 2);\n```\n\nor:\n\n``` ts\nconst math_1 = require(\"./math.mjs\");\nmath_1.add(1, 2);\n```\n\ndepending on the `module` compiler option, but the module specifier will always be `\"./math.mjs\"`. There is no compiler option that enables transforming, substituting, or rewriting module specifiers. Consequently, module specifiers must be written in a way that works for the code’s target runtime or bundler, and it’s TypeScript’s job to understand those *output*-relative specifiers. The process of finding the file referenced by a module specifier is called *module resolution*.\n\n## Module resolution\n\nLet’s return to our [first example](#typescripts-job-concerning-modules) and review what we’ve learned about it so far:\n\n``` ts\nimport sayHello from \"greetings\";\nsayHello(\"world\");\n```\n\nSo far, we’ve discussed how the host’s module system and TypeScript’s `module` compiler option might impact this code. We know that the input syntax looks like ESM, but the output format depends on the `module` compiler option, potentially the file extension, and `package.json` `\"type\"` field. We also know that what `sayHello` gets bound to, and even whether the import is even allowed, may vary depending on the module kinds of this file and the target file. But we haven’t yet discussed how to *find* the target file.\n\n### Module resolution is host-defined\n\nWhile the ECMAScript specification defines how to parse and interpret `import` and `export` statements, it leaves module resolution up to the host. If you’re creating a hot new JavaScript runtime, you’re free to create a module resolution scheme like:\n\n``` ts\nimport monkey from \"🐒\"; // Looks for './eats/bananas.js'\nimport cow from \"🐄\";    // Looks for './eats/grass.js'\nimport lion from \"🦁\";   // Looks for './eats/you.js'\n```\n\nand still claim to implement “standards-compliant ESM.” Needless to say, TypeScript would have no idea what types to assign to `monkey`, `cow`, and `lion` without built-in knowledge of this runtime’s module resolution algorithm. Just as `module` informs the compiler about the host’s expected module format, `moduleResolution`, along with a few customization options, specify the algorithm the host uses to resolve module specifiers to files. This also clarifies why TypeScript doesn’t modify import specifiers during emit: the relationship between an import specifier and a file on disk (if one even exists) is host-defined, and TypeScript is not a host.\n\nThe available `moduleResolution` options are:\n\n- [**`classic`**](reference#classic): TypeScript’s oldest module resolution mode, this is unfortunately the default when `module` is set to anything other than `commonjs`, `node16`, or `nodenext`. It was probably made to provide best-effort resolution for a wide range of [RequireJS](https://requirejs.org/docs/api.html#packages) configurations. It should not be used for new projects (or even old projects that don’t use RequireJS or another AMD module loader), and is scheduled for deprecation in TypeScript 6.0.\n- [**`node10`**](reference#node10-formerly-known-as-node): Formerly known as `node`, this is the unfortunate default when `module` is set to `commonjs`. It’s a pretty good model of Node.js versions older than v12, and sometimes it’s a passable approximation of how most bundlers do module resolution. It supports looking up packages from `node_modules`, loading directory `index.js` files, and omitting `.js` extensions in relative module specifiers. Because Node.js v12 introduced different module resolution rules for ES modules, though, it’s a very bad model of modern versions of Node.js. It should not be used for new projects.\n- [**`node16`**](reference#node16-nodenext-1): This is the counterpart of `--module node16` and is set by default with that `module` setting. Node.js v12 and later support both ESM and CJS, each of which uses its own module resolution algorithm. In Node.js, module specifiers in import statements and dynamic `import()` calls are not allowed to omit file extensions or `/index.js` suffixes, while module specifiers in `require` calls are. This module resolution mode understands and enforces this restriction where necessary, as determined by the [module format detection rules](#module-format-detection) instated by `--module node16`. (For `node16` and `nodenext`, `module` and `moduleResolution` go hand-in-hand: setting one to `node16` or `nodenext` while setting the other to something else has unsupported behavior and may be an error in the future.)\n- [**`nodenext`**](reference#node16-nodenext-1): Currently identical to `node16`, this is the counterpart of `--module nodenext` and is set by default with that `module` setting. It’s intended to be a forward-looking mode that will support new Node.js module resolution features as they’re added.\n- [**`bundler`**](reference#bundler): Node.js v12 introduced some new module resolution features for importing npm packages—the `\"exports\"` and `\"imports\"` fields of `package.json`—and many bundlers adopted those features without also adopting the stricter rules for ESM imports. This module resolution mode provides a base algorithm for code targeting a bundler. It supports `package.json` `\"exports\"` and `\"imports\"` by default, but can be configured to ignore them. It requires setting `module` to `esnext`.\n\n### TypeScript imitates the host’s module resolution, but with types\n\nRemember the three components of TypeScript’s [job](#typescripts-job-concerning-modules) concerning modules?\n\n1.  Compile files into a valid **output module format**\n2.  Ensure that imports in those **outputs** will **resolve successfully**\n3.  Know what **type** to assign to **imported names**.\n\nModule resolution is needed to accomplish last two. But when we spend most of our time working in input files, it can be easy to forget about (2)—that a key component of module resolution is validating that the imports or `require` calls in the output files, containing the [same module specifiers as the input files](#module-specifiers-are-not-transformed), will actually work at runtime. Let’s look at a new example with multiple files:\n\n``` ts\n// @Filename: math.ts\nexport function add(a: number, b: number) {\n  return a + b;\n}\n\n// @Filename: main.ts\nimport { add } from \"./math\";\nadd(1, 2);\n```\n\nWhen we see the import from `\"./math\"`, it might be tempting to think, “This is how one TypeScript file refers to another. The compiler follows this (extensionless) path in order to assign a type to `add`.”\n\nThis isn’t entirely wrong, but the reality is deeper. The resolution of `\"./math\"` (and subsequently, the type of `add`) need to reflect the reality of what happens at runtime to the *output* files. A more robust way to think about this process would look like this:\n\nThis model makes it clear that for TypeScript, module resolution is mostly a matter of accurately modeling the host’s module resolution algorithm between output files, with a little bit of remapping applied to find type information. Let’s look at another example that appears unintuitive through the lens of the simple model, but makes perfect sense with the robust model:\n\n``` ts\n// @moduleResolution: node16\n// @rootDir: src\n// @outDir: dist\n\n// @Filename: src/math.mts\nexport function add(a: number, b: number) {\n  return a + b;\n}\n\n// @Filename: src/main.mts\nimport { add } from \"./math.mjs\";\nadd(1, 2);\n```\n\nNode.js ESM `import` declarations use a strict module resolution algorithm that requires relative paths to include file extensions. When we only think about input files, it’s a little strange that `\"./math.mjs\"` seems to resolve to `math.mts`. Since we’re using an `outDir` to put compiled outputs in a different directory, `math.mjs` doesn’t even exist next to `main.mts`! Why should this resolve? With our new mental model, it’s no problem:\n\nUnderstanding this mental model may not immediately eliminate the strangeness of seeing output file extensions in input files, and it’s natural to think in terms of shortcuts: *`\"./math.mjs\"` refers to the input file `math.mts`. I have to write the output extension, but the compiler knows to look for `.mts` when I write `.mjs`.* This shortcut is even how the compiler works internally, but the more robust mental model explains *why* module resolution in TypeScript works this way: given the constraint that the module specifier in the output file will be [the same](#module-specifiers-are-not-transformed) as the module specifier in the input file, this is the only process that accomplishes our two goals of validating output files and assigning types.\n\n### The role of declaration files\n\nIn the previous example, we saw the “remapping” part of module resolution working between input and output files. But what happens when we import library code? Even if the library was written in TypeScript, it may not have published its source code. If we can’t rely on mapping the library’s JavaScript files back to a TypeScript file, we can verify that our import works at runtime, but how do we accomplish our second goal of assigning types?\n\nThis is where declaration files (`.d.ts`, `.d.mts`, etc.) come into play. The best way to understand how declaration files are interpreted is to understand where they come from. When you run `tsc --declaration` on an input file, you get one output JavaScript file and one output declaration file:\n\nBecause of this relationship, the compiler *assumes* that wherever it sees a declaration file, there is a corresponding JavaScript file that is perfectly described by the type information in the declaration file. For performance reasons, in every module resolution mode, the compiler always looks for TypeScript and declaration files first, and if it finds one, it doesn’t continue looking for the corresponding JavaScript file. If it finds a TypeScript input file, it knows a JavaScript file *will* exist after compilation, and if it finds a declaration file, it knows a compilation (perhaps someone else’s) already happened and created a JavaScript file at the same time as the declaration file.\n\nThe declaration file tells the compiler not only that a JavaScript file exists, but also what its name and extension are:\n\n| Declaration file extension | JavaScript file extension | TypeScript file extension |\n|----------------------------|---------------------------|---------------------------|\n| `.d.ts`                    | `.js`                     | `.ts`                     |\n| `.d.ts`                    | `.js`                     | `.tsx`                    |\n| `.d.mts`                   | `.mjs`                    | `.mts`                    |\n| `.d.cts`                   | `.cjs`                    | `.cts`                    |\n| `.d.*.ts`                  | `.*`                      |                           |\n\nThe last row expresses that non-JS files can be typed with the `allowArbitraryExtensions` compiler option to support cases where the module system supports importing non-JS files as JavaScript objects. For example, a file named `styles.css` can be represented by a declaration file named `styles.d.css.ts`.\n\n> “But wait! Plenty of declaration files are written by hand, *not* generated by `tsc`. Ever heard of DefinitelyTyped?” you might object. And it’s true—hand-writing declaration files, or even moving/copying/renaming them to represent outputs of an external build tool, is a dangerous, error-prone venture. DefinitelyTyped contributors and authors of typed libraries not using `tsc` to generate both JavaScript and declaration files should ensure that every JavaScript file has a sibling declaration file with the same name and matching extension. Breaking from this structure can lead to false-positive TypeScript errors for end users. The npm package [`@arethetypeswrong/cli`](https://www.npmjs.com/package/@arethetypeswrong/cli) can help catch and explain these errors before they’re published.\n\n### Module resolution for bundlers, TypeScript runtimes, and Node.js loaders\n\nSo far, we’ve really emphasized the distinction between *input files* and *output files*. Recall that when specifying a file extension on a relative module specifier, TypeScript typically [makes you use the *output* file extension](#typescript-imitates-the-hosts-module-resolution-but-with-types):\n\n``` ts\n// @Filename: src/math.ts\nexport function add(a: number, b: number) {\n  return a + b;\n}\n\n// @Filename: src/main.ts\nimport { add } from \"./math.ts\";\n//                  ^^^^^^^^^^^\n// An import path can only end with a '.ts' extension when 'allowImportingTsExtensions' is enabled.\n```\n\nThis restriction applies since TypeScript [won’t rewrite the extension](#module-specifiers-are-not-transformed) to `.js`, and if `\"./math.ts\"` appears in an output JS file, that import won’t resolve to another JS file at runtime. TypeScript really wants to prevent you from generating an unsafe output JS file. But what if there *is* no output JS file? What if you’re in one of these situations:\n\n- You’re bundling this code, the bundler is configured to transpile TypeScript files in-memory, and it will eventually consume and erase all the imports you’ve written to produce a bundle.\n- You’re running this code directly in a TypeScript runtime like Deno or Bun.\n- You’re using `ts-node`, `tsx`, or another transpiling loader for Node.\n\nIn these cases, you can turn on `noEmit` (or `emitDeclarationOnly`) and `allowImportingTsExtensions` to disable emitting unsafe JavaScript files and silence the error on `.ts`-extensioned imports.\n\nWith or without `allowImportingTsExtensions`, it’s still important to pick the most appropriate `moduleResolution` setting for the module resolution host. For bundlers and the Bun runtime, it’s `bundler`. These module resolvers were inspired by Node.js, but didn’t adopt the strict ESM resolution algorithm that [disables extension searching](#extension-searching-and-directory-index-files) that Node.js applies to imports. The `bundler` module resolution setting reflects this, enabling `package.json` `\"exports\"` support like `node16` and `nodenext`, while always allowing extensionless imports. See [*Choosing compiler options*](guides/choosing-compiler-options) for more guidance.\n\n### Module resolution for libraries\n\nWhen compiling an app, you choose the `moduleResolution` option for a TypeScript project based on who the module resolution [host](#module-resolution-is-host-defined) is. When compiling a library, you don’t know where the output code will run, but you’d like it to run in as many places as possible. Using `\"module\": \"nodenext\"` (along with the implied [`\"moduleResolution\": \"nodenext\"`](reference#node16-nodenext)) is the best bet for maximizing the compatibility of the output JavaScript’s module specifiers, since it will force you to comply with Node.js’s stricter rules for `import` module resolution. Let’s look at what would happen if a library were to compile with `\"moduleResolution\": \"bundler\"` (or worse, `\"node10\"`):\n\n``` ts\nexport * from \"./utils\";\n```\n\nAssuming `./utils.ts` (or `./utils/index.ts`) exists, a bundler would be fine with this code, so `\"moduleResolution\": \"bundler\"` doesn’t complain. Compiled with `\"module\": \"esnext\"`, the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:\n\n``` typescript\nError [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js\nDid you mean to import ./utils.js?\n```\n\nOn the other hand, if we had written:\n\n``` ts\nexport * from \"./utils.js\";\n```\n\nThis would produce output that works both in Node.js *and* in bundlers.\n\nIn short, `\"moduleResolution\": \"bundler\"` is infectious, allowing code that only works in bundlers to be produced. Likewise, `\"moduleResolution\": \"nodenext\"` is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers.\n\nOf course, this guidance can only apply in cases where the library ships outputs from `tsc`. If the library is being bundled *before* shipping, `\"moduleResolution\": \"bundler\"` may be acceptable. Any build tool that changes the module format or module specifiers to produce the final build of the library bears the responsibility of ensuring the safety and compatibility of the product’s module code, and `tsc` can no longer contribute to that task, since it can’t know what module code will exist at runtime.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/modules/theory.html](https://www.typescriptlang.org/docs/handbook/modules/theory.html)"
- name: 'Modules - Theory: Module resolution'
  id: modules/theory#module-resolution
  summary: So far, we’ve discussed how the host’s module system and TypeScript’s module compiler option might impact this code
  belongs_to: Modules - Theory
  description: "## Module resolution\n\nLet’s return to our [first example](#typescripts-job-concerning-modules) and review what we’ve learned about it so far:\n\n``` ts\nimport sayHello from \"greetings\";\nsayHello(\"world\");\n```\n\nSo far, we’ve discussed how the host’s module system and TypeScript’s `module` compiler option might impact this code. We know that the input syntax looks like ESM, but the output format depends on the `module` compiler option, potentially the file extension, and `package.json` `\"type\"` field. We also know that what `sayHello` gets bound to, and even whether the import is even allowed, may vary depending on the module kinds of this file and the target file. But we haven’t yet discussed how to *find* the target file.\n\n### Module resolution is host-defined\n\nWhile the ECMAScript specification defines how to parse and interpret `import` and `export` statements, it leaves module resolution up to the host. If you’re creating a hot new JavaScript runtime, you’re free to create a module resolution scheme like:\n\n``` ts\nimport monkey from \"🐒\"; // Looks for './eats/bananas.js'\nimport cow from \"🐄\";    // Looks for './eats/grass.js'\nimport lion from \"🦁\";   // Looks for './eats/you.js'\n```\n\nand still claim to implement “standards-compliant ESM.” Needless to say, TypeScript would have no idea what types to assign to `monkey`, `cow`, and `lion` without built-in knowledge of this runtime’s module resolution algorithm. Just as `module` informs the compiler about the host’s expected module format, `moduleResolution`, along with a few customization options, specify the algorithm the host uses to resolve module specifiers to files. This also clarifies why TypeScript doesn’t modify import specifiers during emit: the relationship between an import specifier and a file on disk (if one even exists) is host-defined, and TypeScript is not a host.\n\nThe available `moduleResolution` options are:\n\n- [**`classic`**](reference#classic): TypeScript’s oldest module resolution mode, this is unfortunately the default when `module` is set to anything other than `commonjs`, `node16`, or `nodenext`. It was probably made to provide best-effort resolution for a wide range of [RequireJS](https://requirejs.org/docs/api.html#packages) configurations. It should not be used for new projects (or even old projects that don’t use RequireJS or another AMD module loader), and is scheduled for deprecation in TypeScript 6.0.\n- [**`node10`**](reference#node10-formerly-known-as-node): Formerly known as `node`, this is the unfortunate default when `module` is set to `commonjs`. It’s a pretty good model of Node.js versions older than v12, and sometimes it’s a passable approximation of how most bundlers do module resolution. It supports looking up packages from `node_modules`, loading directory `index.js` files, and omitting `.js` extensions in relative module specifiers. Because Node.js v12 introduced different module resolution rules for ES modules, though, it’s a very bad model of modern versions of Node.js. It should not be used for new projects.\n- [**`node16`**](reference#node16-nodenext-1): This is the counterpart of `--module node16` and is set by default with that `module` setting. Node.js v12 and later support both ESM and CJS, each of which uses its own module resolution algorithm. In Node.js, module specifiers in import statements and dynamic `import()` calls are not allowed to omit file extensions or `/index.js` suffixes, while module specifiers in `require` calls are. This module resolution mode understands and enforces this restriction where necessary, as determined by the [module format detection rules](#module-format-detection) instated by `--module node16`. (For `node16` and `nodenext`, `module` and `moduleResolution` go hand-in-hand: setting one to `node16` or `nodenext` while setting the other to something else has unsupported behavior and may be an error in the future.)\n- [**`nodenext`**](reference#node16-nodenext-1): Currently identical to `node16`, this is the counterpart of `--module nodenext` and is set by default with that `module` setting. It’s intended to be a forward-looking mode that will support new Node.js module resolution features as they’re added.\n- [**`bundler`**](reference#bundler): Node.js v12 introduced some new module resolution features for importing npm packages—the `\"exports\"` and `\"imports\"` fields of `package.json`—and many bundlers adopted those features without also adopting the stricter rules for ESM imports. This module resolution mode provides a base algorithm for code targeting a bundler. It supports `package.json` `\"exports\"` and `\"imports\"` by default, but can be configured to ignore them. It requires setting `module` to `esnext`.\n\n### TypeScript imitates the host’s module resolution, but with types\n\nRemember the three components of TypeScript’s [job](#typescripts-job-concerning-modules) concerning modules?\n\n1.  Compile files into a valid **output module format**\n2.  Ensure that imports in those **outputs** will **resolve successfully**\n3.  Know what **type** to assign to **imported names**.\n\nModule resolution is needed to accomplish last two. But when we spend most of our time working in input files, it can be easy to forget about (2)—that a key component of module resolution is validating that the imports or `require` calls in the output files, containing the [same module specifiers as the input files](#module-specifiers-are-not-transformed), will actually work at runtime. Let’s look at a new example with multiple files:\n\n``` ts\n// @Filename: math.ts\nexport function add(a: number, b: number) {\n  return a + b;\n}\n\n// @Filename: main.ts\nimport { add } from \"./math\";\nadd(1, 2);\n```\n\nWhen we see the import from `\"./math\"`, it might be tempting to think, “This is how one TypeScript file refers to another. The compiler follows this (extensionless) path in order to assign a type to `add`.”\n\nThis isn’t entirely wrong, but the reality is deeper. The resolution of `\"./math\"` (and subsequently, the type of `add`) need to reflect the reality of what happens at runtime to the *output* files. A more robust way to think about this process would look like this:\n\nThis model makes it clear that for TypeScript, module resolution is mostly a matter of accurately modeling the host’s module resolution algorithm between output files, with a little bit of remapping applied to find type information. Let’s look at another example that appears unintuitive through the lens of the simple model, but makes perfect sense with the robust model:\n\n``` ts\n// @moduleResolution: node16\n// @rootDir: src\n// @outDir: dist\n\n// @Filename: src/math.mts\nexport function add(a: number, b: number) {\n  return a + b;\n}\n\n// @Filename: src/main.mts\nimport { add } from \"./math.mjs\";\nadd(1, 2);\n```\n\nNode.js ESM `import` declarations use a strict module resolution algorithm that requires relative paths to include file extensions. When we only think about input files, it’s a little strange that `\"./math.mjs\"` seems to resolve to `math.mts`. Since we’re using an `outDir` to put compiled outputs in a different directory, `math.mjs` doesn’t even exist next to `main.mts`! Why should this resolve? With our new mental model, it’s no problem:\n\nUnderstanding this mental model may not immediately eliminate the strangeness of seeing output file extensions in input files, and it’s natural to think in terms of shortcuts: *`\"./math.mjs\"` refers to the input file `math.mts`. I have to write the output extension, but the compiler knows to look for `.mts` when I write `.mjs`.* This shortcut is even how the compiler works internally, but the more robust mental model explains *why* module resolution in TypeScript works this way: given the constraint that the module specifier in the output file will be [the same](#module-specifiers-are-not-transformed) as the module specifier in the input file, this is the only process that accomplishes our two goals of validating output files and assigning types.\n\n### The role of declaration files\n\nIn the previous example, we saw the “remapping” part of module resolution working between input and output files. But what happens when we import library code? Even if the library was written in TypeScript, it may not have published its source code. If we can’t rely on mapping the library’s JavaScript files back to a TypeScript file, we can verify that our import works at runtime, but how do we accomplish our second goal of assigning types?\n\nThis is where declaration files (`.d.ts`, `.d.mts`, etc.) come into play. The best way to understand how declaration files are interpreted is to understand where they come from. When you run `tsc --declaration` on an input file, you get one output JavaScript file and one output declaration file:\n\nBecause of this relationship, the compiler *assumes* that wherever it sees a declaration file, there is a corresponding JavaScript file that is perfectly described by the type information in the declaration file. For performance reasons, in every module resolution mode, the compiler always looks for TypeScript and declaration files first, and if it finds one, it doesn’t continue looking for the corresponding JavaScript file. If it finds a TypeScript input file, it knows a JavaScript file *will* exist after compilation, and if it finds a declaration file, it knows a compilation (perhaps someone else’s) already happened and created a JavaScript file at the same time as the declaration file.\n\nThe declaration file tells the compiler not only that a JavaScript file exists, but also what its name and extension are:\n\n| Declaration file extension | JavaScript file extension | TypeScript file extension |\n|----------------------------|---------------------------|---------------------------|\n| `.d.ts`                    | `.js`                     | `.ts`                     |\n| `.d.ts`                    | `.js`                     | `.tsx`                    |\n| `.d.mts`                   | `.mjs`                    | `.mts`                    |\n| `.d.cts`                   | `.cjs`                    | `.cts`                    |\n| `.d.*.ts`                  | `.*`                      |                           |\n\nThe last row expresses that non-JS files can be typed with the `allowArbitraryExtensions` compiler option to support cases where the module system supports importing non-JS files as JavaScript objects. For example, a file named `styles.css` can be represented by a declaration file named `styles.d.css.ts`.\n\n> “But wait! Plenty of declaration files are written by hand, *not* generated by `tsc`. Ever heard of DefinitelyTyped?” you might object. And it’s true—hand-writing declaration files, or even moving/copying/renaming them to represent outputs of an external build tool, is a dangerous, error-prone venture. DefinitelyTyped contributors and authors of typed libraries not using `tsc` to generate both JavaScript and declaration files should ensure that every JavaScript file has a sibling declaration file with the same name and matching extension. Breaking from this structure can lead to false-positive TypeScript errors for end users. The npm package [`@arethetypeswrong/cli`](https://www.npmjs.com/package/@arethetypeswrong/cli) can help catch and explain these errors before they’re published.\n\n### Module resolution for bundlers, TypeScript runtimes, and Node.js loaders\n\nSo far, we’ve really emphasized the distinction between *input files* and *output files*. Recall that when specifying a file extension on a relative module specifier, TypeScript typically [makes you use the *output* file extension](#typescript-imitates-the-hosts-module-resolution-but-with-types):\n\n``` ts\n// @Filename: src/math.ts\nexport function add(a: number, b: number) {\n  return a + b;\n}\n\n// @Filename: src/main.ts\nimport { add } from \"./math.ts\";\n//                  ^^^^^^^^^^^\n// An import path can only end with a '.ts' extension when 'allowImportingTsExtensions' is enabled.\n```\n\nThis restriction applies since TypeScript [won’t rewrite the extension](#module-specifiers-are-not-transformed) to `.js`, and if `\"./math.ts\"` appears in an output JS file, that import won’t resolve to another JS file at runtime. TypeScript really wants to prevent you from generating an unsafe output JS file. But what if there *is* no output JS file? What if you’re in one of these situations:\n\n- You’re bundling this code, the bundler is configured to transpile TypeScript files in-memory, and it will eventually consume and erase all the imports you’ve written to produce a bundle.\n- You’re running this code directly in a TypeScript runtime like Deno or Bun.\n- You’re using `ts-node`, `tsx`, or another transpiling loader for Node.\n\nIn these cases, you can turn on `noEmit` (or `emitDeclarationOnly`) and `allowImportingTsExtensions` to disable emitting unsafe JavaScript files and silence the error on `.ts`-extensioned imports.\n\nWith or without `allowImportingTsExtensions`, it’s still important to pick the most appropriate `moduleResolution` setting for the module resolution host. For bundlers and the Bun runtime, it’s `bundler`. These module resolvers were inspired by Node.js, but didn’t adopt the strict ESM resolution algorithm that [disables extension searching](#extension-searching-and-directory-index-files) that Node.js applies to imports. The `bundler` module resolution setting reflects this, enabling `package.json` `\"exports\"` support like `node16` and `nodenext`, while always allowing extensionless imports. See [*Choosing compiler options*](guides/choosing-compiler-options) for more guidance.\n\n### Module resolution for libraries\n\nWhen compiling an app, you choose the `moduleResolution` option for a TypeScript project based on who the module resolution [host](#module-resolution-is-host-defined) is. When compiling a library, you don’t know where the output code will run, but you’d like it to run in as many places as possible. Using `\"module\": \"nodenext\"` (along with the implied [`\"moduleResolution\": \"nodenext\"`](reference#node16-nodenext)) is the best bet for maximizing the compatibility of the output JavaScript’s module specifiers, since it will force you to comply with Node.js’s stricter rules for `import` module resolution. Let’s look at what would happen if a library were to compile with `\"moduleResolution\": \"bundler\"` (or worse, `\"node10\"`):\n\n``` ts\nexport * from \"./utils\";\n```\n\nAssuming `./utils.ts` (or `./utils/index.ts`) exists, a bundler would be fine with this code, so `\"moduleResolution\": \"bundler\"` doesn’t complain. Compiled with `\"module\": \"esnext\"`, the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:\n\n``` typescript\nError [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js\nDid you mean to import ./utils.js?\n```\n\nOn the other hand, if we had written:\n\n``` ts\nexport * from \"./utils.js\";\n```\n\nThis would produce output that works both in Node.js *and* in bundlers.\n\nIn short, `\"moduleResolution\": \"bundler\"` is infectious, allowing code that only works in bundlers to be produced. Likewise, `\"moduleResolution\": \"nodenext\"` is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers.\n\nOf course, this guidance can only apply in cases where the library ships outputs from `tsc`. If the library is being bundled *before* shipping, `\"moduleResolution\": \"bundler\"` may be acceptable. Any build tool that changes the module format or module specifiers to produce the final build of the library bears the responsibility of ensuring the safety and compatibility of the product’s module code, and `tsc` can no longer contribute to that task, since it can’t know what module code will exist at runtime.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/modules/theory.html](https://www.typescriptlang.org/docs/handbook/modules/theory.html)"
- name: 'Modules - Theory: Scripts and modules in JavaScript'
  id: modules/theory#scripts-and-modules-in-javascript
  summary: This approach had some downsides, especially as web pages grew larger and more complex
  belongs_to: Modules - Theory
  description: |-
    ## Scripts and modules in JavaScript

    In the early days of JavaScript, when the language only ran in browsers, there were no modules, but it was still possible to split the JavaScript for a web page into multiple files by using multiple `script` tags in HTML:

    ``` html
    <html>
      <head>
        <script src="a.js"></script>
        <script src="b.js"></script>
      </head>
      <body></body>
    </html>
    ```

    This approach had some downsides, especially as web pages grew larger and more complex. In particular, all scripts loaded onto the same page share the same scope—appropriately called the “global scope”—meaning the scripts had to be very careful not to overwrite each others’ variables and functions.

    Any system that solves this problem by giving files their own scope while still providing a way to make bits of code available to other files can be called a “module system.” (It may sound obvious to say that each file in a module system is called a “module,” but the term is often used to contrast with *script* files, which run outside a module system, in a global scope.)

    > There are [many module systems](https://github.com/myshov/history-of-javascript/tree/master/4_evolution_of_js_modularity), and TypeScript [supports emitting several](https://www.typescriptlang.org/tsconfig/#module), but this documentation will focus on the two most important systems today: ECMAScript modules (ESM) and CommonJS (CJS).
    >
    > ECMAScript Modules (ESM) is the module system built into the language, supported in modern browsers and in Node.js since v12. It uses dedicated `import` and `export` syntax:
    >
    > ``` js
    > // a.js
    > export default "Hello from a.js";
    > ```
    >
    > ``` js
    > // b.js
    > import a from "./a.js";
    > console.log(a); // 'Hello from a.js'
    > ```
    >
    > CommonJS (CJS) is the module system that originally shipped in Node.js, before ESM was part of the language specification. It’s still supported in Node.js alongside ESM. It uses plain JavaScript objects and functions named `exports` and `require`:
    >
    > ``` js
    > // a.js
    > exports.message = "Hello from a.js";
    > ```
    >
    > ``` js
    > // b.js
    > const a = require("./a");
    > console.log(a.message); // 'Hello from a.js'
    > ```

    Accordingly, when TypeScript detects that a file is a CommonJS or ECMAScript module, it starts by assuming that file will have its own scope. Beyond that, though, the compiler’s job gets a little more complicated.
- name: 'Modules - Theory: The module output format'
  id: modules/theory#the-module-output-format
  summary: In any project, the first question about modules we need to answer is what kinds of modules the host expects, so TypeScript can set its output format for each file to match
  belongs_to: Modules - Theory
  description: |-
    ## The module output format

    In any project, the first question about modules we need to answer is what kinds of modules the host expects, so TypeScript can set its output format for each file to match. Sometimes, the host only *supports* one kind of module—ESM in the browser, or CJS in Node.js v11 and earlier, for example. Node.js v12 and later accepts both CJS and ES modules, but uses file extensions and `package.json` files to determine what format each file should be, and throws an error if the file’s contents don’t match the expected format.

    The `module` compiler option provides this information to the compiler. Its primary purpose is to control the module format of any JavaScript that gets emitted during compilation, but it also serves to inform the compiler about how the module kind of each file should be detected, how different module kinds are allowed to import each other, and whether features like `import.meta` and top-level `await` are available. So, even if a TypeScript project is using `noEmit`, choosing the right setting for `module` still matters. As we established earlier, the compiler needs an accurate understanding of the module system so it can type check (and provide IntelliSense for) imports. See [*Choosing compiler options*](guides/choosing-compiler-options) for guidance on choosing the right `module` setting for your project.

    The available `module` settings are

    - [**`node16`**](reference#node16-nodenext): Reflects the module system of Node.js v16+, which supports ES modules and CJS modules side-by-side with particular interoperability and detection rules.
    - [**`nodenext`**](reference#node16-nodenext): Currently identical to `node16`, but will be a moving target reflecting the latest Node.js versions as Node.js’s module system evolves.
    - [**`es2015`**](reference#es2015-es2020-es2022-esnext): Reflects the ES2015 language specification for JavaScript modules (the version that first introduced `import` and `export` to the language).
    - [**`es2020`**](reference#es2015-es2020-es2022-esnext): Adds support for `import.meta` and `export * as ns from "mod"` to `es2015`.
    - [**`es2022`**](reference#es2015-es2020-es2022-esnext): Adds support for top-level `await` to `es2020`.
    - [**`esnext`**](reference#es2015-es2020-es2022-esnext): Currently identical to `es2022`, but will be a moving target reflecting the latest ECMAScript specifications, as well as module-related Stage 3+ proposals that are expected to be included in upcoming specification versions.
    - **[`commonjs`](reference#commonjs), [`system`](reference#system), [`amd`](reference#amd), and [`umd`](reference#umd)**: Each emits everything in the module system named, and assumes everything can be successfully imported into that module system. These are no longer recommended for new projects and will not be covered in detail by this documentation.

    > Node.js’s rules for module format detection and interoperability make it incorrect to specify `module` as `esnext` or `commonjs` for projects that run in Node.js, even if all files emitted by `tsc` are ESM or CJS, respectively. The only correct `module` settings for projects that intend to run in Node.js are `node16` and `nodenext`. While the emitted JavaScript for an all-ESM Node.js project might look identical between compilations using `esnext` and `nodenext`, the type checking can differ. See the [reference section on `nodenext`](reference#node16-nodenext) for more details.

    ### Module format detection

    Node.js understands both ES modules and CJS modules, but the format of each file is determined by its file extension and the `type` field of the first `package.json` file found in a search of the file’s directory and all ancestor directories:

    - `.mjs` and `.cjs` files are always interpreted as ES modules and CJS modules, respectively.
    - `.js` files are interpreted as ES modules if the nearest `package.json` file contains a `type` field with the value `"module"`. If there is no `package.json` file, or if the `type` field is missing or has any other value, `.js` files are interpreted as CJS modules.

    If a file is determined to be an ES module by these rules, Node.js will not inject the CommonJS `module` and `require` objects into the file’s scope during evaluation, so a file that tries to use them will cause a crash. Conversely, if a file is determined to be a CJS module, `import` and `export` declarations in the file will cause a syntax error crash.

    When the `module` compiler option is set to `node16` or `nodenext`, TypeScript applies this same algorithm to the project’s *input* files to determine the module kind of each corresponding *output* file. Let’s look at how module formats are detected in an example project that uses `--module nodenext`:

    | Input file name                  | Contents               | Output file name | Module kind | Reason                                  |
    |----------------------------------|------------------------|------------------|-------------|-----------------------------------------|
    | `/package.json`                  | `{}`                   |                  |             |                                         |
    | `/main.mts`                      |                        | `/main.mjs`      | ESM         | File extension                          |
    | `/utils.cts`                     |                        | `/utils.cjs`     | CJS         | File extension                          |
    | `/example.ts`                    |                        | `/example.js`    | CJS         | No `"type": "module"` in `package.json` |
    | `/node_modules/pkg/package.json` | `{ "type": "module" }` |                  |             |                                         |
    | `/node_modules/pkg/index.d.ts`   |                        |                  | ESM         | `"type": "module"` in `package.json`    |
    | `/node_modules/pkg/index.d.cts`  |                        |                  | CJS         | File extension                          |

    When the input file extension is `.mts` or `.cts`, TypeScript knows to treat that file as an ES module or CJS module, respectively, because Node.js will treat the output `.mjs` file as an ES module or the output `.cjs` file as a CJS module. When the input file extension is `.ts`, TypeScript has to consult the nearest `package.json` file to determine the module format, because this is what Node.js will do when it encounters the output `.js` file. (Notice that the same rules apply to the `.d.cts` and `.d.ts` declaration files in the `pkg` dependency: though they will not produce an output file as part of this compilation, the presence of a `.d.ts` file *implies* the existence of a corresponding `.js` file—perhaps created when the author of the `pkg` library ran `tsc` on an input `.ts` file of their own—which Node.js must interpret as an ES module, due to its `.js` extension and the presence of the `"type": "module"` field in `/node_modules/pkg/package.json`. Declaration files are covered in more detail in a [later section](#the-role-of-declaration-files).)

    The detected module format of input files is used by TypeScript to ensure it emits the output syntax that Node.js expects in each output file. If TypeScript were to emit `/example.js` with `import` and `export` statements in it, Node.js would crash when parsing the file. If TypeScript were to emit `/main.mjs` with `require` calls, Node.js would crash during evaluation. Beyond emit, the module format is also used to determine rules for type checking and module resolution, which we’ll discuss in the following sections.

    It’s worth mentioning again that TypeScript’s behavior in `--module node16` and `--module nodenext` is entirely motivated by Node.js’s behavior. Since TypeScript’s goal is to catch potential runtime errors at compile time, it needs a very accurate model of what will happen at runtime. This fairly complex set of rules for module kind detection is *necessary* for checking code that will run in Node.js, but may be overly strict or just incorrect if applied to non-Node.js hosts.

    ### Input module syntax

    It’s important to note that the *input* module syntax seen in input source files is somewhat decoupled from the output module syntax emitted to JS files. That is, a file with an ESM import:

    ``` ts
    import { sayHello } from "greetings";
    sayHello("world");
    ```

    might be emitted in ESM format exactly as-is, or might be emitted as CommonJS:

    ``` ts
    Object.defineProperty(exports, "__esModule", { value: true });
    const greetings_1 = require("greetings");
    (0, greetings_1.sayHello)("world");
    ```

    depending on the `module` compiler option (and any applicable [module format detection](#module-format-detection) rules, if the `module` option supports more than one kind of module). In general, this means that looking at the contents of an input file isn’t enough to determine whether it’s an ES module or a CJS module.

    > Today, most TypeScript files are authored using ESM syntax (`import` and `export` statements) regardless of the output format. This is largely a legacy of the long road ESM has taken to widespread support. ECMAScript modules were standardized in 2015, were supported in most browsers by 2017, and landed in Node.js v12 in 2019. During much of this window, it was clear that ESM was the future of JavaScript modules, but very few runtimes could consume it. Tools like Babel made it possible for JavaScript to be authored in ESM and downleveled to another module format that could be used in Node.js or browsers. TypeScript followed suit, adding support for ES module syntax and softly discouraging the use of the original CommonJS-inspired `import fs = require("fs")` syntax in [the 1.5 release](https://devblogs.microsoft.com/typescript/announcing-typescript-1-5/).
    >
    > The upside of this “author ESM, output anything” strategy was that TypeScript could use standard JavaScript syntax, making the authoring experience familiar to newcomers, and (theoretically) making it easy for projects to start targeting ESM outputs in the future. There are three significant downsides, which became fully apparent only after ESM and CJS modules were allowed to coexist and interoperate in Node.js:
    >
    > 1.  Early assumptions about how ESM/CJS interoperability would work in Node.js turned out to be wrong, and today, interoperability rules differ between Node.js and bundlers. Consequently, the configuration space for modules in TypeScript is large.
    > 2.  When the syntax in input files all looks like ESM, it’s easy for an author or code reviewer to lose track of what kind of module a file is at runtime. And because of Node.js’s interoperability rules, what kind of module each file is became very important.
    > 3.  When input files are written in ESM, the syntax in type declaration outputs (`.d.ts` files) looks like ESM too. But because the corresponding JavaScript files could have been emitted in any module format, TypeScript can’t tell what kind of module a file is just by looking at the contents of its type declarations. And again, because of the nature of ESM/CJS interoperability, TypeScript *has* to know what kind of module everything is in order to provide correct types and prevent imports that will crash.
    >
    > In TypeScript 5.0, a new compiler option called `verbatimModuleSyntax` was introduced to help TypeScript authors know exactly how their `import` and `export` statements will be emitted. When enabled, the flag requires imports and exports in input files to be written in the form that will undergo the least amount of transformation before emit. So if a file will be emitted as ESM, imports and exports must be written in ESM syntax; if a file will be emitted as CJS, it must be written in the CommonJS-inspired TypeScript syntax (`import fs = require("fs")` and `export = {}`). This setting is particularly recommended for Node.js projects that use mostly ESM, but have a select few CJS files. It is not recommended for projects that currently target CJS, but may want to target ESM in the future.

    ### ESM and CJS interoperability

    Can an ES module `import` a CommonJS module? If so, does a default import link to `exports` or `exports.default`? Can a CommonJS module `require` an ES module? CommonJS isn’t part of the ECMAScript specification, so runtimes, bundlers, and transpilers have been free to make up their own answers to these questions since ESM was standardized in 2015, and as such no standard set of interoperability rules exist. Today, most runtimes and bundlers broadly fall into one of three categories:

    1.  **ESM-only.** Some runtimes, like browser engines, only support what’s actually a part of the language: ECMAScript Modules.
    2.  **Bundler-like.** Before any major JavaScript engine could run ES modules, Babel allowed developers to write them by transpiling them to CommonJS. The way these ESM-transpiled-to-CJS files interacted with hand-written-CJS files implied a set of permissive interoperability rules that have become the de facto standard for bundlers and transpilers.
    3.  **Node.js.** In Node.js, CommonJS modules cannot load ES modules synchronously (with `require`); they can only load them asynchronously with dynamic `import()` calls. ES modules can default-import CJS modules, which always binds to `exports`. (This means that a default import of a Babel-like CJS output with `__esModule` behaves differently between Node.js and some bundlers.)

    TypeScript needs to know which of these rule sets to assume in order to provide correct types on (particularly `default`) imports and to error on imports that will crash at runtime. When the `module` compiler option is set to `node16` or `nodenext`, Node.js’s rules are enforced. All other `module` settings, combined with the [`esModuleInterop`](reference#esModuleInterop) option, result in bundler-like interop in TypeScript. (While using `--module esnext` does prevent you from *writing* CommonJS modules, it does not prevent you from *importing* them as dependencies. There’s currently no TypeScript setting that can guard against an ES module importing a CommonJS module, as would be appropriate for direct-to-browser code.)

    ### Module specifiers are not transformed

    While the `module` compiler option can transform imports and exports in input files to different module formats in output files, the module *specifier* (the string `from` which you `import`, or pass to `require`) is always emitted as-written. For example, an input like:

    ``` ts
    import { add } from "./math.mjs";
    add(1, 2);
    ```

    might be emitted as either:

    ``` ts
    import { add } from "./math.mjs";
    add(1, 2);
    ```

    or:

    ``` ts
    const math_1 = require("./math.mjs");
    math_1.add(1, 2);
    ```

    depending on the `module` compiler option, but the module specifier will always be `"./math.mjs"`. There is no compiler option that enables transforming, substituting, or rewriting module specifiers. Consequently, module specifiers must be written in a way that works for the code’s target runtime or bundler, and it’s TypeScript’s job to understand those *output*-relative specifiers. The process of finding the file referenced by a module specifier is called *module resolution*.
- name: 'Modules - Theory: TypeScript’s job concerning modules'
  id: modules/theory#typescripts-job-concerning-modules
  summary: The TypeScript compiler’s chief goal is to prevent certain kinds of runtime errors by catching them at compile time
  belongs_to: Modules - Theory
  description: |-
    ## TypeScript’s job concerning modules

    The TypeScript compiler’s chief goal is to prevent certain kinds of runtime errors by catching them at compile time. With or without modules involved, the compiler needs to know about the code’s intended runtime environment—what globals are available, for example. When modules are involved, there are several additional questions the compiler needs to answer in order to do its job. Let’s use a few lines of input code as an example to think about all the information needed to analyze it:

    ``` ts
    import sayHello from "greetings";
    sayHello("world");
    ```

    To check this file, the compiler needs to know the type of `sayHello` (is it a function that can accept one string argument?), which opens quite a few additional questions:

    1.  Will the module system load this TypeScript file directly, or will it load a JavaScript file that I (or another compiler) generate from this TypeScript file?
    2.  What *kind* of module does the module system expect to find, given the file name it will load and its location on disk?
    3.  If output JavaScript is being emitted, how will the module syntax present in this file be transformed in the output code?
    4.  Where will the module system look to find the module specified by `"greetings"`? Will the lookup succeed?
    5.  What kind of module is the file resolved by that lookup?
    6.  Does the module system allow the kind of module detected in (2) to reference the kind of module detected in (5) with the syntax decided in (3)?
    7.  Once the `"greetings"` module has been analyzed, what piece of that module is bound to `sayHello`?

    Notice that all of these questions depend on characteristics of the *host*—the system that ultimately consumes the output JavaScript (or raw TypeScript, as the case may be) to direct its module loading behavior, typically either a runtime (like Node.js) or bundler (like Webpack).

    The ECMAScript specification defines how ESM imports and exports link up with each other, but it doesn’t specify how the file lookup in (4), known as *module resolution*, happens, and it doesn’t say anything about other module systems like CommonJS. So runtimes and bundlers, especially those that want to support both ESM and CJS, have a lot of freedom to design their own rules. Consequently, the way TypeScript should answer the questions above can vary dramatically depending on where the code is intended to run. There’s no single right answer, so the compiler must be told the rules through configuration options.

    The other key idea to keep in mind is that TypeScript almost always thinks about these questions in terms of its *output* JavaScript files, not its *input* TypeScript (or JavaScript!) files. Today, some runtimes and bundlers support loading TypeScript files directly, and in those cases, it doesn’t make sense to think about separate input and output files. Most of this document discusses cases where TypeScript files are compiled to JavaScript files, which in turn are loaded by the runtime module system. Examining these cases is essential for building an understanding of the compiler’s options and behavior—it’s easier to start there and simplify when thinking about esbuild, Bun, and other [TypeScript-first runtimes and bundlers](#module-resolution-for-bundlers-typescript-runtimes-and-nodejs-loaders). So for now, we can summarize TypeScript’s job when it comes to modules in terms of output files:

    Understand the **rules of the host** enough

    1.  to compile files into a valid **output module format**,
    2.  to ensure that imports in those **outputs** will **resolve successfully**, and
    3.  to know what **type** to assign to **imported names**.
- name: 'Modules - Theory: Who is the host?'
  id: modules/theory#who-is-the-host
  summary: Before we move on, it’s worth making sure we’re on the same page about the term host, because it will come up frequently
  belongs_to: Modules - Theory
  description: |-
    ## Who is the host?

    Before we move on, it’s worth making sure we’re on the same page about the term *host*, because it will come up frequently. We defined it before as “the system that ultimately consumes the output code to direct its module loading behavior.” In other words, it’s the system outside of TypeScript that TypeScript’s module analysis tries to model:

    - When the output code (whether produced by `tsc` or a third-party transpiler) is run directly in a runtime like Node.js, the runtime is the host.
    - When there is no “output code” because a runtime consumes TypeScript files directly, the runtime is still the host.
    - When a bundler consumes TypeScript inputs or outputs and produces a bundle, the bundler is the host, because it looked at the original set of imports/requires, looked up what files they referenced, and produced a new file or set of files where the original imports and requires are erased or transformed beyond recognition. (That bundle itself might comprise modules, and the runtime that runs it will be its host, but TypeScript doesn’t know about anything that happens post-bundler.)
    - If another transpiler, optimizer, or formatter runs on TypeScript’s outputs, it’s *not* a host that TypeScript cares about, as long as it leaves the imports and exports it sees alone.
    - When loading modules in a web browser, the behaviors TypeScript needs to model are actually split between the web server and the module system running in the browser. The browser’s JavaScript engine (or a script-based module-loading framework like RequireJS) controls what module formats are accepted, while the web server decides what file to send when one module triggers a request to load another.
    - The TypeScript compiler itself is not a host, because it does not provide any behavior related to modules beyond trying to model other hosts.

    &nbsp;
- name: Modules .d.ts
  id: declaration-files/templates/module-d-ts
  summary: A module using CommonJS patterns uses module.exports to describe the exported values
  description: "# Modules .d.ts\n\n## Comparing JavaScript to an example DTS\n\n## Common CommonJS Patterns\n\nA module using CommonJS patterns uses `module.exports` to describe the exported values. For example, here is a module which exports a function and a numerical constant:\n\n``` js\nconst maxInterval = 12;\n\nfunction getArrayLength(arr) {\n  return arr.length;\n}\n\nmodule.exports = {\n  getArrayLength,\n  maxInterval,\n};\n```\n\nThis can be described by the following `.d.ts`:\n\n``` ts\nexport function getArrayLength(arr: any[]): number;\nexport const maxInterval: 12;\n```\n\nThe TypeScript playground can show you the `.d.ts` equivalent for JavaScript code. You can [try it yourself here](https://www.typescriptlang.org/play?useJavaScript=true#code/GYVwdgxgLglg9mABAcwKZQIICcsEMCeAMqmMlABYAUuOAlIgN6IBQiiW6IWSNWAdABsSZcswC+zCAgDOURAFtcADwAq5GKUQBeRAEYATM2by4AExBC+qJQAc4WKNO2NWKdNjxFhFADSvFquqk4sxAA).\n\nThe `.d.ts` syntax intentionally looks like [ES Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) syntax. ES Modules was ratified by TC39 in 2015 as part of ES2015 (ES6), while it has been available via transpilers for a long time, however if you have a JavaScript codebase using ES Modules:\n\n``` js\nexport function getArrayLength(arr) {\n  return arr.length;\n}\n```\n\nThis would have the following `.d.ts` equivalent:\n\n``` ts\nexport function getArrayLength(arr: any[]): number;\n```\n\n### Default Exports\n\nIn CommonJS you can export any value as the default export, for example here is a regular expression module:\n\n``` js\nmodule.exports = /hello( world)?/;\n```\n\nWhich can be described by the following .d.ts:\n\n``` ts\ndeclare const helloWorld: RegExp;\nexport default helloWorld;\n```\n\nOr a number:\n\n``` js\nmodule.exports = 3.142;\n```\n\n``` ts\ndeclare const pi: number;\nexport default pi;\n```\n\nOne style of exporting in CommonJS is to export a function. Because a function is also an object, then extra fields can be added and are included in the export.\n\n``` js\nfunction getArrayLength(arr) {\n  return arr.length;\n}\ngetArrayLength.maxInterval = 12;\n\nmodule.exports = getArrayLength;\n```\n\nWhich can be described with:\n\n``` ts\nexport default function getArrayLength(arr: any[]): number;\nexport const maxInterval: 12;\n```\n\nNote that using `export default` in your .d.ts files requires [`esModuleInterop: true`](https://www.typescriptlang.org/tsconfig#esModuleInterop) to work. If you can’t have `esModuleInterop: true` in your project, such as when you’re submitting a PR to Definitely Typed, you’ll have to use the `export=` syntax instead. This older syntax is harder to use but works everywhere. Here’s how the above example would have to be written using `export=`:\n\n``` ts\ndeclare function getArrayLength(arr: any[]): number;\ndeclare namespace getArrayLength {\n  declare const maxInterval: 12;\n}\n\nexport = getArrayLength;\n```\n\nSee [Module: Functions](module-function-d-ts) for details of how that works, and the [Modules reference](../../modules/introduction) page.\n\n## Handling Many Consuming Import\n\nThere are many ways to import a module in modern consuming code:\n\n``` ts\nconst fastify = require(\"fastify\");\nconst { fastify } = require(\"fastify\");\nimport fastify = require(\"fastify\");\nimport * as Fastify from \"fastify\";\nimport { fastify, FastifyInstance } from \"fastify\";\nimport fastify from \"fastify\";\nimport fastify, { FastifyInstance } from \"fastify\";\n```\n\nCovering all of these cases requires the JavaScript code to actually support all of these patterns. To support many of these patterns, a CommonJS module would need to look something like:\n\n``` js\nclass FastifyInstance {}\n\nfunction fastify() {\n  return new FastifyInstance();\n}\n\nfastify.FastifyInstance = FastifyInstance;\n\n// Allows for { fastify }\nfastify.fastify = fastify;\n// Allows for strict ES Module support\nfastify.default = fastify;\n// Sets the default export\nmodule.exports = fastify;\n```\n\n## Types in Modules\n\nYou may want to provide a type for JavaScript code which does not exist\n\n``` js\nfunction getArrayMetadata(arr) {\n  return {\n    length: getArrayLength(arr),\n    firstObject: arr[0],\n  };\n}\n\nmodule.exports = {\n  getArrayMetadata,\n};\n```\n\nThis can be described with:\n\n``` ts\nexport type ArrayMetadata = {\n  length: number;\n  firstObject: any | undefined;\n};\nexport function getArrayMetadata(arr: any[]): ArrayMetadata;\n```\n\nThis example is a good case for [using generics](../../generics#generic-types) to provide richer type information:\n\n``` ts\nexport type ArrayMetadata<ArrType> = {\n  length: number;\n  firstObject: ArrType | undefined;\n};\n\nexport function getArrayMetadata<ArrType>(\n  arr: ArrType[]\n): ArrayMetadata<ArrType>;\n```\n\nNow the type of the array propagates into the `ArrayMetadata` type.\n\nThe types which are exported can then be re-used by consumers of the modules using either `import` or `import type` in TypeScript code or [JSDoc imports](../../jsdoc-supported-types#import-types).\n\n### Namespaces in Module Code\n\nTrying to describe the runtime relationship of JavaScript code can be tricky. When the ES Module-like syntax doesn’t provide enough tools to describe the exports then you can use `namespaces`.\n\nFor example, you may have complex enough types to describe that you choose to namespace them inside your `.d.ts`:\n\n``` ts\n// This represents the JavaScript class which would be available at runtime\nexport class API {\n  constructor(baseURL: string);\n  getInfo(opts: API.InfoRequest): API.InfoResponse;\n}\n\n// This namespace is merged with the API class and allows for consumers, and this file\n// to have types which are nested away in their own sections.\ndeclare namespace API {\n  export interface InfoRequest {\n    id: string;\n  }\n\n  export interface InfoResponse {\n    width: number;\n    height: number;\n  }\n}\n```\n\nTo understand how namespaces work in `.d.ts` files read the [`.d.ts` deep dive](../deep-dive).\n\n### Optional Global Usage\n\nYou can use `export as namespace` to declare that your module will be available in the global scope in UMD contexts:\n\n``` ts\nexport as namespace moduleName;\n```\n\n## Reference Example\n\nTo give you an idea of how all these pieces can come together, here is a reference `.d.ts` to start with when making a new module\n\n``` ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ If this module is a UMD module that exposes a global variable 'myLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myLib;\n\n/*~ If this module exports functions, declare them like so.\n */\nexport function myFunction(a: string): string;\nexport function myOtherFunction(a: number): number;\n\n/*~ You can declare types that are available via importing the module */\nexport interface SomeType {\n  name: string;\n  length: number;\n  extras?: string[];\n}\n\n/*~ You can declare properties of the module using const, let, or var */\nexport const myField: number;\n```\n\n### Library file layout\n\nThe layout of your declaration files should mirror the layout of the library.\n\nA library can consist of multiple modules, such as\n\n``` typescript\nmyLib\n  +---- index.js\n  +---- foo.js\n  +---- bar\n         +---- index.js\n         +---- baz.js\n```\n\nThese could be imported as\n\n``` js\nvar a = require(\"myLib\");\nvar b = require(\"myLib/foo\");\nvar c = require(\"myLib/bar\");\nvar d = require(\"myLib/bar/baz\");\n```\n\nYour declaration files should thus be\n\n``` typescript\n@types/myLib\n  +---- index.d.ts\n  +---- foo.d.ts\n  +---- bar\n         +---- index.d.ts\n         +---- baz.d.ts\n```\n\n### Testing your types\n\nIf you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:\n\n> 1.  Create a new folder in `node_modules/@types/[libname]`\n> 2.  Create an `index.d.ts` in that folder, and copy the example in\n> 3.  See where your usage of the module breaks, and start to fill out the index.d.ts\n> 4.  When you’re happy, clone [DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped) and follow the instructions in the README.\n\nOtherwise\n\n> 1.  Create a new file in the root of your source tree: `[libname].d.ts`\n> 2.  Add `declare module \"[libname]\" { }`\n> 3.  Add the template inside the braces of the declare module, and see where your usage breaks\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html)"
- name: 'Modules .d.ts: Common CommonJS Patterns'
  id: declaration-files/templates/module-d-ts#common-commonjs-patterns
  summary: A module using CommonJS patterns uses module.exports to describe the exported values
  belongs_to: Modules .d.ts
  description: |-
    ## Common CommonJS Patterns

    A module using CommonJS patterns uses `module.exports` to describe the exported values. For example, here is a module which exports a function and a numerical constant:

    ``` js
    const maxInterval = 12;

    function getArrayLength(arr) {
      return arr.length;
    }

    module.exports = {
      getArrayLength,
      maxInterval,
    };
    ```

    This can be described by the following `.d.ts`:

    ``` ts
    export function getArrayLength(arr: any[]): number;
    export const maxInterval: 12;
    ```

    The TypeScript playground can show you the `.d.ts` equivalent for JavaScript code. You can [try it yourself here](https://www.typescriptlang.org/play?useJavaScript=true#code/GYVwdgxgLglg9mABAcwKZQIICcsEMCeAMqmMlABYAUuOAlIgN6IBQiiW6IWSNWAdABsSZcswC+zCAgDOURAFtcADwAq5GKUQBeRAEYATM2by4AExBC+qJQAc4WKNO2NWKdNjxFhFADSvFquqk4sxAA).

    The `.d.ts` syntax intentionally looks like [ES Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) syntax. ES Modules was ratified by TC39 in 2015 as part of ES2015 (ES6), while it has been available via transpilers for a long time, however if you have a JavaScript codebase using ES Modules:

    ``` js
    export function getArrayLength(arr) {
      return arr.length;
    }
    ```

    This would have the following `.d.ts` equivalent:

    ``` ts
    export function getArrayLength(arr: any[]): number;
    ```

    ### Default Exports

    In CommonJS you can export any value as the default export, for example here is a regular expression module:

    ``` js
    module.exports = /hello( world)?/;
    ```

    Which can be described by the following .d.ts:

    ``` ts
    declare const helloWorld: RegExp;
    export default helloWorld;
    ```

    Or a number:

    ``` js
    module.exports = 3.142;
    ```

    ``` ts
    declare const pi: number;
    export default pi;
    ```

    One style of exporting in CommonJS is to export a function. Because a function is also an object, then extra fields can be added and are included in the export.

    ``` js
    function getArrayLength(arr) {
      return arr.length;
    }
    getArrayLength.maxInterval = 12;

    module.exports = getArrayLength;
    ```

    Which can be described with:

    ``` ts
    export default function getArrayLength(arr: any[]): number;
    export const maxInterval: 12;
    ```

    Note that using `export default` in your .d.ts files requires [`esModuleInterop: true`](https://www.typescriptlang.org/tsconfig#esModuleInterop) to work. If you can’t have `esModuleInterop: true` in your project, such as when you’re submitting a PR to Definitely Typed, you’ll have to use the `export=` syntax instead. This older syntax is harder to use but works everywhere. Here’s how the above example would have to be written using `export=`:

    ``` ts
    declare function getArrayLength(arr: any[]): number;
    declare namespace getArrayLength {
      declare const maxInterval: 12;
    }

    export = getArrayLength;
    ```

    See [Module: Functions](module-function-d-ts) for details of how that works, and the [Modules reference](../../modules/introduction) page.
- name: 'Modules .d.ts: Comparing JavaScript to an example DTS'
  id: declaration-files/templates/module-d-ts#comparing-javascript-to-an-example-dts
  summary: null
  belongs_to: Modules .d.ts
  description: '## Comparing JavaScript to an example DTS'
- name: 'Modules .d.ts: Handling Many Consuming Import'
  id: declaration-files/templates/module-d-ts#handling-many-consuming-import
  summary: Covering all of these cases requires the JavaScript code to actually support all of these patterns
  belongs_to: Modules .d.ts
  description: |-
    ## Handling Many Consuming Import

    There are many ways to import a module in modern consuming code:

    ``` ts
    const fastify = require("fastify");
    const { fastify } = require("fastify");
    import fastify = require("fastify");
    import * as Fastify from "fastify";
    import { fastify, FastifyInstance } from "fastify";
    import fastify from "fastify";
    import fastify, { FastifyInstance } from "fastify";
    ```

    Covering all of these cases requires the JavaScript code to actually support all of these patterns. To support many of these patterns, a CommonJS module would need to look something like:

    ``` js
    class FastifyInstance {}

    function fastify() {
      return new FastifyInstance();
    }

    fastify.FastifyInstance = FastifyInstance;

    // Allows for { fastify }
    fastify.fastify = fastify;
    // Allows for strict ES Module support
    fastify.default = fastify;
    // Sets the default export
    module.exports = fastify;
    ```
- name: 'Modules .d.ts: Reference Example'
  id: declaration-files/templates/module-d-ts#reference-example
  summary: The layout of your declaration files should mirror the layout of the library
  belongs_to: Modules .d.ts
  description: "## Reference Example\n\nTo give you an idea of how all these pieces can come together, here is a reference `.d.ts` to start with when making a new module\n\n``` ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n\n/*~ This is the module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n\n/*~ If this module is a UMD module that exposes a global variable 'myLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myLib;\n\n/*~ If this module exports functions, declare them like so.\n */\nexport function myFunction(a: string): string;\nexport function myOtherFunction(a: number): number;\n\n/*~ You can declare types that are available via importing the module */\nexport interface SomeType {\n  name: string;\n  length: number;\n  extras?: string[];\n}\n\n/*~ You can declare properties of the module using const, let, or var */\nexport const myField: number;\n```\n\n### Library file layout\n\nThe layout of your declaration files should mirror the layout of the library.\n\nA library can consist of multiple modules, such as\n\n``` typescript\nmyLib\n  +---- index.js\n  +---- foo.js\n  +---- bar\n         +---- index.js\n         +---- baz.js\n```\n\nThese could be imported as\n\n``` js\nvar a = require(\"myLib\");\nvar b = require(\"myLib/foo\");\nvar c = require(\"myLib/bar\");\nvar d = require(\"myLib/bar/baz\");\n```\n\nYour declaration files should thus be\n\n``` typescript\n@types/myLib\n  +---- index.d.ts\n  +---- foo.d.ts\n  +---- bar\n         +---- index.d.ts\n         +---- baz.d.ts\n```\n\n### Testing your types\n\nIf you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:\n\n> 1.  Create a new folder in `node_modules/@types/[libname]`\n> 2.  Create an `index.d.ts` in that folder, and copy the example in\n> 3.  See where your usage of the module breaks, and start to fill out the index.d.ts\n> 4.  When you’re happy, clone [DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped) and follow the instructions in the README.\n\nOtherwise\n\n> 1.  Create a new file in the root of your source tree: `[libname].d.ts`\n> 2.  Add `declare module \"[libname]\" { }`\n> 3.  Add the template inside the braces of the declare module, and see where your usage breaks\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html)"
- name: 'Modules .d.ts: Types in Modules'
  id: declaration-files/templates/module-d-ts#types-in-modules
  summary: Now the type of the array propagates into the ArrayMetadata type
  belongs_to: Modules .d.ts
  description: |-
    ## Types in Modules

    You may want to provide a type for JavaScript code which does not exist

    ``` js
    function getArrayMetadata(arr) {
      return {
        length: getArrayLength(arr),
        firstObject: arr[0],
      };
    }

    module.exports = {
      getArrayMetadata,
    };
    ```

    This can be described with:

    ``` ts
    export type ArrayMetadata = {
      length: number;
      firstObject: any | undefined;
    };
    export function getArrayMetadata(arr: any[]): ArrayMetadata;
    ```

    This example is a good case for [using generics](../../generics#generic-types) to provide richer type information:

    ``` ts
    export type ArrayMetadata<ArrType> = {
      length: number;
      firstObject: ArrType | undefined;
    };

    export function getArrayMetadata<ArrType>(
      arr: ArrType[]
    ): ArrayMetadata<ArrType>;
    ```

    Now the type of the array propagates into the `ArrayMetadata` type.

    The types which are exported can then be re-used by consumers of the modules using either `import` or `import type` in TypeScript code or [JSDoc imports](../../jsdoc-supported-types#import-types).

    ### Namespaces in Module Code

    Trying to describe the runtime relationship of JavaScript code can be tricky. When the ES Module-like syntax doesn’t provide enough tools to describe the exports then you can use `namespaces`.

    For example, you may have complex enough types to describe that you choose to namespace them inside your `.d.ts`:

    ``` ts
    // This represents the JavaScript class which would be available at runtime
    export class API {
      constructor(baseURL: string);
      getInfo(opts: API.InfoRequest): API.InfoResponse;
    }

    // This namespace is merged with the API class and allows for consumers, and this file
    // to have types which are nested away in their own sections.
    declare namespace API {
      export interface InfoRequest {
        id: string;
      }

      export interface InfoResponse {
        width: number;
        height: number;
      }
    }
    ```

    To understand how namespaces work in `.d.ts` files read the [`.d.ts` deep dive](../deep-dive).

    ### Optional Global Usage

    You can use `export as namespace` to declare that your module will be available in the global scope in UMD contexts:

    ``` ts
    export as namespace moduleName;
    ```
- name: 'Modules: CommonJS Syntax'
  id: 2/modules#commonjs-syntax
  summary: CommonJS is the format which most modules on npm are delivered in
  belongs_to: Modules
  description: |-
    ## CommonJS Syntax

    CommonJS is the format which most modules on npm are delivered in. Even if you are writing using the ES Modules syntax above, having a brief understanding of how CommonJS syntax works will help you debug easier.

    #### Exporting

    Identifiers are exported via setting the `exports` property on a global called `module`.

    ``` ts
    function absolute(num: number) {
      if (num < 0) return num * -1;
      return num;
    }
     
    module.exports = {
      pi: 3.14,
      squareTwo: 1.41,
      phi: 1.61,
      absolute,
    };
    ```

    Then these files can be imported via a `require` statement:

    ``` ts
    const maths = require("./maths");
    maths.pi;
    ```

    Or you can simplify a bit using the destructuring feature in JavaScript:

    ``` ts
    const { squareTwo } = require("./maths");
    squareTwo;
    ```

    ### CommonJS and ES Modules interop

    There is a mis-match in features between CommonJS and ES Modules regarding the distinction between a default import and a module namespace object import. TypeScript has a compiler flag to reduce the friction between the two different sets of constraints with [`esModuleInterop`](https://www.typescriptlang.org/tsconfig#esModuleInterop).
- name: 'Modules: How JavaScript Modules are Defined'
  id: 2/modules#how-javascript-modules-are-defined
  summary: In TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a module
  belongs_to: Modules
  description: |-
    ## How JavaScript Modules are Defined

    In TypeScript, just as in ECMAScript 2015, any file containing a top-level `import` or `export` is considered a module.

    Conversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).

    Modules are executed within their own scope, not in the global scope. This means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the export forms. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the import forms.
- name: 'Modules: Modules in TypeScript'
  id: 2/modules#modules-in-typescript
  summary: In this case, the import does nothing
  belongs_to: Modules
  description: "## Modules in TypeScript\n\n> Additional Reading:  \n> [Impatient JS (Modules)](https://exploringjs.com/impatient-js/ch_modules.html#overview-syntax-of-ecmascript-modules)  \n> [MDN: JavaScript Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)  \n\nThere are three main things to consider when writing module-based code in TypeScript:\n\n- **Syntax**: What syntax do I want to use to import and export things?\n- **Module Resolution**: What is the relationship between module names (or paths) and files on disk?\n- **Module Output Target**: What should my emitted JavaScript module look like?\n\n### ES Module Syntax\n\nA file can declare a main export via `export default`:\n\n``` ts\n// @filename: hello.ts\nexport default function helloWorld() {\n  console.log(\"Hello, world!\");\n}\n```\n\nThis is then imported via:\n\n``` ts\nimport helloWorld from \"./hello.js\";\nhelloWorld();\n```\n\nIn addition to the default export, you can have more than one export of variables and functions via the `export` by omitting `default`:\n\n``` ts\n// @filename: maths.ts\nexport var pi = 3.14;\nexport let squareTwo = 1.41;\nexport const phi = 1.61;\n \nexport class RandomNumberGenerator {}\n \nexport function absolute(num: number) {\n  if (num < 0) return num * -1;\n  return num;\n}\n```\n\nThese can be used in another file via the `import` syntax:\n\n``` ts\nimport { pi, phi, absolute } from \"./maths.js\";\n \nconsole.log(pi);\nconst absPhi = absolute(phi);\n```\n\n### Additional Import Syntax\n\nAn import can be renamed using a format like `import {old as new}`:\n\n``` ts\nimport { pi as π } from \"./maths.js\";\n \nconsole.log(π);\n```\n\nYou can mix and match the above syntax into a single `import`:\n\n``` ts\n// @filename: maths.ts\nexport const pi = 3.14;\nexport default class RandomNumberGenerator {}\n \n// @filename: app.ts\nimport RandomNumberGenerator, { pi as π } from \"./maths.js\";\n \nRandomNumberGenerator;\n \nconsole.log(π);\n```\n\nYou can take all of the exported objects and put them into a single namespace using `* as name`:\n\n``` ts\n// @filename: app.ts\nimport * as math from \"./maths.js\";\n \nconsole.log(math.pi);\nconst positivePhi = math.absolute(math.phi);\n```\n\nYou can import a file and *not* include any variables into your current module via `import \"./file\"`:\n\n``` ts\n// @filename: app.ts\nimport \"./maths.js\";\n \nconsole.log(\"3.14\");\n```\n\nIn this case, the `import` does nothing. However, all of the code in `maths.ts` was evaluated, which could trigger side-effects which affect other objects.\n\n#### TypeScript Specific ES Module Syntax\n\nTypes can be exported and imported using the same syntax as JavaScript values:\n\n``` ts\n// @filename: animal.ts\nexport type Cat = { breed: string; yearOfBirth: number };\n \nexport interface Dog {\n  breeds: string[];\n  yearOfBirth: number;\n}\n \n// @filename: app.ts\nimport { Cat, Dog } from \"./animal.js\";\ntype Animals = Cat | Dog;\n```\n\nTypeScript has extended the `import` syntax with two concepts for declaring an import of a type:\n\n###### `import type`\n\nWhich is an import statement which can *only* import types:\n\n``` ts\n// @filename: animal.ts\nexport type Cat = { breed: string; yearOfBirth: number };\nexport type Dog = { breeds: string[]; yearOfBirth: number };\nexport const createCatName = () => \"fluffy\";\n \n// @filename: valid.ts\nimport type { Cat, Dog } from \"./animal.js\";\nexport type Animals = Cat | Dog;\n \n// @filename: app.ts\nimport type { createCatName } from \"./animal.js\";\nconst name = createCatName();\n```\n\n###### Inline `type` imports\n\nTypeScript 4.5 also allows for individual imports to be prefixed with `type` to indicate that the imported reference is a type:\n\n``` ts\n// @filename: app.ts\nimport { createCatName, type Cat, type Dog } from \"./animal.js\";\n \nexport type Animals = Cat | Dog;\nconst name = createCatName();\n```\n\nTogether these allow a non-TypeScript transpiler like Babel, swc or esbuild to know what imports can be safely removed.\n\n#### ES Module Syntax with CommonJS Behavior\n\nTypeScript has ES Module syntax which *directly* correlates to a CommonJS and AMD `require`. Imports using ES Module are *for most cases* the same as the `require` from those environments, but this syntax ensures you have a 1 to 1 match in your TypeScript file with the CommonJS output:\n\n``` ts\nimport fs = require(\"fs\");\nconst code = fs.readFileSync(\"hello.ts\", \"utf8\");\n```\n\nYou can learn more about this syntax in the [modules reference page](../modules/introduction#export--and-import--require)."
- name: 'Modules: Non-modules'
  id: 2/modules#non-modules
  summary: Before we start, it’s important to understand what TypeScript considers a module
  belongs_to: Modules
  description: |-
    ## Non-modules

    Before we start, it’s important to understand what TypeScript considers a module. The JavaScript specification declares that any JavaScript files without an `import` declaration, `export`, or top-level `await` should be considered a script and not a module.

    Inside a script file variables and types are declared to be in the shared global scope, and it’s assumed that you’ll either use the [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) compiler option to join multiple input files into one output file, or use multiple `<script>` tags in your HTML to load these files (in the correct order!).

    If you have a file that doesn’t currently have any `import`s or `export`s, but you want to be treated as a module, add the line:

    ``` ts
    export {};
    ```

    which will change the file to be a module exporting nothing. This syntax works regardless of your module target.
- name: 'Modules: TypeScript namespaces'
  id: 2/modules#typescript-namespaces
  summary: TypeScript has its own module format called namespaces which pre-dates the ES Modules standard
  belongs_to: Modules
  description: "## TypeScript namespaces\n\nTypeScript has its own module format called `namespaces` which pre-dates the ES Modules standard. This syntax has a lot of useful features for creating complex definition files, and still sees active use [in DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped). While not deprecated, the majority of the features in namespaces exist in ES Modules and we recommend you use that to align with JavaScript’s direction. You can learn more about namespaces in [the namespaces reference page](../namespaces).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/modules.html](https://www.typescriptlang.org/docs/handbook/2/modules.html)"
- name: 'Modules: TypeScript’s Module Output Options'
  id: 2/modules#typescripts-module-output-options
  summary: Which target you use is determined by the features available in the JavaScript runtime you expect to run the TypeScript code in
  belongs_to: Modules
  description: |-
    ## TypeScript’s Module Output Options

    There are two options which affect the emitted JavaScript output:

    - [`target`](https://www.typescriptlang.org/tsconfig#target) which determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intact
    - [`module`](https://www.typescriptlang.org/tsconfig#module) which determines what code is used for modules to interact with each other

    Which [`target`](https://www.typescriptlang.org/tsconfig#target) you use is determined by the features available in the JavaScript runtime you expect to run the TypeScript code in. That could be: the oldest web browser you support, the lowest version of Node.js you expect to run on or could come from unique constraints from your runtime - like Electron for example.

    All communication between modules happens via a module loader, the compiler option [`module`](https://www.typescriptlang.org/tsconfig#module) determines which one is used. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it.

    For example, here is a TypeScript file using ES Modules syntax, showcasing a few different options for [`module`](https://www.typescriptlang.org/tsconfig#module):

    ``` ts
    import { valueOfPi } from "./constants.js";
     
    export const twoPi = valueOfPi * 2;
    ```

    #### `ES2020`

    ``` ts
    import { valueOfPi } from "./constants.js";
    export const twoPi = valueOfPi * 2;
     
    ```

    #### `CommonJS`

    ``` ts
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.twoPi = void 0;
    const constants_js_1 = require("./constants.js");
    exports.twoPi = constants_js_1.valueOfPi * 2;
     
    ```

    #### `UMD`

    ``` ts
    (function (factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
            var v = factory(require, exports);
            if (v !== undefined) module.exports = v;
        }
        else if (typeof define === "function" && define.amd) {
            define(["require", "exports", "./constants.js"], factory);
        }
    })(function (require, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.twoPi = void 0;
        const constants_js_1 = require("./constants.js");
        exports.twoPi = constants_js_1.valueOfPi * 2;
    });
     
    ```

    > Note that ES2020 is effectively the same as the original `index.ts`.

    You can see all of the available options and what their emitted JavaScript code looks like in the [TSConfig Reference for `module`](https://www.typescriptlang.org/tsconfig#module).
- name: 'Modules: TypeScript’s Module Resolution Options'
  id: 2/modules#typescripts-module-resolution-options
  summary: Module resolution is the process of taking a string from the import or require statement, and determining what file that string refers to
  belongs_to: Modules
  description: |-
    ## TypeScript’s Module Resolution Options

    Module resolution is the process of taking a string from the `import` or `require` statement, and determining what file that string refers to.

    TypeScript includes two resolution strategies: Classic and Node. Classic, the default when the compiler option [`module`](https://www.typescriptlang.org/tsconfig#module) is not `commonjs`, is included for backwards compatibility. The Node strategy replicates how Node.js works in CommonJS mode, with additional checks for `.ts` and `.d.ts`.

    There are many TSConfig flags which influence the module strategy within TypeScript: [`moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution), [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl), [`paths`](https://www.typescriptlang.org/tsconfig#paths), [`rootDirs`](https://www.typescriptlang.org/tsconfig#rootDirs).

    For the full details on how these strategies work, you can consult the [Module Resolution](../modules/reference#the-moduleresolution-compiler-option) reference page.
- name: moduleSuffixes
  id: tsconfig#moduleSuffixes-config
  summary: Provides a way to override the default list of file name suffixes to search when resolving a module
  belongs_to: TSConfig Reference
  description: |-
    ### Module Suffixes - `moduleSuffixes`

    Provides a way to override the default list of file name suffixes to search when resolving a module.

    ``` typescript
    {
      "compilerOptions": {
        "moduleSuffixes": [".ios", ".native", ""]
      }
    }
    ```

    Given the above configuration, an import like the following:

    ``` ts
    import * as foo from "./foo";
    ```

    TypeScript will look for the relative files `./foo.ios.ts`, `./foo.native.ts`, and finally `./foo.ts`.

    Note the empty string `""` in [`moduleSuffixes`](#moduleSuffixes) which is necessary for TypeScript to also look-up `./foo.ts`.

    This feature can be useful for React Native projects where each target platform can use a separate tsconfig.json with differing `moduleSuffixes`.

    - Released:

      [4.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html)
- name: moduleSuffixes
  id: tsconfig/index#moduleSuffixes-config
  summary: Provides a way to override the default list of file name suffixes to search when resolving a module
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Module Suffixes - `moduleSuffixes`

    Provides a way to override the default list of file name suffixes to search when resolving a module.

    ``` typescript
    {
      "compilerOptions": {
        "moduleSuffixes": [".ios", ".native", ""]
      }
    }
    ```

    Given the above configuration, an import like the following:

    ``` ts
    import * as foo from "./foo";
    ```

    TypeScript will look for the relative files `./foo.ios.ts`, `./foo.native.ts`, and finally `./foo.ts`.

    Note the empty string `""` in [`moduleSuffixes`](#moduleSuffixes) which is necessary for TypeScript to also look-up `./foo.ts`.

    This feature can be useful for React Native projects where each target platform can use a separate tsconfig.json with differing `moduleSuffixes`.

    - Released:

      [4.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html)
- name: More on Functions
  id: 2/functions
  summary: Functions are the basic building block of any application, whether they’re local functions, imported from another module, or methods on a class
  description: "# More on Functions\n\nFunctions are the basic building block of any application, whether they’re local functions, imported from another module, or methods on a class. They’re also values, and just like other values, TypeScript has many ways to describe how functions can be called. Let’s learn about how to write types that describe functions.\n\n## Function Type Expressions\n\nThe simplest way to describe a function is with a *function type expression*. These types are syntactically similar to arrow functions:\n\n``` ts\nfunction greeter(fn: (a: string) => void) {\n  fn(\"Hello, World\");\n}\n \nfunction printToConsole(s: string) {\n  console.log(s);\n}\n \ngreeter(printToConsole);\n```\n\nThe syntax `(a: string) => void` means “a function with one parameter, named `a`, of type `string`, that doesn’t have a return value”. Just like with function declarations, if a parameter type isn’t specified, it’s implicitly `any`.\n\n> Note that the parameter name is **required**. The function type `(string) => void` means “a function with a parameter named `string` of type `any`“!\n\nOf course, we can use a type alias to name a function type:\n\n``` ts\ntype GreetFunction = (a: string) => void;\nfunction greeter(fn: GreetFunction) {\n  // ...\n}\n```\n\n## Call Signatures\n\nIn JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesn’t allow for declaring properties. If we want to describe something callable with properties, we can write a *call signature* in an object type:\n\n``` ts\ntype DescribableFunction = {\n  description: string;\n  (someArg: number): boolean;\n};\nfunction doSomething(fn: DescribableFunction) {\n  console.log(fn.description + \" returned \" + fn(6));\n}\n \nfunction myFunc(someArg: number) {\n  return someArg > 3;\n}\nmyFunc.description = \"default description\";\n \ndoSomething(myFunc);\n```\n\nNote that the syntax is slightly different compared to a function type expression - use `:` between the parameter list and the return type rather than `=>`.\n\n## Construct Signatures\n\nJavaScript functions can also be invoked with the `new` operator. TypeScript refers to these as *constructors* because they usually create a new object. You can write a *construct signature* by adding the `new` keyword in front of a call signature:\n\n``` ts\ntype SomeConstructor = {\n  new (s: string): SomeObject;\n};\nfunction fn(ctor: SomeConstructor) {\n  return new ctor(\"hello\");\n}\n```\n\nSome objects, like JavaScript’s `Date` object, can be called with or without `new`. You can combine call and construct signatures in the same type arbitrarily:\n\n``` ts\ninterface CallOrConstruct {\n  (n?: number): string;\n  new (s: string): Date;\n}\n```\n\n## Generic Functions\n\nIt’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way. Let’s consider for a moment a function that returns the first element of an array:\n\n``` ts\nfunction firstElement(arr: any[]) {\n  return arr[0];\n}\n```\n\nThis function does its job, but unfortunately has the return type `any`. It’d be better if the function returned the type of the array element.\n\nIn TypeScript, *generics* are used when we want to describe a correspondence between two values. We do this by declaring a *type parameter* in the function signature:\n\n``` ts\nfunction firstElement<Type>(arr: Type[]): Type | undefined {\n  return arr[0];\n}\n```\n\nBy adding a type parameter `Type` to this function and using it in two places, we’ve created a link between the input of the function (the array) and the output (the return value). Now when we call it, a more specific type comes out:\n\n``` ts\n// s is of type 'string'\nconst s = firstElement([\"a\", \"b\", \"c\"]);\n// n is of type 'number'\nconst n = firstElement([1, 2, 3]);\n// u is of type undefined\nconst u = firstElement([]);\n```\n\n### Inference\n\nNote that we didn’t have to specify `Type` in this sample. The type was *inferred* - chosen automatically - by TypeScript.\n\nWe can use multiple type parameters as well. For example, a standalone version of `map` would look like this:\n\n``` ts\nfunction map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {\n  return arr.map(func);\n}\n \n// Parameter 'n' is of type 'string'\n// 'parsed' is of type 'number[]'\nconst parsed = map([\"1\", \"2\", \"3\"], (n) => parseInt(n));\n```\n\nNote that in this example, TypeScript could infer both the type of the `Input` type parameter (from the given `string` array), as well as the `Output` type parameter based on the return value of the function expression (`number`).\n\n### Constraints\n\nWe’ve written some generic functions that can work on *any* kind of value. Sometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a *constraint* to limit the kinds of types that a type parameter can accept.\n\nLet’s write a function that returns the longer of two values. To do this, we need a `length` property that’s a number. We *constrain* the type parameter to that type by writing an `extends` clause:\n\n``` ts\nfunction longest<Type extends { length: number }>(a: Type, b: Type) {\n  if (a.length >= b.length) {\n    return a;\n  } else {\n    return b;\n  }\n}\n \n// longerArray is of type 'number[]'\nconst longerArray = longest([1, 2], [1, 2, 3]);\n// longerString is of type 'alice' | 'bob'\nconst longerString = longest(\"alice\", \"bob\");\n// Error! Numbers don't have a 'length' property\nconst notOK = longest(10, 100);\n```\n\nThere are a few interesting things to note in this example. We allowed TypeScript to *infer* the return type of `longest`. Return type inference also works on generic functions.\n\nBecause we constrained `Type` to `{ length: number }`, we were allowed to access the `.length` property of the `a` and `b` parameters. Without the type constraint, we wouldn’t be able to access those properties because the values might have been some other type without a length property.\n\nThe types of `longerArray` and `longerString` were inferred based on the arguments. Remember, generics are all about relating two or more values with the same type!\n\nFinally, just as we’d like, the call to `longest(10, 100)` is rejected because the `number` type doesn’t have a `.length` property.\n\n### Working with Constrained Values\n\nHere’s a common error when working with generic constraints:\n\n``` ts\nfunction minimumLength<Type extends { length: number }>(\n  obj: Type,\n  minimum: number\n): Type {\n  if (obj.length >= minimum) {\n    return obj;\n  } else {\n    return { length: minimum };\n  }\n}\n```\n\nIt might look like this function is OK - `Type` is constrained to `{ length: number }`, and the function either returns `Type` or a value matching that constraint. The problem is that the function promises to return the *same* kind of object as was passed in, not just *some* object matching the constraint. If this code were legal, you could write code that definitely wouldn’t work:\n\n``` ts\n// 'arr' gets value { length: 6 }\nconst arr = minimumLength([1, 2, 3], 6);\n// and crashes here because arrays have\n// a 'slice' method, but not the returned object!\nconsole.log(arr.slice(0));\n```\n\n### Specifying Type Arguments\n\nTypeScript can usually infer the intended type arguments in a generic call, but not always. For example, let’s say you wrote a function to combine two arrays:\n\n``` ts\nfunction combine<Type>(arr1: Type[], arr2: Type[]): Type[] {\n  return arr1.concat(arr2);\n}\n```\n\nNormally it would be an error to call this function with mismatched arrays:\n\n``` ts\nconst arr = combine([1, 2, 3], [\"hello\"]);\n```\n\nIf you intended to do this, however, you could manually specify `Type`:\n\n``` ts\nconst arr = combine<string | number>([1, 2, 3], [\"hello\"]);\n```\n\n### Guidelines for Writing Good Generic Functions\n\nWriting generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they aren’t needed can make inference less successful, frustrating callers of your function.\n\n#### Push Type Parameters Down\n\nHere are two ways of writing a function that appear similar:\n\n``` ts\nfunction firstElement1<Type>(arr: Type[]) {\n  return arr[0];\n}\n \nfunction firstElement2<Type extends any[]>(arr: Type) {\n  return arr[0];\n}\n \n// a: number (good)\nconst a = firstElement1([1, 2, 3]);\n// b: any (bad)\nconst b = firstElement2([1, 2, 3]);\n```\n\nThese might seem identical at first glance, but `firstElement1` is a much better way to write this function. Its inferred return type is `Type`, but `firstElement2`’s inferred return type is `any` because TypeScript has to resolve the `arr[0]` expression using the constraint type, rather than “waiting” to resolve the element during a call.\n\n> **Rule**: When possible, use the type parameter itself rather than constraining it\n\n#### Use Fewer Type Parameters\n\nHere’s another pair of similar functions:\n\n``` ts\nfunction filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {\n  return arr.filter(func);\n}\n \nfunction filter2<Type, Func extends (arg: Type) => boolean>(\n  arr: Type[],\n  func: Func\n): Type[] {\n  return arr.filter(func);\n}\n```\n\nWe’ve created a type parameter `Func` that *doesn’t relate two values*. That’s always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason. `Func` doesn’t do anything but make the function harder to read and reason about!\n\n> **Rule**: Always use as few type parameters as possible\n\n#### Type Parameters Should Appear Twice\n\nSometimes we forget that a function might not need to be generic:\n\n``` ts\nfunction greet<Str extends string>(s: Str) {\n  console.log(\"Hello, \" + s);\n}\n \ngreet(\"world\");\n```\n\nWe could just as easily have written a simpler version:\n\n``` ts\nfunction greet(s: string) {\n  console.log(\"Hello, \" + s);\n}\n```\n\nRemember, type parameters are for *relating the types of multiple values*. If a type parameter is only used once in the function signature, it’s not relating anything. This includes the inferred return type; for example, if `Str` was part of the inferred return type of `greet`, it would be relating the argument and return types, so would be used *twice* despite appearing only once in the written code.\n\n> **Rule**: If a type parameter only appears in one location, strongly reconsider if you actually need it\n\n## Optional Parameters\n\nFunctions in JavaScript often take a variable number of arguments. For example, the `toFixed` method of `number` takes an optional digit count:\n\n``` ts\nfunction f(n: number) {\n  console.log(n.toFixed()); // 0 arguments\n  console.log(n.toFixed(3)); // 1 argument\n}\n```\n\nWe can model this in TypeScript by marking the parameter as *optional* with `?`:\n\n``` ts\nfunction f(x?: number) {\n  // ...\n}\nf(); // OK\nf(10); // OK\n```\n\nAlthough the parameter is specified as type `number`, the `x` parameter will actually have the type `number | undefined` because unspecified parameters in JavaScript get the value `undefined`.\n\nYou can also provide a parameter *default*:\n\n``` ts\nfunction f(x = 10) {\n  // ...\n}\n```\n\nNow in the body of `f`, `x` will have type `number` because any `undefined` argument will be replaced with `10`. Note that when a parameter is optional, callers can always pass `undefined`, as this simply simulates a “missing” argument:\n\n``` ts\n// All OK\nf();\nf(10);\nf(undefined);\n```\n\n### Optional Parameters in Callbacks\n\nOnce you’ve learned about optional parameters and function type expressions, it’s very easy to make the following mistakes when writing functions that invoke callbacks:\n\n``` ts\nfunction myForEach(arr: any[], callback: (arg: any, index?: number) => void) {\n  for (let i = 0; i < arr.length; i++) {\n    callback(arr[i], i);\n  }\n}\n```\n\nWhat people usually intend when writing `index?` as an optional parameter is that they want both of these calls to be legal:\n\n``` ts\nmyForEach([1, 2, 3], (a) => console.log(a));\nmyForEach([1, 2, 3], (a, i) => console.log(a, i));\n```\n\nWhat this *actually* means is that *`callback` might get invoked with one argument*. In other words, the function definition says that the implementation might look like this:\n\n``` ts\nfunction myForEach(arr: any[], callback: (arg: any, index?: number) => void) {\n  for (let i = 0; i < arr.length; i++) {\n    // I don't feel like providing the index today\n    callback(arr[i]);\n  }\n}\n```\n\nIn turn, TypeScript will enforce this meaning and issue errors that aren’t really possible:\n\n``` ts\nmyForEach([1, 2, 3], (a, i) => {\n  console.log(i.toFixed());\n});\n```\n\nIn JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored. TypeScript behaves the same way. Functions with fewer parameters (of the same types) can always take the place of functions with more parameters.\n\n> **Rule**: When writing a function type for a callback, *never* write an optional parameter unless you intend to *call* the function without passing that argument\n\n## Function Overloads\n\nSome JavaScript functions can be called in a variety of argument counts and types. For example, you might write a function to produce a `Date` that takes either a timestamp (one argument) or a month/day/year specification (three arguments).\n\nIn TypeScript, we can specify a function that can be called in different ways by writing *overload signatures*. To do this, write some number of function signatures (usually two or more), followed by the body of the function:\n\n``` ts\nfunction makeDate(timestamp: number): Date;\nfunction makeDate(m: number, d: number, y: number): Date;\nfunction makeDate(mOrTimestamp: number, d?: number, y?: number): Date {\n  if (d !== undefined && y !== undefined) {\n    return new Date(y, mOrTimestamp, d);\n  } else {\n    return new Date(mOrTimestamp);\n  }\n}\nconst d1 = makeDate(12345678);\nconst d2 = makeDate(5, 5, 5);\nconst d3 = makeDate(1, 3);\n```\n\nIn this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the *overload signatures*.\n\nThen, we wrote a function implementation with a compatible signature. Functions have an *implementation* signature, but this signature can’t be called directly. Even though we wrote a function with two optional parameters after the required one, it can’t be called with two parameters!\n\n### Overload Signatures and the Implementation Signature\n\nThis is a common source of confusion. Often people will write code like this and not understand why there is an error:\n\n``` ts\nfunction fn(x: string): void;\nfunction fn() {\n  // ...\n}\n// Expected to be able to call with zero arguments\nfn();\n```\n\nAgain, the signature used to write the function body can’t be “seen” from the outside.\n\n> The signature of the *implementation* is not visible from the outside. When writing an overloaded function, you should always have *two* or more signatures above the implementation of the function.\n\nThe implementation signature must also be *compatible* with the overload signatures. For example, these functions have errors because the implementation signature doesn’t match the overloads in a correct way:\n\n``` ts\nfunction fn(x: boolean): void;\n// Argument type isn't right\nfunction fn(x: string): void;\nfunction fn(x: boolean) {}\n```\n\n``` ts\nfunction fn(x: string): string;\n// Return type isn't right\nfunction fn(x: number): boolean;\nfunction fn(x: string | number) {\n  return \"oops\";\n}\n```\n\n### Writing Good Overloads\n\nLike generics, there are a few guidelines you should follow when using function overloads. Following these principles will make your function easier to call, easier to understand, and easier to implement.\n\nLet’s consider a function that returns the length of a string or an array:\n\n``` ts\nfunction len(s: string): number;\nfunction len(arr: any[]): number;\nfunction len(x: any) {\n  return x.length;\n}\n```\n\nThis function is fine; we can invoke it with strings or arrays. However, we can’t invoke it with a value that might be a string *or* an array, because TypeScript can only resolve a function call to a single overload:\n\n``` ts\nlen(\"\"); // OK\nlen([0]); // OK\nlen(Math.random() > 0.5 ? \"hello\" : [0]);\n```\n\nBecause both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:\n\n``` ts\nfunction len(x: any[] | string) {\n  return x.length;\n}\n```\n\nThis is much better! Callers can invoke this with either sort of value, and as an added bonus, we don’t have to figure out a correct implementation signature.\n\n> Always prefer parameters with union types instead of overloads when possible\n\n## Declaring `this` in a Function\n\nTypeScript will infer what the `this` should be in a function via code flow analysis, for example in the following:\n\n``` ts\nconst user = {\n  id: 123,\n \n  admin: false,\n  becomeAdmin: function () {\n    this.admin = true;\n  },\n};\n```\n\nTypeScript understands that the function `user.becomeAdmin` has a corresponding `this` which is the outer object `user`. `this`, *heh*, can be enough for a lot of cases, but there are a lot of cases where you need more control over what object `this` represents. The JavaScript specification states that you cannot have a parameter called `this`, and so TypeScript uses that syntax space to let you declare the type for `this` in the function body.\n\n``` ts\ninterface DB {\n  filterUsers(filter: (this: User) => boolean): User[];\n}\n \nconst db = getDB();\nconst admins = db.filterUsers(function (this: User) {\n  return this.admin;\n});\n```\n\nThis pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to use `function` and not arrow functions to get this behavior:\n\n``` ts\ninterface DB {\n  filterUsers(filter: (this: User) => boolean): User[];\n}\n \nconst db = getDB();\nconst admins = db.filterUsers(() => this.admin);\n```\n\n## Other Types to Know About\n\nThere are some additional types you’ll want to recognize that appear often when working with function types. Like all types, you can use them everywhere, but these are especially relevant in the context of functions.\n\n### `void`\n\n`void` represents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any `return` statements, or doesn’t return any explicit value from those return statements:\n\n``` ts\n// The inferred return type is void\nfunction noop() {\n  return;\n}\n```\n\nIn JavaScript, a function that doesn’t return any value will implicitly return the value `undefined`. However, `void` and `undefined` are not the same thing in TypeScript. There are further details at the end of this chapter.\n\n> `void` is not the same as `undefined`.\n\n### `object`\n\nThe special type `object` refers to any value that isn’t a primitive (`string`, `number`, `bigint`, `boolean`, `symbol`, `null`, or `undefined`). This is different from the *empty object type* `{ }`, and also different from the global type `Object`. It’s very likely you will never use `Object`.\n\n> `object` is not `Object`. **Always** use `object`!\n\nNote that in JavaScript, function values are objects: They have properties, have `Object.prototype` in their prototype chain, are `instanceof Object`, you can call `Object.keys` on them, and so on. For this reason, function types are considered to be `object`s in TypeScript.\n\n### `unknown`\n\nThe `unknown` type represents *any* value. This is similar to the `any` type, but is safer because it’s not legal to do anything with an `unknown` value:\n\n``` ts\nfunction f1(a: any) {\n  a.b(); // OK\n}\nfunction f2(a: unknown) {\n  a.b();\n}\n```\n\nThis is useful when describing function types because you can describe functions that accept any value without having `any` values in your function body.\n\nConversely, you can describe a function that returns a value of unknown type:\n\n``` ts\nfunction safeParse(s: string): unknown {\n  return JSON.parse(s);\n}\n \n// Need to be careful with 'obj'!\nconst obj = safeParse(someRandomString);\n```\n\n### `never`\n\nSome functions *never* return a value:\n\n``` ts\nfunction fail(msg: string): never {\n  throw new Error(msg);\n}\n```\n\nThe `never` type represents values which are *never* observed. In a return type, this means that the function throws an exception or terminates execution of the program.\n\n`never` also appears when TypeScript determines there’s nothing left in a union.\n\n``` ts\nfunction fn(x: string | number) {\n  if (typeof x === \"string\") {\n    // do something\n  } else if (typeof x === \"number\") {\n    // do something else\n  } else {\n    x; // has type 'never'!\n  }\n}\n```\n\n### `Function`\n\nThe global type `Function` describes properties like `bind`, `call`, `apply`, and others present on all function values in JavaScript. It also has the special property that values of type `Function` can always be called; these calls return `any`:\n\n``` ts\nfunction doSomething(f: Function) {\n  return f(1, 2, 3);\n}\n```\n\nThis is an *untyped function call* and is generally best avoided because of the unsafe `any` return type.\n\nIf you need to accept an arbitrary function but don’t intend to call it, the type `() => void` is generally safer.\n\n## Rest Parameters and Arguments\n\n> Background Reading:  \n> [Rest Parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)  \n> [Spread Syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)  \n\n### Rest Parameters\n\nIn addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an *unbounded* number of arguments using *rest parameters*.\n\nA rest parameter appears after all other parameters, and uses the `...` syntax:\n\n``` ts\nfunction multiply(n: number, ...m: number[]) {\n  return m.map((x) => n * x);\n}\n// 'a' gets value [10, 20, 30, 40]\nconst a = multiply(10, 1, 2, 3, 4);\n```\n\nIn TypeScript, the type annotation on these parameters is implicitly `any[]` instead of `any`, and any type annotation given must be of the form `Array<T>` or `T[]`, or a tuple type (which we’ll learn about later).\n\n### Rest Arguments\n\nConversely, we can *provide* a variable number of arguments from an iterable object (for example, an array) using the spread syntax. For example, the `push` method of arrays takes any number of arguments:\n\n``` ts\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\narr1.push(...arr2);\n```\n\nNote that in general, TypeScript does not assume that arrays are immutable. This can lead to some surprising behavior:\n\n``` ts\n// Inferred type is number[] -- \"an array with zero or more numbers\",\n// not specifically two numbers\nconst args = [8, 5];\nconst angle = Math.atan2(...args);\n```\n\nThe best fix for this situation depends a bit on your code, but in general a `const` context is the most straightforward solution:\n\n``` ts\n// Inferred as 2-length tuple\nconst args = [8, 5] as const;\n// OK\nconst angle = Math.atan2(...args);\n```\n\nUsing rest arguments may require turning on [`downlevelIteration`](https://www.typescriptlang.org/tsconfig#downlevelIteration) when targeting older runtimes.\n\n## Parameter Destructuring\n\n> Background Reading:  \n> [Destructuring Assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)  \n\nYou can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this:\n\n``` js\nfunction sum({ a, b, c }) {\n  console.log(a + b + c);\n}\nsum({ a: 10, b: 3, c: 9 });\n```\n\nThe type annotation for the object goes after the destructuring syntax:\n\n``` ts\nfunction sum({ a, b, c }: { a: number; b: number; c: number }) {\n  console.log(a + b + c);\n}\n```\n\nThis can look a bit verbose, but you can use a named type here as well:\n\n``` ts\n// Same as prior example\ntype ABC = { a: number; b: number; c: number };\nfunction sum({ a, b, c }: ABC) {\n  console.log(a + b + c);\n}\n```\n\n## Assignability of Functions\n\n### Return type `void`\n\nThe `void` return type for functions can produce some unusual, but expected behavior.\n\nContextual typing with a return type of `void` does **not** force functions to **not** return something. Another way to say this is a contextual function type with a `void` return type (`type voidFunc = () => void`), when implemented, can return *any* other value, but it will be ignored.\n\nThus, the following implementations of the type `() => void` are valid:\n\n``` ts\ntype voidFunc = () => void;\n \nconst f1: voidFunc = () => {\n  return true;\n};\n \nconst f2: voidFunc = () => true;\n \nconst f3: voidFunc = function () {\n  return true;\n};\n```\n\nAnd when the return value of one of these functions is assigned to another variable, it will retain the type of `void`:\n\n``` ts\nconst v1 = f1();\n \nconst v2 = f2();\n \nconst v3 = f3();\n```\n\nThis behavior exists so that the following code is valid even though `Array.prototype.push` returns a number and the `Array.prototype.forEach` method expects a function with a return type of `void`.\n\n``` ts\nconst src = [1, 2, 3];\nconst dst = [0];\n \nsrc.forEach((el) => dst.push(el));\n```\n\nThere is one other special case to be aware of, when a literal function definition has a `void` return type, that function must **not** return anything.\n\n``` ts\nfunction f2(): void {\n  // @ts-expect-error\n  return true;\n}\n \nconst f3 = function (): void {\n  // @ts-expect-error\n  return true;\n};\n```\n\nFor more on `void` please refer to these other documentation entries:\n\n- [v2 handbook](functions#void)\n- [FAQ - “Why are functions returning non-void assignable to function returning void?”](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/functions.html](https://www.typescriptlang.org/docs/handbook/2/functions.html)"
- name: 'More on Functions: Assignability of Functions'
  id: 2/functions#assignability-of-functions
  summary: null
  belongs_to: More on Functions
  description: '## Assignability of Functions'
- name: 'More on Functions: Call Signatures'
  id: 2/functions#call-signatures
  summary: In JavaScript, functions can have properties in addition to being callable
  belongs_to: More on Functions
  description: |-
    ## Call Signatures

    In JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesn’t allow for declaring properties. If we want to describe something callable with properties, we can write a *call signature* in an object type:

    ``` ts
    type DescribableFunction = {
      description: string;
      (someArg: number): boolean;
    };
    function doSomething(fn: DescribableFunction) {
      console.log(fn.description + " returned " + fn(6));
    }
     
    function myFunc(someArg: number) {
      return someArg > 3;
    }
    myFunc.description = "default description";
     
    doSomething(myFunc);
    ```

    Note that the syntax is slightly different compared to a function type expression - use `:` between the parameter list and the return type rather than `=>`.
- name: 'More on Functions: Construct Signatures'
  id: 2/functions#construct-signatures
  summary: JavaScript functions can also be invoked with the new operator
  belongs_to: More on Functions
  description: |-
    ## Construct Signatures

    JavaScript functions can also be invoked with the `new` operator. TypeScript refers to these as *constructors* because they usually create a new object. You can write a *construct signature* by adding the `new` keyword in front of a call signature:

    ``` ts
    type SomeConstructor = {
      new (s: string): SomeObject;
    };
    function fn(ctor: SomeConstructor) {
      return new ctor("hello");
    }
    ```

    Some objects, like JavaScript’s `Date` object, can be called with or without `new`. You can combine call and construct signatures in the same type arbitrarily:

    ``` ts
    interface CallOrConstruct {
      (n?: number): string;
      new (s: string): Date;
    }
    ```
- name: 'More on Functions: Declaring this in a Function'
  id: 2/functions#declaring-this-in-a-function
  summary: TypeScript understands that the function user.becomeAdmin has a corresponding this which is the outer object user
  belongs_to: More on Functions
  description: |-
    ## Declaring `this` in a Function

    TypeScript will infer what the `this` should be in a function via code flow analysis, for example in the following:

    ``` ts
    const user = {
      id: 123,
     
      admin: false,
      becomeAdmin: function () {
        this.admin = true;
      },
    };
    ```

    TypeScript understands that the function `user.becomeAdmin` has a corresponding `this` which is the outer object `user`. `this`, *heh*, can be enough for a lot of cases, but there are a lot of cases where you need more control over what object `this` represents. The JavaScript specification states that you cannot have a parameter called `this`, and so TypeScript uses that syntax space to let you declare the type for `this` in the function body.

    ``` ts
    interface DB {
      filterUsers(filter: (this: User) => boolean): User[];
    }
     
    const db = getDB();
    const admins = db.filterUsers(function (this: User) {
      return this.admin;
    });
    ```

    This pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to use `function` and not arrow functions to get this behavior:

    ``` ts
    interface DB {
      filterUsers(filter: (this: User) => boolean): User[];
    }
     
    const db = getDB();
    const admins = db.filterUsers(() => this.admin);
    ```
- name: 'More on Functions: Function'
  id: 2/functions#function
  summary: The global type Function describes properties like bind, call, apply, and others present on all function values in JavaScript
  belongs_to: More on Functions
  description: |-
    ### `Function`

    The global type `Function` describes properties like `bind`, `call`, `apply`, and others present on all function values in JavaScript. It also has the special property that values of type `Function` can always be called; these calls return `any`:

    ``` ts
    function doSomething(f: Function) {
      return f(1, 2, 3);
    }
    ```

    This is an *untyped function call* and is generally best avoided because of the unsafe `any` return type.

    If you need to accept an arbitrary function but don’t intend to call it, the type `() => void` is generally safer.
- name: 'More on Functions: Function Overloads'
  id: 2/functions#function-overloads
  summary: Some JavaScript functions can be called in a variety of argument counts and types
  belongs_to: More on Functions
  description: |-
    ## Function Overloads

    Some JavaScript functions can be called in a variety of argument counts and types. For example, you might write a function to produce a `Date` that takes either a timestamp (one argument) or a month/day/year specification (three arguments).

    In TypeScript, we can specify a function that can be called in different ways by writing *overload signatures*. To do this, write some number of function signatures (usually two or more), followed by the body of the function:

    ``` ts
    function makeDate(timestamp: number): Date;
    function makeDate(m: number, d: number, y: number): Date;
    function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
      if (d !== undefined && y !== undefined) {
        return new Date(y, mOrTimestamp, d);
      } else {
        return new Date(mOrTimestamp);
      }
    }
    const d1 = makeDate(12345678);
    const d2 = makeDate(5, 5, 5);
    const d3 = makeDate(1, 3);
    ```

    In this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the *overload signatures*.

    Then, we wrote a function implementation with a compatible signature. Functions have an *implementation* signature, but this signature can’t be called directly. Even though we wrote a function with two optional parameters after the required one, it can’t be called with two parameters!

    ### Overload Signatures and the Implementation Signature

    This is a common source of confusion. Often people will write code like this and not understand why there is an error:

    ``` ts
    function fn(x: string): void;
    function fn() {
      // ...
    }
    // Expected to be able to call with zero arguments
    fn();
    ```

    Again, the signature used to write the function body can’t be “seen” from the outside.

    > The signature of the *implementation* is not visible from the outside. When writing an overloaded function, you should always have *two* or more signatures above the implementation of the function.

    The implementation signature must also be *compatible* with the overload signatures. For example, these functions have errors because the implementation signature doesn’t match the overloads in a correct way:

    ``` ts
    function fn(x: boolean): void;
    // Argument type isn't right
    function fn(x: string): void;
    function fn(x: boolean) {}
    ```

    ``` ts
    function fn(x: string): string;
    // Return type isn't right
    function fn(x: number): boolean;
    function fn(x: string | number) {
      return "oops";
    }
    ```

    ### Writing Good Overloads

    Like generics, there are a few guidelines you should follow when using function overloads. Following these principles will make your function easier to call, easier to understand, and easier to implement.

    Let’s consider a function that returns the length of a string or an array:

    ``` ts
    function len(s: string): number;
    function len(arr: any[]): number;
    function len(x: any) {
      return x.length;
    }
    ```

    This function is fine; we can invoke it with strings or arrays. However, we can’t invoke it with a value that might be a string *or* an array, because TypeScript can only resolve a function call to a single overload:

    ``` ts
    len(""); // OK
    len([0]); // OK
    len(Math.random() > 0.5 ? "hello" : [0]);
    ```

    Because both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:

    ``` ts
    function len(x: any[] | string) {
      return x.length;
    }
    ```

    This is much better! Callers can invoke this with either sort of value, and as an added bonus, we don’t have to figure out a correct implementation signature.

    > Always prefer parameters with union types instead of overloads when possible
- name: 'More on Functions: Function Type Expressions'
  id: 2/functions#function-type-expressions
  summary: The simplest way to describe a function is with a function type expression
  belongs_to: More on Functions
  description: |-
    ## Function Type Expressions

    The simplest way to describe a function is with a *function type expression*. These types are syntactically similar to arrow functions:

    ``` ts
    function greeter(fn: (a: string) => void) {
      fn("Hello, World");
    }
     
    function printToConsole(s: string) {
      console.log(s);
    }
     
    greeter(printToConsole);
    ```

    The syntax `(a: string) => void` means “a function with one parameter, named `a`, of type `string`, that doesn’t have a return value”. Just like with function declarations, if a parameter type isn’t specified, it’s implicitly `any`.

    > Note that the parameter name is **required**. The function type `(string) => void` means “a function with a parameter named `string` of type `any`“!

    Of course, we can use a type alias to name a function type:

    ``` ts
    type GreetFunction = (a: string) => void;
    function greeter(fn: GreetFunction) {
      // ...
    }
    ```
- name: 'More on Functions: Generic Functions'
  id: 2/functions#generic-functions
  summary: It’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way
  belongs_to: More on Functions
  description: |-
    ## Generic Functions

    It’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way. Let’s consider for a moment a function that returns the first element of an array:

    ``` ts
    function firstElement(arr: any[]) {
      return arr[0];
    }
    ```

    This function does its job, but unfortunately has the return type `any`. It’d be better if the function returned the type of the array element.

    In TypeScript, *generics* are used when we want to describe a correspondence between two values. We do this by declaring a *type parameter* in the function signature:

    ``` ts
    function firstElement<Type>(arr: Type[]): Type | undefined {
      return arr[0];
    }
    ```

    By adding a type parameter `Type` to this function and using it in two places, we’ve created a link between the input of the function (the array) and the output (the return value). Now when we call it, a more specific type comes out:

    ``` ts
    // s is of type 'string'
    const s = firstElement(["a", "b", "c"]);
    // n is of type 'number'
    const n = firstElement([1, 2, 3]);
    // u is of type undefined
    const u = firstElement([]);
    ```

    ### Inference

    Note that we didn’t have to specify `Type` in this sample. The type was *inferred* - chosen automatically - by TypeScript.

    We can use multiple type parameters as well. For example, a standalone version of `map` would look like this:

    ``` ts
    function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {
      return arr.map(func);
    }
     
    // Parameter 'n' is of type 'string'
    // 'parsed' is of type 'number[]'
    const parsed = map(["1", "2", "3"], (n) => parseInt(n));
    ```

    Note that in this example, TypeScript could infer both the type of the `Input` type parameter (from the given `string` array), as well as the `Output` type parameter based on the return value of the function expression (`number`).

    ### Constraints

    We’ve written some generic functions that can work on *any* kind of value. Sometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a *constraint* to limit the kinds of types that a type parameter can accept.

    Let’s write a function that returns the longer of two values. To do this, we need a `length` property that’s a number. We *constrain* the type parameter to that type by writing an `extends` clause:

    ``` ts
    function longest<Type extends { length: number }>(a: Type, b: Type) {
      if (a.length >= b.length) {
        return a;
      } else {
        return b;
      }
    }
     
    // longerArray is of type 'number[]'
    const longerArray = longest([1, 2], [1, 2, 3]);
    // longerString is of type 'alice' | 'bob'
    const longerString = longest("alice", "bob");
    // Error! Numbers don't have a 'length' property
    const notOK = longest(10, 100);
    ```

    There are a few interesting things to note in this example. We allowed TypeScript to *infer* the return type of `longest`. Return type inference also works on generic functions.

    Because we constrained `Type` to `{ length: number }`, we were allowed to access the `.length` property of the `a` and `b` parameters. Without the type constraint, we wouldn’t be able to access those properties because the values might have been some other type without a length property.

    The types of `longerArray` and `longerString` were inferred based on the arguments. Remember, generics are all about relating two or more values with the same type!

    Finally, just as we’d like, the call to `longest(10, 100)` is rejected because the `number` type doesn’t have a `.length` property.

    ### Working with Constrained Values

    Here’s a common error when working with generic constraints:

    ``` ts
    function minimumLength<Type extends { length: number }>(
      obj: Type,
      minimum: number
    ): Type {
      if (obj.length >= minimum) {
        return obj;
      } else {
        return { length: minimum };
      }
    }
    ```

    It might look like this function is OK - `Type` is constrained to `{ length: number }`, and the function either returns `Type` or a value matching that constraint. The problem is that the function promises to return the *same* kind of object as was passed in, not just *some* object matching the constraint. If this code were legal, you could write code that definitely wouldn’t work:

    ``` ts
    // 'arr' gets value { length: 6 }
    const arr = minimumLength([1, 2, 3], 6);
    // and crashes here because arrays have
    // a 'slice' method, but not the returned object!
    console.log(arr.slice(0));
    ```

    ### Specifying Type Arguments

    TypeScript can usually infer the intended type arguments in a generic call, but not always. For example, let’s say you wrote a function to combine two arrays:

    ``` ts
    function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
      return arr1.concat(arr2);
    }
    ```

    Normally it would be an error to call this function with mismatched arrays:

    ``` ts
    const arr = combine([1, 2, 3], ["hello"]);
    ```

    If you intended to do this, however, you could manually specify `Type`:

    ``` ts
    const arr = combine<string | number>([1, 2, 3], ["hello"]);
    ```

    ### Guidelines for Writing Good Generic Functions

    Writing generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they aren’t needed can make inference less successful, frustrating callers of your function.

    #### Push Type Parameters Down

    Here are two ways of writing a function that appear similar:

    ``` ts
    function firstElement1<Type>(arr: Type[]) {
      return arr[0];
    }
     
    function firstElement2<Type extends any[]>(arr: Type) {
      return arr[0];
    }
     
    // a: number (good)
    const a = firstElement1([1, 2, 3]);
    // b: any (bad)
    const b = firstElement2([1, 2, 3]);
    ```

    These might seem identical at first glance, but `firstElement1` is a much better way to write this function. Its inferred return type is `Type`, but `firstElement2`’s inferred return type is `any` because TypeScript has to resolve the `arr[0]` expression using the constraint type, rather than “waiting” to resolve the element during a call.

    > **Rule**: When possible, use the type parameter itself rather than constraining it

    #### Use Fewer Type Parameters

    Here’s another pair of similar functions:

    ``` ts
    function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {
      return arr.filter(func);
    }
     
    function filter2<Type, Func extends (arg: Type) => boolean>(
      arr: Type[],
      func: Func
    ): Type[] {
      return arr.filter(func);
    }
    ```

    We’ve created a type parameter `Func` that *doesn’t relate two values*. That’s always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason. `Func` doesn’t do anything but make the function harder to read and reason about!

    > **Rule**: Always use as few type parameters as possible

    #### Type Parameters Should Appear Twice

    Sometimes we forget that a function might not need to be generic:

    ``` ts
    function greet<Str extends string>(s: Str) {
      console.log("Hello, " + s);
    }
     
    greet("world");
    ```

    We could just as easily have written a simpler version:

    ``` ts
    function greet(s: string) {
      console.log("Hello, " + s);
    }
    ```

    Remember, type parameters are for *relating the types of multiple values*. If a type parameter is only used once in the function signature, it’s not relating anything. This includes the inferred return type; for example, if `Str` was part of the inferred return type of `greet`, it would be relating the argument and return types, so would be used *twice* despite appearing only once in the written code.

    > **Rule**: If a type parameter only appears in one location, strongly reconsider if you actually need it
- name: 'More on Functions: never'
  id: 2/functions#never
  summary: The never type represents values which are never observed
  belongs_to: More on Functions
  description: |-
    ### `never`

    Some functions *never* return a value:

    ``` ts
    function fail(msg: string): never {
      throw new Error(msg);
    }
    ```

    The `never` type represents values which are *never* observed. In a return type, this means that the function throws an exception or terminates execution of the program.

    `never` also appears when TypeScript determines there’s nothing left in a union.

    ``` ts
    function fn(x: string | number) {
      if (typeof x === "string") {
        // do something
      } else if (typeof x === "number") {
        // do something else
      } else {
        x; // has type 'never'!
      }
    }
    ```
- name: 'More on Functions: object'
  id: 2/functions#object
  summary: The special type object refers to any value that isn’t a primitive (string, number, bigint, boolean, symbol, null, or undefined). This is different from the empty object type { }, and also different from the global type Object
  belongs_to: More on Functions
  description: |-
    ### `object`

    The special type `object` refers to any value that isn’t a primitive (`string`, `number`, `bigint`, `boolean`, `symbol`, `null`, or `undefined`). This is different from the *empty object type* `{ }`, and also different from the global type `Object`. It’s very likely you will never use `Object`.

    > `object` is not `Object`. **Always** use `object`!

    Note that in JavaScript, function values are objects: They have properties, have `Object.prototype` in their prototype chain, are `instanceof Object`, you can call `Object.keys` on them, and so on. For this reason, function types are considered to be `object`s in TypeScript.
- name: 'More on Functions: Optional Parameters'
  id: 2/functions#optional-parameters
  summary: Functions in JavaScript often take a variable number of arguments
  belongs_to: More on Functions
  description: |-
    ## Optional Parameters

    Functions in JavaScript often take a variable number of arguments. For example, the `toFixed` method of `number` takes an optional digit count:

    ``` ts
    function f(n: number) {
      console.log(n.toFixed()); // 0 arguments
      console.log(n.toFixed(3)); // 1 argument
    }
    ```

    We can model this in TypeScript by marking the parameter as *optional* with `?`:

    ``` ts
    function f(x?: number) {
      // ...
    }
    f(); // OK
    f(10); // OK
    ```

    Although the parameter is specified as type `number`, the `x` parameter will actually have the type `number | undefined` because unspecified parameters in JavaScript get the value `undefined`.

    You can also provide a parameter *default*:

    ``` ts
    function f(x = 10) {
      // ...
    }
    ```

    Now in the body of `f`, `x` will have type `number` because any `undefined` argument will be replaced with `10`. Note that when a parameter is optional, callers can always pass `undefined`, as this simply simulates a “missing” argument:

    ``` ts
    // All OK
    f();
    f(10);
    f(undefined);
    ```

    ### Optional Parameters in Callbacks

    Once you’ve learned about optional parameters and function type expressions, it’s very easy to make the following mistakes when writing functions that invoke callbacks:

    ``` ts
    function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
      for (let i = 0; i < arr.length; i++) {
        callback(arr[i], i);
      }
    }
    ```

    What people usually intend when writing `index?` as an optional parameter is that they want both of these calls to be legal:

    ``` ts
    myForEach([1, 2, 3], (a) => console.log(a));
    myForEach([1, 2, 3], (a, i) => console.log(a, i));
    ```

    What this *actually* means is that *`callback` might get invoked with one argument*. In other words, the function definition says that the implementation might look like this:

    ``` ts
    function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
      for (let i = 0; i < arr.length; i++) {
        // I don't feel like providing the index today
        callback(arr[i]);
      }
    }
    ```

    In turn, TypeScript will enforce this meaning and issue errors that aren’t really possible:

    ``` ts
    myForEach([1, 2, 3], (a, i) => {
      console.log(i.toFixed());
    });
    ```

    In JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored. TypeScript behaves the same way. Functions with fewer parameters (of the same types) can always take the place of functions with more parameters.

    > **Rule**: When writing a function type for a callback, *never* write an optional parameter unless you intend to *call* the function without passing that argument
- name: 'More on Functions: Other Types to Know About'
  id: 2/functions#other-types-to-know-about
  summary: There are some additional types you’ll want to recognize that appear often when working with function types
  belongs_to: More on Functions
  description: |-
    ## Other Types to Know About

    There are some additional types you’ll want to recognize that appear often when working with function types. Like all types, you can use them everywhere, but these are especially relevant in the context of functions.
- name: 'More on Functions: Parameter Destructuring'
  id: 2/functions#parameter-destructuring
  summary: You can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body
  belongs_to: More on Functions
  description: "## Parameter Destructuring\n\n> Background Reading:  \n> [Destructuring Assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)  \n\nYou can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this:\n\n``` js\nfunction sum({ a, b, c }) {\n  console.log(a + b + c);\n}\nsum({ a: 10, b: 3, c: 9 });\n```\n\nThe type annotation for the object goes after the destructuring syntax:\n\n``` ts\nfunction sum({ a, b, c }: { a: number; b: number; c: number }) {\n  console.log(a + b + c);\n}\n```\n\nThis can look a bit verbose, but you can use a named type here as well:\n\n``` ts\n// Same as prior example\ntype ABC = { a: number; b: number; c: number };\nfunction sum({ a, b, c }: ABC) {\n  console.log(a + b + c);\n}\n```"
- name: 'More on Functions: Rest Parameters and Arguments'
  id: 2/functions#rest-parameters-and-arguments
  summary: In addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an unbounded number of arguments using rest parameters
  belongs_to: More on Functions
  description: "## Rest Parameters and Arguments\n\n> Background Reading:  \n> [Rest Parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)  \n> [Spread Syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)  \n\n### Rest Parameters\n\nIn addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an *unbounded* number of arguments using *rest parameters*.\n\nA rest parameter appears after all other parameters, and uses the `...` syntax:\n\n``` ts\nfunction multiply(n: number, ...m: number[]) {\n  return m.map((x) => n * x);\n}\n// 'a' gets value [10, 20, 30, 40]\nconst a = multiply(10, 1, 2, 3, 4);\n```\n\nIn TypeScript, the type annotation on these parameters is implicitly `any[]` instead of `any`, and any type annotation given must be of the form `Array<T>` or `T[]`, or a tuple type (which we’ll learn about later).\n\n### Rest Arguments\n\nConversely, we can *provide* a variable number of arguments from an iterable object (for example, an array) using the spread syntax. For example, the `push` method of arrays takes any number of arguments:\n\n``` ts\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\narr1.push(...arr2);\n```\n\nNote that in general, TypeScript does not assume that arrays are immutable. This can lead to some surprising behavior:\n\n``` ts\n// Inferred type is number[] -- \"an array with zero or more numbers\",\n// not specifically two numbers\nconst args = [8, 5];\nconst angle = Math.atan2(...args);\n```\n\nThe best fix for this situation depends a bit on your code, but in general a `const` context is the most straightforward solution:\n\n``` ts\n// Inferred as 2-length tuple\nconst args = [8, 5] as const;\n// OK\nconst angle = Math.atan2(...args);\n```\n\nUsing rest arguments may require turning on [`downlevelIteration`](https://www.typescriptlang.org/tsconfig#downlevelIteration) when targeting older runtimes."
- name: 'More on Functions: Return type void'
  id: 2/functions#return-type-void
  summary: The void return type for functions can produce some unusual, but expected behavior
  belongs_to: More on Functions
  description: "### Return type `void`\n\nThe `void` return type for functions can produce some unusual, but expected behavior.\n\nContextual typing with a return type of `void` does **not** force functions to **not** return something. Another way to say this is a contextual function type with a `void` return type (`type voidFunc = () => void`), when implemented, can return *any* other value, but it will be ignored.\n\nThus, the following implementations of the type `() => void` are valid:\n\n``` ts\ntype voidFunc = () => void;\n \nconst f1: voidFunc = () => {\n  return true;\n};\n \nconst f2: voidFunc = () => true;\n \nconst f3: voidFunc = function () {\n  return true;\n};\n```\n\nAnd when the return value of one of these functions is assigned to another variable, it will retain the type of `void`:\n\n``` ts\nconst v1 = f1();\n \nconst v2 = f2();\n \nconst v3 = f3();\n```\n\nThis behavior exists so that the following code is valid even though `Array.prototype.push` returns a number and the `Array.prototype.forEach` method expects a function with a return type of `void`.\n\n``` ts\nconst src = [1, 2, 3];\nconst dst = [0];\n \nsrc.forEach((el) => dst.push(el));\n```\n\nThere is one other special case to be aware of, when a literal function definition has a `void` return type, that function must **not** return anything.\n\n``` ts\nfunction f2(): void {\n  // @ts-expect-error\n  return true;\n}\n \nconst f3 = function (): void {\n  // @ts-expect-error\n  return true;\n};\n```\n\nFor more on `void` please refer to these other documentation entries:\n\n- [v2 handbook](functions#void)\n- [FAQ - “Why are functions returning non-void assignable to function returning void?”](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/functions.html](https://www.typescriptlang.org/docs/handbook/2/functions.html)"
- name: 'More on Functions: unknown'
  id: 2/functions#unknown
  summary: The unknown type represents any value
  belongs_to: More on Functions
  description: |-
    ### `unknown`

    The `unknown` type represents *any* value. This is similar to the `any` type, but is safer because it’s not legal to do anything with an `unknown` value:

    ``` ts
    function f1(a: any) {
      a.b(); // OK
    }
    function f2(a: unknown) {
      a.b();
    }
    ```

    This is useful when describing function types because you can describe functions that accept any value without having `any` values in your function body.

    Conversely, you can describe a function that returns a value of unknown type:

    ``` ts
    function safeParse(s: string): unknown {
      return JSON.parse(s);
    }
     
    // Need to be careful with 'obj'!
    const obj = safeParse(someRandomString);
    ```
- name: 'More on Functions: void'
  id: 2/functions#void
  summary: void represents the return value of functions which don’t return a value
  belongs_to: More on Functions
  description: |-
    ### `void`

    `void` represents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any `return` statements, or doesn’t return any explicit value from those return statements:

    ``` ts
    // The inferred return type is void
    function noop() {
      return;
    }
    ```

    In JavaScript, a function that doesn’t return any value will implicitly return the value `undefined`. However, `void` and `undefined` are not the same thing in TypeScript. There are further details at the end of this chapter.

    > `void` is not the same as `undefined`.
- name: Namespaces
  id: namespaces
  summary: 'A note about terminology: It’s important to note that in TypeScript 1.5, the nomenclature has changed'
  description: "# Namespaces\n\n> **A note about terminology:** It’s important to note that in TypeScript 1.5, the nomenclature has changed. “Internal modules” are now “namespaces”. “External modules” are now simply “modules”, as to align with [ECMAScript 2015](https://www.ecma-international.org/ecma-262/6.0/)’s terminology, (namely that `module X {` is equivalent to the now-preferred `namespace X {`).\n\nThis post outlines the various ways to organize your code using namespaces (previously “internal modules”) in TypeScript. As we alluded in our note about terminology, “internal modules” are now referred to as “namespaces”. Additionally, anywhere the `module` keyword was used when declaring an internal module, the `namespace` keyword can and should be used instead. This avoids confusing new users by overloading them with similarly named terms.\n\n## First steps\n\nLet’s start with the program we’ll be using as our example throughout this page. We’ve written a small set of simplistic string validators, as you might write to check a user’s input on a form in a webpage or check the format of an externally-provided data file.\n\n## Validators in a single file\n\n``` ts\ninterface StringValidator {\n  isAcceptable(s: string): boolean;\n}\n\nlet lettersRegexp = /^[A-Za-z]+$/;\nlet numberRegexp = /^[0-9]+$/;\n\nclass LettersOnlyValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return lettersRegexp.test(s);\n  }\n}\n\nclass ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\n\n// Some samples to try\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// Validators to use\nlet validators: { [s: string]: StringValidator } = {};\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\nvalidators[\"Letters only\"] = new LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n  for (let name in validators) {\n    let isMatch = validators[name].isAcceptable(s);\n    console.log(`'${s}' ${isMatch ? \"matches\" : \"does not match\"} '${name}'.`);\n  }\n}\n```\n\n## Namespacing\n\nAs we add more validators, we’re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let’s wrap up our objects into a namespace.\n\nIn this example, we’ll move all validator-related entities into a namespace called `Validation`. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with `export`. Conversely, the variables `lettersRegexp` and `numberRegexp` are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. `Validation.LettersOnlyValidator`.\n\n## Namespaced Validators\n\n``` ts\nnamespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n\n  const lettersRegexp = /^[A-Za-z]+$/;\n  const numberRegexp = /^[0-9]+$/;\n\n  export class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return lettersRegexp.test(s);\n    }\n  }\n\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return s.length === 5 && numberRegexp.test(s);\n    }\n  }\n}\n\n// Some samples to try\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(\n      `\"${s}\" - ${\n        validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"\n      } ${name}`\n    );\n  }\n}\n```\n\n## Splitting Across Files\n\nAs our application grows, we’ll want to split the code across multiple files to make it easier to maintain.\n\n## Multi-file namespaces\n\nHere, we’ll split our `Validation` namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we’ll add reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.\n\n##### Validation.ts\n\n``` ts\nnamespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n}\n```\n\n##### LettersOnlyValidator.ts\n\n``` ts\n/// <reference path=\"Validation.ts\" />\nnamespace Validation {\n  const lettersRegexp = /^[A-Za-z]+$/;\n  export class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return lettersRegexp.test(s);\n    }\n  }\n}\n```\n\n##### ZipCodeValidator.ts\n\n``` ts\n/// <reference path=\"Validation.ts\" />\nnamespace Validation {\n  const numberRegexp = /^[0-9]+$/;\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return s.length === 5 && numberRegexp.test(s);\n    }\n  }\n}\n```\n\n##### Test.ts\n\n``` ts\n/// <reference path=\"Validation.ts\" />\n/// <reference path=\"LettersOnlyValidator.ts\" />\n/// <reference path=\"ZipCodeValidator.ts\" />\n\n// Some samples to try\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(\n      `\"${s}\" - ${\n        validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"\n      } ${name}`\n    );\n  }\n}\n```\n\nOnce there are multiple files involved, we’ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.\n\nFirst, we can use concatenated output using the [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) option to compile all of the input files into a single JavaScript output file:\n\n``` typescript\ntsc --outFile sample.js Test.ts\n```\n\nThe compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:\n\n``` typescript\ntsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts\n```\n\nAlternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we’ll need to use `<script>` tags on our webpage to load each emitted file in the appropriate order, for example:\n\n##### MyTestPage.html (excerpt)\n\n``` html\n<script src=\"Validation.js\" type=\"text/javascript\" />\n<script src=\"LettersOnlyValidator.js\" type=\"text/javascript\" />\n<script src=\"ZipCodeValidator.js\" type=\"text/javascript\" />\n<script src=\"Test.js\" type=\"text/javascript\" />\n```\n\n## Aliases\n\nAnother way that you can simplify working with namespaces is to use `import q = x.y.z` to create shorter names for commonly-used objects. Not to be confused with the `import x = require(\"name\")` syntax used to load modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports.\n\n``` ts\nnamespace Shapes {\n  export namespace Polygons {\n    export class Triangle {}\n    export class Square {}\n  }\n}\n\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()'\n```\n\nNotice that we don’t use the `require` keyword; instead we assign directly from the qualified name of the symbol we’re importing. This is similar to using `var`, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, `import` is a distinct reference from the original symbol, so changes to an aliased `var` will not be reflected in the original variable.\n\n## Working with Other JavaScript Libraries\n\nTo describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them.\n\nWe call declarations that don’t define an implementation “ambient”. Typically these are defined in `.d.ts` files. If you’re familiar with C/C++, you can think of these as `.h` files. Let’s look at a few examples.\n\n## Ambient Namespaces\n\nThe popular library D3 defines its functionality in a global object called `d3`. Because this library is loaded through a `<script>` tag (instead of a module loader), its declaration uses namespaces to define its shape. For the TypeScript compiler to see this shape, we use an ambient namespace declaration. For example, we could begin writing it as follows:\n\n##### D3.d.ts (simplified excerpt)\n\n``` ts\ndeclare namespace D3 {\n  export interface Selectors {\n    select: {\n      (selector: string): Selection;\n      (element: EventTarget): Selection;\n    };\n  }\n\n  export interface Event {\n    x: number;\n    y: number;\n  }\n\n  export interface Base extends Selectors {\n    event: Event;\n  }\n}\n\ndeclare var d3: D3.Base;\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/namespaces.html](https://www.typescriptlang.org/docs/handbook/namespaces.html)"
- name: Namespaces and Modules
  id: namespaces-and-modules
  summary: This post outlines the various ways to organize your code using modules and namespaces in TypeScript
  description: "# Namespaces and Modules\n\nThis post outlines the various ways to organize your code using modules and namespaces in TypeScript. We’ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.\n\nSee the [Modules](modules/introduction) documentation for more information about ES Modules. See the [Namespaces](namespaces) documentation for more information about TypeScript namespaces.\n\nNote: In *very* old versions of TypeScript namespaces were called ‘Internal Modules’, these pre-date JavaScript module systems.\n\n## Using Modules\n\nModules can contain both code and declarations.\n\nModules also have a dependency on a module loader (such as CommonJs/Require.js) or a runtime which supports ES Modules. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.\n\nIt is also worth noting that, for Node.js applications, modules are the default and **we recommended modules over namespaces in modern code**.\n\nStarting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.\n\n## Using Namespaces\n\nNamespaces are a TypeScript-specific way to organize code.  \nNamespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. Unlike modules, they can span multiple files, and can be concatenated using [`outFile`](https://www.typescriptlang.org/tsconfig#outFile). Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as `<script>` tags in your HTML page.\n\nJust like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.\n\n## Pitfalls of Namespaces and Modules\n\nIn this section we’ll describe various common pitfalls in using namespaces and modules, and how to avoid them.\n\n### `/// <reference>`-ing a module\n\nA common mistake is to try to use the `/// <reference ... />` syntax to refer to a module file, rather than using an `import` statement. To understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of an `import` (e.g. the `...` in `import x from \"...\";`, `import x = require(\"...\");`, etc.) path.\n\nThe compiler will try to find a `.ts`, `.tsx`, and then a `.d.ts` with the appropriate path. If a specific file could not be found, then the compiler will look for an *ambient module declaration*. Recall that these need to be declared in a `.d.ts` file.\n\n- `myModules.d.ts`\n\n  ``` ts\n  // In a .d.ts file or .ts file that is not a module:\n  declare module \"SomeModule\" {\n    export function fn(): string;\n  }\n  ```\n\n- `myOtherModule.ts`\n\n  ``` ts\n  /// <reference path=\"myModules.d.ts\" />\n  import * as m from \"SomeModule\";\n  ```\n\nThe reference tag here allows us to locate the declaration file that contains the declaration for the ambient module. This is how the `node.d.ts` file that several of the TypeScript samples use is consumed.\n\n### Needless Namespacing\n\nIf you’re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:\n\n- `shapes.ts`\n\n  ``` ts\n  export namespace Shapes {\n    export class Triangle {\n      /* ... */\n    }\n    export class Square {\n      /* ... */\n    }\n  }\n  ```\n\nThe top-level namespace here `Shapes` wraps up `Triangle` and `Square` for no reason. This is confusing and annoying for consumers of your module:\n\n- `shapeConsumer.ts`\n\n  ``` ts\n  import * as shapes from \"./shapes\";\n  let t = new shapes.Shapes.Triangle(); // shapes.Shapes?\n  ```\n\nA key feature of modules in TypeScript is that two different modules will never contribute names to the same scope. Because the consumer of a module decides what name to assign it, there’s no need to proactively wrap up the exported symbols in a namespace.\n\nTo reiterate why you shouldn’t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it’s unnecessary to use an additional module layer for exported objects.\n\nHere’s a revised example:\n\n- `shapes.ts`\n\n  ``` ts\n  export class Triangle {\n    /* ... */\n  }\n  export class Square {\n    /* ... */\n  }\n  ```\n\n- `shapeConsumer.ts`\n\n  ``` ts\n  import * as shapes from \"./shapes\";\n  let t = new shapes.Triangle();\n  ```\n\n### Trade-offs of Modules\n\nJust as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it’s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can’t use the [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) option while targeting `commonjs` or `umd`, but with TypeScript 1.8 and later, [it’s possible](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile) to use [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) when targeting `amd` or `system`.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html)"
- name: 'Namespaces and Modules: /// <reference>-ing a module'
  id: namespaces-and-modules#-reference-ing-a-module
  summary: A common mistake is to try to use the /// <reference ... /> syntax to refer to a module file, rather than using an import statement
  belongs_to: Namespaces and Modules
  description: "### `/// <reference>`-ing a module\n\nA common mistake is to try to use the `/// <reference ... />` syntax to refer to a module file, rather than using an `import` statement. To understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of an `import` (e.g. the `...` in `import x from \"...\";`, `import x = require(\"...\");`, etc.) path.\n\nThe compiler will try to find a `.ts`, `.tsx`, and then a `.d.ts` with the appropriate path. If a specific file could not be found, then the compiler will look for an *ambient module declaration*. Recall that these need to be declared in a `.d.ts` file.\n\n- `myModules.d.ts`\n\n  ``` ts\n  // In a .d.ts file or .ts file that is not a module:\n  declare module \"SomeModule\" {\n    export function fn(): string;\n  }\n  ```\n\n- `myOtherModule.ts`\n\n  ``` ts\n  /// <reference path=\"myModules.d.ts\" />\n  import * as m from \"SomeModule\";\n  ```\n\nThe reference tag here allows us to locate the declaration file that contains the declaration for the ambient module. This is how the `node.d.ts` file that several of the TypeScript samples use is consumed.\n\n### Needless Namespacing\n\nIf you’re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:\n\n- `shapes.ts`\n\n  ``` ts\n  export namespace Shapes {\n    export class Triangle {\n      /* ... */\n    }\n    export class Square {\n      /* ... */\n    }\n  }\n  ```\n\nThe top-level namespace here `Shapes` wraps up `Triangle` and `Square` for no reason. This is confusing and annoying for consumers of your module:\n\n- `shapeConsumer.ts`\n\n  ``` ts\n  import * as shapes from \"./shapes\";\n  let t = new shapes.Shapes.Triangle(); // shapes.Shapes?\n  ```\n\nA key feature of modules in TypeScript is that two different modules will never contribute names to the same scope. Because the consumer of a module decides what name to assign it, there’s no need to proactively wrap up the exported symbols in a namespace.\n\nTo reiterate why you shouldn’t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it’s unnecessary to use an additional module layer for exported objects.\n\nHere’s a revised example:\n\n- `shapes.ts`\n\n  ``` ts\n  export class Triangle {\n    /* ... */\n  }\n  export class Square {\n    /* ... */\n  }\n  ```\n\n- `shapeConsumer.ts`\n\n  ``` ts\n  import * as shapes from \"./shapes\";\n  let t = new shapes.Triangle();\n  ```\n\n### Trade-offs of Modules\n\nJust as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it’s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can’t use the [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) option while targeting `commonjs` or `umd`, but with TypeScript 1.8 and later, [it’s possible](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile) to use [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) when targeting `amd` or `system`.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html)"
- name: 'Namespaces and Modules: Pitfalls of Namespaces and Modules'
  id: namespaces-and-modules#pitfalls-of-namespaces-and-modules
  summary: In this section we’ll describe various common pitfalls in using namespaces and modules, and how to avoid them
  belongs_to: Namespaces and Modules
  description: |-
    ## Pitfalls of Namespaces and Modules

    In this section we’ll describe various common pitfalls in using namespaces and modules, and how to avoid them.
- name: 'Namespaces and Modules: Using Modules'
  id: namespaces-and-modules#using-modules
  summary: Modules can contain both code and declarations
  belongs_to: Namespaces and Modules
  description: |-
    ## Using Modules

    Modules can contain both code and declarations.

    Modules also have a dependency on a module loader (such as CommonJs/Require.js) or a runtime which supports ES Modules. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.

    It is also worth noting that, for Node.js applications, modules are the default and **we recommended modules over namespaces in modern code**.

    Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.
- name: 'Namespaces and Modules: Using Namespaces'
  id: namespaces-and-modules#using-namespaces
  summary: Namespaces are a TypeScript-specific way to organize code
  belongs_to: Namespaces and Modules
  description: "## Using Namespaces\n\nNamespaces are a TypeScript-specific way to organize code.  \nNamespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. Unlike modules, they can span multiple files, and can be concatenated using [`outFile`](https://www.typescriptlang.org/tsconfig#outFile). Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as `<script>` tags in your HTML page.\n\nJust like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application."
- name: 'Namespaces: Aliases'
  id: namespaces#aliases
  summary: Another way that you can simplify working with namespaces is to use import q = x.y.z to create shorter names for commonly-used objects
  belongs_to: Namespaces
  description: |-
    ## Aliases

    Another way that you can simplify working with namespaces is to use `import q = x.y.z` to create shorter names for commonly-used objects. Not to be confused with the `import x = require("name")` syntax used to load modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports.

    ``` ts
    namespace Shapes {
      export namespace Polygons {
        export class Triangle {}
        export class Square {}
      }
    }

    import polygons = Shapes.Polygons;
    let sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()'
    ```

    Notice that we don’t use the `require` keyword; instead we assign directly from the qualified name of the symbol we’re importing. This is similar to using `var`, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, `import` is a distinct reference from the original symbol, so changes to an aliased `var` will not be reflected in the original variable.
- name: 'Namespaces: Ambient Namespaces'
  id: namespaces#ambient-namespaces
  summary: The popular library D3 defines its functionality in a global object called d3
  belongs_to: Namespaces
  description: "## Ambient Namespaces\n\nThe popular library D3 defines its functionality in a global object called `d3`. Because this library is loaded through a `<script>` tag (instead of a module loader), its declaration uses namespaces to define its shape. For the TypeScript compiler to see this shape, we use an ambient namespace declaration. For example, we could begin writing it as follows:\n\n##### D3.d.ts (simplified excerpt)\n\n``` ts\ndeclare namespace D3 {\n  export interface Selectors {\n    select: {\n      (selector: string): Selection;\n      (element: EventTarget): Selection;\n    };\n  }\n\n  export interface Event {\n    x: number;\n    y: number;\n  }\n\n  export interface Base extends Selectors {\n    event: Event;\n  }\n}\n\ndeclare var d3: D3.Base;\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/namespaces.html](https://www.typescriptlang.org/docs/handbook/namespaces.html)"
- name: 'Namespaces: First steps'
  id: namespaces#first-steps
  summary: Let’s start with the program we’ll be using as our example throughout this page
  belongs_to: Namespaces
  description: |-
    ## First steps

    Let’s start with the program we’ll be using as our example throughout this page. We’ve written a small set of simplistic string validators, as you might write to check a user’s input on a form in a webpage or check the format of an externally-provided data file.
- name: 'Namespaces: Multi-file namespaces'
  id: namespaces#multi-file-namespaces
  summary: Here, we’ll split our Validation namespace across many files
  belongs_to: Namespaces
  description: |-
    ## Multi-file namespaces

    Here, we’ll split our `Validation` namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we’ll add reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.

    ##### Validation.ts

    ``` ts
    namespace Validation {
      export interface StringValidator {
        isAcceptable(s: string): boolean;
      }
    }
    ```

    ##### LettersOnlyValidator.ts

    ``` ts
    /// <reference path="Validation.ts" />
    namespace Validation {
      const lettersRegexp = /^[A-Za-z]+$/;
      export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
          return lettersRegexp.test(s);
        }
      }
    }
    ```

    ##### ZipCodeValidator.ts

    ``` ts
    /// <reference path="Validation.ts" />
    namespace Validation {
      const numberRegexp = /^[0-9]+$/;
      export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
          return s.length === 5 && numberRegexp.test(s);
        }
      }
    }
    ```

    ##### Test.ts

    ``` ts
    /// <reference path="Validation.ts" />
    /// <reference path="LettersOnlyValidator.ts" />
    /// <reference path="ZipCodeValidator.ts" />

    // Some samples to try
    let strings = ["Hello", "98052", "101"];

    // Validators to use
    let validators: { [s: string]: Validation.StringValidator } = {};
    validators["ZIP code"] = new Validation.ZipCodeValidator();
    validators["Letters only"] = new Validation.LettersOnlyValidator();

    // Show whether each string passed each validator
    for (let s of strings) {
      for (let name in validators) {
        console.log(
          `"${s}" - ${
            validators[name].isAcceptable(s) ? "matches" : "does not match"
          } ${name}`
        );
      }
    }
    ```

    Once there are multiple files involved, we’ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.

    First, we can use concatenated output using the [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) option to compile all of the input files into a single JavaScript output file:

    ``` typescript
    tsc --outFile sample.js Test.ts
    ```

    The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:

    ``` typescript
    tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts
    ```

    Alternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we’ll need to use `<script>` tags on our webpage to load each emitted file in the appropriate order, for example:

    ##### MyTestPage.html (excerpt)

    ``` html
    <script src="Validation.js" type="text/javascript" />
    <script src="LettersOnlyValidator.js" type="text/javascript" />
    <script src="ZipCodeValidator.js" type="text/javascript" />
    <script src="Test.js" type="text/javascript" />
    ```
- name: 'Namespaces: Namespaced Validators'
  id: namespaces#namespaced-validators
  summary: null
  belongs_to: Namespaces
  description: |-
    ## Namespaced Validators

    ``` ts
    namespace Validation {
      export interface StringValidator {
        isAcceptable(s: string): boolean;
      }

      const lettersRegexp = /^[A-Za-z]+$/;
      const numberRegexp = /^[0-9]+$/;

      export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
          return lettersRegexp.test(s);
        }
      }

      export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
          return s.length === 5 && numberRegexp.test(s);
        }
      }
    }

    // Some samples to try
    let strings = ["Hello", "98052", "101"];

    // Validators to use
    let validators: { [s: string]: Validation.StringValidator } = {};
    validators["ZIP code"] = new Validation.ZipCodeValidator();
    validators["Letters only"] = new Validation.LettersOnlyValidator();

    // Show whether each string passed each validator
    for (let s of strings) {
      for (let name in validators) {
        console.log(
          `"${s}" - ${
            validators[name].isAcceptable(s) ? "matches" : "does not match"
          } ${name}`
        );
      }
    }
    ```
- name: 'Namespaces: Namespacing'
  id: namespaces#namespacing
  summary: As we add more validators, we’re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects
  belongs_to: Namespaces
  description: |-
    ## Namespacing

    As we add more validators, we’re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let’s wrap up our objects into a namespace.

    In this example, we’ll move all validator-related entities into a namespace called `Validation`. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with `export`. Conversely, the variables `lettersRegexp` and `numberRegexp` are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. `Validation.LettersOnlyValidator`.
- name: 'Namespaces: Splitting Across Files'
  id: namespaces#splitting-across-files
  summary: As our application grows, we’ll want to split the code across multiple files to make it easier to maintain
  belongs_to: Namespaces
  description: |-
    ## Splitting Across Files

    As our application grows, we’ll want to split the code across multiple files to make it easier to maintain.
- name: 'Namespaces: Validators in a single file'
  id: namespaces#validators-in-a-single-file
  summary: null
  belongs_to: Namespaces
  description: |-
    ## Validators in a single file

    ``` ts
    interface StringValidator {
      isAcceptable(s: string): boolean;
    }

    let lettersRegexp = /^[A-Za-z]+$/;
    let numberRegexp = /^[0-9]+$/;

    class LettersOnlyValidator implements StringValidator {
      isAcceptable(s: string) {
        return lettersRegexp.test(s);
      }
    }

    class ZipCodeValidator implements StringValidator {
      isAcceptable(s: string) {
        return s.length === 5 && numberRegexp.test(s);
      }
    }

    // Some samples to try
    let strings = ["Hello", "98052", "101"];

    // Validators to use
    let validators: { [s: string]: StringValidator } = {};
    validators["ZIP code"] = new ZipCodeValidator();
    validators["Letters only"] = new LettersOnlyValidator();

    // Show whether each string passed each validator
    for (let s of strings) {
      for (let name in validators) {
        let isMatch = validators[name].isAcceptable(s);
        console.log(`'${s}' ${isMatch ? "matches" : "does not match"} '${name}'.`);
      }
    }
    ```
- name: 'Namespaces: Working with Other JavaScript Libraries'
  id: namespaces#working-with-other-javascript-libraries
  summary: To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes
  belongs_to: Namespaces
  description: |-
    ## Working with Other JavaScript Libraries

    To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them.

    We call declarations that don’t define an implementation “ambient”. Typically these are defined in `.d.ts` files. If you’re familiar with C/C++, you can think of these as `.h` files. Let’s look at a few examples.
- name: Narrowing
  id: 2/narrowing
  summary: Imagine we have a function called padLeft
  description: "# Narrowing\n\nImagine we have a function called `padLeft`.\n\n``` ts\nfunction padLeft(padding: number | string, input: string): string {\n  throw new Error(\"Not implemented yet!\");\n}\n```\n\nIf `padding` is a `number`, it will treat that as the number of spaces we want to prepend to `input`. If `padding` is a `string`, it should just prepend `padding` to `input`. Let’s try to implement the logic for when `padLeft` is passed a `number` for `padding`.\n\n``` ts\nfunction padLeft(padding: number | string, input: string): string {\n  return \" \".repeat(padding) + input;\n}\n```\n\nUh-oh, we’re getting an error on `padding`. TypeScript is warning us that we’re passing a value with type `number | string` to the `repeat` function, which only accepts a `number`, and it’s right. In other words, we haven’t explicitly checked if `padding` is a `number` first, nor are we handling the case where it’s a `string`, so let’s do exactly that.\n\n``` ts\nfunction padLeft(padding: number | string, input: string): string {\n  if (typeof padding === \"number\") {\n    return \" \".repeat(padding) + input;\n  }\n  return padding + input;\n}\n```\n\nIf this mostly looks like uninteresting JavaScript code, that’s sort of the point. Apart from the annotations we put in place, this TypeScript code looks like JavaScript. The idea is that TypeScript’s type system aims to make it as easy as possible to write typical JavaScript code without bending over backwards to get type safety.\n\nWhile it might not look like much, there’s actually a lot going on under the covers here. Much like how TypeScript analyzes runtime values using static types, it overlays type analysis on JavaScript’s runtime control flow constructs like `if/else`, conditional ternaries, loops, truthiness checks, etc., which can all affect those types.\n\nWithin our `if` check, TypeScript sees `typeof padding === \"number\"` and understands that as a special form of code called a *type guard*. TypeScript follows possible paths of execution that our programs can take to analyze the most specific possible type of a value at a given position. It looks at these special checks (called *type guards*) and assignments, and the process of refining types to more specific types than declared is called *narrowing*. In many editors we can observe these types as they change, and we’ll even do so in our examples.\n\n``` ts\nfunction padLeft(padding: number | string, input: string): string {\n  if (typeof padding === \"number\") {\n    return \" \".repeat(padding) + input;\n  }\n  return padding + input;\n}\n```\n\nThere are a couple of different constructs TypeScript understands for narrowing.\n\n## `typeof` type guards\n\nAs we’ve seen, JavaScript supports a `typeof` operator which can give very basic information about the type of values we have at runtime. TypeScript expects this to return a certain set of strings:\n\n- `\"string\"`\n- `\"number\"`\n- `\"bigint\"`\n- `\"boolean\"`\n- `\"symbol\"`\n- `\"undefined\"`\n- `\"object\"`\n- `\"function\"`\n\nLike we saw with `padLeft`, this operator comes up pretty often in a number of JavaScript libraries, and TypeScript can understand it to narrow types in different branches.\n\nIn TypeScript, checking against the value returned by `typeof` is a type guard. Because TypeScript encodes how `typeof` operates on different values, it knows about some of its quirks in JavaScript. For example, notice that in the list above, `typeof` doesn’t return the string `null`. Check out the following example:\n\n``` ts\nfunction printAll(strs: string | string[] | null) {\n  if (typeof strs === \"object\") {\n    for (const s of strs) {\n      console.log(s);\n    }\n  } else if (typeof strs === \"string\") {\n    console.log(strs);\n  } else {\n    // do nothing\n  }\n}\n```\n\nIn the `printAll` function, we try to check if `strs` is an object to see if it’s an array type (now might be a good time to reinforce that arrays are object types in JavaScript). But it turns out that in JavaScript, `typeof null` is actually `\"object\"`! This is one of those unfortunate accidents of history.\n\nUsers with enough experience might not be surprised, but not everyone has run into this in JavaScript; luckily, TypeScript lets us know that `strs` was only narrowed down to `string[] | null` instead of just `string[]`.\n\nThis might be a good segue into what we’ll call “truthiness” checking.\n\n# Truthiness narrowing\n\nTruthiness might not be a word you’ll find in the dictionary, but it’s very much something you’ll hear about in JavaScript.\n\nIn JavaScript, we can use any expression in conditionals, `&&`s, `||`s, `if` statements, Boolean negations (`!`), and more. As an example, `if` statements don’t expect their condition to always have the type `boolean`.\n\n``` ts\nfunction getUsersOnlineMessage(numUsersOnline: number) {\n  if (numUsersOnline) {\n    return `There are ${numUsersOnline} online now!`;\n  }\n  return \"Nobody's here. :(\";\n}\n```\n\nIn JavaScript, constructs like `if` first “coerce” their conditions to `boolean`s to make sense of them, and then choose their branches depending on whether the result is `true` or `false`. Values like\n\n- `0`\n- `NaN`\n- `\"\"` (the empty string)\n- `0n` (the `bigint` version of zero)\n- `null`\n- `undefined`\n\nall coerce to `false`, and other values get coerced to `true`. You can always coerce values to `boolean`s by running them through the `Boolean` function, or by using the shorter double-Boolean negation. (The latter has the advantage that TypeScript infers a narrow literal boolean type `true`, while inferring the first as type `boolean`.)\n\n``` ts\n// both of these result in 'true'\nBoolean(\"hello\"); // type: boolean, value: true\n!!\"world\"; // type: true,    value: true\n```\n\nIt’s fairly popular to leverage this behavior, especially for guarding against values like `null` or `undefined`. As an example, let’s try using it for our `printAll` function.\n\n``` ts\nfunction printAll(strs: string | string[] | null) {\n  if (strs && typeof strs === \"object\") {\n    for (const s of strs) {\n      console.log(s);\n    }\n  } else if (typeof strs === \"string\") {\n    console.log(strs);\n  }\n}\n```\n\nYou’ll notice that we’ve gotten rid of the error above by checking if `strs` is truthy. This at least prevents us from dreaded errors when we run our code like:\n\n``` txt\nTypeError: null is not iterable\n```\n\nKeep in mind though that truthiness checking on primitives can often be error prone. As an example, consider a different attempt at writing `printAll`\n\n``` ts\nfunction printAll(strs: string | string[] | null) {\n  // !!!!!!!!!!!!!!!!\n  //  DON'T DO THIS!\n  //   KEEP READING\n  // !!!!!!!!!!!!!!!!\n  if (strs) {\n    if (typeof strs === \"object\") {\n      for (const s of strs) {\n        console.log(s);\n      }\n    } else if (typeof strs === \"string\") {\n      console.log(strs);\n    }\n  }\n}\n```\n\nWe wrapped the entire body of the function in a truthy check, but this has a subtle downside: we may no longer be handling the empty string case correctly.\n\nTypeScript doesn’t hurt us here at all, but this behavior is worth noting if you’re less familiar with JavaScript. TypeScript can often help you catch bugs early on, but if you choose to do *nothing* with a value, there’s only so much that it can do without being overly prescriptive. If you want, you can make sure you handle situations like these with a linter.\n\nOne last word on narrowing by truthiness is that Boolean negations with `!` filter out from negated branches.\n\n``` ts\nfunction multiplyAll(\n  values: number[] | undefined,\n  factor: number\n): number[] | undefined {\n  if (!values) {\n    return values;\n  } else {\n    return values.map((x) => x * factor);\n  }\n}\n```\n\n## Equality narrowing\n\nTypeScript also uses `switch` statements and equality checks like `===`, `!==`, `==`, and `!=` to narrow types. For example:\n\n``` ts\nfunction example(x: string | number, y: string | boolean) {\n  if (x === y) {\n    // We can now call any 'string' method on 'x' or 'y'.\n    x.toUpperCase();\n    y.toLowerCase();\n  } else {\n    console.log(x);\n    console.log(y);\n  }\n}\n```\n\nWhen we checked that `x` and `y` are both equal in the above example, TypeScript knew their types also had to be equal. Since `string` is the only common type that both `x` and `y` could take on, TypeScript knows that `x` and `y` must be `string`s in the first branch.\n\nChecking against specific literal values (as opposed to variables) works also. In our section about truthiness narrowing, we wrote a `printAll` function which was error-prone because it accidentally didn’t handle empty strings properly. Instead we could have done a specific check to block out `null`s, and TypeScript still correctly removes `null` from the type of `strs`.\n\n``` ts\nfunction printAll(strs: string | string[] | null) {\n  if (strs !== null) {\n    if (typeof strs === \"object\") {\n      for (const s of strs) {\n        console.log(s);\n      }\n    } else if (typeof strs === \"string\") {\n      console.log(strs);\n    }\n  }\n}\n```\n\nJavaScript’s looser equality checks with `==` and `!=` also get narrowed correctly. If you’re unfamiliar, checking whether something `== null` actually not only checks whether it is specifically the value `null` - it also checks whether it’s potentially `undefined`. The same applies to `== undefined`: it checks whether a value is either `null` or `undefined`.\n\n``` ts\ninterface Container {\n  value: number | null | undefined;\n}\n \nfunction multiplyValue(container: Container, factor: number) {\n  // Remove both 'null' and 'undefined' from the type.\n  if (container.value != null) {\n    console.log(container.value);\n \n    // Now we can safely multiply 'container.value'.\n    container.value *= factor;\n  }\n}\n```\n\n## The `in` operator narrowing\n\nJavaScript has an operator for determining if an object or its prototype chain has a property with a name: the `in` operator. TypeScript takes this into account as a way to narrow down potential types.\n\nFor example, with the code: `\"value\" in x`. where `\"value\"` is a string literal and `x` is a union type. The “true” branch narrows `x`’s types which have either an optional or required property `value`, and the “false” branch narrows to types which have an optional or missing property `value`.\n\n``` ts\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\n \nfunction move(animal: Fish | Bird) {\n  if (\"swim\" in animal) {\n    return animal.swim();\n  }\n \n  return animal.fly();\n}\n```\n\nTo reiterate, optional properties will exist in both sides for narrowing. For example, a human could both swim and fly (with the right equipment) and thus should show up in both sides of the `in` check:\n\n``` ts\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\ntype Human = { swim?: () => void; fly?: () => void };\n \nfunction move(animal: Fish | Bird | Human) {\n  if (\"swim\" in animal) {\n    animal;\n  } else {\n    animal;\n  }\n}\n```\n\n## `instanceof` narrowing\n\nJavaScript has an operator for checking whether or not a value is an “instance” of another value. More specifically, in JavaScript `x instanceof Foo` checks whether the *prototype chain* of `x` contains `Foo.prototype`. While we won’t dive deep here, and you’ll see more of this when we get into classes, they can still be useful for most values that can be constructed with `new`. As you might have guessed, `instanceof` is also a type guard, and TypeScript narrows in branches guarded by `instanceof`s.\n\n``` ts\nfunction logValue(x: Date | string) {\n  if (x instanceof Date) {\n    console.log(x.toUTCString());\n  } else {\n    console.log(x.toUpperCase());\n  }\n}\n```\n\n## Assignments\n\nAs we mentioned earlier, when we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately.\n\n``` ts\nlet x = Math.random() < 0.5 ? 10 : \"hello world!\";\nx = 1;\n \nconsole.log(x);\nx = \"goodbye!\";\n \nconsole.log(x);\n```\n\nNotice that each of these assignments is valid. Even though the observed type of `x` changed to `number` after our first assignment, we were still able to assign a `string` to `x`. This is because the *declared type* of `x` - the type that `x` started with - is `string | number`, and assignability is always checked against the declared type.\n\nIf we’d assigned a `boolean` to `x`, we’d have seen an error since that wasn’t part of the declared type.\n\n``` ts\nlet x = Math.random() < 0.5 ? 10 : \"hello world!\";\nx = 1;\n \nconsole.log(x);\nx = true;\n \nconsole.log(x);\n```\n\n## Control flow analysis\n\nUp until this point, we’ve gone through some basic examples of how TypeScript narrows within specific branches. But there’s a bit more going on than just walking up from every variable and looking for type guards in `if`s, `while`s, conditionals, etc. For example\n\n``` ts\nfunction padLeft(padding: number | string, input: string) {\n  if (typeof padding === \"number\") {\n    return \" \".repeat(padding) + input;\n  }\n  return padding + input;\n}\n```\n\n`padLeft` returns from within its first `if` block. TypeScript was able to analyze this code and see that the rest of the body (`return padding + input;`) is *unreachable* in the case where `padding` is a `number`. As a result, it was able to remove `number` from the type of `padding` (narrowing from `string | number` to `string`) for the rest of the function.\n\nThis analysis of code based on reachability is called *control flow analysis*, and TypeScript uses this flow analysis to narrow types as it encounters type guards and assignments. When a variable is analyzed, control flow can split off and re-merge over and over again, and that variable can be observed to have a different type at each point.\n\n``` ts\nfunction example() {\n  let x: string | number | boolean;\n \n  x = Math.random() < 0.5;\n \n  console.log(x);\n \n  if (Math.random() < 0.5) {\n    x = \"hello\";\n    console.log(x);\n  } else {\n    x = 100;\n    console.log(x);\n  }\n \n  return x;\n}\n```\n\n## Using type predicates\n\nWe’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code.\n\nTo define a user-defined type guard, we simply need to define a function whose return type is a *type predicate*:\n\n``` ts\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n```\n\n`pet is Fish` is our type predicate in this example. A predicate takes the form `parameterName is Type`, where `parameterName` must be the name of a parameter from the current function signature.\n\nAny time `isFish` is called with some variable, TypeScript will *narrow* that variable to that specific type if the original type is compatible.\n\n``` ts\n// Both calls to 'swim' and 'fly' are now okay.\nlet pet = getSmallPet();\n \nif (isFish(pet)) {\n  pet.swim();\n} else {\n  pet.fly();\n}\n```\n\nNotice that TypeScript not only knows that `pet` is a `Fish` in the `if` branch; it also knows that in the `else` branch, you *don’t* have a `Fish`, so you must have a `Bird`.\n\nYou may use the type guard `isFish` to filter an array of `Fish | Bird` and obtain an array of `Fish`:\n\n``` ts\nconst zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];\nconst underWater1: Fish[] = zoo.filter(isFish);\n// or, equivalently\nconst underWater2: Fish[] = zoo.filter(isFish) as Fish[];\n \n// The predicate may need repeating for more complex examples\nconst underWater3: Fish[] = zoo.filter((pet): pet is Fish => {\n  if (pet.name === \"sharkey\") return false;\n  return isFish(pet);\n});\n```\n\nIn addition, classes can [use `this is Type`](classes#this-based-type-guards) to narrow their type.\n\n## Assertion functions\n\nTypes can also be narrowed using [Assertion functions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions).\n\n# Discriminated unions\n\nMost of the examples we’ve looked at so far have focused around narrowing single variables with simple types like `string`, `boolean`, and `number`. While this is common, most of the time in JavaScript we’ll be dealing with slightly more complex structures.\n\nFor some motivation, let’s imagine we’re trying to encode shapes like circles and squares. Circles keep track of their radiuses and squares keep track of their side lengths. We’ll use a field called `kind` to tell which shape we’re dealing with. Here’s a first attempt at defining `Shape`.\n\n``` ts\ninterface Shape {\n  kind: \"circle\" | \"square\";\n  radius?: number;\n  sideLength?: number;\n}\n```\n\nNotice we’re using a union of string literal types: `\"circle\"` and `\"square\"` to tell us whether we should treat the shape as a circle or square respectively. By using `\"circle\" | \"square\"` instead of `string`, we can avoid misspelling issues.\n\n``` ts\nfunction handleShape(shape: Shape) {\n  // oops!\n  if (shape.kind === \"rect\") {\n    // ...\n  }\n}\n```\n\nWe can write a `getArea` function that applies the right logic based on if it’s dealing with a circle or square. We’ll first try dealing with circles.\n\n``` ts\nfunction getArea(shape: Shape) {\n  return Math.PI * shape.radius ** 2;\n}\n```\n\nUnder [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) that gives us an error - which is appropriate since `radius` might not be defined. But what if we perform the appropriate checks on the `kind` property?\n\n``` ts\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    return Math.PI * shape.radius ** 2;\n  }\n}\n```\n\nHmm, TypeScript still doesn’t know what to do here. We’ve hit a point where we know more about our values than the type checker does. We could try to use a non-null assertion (a `!` after `shape.radius`) to say that `radius` is definitely present.\n\n``` ts\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    return Math.PI * shape.radius! ** 2;\n  }\n}\n```\n\nBut this doesn’t feel ideal. We had to shout a bit at the type-checker with those non-null assertions (`!`) to convince it that `shape.radius` was defined, but those assertions are error-prone if we start to move code around. Additionally, outside of [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) we’re able to accidentally access any of those fields anyway (since optional properties are just assumed to always be present when reading them). We can definitely do better.\n\nThe problem with this encoding of `Shape` is that the type-checker doesn’t have any way to know whether or not `radius` or `sideLength` are present based on the `kind` property. We need to communicate what *we* know to the type checker. With that in mind, let’s take another swing at defining `Shape`.\n\n``` ts\ninterface Circle {\n  kind: \"circle\";\n  radius: number;\n}\n \ninterface Square {\n  kind: \"square\";\n  sideLength: number;\n}\n \ntype Shape = Circle | Square;\n```\n\nHere, we’ve properly separated `Shape` out into two types with different values for the `kind` property, but `radius` and `sideLength` are declared as required properties in their respective types.\n\nLet’s see what happens here when we try to access the `radius` of a `Shape`.\n\n``` ts\nfunction getArea(shape: Shape) {\n  return Math.PI * shape.radius ** 2;\n}\n```\n\nLike with our first definition of `Shape`, this is still an error. When `radius` was optional, we got an error (with [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) enabled) because TypeScript couldn’t tell whether the property was present. Now that `Shape` is a union, TypeScript is telling us that `shape` might be a `Square`, and `Square`s don’t have `radius` defined on them! Both interpretations are correct, but only the union encoding of `Shape` will cause an error regardless of how [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is configured.\n\nBut what if we tried checking the `kind` property again?\n\n``` ts\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    return Math.PI * shape.radius ** 2;\n  }\n}\n```\n\nThat got rid of the error! When every type in a union contains a common property with literal types, TypeScript considers that to be a *discriminated union*, and can narrow out the members of the union.\n\nIn this case, `kind` was that common property (which is what’s considered a *discriminant* property of `Shape`). Checking whether the `kind` property was `\"circle\"` got rid of every type in `Shape` that didn’t have a `kind` property with the type `\"circle\"`. That narrowed `shape` down to the type `Circle`.\n\nThe same checking works with `switch` statements as well. Now we can try to write our complete `getArea` without any pesky `!` non-null assertions.\n\n``` ts\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n  }\n}\n```\n\nThe important thing here was the encoding of `Shape`. Communicating the right information to TypeScript - that `Circle` and `Square` were really two separate types with specific `kind` fields - was crucial. Doing that lets us write type-safe TypeScript code that looks no different than the JavaScript we would’ve written otherwise. From there, the type system was able to do the “right” thing and figure out the types in each branch of our `switch` statement.\n\n> As an aside, try playing around with the above example and remove some of the return keywords. You’ll see that type-checking can help avoid bugs when accidentally falling through different clauses in a `switch` statement.\n\nDiscriminated unions are useful for more than just talking about circles and squares. They’re good for representing any sort of messaging scheme in JavaScript, like when sending messages over the network (client/server communication), or encoding mutations in a state management framework.\n\n# The `never` type\n\nWhen narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. In those cases, TypeScript will use a `never` type to represent a state which shouldn’t exist.\n\n# Exhaustiveness checking\n\nThe `never` type is assignable to every type; however, no type is assignable to `never` (except `never` itself). This means you can use narrowing and rely on `never` turning up to do exhaustive checking in a `switch` statement.\n\nFor example, adding a `default` to our `getArea` function which tries to assign the shape to `never` will not raise an error when every possible case has been handled.\n\n``` ts\ntype Shape = Circle | Square;\n \nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never = shape;\n      return _exhaustiveCheck;\n  }\n}\n```\n\nAdding a new member to the `Shape` union, will cause a TypeScript error:\n\n``` ts\ninterface Triangle {\n  kind: \"triangle\";\n  sideLength: number;\n}\n \ntype Shape = Circle | Square | Triangle;\n \nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never = shape;\n      return _exhaustiveCheck;\n  }\n}\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/narrowing.html](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)"
- name: 'Narrowing: Assertion functions'
  id: 2/narrowing#assertion-functions
  summary: Types can also be narrowed using Assertion functions
  belongs_to: Narrowing
  description: "## Assertion functions\n\nTypes can also be narrowed using [Assertion functions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions).\n\n# Discriminated unions\n\nMost of the examples we’ve looked at so far have focused around narrowing single variables with simple types like `string`, `boolean`, and `number`. While this is common, most of the time in JavaScript we’ll be dealing with slightly more complex structures.\n\nFor some motivation, let’s imagine we’re trying to encode shapes like circles and squares. Circles keep track of their radiuses and squares keep track of their side lengths. We’ll use a field called `kind` to tell which shape we’re dealing with. Here’s a first attempt at defining `Shape`.\n\n``` ts\ninterface Shape {\n  kind: \"circle\" | \"square\";\n  radius?: number;\n  sideLength?: number;\n}\n```\n\nNotice we’re using a union of string literal types: `\"circle\"` and `\"square\"` to tell us whether we should treat the shape as a circle or square respectively. By using `\"circle\" | \"square\"` instead of `string`, we can avoid misspelling issues.\n\n``` ts\nfunction handleShape(shape: Shape) {\n  // oops!\n  if (shape.kind === \"rect\") {\n    // ...\n  }\n}\n```\n\nWe can write a `getArea` function that applies the right logic based on if it’s dealing with a circle or square. We’ll first try dealing with circles.\n\n``` ts\nfunction getArea(shape: Shape) {\n  return Math.PI * shape.radius ** 2;\n}\n```\n\nUnder [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) that gives us an error - which is appropriate since `radius` might not be defined. But what if we perform the appropriate checks on the `kind` property?\n\n``` ts\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    return Math.PI * shape.radius ** 2;\n  }\n}\n```\n\nHmm, TypeScript still doesn’t know what to do here. We’ve hit a point where we know more about our values than the type checker does. We could try to use a non-null assertion (a `!` after `shape.radius`) to say that `radius` is definitely present.\n\n``` ts\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    return Math.PI * shape.radius! ** 2;\n  }\n}\n```\n\nBut this doesn’t feel ideal. We had to shout a bit at the type-checker with those non-null assertions (`!`) to convince it that `shape.radius` was defined, but those assertions are error-prone if we start to move code around. Additionally, outside of [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) we’re able to accidentally access any of those fields anyway (since optional properties are just assumed to always be present when reading them). We can definitely do better.\n\nThe problem with this encoding of `Shape` is that the type-checker doesn’t have any way to know whether or not `radius` or `sideLength` are present based on the `kind` property. We need to communicate what *we* know to the type checker. With that in mind, let’s take another swing at defining `Shape`.\n\n``` ts\ninterface Circle {\n  kind: \"circle\";\n  radius: number;\n}\n \ninterface Square {\n  kind: \"square\";\n  sideLength: number;\n}\n \ntype Shape = Circle | Square;\n```\n\nHere, we’ve properly separated `Shape` out into two types with different values for the `kind` property, but `radius` and `sideLength` are declared as required properties in their respective types.\n\nLet’s see what happens here when we try to access the `radius` of a `Shape`.\n\n``` ts\nfunction getArea(shape: Shape) {\n  return Math.PI * shape.radius ** 2;\n}\n```\n\nLike with our first definition of `Shape`, this is still an error. When `radius` was optional, we got an error (with [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) enabled) because TypeScript couldn’t tell whether the property was present. Now that `Shape` is a union, TypeScript is telling us that `shape` might be a `Square`, and `Square`s don’t have `radius` defined on them! Both interpretations are correct, but only the union encoding of `Shape` will cause an error regardless of how [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is configured.\n\nBut what if we tried checking the `kind` property again?\n\n``` ts\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    return Math.PI * shape.radius ** 2;\n  }\n}\n```\n\nThat got rid of the error! When every type in a union contains a common property with literal types, TypeScript considers that to be a *discriminated union*, and can narrow out the members of the union.\n\nIn this case, `kind` was that common property (which is what’s considered a *discriminant* property of `Shape`). Checking whether the `kind` property was `\"circle\"` got rid of every type in `Shape` that didn’t have a `kind` property with the type `\"circle\"`. That narrowed `shape` down to the type `Circle`.\n\nThe same checking works with `switch` statements as well. Now we can try to write our complete `getArea` without any pesky `!` non-null assertions.\n\n``` ts\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n  }\n}\n```\n\nThe important thing here was the encoding of `Shape`. Communicating the right information to TypeScript - that `Circle` and `Square` were really two separate types with specific `kind` fields - was crucial. Doing that lets us write type-safe TypeScript code that looks no different than the JavaScript we would’ve written otherwise. From there, the type system was able to do the “right” thing and figure out the types in each branch of our `switch` statement.\n\n> As an aside, try playing around with the above example and remove some of the return keywords. You’ll see that type-checking can help avoid bugs when accidentally falling through different clauses in a `switch` statement.\n\nDiscriminated unions are useful for more than just talking about circles and squares. They’re good for representing any sort of messaging scheme in JavaScript, like when sending messages over the network (client/server communication), or encoding mutations in a state management framework.\n\n# The `never` type\n\nWhen narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. In those cases, TypeScript will use a `never` type to represent a state which shouldn’t exist.\n\n# Exhaustiveness checking\n\nThe `never` type is assignable to every type; however, no type is assignable to `never` (except `never` itself). This means you can use narrowing and rely on `never` turning up to do exhaustive checking in a `switch` statement.\n\nFor example, adding a `default` to our `getArea` function which tries to assign the shape to `never` will not raise an error when every possible case has been handled.\n\n``` ts\ntype Shape = Circle | Square;\n \nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never = shape;\n      return _exhaustiveCheck;\n  }\n}\n```\n\nAdding a new member to the `Shape` union, will cause a TypeScript error:\n\n``` ts\ninterface Triangle {\n  kind: \"triangle\";\n  sideLength: number;\n}\n \ntype Shape = Circle | Square | Triangle;\n \nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never = shape;\n      return _exhaustiveCheck;\n  }\n}\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/narrowing.html](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)"
- name: 'Narrowing: Assignments'
  id: 2/narrowing#assignments
  summary: As we mentioned earlier, when we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately
  belongs_to: Narrowing
  description: |-
    ## Assignments

    As we mentioned earlier, when we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately.

    ``` ts
    let x = Math.random() < 0.5 ? 10 : "hello world!";
    x = 1;
     
    console.log(x);
    x = "goodbye!";
     
    console.log(x);
    ```

    Notice that each of these assignments is valid. Even though the observed type of `x` changed to `number` after our first assignment, we were still able to assign a `string` to `x`. This is because the *declared type* of `x` - the type that `x` started with - is `string | number`, and assignability is always checked against the declared type.

    If we’d assigned a `boolean` to `x`, we’d have seen an error since that wasn’t part of the declared type.

    ``` ts
    let x = Math.random() < 0.5 ? 10 : "hello world!";
    x = 1;
     
    console.log(x);
    x = true;
     
    console.log(x);
    ```
- name: 'Narrowing: Control flow analysis'
  id: 2/narrowing#control-flow-analysis
  summary: Up until this point, we’ve gone through some basic examples of how TypeScript narrows within specific branches
  belongs_to: Narrowing
  description: |-
    ## Control flow analysis

    Up until this point, we’ve gone through some basic examples of how TypeScript narrows within specific branches. But there’s a bit more going on than just walking up from every variable and looking for type guards in `if`s, `while`s, conditionals, etc. For example

    ``` ts
    function padLeft(padding: number | string, input: string) {
      if (typeof padding === "number") {
        return " ".repeat(padding) + input;
      }
      return padding + input;
    }
    ```

    `padLeft` returns from within its first `if` block. TypeScript was able to analyze this code and see that the rest of the body (`return padding + input;`) is *unreachable* in the case where `padding` is a `number`. As a result, it was able to remove `number` from the type of `padding` (narrowing from `string | number` to `string`) for the rest of the function.

    This analysis of code based on reachability is called *control flow analysis*, and TypeScript uses this flow analysis to narrow types as it encounters type guards and assignments. When a variable is analyzed, control flow can split off and re-merge over and over again, and that variable can be observed to have a different type at each point.

    ``` ts
    function example() {
      let x: string | number | boolean;
     
      x = Math.random() < 0.5;
     
      console.log(x);
     
      if (Math.random() < 0.5) {
        x = "hello";
        console.log(x);
      } else {
        x = 100;
        console.log(x);
      }
     
      return x;
    }
    ```
- name: 'Narrowing: Equality narrowing'
  id: 2/narrowing#equality-narrowing
  summary: TypeScript also uses switch statements and equality checks like ===, !==, ==, and != to narrow types
  belongs_to: Narrowing
  description: |-
    ## Equality narrowing

    TypeScript also uses `switch` statements and equality checks like `===`, `!==`, `==`, and `!=` to narrow types. For example:

    ``` ts
    function example(x: string | number, y: string | boolean) {
      if (x === y) {
        // We can now call any 'string' method on 'x' or 'y'.
        x.toUpperCase();
        y.toLowerCase();
      } else {
        console.log(x);
        console.log(y);
      }
    }
    ```

    When we checked that `x` and `y` are both equal in the above example, TypeScript knew their types also had to be equal. Since `string` is the only common type that both `x` and `y` could take on, TypeScript knows that `x` and `y` must be `string`s in the first branch.

    Checking against specific literal values (as opposed to variables) works also. In our section about truthiness narrowing, we wrote a `printAll` function which was error-prone because it accidentally didn’t handle empty strings properly. Instead we could have done a specific check to block out `null`s, and TypeScript still correctly removes `null` from the type of `strs`.

    ``` ts
    function printAll(strs: string | string[] | null) {
      if (strs !== null) {
        if (typeof strs === "object") {
          for (const s of strs) {
            console.log(s);
          }
        } else if (typeof strs === "string") {
          console.log(strs);
        }
      }
    }
    ```

    JavaScript’s looser equality checks with `==` and `!=` also get narrowed correctly. If you’re unfamiliar, checking whether something `== null` actually not only checks whether it is specifically the value `null` - it also checks whether it’s potentially `undefined`. The same applies to `== undefined`: it checks whether a value is either `null` or `undefined`.

    ``` ts
    interface Container {
      value: number | null | undefined;
    }
     
    function multiplyValue(container: Container, factor: number) {
      // Remove both 'null' and 'undefined' from the type.
      if (container.value != null) {
        console.log(container.value);
     
        // Now we can safely multiply 'container.value'.
        container.value *= factor;
      }
    }
    ```
- name: 'Narrowing: instanceof narrowing'
  id: 2/narrowing#instanceof-narrowing
  summary: JavaScript has an operator for checking whether or not a value is an “instance” of another value
  belongs_to: Narrowing
  description: |-
    ## `instanceof` narrowing

    JavaScript has an operator for checking whether or not a value is an “instance” of another value. More specifically, in JavaScript `x instanceof Foo` checks whether the *prototype chain* of `x` contains `Foo.prototype`. While we won’t dive deep here, and you’ll see more of this when we get into classes, they can still be useful for most values that can be constructed with `new`. As you might have guessed, `instanceof` is also a type guard, and TypeScript narrows in branches guarded by `instanceof`s.

    ``` ts
    function logValue(x: Date | string) {
      if (x instanceof Date) {
        console.log(x.toUTCString());
      } else {
        console.log(x.toUpperCase());
      }
    }
    ```
- name: 'Narrowing: The in operator narrowing'
  id: 2/narrowing#the-in-operator-narrowing
  summary: 'JavaScript has an operator for determining if an object or its prototype chain has a property with a name: the in operator'
  belongs_to: Narrowing
  description: |-
    ## The `in` operator narrowing

    JavaScript has an operator for determining if an object or its prototype chain has a property with a name: the `in` operator. TypeScript takes this into account as a way to narrow down potential types.

    For example, with the code: `"value" in x`. where `"value"` is a string literal and `x` is a union type. The “true” branch narrows `x`’s types which have either an optional or required property `value`, and the “false” branch narrows to types which have an optional or missing property `value`.

    ``` ts
    type Fish = { swim: () => void };
    type Bird = { fly: () => void };
     
    function move(animal: Fish | Bird) {
      if ("swim" in animal) {
        return animal.swim();
      }
     
      return animal.fly();
    }
    ```

    To reiterate, optional properties will exist in both sides for narrowing. For example, a human could both swim and fly (with the right equipment) and thus should show up in both sides of the `in` check:

    ``` ts
    type Fish = { swim: () => void };
    type Bird = { fly: () => void };
    type Human = { swim?: () => void; fly?: () => void };
     
    function move(animal: Fish | Bird | Human) {
      if ("swim" in animal) {
        animal;
      } else {
        animal;
      }
    }
    ```
- name: 'Narrowing: typeof type guards'
  id: 2/narrowing#typeof-type-guards
  summary: As we’ve seen, JavaScript supports a typeof operator which can give very basic information about the type of values we have at runtime
  belongs_to: Narrowing
  description: |-
    ## `typeof` type guards

    As we’ve seen, JavaScript supports a `typeof` operator which can give very basic information about the type of values we have at runtime. TypeScript expects this to return a certain set of strings:

    - `"string"`
    - `"number"`
    - `"bigint"`
    - `"boolean"`
    - `"symbol"`
    - `"undefined"`
    - `"object"`
    - `"function"`

    Like we saw with `padLeft`, this operator comes up pretty often in a number of JavaScript libraries, and TypeScript can understand it to narrow types in different branches.

    In TypeScript, checking against the value returned by `typeof` is a type guard. Because TypeScript encodes how `typeof` operates on different values, it knows about some of its quirks in JavaScript. For example, notice that in the list above, `typeof` doesn’t return the string `null`. Check out the following example:

    ``` ts
    function printAll(strs: string | string[] | null) {
      if (typeof strs === "object") {
        for (const s of strs) {
          console.log(s);
        }
      } else if (typeof strs === "string") {
        console.log(strs);
      } else {
        // do nothing
      }
    }
    ```

    In the `printAll` function, we try to check if `strs` is an object to see if it’s an array type (now might be a good time to reinforce that arrays are object types in JavaScript). But it turns out that in JavaScript, `typeof null` is actually `"object"`! This is one of those unfortunate accidents of history.

    Users with enough experience might not be surprised, but not everyone has run into this in JavaScript; luckily, TypeScript lets us know that `strs` was only narrowed down to `string[] | null` instead of just `string[]`.

    This might be a good segue into what we’ll call “truthiness” checking.

    # Truthiness narrowing

    Truthiness might not be a word you’ll find in the dictionary, but it’s very much something you’ll hear about in JavaScript.

    In JavaScript, we can use any expression in conditionals, `&&`s, `||`s, `if` statements, Boolean negations (`!`), and more. As an example, `if` statements don’t expect their condition to always have the type `boolean`.

    ``` ts
    function getUsersOnlineMessage(numUsersOnline: number) {
      if (numUsersOnline) {
        return `There are ${numUsersOnline} online now!`;
      }
      return "Nobody's here. :(";
    }
    ```

    In JavaScript, constructs like `if` first “coerce” their conditions to `boolean`s to make sense of them, and then choose their branches depending on whether the result is `true` or `false`. Values like

    - `0`
    - `NaN`
    - `""` (the empty string)
    - `0n` (the `bigint` version of zero)
    - `null`
    - `undefined`

    all coerce to `false`, and other values get coerced to `true`. You can always coerce values to `boolean`s by running them through the `Boolean` function, or by using the shorter double-Boolean negation. (The latter has the advantage that TypeScript infers a narrow literal boolean type `true`, while inferring the first as type `boolean`.)

    ``` ts
    // both of these result in 'true'
    Boolean("hello"); // type: boolean, value: true
    !!"world"; // type: true,    value: true
    ```

    It’s fairly popular to leverage this behavior, especially for guarding against values like `null` or `undefined`. As an example, let’s try using it for our `printAll` function.

    ``` ts
    function printAll(strs: string | string[] | null) {
      if (strs && typeof strs === "object") {
        for (const s of strs) {
          console.log(s);
        }
      } else if (typeof strs === "string") {
        console.log(strs);
      }
    }
    ```

    You’ll notice that we’ve gotten rid of the error above by checking if `strs` is truthy. This at least prevents us from dreaded errors when we run our code like:

    ``` txt
    TypeError: null is not iterable
    ```

    Keep in mind though that truthiness checking on primitives can often be error prone. As an example, consider a different attempt at writing `printAll`

    ``` ts
    function printAll(strs: string | string[] | null) {
      // !!!!!!!!!!!!!!!!
      //  DON'T DO THIS!
      //   KEEP READING
      // !!!!!!!!!!!!!!!!
      if (strs) {
        if (typeof strs === "object") {
          for (const s of strs) {
            console.log(s);
          }
        } else if (typeof strs === "string") {
          console.log(strs);
        }
      }
    }
    ```

    We wrapped the entire body of the function in a truthy check, but this has a subtle downside: we may no longer be handling the empty string case correctly.

    TypeScript doesn’t hurt us here at all, but this behavior is worth noting if you’re less familiar with JavaScript. TypeScript can often help you catch bugs early on, but if you choose to do *nothing* with a value, there’s only so much that it can do without being overly prescriptive. If you want, you can make sure you handle situations like these with a linter.

    One last word on narrowing by truthiness is that Boolean negations with `!` filter out from negated branches.

    ``` ts
    function multiplyAll(
      values: number[] | undefined,
      factor: number
    ): number[] | undefined {
      if (!values) {
        return values;
      } else {
        return values.map((x) => x * factor);
      }
    }
    ```
- name: 'Narrowing: Using type predicates'
  id: 2/narrowing#using-type-predicates
  summary: We’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code
  belongs_to: Narrowing
  description: |-
    ## Using type predicates

    We’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code.

    To define a user-defined type guard, we simply need to define a function whose return type is a *type predicate*:

    ``` ts
    function isFish(pet: Fish | Bird): pet is Fish {
      return (pet as Fish).swim !== undefined;
    }
    ```

    `pet is Fish` is our type predicate in this example. A predicate takes the form `parameterName is Type`, where `parameterName` must be the name of a parameter from the current function signature.

    Any time `isFish` is called with some variable, TypeScript will *narrow* that variable to that specific type if the original type is compatible.

    ``` ts
    // Both calls to 'swim' and 'fly' are now okay.
    let pet = getSmallPet();
     
    if (isFish(pet)) {
      pet.swim();
    } else {
      pet.fly();
    }
    ```

    Notice that TypeScript not only knows that `pet` is a `Fish` in the `if` branch; it also knows that in the `else` branch, you *don’t* have a `Fish`, so you must have a `Bird`.

    You may use the type guard `isFish` to filter an array of `Fish | Bird` and obtain an array of `Fish`:

    ``` ts
    const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];
    const underWater1: Fish[] = zoo.filter(isFish);
    // or, equivalently
    const underWater2: Fish[] = zoo.filter(isFish) as Fish[];
     
    // The predicate may need repeating for more complex examples
    const underWater3: Fish[] = zoo.filter((pet): pet is Fish => {
      if (pet.name === "sharkey") return false;
      return isFish(pet);
    });
    ```

    In addition, classes can [use `this is Type`](classes#this-based-type-guards) to narrow their type.
- name: newLine
  id: tsconfig#newLine-config
  summary: null
  belongs_to: TSConfig Reference
  description: |-
    ### New Line - `newLine`

    Specify the end of line sequence to be used when emitting files: ‘CRLF’ (dos) or ‘LF’ (unix).

    - Default:

      `lf`

    - Allowed:
      - `crlf`

      - `lf`

    - Released:

      [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)
- name: newLine
  id: tsconfig/index#newLine-config
  summary: null
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### New Line - `newLine`

    Specify the end of line sequence to be used when emitting files: ‘CRLF’ (dos) or ‘LF’ (unix).

    - Default:

      `lf`

    - Allowed:
      - `crlf`

      - `lf`

    - Released:

      [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)
- name: Nightly Builds
  id: nightly-builds
  summary: A nightly build from the TypeScript’s main branch is published by midnight PST to npm
  description: "# Nightly Builds\n\nA nightly build from the [TypeScript’s `main`](https://github.com/Microsoft/TypeScript/tree/main) branch is published by midnight PST to npm. Here is how you can get it and use it with your tools.\n\n## Using npm\n\n``` shell\nnpm install -D typescript@next\n```\n\n## Updating your IDE to use the nightly builds\n\nYou can also update your editor/IDE to use the nightly drop. You will typically need to install the package through npm. The rest of this section mostly assumes `typescript@next` is already installed.\n\n### Visual Studio Code\n\nThe VS Code website [has documentation on selecting a workspace version of TypeScript](https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions). After installing a nightly version of TypeScript in your workspace, you can follow directions there, or simply update your workspace settings in the JSON view. A direct way to do this is to open or create your workspace’s `.vscode/settings.json` and add the following property:\n\n``` json\n\"typescript.tsdk\": \"<path to your folder>/node_modules/typescript/lib\"\n```\n\nAlternatively, if you simply want to run the nightly editing experience for JavaScript and TypeScript in Visual Studio Code without changing your workspace version, you can run the [JavaScript and TypeScript Nightly Extension](https://marketplace.visualstudio.com/items?itemName%253Dms-vscode.vscode-typescript-next)\n\n### Sublime Text\n\nUpdate the `Settings - User` file with the following:\n\n``` json\n\"typescript_tsdk\": \"<path to your folder>/node_modules/typescript/lib\"\n```\n\nMore information is available at the [TypeScript Plugin for Sublime Text installation documentation](https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation).\n\n### Visual Studio 2013 and 2015\n\n> Note: Most changes do not require you to install a new version of the VS TypeScript plugin.\n\nThe nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well.\n\n1.  Download the [VSDevMode.ps1](https://github.com/Microsoft/TypeScript/blob/main/scripts/VSDevMode.ps1) script.\n\n    > Also see our wiki page on [using a custom language service file](https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file).\n\n2.  From a PowerShell command window, run:\n\nFor VS 2015:\n\n``` typescript\nVSDevMode.ps1 14 -tsScript <path to your folder>/node_modules/typescript/lib\n```\n\nFor VS 2013:\n\n``` typescript\nVSDevMode.ps1 12 -tsScript <path to your folder>/node_modules/typescript/lib\n```\n\n### IntelliJ IDEA (Mac)\n\nGo to `Preferences` \\> `Languages & Frameworks` \\> `TypeScript`:\n\n> TypeScript Version: If you installed with npm: `/usr/local/lib/node_modules/typescript/lib`\n\n### IntelliJ IDEA (Windows)\n\nGo to `File` \\> `Settings` \\> `Languages & Frameworks` \\> `TypeScript`:\n\n> TypeScript Version: If you installed with npm: `C:\\Users\\USERNAME\\AppData\\Roaming\\npm\\node_modules\\typescript\\lib`\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/nightly-builds.html](https://www.typescriptlang.org/docs/handbook/nightly-builds.html)"
- name: 'Nightly Builds: Updating your IDE to use the nightly builds'
  id: nightly-builds#updating-your-ide-to-use-the-nightly-builds
  summary: You can also update your editor/IDE to use the nightly drop
  belongs_to: Nightly Builds
  description: "## Updating your IDE to use the nightly builds\n\nYou can also update your editor/IDE to use the nightly drop. You will typically need to install the package through npm. The rest of this section mostly assumes `typescript@next` is already installed.\n\n### Visual Studio Code\n\nThe VS Code website [has documentation on selecting a workspace version of TypeScript](https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions). After installing a nightly version of TypeScript in your workspace, you can follow directions there, or simply update your workspace settings in the JSON view. A direct way to do this is to open or create your workspace’s `.vscode/settings.json` and add the following property:\n\n``` json\n\"typescript.tsdk\": \"<path to your folder>/node_modules/typescript/lib\"\n```\n\nAlternatively, if you simply want to run the nightly editing experience for JavaScript and TypeScript in Visual Studio Code without changing your workspace version, you can run the [JavaScript and TypeScript Nightly Extension](https://marketplace.visualstudio.com/items?itemName%253Dms-vscode.vscode-typescript-next)\n\n### Sublime Text\n\nUpdate the `Settings - User` file with the following:\n\n``` json\n\"typescript_tsdk\": \"<path to your folder>/node_modules/typescript/lib\"\n```\n\nMore information is available at the [TypeScript Plugin for Sublime Text installation documentation](https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation).\n\n### Visual Studio 2013 and 2015\n\n> Note: Most changes do not require you to install a new version of the VS TypeScript plugin.\n\nThe nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well.\n\n1.  Download the [VSDevMode.ps1](https://github.com/Microsoft/TypeScript/blob/main/scripts/VSDevMode.ps1) script.\n\n    > Also see our wiki page on [using a custom language service file](https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file).\n\n2.  From a PowerShell command window, run:\n\nFor VS 2015:\n\n``` typescript\nVSDevMode.ps1 14 -tsScript <path to your folder>/node_modules/typescript/lib\n```\n\nFor VS 2013:\n\n``` typescript\nVSDevMode.ps1 12 -tsScript <path to your folder>/node_modules/typescript/lib\n```\n\n### IntelliJ IDEA (Mac)\n\nGo to `Preferences` \\> `Languages & Frameworks` \\> `TypeScript`:\n\n> TypeScript Version: If you installed with npm: `/usr/local/lib/node_modules/typescript/lib`\n\n### IntelliJ IDEA (Windows)\n\nGo to `File` \\> `Settings` \\> `Languages & Frameworks` \\> `TypeScript`:\n\n> TypeScript Version: If you installed with npm: `C:\\Users\\USERNAME\\AppData\\Roaming\\npm\\node_modules\\typescript\\lib`\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/nightly-builds.html](https://www.typescriptlang.org/docs/handbook/nightly-builds.html)"
- name: 'Nightly Builds: Using npm'
  id: nightly-builds#using-npm
  summary: null
  belongs_to: Nightly Builds
  description: |-
    ## Using npm

    ``` shell
    npm install -D typescript@next
    ```
- name: noCheck
  id: tsconfig#noCheck-config
  summary: null
  belongs_to: TSConfig Reference
  description: |-
    ### noCheck - `noCheck`

    Disable full type checking (only critical parse and emit errors will be reported).
- name: noCheck
  id: tsconfig/index#noCheck-config
  summary: null
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### noCheck - `noCheck`

    Disable full type checking (only critical parse and emit errors will be reported).
- name: noEmit
  id: tsconfig#noEmit-config
  summary: Do not emit compiler output files like JavaScript source code, source-maps or declarations
  belongs_to: TSConfig Reference
  description: |-
    ### No Emit - `noEmit`

    Do not emit compiler output files like JavaScript source code, source-maps or declarations.

    This makes room for another tool like [Babel](https://babeljs.io), or [swc](https://github.com/swc-project/swc) to handle converting the TypeScript file to a file which can run inside a JavaScript environment.

    You can then use TypeScript as a tool for providing editor integration, and as a source code type-checker.
- name: noEmit
  id: tsconfig/index#noEmit-config
  summary: Do not emit compiler output files like JavaScript source code, source-maps or declarations
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Emit - `noEmit`

    Do not emit compiler output files like JavaScript source code, source-maps or declarations.

    This makes room for another tool like [Babel](https://babeljs.io), or [swc](https://github.com/swc-project/swc) to handle converting the TypeScript file to a file which can run inside a JavaScript environment.

    You can then use TypeScript as a tool for providing editor integration, and as a source code type-checker.
- name: noEmitHelpers
  id: tsconfig/index#noEmitHelpers-config
  summary: Instead of importing helpers with importHelpers, you can provide implementations in the global scope for the helpers you use and completely turn off emitting of helper functions
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Emit Helpers - `noEmitHelpers`

    Instead of importing helpers with [`importHelpers`](#importHelpers), you can provide implementations in the global scope for the helpers you use and completely turn off emitting of helper functions.

    For example, using this `async` function in ES5 requires a `await`-like function and `generator`-like function to run:

    ``` ts
    const getAPI = async (url: string) => {
      // Get API
      return {};
    };
    ```

    Which creates quite a lot of JavaScript:

    ``` ts
    "use strict";
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (this && this.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            // Get API
            return [2 /*return*/, {}];
        });
    }); };
     
    ```

    Which can be switched out with your own globals via this flag:

    ``` ts
    "use strict";
    var getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            // Get API
            return [2 /*return*/, {}];
        });
    }); };
     
    ```

    - Related:
      - [`importHelpers`](#importHelpers)

    - Released:

      [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)
- name: noEmitHelpers
  id: tsconfig#noEmitHelpers-config
  summary: Instead of importing helpers with importHelpers, you can provide implementations in the global scope for the helpers you use and completely turn off emitting of helper functions
  belongs_to: TSConfig Reference
  description: |-
    ### No Emit Helpers - `noEmitHelpers`

    Instead of importing helpers with [`importHelpers`](#importHelpers), you can provide implementations in the global scope for the helpers you use and completely turn off emitting of helper functions.

    For example, using this `async` function in ES5 requires a `await`-like function and `generator`-like function to run:

    ``` ts
    const getAPI = async (url: string) => {
      // Get API
      return {};
    };
    ```

    Which creates quite a lot of JavaScript:

    ``` ts
    "use strict";
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (this && this.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            // Get API
            return [2 /*return*/, {}];
        });
    }); };
     
    ```

    Which can be switched out with your own globals via this flag:

    ``` ts
    "use strict";
    var getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            // Get API
            return [2 /*return*/, {}];
        });
    }); };
     
    ```

    - Related:
      - [`importHelpers`](#importHelpers)

    - Released:

      [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)
- name: noEmitOnError
  id: tsconfig#noEmitOnError-config
  summary: Do not emit compiler output files like JavaScript source code, source-maps or declarations if any errors were reported
  belongs_to: TSConfig Reference
  description: |-
    ### No Emit On Error - `noEmitOnError`

    Do not emit compiler output files like JavaScript source code, source-maps or declarations if any errors were reported.

    This defaults to `false`, making it easier to work with TypeScript in a watch-like environment where you may want to see results of changes to your code in another environment before making sure all errors are resolved.

    - Released:

      [1.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html)
- name: noEmitOnError
  id: tsconfig/index#noEmitOnError-config
  summary: Do not emit compiler output files like JavaScript source code, source-maps or declarations if any errors were reported
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Emit On Error - `noEmitOnError`

    Do not emit compiler output files like JavaScript source code, source-maps or declarations if any errors were reported.

    This defaults to `false`, making it easier to work with TypeScript in a watch-like environment where you may want to see results of changes to your code in another environment before making sure all errors are resolved.

    - Released:

      [1.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html)
- name: noErrorTruncation
  id: tsconfig/index#noErrorTruncation-config
  summary: Do not truncate error messages
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Error Truncation - `noErrorTruncation`

    Do not truncate error messages.

    With `false`, the default.

    ``` ts
    var x: {
      propertyWithAnExceedinglyLongName1: string;
      propertyWithAnExceedinglyLongName2: string;
      propertyWithAnExceedinglyLongName3: string;
      propertyWithAnExceedinglyLongName4: string;
      propertyWithAnExceedinglyLongName5: string;
      propertyWithAnExceedinglyLongName6: string;
      propertyWithAnExceedinglyLongName7: string;
      propertyWithAnExceedinglyLongName8: string;
    };
     
    // String representation of type of 'x' should be truncated in error message
    var s: string = x;
    ```

    With `true`

    ``` ts
    var x: {
      propertyWithAnExceedinglyLongName1: string;
      propertyWithAnExceedinglyLongName2: string;
      propertyWithAnExceedinglyLongName3: string;
      propertyWithAnExceedinglyLongName4: string;
      propertyWithAnExceedinglyLongName5: string;
      propertyWithAnExceedinglyLongName6: string;
      propertyWithAnExceedinglyLongName7: string;
      propertyWithAnExceedinglyLongName8: string;
    };
     
    // String representation of type of 'x' should be truncated in error message
    var s: string = x;
    ```
- name: noErrorTruncation
  id: tsconfig#noErrorTruncation-config
  summary: Do not truncate error messages
  belongs_to: TSConfig Reference
  description: |-
    ### No Error Truncation - `noErrorTruncation`

    Do not truncate error messages.

    With `false`, the default.

    ``` ts
    var x: {
      propertyWithAnExceedinglyLongName1: string;
      propertyWithAnExceedinglyLongName2: string;
      propertyWithAnExceedinglyLongName3: string;
      propertyWithAnExceedinglyLongName4: string;
      propertyWithAnExceedinglyLongName5: string;
      propertyWithAnExceedinglyLongName6: string;
      propertyWithAnExceedinglyLongName7: string;
      propertyWithAnExceedinglyLongName8: string;
    };
     
    // String representation of type of 'x' should be truncated in error message
    var s: string = x;
    ```

    With `true`

    ``` ts
    var x: {
      propertyWithAnExceedinglyLongName1: string;
      propertyWithAnExceedinglyLongName2: string;
      propertyWithAnExceedinglyLongName3: string;
      propertyWithAnExceedinglyLongName4: string;
      propertyWithAnExceedinglyLongName5: string;
      propertyWithAnExceedinglyLongName6: string;
      propertyWithAnExceedinglyLongName7: string;
      propertyWithAnExceedinglyLongName8: string;
    };
     
    // String representation of type of 'x' should be truncated in error message
    var s: string = x;
    ```
- name: noFallthroughCasesInSwitch
  id: tsconfig/index#noFallthroughCasesInSwitch-config
  summary: Report errors for fallthrough cases in switch statements
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Fallthrough Cases In Switch - `noFallthroughCasesInSwitch`

    Report errors for fallthrough cases in switch statements. Ensures that any non-empty case inside a switch statement includes either `break`, `return`, or `throw`. This means you won’t accidentally ship a case fallthrough bug.

    ``` ts
    const a: number = 6;
     
    switch (a) {
      case 0:
        console.log("even");
      case 1:
        console.log("odd");
        break;
    }
    ```

    - Released:

      [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)
- name: noFallthroughCasesInSwitch
  id: tsconfig#noFallthroughCasesInSwitch-config
  summary: Report errors for fallthrough cases in switch statements
  belongs_to: TSConfig Reference
  description: |-
    ### No Fallthrough Cases In Switch - `noFallthroughCasesInSwitch`

    Report errors for fallthrough cases in switch statements. Ensures that any non-empty case inside a switch statement includes either `break`, `return`, or `throw`. This means you won’t accidentally ship a case fallthrough bug.

    ``` ts
    const a: number = 6;
     
    switch (a) {
      case 0:
        console.log("even");
      case 1:
        console.log("odd");
        break;
    }
    ```

    - Released:

      [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)
- name: noImplicitAny
  id: tsconfig#noImplicitAny-config
  summary: In some cases where no type annotations are present, TypeScript will fall back to a type of any for a variable when it cannot infer the type
  belongs_to: TSConfig Reference
  description: |-
    ### No Implicit Any - `noImplicitAny`

    In some cases where no type annotations are present, TypeScript will fall back to a type of `any` for a variable when it cannot infer the type.

    This can cause some errors to be missed, for example:

    ``` ts
    function fn(s) {
      // No error?
      console.log(s.subtr(3));
    }
    fn(42);
    ```

    Turning on `noImplicitAny` however TypeScript will issue an error whenever it would have inferred `any`:

    ``` ts
    function fn(s) {
      console.log(s.subtr(3));
    }
    ```

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)
- name: noImplicitAny
  id: tsconfig/index#noImplicitAny-config
  summary: In some cases where no type annotations are present, TypeScript will fall back to a type of any for a variable when it cannot infer the type
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Implicit Any - `noImplicitAny`

    In some cases where no type annotations are present, TypeScript will fall back to a type of `any` for a variable when it cannot infer the type.

    This can cause some errors to be missed, for example:

    ``` ts
    function fn(s) {
      // No error?
      console.log(s.subtr(3));
    }
    fn(42);
    ```

    Turning on `noImplicitAny` however TypeScript will issue an error whenever it would have inferred `any`:

    ``` ts
    function fn(s) {
      console.log(s.subtr(3));
    }
    ```

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)
- name: noImplicitOverride
  id: tsconfig/index#noImplicitOverride-config
  summary: When working with classes which use inheritance, it’s possible for a sub-class to get “out of sync” with the functions it overloads when they are renamed in the base class
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Implicit Override - `noImplicitOverride`

    When working with classes which use inheritance, it’s possible for a sub-class to get “out of sync” with the functions it overloads when they are renamed in the base class.

    For example, imagine you are modeling a music album syncing system:

    ``` ts
    class Album {
      download() {
        // Default behavior
      }
    }
     
    class SharedAlbum extends Album {
      download() {
        // Override to get info from many sources
      }
    }
    ```

    Then when you add support for machine-learning generated playlists, you refactor the `Album` class to have a ‘setup’ function instead:

    ``` ts
    class Album {
      setup() {
        // Default behavior
      }
    }
     
    class MLAlbum extends Album {
      setup() {
        // Override to get info from algorithm
      }
    }
     
    class SharedAlbum extends Album {
      download() {
        // Override to get info from many sources
      }
    }
    ```

    In this case, TypeScript has provided no warning that `download` on `SharedAlbum` *expected* to override a function in the base class.

    Using `noImplicitOverride` you can ensure that the sub-classes never go out of sync, by ensuring that functions which override include the keyword `override`.

    The following example has `noImplicitOverride` enabled, and you can see the error received when `override` is missing:

    ``` ts
    class Album {
      setup() {}
    }
     
    class MLAlbum extends Album {
      override setup() {}
    }
     
    class SharedAlbum extends Album {
      setup() {}
    }
    ```

    - Released:

      [4.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html)
- name: noImplicitOverride
  id: tsconfig#noImplicitOverride-config
  summary: When working with classes which use inheritance, it’s possible for a sub-class to get “out of sync” with the functions it overloads when they are renamed in the base class
  belongs_to: TSConfig Reference
  description: |-
    ### No Implicit Override - `noImplicitOverride`

    When working with classes which use inheritance, it’s possible for a sub-class to get “out of sync” with the functions it overloads when they are renamed in the base class.

    For example, imagine you are modeling a music album syncing system:

    ``` ts
    class Album {
      download() {
        // Default behavior
      }
    }
     
    class SharedAlbum extends Album {
      download() {
        // Override to get info from many sources
      }
    }
    ```

    Then when you add support for machine-learning generated playlists, you refactor the `Album` class to have a ‘setup’ function instead:

    ``` ts
    class Album {
      setup() {
        // Default behavior
      }
    }
     
    class MLAlbum extends Album {
      setup() {
        // Override to get info from algorithm
      }
    }
     
    class SharedAlbum extends Album {
      download() {
        // Override to get info from many sources
      }
    }
    ```

    In this case, TypeScript has provided no warning that `download` on `SharedAlbum` *expected* to override a function in the base class.

    Using `noImplicitOverride` you can ensure that the sub-classes never go out of sync, by ensuring that functions which override include the keyword `override`.

    The following example has `noImplicitOverride` enabled, and you can see the error received when `override` is missing:

    ``` ts
    class Album {
      setup() {}
    }
     
    class MLAlbum extends Album {
      override setup() {}
    }
     
    class SharedAlbum extends Album {
      setup() {}
    }
    ```

    - Released:

      [4.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html)
- name: noImplicitReturns
  id: tsconfig/index#noImplicitReturns-config
  summary: When enabled, TypeScript will check all code paths in a function to ensure they return a value
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Implicit Returns - `noImplicitReturns`

    When enabled, TypeScript will check all code paths in a function to ensure they return a value.

    ``` ts
    function lookupHeadphonesManufacturer(color: "blue" | "black"): string {
      if (color === "blue") {
        return "beats";
      } else {
        ("bose");
      }
    }
    ```

    - Released:

      [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)
- name: noImplicitReturns
  id: tsconfig#noImplicitReturns-config
  summary: When enabled, TypeScript will check all code paths in a function to ensure they return a value
  belongs_to: TSConfig Reference
  description: |-
    ### No Implicit Returns - `noImplicitReturns`

    When enabled, TypeScript will check all code paths in a function to ensure they return a value.

    ``` ts
    function lookupHeadphonesManufacturer(color: "blue" | "black"): string {
      if (color === "blue") {
        return "beats";
      } else {
        ("bose");
      }
    }
    ```

    - Released:

      [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)
- name: noImplicitThis
  id: tsconfig/index#noImplicitThis-config
  summary: Raise error on ‘this’ expressions with an implied ‘any’ type
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Implicit This - `noImplicitThis`

    Raise error on ‘this’ expressions with an implied ‘any’ type.

    For example, the class below returns a function which tries to access `this.width` and `this.height` – but the context for `this` inside the function inside `getAreaFunction` is not the instance of the Rectangle.

    ``` ts
    class Rectangle {
      width: number;
      height: number;
     
      constructor(width: number, height: number) {
        this.width = width;
        this.height = height;
      }
     
      getAreaFunction() {
        return function () {
          return this.width * this.height;
        };
      }
    }
    ```

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: noImplicitThis
  id: tsconfig#noImplicitThis-config
  summary: Raise error on ‘this’ expressions with an implied ‘any’ type
  belongs_to: TSConfig Reference
  description: |-
    ### No Implicit This - `noImplicitThis`

    Raise error on ‘this’ expressions with an implied ‘any’ type.

    For example, the class below returns a function which tries to access `this.width` and `this.height` – but the context for `this` inside the function inside `getAreaFunction` is not the instance of the Rectangle.

    ``` ts
    class Rectangle {
      width: number;
      height: number;
     
      constructor(width: number, height: number) {
        this.width = width;
        this.height = height;
      }
     
      getAreaFunction() {
        return function () {
          return this.width * this.height;
        };
      }
    }
    ```

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: noImplicitUseStrict
  id: tsconfig#noImplicitUseStrict-config
  summary: You shouldn’t need this
  belongs_to: TSConfig Reference
  description: |-
    ### No Implicit Use Strict - `noImplicitUseStrict`

    You shouldn’t need this. By default, when emitting a module file to a non-ES6 target, TypeScript emits a `"use strict";` prologue at the top of the file. This setting disables the prologue.
- name: noImplicitUseStrict
  id: tsconfig/index#noImplicitUseStrict-config
  summary: You shouldn’t need this
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Implicit Use Strict - `noImplicitUseStrict`

    You shouldn’t need this. By default, when emitting a module file to a non-ES6 target, TypeScript emits a `"use strict";` prologue at the top of the file. This setting disables the prologue.
- name: noLib
  id: tsconfig#noLib-config
  summary: Disables the automatic inclusion of any library files
  belongs_to: TSConfig Reference
  description: |-
    ### No Lib - `noLib`

    Disables the automatic inclusion of any library files. If this option is set, `lib` is ignored.

    TypeScript *cannot* compile anything without a set of interfaces for key primitives like: `Array`, `Boolean`, `Function`, `IArguments`, `Number`, `Object`, `RegExp`, and `String`. It is expected that if you use `noLib` you will be including your own type definitions for these.

    - Related:
      - [`lib`](#lib)
- name: noLib
  id: tsconfig/index#noLib-config
  summary: Disables the automatic inclusion of any library files
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Lib - `noLib`

    Disables the automatic inclusion of any library files. If this option is set, `lib` is ignored.

    TypeScript *cannot* compile anything without a set of interfaces for key primitives like: `Array`, `Boolean`, `Function`, `IArguments`, `Number`, `Object`, `RegExp`, and `String`. It is expected that if you use `noLib` you will be including your own type definitions for these.

    - Related:
      - [`lib`](#lib)
- name: noPropertyAccessFromIndexSignature
  id: tsconfig#noPropertyAccessFromIndexSignature-config
  summary: This setting ensures consistency between accessing a field via the “dot” (obj.key) syntax, and “indexed” (obj["key"]) and the way which the property is declared in the type
  belongs_to: TSConfig Reference
  description: |-
    ### No Property Access From Index Signature - `noPropertyAccessFromIndexSignature`

    This setting ensures consistency between accessing a field via the “dot” (`obj.key`) syntax, and “indexed” (`obj["key"]`) and the way which the property is declared in the type.

    Without this flag, TypeScript will allow you to use the dot syntax to access fields which are not defined:

    ``` ts
    interface GameSettings {
      // Known up-front properties
      speed: "fast" | "medium" | "slow";
      quality: "high" | "low";
     
      // Assume anything unknown to the interface
      // is a string.
      [key: string]: string;
    }
     
    const settings = getSettings();
    settings.speed;
    settings.quality;
     
    // Unknown key accessors are allowed on
    // this object, and are `string`
    settings.username;
    ```

    Turning the flag on will raise an error because the unknown field uses dot syntax instead of indexed syntax.

    ``` ts
    const settings = getSettings();
    settings.speed;
    settings.quality;
     
    // This would need to be settings["username"];
    settings.username;
    ```

    The goal of this flag is to signal intent in your calling syntax about how certain you are this property exists.

    - Released:

      [4.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html)
- name: noPropertyAccessFromIndexSignature
  id: tsconfig/index#noPropertyAccessFromIndexSignature-config
  summary: This setting ensures consistency between accessing a field via the “dot” (obj.key) syntax, and “indexed” (obj["key"]) and the way which the property is declared in the type
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Property Access From Index Signature - `noPropertyAccessFromIndexSignature`

    This setting ensures consistency between accessing a field via the “dot” (`obj.key`) syntax, and “indexed” (`obj["key"]`) and the way which the property is declared in the type.

    Without this flag, TypeScript will allow you to use the dot syntax to access fields which are not defined:

    ``` ts
    interface GameSettings {
      // Known up-front properties
      speed: "fast" | "medium" | "slow";
      quality: "high" | "low";
     
      // Assume anything unknown to the interface
      // is a string.
      [key: string]: string;
    }
     
    const settings = getSettings();
    settings.speed;
    settings.quality;
     
    // Unknown key accessors are allowed on
    // this object, and are `string`
    settings.username;
    ```

    Turning the flag on will raise an error because the unknown field uses dot syntax instead of indexed syntax.

    ``` ts
    const settings = getSettings();
    settings.speed;
    settings.quality;
     
    // This would need to be settings["username"];
    settings.username;
    ```

    The goal of this flag is to signal intent in your calling syntax about how certain you are this property exists.

    - Released:

      [4.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html)
- name: noResolve
  id: tsconfig#noResolve-config
  summary: By default, TypeScript will examine the initial set of files for import and <reference directives and add these resolved files to your program
  belongs_to: TSConfig Reference
  description: |-
    ### No Resolve - `noResolve`

    By default, TypeScript will examine the initial set of files for `import` and `<reference` directives and add these resolved files to your program.

    If `noResolve` is set, this process doesn’t happen. However, `import` statements are still checked to see if they resolve to a valid module, so you’ll need to make sure this is satisfied by some other means.
- name: noResolve
  id: tsconfig/index#noResolve-config
  summary: By default, TypeScript will examine the initial set of files for import and <reference directives and add these resolved files to your program
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Resolve - `noResolve`

    By default, TypeScript will examine the initial set of files for `import` and `<reference` directives and add these resolved files to your program.

    If `noResolve` is set, this process doesn’t happen. However, `import` statements are still checked to see if they resolve to a valid module, so you’ll need to make sure this is satisfied by some other means.
- name: noStrictGenericChecks
  id: tsconfig/index#noStrictGenericChecks-config
  summary: TypeScript will unify type parameters when comparing two generic functions
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Strict Generic Checks - `noStrictGenericChecks`

    TypeScript will unify type parameters when comparing two generic functions.

    ``` ts
    type A = <T, U>(x: T, y: U) => [T, U];
    type B = <S>(x: S, y: S) => [S, S];
     
    function f(a: A, b: B) {
      b = a; // Ok
      a = b; // Error
    }
    ```

    This flag can be used to remove that check.

    - Released:

      [2.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html)
- name: noStrictGenericChecks
  id: tsconfig#noStrictGenericChecks-config
  summary: TypeScript will unify type parameters when comparing two generic functions
  belongs_to: TSConfig Reference
  description: |-
    ### No Strict Generic Checks - `noStrictGenericChecks`

    TypeScript will unify type parameters when comparing two generic functions.

    ``` ts
    type A = <T, U>(x: T, y: U) => [T, U];
    type B = <S>(x: S, y: S) => [S, S];
     
    function f(a: A, b: B) {
      b = a; // Ok
      a = b; // Error
    }
    ```

    This flag can be used to remove that check.

    - Released:

      [2.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html)
- name: noUncheckedIndexedAccess
  id: tsconfig/index#noUncheckedIndexedAccess-config
  summary: TypeScript has a way to describe objects which have unknown keys but known values on an object, via index signatures
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Unchecked Indexed Access - `noUncheckedIndexedAccess`

    TypeScript has a way to describe objects which have unknown keys but known values on an object, via index signatures.

    ``` ts
    interface EnvironmentVars {
      NAME: string;
      OS: string;
     
      // Unknown properties are covered by this index signature.
      [propName: string]: string;
    }
     
    declare const env: EnvironmentVars;
     
    // Declared as existing
    const sysName = env.NAME;
    const os = env.OS;
     
    // Not declared, but because of the index
    // signature, then it is considered a string
    const nodeEnv = env.NODE_ENV;
    ```

    Turning on `noUncheckedIndexedAccess` will add `undefined` to any un-declared field in the type.

    ``` ts
    declare const env: EnvironmentVars;
     
    // Declared as existing
    const sysName = env.NAME;
    const os = env.OS;
     
    // Not declared, but because of the index
    // signature, then it is considered a string
    const nodeEnv = env.NODE_ENV;
    ```

    - Released:

      [4.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html)
- name: noUncheckedIndexedAccess
  id: tsconfig#noUncheckedIndexedAccess-config
  summary: TypeScript has a way to describe objects which have unknown keys but known values on an object, via index signatures
  belongs_to: TSConfig Reference
  description: |-
    ### No Unchecked Indexed Access - `noUncheckedIndexedAccess`

    TypeScript has a way to describe objects which have unknown keys but known values on an object, via index signatures.

    ``` ts
    interface EnvironmentVars {
      NAME: string;
      OS: string;
     
      // Unknown properties are covered by this index signature.
      [propName: string]: string;
    }
     
    declare const env: EnvironmentVars;
     
    // Declared as existing
    const sysName = env.NAME;
    const os = env.OS;
     
    // Not declared, but because of the index
    // signature, then it is considered a string
    const nodeEnv = env.NODE_ENV;
    ```

    Turning on `noUncheckedIndexedAccess` will add `undefined` to any un-declared field in the type.

    ``` ts
    declare const env: EnvironmentVars;
     
    // Declared as existing
    const sysName = env.NAME;
    const os = env.OS;
     
    // Not declared, but because of the index
    // signature, then it is considered a string
    const nodeEnv = env.NODE_ENV;
    ```

    - Released:

      [4.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html)
- name: noUnusedLocals
  id: tsconfig#noUnusedLocals-config
  summary: Report errors on unused local variables
  belongs_to: TSConfig Reference
  description: |-
    ### No Unused Locals - `noUnusedLocals`

    Report errors on unused local variables.

    ``` ts
    const createKeyboard = (modelID: number) => {
      const defaultModelID = 23;
      return { type: "keyboard", modelID };
    };
    ```

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: noUnusedLocals
  id: tsconfig/index#noUnusedLocals-config
  summary: Report errors on unused local variables
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Unused Locals - `noUnusedLocals`

    Report errors on unused local variables.

    ``` ts
    const createKeyboard = (modelID: number) => {
      const defaultModelID = 23;
      return { type: "keyboard", modelID };
    };
    ```

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: noUnusedParameters
  id: tsconfig/index#noUnusedParameters-config
  summary: Report errors on unused parameters in functions
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### No Unused Parameters - `noUnusedParameters`

    Report errors on unused parameters in functions.

    ``` ts
    const createDefaultKeyboard = (modelID: number) => {
      const defaultModelID = 23;
      return { type: "keyboard", modelID: defaultModelID };
    };
    ```

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: noUnusedParameters
  id: tsconfig#noUnusedParameters-config
  summary: Report errors on unused parameters in functions
  belongs_to: TSConfig Reference
  description: |-
    ### No Unused Parameters - `noUnusedParameters`

    Report errors on unused parameters in functions.

    ``` ts
    const createDefaultKeyboard = (modelID: number) => {
      const defaultModelID = 23;
      return { type: "keyboard", modelID: defaultModelID };
    };
    ```

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: Object Types
  id: 2/objects
  summary: In JavaScript, the fundamental way that we group and pass around data is through objects
  description: "# Object Types\n\nIn JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through *object types*.\n\nAs we’ve seen, they can be anonymous:\n\n``` ts\nfunction greet(person: { name: string; age: number }) {\n  return \"Hello \" + person.name;\n}\n```\n\nor they can be named by using either an interface:\n\n``` ts\ninterface Person {\n  name: string;\n  age: number;\n}\n \nfunction greet(person: Person) {\n  return \"Hello \" + person.name;\n}\n```\n\nor a type alias:\n\n``` ts\ntype Person = {\n  name: string;\n  age: number;\n};\n \nfunction greet(person: Person) {\n  return \"Hello \" + person.name;\n}\n```\n\nIn all three examples above, we’ve written functions that take objects that contain the property `name` (which must be a `string`) and `age` (which must be a `number`).\n\n## Quick Reference\n\nWe have cheat-sheets available for both [`type` and `interface`](https://www.typescriptlang.org/cheatsheets), if you want a quick look at the important every-day syntax at a glance.\n\n## Property Modifiers\n\nEach property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to.\n\n### Optional Properties\n\nMuch of the time, we’ll find ourselves dealing with objects that *might* have a property set. In those cases, we can mark those properties as *optional* by adding a question mark (`?`) to the end of their names.\n\n``` ts\ninterface PaintOptions {\n  shape: Shape;\n  xPos?: number;\n  yPos?: number;\n}\n \nfunction paintShape(opts: PaintOptions) {\n  // ...\n}\n \nconst shape = getShape();\npaintShape({ shape });\npaintShape({ shape, xPos: 100 });\npaintShape({ shape, yPos: 100 });\npaintShape({ shape, xPos: 100, yPos: 100 });\n```\n\nIn this example, both `xPos` and `yPos` are considered optional. We can choose to provide either of them, so every call above to `paintShape` is valid. All optionality really says is that if the property *is* set, it better have a specific type.\n\nWe can also read from those properties - but when we do under [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks), TypeScript will tell us they’re potentially `undefined`.\n\n``` ts\nfunction paintShape(opts: PaintOptions) {\n  let xPos = opts.xPos;\n  let yPos = opts.yPos;\n  // ...\n}\n```\n\nIn JavaScript, even if the property has never been set, we can still access it - it’s just going to give us the value `undefined`. We can just handle `undefined` specially by checking for it.\n\n``` ts\nfunction paintShape(opts: PaintOptions) {\n  let xPos = opts.xPos === undefined ? 0 : opts.xPos;\n  let yPos = opts.yPos === undefined ? 0 : opts.yPos;\n  // ...\n}\n```\n\nNote that this pattern of setting defaults for unspecified values is so common that JavaScript has syntax to support it.\n\n``` ts\nfunction paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {\n  console.log(\"x coordinate at\", xPos);\n  console.log(\"y coordinate at\", yPos);\n  // ...\n}\n```\n\nHere we used [a destructuring pattern](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) for `paintShape`’s parameter, and provided [default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values) for `xPos` and `yPos`. Now `xPos` and `yPos` are both definitely present within the body of `paintShape`, but optional for any callers to `paintShape`.\n\n> Note that there is currently no way to place type annotations within destructuring patterns. This is because the following syntax already means something different in JavaScript.\n>\n> ``` ts\n> function draw({ shape: Shape, xPos: number = 100 /*...*/ }) {\n>   render(shape);\n>   render(xPos);\n> }\n> ```\n>\n> In an object destructuring pattern, `shape: Shape` means “grab the property `shape` and redefine it locally as a variable named `Shape`.” Likewise `xPos: number` creates a variable named `number` whose value is based on the parameter’s `xPos`.\n\n### `readonly` Properties\n\nProperties can also be marked as `readonly` for TypeScript. While it won’t change any behavior at runtime, a property marked as `readonly` can’t be written to during type-checking.\n\n``` ts\ninterface SomeType {\n  readonly prop: string;\n}\n \nfunction doSomething(obj: SomeType) {\n  // We can read from 'obj.prop'.\n  console.log(`prop has the value '${obj.prop}'.`);\n \n  // But we can't re-assign it.\n  obj.prop = \"hello\";\n}\n```\n\nUsing the `readonly` modifier doesn’t necessarily imply that a value is totally immutable - or in other words, that its internal contents can’t be changed. It just means the property itself can’t be re-written to.\n\n``` ts\ninterface Home {\n  readonly resident: { name: string; age: number };\n}\n \nfunction visitForBirthday(home: Home) {\n  // We can read and update properties from 'home.resident'.\n  console.log(`Happy birthday ${home.resident.name}!`);\n  home.resident.age++;\n}\n \nfunction evict(home: Home) {\n  // But we can't write to the 'resident' property itself on a 'Home'.\n  home.resident = {\n    name: \"Victor the Evictor\",\n    age: 42,\n  };\n}\n```\n\nIt’s important to manage expectations of what `readonly` implies. It’s useful to signal intent during development time for TypeScript on how an object should be used. TypeScript doesn’t factor in whether properties on two types are `readonly` when checking whether those types are compatible, so `readonly` properties can also change via aliasing.\n\n``` ts\ninterface Person {\n  name: string;\n  age: number;\n}\n \ninterface ReadonlyPerson {\n  readonly name: string;\n  readonly age: number;\n}\n \nlet writablePerson: Person = {\n  name: \"Person McPersonface\",\n  age: 42,\n};\n \n// works\nlet readonlyPerson: ReadonlyPerson = writablePerson;\n \nconsole.log(readonlyPerson.age); // prints '42'\nwritablePerson.age++;\nconsole.log(readonlyPerson.age); // prints '43'\n```\n\nUsing [mapping modifiers](mapped-types#mapping-modifiers), you can remove `readonly` attributes.\n\n### Index Signatures\n\nSometimes you don’t know all the names of a type’s properties ahead of time, but you do know the shape of the values.\n\nIn those cases you can use an index signature to describe the types of possible values, for example:\n\n``` ts\ninterface StringArray {\n  [index: number]: string;\n}\n \nconst myArray: StringArray = getStringArray();\nconst secondItem = myArray[1];\n```\n\nAbove, we have a `StringArray` interface which has an index signature. This index signature states that when a `StringArray` is indexed with a `number`, it will return a `string`.\n\nOnly some types are allowed for index signature properties: `string`, `number`, `symbol`, template string patterns, and union types consisting only of these.\n\nIt is possible to support multiple types of indexers...\n\nIt is possible to support multiple types of indexers. Note that when using both \\`number\\` and \\`string\\` indexers, the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a `number`, JavaScript will actually convert that to a `string` before indexing into an object. That means that indexing with `100` (a `number`) is the same thing as indexing with `\"100\"` (a `string`), so the two need to be consistent.\n\n``` ts\ninterface Animal {\n  name: string;\n}\n \ninterface Dog extends Animal {\n  breed: string;\n}\n \n// Error: indexing with a numeric string might get you a completely separate type of Animal!\ninterface NotOkay {\n  [x: number]: Animal;\n  [x: string]: Dog;\n}\n```\n\nWhile string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. This is because a string index declares that `obj.property` is also available as `obj[\"property\"]`. In the following example, `name`’s type does not match the string index’s type, and the type checker gives an error:\n\n``` ts\ninterface NumberDictionary {\n  [index: string]: number;\n \n  length: number; // ok\n  name: string;\n}\n```\n\nHowever, properties of different types are acceptable if the index signature is a union of the property types:\n\n``` ts\ninterface NumberOrStringDictionary {\n  [index: string]: number | string;\n  length: number; // ok, length is a number\n  name: string; // ok, name is a string\n}\n```\n\nFinally, you can make index signatures `readonly` in order to prevent assignment to their indices:\n\n``` ts\ninterface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\n \nlet myArray: ReadonlyStringArray = getReadOnlyStringArray();\nmyArray[2] = \"Mallory\";\n```\n\nYou can’t set `myArray[2]` because the index signature is `readonly`.\n\n## Excess Property Checks\n\nWhere and how an object is assigned a type can make a difference in the type system. One of the key examples of this is in excess property checking, which validates the object more thoroughly when it is created and assigned to an object type during creation.\n\n``` ts\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n \nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  return {\n    color: config.color || \"red\",\n    area: config.width ? config.width * config.width : 20,\n  };\n}\n \nlet mySquare = createSquare({ colour: \"red\", width: 100 });\n```\n\nNotice the given argument to `createSquare` is spelled *`colour`* instead of `color`. In plain JavaScript, this sort of thing fails silently.\n\nYou could argue that this program is correctly typed, since the `width` properties are compatible, there’s no `color` property present, and the extra `colour` property is insignificant.\n\nHowever, TypeScript takes the stance that there’s probably a bug in this code. Object literals get special treatment and undergo *excess property checking* when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the “target type” doesn’t have, you’ll get an error:\n\n``` ts\nlet mySquare = createSquare({ colour: \"red\", width: 100 });\n```\n\nGetting around these checks is actually really simple. The easiest method is to just use a type assertion:\n\n``` ts\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);\n```\n\nHowever, a better approach might be to add a string index signature if you’re sure that the object can have some extra properties that are used in some special way. If `SquareConfig` can have `color` and `width` properties with the above types, but could *also* have any number of other properties, then we could define it like so:\n\n``` ts\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n  [propName: string]: any;\n}\n```\n\nHere we’re saying that `SquareConfig` can have any number of properties, and as long as they aren’t `color` or `width`, their types don’t matter.\n\nOne final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since assigning `squareOptions` won’t undergo excess property checks, the compiler won’t give you an error:\n\n``` ts\nlet squareOptions = { colour: \"red\", width: 100 };\nlet mySquare = createSquare(squareOptions);\n```\n\nThe above workaround will work as long as you have a common property between `squareOptions` and `SquareConfig`. In this example, it was the property `width`. It will however, fail if the variable does not have any common object property. For example:\n\n``` ts\nlet squareOptions = { colour: \"red\" };\nlet mySquare = createSquare(squareOptions);\n```\n\nKeep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs.\n\nThat means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it’s okay to pass an object with both a `color` or `colour` property to `createSquare`, you should fix up the definition of `SquareConfig` to reflect that.\n\n## Extending Types\n\nIt’s pretty common to have types that might be more specific versions of other types. For example, we might have a `BasicAddress` type that describes the fields necessary for sending letters and packages in the U.S.\n\n``` ts\ninterface BasicAddress {\n  name?: string;\n  street: string;\n  city: string;\n  country: string;\n  postalCode: string;\n}\n```\n\nIn some situations that’s enough, but addresses often have a unit number associated with them if the building at an address has multiple units. We can then describe an `AddressWithUnit`.\n\n``` ts\ninterface AddressWithUnit {\n  name?: string;\n  unit: string;\n  street: string;\n  city: string;\n  country: string;\n  postalCode: string;\n}\n```\n\nThis does the job, but the downside here is that we had to repeat all the other fields from `BasicAddress` when our changes were purely additive. Instead, we can extend the original `BasicAddress` type and just add the new fields that are unique to `AddressWithUnit`.\n\n``` ts\ninterface BasicAddress {\n  name?: string;\n  street: string;\n  city: string;\n  country: string;\n  postalCode: string;\n}\n \ninterface AddressWithUnit extends BasicAddress {\n  unit: string;\n}\n```\n\nThe `extends` keyword on an `interface` allows us to effectively copy members from other named types, and add whatever new members we want. This can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related. For example, `AddressWithUnit` didn’t need to repeat the `street` property, and because `street` originates from `BasicAddress`, a reader will know that those two types are related in some way.\n\n`interface`s can also extend from multiple types.\n\n``` ts\ninterface Colorful {\n  color: string;\n}\n \ninterface Circle {\n  radius: number;\n}\n \ninterface ColorfulCircle extends Colorful, Circle {}\n \nconst cc: ColorfulCircle = {\n  color: \"red\",\n  radius: 42,\n};\n```\n\n## Intersection Types\n\n`interface`s allowed us to build up new types from other types by extending them. TypeScript provides another construct called *intersection types* that is mainly used to combine existing object types.\n\nAn intersection type is defined using the `&` operator.\n\n``` ts\ninterface Colorful {\n  color: string;\n}\ninterface Circle {\n  radius: number;\n}\n \ntype ColorfulCircle = Colorful & Circle;\n```\n\nHere, we’ve intersected `Colorful` and `Circle` to produce a new type that has all the members of `Colorful` *and* `Circle`.\n\n``` ts\nfunction draw(circle: Colorful & Circle) {\n  console.log(`Color was ${circle.color}`);\n  console.log(`Radius was ${circle.radius}`);\n}\n \n// okay\ndraw({ color: \"blue\", radius: 42 });\n \n// oops\ndraw({ color: \"red\", raidus: 42 });\n```\n\n## Interfaces vs. Intersections\n\nWe just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an `extends` clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principal difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type.\n\nIf interfaces are defined with the same name, TypeScript will attempt to merge them if the properties are compatible. If the properties are not compatible (i.e., they have the same property name but different types), TypeScript will raise an error.\n\nIn the case of intersection types, properties with different types will be merged automatically. When the type is used later, TypeScript will expect the property to satisfy both types simultaneously, which may produce unexpected results.\n\nFor example, the following code will throw an error because the properties are incompatible:\n\n``` ts\ninterface Person {\n  name: string;\n}\n\ninterface Person {\n  name: number;\n}\n```\n\nIn contrast, the following code will compile, but it results in a `never` type:\n\n``` ts\ninterface Person1 {\n  name: string;\n}\n \ninterface Person2 {\n  name: number;\n}\n \ntype Staff = Person1 & Person2\n \ndeclare const staffer: Staff;\nstaffer.name;\n```\n\nIn this case, Staff would require the name property to be both a string and a number, which results in property being of type `never`.\n\n## Generic Object Types\n\nLet’s imagine a `Box` type that can contain any value - `string`s, `number`s, `Giraffe`s, whatever.\n\n``` ts\ninterface Box {\n  contents: any;\n}\n```\n\nRight now, the `contents` property is typed as `any`, which works, but can lead to accidents down the line.\n\nWe could instead use `unknown`, but that would mean that in cases where we already know the type of `contents`, we’d need to do precautionary checks, or use error-prone type assertions.\n\n``` ts\ninterface Box {\n  contents: unknown;\n}\n \nlet x: Box = {\n  contents: \"hello world\",\n};\n \n// we could check 'x.contents'\nif (typeof x.contents === \"string\") {\n  console.log(x.contents.toLowerCase());\n}\n \n// or we could use a type assertion\nconsole.log((x.contents as string).toLowerCase());\n```\n\nOne type safe approach would be to instead scaffold out different `Box` types for every type of `contents`.\n\n``` ts\ninterface NumberBox {\n  contents: number;\n}\n \ninterface StringBox {\n  contents: string;\n}\n \ninterface BooleanBox {\n  contents: boolean;\n}\n```\n\nBut that means we’ll have to create different functions, or overloads of functions, to operate on these types.\n\n``` ts\nfunction setContents(box: StringBox, newContents: string): void;\nfunction setContents(box: NumberBox, newContents: number): void;\nfunction setContents(box: BooleanBox, newContents: boolean): void;\nfunction setContents(box: { contents: any }, newContents: any) {\n  box.contents = newContents;\n}\n```\n\nThat’s a lot of boilerplate. Moreover, we might later need to introduce new types and overloads. This is frustrating, since our box types and overloads are all effectively the same.\n\nInstead, we can make a *generic* `Box` type which declares a *type parameter*.\n\n``` ts\ninterface Box<Type> {\n  contents: Type;\n}\n```\n\nYou might read this as “A `Box` of `Type` is something whose `contents` have type `Type`”. Later on, when we refer to `Box`, we have to give a *type argument* in place of `Type`.\n\n``` ts\nlet box: Box<string>;\n```\n\nThink of `Box` as a template for a real type, where `Type` is a placeholder that will get replaced with some other type. When TypeScript sees `Box<string>`, it will replace every instance of `Type` in `Box<Type>` with `string`, and end up working with something like `{ contents: string }`. In other words, `Box<string>` and our earlier `StringBox` work identically.\n\n``` ts\ninterface Box<Type> {\n  contents: Type;\n}\ninterface StringBox {\n  contents: string;\n}\n \nlet boxA: Box<string> = { contents: \"hello\" };\nboxA.contents;\n \nlet boxB: StringBox = { contents: \"world\" };\nboxB.contents;\n```\n\n`Box` is reusable in that `Type` can be substituted with anything. That means that when we need a box for a new type, we don’t need to declare a new `Box` type at all (though we certainly could if we wanted to).\n\n``` ts\ninterface Box<Type> {\n  contents: Type;\n}\n \ninterface Apple {\n  // ....\n}\n \n// Same as '{ contents: Apple }'.\ntype AppleBox = Box<Apple>;\n```\n\nThis also means that we can avoid overloads entirely by instead using [generic functions](functions#generic-functions).\n\n``` ts\nfunction setContents<Type>(box: Box<Type>, newContents: Type) {\n  box.contents = newContents;\n}\n```\n\nIt is worth noting that type aliases can also be generic. We could have defined our new `Box<Type>` interface, which was:\n\n``` ts\ninterface Box<Type> {\n  contents: Type;\n}\n```\n\nby using a type alias instead:\n\n``` ts\ntype Box<Type> = {\n  contents: Type;\n};\n```\n\nSince type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types.\n\n``` ts\ntype OrNull<Type> = Type | null;\n \ntype OneOrMany<Type> = Type | Type[];\n \ntype OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;\n \ntype OneOrManyOrNullStrings = OneOrManyOrNull<string>;\n```\n\nWe’ll circle back to type aliases in just a little bit.\n\n### The `Array` Type\n\nGeneric object types are often some sort of container type that work independently of the type of elements they contain. It’s ideal for data structures to work this way so that they’re re-usable across different data types.\n\nIt turns out we’ve been working with a type just like that throughout this handbook: the `Array` type. Whenever we write out types like `number[]` or `string[]`, that’s really just a shorthand for `Array<number>` and `Array<string>`.\n\n``` ts\nfunction doSomething(value: Array<string>) {\n  // ...\n}\n \nlet myArray: string[] = [\"hello\", \"world\"];\n \n// either of these work!\ndoSomething(myArray);\ndoSomething(new Array(\"hello\", \"world\"));\n```\n\nMuch like the `Box` type above, `Array` itself is a generic type.\n\n``` ts\ninterface Array<Type> {\n  /**\n   * Gets or sets the length of the array.\n   */\n  length: number;\n \n  /**\n   * Removes the last element from an array and returns it.\n   */\n  pop(): Type | undefined;\n \n  /**\n   * Appends new elements to an array, and returns the new length of the array.\n   */\n  push(...items: Type[]): number;\n \n  // ...\n}\n```\n\nModern JavaScript also provides other data structures which are generic, like `Map<K, V>`, `Set<T>`, and `Promise<T>`. All this really means is that because of how `Map`, `Set`, and `Promise` behave, they can work with any sets of types.\n\n### The `ReadonlyArray` Type\n\nThe `ReadonlyArray` is a special type that describes arrays that shouldn’t be changed.\n\n``` ts\nfunction doStuff(values: ReadonlyArray<string>) {\n  // We can read from 'values'...\n  const copy = values.slice();\n  console.log(`The first value is ${values[0]}`);\n \n  // ...but we can't mutate 'values'.\n  values.push(\"hello!\");\n}\n```\n\nMuch like the `readonly` modifier for properties, it’s mainly a tool we can use for intent. When we see a function that returns `ReadonlyArray`s, it tells us we’re not meant to change the contents at all, and when we see a function that consumes `ReadonlyArray`s, it tells us that we can pass any array into that function without worrying that it will change its contents.\n\nUnlike `Array`, there isn’t a `ReadonlyArray` constructor that we can use.\n\n``` ts\nnew ReadonlyArray(\"red\", \"green\", \"blue\");\n```\n\nInstead, we can assign regular `Array`s to `ReadonlyArray`s.\n\n``` ts\nconst roArray: ReadonlyArray<string> = [\"red\", \"green\", \"blue\"];\n```\n\nJust as TypeScript provides a shorthand syntax for `Array<Type>` with `Type[]`, it also provides a shorthand syntax for `ReadonlyArray<Type>` with `readonly Type[]`.\n\n``` ts\nfunction doStuff(values: readonly string[]) {\n  // We can read from 'values'...\n  const copy = values.slice();\n  console.log(`The first value is ${values[0]}`);\n \n  // ...but we can't mutate 'values'.\n  values.push(\"hello!\");\n}\n```\n\nOne last thing to note is that unlike the `readonly` property modifier, assignability isn’t bidirectional between regular `Array`s and `ReadonlyArray`s.\n\n``` ts\nlet x: readonly string[] = [];\nlet y: string[] = [];\n \nx = y;\ny = x;\n```\n\n### Tuple Types\n\nA *tuple type* is another sort of `Array` type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.\n\n``` ts\ntype StringNumberPair = [string, number];\n```\n\nHere, `StringNumberPair` is a tuple type of `string` and `number`. Like `ReadonlyArray`, it has no representation at runtime, but is significant to TypeScript. To the type system, `StringNumberPair` describes arrays whose `0` index contains a `string` and whose `1` index contains a `number`.\n\n``` ts\nfunction doSomething(pair: [string, number]) {\n  const a = pair[0];\n  const b = pair[1];\n  // ...\n}\n \ndoSomething([\"hello\", 42]);\n```\n\nIf we try to index past the number of elements, we’ll get an error.\n\n``` ts\nfunction doSomething(pair: [string, number]) {\n  // ...\n \n  const c = pair[2];\n}\n```\n\nWe can also [destructure tuples](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring) using JavaScript’s array destructuring.\n\n``` ts\nfunction doSomething(stringHash: [string, number]) {\n  const [inputString, hash] = stringHash;\n \n  console.log(inputString);\n \n  console.log(hash);\n}\n```\n\n> Tuple types are useful in heavily convention-based APIs, where each element’s meaning is “obvious”. This gives us flexibility in whatever we want to name our variables when we destructure them. In the above example, we were able to name elements `0` and `1` to whatever we wanted.\n>\n> However, since not every user holds the same view of what’s obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API.\n\nOther than those length checks, simple tuple types like these are equivalent to types which are versions of `Array`s that declare properties for specific indexes, and that declare `length` with a numeric literal type.\n\n``` ts\ninterface StringNumberPair {\n  // specialized properties\n  length: 2;\n  0: string;\n  1: number;\n \n  // Other 'Array<string | number>' members...\n  slice(start?: number, end?: number): Array<string | number>;\n}\n```\n\nAnother thing you may be interested in is that tuples can have optional properties by writing out a question mark (`?` after an element’s type). Optional tuple elements can only come at the end, and also affect the type of `length`.\n\n``` ts\ntype Either2dOr3d = [number, number, number?];\n \nfunction setCoordinate(coord: Either2dOr3d) {\n  const [x, y, z] = coord;\n \n  console.log(`Provided coordinates had ${coord.length} dimensions`);\n}\n```\n\nTuples can also have rest elements, which have to be an array/tuple type.\n\n``` ts\ntype StringNumberBooleans = [string, number, ...boolean[]];\ntype StringBooleansNumber = [string, ...boolean[], number];\ntype BooleansStringNumber = [...boolean[], string, number];\n```\n\n- `StringNumberBooleans` describes a tuple whose first two elements are `string` and `number` respectively, but which may have any number of `boolean`s following.\n- `StringBooleansNumber` describes a tuple whose first element is `string` and then any number of `boolean`s and ending with a `number`.\n- `BooleansStringNumber` describes a tuple whose starting elements are any number of `boolean`s and ending with a `string` then a `number`.\n\nA tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions.\n\n``` ts\nconst a: StringNumberBooleans = [\"hello\", 1];\nconst b: StringNumberBooleans = [\"beautiful\", 2, true];\nconst c: StringNumberBooleans = [\"world\", 3, true, false, true, false, true];\n```\n\nWhy might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in [rest parameters and arguments](functions#rest-parameters-and-arguments), so that the following:\n\n``` ts\nfunction readButtonInput(...args: [string, number, ...boolean[]]) {\n  const [name, version, ...input] = args;\n  // ...\n}\n```\n\nis basically equivalent to:\n\n``` ts\nfunction readButtonInput(name: string, version: number, ...input: boolean[]) {\n  // ...\n}\n```\n\nThis is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don’t want to introduce intermediate variables.\n\n### `readonly` Tuple Types\n\nOne final note about tuple types - tuple types have `readonly` variants, and can be specified by sticking a `readonly` modifier in front of them - just like with array shorthand syntax.\n\n``` ts\nfunction doSomething(pair: readonly [string, number]) {\n  // ...\n}\n```\n\nAs you might expect, writing to any property of a `readonly` tuple isn’t allowed in TypeScript.\n\n``` ts\nfunction doSomething(pair: readonly [string, number]) {\n  pair[0] = \"hello!\";\n}\n```\n\nTuples tend to be created and left un-modified in most code, so annotating types as `readonly` tuples when possible is a good default. This is also important given that array literals with `const` assertions will be inferred with `readonly` tuple types.\n\n``` ts\nlet point = [3, 4] as const;\n \nfunction distanceFromOrigin([x, y]: [number, number]) {\n  return Math.sqrt(x ** 2 + y ** 2);\n}\n \ndistanceFromOrigin(point);\n```\n\nHere, `distanceFromOrigin` never modifies its elements, but expects a mutable tuple. Since `point`’s type was inferred as `readonly [3, 4]`, it won’t be compatible with `[number, number]` since that type can’t guarantee `point`’s elements won’t be mutated.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/objects.html](https://www.typescriptlang.org/docs/handbook/2/objects.html)"
- name: 'Object Types: Excess Property Checks'
  id: 2/objects#excess-property-checks
  summary: Where and how an object is assigned a type can make a difference in the type system
  belongs_to: Object Types
  description: |-
    ## Excess Property Checks

    Where and how an object is assigned a type can make a difference in the type system. One of the key examples of this is in excess property checking, which validates the object more thoroughly when it is created and assigned to an object type during creation.

    ``` ts
    interface SquareConfig {
      color?: string;
      width?: number;
    }
     
    function createSquare(config: SquareConfig): { color: string; area: number } {
      return {
        color: config.color || "red",
        area: config.width ? config.width * config.width : 20,
      };
    }
     
    let mySquare = createSquare({ colour: "red", width: 100 });
    ```

    Notice the given argument to `createSquare` is spelled *`colour`* instead of `color`. In plain JavaScript, this sort of thing fails silently.

    You could argue that this program is correctly typed, since the `width` properties are compatible, there’s no `color` property present, and the extra `colour` property is insignificant.

    However, TypeScript takes the stance that there’s probably a bug in this code. Object literals get special treatment and undergo *excess property checking* when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the “target type” doesn’t have, you’ll get an error:

    ``` ts
    let mySquare = createSquare({ colour: "red", width: 100 });
    ```

    Getting around these checks is actually really simple. The easiest method is to just use a type assertion:

    ``` ts
    let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
    ```

    However, a better approach might be to add a string index signature if you’re sure that the object can have some extra properties that are used in some special way. If `SquareConfig` can have `color` and `width` properties with the above types, but could *also* have any number of other properties, then we could define it like so:

    ``` ts
    interface SquareConfig {
      color?: string;
      width?: number;
      [propName: string]: any;
    }
    ```

    Here we’re saying that `SquareConfig` can have any number of properties, and as long as they aren’t `color` or `width`, their types don’t matter.

    One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since assigning `squareOptions` won’t undergo excess property checks, the compiler won’t give you an error:

    ``` ts
    let squareOptions = { colour: "red", width: 100 };
    let mySquare = createSquare(squareOptions);
    ```

    The above workaround will work as long as you have a common property between `squareOptions` and `SquareConfig`. In this example, it was the property `width`. It will however, fail if the variable does not have any common object property. For example:

    ``` ts
    let squareOptions = { colour: "red" };
    let mySquare = createSquare(squareOptions);
    ```

    Keep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs.

    That means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it’s okay to pass an object with both a `color` or `colour` property to `createSquare`, you should fix up the definition of `SquareConfig` to reflect that.
- name: 'Object Types: Extending Types'
  id: 2/objects#extending-types
  summary: It’s pretty common to have types that might be more specific versions of other types
  belongs_to: Object Types
  description: |-
    ## Extending Types

    It’s pretty common to have types that might be more specific versions of other types. For example, we might have a `BasicAddress` type that describes the fields necessary for sending letters and packages in the U.S.

    ``` ts
    interface BasicAddress {
      name?: string;
      street: string;
      city: string;
      country: string;
      postalCode: string;
    }
    ```

    In some situations that’s enough, but addresses often have a unit number associated with them if the building at an address has multiple units. We can then describe an `AddressWithUnit`.

    ``` ts
    interface AddressWithUnit {
      name?: string;
      unit: string;
      street: string;
      city: string;
      country: string;
      postalCode: string;
    }
    ```

    This does the job, but the downside here is that we had to repeat all the other fields from `BasicAddress` when our changes were purely additive. Instead, we can extend the original `BasicAddress` type and just add the new fields that are unique to `AddressWithUnit`.

    ``` ts
    interface BasicAddress {
      name?: string;
      street: string;
      city: string;
      country: string;
      postalCode: string;
    }
     
    interface AddressWithUnit extends BasicAddress {
      unit: string;
    }
    ```

    The `extends` keyword on an `interface` allows us to effectively copy members from other named types, and add whatever new members we want. This can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related. For example, `AddressWithUnit` didn’t need to repeat the `street` property, and because `street` originates from `BasicAddress`, a reader will know that those two types are related in some way.

    `interface`s can also extend from multiple types.

    ``` ts
    interface Colorful {
      color: string;
    }
     
    interface Circle {
      radius: number;
    }
     
    interface ColorfulCircle extends Colorful, Circle {}
     
    const cc: ColorfulCircle = {
      color: "red",
      radius: 42,
    };
    ```
- name: 'Object Types: Generic Object Types'
  id: 2/objects#generic-object-types
  summary: Let’s imagine a Box type that can contain any value - strings, numbers, Giraffes, whatever
  belongs_to: Object Types
  description: |-
    ## Generic Object Types

    Let’s imagine a `Box` type that can contain any value - `string`s, `number`s, `Giraffe`s, whatever.

    ``` ts
    interface Box {
      contents: any;
    }
    ```

    Right now, the `contents` property is typed as `any`, which works, but can lead to accidents down the line.

    We could instead use `unknown`, but that would mean that in cases where we already know the type of `contents`, we’d need to do precautionary checks, or use error-prone type assertions.

    ``` ts
    interface Box {
      contents: unknown;
    }
     
    let x: Box = {
      contents: "hello world",
    };
     
    // we could check 'x.contents'
    if (typeof x.contents === "string") {
      console.log(x.contents.toLowerCase());
    }
     
    // or we could use a type assertion
    console.log((x.contents as string).toLowerCase());
    ```

    One type safe approach would be to instead scaffold out different `Box` types for every type of `contents`.

    ``` ts
    interface NumberBox {
      contents: number;
    }
     
    interface StringBox {
      contents: string;
    }
     
    interface BooleanBox {
      contents: boolean;
    }
    ```

    But that means we’ll have to create different functions, or overloads of functions, to operate on these types.

    ``` ts
    function setContents(box: StringBox, newContents: string): void;
    function setContents(box: NumberBox, newContents: number): void;
    function setContents(box: BooleanBox, newContents: boolean): void;
    function setContents(box: { contents: any }, newContents: any) {
      box.contents = newContents;
    }
    ```

    That’s a lot of boilerplate. Moreover, we might later need to introduce new types and overloads. This is frustrating, since our box types and overloads are all effectively the same.

    Instead, we can make a *generic* `Box` type which declares a *type parameter*.

    ``` ts
    interface Box<Type> {
      contents: Type;
    }
    ```

    You might read this as “A `Box` of `Type` is something whose `contents` have type `Type`”. Later on, when we refer to `Box`, we have to give a *type argument* in place of `Type`.

    ``` ts
    let box: Box<string>;
    ```

    Think of `Box` as a template for a real type, where `Type` is a placeholder that will get replaced with some other type. When TypeScript sees `Box<string>`, it will replace every instance of `Type` in `Box<Type>` with `string`, and end up working with something like `{ contents: string }`. In other words, `Box<string>` and our earlier `StringBox` work identically.

    ``` ts
    interface Box<Type> {
      contents: Type;
    }
    interface StringBox {
      contents: string;
    }
     
    let boxA: Box<string> = { contents: "hello" };
    boxA.contents;
     
    let boxB: StringBox = { contents: "world" };
    boxB.contents;
    ```

    `Box` is reusable in that `Type` can be substituted with anything. That means that when we need a box for a new type, we don’t need to declare a new `Box` type at all (though we certainly could if we wanted to).

    ``` ts
    interface Box<Type> {
      contents: Type;
    }
     
    interface Apple {
      // ....
    }
     
    // Same as '{ contents: Apple }'.
    type AppleBox = Box<Apple>;
    ```

    This also means that we can avoid overloads entirely by instead using [generic functions](functions#generic-functions).

    ``` ts
    function setContents<Type>(box: Box<Type>, newContents: Type) {
      box.contents = newContents;
    }
    ```

    It is worth noting that type aliases can also be generic. We could have defined our new `Box<Type>` interface, which was:

    ``` ts
    interface Box<Type> {
      contents: Type;
    }
    ```

    by using a type alias instead:

    ``` ts
    type Box<Type> = {
      contents: Type;
    };
    ```

    Since type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types.

    ``` ts
    type OrNull<Type> = Type | null;
     
    type OneOrMany<Type> = Type | Type[];
     
    type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;
     
    type OneOrManyOrNullStrings = OneOrManyOrNull<string>;
    ```

    We’ll circle back to type aliases in just a little bit.
- name: 'Object Types: Interfaces vs. Intersections'
  id: 2/objects#interfaces-vs-intersections
  summary: We just looked at two ways to combine types which are similar, but are actually subtly different
  belongs_to: Object Types
  description: |-
    ## Interfaces vs. Intersections

    We just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an `extends` clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principal difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type.

    If interfaces are defined with the same name, TypeScript will attempt to merge them if the properties are compatible. If the properties are not compatible (i.e., they have the same property name but different types), TypeScript will raise an error.

    In the case of intersection types, properties with different types will be merged automatically. When the type is used later, TypeScript will expect the property to satisfy both types simultaneously, which may produce unexpected results.

    For example, the following code will throw an error because the properties are incompatible:

    ``` ts
    interface Person {
      name: string;
    }

    interface Person {
      name: number;
    }
    ```

    In contrast, the following code will compile, but it results in a `never` type:

    ``` ts
    interface Person1 {
      name: string;
    }
     
    interface Person2 {
      name: number;
    }
     
    type Staff = Person1 & Person2
     
    declare const staffer: Staff;
    staffer.name;
    ```

    In this case, Staff would require the name property to be both a string and a number, which results in property being of type `never`.
- name: 'Object Types: Intersection Types'
  id: 2/objects#intersection-types
  summary: interfaces allowed us to build up new types from other types by extending them
  belongs_to: Object Types
  description: |-
    ## Intersection Types

    `interface`s allowed us to build up new types from other types by extending them. TypeScript provides another construct called *intersection types* that is mainly used to combine existing object types.

    An intersection type is defined using the `&` operator.

    ``` ts
    interface Colorful {
      color: string;
    }
    interface Circle {
      radius: number;
    }
     
    type ColorfulCircle = Colorful & Circle;
    ```

    Here, we’ve intersected `Colorful` and `Circle` to produce a new type that has all the members of `Colorful` *and* `Circle`.

    ``` ts
    function draw(circle: Colorful & Circle) {
      console.log(`Color was ${circle.color}`);
      console.log(`Radius was ${circle.radius}`);
    }
     
    // okay
    draw({ color: "blue", radius: 42 });
     
    // oops
    draw({ color: "red", raidus: 42 });
    ```
- name: 'Object Types: Property Modifiers'
  id: 2/objects#property-modifiers
  summary: 'Each property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to'
  belongs_to: Object Types
  description: |-
    ## Property Modifiers

    Each property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to.

    ### Optional Properties

    Much of the time, we’ll find ourselves dealing with objects that *might* have a property set. In those cases, we can mark those properties as *optional* by adding a question mark (`?`) to the end of their names.

    ``` ts
    interface PaintOptions {
      shape: Shape;
      xPos?: number;
      yPos?: number;
    }
     
    function paintShape(opts: PaintOptions) {
      // ...
    }
     
    const shape = getShape();
    paintShape({ shape });
    paintShape({ shape, xPos: 100 });
    paintShape({ shape, yPos: 100 });
    paintShape({ shape, xPos: 100, yPos: 100 });
    ```

    In this example, both `xPos` and `yPos` are considered optional. We can choose to provide either of them, so every call above to `paintShape` is valid. All optionality really says is that if the property *is* set, it better have a specific type.

    We can also read from those properties - but when we do under [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks), TypeScript will tell us they’re potentially `undefined`.

    ``` ts
    function paintShape(opts: PaintOptions) {
      let xPos = opts.xPos;
      let yPos = opts.yPos;
      // ...
    }
    ```

    In JavaScript, even if the property has never been set, we can still access it - it’s just going to give us the value `undefined`. We can just handle `undefined` specially by checking for it.

    ``` ts
    function paintShape(opts: PaintOptions) {
      let xPos = opts.xPos === undefined ? 0 : opts.xPos;
      let yPos = opts.yPos === undefined ? 0 : opts.yPos;
      // ...
    }
    ```

    Note that this pattern of setting defaults for unspecified values is so common that JavaScript has syntax to support it.

    ``` ts
    function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {
      console.log("x coordinate at", xPos);
      console.log("y coordinate at", yPos);
      // ...
    }
    ```

    Here we used [a destructuring pattern](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) for `paintShape`’s parameter, and provided [default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values) for `xPos` and `yPos`. Now `xPos` and `yPos` are both definitely present within the body of `paintShape`, but optional for any callers to `paintShape`.

    > Note that there is currently no way to place type annotations within destructuring patterns. This is because the following syntax already means something different in JavaScript.
    >
    > ``` ts
    > function draw({ shape: Shape, xPos: number = 100 /*...*/ }) {
    >   render(shape);
    >   render(xPos);
    > }
    > ```
    >
    > In an object destructuring pattern, `shape: Shape` means “grab the property `shape` and redefine it locally as a variable named `Shape`.” Likewise `xPos: number` creates a variable named `number` whose value is based on the parameter’s `xPos`.
- name: 'Object Types: Quick Reference'
  id: 2/objects#quick-reference
  summary: We have cheat-sheets available for both type and interface, if you want a quick look at the important every-day syntax at a glance
  belongs_to: Object Types
  description: |-
    ## Quick Reference

    We have cheat-sheets available for both [`type` and `interface`](https://www.typescriptlang.org/cheatsheets), if you want a quick look at the important every-day syntax at a glance.
- name: 'Object Types: readonly Properties'
  id: 2/objects#readonly-properties
  summary: Properties can also be marked as readonly for TypeScript
  belongs_to: Object Types
  description: |-
    ### `readonly` Properties

    Properties can also be marked as `readonly` for TypeScript. While it won’t change any behavior at runtime, a property marked as `readonly` can’t be written to during type-checking.

    ``` ts
    interface SomeType {
      readonly prop: string;
    }
     
    function doSomething(obj: SomeType) {
      // We can read from 'obj.prop'.
      console.log(`prop has the value '${obj.prop}'.`);
     
      // But we can't re-assign it.
      obj.prop = "hello";
    }
    ```

    Using the `readonly` modifier doesn’t necessarily imply that a value is totally immutable - or in other words, that its internal contents can’t be changed. It just means the property itself can’t be re-written to.

    ``` ts
    interface Home {
      readonly resident: { name: string; age: number };
    }
     
    function visitForBirthday(home: Home) {
      // We can read and update properties from 'home.resident'.
      console.log(`Happy birthday ${home.resident.name}!`);
      home.resident.age++;
    }
     
    function evict(home: Home) {
      // But we can't write to the 'resident' property itself on a 'Home'.
      home.resident = {
        name: "Victor the Evictor",
        age: 42,
      };
    }
    ```

    It’s important to manage expectations of what `readonly` implies. It’s useful to signal intent during development time for TypeScript on how an object should be used. TypeScript doesn’t factor in whether properties on two types are `readonly` when checking whether those types are compatible, so `readonly` properties can also change via aliasing.

    ``` ts
    interface Person {
      name: string;
      age: number;
    }
     
    interface ReadonlyPerson {
      readonly name: string;
      readonly age: number;
    }
     
    let writablePerson: Person = {
      name: "Person McPersonface",
      age: 42,
    };
     
    // works
    let readonlyPerson: ReadonlyPerson = writablePerson;
     
    console.log(readonlyPerson.age); // prints '42'
    writablePerson.age++;
    console.log(readonlyPerson.age); // prints '43'
    ```

    Using [mapping modifiers](mapped-types#mapping-modifiers), you can remove `readonly` attributes.

    ### Index Signatures

    Sometimes you don’t know all the names of a type’s properties ahead of time, but you do know the shape of the values.

    In those cases you can use an index signature to describe the types of possible values, for example:

    ``` ts
    interface StringArray {
      [index: number]: string;
    }
     
    const myArray: StringArray = getStringArray();
    const secondItem = myArray[1];
    ```

    Above, we have a `StringArray` interface which has an index signature. This index signature states that when a `StringArray` is indexed with a `number`, it will return a `string`.

    Only some types are allowed for index signature properties: `string`, `number`, `symbol`, template string patterns, and union types consisting only of these.

    It is possible to support multiple types of indexers...

    It is possible to support multiple types of indexers. Note that when using both \`number\` and \`string\` indexers, the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a `number`, JavaScript will actually convert that to a `string` before indexing into an object. That means that indexing with `100` (a `number`) is the same thing as indexing with `"100"` (a `string`), so the two need to be consistent.

    ``` ts
    interface Animal {
      name: string;
    }
     
    interface Dog extends Animal {
      breed: string;
    }
     
    // Error: indexing with a numeric string might get you a completely separate type of Animal!
    interface NotOkay {
      [x: number]: Animal;
      [x: string]: Dog;
    }
    ```

    While string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. This is because a string index declares that `obj.property` is also available as `obj["property"]`. In the following example, `name`’s type does not match the string index’s type, and the type checker gives an error:

    ``` ts
    interface NumberDictionary {
      [index: string]: number;
     
      length: number; // ok
      name: string;
    }
    ```

    However, properties of different types are acceptable if the index signature is a union of the property types:

    ``` ts
    interface NumberOrStringDictionary {
      [index: string]: number | string;
      length: number; // ok, length is a number
      name: string; // ok, name is a string
    }
    ```

    Finally, you can make index signatures `readonly` in order to prevent assignment to their indices:

    ``` ts
    interface ReadonlyStringArray {
      readonly [index: number]: string;
    }
     
    let myArray: ReadonlyStringArray = getReadOnlyStringArray();
    myArray[2] = "Mallory";
    ```

    You can’t set `myArray[2]` because the index signature is `readonly`.
- name: 'Object Types: readonly Tuple Types'
  id: 2/objects#readonly-tuple-types
  summary: One final note about tuple types - tuple types have readonly variants, and can be specified by sticking a readonly modifier in front of them - just like with array shorthand syntax
  belongs_to: Object Types
  description: "### `readonly` Tuple Types\n\nOne final note about tuple types - tuple types have `readonly` variants, and can be specified by sticking a `readonly` modifier in front of them - just like with array shorthand syntax.\n\n``` ts\nfunction doSomething(pair: readonly [string, number]) {\n  // ...\n}\n```\n\nAs you might expect, writing to any property of a `readonly` tuple isn’t allowed in TypeScript.\n\n``` ts\nfunction doSomething(pair: readonly [string, number]) {\n  pair[0] = \"hello!\";\n}\n```\n\nTuples tend to be created and left un-modified in most code, so annotating types as `readonly` tuples when possible is a good default. This is also important given that array literals with `const` assertions will be inferred with `readonly` tuple types.\n\n``` ts\nlet point = [3, 4] as const;\n \nfunction distanceFromOrigin([x, y]: [number, number]) {\n  return Math.sqrt(x ** 2 + y ** 2);\n}\n \ndistanceFromOrigin(point);\n```\n\nHere, `distanceFromOrigin` never modifies its elements, but expects a mutable tuple. Since `point`’s type was inferred as `readonly [3, 4]`, it won’t be compatible with `[number, number]` since that type can’t guarantee `point`’s elements won’t be mutated.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/objects.html](https://www.typescriptlang.org/docs/handbook/2/objects.html)"
- name: 'Object Types: The Array Type'
  id: 2/objects#the-array-type
  summary: Generic object types are often some sort of container type that work independently of the type of elements they contain
  belongs_to: Object Types
  description: |-
    ### The `Array` Type

    Generic object types are often some sort of container type that work independently of the type of elements they contain. It’s ideal for data structures to work this way so that they’re re-usable across different data types.

    It turns out we’ve been working with a type just like that throughout this handbook: the `Array` type. Whenever we write out types like `number[]` or `string[]`, that’s really just a shorthand for `Array<number>` and `Array<string>`.

    ``` ts
    function doSomething(value: Array<string>) {
      // ...
    }
     
    let myArray: string[] = ["hello", "world"];
     
    // either of these work!
    doSomething(myArray);
    doSomething(new Array("hello", "world"));
    ```

    Much like the `Box` type above, `Array` itself is a generic type.

    ``` ts
    interface Array<Type> {
      /**
       * Gets or sets the length of the array.
       */
      length: number;
     
      /**
       * Removes the last element from an array and returns it.
       */
      pop(): Type | undefined;
     
      /**
       * Appends new elements to an array, and returns the new length of the array.
       */
      push(...items: Type[]): number;
     
      // ...
    }
    ```

    Modern JavaScript also provides other data structures which are generic, like `Map<K, V>`, `Set<T>`, and `Promise<T>`. All this really means is that because of how `Map`, `Set`, and `Promise` behave, they can work with any sets of types.
- name: 'Object Types: The ReadonlyArray Type'
  id: 2/objects#the-readonlyarray-type
  summary: The ReadonlyArray is a special type that describes arrays that shouldn’t be changed
  belongs_to: Object Types
  description: |-
    ### The `ReadonlyArray` Type

    The `ReadonlyArray` is a special type that describes arrays that shouldn’t be changed.

    ``` ts
    function doStuff(values: ReadonlyArray<string>) {
      // We can read from 'values'...
      const copy = values.slice();
      console.log(`The first value is ${values[0]}`);
     
      // ...but we can't mutate 'values'.
      values.push("hello!");
    }
    ```

    Much like the `readonly` modifier for properties, it’s mainly a tool we can use for intent. When we see a function that returns `ReadonlyArray`s, it tells us we’re not meant to change the contents at all, and when we see a function that consumes `ReadonlyArray`s, it tells us that we can pass any array into that function without worrying that it will change its contents.

    Unlike `Array`, there isn’t a `ReadonlyArray` constructor that we can use.

    ``` ts
    new ReadonlyArray("red", "green", "blue");
    ```

    Instead, we can assign regular `Array`s to `ReadonlyArray`s.

    ``` ts
    const roArray: ReadonlyArray<string> = ["red", "green", "blue"];
    ```

    Just as TypeScript provides a shorthand syntax for `Array<Type>` with `Type[]`, it also provides a shorthand syntax for `ReadonlyArray<Type>` with `readonly Type[]`.

    ``` ts
    function doStuff(values: readonly string[]) {
      // We can read from 'values'...
      const copy = values.slice();
      console.log(`The first value is ${values[0]}`);
     
      // ...but we can't mutate 'values'.
      values.push("hello!");
    }
    ```

    One last thing to note is that unlike the `readonly` property modifier, assignability isn’t bidirectional between regular `Array`s and `ReadonlyArray`s.

    ``` ts
    let x: readonly string[] = [];
    let y: string[] = [];
     
    x = y;
    y = x;
    ```

    ### Tuple Types

    A *tuple type* is another sort of `Array` type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.

    ``` ts
    type StringNumberPair = [string, number];
    ```

    Here, `StringNumberPair` is a tuple type of `string` and `number`. Like `ReadonlyArray`, it has no representation at runtime, but is significant to TypeScript. To the type system, `StringNumberPair` describes arrays whose `0` index contains a `string` and whose `1` index contains a `number`.

    ``` ts
    function doSomething(pair: [string, number]) {
      const a = pair[0];
      const b = pair[1];
      // ...
    }
     
    doSomething(["hello", 42]);
    ```

    If we try to index past the number of elements, we’ll get an error.

    ``` ts
    function doSomething(pair: [string, number]) {
      // ...
     
      const c = pair[2];
    }
    ```

    We can also [destructure tuples](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring) using JavaScript’s array destructuring.

    ``` ts
    function doSomething(stringHash: [string, number]) {
      const [inputString, hash] = stringHash;
     
      console.log(inputString);
     
      console.log(hash);
    }
    ```

    > Tuple types are useful in heavily convention-based APIs, where each element’s meaning is “obvious”. This gives us flexibility in whatever we want to name our variables when we destructure them. In the above example, we were able to name elements `0` and `1` to whatever we wanted.
    >
    > However, since not every user holds the same view of what’s obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API.

    Other than those length checks, simple tuple types like these are equivalent to types which are versions of `Array`s that declare properties for specific indexes, and that declare `length` with a numeric literal type.

    ``` ts
    interface StringNumberPair {
      // specialized properties
      length: 2;
      0: string;
      1: number;
     
      // Other 'Array<string | number>' members...
      slice(start?: number, end?: number): Array<string | number>;
    }
    ```

    Another thing you may be interested in is that tuples can have optional properties by writing out a question mark (`?` after an element’s type). Optional tuple elements can only come at the end, and also affect the type of `length`.

    ``` ts
    type Either2dOr3d = [number, number, number?];
     
    function setCoordinate(coord: Either2dOr3d) {
      const [x, y, z] = coord;
     
      console.log(`Provided coordinates had ${coord.length} dimensions`);
    }
    ```

    Tuples can also have rest elements, which have to be an array/tuple type.

    ``` ts
    type StringNumberBooleans = [string, number, ...boolean[]];
    type StringBooleansNumber = [string, ...boolean[], number];
    type BooleansStringNumber = [...boolean[], string, number];
    ```

    - `StringNumberBooleans` describes a tuple whose first two elements are `string` and `number` respectively, but which may have any number of `boolean`s following.
    - `StringBooleansNumber` describes a tuple whose first element is `string` and then any number of `boolean`s and ending with a `number`.
    - `BooleansStringNumber` describes a tuple whose starting elements are any number of `boolean`s and ending with a `string` then a `number`.

    A tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions.

    ``` ts
    const a: StringNumberBooleans = ["hello", 1];
    const b: StringNumberBooleans = ["beautiful", 2, true];
    const c: StringNumberBooleans = ["world", 3, true, false, true, false, true];
    ```

    Why might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in [rest parameters and arguments](functions#rest-parameters-and-arguments), so that the following:

    ``` ts
    function readButtonInput(...args: [string, number, ...boolean[]]) {
      const [name, version, ...input] = args;
      // ...
    }
    ```

    is basically equivalent to:

    ``` ts
    function readButtonInput(name: string, version: number, ...input: boolean[]) {
      // ...
    }
    ```

    This is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don’t want to introduce intermediate variables.
- name: out
  id: tsconfig/index#out-config
  summary: Use outFile instead
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Out - `out`

    Use [`outFile`](#outFile) instead.

    The `out` option computes the final file location in a way that is not predictable or consistent. This option is retained for backward compatibility only and is deprecated.

    - Deprecated
    - Related:
      - [`outDir`](#outDir)

      - [`outFile`](#outFile)
- name: out
  id: tsconfig#out-config
  summary: Use outFile instead
  belongs_to: TSConfig Reference
  description: |-
    ### Out - `out`

    Use [`outFile`](#outFile) instead.

    The `out` option computes the final file location in a way that is not predictable or consistent. This option is retained for backward compatibility only and is deprecated.

    - Deprecated
    - Related:
      - [`outDir`](#outDir)

      - [`outFile`](#outFile)
- name: outDir
  id: tsconfig#outDir-config
  summary: If specified, .js (as well as .d.ts, .js.map, etc.) files will be emitted into this directory
  belongs_to: TSConfig Reference
  description: |-
    ### Out Dir - `outDir`

    If specified, `.js` (as well as `.d.ts`, `.js.map`, etc.) files will be emitted into this directory. The directory structure of the original source files is preserved; see [`rootDir`](#rootDir) if the computed root is not what you intended.

    If not specified, `.js` files will be emitted in the same directory as the `.ts` files they were generated from:

    ``` shell
    $ tsc

    example
    ├── index.js
    └── index.ts
    ```

    With a `tsconfig.json` like this:

    ``` typescript
    {
      "compilerOptions": {
        "outDir": "dist"
      }
    }
    ```

    Running `tsc` with these settings moves the files into the specified `dist` folder:

    ``` shell
    $ tsc

    example
    ├── dist
    │   └── index.js
    ├── index.ts
    └── tsconfig.json
    ```

    - Related:
      - [`out`](#out)

      - [`outFile`](#outFile)
- name: outDir
  id: tsconfig/index#outDir-config
  summary: If specified, .js (as well as .d.ts, .js.map, etc.) files will be emitted into this directory
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Out Dir - `outDir`

    If specified, `.js` (as well as `.d.ts`, `.js.map`, etc.) files will be emitted into this directory. The directory structure of the original source files is preserved; see [`rootDir`](#rootDir) if the computed root is not what you intended.

    If not specified, `.js` files will be emitted in the same directory as the `.ts` files they were generated from:

    ``` shell
    $ tsc

    example
    ├── index.js
    └── index.ts
    ```

    With a `tsconfig.json` like this:

    ``` typescript
    {
      "compilerOptions": {
        "outDir": "dist"
      }
    }
    ```

    Running `tsc` with these settings moves the files into the specified `dist` folder:

    ``` shell
    $ tsc

    example
    ├── dist
    │   └── index.js
    ├── index.ts
    └── tsconfig.json
    ```

    - Related:
      - [`out`](#out)

      - [`outFile`](#outFile)
- name: outFile
  id: tsconfig/index#outFile-config
  summary: If specified, all global (non-module) files will be concatenated into the single output file specified
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Out File - `outFile`

    If specified, all *global* (non-module) files will be concatenated into the single output file specified.

    If `module` is `system` or `amd`, all module files will also be concatenated into this file after all global content.

    Note: `outFile` cannot be used unless `module` is `None`, `System`, or `AMD`. This option *cannot* be used to bundle CommonJS or ES6 modules.

    - Related:
      - [`out`](#out)

      - [`outDir`](#outDir)

    - Released:

      [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)
- name: outFile
  id: tsconfig#outFile-config
  summary: If specified, all global (non-module) files will be concatenated into the single output file specified
  belongs_to: TSConfig Reference
  description: |-
    ### Out File - `outFile`

    If specified, all *global* (non-module) files will be concatenated into the single output file specified.

    If `module` is `system` or `amd`, all module files will also be concatenated into this file after all global content.

    Note: `outFile` cannot be used unless `module` is `None`, `System`, or `AMD`. This option *cannot* be used to bundle CommonJS or ES6 modules.

    - Related:
      - [`out`](#out)

      - [`outDir`](#outDir)

    - Released:

      [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)
- name: paths
  id: tsconfig/index#paths-config
  summary: A series of entries which re-map imports to lookup locations relative to the baseUrl if set, or to the tsconfig file itself otherwise
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Paths - `paths`

    A series of entries which re-map imports to lookup locations relative to the [`baseUrl`](#baseUrl) if set, or to the tsconfig file itself otherwise. There is a larger coverage of `paths` in [the `moduleResolution` reference page](../docs/handbook/modules/reference#paths).

    `paths` lets you declare how TypeScript should resolve an import in your `require`/`import`s.

    ``` typescript
    {
      "compilerOptions": {
        "paths": {
          "jquery": ["./vendor/jquery/dist/jquery"]
        }
      }
    }
    ```

    This would allow you to be able to write `import "jquery"`, and get all of the correct typing locally.

    ``` typescript
    {
      "compilerOptions": {
        "paths": {
            "app/*": ["./src/app/*"],
            "config/*": ["./src/app/_config/*"],
            "environment/*": ["./src/environments/*"],
            "shared/*": ["./src/app/_shared/*"],
            "helpers/*": ["./src/helpers/*"],
            "tests/*": ["./src/tests/*"]
        },
    }
    ```

    In this case, you can tell the TypeScript file resolver to support a number of custom prefixes to find code.

    Note that this feature does not change how import paths are emitted by `tsc`, so `paths` should only be used to inform TypeScript that another tool has this mapping and will use it at runtime or when bundling.
- name: paths
  id: tsconfig#paths-config
  summary: A series of entries which re-map imports to lookup locations relative to the baseUrl if set, or to the tsconfig file itself otherwise
  belongs_to: TSConfig Reference
  description: |-
    ### Paths - `paths`

    A series of entries which re-map imports to lookup locations relative to the [`baseUrl`](#baseUrl) if set, or to the tsconfig file itself otherwise. There is a larger coverage of `paths` in [the `moduleResolution` reference page](docs/handbook/modules/reference#paths).

    `paths` lets you declare how TypeScript should resolve an import in your `require`/`import`s.

    ``` typescript
    {
      "compilerOptions": {
        "paths": {
          "jquery": ["./vendor/jquery/dist/jquery"]
        }
      }
    }
    ```

    This would allow you to be able to write `import "jquery"`, and get all of the correct typing locally.

    ``` typescript
    {
      "compilerOptions": {
        "paths": {
            "app/*": ["./src/app/*"],
            "config/*": ["./src/app/_config/*"],
            "environment/*": ["./src/environments/*"],
            "shared/*": ["./src/app/_shared/*"],
            "helpers/*": ["./src/helpers/*"],
            "tests/*": ["./src/tests/*"]
        },
    }
    ```

    In this case, you can tell the TypeScript file resolver to support a number of custom prefixes to find code.

    Note that this feature does not change how import paths are emitted by `tsc`, so `paths` should only be used to inform TypeScript that another tool has this mapping and will use it at runtime or when bundling.
- name: plugins
  id: tsconfig/index#plugins-config
  summary: List of language service plugins to run inside the editor
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Plugins - `plugins`

    List of language service plugins to run inside the editor.

    Language service plugins are a way to provide additional information to a user based on existing TypeScript files. They can enhance existing messages between TypeScript and an editor, or to provide their own error messages.

    For example:

    - [ts-sql-plugin](https://github.com/xialvjun/ts-sql-plugin#readme) — Adds SQL linting with a template strings SQL builder.
    - [typescript-styled-plugin](https://github.com/Microsoft/typescript-styled-plugin) — Provides CSS linting inside template strings .
    - [typescript-eslint-language-service](https://github.com/Quramy/typescript-eslint-language-service) — Provides eslint error messaging and fix-its inside the compiler’s output.
    - [ts-graphql-plugin](https://github.com/Quramy/ts-graphql-plugin) — Provides validation and auto-completion inside GraphQL query template strings.

    VS Code has the ability for a extension to [automatically include language service plugins](https://code.visualstudio.com/api/references/contribution-points#contributes.typescriptServerPlugins), and so you may have some running in your editor without needing to define them in your `tsconfig.json`.

    ## Interop Constraints
- name: plugins
  id: tsconfig#plugins-config
  summary: List of language service plugins to run inside the editor
  belongs_to: TSConfig Reference
  description: |-
    ### Plugins - `plugins`

    List of language service plugins to run inside the editor.

    Language service plugins are a way to provide additional information to a user based on existing TypeScript files. They can enhance existing messages between TypeScript and an editor, or to provide their own error messages.

    For example:

    - [ts-sql-plugin](https://github.com/xialvjun/ts-sql-plugin#readme) — Adds SQL linting with a template strings SQL builder.
    - [typescript-styled-plugin](https://github.com/Microsoft/typescript-styled-plugin) — Provides CSS linting inside template strings .
    - [typescript-eslint-language-service](https://github.com/Quramy/typescript-eslint-language-service) — Provides eslint error messaging and fix-its inside the compiler’s output.
    - [ts-graphql-plugin](https://github.com/Quramy/ts-graphql-plugin) — Provides validation and auto-completion inside GraphQL query template strings.

    VS Code has the ability for a extension to [automatically include language service plugins](https://code.visualstudio.com/api/references/contribution-points#contributes.typescriptServerPlugins), and so you may have some running in your editor without needing to define them in your `tsconfig.json`.

    ## Interop Constraints
- name: preserveConstEnums
  id: tsconfig#preserveConstEnums-config
  summary: Do not erase const enum declarations in generated code
  belongs_to: TSConfig Reference
  description: |-
    ### Preserve Const Enums - `preserveConstEnums`

    Do not erase `const enum` declarations in generated code. `const enum`s provide a way to reduce the overall memory footprint of your application at runtime by emitting the enum value instead of a reference.

    For example with this TypeScript:

    ``` ts
    const enum Album {
      JimmyEatWorldFutures = 1,
      TubRingZooHypothesis = 2,
      DogFashionDiscoAdultery = 3,
    }
     
    const selectedAlbum = Album.JimmyEatWorldFutures;
    if (selectedAlbum === Album.JimmyEatWorldFutures) {
      console.log("That is a great choice.");
    }
    ```

    The default `const enum` behavior is to convert any `Album.Something` to the corresponding number literal, and to remove a reference to the enum from the JavaScript completely.

    ``` ts
    "use strict";
    const selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;
    if (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {
        console.log("That is a great choice.");
    }
     
    ```

    With `preserveConstEnums` set to `true`, the `enum` exists at runtime and the numbers are still emitted.

    ``` ts
    "use strict";
    var Album;
    (function (Album) {
        Album[Album["JimmyEatWorldFutures"] = 1] = "JimmyEatWorldFutures";
        Album[Album["TubRingZooHypothesis"] = 2] = "TubRingZooHypothesis";
        Album[Album["DogFashionDiscoAdultery"] = 3] = "DogFashionDiscoAdultery";
    })(Album || (Album = {}));
    const selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;
    if (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {
        console.log("That is a great choice.");
    }
     
    ```

    This essentially makes such `const enums` a source-code feature only, with no runtime traces.

    - Default:

      `true` if [`isolatedModules`](#isolatedModules); `false` otherwise.
- name: preserveConstEnums
  id: tsconfig/index#preserveConstEnums-config
  summary: Do not erase const enum declarations in generated code
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Preserve Const Enums - `preserveConstEnums`

    Do not erase `const enum` declarations in generated code. `const enum`s provide a way to reduce the overall memory footprint of your application at runtime by emitting the enum value instead of a reference.

    For example with this TypeScript:

    ``` ts
    const enum Album {
      JimmyEatWorldFutures = 1,
      TubRingZooHypothesis = 2,
      DogFashionDiscoAdultery = 3,
    }
     
    const selectedAlbum = Album.JimmyEatWorldFutures;
    if (selectedAlbum === Album.JimmyEatWorldFutures) {
      console.log("That is a great choice.");
    }
    ```

    The default `const enum` behavior is to convert any `Album.Something` to the corresponding number literal, and to remove a reference to the enum from the JavaScript completely.

    ``` ts
    "use strict";
    const selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;
    if (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {
        console.log("That is a great choice.");
    }
     
    ```

    With `preserveConstEnums` set to `true`, the `enum` exists at runtime and the numbers are still emitted.

    ``` ts
    "use strict";
    var Album;
    (function (Album) {
        Album[Album["JimmyEatWorldFutures"] = 1] = "JimmyEatWorldFutures";
        Album[Album["TubRingZooHypothesis"] = 2] = "TubRingZooHypothesis";
        Album[Album["DogFashionDiscoAdultery"] = 3] = "DogFashionDiscoAdultery";
    })(Album || (Album = {}));
    const selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;
    if (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {
        console.log("That is a great choice.");
    }
     
    ```

    This essentially makes such `const enums` a source-code feature only, with no runtime traces.

    - Default:

      `true` if [`isolatedModules`](#isolatedModules); `false` otherwise.
- name: preserveSymlinks
  id: tsconfig/index#preserveSymlinks-config
  summary: This is to reflect the same flag in Node.js; which does not resolve the real path of symlinks
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Preserve Symlinks - `preserveSymlinks`

    This is to reflect the same flag in Node.js; which does not resolve the real path of symlinks.

    This flag also exhibits the opposite behavior to Webpack’s `resolve.symlinks` option (i.e. setting TypeScript’s `preserveSymlinks` to true parallels setting Webpack’s `resolve.symlinks` to false, and vice-versa).

    With this enabled, references to modules and packages (e.g. `import`s and `/// <reference type="..." />` directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to.
- name: preserveSymlinks
  id: tsconfig#preserveSymlinks-config
  summary: This is to reflect the same flag in Node.js; which does not resolve the real path of symlinks
  belongs_to: TSConfig Reference
  description: |-
    ### Preserve Symlinks - `preserveSymlinks`

    This is to reflect the same flag in Node.js; which does not resolve the real path of symlinks.

    This flag also exhibits the opposite behavior to Webpack’s `resolve.symlinks` option (i.e. setting TypeScript’s `preserveSymlinks` to true parallels setting Webpack’s `resolve.symlinks` to false, and vice-versa).

    With this enabled, references to modules and packages (e.g. `import`s and `/// <reference type="..." />` directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to.
- name: preserveValueImports
  id: tsconfig#preserveValueImports-config
  summary: Deprecated in favor of verbatimModuleSyntax
  belongs_to: TSConfig Reference
  description: |-
    ### Preserve Value Imports - `preserveValueImports`

    Deprecated in favor of [`verbatimModuleSyntax`](#verbatimModuleSyntax).

    There are some cases where TypeScript can’t detect that you’re using an import. For example, take the following code:

    ``` ts
    import { Animal } from "./animal.js";

    eval("console.log(new Animal().isDangerous())");
    ```

    or code using ‘Compiles to HTML’ languages like Svelte or Vue. `preserveValueImports` will prevent TypeScript from removing the import, even if it appears unused.

    When combined with [`isolatedModules`](#isolatedModules): imported types *must* be marked as type-only because compilers that process single files at a time have no way of knowing whether imports are values that appear unused, or a type that must be removed in order to avoid a runtime crash.

    - Related:
      - [`isolatedModules`](#isolatedModules)

      - [`importsNotUsedAsValues`](#importsNotUsedAsValues)

      - [`verbatimModuleSyntax`](#verbatimModuleSyntax)

    - Released:

      [4.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html)
- name: preserveValueImports
  id: tsconfig/index#preserveValueImports-config
  summary: Deprecated in favor of verbatimModuleSyntax
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Preserve Value Imports - `preserveValueImports`

    Deprecated in favor of [`verbatimModuleSyntax`](#verbatimModuleSyntax).

    There are some cases where TypeScript can’t detect that you’re using an import. For example, take the following code:

    ``` ts
    import { Animal } from "./animal.js";

    eval("console.log(new Animal().isDangerous())");
    ```

    or code using ‘Compiles to HTML’ languages like Svelte or Vue. `preserveValueImports` will prevent TypeScript from removing the import, even if it appears unused.

    When combined with [`isolatedModules`](#isolatedModules): imported types *must* be marked as type-only because compilers that process single files at a time have no way of knowing whether imports are values that appear unused, or a type that must be removed in order to avoid a runtime crash.

    - Related:
      - [`isolatedModules`](#isolatedModules)

      - [`importsNotUsedAsValues`](#importsNotUsedAsValues)

      - [`verbatimModuleSyntax`](#verbatimModuleSyntax)

    - Released:

      [4.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html)
- name: preserveWatchOutput
  id: tsconfig#preserveWatchOutput-config
  summary: Whether to keep outdated console output in watch mode instead of clearing the screen every time a change happened
  belongs_to: TSConfig Reference
  description: |-
    ### Preserve Watch Output - `preserveWatchOutput`

    Whether to keep outdated console output in watch mode instead of clearing the screen every time a change happened.

    - Internal
- name: preserveWatchOutput
  id: tsconfig/index#preserveWatchOutput-config
  summary: Whether to keep outdated console output in watch mode instead of clearing the screen every time a change happened
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Preserve Watch Output - `preserveWatchOutput`

    Whether to keep outdated console output in watch mode instead of clearing the screen every time a change happened.

    - Internal
- name: pretty
  id: tsconfig#pretty-config
  summary: Stylize errors and messages using color and context, this is on by default — offers you a chance to have less terse, single colored messages from the compiler
  belongs_to: TSConfig Reference
  description: |-
    ### Pretty - `pretty`

    Stylize errors and messages using color and context, this is on by default — offers you a chance to have less terse, single colored messages from the compiler.

    - Default:

      `true`

    ## Completeness
- name: pretty
  id: tsconfig/index#pretty-config
  summary: Stylize errors and messages using color and context, this is on by default — offers you a chance to have less terse, single colored messages from the compiler
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Pretty - `pretty`

    Stylize errors and messages using color and context, this is on by default — offers you a chance to have less terse, single colored messages from the compiler.

    - Default:

      `true`

    ## Completeness
- name: Project References
  id: project-references
  summary: Project references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces
  description: "# Project References\n\nProject references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces.\n\nBy doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways.\n\nWe’re also introducing a new mode for `tsc`, the `--build` flag, that works hand in hand with project references to enable faster TypeScript builds.\n\n## An Example Project\n\nLet’s look at a fairly normal program and see how project references can help us better organize it. Imagine you have a project with two modules, `converter` and `units`, and a corresponding test file for each:\n\n``` typescript\n/\n├── src/\n│   ├── converter.ts\n│   └── units.ts\n├── test/\n│   ├── converter-tests.ts\n│   └── units-tests.ts\n└── tsconfig.json\n```\n\nThe test files import the implementation files and do some testing:\n\n``` ts\n// converter-tests.ts\nimport * as converter from \"../src/converter\";\n\nassert.areEqual(converter.celsiusToFahrenheit(0), 32);\n```\n\nPreviously, this structure was rather awkward to work with if you used a single tsconfig file:\n\n- It was possible for the implementation files to import the test files\n- It wasn’t possible to build `test` and `src` at the same time without having `src` appear in the output folder name, which you probably don’t want\n- Changing just the *internals* in the implementation files required *typechecking* the tests again, even though this wouldn’t ever cause new errors\n- Changing just the tests required typechecking the implementation again, even if nothing changed\n\nYou could use multiple tsconfig files to solve *some* of those problems, but new ones would appear:\n\n- There’s no built-in up-to-date checking, so you end up always running `tsc` twice\n- Invoking `tsc` twice incurs more startup time overhead\n- `tsc -w` can’t run on multiple config files at once\n\nProject references can solve all of these problems and more.\n\n## What is a Project Reference?\n\n`tsconfig.json` files have a new top-level property, [`references`](https://www.typescriptlang.org/tsconfig#references). It’s an array of objects that specifies projects to reference:\n\n``` js\n{\n    \"compilerOptions\": {\n        // The usual\n    },\n    \"references\": [\n        { \"path\": \"../src\" }\n    ]\n}\n```\n\nThe `path` property of each reference can point to a directory containing a `tsconfig.json` file, or to the config file itself (which may have any name).\n\nWhen you reference a project, new things happen:\n\n- Importing modules from a referenced project will instead load its *output* declaration file (`.d.ts`)\n- If the referenced project produces an [`outFile`](https://www.typescriptlang.org/tsconfig#outFile), the output file `.d.ts` file’s declarations will be visible in this project\n- Build mode (see below) will automatically build the referenced project if needed\n\nBy separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program.\n\n## `composite`\n\nReferenced projects must have the new [`composite`](https://www.typescriptlang.org/tsconfig#composite) setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the [`composite`](https://www.typescriptlang.org/tsconfig#composite) flag changes a few things:\n\n- The [`rootDir`](https://www.typescriptlang.org/tsconfig#rootDir) setting, if not explicitly set, defaults to the directory containing the `tsconfig` file\n- All implementation files must be matched by an [`include`](https://www.typescriptlang.org/tsconfig#include) pattern or listed in the [`files`](https://www.typescriptlang.org/tsconfig#files) array. If this constraint is violated, `tsc` will inform you which files weren’t specified\n- [`declaration`](https://www.typescriptlang.org/tsconfig#declaration) must be turned on\n\n## `declarationMap`\n\nWe’ve also added support for [declaration source maps](https://github.com/Microsoft/TypeScript/issues/14479). If you enable [`declarationMap`](https://www.typescriptlang.org/tsconfig#declarationMap), you’ll be able to use editor features like “Go to Definition” and Rename to transparently navigate and edit code across project boundaries in supported editors.\n\n## `prepend` with `outFile`\n\nYou can also enable prepending the output of a dependency using the `prepend` option in a reference:\n\n``` js\n   \"references\": [\n       { \"path\": \"../utils\", \"prepend\": true }\n   ]\n```\n\nPrepending a project will include the project’s output above the output of the current project. All output files (`.js`, `.d.ts`, `.js.map`, `.d.ts.map`) will be emitted correctly.\n\n`tsc` will only ever use existing files on disk to do this process, so it’s possible to create a project where a correct output file can’t be generated because some project’s output would be present more than once in the resulting file. For example:\n\n``` txt\n   A\n  ^ ^\n /   \\\nB     C\n ^   ^\n  \\ /\n   D\n```\n\nIt’s important in this situation to not prepend at each reference, because you’ll end up with two copies of `A` in the output of `D` - this can lead to unexpected results.\n\n## Caveats for Project References\n\nProject references have a few trade-offs you should be aware of.\n\nBecause dependent projects make use of `.d.ts` files that are built from their dependencies, you’ll either have to check in certain build outputs *or* build a project after cloning it before you can navigate the project in an editor without seeing spurious errors.\n\nWhen using VS Code (since TS 3.7) we have a behind-the-scenes in-memory `.d.ts` generation process that should be able to mitigate this, but it has some perf implications. For very large composite projects you might want to disable this using [disableSourceOfProjectReferenceRedirect option](https://www.typescriptlang.org/tsconfig#disableSourceOfProjectReferenceRedirect).\n\nAdditionally, to preserve compatibility with existing build workflows, `tsc` will *not* automatically build dependencies unless invoked with the `--build` switch. Let’s learn more about `--build`.\n\n## Build Mode for TypeScript\n\nA long-awaited feature is smart incremental builds for TypeScript projects. In 3.0 you can use the `--build` flag with `tsc`. This is effectively a new entry point for `tsc` that behaves more like a build orchestrator than a simple compiler.\n\nRunning `tsc --build` (`tsc -b` for short) will do the following:\n\n- Find all referenced projects\n- Detect if they are up-to-date\n- Build out-of-date projects in the correct order\n\nYou can provide `tsc -b` with multiple config file paths (e.g. `tsc -b src test`). Just like `tsc -p`, specifying the config file name itself is unnecessary if it’s named `tsconfig.json`.\n\n### `tsc -b` Commandline\n\nYou can specify any number of config files:\n\n``` shell\n > tsc -b                            # Use the tsconfig.json in the current directory\n > tsc -b src                        # Use src/tsconfig.json\n > tsc -b foo/prd.tsconfig.json bar  # Use foo/prd.tsconfig.json and bar/tsconfig.json\n```\n\nDon’t worry about ordering the files you pass on the commandline - `tsc` will re-order them if needed so that dependencies are always built first.\n\nThere are also some flags specific to `tsc -b`:\n\n- [`--verbose`](https://www.typescriptlang.org/tsconfig#verbose): Prints out verbose logging to explain what’s going on (may be combined with any other flag)\n- `--dry`: Shows what would be done but doesn’t actually build anything\n- `--clean`: Deletes the outputs of the specified projects (may be combined with `--dry`)\n- [`--force`](https://www.typescriptlang.org/tsconfig#force): Act as if all projects are out of date\n- `--watch`: Watch mode (may not be combined with any flag except [`--verbose`](https://www.typescriptlang.org/tsconfig#verbose))\n\n## Caveats\n\nNormally, `tsc` will produce outputs (`.js` and `.d.ts`) in the presence of syntax or type errors, unless [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) is on. Doing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you’d only see it *once* because a subsequent build would skip building the now up-to-date project. For this reason, `tsc -b` effectively acts as if [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) is enabled for all projects.\n\nIf you check in any build outputs (`.js`, `.d.ts`, `.d.ts.map`, etc.), you may need to run a [`--force`](https://www.typescriptlang.org/tsconfig#force) build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy.\n\n## MSBuild\n\nIf you have an msbuild project, you can enable build mode by adding\n\n``` xml\n    <TypeScriptBuildMode>true</TypeScriptBuildMode>\n```\n\nto your proj file. This will enable automatic incremental build as well as cleaning.\n\nNote that as with `tsconfig.json` / `-p`, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.\n\nSome teams have set up msbuild-based workflows wherein tsconfig files have the same *implicit* graph ordering as the managed projects they are paired with. If your solution is like this, you can continue to use `msbuild` with `tsc -p` along with project references; these are fully interoperable.\n\n## Guidance\n\n### Overall Structure\n\nWith more `tsconfig.json` files, you’ll usually want to use [Configuration file inheritance](tsconfig-json) to centralize your common compiler options. This way you can change a setting in one file rather than having to edit multiple files.\n\nAnother good practice is to have a “solution” `tsconfig.json` file that simply has [`references`](https://www.typescriptlang.org/tsconfig#references) to all of your leaf-node projects and sets [`files`](https://www.typescriptlang.org/tsconfig#files) to an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an empty [`files`](https://www.typescriptlang.org/tsconfig#files) array if you have at least one `reference` in a `tsconfig.json` file.\n\nThis presents a simple entry point; e.g. in the TypeScript repo we simply run `tsc -b src` to build all endpoints because we list all the subprojects in `src/tsconfig.json`\n\nYou can see these patterns in the TypeScript repo - see `src/tsconfig_base.json`, `src/tsconfig.json`, and `src/tsc/tsconfig.json` as key examples.\n\n### Structuring for relative modules\n\nIn general, not much is needed to transition a repo using relative modules. Simply place a `tsconfig.json` file in each subdirectory of a given parent folder, and add `reference`s to these config files to match the intended layering of the program. You will need to either set the [`outDir`](https://www.typescriptlang.org/tsconfig#outDir) to an explicit subfolder of the output folder, or set the [`rootDir`](https://www.typescriptlang.org/tsconfig#rootDir) to the common root of all project folders.\n\n### Structuring for outFiles\n\nLayout for compilations using [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) is more flexible because relative paths don’t matter as much. One thing to keep in mind is that you’ll generally want to not use `prepend` until the “last” project - this will improve build times and reduce the amount of I/O needed in any given build. The TypeScript repo itself is a good reference here - we have some “library” projects and some “endpoint” projects; “endpoint” projects are kept as small as possible and pull in only the libraries they need.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/project-references.html](https://www.typescriptlang.org/docs/handbook/project-references.html)"
- name: 'Project References: An Example Project'
  id: project-references#an-example-project
  summary: Let’s look at a fairly normal program and see how project references can help us better organize it
  belongs_to: Project References
  description: |-
    ## An Example Project

    Let’s look at a fairly normal program and see how project references can help us better organize it. Imagine you have a project with two modules, `converter` and `units`, and a corresponding test file for each:

    ``` typescript
    /
    ├── src/
    │   ├── converter.ts
    │   └── units.ts
    ├── test/
    │   ├── converter-tests.ts
    │   └── units-tests.ts
    └── tsconfig.json
    ```

    The test files import the implementation files and do some testing:

    ``` ts
    // converter-tests.ts
    import * as converter from "../src/converter";

    assert.areEqual(converter.celsiusToFahrenheit(0), 32);
    ```

    Previously, this structure was rather awkward to work with if you used a single tsconfig file:

    - It was possible for the implementation files to import the test files
    - It wasn’t possible to build `test` and `src` at the same time without having `src` appear in the output folder name, which you probably don’t want
    - Changing just the *internals* in the implementation files required *typechecking* the tests again, even though this wouldn’t ever cause new errors
    - Changing just the tests required typechecking the implementation again, even if nothing changed

    You could use multiple tsconfig files to solve *some* of those problems, but new ones would appear:

    - There’s no built-in up-to-date checking, so you end up always running `tsc` twice
    - Invoking `tsc` twice incurs more startup time overhead
    - `tsc -w` can’t run on multiple config files at once

    Project references can solve all of these problems and more.
- name: 'Project References: Build Mode for TypeScript'
  id: project-references#build-mode-for-typescript
  summary: A long-awaited feature is smart incremental builds for TypeScript projects
  belongs_to: Project References
  description: |-
    ## Build Mode for TypeScript

    A long-awaited feature is smart incremental builds for TypeScript projects. In 3.0 you can use the `--build` flag with `tsc`. This is effectively a new entry point for `tsc` that behaves more like a build orchestrator than a simple compiler.

    Running `tsc --build` (`tsc -b` for short) will do the following:

    - Find all referenced projects
    - Detect if they are up-to-date
    - Build out-of-date projects in the correct order

    You can provide `tsc -b` with multiple config file paths (e.g. `tsc -b src test`). Just like `tsc -p`, specifying the config file name itself is unnecessary if it’s named `tsconfig.json`.
- name: 'Project References: Caveats'
  id: project-references#caveats
  summary: Normally, tsc will produce outputs (.js and .d.ts) in the presence of syntax or type errors, unless noEmitOnError is on
  belongs_to: Project References
  description: |-
    ## Caveats

    Normally, `tsc` will produce outputs (`.js` and `.d.ts`) in the presence of syntax or type errors, unless [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) is on. Doing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you’d only see it *once* because a subsequent build would skip building the now up-to-date project. For this reason, `tsc -b` effectively acts as if [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) is enabled for all projects.

    If you check in any build outputs (`.js`, `.d.ts`, `.d.ts.map`, etc.), you may need to run a [`--force`](https://www.typescriptlang.org/tsconfig#force) build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy.
- name: 'Project References: Caveats for Project References'
  id: project-references#caveats-for-project-references
  summary: Project references have a few trade-offs you should be aware of
  belongs_to: Project References
  description: |-
    ## Caveats for Project References

    Project references have a few trade-offs you should be aware of.

    Because dependent projects make use of `.d.ts` files that are built from their dependencies, you’ll either have to check in certain build outputs *or* build a project after cloning it before you can navigate the project in an editor without seeing spurious errors.

    When using VS Code (since TS 3.7) we have a behind-the-scenes in-memory `.d.ts` generation process that should be able to mitigate this, but it has some perf implications. For very large composite projects you might want to disable this using [disableSourceOfProjectReferenceRedirect option](https://www.typescriptlang.org/tsconfig#disableSourceOfProjectReferenceRedirect).

    Additionally, to preserve compatibility with existing build workflows, `tsc` will *not* automatically build dependencies unless invoked with the `--build` switch. Let’s learn more about `--build`.
- name: 'Project References: composite'
  id: project-references#composite
  summary: Referenced projects must have the new composite setting enabled
  belongs_to: Project References
  description: |-
    ## `composite`

    Referenced projects must have the new [`composite`](https://www.typescriptlang.org/tsconfig#composite) setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the [`composite`](https://www.typescriptlang.org/tsconfig#composite) flag changes a few things:

    - The [`rootDir`](https://www.typescriptlang.org/tsconfig#rootDir) setting, if not explicitly set, defaults to the directory containing the `tsconfig` file
    - All implementation files must be matched by an [`include`](https://www.typescriptlang.org/tsconfig#include) pattern or listed in the [`files`](https://www.typescriptlang.org/tsconfig#files) array. If this constraint is violated, `tsc` will inform you which files weren’t specified
    - [`declaration`](https://www.typescriptlang.org/tsconfig#declaration) must be turned on
- name: 'Project References: declarationMap'
  id: project-references#declarationmap
  summary: We’ve also added support for declaration source maps
  belongs_to: Project References
  description: |-
    ## `declarationMap`

    We’ve also added support for [declaration source maps](https://github.com/Microsoft/TypeScript/issues/14479). If you enable [`declarationMap`](https://www.typescriptlang.org/tsconfig#declarationMap), you’ll be able to use editor features like “Go to Definition” and Rename to transparently navigate and edit code across project boundaries in supported editors.
- name: 'Project References: Guidance'
  id: project-references#guidance
  summary: With more tsconfig.json files, you’ll usually want to use Configuration file inheritance to centralize your common compiler options
  belongs_to: Project References
  description: "## Guidance\n\n### Overall Structure\n\nWith more `tsconfig.json` files, you’ll usually want to use [Configuration file inheritance](tsconfig-json) to centralize your common compiler options. This way you can change a setting in one file rather than having to edit multiple files.\n\nAnother good practice is to have a “solution” `tsconfig.json` file that simply has [`references`](https://www.typescriptlang.org/tsconfig#references) to all of your leaf-node projects and sets [`files`](https://www.typescriptlang.org/tsconfig#files) to an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an empty [`files`](https://www.typescriptlang.org/tsconfig#files) array if you have at least one `reference` in a `tsconfig.json` file.\n\nThis presents a simple entry point; e.g. in the TypeScript repo we simply run `tsc -b src` to build all endpoints because we list all the subprojects in `src/tsconfig.json`\n\nYou can see these patterns in the TypeScript repo - see `src/tsconfig_base.json`, `src/tsconfig.json`, and `src/tsc/tsconfig.json` as key examples.\n\n### Structuring for relative modules\n\nIn general, not much is needed to transition a repo using relative modules. Simply place a `tsconfig.json` file in each subdirectory of a given parent folder, and add `reference`s to these config files to match the intended layering of the program. You will need to either set the [`outDir`](https://www.typescriptlang.org/tsconfig#outDir) to an explicit subfolder of the output folder, or set the [`rootDir`](https://www.typescriptlang.org/tsconfig#rootDir) to the common root of all project folders.\n\n### Structuring for outFiles\n\nLayout for compilations using [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) is more flexible because relative paths don’t matter as much. One thing to keep in mind is that you’ll generally want to not use `prepend` until the “last” project - this will improve build times and reduce the amount of I/O needed in any given build. The TypeScript repo itself is a good reference here - we have some “library” projects and some “endpoint” projects; “endpoint” projects are kept as small as possible and pull in only the libraries they need.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/project-references.html](https://www.typescriptlang.org/docs/handbook/project-references.html)"
- name: 'Project References: MSBuild'
  id: project-references#msbuild
  summary: to your proj file
  belongs_to: Project References
  description: |-
    ## MSBuild

    If you have an msbuild project, you can enable build mode by adding

    ``` xml
        <TypeScriptBuildMode>true</TypeScriptBuildMode>
    ```

    to your proj file. This will enable automatic incremental build as well as cleaning.

    Note that as with `tsconfig.json` / `-p`, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.

    Some teams have set up msbuild-based workflows wherein tsconfig files have the same *implicit* graph ordering as the managed projects they are paired with. If your solution is like this, you can continue to use `msbuild` with `tsc -p` along with project references; these are fully interoperable.
- name: 'Project References: prepend with outFile'
  id: project-references#prepend-with-outfile
  summary: Prepending a project will include the project’s output above the output of the current project
  belongs_to: Project References
  description: |-
    ## `prepend` with `outFile`

    You can also enable prepending the output of a dependency using the `prepend` option in a reference:

    ``` js
       "references": [
           { "path": "../utils", "prepend": true }
       ]
    ```

    Prepending a project will include the project’s output above the output of the current project. All output files (`.js`, `.d.ts`, `.js.map`, `.d.ts.map`) will be emitted correctly.

    `tsc` will only ever use existing files on disk to do this process, so it’s possible to create a project where a correct output file can’t be generated because some project’s output would be present more than once in the resulting file. For example:

    ``` txt
       A
      ^ ^
     /   \
    B     C
     ^   ^
      \ /
       D
    ```

    It’s important in this situation to not prepend at each reference, because you’ll end up with two copies of `A` in the output of `D` - this can lead to unexpected results.
- name: 'Project References: tsc -b Commandline'
  id: project-references#tsc--b-commandline
  summary: Don’t worry about ordering the files you pass on the commandline - tsc will re-order them if needed so that dependencies are always built first
  belongs_to: Project References
  description: |-
    ### `tsc -b` Commandline

    You can specify any number of config files:

    ``` shell
     > tsc -b                            # Use the tsconfig.json in the current directory
     > tsc -b src                        # Use src/tsconfig.json
     > tsc -b foo/prd.tsconfig.json bar  # Use foo/prd.tsconfig.json and bar/tsconfig.json
    ```

    Don’t worry about ordering the files you pass on the commandline - `tsc` will re-order them if needed so that dependencies are always built first.

    There are also some flags specific to `tsc -b`:

    - [`--verbose`](https://www.typescriptlang.org/tsconfig#verbose): Prints out verbose logging to explain what’s going on (may be combined with any other flag)
    - `--dry`: Shows what would be done but doesn’t actually build anything
    - `--clean`: Deletes the outputs of the specified projects (may be combined with `--dry`)
    - [`--force`](https://www.typescriptlang.org/tsconfig#force): Act as if all projects are out of date
    - `--watch`: Watch mode (may not be combined with any flag except [`--verbose`](https://www.typescriptlang.org/tsconfig#verbose))

    &nbsp;
- name: 'Project References: What is a Project Reference?'
  id: project-references#what-is-a-project-reference
  summary: tsconfig.json files have a new top-level property, references
  belongs_to: Project References
  description: |-
    ## What is a Project Reference?

    `tsconfig.json` files have a new top-level property, [`references`](https://www.typescriptlang.org/tsconfig#references). It’s an array of objects that specifies projects to reference:

    ``` js
    {
        "compilerOptions": {
            // The usual
        },
        "references": [
            { "path": "../src" }
        ]
    }
    ```

    The `path` property of each reference can point to a directory containing a `tsconfig.json` file, or to the config file itself (which may have any name).

    When you reference a project, new things happen:

    - Importing modules from a referenced project will instead load its *output* declaration file (`.d.ts`)
    - If the referenced project produces an [`outFile`](https://www.typescriptlang.org/tsconfig#outFile), the output file `.d.ts` file’s declarations will be visible in this project
    - Build mode (see below) will automatically build the referenced project if needed

    By separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program.
- name: Publishing
  id: declaration-files/publishing
  summary: Now that you have authored a declaration file following the steps of this guide, it is time to publish it to npm
  description: "# Publishing\n\nNow that you have authored a declaration file following the steps of this guide, it is time to publish it to npm. There are two main ways you can publish your declaration files to npm:\n\n1.  bundling with your npm package\n2.  publishing to the [@types organization](https://www.npmjs.com/~types) on npm.\n\nIf your types are generated by your source code, publish the types with your source code. Both TypeScript and JavaScript projects can generate types via [`declaration`](https://www.typescriptlang.org/tsconfig#declaration).\n\nOtherwise, we recommend submitting the types to DefinitelyTyped, which will publish them to the `@types` organization on npm.\n\n## Including declarations in your npm package\n\nIf your package has a main `.js` file, you will need to indicate the main declaration file in your `package.json` file as well. Set the `types` property to point to your bundled declaration file. For example:\n\n``` json\n{\n  \"name\": \"awesome\",\n  \"author\": \"Vandelay Industries\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./lib/main.js\",\n  \"types\": \"./lib/main.d.ts\"\n}\n```\n\nNote that the `\"typings\"` field is synonymous with `types`, and could be used as well.\n\n## Dependencies\n\nAll dependencies are managed by npm. Make sure all the declaration packages you depend on are marked appropriately in the `\"dependencies\"` section in your `package.json`. For example, imagine we authored a package that used Browserify and TypeScript.\n\n``` json\n{\n  \"name\": \"browserify-typescript-extension\",\n  \"author\": \"Vandelay Industries\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./lib/main.js\",\n  \"types\": \"./lib/main.d.ts\",\n  \"dependencies\": {\n    \"browserify\": \"latest\",\n    \"@types/browserify\": \"latest\",\n    \"typescript\": \"next\"\n  }\n}\n```\n\nHere, our package depends on the `browserify` and `typescript` packages. `browserify` does not bundle its declaration files with its npm packages, so we needed to depend on `@types/browserify` for its declarations. `typescript`, on the other hand, packages its declaration files, so there was no need for any additional dependencies.\n\nOur package exposes declarations from each of those, so any user of our `browserify-typescript-extension` package needs to have these dependencies as well. For that reason, we used `\"dependencies\"` and not `\"devDependencies\"`, because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used `devDependencies`.\n\n## Red flags\n\n### `/// <reference path=\"...\" />`\n\n*Don’t* use `/// <reference path=\"...\" />` in your declaration files.\n\n``` ts\n/// <reference path=\"../typescript/lib/typescriptServices.d.ts\" />\n....\n```\n\n*Do* use `/// <reference types=\"...\" />` instead.\n\n``` ts\n/// <reference types=\"typescript\" />\n....\n```\n\nMake sure to revisit the [Consuming dependencies](library-structures#consuming-dependencies) section for more information.\n\n### Packaging dependent declarations\n\nIf your type definitions depend on another package:\n\n- *Don’t* combine it with yours, keep each in their own file.\n- *Don’t* copy the declarations in your package either.\n- *Do* depend on the npm type declaration package if it doesn’t package its declaration files.\n\n## Version selection with `typesVersions`\n\nWhen TypeScript opens a `package.json` file to figure out which files it needs to read, it first looks at a field called `typesVersions`.\n\n#### Folder redirects (using `*`)\n\nA `package.json` with a `typesVersions` field might look like this:\n\n``` json\n{\n  \"name\": \"package-name\",\n  \"version\": \"1.0.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    \">=3.1\": { \"*\": [\"ts3.1/*\"] }\n  }\n}\n```\n\nThis `package.json` tells TypeScript to first check the current version of TypeScript. If it’s 3.1 or later, TypeScript figures out the path you’ve imported relative to the package, and reads from the package’s `ts3.1` folder.\n\nThat’s what that `{ \"*\": [\"ts3.1/*\"] }` means - if you’re familiar with [path mapping](https://www.typescriptlang.org/tsconfig#paths), it works exactly like that.\n\nIn the above example, if we’re importing from `\"package-name\"`, TypeScript will try to resolve from `[...]/node_modules/package-name/ts3.1/index.d.ts` (and other relevant paths) when running in TypeScript 3.1. If we import from `package-name/foo`, we’ll try to look for `[...]/node_modules/package-name/ts3.1/foo.d.ts` and `[...]/node_modules/package-name/ts3.1/foo/index.d.ts`.\n\nWhat if we’re not running in TypeScript 3.1 in this example? Well, if none of the fields in `typesVersions` get matched, TypeScript falls back to the `types` field, so here TypeScript 3.0 and earlier will be redirected to `[...]/node_modules/package-name/index.d.ts`.\n\n#### File redirects\n\nWhen you want to only change the resolution for a single file at a time, you can tell TypeScript the file to resolve differently by passing in the exact filenames:\n\n``` json\n{\n  \"name\": \"package-name\",\n  \"version\": \"1.0.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    \"<4.0\": { \"index.d.ts\": [\"index.v3.d.ts\"] }\n  }\n}\n```\n\nOn TypeScript 4.0 and above, an import for `\"package-name\"` would resolve to `./index.d.ts` and for 3.9 and below `\"./index.v3.d.ts`.\n\nNote that redirections only affect the *external* API of a package; import resolution within a project is not affected by `typesVersions`. For example, a `d.ts` file in the previous example containing `import * as foo from \"./index\"` will still map to `index.d.ts`, not `index.v3.d.ts`, whereas another package importing `import * as foo from \"package-name\"` *will* get `index.v3.d.ts`.\n\n## Matching behavior\n\nThe way that TypeScript decides on whether a version of the compiler & language matches is by using Node’s [semver ranges](https://github.com/npm/node-semver#ranges).\n\n## Multiple fields\n\n`typesVersions` can support multiple fields where each field name is specified by the range to match on.\n\n``` typescript\n{\n  \"name\": \"package-name\",\n  \"version\": \"1.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    \">=3.2\": { \"*\": [\"ts3.2/*\"] },\n    \">=3.1\": { \"*\": [\"ts3.1/*\"] }\n  }\n}\n```\n\nSince ranges have the potential to overlap, determining which redirect applies is order-specific. That means in the above example, even though both the `>=3.2` and the `>=3.1` matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.\n\n``` typescript\n{\n  \"name\": \"package-name\",\n  \"version\": \"1.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    // NOTE: this doesn't work!\n    \">=3.1\": { \"*\": [\"ts3.1/*\"] },\n    \">=3.2\": { \"*\": [\"ts3.2/*\"] }\n  }\n}\n```\n\n## Publish to\n\nPackages under the [@types](https://www.npmjs.com/~types) organization are published automatically from [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped) using the [types-publisher tool](https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher). To get your declarations published as an @types package, please submit a pull request to [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped). You can find more details in the [contribution guidelines page](https://definitelytyped.github.io/guides/contributing.html).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html)"
- name: 'Publishing: /// <reference path="..." />'
  id: declaration-files/publishing#-reference-path-
  summary: Don’t use /// <reference path="..." /> in your declaration files
  belongs_to: Publishing
  description: |-
    ### `/// <reference path="..." />`

    *Don’t* use `/// <reference path="..." />` in your declaration files.

    ``` ts
    /// <reference path="../typescript/lib/typescriptServices.d.ts" />
    ....
    ```

    *Do* use `/// <reference types="..." />` instead.

    ``` ts
    /// <reference types="typescript" />
    ....
    ```

    Make sure to revisit the [Consuming dependencies](library-structures#consuming-dependencies) section for more information.

    ### Packaging dependent declarations

    If your type definitions depend on another package:

    - *Don’t* combine it with yours, keep each in their own file.
    - *Don’t* copy the declarations in your package either.
    - *Do* depend on the npm type declaration package if it doesn’t package its declaration files.
- name: 'Publishing: Dependencies'
  id: declaration-files/publishing#dependencies
  summary: All dependencies are managed by npm
  belongs_to: Publishing
  description: |-
    ## Dependencies

    All dependencies are managed by npm. Make sure all the declaration packages you depend on are marked appropriately in the `"dependencies"` section in your `package.json`. For example, imagine we authored a package that used Browserify and TypeScript.

    ``` json
    {
      "name": "browserify-typescript-extension",
      "author": "Vandelay Industries",
      "version": "1.0.0",
      "main": "./lib/main.js",
      "types": "./lib/main.d.ts",
      "dependencies": {
        "browserify": "latest",
        "@types/browserify": "latest",
        "typescript": "next"
      }
    }
    ```

    Here, our package depends on the `browserify` and `typescript` packages. `browserify` does not bundle its declaration files with its npm packages, so we needed to depend on `@types/browserify` for its declarations. `typescript`, on the other hand, packages its declaration files, so there was no need for any additional dependencies.

    Our package exposes declarations from each of those, so any user of our `browserify-typescript-extension` package needs to have these dependencies as well. For that reason, we used `"dependencies"` and not `"devDependencies"`, because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used `devDependencies`.
- name: 'Publishing: Including declarations in your npm package'
  id: declaration-files/publishing#including-declarations-in-your-npm-package
  summary: If your package has a main .js file, you will need to indicate the main declaration file in your package.json file as well
  belongs_to: Publishing
  description: |-
    ## Including declarations in your npm package

    If your package has a main `.js` file, you will need to indicate the main declaration file in your `package.json` file as well. Set the `types` property to point to your bundled declaration file. For example:

    ``` json
    {
      "name": "awesome",
      "author": "Vandelay Industries",
      "version": "1.0.0",
      "main": "./lib/main.js",
      "types": "./lib/main.d.ts"
    }
    ```

    Note that the `"typings"` field is synonymous with `types`, and could be used as well.
- name: 'Publishing: Matching behavior'
  id: declaration-files/publishing#matching-behavior
  summary: The way that TypeScript decides on whether a version of the compiler & language matches is by using Node’s semver ranges
  belongs_to: Publishing
  description: |-
    ## Matching behavior

    The way that TypeScript decides on whether a version of the compiler & language matches is by using Node’s [semver ranges](https://github.com/npm/node-semver#ranges).
- name: 'Publishing: Multiple fields'
  id: declaration-files/publishing#multiple-fields
  summary: typesVersions can support multiple fields where each field name is specified by the range to match on
  belongs_to: Publishing
  description: |-
    ## Multiple fields

    `typesVersions` can support multiple fields where each field name is specified by the range to match on.

    ``` typescript
    {
      "name": "package-name",
      "version": "1.0",
      "types": "./index.d.ts",
      "typesVersions": {
        ">=3.2": { "*": ["ts3.2/*"] },
        ">=3.1": { "*": ["ts3.1/*"] }
      }
    }
    ```

    Since ranges have the potential to overlap, determining which redirect applies is order-specific. That means in the above example, even though both the `>=3.2` and the `>=3.1` matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.

    ``` typescript
    {
      "name": "package-name",
      "version": "1.0",
      "types": "./index.d.ts",
      "typesVersions": {
        // NOTE: this doesn't work!
        ">=3.1": { "*": ["ts3.1/*"] },
        ">=3.2": { "*": ["ts3.2/*"] }
      }
    }
    ```
- name: 'Publishing: Publish to @types'
  id: declaration-files/publishing#publish-to-types
  summary: Packages under the @types organization are published automatically from DefinitelyTyped using the types-publisher tool
  belongs_to: Publishing
  description: "## Publish to\n\nPackages under the [@types](https://www.npmjs.com/~types) organization are published automatically from [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped) using the [types-publisher tool](https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher). To get your declarations published as an @types package, please submit a pull request to [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped). You can find more details in the [contribution guidelines page](https://definitelytyped.github.io/guides/contributing.html).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html)"
- name: 'Publishing: Red flags'
  id: declaration-files/publishing#red-flags
  summary: null
  belongs_to: Publishing
  description: '## Red flags'
- name: 'Publishing: Version selection with typesVersions'
  id: declaration-files/publishing#version-selection-with-typesversions
  summary: When TypeScript opens a package.json file to figure out which files it needs to read, it first looks at a field called typesVersions
  belongs_to: Publishing
  description: |-
    ## Version selection with `typesVersions`

    When TypeScript opens a `package.json` file to figure out which files it needs to read, it first looks at a field called `typesVersions`.

    #### Folder redirects (using `*`)

    A `package.json` with a `typesVersions` field might look like this:

    ``` json
    {
      "name": "package-name",
      "version": "1.0.0",
      "types": "./index.d.ts",
      "typesVersions": {
        ">=3.1": { "*": ["ts3.1/*"] }
      }
    }
    ```

    This `package.json` tells TypeScript to first check the current version of TypeScript. If it’s 3.1 or later, TypeScript figures out the path you’ve imported relative to the package, and reads from the package’s `ts3.1` folder.

    That’s what that `{ "*": ["ts3.1/*"] }` means - if you’re familiar with [path mapping](https://www.typescriptlang.org/tsconfig#paths), it works exactly like that.

    In the above example, if we’re importing from `"package-name"`, TypeScript will try to resolve from `[...]/node_modules/package-name/ts3.1/index.d.ts` (and other relevant paths) when running in TypeScript 3.1. If we import from `package-name/foo`, we’ll try to look for `[...]/node_modules/package-name/ts3.1/foo.d.ts` and `[...]/node_modules/package-name/ts3.1/foo/index.d.ts`.

    What if we’re not running in TypeScript 3.1 in this example? Well, if none of the fields in `typesVersions` get matched, TypeScript falls back to the `types` field, so here TypeScript 3.0 and earlier will be redirected to `[...]/node_modules/package-name/index.d.ts`.

    #### File redirects

    When you want to only change the resolution for a single file at a time, you can tell TypeScript the file to resolve differently by passing in the exact filenames:

    ``` json
    {
      "name": "package-name",
      "version": "1.0.0",
      "types": "./index.d.ts",
      "typesVersions": {
        "<4.0": { "index.d.ts": ["index.v3.d.ts"] }
      }
    }
    ```

    On TypeScript 4.0 and above, an import for `"package-name"` would resolve to `./index.d.ts` and for 3.9 and below `"./index.v3.d.ts`.

    Note that redirections only affect the *external* API of a package; import resolution within a project is not affected by `typesVersions`. For example, a `d.ts` file in the previous example containing `import * as foo from "./index"` will still map to `index.d.ts`, not `index.v3.d.ts`, whereas another package importing `import * as foo from "package-name"` *will* get `index.v3.d.ts`.
- name: reactNamespace
  id: tsconfig#reactNamespace-config
  summary: Use jsxFactory instead
  belongs_to: TSConfig Reference
  description: |-
    ### React Namespace - `reactNamespace`

    Use [`jsxFactory`](#jsxFactory) instead. Specify the object invoked for `createElement` when targeting `react` for TSX files.

    - Default:

      `React`
- name: reactNamespace
  id: tsconfig/index#reactNamespace-config
  summary: Use jsxFactory instead
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### React Namespace - `reactNamespace`

    Use [`jsxFactory`](#jsxFactory) instead. Specify the object invoked for `createElement` when targeting `react` for TSX files.

    - Default:

      `React`
- name: references
  id: tsconfig/index#references-config
  summary: Project references are a way to structure your TypeScript programs into smaller pieces
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### References - `references`

    Project references are a way to structure your TypeScript programs into smaller pieces. Using Project References can greatly improve build and editor interaction times, enforce logical separation between components, and organize your code in new and improved ways.

    You can read more about how references works in the [Project References](../docs/handbook/project-references) section of the handbook

    - Default:

      `false`

    ### Compiler Options

    These options make up the bulk of TypeScript’s configuration and it covers how the language should work.

    - [Type Checking](#Type_Checking_6248)
    - [Modules](#Modules_6244)
    - [Emit](#Emit_6246)
    - [JavaScript Support](#JavaScript_Support_6247)
    - [Editor Support](#Editor_Support_6249)
    - [Interop Constraints](#Interop_Constraints_6252)
    - [Backwards Compatibility](#Backwards_Compatibility_6253)
    - [Language and Environment](#Language_and_Environment_6254)
    - [Compiler Diagnostics](#Compiler_Diagnostics_6251)
    - [Projects](#Projects_6255)
    - [Output Formatting](#Output_Formatting_6256)
    - [Completeness](#Completeness_6257)
    - [Command Line](#Command_line_Options_6171)
    - [Watch Options](#Watch_and_Build_Modes_6250)

    ## Type Checking
- name: references
  id: tsconfig#references-config
  summary: Project references are a way to structure your TypeScript programs into smaller pieces
  belongs_to: TSConfig Reference
  description: |-
    ### References - `references`

    Project references are a way to structure your TypeScript programs into smaller pieces. Using Project References can greatly improve build and editor interaction times, enforce logical separation between components, and organize your code in new and improved ways.

    You can read more about how references works in the [Project References](docs/handbook/project-references) section of the handbook

    - Default:

      `false`

    ### Compiler Options

    These options make up the bulk of TypeScript’s configuration and it covers how the language should work.

    - [Type Checking](#Type_Checking_6248)
    - [Modules](#Modules_6244)
    - [Emit](#Emit_6246)
    - [JavaScript Support](#JavaScript_Support_6247)
    - [Editor Support](#Editor_Support_6249)
    - [Interop Constraints](#Interop_Constraints_6252)
    - [Backwards Compatibility](#Backwards_Compatibility_6253)
    - [Language and Environment](#Language_and_Environment_6254)
    - [Compiler Diagnostics](#Compiler_Diagnostics_6251)
    - [Projects](#Projects_6255)
    - [Output Formatting](#Output_Formatting_6256)
    - [Completeness](#Completeness_6257)
    - [Command Line](#Command_line_Options_6171)
    - [Watch Options](#Watch_and_Build_Modes_6250)

    ## Type Checking
- name: removeComments
  id: tsconfig/index#removeComments-config
  summary: Strips all comments from TypeScript files when converting into JavaScript
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Remove Comments - `removeComments`

    Strips all comments from TypeScript files when converting into JavaScript. Defaults to `false`.

    For example, this is a TypeScript file which has a JSDoc comment:

    ``` ts
    /** The translation of 'Hello world' into Portuguese */
    export const helloWorldPTBR = "Olá Mundo";
    ```

    When `removeComments` is set to `true`:

    ``` ts
    export const helloWorldPTBR = "Olá Mundo";
     
    ```

    Without setting `removeComments` or having it as `false`:

    ``` ts
    /** The translation of 'Hello world' into Portuguese */
    export const helloWorldPTBR = "Olá Mundo";
     
    ```

    This means that your comments will show up in the JavaScript code.
- name: removeComments
  id: tsconfig#removeComments-config
  summary: Strips all comments from TypeScript files when converting into JavaScript
  belongs_to: TSConfig Reference
  description: |-
    ### Remove Comments - `removeComments`

    Strips all comments from TypeScript files when converting into JavaScript. Defaults to `false`.

    For example, this is a TypeScript file which has a JSDoc comment:

    ``` ts
    /** The translation of 'Hello world' into Portuguese */
    export const helloWorldPTBR = "Olá Mundo";
    ```

    When `removeComments` is set to `true`:

    ``` ts
    export const helloWorldPTBR = "Olá Mundo";
     
    ```

    Without setting `removeComments` or having it as `false`:

    ``` ts
    /** The translation of 'Hello world' into Portuguese */
    export const helloWorldPTBR = "Olá Mundo";
     
    ```

    This means that your comments will show up in the JavaScript code.
- name: resolveJsonModule
  id: tsconfig/index#resolveJsonModule-config
  summary: Allows importing modules with a .json extension, which is a common practice in node projects
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Resolve JSON Module - `resolveJsonModule`

    Allows importing modules with a `.json` extension, which is a common practice in node projects. This includes generating a type for the `import` based on the static JSON shape.

    TypeScript does not support resolving JSON files by default:

    ``` ts
    // @filename: settings.json
    {
        "repo": "TypeScript",
        "dry": false,
        "debug": false
    }
    // @filename: index.ts
    import settings from "./settings.json";
     
    settings.debug === true;
    settings.dry === 2;
    ```

    Enabling the option allows importing JSON, and validating the types in that JSON file.

    ``` ts
    // @filename: settings.json
    {
        "repo": "TypeScript",
        "dry": false,
        "debug": false
    }
    // @filename: index.ts
    import settings from "./settings.json";
     
    settings.debug === true;
    settings.dry === 2;
    ```
- name: resolveJsonModule
  id: tsconfig#resolveJsonModule-config
  summary: Allows importing modules with a .json extension, which is a common practice in node projects
  belongs_to: TSConfig Reference
  description: |-
    ### Resolve JSON Module - `resolveJsonModule`

    Allows importing modules with a `.json` extension, which is a common practice in node projects. This includes generating a type for the `import` based on the static JSON shape.

    TypeScript does not support resolving JSON files by default:

    ``` ts
    // @filename: settings.json
    {
        "repo": "TypeScript",
        "dry": false,
        "debug": false
    }
    // @filename: index.ts
    import settings from "./settings.json";
     
    settings.debug === true;
    settings.dry === 2;
    ```

    Enabling the option allows importing JSON, and validating the types in that JSON file.

    ``` ts
    // @filename: settings.json
    {
        "repo": "TypeScript",
        "dry": false,
        "debug": false
    }
    // @filename: index.ts
    import settings from "./settings.json";
     
    settings.debug === true;
    settings.dry === 2;
    ```
- name: resolvePackageJsonExports
  id: tsconfig#resolvePackageJsonExports-config
  summary: --resolvePackageJsonExports forces TypeScript to consult the exports field of package.json files if it ever reads from a package in node_modules
  belongs_to: TSConfig Reference
  description: |-
    ### Resolve package.json Exports - `resolvePackageJsonExports`

    `--resolvePackageJsonExports` forces TypeScript to consult [the `exports` field of `package.json` files](https://nodejs.org/api/packages.html#exports) if it ever reads from a package in `node_modules`.

    This option defaults to `true` under the `node16`, `nodenext`, and `bundler` options for [`--moduleResolution`](#moduleResolution).

    - Default:

      `true` when [`moduleResolution`](#moduleResolution) is `node16`, `nodenext`, or `bundler`; otherwise `false`

    - Related:
      - [`moduleResolution`](#moduleResolution)

      - [`customConditions`](#customConditions)

      - [`resolvePackageJsonImports`](#resolvePackageJsonImports)
- name: resolvePackageJsonExports
  id: tsconfig/index#resolvePackageJsonExports-config
  summary: --resolvePackageJsonExports forces TypeScript to consult the exports field of package.json files if it ever reads from a package in node_modules
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Resolve package.json Exports - `resolvePackageJsonExports`

    `--resolvePackageJsonExports` forces TypeScript to consult [the `exports` field of `package.json` files](https://nodejs.org/api/packages.html#exports) if it ever reads from a package in `node_modules`.

    This option defaults to `true` under the `node16`, `nodenext`, and `bundler` options for [`--moduleResolution`](#moduleResolution).

    - Default:

      `true` when [`moduleResolution`](#moduleResolution) is `node16`, `nodenext`, or `bundler`; otherwise `false`

    - Related:
      - [`moduleResolution`](#moduleResolution)

      - [`customConditions`](#customConditions)

      - [`resolvePackageJsonImports`](#resolvePackageJsonImports)
- name: resolvePackageJsonImports
  id: tsconfig/index#resolvePackageJsonImports-config
  summary: '--resolvePackageJsonImports forces TypeScript to consult the imports field of package.json files when performing a lookup that starts with # from a file whose ancestor directory contains a package.json'
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Resolve package.json Imports - `resolvePackageJsonImports`

    `--resolvePackageJsonImports` forces TypeScript to consult [the `imports` field of `package.json` files](https://nodejs.org/api/packages.html#imports) when performing a lookup that starts with `#` from a file whose ancestor directory contains a `package.json`.

    This option defaults to `true` under the `node16`, `nodenext`, and `bundler` options for [`--moduleResolution`](#moduleResolution).

    - Default:

      `true` when [`moduleResolution`](#moduleResolution) is `node16`, `nodenext`, or `bundler`; otherwise `false`

    - Related:
      - [`moduleResolution`](#moduleResolution)

      - [`customConditions`](#customConditions)

      - [`resolvePackageJsonExports`](#resolvePackageJsonExports)
- name: resolvePackageJsonImports
  id: tsconfig#resolvePackageJsonImports-config
  summary: '--resolvePackageJsonImports forces TypeScript to consult the imports field of package.json files when performing a lookup that starts with # from a file whose ancestor directory contains a package.json'
  belongs_to: TSConfig Reference
  description: |-
    ### Resolve package.json Imports - `resolvePackageJsonImports`

    `--resolvePackageJsonImports` forces TypeScript to consult [the `imports` field of `package.json` files](https://nodejs.org/api/packages.html#imports) when performing a lookup that starts with `#` from a file whose ancestor directory contains a `package.json`.

    This option defaults to `true` under the `node16`, `nodenext`, and `bundler` options for [`--moduleResolution`](#moduleResolution).

    - Default:

      `true` when [`moduleResolution`](#moduleResolution) is `node16`, `nodenext`, or `bundler`; otherwise `false`

    - Related:
      - [`moduleResolution`](#moduleResolution)

      - [`customConditions`](#customConditions)

      - [`resolvePackageJsonExports`](#resolvePackageJsonExports)
- name: rootDir
  id: tsconfig/index#rootDir-config
  summary: 'Default: The longest common path of all non-declaration input files'
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Root Dir - `rootDir`

    **Default**: The longest common path of all non-declaration input files. If [`composite`](#composite) is set, the default is instead the directory containing the `tsconfig.json` file.

    When TypeScript compiles files, it keeps the same directory structure in the output directory as exists in the input directory.

    For example, let’s say you have some input files:

    ``` typescript
    MyProj
    ├── tsconfig.json
    ├── core
    │   ├── a.ts
    │   ├── b.ts
    │   ├── sub
    │   │   ├── c.ts
    ├── types.d.ts
    ```

    The inferred value for `rootDir` is the longest common path of all non-declaration input files, which in this case is `core/`.

    If your [`outDir`](#outDir) was `dist`, TypeScript would write this tree:

    ``` typescript
    MyProj
    ├── dist
    │   ├── a.js
    │   ├── b.js
    │   ├── sub
    │   │   ├── c.js
    ```

    However, you may have intended for `core` to be part of the output directory structure. By setting `rootDir: "."` in `tsconfig.json`, TypeScript would write this tree:

    ``` typescript
    MyProj
    ├── dist
    │   ├── core
    │   │   ├── a.js
    │   │   ├── b.js
    │   │   ├── sub
    │   │   │   ├── c.js
    ```

    Importantly, `rootDir` **does not affect which files become part of the compilation**. It has no interaction with the [`include`](#include), [`exclude`](#exclude), or [`files`](#files) `tsconfig.json` settings.

    Note that TypeScript will never write an output file to a directory outside of [`outDir`](#outDir), and will never skip emitting a file. For this reason, `rootDir` also enforces that all files which need to be emitted are underneath the `rootDir` path.

    For example, let’s say you had this tree:

    ``` typescript
    MyProj
    ├── tsconfig.json
    ├── core
    │   ├── a.ts
    │   ├── b.ts
    ├── helpers.ts
    ```

    It would be an error to specify `rootDir` as `core` *and* [`include`](#include) as `*` because it creates a file (`helpers.ts`) that would need to be emitted *outside* the [`outDir`](#outDir) (i.e. `../helpers.js`).

    - Default:

      Computed from the list of input files.

    - Released:

      [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)
- name: rootDir
  id: tsconfig#rootDir-config
  summary: 'Default: The longest common path of all non-declaration input files'
  belongs_to: TSConfig Reference
  description: |-
    ### Root Dir - `rootDir`

    **Default**: The longest common path of all non-declaration input files. If [`composite`](#composite) is set, the default is instead the directory containing the `tsconfig.json` file.

    When TypeScript compiles files, it keeps the same directory structure in the output directory as exists in the input directory.

    For example, let’s say you have some input files:

    ``` typescript
    MyProj
    ├── tsconfig.json
    ├── core
    │   ├── a.ts
    │   ├── b.ts
    │   ├── sub
    │   │   ├── c.ts
    ├── types.d.ts
    ```

    The inferred value for `rootDir` is the longest common path of all non-declaration input files, which in this case is `core/`.

    If your [`outDir`](#outDir) was `dist`, TypeScript would write this tree:

    ``` typescript
    MyProj
    ├── dist
    │   ├── a.js
    │   ├── b.js
    │   ├── sub
    │   │   ├── c.js
    ```

    However, you may have intended for `core` to be part of the output directory structure. By setting `rootDir: "."` in `tsconfig.json`, TypeScript would write this tree:

    ``` typescript
    MyProj
    ├── dist
    │   ├── core
    │   │   ├── a.js
    │   │   ├── b.js
    │   │   ├── sub
    │   │   │   ├── c.js
    ```

    Importantly, `rootDir` **does not affect which files become part of the compilation**. It has no interaction with the [`include`](#include), [`exclude`](#exclude), or [`files`](#files) `tsconfig.json` settings.

    Note that TypeScript will never write an output file to a directory outside of [`outDir`](#outDir), and will never skip emitting a file. For this reason, `rootDir` also enforces that all files which need to be emitted are underneath the `rootDir` path.

    For example, let’s say you had this tree:

    ``` typescript
    MyProj
    ├── tsconfig.json
    ├── core
    │   ├── a.ts
    │   ├── b.ts
    ├── helpers.ts
    ```

    It would be an error to specify `rootDir` as `core` *and* [`include`](#include) as `*` because it creates a file (`helpers.ts`) that would need to be emitted *outside* the [`outDir`](#outDir) (i.e. `../helpers.js`).

    - Default:

      Computed from the list of input files.

    - Released:

      [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)
- name: rootDirs
  id: tsconfig#rootDirs-config
  summary: Using rootDirs, you can inform the compiler that there are many “virtual” directories acting as a single root
  belongs_to: TSConfig Reference
  description: |-
    ### Root Dirs - `rootDirs`

    Using `rootDirs`, you can inform the compiler that there are many “virtual” directories acting as a single root. This allows the compiler to resolve relative module imports within these “virtual” directories, as if they were merged in to one directory.

    For example:

    ``` typescript
     src
     └── views
         └── view1.ts (can import "./template1", "./view2`)
         └── view2.ts (can import "./template1", "./view1`)

     generated
     └── templates
             └── views
                 └── template1.ts (can import "./view1", "./view2")
    ```

    ``` typescript
    {
      "compilerOptions": {
        "rootDirs": ["src/views", "generated/templates/views"]
      }
    }
    ```

    This does not affect how TypeScript emits JavaScript, it only emulates the assumption that they will be able to work via those relative paths at runtime.

    `rootDirs` can be used to provide a separate “type layer” to files that are not TypeScript or JavaScript by providing a home for generated `.d.ts` files in another folder. This technique is useful for bundled applications where you use `import` of files that aren’t necessarily code:

    ``` shell
     src
     └── index.ts
     └── css
         └── main.css
         └── navigation.css

     generated
     └── css
         └── main.css.d.ts
         └── navigation.css.d.ts
    ```

    ``` typescript
    {
      "compilerOptions": {
        "rootDirs": ["src", "generated"]
      }
    }
    ```

    This technique lets you generate types ahead of time for the non-code source files. Imports then work naturally based off the source file’s location. For example `./src/index.ts` can import the file `./src/css/main.css` and TypeScript will be aware of the bundler’s behavior for that filetype via the corresponding generated declaration file.

    ``` ts
    // @filename: index.ts
    import { appClass } from "./main.css";
    ```

    - Default:

      Computed from the list of input files.

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: rootDirs
  id: tsconfig/index#rootDirs-config
  summary: Using rootDirs, you can inform the compiler that there are many “virtual” directories acting as a single root
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Root Dirs - `rootDirs`

    Using `rootDirs`, you can inform the compiler that there are many “virtual” directories acting as a single root. This allows the compiler to resolve relative module imports within these “virtual” directories, as if they were merged in to one directory.

    For example:

    ``` typescript
     src
     └── views
         └── view1.ts (can import "./template1", "./view2`)
         └── view2.ts (can import "./template1", "./view1`)

     generated
     └── templates
             └── views
                 └── template1.ts (can import "./view1", "./view2")
    ```

    ``` typescript
    {
      "compilerOptions": {
        "rootDirs": ["src/views", "generated/templates/views"]
      }
    }
    ```

    This does not affect how TypeScript emits JavaScript, it only emulates the assumption that they will be able to work via those relative paths at runtime.

    `rootDirs` can be used to provide a separate “type layer” to files that are not TypeScript or JavaScript by providing a home for generated `.d.ts` files in another folder. This technique is useful for bundled applications where you use `import` of files that aren’t necessarily code:

    ``` shell
     src
     └── index.ts
     └── css
         └── main.css
         └── navigation.css

     generated
     └── css
         └── main.css.d.ts
         └── navigation.css.d.ts
    ```

    ``` typescript
    {
      "compilerOptions": {
        "rootDirs": ["src", "generated"]
      }
    }
    ```

    This technique lets you generate types ahead of time for the non-code source files. Imports then work naturally based off the source file’s location. For example `./src/index.ts` can import the file `./src/css/main.css` and TypeScript will be aware of the bundler’s behavior for that filetype via the corresponding generated declaration file.

    ``` ts
    // @filename: index.ts
    import { appClass } from "./main.css";
    ```

    - Default:

      Computed from the list of input files.

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: skipDefaultLibCheck
  id: tsconfig#skipDefaultLibCheck-config
  summary: Use skipLibCheck instead
  belongs_to: TSConfig Reference
  description: |-
    ### Skip Default Lib Check - `skipDefaultLibCheck`

    Use [`skipLibCheck`](#skipLibCheck) instead. Skip type checking of default library declaration files.
- name: skipDefaultLibCheck
  id: tsconfig/index#skipDefaultLibCheck-config
  summary: Use skipLibCheck instead
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Skip Default Lib Check - `skipDefaultLibCheck`

    Use [`skipLibCheck`](#skipLibCheck) instead. Skip type checking of default library declaration files.
- name: skipLibCheck
  id: tsconfig#skipLibCheck-config
  summary: Skip type checking of declaration files
  belongs_to: TSConfig Reference
  description: |-
    ### Skip Lib Check - `skipLibCheck`

    Skip type checking of declaration files.

    This can save time during compilation at the expense of type-system accuracy. For example, two libraries could define two copies of the same `type` in an inconsistent way. Rather than doing a full check of all `d.ts` files, TypeScript will type check the code you specifically refer to in your app’s source code.

    A common case where you might think to use `skipLibCheck` is when there are two copies of a library’s types in your `node_modules`. In these cases, you should consider using a feature like [yarn’s resolutions](https://yarnpkg.com/lang/en/docs/selective-version-resolutions/) to ensure there is only one copy of that dependency in your tree or investigate how to ensure there is only one copy by understanding the dependency resolution to fix the issue without additional tooling.

    Another possibility is when you are migrating between TypeScript releases and the changes cause breakages in node_modules and the JS standard libraries which you do not want to deal with during the TypeScript update.

    Note, that if these issues come from the TypeScript standard library you can replace the library using [TypeScript 4.5’s lib replacement](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#supporting-lib-from-node_modules) technique.

    - Recommended

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)

    ## Command Line

    ## Watch Options

    TypeScript 3.8 shipped a new strategy for watching directories, which is crucial for efficiently picking up changes to `node_modules`.

    On operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on `node_modules` and many of its subdirectories to detect changes in dependencies. This is because the number of available file watchers is often eclipsed by the number of files in `node_modules`, whereas there are way fewer directories to track.

    Because every project might work better under different strategies, and this new approach might not work well for your workflows, TypeScript 3.8 introduces a new `watchOptions` field which allows users to tell the compiler/language service which watching strategies should be used to keep track of files and directories.
- name: skipLibCheck
  id: tsconfig/index#skipLibCheck-config
  summary: Skip type checking of declaration files
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Skip Lib Check - `skipLibCheck`

    Skip type checking of declaration files.

    This can save time during compilation at the expense of type-system accuracy. For example, two libraries could define two copies of the same `type` in an inconsistent way. Rather than doing a full check of all `d.ts` files, TypeScript will type check the code you specifically refer to in your app’s source code.

    A common case where you might think to use `skipLibCheck` is when there are two copies of a library’s types in your `node_modules`. In these cases, you should consider using a feature like [yarn’s resolutions](https://yarnpkg.com/lang/en/docs/selective-version-resolutions/) to ensure there is only one copy of that dependency in your tree or investigate how to ensure there is only one copy by understanding the dependency resolution to fix the issue without additional tooling.

    Another possibility is when you are migrating between TypeScript releases and the changes cause breakages in node_modules and the JS standard libraries which you do not want to deal with during the TypeScript update.

    Note, that if these issues come from the TypeScript standard library you can replace the library using [TypeScript 4.5’s lib replacement](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#supporting-lib-from-node_modules) technique.

    - Recommended

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)

    ## Command Line

    ## Watch Options

    TypeScript 3.8 shipped a new strategy for watching directories, which is crucial for efficiently picking up changes to `node_modules`.

    On operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on `node_modules` and many of its subdirectories to detect changes in dependencies. This is because the number of available file watchers is often eclipsed by the number of files in `node_modules`, whereas there are way fewer directories to track.

    Because every project might work better under different strategies, and this new approach might not work well for your workflows, TypeScript 3.8 introduces a new `watchOptions` field which allows users to tell the compiler/language service which watching strategies should be used to keep track of files and directories.
- name: sourceMap
  id: tsconfig#sourceMap-config
  summary: Enables the generation of sourcemap files
  belongs_to: TSConfig Reference
  description: |-
    ### Source Map - `sourceMap`

    Enables the generation of [sourcemap files](https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map). These files allow debuggers and other tools to display the original TypeScript source code when actually working with the emitted JavaScript files. Source map files are emitted as `.js.map` (or `.jsx.map`) files next to the corresponding `.js` output file.

    The `.js` files will in turn contain a sourcemap comment to indicate where the files are to external tools, for example:

    ``` ts
    // helloWorld.ts
    export declare const helloWorld = "hi";
    ```

    Compiling with `sourceMap` set to `true` creates the following JavaScript file:

    ``` js
    // helloWorld.js
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.helloWorld = "hi";
    //# sourceMappingURL=// helloWorld.js.map
    ```

    And this also generates this json map:

    ``` json
    // helloWorld.js.map
    {
      "version": 3,
      "file": "ex.js",
      "sourceRoot": "",
      "sources": ["../ex.ts"],
      "names": [],
      "mappings": ";;AAAa,QAAA,UAAU,GAAG,IAAI,CAAA"
    }
    ```
- name: sourceMap
  id: tsconfig/index#sourceMap-config
  summary: Enables the generation of sourcemap files
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Source Map - `sourceMap`

    Enables the generation of [sourcemap files](https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map). These files allow debuggers and other tools to display the original TypeScript source code when actually working with the emitted JavaScript files. Source map files are emitted as `.js.map` (or `.jsx.map`) files next to the corresponding `.js` output file.

    The `.js` files will in turn contain a sourcemap comment to indicate where the files are to external tools, for example:

    ``` ts
    // helloWorld.ts
    export declare const helloWorld = "hi";
    ```

    Compiling with `sourceMap` set to `true` creates the following JavaScript file:

    ``` js
    // helloWorld.js
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.helloWorld = "hi";
    //# sourceMappingURL=// helloWorld.js.map
    ```

    And this also generates this json map:

    ``` json
    // helloWorld.js.map
    {
      "version": 3,
      "file": "ex.js",
      "sourceRoot": "",
      "sources": ["../ex.ts"],
      "names": [],
      "mappings": ";;AAAa,QAAA,UAAU,GAAG,IAAI,CAAA"
    }
    ```
- name: sourceRoot
  id: tsconfig#sourceRoot-config
  summary: Specify the location where a debugger should locate TypeScript files instead of relative source locations
  belongs_to: TSConfig Reference
  description: |-
    ### Source Root - `sourceRoot`

    Specify the location where a debugger should locate TypeScript files instead of relative source locations. This string is treated verbatim inside the source-map where you can use a path or a URL:

    ``` typescript
    {
      "compilerOptions": {
        "sourceMap": true,
        "sourceRoot": "https://my-website.com/debug/source/"
      }
    }
    ```

    Would declare that `index.js` will have a source file at `https://my-website.com/debug/source/index.ts`.
- name: sourceRoot
  id: tsconfig/index#sourceRoot-config
  summary: Specify the location where a debugger should locate TypeScript files instead of relative source locations
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Source Root - `sourceRoot`

    Specify the location where a debugger should locate TypeScript files instead of relative source locations. This string is treated verbatim inside the source-map where you can use a path or a URL:

    ``` typescript
    {
      "compilerOptions": {
        "sourceMap": true,
        "sourceRoot": "https://my-website.com/debug/source/"
      }
    }
    ```

    Would declare that `index.js` will have a source file at `https://my-website.com/debug/source/index.ts`.
- name: strict
  id: tsconfig/index#strict-config
  summary: The strict flag enables a wide range of type checking behavior that results in stronger guarantees of program correctness
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Strict - `strict`

    The `strict` flag enables a wide range of type checking behavior that results in stronger guarantees of program correctness. Turning this on is equivalent to enabling all of the *strict mode family* options, which are outlined below. You can then turn off individual strict mode family checks as needed.

    Future versions of TypeScript may introduce additional stricter checking under this flag, so upgrades of TypeScript might result in new type errors in your program. When appropriate and possible, a corresponding flag will be added to disable that behavior.

    - Recommended

    - Related:
      - [`alwaysStrict`](#alwaysStrict)

      - [`strictNullChecks`](#strictNullChecks)

      - [`strictBindCallApply`](#strictBindCallApply)

      - [`strictFunctionTypes`](#strictFunctionTypes)

      - [`strictPropertyInitialization`](#strictPropertyInitialization)

      - [`noImplicitAny`](#noImplicitAny)

      - [`noImplicitThis`](#noImplicitThis)

      - [`useUnknownInCatchVariables`](#useUnknownInCatchVariables)

    - Released:

      [2.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html)
- name: strict
  id: tsconfig#strict-config
  summary: The strict flag enables a wide range of type checking behavior that results in stronger guarantees of program correctness
  belongs_to: TSConfig Reference
  description: |-
    ### Strict - `strict`

    The `strict` flag enables a wide range of type checking behavior that results in stronger guarantees of program correctness. Turning this on is equivalent to enabling all of the *strict mode family* options, which are outlined below. You can then turn off individual strict mode family checks as needed.

    Future versions of TypeScript may introduce additional stricter checking under this flag, so upgrades of TypeScript might result in new type errors in your program. When appropriate and possible, a corresponding flag will be added to disable that behavior.

    - Recommended

    - Related:
      - [`alwaysStrict`](#alwaysStrict)

      - [`strictNullChecks`](#strictNullChecks)

      - [`strictBindCallApply`](#strictBindCallApply)

      - [`strictFunctionTypes`](#strictFunctionTypes)

      - [`strictPropertyInitialization`](#strictPropertyInitialization)

      - [`noImplicitAny`](#noImplicitAny)

      - [`noImplicitThis`](#noImplicitThis)

      - [`useUnknownInCatchVariables`](#useUnknownInCatchVariables)

    - Released:

      [2.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html)
- name: strictBindCallApply
  id: tsconfig/index#strictBindCallApply-config
  summary: true if strict; false otherwise
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Strict Bind Call Apply - `strictBindCallApply`

    When set, TypeScript will check that the built-in methods of functions `call`, `bind`, and `apply` are invoked with correct argument for the underlying function:

    ``` ts
    // With strictBindCallApply on
    function fn(x: string) {
      return parseInt(x);
    }
     
    const n1 = fn.call(undefined, "10");
     
    const n2 = fn.call(undefined, false);
    ```

    Otherwise, these functions accept any arguments and will return `any`:

    ``` ts
    // With strictBindCallApply off
    function fn(x: string) {
      return parseInt(x);
    }
     
    // Note: No error; return type is 'any'
    const n = fn.call(undefined, false);
    ```

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)

    - Released:

      [3.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html)
- name: strictBindCallApply
  id: tsconfig#strictBindCallApply-config
  summary: true if strict; false otherwise
  belongs_to: TSConfig Reference
  description: |-
    ### Strict Bind Call Apply - `strictBindCallApply`

    When set, TypeScript will check that the built-in methods of functions `call`, `bind`, and `apply` are invoked with correct argument for the underlying function:

    ``` ts
    // With strictBindCallApply on
    function fn(x: string) {
      return parseInt(x);
    }
     
    const n1 = fn.call(undefined, "10");
     
    const n2 = fn.call(undefined, false);
    ```

    Otherwise, these functions accept any arguments and will return `any`:

    ``` ts
    // With strictBindCallApply off
    function fn(x: string) {
      return parseInt(x);
    }
     
    // Note: No error; return type is 'any'
    const n = fn.call(undefined, false);
    ```

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)

    - Released:

      [3.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html)
- name: strictFunctionTypes
  id: tsconfig/index#strictFunctionTypes-config
  summary: When enabled, this flag causes functions parameters to be checked more correctly
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Strict Function Types - `strictFunctionTypes`

    When enabled, this flag causes functions parameters to be checked more correctly.

    Here’s a basic example with `strictFunctionTypes` off:

    ``` ts
    function fn(x: string) {
      console.log("Hello, " + x.toLowerCase());
    }
     
    type StringOrNumberFunc = (ns: string | number) => void;
     
    // Unsafe assignment
    let func: StringOrNumberFunc = fn;
    // Unsafe call - will crash
    func(10);
    ```

    With `strictFunctionTypes` *on*, the error is correctly detected:

    ``` ts
    function fn(x: string) {
      console.log("Hello, " + x.toLowerCase());
    }
     
    type StringOrNumberFunc = (ns: string | number) => void;
     
    // Unsafe assignment is prevented
    let func: StringOrNumberFunc = fn;
    ```

    During development of this feature, we discovered a large number of inherently unsafe class hierarchies, including some in the DOM. Because of this, the setting only applies to functions written in *function* syntax, not to those in *method* syntax:

    ``` ts
    type Methodish = {
      func(x: string | number): void;
    };
     
    function fn(x: string) {
      console.log("Hello, " + x.toLowerCase());
    }
     
    // Ultimately an unsafe assignment, but not detected
    const m: Methodish = {
      func: fn,
    };
    m.func(10);
    ```

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)

    - Released:

      [2.6](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html)
- name: strictFunctionTypes
  id: tsconfig#strictFunctionTypes-config
  summary: When enabled, this flag causes functions parameters to be checked more correctly
  belongs_to: TSConfig Reference
  description: |-
    ### Strict Function Types - `strictFunctionTypes`

    When enabled, this flag causes functions parameters to be checked more correctly.

    Here’s a basic example with `strictFunctionTypes` off:

    ``` ts
    function fn(x: string) {
      console.log("Hello, " + x.toLowerCase());
    }
     
    type StringOrNumberFunc = (ns: string | number) => void;
     
    // Unsafe assignment
    let func: StringOrNumberFunc = fn;
    // Unsafe call - will crash
    func(10);
    ```

    With `strictFunctionTypes` *on*, the error is correctly detected:

    ``` ts
    function fn(x: string) {
      console.log("Hello, " + x.toLowerCase());
    }
     
    type StringOrNumberFunc = (ns: string | number) => void;
     
    // Unsafe assignment is prevented
    let func: StringOrNumberFunc = fn;
    ```

    During development of this feature, we discovered a large number of inherently unsafe class hierarchies, including some in the DOM. Because of this, the setting only applies to functions written in *function* syntax, not to those in *method* syntax:

    ``` ts
    type Methodish = {
      func(x: string | number): void;
    };
     
    function fn(x: string) {
      console.log("Hello, " + x.toLowerCase());
    }
     
    // Ultimately an unsafe assignment, but not detected
    const m: Methodish = {
      func: fn,
    };
    m.func(10);
    ```

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)

    - Released:

      [2.6](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html)
- name: strictNullChecks
  id: tsconfig#strictNullChecks-config
  summary: When strictNullChecks is false, null and undefined are effectively ignored by the language
  belongs_to: TSConfig Reference
  description: |-
    ### Strict Null Checks - `strictNullChecks`

    When `strictNullChecks` is `false`, `null` and `undefined` are effectively ignored by the language. This can lead to unexpected errors at runtime.

    When `strictNullChecks` is `true`, `null` and `undefined` have their own distinct types and you’ll get a type error if you try to use them where a concrete value is expected.

    For example with this TypeScript code, `users.find` has no guarantee that it will actually find a user, but you can write code as though it will:

    ``` ts
    declare const loggedInUsername: string;
     
    const users = [
      { name: "Oby", age: 12 },
      { name: "Heera", age: 32 },
    ];
     
    const loggedInUser = users.find((u) => u.name === loggedInUsername);
    console.log(loggedInUser.age);
    ```

    Setting `strictNullChecks` to `true` will raise an error that you have not made a guarantee that the `loggedInUser` exists before trying to use it.

    ``` ts
    declare const loggedInUsername: string;
     
    const users = [
      { name: "Oby", age: 12 },
      { name: "Heera", age: 32 },
    ];
     
    const loggedInUser = users.find((u) => u.name === loggedInUsername);
    console.log(loggedInUser.age);
    ```

    The second example failed because the array’s `find` function looks a bit like this simplification:

    ``` ts
    // When strictNullChecks: true
    type Array = {
      find(predicate: (value: any, index: number) => boolean): S | undefined;
    };

    // When strictNullChecks: false the undefined is removed from the type system,
    // allowing you to write code which assumes it always found a result
    type Array = {
      find(predicate: (value: any, index: number) => boolean): S;
    };
    ```

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: strictNullChecks
  id: tsconfig/index#strictNullChecks-config
  summary: When strictNullChecks is false, null and undefined are effectively ignored by the language
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Strict Null Checks - `strictNullChecks`

    When `strictNullChecks` is `false`, `null` and `undefined` are effectively ignored by the language. This can lead to unexpected errors at runtime.

    When `strictNullChecks` is `true`, `null` and `undefined` have their own distinct types and you’ll get a type error if you try to use them where a concrete value is expected.

    For example with this TypeScript code, `users.find` has no guarantee that it will actually find a user, but you can write code as though it will:

    ``` ts
    declare const loggedInUsername: string;
     
    const users = [
      { name: "Oby", age: 12 },
      { name: "Heera", age: 32 },
    ];
     
    const loggedInUser = users.find((u) => u.name === loggedInUsername);
    console.log(loggedInUser.age);
    ```

    Setting `strictNullChecks` to `true` will raise an error that you have not made a guarantee that the `loggedInUser` exists before trying to use it.

    ``` ts
    declare const loggedInUsername: string;
     
    const users = [
      { name: "Oby", age: 12 },
      { name: "Heera", age: 32 },
    ];
     
    const loggedInUser = users.find((u) => u.name === loggedInUsername);
    console.log(loggedInUser.age);
    ```

    The second example failed because the array’s `find` function looks a bit like this simplification:

    ``` ts
    // When strictNullChecks: true
    type Array = {
      find(predicate: (value: any, index: number) => boolean): S | undefined;
    };

    // When strictNullChecks: false the undefined is removed from the type system,
    // allowing you to write code which assumes it always found a result
    type Array = {
      find(predicate: (value: any, index: number) => boolean): S;
    };
    ```

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)
- name: strictPropertyInitialization
  id: tsconfig/index#strictPropertyInitialization-config
  summary: When set to true, TypeScript will raise an error when a class property was declared but not set in the constructor
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Strict Property Initialization - `strictPropertyInitialization`

    When set to true, TypeScript will raise an error when a class property was declared but not set in the constructor.

    ``` ts
    class UserAccount {
      name: string;
      accountType = "user";
     
      email: string;
      address: string | undefined;
     
      constructor(name: string) {
        this.name = name;
        // Note that this.email is not set
      }
    }
    ```

    In the above case:

    - `this.name` is set specifically.
    - `this.accountType` is set by default.
    - `this.email` is not set and raises an error.
    - `this.address` is declared as potentially `undefined` which means it does not have to be set.

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)

    - Released:

      [2.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html)
- name: strictPropertyInitialization
  id: tsconfig#strictPropertyInitialization-config
  summary: When set to true, TypeScript will raise an error when a class property was declared but not set in the constructor
  belongs_to: TSConfig Reference
  description: |-
    ### Strict Property Initialization - `strictPropertyInitialization`

    When set to true, TypeScript will raise an error when a class property was declared but not set in the constructor.

    ``` ts
    class UserAccount {
      name: string;
      accountType = "user";
     
      email: string;
      address: string | undefined;
     
      constructor(name: string) {
        this.name = name;
        // Note that this.email is not set
      }
    }
    ```

    In the above case:

    - `this.name` is set specifically.
    - `this.accountType` is set by default.
    - `this.email` is not set and raises an error.
    - `this.address` is declared as potentially `undefined` which means it does not have to be set.

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)

    - Released:

      [2.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html)
- name: stripInternal
  id: tsconfig#stripInternal-config
  summary: Do not emit declarations for code that has an @internal annotation in its JSDoc comment
  belongs_to: TSConfig Reference
  description: |-
    ### Strip Internal - `stripInternal`

    Do not emit declarations for code that has an `@internal` annotation in its JSDoc comment. This is an internal compiler option; use at your own risk, because the compiler does not check that the result is valid. If you are searching for a tool to handle additional levels of visibility within your `d.ts` files, look at [api-extractor](https://api-extractor.com).

    ``` ts
    /**
     * Days available in a week
     * @internal
     */
    export const daysInAWeek = 7;
     
    /** Calculate how much someone earns in a week */
    export function weeklySalary(dayRate: number) {
      return daysInAWeek * dayRate;
    }
    ```

    With the flag set to `false` (default):

    ``` ts
    /**
     * Days available in a week
     * @internal
     */
    export declare const daysInAWeek = 7;
    /** Calculate how much someone earns in a week */
    export declare function weeklySalary(dayRate: number): number;
     
    ```

    With `stripInternal` set to `true` the `d.ts` emitted will be redacted.

    ``` ts
    /** Calculate how much someone earns in a week */
    export declare function weeklySalary(dayRate: number): number;
     
    ```

    The JavaScript output is still the same.

    - Internal

    ## JavaScript Support
- name: stripInternal
  id: tsconfig/index#stripInternal-config
  summary: Do not emit declarations for code that has an @internal annotation in its JSDoc comment
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Strip Internal - `stripInternal`

    Do not emit declarations for code that has an `@internal` annotation in its JSDoc comment. This is an internal compiler option; use at your own risk, because the compiler does not check that the result is valid. If you are searching for a tool to handle additional levels of visibility within your `d.ts` files, look at [api-extractor](https://api-extractor.com).

    ``` ts
    /**
     * Days available in a week
     * @internal
     */
    export const daysInAWeek = 7;
     
    /** Calculate how much someone earns in a week */
    export function weeklySalary(dayRate: number) {
      return daysInAWeek * dayRate;
    }
    ```

    With the flag set to `false` (default):

    ``` ts
    /**
     * Days available in a week
     * @internal
     */
    export declare const daysInAWeek = 7;
    /** Calculate how much someone earns in a week */
    export declare function weeklySalary(dayRate: number): number;
     
    ```

    With `stripInternal` set to `true` the `d.ts` emitted will be redacted.

    ``` ts
    /** Calculate how much someone earns in a week */
    export declare function weeklySalary(dayRate: number): number;
     
    ```

    The JavaScript output is still the same.

    - Internal

    ## JavaScript Support
- name: suppressExcessPropertyErrors
  id: tsconfig/index#suppressExcessPropertyErrors-config
  summary: This flag was added to help people migrate to the stricter checking of new object literals in TypeScript 1.6
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Suppress Excess Property Errors - `suppressExcessPropertyErrors`

    This disables reporting of excess property errors, such as the one shown in the following example:

    ``` ts
    type Point = { x: number; y: number };
    const p: Point = { x: 1, y: 3, m: 10 };
    ```

    This flag was added to help people migrate to the stricter checking of new object literals in [TypeScript 1.6](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#stricter-object-literal-assignment-checks).

    We don’t recommend using this flag in a modern codebase, you can suppress one-off cases where you need it using `// @ts-ignore`.
- name: suppressExcessPropertyErrors
  id: tsconfig#suppressExcessPropertyErrors-config
  summary: This flag was added to help people migrate to the stricter checking of new object literals in TypeScript 1.6
  belongs_to: TSConfig Reference
  description: |-
    ### Suppress Excess Property Errors - `suppressExcessPropertyErrors`

    This disables reporting of excess property errors, such as the one shown in the following example:

    ``` ts
    type Point = { x: number; y: number };
    const p: Point = { x: 1, y: 3, m: 10 };
    ```

    This flag was added to help people migrate to the stricter checking of new object literals in [TypeScript 1.6](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#stricter-object-literal-assignment-checks).

    We don’t recommend using this flag in a modern codebase, you can suppress one-off cases where you need it using `// @ts-ignore`.
- name: suppressImplicitAnyIndexErrors
  id: tsconfig/index#suppressImplicitAnyIndexErrors-config
  summary: Using suppressImplicitAnyIndexErrors is quite a drastic approach
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Suppress Implicit Any Index Errors - `suppressImplicitAnyIndexErrors`

    Turning `suppressImplicitAnyIndexErrors` on suppresses reporting the error about implicit anys when indexing into objects, as shown in the following example:

    ``` ts
    const obj = { x: 10 };
    console.log(obj["foo"]);
    ```

    Using `suppressImplicitAnyIndexErrors` is quite a drastic approach. It is recommended to use a `@ts-ignore` comment instead:

    ``` ts
    const obj = { x: 10 };
    // @ts-ignore
    console.log(obj["foo"]);
    ```

    - Related:
      - [`noImplicitAny`](#noImplicitAny)

    ## Language and Environment
- name: suppressImplicitAnyIndexErrors
  id: tsconfig#suppressImplicitAnyIndexErrors-config
  summary: Using suppressImplicitAnyIndexErrors is quite a drastic approach
  belongs_to: TSConfig Reference
  description: |-
    ### Suppress Implicit Any Index Errors - `suppressImplicitAnyIndexErrors`

    Turning `suppressImplicitAnyIndexErrors` on suppresses reporting the error about implicit anys when indexing into objects, as shown in the following example:

    ``` ts
    const obj = { x: 10 };
    console.log(obj["foo"]);
    ```

    Using `suppressImplicitAnyIndexErrors` is quite a drastic approach. It is recommended to use a `@ts-ignore` comment instead:

    ``` ts
    const obj = { x: 10 };
    // @ts-ignore
    console.log(obj["foo"]);
    ```

    - Related:
      - [`noImplicitAny`](#noImplicitAny)

    ## Language and Environment
- name: Symbols
  id: symbols
  summary: Starting with ECMAScript 2015, symbol is a primitive data type, just like number and string
  description: "# Symbols\n\nStarting with ECMAScript 2015, `symbol` is a primitive data type, just like `number` and `string`.\n\n`symbol` values are created by calling the `Symbol` constructor.\n\n``` ts\nlet sym1 = Symbol();\n\nlet sym2 = Symbol(\"key\"); // optional string key\n```\n\nSymbols are immutable, and unique.\n\n``` ts\nlet sym2 = Symbol(\"key\");\nlet sym3 = Symbol(\"key\");\n\nsym2 === sym3; // false, symbols are unique\n```\n\nJust like strings, symbols can be used as keys for object properties.\n\n``` ts\nconst sym = Symbol();\n\nlet obj = {\n  [sym]: \"value\",\n};\n\nconsole.log(obj[sym]); // \"value\"\n```\n\nSymbols can also be combined with computed property declarations to declare object properties and class members.\n\n``` ts\nconst getClassNameSymbol = Symbol();\n\nclass C {\n  [getClassNameSymbol]() {\n    return \"C\";\n  }\n}\n\nlet c = new C();\nlet className = c[getClassNameSymbol](); // \"C\"\n```\n\n## `unique symbol`\n\nTo enable treating symbols as unique literals a special type `unique symbol` is available. `unique symbol` is a subtype of `symbol`, and are produced only from calling `Symbol()` or `Symbol.for()`, or from explicit type annotations. This type is only allowed on `const` declarations and `readonly static` properties, and in order to reference a specific unique symbol, you’ll have to use the `typeof` operator. Each reference to a unique symbol implies a completely unique identity that’s tied to a given declaration.\n\n``` ts\ndeclare const sym1: unique symbol;\n \n// sym2 can only be a constant reference.\nlet sym2: unique symbol = Symbol();\n \n// Works - refers to a unique symbol, but its identity is tied to 'sym1'.\nlet sym3: typeof sym1 = sym1;\n \n// Also works.\nclass C {\n  static readonly StaticSymbol: unique symbol = Symbol();\n}\n```\n\nBecause each `unique symbol` has a completely separate identity, no two `unique symbol` types are assignable or comparable to each other.\n\n``` ts\nconst sym2 = Symbol();\nconst sym3 = Symbol();\n \nif (sym2 === sym3) {\n  // ...\n}\n```\n\n## Well-known Symbols\n\nIn addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.\n\nHere is a list of well-known symbols:\n\n### `Symbol.asyncIterator`\n\nA method that returns async iterator for an object, compatible to be used with for await..of loop.\n\n### `Symbol.hasInstance`\n\nA method that determines if a constructor object recognizes an object as one of the constructor’s instances. Called by the semantics of the instanceof operator.\n\n### `Symbol.isConcatSpreadable`\n\nA Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat.\n\n### `Symbol.iterator`\n\nA method that returns the default iterator for an object. Called by the semantics of the for-of statement.\n\n### `Symbol.match`\n\nA regular expression method that matches the regular expression against a string. Called by the `String.prototype.match` method.\n\n### `Symbol.replace`\n\nA regular expression method that replaces matched substrings of a string. Called by the `String.prototype.replace` method.\n\n### `Symbol.search`\n\nA regular expression method that returns the index within a string that matches the regular expression. Called by the `String.prototype.search` method.\n\n### `Symbol.species`\n\nA function valued property that is the constructor function that is used to create derived objects.\n\n### `Symbol.split`\n\nA regular expression method that splits a string at the indices that match the regular expression. Called by the `String.prototype.split` method.\n\n### `Symbol.toPrimitive`\n\nA method that converts an object to a corresponding primitive value. Called by the `ToPrimitive` abstract operation.\n\n### `Symbol.toStringTag`\n\nA String value that is used in the creation of the default string description of an object. Called by the built-in method `Object.prototype.toString`.\n\n### `Symbol.unscopables`\n\nAn Object whose own property names are property names that are excluded from the ‘with’ environment bindings of the associated objects.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/symbols.html](https://www.typescriptlang.org/docs/handbook/symbols.html)"
- name: 'Symbols: Symbol.asyncIterator'
  id: symbols#symbolasynciterator
  summary: A method that returns async iterator for an object, compatible to be used with for await..of loop
  belongs_to: Symbols
  description: |-
    ### `Symbol.asyncIterator`

    A method that returns async iterator for an object, compatible to be used with for await..of loop.
- name: 'Symbols: Symbol.hasInstance'
  id: symbols#symbolhasinstance
  summary: A method that determines if a constructor object recognizes an object as one of the constructor’s instances
  belongs_to: Symbols
  description: |-
    ### `Symbol.hasInstance`

    A method that determines if a constructor object recognizes an object as one of the constructor’s instances. Called by the semantics of the instanceof operator.
- name: 'Symbols: Symbol.isConcatSpreadable'
  id: symbols#symbolisconcatspreadable
  summary: A Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat
  belongs_to: Symbols
  description: |-
    ### `Symbol.isConcatSpreadable`

    A Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat.
- name: 'Symbols: Symbol.iterator'
  id: symbols#symboliterator
  summary: A method that returns the default iterator for an object
  belongs_to: Symbols
  description: |-
    ### `Symbol.iterator`

    A method that returns the default iterator for an object. Called by the semantics of the for-of statement.
- name: 'Symbols: Symbol.match'
  id: symbols#symbolmatch
  summary: A regular expression method that matches the regular expression against a string
  belongs_to: Symbols
  description: |-
    ### `Symbol.match`

    A regular expression method that matches the regular expression against a string. Called by the `String.prototype.match` method.
- name: 'Symbols: Symbol.replace'
  id: symbols#symbolreplace
  summary: A regular expression method that replaces matched substrings of a string
  belongs_to: Symbols
  description: |-
    ### `Symbol.replace`

    A regular expression method that replaces matched substrings of a string. Called by the `String.prototype.replace` method.
- name: 'Symbols: Symbol.search'
  id: symbols#symbolsearch
  summary: A regular expression method that returns the index within a string that matches the regular expression
  belongs_to: Symbols
  description: |-
    ### `Symbol.search`

    A regular expression method that returns the index within a string that matches the regular expression. Called by the `String.prototype.search` method.
- name: 'Symbols: Symbol.species'
  id: symbols#symbolspecies
  summary: A function valued property that is the constructor function that is used to create derived objects
  belongs_to: Symbols
  description: |-
    ### `Symbol.species`

    A function valued property that is the constructor function that is used to create derived objects.
- name: 'Symbols: Symbol.split'
  id: symbols#symbolsplit
  summary: A regular expression method that splits a string at the indices that match the regular expression
  belongs_to: Symbols
  description: |-
    ### `Symbol.split`

    A regular expression method that splits a string at the indices that match the regular expression. Called by the `String.prototype.split` method.
- name: 'Symbols: Symbol.toPrimitive'
  id: symbols#symboltoprimitive
  summary: A method that converts an object to a corresponding primitive value
  belongs_to: Symbols
  description: |-
    ### `Symbol.toPrimitive`

    A method that converts an object to a corresponding primitive value. Called by the `ToPrimitive` abstract operation.
- name: 'Symbols: Symbol.toStringTag'
  id: symbols#symboltostringtag
  summary: A String value that is used in the creation of the default string description of an object
  belongs_to: Symbols
  description: |-
    ### `Symbol.toStringTag`

    A String value that is used in the creation of the default string description of an object. Called by the built-in method `Object.prototype.toString`.
- name: 'Symbols: Symbol.unscopables'
  id: symbols#symbolunscopables
  summary: An Object whose own property names are property names that are excluded from the ‘with’ environment bindings of the associated objects
  belongs_to: Symbols
  description: "### `Symbol.unscopables`\n\nAn Object whose own property names are property names that are excluded from the ‘with’ environment bindings of the associated objects.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/symbols.html](https://www.typescriptlang.org/docs/handbook/symbols.html)"
- name: 'Symbols: unique symbol'
  id: symbols#unique-symbol
  summary: To enable treating symbols as unique literals a special type unique symbol is available
  belongs_to: Symbols
  description: |-
    ## `unique symbol`

    To enable treating symbols as unique literals a special type `unique symbol` is available. `unique symbol` is a subtype of `symbol`, and are produced only from calling `Symbol()` or `Symbol.for()`, or from explicit type annotations. This type is only allowed on `const` declarations and `readonly static` properties, and in order to reference a specific unique symbol, you’ll have to use the `typeof` operator. Each reference to a unique symbol implies a completely unique identity that’s tied to a given declaration.

    ``` ts
    declare const sym1: unique symbol;
     
    // sym2 can only be a constant reference.
    let sym2: unique symbol = Symbol();
     
    // Works - refers to a unique symbol, but its identity is tied to 'sym1'.
    let sym3: typeof sym1 = sym1;
     
    // Also works.
    class C {
      static readonly StaticSymbol: unique symbol = Symbol();
    }
    ```

    Because each `unique symbol` has a completely separate identity, no two `unique symbol` types are assignable or comparable to each other.

    ``` ts
    const sym2 = Symbol();
    const sym3 = Symbol();
     
    if (sym2 === sym3) {
      // ...
    }
    ```
- name: 'Symbols: Well-known Symbols'
  id: symbols#well-known-symbols
  summary: In addition to user-defined symbols, there are well-known built-in symbols
  belongs_to: Symbols
  description: |-
    ## Well-known Symbols

    In addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.

    Here is a list of well-known symbols:
- name: synchronousWatchDirectory
  id: tsconfig/index#watch-synchronousWatchDirectory-config
  summary: Synchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Synchronous Watch Directory - `synchronousWatchDirectory`

    Synchronously call callbacks and update the state of directory watchers on platforms that don\`t support recursive watching natively. Instead of giving a small timeout to allow for potentially multiple edits to occur on a file.

    ``` typescript
    {
      "watchOptions": {
        "synchronousWatchDirectory": true
      }
    }
    ```
- name: synchronousWatchDirectory
  id: tsconfig#watch-synchronousWatchDirectory-config
  summary: Synchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively
  belongs_to: TSConfig Reference
  description: |-
    ### Synchronous Watch Directory - `synchronousWatchDirectory`

    Synchronously call callbacks and update the state of directory watchers on platforms that don\`t support recursive watching natively. Instead of giving a small timeout to allow for potentially multiple edits to occur on a file.

    ``` typescript
    {
      "watchOptions": {
        "synchronousWatchDirectory": true
      }
    }
    ```
- name: target
  id: tsconfig/index#target-config
  summary: Modern browsers support all ES6 features, so ES6 is a good choice
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Target - `target`

    Modern browsers support all ES6 features, so `ES6` is a good choice. You might choose to set a lower target if your code is deployed to older environments, or a higher target if your code is guaranteed to run in newer environments.

    The `target` setting changes which JS features are downleveled and which are left intact. For example, an arrow function `() => this` will be turned into an equivalent `function` expression if `target` is ES5 or lower.

    Changing `target` also changes the default value of [`lib`](#lib). You may “mix and match” `target` and `lib` settings as desired, but you could just set `target` for convenience.

    For developer platforms like Node there are baselines for the `target`, depending on the type of platform and its version. You can find a set of community organized TSConfigs at [tsconfig/bases](https://github.com/tsconfig/bases#centralized-recommendations-for-tsconfig-bases), which has configurations for common platforms and their versions.

    The special `ESNext` value refers to the highest version your version of TypeScript supports. This setting should be used with caution, since it doesn’t mean the same thing between different TypeScript versions and can make upgrades less predictable.

    - Default:

      `ES3`

    - Allowed:
      - `es3`

      - `es5`

      - `es6`/`es2015`

      - `es2016`

      - `es2017`

      - `es2018`

      - `es2019`

      - `es2020`

      - `es2021`

      - `es2022`

      - `es2023`

      - `esnext`

    - Released:

      [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)
- name: target
  id: tsconfig#target-config
  summary: Modern browsers support all ES6 features, so ES6 is a good choice
  belongs_to: TSConfig Reference
  description: |-
    ### Target - `target`

    Modern browsers support all ES6 features, so `ES6` is a good choice. You might choose to set a lower target if your code is deployed to older environments, or a higher target if your code is guaranteed to run in newer environments.

    The `target` setting changes which JS features are downleveled and which are left intact. For example, an arrow function `() => this` will be turned into an equivalent `function` expression if `target` is ES5 or lower.

    Changing `target` also changes the default value of [`lib`](#lib). You may “mix and match” `target` and `lib` settings as desired, but you could just set `target` for convenience.

    For developer platforms like Node there are baselines for the `target`, depending on the type of platform and its version. You can find a set of community organized TSConfigs at [tsconfig/bases](https://github.com/tsconfig/bases#centralized-recommendations-for-tsconfig-bases), which has configurations for common platforms and their versions.

    The special `ESNext` value refers to the highest version your version of TypeScript supports. This setting should be used with caution, since it doesn’t mean the same thing between different TypeScript versions and can make upgrades less predictable.

    - Default:

      `ES3`

    - Allowed:
      - `es3`

      - `es5`

      - `es6`/`es2015`

      - `es2016`

      - `es2017`

      - `es2018`

      - `es2019`

      - `es2020`

      - `es2021`

      - `es2022`

      - `es2023`

      - `esnext`

    - Released:

      [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)
- name: Template Literal Types
  id: 2/template-literal-types
  summary: Template literal types build on string literal types, and have the ability to expand into many strings via unions
  description: "# Template Literal Types\n\nTemplate literal types build on [string literal types](everyday-types#literal-types), and have the ability to expand into many strings via unions.\n\nThey have the same syntax as [template literal strings in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals), but are used in type positions. When used with concrete literal types, a template literal produces a new string literal type by concatenating the contents.\n\n``` ts\ntype World = \"world\";\n \ntype Greeting = `hello ${World}`;\n```\n\nWhen a union is used in the interpolated position, the type is the set of every possible string literal that could be represented by each union member:\n\n``` ts\ntype EmailLocaleIDs = \"welcome_email\" | \"email_heading\";\ntype FooterLocaleIDs = \"footer_title\" | \"footer_sendoff\";\n \ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;\n```\n\nFor each interpolated position in the template literal, the unions are cross multiplied:\n\n``` ts\ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;\ntype Lang = \"en\" | \"ja\" | \"pt\";\n \ntype LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;\n```\n\nWe generally recommend that people use ahead-of-time generation for large string unions, but this is useful in smaller cases.\n\n### String Unions in Types\n\nThe power in template literals comes when defining a new string based on information inside a type.\n\nConsider the case where a function (`makeWatchedObject`) adds a new function called `on()` to a passed object. In JavaScript, its call might look like: `makeWatchedObject(baseObject)`. We can imagine the base object as looking like:\n\n``` ts\nconst passedObject = {\n  firstName: \"Saoirse\",\n  lastName: \"Ronan\",\n  age: 26,\n};\n```\n\nThe `on` function that will be added to the base object expects two arguments, an `eventName` (a `string`) and a `callback` (a `function`).\n\nThe `eventName` should be of the form `attributeInThePassedObject + \"Changed\"`; thus, `firstNameChanged` as derived from the attribute `firstName` in the base object.\n\nThe `callback` function, when called:\n\n- Should be passed a value of the type associated with the name `attributeInThePassedObject`; thus, since `firstName` is typed as `string`, the callback for the `firstNameChanged` event expects a `string` to be passed to it at call time. Similarly events associated with `age` should expect to be called with a `number` argument\n- Should have `void` return type (for simplicity of demonstration)\n\nThe naive function signature of `on()` might thus be: `on(eventName: string, callback: (newValue: any) => void)`. However, in the preceding description, we identified important type constraints that we’d like to document in our code. Template Literal types let us bring these constraints into our code.\n\n``` ts\nconst person = makeWatchedObject({\n  firstName: \"Saoirse\",\n  lastName: \"Ronan\",\n  age: 26,\n});\n \n// makeWatchedObject has added `on` to the anonymous Object\n \nperson.on(\"firstNameChanged\", (newValue) => {\n  console.log(`firstName was changed to ${newValue}!`);\n});\n```\n\nNotice that `on` listens on the event `\"firstNameChanged\"`, not just `\"firstName\"`. Our naive specification of `on()` could be made more robust if we were to ensure that the set of eligible event names was constrained by the union of attribute names in the watched object with “Changed” added at the end. While we are comfortable with doing such a calculation in JavaScript i.e. `` Object.keys(passedObject).map(x => `${x}Changed`) ``, template literals *inside the type system* provide a similar approach to string manipulation:\n\n``` ts\ntype PropEventSource<Type> = {\n    on(eventName: `${string & keyof Type}Changed`, callback: (newValue: any) => void): void;\n};\n \n/// Create a \"watched object\" with an `on` method\n/// so that you can watch for changes to properties.\ndeclare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;\n```\n\nWith this, we can build something that errors when given the wrong property:\n\n``` ts\nconst person = makeWatchedObject({\n  firstName: \"Saoirse\",\n  lastName: \"Ronan\",\n  age: 26\n});\n \nperson.on(\"firstNameChanged\", () => {});\n \n// Prevent easy human error (using the key instead of the event name)\nperson.on(\"firstName\", () => {});\n \n// It's typo-resistant\nperson.on(\"frstNameChanged\", () => {});\n```\n\n### Inference with Template Literals\n\nNotice that we did not benefit from all the information provided in the original passed object. Given change of a `firstName` (i.e. a `firstNameChanged` event), we should expect that the callback will receive an argument of type `string`. Similarly, the callback for a change to `age` should receive a `number` argument. We’re naively using `any` to type the `callback`’s argument. Again, template literal types make it possible to ensure an attribute’s data type will be the same type as that attribute’s callback’s first argument.\n\nThe key insight that makes this possible is this: we can use a function with a generic such that:\n\n1.  The literal used in the first argument is captured as a literal type\n2.  That literal type can be validated as being in the union of valid attributes in the generic\n3.  The type of the validated attribute can be looked up in the generic’s structure using Indexed Access\n4.  This typing information can *then* be applied to ensure the argument to the callback function is of the same type\n\n``` ts\ntype PropEventSource<Type> = {\n    on<Key extends string & keyof Type>\n        (eventName: `${Key}Changed`, callback: (newValue: Type[Key]) => void): void;\n};\n \ndeclare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;\n \nconst person = makeWatchedObject({\n  firstName: \"Saoirse\",\n  lastName: \"Ronan\",\n  age: 26\n});\n \nperson.on(\"firstNameChanged\", newName => {\n    console.log(`new name is ${newName.toUpperCase()}`);\n});\n \nperson.on(\"ageChanged\", newAge => {\n    if (newAge < 0) {\n        console.warn(\"warning! negative age\");\n    }\n})\n```\n\nHere we made `on` into a generic method.\n\nWhen a user calls with the string `\"firstNameChanged\"`, TypeScript will try to infer the right type for `Key`. To do that, it will match `Key` against the content before `\"Changed\"` and infer the string `\"firstName\"`. Once TypeScript figures that out, the `on` method can fetch the type of `firstName` on the original object, which is `string` in this case. Similarly, when called with `\"ageChanged\"`, TypeScript finds the type for the property `age` which is `number`.\n\nInference can be combined in different ways, often to deconstruct strings, and reconstruct them in different ways.\n\n## Intrinsic String Manipulation Types\n\nTo help with string manipulation, TypeScript includes a set of types which can be used in string manipulation. These types come built-in to the compiler for performance and can’t be found in the `.d.ts` files included with TypeScript.\n\n### `Uppercase<StringType>`\n\nConverts each character in the string to the uppercase version.\n\n##### Example\n\n``` ts\ntype Greeting = \"Hello, world\"\ntype ShoutyGreeting = Uppercase<Greeting>\n \ntype ASCIICacheKey<Str extends string> = `ID-${Uppercase<Str>}`\ntype MainID = ASCIICacheKey<\"my_app\">\n```\n\n### `Lowercase<StringType>`\n\nConverts each character in the string to the lowercase equivalent.\n\n##### Example\n\n``` ts\ntype Greeting = \"Hello, world\"\ntype QuietGreeting = Lowercase<Greeting>\n \ntype ASCIICacheKey<Str extends string> = `id-${Lowercase<Str>}`\ntype MainID = ASCIICacheKey<\"MY_APP\">\n```\n\n### `Capitalize<StringType>`\n\nConverts the first character in the string to an uppercase equivalent.\n\n##### Example\n\n``` ts\ntype LowercaseGreeting = \"hello, world\";\ntype Greeting = Capitalize<LowercaseGreeting>;\n```\n\n### `Uncapitalize<StringType>`\n\nConverts the first character in the string to a lowercase equivalent.\n\n##### Example\n\n``` ts\ntype UppercaseGreeting = \"HELLO WORLD\";\ntype UncomfortableGreeting = Uncapitalize<UppercaseGreeting>;\n```\n\nTechnical details on the intrinsic string manipulation types\n\nThe code, as of TypeScript 4.1, for these intrinsic functions uses the JavaScript string runtime functions directly for manipulation and are not locale aware.\n\n``` typescript\nfunction applyStringMapping(symbol: Symbol, str: string) {\n    switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {\n        case IntrinsicTypeKind.Uppercase: return str.toUpperCase();\n        case IntrinsicTypeKind.Lowercase: return str.toLowerCase();\n        case IntrinsicTypeKind.Capitalize: return str.charAt(0).toUpperCase() + str.slice(1);\n        case IntrinsicTypeKind.Uncapitalize: return str.charAt(0).toLowerCase() + str.slice(1);\n    }\n    return str;\n}\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)"
- name: 'Template Literal Types: Capitalize<StringType>'
  id: 2/template-literal-types#capitalizestringtype
  summary: Converts the first character in the string to an uppercase equivalent
  belongs_to: Template Literal Types
  description: |-
    ### `Capitalize<StringType>`

    Converts the first character in the string to an uppercase equivalent.

    ##### Example

    ``` ts
    type LowercaseGreeting = "hello, world";
    type Greeting = Capitalize<LowercaseGreeting>;
    ```
- name: 'Template Literal Types: Intrinsic String Manipulation Types'
  id: 2/template-literal-types#intrinsic-string-manipulation-types
  summary: To help with string manipulation, TypeScript includes a set of types which can be used in string manipulation
  belongs_to: Template Literal Types
  description: |-
    ## Intrinsic String Manipulation Types

    To help with string manipulation, TypeScript includes a set of types which can be used in string manipulation. These types come built-in to the compiler for performance and can’t be found in the `.d.ts` files included with TypeScript.
- name: 'Template Literal Types: Lowercase<StringType>'
  id: 2/template-literal-types#lowercasestringtype
  summary: Converts each character in the string to the lowercase equivalent
  belongs_to: Template Literal Types
  description: |-
    ### `Lowercase<StringType>`

    Converts each character in the string to the lowercase equivalent.

    ##### Example

    ``` ts
    type Greeting = "Hello, world"
    type QuietGreeting = Lowercase<Greeting>
     
    type ASCIICacheKey<Str extends string> = `id-${Lowercase<Str>}`
    type MainID = ASCIICacheKey<"MY_APP">
    ```
- name: 'Template Literal Types: Uncapitalize<StringType>'
  id: 2/template-literal-types#uncapitalizestringtype
  summary: Converts the first character in the string to a lowercase equivalent
  belongs_to: Template Literal Types
  description: "### `Uncapitalize<StringType>`\n\nConverts the first character in the string to a lowercase equivalent.\n\n##### Example\n\n``` ts\ntype UppercaseGreeting = \"HELLO WORLD\";\ntype UncomfortableGreeting = Uncapitalize<UppercaseGreeting>;\n```\n\nTechnical details on the intrinsic string manipulation types\n\nThe code, as of TypeScript 4.1, for these intrinsic functions uses the JavaScript string runtime functions directly for manipulation and are not locale aware.\n\n``` typescript\nfunction applyStringMapping(symbol: Symbol, str: string) {\n    switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {\n        case IntrinsicTypeKind.Uppercase: return str.toUpperCase();\n        case IntrinsicTypeKind.Lowercase: return str.toLowerCase();\n        case IntrinsicTypeKind.Capitalize: return str.charAt(0).toUpperCase() + str.slice(1);\n        case IntrinsicTypeKind.Uncapitalize: return str.charAt(0).toLowerCase() + str.slice(1);\n    }\n    return str;\n}\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)"
- name: 'Template Literal Types: Uppercase<StringType>'
  id: 2/template-literal-types#uppercasestringtype
  summary: Converts each character in the string to the uppercase version
  belongs_to: Template Literal Types
  description: |-
    ### `Uppercase<StringType>`

    Converts each character in the string to the uppercase version.

    ##### Example

    ``` ts
    type Greeting = "Hello, world"
    type ShoutyGreeting = Uppercase<Greeting>
     
    type ASCIICacheKey<Str extends string> = `ID-${Uppercase<Str>}`
    type MainID = ASCIICacheKey<"my_app">
    ```
- name: Templates
  id: declaration-files/templates
  summary: © 2012-2024 Microsoft Licensed under the Apache License, Version 2.0
  description: "# Templates\n\n[global-modifying-module.d.ts](https://www.typescriptlang.org/3ed761a6c3f38d73aadf745e7454f74d/global-modifying-module.d.ts.md)\n\n- [global-plugin.d.ts](templates/global-plugin-d-ts)\n- [global.d.ts](templates/global-d-ts)\n- [module-class.d.ts](templates/module-class-d-ts)\n- [module-function.d.ts](templates/module-function-d-ts)\n- [module-plugin.d.ts](templates/module-plugin-d-ts)\n- [module.d.ts](templates/module-d-ts)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html](https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html)"
- name: The Basics
  id: 2/basic-types
  summary: Each and every value in JavaScript has a set of behaviors you can observe from running different operations
  description: "# The Basics\n\nEach and every value in JavaScript has a set of behaviors you can observe from running different operations. That sounds abstract, but as a quick example, consider some operations we might run on a variable named `message`.\n\n``` js\n// Accessing the property 'toLowerCase'\n// on 'message' and then calling it\nmessage.toLowerCase();\n\n// Calling 'message'\nmessage();\n```\n\nIf we break this down, the first runnable line of code accesses a property called `toLowerCase` and then calls it. The second one tries to call `message` directly.\n\nBut assuming we don’t know the value of `message` - and that’s pretty common - we can’t reliably say what results we’ll get from trying to run any of this code. The behavior of each operation depends entirely on what value we had in the first place.\n\n- Is `message` callable?\n- Does it have a property called `toLowerCase` on it?\n- If it does, is `toLowerCase` even callable?\n- If both of these values are callable, what do they return?\n\nThe answers to these questions are usually things we keep in our heads when we write JavaScript, and we have to hope we got all the details right.\n\nLet’s say `message` was defined in the following way.\n\n``` js\nconst message = \"Hello World!\";\n```\n\nAs you can probably guess, if we try to run `message.toLowerCase()`, we’ll get the same string only in lower-case.\n\nWhat about that second line of code? If you’re familiar with JavaScript, you’ll know this fails with an exception:\n\n``` txt\nTypeError: message is not a function\n```\n\nIt’d be great if we could avoid mistakes like this.\n\nWhen we run our code, the way that our JavaScript runtime chooses what to do is by figuring out the *type* of the value - what sorts of behaviors and capabilities it has. That’s part of what that `TypeError` is alluding to - it’s saying that the string `\"Hello World!\"` cannot be called as a function.\n\nFor some values, such as the primitives `string` and `number`, we can identify their type at runtime using the `typeof` operator. But for other things like functions, there’s no corresponding runtime mechanism to identify their types. For example, consider this function:\n\n``` js\nfunction fn(x) {\n  return x.flip();\n}\n```\n\nWe can *observe* by reading the code that this function will only work if given an object with a callable `flip` property, but JavaScript doesn’t surface this information in a way that we can check while the code is running. The only way in pure JavaScript to tell what `fn` does with a particular value is to call it and see what happens. This kind of behavior makes it hard to predict what the code will do before it runs, which means it’s harder to know what your code is going to do while you’re writing it.\n\nSeen in this way, a *type* is the concept of describing which values can be passed to `fn` and which will crash. JavaScript only truly provides *dynamic* typing - running the code to see what happens.\n\nThe alternative is to use a *static* type system to make predictions about what the code is expected to do *before* it runs.\n\n## Static type-checking\n\nThink back to that `TypeError` we got earlier from trying to call a `string` as a function. *Most people* don’t like to get any sorts of errors when running their code - those are considered bugs! And when we write new code, we try our best to avoid introducing new bugs.\n\nIf we add just a bit of code, save our file, re-run the code, and immediately see the error, we might be able to isolate the problem quickly; but that’s not always the case. We might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown! Or if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that we’re forced to dig through.\n\nIdeally, we could have a tool that helps us find these bugs *before* our code runs. That’s what a static type-checker like TypeScript does. *Static types systems* describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails.\n\n``` ts\nconst message = \"hello!\";\n \nmessage();\n```\n\nRunning that last sample with TypeScript will give us an error message before we run the code in the first place.\n\n## Non-exception Failures\n\nSo far we’ve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical. Those cases come up because [the ECMAScript specification](https://tc39.github.io/ecma262/) has explicit instructions on how the language should behave when it runs into something unexpected.\n\nFor example, the specification says that trying to call something that isn’t callable should throw an error. Maybe that sounds like “obvious behavior”, but you could imagine that accessing a property that doesn’t exist on an object should throw an error too. Instead, JavaScript gives us different behavior and returns the value `undefined`:\n\n``` js\nconst user = {\n  name: \"Daniel\",\n  age: 26,\n};\n\nuser.location; // returns undefined\n```\n\nUltimately, a static type system has to make the call over what code should be flagged as an error in its system, even if it’s “valid” JavaScript that won’t immediately throw an error. In TypeScript, the following code produces an error about `location` not being defined:\n\n``` ts\nconst user = {\n  name: \"Daniel\",\n  age: 26,\n};\n \nuser.location;\n```\n\nWhile sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs. And TypeScript catches *a lot* of legitimate bugs.\n\nFor example: typos,\n\n``` ts\nconst announcement = \"Hello World!\";\n \n// How quickly can you spot the typos?\nannouncement.toLocaleLowercase();\nannouncement.toLocalLowerCase();\n \n// We probably meant to write this...\nannouncement.toLocaleLowerCase();\n```\n\nuncalled functions,\n\n``` ts\nfunction flipCoin() {\n  // Meant to be Math.random()\n  return Math.random < 0.5;\n}\n```\n\nor basic logic errors.\n\n``` ts\nconst value = Math.random() < 0.5 ? \"a\" : \"b\";\nif (value !== \"a\") {\n  // ...\n} else if (value === \"b\") {\n  // Oops, unreachable\n}\n```\n\n## Types for Tooling\n\nTypeScript can catch bugs when we make mistakes in our code. That’s great, but TypeScript can *also* prevent us from making those mistakes in the first place.\n\nThe type-checker has information to check things like whether we’re accessing the right properties on variables and other properties. Once it has that information, it can also start *suggesting* which properties you might want to use.\n\nThat means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor. That’s part of what people often refer to when they talk about tooling in TypeScript.\n\n``` ts\nimport express from \"express\";\nconst app = express();\n \napp.get(\"/\", function (req, res) {\n  res.sen\n});\n \napp.listen(3000);\n```\n\nTypeScript takes tooling seriously, and that goes beyond completions and errors as you type. An editor that supports TypeScript can deliver “quick fixes” to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable. All of this is built on top of the type-checker and is fully cross-platform, so it’s likely that [your favorite editor has TypeScript support available](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support).\n\n## `tsc`, the TypeScript compiler\n\nWe’ve been talking about type-checking, but we haven’t yet used our type-*checker*. Let’s get acquainted with our new friend `tsc`, the TypeScript compiler. First we’ll need to grab it via npm.\n\n``` shell\nnpm install -g typescript\n```\n\n> This installs the TypeScript Compiler `tsc` globally. You can use `npx` or similar tools if you’d prefer to run `tsc` from a local `node_modules` package instead.\n\nNow let’s move to an empty folder and try writing our first TypeScript program: `hello.ts`:\n\n``` ts\n// Greets the world.\nconsole.log(\"Hello world!\");\n```\n\nNotice there are no frills here; this “hello world” program looks identical to what you’d write for a “hello world” program in JavaScript. And now let’s type-check it by running the command `tsc` which was installed for us by the `typescript` package.\n\n``` shell\ntsc hello.ts\n```\n\nTada!\n\nWait, “tada” *what* exactly? We ran `tsc` and nothing happened! Well, there were no type errors, so we didn’t get any output in our console since there was nothing to report.\n\nBut check again - we got some *file* output instead. If we look in our current directory, we’ll see a `hello.js` file next to `hello.ts`. That’s the output from our `hello.ts` file after `tsc` *compiles* or *transforms* it into a plain JavaScript file. And if we check the contents, we’ll see what TypeScript spits out after it processes a `.ts` file:\n\n``` js\n// Greets the world.\nconsole.log(\"Hello world!\");\n```\n\nIn this case, there was very little for TypeScript to transform, so it looks identical to what we wrote. The compiler tries to emit clean readable code that looks like something a person would write. While that’s not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around.\n\nWhat about if we *did* introduce a type-checking error? Let’s rewrite `hello.ts`:\n\n``` ts\n// This is an industrial-grade general-purpose greeter function:\nfunction greet(person, date) {\n  console.log(`Hello ${person}, today is ${date}!`);\n}\n \ngreet(\"Brendan\");\n```\n\nIf we run `tsc hello.ts` again, notice that we get an error on the command line!\n\n``` txt\nExpected 2 arguments, but got 1.\n```\n\nTypeScript is telling us we forgot to pass an argument to the `greet` function, and rightfully so. So far we’ve only written standard JavaScript, and yet type-checking was still able to find problems with our code. Thanks TypeScript!\n\n## Emitting with Errors\n\nOne thing you might not have noticed from the last example was that our `hello.js` file changed again. If we open that file up then we’ll see that the contents still basically look the same as our input file. That might be a bit surprising given the fact that `tsc` reported an error about our code, but this is based on one of TypeScript’s core values: much of the time, *you* will know better than TypeScript.\n\nTo reiterate from earlier, type-checking code limits the sorts of programs you can run, and so there’s a tradeoff on what sorts of things a type-checker finds acceptable. Most of the time that’s okay, but there are scenarios where those checks get in the way. For example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors. Eventually you’ll get around to cleaning things up for the type-checker, but that original JavaScript code was already working! Why should converting it over to TypeScript stop you from running it?\n\nSo TypeScript doesn’t get in your way. Of course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly. In that case, you can use the [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) compiler option. Try changing your `hello.ts` file and running `tsc` with that flag:\n\n``` shell\ntsc --noEmitOnError hello.ts\n```\n\nYou’ll notice that `hello.js` never gets updated.\n\n## Explicit Types\n\nUp until now, we haven’t told TypeScript what `person` or `date` are. Let’s edit the code to tell TypeScript that `person` is a `string`, and that `date` should be a `Date` object. We’ll also use the `toDateString()` method on `date`.\n\n``` ts\nfunction greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\n```\n\nWhat we did was add *type annotations* on `person` and `date` to describe what types of values `greet` can be called with. You can read that signature as ”`greet` takes a `person` of type `string`, and a `date` of type `Date`“.\n\nWith this, TypeScript can tell us about other cases where `greet` might have been called incorrectly. For example…\n\n``` ts\nfunction greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\n \ngreet(\"Maddison\", Date());\n```\n\nHuh? TypeScript reported an error on our second argument, but why?\n\nPerhaps surprisingly, calling `Date()` in JavaScript returns a `string`. On the other hand, constructing a `Date` with `new Date()` actually gives us what we were expecting.\n\nAnyway, we can quickly fix up the error:\n\n``` ts\nfunction greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\n \ngreet(\"Maddison\", new Date());\n```\n\nKeep in mind, we don’t always have to write explicit type annotations. In many cases, TypeScript can even just *infer* (or “figure out”) the types for us even if we omit them.\n\n``` ts\nlet msg = \"hello there!\";\n```\n\nEven though we didn’t tell TypeScript that `msg` had the type `string` it was able to figure that out. That’s a feature, and it’s best not to add annotations when the type system would end up inferring the same type anyway.\n\n> Note: The message bubble inside the previous code sample is what your editor would show if you had hovered over the word.\n\n## Erased Types\n\nLet’s take a look at what happens when we compile the above function `greet` with `tsc` to output JavaScript:\n\n``` ts\n\"use strict\";\nfunction greet(person, date) {\n    console.log(\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\"));\n}\ngreet(\"Maddison\", new Date());\n \n```\n\nNotice two things here:\n\n1.  Our `person` and `date` parameters no longer have type annotations.\n2.  Our “template string” - that string that used backticks (the `` ` `` character) - was converted to plain strings with concatenations.\n\nMore on that second point later, but let’s now focus on that first point. Type annotations aren’t part of JavaScript (or ECMAScript to be pedantic), so there really aren’t any browsers or other runtimes that can just run TypeScript unmodified. That’s why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it. Most TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased.\n\n> **Remember**: Type annotations never change the runtime behavior of your program.\n\n## Downleveling\n\nOne other difference from the above was that our template string was rewritten from\n\n``` js\n`Hello ${person}, today is ${date.toDateString()}!`;\n```\n\nto\n\n``` js\n\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\");\n```\n\nWhy did this happen?\n\nTemplate strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - *don’t ask*). TypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES3 and ES5). This process of moving from a newer or “higher” version of ECMAScript down to an older or “lower” one is sometimes called *downleveling*.\n\nBy default TypeScript targets ES3, an extremely old version of ECMAScript. We could have chosen something a little bit more recent by using the [`target`](https://www.typescriptlang.org/tsconfig#target) option. Running with `--target es2015` changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported. So running `tsc --target es2015 hello.ts` gives us the following output:\n\n``` js\nfunction greet(person, date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\ngreet(\"Maddison\", new Date());\n```\n\n> While the default target is ES3, the great majority of current browsers support ES2015. Most developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important.\n\n## Strictness\n\nDifferent users come to TypeScript looking for different things in a type-checker. Some people are looking for a more loose opt-in experience which can help validate only some parts of their program, and still have decent tooling. This is the default experience with TypeScript, where types are optional, inference takes the most lenient types, and there’s no checking for potentially `null`/`undefined` values. Much like how `tsc` emits in the face of errors, these defaults are put in place to stay out of your way. If you’re migrating existing JavaScript, that might be a desirable first step.\n\nIn contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and that’s why the language provides strictness settings as well. These strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial. The further you turn this dial up, the more TypeScript will check for you. This can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling. When possible, a new codebase should always turn these strictness checks on.\n\nTypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples will be written with all of them enabled unless otherwise stated. The [`strict`](https://www.typescriptlang.org/tsconfig#strict) flag in the CLI, or `\"strict\": true` in a [`tsconfig.json`](../tsconfig-json) toggles them all on simultaneously, but we can opt out of them individually. The two biggest ones you should know about are [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) and [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks).\n\n## `noImplicitAny`\n\nRecall that in some places, TypeScript doesn’t try to infer types for us and instead falls back to the most lenient type: `any`. This isn’t the worst thing that can happen - after all, falling back to `any` is just the plain JavaScript experience anyway.\n\nHowever, using `any` often defeats the purpose of using TypeScript in the first place. The more typed your program is, the more validation and tooling you’ll get, meaning you’ll run into fewer bugs as you code. Turning on the [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) flag will issue an error on any variables whose type is implicitly inferred as `any`.\n\n## `strictNullChecks`\n\nBy default, values like `null` and `undefined` are assignable to any other type. This can make writing some code easier, but forgetting to handle `null` and `undefined` is the cause of countless bugs in the world - some consider it a [billion dollar mistake](https://www.youtube.com/watch?v=ybrQvs4x0Ps)! The [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) flag makes handling `null` and `undefined` more explicit, and *spares* us from worrying about whether we *forgot* to handle `null` and `undefined`.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/basic-types.html](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)"
- name: 'The Basics: Downleveling'
  id: 2/basic-types#downleveling
  summary: Template strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a
  belongs_to: The Basics
  description: |-
    ## Downleveling

    One other difference from the above was that our template string was rewritten from

    ``` js
    `Hello ${person}, today is ${date.toDateString()}!`;
    ```

    to

    ``` js
    "Hello ".concat(person, ", today is ").concat(date.toDateString(), "!");
    ```

    Why did this happen?

    Template strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - *don’t ask*). TypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES3 and ES5). This process of moving from a newer or “higher” version of ECMAScript down to an older or “lower” one is sometimes called *downleveling*.

    By default TypeScript targets ES3, an extremely old version of ECMAScript. We could have chosen something a little bit more recent by using the [`target`](https://www.typescriptlang.org/tsconfig#target) option. Running with `--target es2015` changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported. So running `tsc --target es2015 hello.ts` gives us the following output:

    ``` js
    function greet(person, date) {
      console.log(`Hello ${person}, today is ${date.toDateString()}!`);
    }
    greet("Maddison", new Date());
    ```

    > While the default target is ES3, the great majority of current browsers support ES2015. Most developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important.
- name: 'The Basics: Emitting with Errors'
  id: 2/basic-types#emitting-with-errors
  summary: One thing you might not have noticed from the last example was that our hello.js file changed again
  belongs_to: The Basics
  description: |-
    ## Emitting with Errors

    One thing you might not have noticed from the last example was that our `hello.js` file changed again. If we open that file up then we’ll see that the contents still basically look the same as our input file. That might be a bit surprising given the fact that `tsc` reported an error about our code, but this is based on one of TypeScript’s core values: much of the time, *you* will know better than TypeScript.

    To reiterate from earlier, type-checking code limits the sorts of programs you can run, and so there’s a tradeoff on what sorts of things a type-checker finds acceptable. Most of the time that’s okay, but there are scenarios where those checks get in the way. For example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors. Eventually you’ll get around to cleaning things up for the type-checker, but that original JavaScript code was already working! Why should converting it over to TypeScript stop you from running it?

    So TypeScript doesn’t get in your way. Of course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly. In that case, you can use the [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError) compiler option. Try changing your `hello.ts` file and running `tsc` with that flag:

    ``` shell
    tsc --noEmitOnError hello.ts
    ```

    You’ll notice that `hello.js` never gets updated.
- name: 'The Basics: Erased Types'
  id: 2/basic-types#erased-types
  summary: More on that second point later, but let’s now focus on that first point
  belongs_to: The Basics
  description: |-
    ## Erased Types

    Let’s take a look at what happens when we compile the above function `greet` with `tsc` to output JavaScript:

    ``` ts
    "use strict";
    function greet(person, date) {
        console.log("Hello ".concat(person, ", today is ").concat(date.toDateString(), "!"));
    }
    greet("Maddison", new Date());
     
    ```

    Notice two things here:

    1.  Our `person` and `date` parameters no longer have type annotations.
    2.  Our “template string” - that string that used backticks (the `` ` `` character) - was converted to plain strings with concatenations.

    More on that second point later, but let’s now focus on that first point. Type annotations aren’t part of JavaScript (or ECMAScript to be pedantic), so there really aren’t any browsers or other runtimes that can just run TypeScript unmodified. That’s why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it. Most TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased.

    > **Remember**: Type annotations never change the runtime behavior of your program.
- name: 'The Basics: Explicit Types'
  id: 2/basic-types#explicit-types
  summary: Up until now, we haven’t told TypeScript what person or date are
  belongs_to: The Basics
  description: |-
    ## Explicit Types

    Up until now, we haven’t told TypeScript what `person` or `date` are. Let’s edit the code to tell TypeScript that `person` is a `string`, and that `date` should be a `Date` object. We’ll also use the `toDateString()` method on `date`.

    ``` ts
    function greet(person: string, date: Date) {
      console.log(`Hello ${person}, today is ${date.toDateString()}!`);
    }
    ```

    What we did was add *type annotations* on `person` and `date` to describe what types of values `greet` can be called with. You can read that signature as ”`greet` takes a `person` of type `string`, and a `date` of type `Date`“.

    With this, TypeScript can tell us about other cases where `greet` might have been called incorrectly. For example…

    ``` ts
    function greet(person: string, date: Date) {
      console.log(`Hello ${person}, today is ${date.toDateString()}!`);
    }
     
    greet("Maddison", Date());
    ```

    Huh? TypeScript reported an error on our second argument, but why?

    Perhaps surprisingly, calling `Date()` in JavaScript returns a `string`. On the other hand, constructing a `Date` with `new Date()` actually gives us what we were expecting.

    Anyway, we can quickly fix up the error:

    ``` ts
    function greet(person: string, date: Date) {
      console.log(`Hello ${person}, today is ${date.toDateString()}!`);
    }
     
    greet("Maddison", new Date());
    ```

    Keep in mind, we don’t always have to write explicit type annotations. In many cases, TypeScript can even just *infer* (or “figure out”) the types for us even if we omit them.

    ``` ts
    let msg = "hello there!";
    ```

    Even though we didn’t tell TypeScript that `msg` had the type `string` it was able to figure that out. That’s a feature, and it’s best not to add annotations when the type system would end up inferring the same type anyway.

    > Note: The message bubble inside the previous code sample is what your editor would show if you had hovered over the word.
- name: 'The Basics: noImplicitAny'
  id: 2/basic-types#noimplicitany
  summary: 'Recall that in some places, TypeScript doesn’t try to infer types for us and instead falls back to the most lenient type: any'
  belongs_to: The Basics
  description: |-
    ## `noImplicitAny`

    Recall that in some places, TypeScript doesn’t try to infer types for us and instead falls back to the most lenient type: `any`. This isn’t the worst thing that can happen - after all, falling back to `any` is just the plain JavaScript experience anyway.

    However, using `any` often defeats the purpose of using TypeScript in the first place. The more typed your program is, the more validation and tooling you’ll get, meaning you’ll run into fewer bugs as you code. Turning on the [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) flag will issue an error on any variables whose type is implicitly inferred as `any`.
- name: 'The Basics: Non-exception Failures'
  id: 2/basic-types#non-exception-failures
  summary: So far we’ve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical
  belongs_to: The Basics
  description: |-
    ## Non-exception Failures

    So far we’ve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical. Those cases come up because [the ECMAScript specification](https://tc39.github.io/ecma262/) has explicit instructions on how the language should behave when it runs into something unexpected.

    For example, the specification says that trying to call something that isn’t callable should throw an error. Maybe that sounds like “obvious behavior”, but you could imagine that accessing a property that doesn’t exist on an object should throw an error too. Instead, JavaScript gives us different behavior and returns the value `undefined`:

    ``` js
    const user = {
      name: "Daniel",
      age: 26,
    };

    user.location; // returns undefined
    ```

    Ultimately, a static type system has to make the call over what code should be flagged as an error in its system, even if it’s “valid” JavaScript that won’t immediately throw an error. In TypeScript, the following code produces an error about `location` not being defined:

    ``` ts
    const user = {
      name: "Daniel",
      age: 26,
    };
     
    user.location;
    ```

    While sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs. And TypeScript catches *a lot* of legitimate bugs.

    For example: typos,

    ``` ts
    const announcement = "Hello World!";
     
    // How quickly can you spot the typos?
    announcement.toLocaleLowercase();
    announcement.toLocalLowerCase();
     
    // We probably meant to write this...
    announcement.toLocaleLowerCase();
    ```

    uncalled functions,

    ``` ts
    function flipCoin() {
      // Meant to be Math.random()
      return Math.random < 0.5;
    }
    ```

    or basic logic errors.

    ``` ts
    const value = Math.random() < 0.5 ? "a" : "b";
    if (value !== "a") {
      // ...
    } else if (value === "b") {
      // Oops, unreachable
    }
    ```
- name: 'The Basics: Static type-checking'
  id: 2/basic-types#static-type-checking
  summary: Think back to that TypeError we got earlier from trying to call a string as a function
  belongs_to: The Basics
  description: |-
    ## Static type-checking

    Think back to that `TypeError` we got earlier from trying to call a `string` as a function. *Most people* don’t like to get any sorts of errors when running their code - those are considered bugs! And when we write new code, we try our best to avoid introducing new bugs.

    If we add just a bit of code, save our file, re-run the code, and immediately see the error, we might be able to isolate the problem quickly; but that’s not always the case. We might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown! Or if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that we’re forced to dig through.

    Ideally, we could have a tool that helps us find these bugs *before* our code runs. That’s what a static type-checker like TypeScript does. *Static types systems* describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails.

    ``` ts
    const message = "hello!";
     
    message();
    ```

    Running that last sample with TypeScript will give us an error message before we run the code in the first place.
- name: 'The Basics: Strictness'
  id: 2/basic-types#strictness
  summary: Different users come to TypeScript looking for different things in a type-checker
  belongs_to: The Basics
  description: |-
    ## Strictness

    Different users come to TypeScript looking for different things in a type-checker. Some people are looking for a more loose opt-in experience which can help validate only some parts of their program, and still have decent tooling. This is the default experience with TypeScript, where types are optional, inference takes the most lenient types, and there’s no checking for potentially `null`/`undefined` values. Much like how `tsc` emits in the face of errors, these defaults are put in place to stay out of your way. If you’re migrating existing JavaScript, that might be a desirable first step.

    In contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and that’s why the language provides strictness settings as well. These strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial. The further you turn this dial up, the more TypeScript will check for you. This can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling. When possible, a new codebase should always turn these strictness checks on.

    TypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples will be written with all of them enabled unless otherwise stated. The [`strict`](https://www.typescriptlang.org/tsconfig#strict) flag in the CLI, or `"strict": true` in a [`tsconfig.json`](../tsconfig-json) toggles them all on simultaneously, but we can opt out of them individually. The two biggest ones you should know about are [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) and [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks).
- name: 'The Basics: strictNullChecks'
  id: 2/basic-types#strictnullchecks
  summary: By default, values like null and undefined are assignable to any other type
  belongs_to: The Basics
  description: "## `strictNullChecks`\n\nBy default, values like `null` and `undefined` are assignable to any other type. This can make writing some code easier, but forgetting to handle `null` and `undefined` is the cause of countless bugs in the world - some consider it a [billion dollar mistake](https://www.youtube.com/watch?v=ybrQvs4x0Ps)! The [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) flag makes handling `null` and `undefined` more explicit, and *spares* us from worrying about whether we *forgot* to handle `null` and `undefined`.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/basic-types.html](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)"
- name: 'The Basics: tsc, the TypeScript compiler'
  id: 2/basic-types#tsc-the-typescript-compiler
  summary: We’ve been talking about type-checking, but we haven’t yet used our type-checker
  belongs_to: The Basics
  description: |-
    ## `tsc`, the TypeScript compiler

    We’ve been talking about type-checking, but we haven’t yet used our type-*checker*. Let’s get acquainted with our new friend `tsc`, the TypeScript compiler. First we’ll need to grab it via npm.

    ``` shell
    npm install -g typescript
    ```

    > This installs the TypeScript Compiler `tsc` globally. You can use `npx` or similar tools if you’d prefer to run `tsc` from a local `node_modules` package instead.

    Now let’s move to an empty folder and try writing our first TypeScript program: `hello.ts`:

    ``` ts
    // Greets the world.
    console.log("Hello world!");
    ```

    Notice there are no frills here; this “hello world” program looks identical to what you’d write for a “hello world” program in JavaScript. And now let’s type-check it by running the command `tsc` which was installed for us by the `typescript` package.

    ``` shell
    tsc hello.ts
    ```

    Tada!

    Wait, “tada” *what* exactly? We ran `tsc` and nothing happened! Well, there were no type errors, so we didn’t get any output in our console since there was nothing to report.

    But check again - we got some *file* output instead. If we look in our current directory, we’ll see a `hello.js` file next to `hello.ts`. That’s the output from our `hello.ts` file after `tsc` *compiles* or *transforms* it into a plain JavaScript file. And if we check the contents, we’ll see what TypeScript spits out after it processes a `.ts` file:

    ``` js
    // Greets the world.
    console.log("Hello world!");
    ```

    In this case, there was very little for TypeScript to transform, so it looks identical to what we wrote. The compiler tries to emit clean readable code that looks like something a person would write. While that’s not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around.

    What about if we *did* introduce a type-checking error? Let’s rewrite `hello.ts`:

    ``` ts
    // This is an industrial-grade general-purpose greeter function:
    function greet(person, date) {
      console.log(`Hello ${person}, today is ${date}!`);
    }
     
    greet("Brendan");
    ```

    If we run `tsc hello.ts` again, notice that we get an error on the command line!

    ``` txt
    Expected 2 arguments, but got 1.
    ```

    TypeScript is telling us we forgot to pass an argument to the `greet` function, and rightfully so. So far we’ve only written standard JavaScript, and yet type-checking was still able to find problems with our code. Thanks TypeScript!
- name: 'The Basics: Types for Tooling'
  id: 2/basic-types#types-for-tooling
  summary: TypeScript can catch bugs when we make mistakes in our code
  belongs_to: The Basics
  description: |-
    ## Types for Tooling

    TypeScript can catch bugs when we make mistakes in our code. That’s great, but TypeScript can *also* prevent us from making those mistakes in the first place.

    The type-checker has information to check things like whether we’re accessing the right properties on variables and other properties. Once it has that information, it can also start *suggesting* which properties you might want to use.

    That means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor. That’s part of what people often refer to when they talk about tooling in TypeScript.

    ``` ts
    import express from "express";
    const app = express();
     
    app.get("/", function (req, res) {
      res.sen
    });
     
    app.listen(3000);
    ```

    TypeScript takes tooling seriously, and that goes beyond completions and errors as you type. An editor that supports TypeScript can deliver “quick fixes” to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable. All of this is built on top of the type-checker and is fully cross-platform, so it’s likely that [your favorite editor has TypeScript support available](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support).
- name: The TypeScript Handbook
  id: intro
  summary: Over 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created
  description: "# The TypeScript Handbook\n\n## About this Handbook\n\nOver 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created. Starting as a small scripting language for adding trivial interactivity to webpages, JavaScript has grown to be a language of choice for both frontend and backend applications of every size. While the size, scope, and complexity of programs written in JavaScript has grown exponentially, the ability of the JavaScript language to express the relationships between different units of code has not. Combined with JavaScript’s rather peculiar runtime semantics, this mismatch between language and program complexity has made JavaScript development a difficult task to manage at scale.\n\nThe most common kinds of errors that programmers write can be described as type errors: a certain kind of value was used where a different kind of value was expected. This could be due to simple typos, a failure to understand the API surface of a library, incorrect assumptions about runtime behavior, or other errors. The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked).\n\nIf you are coming to TypeScript without a JavaScript background, with the intention of TypeScript being your first language, we recommend you first start reading the documentation on either the [Microsoft Learn JavaScript tutorial](https://developer.microsoft.com/javascript/) or read [JavaScript at the Mozilla Web Docs](https://developer.mozilla.org/docs/Web/JavaScript/Guide). If you have experience in other languages, you should be able to pick up JavaScript syntax quite quickly by reading the handbook.\n\n## How is this Handbook Structured\n\nThe handbook is split into two sections:\n\n- **The Handbook**\n\n  The TypeScript Handbook is intended to be a comprehensive document that explains TypeScript to everyday programmers. You can read the handbook by going from top to bottom in the left-hand navigation.\n\n  You should expect each chapter or page to provide you with a strong understanding of the given concepts. The TypeScript Handbook is not a complete language specification, but it is intended to be a comprehensive guide to all of the language’s features and behaviors.\n\n  A reader who completes the walkthrough should be able to:\n\n  - Read and understand commonly-used TypeScript syntax and patterns\n  - Explain the effects of important compiler options\n  - Correctly predict type system behavior in most cases\n\n  In the interests of clarity and brevity, the main content of the Handbook will not explore every edge case or minutiae of the features being covered. You can find more details on particular concepts in the reference articles.\n\n- **Reference Files**\n\n  The reference section below the handbook in the navigation is built to provide a richer understanding of how a particular part of TypeScript works. You can read it top-to-bottom, but each section aims to provide a deeper explanation of a single concept - meaning there is no aim for continuity.\n\n### Non-Goals\n\nThe Handbook is also intended to be a concise document that can be comfortably read in a few hours. Certain topics won’t be covered in order to keep things short.\n\nSpecifically, the Handbook does not fully introduce core JavaScript basics like functions, classes, and closures. Where appropriate, we’ll include links to background reading that you can use to read up on those concepts.\n\nThe Handbook also isn’t intended to be a replacement for a language specification. In some cases, edge cases or formal descriptions of behavior will be skipped in favor of high-level, easier-to-understand explanations. Instead, there are separate reference pages that more precisely and formally describe many aspects of TypeScript’s behavior. The reference pages are not intended for readers unfamiliar with TypeScript, so they may use advanced terminology or reference topics you haven’t read about yet.\n\nFinally, the Handbook won’t cover how TypeScript interacts with other tools, except where necessary. Topics like how to configure TypeScript with webpack, rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue, angular, svelte, jquery, yarn, or npm are out of scope - you can find these resources elsewhere on the web.\n\n## Get Started\n\nBefore getting started with [The Basics](2/basic-types), we recommend reading one of the following introductory pages. These introductions are intended to highlight key similarities and differences between TypeScript and your favored programming language, and clear up common misconceptions specific to those languages.\n\n- [TypeScript for the New Programmer](typescript-from-scratch)\n- [TypeScript for JavaScript Programmers](typescript-in-5-minutes)\n- [TypeScript for Java/C# Programmers](typescript-in-5-minutes-oop)\n- [TypeScript for Functional Programmers](typescript-in-5-minutes-func)\n\nOtherwise, jump to [The Basics](2/basic-types).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/intro.html](https://www.typescriptlang.org/docs/handbook/intro.html)"
- name: 'The TypeScript Handbook: About this Handbook'
  id: intro#about-this-handbook
  summary: Over 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created
  belongs_to: The TypeScript Handbook
  description: |-
    ## About this Handbook

    Over 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created. Starting as a small scripting language for adding trivial interactivity to webpages, JavaScript has grown to be a language of choice for both frontend and backend applications of every size. While the size, scope, and complexity of programs written in JavaScript has grown exponentially, the ability of the JavaScript language to express the relationships between different units of code has not. Combined with JavaScript’s rather peculiar runtime semantics, this mismatch between language and program complexity has made JavaScript development a difficult task to manage at scale.

    The most common kinds of errors that programmers write can be described as type errors: a certain kind of value was used where a different kind of value was expected. This could be due to simple typos, a failure to understand the API surface of a library, incorrect assumptions about runtime behavior, or other errors. The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked).

    If you are coming to TypeScript without a JavaScript background, with the intention of TypeScript being your first language, we recommend you first start reading the documentation on either the [Microsoft Learn JavaScript tutorial](https://developer.microsoft.com/javascript/) or read [JavaScript at the Mozilla Web Docs](https://developer.mozilla.org/docs/Web/JavaScript/Guide). If you have experience in other languages, you should be able to pick up JavaScript syntax quite quickly by reading the handbook.
- name: 'The TypeScript Handbook: Get Started'
  id: intro#get-started
  summary: Before getting started with The Basics, we recommend reading one of the following introductory pages
  belongs_to: The TypeScript Handbook
  description: "## Get Started\n\nBefore getting started with [The Basics](2/basic-types), we recommend reading one of the following introductory pages. These introductions are intended to highlight key similarities and differences between TypeScript and your favored programming language, and clear up common misconceptions specific to those languages.\n\n- [TypeScript for the New Programmer](typescript-from-scratch)\n- [TypeScript for JavaScript Programmers](typescript-in-5-minutes)\n- [TypeScript for Java/C# Programmers](typescript-in-5-minutes-oop)\n- [TypeScript for Functional Programmers](typescript-in-5-minutes-func)\n\nOtherwise, jump to [The Basics](2/basic-types).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/intro.html](https://www.typescriptlang.org/docs/handbook/intro.html)"
- name: 'The TypeScript Handbook: How is this Handbook Structured'
  id: intro#how-is-this-handbook-structured
  summary: The TypeScript Handbook is intended to be a comprehensive document that explains TypeScript to everyday programmers
  belongs_to: The TypeScript Handbook
  description: |-
    ## How is this Handbook Structured

    The handbook is split into two sections:

    - **The Handbook**

      The TypeScript Handbook is intended to be a comprehensive document that explains TypeScript to everyday programmers. You can read the handbook by going from top to bottom in the left-hand navigation.

      You should expect each chapter or page to provide you with a strong understanding of the given concepts. The TypeScript Handbook is not a complete language specification, but it is intended to be a comprehensive guide to all of the language’s features and behaviors.

      A reader who completes the walkthrough should be able to:

      - Read and understand commonly-used TypeScript syntax and patterns
      - Explain the effects of important compiler options
      - Correctly predict type system behavior in most cases

      In the interests of clarity and brevity, the main content of the Handbook will not explore every edge case or minutiae of the features being covered. You can find more details on particular concepts in the reference articles.

    - **Reference Files**

      The reference section below the handbook in the navigation is built to provide a richer understanding of how a particular part of TypeScript works. You can read it top-to-bottom, but each section aims to provide a deeper explanation of a single concept - meaning there is no aim for continuity.

    ### Non-Goals

    The Handbook is also intended to be a concise document that can be comfortably read in a few hours. Certain topics won’t be covered in order to keep things short.

    Specifically, the Handbook does not fully introduce core JavaScript basics like functions, classes, and closures. Where appropriate, we’ll include links to background reading that you can use to read up on those concepts.

    The Handbook also isn’t intended to be a replacement for a language specification. In some cases, edge cases or formal descriptions of behavior will be skipped in favor of high-level, easier-to-understand explanations. Instead, there are separate reference pages that more precisely and formally describe many aspects of TypeScript’s behavior. The reference pages are not intended for readers unfamiliar with TypeScript, so they may use advanced terminology or reference topics you haven’t read about yet.

    Finally, the Handbook won’t cover how TypeScript interacts with other tools, except where necessary. Topics like how to configure TypeScript with webpack, rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue, angular, svelte, jquery, yarn, or npm are out of scope - you can find these resources elsewhere on the web.
- name: traceResolution
  id: tsconfig/index#traceResolution-config
  summary: When you are trying to debug why a module isn’t being included
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Trace Resolution - `traceResolution`

    When you are trying to debug why a module isn’t being included. You can set `traceResolution` to `true` to have TypeScript print information about its resolution process for each processed file.

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)

    ## Projects
- name: traceResolution
  id: tsconfig#traceResolution-config
  summary: When you are trying to debug why a module isn’t being included
  belongs_to: TSConfig Reference
  description: |-
    ### Trace Resolution - `traceResolution`

    When you are trying to debug why a module isn’t being included. You can set `traceResolution` to `true` to have TypeScript print information about its resolution process for each processed file.

    - Released:

      [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)

    ## Projects
- name: Triple-Slash Directives
  id: triple-slash-directives
  summary: Triple-slash directives are single-line comments containing a single XML tag
  description: "# Triple-Slash Directives\n\nTriple-slash directives are single-line comments containing a single XML tag. The contents of the comment are used as compiler directives.\n\nTriple-slash directives are **only** valid at the top of their containing file. A triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives. If they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning.\n\n## `/// <reference path=\"...\" />`\n\nThe `/// <reference path=\"...\" />` directive is the most common of this group. It serves as a declaration of *dependency* between files.\n\nTriple-slash references instruct the compiler to include additional files in the compilation process.\n\nThey also serve as a method to order the output when using [`out`](https://www.typescriptlang.org/tsconfig#out) or [`outFile`](https://www.typescriptlang.org/tsconfig#outFile). Files are emitted to the output file location in the same order as the input after preprocessing pass.\n\n### Preprocessing input files\n\nThe compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives. During this process, additional files are added to the compilation.\n\nThe process starts with a set of *root files*; these are the file names specified on the command-line or in the [`files`](https://www.typescriptlang.org/tsconfig#files) list in the `tsconfig.json` file. These root files are preprocessed in the same order they are specified. Before a file is added to the list, all triple-slash references in it are processed, and their targets included. Triple-slash references are resolved in a depth-first manner, in the order they have been seen in the file.\n\nA triple-slash reference path is resolved relative to the containing file, if a relative path is used.\n\n### Errors\n\nIt is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.\n\n### Using `--noResolve`\n\nIf the compiler flag [`noResolve`](https://www.typescriptlang.org/tsconfig#noResolve) is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided.\n\n## `/// <reference types=\"...\" />`\n\nSimilar to a `/// <reference path=\"...\" />` directive, which serves as a declaration of *dependency*, a `/// <reference types=\"...\" />` directive declares a dependency on a package.\n\nThe process of resolving these package names is similar to the process of resolving module names in an `import` statement. An easy way to think of triple-slash-reference-types directives are as an `import` for declaration packages.\n\nFor example, including `/// <reference types=\"node\" />` in a declaration file declares that this file uses names declared in `@types/node/index.d.ts`; and thus, this package needs to be included in the compilation along with the declaration file.\n\nUse these directives only when you’re authoring a `d.ts` file by hand.\n\nFor declaration files generated during compilation, the compiler will automatically add `/// <reference types=\"...\" />` for you; A `/// <reference types=\"...\" />` in a generated declaration file is added *if and only if* the resulting file uses any declarations from the referenced package.\n\nFor declaring a dependency on an `@types` package in a `.ts` file, use [`types`](https://www.typescriptlang.org/tsconfig#types) on the command line or in your `tsconfig.json` instead. See [using `@types`, `typeRoots` and `types` in `tsconfig.json` files](tsconfig-json#types-typeroots-and-types) for more details.\n\n## `/// <reference lib=\"...\" />`\n\nThis directive allows a file to explicitly include an existing built-in *lib* file.\n\nBuilt-in *lib* files are referenced in the same fashion as the [`lib`](https://www.typescriptlang.org/tsconfig#lib) compiler option in *tsconfig.json* (e.g. use `lib=\"es2015\"` and not `lib=\"lib.es2015.d.ts\"`, etc.).\n\nFor declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like `Symbol` or `Iterable`, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.\n\nFor example, adding `/// <reference lib=\"es2017.string\" />` to one of the files in a compilation is equivalent to compiling with `--lib es2017.string`.\n\n``` ts\n/// <reference lib=\"es2017.string\" />\n\n\"foo\".padStart(4);\n```\n\n## `/// <reference no-default-lib=\"true\"/>`\n\nThis directive marks a file as a *default library*. You will see this comment at the top of `lib.d.ts` and its different variants.\n\nThis directive instructs the compiler to *not* include the default library (i.e. `lib.d.ts`) in the compilation. The impact here is similar to passing [`noLib`](https://www.typescriptlang.org/tsconfig#noLib) on the command line.\n\nAlso note that when passing [`skipDefaultLibCheck`](https://www.typescriptlang.org/tsconfig#skipDefaultLibCheck), the compiler will only skip checking files with `/// <reference no-default-lib=\"true\"/>`.\n\n## `/// <amd-module />`\n\nBy default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g. `r.js`).\n\nThe `amd-module` directive allows passing an optional module name to the compiler:\n\n##### amdModule.ts\n\n``` ts\n/// <amd-module name=\"NamedModule\"/>\nexport class C {}\n```\n\nWill result in assigning the name `NamedModule` to the module as part of calling the AMD `define`:\n\n##### amdModule.js\n\n``` js\ndefine(\"NamedModule\", [\"require\", \"exports\"], function (require, exports) {\n  var C = (function () {\n    function C() {}\n    return C;\n  })();\n  exports.C = C;\n});\n```\n\n## `/// <amd-dependency />`\n\n> **Note**: this directive has been deprecated. Use `import \"moduleName\";` statements instead.\n\n`/// <amd-dependency path=\"x\" />` informs the compiler about a non-TS module dependency that needs to be injected in the resulting module’s require call.\n\nThe `amd-dependency` directive can also have an optional `name` property; this allows passing an optional name for an amd-dependency:\n\n``` ts\n/// <amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/>\ndeclare var moduleA: MyType;\nmoduleA.callStuff();\n```\n\nGenerated JS code:\n\n``` js\ndefine([\"require\", \"exports\", \"legacy/moduleA\"], function (\n  require,\n  exports,\n  moduleA\n) {\n  moduleA.callStuff();\n});\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html)"
- name: 'Triple-Slash Directives: /// <amd-dependency />'
  id: triple-slash-directives#-amd-dependency-
  summary: 'Note: this directive has been deprecated'
  belongs_to: Triple-Slash Directives
  description: "## `/// <amd-dependency />`\n\n> **Note**: this directive has been deprecated. Use `import \"moduleName\";` statements instead.\n\n`/// <amd-dependency path=\"x\" />` informs the compiler about a non-TS module dependency that needs to be injected in the resulting module’s require call.\n\nThe `amd-dependency` directive can also have an optional `name` property; this allows passing an optional name for an amd-dependency:\n\n``` ts\n/// <amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/>\ndeclare var moduleA: MyType;\nmoduleA.callStuff();\n```\n\nGenerated JS code:\n\n``` js\ndefine([\"require\", \"exports\", \"legacy/moduleA\"], function (\n  require,\n  exports,\n  moduleA\n) {\n  moduleA.callStuff();\n});\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html)"
- name: 'Triple-Slash Directives: /// <amd-module />'
  id: triple-slash-directives#-amd-module-
  summary: By default AMD modules are generated anonymous
  belongs_to: Triple-Slash Directives
  description: |-
    ## `/// <amd-module />`

    By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g. `r.js`).

    The `amd-module` directive allows passing an optional module name to the compiler:

    ##### amdModule.ts

    ``` ts
    /// <amd-module name="NamedModule"/>
    export class C {}
    ```

    Will result in assigning the name `NamedModule` to the module as part of calling the AMD `define`:

    ##### amdModule.js

    ``` js
    define("NamedModule", ["require", "exports"], function (require, exports) {
      var C = (function () {
        function C() {}
        return C;
      })();
      exports.C = C;
    });
    ```
- name: 'Triple-Slash Directives: /// <reference lib="..." />'
  id: triple-slash-directives#-reference-lib-
  summary: This directive allows a file to explicitly include an existing built-in lib file
  belongs_to: Triple-Slash Directives
  description: |-
    ## `/// <reference lib="..." />`

    This directive allows a file to explicitly include an existing built-in *lib* file.

    Built-in *lib* files are referenced in the same fashion as the [`lib`](https://www.typescriptlang.org/tsconfig#lib) compiler option in *tsconfig.json* (e.g. use `lib="es2015"` and not `lib="lib.es2015.d.ts"`, etc.).

    For declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like `Symbol` or `Iterable`, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.

    For example, adding `/// <reference lib="es2017.string" />` to one of the files in a compilation is equivalent to compiling with `--lib es2017.string`.

    ``` ts
    /// <reference lib="es2017.string" />

    "foo".padStart(4);
    ```
- name: 'Triple-Slash Directives: /// <reference no-default-lib="true"/>'
  id: triple-slash-directives#-reference-no-default-libtrue
  summary: This directive marks a file as a default library
  belongs_to: Triple-Slash Directives
  description: |-
    ## `/// <reference no-default-lib="true"/>`

    This directive marks a file as a *default library*. You will see this comment at the top of `lib.d.ts` and its different variants.

    This directive instructs the compiler to *not* include the default library (i.e. `lib.d.ts`) in the compilation. The impact here is similar to passing [`noLib`](https://www.typescriptlang.org/tsconfig#noLib) on the command line.

    Also note that when passing [`skipDefaultLibCheck`](https://www.typescriptlang.org/tsconfig#skipDefaultLibCheck), the compiler will only skip checking files with `/// <reference no-default-lib="true"/>`.
- name: 'Triple-Slash Directives: /// <reference path="..." />'
  id: triple-slash-directives#-reference-path-
  summary: The /// <reference path="..." /> directive is the most common of this group
  belongs_to: Triple-Slash Directives
  description: |-
    ## `/// <reference path="..." />`

    The `/// <reference path="..." />` directive is the most common of this group. It serves as a declaration of *dependency* between files.

    Triple-slash references instruct the compiler to include additional files in the compilation process.

    They also serve as a method to order the output when using [`out`](https://www.typescriptlang.org/tsconfig#out) or [`outFile`](https://www.typescriptlang.org/tsconfig#outFile). Files are emitted to the output file location in the same order as the input after preprocessing pass.

    ### Preprocessing input files

    The compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives. During this process, additional files are added to the compilation.

    The process starts with a set of *root files*; these are the file names specified on the command-line or in the [`files`](https://www.typescriptlang.org/tsconfig#files) list in the `tsconfig.json` file. These root files are preprocessed in the same order they are specified. Before a file is added to the list, all triple-slash references in it are processed, and their targets included. Triple-slash references are resolved in a depth-first manner, in the order they have been seen in the file.

    A triple-slash reference path is resolved relative to the containing file, if a relative path is used.

    ### Errors

    It is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.
- name: 'Triple-Slash Directives: /// <reference types="..." />'
  id: triple-slash-directives#-reference-types-
  summary: Similar to a /// <reference path="..." /> directive, which serves as a declaration of dependency, a /// <reference types="..." /> directive declares a dependency on a package
  belongs_to: Triple-Slash Directives
  description: |-
    ## `/// <reference types="..." />`

    Similar to a `/// <reference path="..." />` directive, which serves as a declaration of *dependency*, a `/// <reference types="..." />` directive declares a dependency on a package.

    The process of resolving these package names is similar to the process of resolving module names in an `import` statement. An easy way to think of triple-slash-reference-types directives are as an `import` for declaration packages.

    For example, including `/// <reference types="node" />` in a declaration file declares that this file uses names declared in `@types/node/index.d.ts`; and thus, this package needs to be included in the compilation along with the declaration file.

    Use these directives only when you’re authoring a `d.ts` file by hand.

    For declaration files generated during compilation, the compiler will automatically add `/// <reference types="..." />` for you; A `/// <reference types="..." />` in a generated declaration file is added *if and only if* the resulting file uses any declarations from the referenced package.

    For declaring a dependency on an `@types` package in a `.ts` file, use [`types`](https://www.typescriptlang.org/tsconfig#types) on the command line or in your `tsconfig.json` instead. See [using `@types`, `typeRoots` and `types` in `tsconfig.json` files](tsconfig-json#types-typeroots-and-types) for more details.
- name: 'Triple-Slash Directives: Using --noResolve'
  id: triple-slash-directives#using---noresolve
  summary: If the compiler flag noResolve is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided
  belongs_to: Triple-Slash Directives
  description: |-
    ### Using `--noResolve`

    If the compiler flag [`noResolve`](https://www.typescriptlang.org/tsconfig#noResolve) is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided.
- name: tsBuildInfoFile
  id: tsconfig/index#tsBuildInfoFile-config
  summary: This setting lets you specify a file for storing incremental compilation information as a part of composite projects which enables faster building of larger TypeScript codebases
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### TS Build Info File - `tsBuildInfoFile`

    This setting lets you specify a file for storing incremental compilation information as a part of composite projects which enables faster building of larger TypeScript codebases. You can read more about composite projects [in the handbook](../docs/handbook/project-references).

    The default depends on a combination of other settings:

    - If `outFile` is set, the default is `<outFile>.tsbuildinfo`.
    - If `rootDir` and `outDir` are set, then the file is `<outDir>/<relative path to config from rootDir>/<config name>.tsbuildinfo` For example, if `rootDir` is `src`, `outDir` is `dest`, and the config is `./tsconfig.json`, then the default is `./tsconfig.tsbuildinfo` as the relative path from `src/` to `./tsconfig.json` is `../`.
    - If `outDir` is set, then the default is `<outDir>/<config name>.tsbuildInfo`
    - Otherwise, the default is `<config name>.tsbuildInfo`

    - Default:

      `.tsbuildinfo`

    - Related:
      - [`incremental`](#incremental)

      - [`composite`](#composite)

    - Released:

      [3.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html)

    ## Output Formatting
- name: tsBuildInfoFile
  id: tsconfig#tsBuildInfoFile-config
  summary: This setting lets you specify a file for storing incremental compilation information as a part of composite projects which enables faster building of larger TypeScript codebases
  belongs_to: TSConfig Reference
  description: |-
    ### TS Build Info File - `tsBuildInfoFile`

    This setting lets you specify a file for storing incremental compilation information as a part of composite projects which enables faster building of larger TypeScript codebases. You can read more about composite projects [in the handbook](docs/handbook/project-references).

    The default depends on a combination of other settings:

    - If `outFile` is set, the default is `<outFile>.tsbuildinfo`.
    - If `rootDir` and `outDir` are set, then the file is `<outDir>/<relative path to config from rootDir>/<config name>.tsbuildinfo` For example, if `rootDir` is `src`, `outDir` is `dest`, and the config is `./tsconfig.json`, then the default is `./tsconfig.tsbuildinfo` as the relative path from `src/` to `./tsconfig.json` is `../`.
    - If `outDir` is set, then the default is `<outDir>/<config name>.tsbuildInfo`
    - Otherwise, the default is `<config name>.tsbuildInfo`

    - Default:

      `.tsbuildinfo`

    - Related:
      - [`incremental`](#incremental)

      - [`composite`](#composite)

    - Released:

      [3.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html)

    ## Output Formatting
- name: tsc CLI Options
  id: compiler-options
  summary: Running tsc locally will compile the closest project defined by a tsconfig.json, or you can compile a set of TypeScript files by passing in a glob of files you want
  description: "# tsc CLI Options\n\n## Using the CLI\n\nRunning `tsc` locally will compile the closest project defined by a `tsconfig.json`, or you can compile a set of TypeScript files by passing in a glob of files you want. When input files are specified on the command line, `tsconfig.json` files are ignored.\n\n``` shell\n# Run a compile based on a backwards look through the fs for a tsconfig.json\ntsc\n\n# Emit JS for just the index.ts with the compiler defaults\ntsc index.ts\n\n# Emit JS for any .ts files in the folder src, with the default settings\ntsc src/*.ts\n\n# Emit files referenced in with the compiler settings from tsconfig.production.json\ntsc --project tsconfig.production.json\n\n# Emit d.ts files for a js file with showing compiler options which are booleans\ntsc index.js --declaration --emitDeclarationOnly\n\n# Emit a single .js file from two files via compiler options which take string arguments\ntsc app.ts util.ts --target esnext --outfile index.js\n```\n\n## Compiler Options\n\n**If you’re looking for more information about the compiler options in a tsconfig, check out the [TSConfig Reference](https://www.typescriptlang.org/tsconfig)**\n\n### CLI Commands\n\n| Flag                                                                                                 | Type      |     |\n|------------------------------------------------------------------------------------------------------|-----------|-----|\n| `--all`                                                                                              | `boolean` |     |\n| Show all compiler options.                                                                           |           |     |\n| `--generateTrace`                                                                                    | `string`  |     |\n| Generates an event trace and a list of types.                                                        |           |     |\n| `--help`                                                                                             | `boolean` |     |\n| Gives local information for help on the CLI.                                                         |           |     |\n| `--init`                                                                                             | `boolean` |     |\n| Initializes a TypeScript project and creates a tsconfig.json file.                                   |           |     |\n| `--listFilesOnly`                                                                                    | `boolean` |     |\n| Print names of files that are part of the compilation and then stop processing.                      |           |     |\n| `--locale`                                                                                           | `string`  |     |\n| Set the language of the messaging from TypeScript. This does not affect emit.                        |           |     |\n| `--project`                                                                                          | `string`  |     |\n| Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'. |           |     |\n| `--showConfig`                                                                                       | `boolean` |     |\n| Print the final configuration instead of building.                                                   |           |     |\n| `--version`                                                                                          | `boolean` |     |\n| Print the compiler's version.                                                                        |           |     |\n\n### Build Options\n\n| Flag                                                               | Type      |     |\n|--------------------------------------------------------------------|-----------|-----|\n| `--build`                                                          | `boolean` |     |\n| Build one or more projects and their dependencies, if out of date  |           |     |\n| `--clean`                                                          | `boolean` |     |\n| Delete the outputs of all projects.                                |           |     |\n| `--dry`                                                            | `boolean` |     |\n| Show what would be built (or deleted, if specified with '--clean') |           |     |\n| [`--force`](https://www.typescriptlang.org/tsconfig/#force)        | `boolean` |     |\n| Build all projects, including those that appear to be up to date.  |           |     |\n| [`--verbose`](https://www.typescriptlang.org/tsconfig/#verbose)    | `boolean` |     |\n| Enable verbose logging.                                            |           |     |\n\n### Watch Options\n\n| Flag                                                                                                                                  | Type                                                                                                                                                   |     |\n|---------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------|-----|\n| [`--excludeDirectories`](https://www.typescriptlang.org/tsconfig/#excludeDirectories)                                                 | `list`                                                                                                                                                 |     |\n| Remove a list of directories from the watch process.                                                                                  |                                                                                                                                                        |     |\n| [`--excludeFiles`](https://www.typescriptlang.org/tsconfig/#excludeFiles)                                                             | `list`                                                                                                                                                 |     |\n| Remove a list of files from the watch mode's processing.                                                                              |                                                                                                                                                        |     |\n| [`--fallbackPolling`](https://www.typescriptlang.org/tsconfig/#fallbackPolling)                                                       | `fixedinterval`, `priorityinterval`, `dynamicpriority`, or `fixedchunksize`                                                                            |     |\n| Specify what approach the watcher should use if the system runs out of native file watchers.                                          |                                                                                                                                                        |     |\n| [`--synchronousWatchDirectory`](https://www.typescriptlang.org/tsconfig/#synchronousWatchDirectory)                                   | `boolean`                                                                                                                                              |     |\n| Synchronously call callbacks and update the state of directory watchers on platforms that don\\`t support recursive watching natively. |                                                                                                                                                        |     |\n| `--watch`                                                                                                                             | `boolean`                                                                                                                                              |     |\n| Watch input files.                                                                                                                    |                                                                                                                                                        |     |\n| [`--watchDirectory`](https://www.typescriptlang.org/tsconfig/#watchDirectory)                                                         | `usefsevents`, `fixedpollinginterval`, `dynamicprioritypolling`, or `fixedchunksizepolling`                                                            |     |\n| Specify how directories are watched on systems that lack recursive file-watching functionality.                                       |                                                                                                                                                        |     |\n| [`--watchFile`](https://www.typescriptlang.org/tsconfig/#watchFile)                                                                   | `fixedpollinginterval`, `prioritypollinginterval`, `dynamicprioritypolling`, `fixedchunksizepolling`, `usefsevents`, or `usefseventsonparentdirectory` |     |\n| Specify how the TypeScript watch mode works.                                                                                          |                                                                                                                                                        |     |\n\n### Compiler Flags\n\n| Flag                                                                                                                                                                            | Type                                                                                                                          | Default                                                                                                                                                                   |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| [`--allowArbitraryExtensions`](https://www.typescriptlang.org/tsconfig/#allowArbitraryExtensions)                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Enable importing files with any extension, provided a declaration file is present.                                                                                              |                                                                                                                               |                                                                                                                                                                           |\n| [`--allowImportingTsExtensions`](https://www.typescriptlang.org/tsconfig/#allowImportingTsExtensions)                                                                           | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Allow imports to include TypeScript file extensions.                                                                                                                            |                                                                                                                               |                                                                                                                                                                           |\n| [`--allowJs`](https://www.typescriptlang.org/tsconfig/#allowJs)                                                                                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files.                                                                   |                                                                                                                               |                                                                                                                                                                           |\n| [`--allowSyntheticDefaultImports`](https://www.typescriptlang.org/tsconfig/#allowSyntheticDefaultImports)                                                                       | `boolean`                                                                                                                     | `true` if [`esModuleInterop`](#esModuleInterop) is enabled, [`module`](#module) is `system`, or [`moduleResolution`](#module-resolution) is `bundler`; `false` otherwise. |\n| Allow 'import x from y' when a module doesn't have a default export.                                                                                                            |                                                                                                                               |                                                                                                                                                                           |\n| [`--allowUmdGlobalAccess`](https://www.typescriptlang.org/tsconfig/#allowUmdGlobalAccess)                                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Allow accessing UMD globals from modules.                                                                                                                                       |                                                                                                                               |                                                                                                                                                                           |\n| [`--allowUnreachableCode`](https://www.typescriptlang.org/tsconfig/#allowUnreachableCode)                                                                                       | `boolean`                                                                                                                     |                                                                                                                                                                           |\n| Disable error reporting for unreachable code.                                                                                                                                   |                                                                                                                               |                                                                                                                                                                           |\n| [`--allowUnusedLabels`](https://www.typescriptlang.org/tsconfig/#allowUnusedLabels)                                                                                             | `boolean`                                                                                                                     |                                                                                                                                                                           |\n| Disable error reporting for unused labels.                                                                                                                                      |                                                                                                                               |                                                                                                                                                                           |\n| [`--alwaysStrict`](https://www.typescriptlang.org/tsconfig/#alwaysStrict)                                                                                                       | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |\n| Ensure 'use strict' is always emitted.                                                                                                                                          |                                                                                                                               |                                                                                                                                                                           |\n| [`--assumeChangesOnlyAffectDirectDependencies`](https://www.typescriptlang.org/tsconfig/#assumeChangesOnlyAffectDirectDependencies)                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Have recompiles in projects that use [`incremental`](#incremental) and `watch` mode assume that changes within a file will only affect files directly depending on it.          |                                                                                                                               |                                                                                                                                                                           |\n| [`--baseUrl`](https://www.typescriptlang.org/tsconfig/#baseUrl)                                                                                                                 | `string`                                                                                                                      |                                                                                                                                                                           |\n| Specify the base directory to resolve bare specifier module names.                                                                                                              |                                                                                                                               |                                                                                                                                                                           |\n| [`--charset`](https://www.typescriptlang.org/tsconfig/#charset)                                                                                                                 | `string`                                                                                                                      | `utf8`                                                                                                                                                                    |\n| No longer supported. In early versions, manually set the text encoding for reading files.                                                                                       |                                                                                                                               |                                                                                                                                                                           |\n| [`--checkJs`](https://www.typescriptlang.org/tsconfig/#checkJs)                                                                                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Enable error reporting in type-checked JavaScript files.                                                                                                                        |                                                                                                                               |                                                                                                                                                                           |\n| [`--composite`](https://www.typescriptlang.org/tsconfig/#composite)                                                                                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Enable constraints that allow a TypeScript project to be used with project references.                                                                                          |                                                                                                                               |                                                                                                                                                                           |\n| [`--customConditions`](https://www.typescriptlang.org/tsconfig/#customConditions)                                                                                               | `list`                                                                                                                        |                                                                                                                                                                           |\n| Conditions to set in addition to the resolver-specific defaults when resolving imports.                                                                                         |                                                                                                                               |                                                                                                                                                                           |\n| [`--declaration`](https://www.typescriptlang.org/tsconfig/#declaration)                                                                                                         | `boolean`                                                                                                                     | `true` if [`composite`](#composite); `false` otherwise.                                                                                                                   |\n| Generate .d.ts files from TypeScript and JavaScript files in your project.                                                                                                      |                                                                                                                               |                                                                                                                                                                           |\n| [`--declarationDir`](https://www.typescriptlang.org/tsconfig/#declarationDir)                                                                                                   | `string`                                                                                                                      |                                                                                                                                                                           |\n| Specify the output directory for generated declaration files.                                                                                                                   |                                                                                                                               |                                                                                                                                                                           |\n| [`--declarationMap`](https://www.typescriptlang.org/tsconfig/#declarationMap)                                                                                                   | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Create sourcemaps for d.ts files.                                                                                                                                               |                                                                                                                               |                                                                                                                                                                           |\n| [`--diagnostics`](https://www.typescriptlang.org/tsconfig/#diagnostics)                                                                                                         | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Output compiler performance information after building.                                                                                                                         |                                                                                                                               |                                                                                                                                                                           |\n| [`--disableReferencedProjectLoad`](https://www.typescriptlang.org/tsconfig/#disableReferencedProjectLoad)                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Reduce the number of projects loaded automatically by TypeScript.                                                                                                               |                                                                                                                               |                                                                                                                                                                           |\n| [`--disableSizeLimit`](https://www.typescriptlang.org/tsconfig/#disableSizeLimit)                                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Remove the 20mb cap on total source code size for JavaScript files in the TypeScript language server.                                                                           |                                                                                                                               |                                                                                                                                                                           |\n| [`--disableSolutionSearching`](https://www.typescriptlang.org/tsconfig/#disableSolutionSearching)                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Opt a project out of multi-project reference checking when editing.                                                                                                             |                                                                                                                               |                                                                                                                                                                           |\n| [`--disableSourceOfProjectReferenceRedirect`](https://www.typescriptlang.org/tsconfig/#disableSourceOfProjectReferenceRedirect)                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disable preferring source files instead of declaration files when referencing composite projects.                                                                               |                                                                                                                               |                                                                                                                                                                           |\n| [`--downlevelIteration`](https://www.typescriptlang.org/tsconfig/#downlevelIteration)                                                                                           | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Emit more compliant, but verbose and less performant JavaScript for iteration.                                                                                                  |                                                                                                                               |                                                                                                                                                                           |\n| [`--emitBOM`](https://www.typescriptlang.org/tsconfig/#emitBOM)                                                                                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.                                                                                                            |                                                                                                                               |                                                                                                                                                                           |\n| [`--emitDeclarationOnly`](https://www.typescriptlang.org/tsconfig/#emitDeclarationOnly)                                                                                         | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Only output d.ts files and not JavaScript files.                                                                                                                                |                                                                                                                               |                                                                                                                                                                           |\n| [`--emitDecoratorMetadata`](https://www.typescriptlang.org/tsconfig/#emitDecoratorMetadata)                                                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Emit design-type metadata for decorated declarations in source files.                                                                                                           |                                                                                                                               |                                                                                                                                                                           |\n| [`--esModuleInterop`](https://www.typescriptlang.org/tsconfig/#esModuleInterop)                                                                                                 | `boolean`                                                                                                                     | `true` if [`module`](#module) is `node16` or `nodenext`; `false` otherwise.                                                                                               |\n| Emit additional JavaScript to ease support for importing CommonJS modules. This enables [`allowSyntheticDefaultImports`](#allowSyntheticDefaultImports) for type compatibility. |                                                                                                                               |                                                                                                                                                                           |\n| [`--exactOptionalPropertyTypes`](https://www.typescriptlang.org/tsconfig/#exactOptionalPropertyTypes)                                                                           | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Interpret optional property types as written, rather than adding `undefined`.                                                                                                   |                                                                                                                               |                                                                                                                                                                           |\n| [`--experimentalDecorators`](https://www.typescriptlang.org/tsconfig/#experimentalDecorators)                                                                                   | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Enable experimental support for TC39 stage 2 draft decorators.                                                                                                                  |                                                                                                                               |                                                                                                                                                                           |\n| [`--explainFiles`](https://www.typescriptlang.org/tsconfig/#explainFiles)                                                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Print files read during the compilation including why it was included.                                                                                                          |                                                                                                                               |                                                                                                                                                                           |\n| [`--extendedDiagnostics`](https://www.typescriptlang.org/tsconfig/#extendedDiagnostics)                                                                                         | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Output more detailed compiler performance information after building.                                                                                                           |                                                                                                                               |                                                                                                                                                                           |\n| [`--forceConsistentCasingInFileNames`](https://www.typescriptlang.org/tsconfig/#forceConsistentCasingInFileNames)                                                               | `boolean`                                                                                                                     | `true`                                                                                                                                                                    |\n| Ensure that casing is correct in imports.                                                                                                                                       |                                                                                                                               |                                                                                                                                                                           |\n| [`--generateCpuProfile`](https://www.typescriptlang.org/tsconfig/#generateCpuProfile)                                                                                           | `string`                                                                                                                      | `profile.cpuprofile`                                                                                                                                                      |\n| Emit a v8 CPU profile of the compiler run for debugging.                                                                                                                        |                                                                                                                               |                                                                                                                                                                           |\n| [`--importHelpers`](https://www.typescriptlang.org/tsconfig/#importHelpers)                                                                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Allow importing helper functions from tslib once per project, instead of including them per-file.                                                                               |                                                                                                                               |                                                                                                                                                                           |\n| [`--importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig/#importsNotUsedAsValues)                                                                                   | `remove`, `preserve`, or `error`                                                                                              | `remove`                                                                                                                                                                  |\n| Specify emit/checking behavior for imports that are only used for types.                                                                                                        |                                                                                                                               |                                                                                                                                                                           |\n| [`--incremental`](https://www.typescriptlang.org/tsconfig/#incremental)                                                                                                         | `boolean`                                                                                                                     | `true` if [`composite`](#composite); `false` otherwise.                                                                                                                   |\n| Save .tsbuildinfo files to allow for incremental compilation of projects.                                                                                                       |                                                                                                                               |                                                                                                                                                                           |\n| [`--inlineSourceMap`](https://www.typescriptlang.org/tsconfig/#inlineSourceMap)                                                                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Include sourcemap files inside the emitted JavaScript.                                                                                                                          |                                                                                                                               |                                                                                                                                                                           |\n| [`--inlineSources`](https://www.typescriptlang.org/tsconfig/#inlineSources)                                                                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Include source code in the sourcemaps inside the emitted JavaScript.                                                                                                            |                                                                                                                               |                                                                                                                                                                           |\n| [`--isolatedDeclarations`](https://www.typescriptlang.org/tsconfig/#isolatedDeclarations)                                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Require sufficient annotation on exports so other tools can trivially generate declaration files.                                                                               |                                                                                                                               |                                                                                                                                                                           |\n| [`--isolatedModules`](https://www.typescriptlang.org/tsconfig/#isolatedModules)                                                                                                 | `boolean`                                                                                                                     | `true` if [`verbatimModuleSyntax`](#verbatimModuleSyntax); `false` otherwise.                                                                                             |\n| Ensure that each file can be safely transpiled without relying on other imports.                                                                                                |                                                                                                                               |                                                                                                                                                                           |\n| [`--jsx`](https://www.typescriptlang.org/tsconfig/#jsx)                                                                                                                         | `preserve`, `react`, `react-native`, `react-jsx`, or `react-jsxdev`                                                           |                                                                                                                                                                           |\n| Specify what JSX code is generated.                                                                                                                                             |                                                                                                                               |                                                                                                                                                                           |\n| [`--jsxFactory`](https://www.typescriptlang.org/tsconfig/#jsxFactory)                                                                                                           | `string`                                                                                                                      | `React.createElement`                                                                                                                                                     |\n| Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'.                                                                         |                                                                                                                               |                                                                                                                                                                           |\n| [`--jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig/#jsxFragmentFactory)                                                                                           | `string`                                                                                                                      | `React.Fragment`                                                                                                                                                          |\n| Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'.                                                        |                                                                                                                               |                                                                                                                                                                           |\n| [`--jsxImportSource`](https://www.typescriptlang.org/tsconfig/#jsxImportSource)                                                                                                 | `string`                                                                                                                      | `react`                                                                                                                                                                   |\n| Specify module specifier used to import the JSX factory functions when using `jsx: react-jsx*`.                                                                                 |                                                                                                                               |                                                                                                                                                                           |\n| [`--keyofStringsOnly`](https://www.typescriptlang.org/tsconfig/#keyofStringsOnly)                                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Make keyof only return strings instead of string, numbers or symbols. Legacy option.                                                                                            |                                                                                                                               |                                                                                                                                                                           |\n| [`--lib`](https://www.typescriptlang.org/tsconfig/#lib)                                                                                                                         | `list`                                                                                                                        |                                                                                                                                                                           |\n| Specify a set of bundled library declaration files that describe the target runtime environment.                                                                                |                                                                                                                               |                                                                                                                                                                           |\n| [`--listEmittedFiles`](https://www.typescriptlang.org/tsconfig/#listEmittedFiles)                                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Print the names of emitted files after a compilation.                                                                                                                           |                                                                                                                               |                                                                                                                                                                           |\n| [`--listFiles`](https://www.typescriptlang.org/tsconfig/#listFiles)                                                                                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Print all of the files read during the compilation.                                                                                                                             |                                                                                                                               |                                                                                                                                                                           |\n| [`--mapRoot`](https://www.typescriptlang.org/tsconfig/#mapRoot)                                                                                                                 | `string`                                                                                                                      |                                                                                                                                                                           |\n| Specify the location where debugger should locate map files instead of generated locations.                                                                                     |                                                                                                                               |                                                                                                                                                                           |\n| [`--maxNodeModuleJsDepth`](https://www.typescriptlang.org/tsconfig/#maxNodeModuleJsDepth)                                                                                       | `number`                                                                                                                      | `0`                                                                                                                                                                       |\n| Specify the maximum folder depth used for checking JavaScript files from `node_modules`. Only applicable with [`allowJs`](#allowJs).                                            |                                                                                                                               |                                                                                                                                                                           |\n| [`--module`](https://www.typescriptlang.org/tsconfig/#module)                                                                                                                   | `none`, `commonjs`, `amd`, `umd`, `system`, `es6`/`es2015`, `es2020`, `es2022`, `esnext`, `node16`, `nodenext`, or `preserve` | `CommonJS` if [`target`](#target) is `ES3` or `ES5`; `ES6`/`ES2015` otherwise.                                                                                            |\n| Specify what module code is generated.                                                                                                                                          |                                                                                                                               |                                                                                                                                                                           |\n| [`--moduleDetection`](https://www.typescriptlang.org/tsconfig/#moduleDetection)                                                                                                 | `legacy`, `auto`, or `force`                                                                                                  | \"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.                                       |\n| Specify what method is used to detect whether a file is a script or a module.                                                                                                   |                                                                                                                               |                                                                                                                                                                           |\n| [`--moduleResolution`](https://www.typescriptlang.org/tsconfig/#moduleResolution)                                                                                               | `classic`, `node10`/`node`, `node16`, `nodenext`, or `bundler`                                                                | `Classic` if [`module`](#module) is `AMD`, `UMD`, `System`, or `ES6`/`ES2015`; Matches if [`module`](#module) is `node16` or `nodenext`; `Node` otherwise.                |\n| Specify how TypeScript looks up a file from a given module specifier.                                                                                                           |                                                                                                                               |                                                                                                                                                                           |\n| [`--moduleSuffixes`](https://www.typescriptlang.org/tsconfig/#moduleSuffixes)                                                                                                   | `list`                                                                                                                        |                                                                                                                                                                           |\n| List of file name suffixes to search when resolving a module.                                                                                                                   |                                                                                                                               |                                                                                                                                                                           |\n| [`--newLine`](https://www.typescriptlang.org/tsconfig/#newLine)                                                                                                                 | `crlf` or `lf`                                                                                                                | `lf`                                                                                                                                                                      |\n| Set the newline character for emitting files.                                                                                                                                   |                                                                                                                               |                                                                                                                                                                           |\n| [`--noCheck`](https://www.typescriptlang.org/tsconfig/#noCheck)                                                                                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disable full type checking (only critical parse and emit errors will be reported).                                                                                              |                                                                                                                               |                                                                                                                                                                           |\n| [`--noEmit`](https://www.typescriptlang.org/tsconfig/#noEmit)                                                                                                                   | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disable emitting files from a compilation.                                                                                                                                      |                                                                                                                               |                                                                                                                                                                           |\n| [`--noEmitHelpers`](https://www.typescriptlang.org/tsconfig/#noEmitHelpers)                                                                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disable generating custom helper functions like `__extends` in compiled output.                                                                                                 |                                                                                                                               |                                                                                                                                                                           |\n| [`--noEmitOnError`](https://www.typescriptlang.org/tsconfig/#noEmitOnError)                                                                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disable emitting files if any type checking errors are reported.                                                                                                                |                                                                                                                               |                                                                                                                                                                           |\n| [`--noErrorTruncation`](https://www.typescriptlang.org/tsconfig/#noErrorTruncation)                                                                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disable truncating types in error messages.                                                                                                                                     |                                                                                                                               |                                                                                                                                                                           |\n| [`--noFallthroughCasesInSwitch`](https://www.typescriptlang.org/tsconfig/#noFallthroughCasesInSwitch)                                                                           | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Enable error reporting for fallthrough cases in switch statements.                                                                                                              |                                                                                                                               |                                                                                                                                                                           |\n| [`--noImplicitAny`](https://www.typescriptlang.org/tsconfig/#noImplicitAny)                                                                                                     | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |\n| Enable error reporting for expressions and declarations with an implied `any` type.                                                                                             |                                                                                                                               |                                                                                                                                                                           |\n| [`--noImplicitOverride`](https://www.typescriptlang.org/tsconfig/#noImplicitOverride)                                                                                           | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Ensure overriding members in derived classes are marked with an override modifier.                                                                                              |                                                                                                                               |                                                                                                                                                                           |\n| [`--noImplicitReturns`](https://www.typescriptlang.org/tsconfig/#noImplicitReturns)                                                                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Enable error reporting for codepaths that do not explicitly return in a function.                                                                                               |                                                                                                                               |                                                                                                                                                                           |\n| [`--noImplicitThis`](https://www.typescriptlang.org/tsconfig/#noImplicitThis)                                                                                                   | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |\n| Enable error reporting when `this` is given the type `any`.                                                                                                                     |                                                                                                                               |                                                                                                                                                                           |\n| [`--noImplicitUseStrict`](https://www.typescriptlang.org/tsconfig/#noImplicitUseStrict)                                                                                         | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disable adding 'use strict' directives in emitted JavaScript files.                                                                                                             |                                                                                                                               |                                                                                                                                                                           |\n| [`--noLib`](https://www.typescriptlang.org/tsconfig/#noLib)                                                                                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disable including any library files, including the default lib.d.ts.                                                                                                            |                                                                                                                               |                                                                                                                                                                           |\n| [`--noPropertyAccessFromIndexSignature`](https://www.typescriptlang.org/tsconfig/#noPropertyAccessFromIndexSignature)                                                           | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Enforces using indexed accessors for keys declared using an indexed type.                                                                                                       |                                                                                                                               |                                                                                                                                                                           |\n| [`--noResolve`](https://www.typescriptlang.org/tsconfig/#noResolve)                                                                                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disallow `import`s, `require`s or `<reference>`s from expanding the number of files TypeScript should add to a project.                                                         |                                                                                                                               |                                                                                                                                                                           |\n| [`--noStrictGenericChecks`](https://www.typescriptlang.org/tsconfig/#noStrictGenericChecks)                                                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disable strict checking of generic signatures in function types.                                                                                                                |                                                                                                                               |                                                                                                                                                                           |\n| [`--noUncheckedIndexedAccess`](https://www.typescriptlang.org/tsconfig/#noUncheckedIndexedAccess)                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Add `undefined` to a type when accessed using an index.                                                                                                                         |                                                                                                                               |                                                                                                                                                                           |\n| [`--noUnusedLocals`](https://www.typescriptlang.org/tsconfig/#noUnusedLocals)                                                                                                   | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Enable error reporting when local variables aren't read.                                                                                                                        |                                                                                                                               |                                                                                                                                                                           |\n| [`--noUnusedParameters`](https://www.typescriptlang.org/tsconfig/#noUnusedParameters)                                                                                           | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Raise an error when a function parameter isn't read.                                                                                                                            |                                                                                                                               |                                                                                                                                                                           |\n| [`--out`](https://www.typescriptlang.org/tsconfig/#out)                                                                                                                         | `string`                                                                                                                      |                                                                                                                                                                           |\n| Deprecated setting. Use [`outFile`](#outFile) instead.                                                                                                                          |                                                                                                                               |                                                                                                                                                                           |\n| [`--outDir`](https://www.typescriptlang.org/tsconfig/#outDir)                                                                                                                   | `string`                                                                                                                      |                                                                                                                                                                           |\n| Specify an output folder for all emitted files.                                                                                                                                 |                                                                                                                               |                                                                                                                                                                           |\n| [`--outFile`](https://www.typescriptlang.org/tsconfig/#outFile)                                                                                                                 | `string`                                                                                                                      |                                                                                                                                                                           |\n| Specify a file that bundles all outputs into one JavaScript file. If [`declaration`](#declaration) is true, also designates a file that bundles all .d.ts output.               |                                                                                                                               |                                                                                                                                                                           |\n| [`--paths`](https://www.typescriptlang.org/tsconfig/#paths)                                                                                                                     | `object`                                                                                                                      |                                                                                                                                                                           |\n| Specify a set of entries that re-map imports to additional lookup locations.                                                                                                    |                                                                                                                               |                                                                                                                                                                           |\n| [`--plugins`](https://www.typescriptlang.org/tsconfig/#plugins)                                                                                                                 | `list`                                                                                                                        |                                                                                                                                                                           |\n| Specify a list of language service plugins to include.                                                                                                                          |                                                                                                                               |                                                                                                                                                                           |\n| [`--preserveConstEnums`](https://www.typescriptlang.org/tsconfig/#preserveConstEnums)                                                                                           | `boolean`                                                                                                                     | `true` if [`isolatedModules`](#isolatedModules); `false` otherwise.                                                                                                       |\n| Disable erasing `const enum` declarations in generated code.                                                                                                                    |                                                                                                                               |                                                                                                                                                                           |\n| [`--preserveSymlinks`](https://www.typescriptlang.org/tsconfig/#preserveSymlinks)                                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disable resolving symlinks to their realpath. This correlates to the same flag in node.                                                                                         |                                                                                                                               |                                                                                                                                                                           |\n| [`--preserveValueImports`](https://www.typescriptlang.org/tsconfig/#preserveValueImports)                                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Preserve unused imported values in the JavaScript output that would otherwise be removed.                                                                                       |                                                                                                                               |                                                                                                                                                                           |\n| [`--preserveWatchOutput`](https://www.typescriptlang.org/tsconfig/#preserveWatchOutput)                                                                                         | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disable wiping the console in watch mode.                                                                                                                                       |                                                                                                                               |                                                                                                                                                                           |\n| [`--pretty`](https://www.typescriptlang.org/tsconfig/#pretty)                                                                                                                   | `boolean`                                                                                                                     | `true`                                                                                                                                                                    |\n| Enable color and formatting in TypeScript's output to make compiler errors easier to read.                                                                                      |                                                                                                                               |                                                                                                                                                                           |\n| [`--reactNamespace`](https://www.typescriptlang.org/tsconfig/#reactNamespace)                                                                                                   | `string`                                                                                                                      | `React`                                                                                                                                                                   |\n| Specify the object invoked for `createElement`. This only applies when targeting `react` JSX emit.                                                                              |                                                                                                                               |                                                                                                                                                                           |\n| [`--removeComments`](https://www.typescriptlang.org/tsconfig/#removeComments)                                                                                                   | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disable emitting comments.                                                                                                                                                      |                                                                                                                               |                                                                                                                                                                           |\n| [`--resolveJsonModule`](https://www.typescriptlang.org/tsconfig/#resolveJsonModule)                                                                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Enable importing .json files.                                                                                                                                                   |                                                                                                                               |                                                                                                                                                                           |\n| [`--resolvePackageJsonExports`](https://www.typescriptlang.org/tsconfig/#resolvePackageJsonExports)                                                                             | `boolean`                                                                                                                     | `true` when [`moduleResolution`](#moduleResolution) is `node16`, `nodenext`, or `bundler`; otherwise `false`                                                              |\n| Use the package.json 'exports' field when resolving package imports.                                                                                                            |                                                                                                                               |                                                                                                                                                                           |\n| [`--resolvePackageJsonImports`](https://www.typescriptlang.org/tsconfig/#resolvePackageJsonImports)                                                                             | `boolean`                                                                                                                     | `true` when [`moduleResolution`](#moduleResolution) is `node16`, `nodenext`, or `bundler`; otherwise `false`                                                              |\n| Use the package.json 'imports' field when resolving imports.                                                                                                                    |                                                                                                                               |                                                                                                                                                                           |\n| [`--rootDir`](https://www.typescriptlang.org/tsconfig/#rootDir)                                                                                                                 | `string`                                                                                                                      | Computed from the list of input files.                                                                                                                                    |\n| Specify the root folder within your source files.                                                                                                                               |                                                                                                                               |                                                                                                                                                                           |\n| [`--rootDirs`](https://www.typescriptlang.org/tsconfig/#rootDirs)                                                                                                               | `list`                                                                                                                        | Computed from the list of input files.                                                                                                                                    |\n| Allow multiple folders to be treated as one when resolving modules.                                                                                                             |                                                                                                                               |                                                                                                                                                                           |\n| [`--skipDefaultLibCheck`](https://www.typescriptlang.org/tsconfig/#skipDefaultLibCheck)                                                                                         | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Skip type checking .d.ts files that are included with TypeScript.                                                                                                               |                                                                                                                               |                                                                                                                                                                           |\n| [`--skipLibCheck`](https://www.typescriptlang.org/tsconfig/#skipLibCheck)                                                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Skip type checking all .d.ts files.                                                                                                                                             |                                                                                                                               |                                                                                                                                                                           |\n| [`--sourceMap`](https://www.typescriptlang.org/tsconfig/#sourceMap)                                                                                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Create source map files for emitted JavaScript files.                                                                                                                           |                                                                                                                               |                                                                                                                                                                           |\n| [`--sourceRoot`](https://www.typescriptlang.org/tsconfig/#sourceRoot)                                                                                                           | `string`                                                                                                                      |                                                                                                                                                                           |\n| Specify the root path for debuggers to find the reference source code.                                                                                                          |                                                                                                                               |                                                                                                                                                                           |\n| [`--strict`](https://www.typescriptlang.org/tsconfig/#strict)                                                                                                                   | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Enable all strict type-checking options.                                                                                                                                        |                                                                                                                               |                                                                                                                                                                           |\n| [`--strictBindCallApply`](https://www.typescriptlang.org/tsconfig/#strictBindCallApply)                                                                                         | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |\n| Check that the arguments for `bind`, `call`, and `apply` methods match the original function.                                                                                   |                                                                                                                               |                                                                                                                                                                           |\n| [`--strictFunctionTypes`](https://www.typescriptlang.org/tsconfig/#strictFunctionTypes)                                                                                         | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |\n| When assigning functions, check to ensure parameters and the return values are subtype-compatible.                                                                              |                                                                                                                               |                                                                                                                                                                           |\n| [`--strictNullChecks`](https://www.typescriptlang.org/tsconfig/#strictNullChecks)                                                                                               | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |\n| When type checking, take into account `null` and `undefined`.                                                                                                                   |                                                                                                                               |                                                                                                                                                                           |\n| [`--strictPropertyInitialization`](https://www.typescriptlang.org/tsconfig/#strictPropertyInitialization)                                                                       | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |\n| Check for class properties that are declared but not set in the constructor.                                                                                                    |                                                                                                                               |                                                                                                                                                                           |\n| [`--stripInternal`](https://www.typescriptlang.org/tsconfig/#stripInternal)                                                                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disable emitting declarations that have `@internal` in their JSDoc comments.                                                                                                    |                                                                                                                               |                                                                                                                                                                           |\n| [`--suppressExcessPropertyErrors`](https://www.typescriptlang.org/tsconfig/#suppressExcessPropertyErrors)                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Disable reporting of excess property errors during the creation of object literals.                                                                                             |                                                                                                                               |                                                                                                                                                                           |\n| [`--suppressImplicitAnyIndexErrors`](https://www.typescriptlang.org/tsconfig/#suppressImplicitAnyIndexErrors)                                                                   | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Suppress [`noImplicitAny`](#noImplicitAny) errors when indexing objects that lack index signatures.                                                                             |                                                                                                                               |                                                                                                                                                                           |\n| [`--target`](https://www.typescriptlang.org/tsconfig/#target)                                                                                                                   | `es3`, `es5`, `es6`/`es2015`, `es2016`, `es2017`, `es2018`, `es2019`, `es2020`, `es2021`, `es2022`, `es2023`, or `esnext`     | `ES3`                                                                                                                                                                     |\n| Set the JavaScript language version for emitted JavaScript and include compatible library declarations.                                                                         |                                                                                                                               |                                                                                                                                                                           |\n| [`--traceResolution`](https://www.typescriptlang.org/tsconfig/#traceResolution)                                                                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Log paths used during the [`moduleResolution`](#moduleResolution) process.                                                                                                      |                                                                                                                               |                                                                                                                                                                           |\n| [`--tsBuildInfoFile`](https://www.typescriptlang.org/tsconfig/#tsBuildInfoFile)                                                                                                 | `string`                                                                                                                      | `.tsbuildinfo`                                                                                                                                                            |\n| The file to store `.tsbuildinfo` incremental build information in.                                                                                                              |                                                                                                                               |                                                                                                                                                                           |\n| [`--typeRoots`](https://www.typescriptlang.org/tsconfig/#typeRoots)                                                                                                             | `list`                                                                                                                        |                                                                                                                                                                           |\n| Specify multiple folders that act like `./node_modules/@types`.                                                                                                                 |                                                                                                                               |                                                                                                                                                                           |\n| [`--types`](https://www.typescriptlang.org/tsconfig/#types)                                                                                                                     | `list`                                                                                                                        |                                                                                                                                                                           |\n| Specify type package names to be included without being referenced in a source file.                                                                                            |                                                                                                                               |                                                                                                                                                                           |\n| [`--useDefineForClassFields`](https://www.typescriptlang.org/tsconfig/#useDefineForClassFields)                                                                                 | `boolean`                                                                                                                     | `true` if [`target`](#target) is `ES2022` or higher, including `ESNext`; `false` otherwise.                                                                               |\n| Emit ECMAScript-standard-compliant class fields.                                                                                                                                |                                                                                                                               |                                                                                                                                                                           |\n| [`--useUnknownInCatchVariables`](https://www.typescriptlang.org/tsconfig/#useUnknownInCatchVariables)                                                                           | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |\n| Default catch clause variables as `unknown` instead of `any`.                                                                                                                   |                                                                                                                               |                                                                                                                                                                           |\n| [`--verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax)                                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |\n| Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting.                  |                                                                                                                               |                                                                                                                                                                           |\n\n## Related\n\n- Every option is fully explained in the [TSConfig Reference](https://www.typescriptlang.org/tsconfig).\n- Learn how to use a [`tsconfig.json`](tsconfig-json) file.\n- Learn how to work in an [MSBuild project](compiler-options-in-msbuild).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)"
- name: 'tsc CLI Options: Compiler Options'
  id: compiler-options#compiler-options
  summary: null
  belongs_to: tsc CLI Options
  description: |-
    ## Compiler Options

    **If you’re looking for more information about the compiler options in a tsconfig, check out the [TSConfig Reference](https://www.typescriptlang.org/tsconfig)**

    ### CLI Commands

    | Flag                                                                                                 | Type      |     |
    |------------------------------------------------------------------------------------------------------|-----------|-----|
    | `--all`                                                                                              | `boolean` |     |
    | Show all compiler options.                                                                           |           |     |
    | `--generateTrace`                                                                                    | `string`  |     |
    | Generates an event trace and a list of types.                                                        |           |     |
    | `--help`                                                                                             | `boolean` |     |
    | Gives local information for help on the CLI.                                                         |           |     |
    | `--init`                                                                                             | `boolean` |     |
    | Initializes a TypeScript project and creates a tsconfig.json file.                                   |           |     |
    | `--listFilesOnly`                                                                                    | `boolean` |     |
    | Print names of files that are part of the compilation and then stop processing.                      |           |     |
    | `--locale`                                                                                           | `string`  |     |
    | Set the language of the messaging from TypeScript. This does not affect emit.                        |           |     |
    | `--project`                                                                                          | `string`  |     |
    | Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'. |           |     |
    | `--showConfig`                                                                                       | `boolean` |     |
    | Print the final configuration instead of building.                                                   |           |     |
    | `--version`                                                                                          | `boolean` |     |
    | Print the compiler's version.                                                                        |           |     |

    ### Build Options

    | Flag                                                                  | Type      |     |
    |-----------------------------------------------------------------------|-----------|-----|
    | `--build`                                                             | `boolean` |     |
    | Build one or more projects and their dependencies, if out of date     |           |     |
    | `--clean`                                                             | `boolean` |     |
    | Delete the outputs of all projects.                                   |           |     |
    | `--dry`                                                               | `boolean` |     |
    | Show what would be built (or deleted, if specified with '--clean')    |           |     |
    | ` `[`--force`](https://www.typescriptlang.org/tsconfig/#force)` `     | `boolean` |     |
    | Build all projects, including those that appear to be up to date.     |           |     |
    | ` `[`--verbose`](https://www.typescriptlang.org/tsconfig/#verbose)` ` | `boolean` |     |
    | Enable verbose logging.                                               |           |     |

    ### Watch Options

    | Flag                                                                                                                                  | Type                                                                                                                                                   |     |
    |---------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------|-----|
    | ` `[`--excludeDirectories`](https://www.typescriptlang.org/tsconfig/#excludeDirectories)` `                                           | `list`                                                                                                                                                 |     |
    | Remove a list of directories from the watch process.                                                                                  |                                                                                                                                                        |     |
    | ` `[`--excludeFiles`](https://www.typescriptlang.org/tsconfig/#excludeFiles)` `                                                       | `list`                                                                                                                                                 |     |
    | Remove a list of files from the watch mode's processing.                                                                              |                                                                                                                                                        |     |
    | ` `[`--fallbackPolling`](https://www.typescriptlang.org/tsconfig/#fallbackPolling)` `                                                 | `fixedinterval`, `priorityinterval`, `dynamicpriority`, or `fixedchunksize`                                                                            |     |
    | Specify what approach the watcher should use if the system runs out of native file watchers.                                          |                                                                                                                                                        |     |
    | ` `[`--synchronousWatchDirectory`](https://www.typescriptlang.org/tsconfig/#synchronousWatchDirectory)` `                             | `boolean`                                                                                                                                              |     |
    | Synchronously call callbacks and update the state of directory watchers on platforms that don\`t support recursive watching natively. |                                                                                                                                                        |     |
    | `--watch`                                                                                                                             | `boolean`                                                                                                                                              |     |
    | Watch input files.                                                                                                                    |                                                                                                                                                        |     |
    | ` `[`--watchDirectory`](https://www.typescriptlang.org/tsconfig/#watchDirectory)` `                                                   | `usefsevents`, `fixedpollinginterval`, `dynamicprioritypolling`, or `fixedchunksizepolling`                                                            |     |
    | Specify how directories are watched on systems that lack recursive file-watching functionality.                                       |                                                                                                                                                        |     |
    | ` `[`--watchFile`](https://www.typescriptlang.org/tsconfig/#watchFile)` `                                                             | `fixedpollinginterval`, `prioritypollinginterval`, `dynamicprioritypolling`, `fixedchunksizepolling`, `usefsevents`, or `usefseventsonparentdirectory` |     |
    | Specify how the TypeScript watch mode works.                                                                                          |                                                                                                                                                        |     |

    ### Compiler Flags

    | Flag                                                                                                                                                                            | Type                                                                                                                          | Default                                                                                                                                                                   |
    |---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | ` `[`--allowArbitraryExtensions`](https://www.typescriptlang.org/tsconfig/#allowArbitraryExtensions)` `                                                                         | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Enable importing files with any extension, provided a declaration file is present.                                                                                              |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--allowImportingTsExtensions`](https://www.typescriptlang.org/tsconfig/#allowImportingTsExtensions)` `                                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Allow imports to include TypeScript file extensions.                                                                                                                            |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--allowJs`](https://www.typescriptlang.org/tsconfig/#allowJs)` `                                                                                                           | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files.                                                                   |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--allowSyntheticDefaultImports`](https://www.typescriptlang.org/tsconfig/#allowSyntheticDefaultImports)` `                                                                 | `boolean`                                                                                                                     | `true` if [`esModuleInterop`](#esModuleInterop) is enabled, [`module`](#module) is `system`, or [`moduleResolution`](#module-resolution) is `bundler`; `false` otherwise. |
    | Allow 'import x from y' when a module doesn't have a default export.                                                                                                            |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--allowUmdGlobalAccess`](https://www.typescriptlang.org/tsconfig/#allowUmdGlobalAccess)` `                                                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Allow accessing UMD globals from modules.                                                                                                                                       |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--allowUnreachableCode`](https://www.typescriptlang.org/tsconfig/#allowUnreachableCode)` `                                                                                 | `boolean`                                                                                                                     |                                                                                                                                                                           |
    | Disable error reporting for unreachable code.                                                                                                                                   |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--allowUnusedLabels`](https://www.typescriptlang.org/tsconfig/#allowUnusedLabels)` `                                                                                       | `boolean`                                                                                                                     |                                                                                                                                                                           |
    | Disable error reporting for unused labels.                                                                                                                                      |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--alwaysStrict`](https://www.typescriptlang.org/tsconfig/#alwaysStrict)` `                                                                                                 | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |
    | Ensure 'use strict' is always emitted.                                                                                                                                          |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--assumeChangesOnlyAffectDirectDependencies`](https://www.typescriptlang.org/tsconfig/#assumeChangesOnlyAffectDirectDependencies)` `                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Have recompiles in projects that use [`incremental`](#incremental) and `watch` mode assume that changes within a file will only affect files directly depending on it.          |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--baseUrl`](https://www.typescriptlang.org/tsconfig/#baseUrl)` `                                                                                                           | `string`                                                                                                                      |                                                                                                                                                                           |
    | Specify the base directory to resolve bare specifier module names.                                                                                                              |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--charset`](https://www.typescriptlang.org/tsconfig/#charset)` `                                                                                                           | `string`                                                                                                                      | `utf8`                                                                                                                                                                    |
    | No longer supported. In early versions, manually set the text encoding for reading files.                                                                                       |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--checkJs`](https://www.typescriptlang.org/tsconfig/#checkJs)` `                                                                                                           | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Enable error reporting in type-checked JavaScript files.                                                                                                                        |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--composite`](https://www.typescriptlang.org/tsconfig/#composite)` `                                                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Enable constraints that allow a TypeScript project to be used with project references.                                                                                          |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--customConditions`](https://www.typescriptlang.org/tsconfig/#customConditions)` `                                                                                         | `list`                                                                                                                        |                                                                                                                                                                           |
    | Conditions to set in addition to the resolver-specific defaults when resolving imports.                                                                                         |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--declaration`](https://www.typescriptlang.org/tsconfig/#declaration)` `                                                                                                   | `boolean`                                                                                                                     | `true` if [`composite`](#composite); `false` otherwise.                                                                                                                   |
    | Generate .d.ts files from TypeScript and JavaScript files in your project.                                                                                                      |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--declarationDir`](https://www.typescriptlang.org/tsconfig/#declarationDir)` `                                                                                             | `string`                                                                                                                      |                                                                                                                                                                           |
    | Specify the output directory for generated declaration files.                                                                                                                   |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--declarationMap`](https://www.typescriptlang.org/tsconfig/#declarationMap)` `                                                                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Create sourcemaps for d.ts files.                                                                                                                                               |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--diagnostics`](https://www.typescriptlang.org/tsconfig/#diagnostics)` `                                                                                                   | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Output compiler performance information after building.                                                                                                                         |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--disableReferencedProjectLoad`](https://www.typescriptlang.org/tsconfig/#disableReferencedProjectLoad)` `                                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Reduce the number of projects loaded automatically by TypeScript.                                                                                                               |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--disableSizeLimit`](https://www.typescriptlang.org/tsconfig/#disableSizeLimit)` `                                                                                         | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Remove the 20mb cap on total source code size for JavaScript files in the TypeScript language server.                                                                           |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--disableSolutionSearching`](https://www.typescriptlang.org/tsconfig/#disableSolutionSearching)` `                                                                         | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Opt a project out of multi-project reference checking when editing.                                                                                                             |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--disableSourceOfProjectReferenceRedirect`](https://www.typescriptlang.org/tsconfig/#disableSourceOfProjectReferenceRedirect)` `                                           | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disable preferring source files instead of declaration files when referencing composite projects.                                                                               |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--downlevelIteration`](https://www.typescriptlang.org/tsconfig/#downlevelIteration)` `                                                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Emit more compliant, but verbose and less performant JavaScript for iteration.                                                                                                  |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--emitBOM`](https://www.typescriptlang.org/tsconfig/#emitBOM)` `                                                                                                           | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.                                                                                                            |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--emitDeclarationOnly`](https://www.typescriptlang.org/tsconfig/#emitDeclarationOnly)` `                                                                                   | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Only output d.ts files and not JavaScript files.                                                                                                                                |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--emitDecoratorMetadata`](https://www.typescriptlang.org/tsconfig/#emitDecoratorMetadata)` `                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Emit design-type metadata for decorated declarations in source files.                                                                                                           |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--esModuleInterop`](https://www.typescriptlang.org/tsconfig/#esModuleInterop)` `                                                                                           | `boolean`                                                                                                                     | `true` if [`module`](#module) is `node16` or `nodenext`; `false` otherwise.                                                                                               |
    | Emit additional JavaScript to ease support for importing CommonJS modules. This enables [`allowSyntheticDefaultImports`](#allowSyntheticDefaultImports) for type compatibility. |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--exactOptionalPropertyTypes`](https://www.typescriptlang.org/tsconfig/#exactOptionalPropertyTypes)` `                                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Interpret optional property types as written, rather than adding `undefined`.                                                                                                   |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--experimentalDecorators`](https://www.typescriptlang.org/tsconfig/#experimentalDecorators)` `                                                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Enable experimental support for TC39 stage 2 draft decorators.                                                                                                                  |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--explainFiles`](https://www.typescriptlang.org/tsconfig/#explainFiles)` `                                                                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Print files read during the compilation including why it was included.                                                                                                          |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--extendedDiagnostics`](https://www.typescriptlang.org/tsconfig/#extendedDiagnostics)` `                                                                                   | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Output more detailed compiler performance information after building.                                                                                                           |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--forceConsistentCasingInFileNames`](https://www.typescriptlang.org/tsconfig/#forceConsistentCasingInFileNames)` `                                                         | `boolean`                                                                                                                     | `true`                                                                                                                                                                    |
    | Ensure that casing is correct in imports.                                                                                                                                       |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--generateCpuProfile`](https://www.typescriptlang.org/tsconfig/#generateCpuProfile)` `                                                                                     | `string`                                                                                                                      | `profile.cpuprofile`                                                                                                                                                      |
    | Emit a v8 CPU profile of the compiler run for debugging.                                                                                                                        |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--importHelpers`](https://www.typescriptlang.org/tsconfig/#importHelpers)` `                                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Allow importing helper functions from tslib once per project, instead of including them per-file.                                                                               |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig/#importsNotUsedAsValues)` `                                                                             | `remove`, `preserve`, or `error`                                                                                              | `remove`                                                                                                                                                                  |
    | Specify emit/checking behavior for imports that are only used for types.                                                                                                        |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--incremental`](https://www.typescriptlang.org/tsconfig/#incremental)` `                                                                                                   | `boolean`                                                                                                                     | `true` if [`composite`](#composite); `false` otherwise.                                                                                                                   |
    | Save .tsbuildinfo files to allow for incremental compilation of projects.                                                                                                       |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--inlineSourceMap`](https://www.typescriptlang.org/tsconfig/#inlineSourceMap)` `                                                                                           | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Include sourcemap files inside the emitted JavaScript.                                                                                                                          |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--inlineSources`](https://www.typescriptlang.org/tsconfig/#inlineSources)` `                                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Include source code in the sourcemaps inside the emitted JavaScript.                                                                                                            |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--isolatedDeclarations`](https://www.typescriptlang.org/tsconfig/#isolatedDeclarations)` `                                                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Require sufficient annotation on exports so other tools can trivially generate declaration files.                                                                               |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--isolatedModules`](https://www.typescriptlang.org/tsconfig/#isolatedModules)` `                                                                                           | `boolean`                                                                                                                     | `true` if [`verbatimModuleSyntax`](#verbatimModuleSyntax); `false` otherwise.                                                                                             |
    | Ensure that each file can be safely transpiled without relying on other imports.                                                                                                |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--jsx`](https://www.typescriptlang.org/tsconfig/#jsx)` `                                                                                                                   | `preserve`, `react`, `react-native`, `react-jsx`, or `react-jsxdev`                                                           |                                                                                                                                                                           |
    | Specify what JSX code is generated.                                                                                                                                             |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--jsxFactory`](https://www.typescriptlang.org/tsconfig/#jsxFactory)` `                                                                                                     | `string`                                                                                                                      | `React.createElement`                                                                                                                                                     |
    | Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'.                                                                         |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig/#jsxFragmentFactory)` `                                                                                     | `string`                                                                                                                      | `React.Fragment`                                                                                                                                                          |
    | Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'.                                                        |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--jsxImportSource`](https://www.typescriptlang.org/tsconfig/#jsxImportSource)` `                                                                                           | `string`                                                                                                                      | `react`                                                                                                                                                                   |
    | Specify module specifier used to import the JSX factory functions when using `jsx: react-jsx*`.                                                                                 |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--keyofStringsOnly`](https://www.typescriptlang.org/tsconfig/#keyofStringsOnly)` `                                                                                         | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Make keyof only return strings instead of string, numbers or symbols. Legacy option.                                                                                            |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--lib`](https://www.typescriptlang.org/tsconfig/#lib)` `                                                                                                                   | `list`                                                                                                                        |                                                                                                                                                                           |
    | Specify a set of bundled library declaration files that describe the target runtime environment.                                                                                |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--listEmittedFiles`](https://www.typescriptlang.org/tsconfig/#listEmittedFiles)` `                                                                                         | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Print the names of emitted files after a compilation.                                                                                                                           |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--listFiles`](https://www.typescriptlang.org/tsconfig/#listFiles)` `                                                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Print all of the files read during the compilation.                                                                                                                             |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--mapRoot`](https://www.typescriptlang.org/tsconfig/#mapRoot)` `                                                                                                           | `string`                                                                                                                      |                                                                                                                                                                           |
    | Specify the location where debugger should locate map files instead of generated locations.                                                                                     |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--maxNodeModuleJsDepth`](https://www.typescriptlang.org/tsconfig/#maxNodeModuleJsDepth)` `                                                                                 | `number`                                                                                                                      | `0`                                                                                                                                                                       |
    | Specify the maximum folder depth used for checking JavaScript files from `node_modules`. Only applicable with [`allowJs`](#allowJs).                                            |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--module`](https://www.typescriptlang.org/tsconfig/#module)` `                                                                                                             | `none`, `commonjs`, `amd`, `umd`, `system`, `es6`/`es2015`, `es2020`, `es2022`, `esnext`, `node16`, `nodenext`, or `preserve` | `CommonJS` if [`target`](#target) is `ES3` or `ES5`; `ES6`/`ES2015` otherwise.                                                                                            |
    | Specify what module code is generated.                                                                                                                                          |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--moduleDetection`](https://www.typescriptlang.org/tsconfig/#moduleDetection)` `                                                                                           | `legacy`, `auto`, or `force`                                                                                                  | "auto": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.                                       |
    | Specify what method is used to detect whether a file is a script or a module.                                                                                                   |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--moduleResolution`](https://www.typescriptlang.org/tsconfig/#moduleResolution)` `                                                                                         | `classic`, `node10`/`node`, `node16`, `nodenext`, or `bundler`                                                                | `Classic` if [`module`](#module) is `AMD`, `UMD`, `System`, or `ES6`/`ES2015`; Matches if [`module`](#module) is `node16` or `nodenext`; `Node` otherwise.                |
    | Specify how TypeScript looks up a file from a given module specifier.                                                                                                           |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--moduleSuffixes`](https://www.typescriptlang.org/tsconfig/#moduleSuffixes)` `                                                                                             | `list`                                                                                                                        |                                                                                                                                                                           |
    | List of file name suffixes to search when resolving a module.                                                                                                                   |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--newLine`](https://www.typescriptlang.org/tsconfig/#newLine)` `                                                                                                           | `crlf` or `lf`                                                                                                                | `lf`                                                                                                                                                                      |
    | Set the newline character for emitting files.                                                                                                                                   |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noCheck`](https://www.typescriptlang.org/tsconfig/#noCheck)` `                                                                                                           | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disable full type checking (only critical parse and emit errors will be reported).                                                                                              |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noEmit`](https://www.typescriptlang.org/tsconfig/#noEmit)` `                                                                                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disable emitting files from a compilation.                                                                                                                                      |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noEmitHelpers`](https://www.typescriptlang.org/tsconfig/#noEmitHelpers)` `                                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disable generating custom helper functions like `__extends` in compiled output.                                                                                                 |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noEmitOnError`](https://www.typescriptlang.org/tsconfig/#noEmitOnError)` `                                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disable emitting files if any type checking errors are reported.                                                                                                                |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noErrorTruncation`](https://www.typescriptlang.org/tsconfig/#noErrorTruncation)` `                                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disable truncating types in error messages.                                                                                                                                     |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noFallthroughCasesInSwitch`](https://www.typescriptlang.org/tsconfig/#noFallthroughCasesInSwitch)` `                                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Enable error reporting for fallthrough cases in switch statements.                                                                                                              |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noImplicitAny`](https://www.typescriptlang.org/tsconfig/#noImplicitAny)` `                                                                                               | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |
    | Enable error reporting for expressions and declarations with an implied `any` type.                                                                                             |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noImplicitOverride`](https://www.typescriptlang.org/tsconfig/#noImplicitOverride)` `                                                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Ensure overriding members in derived classes are marked with an override modifier.                                                                                              |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noImplicitReturns`](https://www.typescriptlang.org/tsconfig/#noImplicitReturns)` `                                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Enable error reporting for codepaths that do not explicitly return in a function.                                                                                               |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noImplicitThis`](https://www.typescriptlang.org/tsconfig/#noImplicitThis)` `                                                                                             | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |
    | Enable error reporting when `this` is given the type `any`.                                                                                                                     |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noImplicitUseStrict`](https://www.typescriptlang.org/tsconfig/#noImplicitUseStrict)` `                                                                                   | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disable adding 'use strict' directives in emitted JavaScript files.                                                                                                             |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noLib`](https://www.typescriptlang.org/tsconfig/#noLib)` `                                                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disable including any library files, including the default lib.d.ts.                                                                                                            |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noPropertyAccessFromIndexSignature`](https://www.typescriptlang.org/tsconfig/#noPropertyAccessFromIndexSignature)` `                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Enforces using indexed accessors for keys declared using an indexed type.                                                                                                       |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noResolve`](https://www.typescriptlang.org/tsconfig/#noResolve)` `                                                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disallow `import`s, `require`s or `<reference>`s from expanding the number of files TypeScript should add to a project.                                                         |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noStrictGenericChecks`](https://www.typescriptlang.org/tsconfig/#noStrictGenericChecks)` `                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disable strict checking of generic signatures in function types.                                                                                                                |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noUncheckedIndexedAccess`](https://www.typescriptlang.org/tsconfig/#noUncheckedIndexedAccess)` `                                                                         | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Add `undefined` to a type when accessed using an index.                                                                                                                         |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noUnusedLocals`](https://www.typescriptlang.org/tsconfig/#noUnusedLocals)` `                                                                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Enable error reporting when local variables aren't read.                                                                                                                        |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--noUnusedParameters`](https://www.typescriptlang.org/tsconfig/#noUnusedParameters)` `                                                                                     | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Raise an error when a function parameter isn't read.                                                                                                                            |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--out`](https://www.typescriptlang.org/tsconfig/#out)` `                                                                                                                   | `string`                                                                                                                      |                                                                                                                                                                           |
    | Deprecated setting. Use [`outFile`](#outFile) instead.                                                                                                                          |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--outDir`](https://www.typescriptlang.org/tsconfig/#outDir)` `                                                                                                             | `string`                                                                                                                      |                                                                                                                                                                           |
    | Specify an output folder for all emitted files.                                                                                                                                 |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--outFile`](https://www.typescriptlang.org/tsconfig/#outFile)` `                                                                                                           | `string`                                                                                                                      |                                                                                                                                                                           |
    | Specify a file that bundles all outputs into one JavaScript file. If [`declaration`](#declaration) is true, also designates a file that bundles all .d.ts output.               |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--paths`](https://www.typescriptlang.org/tsconfig/#paths)` `                                                                                                               | `object`                                                                                                                      |                                                                                                                                                                           |
    | Specify a set of entries that re-map imports to additional lookup locations.                                                                                                    |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--plugins`](https://www.typescriptlang.org/tsconfig/#plugins)` `                                                                                                           | `list`                                                                                                                        |                                                                                                                                                                           |
    | Specify a list of language service plugins to include.                                                                                                                          |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--preserveConstEnums`](https://www.typescriptlang.org/tsconfig/#preserveConstEnums)` `                                                                                     | `boolean`                                                                                                                     | `true` if [`isolatedModules`](#isolatedModules); `false` otherwise.                                                                                                       |
    | Disable erasing `const enum` declarations in generated code.                                                                                                                    |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--preserveSymlinks`](https://www.typescriptlang.org/tsconfig/#preserveSymlinks)` `                                                                                         | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disable resolving symlinks to their realpath. This correlates to the same flag in node.                                                                                         |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--preserveValueImports`](https://www.typescriptlang.org/tsconfig/#preserveValueImports)` `                                                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Preserve unused imported values in the JavaScript output that would otherwise be removed.                                                                                       |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--preserveWatchOutput`](https://www.typescriptlang.org/tsconfig/#preserveWatchOutput)` `                                                                                   | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disable wiping the console in watch mode.                                                                                                                                       |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--pretty`](https://www.typescriptlang.org/tsconfig/#pretty)` `                                                                                                             | `boolean`                                                                                                                     | `true`                                                                                                                                                                    |
    | Enable color and formatting in TypeScript's output to make compiler errors easier to read.                                                                                      |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--reactNamespace`](https://www.typescriptlang.org/tsconfig/#reactNamespace)` `                                                                                             | `string`                                                                                                                      | `React`                                                                                                                                                                   |
    | Specify the object invoked for `createElement`. This only applies when targeting `react` JSX emit.                                                                              |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--removeComments`](https://www.typescriptlang.org/tsconfig/#removeComments)` `                                                                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disable emitting comments.                                                                                                                                                      |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--resolveJsonModule`](https://www.typescriptlang.org/tsconfig/#resolveJsonModule)` `                                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Enable importing .json files.                                                                                                                                                   |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--resolvePackageJsonExports`](https://www.typescriptlang.org/tsconfig/#resolvePackageJsonExports)` `                                                                       | `boolean`                                                                                                                     | `true` when [`moduleResolution`](#moduleResolution) is `node16`, `nodenext`, or `bundler`; otherwise `false`                                                              |
    | Use the package.json 'exports' field when resolving package imports.                                                                                                            |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--resolvePackageJsonImports`](https://www.typescriptlang.org/tsconfig/#resolvePackageJsonImports)` `                                                                       | `boolean`                                                                                                                     | `true` when [`moduleResolution`](#moduleResolution) is `node16`, `nodenext`, or `bundler`; otherwise `false`                                                              |
    | Use the package.json 'imports' field when resolving imports.                                                                                                                    |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--rootDir`](https://www.typescriptlang.org/tsconfig/#rootDir)` `                                                                                                           | `string`                                                                                                                      | Computed from the list of input files.                                                                                                                                    |
    | Specify the root folder within your source files.                                                                                                                               |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--rootDirs`](https://www.typescriptlang.org/tsconfig/#rootDirs)` `                                                                                                         | `list`                                                                                                                        | Computed from the list of input files.                                                                                                                                    |
    | Allow multiple folders to be treated as one when resolving modules.                                                                                                             |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--skipDefaultLibCheck`](https://www.typescriptlang.org/tsconfig/#skipDefaultLibCheck)` `                                                                                   | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Skip type checking .d.ts files that are included with TypeScript.                                                                                                               |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--skipLibCheck`](https://www.typescriptlang.org/tsconfig/#skipLibCheck)` `                                                                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Skip type checking all .d.ts files.                                                                                                                                             |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--sourceMap`](https://www.typescriptlang.org/tsconfig/#sourceMap)` `                                                                                                       | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Create source map files for emitted JavaScript files.                                                                                                                           |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--sourceRoot`](https://www.typescriptlang.org/tsconfig/#sourceRoot)` `                                                                                                     | `string`                                                                                                                      |                                                                                                                                                                           |
    | Specify the root path for debuggers to find the reference source code.                                                                                                          |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--strict`](https://www.typescriptlang.org/tsconfig/#strict)` `                                                                                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Enable all strict type-checking options.                                                                                                                                        |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--strictBindCallApply`](https://www.typescriptlang.org/tsconfig/#strictBindCallApply)` `                                                                                   | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |
    | Check that the arguments for `bind`, `call`, and `apply` methods match the original function.                                                                                   |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--strictFunctionTypes`](https://www.typescriptlang.org/tsconfig/#strictFunctionTypes)` `                                                                                   | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |
    | When assigning functions, check to ensure parameters and the return values are subtype-compatible.                                                                              |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--strictNullChecks`](https://www.typescriptlang.org/tsconfig/#strictNullChecks)` `                                                                                         | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |
    | When type checking, take into account `null` and `undefined`.                                                                                                                   |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--strictPropertyInitialization`](https://www.typescriptlang.org/tsconfig/#strictPropertyInitialization)` `                                                                 | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |
    | Check for class properties that are declared but not set in the constructor.                                                                                                    |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--stripInternal`](https://www.typescriptlang.org/tsconfig/#stripInternal)` `                                                                                               | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disable emitting declarations that have `@internal` in their JSDoc comments.                                                                                                    |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--suppressExcessPropertyErrors`](https://www.typescriptlang.org/tsconfig/#suppressExcessPropertyErrors)` `                                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Disable reporting of excess property errors during the creation of object literals.                                                                                             |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--suppressImplicitAnyIndexErrors`](https://www.typescriptlang.org/tsconfig/#suppressImplicitAnyIndexErrors)` `                                                             | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Suppress [`noImplicitAny`](#noImplicitAny) errors when indexing objects that lack index signatures.                                                                             |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--target`](https://www.typescriptlang.org/tsconfig/#target)` `                                                                                                             | `es3`, `es5`, `es6`/`es2015`, `es2016`, `es2017`, `es2018`, `es2019`, `es2020`, `es2021`, `es2022`, `es2023`, or `esnext`     | `ES3`                                                                                                                                                                     |
    | Set the JavaScript language version for emitted JavaScript and include compatible library declarations.                                                                         |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--traceResolution`](https://www.typescriptlang.org/tsconfig/#traceResolution)` `                                                                                           | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Log paths used during the [`moduleResolution`](#moduleResolution) process.                                                                                                      |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--tsBuildInfoFile`](https://www.typescriptlang.org/tsconfig/#tsBuildInfoFile)` `                                                                                           | `string`                                                                                                                      | `.tsbuildinfo`                                                                                                                                                            |
    | The file to store `.tsbuildinfo` incremental build information in.                                                                                                              |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--typeRoots`](https://www.typescriptlang.org/tsconfig/#typeRoots)` `                                                                                                       | `list`                                                                                                                        |                                                                                                                                                                           |
    | Specify multiple folders that act like `./node_modules/@types`.                                                                                                                 |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--types`](https://www.typescriptlang.org/tsconfig/#types)` `                                                                                                               | `list`                                                                                                                        |                                                                                                                                                                           |
    | Specify type package names to be included without being referenced in a source file.                                                                                            |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--useDefineForClassFields`](https://www.typescriptlang.org/tsconfig/#useDefineForClassFields)` `                                                                           | `boolean`                                                                                                                     | `true` if [`target`](#target) is `ES2022` or higher, including `ESNext`; `false` otherwise.                                                                               |
    | Emit ECMAScript-standard-compliant class fields.                                                                                                                                |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--useUnknownInCatchVariables`](https://www.typescriptlang.org/tsconfig/#useUnknownInCatchVariables)` `                                                                     | `boolean`                                                                                                                     | `true` if [`strict`](#strict); `false` otherwise.                                                                                                                         |
    | Default catch clause variables as `unknown` instead of `any`.                                                                                                                   |                                                                                                                               |                                                                                                                                                                           |
    | ` `[`--verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax)` `                                                                                 | `boolean`                                                                                                                     | `false`                                                                                                                                                                   |
    | Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting.                  |                                                                                                                               |                                                                                                                                                                           |
- name: 'tsc CLI Options: Related'
  id: compiler-options#related
  summary: © 2012-2024 Microsoft Licensed under the Apache License, Version 2.0
  belongs_to: tsc CLI Options
  description: "## Related\n\n- Every option is fully explained in the [TSConfig Reference](https://www.typescriptlang.org/tsconfig).\n- Learn how to use a [`tsconfig.json`](tsconfig-json) file.\n- Learn how to work in an [MSBuild project](compiler-options-in-msbuild).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)"
- name: 'tsc CLI Options: Using the CLI'
  id: compiler-options#using-the-cli
  summary: Running tsc locally will compile the closest project defined by a tsconfig.json, or you can compile a set of TypeScript files by passing in a glob of files you want
  belongs_to: tsc CLI Options
  description: |-
    ## Using the CLI

    Running `tsc` locally will compile the closest project defined by a `tsconfig.json`, or you can compile a set of TypeScript files by passing in a glob of files you want. When input files are specified on the command line, `tsconfig.json` files are ignored.

    ``` shell
    # Run a compile based on a backwards look through the fs for a tsconfig.json
    tsc

    # Emit JS for just the index.ts with the compiler defaults
    tsc index.ts

    # Emit JS for any .ts files in the folder src, with the default settings
    tsc src/*.ts

    # Emit files referenced in with the compiler settings from tsconfig.production.json
    tsc --project tsconfig.production.json

    # Emit d.ts files for a js file with showing compiler options which are booleans
    tsc index.js --declaration --emitDeclarationOnly

    # Emit a single .js file from two files via compiler options which take string arguments
    tsc app.ts util.ts --target esnext --outfile index.js
    ```
- name: TSConfig Reference
  id: tsconfig
  summary: Starting up are the root options in the TSConfig - these options relate to how your TypeScript or JavaScript project is set up
  description: "# TSConfig Reference\n\n[](#)\n\n## Intro to the TSConfig Reference\n\nA TSConfig file in a directory indicates that the directory is the root of a TypeScript or JavaScript project...\n\n## Compiler Options\n\n##### Top Level\n\n1.  [`files`](#files)`, `\n2.  [`extends`](#extends)`, `\n3.  [`include`](#include)`, `\n4.  [`exclude`](#exclude)` and `\n5.  [`references`](#references)\n\n#### [`\"compilerOptions\"`](#compilerOptions)\n\n##### Type Checking\n\n1.  [`allowUnreachableCode`](#allowUnreachableCode)`, `\n2.  [`allowUnusedLabels`](#allowUnusedLabels)`, `\n3.  [`alwaysStrict`](#alwaysStrict)`, `\n4.  [`exactOptionalPropertyTypes`](#exactOptionalPropertyTypes)`, `\n5.  [`noFallthroughCasesInSwitch`](#noFallthroughCasesInSwitch)`, `\n6.  [`noImplicitAny`](#noImplicitAny)`, `\n7.  [`noImplicitOverride`](#noImplicitOverride)`, `\n8.  [`noImplicitReturns`](#noImplicitReturns)`, `\n9.  [`noImplicitThis`](#noImplicitThis)`, `\n10. [`noPropertyAccessFromIndexSignature`](#noPropertyAccessFromIndexSignature)`, `\n11. [`noUncheckedIndexedAccess`](#noUncheckedIndexedAccess)`, `\n12. [`noUnusedLocals`](#noUnusedLocals)`, `\n13. [`noUnusedParameters`](#noUnusedParameters)`, `\n14. [`strict`](#strict)`, `\n15. [`strictBindCallApply`](#strictBindCallApply)`, `\n16. [`strictFunctionTypes`](#strictFunctionTypes)`, `\n17. [`strictNullChecks`](#strictNullChecks)`, `\n18. [`strictPropertyInitialization`](#strictPropertyInitialization)` and `\n19. [`useUnknownInCatchVariables`](#useUnknownInCatchVariables)\n\n##### Modules\n\n1.  [`allowArbitraryExtensions`](#allowArbitraryExtensions)`, `\n2.  [`allowImportingTsExtensions`](#allowImportingTsExtensions)`, `\n3.  [`allowUmdGlobalAccess`](#allowUmdGlobalAccess)`, `\n4.  [`baseUrl`](#baseUrl)`, `\n5.  [`customConditions`](#customConditions)`, `\n6.  [`module`](#module)`, `\n7.  [`moduleResolution`](#moduleResolution)`, `\n8.  [`moduleSuffixes`](#moduleSuffixes)`, `\n9.  [`noResolve`](#noResolve)`, `\n10. [`paths`](#paths)`, `\n11. [`resolveJsonModule`](#resolveJsonModule)`, `\n12. [`resolvePackageJsonExports`](#resolvePackageJsonExports)`, `\n13. [`resolvePackageJsonImports`](#resolvePackageJsonImports)`, `\n14. [`rootDir`](#rootDir)`, `\n15. [`rootDirs`](#rootDirs)`, `\n16. [`typeRoots`](#typeRoots)` and `\n17. [`types`](#types)\n\n##### Emit\n\n1.  [`declaration`](#declaration)`, `\n2.  [`declarationDir`](#declarationDir)`, `\n3.  [`declarationMap`](#declarationMap)`, `\n4.  [`downlevelIteration`](#downlevelIteration)`, `\n5.  [`emitBOM`](#emitBOM)`, `\n6.  [`emitDeclarationOnly`](#emitDeclarationOnly)`, `\n7.  [`importHelpers`](#importHelpers)`, `\n8.  [`inlineSourceMap`](#inlineSourceMap)`, `\n9.  [`inlineSources`](#inlineSources)`, `\n10. [`mapRoot`](#mapRoot)`, `\n11. [`newLine`](#newLine)`, `\n12. [`noEmit`](#noEmit)`, `\n13. [`noEmitHelpers`](#noEmitHelpers)`, `\n14. [`noEmitOnError`](#noEmitOnError)`, `\n15. [`outDir`](#outDir)`, `\n16. [`outFile`](#outFile)`, `\n17. [`preserveConstEnums`](#preserveConstEnums)`, `\n18. [`removeComments`](#removeComments)`, `\n19. [`sourceMap`](#sourceMap)`, `\n20. [`sourceRoot`](#sourceRoot)` and `\n21. [`stripInternal`](#stripInternal)\n\n##### JavaScript Support\n\n1.  [`allowJs`](#allowJs)`, `\n2.  [`checkJs`](#checkJs)` and `\n3.  [`maxNodeModuleJsDepth`](#maxNodeModuleJsDepth)\n\n##### Editor Support\n\n1.  [`disableSizeLimit`](#disableSizeLimit)` and `\n2.  [`plugins`](#plugins)\n\n##### Interop Constraints\n\n1.  [`allowSyntheticDefaultImports`](#allowSyntheticDefaultImports)`, `\n2.  [`esModuleInterop`](#esModuleInterop)`, `\n3.  [`forceConsistentCasingInFileNames`](#forceConsistentCasingInFileNames)`, `\n4.  [`isolatedDeclarations`](#isolatedDeclarations)`, `\n5.  [`isolatedModules`](#isolatedModules)`, `\n6.  [`preserveSymlinks`](#preserveSymlinks)` and `\n7.  [`verbatimModuleSyntax`](#verbatimModuleSyntax)\n\n##### Backwards Compatibility\n\n1.  [`charset`](#charset)`, `\n2.  [`importsNotUsedAsValues`](#importsNotUsedAsValues)`, `\n3.  [`keyofStringsOnly`](#keyofStringsOnly)`, `\n4.  [`noImplicitUseStrict`](#noImplicitUseStrict)`, `\n5.  [`noStrictGenericChecks`](#noStrictGenericChecks)`, `\n6.  [`out`](#out)`, `\n7.  [`preserveValueImports`](#preserveValueImports)`, `\n8.  [`suppressExcessPropertyErrors`](#suppressExcessPropertyErrors)` and `\n9.  [`suppressImplicitAnyIndexErrors`](#suppressImplicitAnyIndexErrors)\n\n##### Language and Environment\n\n1.  [`emitDecoratorMetadata`](#emitDecoratorMetadata)`, `\n2.  [`experimentalDecorators`](#experimentalDecorators)`, `\n3.  [`jsx`](#jsx)`, `\n4.  [`jsxFactory`](#jsxFactory)`, `\n5.  [`jsxFragmentFactory`](#jsxFragmentFactory)`, `\n6.  [`jsxImportSource`](#jsxImportSource)`, `\n7.  [`lib`](#lib)`, `\n8.  [`moduleDetection`](#moduleDetection)`, `\n9.  [`noLib`](#noLib)`, `\n10. [`reactNamespace`](#reactNamespace)`, `\n11. [`target`](#target)` and `\n12. [`useDefineForClassFields`](#useDefineForClassFields)\n\n##### Compiler Diagnostics\n\n1.  [`diagnostics`](#diagnostics)`, `\n2.  [`explainFiles`](#explainFiles)`, `\n3.  [`extendedDiagnostics`](#extendedDiagnostics)`, `\n4.  [`generateCpuProfile`](#generateCpuProfile)`, `\n5.  [`listEmittedFiles`](#listEmittedFiles)`, `\n6.  [`listFiles`](#listFiles)`, `\n7.  [`noCheck`](#noCheck)` and `\n8.  [`traceResolution`](#traceResolution)\n\n##### Projects\n\n1.  [`composite`](#composite)`, `\n2.  [`disableReferencedProjectLoad`](#disableReferencedProjectLoad)`, `\n3.  [`disableSolutionSearching`](#disableSolutionSearching)`, `\n4.  [`disableSourceOfProjectReferenceRedirect`](#disableSourceOfProjectReferenceRedirect)`, `\n5.  [`incremental`](#incremental)` and `\n6.  [`tsBuildInfoFile`](#tsBuildInfoFile)\n\n##### Output Formatting\n\n1.  [`noErrorTruncation`](#noErrorTruncation)`, `\n2.  [`preserveWatchOutput`](#preserveWatchOutput)` and `\n3.  [`pretty`](#pretty)\n\n##### Completeness\n\n1.  [`skipDefaultLibCheck`](#skipDefaultLibCheck)` and `\n2.  [`skipLibCheck`](#skipLibCheck)\n\n##### Command Line\n\n##### Watch Options\n\n1.  [`assumeChangesOnlyAffectDirectDependencies`](#assumeChangesOnlyAffectDirectDependencies)\n\n#### [`\"watchOptions\"`](#watchOptions)\n\n##### watchOptions\n\n1.  [`watchFile`](#watch-watchFile)`, `\n2.  [`watchDirectory`](#watch-watchDirectory)`, `\n3.  [`fallbackPolling`](#watch-fallbackPolling)`, `\n4.  [`synchronousWatchDirectory`](#watch-synchronousWatchDirectory)`, `\n5.  [`excludeDirectories`](#watch-excludeDirectories)` and `\n6.  [`excludeFiles`](#watch-excludeFiles)\n\n#### [`\"typeAcquisition\"`](#typeAcquisition)\n\n##### typeAcquisition\n\n1.  [`enable`](#type-enable)`, `\n2.  [`include`](#type-include)`, `\n3.  [`exclude`](#type-exclude)` and `\n4.  [`disableFilenameBasedTypeAcquisition`](#type-disableFilenameBasedTypeAcquisition)\n\n### Root Fields\n\nStarting up are the root options in the TSConfig - these options relate to how your TypeScript or JavaScript project is set up.\n\n### Files - `files`\n\nSpecifies an allowlist of files to include in the program. An error occurs if any of the files can’t be found.\n\n``` typescript\n{\n  \"compilerOptions\": {},\n  \"files\": [\n    \"core.ts\",\n    \"sys.ts\",\n    \"types.ts\",\n    \"scanner.ts\",\n    \"parser.ts\",\n    \"utilities.ts\",\n    \"binder.ts\",\n    \"checker.ts\",\n    \"tsc.ts\"\n  ]\n}\n```\n\nThis is useful when you only have a small number of files and don’t need to use a glob to reference many files. If you need that then use [`include`](#include).\n\n- Default:\n\n  `false`\n\n- Related:\n  - [`include`](#include)\n\n  - [`exclude`](#exclude)\n\n### Extends - `extends`\n\nThe value of `extends` is a string which contains a path to another configuration file to inherit from. The path may use Node.js style resolution.\n\nThe configuration from the base file are loaded first, then overridden by those in the inheriting config file. All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.\n\nIt’s worth noting that [`files`](#files), [`include`](#include), and [`exclude`](#exclude) from the inheriting config file *overwrite* those from the base config file, and that circularity between configuration files is not allowed.\n\nCurrently, the only top-level property that is excluded from inheritance is [`references`](#references).\n\n##### Example\n\n`configs/base.json`:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true\n  }\n}\n```\n\n`tsconfig.json`:\n\n``` typescript\n{\n  \"extends\": \"./configs/base\",\n  \"files\": [\"main.ts\", \"supplemental.ts\"]\n}\n```\n\n`tsconfig.nostrictnull.json`:\n\n``` typescript\n{\n  \"extends\": \"./tsconfig\",\n  \"compilerOptions\": {\n    \"strictNullChecks\": false\n  }\n}\n```\n\nProperties with relative paths found in the configuration file, which aren’t excluded from inheritance, will be resolved relative to the configuration file they originated in.\n\n- Default:\n\n  `false`\n\n- Released:\n\n  [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html)\n\n### Include - `include`\n\nSpecifies an array of filenames or patterns to include in the program. These filenames are resolved relative to the directory containing the `tsconfig.json` file.\n\n``` json\n{\n  \"include\": [\"src/**/*\", \"tests/**/*\"]\n}\n```\n\nWhich would include:\n\n``` typescript\n.\n├── scripts                ⨯\n│   ├── lint.ts            ⨯\n│   ├── update_deps.ts     ⨯\n│   └── utils.ts           ⨯\n├── src                    ✓\n│   ├── client             ✓\n│   │    ├── index.ts      ✓\n│   │    └── utils.ts      ✓\n│   ├── server             ✓\n│   │    └── index.ts      ✓\n├── tests                  ✓\n│   ├── app.test.ts        ✓\n│   ├── utils.ts           ✓\n│   └── tests.d.ts         ✓\n├── package.json\n├── tsconfig.json\n└── yarn.lock\n```\n\n`include` and `exclude` support wildcard characters to make glob patterns:\n\n- `*` matches zero or more characters (excluding directory separators)\n- `?` matches any one character (excluding directory separators)\n- `**/` matches any directory nested to any level\n\nIf the last path segment in a pattern does not contain a file extension or wildcard character, then it is treated as a directory, and files with supported extensions inside that directory are included (e.g. `.ts`, `.tsx`, and `.d.ts` by default, with `.js` and `.jsx` if [`allowJs`](#allowJs) is set to true).\n\n- Default:\n\n  `[]` if [`files`](#files) is specified; `**/*` otherwise.\n\n- Related:\n  - [`files`](#files)\n\n  - [`exclude`](#exclude)\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### Exclude - `exclude`\n\nSpecifies an array of filenames or patterns that should be skipped when resolving [`include`](#include).\n\n**Important**: `exclude` *only* changes which files are included as a result of the [`include`](#include) setting. A file specified by `exclude` can still become part of your codebase due to an `import` statement in your code, a `types` inclusion, a `/// <reference` directive, or being specified in the [`files`](#files) list.\n\nIt is not a mechanism that **prevents** a file from being included in the codebase - it simply changes what the [`include`](#include) setting finds.\n\n- Default:\n\n  node_modules bower_components jspm_packages [`outDir`](#outDir)\n\n- Related:\n  - [`include`](#include)\n\n  - [`files`](#files)\n\n### References - `references`\n\nProject references are a way to structure your TypeScript programs into smaller pieces. Using Project References can greatly improve build and editor interaction times, enforce logical separation between components, and organize your code in new and improved ways.\n\nYou can read more about how references works in the [Project References](docs/handbook/project-references) section of the handbook\n\n- Default:\n\n  `false`\n\n### Compiler Options\n\nThese options make up the bulk of TypeScript’s configuration and it covers how the language should work.\n\n- [Type Checking](#Type_Checking_6248)\n- [Modules](#Modules_6244)\n- [Emit](#Emit_6246)\n- [JavaScript Support](#JavaScript_Support_6247)\n- [Editor Support](#Editor_Support_6249)\n- [Interop Constraints](#Interop_Constraints_6252)\n- [Backwards Compatibility](#Backwards_Compatibility_6253)\n- [Language and Environment](#Language_and_Environment_6254)\n- [Compiler Diagnostics](#Compiler_Diagnostics_6251)\n- [Projects](#Projects_6255)\n- [Output Formatting](#Output_Formatting_6256)\n- [Completeness](#Completeness_6257)\n- [Command Line](#Command_line_Options_6171)\n- [Watch Options](#Watch_and_Build_Modes_6250)\n\n## Type Checking\n\n### Allow Unreachable Code - `allowUnreachableCode`\n\nWhen:\n\n- `undefined` (default) provide suggestions as warnings to editors\n- `true` unreachable code is ignored\n- `false` raises compiler errors about unreachable code\n\nThese warnings are only about code which is provably unreachable due to the use of JavaScript syntax, for example:\n\n``` ts\nfunction fn(n: number) {\n  if (n > 5) {\n    return true;\n  } else {\n    return false;\n  }\n  return true;\n}\n```\n\nWith `\"allowUnreachableCode\": false`:\n\n``` ts\nfunction fn(n: number) {\n  if (n > 5) {\n    return true;\n  } else {\n    return false;\n  }\n  return true;\n}\n```\n\nThis does not affect errors on the basis of code which *appears* to be unreachable due to type analysis.\n\n- Released:\n\n  [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)\n\n### Allow Unused Labels - `allowUnusedLabels`\n\nWhen:\n\n- `undefined` (default) provide suggestions as warnings to editors\n- `true` unused labels are ignored\n- `false` raises compiler errors about unused labels\n\nLabels are very rare in JavaScript and typically indicate an attempt to write an object literal:\n\n``` ts\nfunction verifyAge(age: number) {\n  // Forgot 'return' statement\n  if (age > 18) {\n    verified: true;\n  }\n}\n```\n\n- Released:\n\n  [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)\n\n### Always Strict - `alwaysStrict`\n\nEnsures that your files are parsed in the ECMAScript strict mode, and emit “use strict” for each source file.\n\n[ECMAScript strict](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode) mode was introduced in ES5 and provides behavior tweaks to the runtime of the JavaScript engine to improve performance, and makes a set of errors throw instead of silently ignoring them.\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n- Released:\n\n  [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html)\n\n### Exact Optional Property Types - `exactOptionalPropertyTypes`\n\nWith exactOptionalPropertyTypes enabled, TypeScript applies stricter rules around how it handles properties on `type` or `interfaces` which have a `?` prefix.\n\nFor example, this interface declares that there is a property which can be one of two strings: ‘dark’ or ‘light’ or it should not be in the object.\n\n``` ts\ninterface UserDefaults {\n  // The absence of a value represents 'system'\n  colorThemeOverride?: \"dark\" | \"light\";\n}\n```\n\nWithout this flag enabled, there are three values which you can set `colorThemeOverride` to be: “dark”, “light” and `undefined`.\n\nSetting the value to `undefined` will allow most JavaScript runtime checks for the existence to fail, which is effectively falsy. However, this isn’t quite accurate; `colorThemeOverride: undefined` is not the same as `colorThemeOverride` not being defined. For example, `\"colorThemeOverride\" in settings` would have different behavior with `undefined` as the key compared to not being defined.\n\n`exactOptionalPropertyTypes` makes TypeScript truly enforce the definition provided as an optional property:\n\n``` ts\nconst settings = getUserSettings();\nsettings.colorThemeOverride = \"dark\";\nsettings.colorThemeOverride = \"light\";\n \n// But not:\nsettings.colorThemeOverride = undefined;\n```\n\n- Recommended\n\n- Released:\n\n  [4.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html)\n\n### No Fallthrough Cases In Switch - `noFallthroughCasesInSwitch`\n\nReport errors for fallthrough cases in switch statements. Ensures that any non-empty case inside a switch statement includes either `break`, `return`, or `throw`. This means you won’t accidentally ship a case fallthrough bug.\n\n``` ts\nconst a: number = 6;\n \nswitch (a) {\n  case 0:\n    console.log(\"even\");\n  case 1:\n    console.log(\"odd\");\n    break;\n}\n```\n\n- Released:\n\n  [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)\n\n### No Implicit Any - `noImplicitAny`\n\nIn some cases where no type annotations are present, TypeScript will fall back to a type of `any` for a variable when it cannot infer the type.\n\nThis can cause some errors to be missed, for example:\n\n``` ts\nfunction fn(s) {\n  // No error?\n  console.log(s.subtr(3));\n}\nfn(42);\n```\n\nTurning on `noImplicitAny` however TypeScript will issue an error whenever it would have inferred `any`:\n\n``` ts\nfunction fn(s) {\n  console.log(s.subtr(3));\n}\n```\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n### No Implicit Override - `noImplicitOverride`\n\nWhen working with classes which use inheritance, it’s possible for a sub-class to get “out of sync” with the functions it overloads when they are renamed in the base class.\n\nFor example, imagine you are modeling a music album syncing system:\n\n``` ts\nclass Album {\n  download() {\n    // Default behavior\n  }\n}\n \nclass SharedAlbum extends Album {\n  download() {\n    // Override to get info from many sources\n  }\n}\n```\n\nThen when you add support for machine-learning generated playlists, you refactor the `Album` class to have a ‘setup’ function instead:\n\n``` ts\nclass Album {\n  setup() {\n    // Default behavior\n  }\n}\n \nclass MLAlbum extends Album {\n  setup() {\n    // Override to get info from algorithm\n  }\n}\n \nclass SharedAlbum extends Album {\n  download() {\n    // Override to get info from many sources\n  }\n}\n```\n\nIn this case, TypeScript has provided no warning that `download` on `SharedAlbum` *expected* to override a function in the base class.\n\nUsing `noImplicitOverride` you can ensure that the sub-classes never go out of sync, by ensuring that functions which override include the keyword `override`.\n\nThe following example has `noImplicitOverride` enabled, and you can see the error received when `override` is missing:\n\n``` ts\nclass Album {\n  setup() {}\n}\n \nclass MLAlbum extends Album {\n  override setup() {}\n}\n \nclass SharedAlbum extends Album {\n  setup() {}\n}\n```\n\n- Released:\n\n  [4.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html)\n\n### No Implicit Returns - `noImplicitReturns`\n\nWhen enabled, TypeScript will check all code paths in a function to ensure they return a value.\n\n``` ts\nfunction lookupHeadphonesManufacturer(color: \"blue\" | \"black\"): string {\n  if (color === \"blue\") {\n    return \"beats\";\n  } else {\n    (\"bose\");\n  }\n}\n```\n\n- Released:\n\n  [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)\n\n### No Implicit This - `noImplicitThis`\n\nRaise error on ‘this’ expressions with an implied ‘any’ type.\n\nFor example, the class below returns a function which tries to access `this.width` and `this.height` – but the context for `this` inside the function inside `getAreaFunction` is not the instance of the Rectangle.\n\n``` ts\nclass Rectangle {\n  width: number;\n  height: number;\n \n  constructor(width: number, height: number) {\n    this.width = width;\n    this.height = height;\n  }\n \n  getAreaFunction() {\n    return function () {\n      return this.width * this.height;\n    };\n  }\n}\n```\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### No Property Access From Index Signature - `noPropertyAccessFromIndexSignature`\n\nThis setting ensures consistency between accessing a field via the “dot” (`obj.key`) syntax, and “indexed” (`obj[\"key\"]`) and the way which the property is declared in the type.\n\nWithout this flag, TypeScript will allow you to use the dot syntax to access fields which are not defined:\n\n``` ts\ninterface GameSettings {\n  // Known up-front properties\n  speed: \"fast\" | \"medium\" | \"slow\";\n  quality: \"high\" | \"low\";\n \n  // Assume anything unknown to the interface\n  // is a string.\n  [key: string]: string;\n}\n \nconst settings = getSettings();\nsettings.speed;\nsettings.quality;\n \n// Unknown key accessors are allowed on\n// this object, and are `string`\nsettings.username;\n```\n\nTurning the flag on will raise an error because the unknown field uses dot syntax instead of indexed syntax.\n\n``` ts\nconst settings = getSettings();\nsettings.speed;\nsettings.quality;\n \n// This would need to be settings[\"username\"];\nsettings.username;\n```\n\nThe goal of this flag is to signal intent in your calling syntax about how certain you are this property exists.\n\n- Released:\n\n  [4.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html)\n\n### No Unchecked Indexed Access - `noUncheckedIndexedAccess`\n\nTypeScript has a way to describe objects which have unknown keys but known values on an object, via index signatures.\n\n``` ts\ninterface EnvironmentVars {\n  NAME: string;\n  OS: string;\n \n  // Unknown properties are covered by this index signature.\n  [propName: string]: string;\n}\n \ndeclare const env: EnvironmentVars;\n \n// Declared as existing\nconst sysName = env.NAME;\nconst os = env.OS;\n \n// Not declared, but because of the index\n// signature, then it is considered a string\nconst nodeEnv = env.NODE_ENV;\n```\n\nTurning on `noUncheckedIndexedAccess` will add `undefined` to any un-declared field in the type.\n\n``` ts\ndeclare const env: EnvironmentVars;\n \n// Declared as existing\nconst sysName = env.NAME;\nconst os = env.OS;\n \n// Not declared, but because of the index\n// signature, then it is considered a string\nconst nodeEnv = env.NODE_ENV;\n```\n\n- Released:\n\n  [4.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html)\n\n### No Unused Locals - `noUnusedLocals`\n\nReport errors on unused local variables.\n\n``` ts\nconst createKeyboard = (modelID: number) => {\n  const defaultModelID = 23;\n  return { type: \"keyboard\", modelID };\n};\n```\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### No Unused Parameters - `noUnusedParameters`\n\nReport errors on unused parameters in functions.\n\n``` ts\nconst createDefaultKeyboard = (modelID: number) => {\n  const defaultModelID = 23;\n  return { type: \"keyboard\", modelID: defaultModelID };\n};\n```\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### Strict - `strict`\n\nThe `strict` flag enables a wide range of type checking behavior that results in stronger guarantees of program correctness. Turning this on is equivalent to enabling all of the *strict mode family* options, which are outlined below. You can then turn off individual strict mode family checks as needed.\n\nFuture versions of TypeScript may introduce additional stricter checking under this flag, so upgrades of TypeScript might result in new type errors in your program. When appropriate and possible, a corresponding flag will be added to disable that behavior.\n\n- Recommended\n\n- Related:\n  - [`alwaysStrict`](#alwaysStrict)\n\n  - [`strictNullChecks`](#strictNullChecks)\n\n  - [`strictBindCallApply`](#strictBindCallApply)\n\n  - [`strictFunctionTypes`](#strictFunctionTypes)\n\n  - [`strictPropertyInitialization`](#strictPropertyInitialization)\n\n  - [`noImplicitAny`](#noImplicitAny)\n\n  - [`noImplicitThis`](#noImplicitThis)\n\n  - [`useUnknownInCatchVariables`](#useUnknownInCatchVariables)\n\n- Released:\n\n  [2.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html)\n\n### Strict Bind Call Apply - `strictBindCallApply`\n\nWhen set, TypeScript will check that the built-in methods of functions `call`, `bind`, and `apply` are invoked with correct argument for the underlying function:\n\n``` ts\n// With strictBindCallApply on\nfunction fn(x: string) {\n  return parseInt(x);\n}\n \nconst n1 = fn.call(undefined, \"10\");\n \nconst n2 = fn.call(undefined, false);\n```\n\nOtherwise, these functions accept any arguments and will return `any`:\n\n``` ts\n// With strictBindCallApply off\nfunction fn(x: string) {\n  return parseInt(x);\n}\n \n// Note: No error; return type is 'any'\nconst n = fn.call(undefined, false);\n```\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n- Released:\n\n  [3.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html)\n\n### Strict Function Types - `strictFunctionTypes`\n\nWhen enabled, this flag causes functions parameters to be checked more correctly.\n\nHere’s a basic example with `strictFunctionTypes` off:\n\n``` ts\nfunction fn(x: string) {\n  console.log(\"Hello, \" + x.toLowerCase());\n}\n \ntype StringOrNumberFunc = (ns: string | number) => void;\n \n// Unsafe assignment\nlet func: StringOrNumberFunc = fn;\n// Unsafe call - will crash\nfunc(10);\n```\n\nWith `strictFunctionTypes` *on*, the error is correctly detected:\n\n``` ts\nfunction fn(x: string) {\n  console.log(\"Hello, \" + x.toLowerCase());\n}\n \ntype StringOrNumberFunc = (ns: string | number) => void;\n \n// Unsafe assignment is prevented\nlet func: StringOrNumberFunc = fn;\n```\n\nDuring development of this feature, we discovered a large number of inherently unsafe class hierarchies, including some in the DOM. Because of this, the setting only applies to functions written in *function* syntax, not to those in *method* syntax:\n\n``` ts\ntype Methodish = {\n  func(x: string | number): void;\n};\n \nfunction fn(x: string) {\n  console.log(\"Hello, \" + x.toLowerCase());\n}\n \n// Ultimately an unsafe assignment, but not detected\nconst m: Methodish = {\n  func: fn,\n};\nm.func(10);\n```\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n- Released:\n\n  [2.6](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html)\n\n### Strict Null Checks - `strictNullChecks`\n\nWhen `strictNullChecks` is `false`, `null` and `undefined` are effectively ignored by the language. This can lead to unexpected errors at runtime.\n\nWhen `strictNullChecks` is `true`, `null` and `undefined` have their own distinct types and you’ll get a type error if you try to use them where a concrete value is expected.\n\nFor example with this TypeScript code, `users.find` has no guarantee that it will actually find a user, but you can write code as though it will:\n\n``` ts\ndeclare const loggedInUsername: string;\n \nconst users = [\n  { name: \"Oby\", age: 12 },\n  { name: \"Heera\", age: 32 },\n];\n \nconst loggedInUser = users.find((u) => u.name === loggedInUsername);\nconsole.log(loggedInUser.age);\n```\n\nSetting `strictNullChecks` to `true` will raise an error that you have not made a guarantee that the `loggedInUser` exists before trying to use it.\n\n``` ts\ndeclare const loggedInUsername: string;\n \nconst users = [\n  { name: \"Oby\", age: 12 },\n  { name: \"Heera\", age: 32 },\n];\n \nconst loggedInUser = users.find((u) => u.name === loggedInUsername);\nconsole.log(loggedInUser.age);\n```\n\nThe second example failed because the array’s `find` function looks a bit like this simplification:\n\n``` ts\n// When strictNullChecks: true\ntype Array = {\n  find(predicate: (value: any, index: number) => boolean): S | undefined;\n};\n\n// When strictNullChecks: false the undefined is removed from the type system,\n// allowing you to write code which assumes it always found a result\ntype Array = {\n  find(predicate: (value: any, index: number) => boolean): S;\n};\n```\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### Strict Property Initialization - `strictPropertyInitialization`\n\nWhen set to true, TypeScript will raise an error when a class property was declared but not set in the constructor.\n\n``` ts\nclass UserAccount {\n  name: string;\n  accountType = \"user\";\n \n  email: string;\n  address: string | undefined;\n \n  constructor(name: string) {\n    this.name = name;\n    // Note that this.email is not set\n  }\n}\n```\n\nIn the above case:\n\n- `this.name` is set specifically.\n- `this.accountType` is set by default.\n- `this.email` is not set and raises an error.\n- `this.address` is declared as potentially `undefined` which means it does not have to be set.\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n- Released:\n\n  [2.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html)\n\n### Use Unknown In Catch Variables - `useUnknownInCatchVariables`\n\nIn TypeScript 4.0, support was added to allow changing the type of the variable in a catch clause from `any` to `unknown`. Allowing for code like:\n\n``` ts\ntry {\n  // ...\n} catch (err: unknown) {\n  // We have to verify err is an\n  // error before using it as one.\n  if (err instanceof Error) {\n    console.log(err.message);\n  }\n}\n```\n\nThis pattern ensures that error handling code becomes more comprehensive because you cannot guarantee that the object being thrown *is* a Error subclass ahead of time. With the flag `useUnknownInCatchVariables` enabled, then you do not need the additional syntax (`: unknown`) nor a linter rule to try enforce this behavior.\n\n- Recommended\n\n- Default:\n\n  `true` if [`strict`](#strict); `false` otherwise.\n\n- Related:\n  - [`strict`](#strict)\n\n- Released:\n\n  [4.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html)\n\n## Modules\n\n### Allow Arbitrary Extensions - `allowArbitraryExtensions`\n\nIn TypeScript 5.0, when an import path ends in an extension that isn’t a known JavaScript or TypeScript file extension, the compiler will look for a declaration file for that path in the form of `{file basename}.d.{extension}.ts`. For example, if you are using a CSS loader in a bundler project, you might want to write (or generate) declaration files for those stylesheets:\n\n``` css\n/* app.css */\n.cookie-banner {\n  display: none;\n}\n```\n\n``` ts\n// app.d.css.ts\ndeclare const css: {\n  cookieBanner: string;\n};\nexport default css;\n```\n\n``` ts\n// App.tsx\nimport styles from \"./app.css\";\n\nstyles.cookieBanner; // string\n```\n\nBy default, this import will raise an error to let you know that TypeScript doesn’t understand this file type and your runtime might not support importing it. But if you’ve configured your runtime or bundler to handle it, you can suppress the error with the new `--allowArbitraryExtensions` compiler option.\n\nNote that historically, a similar effect has often been achievable by adding a declaration file named `app.css.d.ts` instead of `app.d.css.ts` - however, this just worked through Node’s `require` resolution rules for CommonJS. Strictly speaking, the former is interpreted as a declaration file for a JavaScript file named `app.css.js`. Because relative files imports need to include extensions in Node’s ESM support, TypeScript would error on our example in an ESM file under `--moduleResolution node16` or `nodenext`.\n\nFor more information, read up [the proposal for this feature](https://github.com/microsoft/TypeScript/issues/50133) and [its corresponding pull request](https://github.com/microsoft/TypeScript/pull/51435).\n\n### Allow Importing TS Extensions - `allowImportingTsExtensions`\n\n`--allowImportingTsExtensions` allows TypeScript files to import each other with a TypeScript-specific extension like `.ts`, `.mts`, or `.tsx`.\n\nThis flag is only allowed when `--noEmit` or `--emitDeclarationOnly` is enabled, since these import paths would not be resolvable at runtime in JavaScript output files. The expectation here is that your resolver (e.g. your bundler, a runtime, or some other tool) is going to make these imports between `.ts` files work.\n\n### Allow Umd Global Access - `allowUmdGlobalAccess`\n\nWhen set to true, `allowUmdGlobalAccess` lets you access UMD exports as globals from inside module files. A module file is a file that has imports and/or exports. Without this flag, using an export from a UMD module requires an import declaration.\n\nAn example use case for this flag would be a web project where you know the particular library (like jQuery or Lodash) will always be available at runtime, but you can’t access it with an import.\n\n- Released:\n\n  [3.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html)\n\n### Base URL - `baseUrl`\n\nSets a base directory from which to resolve bare specifier module names. For example, in the directory structure:\n\n``` typescript\nproject\n├── ex.ts\n├── hello\n│   └── world.ts\n└── tsconfig.json\n```\n\nWith `\"baseUrl\": \"./\"`, TypeScript will look for files starting at the same folder as the `tsconfig.json`:\n\n``` ts\nimport { helloWorld } from \"hello/world\";\n\nconsole.log(helloWorld);\n```\n\nThis resolution has higher priority than lookups from `node_modules`.\n\nThis feature was designed for use in conjunction with AMD module loaders in the browser, and is not recommended in any other context. As of TypeScript 4.1, `baseUrl` is no longer required to be set when using [`paths`](#paths).\n\n### Custom Conditions - `customConditions`\n\n`--customConditions` takes a list of additional [conditions](https://nodejs.org/api/packages.html#nested-conditions) that should succeed when TypeScript resolves from an [`exports`](https://nodejs.org/api/packages.html#exports) or [`imports`](https://nodejs.org/api/packages.html#imports) field of a `package.json`. These conditions are added to whatever existing conditions a resolver will use by default.\n\nFor example, when this field is set in a `tsconfig.json` as so:\n\n``` jsonc\n{\n  \"compilerOptions\": {\n    \"target\": \"es2022\",\n    \"moduleResolution\": \"bundler\",\n    \"customConditions\": [\"my-condition\"]\n  }\n}\n```\n\nAny time an `exports` or `imports` field is referenced in `package.json`, TypeScript will consider conditions called `my-condition`.\n\nSo when importing from a package with the following `package.json`\n\n``` jsonc\n{\n  // ...\n  \"exports\": {\n    \".\": {\n      \"my-condition\": \"./foo.mjs\",\n      \"node\": \"./bar.mjs\",\n      \"import\": \"./baz.mjs\",\n      \"require\": \"./biz.mjs\"\n    }\n  }\n}\n```\n\nTypeScript will try to look for files corresponding to `foo.mjs`.\n\nThis field is only valid under the `node16`, `nodenext`, and `bundler` options for [`--moduleResolution`](#moduleResolution).\n\n- Related:\n  - [`moduleResolution`](#moduleResolution)\n\n  - [`resolvePackageJsonExports`](#resolvePackageJsonExports)\n\n  - [`resolvePackageJsonImports`](#resolvePackageJsonImports)\n\n### Module - `module`\n\nSets the module system for the program. See the [theory behind TypeScript’s `module` option](docs/handbook/modules/theory#the-module-output-format) and [its reference page](docs/handbook/modules/reference#the-module-compiler-option) for more information. You very likely want `\"nodenext\"` for modern Node.js projects and `preserve` or `esnext` for code that will be bundled.\n\nChanging `module` affects [`moduleResolution`](#moduleResolution) which [also has a reference page](docs/handbook/modules/reference#the-moduleresolution-compiler-option).\n\nHere’s some example output for this file:\n\n``` ts\n// @filename: index.ts\nimport { valueOfPi } from \"./constants\";\n \nexport const twoPi = valueOfPi * 2;\n```\n\n#### `CommonJS`\n\n``` ts\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.twoPi = void 0;\nconst constants_1 = require(\"./constants\");\nexports.twoPi = constants_1.valueOfPi * 2;\n \n```\n\n#### `UMD`\n\n``` ts\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./constants\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.twoPi = void 0;\n    const constants_1 = require(\"./constants\");\n    exports.twoPi = constants_1.valueOfPi * 2;\n});\n \n```\n\n#### `AMD`\n\n``` ts\ndefine([\"require\", \"exports\", \"./constants\"], function (require, exports, constants_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.twoPi = void 0;\n    exports.twoPi = constants_1.valueOfPi * 2;\n});\n \n```\n\n#### `System`\n\n``` ts\nSystem.register([\"./constants\"], function (exports_1, context_1) {\n    \"use strict\";\n    var constants_1, twoPi;\n    var __moduleName = context_1 && context_1.id;\n    return {\n        setters: [\n            function (constants_1_1) {\n                constants_1 = constants_1_1;\n            }\n        ],\n        execute: function () {\n            exports_1(\"twoPi\", twoPi = constants_1.valueOfPi * 2);\n        }\n    };\n});\n \n```\n\n#### `ESNext`\n\n``` ts\nimport { valueOfPi } from \"./constants\";\nexport const twoPi = valueOfPi * 2;\n \n```\n\n#### `ES2015`/`ES6`/`ES2020`/`ES2022`\n\n``` ts\nimport { valueOfPi } from \"./constants\";\nexport const twoPi = valueOfPi * 2;\n \n```\n\nIn addition to the base functionality of `ES2015`/`ES6`, `ES2020` adds support for [dynamic `import`s](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import), and [`import.meta`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta) while `ES2022` further adds support for [top level `await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#top_level_await).\n\n#### `node16`/`nodenext`\n\nAvailable from 4.7+, the `node16` and `nodenext` modes integrate with Node’s [native ECMAScript Module support](https://nodejs.org/api/esm.html). The emitted JavaScript uses either `CommonJS` or `ES2020` output depending on the file extension and the value of the `type` setting in the nearest `package.json`. Module resolution also works differently. You can learn more in the [handbook](docs/handbook/modules/reference#node16-nodenext) and [Modules Reference](docs/handbook/modules/reference#node16-nodenext).\n\n#### `preserve`\n\nIn `--module preserve` ([added](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-bundler-and---module-preserve) in TypeScript 5.4), ECMAScript imports and exports written in input files are preserved in the output, and CommonJS-style `import x = require(\"...\")` and `export = ...` statements are emitted as CommonJS `require` and `module.exports`. In other words, the format of each individual import or export statement is preserved, rather than being coerced into a single format for the whole compilation (or even a whole file).\n\n``` ts\nimport { valueOfPi } from \"./constants\";\nconst constants = require(\"./constants\");\nexport const piSquared = valueOfPi * constants.valueOfPi;\n \n```\n\nWhile it’s rare to need to mix imports and require calls in the same file, this `module` mode best reflects the capabilities of most modern bundlers, as well as the Bun runtime.\n\n> Why care about TypeScript’s `module` emit with a bundler or with Bun, where you’re likely also setting `noEmit`? TypeScript’s type checking and module resolution behavior are affected by the module format that it *would* emit. Setting `module` gives TypeScript information about how your bundler or runtime will process imports and exports, which ensures that the types you see on imported values accurately reflect what will happen at runtime or after bundling.\n\n#### `None`\n\n``` ts\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.twoPi = void 0;\nconst constants_1 = require(\"./constants\");\nexports.twoPi = constants_1.valueOfPi * 2;\n \n```\n\n- Default:\n\n  `CommonJS` if [`target`](#target) is `ES3` or `ES5`; `ES6`/`ES2015` otherwise.\n\n- Allowed:\n  - `none`\n\n  - `commonjs`\n\n  - `amd`\n\n  - `umd`\n\n  - `system`\n\n  - `es6`/`es2015`\n\n  - `es2020`\n\n  - `es2022`\n\n  - `esnext`\n\n  - `node16`\n\n  - `nodenext`\n\n  - `preserve`\n\n- Related:\n  - [`moduleResolution`](#moduleResolution)\n\n  - [`esModuleInterop`](#esModuleInterop)\n\n  - [`allowImportingTsExtensions`](#allowImportingTsExtensions)\n\n  - [`allowArbitraryExtensions`](#allowArbitraryExtensions)\n\n  - [`resolveJsonModule`](#resolveJsonModule)\n\n- Released:\n\n  [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)\n\n### Module Resolution - `moduleResolution`\n\nSpecify the module resolution strategy:\n\n- `'node16'` or `'nodenext'` for modern versions of Node.js. Node.js v12 and later supports both ECMAScript imports and CommonJS `require`, which resolve using different algorithms. These `moduleResolution` values, when combined with the corresponding [`module`](#module) values, picks the right algorithm for each resolution based on whether Node.js will see an `import` or `require` in the output JavaScript code.\n- `'node10'` (previously called `'node'`) for Node.js versions older than v10, which only support CommonJS `require`. You probably won’t need to use `node10` in modern code.\n- `'bundler'` for use with bundlers. Like `node16` and `nodenext`, this mode supports package.json `\"imports\"` and `\"exports\"`, but unlike the Node.js resolution modes, `bundler` never requires file extensions on relative paths in imports.\n- `'classic'` was used in TypeScript before the release of 1.6. `classic` should not be used.\n\nThere are reference pages explaining the [theory behind TypeScript’s module resolution](docs/handbook/modules/theory#module-resolution) and the [details of each option](docs/handbook/modules/reference#the-moduleresolution-compiler-option).\n\n- Default:\n\n  `Classic` if [`module`](#module) is `AMD`, `UMD`, `System`, or `ES6`/`ES2015`; Matches if [`module`](#module) is `node16` or `nodenext`; `Node` otherwise.\n\n- Allowed:\n  - `classic`\n\n  - `node10`/`node`\n\n  - `node16`\n\n  - `nodenext`\n\n  - `bundler`\n\n- Related:\n  - [`module`](#module)\n\n  - [`paths`](#paths)\n\n  - [`baseUrl`](#baseUrl)\n\n  - [`rootDirs`](#rootDirs)\n\n  - [`moduleSuffixes`](#moduleSuffixes)\n\n  - [`customConditions`](#customConditions)\n\n  - [`resolvePackageJsonExports`](#resolvePackageJsonExports)\n\n  - [`resolvePackageJsonImports`](#resolvePackageJsonImports)\n\n### Module Suffixes - `moduleSuffixes`\n\nProvides a way to override the default list of file name suffixes to search when resolving a module.\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"moduleSuffixes\": [\".ios\", \".native\", \"\"]\n  }\n}\n```\n\nGiven the above configuration, an import like the following:\n\n``` ts\nimport * as foo from \"./foo\";\n```\n\nTypeScript will look for the relative files `./foo.ios.ts`, `./foo.native.ts`, and finally `./foo.ts`.\n\nNote the empty string `\"\"` in [`moduleSuffixes`](#moduleSuffixes) which is necessary for TypeScript to also look-up `./foo.ts`.\n\nThis feature can be useful for React Native projects where each target platform can use a separate tsconfig.json with differing `moduleSuffixes`.\n\n- Released:\n\n  [4.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html)\n\n### No Resolve - `noResolve`\n\nBy default, TypeScript will examine the initial set of files for `import` and `<reference` directives and add these resolved files to your program.\n\nIf `noResolve` is set, this process doesn’t happen. However, `import` statements are still checked to see if they resolve to a valid module, so you’ll need to make sure this is satisfied by some other means.\n\n### Paths - `paths`\n\nA series of entries which re-map imports to lookup locations relative to the [`baseUrl`](#baseUrl) if set, or to the tsconfig file itself otherwise. There is a larger coverage of `paths` in [the `moduleResolution` reference page](docs/handbook/modules/reference#paths).\n\n`paths` lets you declare how TypeScript should resolve an import in your `require`/`import`s.\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"jquery\": [\"./vendor/jquery/dist/jquery\"]\n    }\n  }\n}\n```\n\nThis would allow you to be able to write `import \"jquery\"`, and get all of the correct typing locally.\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"paths\": {\n        \"app/*\": [\"./src/app/*\"],\n        \"config/*\": [\"./src/app/_config/*\"],\n        \"environment/*\": [\"./src/environments/*\"],\n        \"shared/*\": [\"./src/app/_shared/*\"],\n        \"helpers/*\": [\"./src/helpers/*\"],\n        \"tests/*\": [\"./src/tests/*\"]\n    },\n}\n```\n\nIn this case, you can tell the TypeScript file resolver to support a number of custom prefixes to find code.\n\nNote that this feature does not change how import paths are emitted by `tsc`, so `paths` should only be used to inform TypeScript that another tool has this mapping and will use it at runtime or when bundling.\n\n### Resolve JSON Module - `resolveJsonModule`\n\nAllows importing modules with a `.json` extension, which is a common practice in node projects. This includes generating a type for the `import` based on the static JSON shape.\n\nTypeScript does not support resolving JSON files by default:\n\n``` ts\n// @filename: settings.json\n{\n    \"repo\": \"TypeScript\",\n    \"dry\": false,\n    \"debug\": false\n}\n// @filename: index.ts\nimport settings from \"./settings.json\";\n \nsettings.debug === true;\nsettings.dry === 2;\n```\n\nEnabling the option allows importing JSON, and validating the types in that JSON file.\n\n``` ts\n// @filename: settings.json\n{\n    \"repo\": \"TypeScript\",\n    \"dry\": false,\n    \"debug\": false\n}\n// @filename: index.ts\nimport settings from \"./settings.json\";\n \nsettings.debug === true;\nsettings.dry === 2;\n```\n\n### Resolve package.json Exports - `resolvePackageJsonExports`\n\n`--resolvePackageJsonExports` forces TypeScript to consult [the `exports` field of `package.json` files](https://nodejs.org/api/packages.html#exports) if it ever reads from a package in `node_modules`.\n\nThis option defaults to `true` under the `node16`, `nodenext`, and `bundler` options for [`--moduleResolution`](#moduleResolution).\n\n- Default:\n\n  `true` when [`moduleResolution`](#moduleResolution) is `node16`, `nodenext`, or `bundler`; otherwise `false`\n\n- Related:\n  - [`moduleResolution`](#moduleResolution)\n\n  - [`customConditions`](#customConditions)\n\n  - [`resolvePackageJsonImports`](#resolvePackageJsonImports)\n\n### Resolve package.json Imports - `resolvePackageJsonImports`\n\n`--resolvePackageJsonImports` forces TypeScript to consult [the `imports` field of `package.json` files](https://nodejs.org/api/packages.html#imports) when performing a lookup that starts with `#` from a file whose ancestor directory contains a `package.json`.\n\nThis option defaults to `true` under the `node16`, `nodenext`, and `bundler` options for [`--moduleResolution`](#moduleResolution).\n\n- Default:\n\n  `true` when [`moduleResolution`](#moduleResolution) is `node16`, `nodenext`, or `bundler`; otherwise `false`\n\n- Related:\n  - [`moduleResolution`](#moduleResolution)\n\n  - [`customConditions`](#customConditions)\n\n  - [`resolvePackageJsonExports`](#resolvePackageJsonExports)\n\n### Root Dir - `rootDir`\n\n**Default**: The longest common path of all non-declaration input files. If [`composite`](#composite) is set, the default is instead the directory containing the `tsconfig.json` file.\n\nWhen TypeScript compiles files, it keeps the same directory structure in the output directory as exists in the input directory.\n\nFor example, let’s say you have some input files:\n\n``` typescript\nMyProj\n├── tsconfig.json\n├── core\n│   ├── a.ts\n│   ├── b.ts\n│   ├── sub\n│   │   ├── c.ts\n├── types.d.ts\n```\n\nThe inferred value for `rootDir` is the longest common path of all non-declaration input files, which in this case is `core/`.\n\nIf your [`outDir`](#outDir) was `dist`, TypeScript would write this tree:\n\n``` typescript\nMyProj\n├── dist\n│   ├── a.js\n│   ├── b.js\n│   ├── sub\n│   │   ├── c.js\n```\n\nHowever, you may have intended for `core` to be part of the output directory structure. By setting `rootDir: \".\"` in `tsconfig.json`, TypeScript would write this tree:\n\n``` typescript\nMyProj\n├── dist\n│   ├── core\n│   │   ├── a.js\n│   │   ├── b.js\n│   │   ├── sub\n│   │   │   ├── c.js\n```\n\nImportantly, `rootDir` **does not affect which files become part of the compilation**. It has no interaction with the [`include`](#include), [`exclude`](#exclude), or [`files`](#files) `tsconfig.json` settings.\n\nNote that TypeScript will never write an output file to a directory outside of [`outDir`](#outDir), and will never skip emitting a file. For this reason, `rootDir` also enforces that all files which need to be emitted are underneath the `rootDir` path.\n\nFor example, let’s say you had this tree:\n\n``` typescript\nMyProj\n├── tsconfig.json\n├── core\n│   ├── a.ts\n│   ├── b.ts\n├── helpers.ts\n```\n\nIt would be an error to specify `rootDir` as `core` *and* [`include`](#include) as `*` because it creates a file (`helpers.ts`) that would need to be emitted *outside* the [`outDir`](#outDir) (i.e. `../helpers.js`).\n\n- Default:\n\n  Computed from the list of input files.\n\n- Released:\n\n  [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)\n\n### Root Dirs - `rootDirs`\n\nUsing `rootDirs`, you can inform the compiler that there are many “virtual” directories acting as a single root. This allows the compiler to resolve relative module imports within these “virtual” directories, as if they were merged in to one directory.\n\nFor example:\n\n``` typescript\n src\n └── views\n     └── view1.ts (can import \"./template1\", \"./view2`)\n     └── view2.ts (can import \"./template1\", \"./view1`)\n\n generated\n └── templates\n         └── views\n             └── template1.ts (can import \"./view1\", \"./view2\")\n```\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src/views\", \"generated/templates/views\"]\n  }\n}\n```\n\nThis does not affect how TypeScript emits JavaScript, it only emulates the assumption that they will be able to work via those relative paths at runtime.\n\n`rootDirs` can be used to provide a separate “type layer” to files that are not TypeScript or JavaScript by providing a home for generated `.d.ts` files in another folder. This technique is useful for bundled applications where you use `import` of files that aren’t necessarily code:\n\n``` shell\n src\n └── index.ts\n └── css\n     └── main.css\n     └── navigation.css\n\n generated\n └── css\n     └── main.css.d.ts\n     └── navigation.css.d.ts\n```\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src\", \"generated\"]\n  }\n}\n```\n\nThis technique lets you generate types ahead of time for the non-code source files. Imports then work naturally based off the source file’s location. For example `./src/index.ts` can import the file `./src/css/main.css` and TypeScript will be aware of the bundler’s behavior for that filetype via the corresponding generated declaration file.\n\n``` ts\n// @filename: index.ts\nimport { appClass } from \"./main.css\";\n```\n\n- Default:\n\n  Computed from the list of input files.\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### Type Roots - `typeRoots`\n\nBy default all *visible* ”`@types`” packages are included in your compilation. Packages in `node_modules/@types` of any enclosing folder are considered *visible*. For example, that means packages within `./node_modules/@types/`, `../node_modules/@types/`, `../../node_modules/@types/`, and so on.\n\nIf `typeRoots` is specified, *only* packages under `typeRoots` will be included. For example:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"typeRoots\": [\"./typings\", \"./vendor/types\"]\n  }\n}\n```\n\nThis config file will include *all* packages under `./typings` and `./vendor/types`, and no packages from `./node_modules/@types`. All paths are relative to the `tsconfig.json`.\n\n- Related:\n  - [`types`](#types)\n\n### Types - `types`\n\nBy default all *visible* ”`@types`” packages are included in your compilation. Packages in `node_modules/@types` of any enclosing folder are considered *visible*. For example, that means packages within `./node_modules/@types/`, `../node_modules/@types/`, `../../node_modules/@types/`, and so on.\n\nIf `types` is specified, only packages listed will be included in the global scope. For instance:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"types\": [\"node\", \"jest\", \"express\"]\n  }\n}\n```\n\nThis `tsconfig.json` file will *only* include `./node_modules/@types/node`, `./node_modules/@types/jest` and `./node_modules/@types/express`. Other packages under `node_modules/@types/*` will not be included.\n\n### What does this affect?\n\nThis option does not affect how `@types/*` are included in your application code, for example if you had the above `compilerOptions` example with code like:\n\n``` ts\nimport * as moment from \"moment\";\n\nmoment().format(\"MMMM Do YYYY, h:mm:ss a\");\n```\n\nThe `moment` import would be fully typed.\n\nWhen you have this option set, by not including a module in the `types` array it:\n\n- Will not add globals to your project (e.g `process` in node, or `expect` in Jest)\n- Will not have exports appear as auto-import recommendations\n\nThis feature differs from [`typeRoots`](#typeRoots) in that it is about specifying only the exact types you want included, whereas [`typeRoots`](#typeRoots) supports saying you want particular folders.\n\n- Related:\n  - [`typeRoots`](#typeRoots)\n\n## Emit\n\n### Declaration - `declaration`\n\nGenerate `.d.ts` files for every TypeScript or JavaScript file inside your project. These `.d.ts` files are type definition files which describe the external API of your module. With `.d.ts` files, tools like TypeScript can provide intellisense and accurate types for un-typed code.\n\nWhen `declaration` is set to `true`, running the compiler with this TypeScript code:\n\n``` ts\nexport let helloWorld = \"hi\";\n```\n\nWill generate an `index.js` file like this:\n\n``` ts\nexport let helloWorld = \"hi\";\n \n```\n\nWith a corresponding `helloWorld.d.ts`:\n\n``` ts\nexport declare let helloWorld: string;\n \n```\n\nWhen working with `.d.ts` files for JavaScript files you may want to use [`emitDeclarationOnly`](#emitDeclarationOnly) or use [`outDir`](#outDir) to ensure that the JavaScript files are not overwritten.\n\n- Default:\n\n  `true` if [`composite`](#composite); `false` otherwise.\n\n- Related:\n  - [`declarationDir`](#declarationDir)\n\n  - [`emitDeclarationOnly`](#emitDeclarationOnly)\n\n- Released:\n\n  [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)\n\n### Declaration Dir - `declarationDir`\n\nOffers a way to configure the root directory for where declaration files are emitted.\n\n``` typescript\nexample\n├── index.ts\n├── package.json\n└── tsconfig.json\n```\n\nwith this `tsconfig.json`:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"declaration\": true,\n    \"declarationDir\": \"./types\"\n  }\n}\n```\n\nWould place the d.ts for the `index.ts` in a `types` folder:\n\n``` typescript\nexample\n├── index.js\n├── index.ts\n├── package.json\n├── tsconfig.json\n└── types\n    └── index.d.ts\n```\n\n- Related:\n  - [`declaration`](#declaration)\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### Declaration Map - `declarationMap`\n\nGenerates a source map for `.d.ts` files which map back to the original `.ts` source file. This will allow editors such as VS Code to go to the original `.ts` file when using features like *Go to Definition*.\n\nYou should strongly consider turning this on if you’re using project references.\n\n- Released:\n\n  [2.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html)\n\n### Downlevel Iteration - `downlevelIteration`\n\nDownleveling is TypeScript’s term for transpiling to an older version of JavaScript. This flag is to enable support for a more accurate implementation of how modern JavaScript iterates through new concepts in older JavaScript runtimes.\n\nECMAScript 6 added several new iteration primitives: the `for / of` loop (`for (el of arr)`), Array spread (`[a, ...b]`), argument spread (`fn(...args)`), and `Symbol.iterator`. `downlevelIteration` allows for these iteration primitives to be used more accurately in ES5 environments if a `Symbol.iterator` implementation is present.\n\n#### Example: Effects on `for / of`\n\nWith this TypeScript code:\n\n``` ts\nconst str = \"Hello!\";\nfor (const s of str) {\n  console.log(s);\n}\n```\n\nWithout `downlevelIteration` enabled, a `for / of` loop on any object is downleveled to a traditional `for` loop:\n\n``` ts\n\"use strict\";\nvar str = \"Hello!\";\nfor (var _i = 0, str_1 = str; _i < str_1.length; _i++) {\n    var s = str_1[_i];\n    console.log(s);\n}\n \n```\n\nThis is often what people expect, but it’s not 100% compliant with ECMAScript iteration protocol. Certain strings, such as emoji (😜), have a `.length` of 2 (or even more!), but should iterate as 1 unit in a `for-of` loop. See [this blog post by Jonathan New](https://blog.jonnew.com/posts/poo-dot-length-equals-two) for a longer explanation.\n\nWhen `downlevelIteration` is enabled, TypeScript will use a helper function that checks for a `Symbol.iterator` implementation (either native or polyfill). If this implementation is missing, you’ll fall back to index-based iteration.\n\n``` ts\n\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar e_1, _a;\nvar str = \"Hello!\";\ntry {\n    for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {\n        var s = str_1_1.value;\n        console.log(s);\n    }\n}\ncatch (e_1_1) { e_1 = { error: e_1_1 }; }\nfinally {\n    try {\n        if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);\n    }\n    finally { if (e_1) throw e_1.error; }\n}\n \n```\n\nYou can use [tslib](https://www.npmjs.com/package/tslib) via [`importHelpers`](#importHelpers) to reduce the amount of inline JavaScript too:\n\n``` ts\n\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar e_1, _a;\nvar str = \"Hello!\";\ntry {\n    for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {\n        var s = str_1_1.value;\n        console.log(s);\n    }\n}\ncatch (e_1_1) { e_1 = { error: e_1_1 }; }\nfinally {\n    try {\n        if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);\n    }\n    finally { if (e_1) throw e_1.error; }\n}\n \n```\n\n**Note:** enabling `downlevelIteration` does not improve compliance if `Symbol.iterator` is not present in the runtime.\n\n#### Example: Effects on Array Spreads\n\nThis is an array spread:\n\n``` js\n// Make a new array whose elements are 1 followed by the elements of arr2\nconst arr = [1, ...arr2];\n```\n\nBased on the description, it sounds easy to downlevel to ES5:\n\n``` js\n// The same, right?\nconst arr = [1].concat(arr2);\n```\n\nHowever, this is observably different in certain rare cases.\n\nFor example, if a source array is missing one or more items (contains a hole), the spread syntax will replace each empty item with `undefined`, whereas `.concat` will leave them intact.\n\n``` js\n// Make an array where the element at index 1 is missing\nlet arrayWithHole = [\"a\", , \"c\"];\nlet spread = [...arrayWithHole];\nlet concatenated = [].concat(arrayWithHole);\n\nconsole.log(arrayWithHole);\n// [ 'a', <1 empty item>, 'c' ]\nconsole.log(spread);\n// [ 'a', undefined, 'c' ]\nconsole.log(concatenated);\n// [ 'a', <1 empty item>, 'c' ]\n```\n\nJust as with `for / of`, `downlevelIteration` will use `Symbol.iterator` (if present) to more accurately emulate ES 6 behavior.\n\n- Related:\n  - [`importHelpers`](#importHelpers)\n\n- Released:\n\n  [2.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html)\n\n### Emit BOM - `emitBOM`\n\nControls whether TypeScript will emit a [byte order mark (BOM)](https://wikipedia.org/wiki/Byte_order_mark) when writing output files. Some runtime environments require a BOM to correctly interpret a JavaScript files; others require that it is not present. The default value of `false` is generally best unless you have a reason to change it.\n\n### Emit Declaration Only - `emitDeclarationOnly`\n\n*Only* emit `.d.ts` files; do not emit `.js` files.\n\nThis setting is useful in two cases:\n\n- You are using a transpiler other than TypeScript to generate your JavaScript.\n- You are using TypeScript to only generate `d.ts` files for your consumers.\n\n- Related:\n  - [`declaration`](#declaration)\n\n- Released:\n\n  [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html)\n\n### Import Helpers - `importHelpers`\n\nFor certain downleveling operations, TypeScript uses some helper code for operations like extending class, spreading arrays or objects, and async operations. By default, these helpers are inserted into files which use them. This can result in code duplication if the same helper is used in many different modules.\n\nIf the `importHelpers` flag is on, these helper functions are instead imported from the [tslib](https://www.npmjs.com/package/tslib) module. You will need to ensure that the `tslib` module is able to be imported at runtime. This only affects modules; global script files will not attempt to import modules.\n\nFor example, with this TypeScript:\n\n``` ts\nexport function fn(arr: number[]) {\n  const arr2 = [1, ...arr];\n}\n```\n\nTurning on [`downlevelIteration`](#downlevelIteration) and `importHelpers` is still false:\n\n``` ts\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nexport function fn(arr) {\n    var arr2 = __spreadArray([1], __read(arr), false);\n}\n \n```\n\nThen turning on both [`downlevelIteration`](#downlevelIteration) and `importHelpers`:\n\n``` ts\nimport { __read, __spreadArray } from \"tslib\";\nexport function fn(arr) {\n    var arr2 = __spreadArray([1], __read(arr), false);\n}\n \n```\n\nYou can use [`noEmitHelpers`](#noEmitHelpers) when you provide your own implementations of these functions.\n\n- Related:\n  - [`noEmitHelpers`](#noEmitHelpers)\n\n  - [`downlevelIteration`](#downlevelIteration)\n\n### Inline Source Map - `inlineSourceMap`\n\nWhen set, instead of writing out a `.js.map` file to provide source maps, TypeScript will embed the source map content in the `.js` files. Although this results in larger JS files, it can be convenient in some scenarios. For example, you might want to debug JS files on a webserver that doesn’t allow `.map` files to be served.\n\nMutually exclusive with [`sourceMap`](#sourceMap).\n\nFor example, with this TypeScript:\n\n``` ts\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n```\n\nConverts to this JavaScript:\n\n``` ts\n\"use strict\";\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n \n```\n\nThen enable building it with `inlineSourceMap` enabled there is a comment at the bottom of the file which includes a source-map for the file.\n\n``` ts\n\"use strict\";\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMifQ==\n```\n\n- Released:\n\n  [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)\n\n### Inline Sources - `inlineSources`\n\nWhen set, TypeScript will include the original content of the `.ts` file as an embedded string in the source map (using the source map’s `sourcesContent` property). This is often useful in the same cases as [`inlineSourceMap`](#inlineSourceMap).\n\nRequires either [`sourceMap`](#sourceMap) or [`inlineSourceMap`](#inlineSourceMap) to be set.\n\nFor example, with this TypeScript:\n\n``` ts\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n```\n\nBy default converts to this JavaScript:\n\n``` ts\n\"use strict\";\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n \n```\n\nThen enable building it with `inlineSources` and [`inlineSourceMap`](#inlineSourceMap) enabled there is a comment at the bottom of the file which includes a source-map for the file. Note that the end is different from the example in [`inlineSourceMap`](#inlineSourceMap) because the source-map now contains the original source code also.\n\n``` ts\n\"use strict\";\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoZWxsb1dvcmxkID0gXCJoaVwiO1xuY29uc29sZS5sb2coaGVsbG9Xb3JsZCk7Il19\n```\n\n- Released:\n\n  [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)\n\n### Map Root - `mapRoot`\n\nSpecify the location where debugger should locate map files instead of generated locations. This string is treated verbatim inside the source-map, for example:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"sourceMap\": true,\n    \"mapRoot\": \"https://my-website.com/debug/sourcemaps/\"\n  }\n}\n```\n\nWould declare that `index.js` will have sourcemaps at `https://my-website.com/debug/sourcemaps/index.js.map`.\n\n### New Line - `newLine`\n\nSpecify the end of line sequence to be used when emitting files: ‘CRLF’ (dos) or ‘LF’ (unix).\n\n- Default:\n\n  `lf`\n\n- Allowed:\n  - `crlf`\n\n  - `lf`\n\n- Released:\n\n  [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)\n\n### No Emit - `noEmit`\n\nDo not emit compiler output files like JavaScript source code, source-maps or declarations.\n\nThis makes room for another tool like [Babel](https://babeljs.io), or [swc](https://github.com/swc-project/swc) to handle converting the TypeScript file to a file which can run inside a JavaScript environment.\n\nYou can then use TypeScript as a tool for providing editor integration, and as a source code type-checker.\n\n### No Emit Helpers - `noEmitHelpers`\n\nInstead of importing helpers with [`importHelpers`](#importHelpers), you can provide implementations in the global scope for the helpers you use and completely turn off emitting of helper functions.\n\nFor example, using this `async` function in ES5 requires a `await`-like function and `generator`-like function to run:\n\n``` ts\nconst getAPI = async (url: string) => {\n  // Get API\n  return {};\n};\n```\n\nWhich creates quite a lot of JavaScript:\n\n``` ts\n\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n        // Get API\n        return [2 /*return*/, {}];\n    });\n}); };\n \n```\n\nWhich can be switched out with your own globals via this flag:\n\n``` ts\n\"use strict\";\nvar getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n        // Get API\n        return [2 /*return*/, {}];\n    });\n}); };\n \n```\n\n- Related:\n  - [`importHelpers`](#importHelpers)\n\n- Released:\n\n  [1.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html)\n\n### No Emit On Error - `noEmitOnError`\n\nDo not emit compiler output files like JavaScript source code, source-maps or declarations if any errors were reported.\n\nThis defaults to `false`, making it easier to work with TypeScript in a watch-like environment where you may want to see results of changes to your code in another environment before making sure all errors are resolved.\n\n- Released:\n\n  [1.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html)\n\n### Out Dir - `outDir`\n\nIf specified, `.js` (as well as `.d.ts`, `.js.map`, etc.) files will be emitted into this directory. The directory structure of the original source files is preserved; see [`rootDir`](#rootDir) if the computed root is not what you intended.\n\nIf not specified, `.js` files will be emitted in the same directory as the `.ts` files they were generated from:\n\n``` shell\n$ tsc\n\nexample\n├── index.js\n└── index.ts\n```\n\nWith a `tsconfig.json` like this:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"outDir\": \"dist\"\n  }\n}\n```\n\nRunning `tsc` with these settings moves the files into the specified `dist` folder:\n\n``` shell\n$ tsc\n\nexample\n├── dist\n│   └── index.js\n├── index.ts\n└── tsconfig.json\n```\n\n- Related:\n  - [`out`](#out)\n\n  - [`outFile`](#outFile)\n\n### Out File - `outFile`\n\nIf specified, all *global* (non-module) files will be concatenated into the single output file specified.\n\nIf `module` is `system` or `amd`, all module files will also be concatenated into this file after all global content.\n\nNote: `outFile` cannot be used unless `module` is `None`, `System`, or `AMD`. This option *cannot* be used to bundle CommonJS or ES6 modules.\n\n- Related:\n  - [`out`](#out)\n\n  - [`outDir`](#outDir)\n\n- Released:\n\n  [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)\n\n### Preserve Const Enums - `preserveConstEnums`\n\nDo not erase `const enum` declarations in generated code. `const enum`s provide a way to reduce the overall memory footprint of your application at runtime by emitting the enum value instead of a reference.\n\nFor example with this TypeScript:\n\n``` ts\nconst enum Album {\n  JimmyEatWorldFutures = 1,\n  TubRingZooHypothesis = 2,\n  DogFashionDiscoAdultery = 3,\n}\n \nconst selectedAlbum = Album.JimmyEatWorldFutures;\nif (selectedAlbum === Album.JimmyEatWorldFutures) {\n  console.log(\"That is a great choice.\");\n}\n```\n\nThe default `const enum` behavior is to convert any `Album.Something` to the corresponding number literal, and to remove a reference to the enum from the JavaScript completely.\n\n``` ts\n\"use strict\";\nconst selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;\nif (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {\n    console.log(\"That is a great choice.\");\n}\n \n```\n\nWith `preserveConstEnums` set to `true`, the `enum` exists at runtime and the numbers are still emitted.\n\n``` ts\n\"use strict\";\nvar Album;\n(function (Album) {\n    Album[Album[\"JimmyEatWorldFutures\"] = 1] = \"JimmyEatWorldFutures\";\n    Album[Album[\"TubRingZooHypothesis\"] = 2] = \"TubRingZooHypothesis\";\n    Album[Album[\"DogFashionDiscoAdultery\"] = 3] = \"DogFashionDiscoAdultery\";\n})(Album || (Album = {}));\nconst selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;\nif (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {\n    console.log(\"That is a great choice.\");\n}\n \n```\n\nThis essentially makes such `const enums` a source-code feature only, with no runtime traces.\n\n- Default:\n\n  `true` if [`isolatedModules`](#isolatedModules); `false` otherwise.\n\n### Remove Comments - `removeComments`\n\nStrips all comments from TypeScript files when converting into JavaScript. Defaults to `false`.\n\nFor example, this is a TypeScript file which has a JSDoc comment:\n\n``` ts\n/** The translation of 'Hello world' into Portuguese */\nexport const helloWorldPTBR = \"Olá Mundo\";\n```\n\nWhen `removeComments` is set to `true`:\n\n``` ts\nexport const helloWorldPTBR = \"Olá Mundo\";\n \n```\n\nWithout setting `removeComments` or having it as `false`:\n\n``` ts\n/** The translation of 'Hello world' into Portuguese */\nexport const helloWorldPTBR = \"Olá Mundo\";\n \n```\n\nThis means that your comments will show up in the JavaScript code.\n\n### Source Map - `sourceMap`\n\nEnables the generation of [sourcemap files](https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map). These files allow debuggers and other tools to display the original TypeScript source code when actually working with the emitted JavaScript files. Source map files are emitted as `.js.map` (or `.jsx.map`) files next to the corresponding `.js` output file.\n\nThe `.js` files will in turn contain a sourcemap comment to indicate where the files are to external tools, for example:\n\n``` ts\n// helloWorld.ts\nexport declare const helloWorld = \"hi\";\n```\n\nCompiling with `sourceMap` set to `true` creates the following JavaScript file:\n\n``` js\n// helloWorld.js\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.helloWorld = \"hi\";\n//# sourceMappingURL=// helloWorld.js.map\n```\n\nAnd this also generates this json map:\n\n``` json\n// helloWorld.js.map\n{\n  \"version\": 3,\n  \"file\": \"ex.js\",\n  \"sourceRoot\": \"\",\n  \"sources\": [\"../ex.ts\"],\n  \"names\": [],\n  \"mappings\": \";;AAAa,QAAA,UAAU,GAAG,IAAI,CAAA\"\n}\n```\n\n### Source Root - `sourceRoot`\n\nSpecify the location where a debugger should locate TypeScript files instead of relative source locations. This string is treated verbatim inside the source-map where you can use a path or a URL:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"sourceMap\": true,\n    \"sourceRoot\": \"https://my-website.com/debug/source/\"\n  }\n}\n```\n\nWould declare that `index.js` will have a source file at `https://my-website.com/debug/source/index.ts`.\n\n### Strip Internal - `stripInternal`\n\nDo not emit declarations for code that has an `@internal` annotation in its JSDoc comment. This is an internal compiler option; use at your own risk, because the compiler does not check that the result is valid. If you are searching for a tool to handle additional levels of visibility within your `d.ts` files, look at [api-extractor](https://api-extractor.com).\n\n``` ts\n/**\n * Days available in a week\n * @internal\n */\nexport const daysInAWeek = 7;\n \n/** Calculate how much someone earns in a week */\nexport function weeklySalary(dayRate: number) {\n  return daysInAWeek * dayRate;\n}\n```\n\nWith the flag set to `false` (default):\n\n``` ts\n/**\n * Days available in a week\n * @internal\n */\nexport declare const daysInAWeek = 7;\n/** Calculate how much someone earns in a week */\nexport declare function weeklySalary(dayRate: number): number;\n \n```\n\nWith `stripInternal` set to `true` the `d.ts` emitted will be redacted.\n\n``` ts\n/** Calculate how much someone earns in a week */\nexport declare function weeklySalary(dayRate: number): number;\n \n```\n\nThe JavaScript output is still the same.\n\n- Internal\n\n## JavaScript Support\n\n### Allow JS - `allowJs`\n\nAllow JavaScript files to be imported inside your project, instead of just `.ts` and `.tsx` files. For example, this JS file:\n\n``` js\n// @filename: card.js\nexport const defaultCardDeck = \"Heart\";\n```\n\nWhen imported into a TypeScript file will raise an error:\n\n``` ts\n// @filename: index.ts\nimport { defaultCardDeck } from \"./card\";\n \nconsole.log(defaultCardDeck);\n```\n\nImports fine with `allowJs` enabled:\n\n``` ts\n// @filename: index.ts\nimport { defaultCardDeck } from \"./card\";\n \nconsole.log(defaultCardDeck);\n```\n\nThis flag can be used as a way to incrementally add TypeScript files into JS projects by allowing the `.ts` and `.tsx` files to live along-side existing JavaScript files.\n\nIt can also be used along-side [`declaration`](#declaration) and [`emitDeclarationOnly`](#emitDeclarationOnly) to [create declarations for JS files](docs/handbook/declaration-files/dts-from-js).\n\n- Related:\n  - [`checkJs`](#checkJs)\n\n  - [`emitDeclarationOnly`](#emitDeclarationOnly)\n\n- Released:\n\n  [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)\n\n### Check JS - `checkJs`\n\nWorks in tandem with [`allowJs`](#allowJs). When `checkJs` is enabled then errors are reported in JavaScript files. This is the equivalent of including `// @ts-check` at the top of all JavaScript files which are included in your project.\n\nFor example, this is incorrect JavaScript according to the `parseFloat` type definition which comes with TypeScript:\n\n``` js\n// parseFloat only takes a string\nmodule.exports.pi = parseFloat(3.142);\n```\n\nWhen imported into a TypeScript module:\n\n``` ts\n// @filename: constants.js\nmodule.exports.pi = parseFloat(3.142);\n \n// @filename: index.ts\nimport { pi } from \"./constants\";\nconsole.log(pi);\n```\n\nYou will not get any errors. However, if you turn on `checkJs` then you will get error messages from the JavaScript file.\n\n``` ts\n// @filename: constants.js\nmodule.exports.pi = parseFloat(3.142);\n \n// @filename: index.ts\nimport { pi } from \"./constants\";\nconsole.log(pi);\n```\n\n- Related:\n  - [`allowJs`](#allowJs)\n\n  - [`emitDeclarationOnly`](#emitDeclarationOnly)\n\n- Released:\n\n  [2.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html)\n\n### Max Node Module JS Depth - `maxNodeModuleJsDepth`\n\nThe maximum dependency depth to search under `node_modules` and load JavaScript files.\n\nThis flag can only be used when [`allowJs`](#allowJs) is enabled, and is used if you want to have TypeScript infer types for all of the JavaScript inside your `node_modules`.\n\nIdeally this should stay at 0 (the default), and `d.ts` files should be used to explicitly define the shape of modules. However, there are cases where you may want to turn this on at the expense of speed and potential accuracy.\n\n## Editor Support\n\n### Disable Size Limit - `disableSizeLimit`\n\nTo avoid a possible memory bloat issues when working with very large JavaScript projects, there is an upper limit to the amount of memory TypeScript will allocate. Turning this flag on will remove the limit.\n\n### Plugins - `plugins`\n\nList of language service plugins to run inside the editor.\n\nLanguage service plugins are a way to provide additional information to a user based on existing TypeScript files. They can enhance existing messages between TypeScript and an editor, or to provide their own error messages.\n\nFor example:\n\n- [ts-sql-plugin](https://github.com/xialvjun/ts-sql-plugin#readme) — Adds SQL linting with a template strings SQL builder.\n- [typescript-styled-plugin](https://github.com/Microsoft/typescript-styled-plugin) — Provides CSS linting inside template strings .\n- [typescript-eslint-language-service](https://github.com/Quramy/typescript-eslint-language-service) — Provides eslint error messaging and fix-its inside the compiler’s output.\n- [ts-graphql-plugin](https://github.com/Quramy/ts-graphql-plugin) — Provides validation and auto-completion inside GraphQL query template strings.\n\nVS Code has the ability for a extension to [automatically include language service plugins](https://code.visualstudio.com/api/references/contribution-points#contributes.typescriptServerPlugins), and so you may have some running in your editor without needing to define them in your `tsconfig.json`.\n\n## Interop Constraints\n\n### Allow Synthetic Default Imports - `allowSyntheticDefaultImports`\n\nWhen set to true, `allowSyntheticDefaultImports` allows you to write an import like:\n\n``` ts\nimport React from \"react\";\n```\n\ninstead of:\n\n``` ts\nimport * as React from \"react\";\n```\n\nWhen the module **does not** explicitly specify a default export.\n\nFor example, without `allowSyntheticDefaultImports` as true:\n\n``` ts\n// @filename: utilFunctions.js\nconst getStringLength = (str) => str.length;\n \nmodule.exports = {\n  getStringLength,\n};\n \n// @filename: index.ts\nimport utils from \"./utilFunctions\";\n \nconst count = utils.getStringLength(\"Check JS\");\n```\n\nThis code raises an error because there isn’t a `default` object which you can import. Even though it feels like it should. For convenience, transpilers like Babel will automatically create a default if one isn’t created. Making the module look a bit more like:\n\n``` js\n// @filename: utilFunctions.js\nconst getStringLength = (str) => str.length;\nconst allFunctions = {\n  getStringLength,\n};\n\nmodule.exports = allFunctions;\nmodule.exports.default = allFunctions;\n```\n\nThis flag does not affect the JavaScript emitted by TypeScript, it’s only for the type checking. This option brings the behavior of TypeScript in-line with Babel, where extra code is emitted to make using a default export of a module more ergonomic.\n\n- Default:\n\n  `true` if [`esModuleInterop`](#esModuleInterop) is enabled, [`module`](#module) is `system`, or [`moduleResolution`](#module-resolution) is `bundler`; `false` otherwise.\n\n- Related:\n  - [`esModuleInterop`](#esModuleInterop)\n\n- Released:\n\n  [1.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html)\n\n### ES Module Interop - `esModuleInterop`\n\nBy default (with `esModuleInterop` false or not set) TypeScript treats CommonJS/AMD/UMD modules similar to ES6 modules. In doing this, there are two parts in particular which turned out to be flawed assumptions:\n\n- a namespace import like `import * as moment from \"moment\"` acts the same as `const moment = require(\"moment\")`\n\n- a default import like `import moment from \"moment\"` acts the same as `const moment = require(\"moment\").default`\n\nThis mis-match causes these two issues:\n\n- the ES6 modules spec states that a namespace import (`import * as x`) can only be an object, by having TypeScript treating it the same as `= require(\"x\")` then TypeScript allowed for the import to be treated as a function and be callable. That’s not valid according to the spec.\n\n- while accurate to the ES6 modules spec, most libraries with CommonJS/AMD/UMD modules didn’t conform as strictly as TypeScript’s implementation.\n\nTurning on `esModuleInterop` will fix both of these problems in the code transpiled by TypeScript. The first changes the behavior in the compiler, the second is fixed by two new helper functions which provide a shim to ensure compatibility in the emitted JavaScript:\n\n``` ts\nimport * as fs from \"fs\";\nimport _ from \"lodash\";\n\nfs.readFileSync(\"file.txt\", \"utf8\");\n_.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n```\n\nWith `esModuleInterop` disabled:\n\n``` ts\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst lodash_1 = require(\"lodash\");\nfs.readFileSync(\"file.txt\", \"utf8\");\nlodash_1.default.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n \n```\n\nWith `esModuleInterop` set to `true`:\n\n``` ts\n\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = __importStar(require(\"fs\"));\nconst lodash_1 = __importDefault(require(\"lodash\"));\nfs.readFileSync(\"file.txt\", \"utf8\");\nlodash_1.default.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n \n```\n\n*Note*: The namespace import `import * as fs from \"fs\"` only accounts for properties which [are owned](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty) (basically properties set on the object and not via the prototype chain) on the imported object. If the module you’re importing defines its API using inherited properties, you need to use the default import form (`import fs from \"fs\"`), or disable `esModuleInterop`.\n\n*Note*: You can make JS emit terser by enabling [`importHelpers`](#importHelpers):\n\n``` ts\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst fs = tslib_1.__importStar(require(\"fs\"));\nconst lodash_1 = tslib_1.__importDefault(require(\"lodash\"));\nfs.readFileSync(\"file.txt\", \"utf8\");\nlodash_1.default.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n \n```\n\nEnabling `esModuleInterop` will also enable [`allowSyntheticDefaultImports`](#allowSyntheticDefaultImports).\n\n- Recommended\n\n- Default:\n\n  `true` if [`module`](#module) is `node16` or `nodenext`; `false` otherwise.\n\n- Related:\n  - [`allowSyntheticDefaultImports`](#allowSyntheticDefaultImports)\n\n- Released:\n\n  [2.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html)\n\n### Force Consistent Casing In File Names - `forceConsistentCasingInFileNames`\n\nTypeScript follows the case sensitivity rules of the file system it’s running on. This can be problematic if some developers are working in a case-sensitive file system and others aren’t. If a file attempts to import `fileManager.ts` by specifying `./FileManager.ts` the file will be found in a case-insensitive file system, but not on a case-sensitive file system.\n\nWhen this option is set, TypeScript will issue an error if a program tries to include a file by a casing different from the casing on disk.\n\n- Recommended\n\n- Default:\n\n  `true`\n\n### isolatedDeclarations - `isolatedDeclarations`\n\nRequire sufficient annotation on exports so other tools can trivially generate declaration files.\n\nFor more information, see the [5.5 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#isolated-declarations)\n\n### Isolated Modules - `isolatedModules`\n\nWhile you can use TypeScript to produce JavaScript code from TypeScript code, it’s also common to use other transpilers such as [Babel](https://babeljs.io) to do this. However, other transpilers only operate on a single file at a time, which means they can’t apply code transforms that depend on understanding the full type system. This restriction also applies to TypeScript’s `ts.transpileModule` API which is used by some build tools.\n\nThese limitations can cause runtime problems with some TypeScript features like `const enum`s and `namespace`s. Setting the `isolatedModules` flag tells TypeScript to warn you if you write certain code that can’t be correctly interpreted by a single-file transpilation process.\n\nIt does not change the behavior of your code, or otherwise change the behavior of TypeScript’s checking and emitting process.\n\nSome examples of code which does not work when `isolatedModules` is enabled.\n\n#### Exports of Non-Value Identifiers\n\nIn TypeScript, you can import a *type* and then subsequently export it:\n\n``` ts\nimport { someType, someFunction } from \"someModule\";\n \nsomeFunction();\n \nexport { someType, someFunction };\n```\n\nBecause there’s no value for `someType`, the emitted `export` will not try to export it (this would be a runtime error in JavaScript):\n\n``` js\nexport { someFunction };\n```\n\nSingle-file transpilers don’t know whether `someType` produces a value or not, so it’s an error to export a name that only refers to a type.\n\n#### Non-Module Files\n\nIf `isolatedModules` is set, namespaces are only allowed in *modules* (which means it has some form of `import`/`export`). An error occurs if a namespace is found in a non-module file:\n\n``` ts\nnamespace Instantiated {\n  export const x = 1;\n}\n```\n\nThis restriction doesn’t apply to `.d.ts` files.\n\n#### References to `const enum` members\n\nIn TypeScript, when you reference a `const enum` member, the reference is replaced by its actual value in the emitted JavaScript. Changing this TypeScript:\n\n``` ts\ndeclare const enum Numbers {\n  Zero = 0,\n  One = 1,\n}\nconsole.log(Numbers.Zero + Numbers.One);\n```\n\nTo this JavaScript:\n\n``` ts\n\"use strict\";\nconsole.log(0 + 1);\n \n```\n\nWithout knowledge of the values of these members, other transpilers can’t replace the references to `Numbers`, which would be a runtime error if left alone (since there are no `Numbers` object at runtime). Because of this, when `isolatedModules` is set, it is an error to reference an ambient `const enum` member.\n\n- Default:\n\n  `true` if [`verbatimModuleSyntax`](#verbatimModuleSyntax); `false` otherwise.\n\n### Preserve Symlinks - `preserveSymlinks`\n\nThis is to reflect the same flag in Node.js; which does not resolve the real path of symlinks.\n\nThis flag also exhibits the opposite behavior to Webpack’s `resolve.symlinks` option (i.e. setting TypeScript’s `preserveSymlinks` to true parallels setting Webpack’s `resolve.symlinks` to false, and vice-versa).\n\nWith this enabled, references to modules and packages (e.g. `import`s and `/// <reference type=\"...\" />` directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to.\n\n### Verbatim Module Syntax - `verbatimModuleSyntax`\n\nBy default, TypeScript does something called *import elision*. Basically, if you write something like\n\n``` ts\nimport { Car } from \"./car\";\n\nexport function drive(car: Car) {\n  // ...\n}\n```\n\nTypeScript detects that you’re only using an import for types and drops the import entirely. Your output JavaScript might look something like this:\n\n``` js\nexport function drive(car) {\n  // ...\n}\n```\n\nMost of the time this is good, because if `Car` isn’t a value that’s exported from `./car`, we’ll get a runtime error.\n\nBut it does add a layer of complexity for certain edge cases. For example, notice there’s no statement like `import \"./car\";` - the import was dropped entirely. That actually makes a difference for modules that have side-effects or not.\n\nTypeScript’s emit strategy for JavaScript also has another few layers of complexity - import elision isn’t always just driven by how an import is used - it often consults how a value is declared as well. So it’s not always clear whether code like the following\n\n``` ts\nexport { Car } from \"./car\";\n```\n\nshould be preserved or dropped. If `Car` is declared with something like a `class`, then it can be preserved in the resulting JavaScript file. But if `Car` is only declared as a `type` alias or `interface`, then the JavaScript file shouldn’t export `Car` at all.\n\nWhile TypeScript might be able to make these emit decisions based on information from across files, not every compiler can.\n\nThe `type` modifier on imports and exports helps with these situations a bit. We can make it explicit whether an import or export is only being used for type analysis, and can be dropped entirely in JavaScript files by using the `type` modifier.\n\n``` ts\n// This statement can be dropped entirely in JS output\nimport type * as car from \"./car\";\n\n// The named import/export 'Car' can be dropped in JS output\nimport { type Car } from \"./car\";\nexport { type Car } from \"./car\";\n```\n\n`type` modifiers are not quite useful on their own - by default, module elision will still drop imports, and nothing forces you to make the distinction between `type` and plain imports and exports. So TypeScript has the flag `--importsNotUsedAsValues` to make sure you use the `type` modifier, `--preserveValueImports` to prevent *some* module elision behavior, and `--isolatedModules` to make sure that your TypeScript code works across different compilers. Unfortunately, understanding the fine details of those 3 flags is hard, and there are still some edge cases with unexpected behavior.\n\nTypeScript 5.0 introduces a new option called `--verbatimModuleSyntax` to simplify the situation. The rules are much simpler - any imports or exports without a `type` modifier are left around. Anything that uses the `type` modifier is dropped entirely.\n\n``` ts\n// Erased away entirely.\nimport type { A } from \"a\";\n\n// Rewritten to 'import { b } from \"bcd\";'\nimport { b, type c, type d } from \"bcd\";\n\n// Rewritten to 'import {} from \"xyz\";'\nimport { type xyz } from \"xyz\";\n```\n\nWith this new option, what you see is what you get.\n\nThat does have some implications when it comes to module interop though. Under this flag, ECMAScript `import`s and `export`s won’t be rewritten to `require` calls when your settings or file extension implied a different module system. Instead, you’ll get an error. If you need to emit code that uses `require` and `module.exports`, you’ll have to use TypeScript’s module syntax that predates ES2015:\n\n[TABLE]\n\nWhile this is a limitation, it does help make some issues more obvious. For example, it’s very common to forget to set the [`type` field in `package.json`](https://nodejs.org/api/packages.html#type) under `--module node16`. As a result, developers would start writing CommonJS modules instead of an ES modules without realizing it, giving surprising lookup rules and JavaScript output. This new flag ensures that you’re intentional about the file type you’re using because the syntax is intentionally different.\n\nBecause `--verbatimModuleSyntax` provides a more consistent story than `--importsNotUsedAsValues` and `--preserveValueImports`, those two existing flags are being deprecated in its favor.\n\nFor more details, read up on [the original pull request](https://github.com/microsoft/TypeScript/pull/52203) and [its proposal issue](https://github.com/microsoft/TypeScript/issues/51479).\n\n## Backwards Compatibility\n\n### Charset - `charset`\n\nIn prior versions of TypeScript, this controlled what encoding was used when reading text files from disk. Today, TypeScript assumes UTF-8 encoding, but will correctly detect UTF-16 (BE and LE) or UTF-8 BOMs.\n\n- Deprecated\n\n- Default:\n\n  `utf8`\n\n### Imports Not Used As Values - `importsNotUsedAsValues`\n\nDeprecated in favor of [`verbatimModuleSyntax`](#verbatimModuleSyntax).\n\nThis flag controls how `import` works, there are 3 different options:\n\n- `remove`: The default behavior of dropping `import` statements which only reference types.\n\n- `preserve`: Preserves all `import` statements whose values or types are never used. This can cause imports/side-effects to be preserved.\n\n- `error`: This preserves all imports (the same as the preserve option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.\n\nThis flag works because you can use `import type` to explicitly create an `import` statement which should never be emitted into JavaScript.\n\n- Default:\n\n  `remove`\n\n- Allowed:\n  - `remove`\n\n  - `preserve`\n\n  - `error`\n\n- Related:\n  - [`preserveValueImports`](#preserveValueImports)\n\n  - [`verbatimModuleSyntax`](#verbatimModuleSyntax)\n\n- Released:\n\n  [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)\n\n### Keyof Strings Only - `keyofStringsOnly`\n\nThis flag changes the `keyof` type operator to return `string` instead of `string | number` when applied to a type with a string index signature.\n\nThis flag is used to help people keep this behavior from [before TypeScript 2.9’s release](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types).\n\n- Deprecated\n\n- Released:\n\n  [2.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html)\n\n### No Implicit Use Strict - `noImplicitUseStrict`\n\nYou shouldn’t need this. By default, when emitting a module file to a non-ES6 target, TypeScript emits a `\"use strict\";` prologue at the top of the file. This setting disables the prologue.\n\n### No Strict Generic Checks - `noStrictGenericChecks`\n\nTypeScript will unify type parameters when comparing two generic functions.\n\n``` ts\ntype A = <T, U>(x: T, y: U) => [T, U];\ntype B = <S>(x: S, y: S) => [S, S];\n \nfunction f(a: A, b: B) {\n  b = a; // Ok\n  a = b; // Error\n}\n```\n\nThis flag can be used to remove that check.\n\n- Released:\n\n  [2.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html)\n\n### Out - `out`\n\nUse [`outFile`](#outFile) instead.\n\nThe `out` option computes the final file location in a way that is not predictable or consistent. This option is retained for backward compatibility only and is deprecated.\n\n- Deprecated\n- Related:\n  - [`outDir`](#outDir)\n\n  - [`outFile`](#outFile)\n\n### Preserve Value Imports - `preserveValueImports`\n\nDeprecated in favor of [`verbatimModuleSyntax`](#verbatimModuleSyntax).\n\nThere are some cases where TypeScript can’t detect that you’re using an import. For example, take the following code:\n\n``` ts\nimport { Animal } from \"./animal.js\";\n\neval(\"console.log(new Animal().isDangerous())\");\n```\n\nor code using ‘Compiles to HTML’ languages like Svelte or Vue. `preserveValueImports` will prevent TypeScript from removing the import, even if it appears unused.\n\nWhen combined with [`isolatedModules`](#isolatedModules): imported types *must* be marked as type-only because compilers that process single files at a time have no way of knowing whether imports are values that appear unused, or a type that must be removed in order to avoid a runtime crash.\n\n- Related:\n  - [`isolatedModules`](#isolatedModules)\n\n  - [`importsNotUsedAsValues`](#importsNotUsedAsValues)\n\n  - [`verbatimModuleSyntax`](#verbatimModuleSyntax)\n\n- Released:\n\n  [4.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html)\n\n### Suppress Excess Property Errors - `suppressExcessPropertyErrors`\n\nThis disables reporting of excess property errors, such as the one shown in the following example:\n\n``` ts\ntype Point = { x: number; y: number };\nconst p: Point = { x: 1, y: 3, m: 10 };\n```\n\nThis flag was added to help people migrate to the stricter checking of new object literals in [TypeScript 1.6](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#stricter-object-literal-assignment-checks).\n\nWe don’t recommend using this flag in a modern codebase, you can suppress one-off cases where you need it using `// @ts-ignore`.\n\n### Suppress Implicit Any Index Errors - `suppressImplicitAnyIndexErrors`\n\nTurning `suppressImplicitAnyIndexErrors` on suppresses reporting the error about implicit anys when indexing into objects, as shown in the following example:\n\n``` ts\nconst obj = { x: 10 };\nconsole.log(obj[\"foo\"]);\n```\n\nUsing `suppressImplicitAnyIndexErrors` is quite a drastic approach. It is recommended to use a `@ts-ignore` comment instead:\n\n``` ts\nconst obj = { x: 10 };\n// @ts-ignore\nconsole.log(obj[\"foo\"]);\n```\n\n- Related:\n  - [`noImplicitAny`](#noImplicitAny)\n\n## Language and Environment\n\n### Emit Decorator Metadata - `emitDecoratorMetadata`\n\nEnables experimental support for emitting type metadata for decorators which works with the module [`reflect-metadata`](https://www.npmjs.com/package/reflect-metadata).\n\nFor example, here is the TypeScript\n\n``` ts\nfunction LogMethod(\n  target: any,\n  propertyKey: string | symbol,\n  descriptor: PropertyDescriptor\n) {\n  console.log(target);\n  console.log(propertyKey);\n  console.log(descriptor);\n}\n \nclass Demo {\n  @LogMethod\n  public foo(bar: number) {\n    // do nothing\n  }\n}\n \nconst demo = new Demo();\n```\n\nWith `emitDecoratorMetadata` not set to true (default) the emitted JavaScript is:\n\n``` ts\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nfunction LogMethod(target, propertyKey, descriptor) {\n    console.log(target);\n    console.log(propertyKey);\n    console.log(descriptor);\n}\nclass Demo {\n    foo(bar) {\n        // do nothing\n    }\n}\n__decorate([\n    LogMethod\n], Demo.prototype, \"foo\", null);\nconst demo = new Demo();\n \n```\n\nWith `emitDecoratorMetadata` set to true the emitted JavaScript is:\n\n``` ts\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nfunction LogMethod(target, propertyKey, descriptor) {\n    console.log(target);\n    console.log(propertyKey);\n    console.log(descriptor);\n}\nclass Demo {\n    foo(bar) {\n        // do nothing\n    }\n}\n__decorate([\n    LogMethod,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Number]),\n    __metadata(\"design:returntype\", void 0)\n], Demo.prototype, \"foo\", null);\nconst demo = new Demo();\n \n```\n\n- Related:\n  - [`experimentalDecorators`](#experimentalDecorators)\n\n### Experimental Decorators - `experimentalDecorators`\n\nEnables [experimental support for decorators](https://github.com/tc39/proposal-decorators), which is a version of decorators that predates the TC39 standardization process.\n\nDecorators are a language feature which hasn’t yet been fully ratified into the JavaScript specification. This means that the implementation version in TypeScript may differ from the implementation in JavaScript when it it decided by TC39.\n\nYou can find out more about decorator support in TypeScript in [the handbook](docs/handbook/decorators).\n\n- Related:\n  - [`emitDecoratorMetadata`](#emitDecoratorMetadata)\n\n### JSX - `jsx`\n\nControls how JSX constructs are emitted in JavaScript files. This only affects output of JS files that started in `.tsx` files.\n\n- `react-jsx`: Emit `.js` files with the JSX changed to `_jsx` calls optimized for production\n- `react-jsxdev`: Emit `.js` files with the JSX changed to `_jsx` calls for development only\n- `preserve`: Emit `.jsx` files with the JSX unchanged\n- `react-native`: Emit `.js` files with the JSX unchanged\n- `react`: Emit `.js` files with JSX changed to the equivalent `React.createElement` calls\n\n### For example\n\nThis sample code:\n\n``` typescript+html\nexport const HelloWorld = () => <h1>Hello world</h1>;\n```\n\nReact: `\"react-jsx\"`^([\\[1\\]](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html))\n\n``` typescript+html\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport const HelloWorld = () => _jsx(\"h1\", { children: \"Hello world\" });\n \n```\n\nReact dev transform: `\"react-jsxdev\"`^([\\[1\\]](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html))\n\n``` typescript+html\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst _jsxFileName = \"/home/runner/work/TypeScript-Website/TypeScript-Website/packages/typescriptlang-org/index.tsx\";\nexport const HelloWorld = () => _jsxDEV(\"h1\", { children: \"Hello world\" }, void 0, false, { fileName: _jsxFileName, lineNumber: 9, columnNumber: 32 }, this);\n \n```\n\nPreserve: `\"preserve\"`\n\n``` typescript+html\nimport React from 'react';\nexport const HelloWorld = () => <h1>Hello world</h1>;\n \n```\n\nReact Native: `\"react-native\"`\n\n``` typescript+html\nimport React from 'react';\nexport const HelloWorld = () => <h1>Hello world</h1>;\n \n```\n\nLegacy React runtime: `\"react\"`\n\n``` typescript+html\nimport React from 'react';\nexport const HelloWorld = () => React.createElement(\"h1\", null, \"Hello world\");\n \n```\n\nThis option can be used on a per-file basis too using an `@jsxRuntime` comment.\n\nAlways use the classic runtime (`\"react\"`) for this file:\n\n``` typescript+html\n/* @jsxRuntime classic */\nexport const HelloWorld = () => <h1>Hello world</h1>;\n```\n\nAlways use the automatic runtime (`\"react-jsx\"`) for this file:\n\n``` typescript+html\n/* @jsxRuntime automatic */\nexport const HelloWorld = () => <h1>Hello world</h1>;\n```\n\n- Allowed:\n  - `preserve`\n\n  - `react`\n\n  - `react-native`\n\n  - `react-jsx`\n\n  - `react-jsxdev`\n\n- Related:\n  - [`jsxFactory`](#jsxFactory)\n\n  - [`jsxFragmentFactory`](#jsxFragmentFactory)\n\n  - [`jsxImportSource`](#jsxImportSource)\n\n- Released:\n\n  [2.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html)\n\n### JSX Factory - `jsxFactory`\n\nChanges the function called in `.js` files when compiling JSX Elements using the classic JSX runtime. The most common change is to use `\"h\"` or `\"preact.h\"` instead of the default `\"React.createElement\"` if using `preact`.\n\nFor example, this TSX file:\n\n``` typescript+html\nimport { h } from \"preact\";\n\nconst HelloWorld = () => <div>Hello</div>;\n```\n\nWith `jsxFactory: \"h\"` looks like:\n\n``` typescript+html\nconst preact_1 = require(\"preact\");\nconst HelloWorld = () => (0, preact_1.h)(\"div\", null, \"Hello\");\n \n```\n\nThis option can be used on a per-file basis too similar to [Babel’s `/** @jsx h */` directive](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#custom).\n\n``` typescript+html\n/** @jsx h */\nimport { h } from \"preact\";\n \nconst HelloWorld = () => <div>Hello</div>;\n```\n\nThe factory chosen will also affect where the `JSX` namespace is looked up (for type checking information) before falling back to the global one.\n\nIf the factory is defined as `React.createElement` (the default), the compiler will check for `React.JSX` before checking for a global `JSX`. If the factory is defined as `h`, it will check for `h.JSX` before a global `JSX`.\n\n- Default:\n\n  `React.createElement`\n\n- Allowed:\n  - Any identifier or dotted identifier.\n\n- Related:\n  - [`jsx`](#jsx)\n\n  - [`jsxFragmentFactory`](#jsxFragmentFactory)\n\n  - [`jsxImportSource`](#jsxImportSource)\n\n### JSX Fragment Factory - `jsxFragmentFactory`\n\nSpecify the JSX fragment factory function to use when targeting react JSX emit with [`jsxFactory`](#jsxFactory) compiler option is specified, e.g. `Fragment`.\n\nFor example with this TSConfig:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"commonjs\",\n    \"jsx\": \"react\",\n    \"jsxFactory\": \"h\",\n    \"jsxFragmentFactory\": \"Fragment\"\n  }\n}\n```\n\nThis TSX file:\n\n``` typescript+html\nimport { h, Fragment } from \"preact\";\n\nconst HelloWorld = () => (\n  <>\n    <div>Hello</div>\n  </>\n);\n```\n\nWould look like:\n\n``` typescript+html\nconst preact_1 = require(\"preact\");\nconst HelloWorld = () => ((0, preact_1.h)(preact_1.Fragment, null,\n    (0, preact_1.h)(\"div\", null, \"Hello\")));\n \n```\n\nThis option can be used on a per-file basis too similar to [Babel’s `/* @jsxFrag h */` directive](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#fragments).\n\nFor example:\n\n``` typescript+html\n/** @jsx h */\n/** @jsxFrag Fragment */\n \nimport { h, Fragment } from \"preact\";\n \nconst HelloWorld = () => (\n  <>\n    <div>Hello</div>\n  </>\n);\n```\n\n- Default:\n\n  `React.Fragment`\n\n- Related:\n  - [`jsx`](#jsx)\n\n  - [`jsxFactory`](#jsxFactory)\n\n  - [`jsxImportSource`](#jsxImportSource)\n\n- Released:\n\n  [4.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html)\n\n### JSX Import Source - `jsxImportSource`\n\nDeclares the module specifier to be used for importing the `jsx` and `jsxs` factory functions when using [`jsx`](#jsx) as `\"react-jsx\"` or `\"react-jsxdev\"` which were introduced in TypeScript 4.1.\n\nWith [React 17](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html) the library supports a new form of JSX transformation via a separate import.\n\nFor example with this code:\n\n``` typescript+html\nimport React from \"react\";\n\nfunction App() {\n  return <h1>Hello World</h1>;\n}\n```\n\nUsing this TSConfig:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"commonjs\",\n    \"jsx\": \"react-jsx\"\n  }\n}\n```\n\nThe emitted JavaScript from TypeScript is:\n\n``` typescript+html\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nfunction App() {\n    return (0, jsx_runtime_1.jsx)(\"h1\", { children: \"Hello World\" });\n}\n \n```\n\nFor example if you wanted to use `\"jsxImportSource\": \"preact\"`, you need a tsconfig like:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"commonjs\",\n    \"jsx\": \"react-jsx\",\n    \"jsxImportSource\": \"preact\",\n    \"types\": [\"preact\"]\n  }\n}\n```\n\nWhich generates code like:\n\n``` typescript+html\nfunction App() {\n    return (0, jsx_runtime_1.jsx)(\"h1\", { children: \"Hello World\" });\n}\n \n```\n\nAlternatively, you can use a per-file pragma to set this option, for example:\n\n``` typescript+html\n/** @jsxImportSource preact */\n\nexport function App() {\n  return <h1>Hello World</h1>;\n}\n```\n\nWould add `preact/jsx-runtime` as an import for the `_jsx` factory.\n\n*Note:* In order for this to work like you would expect, your `tsx` file must include an `export` or `import` so that it is considered a module.\n\n- Default:\n\n  `react`\n\n- Related:\n  - [`jsx`](#jsx)\n\n  - [`jsxFactory`](#jsxFactory)\n\n- Released:\n\n  [4.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html)\n\n### Lib - `lib`\n\nTypeScript includes a default set of type definitions for built-in JS APIs (like `Math`), as well as type definitions for things found in browser environments (like `document`). TypeScript also includes APIs for newer JS features matching the [`target`](#target) you specify; for example the definition for `Map` is available if [`target`](#target) is `ES6` or newer.\n\nYou may want to change these for a few reasons:\n\n- Your program doesn’t run in a browser, so you don’t want the `\"dom\"` type definitions\n- Your runtime platform provides certain JavaScript API objects (maybe through polyfills), but doesn’t yet support the full syntax of a given ECMAScript version\n- You have polyfills or native implementations for some, but not all, of a higher level ECMAScript version\n\nIn TypeScript 4.5, lib files can be overridden by npm modules, find out more [in the blog](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5-beta/#supporting-lib-from-node_modules).\n\n### High Level libraries\n\n| Name         | Contents                                                                                                                                          |\n|--------------|---------------------------------------------------------------------------------------------------------------------------------------------------|\n| `ES5`        | Core definitions for all ES3 and ES5 functionality                                                                                                |\n| `ES2015`     | Additional APIs available in ES2015 (also known as ES6) - `array.find`, `Promise`, `Proxy`, `Symbol`, `Map`, `Set`, `Reflect`, etc.               |\n| `ES6`        | Alias for “ES2015”                                                                                                                                |\n| `ES2016`     | Additional APIs available in ES2016 - `array.include`, etc.                                                                                       |\n| `ES7`        | Alias for “ES2016”                                                                                                                                |\n| `ES2017`     | Additional APIs available in ES2017 - `Object.entries`, `Object.values`, `Atomics`, `SharedArrayBuffer`, `date.formatToParts`, typed arrays, etc. |\n| `ES2018`     | Additional APIs available in ES2018 - `async` iterables, `promise.finally`, `Intl.PluralRules`, `regexp.groups`, etc.                             |\n| `ES2019`     | Additional APIs available in ES2019 - `array.flat`, `array.flatMap`, `Object.fromEntries`, `string.trimStart`, `string.trimEnd`, etc.             |\n| `ES2020`     | Additional APIs available in ES2020 - `string.matchAll`, etc.                                                                                     |\n| `ES2021`     | Additional APIs available in ES2021 - `promise.any`, `string.replaceAll` etc.                                                                     |\n| `ES2022`     | Additional APIs available in ES2022 - `array.at`, `RegExp.hasIndices`, etc.                                                                       |\n| `ES2023`     | Additional APIs available in ES2023 - `array.with`, `array.findLast`, `array.findLastIndex`, `array.toSorted`, `array.toReversed`, etc.           |\n| `ESNext`     | Additional APIs available in ESNext - This changes as the JavaScript specification evolves                                                        |\n| `DOM`        | [DOM](https://developer.mozilla.org/docs/Glossary/DOM) definitions - `window`, `document`, etc.                                                   |\n| `WebWorker`  | APIs available in [WebWorker](https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers) contexts                              |\n| `ScriptHost` | APIs for the [Windows Script Hosting System](https://wikipedia.org/wiki/Windows_Script_Host)                                                      |\n\n### Individual library components\n\n| Name                      |\n|---------------------------|\n| `DOM.Iterable`            |\n| `ES2015.Core`             |\n| `ES2015.Collection`       |\n| `ES2015.Generator`        |\n| `ES2015.Iterable`         |\n| `ES2015.Promise`          |\n| `ES2015.Proxy`            |\n| `ES2015.Reflect`          |\n| `ES2015.Symbol`           |\n| `ES2015.Symbol.WellKnown` |\n| `ES2016.Array.Include`    |\n| `ES2017.object`           |\n| `ES2017.Intl`             |\n| `ES2017.SharedMemory`     |\n| `ES2017.String`           |\n| `ES2017.TypedArrays`      |\n| `ES2018.Intl`             |\n| `ES2018.Promise`          |\n| `ES2018.RegExp`           |\n| `ES2019.Array`            |\n| `ES2019.Object`           |\n| `ES2019.String`           |\n| `ES2019.Symbol`           |\n| `ES2020.String`           |\n| `ES2020.Symbol.wellknown` |\n| `ES2021.Promise`          |\n| `ES2021.String`           |\n| `ES2021.WeakRef`          |\n| `ESNext.AsyncIterable`    |\n| `ESNext.Array`            |\n| `ESNext.Intl`             |\n| `ESNext.Symbol`           |\n\nThis list may be out of date, you can see the full list in the [TypeScript source code](https://github.com/microsoft/TypeScript/tree/main/src/lib).\n\n- Related:\n  - [`noLib`](#noLib)\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n### Module Detection - `moduleDetection`\n\nThis setting controls how TypeScript determines whether a file is a [script or a module](docs/handbook/modules/theory#scripts-and-modules-in-javascript).\n\nThere are three choices:\n\n- `\"auto\"` (default) - TypeScript will not only look for import and export statements, but it will also check whether the `\"type\"` field in a `package.json` is set to `\"module\"` when running with [`module`](#module): `nodenext` or `node16`, and check whether the current file is a JSX file when running under [`jsx`](#jsx): `react-jsx`.\n\n- `\"legacy\"` - The same behavior as 4.6 and prior, usings import and export statements to determine whether a file is a module.\n\n- `\"force\"` - Ensures that every non-declaration file is treated as a module.\n\n- Default:\n\n  \"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.\n\n- Allowed:\n  - `legacy`\n\n  - `auto`\n\n  - `force`\n\n- Released:\n\n  [4.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html)\n\n### No Lib - `noLib`\n\nDisables the automatic inclusion of any library files. If this option is set, `lib` is ignored.\n\nTypeScript *cannot* compile anything without a set of interfaces for key primitives like: `Array`, `Boolean`, `Function`, `IArguments`, `Number`, `Object`, `RegExp`, and `String`. It is expected that if you use `noLib` you will be including your own type definitions for these.\n\n- Related:\n  - [`lib`](#lib)\n\n### React Namespace - `reactNamespace`\n\nUse [`jsxFactory`](#jsxFactory) instead. Specify the object invoked for `createElement` when targeting `react` for TSX files.\n\n- Default:\n\n  `React`\n\n### Target - `target`\n\nModern browsers support all ES6 features, so `ES6` is a good choice. You might choose to set a lower target if your code is deployed to older environments, or a higher target if your code is guaranteed to run in newer environments.\n\nThe `target` setting changes which JS features are downleveled and which are left intact. For example, an arrow function `() => this` will be turned into an equivalent `function` expression if `target` is ES5 or lower.\n\nChanging `target` also changes the default value of [`lib`](#lib). You may “mix and match” `target` and `lib` settings as desired, but you could just set `target` for convenience.\n\nFor developer platforms like Node there are baselines for the `target`, depending on the type of platform and its version. You can find a set of community organized TSConfigs at [tsconfig/bases](https://github.com/tsconfig/bases#centralized-recommendations-for-tsconfig-bases), which has configurations for common platforms and their versions.\n\nThe special `ESNext` value refers to the highest version your version of TypeScript supports. This setting should be used with caution, since it doesn’t mean the same thing between different TypeScript versions and can make upgrades less predictable.\n\n- Default:\n\n  `ES3`\n\n- Allowed:\n  - `es3`\n\n  - `es5`\n\n  - `es6`/`es2015`\n\n  - `es2016`\n\n  - `es2017`\n\n  - `es2018`\n\n  - `es2019`\n\n  - `es2020`\n\n  - `es2021`\n\n  - `es2022`\n\n  - `es2023`\n\n  - `esnext`\n\n- Released:\n\n  [1.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html)\n\n### Use Define For Class Fields - `useDefineForClassFields`\n\nThis flag is used as part of migrating to the upcoming standard version of class fields. TypeScript introduced class fields many years before it was ratified in TC39. The latest version of the upcoming specification has a different runtime behavior to TypeScript’s implementation but the same syntax.\n\nThis flag switches to the upcoming ECMA runtime behavior.\n\nYou can read more about the transition in [the 3.7 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier).\n\n- Default:\n\n  `true` if [`target`](#target) is `ES2022` or higher, including `ESNext`; `false` otherwise.\n\n- Released:\n\n  [3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)\n\n## Compiler Diagnostics\n\n### Diagnostics - `diagnostics`\n\nUsed to output diagnostic information for debugging. This command is a subset of [`extendedDiagnostics`](#extendedDiagnostics) which are more user-facing results, and easier to interpret.\n\nIf you have been asked by a TypeScript compiler engineer to give the results using this flag in a compile, in which there is no harm in using [`extendedDiagnostics`](#extendedDiagnostics) instead.\n\n- Deprecated\n- Related:\n  - [`extendedDiagnostics`](#extendedDiagnostics)\n\n### Explain Files - `explainFiles`\n\nPrint names of files which TypeScript sees as a part of your project and the reason they are part of the compilation.\n\nFor example, with this project of just a single `index.ts` file\n\n``` shell\nexample\n├── index.ts\n├── package.json\n└── tsconfig.json\n```\n\nUsing a `tsconfig.json` which has `explainFiles` set to true:\n\n``` json\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"commonjs\",\n    \"explainFiles\": true\n  }\n}\n```\n\nRunning TypeScript against this folder would have output like this:\n\n``` typescript\n❯ tsc\nnode_modules/typescript/lib/lib.d.ts\n  Default library for target 'es5'\nnode_modules/typescript/lib/lib.es5.d.ts\n  Library referenced via 'es5' from file 'node_modules/typescript/lib/lib.d.ts'\nnode_modules/typescript/lib/lib.dom.d.ts\n  Library referenced via 'dom' from file 'node_modules/typescript/lib/lib.d.ts'\nnode_modules/typescript/lib/lib.webworker.importscripts.d.ts\n  Library referenced via 'webworker.importscripts' from file 'node_modules/typescript/lib/lib.d.ts'\nnode_modules/typescript/lib/lib.scripthost.d.ts\n  Library referenced via 'scripthost' from file 'node_modules/typescript/lib/lib.d.ts'\nindex.ts\n  Matched by include pattern '**/*' in 'tsconfig.json'\n```\n\nThe output above show:\n\n- The initial lib.d.ts lookup based on [`target`](#target), and the chain of `.d.ts` files which are referenced\n- The `index.ts` file located via the default pattern of [`include`](#include)\n\nThis option is intended for debugging how a file has become a part of your compile.\n\n- Released:\n\n  [4.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html)\n\n### Extended Diagnostics - `extendedDiagnostics`\n\nYou can use this flag to discover where TypeScript is spending its time when compiling. This is a tool used for understanding the performance characteristics of your codebase overall.\n\nYou can learn more about how to measure and understand the output in the performance [section of the wiki](https://github.com/microsoft/TypeScript/wiki/Performance).\n\n- Related:\n  - [`diagnostics`](#diagnostics)\n\n### Generate CPU Profile - `generateCpuProfile`\n\nThis option gives you the chance to have TypeScript emit a v8 CPU profile during the compiler run. The CPU profile can provide insight into why your builds may be slow.\n\nThis option can only be used from the CLI via: `--generateCpuProfile tsc-output.cpuprofile`.\n\n``` shell\nnpm run tsc --generateCpuProfile tsc-output.cpuprofile\n```\n\nThis file can be opened in a chromium based browser like Chrome or Edge Developer in [the CPU profiler](https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution) section. You can learn more about understanding the compilers performance in the [TypeScript wiki section on performance](https://github.com/microsoft/TypeScript/wiki/Performance).\n\n- Default:\n\n  `profile.cpuprofile`\n\n- Released:\n\n  [3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)\n\n### List Emitted Files - `listEmittedFiles`\n\nPrint names of generated files part of the compilation to the terminal.\n\nThis flag is useful in two cases:\n\n- You want to transpile TypeScript as a part of a build chain in the terminal where the filenames are processed in the next command.\n- You are not sure that TypeScript has included a file you expected, as a part of debugging the [file inclusion settings](#Project_Files_0).\n\nFor example:\n\n``` typescript\nexample\n├── index.ts\n├── package.json\n└── tsconfig.json\n```\n\nWith:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"declaration\": true,\n    \"listEmittedFiles\": true\n  }\n}\n```\n\nWould echo paths like:\n\n``` typescript\n$ npm run tsc\n\npath/to/example/index.js\npath/to/example/index.d.ts\n```\n\nNormally, TypeScript would return silently on success.\n\n### List Files - `listFiles`\n\nPrint names of files part of the compilation. This is useful when you are not sure that TypeScript has included a file you expected.\n\nFor example:\n\n``` typescript\nexample\n├── index.ts\n├── package.json\n└── tsconfig.json\n```\n\nWith:\n\n``` typescript\n{\n  \"compilerOptions\": {\n    \"listFiles\": true\n  }\n}\n```\n\nWould echo paths like:\n\n``` typescript\n$ npm run tsc\npath/to/example/node_modules/typescript/lib/lib.d.ts\npath/to/example/node_modules/typescript/lib/lib.es5.d.ts\npath/to/example/node_modules/typescript/lib/lib.dom.d.ts\npath/to/example/node_modules/typescript/lib/lib.webworker.importscripts.d.ts\npath/to/example/node_modules/typescript/lib/lib.scripthost.d.ts\npath/to/example/index.ts\n```\n\nNote if using TypeScript 4.2, prefer [`explainFiles`](#explainFiles) which offers an explanation of why a file was added too.\n\n- Related:\n  - [`explainFiles`](#explainFiles)\n\n### noCheck - `noCheck`\n\nDisable full type checking (only critical parse and emit errors will be reported).\n\n### Trace Resolution - `traceResolution`\n\nWhen you are trying to debug why a module isn’t being included. You can set `traceResolution` to `true` to have TypeScript print information about its resolution process for each processed file.\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n## Projects\n\n### Composite - `composite`\n\nThe `composite` option enforces certain constraints which make it possible for build tools (including TypeScript itself, under `--build` mode) to quickly determine if a project has been built yet.\n\nWhen this setting is on:\n\n- The [`rootDir`](#rootDir) setting, if not explicitly set, defaults to the directory containing the `tsconfig.json` file.\n\n- All implementation files must be matched by an [`include`](#include) pattern or listed in the [`files`](#files) array. If this constraint is violated, `tsc` will inform you which files weren’t specified.\n\n- [`declaration`](#declaration) defaults to `true`\n\nYou can find documentation on TypeScript projects in [the handbook](docs/handbook/project-references).\n\n- Related:\n  - [`incremental`](#incremental)\n\n  - [`tsBuildInfoFile`](#tsBuildInfoFile)\n\n- Released:\n\n  [3.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html)\n\n### Disable Referenced Project Load - `disableReferencedProjectLoad`\n\nIn multi-project TypeScript programs, TypeScript will load all of the available projects into memory in order to provide accurate results for editor responses which require a full knowledge graph like ‘Find All References’.\n\nIf your project is large, you can use the flag `disableReferencedProjectLoad` to disable the automatic loading of all projects. Instead, projects are loaded dynamically as you open files through your editor.\n\n- Released:\n\n  [4.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html)\n\n### Disable Solution Searching - `disableSolutionSearching`\n\nWhen working with [composite TypeScript projects](docs/handbook/project-references), this option provides a way to declare that you do not want a project to be included when using features like *find all references* or *jump to definition* in an editor.\n\nThis flag is something you can use to increase responsiveness in large composite projects.\n\n- Released:\n\n  [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)\n\n### Disable Source Project Reference Redirect - `disableSourceOfProjectReferenceRedirect`\n\nWhen working with [composite TypeScript projects](docs/handbook/project-references), this option provides a way to go [back to the pre-3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#build-free-editing-with-project-references) behavior where d.ts files were used to as the boundaries between modules. In 3.7 the source of truth is now your TypeScript files.\n\n- Released:\n\n  [3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)\n\n### Incremental - `incremental`\n\nTells TypeScript to save information about the project graph from the last compilation to files stored on disk. This creates a series of `.tsbuildinfo` files in the same folder as your compilation output. They are not used by your JavaScript at runtime and can be safely deleted. You can read more about the flag in the [3.4 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#faster-subsequent-builds-with-the---incremental-flag).\n\nTo control which folders you want to the files to be built to, use the config option [`tsBuildInfoFile`](#tsBuildInfoFile).\n\n- Default:\n\n  `true` if [`composite`](#composite); `false` otherwise.\n\n- Related:\n  - [`composite`](#composite)\n\n  - [`tsBuildInfoFile`](#tsBuildInfoFile)\n\n- Released:\n\n  [3.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html)\n\n### TS Build Info File - `tsBuildInfoFile`\n\nThis setting lets you specify a file for storing incremental compilation information as a part of composite projects which enables faster building of larger TypeScript codebases. You can read more about composite projects [in the handbook](docs/handbook/project-references).\n\nThe default depends on a combination of other settings:\n\n- If `outFile` is set, the default is `<outFile>.tsbuildinfo`.\n- If `rootDir` and `outDir` are set, then the file is `<outDir>/<relative path to config from rootDir>/<config name>.tsbuildinfo` For example, if `rootDir` is `src`, `outDir` is `dest`, and the config is `./tsconfig.json`, then the default is `./tsconfig.tsbuildinfo` as the relative path from `src/` to `./tsconfig.json` is `../`.\n- If `outDir` is set, then the default is `<outDir>/<config name>.tsbuildInfo`\n- Otherwise, the default is `<config name>.tsbuildInfo`\n\n- Default:\n\n  `.tsbuildinfo`\n\n- Related:\n  - [`incremental`](#incremental)\n\n  - [`composite`](#composite)\n\n- Released:\n\n  [3.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html)\n\n## Output Formatting\n\n### No Error Truncation - `noErrorTruncation`\n\nDo not truncate error messages.\n\nWith `false`, the default.\n\n``` ts\nvar x: {\n  propertyWithAnExceedinglyLongName1: string;\n  propertyWithAnExceedinglyLongName2: string;\n  propertyWithAnExceedinglyLongName3: string;\n  propertyWithAnExceedinglyLongName4: string;\n  propertyWithAnExceedinglyLongName5: string;\n  propertyWithAnExceedinglyLongName6: string;\n  propertyWithAnExceedinglyLongName7: string;\n  propertyWithAnExceedinglyLongName8: string;\n};\n \n// String representation of type of 'x' should be truncated in error message\nvar s: string = x;\n```\n\nWith `true`\n\n``` ts\nvar x: {\n  propertyWithAnExceedinglyLongName1: string;\n  propertyWithAnExceedinglyLongName2: string;\n  propertyWithAnExceedinglyLongName3: string;\n  propertyWithAnExceedinglyLongName4: string;\n  propertyWithAnExceedinglyLongName5: string;\n  propertyWithAnExceedinglyLongName6: string;\n  propertyWithAnExceedinglyLongName7: string;\n  propertyWithAnExceedinglyLongName8: string;\n};\n \n// String representation of type of 'x' should be truncated in error message\nvar s: string = x;\n```\n\n### Preserve Watch Output - `preserveWatchOutput`\n\nWhether to keep outdated console output in watch mode instead of clearing the screen every time a change happened.\n\n- Internal\n\n### Pretty - `pretty`\n\nStylize errors and messages using color and context, this is on by default — offers you a chance to have less terse, single colored messages from the compiler.\n\n- Default:\n\n  `true`\n\n## Completeness\n\n### Skip Default Lib Check - `skipDefaultLibCheck`\n\nUse [`skipLibCheck`](#skipLibCheck) instead. Skip type checking of default library declaration files.\n\n### Skip Lib Check - `skipLibCheck`\n\nSkip type checking of declaration files.\n\nThis can save time during compilation at the expense of type-system accuracy. For example, two libraries could define two copies of the same `type` in an inconsistent way. Rather than doing a full check of all `d.ts` files, TypeScript will type check the code you specifically refer to in your app’s source code.\n\nA common case where you might think to use `skipLibCheck` is when there are two copies of a library’s types in your `node_modules`. In these cases, you should consider using a feature like [yarn’s resolutions](https://yarnpkg.com/lang/en/docs/selective-version-resolutions/) to ensure there is only one copy of that dependency in your tree or investigate how to ensure there is only one copy by understanding the dependency resolution to fix the issue without additional tooling.\n\nAnother possibility is when you are migrating between TypeScript releases and the changes cause breakages in node_modules and the JS standard libraries which you do not want to deal with during the TypeScript update.\n\nNote, that if these issues come from the TypeScript standard library you can replace the library using [TypeScript 4.5’s lib replacement](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#supporting-lib-from-node_modules) technique.\n\n- Recommended\n\n- Released:\n\n  [2.0](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html)\n\n## Command Line\n\n## Watch Options\n\nTypeScript 3.8 shipped a new strategy for watching directories, which is crucial for efficiently picking up changes to `node_modules`.\n\nOn operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on `node_modules` and many of its subdirectories to detect changes in dependencies. This is because the number of available file watchers is often eclipsed by the number of files in `node_modules`, whereas there are way fewer directories to track.\n\nBecause every project might work better under different strategies, and this new approach might not work well for your workflows, TypeScript 3.8 introduces a new `watchOptions` field which allows users to tell the compiler/language service which watching strategies should be used to keep track of files and directories.\n\n### Assume Changes Only Affect Direct Dependencies - `assumeChangesOnlyAffectDirectDependencies`\n\nWhen this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them.\n\nThis can be considered a ‘fast & loose’ implementation of the watching algorithm, which can drastically reduce incremental rebuild times at the expense of having to run the full build occasionally to get all compiler error messages.\n\n- Released:\n\n  [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)\n\n## Watch Options\n\nYou can configure the how TypeScript `--watch` works. This section is mainly for handling case where `fs.watch` and `fs.watchFile` have additional constraints like on Linux. You can read more at [Configuring Watch](docs/handbook/configuring-watch).\n\n### Watch File - `watchFile`\n\nThe strategy for how individual files are watched.\n\n- `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.\n- `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.\n- `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.\n- `useFsEvents` (the default): Attempt to use the operating system/file system’s native events for file changes.\n- `useFsEventsOnParentDirectory`: Attempt to use the operating system/file system’s native events to listen for changes on a file’s parent directory\n\n- Allowed:\n  - `fixedpollinginterval`\n\n  - `prioritypollinginterval`\n\n  - `dynamicprioritypolling`\n\n  - `fixedchunksizepolling`\n\n  - `usefsevents`\n\n  - `usefseventsonparentdirectory`\n\n- Released:\n\n  [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)\n\n### Watch Directory - `watchDirectory`\n\nThe strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality.\n\n- `fixedPollingInterval`: Check every directory for changes several times a second at a fixed interval.\n- `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified directories will be checked less often.\n- `useFsEvents` (the default): Attempt to use the operating system/file system’s native events for directory changes.\n\n- Allowed:\n  - `usefsevents`\n\n  - `fixedpollinginterval`\n\n  - `dynamicprioritypolling`\n\n  - `fixedchunksizepolling`\n\n- Released:\n\n  [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)\n\n### Fallback Polling - `fallbackPolling`\n\nWhen using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn’t support native file watchers.\n\n- `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.\n- `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.\n- `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.\n- `synchronousWatchDirectory`: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in `node_modules` from running `npm install`), but you might want to disable it with this flag for some less-common setups.\n\n- Allowed:\n  - `fixedinterval`\n\n  - `priorityinterval`\n\n  - `dynamicpriority`\n\n  - `fixedchunksize`\n\n- Released:\n\n  [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)\n\n### Synchronous Watch Directory - `synchronousWatchDirectory`\n\nSynchronously call callbacks and update the state of directory watchers on platforms that don\\`t support recursive watching natively. Instead of giving a small timeout to allow for potentially multiple edits to occur on a file.\n\n``` typescript\n{\n  \"watchOptions\": {\n    \"synchronousWatchDirectory\": true\n  }\n}\n```\n\n### Exclude Directories - `excludeDirectories`\n\nYou can use [`excludeFiles`](#excludeFiles) to drastically reduce the number of files which are watched during `--watch`. This can be a useful way to reduce the number of open file which TypeScript tracks on Linux.\n\n``` typescript\n{\n  \"watchOptions\": {\n    \"excludeDirectories\": [\"**/node_modules\", \"_build\", \"temp/*\"]\n  }\n}\n```\n\n### Exclude Files - `excludeFiles`\n\nYou can use `excludeFiles` to remove a set of specific files from the files which are watched.\n\n``` typescript\n{\n  \"watchOptions\": {\n    \"excludeFiles\": [\"temp/file.ts\"]\n  }\n}\n```\n\n## Type Acquisition\n\nType Acquisition is only important for JavaScript projects. In TypeScript projects you need to include the types in your projects explicitly. However, for JavaScript projects, the TypeScript tooling will download types for your modules in the background and outside of your node_modules folder.\n\n### Enable - `enable`\n\nDisables automatic type acquisition in JavaScript projects:\n\n``` json\n{\n  \"typeAcquisition\": {\n    \"enable\": false\n  }\n}\n```\n\n### Include - `include`\n\nIf you have a JavaScript project where TypeScript needs additional guidance to understand global dependencies, or have disabled the built-in inference via [`disableFilenameBasedTypeAcquisition`](#disableFilenameBasedTypeAcquisition).\n\nYou can use `include` to specify which types should be used from DefinitelyTyped:\n\n``` json\n{\n  \"typeAcquisition\": {\n    \"include\": [\"jquery\"]\n  }\n}\n```\n\n### Exclude - `exclude`\n\nOffers a config for disabling the type-acquisition for a certain module in JavaScript projects. This can be useful for projects which include other libraries in testing infrastructure which aren’t needed in the main application.\n\n``` json\n{\n  \"typeAcquisition\": {\n    \"exclude\": [\"jest\", \"mocha\"]\n  }\n}\n```\n\n### Disable Filename Based Type Acquisition - `disableFilenameBasedTypeAcquisition`\n\nTypeScript’s type acquisition can infer what types should be added based on filenames in a project. This means that having a file like `jquery.js` in your project would automatically download the types for JQuery from DefinitelyTyped.\n\nYou can disable this via `disableFilenameBasedTypeAcquisition`.\n\n``` json\n{\n  \"typeAcquisition\": {\n    \"disableFilenameBasedTypeAcquisition\": true\n  }\n}\n```\n\n- Released:\n\n  [4.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/tsconfig](https://www.typescriptlang.org/tsconfig)"
- name: Type Checking JavaScript Files
  id: type-checking-javascript-files
  summary: Here are some notable differences on how checking works in .js files compared to .ts files
  description: "# Type Checking JavaScript Files\n\nHere are some notable differences on how checking works in `.js` files compared to `.ts` files.\n\n## Properties are inferred from assignments in class bodies\n\nES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals.\n\nIn a `.js` file, the compiler infers properties from property assignments inside the class body. The type of a property is the type given in the constructor, unless it’s not defined there, or the type in the constructor is undefined or null. In that case, the type is the union of the types of all the right-hand values in these assignments. Properties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional.\n\n``` js\nclass C {\n  constructor() {\n    this.constructorOnly = 0;\n    this.constructorUnknown = undefined;\n  }\n  method() {\n    this.constructorOnly = false;\n    this.constructorUnknown = \"plunkbat\"; // ok, constructorUnknown is string | undefined\n    this.methodOnly = \"ok\"; // ok, but methodOnly could also be undefined\n  }\n  method2() {\n    this.methodOnly = true; // also, ok, methodOnly's type is string | boolean | undefined\n  }\n}\n```\n\nIf properties are never set in the class body, they are considered unknown. If your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type. You don’t even have to give a value if it will be initialized later:\n\n``` js\nclass C {\n  constructor() {\n    /** @type {number | undefined} */\n    this.prop = undefined;\n    /** @type {number | undefined} */\n    this.count;\n  }\n}\n \nlet c = new C();\nc.prop = 0; // OK\nc.count = \"string\";\n```\n\n## Constructor functions are equivalent to classes\n\nBefore ES2015, JavaScript used constructor functions instead of classes. The compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes. The property inference rules described above work exactly the same way.\n\n``` js\nfunction C() {\n  this.constructorOnly = 0;\n  this.constructorUnknown = undefined;\n}\nC.prototype.method = function () {\n  this.constructorOnly = false;\n  this.constructorUnknown = \"plunkbat\"; // OK, the type is string | undefined\n};\n```\n\n## CommonJS modules are supported\n\nIn a `.js` file, TypeScript understands the CommonJS module format. Assignments to `exports` and `module.exports` are recognized as export declarations. Similarly, `require` function calls are recognized as module imports. For example:\n\n``` js\n// same as `import module \"fs\"`\nconst fs = require(\"fs\");\n\n// same as `export function readFile`\nmodule.exports.readFile = function (f) {\n  return fs.readFileSync(f);\n};\n```\n\nThe module support in JavaScript is much more syntactically forgiving than TypeScript’s module support. Most combinations of assignments and declarations are supported.\n\n## Classes, functions, and object literals are namespaces\n\nClasses are namespaces in `.js` files. This can be used to nest classes, for example:\n\n``` js\nclass C {}\nC.D = class {};\n```\n\nAnd, for pre-ES2015 code, it can be used to simulate static methods:\n\n``` js\nfunction Outer() {\n  this.y = 2;\n}\n \nOuter.Inner = function () {\n  this.yy = 2;\n};\n \nOuter.Inner();\n```\n\nIt can also be used to create simple namespaces:\n\n``` js\nvar ns = {};\nns.C = class {};\nns.func = function () {};\n \nns;\n```\n\nOther variants are allowed as well:\n\n``` js\n// IIFE\nvar ns = (function (n) {\n  return n || {};\n})();\nns.CONST = 1;\n \n// defaulting to global\nvar assign =\n  assign ||\n  function () {\n    // code goes here\n  };\nassign.extra = 1;\n```\n\n## Object literals are open-ended\n\nIn a `.ts` file, an object literal that initializes a variable declaration gives its type to the declaration. No new members can be added that were not specified in the original literal. This rule is relaxed in a `.js` file; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally. For instance:\n\n``` js\nvar obj = { a: 1 };\nobj.b = 2; // Allowed\n```\n\nObject literals behave as if they have an index signature `[x:string]: any` that allows them to be treated as open maps instead of closed objects.\n\nLike other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:\n\n``` js\n/** @type {{a: number}} */\nvar obj = { a: 1 };\nobj.b = 2;\n```\n\n## null, undefined, and empty array initializers are of type any or any\\[\\]\n\nAny variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on. Any variable, parameter or property that is initialized with \\[\\] will have type any\\[\\], even if strict null checks is turned on. The only exception is for properties that have multiple initializers as described above.\n\n``` js\nfunction Foo(i = null) {\n  if (!i) i = 1;\n  var j = undefined;\n  j = 2;\n  this.l = [];\n}\n \nvar foo = new Foo();\nfoo.l.push(foo.i);\nfoo.l.push(\"end\");\n```\n\n## Function parameters are optional by default\n\nSince there is no way to specify optionality on parameters in pre-ES2015 JavaScript, all function parameters in `.js` file are considered optional. Calls with fewer arguments than the declared number of parameters are allowed.\n\nIt is important to note that it is an error to call a function with too many arguments.\n\nFor instance:\n\n``` js\nfunction bar(a, b) {\n  console.log(a + \" \" + b);\n}\n \nbar(1); // OK, second argument considered optional\nbar(1, 2);\nbar(1, 2, 3); // Error, too many arguments\n```\n\nJSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax (`[` `]`) to express optionality. e.g.:\n\n``` js\n/**\n * @param {string} [somebody] - Somebody's name.\n */\nfunction sayHello(somebody) {\n  if (!somebody) {\n    somebody = \"John Doe\";\n  }\n  console.log(\"Hello \" + somebody);\n}\n \nsayHello();\n```\n\n## Var-args parameter declaration inferred from use of `arguments`\n\nA function whose body has a reference to the `arguments` reference is implicitly considered to have a var-arg parameter (i.e. `(...arg: any[]) => any`). Use JSDoc var-arg syntax to specify the type of the arguments.\n\n``` js\n/** @param {...number} args */\nfunction sum(/* numbers */) {\n  var total = 0;\n  for (var i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}\n```\n\n## Unspecified type parameters default to `any`\n\nSince there is no natural syntax for specifying generic type parameters in JavaScript, an unspecified type parameter defaults to `any`.\n\n### In extends clause\n\nFor instance, `React.Component` is defined to have two type parameters, `Props` and `State`. In a `.js` file, there is no legal way to specify these in the extends clause. By default the type arguments will be `any`:\n\n``` js\nimport { Component } from \"react\";\n\nclass MyComponent extends Component {\n  render() {\n    this.props.b; // Allowed, since this.props is of type any\n  }\n}\n```\n\nUse JSDoc `@augments` to specify the types explicitly. for instance:\n\n``` js\nimport { Component } from \"react\";\n\n/**\n * @augments {Component<{a: number}, State>}\n */\nclass MyComponent extends Component {\n  render() {\n    this.props.b; // Error: b does not exist on {a:number}\n  }\n}\n```\n\n### In JSDoc references\n\nAn unspecified type argument in JSDoc defaults to any:\n\n``` js\n/** @type{Array} */\nvar x = [];\n \nx.push(1); // OK\nx.push(\"string\"); // OK, x is of type Array<any>\n \n/** @type{Array.<number>} */\nvar y = [];\n \ny.push(1); // OK\ny.push(\"string\"); // Error, string is not assignable to number\n```\n\n### In function calls\n\nA call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default to `any`. For example:\n\n``` js\nvar p = new Promise((resolve, reject) => {\n  reject();\n});\n\np; // Promise<any>;\n```\n\nTo learn all of the features available in JSDoc, see [the reference](jsdoc-supported-types).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html)"
- name: 'Type Checking JavaScript Files: Classes, functions, and object literals are namespaces'
  id: type-checking-javascript-files#classes-functions-and-object-literals-are-namespaces
  summary: Classes are namespaces in .js files
  belongs_to: Type Checking JavaScript Files
  description: |-
    ## Classes, functions, and object literals are namespaces

    Classes are namespaces in `.js` files. This can be used to nest classes, for example:

    ``` js
    class C {}
    C.D = class {};
    ```

    And, for pre-ES2015 code, it can be used to simulate static methods:

    ``` js
    function Outer() {
      this.y = 2;
    }
     
    Outer.Inner = function () {
      this.yy = 2;
    };
     
    Outer.Inner();
    ```

    It can also be used to create simple namespaces:

    ``` js
    var ns = {};
    ns.C = class {};
    ns.func = function () {};
     
    ns;
    ```

    Other variants are allowed as well:

    ``` js
    // IIFE
    var ns = (function (n) {
      return n || {};
    })();
    ns.CONST = 1;
     
    // defaulting to global
    var assign =
      assign ||
      function () {
        // code goes here
      };
    assign.extra = 1;
    ```
- name: 'Type Checking JavaScript Files: CommonJS modules are supported'
  id: type-checking-javascript-files#commonjs-modules-are-supported
  summary: In a .js file, TypeScript understands the CommonJS module format
  belongs_to: Type Checking JavaScript Files
  description: |-
    ## CommonJS modules are supported

    In a `.js` file, TypeScript understands the CommonJS module format. Assignments to `exports` and `module.exports` are recognized as export declarations. Similarly, `require` function calls are recognized as module imports. For example:

    ``` js
    // same as `import module "fs"`
    const fs = require("fs");

    // same as `export function readFile`
    module.exports.readFile = function (f) {
      return fs.readFileSync(f);
    };
    ```

    The module support in JavaScript is much more syntactically forgiving than TypeScript’s module support. Most combinations of assignments and declarations are supported.
- name: 'Type Checking JavaScript Files: Constructor functions are equivalent to classes'
  id: type-checking-javascript-files#constructor-functions-are-equivalent-to-classes
  summary: Before ES2015, JavaScript used constructor functions instead of classes
  belongs_to: Type Checking JavaScript Files
  description: |-
    ## Constructor functions are equivalent to classes

    Before ES2015, JavaScript used constructor functions instead of classes. The compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes. The property inference rules described above work exactly the same way.

    ``` js
    function C() {
      this.constructorOnly = 0;
      this.constructorUnknown = undefined;
    }
    C.prototype.method = function () {
      this.constructorOnly = false;
      this.constructorUnknown = "plunkbat"; // OK, the type is string | undefined
    };
    ```
- name: 'Type Checking JavaScript Files: Function parameters are optional by default'
  id: type-checking-javascript-files#function-parameters-are-optional-by-default
  summary: Since there is no way to specify optionality on parameters in pre-ES2015 JavaScript, all function parameters in .js file are considered optional
  belongs_to: Type Checking JavaScript Files
  description: |-
    ## Function parameters are optional by default

    Since there is no way to specify optionality on parameters in pre-ES2015 JavaScript, all function parameters in `.js` file are considered optional. Calls with fewer arguments than the declared number of parameters are allowed.

    It is important to note that it is an error to call a function with too many arguments.

    For instance:

    ``` js
    function bar(a, b) {
      console.log(a + " " + b);
    }
     
    bar(1); // OK, second argument considered optional
    bar(1, 2);
    bar(1, 2, 3); // Error, too many arguments
    ```

    JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax (`[` `]`) to express optionality. e.g.:

    ``` js
    /**
     * @param {string} [somebody] - Somebody's name.
     */
    function sayHello(somebody) {
      if (!somebody) {
        somebody = "John Doe";
      }
      console.log("Hello " + somebody);
    }
     
    sayHello();
    ```
- name: 'Type Checking JavaScript Files: null, undefined, and empty array initializers are of type any or any[]'
  id: type-checking-javascript-files#null-undefined-and-empty-array-initializers-are-of-type-any-or-any
  summary: Any variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on
  belongs_to: Type Checking JavaScript Files
  description: |-
    ## null, undefined, and empty array initializers are of type any or any\[\]

    Any variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on. Any variable, parameter or property that is initialized with \[\] will have type any\[\], even if strict null checks is turned on. The only exception is for properties that have multiple initializers as described above.

    ``` js
    function Foo(i = null) {
      if (!i) i = 1;
      var j = undefined;
      j = 2;
      this.l = [];
    }
     
    var foo = new Foo();
    foo.l.push(foo.i);
    foo.l.push("end");
    ```
- name: 'Type Checking JavaScript Files: Object literals are open-ended'
  id: type-checking-javascript-files#object-literals-are-open-ended
  summary: In a .ts file, an object literal that initializes a variable declaration gives its type to the declaration
  belongs_to: Type Checking JavaScript Files
  description: |-
    ## Object literals are open-ended

    In a `.ts` file, an object literal that initializes a variable declaration gives its type to the declaration. No new members can be added that were not specified in the original literal. This rule is relaxed in a `.js` file; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally. For instance:

    ``` js
    var obj = { a: 1 };
    obj.b = 2; // Allowed
    ```

    Object literals behave as if they have an index signature `[x:string]: any` that allows them to be treated as open maps instead of closed objects.

    Like other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:

    ``` js
    /** @type {{a: number}} */
    var obj = { a: 1 };
    obj.b = 2;
    ```
- name: 'Type Checking JavaScript Files: Properties are inferred from assignments in class bodies'
  id: type-checking-javascript-files#properties-are-inferred-from-assignments-in-class-bodies
  summary: ES2015 does not have a means for declaring properties on classes
  belongs_to: Type Checking JavaScript Files
  description: |-
    ## Properties are inferred from assignments in class bodies

    ES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals.

    In a `.js` file, the compiler infers properties from property assignments inside the class body. The type of a property is the type given in the constructor, unless it’s not defined there, or the type in the constructor is undefined or null. In that case, the type is the union of the types of all the right-hand values in these assignments. Properties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional.

    ``` js
    class C {
      constructor() {
        this.constructorOnly = 0;
        this.constructorUnknown = undefined;
      }
      method() {
        this.constructorOnly = false;
        this.constructorUnknown = "plunkbat"; // ok, constructorUnknown is string | undefined
        this.methodOnly = "ok"; // ok, but methodOnly could also be undefined
      }
      method2() {
        this.methodOnly = true; // also, ok, methodOnly's type is string | boolean | undefined
      }
    }
    ```

    If properties are never set in the class body, they are considered unknown. If your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type. You don’t even have to give a value if it will be initialized later:

    ``` js
    class C {
      constructor() {
        /** @type {number | undefined} */
        this.prop = undefined;
        /** @type {number | undefined} */
        this.count;
      }
    }
     
    let c = new C();
    c.prop = 0; // OK
    c.count = "string";
    ```
- name: 'Type Checking JavaScript Files: Unspecified type parameters default to any'
  id: type-checking-javascript-files#unspecified-type-parameters-default-to-any
  summary: Since there is no natural syntax for specifying generic type parameters in JavaScript, an unspecified type parameter defaults to any
  belongs_to: Type Checking JavaScript Files
  description: "## Unspecified type parameters default to `any`\n\nSince there is no natural syntax for specifying generic type parameters in JavaScript, an unspecified type parameter defaults to `any`.\n\n### In extends clause\n\nFor instance, `React.Component` is defined to have two type parameters, `Props` and `State`. In a `.js` file, there is no legal way to specify these in the extends clause. By default the type arguments will be `any`:\n\n``` js\nimport { Component } from \"react\";\n\nclass MyComponent extends Component {\n  render() {\n    this.props.b; // Allowed, since this.props is of type any\n  }\n}\n```\n\nUse JSDoc `@augments` to specify the types explicitly. for instance:\n\n``` js\nimport { Component } from \"react\";\n\n/**\n * @augments {Component<{a: number}, State>}\n */\nclass MyComponent extends Component {\n  render() {\n    this.props.b; // Error: b does not exist on {a:number}\n  }\n}\n```\n\n### In JSDoc references\n\nAn unspecified type argument in JSDoc defaults to any:\n\n``` js\n/** @type{Array} */\nvar x = [];\n \nx.push(1); // OK\nx.push(\"string\"); // OK, x is of type Array<any>\n \n/** @type{Array.<number>} */\nvar y = [];\n \ny.push(1); // OK\ny.push(\"string\"); // Error, string is not assignable to number\n```\n\n### In function calls\n\nA call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default to `any`. For example:\n\n``` js\nvar p = new Promise((resolve, reject) => {\n  reject();\n});\n\np; // Promise<any>;\n```\n\nTo learn all of the features available in JSDoc, see [the reference](jsdoc-supported-types).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html)"
- name: 'Type Checking JavaScript Files: Var-args parameter declaration inferred from use of arguments'
  id: type-checking-javascript-files#var-args-parameter-declaration-inferred-from-use-of-arguments
  summary: A function whose body has a reference to the arguments reference is implicitly considered to have a var-arg parameter (i.e
  belongs_to: Type Checking JavaScript Files
  description: |-
    ## Var-args parameter declaration inferred from use of `arguments`

    A function whose body has a reference to the `arguments` reference is implicitly considered to have a var-arg parameter (i.e. `(...arg: any[]) => any`). Use JSDoc var-arg syntax to specify the type of the arguments.

    ``` js
    /** @param {...number} args */
    function sum(/* numbers */) {
      var total = 0;
      for (var i = 0; i < arguments.length; i++) {
        total += arguments[i];
      }
      return total;
    }
    ```
- name: Type Compatibility
  id: type-compatibility
  summary: Type compatibility in TypeScript is based on structural subtyping
  description: "# Type Compatibility\n\nType compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:\n\n``` ts\ninterface Pet {\n  name: string;\n}\n\nclass Dog {\n  name: string;\n}\n\nlet pet: Pet;\n// OK, because of structural typing\npet = new Dog();\n```\n\nIn nominally-typed languages like C# or Java, the equivalent code would be an error because the `Dog` class does not explicitly describe itself as being an implementer of the `Pet` interface.\n\nTypeScript’s structural type system was designed based on how JavaScript code is typically written. Because JavaScript widely uses anonymous objects like function expressions and object literals, it’s much more natural to represent the kinds of relationships found in JavaScript libraries with a structural type system instead of a nominal one.\n\n## A Note on Soundness\n\nTypeScript’s type system allows certain operations that can’t be known at compile-time to be safe. When a type system has this property, it is said to not be “sound”. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we’ll explain where these happen and the motivating scenarios behind them.\n\n## Starting out\n\nThe basic rule for TypeScript’s structural type system is that `x` is compatible with `y` if `y` has at least the same members as `x`. For example consider the following code involving an interface named `Pet` which has a `name` property:\n\n``` ts\ninterface Pet {\n  name: string;\n}\n\nlet pet: Pet;\n// dog's inferred type is { name: string; owner: string; }\nlet dog = { name: \"Lassie\", owner: \"Rudd Weatherwax\" };\npet = dog;\n```\n\nTo check whether `dog` can be assigned to `pet`, the compiler checks each property of `pet` to find a corresponding compatible property in `dog`. In this case, `dog` must have a member called `name` that is a string. It does, so the assignment is allowed.\n\nThe same rule for assignment is used when checking function call arguments:\n\n``` ts\ninterface Pet {\n  name: string;\n}\n\nlet dog = { name: \"Lassie\", owner: \"Rudd Weatherwax\" };\n\nfunction greet(pet: Pet) {\n  console.log(\"Hello, \" + pet.name);\n}\ngreet(dog); // OK\n```\n\nNote that `dog` has an extra `owner` property, but this does not create an error. Only members of the target type (`Pet` in this case) are considered when checking for compatibility. This comparison process proceeds recursively, exploring the type of each member and sub-member.\n\nBe aware, however, that object literals [may only specify known properties](2/objects#excess-property-checks). For example, because we have explicitly specified that `dog` is of type `Pet`, the following code is invalid:\n\n``` ts\nlet dog: Pet = { name: \"Lassie\", owner: \"Rudd Weatherwax\" }; // Error\n```\n\n## Comparing two functions\n\nWhile comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible is a bit more involved. Let’s start with a basic example of two functions that differ only in their parameter lists:\n\n``` ts\nlet x = (a: number) => 0;\nlet y = (b: number, s: string) => 0;\n\ny = x; // OK\nx = y; // Error\n```\n\nTo check if `x` is assignable to `y`, we first look at the parameter list. Each parameter in `x` must have a corresponding parameter in `y` with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of `x` has a corresponding compatible parameter in `y`, so the assignment is allowed.\n\nThe second assignment is an error, because `y` has a required second parameter that `x` does not have, so the assignment is disallowed.\n\nYou may be wondering why we allow ‘discarding’ parameters like in the example `y = x`. The reason for this assignment to be allowed is that ignoring extra function parameters is actually quite common in JavaScript. For example, `Array#forEach` provides three parameters to the callback function: the array element, its index, and the containing array. Nevertheless, it’s very useful to provide a callback that only uses the first parameter:\n\n``` ts\nlet items = [1, 2, 3];\n\n// Don't force these extra parameters\nitems.forEach((item, index, array) => console.log(item));\n\n// Should be OK!\nitems.forEach((item) => console.log(item));\n```\n\nNow let’s look at how return types are treated, using two functions that differ only by their return type:\n\n``` ts\nlet x = () => ({ name: \"Alice\" });\nlet y = () => ({ name: \"Alice\", location: \"Seattle\" });\n\nx = y; // OK\ny = x; // Error, because x() lacks a location property\n```\n\nThe type system enforces that the source function’s return type be a subtype of the target type’s return type.\n\n### Function Parameter Bivariance\n\nWhen comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:\n\n``` ts\nenum EventType {\n  Mouse,\n  Keyboard,\n}\n\ninterface Event {\n  timestamp: number;\n}\ninterface MyMouseEvent extends Event {\n  x: number;\n  y: number;\n}\ninterface MyKeyEvent extends Event {\n  keyCode: number;\n}\n\nfunction listenEvent(eventType: EventType, handler: (n: Event) => void) {\n  /* ... */\n}\n\n// Unsound, but useful and common\nlistenEvent(EventType.Mouse, (e: MyMouseEvent) => console.log(e.x + \",\" + e.y));\n\n// Undesirable alternatives in presence of soundness\nlistenEvent(EventType.Mouse, (e: Event) =>\n  console.log((e as MyMouseEvent).x + \",\" + (e as MyMouseEvent).y)\n);\nlistenEvent(EventType.Mouse, ((e: MyMouseEvent) =>\n  console.log(e.x + \",\" + e.y)) as (e: Event) => void);\n\n// Still disallowed (clear error). Type safety enforced for wholly incompatible types\nlistenEvent(EventType.Mouse, (e: number) => console.log(e));\n```\n\nYou can have TypeScript raise errors when this happens via the compiler flag [`strictFunctionTypes`](https://www.typescriptlang.org/tsconfig#strictFunctionTypes).\n\n### Optional Parameters and Rest Parameters\n\nWhen comparing functions for compatibility, optional and required parameters are interchangeable. Extra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the source type are not an error.\n\nWhen a function has a rest parameter, it is treated as if it were an infinite series of optional parameters.\n\nThis is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing `undefined` in that position is equivalent for most functions.\n\nThe motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:\n\n``` ts\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n  /* ... Invoke callback with 'args' ... */\n}\n\n// Unsound - invokeLater \"might\" provide any number of arguments\ninvokeLater([1, 2], (x, y) => console.log(x + \", \" + y));\n\n// Confusing (x and y are actually required) and undiscoverable\ninvokeLater([1, 2], (x?, y?) => console.log(x + \", \" + y));\n```\n\n### Functions with overloads\n\nWhen a function has overloads, each overload in the target type must be matched by a compatible signature on the source type. This ensures that the source function can be called in all the same cases as the target function.\n\n## Enums\n\nEnums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,\n\n``` ts\nenum Status {\n  Ready,\n  Waiting,\n}\nenum Color {\n  Red,\n  Blue,\n  Green,\n}\n\nlet status = Status.Ready;\nstatus = Color.Green; // Error\n```\n\n## Classes\n\nClasses work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility.\n\n``` ts\nclass Animal {\n  feet: number;\n  constructor(name: string, numFeet: number) {}\n}\n\nclass Size {\n  feet: number;\n  constructor(numFeet: number) {}\n}\n\nlet a: Animal;\nlet s: Size;\n\na = s; // OK\ns = a; // OK\n```\n\n### Private and protected members in classes\n\nPrivate and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but *not* with classes from a different inheritance hierarchy which otherwise have the same shape.\n\n## Generics\n\nBecause TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,\n\n``` ts\ninterface Empty<T> {}\nlet x: Empty<number>;\nlet y: Empty<string>;\n\nx = y; // OK, because y matches structure of x\n```\n\nIn the above, `x` and `y` are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to `Empty<T>` shows how this works:\n\n``` ts\ninterface NotEmpty<T> {\n  data: T;\n}\nlet x: NotEmpty<number>;\nlet y: NotEmpty<string>;\n\nx = y; // Error, because x and y are not compatible\n```\n\nIn this way, a generic type that has its type arguments specified acts just like a non-generic type.\n\nFor generic types that do not have their type arguments specified, compatibility is checked by specifying `any` in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.\n\nFor example,\n\n``` ts\nlet identity = function <T>(x: T): T {\n  // ...\n};\n\nlet reverse = function <U>(y: U): U {\n  // ...\n};\n\nidentity = reverse; // OK, because (x: any) => any matches (y: any) => any\n```\n\n## Advanced Topics\n\n### Subtype vs Assignment\n\nSo far, we’ve used “compatible”, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from `any`, and to and from `enum` with corresponding numeric values.\n\nDifferent places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the `implements` and `extends` clauses.\n\n## `any`, `unknown`, `object`, `void`, `undefined`, `null`, and `never` assignability\n\nThe following table summarizes assignability between some abstract types. Rows indicate what each is assignable to, columns indicate what is assignable to them. A ”✓” indicates a combination that is compatible only when [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is off.\n\n|             | any | unknown | object | void | undefined | null | never |\n|-------------|:---:|:-------:|:------:|:----:|:---------:|:----:|:-----:|\n| any →       |     |    ✓    |   ✓    |  ✓   |     ✓     |  ✓   |   ✕   |\n| unknown →   |  ✓  |         |   ✕    |  ✕   |     ✕     |  ✕   |   ✕   |\n| object →    |  ✓  |    ✓    |        |  ✕   |     ✕     |  ✕   |   ✕   |\n| void →      |  ✓  |    ✓    |   ✕    |      |     ✕     |  ✕   |   ✕   |\n| undefined → |  ✓  |    ✓    |   ✓    |  ✓   |           |  ✓   |   ✕   |\n| null →      |  ✓  |    ✓    |   ✓    |  ✓   |     ✓     |      |   ✕   |\n| never →     |  ✓  |    ✓    |   ✓    |  ✓   |     ✓     |  ✓   |       |\n\nReiterating [The Basics](2/basic-types):\n\n- Everything is assignable to itself.\n- `any` and `unknown` are the same in terms of what is assignable to them, different in that `unknown` is not assignable to anything except `any`.\n- `unknown` and `never` are like inverses of each other. Everything is assignable to `unknown`, `never` is assignable to everything. Nothing is assignable to `never`, `unknown` is not assignable to anything (except `any`).\n- `void` is not assignable to or from anything, with the following exceptions: `any`, `unknown`, `never`, `undefined`, and `null` (if [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is off, see table for details).\n- When [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is off, `null` and `undefined` are similar to `never`: assignable to most types, most types are not assignable to them. They are assignable to each other.\n- When [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is on, `null` and `undefined` behave more like `void`: not assignable to or from anything, except for `any`, `unknown`, and `void` (`undefined` is always assignable to `void`).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/type-compatibility.html](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)"
- name: 'Type Compatibility: A Note on Soundness'
  id: type-compatibility#a-note-on-soundness
  summary: TypeScript’s type system allows certain operations that can’t be known at compile-time to be safe
  belongs_to: Type Compatibility
  description: |-
    ## A Note on Soundness

    TypeScript’s type system allows certain operations that can’t be known at compile-time to be safe. When a type system has this property, it is said to not be “sound”. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we’ll explain where these happen and the motivating scenarios behind them.
- name: 'Type Compatibility: Advanced Topics'
  id: type-compatibility#advanced-topics
  summary: So far, we’ve used “compatible”, which is not a term defined in the language spec
  belongs_to: Type Compatibility
  description: |-
    ## Advanced Topics

    ### Subtype vs Assignment

    So far, we’ve used “compatible”, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from `any`, and to and from `enum` with corresponding numeric values.

    Different places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the `implements` and `extends` clauses.
- name: 'Type Compatibility: any, unknown, object, void, undefined, null, and never assignability'
  id: type-compatibility#any-unknown-object-void-undefined-null-and-never-assignability
  summary: The following table summarizes assignability between some abstract types
  belongs_to: Type Compatibility
  description: "## `any`, `unknown`, `object`, `void`, `undefined`, `null`, and `never` assignability\n\nThe following table summarizes assignability between some abstract types. Rows indicate what each is assignable to, columns indicate what is assignable to them. A ”✓” indicates a combination that is compatible only when [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is off.\n\n|             | any | unknown | object | void | undefined | null | never |\n|-------------|:---:|:-------:|:------:|:----:|:---------:|:----:|:-----:|\n| any →       |     |    ✓    |   ✓    |  ✓   |     ✓     |  ✓   |   ✕   |\n| unknown →   |  ✓  |         |   ✕    |  ✕   |     ✕     |  ✕   |   ✕   |\n| object →    |  ✓  |    ✓    |        |  ✕   |     ✕     |  ✕   |   ✕   |\n| void →      |  ✓  |    ✓    |   ✕    |      |     ✕     |  ✕   |   ✕   |\n| undefined → |  ✓  |    ✓    |   ✓    |  ✓   |           |  ✓   |   ✕   |\n| null →      |  ✓  |    ✓    |   ✓    |  ✓   |     ✓     |      |   ✕   |\n| never →     |  ✓  |    ✓    |   ✓    |  ✓   |     ✓     |  ✓   |       |\n\nReiterating [The Basics](2/basic-types):\n\n- Everything is assignable to itself.\n- `any` and `unknown` are the same in terms of what is assignable to them, different in that `unknown` is not assignable to anything except `any`.\n- `unknown` and `never` are like inverses of each other. Everything is assignable to `unknown`, `never` is assignable to everything. Nothing is assignable to `never`, `unknown` is not assignable to anything (except `any`).\n- `void` is not assignable to or from anything, with the following exceptions: `any`, `unknown`, `never`, `undefined`, and `null` (if [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is off, see table for details).\n- When [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is off, `null` and `undefined` are similar to `never`: assignable to most types, most types are not assignable to them. They are assignable to each other.\n- When [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is on, `null` and `undefined` behave more like `void`: not assignable to or from anything, except for `any`, `unknown`, and `void` (`undefined` is always assignable to `void`).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/type-compatibility.html](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)"
- name: 'Type Compatibility: Classes'
  id: type-compatibility#classes
  summary: 'Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type'
  belongs_to: Type Compatibility
  description: |-
    ## Classes

    Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility.

    ``` ts
    class Animal {
      feet: number;
      constructor(name: string, numFeet: number) {}
    }

    class Size {
      feet: number;
      constructor(numFeet: number) {}
    }

    let a: Animal;
    let s: Size;

    a = s; // OK
    s = a; // OK
    ```

    ### Private and protected members in classes

    Private and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but *not* with classes from a different inheritance hierarchy which otherwise have the same shape.
- name: 'Type Compatibility: Comparing two functions'
  id: type-compatibility#comparing-two-functions
  summary: While comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible is a bit more involved
  belongs_to: Type Compatibility
  description: |-
    ## Comparing two functions

    While comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible is a bit more involved. Let’s start with a basic example of two functions that differ only in their parameter lists:

    ``` ts
    let x = (a: number) => 0;
    let y = (b: number, s: string) => 0;

    y = x; // OK
    x = y; // Error
    ```

    To check if `x` is assignable to `y`, we first look at the parameter list. Each parameter in `x` must have a corresponding parameter in `y` with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of `x` has a corresponding compatible parameter in `y`, so the assignment is allowed.

    The second assignment is an error, because `y` has a required second parameter that `x` does not have, so the assignment is disallowed.

    You may be wondering why we allow ‘discarding’ parameters like in the example `y = x`. The reason for this assignment to be allowed is that ignoring extra function parameters is actually quite common in JavaScript. For example, `Array#forEach` provides three parameters to the callback function: the array element, its index, and the containing array. Nevertheless, it’s very useful to provide a callback that only uses the first parameter:

    ``` ts
    let items = [1, 2, 3];

    // Don't force these extra parameters
    items.forEach((item, index, array) => console.log(item));

    // Should be OK!
    items.forEach((item) => console.log(item));
    ```

    Now let’s look at how return types are treated, using two functions that differ only by their return type:

    ``` ts
    let x = () => ({ name: "Alice" });
    let y = () => ({ name: "Alice", location: "Seattle" });

    x = y; // OK
    y = x; // Error, because x() lacks a location property
    ```

    The type system enforces that the source function’s return type be a subtype of the target type’s return type.

    ### Function Parameter Bivariance

    When comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:

    ``` ts
    enum EventType {
      Mouse,
      Keyboard,
    }

    interface Event {
      timestamp: number;
    }
    interface MyMouseEvent extends Event {
      x: number;
      y: number;
    }
    interface MyKeyEvent extends Event {
      keyCode: number;
    }

    function listenEvent(eventType: EventType, handler: (n: Event) => void) {
      /* ... */
    }

    // Unsound, but useful and common
    listenEvent(EventType.Mouse, (e: MyMouseEvent) => console.log(e.x + "," + e.y));

    // Undesirable alternatives in presence of soundness
    listenEvent(EventType.Mouse, (e: Event) =>
      console.log((e as MyMouseEvent).x + "," + (e as MyMouseEvent).y)
    );
    listenEvent(EventType.Mouse, ((e: MyMouseEvent) =>
      console.log(e.x + "," + e.y)) as (e: Event) => void);

    // Still disallowed (clear error). Type safety enforced for wholly incompatible types
    listenEvent(EventType.Mouse, (e: number) => console.log(e));
    ```

    You can have TypeScript raise errors when this happens via the compiler flag [`strictFunctionTypes`](https://www.typescriptlang.org/tsconfig#strictFunctionTypes).

    ### Optional Parameters and Rest Parameters

    When comparing functions for compatibility, optional and required parameters are interchangeable. Extra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the source type are not an error.

    When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters.

    This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing `undefined` in that position is equivalent for most functions.

    The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:

    ``` ts
    function invokeLater(args: any[], callback: (...args: any[]) => void) {
      /* ... Invoke callback with 'args' ... */
    }

    // Unsound - invokeLater "might" provide any number of arguments
    invokeLater([1, 2], (x, y) => console.log(x + ", " + y));

    // Confusing (x and y are actually required) and undiscoverable
    invokeLater([1, 2], (x?, y?) => console.log(x + ", " + y));
    ```

    ### Functions with overloads

    When a function has overloads, each overload in the target type must be matched by a compatible signature on the source type. This ensures that the source function can be called in all the same cases as the target function.
- name: 'Type Compatibility: Enums'
  id: type-compatibility#enums
  summary: Enums are compatible with numbers, and numbers are compatible with enums
  belongs_to: Type Compatibility
  description: |-
    ## Enums

    Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,

    ``` ts
    enum Status {
      Ready,
      Waiting,
    }
    enum Color {
      Red,
      Blue,
      Green,
    }

    let status = Status.Ready;
    status = Color.Green; // Error
    ```
- name: 'Type Compatibility: Generics'
  id: type-compatibility#generics
  summary: Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member
  belongs_to: Type Compatibility
  description: |-
    ## Generics

    Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,

    ``` ts
    interface Empty<T> {}
    let x: Empty<number>;
    let y: Empty<string>;

    x = y; // OK, because y matches structure of x
    ```

    In the above, `x` and `y` are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to `Empty<T>` shows how this works:

    ``` ts
    interface NotEmpty<T> {
      data: T;
    }
    let x: NotEmpty<number>;
    let y: NotEmpty<string>;

    x = y; // Error, because x and y are not compatible
    ```

    In this way, a generic type that has its type arguments specified acts just like a non-generic type.

    For generic types that do not have their type arguments specified, compatibility is checked by specifying `any` in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.

    For example,

    ``` ts
    let identity = function <T>(x: T): T {
      // ...
    };

    let reverse = function <U>(y: U): U {
      // ...
    };

    identity = reverse; // OK, because (x: any) => any matches (y: any) => any
    ```
- name: 'Type Compatibility: Starting out'
  id: type-compatibility#starting-out
  summary: The basic rule for TypeScript’s structural type system is that x is compatible with y if y has at least the same members as x
  belongs_to: Type Compatibility
  description: |-
    ## Starting out

    The basic rule for TypeScript’s structural type system is that `x` is compatible with `y` if `y` has at least the same members as `x`. For example consider the following code involving an interface named `Pet` which has a `name` property:

    ``` ts
    interface Pet {
      name: string;
    }

    let pet: Pet;
    // dog's inferred type is { name: string; owner: string; }
    let dog = { name: "Lassie", owner: "Rudd Weatherwax" };
    pet = dog;
    ```

    To check whether `dog` can be assigned to `pet`, the compiler checks each property of `pet` to find a corresponding compatible property in `dog`. In this case, `dog` must have a member called `name` that is a string. It does, so the assignment is allowed.

    The same rule for assignment is used when checking function call arguments:

    ``` ts
    interface Pet {
      name: string;
    }

    let dog = { name: "Lassie", owner: "Rudd Weatherwax" };

    function greet(pet: Pet) {
      console.log("Hello, " + pet.name);
    }
    greet(dog); // OK
    ```

    Note that `dog` has an extra `owner` property, but this does not create an error. Only members of the target type (`Pet` in this case) are considered when checking for compatibility. This comparison process proceeds recursively, exploring the type of each member and sub-member.

    Be aware, however, that object literals [may only specify known properties](2/objects#excess-property-checks). For example, because we have explicitly specified that `dog` is of type `Pet`, the following code is invalid:

    ``` ts
    let dog: Pet = { name: "Lassie", owner: "Rudd Weatherwax" }; // Error
    ```
- name: Type Inference
  id: type-inference
  summary: In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation
  description: "# Type Inference\n\nIn TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code\n\n``` ts\nlet x = 3;\n```\n\nThe type of the `x` variable is inferred to be `number`. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.\n\nIn most cases, type inference is straightforward. In the following sections, we’ll explore some of the nuances in how types are inferred.\n\n## Best common type\n\nWhen a type inference is made from several expressions, the types of those expressions are used to calculate a “best common type”. For example,\n\n``` ts\nlet x = [0, 1, null];\n```\n\nTo infer the type of `x` in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: `number` and `null`. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.\n\nBecause the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:\n\n``` ts\nlet zoo = [new Rhino(), new Elephant(), new Snake()];\n```\n\nIdeally, we may want `zoo` to be inferred as an `Animal[]`, but because there is no object that is strictly of type `Animal` in the array, we make no inference about the array element type. To correct this, explicitly provide the type when no one type is a super type of all other candidates:\n\n``` ts\nlet zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];\n```\n\nWhen no best common type is found, the resulting inference is the union array type, `(Rhino | Elephant | Snake)[]`.\n\n## Contextual Typing\n\nType inference also works in “the other direction” in some cases in TypeScript. This is known as “contextual typing”. Contextual typing occurs when the type of an expression is implied by its location. For example:\n\n``` ts\nwindow.onmousedown = function (mouseEvent) {\n  console.log(mouseEvent.button);\n  console.log(mouseEvent.kangaroo);\n};\n```\n\nHere, the TypeScript type checker used the type of the `Window.onmousedown` function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the [type](https://developer.mozilla.org/docs/Web/API/MouseEvent) of the `mouseEvent` parameter, which does contain a `button` property, but not a `kangaroo` property.\n\nThis works because window already has `onmousedown` declared in its type:\n\n``` ts\n// Declares there is a global variable called 'window'\ndeclare var window: Window & typeof globalThis;\n\n// Which is declared as (simplified):\ninterface Window extends GlobalEventHandlers {\n  // ...\n}\n\n// Which defines a lot of known handler events\ninterface GlobalEventHandlers {\n  onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n  // ...\n}\n```\n\nTypeScript is smart enough to infer types in other contexts as well:\n\n``` ts\nwindow.onscroll = function (uiEvent) {\n  console.log(uiEvent.button);\n};\n```\n\nBased on the fact that the above function is being assigned to `Window.onscroll`, TypeScript knows that `uiEvent` is a [UIEvent](https://developer.mozilla.org/docs/Web/API/UIEvent), and not a [MouseEvent](https://developer.mozilla.org/docs/Web/API/MouseEvent) like the previous example. `UIEvent` objects contain no `button` property, and so TypeScript will throw an error.\n\nIf this function were not in a contextually typed position, the function’s argument would implicitly have type `any`, and no error would be issued (unless you are using the [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) option):\n\n``` ts\nconst handler = function (uiEvent) {\n  console.log(uiEvent.button); // <- OK\n};\n```\n\nWe can also explicitly give type information to the function’s argument to override any contextual type:\n\n``` ts\nwindow.onscroll = function (uiEvent: any) {\n  console.log(uiEvent.button); // <- Now, no error is given\n};\n```\n\nHowever, this code will log `undefined`, since `uiEvent` has no property called `button`.\n\nContextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:\n\n``` ts\nfunction createZoo(): Animal[] {\n  return [new Rhino(), new Elephant(), new Snake()];\n}\n```\n\nIn this example, best common type has a set of four candidates: `Animal`, `Rhino`, `Elephant`, and `Snake`. Of these, `Animal` can be chosen by the best common type algorithm.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/type-inference.html](https://www.typescriptlang.org/docs/handbook/type-inference.html)"
- name: 'Type Inference: Best common type'
  id: type-inference#best-common-type
  summary: To infer the type of x in the example above, we must consider the type of each array element
  belongs_to: Type Inference
  description: |-
    ## Best common type

    When a type inference is made from several expressions, the types of those expressions are used to calculate a “best common type”. For example,

    ``` ts
    let x = [0, 1, null];
    ```

    To infer the type of `x` in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: `number` and `null`. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.

    Because the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:

    ``` ts
    let zoo = [new Rhino(), new Elephant(), new Snake()];
    ```

    Ideally, we may want `zoo` to be inferred as an `Animal[]`, but because there is no object that is strictly of type `Animal` in the array, we make no inference about the array element type. To correct this, explicitly provide the type when no one type is a super type of all other candidates:

    ``` ts
    let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];
    ```

    When no best common type is found, the resulting inference is the union array type, `(Rhino | Elephant | Snake)[]`.
- name: 'Type Inference: Contextual Typing'
  id: type-inference#contextual-typing
  summary: Type inference also works in “the other direction” in some cases in TypeScript
  belongs_to: Type Inference
  description: "## Contextual Typing\n\nType inference also works in “the other direction” in some cases in TypeScript. This is known as “contextual typing”. Contextual typing occurs when the type of an expression is implied by its location. For example:\n\n``` ts\nwindow.onmousedown = function (mouseEvent) {\n  console.log(mouseEvent.button);\n  console.log(mouseEvent.kangaroo);\n};\n```\n\nHere, the TypeScript type checker used the type of the `Window.onmousedown` function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the [type](https://developer.mozilla.org/docs/Web/API/MouseEvent) of the `mouseEvent` parameter, which does contain a `button` property, but not a `kangaroo` property.\n\nThis works because window already has `onmousedown` declared in its type:\n\n``` ts\n// Declares there is a global variable called 'window'\ndeclare var window: Window & typeof globalThis;\n\n// Which is declared as (simplified):\ninterface Window extends GlobalEventHandlers {\n  // ...\n}\n\n// Which defines a lot of known handler events\ninterface GlobalEventHandlers {\n  onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n  // ...\n}\n```\n\nTypeScript is smart enough to infer types in other contexts as well:\n\n``` ts\nwindow.onscroll = function (uiEvent) {\n  console.log(uiEvent.button);\n};\n```\n\nBased on the fact that the above function is being assigned to `Window.onscroll`, TypeScript knows that `uiEvent` is a [UIEvent](https://developer.mozilla.org/docs/Web/API/UIEvent), and not a [MouseEvent](https://developer.mozilla.org/docs/Web/API/MouseEvent) like the previous example. `UIEvent` objects contain no `button` property, and so TypeScript will throw an error.\n\nIf this function were not in a contextually typed position, the function’s argument would implicitly have type `any`, and no error would be issued (unless you are using the [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny) option):\n\n``` ts\nconst handler = function (uiEvent) {\n  console.log(uiEvent.button); // <- OK\n};\n```\n\nWe can also explicitly give type information to the function’s argument to override any contextual type:\n\n``` ts\nwindow.onscroll = function (uiEvent: any) {\n  console.log(uiEvent.button); // <- Now, no error is given\n};\n```\n\nHowever, this code will log `undefined`, since `uiEvent` has no property called `button`.\n\nContextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:\n\n``` ts\nfunction createZoo(): Animal[] {\n  return [new Rhino(), new Elephant(), new Snake()];\n}\n```\n\nIn this example, best common type has a set of four candidates: `Animal`, `Rhino`, `Elephant`, and `Snake`. Of these, `Animal` can be chosen by the best common type algorithm.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/type-inference.html](https://www.typescriptlang.org/docs/handbook/type-inference.html)"
- name: Typeof Type Operator
  id: 2/typeof-types
  summary: This isn’t very useful for basic types, but combined with other type operators, you can use typeof to conveniently express many patterns
  description: "# Typeof Type Operator\n\n## The `typeof` type operator\n\nJavaScript already has a `typeof` operator you can use in an *expression* context:\n\n``` ts\n// Prints \"string\"\nconsole.log(typeof \"Hello world\");\n```\n\nTypeScript adds a `typeof` operator you can use in a *type* context to refer to the *type* of a variable or property:\n\n``` ts\nlet s = \"hello\";\nlet n: typeof s;\n```\n\nThis isn’t very useful for basic types, but combined with other type operators, you can use `typeof` to conveniently express many patterns. For an example, let’s start by looking at the predefined type `ReturnType<T>`. It takes a *function type* and produces its return type:\n\n``` ts\ntype Predicate = (x: unknown) => boolean;\ntype K = ReturnType<Predicate>;\n```\n\nIf we try to use `ReturnType` on a function name, we see an instructive error:\n\n``` ts\nfunction f() {\n  return { x: 10, y: 3 };\n}\ntype P = ReturnType<f>;\n```\n\nRemember that *values* and *types* aren’t the same thing. To refer to the *type* that the *value `f`* has, we use `typeof`:\n\n``` ts\nfunction f() {\n  return { x: 10, y: 3 };\n}\ntype P = ReturnType<typeof f>;\n```\n\n### Limitations\n\nTypeScript intentionally limits the sorts of expressions you can use `typeof` on.\n\nSpecifically, it’s only legal to use `typeof` on identifiers (i.e. variable names) or their properties. This helps avoid the confusing trap of writing code you think is executing, but isn’t:\n\n``` ts\n// Meant to use = ReturnType<typeof msgbox>\nlet shouldContinue: typeof msgbox(\"Are you sure you want to continue?\");\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/typeof-types.html](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)"
- name: 'Typeof Type Operator: The typeof type operator'
  id: 2/typeof-types#the-typeof-type-operator
  summary: This isn’t very useful for basic types, but combined with other type operators, you can use typeof to conveniently express many patterns
  belongs_to: Typeof Type Operator
  description: "## The `typeof` type operator\n\nJavaScript already has a `typeof` operator you can use in an *expression* context:\n\n``` ts\n// Prints \"string\"\nconsole.log(typeof \"Hello world\");\n```\n\nTypeScript adds a `typeof` operator you can use in a *type* context to refer to the *type* of a variable or property:\n\n``` ts\nlet s = \"hello\";\nlet n: typeof s;\n```\n\nThis isn’t very useful for basic types, but combined with other type operators, you can use `typeof` to conveniently express many patterns. For an example, let’s start by looking at the predefined type `ReturnType<T>`. It takes a *function type* and produces its return type:\n\n``` ts\ntype Predicate = (x: unknown) => boolean;\ntype K = ReturnType<Predicate>;\n```\n\nIf we try to use `ReturnType` on a function name, we see an instructive error:\n\n``` ts\nfunction f() {\n  return { x: 10, y: 3 };\n}\ntype P = ReturnType<f>;\n```\n\nRemember that *values* and *types* aren’t the same thing. To refer to the *type* that the *value `f`* has, we use `typeof`:\n\n``` ts\nfunction f() {\n  return { x: 10, y: 3 };\n}\ntype P = ReturnType<typeof f>;\n```\n\n### Limitations\n\nTypeScript intentionally limits the sorts of expressions you can use `typeof` on.\n\nSpecifically, it’s only legal to use `typeof` on identifiers (i.e. variable names) or their properties. This helps avoid the confusing trap of writing code you think is executing, but isn’t:\n\n``` ts\n// Meant to use = ReturnType<typeof msgbox>\nlet shouldContinue: typeof msgbox(\"Are you sure you want to continue?\");\n```\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/2/typeof-types.html](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)"
- name: typeRoots
  id: tsconfig/index#typeRoots-config
  summary: By default all visible ”@types” packages are included in your compilation
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Type Roots - `typeRoots`

    By default all *visible* ”`@types`” packages are included in your compilation. Packages in `node_modules/@types` of any enclosing folder are considered *visible*. For example, that means packages within `./node_modules/@types/`, `../node_modules/@types/`, `../../node_modules/@types/`, and so on.

    If `typeRoots` is specified, *only* packages under `typeRoots` will be included. For example:

    ``` typescript
    {
      "compilerOptions": {
        "typeRoots": ["./typings", "./vendor/types"]
      }
    }
    ```

    This config file will include *all* packages under `./typings` and `./vendor/types`, and no packages from `./node_modules/@types`. All paths are relative to the `tsconfig.json`.

    - Related:
      - [`types`](#types)
- name: typeRoots
  id: tsconfig#typeRoots-config
  summary: By default all visible ”@types” packages are included in your compilation
  belongs_to: TSConfig Reference
  description: |-
    ### Type Roots - `typeRoots`

    By default all *visible* ”`@types`” packages are included in your compilation. Packages in `node_modules/@types` of any enclosing folder are considered *visible*. For example, that means packages within `./node_modules/@types/`, `../node_modules/@types/`, `../../node_modules/@types/`, and so on.

    If `typeRoots` is specified, *only* packages under `typeRoots` will be included. For example:

    ``` typescript
    {
      "compilerOptions": {
        "typeRoots": ["./typings", "./vendor/types"]
      }
    }
    ```

    This config file will include *all* packages under `./typings` and `./vendor/types`, and no packages from `./node_modules/@types`. All paths are relative to the `tsconfig.json`.

    - Related:
      - [`types`](#types)
- name: types
  id: tsconfig/index#types-config
  summary: By default all visible ”@types” packages are included in your compilation
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Types - `types`

    By default all *visible* ”`@types`” packages are included in your compilation. Packages in `node_modules/@types` of any enclosing folder are considered *visible*. For example, that means packages within `./node_modules/@types/`, `../node_modules/@types/`, `../../node_modules/@types/`, and so on.

    If `types` is specified, only packages listed will be included in the global scope. For instance:

    ``` typescript
    {
      "compilerOptions": {
        "types": ["node", "jest", "express"]
      }
    }
    ```

    This `tsconfig.json` file will *only* include `./node_modules/@types/node`, `./node_modules/@types/jest` and `./node_modules/@types/express`. Other packages under `node_modules/@types/*` will not be included.

    ### What does this affect?

    This option does not affect how `@types/*` are included in your application code, for example if you had the above `compilerOptions` example with code like:

    ``` ts
    import * as moment from "moment";

    moment().format("MMMM Do YYYY, h:mm:ss a");
    ```

    The `moment` import would be fully typed.

    When you have this option set, by not including a module in the `types` array it:

    - Will not add globals to your project (e.g `process` in node, or `expect` in Jest)
    - Will not have exports appear as auto-import recommendations

    This feature differs from [`typeRoots`](#typeRoots) in that it is about specifying only the exact types you want included, whereas [`typeRoots`](#typeRoots) supports saying you want particular folders.

    - Related:
      - [`typeRoots`](#typeRoots)

    ## Emit
- name: types
  id: tsconfig#types-config
  summary: By default all visible ”@types” packages are included in your compilation
  belongs_to: TSConfig Reference
  description: |-
    ### Types - `types`

    By default all *visible* ”`@types`” packages are included in your compilation. Packages in `node_modules/@types` of any enclosing folder are considered *visible*. For example, that means packages within `./node_modules/@types/`, `../node_modules/@types/`, `../../node_modules/@types/`, and so on.

    If `types` is specified, only packages listed will be included in the global scope. For instance:

    ``` typescript
    {
      "compilerOptions": {
        "types": ["node", "jest", "express"]
      }
    }
    ```

    This `tsconfig.json` file will *only* include `./node_modules/@types/node`, `./node_modules/@types/jest` and `./node_modules/@types/express`. Other packages under `node_modules/@types/*` will not be included.

    ### What does this affect?

    This option does not affect how `@types/*` are included in your application code, for example if you had the above `compilerOptions` example with code like:

    ``` ts
    import * as moment from "moment";

    moment().format("MMMM Do YYYY, h:mm:ss a");
    ```

    The `moment` import would be fully typed.

    When you have this option set, by not including a module in the `types` array it:

    - Will not add globals to your project (e.g `process` in node, or `expect` in Jest)
    - Will not have exports appear as auto-import recommendations

    This feature differs from [`typeRoots`](#typeRoots) in that it is about specifying only the exact types you want included, whereas [`typeRoots`](#typeRoots) supports saying you want particular folders.

    - Related:
      - [`typeRoots`](#typeRoots)

    ## Emit
- name: TypeScript Cheat Sheets
  id: cheatsheets/index
  summary: © 2012-2024 Microsoft Licensed under the Apache License, Version 2.0
  description: "# TypeScript Cheat Sheets\n\n- Cheat Sheets\n- [Download Zip](../assets/typescript-cheat-sheets.zip \"Download the zip file\")\n\n## TypeScript Cheat Sheets\n\nDownloadable syntax reference pages for different parts of everyday TypeScript code\n\nLearn more about Classes, Interfaces, Types and Control Flow Analysis\n\n[](../static/typescript%20control%20flow%20analysis-8a549253ad8470850b77c4c5c351d457.png \"Control Flow Analysis Cheat Sheets\")\n\nControl Flow Analysis\n\n[](../static/typescript%20interfaces-34f1ad12132fb463bd1dfe5b85c5b2e6.png \"Interfaces Cheat Sheets\")\n\nInterfaces\n\n[](../static/typescript%20types-ae199d69aeecf7d4a2704a528d0fd3f9.png \"Types Cheat Sheets\")\n\nTypes\n\n[](../static/typescript%20classes-83cc6f8e42ba2002d5e2c04221fa78f9.png \"Classes Cheat Sheets\")\n\nClasses\n\n[](../assets/typescript-cheat-sheets.zip)\n\nDownload PDFs and PNGs\n\nTo read later or print\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/cheatsheets/](https://www.typescriptlang.org/cheatsheets/)"
- name: TypeScript for Functional Programmers
  id: typescript-in-5-minutes-func
  summary: TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web
  description: "# TypeScript for Functional Programmers\n\nTypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is powerful, interesting and messy.\n\nThis introduction is designed for working Haskell or ML programmers who want to learn TypeScript. It describes how the type system of TypeScript differs from Haskell’s type system. It also describes unique features of TypeScript’s type system that arise from its modelling of JavaScript code.\n\nThis introduction does not cover object-oriented programming. In practice, object-oriented programs in TypeScript are similar to those in other popular languages with OO features.\n\n## Prerequisites\n\nIn this introduction, I assume you know the following:\n\n- How to program in JavaScript, the good parts.\n- Type syntax of a C-descended language.\n\nIf you need to learn the good parts of JavaScript, read [JavaScript: The Good Parts](https://shop.oreilly.com/product/9780596517748.do). You may be able to skip the book if you know how to write programs in a call-by-value lexically scoped language with lots of mutability and not much else. [R⁴RS Scheme](https://people.csail.mit.edu/jaffer/r4rs.pdf) is a good example.\n\n[The C++ Programming Language](http://www.stroustrup.com/4th.html) is a good place to learn about C-style type syntax. Unlike C++, TypeScript uses postfix types, like so: `x: string` instead of `string x`.\n\n## Concepts not in Haskell\n\n### Built-in types\n\nJavaScript defines 8 built-in types:\n\n| Type        | Explanation                                 |\n|-------------|---------------------------------------------|\n| `Number`    | a double-precision IEEE 754 floating point. |\n| `String`    | an immutable UTF-16 string.                 |\n| `BigInt`    | integers in the arbitrary precision format. |\n| `Boolean`   | `true` and `false`.                         |\n| `Symbol`    | a unique value usually used as a key.       |\n| `Null`      | equivalent to the unit type.                |\n| `Undefined` | also equivalent to the unit type.           |\n| `Object`    | similar to records.                         |\n\n[See the MDN page for more detail](https://developer.mozilla.org/docs/Web/JavaScript/Data_structures).\n\nTypeScript has corresponding primitive types for the built-in types:\n\n- `number`\n- `string`\n- `bigint`\n- `boolean`\n- `symbol`\n- `null`\n- `undefined`\n- `object`\n\n#### Other important TypeScript types\n\n| Type           | Explanation                                   |\n|----------------|-----------------------------------------------|\n| `unknown`      | the top type.                                 |\n| `never`        | the bottom type.                              |\n| object literal | e.g. `{ property: Type }`                     |\n| `void`         | for functions with no documented return value |\n| `T[]`          | mutable arrays, also written `Array<T>`       |\n| `[T, T]`       | tuples, which are fixed-length but mutable    |\n| `(t: T) => U`  | functions                                     |\n\nNotes:\n\n1.  Function syntax includes parameter names. This is pretty hard to get used to!\n\n    ``` ts\n    let fst: (a: any, b: any) => any = (a, b) => a;\n\n    // or more precisely:\n\n    let fst: <T, U>(a: T, b: U) => T = (a, b) => a;\n    ```\n\n2.  Object literal type syntax closely mirrors object literal value syntax:\n\n    ``` ts\n    let o: { n: number; xs: object[] } = { n: 1, xs: [] };\n    ```\n\n3.  `[T, T]` is a subtype of `T[]`. This is different than Haskell, where tuples are not related to lists.\n\n#### Boxed types\n\nJavaScript has boxed equivalents of primitive types that contain the methods that programmers associate with those types. TypeScript reflects this with, for example, the difference between the primitive type `number` and the boxed type `Number`. The boxed types are rarely needed, since their methods return primitives.\n\n``` ts\n(1).toExponential();\n// equivalent to\nNumber.prototype.toExponential.call(1);\n```\n\nNote that calling a method on a numeric literal requires it to be in parentheses to aid the parser.\n\n### Gradual typing\n\nTypeScript uses the type `any` whenever it can’t tell what the type of an expression should be. Compared to `Dynamic`, calling `any` a type is an overstatement. It just turns off the type checker wherever it appears. For example, you can push any value into an `any[]` without marking the value in any way:\n\n``` ts\n// with \"noImplicitAny\": false in tsconfig.json, anys: any[]\nconst anys = [];\nanys.push(1);\nanys.push(\"oh no\");\nanys.push({ anything: \"goes\" });\n```\n\nAnd you can use an expression of type `any` anywhere:\n\n``` ts\nanys.map(anys[1]); // oh no, \"oh no\" is not a function\n```\n\n`any` is contagious, too — if you initialize a variable with an expression of type `any`, the variable has type `any` too.\n\n``` ts\nlet sepsis = anys[0] + anys[1]; // this could mean anything\n```\n\nTo get an error when TypeScript produces an `any`, use `\"noImplicitAny\": true`, or `\"strict\": true` in `tsconfig.json`.\n\n### Structural typing\n\nStructural typing is a familiar concept to most functional programmers, although Haskell and most MLs are not structurally typed. Its basic form is pretty simple:\n\n``` ts\n// @strict: false\nlet o = { x: \"hi\", extra: 1 }; // ok\nlet o2: { x: string } = o; // ok\n```\n\nHere, the object literal `{ x: \"hi\", extra: 1 }` has a matching literal type `{ x: string, extra: number }`. That type is assignable to `{ x: string }` since it has all the required properties and those properties have assignable types. The extra property doesn’t prevent assignment, it just makes it a subtype of `{ x: string }`.\n\nNamed types just give a name to a type; for assignability purposes there’s no difference between the type alias `One` and the interface type `Two` below. They both have a property `p: string`. (Type aliases behave differently from interfaces with respect to recursive definitions and type parameters, however.)\n\n``` ts\ntype One = { p: string };\ninterface Two {\n  p: string;\n}\nclass Three {\n  p = \"Hello\";\n}\n \nlet x: One = { p: \"hi\" };\nlet two: Two = x;\ntwo = new Three();\n```\n\n### Unions\n\nIn TypeScript, union types are untagged. In other words, they are not discriminated unions like `data` in Haskell. However, you can often discriminate types in a union using built-in tags or other properties.\n\n``` ts\nfunction start(\n  arg: string | string[] | (() => string) | { s: string }\n): string {\n  // this is super common in JavaScript\n  if (typeof arg === \"string\") {\n    return commonCase(arg);\n  } else if (Array.isArray(arg)) {\n    return arg.map(commonCase).join(\",\");\n  } else if (typeof arg === \"function\") {\n    return commonCase(arg());\n  } else {\n    return commonCase(arg.s);\n  }\n \n  function commonCase(s: string): string {\n    // finally, just convert a string to another string\n    return s;\n  }\n}\n```\n\n`string`, `Array` and `Function` have built-in type predicates, conveniently leaving the object type for the `else` branch. It is possible, however, to generate unions that are difficult to differentiate at runtime. For new code, it’s best to build only discriminated unions.\n\nThe following types have built-in predicates:\n\n| Type      | Predicate                          |\n|-----------|------------------------------------|\n| string    | `typeof s === \"string\"`            |\n| number    | `typeof n === \"number\"`            |\n| bigint    | `typeof m === \"bigint\"`            |\n| boolean   | `typeof b === \"boolean\"`           |\n| symbol    | `typeof g === \"symbol\"`            |\n| undefined | `typeof undefined === \"undefined\"` |\n| function  | `typeof f === \"function\"`          |\n| array     | `Array.isArray(a)`                 |\n| object    | `typeof o === \"object\"`            |\n\nNote that functions and arrays are objects at runtime, but have their own predicates.\n\n#### Intersections\n\nIn addition to unions, TypeScript also has intersections:\n\n``` ts\ntype Combined = { a: number } & { b: string };\ntype Conflicting = { a: number } & { a: string };\n```\n\n`Combined` has two properties, `a` and `b`, just as if they had been written as one object literal type. Intersection and union are recursive in case of conflicts, so `Conflicting.a: number & string`.\n\n### Unit types\n\nUnit types are subtypes of primitive types that contain exactly one primitive value. For example, the string `\"foo\"` has the type `\"foo\"`. Since JavaScript has no built-in enums, it is common to use a set of well-known strings instead. Unions of string literal types allow TypeScript to type this pattern:\n\n``` ts\ndeclare function pad(s: string, n: number, direction: \"left\" | \"right\"): string;\npad(\"hi\", 10, \"left\");\n```\n\nWhen needed, the compiler *widens* — converts to a supertype — the unit type to the primitive type, such as `\"foo\"` to `string`. This happens when using mutability, which can hamper some uses of mutable variables:\n\n``` ts\nlet s = \"right\";\npad(\"hi\", 10, s); // error: 'string' is not assignable to '\"left\" | \"right\"'\n```\n\nHere’s how the error happens:\n\n- `\"right\": \"right\"`\n- `s: string` because `\"right\"` widens to `string` on assignment to a mutable variable.\n- `string` is not assignable to `\"left\" | \"right\"`\n\nYou can work around this with a type annotation for `s`, but that in turn prevents assignments to `s` of variables that are not of type `\"left\" | \"right\"`.\n\n``` ts\nlet s: \"left\" | \"right\" = \"right\";\npad(\"hi\", 10, s);\n```\n\n## Concepts similar to Haskell\n\n### Contextual typing\n\nTypeScript has some obvious places where it can infer types, like variable declarations:\n\n``` ts\nlet s = \"I'm a string!\";\n```\n\nBut it also infers types in a few other places that you may not expect if you’ve worked with other C-syntax languages:\n\n``` ts\ndeclare function map<T, U>(f: (t: T) => U, ts: T[]): U[];\nlet sns = map((n) => n.toString(), [1, 2, 3]);\n```\n\nHere, `n: number` in this example also, despite the fact that `T` and `U` have not been inferred before the call. In fact, after `[1,2,3]` has been used to infer `T=number`, the return type of `n => n.toString()` is used to infer `U=string`, causing `sns` to have the type `string[]`.\n\nNote that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare `map` with the array first:\n\n``` ts\ndeclare function map<T, U>(ts: T[], f: (t: T) => U): U[];\n```\n\nContextual typing also works recursively through object literals, and on unit types that would otherwise be inferred as `string` or `number`. And it can infer return types from context:\n\n``` ts\ndeclare function run<T>(thunk: (t: T) => void): T;\nlet i: { inference: string } = run((o) => {\n  o.inference = \"INSERT STATE HERE\";\n});\n```\n\nThe type of `o` is determined to be `{ inference: string }` because\n\n1.  Declaration initializers are contextually typed by the declaration’s type: `{ inference: string }`.\n2.  The return type of a call uses the contextual type for inferences, so the compiler infers that `T={ inference: string }`.\n3.  Arrow functions use the contextual type to type their parameters, so the compiler gives `o: { inference: string }`.\n\nAnd it does so while you are typing, so that after typing `o.`, you get completions for the property `inference`, along with any other properties you’d have in a real program. Altogether, this feature can make TypeScript’s inference look a bit like a unifying type inference engine, but it is not.\n\n### Type aliases\n\nType aliases are mere aliases, just like `type` in Haskell. The compiler will attempt to use the alias name wherever it was used in the source code, but does not always succeed.\n\n``` ts\ntype Size = [number, number];\nlet x: Size = [101.1, 999.9];\n```\n\nThe closest equivalent to `newtype` is a *tagged intersection*:\n\n``` ts\ntype FString = string & { __compileTimeOnly: any };\n```\n\nAn `FString` is just like a normal string, except that the compiler thinks it has a property named `__compileTimeOnly` that doesn’t actually exist. This means that `FString` can still be assigned to `string`, but not the other way round.\n\n### Discriminated Unions\n\nThe closest equivalent to `data` is a union of types with discriminant properties, normally called discriminated unions in TypeScript:\n\n``` ts\ntype Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; x: number }\n  | { kind: \"triangle\"; x: number; y: number };\n```\n\nUnlike Haskell, the tag, or discriminant, is just a property in each object type. Each variant has an identical property with a different unit type. This is still a normal union type; the leading `|` is an optional part of the union type syntax. You can discriminate the members of the union using normal JavaScript code:\n\n``` ts\ntype Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; x: number }\n  | { kind: \"triangle\"; x: number; y: number };\n \nfunction area(s: Shape) {\n  if (s.kind === \"circle\") {\n    return Math.PI * s.radius * s.radius;\n  } else if (s.kind === \"square\") {\n    return s.x * s.x;\n  } else {\n    return (s.x * s.y) / 2;\n  }\n}\n```\n\nNote that the return type of `area` is inferred to be `number` because TypeScript knows the function is total. If some variant is not covered, the return type of `area` will be `number | undefined` instead.\n\nAlso, unlike Haskell, common properties show up in any union, so you can usefully discriminate multiple members of the union:\n\n``` ts\nfunction height(s: Shape) {\n  if (s.kind === \"circle\") {\n    return 2 * s.radius;\n  } else {\n    // s.kind: \"square\" | \"triangle\"\n    return s.x;\n  }\n}\n```\n\n### Type Parameters\n\nLike most C-descended languages, TypeScript requires declaration of type parameters:\n\n``` ts\nfunction liftArray<T>(t: T): Array<T> {\n  return [t];\n}\n```\n\nThere is no case requirement, but type parameters are conventionally single uppercase letters. Type parameters can also be constrained to a type, which behaves a bit like type class constraints:\n\n``` ts\nfunction firstish<T extends { length: number }>(t1: T, t2: T): T {\n  return t1.length > t2.length ? t1 : t2;\n}\n```\n\nTypeScript can usually infer type arguments from a call based on the type of the arguments, so type arguments are usually not needed.\n\nBecause TypeScript is structural, it doesn’t need type parameters as much as nominal systems. Specifically, they are not needed to make a function polymorphic. Type parameters should only be used to *propagate* type information, such as constraining parameters to be the same type:\n\n``` ts\nfunction length<T extends ArrayLike<unknown>>(t: T): number {}\n\nfunction length(t: ArrayLike<unknown>): number {}\n```\n\nIn the first `length`, T is not necessary; notice that it’s only referenced once, so it’s not being used to constrain the type of the return value or other parameters.\n\n#### Higher-kinded types\n\nTypeScript does not have higher kinded types, so the following is not legal:\n\n``` ts\nfunction length<T extends ArrayLike<unknown>, U>(m: T<U>) {}\n```\n\n#### Point-free programming\n\nPoint-free programming — heavy use of currying and function composition — is possible in JavaScript, but can be verbose. In TypeScript, type inference often fails for point-free programs, so you’ll end up specifying type parameters instead of value parameters. The result is so verbose that it’s usually better to avoid point-free programming.\n\n### Module system\n\nJavaScript’s modern module syntax is a bit like Haskell’s, except that any file with `import` or `export` is implicitly a module:\n\n``` ts\nimport { value, Type } from \"npm-package\";\nimport { other, Types } from \"./local-package\";\nimport * as prefix from \"../lib/third-package\";\n```\n\nYou can also import commonjs modules — modules written using node.js’ module system:\n\n``` ts\nimport f = require(\"single-function-package\");\n```\n\nYou can export with an export list:\n\n``` ts\nexport { f };\n\nfunction f() {\n  return g();\n}\nfunction g() {} // g is not exported\n```\n\nOr by marking each export individually:\n\n``` ts\nexport function f() { return g() }\nfunction g() { }\n```\n\nThe latter style is more common but both are allowed, even in the same file.\n\n### `readonly` and `const`\n\nIn JavaScript, mutability is the default, although it allows variable declarations with `const` to declare that the *reference* is immutable. The referent is still mutable:\n\n``` js\nconst a = [1, 2, 3];\na.push(102); // ):\na[0] = 101; // D:\n```\n\nTypeScript additionally has a `readonly` modifier for properties.\n\n``` ts\ninterface Rx {\n  readonly x: number;\n}\nlet rx: Rx = { x: 1 };\nrx.x = 12; // error\n```\n\nIt also ships with a mapped type `Readonly<T>` that makes all properties `readonly`:\n\n``` ts\ninterface X {\n  x: number;\n}\nlet rx: Readonly<X> = { x: 1 };\nrx.x = 12; // error\n```\n\nAnd it has a specific `ReadonlyArray<T>` type that removes side-affecting methods and prevents writing to indices of the array, as well as special syntax for this type:\n\n``` ts\nlet a: ReadonlyArray<number> = [1, 2, 3];\nlet b: readonly number[] = [1, 2, 3];\na.push(102); // error\nb[0] = 101; // error\n```\n\nYou can also use a const-assertion, which operates on arrays and object literals:\n\n``` ts\nlet a = [1, 2, 3] as const;\na.push(102); // error\na[0] = 101; // error\n```\n\nHowever, none of these options are the default, so they are not consistently used in TypeScript code.\n\n### Next Steps\n\nThis doc is a high level overview of the syntax and types you would use in everyday code. From here you should:\n\n- Read the full Handbook [from start to finish](intro)\n- Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html)"
- name: 'TypeScript for Functional Programmers: Concepts not in Haskell'
  id: typescript-in-5-minutes-func#concepts-not-in-haskell
  summary: See the MDN page for more detail
  belongs_to: TypeScript for Functional Programmers
  description: |-
    ## Concepts not in Haskell

    ### Built-in types

    JavaScript defines 8 built-in types:

    | Type        | Explanation                                 |
    |-------------|---------------------------------------------|
    | `Number`    | a double-precision IEEE 754 floating point. |
    | `String`    | an immutable UTF-16 string.                 |
    | `BigInt`    | integers in the arbitrary precision format. |
    | `Boolean`   | `true` and `false`.                         |
    | `Symbol`    | a unique value usually used as a key.       |
    | `Null`      | equivalent to the unit type.                |
    | `Undefined` | also equivalent to the unit type.           |
    | `Object`    | similar to records.                         |

    [See the MDN page for more detail](https://developer.mozilla.org/docs/Web/JavaScript/Data_structures).

    TypeScript has corresponding primitive types for the built-in types:

    - `number`
    - `string`
    - `bigint`
    - `boolean`
    - `symbol`
    - `null`
    - `undefined`
    - `object`

    #### Other important TypeScript types

    | Type           | Explanation                                   |
    |----------------|-----------------------------------------------|
    | `unknown`      | the top type.                                 |
    | `never`        | the bottom type.                              |
    | object literal | e.g. `{ property: Type }`                     |
    | `void`         | for functions with no documented return value |
    | `T[]`          | mutable arrays, also written `Array<T>`       |
    | `[T, T]`       | tuples, which are fixed-length but mutable    |
    | `(t: T) => U`  | functions                                     |

    Notes:

    1.  Function syntax includes parameter names. This is pretty hard to get used to!

        ``` ts
        let fst: (a: any, b: any) => any = (a, b) => a;

        // or more precisely:

        let fst: <T, U>(a: T, b: U) => T = (a, b) => a;
        ```

    2.  Object literal type syntax closely mirrors object literal value syntax:

        ``` ts
        let o: { n: number; xs: object[] } = { n: 1, xs: [] };
        ```

    3.  `[T, T]` is a subtype of `T[]`. This is different than Haskell, where tuples are not related to lists.

    #### Boxed types

    JavaScript has boxed equivalents of primitive types that contain the methods that programmers associate with those types. TypeScript reflects this with, for example, the difference between the primitive type `number` and the boxed type `Number`. The boxed types are rarely needed, since their methods return primitives.

    ``` ts
    (1).toExponential();
    // equivalent to
    Number.prototype.toExponential.call(1);
    ```

    Note that calling a method on a numeric literal requires it to be in parentheses to aid the parser.

    ### Gradual typing

    TypeScript uses the type `any` whenever it can’t tell what the type of an expression should be. Compared to `Dynamic`, calling `any` a type is an overstatement. It just turns off the type checker wherever it appears. For example, you can push any value into an `any[]` without marking the value in any way:

    ``` ts
    // with "noImplicitAny": false in tsconfig.json, anys: any[]
    const anys = [];
    anys.push(1);
    anys.push("oh no");
    anys.push({ anything: "goes" });
    ```

    And you can use an expression of type `any` anywhere:

    ``` ts
    anys.map(anys[1]); // oh no, "oh no" is not a function
    ```

    `any` is contagious, too — if you initialize a variable with an expression of type `any`, the variable has type `any` too.

    ``` ts
    let sepsis = anys[0] + anys[1]; // this could mean anything
    ```

    To get an error when TypeScript produces an `any`, use `"noImplicitAny": true`, or `"strict": true` in `tsconfig.json`.

    ### Structural typing

    Structural typing is a familiar concept to most functional programmers, although Haskell and most MLs are not structurally typed. Its basic form is pretty simple:

    ``` ts
    // @strict: false
    let o = { x: "hi", extra: 1 }; // ok
    let o2: { x: string } = o; // ok
    ```

    Here, the object literal `{ x: "hi", extra: 1 }` has a matching literal type `{ x: string, extra: number }`. That type is assignable to `{ x: string }` since it has all the required properties and those properties have assignable types. The extra property doesn’t prevent assignment, it just makes it a subtype of `{ x: string }`.

    Named types just give a name to a type; for assignability purposes there’s no difference between the type alias `One` and the interface type `Two` below. They both have a property `p: string`. (Type aliases behave differently from interfaces with respect to recursive definitions and type parameters, however.)

    ``` ts
    type One = { p: string };
    interface Two {
      p: string;
    }
    class Three {
      p = "Hello";
    }
     
    let x: One = { p: "hi" };
    let two: Two = x;
    two = new Three();
    ```

    ### Unions

    In TypeScript, union types are untagged. In other words, they are not discriminated unions like `data` in Haskell. However, you can often discriminate types in a union using built-in tags or other properties.

    ``` ts
    function start(
      arg: string | string[] | (() => string) | { s: string }
    ): string {
      // this is super common in JavaScript
      if (typeof arg === "string") {
        return commonCase(arg);
      } else if (Array.isArray(arg)) {
        return arg.map(commonCase).join(",");
      } else if (typeof arg === "function") {
        return commonCase(arg());
      } else {
        return commonCase(arg.s);
      }
     
      function commonCase(s: string): string {
        // finally, just convert a string to another string
        return s;
      }
    }
    ```

    `string`, `Array` and `Function` have built-in type predicates, conveniently leaving the object type for the `else` branch. It is possible, however, to generate unions that are difficult to differentiate at runtime. For new code, it’s best to build only discriminated unions.

    The following types have built-in predicates:

    | Type      | Predicate                          |
    |-----------|------------------------------------|
    | string    | `typeof s === "string"`            |
    | number    | `typeof n === "number"`            |
    | bigint    | `typeof m === "bigint"`            |
    | boolean   | `typeof b === "boolean"`           |
    | symbol    | `typeof g === "symbol"`            |
    | undefined | `typeof undefined === "undefined"` |
    | function  | `typeof f === "function"`          |
    | array     | `Array.isArray(a)`                 |
    | object    | `typeof o === "object"`            |

    Note that functions and arrays are objects at runtime, but have their own predicates.

    #### Intersections

    In addition to unions, TypeScript also has intersections:

    ``` ts
    type Combined = { a: number } & { b: string };
    type Conflicting = { a: number } & { a: string };
    ```

    `Combined` has two properties, `a` and `b`, just as if they had been written as one object literal type. Intersection and union are recursive in case of conflicts, so `Conflicting.a: number & string`.

    ### Unit types

    Unit types are subtypes of primitive types that contain exactly one primitive value. For example, the string `"foo"` has the type `"foo"`. Since JavaScript has no built-in enums, it is common to use a set of well-known strings instead. Unions of string literal types allow TypeScript to type this pattern:

    ``` ts
    declare function pad(s: string, n: number, direction: "left" | "right"): string;
    pad("hi", 10, "left");
    ```

    When needed, the compiler *widens* — converts to a supertype — the unit type to the primitive type, such as `"foo"` to `string`. This happens when using mutability, which can hamper some uses of mutable variables:

    ``` ts
    let s = "right";
    pad("hi", 10, s); // error: 'string' is not assignable to '"left" | "right"'
    ```

    Here’s how the error happens:

    - `"right": "right"`
    - `s: string` because `"right"` widens to `string` on assignment to a mutable variable.
    - `string` is not assignable to `"left" | "right"`

    You can work around this with a type annotation for `s`, but that in turn prevents assignments to `s` of variables that are not of type `"left" | "right"`.

    ``` ts
    let s: "left" | "right" = "right";
    pad("hi", 10, s);
    ```
- name: 'TypeScript for Functional Programmers: Concepts similar to Haskell'
  id: typescript-in-5-minutes-func#concepts-similar-to-haskell
  summary: 'Here, n: number in this example also, despite the fact that T and U have not been inferred before the call'
  belongs_to: TypeScript for Functional Programmers
  description: |-
    ## Concepts similar to Haskell

    ### Contextual typing

    TypeScript has some obvious places where it can infer types, like variable declarations:

    ``` ts
    let s = "I'm a string!";
    ```

    But it also infers types in a few other places that you may not expect if you’ve worked with other C-syntax languages:

    ``` ts
    declare function map<T, U>(f: (t: T) => U, ts: T[]): U[];
    let sns = map((n) => n.toString(), [1, 2, 3]);
    ```

    Here, `n: number` in this example also, despite the fact that `T` and `U` have not been inferred before the call. In fact, after `[1,2,3]` has been used to infer `T=number`, the return type of `n => n.toString()` is used to infer `U=string`, causing `sns` to have the type `string[]`.

    Note that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare `map` with the array first:

    ``` ts
    declare function map<T, U>(ts: T[], f: (t: T) => U): U[];
    ```

    Contextual typing also works recursively through object literals, and on unit types that would otherwise be inferred as `string` or `number`. And it can infer return types from context:

    ``` ts
    declare function run<T>(thunk: (t: T) => void): T;
    let i: { inference: string } = run((o) => {
      o.inference = "INSERT STATE HERE";
    });
    ```

    The type of `o` is determined to be `{ inference: string }` because

    1.  Declaration initializers are contextually typed by the declaration’s type: `{ inference: string }`.
    2.  The return type of a call uses the contextual type for inferences, so the compiler infers that `T={ inference: string }`.
    3.  Arrow functions use the contextual type to type their parameters, so the compiler gives `o: { inference: string }`.

    And it does so while you are typing, so that after typing `o.`, you get completions for the property `inference`, along with any other properties you’d have in a real program. Altogether, this feature can make TypeScript’s inference look a bit like a unifying type inference engine, but it is not.

    ### Type aliases

    Type aliases are mere aliases, just like `type` in Haskell. The compiler will attempt to use the alias name wherever it was used in the source code, but does not always succeed.

    ``` ts
    type Size = [number, number];
    let x: Size = [101.1, 999.9];
    ```

    The closest equivalent to `newtype` is a *tagged intersection*:

    ``` ts
    type FString = string & { __compileTimeOnly: any };
    ```

    An `FString` is just like a normal string, except that the compiler thinks it has a property named `__compileTimeOnly` that doesn’t actually exist. This means that `FString` can still be assigned to `string`, but not the other way round.

    ### Discriminated Unions

    The closest equivalent to `data` is a union of types with discriminant properties, normally called discriminated unions in TypeScript:

    ``` ts
    type Shape =
      | { kind: "circle"; radius: number }
      | { kind: "square"; x: number }
      | { kind: "triangle"; x: number; y: number };
    ```

    Unlike Haskell, the tag, or discriminant, is just a property in each object type. Each variant has an identical property with a different unit type. This is still a normal union type; the leading `|` is an optional part of the union type syntax. You can discriminate the members of the union using normal JavaScript code:

    ``` ts
    type Shape =
      | { kind: "circle"; radius: number }
      | { kind: "square"; x: number }
      | { kind: "triangle"; x: number; y: number };
     
    function area(s: Shape) {
      if (s.kind === "circle") {
        return Math.PI * s.radius * s.radius;
      } else if (s.kind === "square") {
        return s.x * s.x;
      } else {
        return (s.x * s.y) / 2;
      }
    }
    ```

    Note that the return type of `area` is inferred to be `number` because TypeScript knows the function is total. If some variant is not covered, the return type of `area` will be `number | undefined` instead.

    Also, unlike Haskell, common properties show up in any union, so you can usefully discriminate multiple members of the union:

    ``` ts
    function height(s: Shape) {
      if (s.kind === "circle") {
        return 2 * s.radius;
      } else {
        // s.kind: "square" | "triangle"
        return s.x;
      }
    }
    ```

    ### Type Parameters

    Like most C-descended languages, TypeScript requires declaration of type parameters:

    ``` ts
    function liftArray<T>(t: T): Array<T> {
      return [t];
    }
    ```

    There is no case requirement, but type parameters are conventionally single uppercase letters. Type parameters can also be constrained to a type, which behaves a bit like type class constraints:

    ``` ts
    function firstish<T extends { length: number }>(t1: T, t2: T): T {
      return t1.length > t2.length ? t1 : t2;
    }
    ```

    TypeScript can usually infer type arguments from a call based on the type of the arguments, so type arguments are usually not needed.

    Because TypeScript is structural, it doesn’t need type parameters as much as nominal systems. Specifically, they are not needed to make a function polymorphic. Type parameters should only be used to *propagate* type information, such as constraining parameters to be the same type:

    ``` ts
    function length<T extends ArrayLike<unknown>>(t: T): number {}

    function length(t: ArrayLike<unknown>): number {}
    ```

    In the first `length`, T is not necessary; notice that it’s only referenced once, so it’s not being used to constrain the type of the return value or other parameters.

    #### Higher-kinded types

    TypeScript does not have higher kinded types, so the following is not legal:

    ``` ts
    function length<T extends ArrayLike<unknown>, U>(m: T<U>) {}
    ```

    #### Point-free programming

    Point-free programming — heavy use of currying and function composition — is possible in JavaScript, but can be verbose. In TypeScript, type inference often fails for point-free programs, so you’ll end up specifying type parameters instead of value parameters. The result is so verbose that it’s usually better to avoid point-free programming.

    ### Module system

    JavaScript’s modern module syntax is a bit like Haskell’s, except that any file with `import` or `export` is implicitly a module:

    ``` ts
    import { value, Type } from "npm-package";
    import { other, Types } from "./local-package";
    import * as prefix from "../lib/third-package";
    ```

    You can also import commonjs modules — modules written using node.js’ module system:

    ``` ts
    import f = require("single-function-package");
    ```

    You can export with an export list:

    ``` ts
    export { f };

    function f() {
      return g();
    }
    function g() {} // g is not exported
    ```

    Or by marking each export individually:

    ``` ts
    export function f() { return g() }
    function g() { }
    ```

    The latter style is more common but both are allowed, even in the same file.
- name: 'TypeScript for Functional Programmers: Prerequisites'
  id: typescript-in-5-minutes-func#prerequisites
  summary: 'If you need to learn the good parts of JavaScript, read JavaScript: The Good Parts'
  belongs_to: TypeScript for Functional Programmers
  description: |-
    ## Prerequisites

    In this introduction, I assume you know the following:

    - How to program in JavaScript, the good parts.
    - Type syntax of a C-descended language.

    If you need to learn the good parts of JavaScript, read [JavaScript: The Good Parts](https://shop.oreilly.com/product/9780596517748.do). You may be able to skip the book if you know how to write programs in a call-by-value lexically scoped language with lots of mutability and not much else. [R⁴RS Scheme](https://people.csail.mit.edu/jaffer/r4rs.pdf) is a good example.

    [The C++ Programming Language](http://www.stroustrup.com/4th.html) is a good place to learn about C-style type syntax. Unlike C++, TypeScript uses postfix types, like so: `x: string` instead of `string x`.
- name: 'TypeScript for Functional Programmers: readonly and const'
  id: typescript-in-5-minutes-func#readonly-and-const
  summary: In JavaScript, mutability is the default, although it allows variable declarations with const to declare that the reference is immutable
  belongs_to: TypeScript for Functional Programmers
  description: "### `readonly` and `const`\n\nIn JavaScript, mutability is the default, although it allows variable declarations with `const` to declare that the *reference* is immutable. The referent is still mutable:\n\n``` js\nconst a = [1, 2, 3];\na.push(102); // ):\na[0] = 101; // D:\n```\n\nTypeScript additionally has a `readonly` modifier for properties.\n\n``` ts\ninterface Rx {\n  readonly x: number;\n}\nlet rx: Rx = { x: 1 };\nrx.x = 12; // error\n```\n\nIt also ships with a mapped type `Readonly<T>` that makes all properties `readonly`:\n\n``` ts\ninterface X {\n  x: number;\n}\nlet rx: Readonly<X> = { x: 1 };\nrx.x = 12; // error\n```\n\nAnd it has a specific `ReadonlyArray<T>` type that removes side-affecting methods and prevents writing to indices of the array, as well as special syntax for this type:\n\n``` ts\nlet a: ReadonlyArray<number> = [1, 2, 3];\nlet b: readonly number[] = [1, 2, 3];\na.push(102); // error\nb[0] = 101; // error\n```\n\nYou can also use a const-assertion, which operates on arrays and object literals:\n\n``` ts\nlet a = [1, 2, 3] as const;\na.push(102); // error\na[0] = 101; // error\n```\n\nHowever, none of these options are the default, so they are not consistently used in TypeScript code.\n\n### Next Steps\n\nThis doc is a high level overview of the syntax and types you would use in everyday code. From here you should:\n\n- Read the full Handbook [from start to finish](intro)\n- Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html)"
- name: TypeScript for Java/C# Programmers
  id: typescript-in-5-minutes-oop
  summary: TypeScript is a popular choice for programmers accustomed to other languages with static typing, such as C# and Java
  description: "# TypeScript for Java/C# Programmers\n\nTypeScript is a popular choice for programmers accustomed to other languages with static typing, such as C# and Java.\n\nTypeScript’s type system offers many of the same benefits, such as better code completion, earlier detection of errors, and clearer communication between parts of your program. While TypeScript provides many familiar features for these developers, it’s worth stepping back to see how JavaScript (and therefore TypeScript) differ from traditional OOP languages. Understanding these differences will help you write better JavaScript code, and avoid common pitfalls that programmers who go straight from C#/Java to TypeScript may fall into.\n\n## Co-learning JavaScript\n\nIf you’re familiar with JavaScript already but are primarily a Java or C# programmer, this introductory page can help explain some of the common misconceptions and pitfalls you might be susceptible to. Some of the ways that TypeScript models types are quite different from Java or C#, and it’s important to keep these in mind when learning TypeScript.\n\nIf you’re a Java or C# programmer that is new to JavaScript in general, we recommend learning a little bit of JavaScript *without* types first to understand JavaScript’s runtime behaviors. Because TypeScript doesn’t change how your code *runs*, you’ll still have to learn how JavaScript works in order to write code that actually does something!\n\nIt’s important to remember that TypeScript uses the same *runtime* as JavaScript, so any resources about how to accomplish specific runtime behavior (converting a string to a number, displaying an alert, writing a file to disk, etc.) will always apply equally well to TypeScript programs. Don’t limit yourself to TypeScript-specific resources!\n\n## Rethinking the Class\n\nC# and Java are what we might call *mandatory OOP* languages. In these languages, the *class* is the basic unit of code organization, and also the basic container of all data *and* behavior at runtime. Forcing all functionality and data to be held in classes can be a good domain model for some problems, but not every domain *needs* to be represented this way.\n\n### Free Functions and Data\n\nIn JavaScript, functions can live anywhere, and data can be passed around freely without being inside a pre-defined `class` or `struct`. This flexibility is extremely powerful. “Free” functions (those not associated with a class) working over data without an implied OOP hierarchy tend to be the preferred model for writing programs in JavaScript.\n\n### Static Classes\n\nAdditionally, certain constructs from C# and Java such as singletons and static classes are unnecessary in TypeScript.\n\n## OOP in TypeScript\n\nThat said, you can still use classes if you like! Some problems are well-suited to being solved by a traditional OOP hierarchy, and TypeScript’s support for JavaScript classes will make these models even more powerful. TypeScript supports many common patterns such as implementing interfaces, inheritance, and static methods.\n\nWe’ll cover classes later in this guide.\n\n## Rethinking Types\n\nTypeScript’s understanding of a *type* is actually quite different from C# or Java’s. Let’s explore some differences.\n\n### Nominal Reified Type Systems\n\nIn C# or Java, any given value or object has one exact type - either `null`, a primitive, or a known class type. We can call methods like `value.GetType()` or `value.getClass()` to query the exact type at runtime. The definition of this type will reside in a class somewhere with some name, and we can’t use two classes with similar shapes in lieu of each other unless there’s an explicit inheritance relationship or commonly-implemented interface.\n\nThese aspects describe a *reified, nominal* type system. The types we wrote in the code are present at runtime, and the types are related via their declarations, not their structures.\n\n### Types as Sets\n\nIn C# or Java, it’s meaningful to think of a one-to-one correspondence between runtime types and their compile-time declarations.\n\nIn TypeScript, it’s better to think of a type as a *set of values* that share something in common. Because types are just sets, a particular value can belong to *many* sets at the same time.\n\nOnce you start thinking of types as sets, certain operations become very natural. For example, in C#, it’s awkward to pass around a value that is *either* a `string` or `int`, because there isn’t a single type that represents this sort of value.\n\nIn TypeScript, this becomes very natural once you realize that every type is just a set. How do you describe a value that either belongs in the `string` set or the `number` set? It simply belongs to the *union* of those sets: `string | number`.\n\nTypeScript provides a number of mechanisms to work with types in a set-theoretic way, and you’ll find them more intuitive if you think of types as sets.\n\n### Erased Structural Types\n\nIn TypeScript, objects are *not* of a single exact type. For example, if we construct an object that satisfies an interface, we can use that object where that interface is expected even though there was no declarative relationship between the two.\n\n``` ts\ninterface Pointlike {\n  x: number;\n  y: number;\n}\ninterface Named {\n  name: string;\n}\n \nfunction logPoint(point: Pointlike) {\n  console.log(\"x = \" + point.x + \", y = \" + point.y);\n}\n \nfunction logName(x: Named) {\n  console.log(\"Hello, \" + x.name);\n}\n \nconst obj = {\n  x: 0,\n  y: 0,\n  name: \"Origin\",\n};\n \nlogPoint(obj);\nlogName(obj);\n```\n\nTypeScript’s type system is *structural*, not nominal: We can use `obj` as a `Pointlike` because it has `x` and `y` properties that are both numbers. The relationships between types are determined by the properties they contain, not whether they were declared with some particular relationship.\n\nTypeScript’s type system is also *not reified*: There’s nothing at runtime that will tell us that `obj` is `Pointlike`. In fact, the `Pointlike` type is not present *in any form* at runtime.\n\nGoing back to the idea of *types as sets*, we can think of `obj` as being a member of both the `Pointlike` set of values and the `Named` set of values.\n\n### Consequences of Structural Typing\n\nOOP programmers are often surprised by two particular aspects of structural typing.\n\n#### Empty Types\n\nThe first is that the *empty type* seems to defy expectation:\n\n``` ts\nclass Empty {}\n \nfunction fn(arg: Empty) {\n  // do something?\n}\n \n// No error, but this isn't an 'Empty' ?\nfn({ k: 10 });\n```\n\nTypeScript determines if the call to `fn` here is valid by seeing if the provided argument is a valid `Empty`. It does so by examining the *structure* of `{ k: 10 }` and `class Empty { }`. We can see that `{ k: 10 }` has *all* of the properties that `Empty` does, because `Empty` has no properties. Therefore, this is a valid call!\n\nThis may seem surprising, but it’s ultimately a very similar relationship to one enforced in nominal OOP languages. A subclass cannot *remove* a property of its base class, because doing so would destroy the natural subtype relationship between the derived class and its base. Structural type systems simply identify this relationship implicitly by describing subtypes in terms of having properties of compatible types.\n\n#### Identical Types\n\nAnother frequent source of surprise comes with identical types:\n\n``` ts\nclass Car {\n  drive() {\n    // hit the gas\n  }\n}\nclass Golfer {\n  drive() {\n    // hit the ball far\n  }\n}\n\n// No error?\nlet w: Car = new Golfer();\n```\n\nAgain, this isn’t an error because the *structures* of these classes are the same. While this may seem like a potential source of confusion, in practice, identical classes that shouldn’t be related are not common.\n\nWe’ll learn more about how classes relate to each other in the Classes chapter.\n\n### Reflection\n\nOOP programmers are accustomed to being able to query the type of any value, even a generic one:\n\n``` csharp\n// C#\nstatic void LogType<T>() {\n    Console.WriteLine(typeof(T).Name);\n}\n```\n\nBecause TypeScript’s type system is fully erased, information about e.g. the instantiation of a generic type parameter is not available at runtime.\n\nJavaScript does have some limited primitives like `typeof` and `instanceof`, but remember that these operators are still working on the values as they exist in the type-erased output code. For example, `typeof (new Car())` will be `\"object\"`, not `Car` or `\"Car\"`.\n\n## Next Steps\n\nThis was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:\n\n- Read the full Handbook [from start to finish](intro)\n- Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html)"
- name: 'TypeScript for Java/C# Programmers: Co-learning JavaScript'
  id: typescript-in-5-minutes-oop#co-learning-javascript
  summary: If you’re familiar with JavaScript already but are primarily a Java or C# programmer, this introductory page can help explain some of the common misconceptions and pitfalls you might be susceptible to
  belongs_to: TypeScript for Java/C# Programmers
  description: |-
    ## Co-learning JavaScript

    If you’re familiar with JavaScript already but are primarily a Java or C# programmer, this introductory page can help explain some of the common misconceptions and pitfalls you might be susceptible to. Some of the ways that TypeScript models types are quite different from Java or C#, and it’s important to keep these in mind when learning TypeScript.

    If you’re a Java or C# programmer that is new to JavaScript in general, we recommend learning a little bit of JavaScript *without* types first to understand JavaScript’s runtime behaviors. Because TypeScript doesn’t change how your code *runs*, you’ll still have to learn how JavaScript works in order to write code that actually does something!

    It’s important to remember that TypeScript uses the same *runtime* as JavaScript, so any resources about how to accomplish specific runtime behavior (converting a string to a number, displaying an alert, writing a file to disk, etc.) will always apply equally well to TypeScript programs. Don’t limit yourself to TypeScript-specific resources!
- name: 'TypeScript for Java/C# Programmers: Next Steps'
  id: typescript-in-5-minutes-oop#next-steps
  summary: This was a brief overview of the syntax and tools used in everyday TypeScript
  belongs_to: TypeScript for Java/C# Programmers
  description: "## Next Steps\n\nThis was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:\n\n- Read the full Handbook [from start to finish](intro)\n- Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html)"
- name: 'TypeScript for Java/C# Programmers: OOP in TypeScript'
  id: typescript-in-5-minutes-oop#oop-in-typescript
  summary: That said, you can still use classes if you like! Some problems are well-suited to being solved by a traditional OOP hierarchy, and TypeScript’s support for JavaScript classes will make these models even more powerful
  belongs_to: TypeScript for Java/C# Programmers
  description: |-
    ## OOP in TypeScript

    That said, you can still use classes if you like! Some problems are well-suited to being solved by a traditional OOP hierarchy, and TypeScript’s support for JavaScript classes will make these models even more powerful. TypeScript supports many common patterns such as implementing interfaces, inheritance, and static methods.

    We’ll cover classes later in this guide.
- name: 'TypeScript for Java/C# Programmers: Rethinking the Class'
  id: typescript-in-5-minutes-oop#rethinking-the-class
  summary: C# and Java are what we might call mandatory OOP languages
  belongs_to: TypeScript for Java/C# Programmers
  description: |-
    ## Rethinking the Class

    C# and Java are what we might call *mandatory OOP* languages. In these languages, the *class* is the basic unit of code organization, and also the basic container of all data *and* behavior at runtime. Forcing all functionality and data to be held in classes can be a good domain model for some problems, but not every domain *needs* to be represented this way.

    ### Free Functions and Data

    In JavaScript, functions can live anywhere, and data can be passed around freely without being inside a pre-defined `class` or `struct`. This flexibility is extremely powerful. “Free” functions (those not associated with a class) working over data without an implied OOP hierarchy tend to be the preferred model for writing programs in JavaScript.

    ### Static Classes

    Additionally, certain constructs from C# and Java such as singletons and static classes are unnecessary in TypeScript.
- name: 'TypeScript for Java/C# Programmers: Rethinking Types'
  id: typescript-in-5-minutes-oop#rethinking-types
  summary: TypeScript’s understanding of a type is actually quite different from C# or Java’s
  belongs_to: TypeScript for Java/C# Programmers
  description: |-
    ## Rethinking Types

    TypeScript’s understanding of a *type* is actually quite different from C# or Java’s. Let’s explore some differences.

    ### Nominal Reified Type Systems

    In C# or Java, any given value or object has one exact type - either `null`, a primitive, or a known class type. We can call methods like `value.GetType()` or `value.getClass()` to query the exact type at runtime. The definition of this type will reside in a class somewhere with some name, and we can’t use two classes with similar shapes in lieu of each other unless there’s an explicit inheritance relationship or commonly-implemented interface.

    These aspects describe a *reified, nominal* type system. The types we wrote in the code are present at runtime, and the types are related via their declarations, not their structures.

    ### Types as Sets

    In C# or Java, it’s meaningful to think of a one-to-one correspondence between runtime types and their compile-time declarations.

    In TypeScript, it’s better to think of a type as a *set of values* that share something in common. Because types are just sets, a particular value can belong to *many* sets at the same time.

    Once you start thinking of types as sets, certain operations become very natural. For example, in C#, it’s awkward to pass around a value that is *either* a `string` or `int`, because there isn’t a single type that represents this sort of value.

    In TypeScript, this becomes very natural once you realize that every type is just a set. How do you describe a value that either belongs in the `string` set or the `number` set? It simply belongs to the *union* of those sets: `string | number`.

    TypeScript provides a number of mechanisms to work with types in a set-theoretic way, and you’ll find them more intuitive if you think of types as sets.

    ### Erased Structural Types

    In TypeScript, objects are *not* of a single exact type. For example, if we construct an object that satisfies an interface, we can use that object where that interface is expected even though there was no declarative relationship between the two.

    ``` ts
    interface Pointlike {
      x: number;
      y: number;
    }
    interface Named {
      name: string;
    }
     
    function logPoint(point: Pointlike) {
      console.log("x = " + point.x + ", y = " + point.y);
    }
     
    function logName(x: Named) {
      console.log("Hello, " + x.name);
    }
     
    const obj = {
      x: 0,
      y: 0,
      name: "Origin",
    };
     
    logPoint(obj);
    logName(obj);
    ```

    TypeScript’s type system is *structural*, not nominal: We can use `obj` as a `Pointlike` because it has `x` and `y` properties that are both numbers. The relationships between types are determined by the properties they contain, not whether they were declared with some particular relationship.

    TypeScript’s type system is also *not reified*: There’s nothing at runtime that will tell us that `obj` is `Pointlike`. In fact, the `Pointlike` type is not present *in any form* at runtime.

    Going back to the idea of *types as sets*, we can think of `obj` as being a member of both the `Pointlike` set of values and the `Named` set of values.

    ### Consequences of Structural Typing

    OOP programmers are often surprised by two particular aspects of structural typing.

    #### Empty Types

    The first is that the *empty type* seems to defy expectation:

    ``` ts
    class Empty {}
     
    function fn(arg: Empty) {
      // do something?
    }
     
    // No error, but this isn't an 'Empty' ?
    fn({ k: 10 });
    ```

    TypeScript determines if the call to `fn` here is valid by seeing if the provided argument is a valid `Empty`. It does so by examining the *structure* of `{ k: 10 }` and `class Empty { }`. We can see that `{ k: 10 }` has *all* of the properties that `Empty` does, because `Empty` has no properties. Therefore, this is a valid call!

    This may seem surprising, but it’s ultimately a very similar relationship to one enforced in nominal OOP languages. A subclass cannot *remove* a property of its base class, because doing so would destroy the natural subtype relationship between the derived class and its base. Structural type systems simply identify this relationship implicitly by describing subtypes in terms of having properties of compatible types.

    #### Identical Types

    Another frequent source of surprise comes with identical types:

    ``` ts
    class Car {
      drive() {
        // hit the gas
      }
    }
    class Golfer {
      drive() {
        // hit the ball far
      }
    }

    // No error?
    let w: Car = new Golfer();
    ```

    Again, this isn’t an error because the *structures* of these classes are the same. While this may seem like a potential source of confusion, in practice, identical classes that shouldn’t be related are not common.

    We’ll learn more about how classes relate to each other in the Classes chapter.

    ### Reflection

    OOP programmers are accustomed to being able to query the type of any value, even a generic one:

    ``` csharp
    // C#
    static void LogType<T>() {
        Console.WriteLine(typeof(T).Name);
    }
    ```

    Because TypeScript’s type system is fully erased, information about e.g. the instantiation of a generic type parameter is not available at runtime.

    JavaScript does have some limited primitives like `typeof` and `instanceof`, but remember that these operators are still working on the values as they exist in the type-erased output code. For example, `typeof (new Car())` will be `"object"`, not `Car` or `"Car"`.
- name: TypeScript for JavaScript Programmers
  id: typescript-in-5-minutes
  summary: TypeScript stands in an unusual relationship to JavaScript
  description: "# TypeScript for JavaScript Programmers\n\nTypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript’s features, and an additional layer on top of these: TypeScript’s type system.\n\nFor example, JavaScript provides language primitives like `string` and `number`, but it doesn’t check that you’ve consistently assigned these. TypeScript does.\n\nThis means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs.\n\nThis tutorial provides a brief overview of TypeScript, focusing on its type system.\n\n## Types by Inference\n\nTypeScript knows the JavaScript language and will generate types for you in many cases. For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.\n\n``` ts\nlet helloWorld = \"Hello World\";\n```\n\nBy understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That’s how TypeScript knows that `helloWorld` is a `string` in the above example.\n\nYou may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.\n\n## Defining Types\n\nYou can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.\n\nFor example, to create an object with an inferred type which includes `name: string` and `id: number`, you can write:\n\n``` ts\nconst user = {\n  name: \"Hayes\",\n  id: 0,\n};\n```\n\nYou can explicitly describe this object’s shape using an `interface` declaration:\n\n``` ts\ninterface User {\n  name: string;\n  id: number;\n}\n```\n\nYou can then declare that a JavaScript object conforms to the shape of your new `interface` by using syntax like `: TypeName` after a variable declaration:\n\n``` ts\nconst user: User = {\n  name: \"Hayes\",\n  id: 0,\n};\n```\n\nIf you provide an object that doesn’t match the interface you have provided, TypeScript will warn you:\n\n``` ts\ninterface User {\n  name: string;\n  id: number;\n}\n \nconst user: User = {\n  username: \"Hayes\",\n  id: 0,\n};\n```\n\nSince JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:\n\n``` ts\ninterface User {\n  name: string;\n  id: number;\n}\n \nclass UserAccount {\n  name: string;\n  id: number;\n \n  constructor(name: string, id: number) {\n    this.name = name;\n    this.id = id;\n  }\n}\n \nconst user: User = new UserAccount(\"Murphy\", 1);\n```\n\nYou can use interfaces to annotate parameters and return values to functions:\n\n``` ts\nfunction deleteUser(user: User) {\n  // ...\n}\n \nfunction getAdminUser(): User {\n  //...\n}\n```\n\nThere is already a small set of primitive types available in JavaScript: `boolean`, `bigint`, `null`, `number`, `string`, `symbol`, and `undefined`, which you can use in an interface. TypeScript extends this list with a few more, such as `any` (allow anything), [`unknown`](https://www.typescriptlang.org/play#example/unknown-and-never) (ensure someone using this type declares what the type is), [`never`](https://www.typescriptlang.org/play#example/unknown-and-never) (it’s not possible that this type could happen), and `void` (a function which returns `undefined` or has no return value).\n\nYou’ll see that there are two syntaxes for building types: [Interfaces and Types](https://www.typescriptlang.org/play/?e=83#example/types-vs-interfaces). You should prefer `interface`. Use `type` when you need specific features.\n\n## Composing Types\n\nWith TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: with unions, and with generics.\n\n### Unions\n\nWith a union, you can declare that a type could be one of many types. For example, you can describe a `boolean` type as being either `true` or `false`:\n\n``` ts\ntype MyBool = true | false;\n```\n\n*Note:* If you hover over `MyBool` above, you’ll see that it is classed as `boolean`. That’s a property of the Structural Type System. More on this below.\n\nA popular use-case for union types is to describe the set of `string` or `number` [literals](2/everyday-types#literal-types) that a value is allowed to be:\n\n``` ts\ntype WindowStates = \"open\" | \"closed\" | \"minimized\";\ntype LockStates = \"locked\" | \"unlocked\";\ntype PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;\n```\n\nUnions provide a way to handle different types too. For example, you may have a function that takes an `array` or a `string`:\n\n``` ts\nfunction getLength(obj: string | string[]) {\n  return obj.length;\n}\n```\n\nTo learn the type of a variable, use `typeof`:\n\n| Type      | Predicate                          |\n|-----------|------------------------------------|\n| string    | `typeof s === \"string\"`            |\n| number    | `typeof n === \"number\"`            |\n| boolean   | `typeof b === \"boolean\"`           |\n| undefined | `typeof undefined === \"undefined\"` |\n| function  | `typeof f === \"function\"`          |\n| array     | `Array.isArray(a)`                 |\n\nFor example, you can make a function return different values depending on whether it is passed a string or an array:\n\n``` ts\nfunction wrapInArray(obj: string | string[]) {\n  if (typeof obj === \"string\") {\n    return [obj];\n  }\n  return obj;\n}\n```\n\n### Generics\n\nGenerics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.\n\n``` ts\ntype StringArray = Array<string>;\ntype NumberArray = Array<number>;\ntype ObjectWithNameArray = Array<{ name: string }>;\n```\n\nYou can declare your own types that use generics:\n\n``` ts\ninterface Backpack<Type> {\n  add: (obj: Type) => void;\n  get: () => Type;\n}\n \n// This line is a shortcut to tell TypeScript there is a\n// constant called `backpack`, and to not worry about where it came from.\ndeclare const backpack: Backpack<string>;\n \n// object is a string, because we declared it above as the variable part of Backpack.\nconst object = backpack.get();\n \n// Since the backpack variable is a string, you can't pass a number to the add function.\nbackpack.add(23);\n```\n\n## Structural Type System\n\nOne of TypeScript’s core principles is that type checking focuses on the *shape* that values have. This is sometimes called “duck typing” or “structural typing”.\n\nIn a structural type system, if two objects have the same shape, they are considered to be of the same type.\n\n``` ts\ninterface Point {\n  x: number;\n  y: number;\n}\n \nfunction logPoint(p: Point) {\n  console.log(`${p.x}, ${p.y}`);\n}\n \n// logs \"12, 26\"\nconst point = { x: 12, y: 26 };\nlogPoint(point);\n```\n\nThe `point` variable is never declared to be a `Point` type. However, TypeScript compares the shape of `point` to the shape of `Point` in the type-check. They have the same shape, so the code passes.\n\nThe shape-matching only requires a subset of the object’s fields to match.\n\n``` ts\nconst point3 = { x: 12, y: 26, z: 89 };\nlogPoint(point3); // logs \"12, 26\"\n \nconst rect = { x: 33, y: 3, width: 30, height: 80 };\nlogPoint(rect); // logs \"33, 3\"\n \nconst color = { hex: \"#187ABF\" };\nlogPoint(color);\n```\n\nThere is no difference between how classes and objects conform to shapes:\n\n``` ts\nclass VirtualPoint {\n  x: number;\n  y: number;\n \n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n}\n \nconst newVPoint = new VirtualPoint(13, 56);\nlogPoint(newVPoint); // logs \"13, 56\"\n```\n\nIf the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.\n\n## Next Steps\n\nThis was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:\n\n- Read the full Handbook [from start to finish](intro)\n- Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)"
- name: 'TypeScript for JavaScript Programmers: Composing Types'
  id: typescript-in-5-minutes#composing-types
  summary: With TypeScript, you can create complex types by combining simple ones
  belongs_to: TypeScript for JavaScript Programmers
  description: |-
    ## Composing Types

    With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: with unions, and with generics.

    ### Unions

    With a union, you can declare that a type could be one of many types. For example, you can describe a `boolean` type as being either `true` or `false`:

    ``` ts
    type MyBool = true | false;
    ```

    *Note:* If you hover over `MyBool` above, you’ll see that it is classed as `boolean`. That’s a property of the Structural Type System. More on this below.

    A popular use-case for union types is to describe the set of `string` or `number` [literals](2/everyday-types#literal-types) that a value is allowed to be:

    ``` ts
    type WindowStates = "open" | "closed" | "minimized";
    type LockStates = "locked" | "unlocked";
    type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;
    ```

    Unions provide a way to handle different types too. For example, you may have a function that takes an `array` or a `string`:

    ``` ts
    function getLength(obj: string | string[]) {
      return obj.length;
    }
    ```

    To learn the type of a variable, use `typeof`:

    | Type      | Predicate                          |
    |-----------|------------------------------------|
    | string    | `typeof s === "string"`            |
    | number    | `typeof n === "number"`            |
    | boolean   | `typeof b === "boolean"`           |
    | undefined | `typeof undefined === "undefined"` |
    | function  | `typeof f === "function"`          |
    | array     | `Array.isArray(a)`                 |

    For example, you can make a function return different values depending on whether it is passed a string or an array:

    ``` ts
    function wrapInArray(obj: string | string[]) {
      if (typeof obj === "string") {
        return [obj];
      }
      return obj;
    }
    ```

    ### Generics

    Generics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.

    ``` ts
    type StringArray = Array<string>;
    type NumberArray = Array<number>;
    type ObjectWithNameArray = Array<{ name: string }>;
    ```

    You can declare your own types that use generics:

    ``` ts
    interface Backpack<Type> {
      add: (obj: Type) => void;
      get: () => Type;
    }
     
    // This line is a shortcut to tell TypeScript there is a
    // constant called `backpack`, and to not worry about where it came from.
    declare const backpack: Backpack<string>;
     
    // object is a string, because we declared it above as the variable part of Backpack.
    const object = backpack.get();
     
    // Since the backpack variable is a string, you can't pass a number to the add function.
    backpack.add(23);
    ```
- name: 'TypeScript for JavaScript Programmers: Defining Types'
  id: typescript-in-5-minutes#defining-types
  summary: You can use a wide variety of design patterns in JavaScript
  belongs_to: TypeScript for JavaScript Programmers
  description: |-
    ## Defining Types

    You can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.

    For example, to create an object with an inferred type which includes `name: string` and `id: number`, you can write:

    ``` ts
    const user = {
      name: "Hayes",
      id: 0,
    };
    ```

    You can explicitly describe this object’s shape using an `interface` declaration:

    ``` ts
    interface User {
      name: string;
      id: number;
    }
    ```

    You can then declare that a JavaScript object conforms to the shape of your new `interface` by using syntax like `: TypeName` after a variable declaration:

    ``` ts
    const user: User = {
      name: "Hayes",
      id: 0,
    };
    ```

    If you provide an object that doesn’t match the interface you have provided, TypeScript will warn you:

    ``` ts
    interface User {
      name: string;
      id: number;
    }
     
    const user: User = {
      username: "Hayes",
      id: 0,
    };
    ```

    Since JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:

    ``` ts
    interface User {
      name: string;
      id: number;
    }
     
    class UserAccount {
      name: string;
      id: number;
     
      constructor(name: string, id: number) {
        this.name = name;
        this.id = id;
      }
    }
     
    const user: User = new UserAccount("Murphy", 1);
    ```

    You can use interfaces to annotate parameters and return values to functions:

    ``` ts
    function deleteUser(user: User) {
      // ...
    }
     
    function getAdminUser(): User {
      //...
    }
    ```

    There is already a small set of primitive types available in JavaScript: `boolean`, `bigint`, `null`, `number`, `string`, `symbol`, and `undefined`, which you can use in an interface. TypeScript extends this list with a few more, such as `any` (allow anything), [`unknown`](https://www.typescriptlang.org/play#example/unknown-and-never) (ensure someone using this type declares what the type is), [`never`](https://www.typescriptlang.org/play#example/unknown-and-never) (it’s not possible that this type could happen), and `void` (a function which returns `undefined` or has no return value).

    You’ll see that there are two syntaxes for building types: [Interfaces and Types](https://www.typescriptlang.org/play/?e=83#example/types-vs-interfaces). You should prefer `interface`. Use `type` when you need specific features.
- name: 'TypeScript for JavaScript Programmers: Next Steps'
  id: typescript-in-5-minutes#next-steps
  summary: This was a brief overview of the syntax and tools used in everyday TypeScript
  belongs_to: TypeScript for JavaScript Programmers
  description: "## Next Steps\n\nThis was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:\n\n- Read the full Handbook [from start to finish](intro)\n- Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)"
- name: 'TypeScript for JavaScript Programmers: Structural Type System'
  id: typescript-in-5-minutes#structural-type-system
  summary: One of TypeScript’s core principles is that type checking focuses on the shape that values have
  belongs_to: TypeScript for JavaScript Programmers
  description: |-
    ## Structural Type System

    One of TypeScript’s core principles is that type checking focuses on the *shape* that values have. This is sometimes called “duck typing” or “structural typing”.

    In a structural type system, if two objects have the same shape, they are considered to be of the same type.

    ``` ts
    interface Point {
      x: number;
      y: number;
    }
     
    function logPoint(p: Point) {
      console.log(`${p.x}, ${p.y}`);
    }
     
    // logs "12, 26"
    const point = { x: 12, y: 26 };
    logPoint(point);
    ```

    The `point` variable is never declared to be a `Point` type. However, TypeScript compares the shape of `point` to the shape of `Point` in the type-check. They have the same shape, so the code passes.

    The shape-matching only requires a subset of the object’s fields to match.

    ``` ts
    const point3 = { x: 12, y: 26, z: 89 };
    logPoint(point3); // logs "12, 26"
     
    const rect = { x: 33, y: 3, width: 30, height: 80 };
    logPoint(rect); // logs "33, 3"
     
    const color = { hex: "#187ABF" };
    logPoint(color);
    ```

    There is no difference between how classes and objects conform to shapes:

    ``` ts
    class VirtualPoint {
      x: number;
      y: number;
     
      constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
      }
    }
     
    const newVPoint = new VirtualPoint(13, 56);
    logPoint(newVPoint); // logs "13, 56"
    ```

    If the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.
- name: 'TypeScript for JavaScript Programmers: Types by Inference'
  id: typescript-in-5-minutes#types-by-inference
  summary: TypeScript knows the JavaScript language and will generate types for you in many cases
  belongs_to: TypeScript for JavaScript Programmers
  description: |-
    ## Types by Inference

    TypeScript knows the JavaScript language and will generate types for you in many cases. For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.

    ``` ts
    let helloWorld = "Hello World";
    ```

    By understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That’s how TypeScript knows that `helloWorld` is a `string` in the above example.

    You may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.
- name: TypeScript for the New Programmer
  id: typescript-from-scratch
  summary: You’ve probably already heard that TypeScript is a “flavor” or “variant” of JavaScript
  description: "# TypeScript for the New Programmer\n\nCongratulations on choosing TypeScript as one of your first languages — you’re already making good decisions!\n\nYou’ve probably already heard that TypeScript is a “flavor” or “variant” of JavaScript. The relationship between TypeScript (TS) and JavaScript (JS) is rather unique among modern programming languages, so learning more about this relationship will help you understand how TypeScript adds to JavaScript.\n\n## What is JavaScript? A Brief History\n\nJavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers. At the time it was invented, it was expected to be used for short snippets of code embedded in a web page — writing more than a few dozen lines of code would have been somewhat unusual. Due to this, early web browsers executed such code pretty slowly. Over time, though, JS became more and more popular, and web developers started using it to create interactive experiences.\n\nWeb browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more. On modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code. This is the long and gradual growth of “the web”, starting as a simple network of static pages, and evolving into a platform for rich *applications* of all kinds.\n\nMore than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js. The “run anywhere” nature of JS makes it an attractive choice for cross-platform development. There are many developers these days that use *only* JavaScript to program their entire stack!\n\nTo summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines. Every language has its own *quirks* — oddities and surprises, and JavaScript’s humble beginning makes it have *many* of these. Some examples:\n\n- JavaScript’s equality operator (`==`) *coerces* its operands, leading to unexpected behavior:\n\n  ``` js\n  if (\"\" == 0) {\n    // It is! But why??\n  }\n  if (1 < x < 3) {\n    // True for *any* value of x!\n  }\n  ```\n\n- JavaScript also allows accessing properties which aren’t present:\n\n  ``` js\n  const obj = { width: 10, height: 15 };\n  // Why is this NaN? Spelling is hard!\n  const area = obj.width * obj.heigth;\n  ```\n\nMost programming languages would throw an error when these sorts of errors occur, some would do so during compilation — before any code is running. When writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem.\n\n## TypeScript: A Static Type Checker\n\nWe said earlier that some languages wouldn’t allow those buggy programs to run at all. Detecting errors in code without running it is referred to as *static checking*. Determining what’s an error and what’s not based on the kinds of values being operated on is known as static *type* checking.\n\nTypeScript checks a program for errors before execution, and does so based on the *kinds of values*, making it a *static type checker*. For example, the last example above has an error because of the *type* of `obj`. Here’s the error TypeScript found:\n\n``` ts\nconst obj = { width: 10, height: 15 };\nconst area = obj.width * obj.heigth;\n```\n\n### A Typed Superset of JavaScript\n\nHow does TypeScript relate to JavaScript, though?\n\n#### Syntax\n\nTypeScript is a language that is a *superset* of JavaScript: JS syntax is therefore legal TS. Syntax refers to the way we write text to form a program. For example, this code has a *syntax* error because it’s missing a `)`:\n\n``` ts\nlet a = (4\n```\n\nTypeScript doesn’t consider any JavaScript code to be an error because of its syntax. This means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written.\n\n#### Types\n\nHowever, TypeScript is a *typed* superset, meaning that it adds rules about how different kinds of values can be used. The earlier error about `obj.heigth` was not a *syntax* error: it is an error of using some kind of value (a *type*) in an incorrect way.\n\nAs another example, this is JavaScript code that you can run in your browser, and it *will* log a value:\n\n``` js\nconsole.log(4 / []);\n```\n\nThis syntactically-legal program logs `Infinity`. TypeScript, though, considers division of number by an array to be a nonsensical operation, and will issue an error:\n\n``` ts\nconsole.log(4 / []);\n```\n\nIt’s possible you really *did* intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake. TypeScript’s type checker is designed to allow correct programs through while still catching as many common errors as possible. (Later, we’ll learn about settings you can use to configure how strictly TypeScript checks your code.)\n\nIf you move some code from a JavaScript file to a TypeScript file, you might see *type errors* depending on how the code is written. These may be legitimate problems with the code, or TypeScript being overly conservative. Throughout this guide we’ll demonstrate how to add various TypeScript syntax to eliminate such errors.\n\n#### Runtime Behavior\n\nTypeScript is also a programming language that preserves the *runtime behavior* of JavaScript. For example, dividing by zero in JavaScript produces `Infinity` instead of throwing a runtime exception. As a principle, TypeScript **never** changes the runtime behavior of JavaScript code.\n\nThis means that if you move code from JavaScript to TypeScript, it is **guaranteed** to run the same way, even if TypeScript thinks that the code has type errors.\n\nKeeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working.\n\n#### Erased Types\n\nRoughly speaking, once TypeScript’s compiler is done with checking your code, it *erases* the types to produce the resulting “compiled” code. This means that once your code is compiled, the resulting plain JS code has no type information.\n\nThis also means that TypeScript never changes the *behavior* of your program based on the types it inferred. The bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs.\n\nFinally, TypeScript doesn’t provide any additional runtime libraries. Your programs will use the same standard library (or external libraries) as JavaScript programs, so there’s no additional TypeScript-specific framework to learn.\n\n## Learning JavaScript and TypeScript\n\nWe frequently see the question “Should I learn JavaScript or TypeScript?“.\n\nThe answer is that you can’t learn TypeScript without learning JavaScript! TypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time.\n\nThere are many, many resources available for programmers to learn JavaScript; you should *not* ignore these resources if you’re writing TypeScript. For example, there are about 20 times more StackOverflow questions tagged `javascript` than `typescript`, but *all* of the `javascript` questions also apply to TypeScript.\n\nIf you find yourself searching for something like “how to sort a list in TypeScript”, remember: **TypeScript is JavaScript’s runtime with a compile-time type checker**. The way you sort a list in TypeScript is the same way you do so in JavaScript. If you find a resource that uses TypeScript directly, that’s great too, but don’t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks.\n\n## Next Steps\n\nThis was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:\n\n- Learn some of the JavaScript fundamentals, we recommend either:\n\n  - [Microsoft’s JavaScript Resources](https://developer.microsoft.com/javascript/) or\n  - [JavaScript guide at the Mozilla Web Docs](https://developer.mozilla.org/docs/Web/JavaScript/Guide)\n\n- Continue to [TypeScript for JavaScript Programmers](typescript-in-5-minutes)\n\n- Read the full Handbook [from start to finish](intro)\n\n- Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html)"
- name: 'TypeScript for the New Programmer: Learning JavaScript and TypeScript'
  id: typescript-from-scratch#learning-javascript-and-typescript
  summary: The answer is that you can’t learn TypeScript without learning JavaScript! TypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time
  belongs_to: TypeScript for the New Programmer
  description: |-
    ## Learning JavaScript and TypeScript

    We frequently see the question “Should I learn JavaScript or TypeScript?“.

    The answer is that you can’t learn TypeScript without learning JavaScript! TypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time.

    There are many, many resources available for programmers to learn JavaScript; you should *not* ignore these resources if you’re writing TypeScript. For example, there are about 20 times more StackOverflow questions tagged `javascript` than `typescript`, but *all* of the `javascript` questions also apply to TypeScript.

    If you find yourself searching for something like “how to sort a list in TypeScript”, remember: **TypeScript is JavaScript’s runtime with a compile-time type checker**. The way you sort a list in TypeScript is the same way you do so in JavaScript. If you find a resource that uses TypeScript directly, that’s great too, but don’t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks.
- name: 'TypeScript for the New Programmer: Next Steps'
  id: typescript-from-scratch#next-steps
  summary: This was a brief overview of the syntax and tools used in everyday TypeScript
  belongs_to: TypeScript for the New Programmer
  description: "## Next Steps\n\nThis was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:\n\n- Learn some of the JavaScript fundamentals, we recommend either:\n\n  - [Microsoft’s JavaScript Resources](https://developer.microsoft.com/javascript/) or\n  - [JavaScript guide at the Mozilla Web Docs](https://developer.mozilla.org/docs/Web/JavaScript/Guide)\n\n- Continue to [TypeScript for JavaScript Programmers](typescript-in-5-minutes)\n\n- Read the full Handbook [from start to finish](intro)\n\n- Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html)"
- name: 'TypeScript for the New Programmer: TypeScript: A Static Type Checker'
  id: typescript-from-scratch#typescript-a-static-type-checker
  summary: We said earlier that some languages wouldn’t allow those buggy programs to run at all
  belongs_to: TypeScript for the New Programmer
  description: |-
    ## TypeScript: A Static Type Checker

    We said earlier that some languages wouldn’t allow those buggy programs to run at all. Detecting errors in code without running it is referred to as *static checking*. Determining what’s an error and what’s not based on the kinds of values being operated on is known as static *type* checking.

    TypeScript checks a program for errors before execution, and does so based on the *kinds of values*, making it a *static type checker*. For example, the last example above has an error because of the *type* of `obj`. Here’s the error TypeScript found:

    ``` ts
    const obj = { width: 10, height: 15 };
    const area = obj.width * obj.heigth;
    ```

    ### A Typed Superset of JavaScript

    How does TypeScript relate to JavaScript, though?

    #### Syntax

    TypeScript is a language that is a *superset* of JavaScript: JS syntax is therefore legal TS. Syntax refers to the way we write text to form a program. For example, this code has a *syntax* error because it’s missing a `)`:

    ``` ts
    let a = (4
    ```

    TypeScript doesn’t consider any JavaScript code to be an error because of its syntax. This means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written.

    #### Types

    However, TypeScript is a *typed* superset, meaning that it adds rules about how different kinds of values can be used. The earlier error about `obj.heigth` was not a *syntax* error: it is an error of using some kind of value (a *type*) in an incorrect way.

    As another example, this is JavaScript code that you can run in your browser, and it *will* log a value:

    ``` js
    console.log(4 / []);
    ```

    This syntactically-legal program logs `Infinity`. TypeScript, though, considers division of number by an array to be a nonsensical operation, and will issue an error:

    ``` ts
    console.log(4 / []);
    ```

    It’s possible you really *did* intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake. TypeScript’s type checker is designed to allow correct programs through while still catching as many common errors as possible. (Later, we’ll learn about settings you can use to configure how strictly TypeScript checks your code.)

    If you move some code from a JavaScript file to a TypeScript file, you might see *type errors* depending on how the code is written. These may be legitimate problems with the code, or TypeScript being overly conservative. Throughout this guide we’ll demonstrate how to add various TypeScript syntax to eliminate such errors.

    #### Runtime Behavior

    TypeScript is also a programming language that preserves the *runtime behavior* of JavaScript. For example, dividing by zero in JavaScript produces `Infinity` instead of throwing a runtime exception. As a principle, TypeScript **never** changes the runtime behavior of JavaScript code.

    This means that if you move code from JavaScript to TypeScript, it is **guaranteed** to run the same way, even if TypeScript thinks that the code has type errors.

    Keeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working.

    #### Erased Types

    Roughly speaking, once TypeScript’s compiler is done with checking your code, it *erases* the types to produce the resulting “compiled” code. This means that once your code is compiled, the resulting plain JS code has no type information.

    This also means that TypeScript never changes the *behavior* of your program based on the types it inferred. The bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs.

    Finally, TypeScript doesn’t provide any additional runtime libraries. Your programs will use the same standard library (or external libraries) as JavaScript programs, so there’s no additional TypeScript-specific framework to learn.
- name: 'TypeScript for the New Programmer: What is JavaScript? A Brief History'
  id: typescript-from-scratch#what-is-javascript-a-brief-history
  summary: JavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers
  belongs_to: TypeScript for the New Programmer
  description: |-
    ## What is JavaScript? A Brief History

    JavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers. At the time it was invented, it was expected to be used for short snippets of code embedded in a web page — writing more than a few dozen lines of code would have been somewhat unusual. Due to this, early web browsers executed such code pretty slowly. Over time, though, JS became more and more popular, and web developers started using it to create interactive experiences.

    Web browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more. On modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code. This is the long and gradual growth of “the web”, starting as a simple network of static pages, and evolving into a platform for rich *applications* of all kinds.

    More than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js. The “run anywhere” nature of JS makes it an attractive choice for cross-platform development. There are many developers these days that use *only* JavaScript to program their entire stack!

    To summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines. Every language has its own *quirks* — oddities and surprises, and JavaScript’s humble beginning makes it have *many* of these. Some examples:

    - JavaScript’s equality operator (`==`) *coerces* its operands, leading to unexpected behavior:

      ``` js
      if ("" == 0) {
        // It is! But why??
      }
      if (1 < x < 3) {
        // True for *any* value of x!
      }
      ```

    - JavaScript also allows accessing properties which aren’t present:

      ``` js
      const obj = { width: 10, height: 15 };
      // Why is this NaN? Spelling is hard!
      const area = obj.width * obj.heigth;
      ```

    Most programming languages would throw an error when these sorts of errors occur, some would do so during compilation — before any code is running. When writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem.
- name: TypeScript Tooling in 5 minutes
  id: typescript-tooling-in-5-minutes
  summary: Let’s get started by building a simple web application with TypeScript
  description: "# TypeScript Tooling in 5 minutes\n\nLet’s get started by building a simple web application with TypeScript.\n\n## Installing TypeScript\n\nThere are two main ways to add TypeScript to your project:\n\n- Via npm (the Node.js package manager)\n- By installing TypeScript’s Visual Studio plugins\n\nVisual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript language support by default but does not include the TypeScript compiler, `tsc`. If you didn’t install TypeScript with Visual Studio, you can still [download it](https://www.typescriptlang.org/download).\n\nFor npm users:\n\n``` shell\n> npm install -g typescript\n```\n\n## Building your first TypeScript file\n\nIn your editor, type the following JavaScript code in `greeter.ts`:\n\n``` ts\nfunction greeter(person) {\n  return \"Hello, \" + person;\n}\n \nlet user = \"Jane User\";\n \ndocument.body.textContent = greeter(user);\n```\n\n## Compiling your code\n\nWe used a `.ts` extension, but this code is just JavaScript. You could have copy/pasted this straight out of an existing JavaScript app.\n\nAt the command line, run the TypeScript compiler:\n\n``` shell\ntsc greeter.ts\n```\n\nThe result will be a file `greeter.js` which contains the same JavaScript that you fed in. We’re up and running using TypeScript in our JavaScript app!\n\nNow we can start taking advantage of some of the new tools TypeScript offers. Add a `: string` type annotation to the ‘person’ function parameter as shown here:\n\n``` ts\nfunction greeter(person: string) {\n  return \"Hello, \" + person;\n}\n \nlet user = \"Jane User\";\n \ndocument.body.textContent = greeter(user);\n```\n\n## Type annotations\n\nType annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:\n\n``` ts\nfunction greeter(person: string) {\n  return \"Hello, \" + person;\n}\n \nlet user = [0, 1, 2];\n \ndocument.body.textContent = greeter(user);\n```\n\nRe-compiling, you’ll now see an error:\n\n``` shell\nerror TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.\n```\n\nSimilarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of arguments. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.\n\nNotice that although there were errors, the `greeter.js` file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.\n\n## Interfaces\n\nLet’s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field. In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit `implements` clause.\n\n``` ts\ninterface Person {\n  firstName: string;\n  lastName: string;\n}\n \nfunction greeter(person: Person) {\n  return \"Hello, \" + person.firstName + \" \" + person.lastName;\n}\n \nlet user = { firstName: \"Jane\", lastName: \"User\" };\n \ndocument.body.textContent = greeter(user);\n```\n\n## Classes\n\nFinally, let’s extend the example one last time with classes. TypeScript supports new features in JavaScript, like support for class-based object-oriented programming.\n\nHere we’re going to create a `Student` class with a constructor and a few public fields. Notice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction.\n\nAlso of note, the use of `public` on parameters to the constructor is a shorthand that allows us to automatically create properties with that name.\n\n``` ts\nclass Student {\n  fullName: string;\n  constructor(\n    public firstName: string,\n    public middleInitial: string,\n    public lastName: string\n  ) {\n    this.fullName = firstName + \" \" + middleInitial + \" \" + lastName;\n  }\n}\n \ninterface Person {\n  firstName: string;\n  lastName: string;\n}\n \nfunction greeter(person: Person) {\n  return \"Hello, \" + person.firstName + \" \" + person.lastName;\n}\n \nlet user = new Student(\"Jane\", \"M.\", \"User\");\n \ndocument.body.textContent = greeter(user);\n```\n\nRe-run `tsc greeter.ts` and you’ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.\n\n## Running your TypeScript web app\n\nNow type the following in `greeter.html`:\n\n``` html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>TypeScript Greeter</title>\n  </head>\n  <body>\n    <script src=\"greeter.js\"></script>\n  </body>\n</html>\n```\n\nOpen `greeter.html` in the browser to run your first simple TypeScript web application!\n\nOptional: Open `greeter.ts` in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.\n\nThe type information provided works together with the tools to work with JavaScript at application scale. For more examples of what’s possible in TypeScript, see the Samples section of the website.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html)"
- name: 'TypeScript Tooling in 5 minutes: Building your first TypeScript file'
  id: typescript-tooling-in-5-minutes#building-your-first-typescript-file
  summary: null
  belongs_to: TypeScript Tooling in 5 minutes
  description: |-
    ## Building your first TypeScript file

    In your editor, type the following JavaScript code in `greeter.ts`:

    ``` ts
    function greeter(person) {
      return "Hello, " + person;
    }
     
    let user = "Jane User";
     
    document.body.textContent = greeter(user);
    ```
- name: 'TypeScript Tooling in 5 minutes: Classes'
  id: typescript-tooling-in-5-minutes#classes
  summary: Finally, let’s extend the example one last time with classes
  belongs_to: TypeScript Tooling in 5 minutes
  description: |-
    ## Classes

    Finally, let’s extend the example one last time with classes. TypeScript supports new features in JavaScript, like support for class-based object-oriented programming.

    Here we’re going to create a `Student` class with a constructor and a few public fields. Notice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction.

    Also of note, the use of `public` on parameters to the constructor is a shorthand that allows us to automatically create properties with that name.

    ``` ts
    class Student {
      fullName: string;
      constructor(
        public firstName: string,
        public middleInitial: string,
        public lastName: string
      ) {
        this.fullName = firstName + " " + middleInitial + " " + lastName;
      }
    }
     
    interface Person {
      firstName: string;
      lastName: string;
    }
     
    function greeter(person: Person) {
      return "Hello, " + person.firstName + " " + person.lastName;
    }
     
    let user = new Student("Jane", "M.", "User");
     
    document.body.textContent = greeter(user);
    ```

    Re-run `tsc greeter.ts` and you’ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.
- name: 'TypeScript Tooling in 5 minutes: Compiling your code'
  id: typescript-tooling-in-5-minutes#compiling-your-code
  summary: We used a .ts extension, but this code is just JavaScript
  belongs_to: TypeScript Tooling in 5 minutes
  description: |-
    ## Compiling your code

    We used a `.ts` extension, but this code is just JavaScript. You could have copy/pasted this straight out of an existing JavaScript app.

    At the command line, run the TypeScript compiler:

    ``` shell
    tsc greeter.ts
    ```

    The result will be a file `greeter.js` which contains the same JavaScript that you fed in. We’re up and running using TypeScript in our JavaScript app!

    Now we can start taking advantage of some of the new tools TypeScript offers. Add a `: string` type annotation to the ‘person’ function parameter as shown here:

    ``` ts
    function greeter(person: string) {
      return "Hello, " + person;
    }
     
    let user = "Jane User";
     
    document.body.textContent = greeter(user);
    ```
- name: 'TypeScript Tooling in 5 minutes: Installing TypeScript'
  id: typescript-tooling-in-5-minutes#installing-typescript
  summary: Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript language support by default but does not include the TypeScript compiler, tsc
  belongs_to: TypeScript Tooling in 5 minutes
  description: |-
    ## Installing TypeScript

    There are two main ways to add TypeScript to your project:

    - Via npm (the Node.js package manager)
    - By installing TypeScript’s Visual Studio plugins

    Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript language support by default but does not include the TypeScript compiler, `tsc`. If you didn’t install TypeScript with Visual Studio, you can still [download it](https://www.typescriptlang.org/download).

    For npm users:

    ``` shell
    > npm install -g typescript
    ```
- name: 'TypeScript Tooling in 5 minutes: Interfaces'
  id: typescript-tooling-in-5-minutes#interfaces
  summary: Let’s develop our sample further
  belongs_to: TypeScript Tooling in 5 minutes
  description: |-
    ## Interfaces

    Let’s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field. In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit `implements` clause.

    ``` ts
    interface Person {
      firstName: string;
      lastName: string;
    }
     
    function greeter(person: Person) {
      return "Hello, " + person.firstName + " " + person.lastName;
    }
     
    let user = { firstName: "Jane", lastName: "User" };
     
    document.body.textContent = greeter(user);
    ```
- name: 'TypeScript Tooling in 5 minutes: Running your TypeScript web app'
  id: typescript-tooling-in-5-minutes#running-your-typescript-web-app
  summary: 'Optional: Open greeter.ts in Visual Studio, or copy the code into the TypeScript playground'
  belongs_to: TypeScript Tooling in 5 minutes
  description: "## Running your TypeScript web app\n\nNow type the following in `greeter.html`:\n\n``` html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>TypeScript Greeter</title>\n  </head>\n  <body>\n    <script src=\"greeter.js\"></script>\n  </body>\n</html>\n```\n\nOpen `greeter.html` in the browser to run your first simple TypeScript web application!\n\nOptional: Open `greeter.ts` in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.\n\nThe type information provided works together with the tools to work with JavaScript at application scale. For more examples of what’s possible in TypeScript, see the Samples section of the website.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html)"
- name: 'TypeScript Tooling in 5 minutes: Type annotations'
  id: typescript-tooling-in-5-minutes#type-annotations
  summary: Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable
  belongs_to: TypeScript Tooling in 5 minutes
  description: |-
    ## Type annotations

    Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:

    ``` ts
    function greeter(person: string) {
      return "Hello, " + person;
    }
     
    let user = [0, 1, 2];
     
    document.body.textContent = greeter(user);
    ```

    Re-compiling, you’ll now see an error:

    ``` shell
    error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.
    ```

    Similarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of arguments. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.

    Notice that although there were errors, the `greeter.js` file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.
- name: useDefineForClassFields
  id: tsconfig/index#useDefineForClassFields-config
  summary: This flag is used as part of migrating to the upcoming standard version of class fields
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Use Define For Class Fields - `useDefineForClassFields`

    This flag is used as part of migrating to the upcoming standard version of class fields. TypeScript introduced class fields many years before it was ratified in TC39. The latest version of the upcoming specification has a different runtime behavior to TypeScript’s implementation but the same syntax.

    This flag switches to the upcoming ECMA runtime behavior.

    You can read more about the transition in [the 3.7 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier).

    - Default:

      `true` if [`target`](#target) is `ES2022` or higher, including `ESNext`; `false` otherwise.

    - Released:

      [3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)

    ## Compiler Diagnostics
- name: useDefineForClassFields
  id: tsconfig#useDefineForClassFields-config
  summary: This flag is used as part of migrating to the upcoming standard version of class fields
  belongs_to: TSConfig Reference
  description: |-
    ### Use Define For Class Fields - `useDefineForClassFields`

    This flag is used as part of migrating to the upcoming standard version of class fields. TypeScript introduced class fields many years before it was ratified in TC39. The latest version of the upcoming specification has a different runtime behavior to TypeScript’s implementation but the same syntax.

    This flag switches to the upcoming ECMA runtime behavior.

    You can read more about the transition in [the 3.7 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier).

    - Default:

      `true` if [`target`](#target) is `ES2022` or higher, including `ESNext`; `false` otherwise.

    - Released:

      [3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)

    ## Compiler Diagnostics
- name: useUnknownInCatchVariables
  id: tsconfig#useUnknownInCatchVariables-config
  summary: In TypeScript 4.0, support was added to allow changing the type of the variable in a catch clause from any to unknown
  belongs_to: TSConfig Reference
  description: |-
    ### Use Unknown In Catch Variables - `useUnknownInCatchVariables`

    In TypeScript 4.0, support was added to allow changing the type of the variable in a catch clause from `any` to `unknown`. Allowing for code like:

    ``` ts
    try {
      // ...
    } catch (err: unknown) {
      // We have to verify err is an
      // error before using it as one.
      if (err instanceof Error) {
        console.log(err.message);
      }
    }
    ```

    This pattern ensures that error handling code becomes more comprehensive because you cannot guarantee that the object being thrown *is* a Error subclass ahead of time. With the flag `useUnknownInCatchVariables` enabled, then you do not need the additional syntax (`: unknown`) nor a linter rule to try enforce this behavior.

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)

    - Released:

      [4.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html)

    ## Modules
- name: useUnknownInCatchVariables
  id: tsconfig/index#useUnknownInCatchVariables-config
  summary: In TypeScript 4.0, support was added to allow changing the type of the variable in a catch clause from any to unknown
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Use Unknown In Catch Variables - `useUnknownInCatchVariables`

    In TypeScript 4.0, support was added to allow changing the type of the variable in a catch clause from `any` to `unknown`. Allowing for code like:

    ``` ts
    try {
      // ...
    } catch (err: unknown) {
      // We have to verify err is an
      // error before using it as one.
      if (err instanceof Error) {
        console.log(err.message);
      }
    }
    ```

    This pattern ensures that error handling code becomes more comprehensive because you cannot guarantee that the object being thrown *is* a Error subclass ahead of time. With the flag `useUnknownInCatchVariables` enabled, then you do not need the additional syntax (`: unknown`) nor a linter rule to try enforce this behavior.

    - Recommended

    - Default:

      `true` if [`strict`](#strict); `false` otherwise.

    - Related:
      - [`strict`](#strict)

    - Released:

      [4.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html)

    ## Modules
- name: Using Babel with TypeScript
  id: babel-with-typescript
  summary: A lot of the time the answer is “it depends”, or “someone may have decided for you” depending on the project
  description: "# Using Babel with TypeScript\n\n## Babel vs `tsc` for TypeScript\n\nWhen making a modern JavaScript project, you might ask yourself what is the right way to convert files from TypeScript to JavaScript?\n\nA lot of the time the answer is *“it depends”*, or *“someone may have decided for you”* depending on the project. If you are building your project with an existing framework like [tsdx](https://tsdx.io), [Angular](https://angular.io/), [NestJS](https://nestjs.com/) or any framework mentioned in the [Getting Started](https://www.typescriptlang.org/docs/home) then this decision is handled for you.\n\nHowever, a useful heuristic could be:\n\n- Is your build output mostly the same as your source input files? Use `tsc`\n- Do you need a build pipeline with multiple potential outputs? Use `babel` for transpiling and `tsc` for type checking\n\n## Babel for transpiling, `tsc` for types\n\nThis is a common pattern for projects with existing build infrastructure which may have been ported from a JavaScript codebase to TypeScript.\n\nThis technique is a hybrid approach, using Babel’s [preset-typescript](https://babeljs.io/docs/en/babel-preset-typescript) to generate your JS files, and then using TypeScript to do type checking and `.d.ts` file generation.\n\nBy using babel’s support for TypeScript, you get the ability to work with existing build pipelines and are more likely to have a faster JS emit time because Babel does not type check your code.\n\n#### Type Checking and d.ts file generation\n\nThe downside to using babel is that you don’t get type checking during the transition from TS to JS. This can mean that type errors which you miss in your editor could sneak through into production code.\n\nIn addition to that, Babel cannot create `.d.ts` files for your TypeScript which can make it harder to work with your project if it is a library.\n\nTo fix these issues, you would probably want to set up a command to type check your project using TSC. This likely means duplicating some of your babel config into a corresponding [`tsconfig.json`](https://www.typescriptlang.org/tsconfig) and ensuring these flags are enabled:\n\n``` typescript\n\"compilerOptions\": {\n  // Ensure that .d.ts files are created by tsc, but not .js files\n  \"declaration\": true,\n  \"emitDeclarationOnly\": true,\n  // Ensure that Babel can safely transpile files in the TypeScript project\n  \"isolatedModules\": true\n}\n```\n\nFor more information on these flags:\n\n- [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules)\n- [`declaration`](https://www.typescriptlang.org/tsconfig#declaration), [`emitDeclarationOnly`](https://www.typescriptlang.org/tsconfig#emitDeclarationOnly)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html](https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html)"
- name: 'Using Babel with TypeScript: Babel for transpiling, tsc for types'
  id: babel-with-typescript#babel-for-transpiling-tsc-for-types
  summary: This is a common pattern for projects with existing build infrastructure which may have been ported from a JavaScript codebase to TypeScript
  belongs_to: Using Babel with TypeScript
  description: "## Babel for transpiling, `tsc` for types\n\nThis is a common pattern for projects with existing build infrastructure which may have been ported from a JavaScript codebase to TypeScript.\n\nThis technique is a hybrid approach, using Babel’s [preset-typescript](https://babeljs.io/docs/en/babel-preset-typescript) to generate your JS files, and then using TypeScript to do type checking and `.d.ts` file generation.\n\nBy using babel’s support for TypeScript, you get the ability to work with existing build pipelines and are more likely to have a faster JS emit time because Babel does not type check your code.\n\n#### Type Checking and d.ts file generation\n\nThe downside to using babel is that you don’t get type checking during the transition from TS to JS. This can mean that type errors which you miss in your editor could sneak through into production code.\n\nIn addition to that, Babel cannot create `.d.ts` files for your TypeScript which can make it harder to work with your project if it is a library.\n\nTo fix these issues, you would probably want to set up a command to type check your project using TSC. This likely means duplicating some of your babel config into a corresponding [`tsconfig.json`](https://www.typescriptlang.org/tsconfig) and ensuring these flags are enabled:\n\n``` typescript\n\"compilerOptions\": {\n  // Ensure that .d.ts files are created by tsc, but not .js files\n  \"declaration\": true,\n  \"emitDeclarationOnly\": true,\n  // Ensure that Babel can safely transpile files in the TypeScript project\n  \"isolatedModules\": true\n}\n```\n\nFor more information on these flags:\n\n- [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules)\n- [`declaration`](https://www.typescriptlang.org/tsconfig#declaration), [`emitDeclarationOnly`](https://www.typescriptlang.org/tsconfig#emitDeclarationOnly)\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html](https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html)"
- name: 'Using Babel with TypeScript: Babel vs tsc for TypeScript'
  id: babel-with-typescript#babel-vs-tsc-for-typescript
  summary: A lot of the time the answer is “it depends”, or “someone may have decided for you” depending on the project
  belongs_to: Using Babel with TypeScript
  description: |-
    ## Babel vs `tsc` for TypeScript

    When making a modern JavaScript project, you might ask yourself what is the right way to convert files from TypeScript to JavaScript?

    A lot of the time the answer is *“it depends”*, or *“someone may have decided for you”* depending on the project. If you are building your project with an existing framework like [tsdx](https://tsdx.io), [Angular](https://angular.io/), [NestJS](https://nestjs.com/) or any framework mentioned in the [Getting Started](https://www.typescriptlang.org/docs/home) then this decision is handled for you.

    However, a useful heuristic could be:

    - Is your build output mostly the same as your source input files? Use `tsc`
    - Do you need a build pipeline with multiple potential outputs? Use `babel` for transpiling and `tsc` for type checking
- name: Utility Types
  id: utility-types
  summary: TypeScript provides several utility types to facilitate common type transformations
  description: "# Utility Types\n\nTypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.\n\n## `Awaited<Type>`\n\n> Released: [4.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#the-awaited-type-and-promise-improvements)\n\nThis type is meant to model operations like `await` in `async` functions, or the `.then()` method on `Promise`s - specifically, the way that they recursively unwrap `Promise`s.\n\n##### Example\n\n``` ts\ntype A = Awaited<Promise<string>>;\n \ntype B = Awaited<Promise<Promise<number>>>;\n \ntype C = Awaited<boolean | Promise<number>>;\n```\n\n## `Partial<Type>`\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs a type with all properties of `Type` set to optional. This utility will return a type that represents all subsets of a given type.\n\n##### Example\n\n``` ts\ninterface Todo {\n  title: string;\n  description: string;\n}\n \nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {\n  return { ...todo, ...fieldsToUpdate };\n}\n \nconst todo1 = {\n  title: \"organize desk\",\n  description: \"clear clutter\",\n};\n \nconst todo2 = updateTodo(todo1, {\n  description: \"throw out trash\",\n});\n```\n\n## `Required<Type>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#improved-control-over-mapped-type-modifiers)\n\nConstructs a type consisting of all properties of `Type` set to required. The opposite of [`Partial`](#partialtype).\n\n##### Example\n\n``` ts\ninterface Props {\n  a?: number;\n  b?: string;\n}\n \nconst obj: Props = { a: 5 };\n \nconst obj2: Required<Props> = { a: 5 };\n```\n\n## `Readonly<Type>`\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs a type with all properties of `Type` set to `readonly`, meaning the properties of the constructed type cannot be reassigned.\n\n##### Example\n\n``` ts\ninterface Todo {\n  title: string;\n}\n \nconst todo: Readonly<Todo> = {\n  title: \"Delete inactive users\",\n};\n \ntodo.title = \"Hello\";\n```\n\nThis utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a [frozen object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)).\n\n##### `Object.freeze`\n\n``` ts\nfunction freeze<Type>(obj: Type): Readonly<Type>;\n```\n\n## `Record<Keys, Type>`\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs an object type whose property keys are `Keys` and whose property values are `Type`. This utility can be used to map the properties of a type to another type.\n\n##### Example\n\n``` ts\ntype CatName = \"miffy\" | \"boris\" | \"mordred\";\n \ninterface CatInfo {\n  age: number;\n  breed: string;\n}\n \nconst cats: Record<CatName, CatInfo> = {\n  miffy: { age: 10, breed: \"Persian\" },\n  boris: { age: 5, breed: \"Maine Coon\" },\n  mordred: { age: 16, breed: \"British Shorthair\" },\n};\n \ncats.boris;\n```\n\n## `Pick<Type, Keys>`\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs a type by picking the set of properties `Keys` (string literal or union of string literals) from `Type`.\n\n##### Example\n\n``` ts\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n}\n \ntype TodoPreview = Pick<Todo, \"title\" | \"completed\">;\n \nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n};\n \ntodo;\n```\n\n## `Omit<Type, Keys>`\n\n> Released:  \n> [3.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type)\n\nConstructs a type by picking all properties from `Type` and then removing `Keys` (string literal or union of string literals). The opposite of [`Pick`](#picktype-keys).\n\n##### Example\n\n``` ts\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt: number;\n}\n \ntype TodoPreview = Omit<Todo, \"description\">;\n \nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n  createdAt: 1615544252770,\n};\n \ntodo;\n \ntype TodoInfo = Omit<Todo, \"completed\" | \"createdAt\">;\n \nconst todoInfo: TodoInfo = {\n  title: \"Pick up kids\",\n  description: \"Kindergarten closes at 5pm\",\n};\n \ntodoInfo;\n```\n\n## `Exclude<UnionType, ExcludedMembers>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type by excluding from `UnionType` all union members that are assignable to `ExcludedMembers`.\n\n##### Example\n\n``` ts\ntype T0 = Exclude<\"a\" | \"b\" | \"c\", \"a\">;\ntype T1 = Exclude<\"a\" | \"b\" | \"c\", \"a\" | \"b\">;\ntype T2 = Exclude<string | number | (() => void), Function>;\n \ntype Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; x: number }\n  | { kind: \"triangle\"; x: number; y: number };\n \ntype T3 = Exclude<Shape, { kind: \"circle\" }>\n```\n\n## `Extract<Type, Union>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type by extracting from `Type` all union members that are assignable to `Union`.\n\n##### Example\n\n``` ts\ntype T0 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">;\ntype T1 = Extract<string | number | (() => void), Function>;\n \ntype Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; x: number }\n  | { kind: \"triangle\"; x: number; y: number };\n \ntype T2 = Extract<Shape, { kind: \"circle\" }>\n```\n\n## `NonNullable<Type>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type by excluding `null` and `undefined` from `Type`.\n\n##### Example\n\n``` ts\ntype T0 = NonNullable<string | number | undefined>;\ntype T1 = NonNullable<string[] | null | undefined>;\n```\n\n## `Parameters<Type>`\n\n> Released:  \n> [3.1](https://github.com/microsoft/TypeScript/pull/26243)\n\nConstructs a tuple type from the types used in the parameters of a function type `Type`.\n\nFor overloaded functions, this will be the parameters of the *last* signature; see [Inferring Within Conditional Types](2/conditional-types#inferring-within-conditional-types).\n\n##### Example\n\n``` ts\ndeclare function f1(arg: { a: number; b: string }): void;\n \ntype T0 = Parameters<() => string>;\ntype T1 = Parameters<(s: string) => void>;\ntype T2 = Parameters<<T>(arg: T) => T>;\ntype T3 = Parameters<typeof f1>;\ntype T4 = Parameters<any>;\ntype T5 = Parameters<never>;\ntype T6 = Parameters<string>;\ntype T7 = Parameters<Function>;\n```\n\n## `ConstructorParameters<Type>`\n\n> Released:  \n> [3.1](https://github.com/microsoft/TypeScript/pull/26243)\n\nConstructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type `never` if `Type` is not a function).\n\n##### Example\n\n``` ts\ntype T0 = ConstructorParameters<ErrorConstructor>;\ntype T1 = ConstructorParameters<FunctionConstructor>;\ntype T2 = ConstructorParameters<RegExpConstructor>;\nclass C {\n  constructor(a: number, b: string) {}\n}\ntype T3 = ConstructorParameters<typeof C>;\ntype T4 = ConstructorParameters<any>;\n \ntype T5 = ConstructorParameters<Function>;\n```\n\n## `ReturnType<Type>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type consisting of the return type of function `Type`.\n\nFor overloaded functions, this will be the return type of the *last* signature; see [Inferring Within Conditional Types](2/conditional-types#inferring-within-conditional-types).\n\n##### Example\n\n``` ts\ndeclare function f1(): { a: number; b: string };\n \ntype T0 = ReturnType<() => string>;\ntype T1 = ReturnType<(s: string) => void>;\ntype T2 = ReturnType<<T>() => T>;\ntype T3 = ReturnType<<T extends U, U extends number[]>() => T>;\ntype T4 = ReturnType<typeof f1>;\ntype T5 = ReturnType<any>;\ntype T6 = ReturnType<never>;\ntype T7 = ReturnType<string>;\ntype T8 = ReturnType<Function>;\n```\n\n## `InstanceType<Type>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type consisting of the instance type of a constructor function in `Type`.\n\n##### Example\n\n``` ts\nclass C {\n  x = 0;\n  y = 0;\n}\n \ntype T0 = InstanceType<typeof C>;\ntype T1 = InstanceType<any>;\ntype T2 = InstanceType<never>;\ntype T3 = InstanceType<string>;\ntype T4 = InstanceType<Function>;\n```\n\n## `NoInfer<Type>`\n\n> Released:  \n> [5.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#the-noinfer-utility-type)\n\nBlocks inferences to the contained type. Other than blocking inferences, `NoInfer<Type>` is identical to `Type`.\n\n##### Example\n\n``` ts\nfunction createStreetLight<C extends string>(\n  colors: C[],\n  defaultColor?: NoInfer<C>,\n) {\n  // ...\n}\n\ncreateStreetLight([\"red\", \"yellow\", \"green\"], \"red\");  // OK\ncreateStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");  // Error\n```\n\n## `ThisParameterType<Type>`\n\n> Released:  \n> [3.3](https://github.com/microsoft/TypeScript/pull/28920)\n\nExtracts the type of the [this](functions#this-parameters) parameter for a function type, or [unknown](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type) if the function type has no `this` parameter.\n\n##### Example\n\n``` ts\nfunction toHex(this: Number) {\n  return this.toString(16);\n}\n \nfunction numberToString(n: ThisParameterType<typeof toHex>) {\n  return toHex.apply(n);\n}\n```\n\n## `OmitThisParameter<Type>`\n\n> Released:  \n> [3.3](https://github.com/microsoft/TypeScript/pull/28920)\n\nRemoves the [`this`](functions#this-parameters) parameter from `Type`. If `Type` has no explicitly declared `this` parameter, the result is simply `Type`. Otherwise, a new function type with no `this` parameter is created from `Type`. Generics are erased and only the last overload signature is propagated into the new function type.\n\n##### Example\n\n``` ts\nfunction toHex(this: Number) {\n  return this.toString(16);\n}\n \nconst fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5);\n \nconsole.log(fiveToHex());\n```\n\n## `ThisType<Type>`\n\n> Released:  \n> [2.3](https://github.com/microsoft/TypeScript/pull/14141)\n\nThis utility does not return a transformed type. Instead, it serves as a marker for a contextual [`this`](functions#this) type. Note that the [`noImplicitThis`](https://www.typescriptlang.org/tsconfig#noImplicitThis) flag must be enabled to use this utility.\n\n##### Example\n\n``` ts\ntype ObjectDescriptor<D, M> = {\n  data?: D;\n  methods?: M & ThisType<D & M>; // Type of 'this' in methods is D & M\n};\n \nfunction makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {\n  let data: object = desc.data || {};\n  let methods: object = desc.methods || {};\n  return { ...data, ...methods } as D & M;\n}\n \nlet obj = makeObject({\n  data: { x: 0, y: 0 },\n  methods: {\n    moveBy(dx: number, dy: number) {\n      this.x += dx; // Strongly typed this\n      this.y += dy; // Strongly typed this\n    },\n  },\n});\n \nobj.x = 10;\nobj.y = 20;\nobj.moveBy(5, 5);\n```\n\nIn the example above, the `methods` object in the argument to `makeObject` has a contextual type that includes `ThisType<D & M>` and therefore the type of [this](functions#this) in methods within the `methods` object is `{ x: number, y: number } & { moveBy(dx: number, dy: number): void }`. Notice how the type of the `methods` property simultaneously is an inference target and a source for the `this` type in methods.\n\nThe `ThisType<T>` marker interface is simply an empty interface declared in `lib.d.ts`. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.\n\n## Intrinsic String Manipulation Types\n\n### `Uppercase<StringType>`\n\n### `Lowercase<StringType>`\n\n### `Capitalize<StringType>`\n\n### `Uncapitalize<StringType>`\n\nTo help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can find those in the [Template Literal Types](2/template-literal-types#uppercasestringtype) documentation.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html)"
- name: 'Utility Types: Awaited<Type>'
  id: utility-types#awaitedtype
  summary: This type is meant to model operations like await in async functions, or the .then() method on Promises - specifically, the way that they recursively unwrap Promises
  belongs_to: Utility Types
  description: |-
    ## `Awaited<Type>`

    > Released: [4.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#the-awaited-type-and-promise-improvements)

    This type is meant to model operations like `await` in `async` functions, or the `.then()` method on `Promise`s - specifically, the way that they recursively unwrap `Promise`s.

    ##### Example

    ``` ts
    type A = Awaited<Promise<string>>;
     
    type B = Awaited<Promise<Promise<number>>>;
     
    type C = Awaited<boolean | Promise<number>>;
    ```
- name: 'Utility Types: Capitalize<StringType>'
  id: utility-types#capitalizestringtype
  summary: null
  belongs_to: Utility Types
  description: '### `Capitalize<StringType>`'
- name: 'Utility Types: ConstructorParameters<Type>'
  id: utility-types#constructorparameterstype
  summary: Constructs a tuple or array type from the types of a constructor function type
  belongs_to: Utility Types
  description: "## `ConstructorParameters<Type>`\n\n> Released:  \n> [3.1](https://github.com/microsoft/TypeScript/pull/26243)\n\nConstructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type `never` if `Type` is not a function).\n\n##### Example\n\n``` ts\ntype T0 = ConstructorParameters<ErrorConstructor>;\ntype T1 = ConstructorParameters<FunctionConstructor>;\ntype T2 = ConstructorParameters<RegExpConstructor>;\nclass C {\n  constructor(a: number, b: string) {}\n}\ntype T3 = ConstructorParameters<typeof C>;\ntype T4 = ConstructorParameters<any>;\n \ntype T5 = ConstructorParameters<Function>;\n```"
- name: 'Utility Types: Exclude<UnionType, ExcludedMembers>'
  id: utility-types#excludeuniontype-excludedmembers
  summary: Constructs a type by excluding from UnionType all union members that are assignable to ExcludedMembers
  belongs_to: Utility Types
  description: "## `Exclude<UnionType, ExcludedMembers>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type by excluding from `UnionType` all union members that are assignable to `ExcludedMembers`.\n\n##### Example\n\n``` ts\ntype T0 = Exclude<\"a\" | \"b\" | \"c\", \"a\">;\ntype T1 = Exclude<\"a\" | \"b\" | \"c\", \"a\" | \"b\">;\ntype T2 = Exclude<string | number | (() => void), Function>;\n \ntype Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; x: number }\n  | { kind: \"triangle\"; x: number; y: number };\n \ntype T3 = Exclude<Shape, { kind: \"circle\" }>\n```"
- name: 'Utility Types: Extract<Type, Union>'
  id: utility-types#extracttype-union
  summary: Constructs a type by extracting from Type all union members that are assignable to Union
  belongs_to: Utility Types
  description: "## `Extract<Type, Union>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type by extracting from `Type` all union members that are assignable to `Union`.\n\n##### Example\n\n``` ts\ntype T0 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">;\ntype T1 = Extract<string | number | (() => void), Function>;\n \ntype Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; x: number }\n  | { kind: \"triangle\"; x: number; y: number };\n \ntype T2 = Extract<Shape, { kind: \"circle\" }>\n```"
- name: 'Utility Types: InstanceType<Type>'
  id: utility-types#instancetypetype
  summary: Constructs a type consisting of the instance type of a constructor function in Type
  belongs_to: Utility Types
  description: "## `InstanceType<Type>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type consisting of the instance type of a constructor function in `Type`.\n\n##### Example\n\n``` ts\nclass C {\n  x = 0;\n  y = 0;\n}\n \ntype T0 = InstanceType<typeof C>;\ntype T1 = InstanceType<any>;\ntype T2 = InstanceType<never>;\ntype T3 = InstanceType<string>;\ntype T4 = InstanceType<Function>;\n```"
- name: 'Utility Types: Intrinsic String Manipulation Types'
  id: utility-types#intrinsic-string-manipulation-types
  summary: null
  belongs_to: Utility Types
  description: '## Intrinsic String Manipulation Types'
- name: 'Utility Types: Lowercase<StringType>'
  id: utility-types#lowercasestringtype
  summary: null
  belongs_to: Utility Types
  description: '### `Lowercase<StringType>`'
- name: 'Utility Types: NoInfer<Type>'
  id: utility-types#noinfertype
  summary: Blocks inferences to the contained type
  belongs_to: Utility Types
  description: "## `NoInfer<Type>`\n\n> Released:  \n> [5.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#the-noinfer-utility-type)\n\nBlocks inferences to the contained type. Other than blocking inferences, `NoInfer<Type>` is identical to `Type`.\n\n##### Example\n\n``` ts\nfunction createStreetLight<C extends string>(\n  colors: C[],\n  defaultColor?: NoInfer<C>,\n) {\n  // ...\n}\n\ncreateStreetLight([\"red\", \"yellow\", \"green\"], \"red\");  // OK\ncreateStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");  // Error\n```"
- name: 'Utility Types: NonNullable<Type>'
  id: utility-types#nonnullabletype
  summary: Constructs a type by excluding null and undefined from Type
  belongs_to: Utility Types
  description: "## `NonNullable<Type>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type by excluding `null` and `undefined` from `Type`.\n\n##### Example\n\n``` ts\ntype T0 = NonNullable<string | number | undefined>;\ntype T1 = NonNullable<string[] | null | undefined>;\n```"
- name: 'Utility Types: Omit<Type, Keys>'
  id: utility-types#omittype-keys
  summary: Constructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals). The opposite of Pick
  belongs_to: Utility Types
  description: "## `Omit<Type, Keys>`\n\n> Released:  \n> [3.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type)\n\nConstructs a type by picking all properties from `Type` and then removing `Keys` (string literal or union of string literals). The opposite of [`Pick`](#picktype-keys).\n\n##### Example\n\n``` ts\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt: number;\n}\n \ntype TodoPreview = Omit<Todo, \"description\">;\n \nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n  createdAt: 1615544252770,\n};\n \ntodo;\n \ntype TodoInfo = Omit<Todo, \"completed\" | \"createdAt\">;\n \nconst todoInfo: TodoInfo = {\n  title: \"Pick up kids\",\n  description: \"Kindergarten closes at 5pm\",\n};\n \ntodoInfo;\n```"
- name: 'Utility Types: OmitThisParameter<Type>'
  id: utility-types#omitthisparametertype
  summary: Removes the this parameter from Type
  belongs_to: Utility Types
  description: "## `OmitThisParameter<Type>`\n\n> Released:  \n> [3.3](https://github.com/microsoft/TypeScript/pull/28920)\n\nRemoves the [`this`](functions#this-parameters) parameter from `Type`. If `Type` has no explicitly declared `this` parameter, the result is simply `Type`. Otherwise, a new function type with no `this` parameter is created from `Type`. Generics are erased and only the last overload signature is propagated into the new function type.\n\n##### Example\n\n``` ts\nfunction toHex(this: Number) {\n  return this.toString(16);\n}\n \nconst fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5);\n \nconsole.log(fiveToHex());\n```"
- name: 'Utility Types: Parameters<Type>'
  id: utility-types#parameterstype
  summary: Constructs a tuple type from the types used in the parameters of a function type Type
  belongs_to: Utility Types
  description: "## `Parameters<Type>`\n\n> Released:  \n> [3.1](https://github.com/microsoft/TypeScript/pull/26243)\n\nConstructs a tuple type from the types used in the parameters of a function type `Type`.\n\nFor overloaded functions, this will be the parameters of the *last* signature; see [Inferring Within Conditional Types](2/conditional-types#inferring-within-conditional-types).\n\n##### Example\n\n``` ts\ndeclare function f1(arg: { a: number; b: string }): void;\n \ntype T0 = Parameters<() => string>;\ntype T1 = Parameters<(s: string) => void>;\ntype T2 = Parameters<<T>(arg: T) => T>;\ntype T3 = Parameters<typeof f1>;\ntype T4 = Parameters<any>;\ntype T5 = Parameters<never>;\ntype T6 = Parameters<string>;\ntype T7 = Parameters<Function>;\n```"
- name: 'Utility Types: Partial<Type>'
  id: utility-types#partialtype
  summary: Constructs a type with all properties of Type set to optional
  belongs_to: Utility Types
  description: "## `Partial<Type>`\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs a type with all properties of `Type` set to optional. This utility will return a type that represents all subsets of a given type.\n\n##### Example\n\n``` ts\ninterface Todo {\n  title: string;\n  description: string;\n}\n \nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {\n  return { ...todo, ...fieldsToUpdate };\n}\n \nconst todo1 = {\n  title: \"organize desk\",\n  description: \"clear clutter\",\n};\n \nconst todo2 = updateTodo(todo1, {\n  description: \"throw out trash\",\n});\n```"
- name: 'Utility Types: Pick<Type, Keys>'
  id: utility-types#picktype-keys
  summary: Constructs a type by picking the set of properties Keys (string literal or union of string literals) from Type
  belongs_to: Utility Types
  description: "## `Pick<Type, Keys>`\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs a type by picking the set of properties `Keys` (string literal or union of string literals) from `Type`.\n\n##### Example\n\n``` ts\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n}\n \ntype TodoPreview = Pick<Todo, \"title\" | \"completed\">;\n \nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n};\n \ntodo;\n```"
- name: 'Utility Types: Readonly<Type>'
  id: utility-types#readonlytype
  summary: Constructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned
  belongs_to: Utility Types
  description: "## `Readonly<Type>`\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs a type with all properties of `Type` set to `readonly`, meaning the properties of the constructed type cannot be reassigned.\n\n##### Example\n\n``` ts\ninterface Todo {\n  title: string;\n}\n \nconst todo: Readonly<Todo> = {\n  title: \"Delete inactive users\",\n};\n \ntodo.title = \"Hello\";\n```\n\nThis utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a [frozen object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)).\n\n##### `Object.freeze`\n\n``` ts\nfunction freeze<Type>(obj: Type): Readonly<Type>;\n```"
- name: 'Utility Types: Record<Keys, Type>'
  id: utility-types#recordkeys-type
  summary: Constructs an object type whose property keys are Keys and whose property values are Type
  belongs_to: Utility Types
  description: "## `Record<Keys, Type>`\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs an object type whose property keys are `Keys` and whose property values are `Type`. This utility can be used to map the properties of a type to another type.\n\n##### Example\n\n``` ts\ntype CatName = \"miffy\" | \"boris\" | \"mordred\";\n \ninterface CatInfo {\n  age: number;\n  breed: string;\n}\n \nconst cats: Record<CatName, CatInfo> = {\n  miffy: { age: 10, breed: \"Persian\" },\n  boris: { age: 5, breed: \"Maine Coon\" },\n  mordred: { age: 16, breed: \"British Shorthair\" },\n};\n \ncats.boris;\n```"
- name: 'Utility Types: Required<Type>'
  id: utility-types#requiredtype
  summary: Constructs a type consisting of all properties of Type set to required
  belongs_to: Utility Types
  description: "## `Required<Type>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#improved-control-over-mapped-type-modifiers)\n\nConstructs a type consisting of all properties of `Type` set to required. The opposite of [`Partial`](#partialtype).\n\n##### Example\n\n``` ts\ninterface Props {\n  a?: number;\n  b?: string;\n}\n \nconst obj: Props = { a: 5 };\n \nconst obj2: Required<Props> = { a: 5 };\n```"
- name: 'Utility Types: ReturnType<Type>'
  id: utility-types#returntypetype
  summary: Constructs a type consisting of the return type of function Type
  belongs_to: Utility Types
  description: "## `ReturnType<Type>`\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type consisting of the return type of function `Type`.\n\nFor overloaded functions, this will be the return type of the *last* signature; see [Inferring Within Conditional Types](2/conditional-types#inferring-within-conditional-types).\n\n##### Example\n\n``` ts\ndeclare function f1(): { a: number; b: string };\n \ntype T0 = ReturnType<() => string>;\ntype T1 = ReturnType<(s: string) => void>;\ntype T2 = ReturnType<<T>() => T>;\ntype T3 = ReturnType<<T extends U, U extends number[]>() => T>;\ntype T4 = ReturnType<typeof f1>;\ntype T5 = ReturnType<any>;\ntype T6 = ReturnType<never>;\ntype T7 = ReturnType<string>;\ntype T8 = ReturnType<Function>;\n```"
- name: 'Utility Types: ThisParameterType<Type>'
  id: utility-types#thisparametertypetype
  summary: Extracts the type of the this parameter for a function type, or unknown if the function type has no this parameter
  belongs_to: Utility Types
  description: "## `ThisParameterType<Type>`\n\n> Released:  \n> [3.3](https://github.com/microsoft/TypeScript/pull/28920)\n\nExtracts the type of the [this](functions#this-parameters) parameter for a function type, or [unknown](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type) if the function type has no `this` parameter.\n\n##### Example\n\n``` ts\nfunction toHex(this: Number) {\n  return this.toString(16);\n}\n \nfunction numberToString(n: ThisParameterType<typeof toHex>) {\n  return toHex.apply(n);\n}\n```"
- name: 'Utility Types: ThisType<Type>'
  id: utility-types#thistypetype
  summary: This utility does not return a transformed type
  belongs_to: Utility Types
  description: "## `ThisType<Type>`\n\n> Released:  \n> [2.3](https://github.com/microsoft/TypeScript/pull/14141)\n\nThis utility does not return a transformed type. Instead, it serves as a marker for a contextual [`this`](functions#this) type. Note that the [`noImplicitThis`](https://www.typescriptlang.org/tsconfig#noImplicitThis) flag must be enabled to use this utility.\n\n##### Example\n\n``` ts\ntype ObjectDescriptor<D, M> = {\n  data?: D;\n  methods?: M & ThisType<D & M>; // Type of 'this' in methods is D & M\n};\n \nfunction makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {\n  let data: object = desc.data || {};\n  let methods: object = desc.methods || {};\n  return { ...data, ...methods } as D & M;\n}\n \nlet obj = makeObject({\n  data: { x: 0, y: 0 },\n  methods: {\n    moveBy(dx: number, dy: number) {\n      this.x += dx; // Strongly typed this\n      this.y += dy; // Strongly typed this\n    },\n  },\n});\n \nobj.x = 10;\nobj.y = 20;\nobj.moveBy(5, 5);\n```\n\nIn the example above, the `methods` object in the argument to `makeObject` has a contextual type that includes `ThisType<D & M>` and therefore the type of [this](functions#this) in methods within the `methods` object is `{ x: number, y: number } & { moveBy(dx: number, dy: number): void }`. Notice how the type of the `methods` property simultaneously is an inference target and a source for the `this` type in methods.\n\nThe `ThisType<T>` marker interface is simply an empty interface declared in `lib.d.ts`. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface."
- name: 'Utility Types: Uncapitalize<StringType>'
  id: utility-types#uncapitalizestringtype
  summary: To help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system
  belongs_to: Utility Types
  description: "### `Uncapitalize<StringType>`\n\nTo help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can find those in the [Template Literal Types](2/template-literal-types#uppercasestringtype) documentation.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html)"
- name: 'Utility Types: Uppercase<StringType>'
  id: utility-types#uppercasestringtype
  summary: null
  belongs_to: Utility Types
  description: '### `Uppercase<StringType>`'
- name: Variable Declaration
  id: variable-declarations
  summary: let and const are two relatively new concepts for variable declarations in JavaScript
  description: "# Variable Declaration\n\n`let` and `const` are two relatively new concepts for variable declarations in JavaScript. [As we mentioned earlier](basic-types#a-note-about-let), `let` is similar to `var` in some respects, but allows users to avoid some of the common “gotchas” that users run into in JavaScript.\n\n`const` is an augmentation of `let` in that it prevents re-assignment to a variable.\n\nWith TypeScript being an extension of JavaScript, the language naturally supports `let` and `const`. Here we’ll elaborate more on these new declarations and why they’re preferable to `var`.\n\nIf you’ve used JavaScript offhandedly, the next section might be a good way to refresh your memory. If you’re intimately familiar with all the quirks of `var` declarations in JavaScript, you might find it easier to skip ahead.\n\n## `var` declarations\n\nDeclaring a variable in JavaScript has always traditionally been done with the `var` keyword.\n\n``` ts\nvar a = 10;\n```\n\nAs you might’ve figured out, we just declared a variable named `a` with the value `10`.\n\nWe can also declare a variable inside of a function:\n\n``` ts\nfunction f() {\n  var message = \"Hello, world!\";\n\n  return message;\n}\n```\n\nand we can also access those same variables within other functions:\n\n``` ts\nfunction f() {\n  var a = 10;\n  return function g() {\n    var b = a + 1;\n    return b;\n  };\n}\n\nvar g = f();\ng(); // returns '11'\n```\n\nIn this above example, `g` captured the variable `a` declared in `f`. At any point that `g` gets called, the value of `a` will be tied to the value of `a` in `f`. Even if `g` is called once `f` is done running, it will be able to access and modify `a`.\n\n``` ts\nfunction f() {\n  var a = 1;\n\n  a = 2;\n  var b = g();\n  a = 3;\n\n  return b;\n\n  function g() {\n    return a;\n  }\n}\n\nf(); // returns '2'\n```\n\n### Scoping rules\n\n`var` declarations have some odd scoping rules for those used to other languages. Take the following example:\n\n``` ts\nfunction f(shouldInitialize: boolean) {\n  if (shouldInitialize) {\n    var x = 10;\n  }\n\n  return x;\n}\n\nf(true); // returns '10'\nf(false); // returns 'undefined'\n```\n\nSome readers might do a double-take at this example. The variable `x` was declared *within the `if` block*, and yet we were able to access it from outside that block. That’s because `var` declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we’ll go over later on - regardless of the containing block. Some people call this *`var`-scoping* or *function-scoping*. Parameters are also function scoped.\n\nThese scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:\n\n``` ts\nfunction sumMatrix(matrix: number[][]) {\n  var sum = 0;\n  for (var i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i];\n    for (var i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i];\n    }\n  }\n\n  return sum;\n}\n```\n\nMaybe it was easy to spot out for some experienced JavaScript developers, but the inner `for`-loop will accidentally overwrite the variable `i` because `i` refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.\n\n### Variable capturing quirks\n\nTake a quick second to guess what the output of the following snippet is:\n\n``` ts\nfor (var i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100 * i);\n}\n```\n\nFor those unfamiliar, `setTimeout` will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running).\n\nReady? Take a look:\n\n``` typescript\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n```\n\nMany JavaScript developers are intimately familiar with this behavior, but if you’re surprised, you’re certainly not alone. Most people expect the output to be\n\n``` typescript\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\nRemember what we mentioned earlier about variable capturing? Every function expression we pass to `setTimeout` actually refers to the same `i` from the same scope.\n\nLet’s take a minute to consider what that means. `setTimeout` will run a function after some number of milliseconds, *but only* after the `for` loop has stopped executing; By the time the `for` loop has stopped executing, the value of `i` is `10`. So each time the given function gets called, it will print out `10`!\n\nA common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture `i` at each iteration:\n\n``` ts\nfor (var i = 0; i < 10; i++) {\n  // capture the current state of 'i'\n  // by invoking a function with its current value\n  (function (i) {\n    setTimeout(function () {\n      console.log(i);\n    }, 100 * i);\n  })(i);\n}\n```\n\nThis odd-looking pattern is actually pretty common. The `i` in the parameter list actually shadows the `i` declared in the `for` loop, but since we named them the same, we didn’t have to modify the loop body too much.\n\n## `let` declarations\n\nBy now you’ve figured out that `var` has some problems, which is precisely why `let` statements were introduced. Apart from the keyword used, `let` statements are written the same way `var` statements are.\n\n``` ts\nlet hello = \"Hello!\";\n```\n\nThe key difference is not in the syntax, but in the semantics, which we’ll now dive into.\n\n### Block-scoping\n\nWhen a variable is declared using `let`, it uses what some call *lexical-scoping* or *block-scoping*. Unlike variables declared with `var` whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block or `for`-loop.\n\n``` ts\nfunction f(input: boolean) {\n  let a = 100;\n\n  if (input) {\n    // Still okay to reference 'a'\n    let b = a + 1;\n    return b;\n  }\n\n  // Error: 'b' doesn't exist here\n  return b;\n}\n```\n\nHere, we have two local variables `a` and `b`. `a`’s scope is limited to the body of `f` while `b`’s scope is limited to the containing `if` statement’s block.\n\nVariables declared in a `catch` clause also have similar scoping rules.\n\n``` ts\ntry {\n  throw \"oh no!\";\n} catch (e) {\n  console.log(\"Oh well.\");\n}\n\n// Error: 'e' doesn't exist here\nconsole.log(e);\n```\n\nAnother property of block-scoped variables is that they can’t be read or written to before they’re actually declared. While these variables are “present” throughout their scope, all points up until their declaration are part of their *temporal dead zone*. This is just a sophisticated way of saying you can’t access them before the `let` statement, and luckily TypeScript will let you know that.\n\n``` ts\na++; // illegal to use 'a' before it's declared;\nlet a;\n```\n\nSomething to note is that you can still *capture* a block-scoped variable before it’s declared. The only catch is that it’s illegal to call that function before the declaration. If targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won’t report this as an error.\n\n``` ts\nfunction foo() {\n  // okay to capture 'a'\n  return a;\n}\n\n// illegal call 'foo' before 'a' is declared\n// runtimes should throw an error here\nfoo();\n\nlet a;\n```\n\nFor more information on temporal dead zones, see relevant content on the [Mozilla Developer Network](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let).\n\n### Re-declarations and Shadowing\n\nWith `var` declarations, we mentioned that it didn’t matter how many times you declared your variables; you just got one.\n\n``` ts\nfunction f(x) {\n  var x;\n  var x;\n\n  if (true) {\n    var x;\n  }\n}\n```\n\nIn the above example, all declarations of `x` actually refer to the *same* `x`, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, `let` declarations are not as forgiving.\n\n``` ts\nlet x = 10;\nlet x = 20; // error: can't re-declare 'x' in the same scope\n```\n\nThe variables don’t necessarily need to both be block-scoped for TypeScript to tell us that there’s a problem.\n\n``` ts\nfunction f(x) {\n  let x = 100; // error: interferes with parameter declaration\n}\n\nfunction g() {\n  let x = 100;\n  var x = 100; // error: can't have both declarations of 'x'\n}\n```\n\nThat’s not to say that a block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.\n\n``` ts\nfunction f(condition, x) {\n  if (condition) {\n    let x = 100;\n    return x;\n  }\n\n  return x;\n}\n\nf(false, 0); // returns '0'\nf(true, 0); // returns '100'\n```\n\nThe act of introducing a new name in a more nested scope is called *shadowing*. It is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs. For instance, imagine we had written our earlier `sumMatrix` function using `let` variables.\n\n``` ts\nfunction sumMatrix(matrix: number[][]) {\n  let sum = 0;\n  for (let i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i];\n    for (let i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i];\n    }\n  }\n\n  return sum;\n}\n```\n\nThis version of the loop will actually perform the summation correctly because the inner loop’s `i` shadows `i` from the outer loop.\n\nShadowing should *usually* be avoided in the interest of writing clearer code. While there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement.\n\n### Block-scoped variable capturing\n\nWhen we first touched on the idea of variable capturing with `var` declaration, we briefly went into how variables act once captured. To give a better intuition of this, each time a scope is run, it creates an “environment” of variables. That environment and its captured variables can exist even after everything within its scope has finished executing.\n\n``` ts\nfunction theCityThatAlwaysSleeps() {\n  let getCity;\n\n  if (true) {\n    let city = \"Seattle\";\n    getCity = function () {\n      return city;\n    };\n  }\n\n  return getCity();\n}\n```\n\nBecause we’ve captured `city` from within its environment, we’re still able to access it despite the fact that the `if` block finished executing.\n\nRecall that with our earlier `setTimeout` example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the `for` loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you’ll never have to do that again in TypeScript.\n\n`let` declarations have drastically different behavior when declared as part of a loop. Rather than just introducing a new environment to the loop itself, these declarations sort of create a new scope *per iteration*. Since this is what we were doing anyway with our IIFE, we can change our old `setTimeout` example to just use a `let` declaration.\n\n``` ts\nfor (let i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100 * i);\n}\n```\n\nand as expected, this will print out\n\n``` typescript\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n## `const` declarations\n\n`const` declarations are another way of declaring variables.\n\n``` ts\nconst numLivesForCat = 9;\n```\n\nThey are like `let` declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as `let`, but you can’t re-assign to them.\n\nThis should not be confused with the idea that the values they refer to are *immutable*.\n\n``` ts\nconst numLivesForCat = 9;\nconst kitty = {\n  name: \"Aurora\",\n  numLives: numLivesForCat,\n};\n\n// Error\nkitty = {\n  name: \"Danielle\",\n  numLives: numLivesForCat,\n};\n\n// all \"okay\"\nkitty.name = \"Rory\";\nkitty.name = \"Kitty\";\nkitty.name = \"Cat\";\nkitty.numLives--;\n```\n\nUnless you take specific measures to avoid it, the internal state of a `const` variable is still modifiable. Fortunately, TypeScript allows you to specify that members of an object are `readonly`. The [chapter on Interfaces](interfaces) has the details.\n\n## `let` vs. `const`\n\nGiven that we have two types of declarations with similar scoping semantics, it’s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.\n\nApplying the [principle of least privilege](https://wikipedia.org/wiki/Principle_of_least_privilege), all declarations other than those you plan to modify should use `const`. The rationale is that if a variable didn’t need to get written to, others working on the same codebase shouldn’t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using `const` also makes code more predictable when reasoning about flow of data.\n\nUse your best judgement, and if applicable, consult the matter with the rest of your team.\n\nThe majority of this handbook uses `let` declarations.\n\n## Destructuring\n\nAnother ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see [the article on the Mozilla Developer Network](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment). In this section, we’ll give a short overview.\n\n### Array destructuring\n\nThe simplest form of destructuring is array destructuring assignment:\n\n``` ts\nlet input = [1, 2];\nlet [first, second] = input;\nconsole.log(first); // outputs 1\nconsole.log(second); // outputs 2\n```\n\nThis creates two new variables named `first` and `second`. This is equivalent to using indexing, but is much more convenient:\n\n``` ts\nfirst = input[0];\nsecond = input[1];\n```\n\nDestructuring works with already-declared variables as well:\n\n``` ts\n// swap variables\n[first, second] = [second, first];\n```\n\nAnd with parameters to a function:\n\n``` ts\nfunction f([first, second]: [number, number]) {\n  console.log(first);\n  console.log(second);\n}\nf([1, 2]);\n```\n\nYou can create a variable for the remaining items in a list using the syntax `...`:\n\n``` ts\nlet [first, ...rest] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\nconsole.log(rest); // outputs [ 2, 3, 4 ]\n```\n\nOf course, since this is JavaScript, you can just ignore trailing elements you don’t care about:\n\n``` ts\nlet [first] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\n```\n\nOr other elements:\n\n``` ts\nlet [, second, , fourth] = [1, 2, 3, 4];\nconsole.log(second); // outputs 2\nconsole.log(fourth); // outputs 4\n```\n\n### Tuple destructuring\n\nTuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:\n\n``` ts\nlet tuple: [number, string, boolean] = [7, \"hello\", true];\n\nlet [a, b, c] = tuple; // a: number, b: string, c: boolean\n```\n\nIt’s an error to destructure a tuple beyond the range of its elements:\n\n``` ts\nlet [a, b, c, d] = tuple; // Error, no element at index 3\n```\n\nAs with arrays, you can destructure the rest of the tuple with `...`, to get a shorter tuple:\n\n``` ts\nlet [a, ...bc] = tuple; // bc: [string, boolean]\nlet [a, b, c, ...d] = tuple; // d: [], the empty tuple\n```\n\nOr ignore trailing elements, or other elements:\n\n``` ts\nlet [a] = tuple; // a: number\nlet [, b] = tuple; // b: string\n```\n\n### Object destructuring\n\nYou can also destructure objects:\n\n``` ts\nlet o = {\n  a: \"foo\",\n  b: 12,\n  c: \"bar\",\n};\nlet { a, b } = o;\n```\n\nThis creates new variables `a` and `b` from `o.a` and `o.b`. Notice that you can skip `c` if you don’t need it.\n\nLike array destructuring, you can have assignment without declaration:\n\n``` ts\n({ a, b } = { a: \"baz\", b: 101 });\n```\n\nNotice that we had to surround this statement with parentheses. JavaScript normally parses a `{` as the start of block.\n\nYou can create a variable for the remaining items in an object using the syntax `...`:\n\n``` ts\nlet { a, ...passthrough } = o;\nlet total = passthrough.b + passthrough.c.length;\n```\n\n#### Property renaming\n\nYou can also give different names to properties:\n\n``` ts\nlet { a: newName1, b: newName2 } = o;\n```\n\nHere the syntax starts to get confusing. You can read `a: newName1` as ”`a` as `newName1`”. The direction is left-to-right, as if you had written:\n\n``` ts\nlet newName1 = o.a;\nlet newName2 = o.b;\n```\n\nConfusingly, the colon here does *not* indicate the type. The type, if you specify it, still needs to be written after the entire destructuring:\n\n``` ts\nlet { a: newName1, b: newName2 }: { a: string; b: number } = o;\n```\n\n#### Default values\n\nDefault values let you specify a default value in case a property is undefined:\n\n``` ts\nfunction keepWholeObject(wholeObject: { a: string; b?: number }) {\n  let { a, b = 1001 } = wholeObject;\n}\n```\n\nIn this example the `b?` indicates that `b` is optional, so it may be `undefined`. `keepWholeObject` now has a variable for `wholeObject` as well as the properties `a` and `b`, even if `b` is undefined.\n\n## Function declarations\n\nDestructuring also works in function declarations. For simple cases this is straightforward:\n\n``` ts\ntype C = { a: string; b?: number };\nfunction f({ a, b }: C): void {\n  // ...\n}\n```\n\nBut specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky. First of all, you need to remember to put the pattern before the default value.\n\n``` ts\nfunction f({ a = \"\", b = 0 } = {}): void {\n  // ...\n}\nf();\n```\n\n> The snippet above is an example of type inference, explained earlier in the handbook.\n\nThen, you need to remember to give a default for optional properties on the destructured property instead of the main initializer. Remember that `C` was defined with `b` optional:\n\n``` ts\nfunction f({ a, b = 0 } = { a: \"\" }): void {\n  // ...\n}\nf({ a: \"yes\" }); // ok, default b = 0\nf(); // ok, default to { a: \"\" }, which then defaults b = 0\nf({}); // error, 'a' is required if you supply an argument\n```\n\nUse destructuring with care. As the previous example demonstrates, anything but the simplest destructuring expression is confusing. This is especially true with deeply nested destructuring, which gets *really* hard to understand even without piling on renaming, default values, and type annotations. Try to keep destructuring expressions small and simple. You can always write the assignments that destructuring would generate yourself.\n\n## Spread\n\nThe spread operator is the opposite of destructuring. It allows you to spread an array into another array, or an object into another object. For example:\n\n``` ts\nlet first = [1, 2];\nlet second = [3, 4];\nlet bothPlus = [0, ...first, ...second, 5];\n```\n\nThis gives bothPlus the value `[0, 1, 2, 3, 4, 5]`. Spreading creates a shallow copy of `first` and `second`. They are not changed by the spread.\n\nYou can also spread objects:\n\n``` ts\nlet defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { ...defaults, food: \"rich\" };\n```\n\nNow `search` is `{ food: \"rich\", price: \"$$\", ambiance: \"noisy\" }`. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:\n\n``` ts\nlet defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { food: \"rich\", ...defaults };\n```\n\nThen the `food` property in `defaults` overwrites `food: \"rich\"`, which is not what we want in this case.\n\nObject spread also has a couple of other surprising limits. First, it only includes an objects’ [own, enumerable properties](https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties). Basically, that means you lose methods when you spread instances of an object:\n\n``` ts\nclass C {\n  p = 12;\n  m() {}\n}\nlet c = new C();\nlet clone = { ...c };\nclone.p; // ok\nclone.m(); // error!\n```\n\nSecond, the TypeScript compiler doesn’t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.\n\n## `using` declarations\n\n`using` declarations are an upcoming feature for JavaScript that are part of the [Stage 3 Explicit Resource Management](https://github.com/tc39/proposal-explicit-resource-management) proposal. A `using` declaration is much like a `const` declaration, except that it couples the *lifetime* of the value bound to the declaration with the *scope* of the variable.\n\nWhen control exits the block containing a `using` declaration, the `[Symbol.dispose]()` method of the declared value is executed, which allows that value to perform cleanup:\n\n``` ts\nfunction f() {\n  using x = new C();\n  doSomethingWith(x);\n} // `x[Symbol.dispose]()` is called\n```\n\nAt runtime, this has an effect *roughly* equivalent to the following:\n\n``` ts\nfunction f() {\n  const x = new C();\n  try {\n    doSomethingWith(x);\n  }\n  finally {\n    x[Symbol.dispose]();\n  }\n}\n```\n\n`using` declarations are extremely useful for avoiding memory leaks when working with JavaScript objects that hold on to native references like file handles\n\n``` ts\n{\n  using file = await openFile();\n  file.write(text);\n  doSomethingThatMayThrow();\n} // `file` is disposed, even if an error is thrown\n```\n\nor scoped operations like tracing\n\n``` ts\nfunction f() {\n  using activity = new TraceActivity(\"f\"); // traces entry into function\n  // ...\n} // traces exit of function\n```\n\nUnlike `var`, `let`, and `const`, `using` declarations do not support destructuring.\n\n### `null` and `undefined`\n\nIt’s important to note that the value can be `null` or `undefined`, in which case nothing is disposed at the end of the block:\n\n``` ts\n{\n  using x = b ? new C() : null;\n  // ...\n}\n```\n\nwhich is *roughly* equivalent to:\n\n``` ts\n{\n  const x = b ? new C() : null;\n  try {\n    // ...\n  }\n  finally {\n    x?.[Symbol.dispose]();\n  }\n}\n```\n\nThis allows you to conditionally acquire resources when declaring a `using` declaration without the need for complex branching or repetition.\n\n### Defining a disposable resource\n\nYou can indicate the classes or objects you produce are disposable by implementing the `Disposable` interface:\n\n``` ts\n// from the default lib:\ninterface Disposable {\n  [Symbol.dispose](): void;\n}\n\n// usage:\nclass TraceActivity implements Disposable {\n  readonly name: string;\n  constructor(name: string) {\n    this.name = name;\n    console.log(`Entering: ${name}`);\n  }\n\n  [Symbol.dispose](): void {\n    console.log(`Exiting: ${name}`);\n  }\n}\n\nfunction f() {\n  using _activity = new TraceActivity(\"f\");\n  console.log(\"Hello world!\");\n}\n\nf();\n// prints:\n//   Entering: f\n//   Hello world!\n//   Exiting: f\n```\n\n## `await using` declarations\n\nSome resources or operations may have cleanup that needs to be performed asynchronously. To accommodate this, the [Explicit Resource Management](https://github.com/tc39/proposal-explicit-resource-management) proposal also introduces the `await using` declaration:\n\n``` ts\nasync function f() {\n  await using x = new C();\n} // `await x[Symbol.asyncDispose]()` is invoked\n```\n\nAn `await using` declaration invokes, and *awaits*, its value’s `[Symbol.asyncDispose]()` method as control leaves the containing block. This allows for asynchronous cleanup, such as a database transaction performing a rollback or commit, or a file stream flushing any pending writes to storage before it is closed.\n\nAs with `await`, `await using` can only be used in an `async` function or method, or at the top level of a module.\n\n### Defining an asynchronously disposable resource\n\nJust as `using` relies on objects that are `Disposable`, an `await using` relies on objects that are `AsyncDisposable`:\n\n``` ts\n// from the default lib:\ninterface AsyncDisposable {\n  [Symbol.asyncDispose]: PromiseLike<void>;\n}\n\n// usage:\nclass DatabaseTransaction implements AsyncDisposable {\n  public success = false;\n  private db: Database | undefined;\n\n  private constructor(db: Database) {\n    this.db = db;\n  }\n\n  static async create(db: Database) {\n    await db.execAsync(\"BEGIN TRANSACTION\");\n    return new DatabaseTransaction(db);\n  }\n\n  async [Symbol.asyncDispose]() {\n    if (this.db) {\n      const db = this.db:\n      this.db = undefined;\n      if (this.success) {\n        await db.execAsync(\"COMMIT TRANSACTION\");\n      }\n      else {\n        await db.execAsync(\"ROLLBACK TRANSACTION\");\n      }\n    }\n  }\n}\n\nasync function transfer(db: Database, account1: Account, account2: Account, amount: number) {\n  using tx = await DatabaseTransaction.create(db);\n  if (await debitAccount(db, account1, amount)) {\n    await creditAccount(db, account2, amount);\n  }\n  // if an exception is thrown before this line, the transaction will roll back\n  tx.success = true;\n  // now the transaction will commit\n}\n```\n\n### `await using` vs `await`\n\nThe `await` keyword that is part of the `await using` declaration only indicates that the *disposal* of the resource is `await`-ed. It does *not* `await` the value itself:\n\n``` ts\n{\n  await using x = getResourceSynchronously();\n} // performs `await x[Symbol.asyncDispose]()`\n\n{\n  await using y = await getResourceAsynchronously();\n} // performs `await y[Symbol.asyncDispose]()`\n```\n\n### `await using` and `return`\n\nIt’s important to note that there is a small caveat with this behavior if you are using an `await using` declaration in an `async` function that returns a `Promise` without first `await`-ing it:\n\n``` ts\nfunction g() {\n  return Promise.reject(\"error!\");\n}\n\nasync function f() {\n  await using x = new C();\n  return g(); // missing an `await`\n}\n```\n\nBecause the returned promise isn’t `await`-ed, it’s possible that the JavaScript runtime may report an unhandled rejection since execution pauses while `await`-ing the asynchronous disposal of `x`, without having subscribed to the returned promise. This is not a problem that is unique to `await using`, however, as this can also occur in an `async` function that uses `try..finally`:\n\n``` ts\nasync function f() {\n  try {\n    return g(); // also reports an unhandled rejection\n  }\n  finally {\n    await somethingElse();\n  }\n}\n```\n\nTo avoid this situation, it is recommended that you `await` your return value if it may be a `Promise`:\n\n``` ts\nasync function f() {\n  await using x = new C();\n  return await g();\n}\n```\n\n## `using` and `await using` in `for` and `for..of` statements\n\nBoth `using` and `await using` can be used in a `for` statement:\n\n``` ts\nfor (using x = getReader(); !x.eof; x.next()) {\n  // ...\n}\n```\n\nIn this case, the lifetime of `x` is scoped to the entire `for` statement and is only disposed when control leaves the loop due to `break`, `return`, `throw`, or when the loop condition is false.\n\nIn addition to `for` statements, both declarations can also be used in `for..of` statements:\n\n``` ts\nfunction * g() {\n  yield createResource1();\n  yield createResource2();\n}\n\nfor (using x of g()) {\n  // ...\n}\n```\n\nHere, `x` is disposed at the end of *each iteration of the loop*, and is then reinitialized with the next value. This is especially useful when consuming resources produced one at a time by a generator.\n\n## `using` and `await using` in older runtimes\n\n`using` and `await using` declarations can be used when targeting older ECMAScript editions as long as you are using a compatible polyfill for `Symbol.dispose`/`Symbol.asyncDispose`, such as the one provided by default in recent editions of NodeJS.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/variable-declarations.html](https://www.typescriptlang.org/docs/handbook/variable-declarations.html)"
- name: 'Variable Declaration: await using and return'
  id: variable-declarations#await-using-and-return
  summary: Because the returned promise isn’t await-ed, it’s possible that the JavaScript runtime may report an unhandled rejection since execution pauses while await-ing the asynchronous disposal of x, without having subscribed to the returned promise
  belongs_to: Variable Declaration
  description: |-
    ### `await using` and `return`

    It’s important to note that there is a small caveat with this behavior if you are using an `await using` declaration in an `async` function that returns a `Promise` without first `await`-ing it:

    ``` ts
    function g() {
      return Promise.reject("error!");
    }

    async function f() {
      await using x = new C();
      return g(); // missing an `await`
    }
    ```

    Because the returned promise isn’t `await`-ed, it’s possible that the JavaScript runtime may report an unhandled rejection since execution pauses while `await`-ing the asynchronous disposal of `x`, without having subscribed to the returned promise. This is not a problem that is unique to `await using`, however, as this can also occur in an `async` function that uses `try..finally`:

    ``` ts
    async function f() {
      try {
        return g(); // also reports an unhandled rejection
      }
      finally {
        await somethingElse();
      }
    }
    ```

    To avoid this situation, it is recommended that you `await` your return value if it may be a `Promise`:

    ``` ts
    async function f() {
      await using x = new C();
      return await g();
    }
    ```
- name: 'Variable Declaration: await using declarations'
  id: variable-declarations#await-using-declarations
  summary: Some resources or operations may have cleanup that needs to be performed asynchronously
  belongs_to: Variable Declaration
  description: |-
    ## `await using` declarations

    Some resources or operations may have cleanup that needs to be performed asynchronously. To accommodate this, the [Explicit Resource Management](https://github.com/tc39/proposal-explicit-resource-management) proposal also introduces the `await using` declaration:

    ``` ts
    async function f() {
      await using x = new C();
    } // `await x[Symbol.asyncDispose]()` is invoked
    ```

    An `await using` declaration invokes, and *awaits*, its value’s `[Symbol.asyncDispose]()` method as control leaves the containing block. This allows for asynchronous cleanup, such as a database transaction performing a rollback or commit, or a file stream flushing any pending writes to storage before it is closed.

    As with `await`, `await using` can only be used in an `async` function or method, or at the top level of a module.

    ### Defining an asynchronously disposable resource

    Just as `using` relies on objects that are `Disposable`, an `await using` relies on objects that are `AsyncDisposable`:

    ``` ts
    // from the default lib:
    interface AsyncDisposable {
      [Symbol.asyncDispose]: PromiseLike<void>;
    }

    // usage:
    class DatabaseTransaction implements AsyncDisposable {
      public success = false;
      private db: Database | undefined;

      private constructor(db: Database) {
        this.db = db;
      }

      static async create(db: Database) {
        await db.execAsync("BEGIN TRANSACTION");
        return new DatabaseTransaction(db);
      }

      async [Symbol.asyncDispose]() {
        if (this.db) {
          const db = this.db:
          this.db = undefined;
          if (this.success) {
            await db.execAsync("COMMIT TRANSACTION");
          }
          else {
            await db.execAsync("ROLLBACK TRANSACTION");
          }
        }
      }
    }

    async function transfer(db: Database, account1: Account, account2: Account, amount: number) {
      using tx = await DatabaseTransaction.create(db);
      if (await debitAccount(db, account1, amount)) {
        await creditAccount(db, account2, amount);
      }
      // if an exception is thrown before this line, the transaction will roll back
      tx.success = true;
      // now the transaction will commit
    }
    ```
- name: 'Variable Declaration: await using vs await'
  id: variable-declarations#await-using-vs-await
  summary: The await keyword that is part of the await using declaration only indicates that the disposal of the resource is await-ed
  belongs_to: Variable Declaration
  description: |-
    ### `await using` vs `await`

    The `await` keyword that is part of the `await using` declaration only indicates that the *disposal* of the resource is `await`-ed. It does *not* `await` the value itself:

    ``` ts
    {
      await using x = getResourceSynchronously();
    } // performs `await x[Symbol.asyncDispose]()`

    {
      await using y = await getResourceAsynchronously();
    } // performs `await y[Symbol.asyncDispose]()`
    ```
- name: 'Variable Declaration: const declarations'
  id: variable-declarations#const-declarations
  summary: const declarations are another way of declaring variables
  belongs_to: Variable Declaration
  description: |-
    ## `const` declarations

    `const` declarations are another way of declaring variables.

    ``` ts
    const numLivesForCat = 9;
    ```

    They are like `let` declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as `let`, but you can’t re-assign to them.

    This should not be confused with the idea that the values they refer to are *immutable*.

    ``` ts
    const numLivesForCat = 9;
    const kitty = {
      name: "Aurora",
      numLives: numLivesForCat,
    };

    // Error
    kitty = {
      name: "Danielle",
      numLives: numLivesForCat,
    };

    // all "okay"
    kitty.name = "Rory";
    kitty.name = "Kitty";
    kitty.name = "Cat";
    kitty.numLives--;
    ```

    Unless you take specific measures to avoid it, the internal state of a `const` variable is still modifiable. Fortunately, TypeScript allows you to specify that members of an object are `readonly`. The [chapter on Interfaces](interfaces) has the details.
- name: 'Variable Declaration: Destructuring'
  id: variable-declarations#destructuring
  summary: Another ECMAScript 2015 feature that TypeScript has is destructuring
  belongs_to: Variable Declaration
  description: |-
    ## Destructuring

    Another ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see [the article on the Mozilla Developer Network](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment). In this section, we’ll give a short overview.

    ### Array destructuring

    The simplest form of destructuring is array destructuring assignment:

    ``` ts
    let input = [1, 2];
    let [first, second] = input;
    console.log(first); // outputs 1
    console.log(second); // outputs 2
    ```

    This creates two new variables named `first` and `second`. This is equivalent to using indexing, but is much more convenient:

    ``` ts
    first = input[0];
    second = input[1];
    ```

    Destructuring works with already-declared variables as well:

    ``` ts
    // swap variables
    [first, second] = [second, first];
    ```

    And with parameters to a function:

    ``` ts
    function f([first, second]: [number, number]) {
      console.log(first);
      console.log(second);
    }
    f([1, 2]);
    ```

    You can create a variable for the remaining items in a list using the syntax `...`:

    ``` ts
    let [first, ...rest] = [1, 2, 3, 4];
    console.log(first); // outputs 1
    console.log(rest); // outputs [ 2, 3, 4 ]
    ```

    Of course, since this is JavaScript, you can just ignore trailing elements you don’t care about:

    ``` ts
    let [first] = [1, 2, 3, 4];
    console.log(first); // outputs 1
    ```

    Or other elements:

    ``` ts
    let [, second, , fourth] = [1, 2, 3, 4];
    console.log(second); // outputs 2
    console.log(fourth); // outputs 4
    ```

    ### Tuple destructuring

    Tuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:

    ``` ts
    let tuple: [number, string, boolean] = [7, "hello", true];

    let [a, b, c] = tuple; // a: number, b: string, c: boolean
    ```

    It’s an error to destructure a tuple beyond the range of its elements:

    ``` ts
    let [a, b, c, d] = tuple; // Error, no element at index 3
    ```

    As with arrays, you can destructure the rest of the tuple with `...`, to get a shorter tuple:

    ``` ts
    let [a, ...bc] = tuple; // bc: [string, boolean]
    let [a, b, c, ...d] = tuple; // d: [], the empty tuple
    ```

    Or ignore trailing elements, or other elements:

    ``` ts
    let [a] = tuple; // a: number
    let [, b] = tuple; // b: string
    ```

    ### Object destructuring

    You can also destructure objects:

    ``` ts
    let o = {
      a: "foo",
      b: 12,
      c: "bar",
    };
    let { a, b } = o;
    ```

    This creates new variables `a` and `b` from `o.a` and `o.b`. Notice that you can skip `c` if you don’t need it.

    Like array destructuring, you can have assignment without declaration:

    ``` ts
    ({ a, b } = { a: "baz", b: 101 });
    ```

    Notice that we had to surround this statement with parentheses. JavaScript normally parses a `{` as the start of block.

    You can create a variable for the remaining items in an object using the syntax `...`:

    ``` ts
    let { a, ...passthrough } = o;
    let total = passthrough.b + passthrough.c.length;
    ```

    #### Property renaming

    You can also give different names to properties:

    ``` ts
    let { a: newName1, b: newName2 } = o;
    ```

    Here the syntax starts to get confusing. You can read `a: newName1` as ”`a` as `newName1`”. The direction is left-to-right, as if you had written:

    ``` ts
    let newName1 = o.a;
    let newName2 = o.b;
    ```

    Confusingly, the colon here does *not* indicate the type. The type, if you specify it, still needs to be written after the entire destructuring:

    ``` ts
    let { a: newName1, b: newName2 }: { a: string; b: number } = o;
    ```

    #### Default values

    Default values let you specify a default value in case a property is undefined:

    ``` ts
    function keepWholeObject(wholeObject: { a: string; b?: number }) {
      let { a, b = 1001 } = wholeObject;
    }
    ```

    In this example the `b?` indicates that `b` is optional, so it may be `undefined`. `keepWholeObject` now has a variable for `wholeObject` as well as the properties `a` and `b`, even if `b` is undefined.
- name: 'Variable Declaration: Function declarations'
  id: variable-declarations#function-declarations
  summary: Destructuring also works in function declarations
  belongs_to: Variable Declaration
  description: |-
    ## Function declarations

    Destructuring also works in function declarations. For simple cases this is straightforward:

    ``` ts
    type C = { a: string; b?: number };
    function f({ a, b }: C): void {
      // ...
    }
    ```

    But specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky. First of all, you need to remember to put the pattern before the default value.

    ``` ts
    function f({ a = "", b = 0 } = {}): void {
      // ...
    }
    f();
    ```

    > The snippet above is an example of type inference, explained earlier in the handbook.

    Then, you need to remember to give a default for optional properties on the destructured property instead of the main initializer. Remember that `C` was defined with `b` optional:

    ``` ts
    function f({ a, b = 0 } = { a: "" }): void {
      // ...
    }
    f({ a: "yes" }); // ok, default b = 0
    f(); // ok, default to { a: "" }, which then defaults b = 0
    f({}); // error, 'a' is required if you supply an argument
    ```

    Use destructuring with care. As the previous example demonstrates, anything but the simplest destructuring expression is confusing. This is especially true with deeply nested destructuring, which gets *really* hard to understand even without piling on renaming, default values, and type annotations. Try to keep destructuring expressions small and simple. You can always write the assignments that destructuring would generate yourself.
- name: 'Variable Declaration: let declarations'
  id: variable-declarations#let-declarations
  summary: By now you’ve figured out that var has some problems, which is precisely why let statements were introduced
  belongs_to: Variable Declaration
  description: |-
    ## `let` declarations

    By now you’ve figured out that `var` has some problems, which is precisely why `let` statements were introduced. Apart from the keyword used, `let` statements are written the same way `var` statements are.

    ``` ts
    let hello = "Hello!";
    ```

    The key difference is not in the syntax, but in the semantics, which we’ll now dive into.

    ### Block-scoping

    When a variable is declared using `let`, it uses what some call *lexical-scoping* or *block-scoping*. Unlike variables declared with `var` whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block or `for`-loop.

    ``` ts
    function f(input: boolean) {
      let a = 100;

      if (input) {
        // Still okay to reference 'a'
        let b = a + 1;
        return b;
      }

      // Error: 'b' doesn't exist here
      return b;
    }
    ```

    Here, we have two local variables `a` and `b`. `a`’s scope is limited to the body of `f` while `b`’s scope is limited to the containing `if` statement’s block.

    Variables declared in a `catch` clause also have similar scoping rules.

    ``` ts
    try {
      throw "oh no!";
    } catch (e) {
      console.log("Oh well.");
    }

    // Error: 'e' doesn't exist here
    console.log(e);
    ```

    Another property of block-scoped variables is that they can’t be read or written to before they’re actually declared. While these variables are “present” throughout their scope, all points up until their declaration are part of their *temporal dead zone*. This is just a sophisticated way of saying you can’t access them before the `let` statement, and luckily TypeScript will let you know that.

    ``` ts
    a++; // illegal to use 'a' before it's declared;
    let a;
    ```

    Something to note is that you can still *capture* a block-scoped variable before it’s declared. The only catch is that it’s illegal to call that function before the declaration. If targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won’t report this as an error.

    ``` ts
    function foo() {
      // okay to capture 'a'
      return a;
    }

    // illegal call 'foo' before 'a' is declared
    // runtimes should throw an error here
    foo();

    let a;
    ```

    For more information on temporal dead zones, see relevant content on the [Mozilla Developer Network](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let).

    ### Re-declarations and Shadowing

    With `var` declarations, we mentioned that it didn’t matter how many times you declared your variables; you just got one.

    ``` ts
    function f(x) {
      var x;
      var x;

      if (true) {
        var x;
      }
    }
    ```

    In the above example, all declarations of `x` actually refer to the *same* `x`, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, `let` declarations are not as forgiving.

    ``` ts
    let x = 10;
    let x = 20; // error: can't re-declare 'x' in the same scope
    ```

    The variables don’t necessarily need to both be block-scoped for TypeScript to tell us that there’s a problem.

    ``` ts
    function f(x) {
      let x = 100; // error: interferes with parameter declaration
    }

    function g() {
      let x = 100;
      var x = 100; // error: can't have both declarations of 'x'
    }
    ```

    That’s not to say that a block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.

    ``` ts
    function f(condition, x) {
      if (condition) {
        let x = 100;
        return x;
      }

      return x;
    }

    f(false, 0); // returns '0'
    f(true, 0); // returns '100'
    ```

    The act of introducing a new name in a more nested scope is called *shadowing*. It is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs. For instance, imagine we had written our earlier `sumMatrix` function using `let` variables.

    ``` ts
    function sumMatrix(matrix: number[][]) {
      let sum = 0;
      for (let i = 0; i < matrix.length; i++) {
        var currentRow = matrix[i];
        for (let i = 0; i < currentRow.length; i++) {
          sum += currentRow[i];
        }
      }

      return sum;
    }
    ```

    This version of the loop will actually perform the summation correctly because the inner loop’s `i` shadows `i` from the outer loop.

    Shadowing should *usually* be avoided in the interest of writing clearer code. While there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement.

    ### Block-scoped variable capturing

    When we first touched on the idea of variable capturing with `var` declaration, we briefly went into how variables act once captured. To give a better intuition of this, each time a scope is run, it creates an “environment” of variables. That environment and its captured variables can exist even after everything within its scope has finished executing.

    ``` ts
    function theCityThatAlwaysSleeps() {
      let getCity;

      if (true) {
        let city = "Seattle";
        getCity = function () {
          return city;
        };
      }

      return getCity();
    }
    ```

    Because we’ve captured `city` from within its environment, we’re still able to access it despite the fact that the `if` block finished executing.

    Recall that with our earlier `setTimeout` example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the `for` loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you’ll never have to do that again in TypeScript.

    `let` declarations have drastically different behavior when declared as part of a loop. Rather than just introducing a new environment to the loop itself, these declarations sort of create a new scope *per iteration*. Since this is what we were doing anyway with our IIFE, we can change our old `setTimeout` example to just use a `let` declaration.

    ``` ts
    for (let i = 0; i < 10; i++) {
      setTimeout(function () {
        console.log(i);
      }, 100 * i);
    }
    ```

    and as expected, this will print out

    ``` typescript
    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
    ```
- name: 'Variable Declaration: let vs. const'
  id: variable-declarations#let-vs-const
  summary: Given that we have two types of declarations with similar scoping semantics, it’s natural to find ourselves asking which one to use
  belongs_to: Variable Declaration
  description: |-
    ## `let` vs. `const`

    Given that we have two types of declarations with similar scoping semantics, it’s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.

    Applying the [principle of least privilege](https://wikipedia.org/wiki/Principle_of_least_privilege), all declarations other than those you plan to modify should use `const`. The rationale is that if a variable didn’t need to get written to, others working on the same codebase shouldn’t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using `const` also makes code more predictable when reasoning about flow of data.

    Use your best judgement, and if applicable, consult the matter with the rest of your team.

    The majority of this handbook uses `let` declarations.
- name: 'Variable Declaration: null and undefined'
  id: variable-declarations#null-and-undefined
  summary: This allows you to conditionally acquire resources when declaring a using declaration without the need for complex branching or repetition
  belongs_to: Variable Declaration
  description: |-
    ### `null` and `undefined`

    It’s important to note that the value can be `null` or `undefined`, in which case nothing is disposed at the end of the block:

    ``` ts
    {
      using x = b ? new C() : null;
      // ...
    }
    ```

    which is *roughly* equivalent to:

    ``` ts
    {
      const x = b ? new C() : null;
      try {
        // ...
      }
      finally {
        x?.[Symbol.dispose]();
      }
    }
    ```

    This allows you to conditionally acquire resources when declaring a `using` declaration without the need for complex branching or repetition.

    ### Defining a disposable resource

    You can indicate the classes or objects you produce are disposable by implementing the `Disposable` interface:

    ``` ts
    // from the default lib:
    interface Disposable {
      [Symbol.dispose](): void;
    }

    // usage:
    class TraceActivity implements Disposable {
      readonly name: string;
      constructor(name: string) {
        this.name = name;
        console.log(`Entering: ${name}`);
      }

      [Symbol.dispose](): void {
        console.log(`Exiting: ${name}`);
      }
    }

    function f() {
      using _activity = new TraceActivity("f");
      console.log("Hello world!");
    }

    f();
    // prints:
    //   Entering: f
    //   Hello world!
    //   Exiting: f
    ```
- name: 'Variable Declaration: Spread'
  id: variable-declarations#spread
  summary: The spread operator is the opposite of destructuring
  belongs_to: Variable Declaration
  description: |-
    ## Spread

    The spread operator is the opposite of destructuring. It allows you to spread an array into another array, or an object into another object. For example:

    ``` ts
    let first = [1, 2];
    let second = [3, 4];
    let bothPlus = [0, ...first, ...second, 5];
    ```

    This gives bothPlus the value `[0, 1, 2, 3, 4, 5]`. Spreading creates a shallow copy of `first` and `second`. They are not changed by the spread.

    You can also spread objects:

    ``` ts
    let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
    let search = { ...defaults, food: "rich" };
    ```

    Now `search` is `{ food: "rich", price: "$$", ambiance: "noisy" }`. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:

    ``` ts
    let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
    let search = { food: "rich", ...defaults };
    ```

    Then the `food` property in `defaults` overwrites `food: "rich"`, which is not what we want in this case.

    Object spread also has a couple of other surprising limits. First, it only includes an objects’ [own, enumerable properties](https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties). Basically, that means you lose methods when you spread instances of an object:

    ``` ts
    class C {
      p = 12;
      m() {}
    }
    let c = new C();
    let clone = { ...c };
    clone.p; // ok
    clone.m(); // error!
    ```

    Second, the TypeScript compiler doesn’t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.
- name: 'Variable Declaration: using and await using in for and for..of statements'
  id: variable-declarations#using-and-await-using-in-for-and-forof-statements
  summary: In this case, the lifetime of x is scoped to the entire for statement and is only disposed when control leaves the loop due to break, return, throw, or when the loop condition is false
  belongs_to: Variable Declaration
  description: |-
    ## `using` and `await using` in `for` and `for..of` statements

    Both `using` and `await using` can be used in a `for` statement:

    ``` ts
    for (using x = getReader(); !x.eof; x.next()) {
      // ...
    }
    ```

    In this case, the lifetime of `x` is scoped to the entire `for` statement and is only disposed when control leaves the loop due to `break`, `return`, `throw`, or when the loop condition is false.

    In addition to `for` statements, both declarations can also be used in `for..of` statements:

    ``` ts
    function * g() {
      yield createResource1();
      yield createResource2();
    }

    for (using x of g()) {
      // ...
    }
    ```

    Here, `x` is disposed at the end of *each iteration of the loop*, and is then reinitialized with the next value. This is especially useful when consuming resources produced one at a time by a generator.
- name: 'Variable Declaration: using and await using in older runtimes'
  id: variable-declarations#using-and-await-using-in-older-runtimes
  summary: using and await using declarations can be used when targeting older ECMAScript editions as long as you are using a compatible polyfill for Symbol.dispose/Symbol.asyncDispose, such as the one provided by default in recent editions of NodeJS
  belongs_to: Variable Declaration
  description: "## `using` and `await using` in older runtimes\n\n`using` and `await using` declarations can be used when targeting older ECMAScript editions as long as you are using a compatible polyfill for `Symbol.dispose`/`Symbol.asyncDispose`, such as the one provided by default in recent editions of NodeJS.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/variable-declarations.html](https://www.typescriptlang.org/docs/handbook/variable-declarations.html)"
- name: 'Variable Declaration: using declarations'
  id: variable-declarations#using-declarations
  summary: using declarations are an upcoming feature for JavaScript that are part of the Stage 3 Explicit Resource Management proposal
  belongs_to: Variable Declaration
  description: |-
    ## `using` declarations

    `using` declarations are an upcoming feature for JavaScript that are part of the [Stage 3 Explicit Resource Management](https://github.com/tc39/proposal-explicit-resource-management) proposal. A `using` declaration is much like a `const` declaration, except that it couples the *lifetime* of the value bound to the declaration with the *scope* of the variable.

    When control exits the block containing a `using` declaration, the `[Symbol.dispose]()` method of the declared value is executed, which allows that value to perform cleanup:

    ``` ts
    function f() {
      using x = new C();
      doSomethingWith(x);
    } // `x[Symbol.dispose]()` is called
    ```

    At runtime, this has an effect *roughly* equivalent to the following:

    ``` ts
    function f() {
      const x = new C();
      try {
        doSomethingWith(x);
      }
      finally {
        x[Symbol.dispose]();
      }
    }
    ```

    `using` declarations are extremely useful for avoiding memory leaks when working with JavaScript objects that hold on to native references like file handles

    ``` ts
    {
      using file = await openFile();
      file.write(text);
      doSomethingThatMayThrow();
    } // `file` is disposed, even if an error is thrown
    ```

    or scoped operations like tracing

    ``` ts
    function f() {
      using activity = new TraceActivity("f"); // traces entry into function
      // ...
    } // traces exit of function
    ```

    Unlike `var`, `let`, and `const`, `using` declarations do not support destructuring.
- name: 'Variable Declaration: var declarations'
  id: variable-declarations#var-declarations
  summary: Declaring a variable in JavaScript has always traditionally been done with the var keyword
  belongs_to: Variable Declaration
  description: |-
    ## `var` declarations

    Declaring a variable in JavaScript has always traditionally been done with the `var` keyword.

    ``` ts
    var a = 10;
    ```

    As you might’ve figured out, we just declared a variable named `a` with the value `10`.

    We can also declare a variable inside of a function:

    ``` ts
    function f() {
      var message = "Hello, world!";

      return message;
    }
    ```

    and we can also access those same variables within other functions:

    ``` ts
    function f() {
      var a = 10;
      return function g() {
        var b = a + 1;
        return b;
      };
    }

    var g = f();
    g(); // returns '11'
    ```

    In this above example, `g` captured the variable `a` declared in `f`. At any point that `g` gets called, the value of `a` will be tied to the value of `a` in `f`. Even if `g` is called once `f` is done running, it will be able to access and modify `a`.

    ``` ts
    function f() {
      var a = 1;

      a = 2;
      var b = g();
      a = 3;

      return b;

      function g() {
        return a;
      }
    }

    f(); // returns '2'
    ```

    ### Scoping rules

    `var` declarations have some odd scoping rules for those used to other languages. Take the following example:

    ``` ts
    function f(shouldInitialize: boolean) {
      if (shouldInitialize) {
        var x = 10;
      }

      return x;
    }

    f(true); // returns '10'
    f(false); // returns 'undefined'
    ```

    Some readers might do a double-take at this example. The variable `x` was declared *within the `if` block*, and yet we were able to access it from outside that block. That’s because `var` declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we’ll go over later on - regardless of the containing block. Some people call this *`var`-scoping* or *function-scoping*. Parameters are also function scoped.

    These scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:

    ``` ts
    function sumMatrix(matrix: number[][]) {
      var sum = 0;
      for (var i = 0; i < matrix.length; i++) {
        var currentRow = matrix[i];
        for (var i = 0; i < currentRow.length; i++) {
          sum += currentRow[i];
        }
      }

      return sum;
    }
    ```

    Maybe it was easy to spot out for some experienced JavaScript developers, but the inner `for`-loop will accidentally overwrite the variable `i` because `i` refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.

    ### Variable capturing quirks

    Take a quick second to guess what the output of the following snippet is:

    ``` ts
    for (var i = 0; i < 10; i++) {
      setTimeout(function () {
        console.log(i);
      }, 100 * i);
    }
    ```

    For those unfamiliar, `setTimeout` will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running).

    Ready? Take a look:

    ``` typescript
    10
    10
    10
    10
    10
    10
    10
    10
    10
    10
    ```

    Many JavaScript developers are intimately familiar with this behavior, but if you’re surprised, you’re certainly not alone. Most people expect the output to be

    ``` typescript
    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
    ```

    Remember what we mentioned earlier about variable capturing? Every function expression we pass to `setTimeout` actually refers to the same `i` from the same scope.

    Let’s take a minute to consider what that means. `setTimeout` will run a function after some number of milliseconds, *but only* after the `for` loop has stopped executing; By the time the `for` loop has stopped executing, the value of `i` is `10`. So each time the given function gets called, it will print out `10`!

    A common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture `i` at each iteration:

    ``` ts
    for (var i = 0; i < 10; i++) {
      // capture the current state of 'i'
      // by invoking a function with its current value
      (function (i) {
        setTimeout(function () {
          console.log(i);
        }, 100 * i);
      })(i);
    }
    ```

    This odd-looking pattern is actually pretty common. The `i` in the parameter list actually shadows the `i` declared in the `for` loop, but since we named them the same, we didn’t have to modify the loop body too much.
- name: verbatimModuleSyntax
  id: tsconfig/index#verbatimModuleSyntax-config
  summary: By default, TypeScript does something called import elision
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Verbatim Module Syntax - `verbatimModuleSyntax`

    By default, TypeScript does something called *import elision*. Basically, if you write something like

    ``` ts
    import { Car } from "./car";

    export function drive(car: Car) {
      // ...
    }
    ```

    TypeScript detects that you’re only using an import for types and drops the import entirely. Your output JavaScript might look something like this:

    ``` js
    export function drive(car) {
      // ...
    }
    ```

    Most of the time this is good, because if `Car` isn’t a value that’s exported from `./car`, we’ll get a runtime error.

    But it does add a layer of complexity for certain edge cases. For example, notice there’s no statement like `import "./car";` - the import was dropped entirely. That actually makes a difference for modules that have side-effects or not.

    TypeScript’s emit strategy for JavaScript also has another few layers of complexity - import elision isn’t always just driven by how an import is used - it often consults how a value is declared as well. So it’s not always clear whether code like the following

    ``` ts
    export { Car } from "./car";
    ```

    should be preserved or dropped. If `Car` is declared with something like a `class`, then it can be preserved in the resulting JavaScript file. But if `Car` is only declared as a `type` alias or `interface`, then the JavaScript file shouldn’t export `Car` at all.

    While TypeScript might be able to make these emit decisions based on information from across files, not every compiler can.

    The `type` modifier on imports and exports helps with these situations a bit. We can make it explicit whether an import or export is only being used for type analysis, and can be dropped entirely in JavaScript files by using the `type` modifier.

    ``` ts
    // This statement can be dropped entirely in JS output
    import type * as car from "./car";

    // The named import/export 'Car' can be dropped in JS output
    import { type Car } from "./car";
    export { type Car } from "./car";
    ```

    `type` modifiers are not quite useful on their own - by default, module elision will still drop imports, and nothing forces you to make the distinction between `type` and plain imports and exports. So TypeScript has the flag `--importsNotUsedAsValues` to make sure you use the `type` modifier, `--preserveValueImports` to prevent *some* module elision behavior, and `--isolatedModules` to make sure that your TypeScript code works across different compilers. Unfortunately, understanding the fine details of those 3 flags is hard, and there are still some edge cases with unexpected behavior.

    TypeScript 5.0 introduces a new option called `--verbatimModuleSyntax` to simplify the situation. The rules are much simpler - any imports or exports without a `type` modifier are left around. Anything that uses the `type` modifier is dropped entirely.

    ``` ts
    // Erased away entirely.
    import type { A } from "a";

    // Rewritten to 'import { b } from "bcd";'
    import { b, type c, type d } from "bcd";

    // Rewritten to 'import {} from "xyz";'
    import { type xyz } from "xyz";
    ```

    With this new option, what you see is what you get.

    That does have some implications when it comes to module interop though. Under this flag, ECMAScript `import`s and `export`s won’t be rewritten to `require` calls when your settings or file extension implied a different module system. Instead, you’ll get an error. If you need to emit code that uses `require` and `module.exports`, you’ll have to use TypeScript’s module syntax that predates ES2015:

    [TABLE]

    While this is a limitation, it does help make some issues more obvious. For example, it’s very common to forget to set the [`type` field in `package.json`](https://nodejs.org/api/packages.html#type) under `--module node16`. As a result, developers would start writing CommonJS modules instead of an ES modules without realizing it, giving surprising lookup rules and JavaScript output. This new flag ensures that you’re intentional about the file type you’re using because the syntax is intentionally different.

    Because `--verbatimModuleSyntax` provides a more consistent story than `--importsNotUsedAsValues` and `--preserveValueImports`, those two existing flags are being deprecated in its favor.

    For more details, read up on [the original pull request](https://github.com/microsoft/TypeScript/pull/52203) and [its proposal issue](https://github.com/microsoft/TypeScript/issues/51479).

    ## Backwards Compatibility
- name: verbatimModuleSyntax
  id: tsconfig#verbatimModuleSyntax-config
  summary: By default, TypeScript does something called import elision
  belongs_to: TSConfig Reference
  description: |-
    ### Verbatim Module Syntax - `verbatimModuleSyntax`

    By default, TypeScript does something called *import elision*. Basically, if you write something like

    ``` ts
    import { Car } from "./car";

    export function drive(car: Car) {
      // ...
    }
    ```

    TypeScript detects that you’re only using an import for types and drops the import entirely. Your output JavaScript might look something like this:

    ``` js
    export function drive(car) {
      // ...
    }
    ```

    Most of the time this is good, because if `Car` isn’t a value that’s exported from `./car`, we’ll get a runtime error.

    But it does add a layer of complexity for certain edge cases. For example, notice there’s no statement like `import "./car";` - the import was dropped entirely. That actually makes a difference for modules that have side-effects or not.

    TypeScript’s emit strategy for JavaScript also has another few layers of complexity - import elision isn’t always just driven by how an import is used - it often consults how a value is declared as well. So it’s not always clear whether code like the following

    ``` ts
    export { Car } from "./car";
    ```

    should be preserved or dropped. If `Car` is declared with something like a `class`, then it can be preserved in the resulting JavaScript file. But if `Car` is only declared as a `type` alias or `interface`, then the JavaScript file shouldn’t export `Car` at all.

    While TypeScript might be able to make these emit decisions based on information from across files, not every compiler can.

    The `type` modifier on imports and exports helps with these situations a bit. We can make it explicit whether an import or export is only being used for type analysis, and can be dropped entirely in JavaScript files by using the `type` modifier.

    ``` ts
    // This statement can be dropped entirely in JS output
    import type * as car from "./car";

    // The named import/export 'Car' can be dropped in JS output
    import { type Car } from "./car";
    export { type Car } from "./car";
    ```

    `type` modifiers are not quite useful on their own - by default, module elision will still drop imports, and nothing forces you to make the distinction between `type` and plain imports and exports. So TypeScript has the flag `--importsNotUsedAsValues` to make sure you use the `type` modifier, `--preserveValueImports` to prevent *some* module elision behavior, and `--isolatedModules` to make sure that your TypeScript code works across different compilers. Unfortunately, understanding the fine details of those 3 flags is hard, and there are still some edge cases with unexpected behavior.

    TypeScript 5.0 introduces a new option called `--verbatimModuleSyntax` to simplify the situation. The rules are much simpler - any imports or exports without a `type` modifier are left around. Anything that uses the `type` modifier is dropped entirely.

    ``` ts
    // Erased away entirely.
    import type { A } from "a";

    // Rewritten to 'import { b } from "bcd";'
    import { b, type c, type d } from "bcd";

    // Rewritten to 'import {} from "xyz";'
    import { type xyz } from "xyz";
    ```

    With this new option, what you see is what you get.

    That does have some implications when it comes to module interop though. Under this flag, ECMAScript `import`s and `export`s won’t be rewritten to `require` calls when your settings or file extension implied a different module system. Instead, you’ll get an error. If you need to emit code that uses `require` and `module.exports`, you’ll have to use TypeScript’s module syntax that predates ES2015:

    [TABLE]

    While this is a limitation, it does help make some issues more obvious. For example, it’s very common to forget to set the [`type` field in `package.json`](https://nodejs.org/api/packages.html#type) under `--module node16`. As a result, developers would start writing CommonJS modules instead of an ES modules without realizing it, giving surprising lookup rules and JavaScript output. This new flag ensures that you’re intentional about the file type you’re using because the syntax is intentionally different.

    Because `--verbatimModuleSyntax` provides a more consistent story than `--importsNotUsedAsValues` and `--preserveValueImports`, those two existing flags are being deprecated in its favor.

    For more details, read up on [the original pull request](https://github.com/microsoft/TypeScript/pull/52203) and [its proposal issue](https://github.com/microsoft/TypeScript/issues/51479).

    ## Backwards Compatibility
- name: watchDirectory
  id: tsconfig#watch-watchDirectory-config
  summary: The strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality
  belongs_to: TSConfig Reference
  description: |-
    ### Watch Directory - `watchDirectory`

    The strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality.

    - `fixedPollingInterval`: Check every directory for changes several times a second at a fixed interval.
    - `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified directories will be checked less often.
    - `useFsEvents` (the default): Attempt to use the operating system/file system’s native events for directory changes.

    - Allowed:
      - `usefsevents`

      - `fixedpollinginterval`

      - `dynamicprioritypolling`

      - `fixedchunksizepolling`

    - Released:

      [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)
- name: watchDirectory
  id: tsconfig/index#watch-watchDirectory-config
  summary: The strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Watch Directory - `watchDirectory`

    The strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality.

    - `fixedPollingInterval`: Check every directory for changes several times a second at a fixed interval.
    - `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified directories will be checked less often.
    - `useFsEvents` (the default): Attempt to use the operating system/file system’s native events for directory changes.

    - Allowed:
      - `usefsevents`

      - `fixedpollinginterval`

      - `dynamicprioritypolling`

      - `fixedchunksizepolling`

    - Released:

      [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)
- name: watchFile
  id: tsconfig#watch-watchFile-config
  summary: The strategy for how individual files are watched
  belongs_to: TSConfig Reference
  description: |-
    ### Watch File - `watchFile`

    The strategy for how individual files are watched.

    - `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.
    - `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.
    - `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.
    - `useFsEvents` (the default): Attempt to use the operating system/file system’s native events for file changes.
    - `useFsEventsOnParentDirectory`: Attempt to use the operating system/file system’s native events to listen for changes on a file’s parent directory

    - Allowed:
      - `fixedpollinginterval`

      - `prioritypollinginterval`

      - `dynamicprioritypolling`

      - `fixedchunksizepolling`

      - `usefsevents`

      - `usefseventsonparentdirectory`

    - Released:

      [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)
- name: watchFile
  id: tsconfig/index#watch-watchFile-config
  summary: The strategy for how individual files are watched
  belongs_to: Intro to the TSConfig Reference
  description: |-
    ### Watch File - `watchFile`

    The strategy for how individual files are watched.

    - `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.
    - `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.
    - `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.
    - `useFsEvents` (the default): Attempt to use the operating system/file system’s native events for file changes.
    - `useFsEventsOnParentDirectory`: Attempt to use the operating system/file system’s native events to listen for changes on a file’s parent directory

    - Allowed:
      - `fixedpollinginterval`

      - `prioritypollinginterval`

      - `dynamicprioritypolling`

      - `fixedchunksizepolling`

      - `usefsevents`

      - `usefseventsonparentdirectory`

    - Released:

      [3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html)
- name: What is a tsconfig.json
  id: tsconfig-json
  summary: The presence of a tsconfig.json file in a directory indicates that the directory is the root of a TypeScript project
  description: "# What is a tsconfig.json\n\n## Overview\n\nThe presence of a `tsconfig.json` file in a directory indicates that the directory is the root of a TypeScript project. The `tsconfig.json` file specifies the root files and the compiler options required to compile the project.\n\nJavaScript projects can use a `jsconfig.json` file instead, which acts almost the same but has some JavaScript-related compiler flags enabled by default.\n\nA project is compiled in one of the following ways:\n\n## Using `tsconfig.json` or `jsconfig.json`\n\n- By invoking tsc with no input files, in which case the compiler searches for the `tsconfig.json` file starting in the current directory and continuing up the parent directory chain.\n- By invoking tsc with no input files and a `--project` (or just `-p`) command line option that specifies the path of a directory containing a `tsconfig.json` file, or a path to a valid `.json` file containing the configurations.\n\nWhen input files are specified on the command line, `tsconfig.json` files are ignored.\n\n## Examples\n\nExample `tsconfig.json` files:\n\n- Using the [`files`](https://www.typescriptlang.org/tsconfig#files) property\n\n  ``` typescript\n  {\n    \"compilerOptions\": {\n      \"module\": \"commonjs\",\n      \"noImplicitAny\": true,\n      \"removeComments\": true,\n      \"preserveConstEnums\": true,\n      \"sourceMap\": true\n    },\n    \"files\": [\n      \"core.ts\",\n      \"sys.ts\",\n      \"types.ts\",\n      \"scanner.ts\",\n      \"parser.ts\",\n      \"utilities.ts\",\n      \"binder.ts\",\n      \"checker.ts\",\n      \"emitter.ts\",\n      \"program.ts\",\n      \"commandLineParser.ts\",\n      \"tsc.ts\",\n      \"diagnosticInformationMap.generated.ts\"\n    ]\n  }\n  ```\n\n- Using the [`include`](https://www.typescriptlang.org/tsconfig#include) and [`exclude`](https://www.typescriptlang.org/tsconfig#exclude) properties\n\n  ``` typescript\n  {\n    \"compilerOptions\": {\n      \"module\": \"system\",\n      \"noImplicitAny\": true,\n      \"removeComments\": true,\n      \"preserveConstEnums\": true,\n      \"outFile\": \"../../built/local/tsc.js\",\n      \"sourceMap\": true\n    },\n    \"include\": [\"src/**/*\"],\n    \"exclude\": [\"**/*.spec.ts\"]\n  }\n  ```\n\n## TSConfig Bases\n\nDepending on the JavaScript runtime environment which you intend to run your code in, there may be a base configuration which you can use at [github.com/tsconfig/bases](https://github.com/tsconfig/bases/). These are `tsconfig.json` files which your project extends from which simplifies your `tsconfig.json` by handling the runtime support.\n\nFor example, if you were writing a project which uses Node.js version 12 and above, then you could use the npm module [`@tsconfig/node12`](https://www.npmjs.com/package/@tsconfig/node12):\n\n``` typescript\n{\n  \"extends\": \"@tsconfig/node12/tsconfig.json\",\n\n  \"compilerOptions\": {\n    \"preserveConstEnums\": true\n  },\n\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"**/*.spec.ts\"]\n}\n```\n\nThis lets your `tsconfig.json` focus on the unique choices for your project, and not all of the runtime mechanics. There are a few tsconfig bases already, and we’re hoping the community can add more for different environments.\n\n## Details\n\nThe `\"compilerOptions\"` property can be omitted, in which case the compiler’s defaults are used. See our full list of supported [Compiler Options](https://www.typescriptlang.org/tsconfig).\n\n## TSConfig Reference\n\nTo learn more about the hundreds of configuration options in the [TSConfig Reference](https://www.typescriptlang.org/tsconfig).\n\n## Schema\n\nThe `tsconfig.json` Schema can be found at [the JSON Schema Store](http://json.schemastore.org/tsconfig).\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/docs/handbook/tsconfig-json.html](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)"
- name: What is JavaScript?
  id: why-create-typescript/index
  summary: TypeScript is a language from Microsoft which builds on JavaScript
  description: "# What is JavaScript?\n\nTypeScript is a language from Microsoft which builds on JavaScript.  \nThis post is a non-technical overview of what JavaScript is, how TypeScript extends JavaScript and what problems it solves.\n\n## What is JavaScript?\n\nBecause TypeScript extends JavaScript, this makes it a good starting point. JavaScript is commonly used to create websites. When building a website, you work with three languages: HTML, CSS and JavaScript (JS). Broadly speaking: HTML defines the content which will appear on the page, CSS defines the visual style of the page, and JS defines the interactive behaviors of the page.\n\nWe describe having these sets of skills as being a \"front-end\" developer. You use three languages to create pages inside a web browser like Safari, Firefox, Edge or Chrome. Given how popular the web is for commerce and information sharing, there is a massive demand for people who are good at using these three languages.\n\nRelated to the role of being a \"front-end\" developer is the set of skills for the \"back-end\" developers, which are to create computer services that communicate either to a web browser (by passing it HTML/CSS/JS) or to another service (by sending data more directly.) You don't need to use HTML, CSS or JS to write this type of code, but it's usually an end-product of your work because it is likely to be presented in a web browser.\n\n### What do Programming Languages do?\n\nProgramming languages are a way for humans and computers to communicate. People read code many, many multiples of times more than they write it - so developers create programming languages which are good at solving particular problems with a small amount of code. Here's an example using JavaScript:\n\n``` typescript\nvar name = \"Danger\"\nconsole.log(\"Hello, \" + name)\n```\n\nThe first line makes a variable (effectively a box you can store other things in) and then the second line outputs text to the console (for example DOS, or the terminal) `\"Hello, Danger\"`.\n\nJavaScript is designed to work as a scripting language, which means the code starts at the top of the file and then goes through line by line downwards running that code. To provide some contrast, here is the same behavior in Java, which is built with different language constraints:\n\n``` typescript\nclass Main {\n  public static void main(String[] args) {\n    String name = \"Danger\";\n    System.out.println(\"Hello, \" + name);\n  }\n}\n```\n\nThese two code samples do the same thing, however the Java version comes with a lot of words that aren't necessarily about telling the computer exactly what to do, e.g. `class Main {`, `public static void main(String[] args) {`, and two extra `}`s. It also has semi-colons at the end of some lines. Neither of these programming languages are wrong, Java however, is aimed at building different things from JavaScript, and these extra bits of code make sense within the constraints of building a Java app.\n\nTo get to the key point though, there is one standout line I'd like us to compare:\n\n``` typescript\n// JavaScript\nvar name = \"Danger\"\n\n// Java\nString name = \"Danger\";\n```\n\nBoth of these lines declare variables called `name` which contain the value `\"Danger\"`.\n\nIn JavaScript you use the abbreviation `var` to declare a variable. Meanwhile, in Java you need to say *what kind of data* the variable contains. In this case the variable contains a `String`. (A string is a programming term for a collection of characters. They `\"look like this\"`. This [5m video](https://www.youtube.com/watch?v=czTWbdwbt7E) is a good primer if you want to learn more.)\n\nBoth of these variables contain a string, but the difference is that in Java the variable can *only* ever contain a *string*, because that's what we said when we created the variable. In JS, the variable can change to be *anything*, like a number, or a list of dates.\n\nTo illustrate:\n\n``` typescript\n// Before in JS\nvar name = \"Danger\"\n// Also OK\nvar name = 1\nvar name = false\nvar name = [\"2018-02-03\", \"2019-01-12\"]\n\n// Before in Java\nString name = \"Danger\";\n// Not OK, the code wouldn't be accepted by Java\nString name = 1;\nString name = false\nString name = new String[]{\"2018-02-03\", \"2019-01-12\"};\n```\n\nThese trade-offs make sense in the context for which these languages were built back in 1995. JavaScript was originally designed to be a small programming language which handled simple interactions on websites. Java on the other hand was built specifically to make complex apps which could run on any computer. They expected to be used to build codebases of different scales, so the language required programmers write different types of code.\n\nJava required programmers to be more explicit with the values of their variables because the programs they expected people to build were more complex. While JavaScript opted for ease of reading by omitting information about the specifics, and expected codebases to be significantly smaller.\n\n### What is TypeScript?\n\nTypeScript is a programming language - it contains all of JavaScript, and then a bit more. Using our example above, let's compare the scripts for \"Hello, Danger\" in JavaScript vs TypeScript:\n\n``` typescript\n// JavaScript\nvar name = \"Danger\"\nconsole.log(\"Hello, \" + name)\n\n// TypeScript\nvar name = \"Danger\"\nconsole.log(\"Hello, \" + name)\n\n// Yep, you're not missing something, there's no difference\n```\n\nDue to TypeScript's goal of only *extending* JavaScript, the existing JavaScript code we saw works as TypeScript. The extensions which TypeScript adds to JavaScript are intended to help you be more explicit about what kinds of data are used in your code, a bit like Java.\n\nHere is the same sample, but using TypeScript to be more explicit about what the variable is:\n\n``` typescript\nvar name: string = \"Danger\"\nconsole.log(\"Hello, \" + name)\n```\n\nThis extra `: string` allow the reader to be certain that `name` will only be a string. Annotating your variables in this way also gives TypeScript the chance to verify that these match. This is *very* useful, because keeping track of changes like the type of value in a variable seems easy when it's one or two, but once it starts hitting the hundreds, that's a lot to keep track of. Writing types help programmers be more confident about their code because types catch mistakes.\n\nSimply speaking, we call these annotations \"Types\". Hence the name *Type*Script. One of the tag-lines for TypeScript is \"JavaScript which scales\" which is a statement that these extra type annotations allows you to work on bigger projects. This is because you can verify up-front how correct your code is. This means you have less need to understand how every change affects the rest of the program.\n\nIn the 90s, and maybe until a 5-10 years ago the trade-off for not having types in your JavaScript application was fine because the size and complexities of the programs being built were constrained to just the front-end of websites. Today though, JavaScript is being used almost everywhere, to build almost anything which runs on a computer. A large amount of mobile and desktop apps use JavaScript and web technology under the hood.\n\nThese are all considerably more complicated to build and understand, adding types drastically reduces the complexity of making improvements to those programs.\n\n### What Problems Can TypeScript Solve?\n\nTypically, the need to ensure there are no bugs in your code can be handled by writing automated tests, then by manually verifying that the code works as you expect and finally having another person validate that it seems correct.\n\nNot many companies are the size of Microsoft, however a lot of all problems writing JavaScript in large codebases are the same. Many JavaScript apps are made up of hundreds of thousands of files. A single change to one individual file can affect the behaviour of any number of other files, like throwing a pebble into a pond and causing ripples to spread out to the bank.\n\nValidating the connections between every part of your project can get time consuming quickly, using a type-checked language like TypeScript can handle that automatically and provide instant feedback during development.\n\nThese features allows TypeScript to help developers feel more confident in their code, and save considerable amounts time in validating that they have not accidentally broken the project.\n\n© 2012-2024 Microsoft  \nLicensed under the Apache License, Version 2.0.  \n[https://www.typescriptlang.org/why-create-typescript/](https://www.typescriptlang.org/why-create-typescript/)"
