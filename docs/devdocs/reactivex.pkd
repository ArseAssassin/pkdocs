---
name: ReactiveX
slug: reactivex
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © ReactiveX contributors
  Licensed under the Apache License 2.0.
  http://reactivex.io/intro.html
homepage: http://reactivex.io/

---
- name: All
  id: documentation/operators/all
  summary: Pass a predicate function to the All operator that accepts an item emitted by the source Observable and returns a boolean value based on an evaluation of that item
  description: "# All\n\ndetermine whether all items emitted by an Observable meet some criteria\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#every)\n\nPass a predicate function to the All operator that accepts an item emitted by the source Observable and returns a boolean value based on an evaluation of that item. All returns an Observable that emits a single boolean value: `true` if and only if the source Observable terminates normally and every item emitted by the source Observable evaluated as `true` according to this predicate; `false` if any item emitted by the source Observable evaluates as `false` according to this predicate.\n\n#### See Also\n\n- [Introduction to Rx: All](http://www.introtorx.com/Content/v1.0.10621.0/06_Inspection.html#All)\n- [RxMarbles: `every`](http://rxmarbles.com/#every)\n\n## Language-Specific Information\n\n### RxGroovy `all`\n\nRxGroovy implements this operator as `all`. It does not by default operate on any particular [Scheduler](../scheduler). The following example shows how to use this operator:\n\n#### Sample Code\n\n``` groovy\nnumbers = Observable.from([1, 2, 3, 4, 5]);\n\nprintln(\"all even?\" )\nnumbers.all({ 0 == (it % 2) }).subscribe({ println(it); });\n\nprintln(\"all positive?\");\nnumbers.all({ 0 < it }).subscribe({ println(it); });\n```\n\n``` javascript\nall even? \nfalse\nall positive? \ntrue\n```\n\n- Javadoc: [`all(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#all(rx.functions.Func1))\n\n### RxJava 1․x `all`\n\nRxJava 1.x implements this operator as `all`. It does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`all(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#all(rx.functions.Func1))\n\n### RxJava 2․x `all`\n\nRxJava 2.x implements this operator as `all`. It does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`all(Predicate)`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#all(io.reactivex.functions.Predicate))\n\n### RxJS `every jortSort jortSortUntil`\n\nRxJS implements this operator as `every`. The following example shows how to use this operator:\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.of(1,2,3,4,5)\n  .every(function (x) {\n    return x < 6;\n  });\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: true\nCompleted\n```\n\n`every` is found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\nIt requires one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThere is also a `jortSort` operator that performs a test on the entire sequence of items emitted by the source Observable. If those items are emitted in sorted order, upon the successful completion of the source Observable, the Observable returned from `jortSort` will emit `true` and then complete. If any of the items emitted by the source Observable is out of sort order, upon the successful completion of the source Observable, the Observable returned from `jortSort` will emit `false` and then complete.\n\nThere is also a `jortSortUntil` operator. It does not wait until the source Observable completes to evaluate its sequence for sortedness, as `jortSort` does, but waits until a second Observable emits an item to do so.\n\n#### See also\n\n- [jort.technology](http://jort.technology)\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.of(1,2,3,4) // already sorted\n               .jortSort();\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (e) { console.log('Error: %s', e); },\n  function ( ) { console.log('Completed'); });\n```\n\n``` javascript\nNext: true\nCompleted\n```\n\n``` javascript\nvar source = Rx.Observable.of(3,1,2,4) // not sorted\n               .jortSort();\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (e) { console.log('Error: %s', e); },\n  function ( ) { console.log('Completed'); });\n```\n\n``` javascript\nNext: false\nCompleted\n```\n\n``` javascript\nvar just = Rx.helpers.just;\n\nvar source = Rx.Observable.of(1,2,3,4) // already sorted\n               .flatmap(function (x) {\n                 return Rx.Observable.timer(1000).map(just(x));\n               }).jortSortUntil(Rx.Observable.timer(3000);\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (e) { console.log('Error: %s', e); },\n  function ( ) { console.log('Completed'); });\n```\n\n``` javascript\nNext: true\nCompleted\n```\n\n``` javascript\nvar just = Rx.helpers.just;\n\nvar source = Rx.Observable.of(3,1,2,4) // not sorted\n               .flatmap(function (x) {\n                 return Rx.Observable.timer(1000).map(just(x));\n               }).jortSortUntil(Rx.Observable.timer(3000);\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (e) { console.log('Error: %s', e); },\n  function ( ) { console.log('Completed'); });\n```\n\n``` javascript\nNext: false\nCompleted\n```\n\n`jortSort` and `jortSortUntil` are found in the following distribution:\n\n- `rx.sorting.js`\n\nThey require one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/all.html](http://reactivex.io/documentation/operators/all.html)"
- name: Amb
  id: documentation/operators/amb
  summary: 'When you pass a number of source Observables to Amb, it will pass through the emissions and notifications of exactly one of these Observables: the first one that sends a notification to Amb, either by emitting an item or sending an onError or onCompleted notification'
  description: "# Amb\n\ngiven two or more source Observables, emit all of the items from only the first of these Observables to emit an item or notification\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#amb)\n\nWhen you pass a number of source Observables to Amb, it will pass through the emissions and notifications of exactly one of these Observables: the first one that sends a notification to Amb, either by emitting an item or sending an `onError` or `onCompleted` notification. Amb will ignore and discard the emissions and notifications of all of the other source Observables.\n\n#### See Also\n\n- [RxMarbles: `amb`](http://rxmarbles.com/#amb)\n\n## Language-Specific Information\n\n### RxGroovy `amb ambWith`\n\nRxGroovy implements this operator as `amb`. It takes up to nine Observables as individual parameters, or a single Iterable of Observables. There is also an instance version of the operator, `ambWith`, so that, for example, instead of writing `Observable.amb(o1,o2)` you could also write `o1.ambWith(o2)` for the same effect.\n\nThis operator does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`amb(Iterable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(java.lang.Iterable))\n- Javadoc: [`amb(Observable,Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(rx.Observable,%20rx.Observable)) (there are also versions that take up to nine Observable parameters)\n- Javadoc: [`ambWith(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#ambWith(rx.Observable))\n\n### RxJava 1․x `amb ambWith`\n\nRxJava 1.x implements this operator as `amb`. It takes up to nine Observables as individual parameters, or a single Iterable of Observables. There is also an instance version of the operator, `ambWith`, so that, for example, instead of writing `Observable.amb(o1,o2)` you could also write `o1.ambWith(o2)` for the same effect.\n\nThis operator does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`amb(Iterable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(java.lang.Iterable))\n- Javadoc: [`amb(Observable,Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(rx.Observable,%20rx.Observable)) (there are also versions that take up to nine Observable parameters)\n- Javadoc: [`ambWith(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#ambWith(rx.Observable))\n\n### RxJava 2․x `amb ambArray ambWith`\n\nRxJava 2.x implements this operator as `amb`. It takes an Iterable of Observables as its parameter. You can also use `ambArray` to pass an array of Observables. There is also an instance version of the operator, `ambWith`, so that, for example, instead of writing `Observable.ambArray([o1,o2])` you could also write `o1.ambWith(o2)` for the same effect.\n\nThis operator does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`amb(Iterable)`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#amb(java.lang.Iterable))\n- Javadoc: [`ambArray(Iterable)`](#)\n- Javadoc: [`ambWith(Observable)`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#ambWith(io.reactivex.ObservableSource))\n\n### RxJS `amb`\n\nRxJS implements this operator as `amb`. It takes a variable number of parameters, which may be either Observables or Promises (or combinations of the two).\n\n#### Sample Code\n\n``` javascript\n/* Using Observable sequences */\nvar source = Rx.Observable.amb(\n    Rx.Observable.timer(500).select(function () { return 'foo'; }),\n    Rx.Observable.timer(200).select(function () { return 'bar'; })\n);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: bar\nCompleted\n```\n\n``` javascript\n/* Using Promises and Observables */\nvar source = Rx.Observable.amb(\n    RSVP.Promise.resolve('foo')\n    Rx.Observable.timer(200).select(function () { return 'bar'; })\n);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: foo\nCompleted\n```\n\n### RxPHP `race`\n\nRxPHP implements this operator as `race`.\n\nPropagates the observable sequence that reacts first. Also known as 'amb'.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/race/race.php\n\n$source = Rx\\Observable::race(\n    [\n        Rx\\Observable::timer(500)->map(function () {\n            return 'foo';\n        }),\n        Rx\\Observable::timer(200)->map(function () {\n            return 'bar';\n        })\n    ]\n);\n\n$source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: bar\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/amb.html](http://reactivex.io/documentation/operators/amb.html)"
- name: And/Then/When
  id: documentation/operators/and-then-when
  summary: The combination of the And, Then, and When operators behave much like the Zip operator, but they do so by means of intermediate data structures
  description: "# And/Then/When\n\ncombine sets of items emitted by two or more Observables by means of Pattern and Plan intermediaries\n\nThe combination of the And, Then, and When operators behave much like the Zip operator, but they do so by means of intermediate data structures. And accepts two or more Observables and combines the emissions from each, one set at a time, into `Pattern` objects. Then operates on such `Pattern` objects, transforming them in a `Plan`. When in turn transforms these various `Plan` objects into emissions from an Observable.\n\n#### See Also\n\n- [Zip](zip)\n- [Introduction to Rx: And-Then-When](http://www.introtorx.com/content/v1.0.10621.0/12_CombiningSequences.html#AndThenWhen)\n\n## Language-Specific Information\n\n### RxGroovy `and then when`\n\nIn RxGroovy, these are not part of the core ReactiveX implementation, but are found as `and`, `then`, and `when` in the `rxjava-joins` module.\n\n### RxJava 1․x `and then when`\n\nThese are not part of the core RxJava implementation, but are found as `and`, `then`, and `when` in the `rxjava-joins` module.\n\n### RxJS `and thenDo when`\n\nRxJS implements these operators as `and`, `thenDo`, and `when`.\n\nThese are found in the following packages:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.joinpatterns.js`\n\nThey require one of the following packages:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/and-then-when.html](http://reactivex.io/documentation/operators/and-then-when.html)"
- name: Average
  id: documentation/operators/average
  summary: 'The Average operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single value: the average of all of the numbers emitted by the source Observable'
  description: "# Average\n\ncalculates the average of numbers emitted by an Observable and emits this average\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#average)\n\nThe Average operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single value: the average of all of the numbers emitted by the source Observable.\n\n#### See Also\n\n- [Sum](sum)\n- [Introduction to Rx: Min, Max, Sum, and Average](http://www.introtorx.com/Content/v1.0.10621.0/07_Aggregation.html#MaxAndMin)\n- [RxMarbles: `average`](http://rxmarbles.com/#average)\n\n## Language-Specific Information\n\n### RxGroovy `averageDouble averageFloat averageInteger averageLong`\n\nIn RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct `rxjava-math` module, where it is implemented with four type-specific operators: `averageDouble`, `averageFloat`, `averageInteger`, and `averageLong`. The following example shows how these operators work:\n\n#### Sample Code\n\n``` groovy\ndef myObservable = Observable.create({ aSubscriber ->\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext(4);\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext(3);\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext(2);\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext(1);\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onCompleted();\n});\n\nObservable.averageInteger(myObservable).subscribe(\n  { println(it); },                  // onNext\n  { println(\"Error encountered\"); }, // onError\n  { println(\"Sequence complete\"); }  // onCompleted\n);\n```\n\n``` javascript\n2\nSequence complete\n```\n\nYou can also average not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the average number of sides on the figures emitted by the source Observable.\n\nThis operator will fail with an `IllegalArgumentException` if the source Observable does not emit any items.\n\n### RxJava 1․x `averageDouble averageFloat averageInteger averageLong`\n\nThis operator is not in the RxJava core, but is part of the distinct `rxjava-math` module, where it is implemented with four type-specific operators: `averageDouble`, `averageFloat`, `averageInteger`, and `averageLong`.\n\nYou can also average not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the average number of sides on the figures emitted by the source Observable.\n\nThis operator will fail with an `IllegalArgumentException` if the source Observable does not emit any items.\n\n### RxJS `average`\n\nRxJS implements this operator as `average`. The following code sample shows how to use it:\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 9).average();\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x);\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nNext: 4\nCompleted\n```\n\nYou can also average not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the average number of sides on the figures emitted by the source Observable.\n\n#### Sample Code\n\n``` javascript\nvar arr = [\n    { value: 1 },\n    { value: 2 },\n    { value: 3 }\n];\n\nvar source = Rx.Observable.fromArray(arr).average(function (x) {\n    return x.value;\n});\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x);\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nNext: 2\nCompleted\n```\n\n`average` is found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\nIt requires one of the following:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `average`\n\nRxPHP implements this operator as `average`.\n\nComputes the average of an observable sequence of values.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/average/average.php\n\n$source = Rx\\Observable::range(0, 9)->average();\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 4\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/average.html](http://reactivex.io/documentation/operators/average.html)"
- name: Backpressure Operators
  id: documentation/operators/backpressure
  summary: In ReactiveX it is not difficult to get into a situation in which an Observable is emitting items more rapidly than an operator or observer can consume them
  description: "# Backpressure Operators\n\nstrategies for coping with Observables that produce items more rapidly than their observers consume them\n\nIn ReactiveX it is not difficult to get into a situation in which an Observable is emitting items more rapidly than an operator or observer can consume them. This presents the problem of what to do with such a growing backlog of unconsumed items.\n\nFor example, imagine using the [Zip](zip) operator to zip together two infinite Observables, one of which emits items twice as frequently as the other. A naive implementation of the operator would have to maintain an ever-expanding buffer of items emitted by the faster Observable to eventually combine with items emitted by the slower one. This could cause ReactiveX to seize an unwieldy amount of system resources.\n\nThere are a variety of strategies with which you can exercise flow control and backpressure in ReactiveX in order to alleviate the problems caused when a quickly-producing Observable meets a slow-consuming observer, which include, in some ReactiveX implementations, reactive pull backpressure and some backpressure-specific operators.\n\nA cold Observable emits a particular sequence of items, but can begin emitting this sequence when its observer finds it to be convenient, and at whatever rate the observer desires, without disrupting the integrity of the sequence. For example if you convert a static iterable into an Observable, that Observable will emit the same sequence of items no matter when it is later subscribed to or how frequently those items are observed. Examples of items emitted by a cold Observable might include the results of a database query, file retrieval, or web request.\n\nA hot Observable begins generating items to emit immediately when it is created. Subscribers typically begin observing the sequence of items emitted by a hot Observable from somewhere in the middle of the sequence, beginning with the first item emitted by the Observable subsequent to the establishment of the subscription. Such an Observable emits items at its own pace, and it is up to its observers to keep up. Examples of items emitted by a hot Observable might include mouse & keyboard events, system events, or stock prices.\n\nWhen a cold Observable is multicast (when it is converted into a connectable Observable and its [Connect](connect) method is called), it effectively becomes hot and for the purposes of backpressure and flow-control it should be treated as a hot Observable.\n\nCold Observables are ideal for the reactive pull model of backpressure implemented by some implementations of ReactiveX (which is described elsewhere). Hot Observables typically do not cope well with a reactive pull model, and are better candidates for other flow control strategies, such as the use of the operators described on this page, or operators like [Buffer](buffer), [Sample](sample), [Debounce](debounce), or [Window](window).\n\n#### See Also\n\n- [Buffer](buffer)\n- [Sample](sample)\n- [Debounce](debounce)\n- [Window](window)\n\n## Language-Specific Information\n\n### RxGroovy `onBackpressureBuffer onBackpressureDrop onBackpressureLatest`\n\nRxGroovy implements reactive pull backpressure, and many of its operators support that form of backpressure. It also has three operators that you can apply to Observables that have not been written to support backpressure:\n\n`onBackpressureBuffer` maintains a buffer of all unobserved emissions from the source Observable and emits them to downstream observers according to the requests they generate.\n\nA version of this operator that was introduced in RxGroovy 1.1 allows you to set the capacity of the buffer; applying this operator will cause the resulting Observable to terminate with an error if this buffer is overrun. A second version, introduced during the same release, allows you to set an `Action` that `onBackpressureBuffer` will call if the buffer is overrun.\n\n- Javadoc: [`onBackpressureBuffer()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onBackpressureBuffer())\n- Javadoc: [`onBackpressureBuffer(long)` (RxGroovy 1.1)](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onBackpressureBuffer(long))\n- Javadoc: [`onBackpressureBuffer(long, Action0)` (RxGroovy 1.1)](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onBackpressureBuffer(long,%20rx.functions.Action0))\n\n`onBackpressureDrop` drops emissions from the source Observable unless there is a pending request from a downstream observer, in which case it will emit enough items to fulfill the request.\n\nA version of this operator that was introduced in the 1.1 release notifies you, by means of an `Action` you pass as a parameter, when an item has been dropped and which item was dropped.\n\n- Javadoc: [`onBackpressureDrop()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onBackpressureDrop())\n- Javadoc: [onBackpressureDrop(Action1) (RxGroovy 1.1)](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onBackpressureDrop(rx.functions.Action1))\n\n`onBackpressureLatest` (new in RxJava 1.1) holds on to the most-recently emitted item from the source Observable and immediately emits that item to its observer upon request. It drops any other items that it observes between requests from its observer.\n\n- Javadoc: [`onBackpressureLatest()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onBackpressureLatest())\n\n### RxJava 1․x `onBackpressureBuffer onBackpressureDrop onBackpressureLatest`\n\nRxJava implements reactive pull backpressure, and many of its operators support that form of backpressure. It also has three operators that you can apply to Observables that have not been written to support backpressure:\n\n`onBackpressureBuffer` maintains a buffer of all unobserved emissions from the source Observable and emits them to downstream observers according to the requests they generate.\n\nA version of this operator that was introduced in RxJava 1.1 allows you to set the capacity of the buffer; applying this operator will cause the resulting Observable to terminate with an error if this buffer is overrun. A second version, introduced during the same release, allows you to set an `Action` that `onBackpressureBuffer` will call if the buffer is overrun.\n\n- Javadoc: [`onBackpressureBuffer()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onBackpressureBuffer())\n- Javadoc: [`onBackpressureBuffer(long)` (RxJava 1.1)](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onBackpressureBuffer(long))\n- Javadoc: [`onBackpressureBuffer(long, Action0)` (RxJava 1.1)](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onBackpressureBuffer(long,%20rx.functions.Action0))\n\n`onBackpressureDrop` drops emissions from the source Observable unless there is a pending request from a downstream observer, in which case it will emit enough items to fulfill the request.\n\nA version of this operator that was introduced in the 1.1 release notifies you, by means of an `Action` you pass as a parameter, when an item has been dropped and which item was dropped.\n\n- Javadoc: [`onBackpressureDrop()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onBackpressureDrop())\n- Javadoc: [onBackpressureDrop(Action1) (RxJava 1.1)](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onBackpressureDrop(rx.functions.Action1))\n\n`onBackpressureLatest` (new in RxJava 1.1) holds on to the most-recently emitted item from the source Observable and immediately emits that item to its observer upon request. It drops any other items that it observes between requests from its observer.\n\n- Javadoc: [`onBackpressureLatest()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onBackpressureLatest())\n\n### RxJS `controlled pausable pausableBuffered stopAndWait windowed`\n\nRxJS implements backpressure by transforming an ordinary Observable into a `ControlledObservable` with the `controlled` operator. This forces the Observable to respect pull `request`s from its observer rather than pushing items on its own initiative.\n\nAs an alternative to using `request` to pull items from a `ControlledObservable`, you may apply the `stopAndWait` operator to it. This operator will request a new item from the Observable each time its observers’ `onNext` routine receives the latest item.\n\nA second possibility is to use the `windowed(`*n*`)`. This behaves similarly to `stopAndWait` but has an internal buffer of *n* items, which allows the `ControlledObservable` to run somewhat ahead of the observer from time to time. `windowed(1)` is equivalent to `stopAndWait`.\n\nThere are also two operators that convert an ordinary Observable into at `PausableObservable`.\n\nIf you call the `pause` method of a `PausableObservable` created with the `pausable` operator, it will drop (ignore) any items emitted by the underlying source Observable until such time as you call its `resume` method, whereupon it will continue to pass along emitted items to its observers.\n\n#### See Also\n\n- [RxMarbles: `pausable`](http://rxmarbles.com/#pausable)\n\nIf you call the `pause` method of a `PausableObservable` created with the `pausableBuffered` operator, it will buffer any items emitted by the underlying source Observable until such time as you call its `resume` method, whereupon it will emit those buffered items and then continue to pass along any additional emitted items to its observers.\n\n#### See Also\n\n- [RxMarbles: `pausableBuffered`](http://rxmarbles.com/#pausableBuffered)\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/backpressure.html](http://reactivex.io/documentation/operators/backpressure.html)"
- name: Buffer
  id: documentation/operators/buffer
  summary: The Buffer operator transforms an Observable that emits items into an Observable that emits buffered collections of those items
  description: "# Buffer\n\nperiodically gather items emitted by an Observable into bundles and emit these bundles rather than emitting the items one at a time\n\nThe Buffer operator transforms an Observable that emits items into an Observable that emits buffered collections of those items. There are a number of variants in the various language-specific implementations of Buffer that differ in how they choose which items go in which buffers.\n\nNote that if the source Observable issues an `onError` notification, Buffer will pass on this notification immediately without first emitting the buffer it is in the process of assembling, even if that buffer contains items that were emitted by the source Observable before it issued the error notification.\n\nThe [Window](window) operator is similar to Buffer but collects items into separate Observables rather than into data structures before reemitting them.\n\n#### See Also\n\n- [Window](window)\n- [Introduction to Rx: Buffer](http://www.introtorx.com/Content/v1.0.10621.0/13_TimeShiftedSequences.html#Buffer)\n- [Introduction to Rx: Buffer revisited](http://www.introtorx.com/Content/v1.0.10621.0/17_SequencesOfCoincidence.html#BufferRevisted)\n- [101 Rx Samples: Buffer — Simple](http://rxwiki.wikidot.com/101samples#toc26)\n\n## Language-Specific Information\n\n### RxCpp `buffer pairwise`\n\nRxCpp implements two variants of Buffer:\n\n#### `buffer(count)`\n\n`buffer(count)` emits non-overlapping buffers in the form of `vector`s, each of which contains at most `count` items from the source Observable (the final emitted `vector` may have fewer than `count` items).\n\n#### `buffer(count, skip)`\n\n`buffer(count, skip)` creates a new buffer starting with the first emitted item from the source Observable, and every `skip` items thereafter, and fills each buffer with `count` items: the initial item and `count-1` subsequent ones. It emits these buffers as `vector`s. Depending on the values of `count` and `skip` these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).\n\n### RxGroovy `buffer`\n\nIn RxGroovy there are several variants of Buffer:\n\n#### `buffer(count)`\n\n`buffer(count)` emits non-overlapping buffers in the form of `List`s, each of which contains at most `count` items from the source Observable (the final emitted `List` may have fewer than `count` items).\n\n- Javadoc: [`buffer(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int))\n\n#### `buffer(count, skip)`\n\n`buffer(count, skip)` creates a new buffer starting with the first emitted item from the source Observable, and every `skip` items thereafter, and fills each buffer with `count` items: the initial item and `count-1` subsequent ones. It emits these buffers as `List`s. Depending on the values of `count` and `skip` these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).\n\n- Javadoc: [`buffer(int,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int,%20int))\n\n#### `buffer(bufferClosingSelector)`\n\nWhen it subscribes to the source Observable, `buffer(bufferClosingSelector)` begins to collect its emissions into a `List`, and it also calls `bufferClosingSelector` to generate a second Observable. When this second Observable emits an `TClosing` object, `buffer` emits the current `List` and repeats this process: beginning a new `List` and calling `bufferClosingSelector` to create a new Observable to monitor. It will do this until the source Observable terminates.\n\n- Javadoc: [`buffer(Func0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0))\n\n#### `buffer(boundary`\\[`, initialCapacity`\\]`)`\n\n`buffer(boundary)` monitors an Observable, `boundary`. Each time that Observable emits an item, it creates a new `List` to begin collecting items emitted by the source Observable and emits the previous `List`.\n\n- Javadoc: [`buffer(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable))\n- Javadoc: [`buffer(Observable,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20int))\n\n#### `buffer(bufferOpenings, bufferClosingSelector)`\n\n`buffer(bufferOpenings, bufferClosingSelector)` monitors an Observable, `bufferOpenings`, that emits `BufferOpening` objects. Each time it observes such an emitted item, it creates a new `List` to begin collecting items emitted by the source Observable and it passes the `bufferOpenings` Observable into the `closingSelector` function. That function returns an Observable. `buffer` monitors that Observable and when it detects an emitted item from it, it closes the `List` and emits it as its own emission.\n\n- Javadoc: [`buffer(Observable,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20rx.functions.Func1))\n\n#### `buffer(timespan, unit`\\[`, scheduler`\\]`)`\n\n`buffer(timespan, unit)` emits a new `List` of items periodically, every `timespan` amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a [`Scheduler`](../scheduler) as a parameter and uses it to govern the timespan; by default this variant uses the `computation` Scheduler.\n\n- Javadoc: [`buffer(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`buffer(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n#### `buffer(timespan, unit, count`\\[`, scheduler`\\]`)`\n\n`buffer(timespan, unit, count)` emits a new `List` of items for every `count` items emitted by the source Observable, or, if `timespan` has elapsed since its last bundle emission, it emits a bundle of however many items the source Observable has emitted in that span, even if this is fewer than `count`. There is also a version of this variant of the operator that takes a [`Scheduler`](../scheduler) as a parameter and uses it to govern the timespan; by default this variant uses the `computation` scheduler.\n\n- Javadoc: [`buffer(long,TimeUnit,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int))\n- Javadoc: [`buffer(long,TimeUnit,int,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler))\n\n#### `buffer(timespan, timeshift, unit`\\[`, scheduler`\\]`)`\n\n`buffer(timespan, timeshift, unit)` creates a new `List` of items every `timeshift` period of time, and fills this bundle with every item emitted by the source Observable from that time until `timespan` time has passed since the bundle’s creation, before emitting this `List` as its own emission. If `timespan` is longer than `timeshift`, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a [`Scheduler`](../scheduler) as a parameter and uses it to govern the timespan; by default this variant uses the `computation` scheduler.\n\n- Javadoc: [`buffer(long,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`buffer(long,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nYou can use the Buffer operator to implement backpressure (that is, to cope with an Observable that may produce items too quickly for its observer to consume).\n\nBuffer can reduce a sequence of many items to a sequence of fewer buffers-of-items, making them more manageable. You could, for example, close and emit a buffer of items from a bursty Observable periodically, at a regular interval of time.\n\n#### Sample Code\n\n``` groovy\nObservable<List<Integer>> burstyBuffered = bursty.buffer(500, TimeUnit.MILLISECONDS);\n```\n\nOr you could get fancy, and collect items in buffers during the bursty periods and emit them at the end of each burst, by using the [Debounce](debounce) operator to emit a buffer closing indicator to the buffer operator.\n\n#### Sample Code\n\n``` groovy\n// we have to multicast the original bursty Observable so we can use it\n// both as our source and as the source for our buffer closing selector:\nObservable<Integer> burstyMulticast = bursty.publish().refCount();\n// burstyDebounced will be our buffer closing selector:\nObservable<Integer> burstyDebounced = burstyMulticast.debounce(10, TimeUnit.MILLISECONDS);\n// and this, finally, is the Observable of buffers we're interested in:\nObservable<List<Integer>> burstyBuffered = burstyMulticast.buffer(burstyDebounced);\n```\n\n### RxJava 1․x `buffer`\n\nIn RxJava there are several variants of Buffer:\n\n#### `buffer(count)`\n\n`buffer(count)` emits non-overlapping buffers in the form of `List`s, each of which contains at most `count` items from the source Observable (the final emitted `List` may have fewer than `count` items).\n\n- Javadoc: [`buffer(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int))\n\n#### `buffer(count, skip)`\n\n`buffer(count, skip)` creates a new buffer starting with the first emitted item from the source Observable, and every `skip` items thereafter, and fills each buffer with `count` items: the initial item and `count-1` subsequent ones. It emits these buffers as `List`s. Depending on the values of `count` and `skip` these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).\n\n- Javadoc: [`buffer(int,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int,%20int))\n\n#### `buffer(bufferClosingSelector)`\n\nWhen it subscribes to the source Observable, `buffer(bufferClosingSelector)` begins to collect its emissions into a `List`, and it also calls `bufferClosingSelector` to generate a second Observable. When this second Observable emits an `TClosing` object, `buffer` emits the current `List` and repeats this process: beginning a new `List` and calling `bufferClosingSelector` to create a new Observable to monitor. It will do this until the source Observable terminates.\n\n- Javadoc: [`buffer(Func0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0))\n\n#### `buffer(boundary)`\n\n`buffer(boundary)` monitors an Observable, `boundary`. Each time that Observable emits an item, it creates a new `List` to begin collecting items emitted by the source Observable and emits the previous `List`.\n\n- Javadoc: [`buffer(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable))\n- Javadoc: [`buffer(Observable,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20int))\n\n#### `buffer(bufferOpenings, bufferClosingSelector)`\n\n`buffer(bufferOpenings, bufferClosingSelector)` monitors an Observable, `bufferOpenings`, that emits `BufferOpening` objects. Each time it observes such an emitted item, it creates a new `List` to begin collecting items emitted by the source Observable and it passes the `bufferOpenings` Observable into the `closingSelector` function. That function returns an Observable. `buffer` monitors that Observable and when it detects an emitted item from it, it closes the `List` and emits it as its own emission.\n\n- Javadoc: [`buffer(Observable,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20rx.functions.Func1))\n\n#### `buffer(timespan, unit`\\[`, scheduler`\\]`)`\n\n`buffer(timespan, unit)` emits a new `List` of items periodically, every `timespan` amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a [`Scheduler`](../scheduler) as a parameter and uses it to govern the timespan; by default this variant uses the `computation` scheduler.\n\n- Javadoc: [`buffer(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`buffer(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n#### `buffer(timespan, unit, count`\\[`, scheduler`\\]`)`\n\n`buffer(timespan, unit, count)` emits a new `List` of items for every `count` items emitted by the source Observable, or, if `timespan` has elapsed since its last bundle emission, it emits a bundle of however many items the source Observable has emitted in that span, even if this is fewer than `count`. There is also a version of this variant of the operator that takes a [`Scheduler`](../scheduler) as a parameter and uses it to govern the timespan; by default this variant uses the `computation` scheduler.\n\n- Javadoc: [`buffer(long,TimeUnit,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int))\n- Javadoc: [`buffer(long,TimeUnit,int,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler))\n\n#### `buffer(timespan, timeshift, unit`\\[`, scheduler`\\]`)`\n\n`buffer(timespan, timeshift, unit)` creates a new `List` of items every `timeshift` period of time, and fills this bundle with every item emitted by the source Observable from that time until `timespan` time has passed since the bundle’s creation, before emitting this `List` as its own emission. If `timespan` is longer than `timeshift`, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a [`Scheduler`](../scheduler) as a parameter and uses it to govern the timespan; by default this variant uses the `computation` scheduler.\n\n- Javadoc: [`buffer(long,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`buffer(long,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nYou can use the Buffer operator to implement backpressure (that is, to cope with an Observable that may produce items too quickly for its observer to consume).\n\nBuffer can reduce a sequence of many items to a sequence of fewer buffers-of-items, making them more manageable. You could, for example, close and emit a buffer of items from a bursty Observable periodically, at a regular interval of time.\n\n#### Sample Code\n\n``` java\nObservable<List<Integer>> burstyBuffered = bursty.buffer(500, TimeUnit.MILLISECONDS);\n```\n\nOr you could get fancy, and collect items in buffers during the bursty periods and emit them at the end of each burst, by using the [Debounce](debounce) operator to emit a buffer closing indicator to the buffer operator.\n\n#### Sample Code\n\n``` java\n// we have to multicast the original bursty Observable so we can use it\n// both as our source and as the source for our buffer closing selector:\nObservable<Integer> burstyMulticast = bursty.publish().refCount();\n// burstyDebounced will be our buffer closing selector:\nObservable<Integer> burstyDebounced = burstyMulticast.debounce(10, TimeUnit.MILLISECONDS);\n// and this, finally, is the Observable of buffers we're interested in:\nObservable<List<Integer>> burstyBuffered = burstyMulticast.buffer(burstyDebounced);\n```\n\n#### See Also\n\n- [DebouncedBuffer With RxJava by Gopal Kaushik](http://blog.kaush.co/2015/01/05/debouncedbuffer-with-rxjava/)\n- [DebounceBuffer: Use publish(), debounce() and buffer() together to capture bursts of events. by Ben Christensen](https://gist.github.com/benjchristensen/e4524a308456f3c21c0b#file-debouncebufferpublish-java)\n\n### RxJS `buffer bufferWithCount bufferWithTime bufferWithTimeOrCount`\n\nRxJS has four Buffer operators — `buffer`, `bufferWithCount`, `bufferWithTime`, and `bufferWithTimeOrCount` — each of which has variants that have different ways of governing which source Observable items are emitted as part of which buffers.\n\n#### `buffer(bufferBoundaries)`\n\n`buffer(bufferBoundaries)` monitors an Observable, `bufferBoundaries`. Each time that Observable emits an item, it creates a new collection to begin collecting items emitted by the source Observable and emits the previous collection.\n\n#### `buffer(bufferClosingSelector)`\n\nWhen it subscribes to the source Observable, `buffer(bufferClosingSelector)` begins to collect its emissions into a collection, and it also calls `bufferClosingSelector` to generate a second Observable. When this second Observable emits an item, `buffer` emits the current collection and repeats this process: beginning a new collection and calling `bufferClosingSelector` to create a new Observable to monitor. It will do this until the source Observable terminates.\n\n#### `buffer(bufferOpenings,bufferClosingSelector)`\n\n`buffer(bufferOpenings, bufferClosingSelector)` monitors an Observable, `bufferOpenings`, that emits `BufferOpening` objects. Each time it observes such an emitted item, it creates a new collection to begin collecting items emitted by the source Observable and it passes the `bufferOpenings` Observable into the `bufferClosingSelector` function. That function returns an Observable. `buffer` monitors that Observable and when it detects an emitted item from it, it emits the current collection and begins a new one.\n\n`buffer` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.coincidence.js`\n\n`buffer` requires one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n#### `bufferWithCount(count)`\n\n`bufferWithCount(count)` emits non-overlapping buffers, each of which contains at most `count` items from the source Observable (the final emitted buffer may contain fewer than `count` items).\n\n#### `bufferWithCount(count, skip)`\n\n`bufferWithCount(count, skip)` creates a new buffer starting with the first emitted item from the source Observable, and a new one for every `skip` items thereafter, and fills each buffer with `count` items: the initial item and `count-1` subsequent ones, emitting each buffer when it is complete. Depending on the values of `count` and `skip` these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).\n\n`bufferWithCount` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.lite.extras.js`\n\n#### `bufferWithTime(timeSpan)`\n\n`bufferWithTime(timeSpan)` emits a new collection of items periodically, every `timeSpan` milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a [`Scheduler`](../scheduler) as a parameter and uses it to govern the timespan; by default this variant uses the `timeout` scheduler.\n\n#### `bufferWithTime(timeSpan, timeShift)`\n\n`bufferWithTime(timeSpan, timeShift)` creates a new collection of items every `timeShift` milliseconds, and fills this bundle with every item emitted by the source Observable from that time until `timeSpan` milliseconds has passed since the collection’s creation, before emitting this collection as its own emission. If `timeSpan` is longer than `timeShift`, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a [`Scheduler`](../scheduler) as a parameter and uses it to govern the timespan; by default this variant uses the `timeout` scheduler.\n\n#### `bufferWithTimeOrCount(timeSpan, count)`\n\n`bufferWithTimeOrCount(timeSpan, count)` emits a new collection of items for every `count` items emitted by the source Observable, or, if `timeSpan` milliseconds have elapsed since its last collection emission, it emits a collection of however many items the source Observable has emitted in that span, even if this is fewer than `count`. There is also a version of this variant of the operator that takes a [`Scheduler`](../scheduler) as a parameter and uses it to govern the timespan; by default this variant uses the `timeout` scheduler.\n\n`bufferWithTime` and `bufferWithTimeOrCount` are found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.time.js`\n\n`bufferWithTime` and `bufferWithTimeOrCount` require one of the following distributions:\n\n- `rx.time.js` requires `rx.js` or `rx.compat.js`\n- otherwise: `rx.lite.js` or `rx.lite.compat.js`\n\n### RxKotlin `buffer`\n\nIn RxKotlin there are several variants of Buffer:\n\n#### `buffer(count)`\n\n`buffer(count)` emits non-overlapping buffers in the form of `List`s, each of which contains at most `count` items from the source Observable (the final emitted `List` may have fewer than `count` items).\n\n#### `buffer(count, skip)`\n\n`buffer(count, skip)` creates a new buffer starting with the first emitted item from the source Observable, and every `skip` items thereafter, and fills each buffer with `count` items: the initial item and `count-1` subsequent ones. It emits these buffers as `List`s. Depending on the values of `count` and `skip` these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).\n\n#### `buffer(bufferClosingSelector)`\n\nWhen it subscribes to the source Observable, `buffer(bufferClosingSelector)` begins to collect its emissions into a `List`, and it also calls `bufferClosingSelector` to generate a second Observable. When this second Observable emits an `TClosing` object, `buffer` emits the current `List` and repeats this process: beginning a new `List` and calling `bufferClosingSelector` to create a new Observable to monitor. It will do this until the source Observable terminates.\n\n#### `buffer(boundary)`\n\n`buffer(boundary)` monitors an Observable, `boundary`. Each time that Observable emits an item, it creates a new `List` to begin collecting items emitted by the source Observable and emits the previous `List`.\n\n#### `buffer(bufferOpenings, bufferClosingSelector)`\n\n`buffer(bufferOpenings, bufferClosingSelector)` monitors an Observable, `bufferOpenings`, that emits `BufferOpening` objects. Each time it observes such an emitted item, it creates a new `List` to begin collecting items emitted by the source Observable and it passes the `bufferOpenings` Observable into the `closingSelector` function. That function returns an Observable. `buffer` monitors that Observable and when it detects an emitted item from it, it closes the `List` and emits it as its own emission.\n\n#### `buffer(timespan, unit`\\[`, scheduler`\\]`)`\n\n`buffer(timespan, unit)` emits a new `List` of items periodically, every `timespan` amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a [`Scheduler`](../scheduler) as a parameter and uses it to govern the timespan; by default this variant uses the `computation` scheduler.\n\n#### `buffer(timespan, unit, count`\\[`, scheduler`\\]`)`\n\n`buffer(timespan, unit, count)` emits a new `List` of items for every `count` items emitted by the source Observable, or, if `timespan` has elapsed since its last bundle emission, it emits a bundle of however many items the source Observable has emitted in that span, even if this is fewer than `count`. There is also a version of this variant of the operator that takes a [`Scheduler`](../scheduler) as a parameter and uses it to govern the timespan; by default this variant uses the `computation` scheduler.\n\n#### `buffer(timespan, timeshift, unit`\\[`, scheduler`\\]`)`\n\n`buffer(timespan, timeshift, unit)` creates a new `List` of items every `timeshift` period of time, and fills this bundle with every item emitted by the source Observable from that time until `timespan` time has passed since the bundle’s creation, before emitting this `List` as its own emission. If `timespan` is longer than `timeshift`, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a [`Scheduler`](../scheduler) as a parameter and uses it to govern the timespan; by default this variant uses the `computation` scheduler.\n\n### RxNET `Buffer`\n\nIn Rx.NET there are several variants of Buffer. For each variety you can either pass in the source Observable as the first parameter, or you can call it as an instance method of the source Observable (in which case you can omit that parameter):\n\n#### `Buffer(count)`\n\n`Buffer(count)` emits non-overlapping buffers in the form of `IList`s, each of which contains at most `count` items from the source Observable (the final emitted `IList` may have fewer than `count` items).\n\n#### `Buffer(count, skip)`\n\n`Buffer(count, skip)` creates a new buffer starting with the first emitted item from the source Observable, and every `skip` items thereafter, and fills each buffer with `count` items: the initial item and `count-1` subsequent ones. It emits these buffers as `IList`s. Depending on the values of `count` and `skip` these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).\n\n#### `Buffer(bufferClosingSelector)`\n\nWhen it subscribes to the source Observable, `Buffer(bufferClosingSelector)` begins to collect its emissions into an `IList`, and it also calls `bufferClosingSelector` to generate a second Observable. When this second Observable emits an `TBufferClosing` object, `Buffer` emits the current `IList` and repeats this process: beginning a new `IList` and calling `bufferClosingSelector` to create a new Observable to monitor. It will do this until the source Observable terminates.\n\n#### `Buffer(bufferOpenings,bufferClosingSelector)`\n\n`Buffer(bufferOpenings, bufferClosingSelector)` monitors an Observable, `BufferOpenings`, that emits `TBufferOpening` objects. Each time it observes such an emitted item, it creates a new `IList` to begin collecting items emitted by the source Observable and it passes the `TBufferOpening` object into the `bufferClosingSelector` function. That function returns an Observable. `Buffer` monitors that Observable and when it detects an emitted item from it, it closes the `IList` and emits it as its own emission.\n\n#### `Buffer(timeSpan)`\n\n`Buffer(timeSpan)` emits a new `IList` of items periodically, every `timeSpan` amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first list, since the subscription to the source Observable. There is also a version of this variant of the operator that takes an [`IScheduler`](../scheduler) as a parameter and uses it to govern the timespan.\n\n#### `Buffer(timeSpan, count)`\n\n`Buffer(timeSpan, count)` emits a new `IList` of items for every `count` items emitted by the source Observable, or, if `timeSpan` has elapsed since its last list emission, it emits a list of however many items the source Observable has emitted in that span, even if this is fewer than `count`. There is also a version of this variant of the operator that takes an [`IScheduler`](../scheduler) as a parameter and uses it to govern the timespan.\n\n#### `Buffer(timeSpan, timeShift)`\n\n`Buffer(timeSpan, timeShift)` creates a new `IList` of items every `timeShift` period of time, and fills this list with every item emitted by the source Observable from that time until `timeSpan` time has passed since the list’s creation, before emitting this `IList` as its own emission. If `timeSpan` is longer than `timeShift`, the emitted lists will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes an [`IScheduler`](../scheduler) as a parameter and uses it to govern the timespan.\n\n### RxPHP `bufferWithCount`\n\nRxPHP implements this operator as `bufferWithCount`.\n\nProjects each element of an observable sequence into zero or more buffers which are produced based on element count information.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/bufferWithCount/bufferWithCount.php\n\n$source = Rx\\Observable::range(1, 6)\n    ->bufferWithCount(2)\n    ->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: [1,2]\nNext value: [3,4]\nNext value: [5,6]\nComplete!\n```\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/bufferWithCount/bufferWithCountAndSkip.php\n\n$source = Rx\\Observable::range(1, 6)\n    ->bufferWithCount(2, 1)\n    ->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: [1,2]\nNext value: [2,3]\nNext value: [3,4]\nNext value: [4,5]\nNext value: [5,6]\nNext value: [6]\nComplete!\n```\n\n### RxPY `buffer buffer_with_count buffer_with_time buffer_with_time_or_count pairwise`\n\nRxPY has several Buffer variants: `buffer`, `buffer_with_count`, `buffer_with_time`, and `buffer_with_time_or_count`. For each of these variants there are optional parameters that change the behavior of the operator. As always in RxPY, when an operator may take more than one optional parameter, be sure to name the parameter in the parameter list when you call the operator so as to avoid ambiguity.\n\n#### `buffer(buffer_openings)`\n\n`buffer(buffer_openings=boundaryObservable)` monitors an Observable, `buffer_openings`. Each time that Observable emits an item, it creates a new array to begin collecting items emitted by the source Observable and emits the previous array.\n\n#### `buffer(closing_selector)`\n\n`buffer(closing_selector=closingSelector)` begins collecting items emitted by the source Observable immediately upon subscription, and also calls the `closing_selector` function to generate a second Observable. It monitors this new Observable and, when it completes or emits an item, it emits the current array, begins a new array to collect items from the source Observable, and calls `closing_selector` again to generate a new Observable to monitor in order to determine when to emit the new array. It repeats this process until the source Observable terminates, whereupon it emits the final array.\n\n`buffer(closing_selector=openingSelector, buffer_closing_selector=closingSelector)` begins by calling `closing_selector` to get an Observable. It monitors this Observable, and, whenever it emits an item, `buffer` creates a new array, begins to collect items subsequently emitted by the source Observable into this array, and calls `buffer_closing_selector` to get a new Observable to govern the closing of that array. When this new Observable emits an item or terminates, `buffer` closes and emits the array that the Observable governs.\n\n#### `buffer_with_count(count)`\n\n`buffer_with_count(count)` emits non-overlapping buffers in the form of arrays, each of which contains at most `count` items from the source Observable (the final emitted array may have fewer than `count` items).\n\n#### `buffer_with_count(count, skip)`\n\n`buffer_with_count(count, skip=skip)` creates a new buffer starting with the first emitted item from the source Observable, and every `skip` items thereafter, and fills each buffer with `count` items: the initial item and `count-1` subsequent ones. It emits these buffers as arrays. Depending on the values of `count` and `skip` these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).\n\n#### `buffer_with_time(timespan)`\n\n`buffer_with_time(timespan)` emits a new array of items periodically, every `timespan` milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a `scheduler` parameter and uses it to govern the timespan; by default this variant uses the `timeout` scheduler.\n\n#### `buffer_with_time(timespan, timeshift)`\n\n`buffer(timespan, timeshift=timeshift)` creates a new array of items every `timeshift` milliseconds, and fills this array with every item emitted by the source Observable from that time until `timespan` milliseconds have passed since the array’s creation, before emitting this array as its own emission. If `timespan` is longer than `timeshift`, the emitted arrays will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a `scheduler` parameter and uses it to govern the timespan; by default this variant uses the `timeout` scheduler.\n\n#### `buffer_with_time_or_count(timespan, count)`\n\n`buffer_with_time_or_count(timespan, count)` emits a new array of items for every `count` items emitted by the source Observable, or, if `timespan` milliseconds have elapsed since its last bundle emission, it emits an array of however many items the source Observable has emitted in that span, even if this is fewer than `count`. There is also a version of this variant of the operator that takes a `scheduler` parameter and uses it to govern the timespan; by default this variant uses the `timeout` scheduler.\n\n### Rxrb `buffer_with_count buffer_with_time`\n\nRx.rb has three variants of the Buffer operator:\n\n#### `buffer_with_count(count)`\n\n`buffer_with_count(count)` emits non-overlapping buffers in the form of arrays, each of which contains at most `count` items from the source Observable (the final emitted array may have fewer than `count` items).\n\n#### `buffer_with_count(count,skip)`\n\n`buffer_with_count(count, skip=skip)` creates a new buffer starting with the first emitted item from the source Observable, and every `skip` items thereafter, and fills each buffer with `count` items: the initial item and `count-1` subsequent ones. It emits these buffers as arrays. Depending on the values of `count` and `skip` these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).\n\n#### `buffer_with_time(timespan)`\n\n`buffer_with_time(timespan)` emits a new array of items periodically, every `timespan` milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable.\n\n### RxScala `slidingBuffer tumblingBuffer`\n\nRxScala has two varieties of Buffer — `slidingBuffer` and `tumblingBuffer` — each of which has variants with different ways of assembling the buffers they emit:\n\n#### `slidingBuffer(count, skip)`\n\n`slidingBuffer(count, skip)` creates a new buffer starting with the first emitted item from the source Observable, and every `skip` items thereafter, and fills each buffer with `count` items: the initial item and `count-1` subsequent ones. It emits these buffers as `Seq`s. Depending on the values of `count` and `skip` these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).\n\n#### `slidingBuffer(timespan, timeshift)`\n\n`slidingBuffer(timespan, timeshift)` creates a new `Seq` of items every `timeshift` (a `Duration`), and fills this buffer with every item emitted by the source Observable from that time until `timespan` (also a `Duration`) has passed since the buffer’s creation, before emitting this `Seq` as its own emission. If `timespan` is longer than `timeshift`, the emitted arrays will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a [`Scheduler`](../scheduler) as a parameter and uses it to govern the timespan.\n\n#### `slidingBuffer(openings, closings)`\n\n`slidingBuffer(openings,closings)` monitors the `openings` Observable, and, whenever it emits an `Opening` item, `slidingBuffer` creates a new `Seq`, begins to collect items subsequently emitted by the source Observable into this buffer, and calls `closings` to get a new Observable to govern the closing of that buffer. When this new Observable emits an item or terminates, `slidingBuffer` closes and emits the `Seq`that the Observable governs.\n\n#### `tumblingBuffer(count)`\n\n`tumblingBuffer(count)` emits non-overlapping buffers in the form of `Seq`s, each of which contains at most `count` items from the source Observable (the final emitted buffer may have fewer than `count` items).\n\n#### `tumblingBuffer(boundary)`\n\n`tumblingBuffer(boundary)` monitors an Observable, `boundary`. Each time that Observable emits an item, it creates a new `Seq` to begin collecting items emitted by the source Observable and emits the previous `Seq`. This variant of the operator has an optional second parameter, `initialCapacity` with which you can indicate the expected size of these buffers so as to make memory allocation more efficient.\n\n#### `tumblingBuffer(timespan)`\n\n`tumblingBuffer(timespan)` emits a new `Seq` of items periodically, every `timespan` (a `Duration`), containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. This variant of the operator has an optional second parameter, `scheduler`, with which you can set the [`Scheduler`](../scheduler) that you want to govern the timespan calculation.\n\n#### `tumblingBuffer(timespan, count)`\n\n`tumblingBuffer(timespan, count)` emits a new `Seq` of items for every `count` items emitted by the source Observable, or, if `timespan` (a `Duration`) has elapsed since its last bundle emission, it emits a `Seq` containing however many items the source Observable emitted in that span, even if this is fewer than `count`. This variant of the operator has an optional third parameter, `scheduler`, with which you can set the [`Scheduler`](../scheduler) that you want to govern the timespan calculation.\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/buffer.html](http://reactivex.io/documentation/operators/buffer.html)"
- name: Catch
  id: documentation/operators/catch
  summary: The Catch operator intercepts an onError notification from the source Observable and, instead of passing it through to any observers, replaces it with some other item or sequence of items, potentially allowing the resulting Observable to terminate normally or not to terminate at all
  description: "# Catch\n\nrecover from an onError notification by continuing the sequence without error\n\nThe Catch operator intercepts an `onError` notification from the source Observable and, instead of passing it through to any observers, replaces it with some other item or sequence of items, potentially allowing the resulting Observable to terminate normally or not to terminate at all.\n\nThere are several variants of the Catch operator, and a variety of names used by different ReactiveX implementations to describe this operation, as you can see in the sections below.\n\nIn some ReactiveX implementations, there is an operator called something like “OnErrorResumeNext” that behaves like a Catch variant: specifically reacting to an `onError` notification from the source Observable. In others, there is an operator with that name that behaves more like a Concat variant: performing the concatenation operation regardless of whether the source Observable terminates normally or with an error. This is unfortunate and confusing, but something we have to live with.\n\n#### See Also\n\n- [Concat](concat)\n- [Retry](retry)\n- [Introduction to Rx: Catch](http://www.introtorx.com/Content/v1.0.10621.0/11_AdvancedErrorHandling.html#Catch)\n\n## Language-Specific Information\n\n### RxClojure `catch*`\n\nRxClojure implements this operator as `catch*`. This operator takes two arguments, both of which are functions of your choosing that take the exception raised by `onError` as their single parameters. The first function is a predicate. If it returns `false`, `catch*` passes the `onError` notification unchanged to its observers. If it returns `true`, however, `catch*` swallows the error, calls the second function (which returns an Observable), and passes along the emissions and notifications from this new Observable to its observers.\n\nYou may replace the first function parameter (the predicate that evaluates the exception) with a class object representing a variety of exception. If you do this, `catch*` will treat it as equivalent to predicate that performs an `instance?` check to see if the exception from the `onError` notification is an instance of the class object. In other words:\n\n#### Sample Code\n\n``` clojure\n(->> my-observable\n  (catch* IllegalArgumentException\n          (fn [e] (rx/return 1)))\n)\n```\n\nis equivalent to:\n\n``` clojure\n(->> my-observable\n  (catch* (fn [e] (-> instance? IllegalArgumentException e))\n          (fn [e] (rx/return 1)))\n)\n```\n\n### RxCpp\n\nRxCpp does not implement the Catch operator.\n\n### RxGroovy `onErrorResumeNext onErrorReturn onExceptionResumeNext`\n\nRxGroovy implements the Catch operator in the same way as does RxJava. There are three distinct operators that provide this functionality:\n\n`onErrorReturn`  \ninstructs an Observable to emit a particular item when it encounters an error, and then terminate normally\n\n`onErrorResumeNext`  \ninstructs an Observable to begin emitting a second Observable sequence if it encounters an error\n\n`onExceptionResumeNext`  \ninstructs an Observable to continue emitting items after it encounters an exception (but not another variety of throwable)\n\n#### `onErrorReturn`\n\nThe `onErrorReturn` method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes `onError` in which case, rather than propagating that error to the observer, `onErrorReturn` will instead emit a specified item and invoke the observer’s `onCompleted` method, as shown in the following sample code:\n\n#### Sample Code\n\n``` groovy\ndef myObservable = Observable.create({ aSubscriber ->\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext('Four');\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext('Three');\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext('Two');\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext('One');\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onError();\n});\n\nmyObservable.onErrorReturn({ return('Blastoff!'); }).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\nFour\nThree\nTwo\nOne\nBlastoff!\nSequence complete\n```\n\n- Javadoc: [`onErrorReturn(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onErrorReturn(rx.functions.Func1))\n\n#### `onErrorResumeNext`\n\nThe `onErrorResumeNext` method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes `onError` in which case, rather than propagating that error to the observer, `onErrorResumeNext` will instead begin mirroring a second, backup Observable, as shown in the following sample code:\n\n#### Sample Code\n\n``` groovy\ndef myObservable = Observable.create({ aSubscriber ->\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext('Three');\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext('Two');\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext('One');\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onError();\n});\ndef myFallback = Observable.create({ aSubscriber ->\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext('0');\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext('1');\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext('2');\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onCompleted();\n});\n\nmyObservable.onErrorResumeNext(myFallback).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\nThree\nTwo\nOne\n0\n1\n2\nSequence complete\n```\n\n- Javadoc: [`onErrorResumeNext(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onErrorResumeNext(rx.functions.Func1))\n- Javadoc: [`onErrorResumeNext(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onErrorResumeNext(rx.Observable))\n\n#### `onExceptionResumeNext`\n\nMuch like `onErrorResumeNext` method, this returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes `onError` in which case, if the Throwable passed to `onError` is an Exception, rather than propagating that Exception to the observer, `onExceptionResumeNext` will instead begin mirroring a second, backup Observable. If the Throwable is not an Exception, the Observable returned by `onExceptionResumeNext` will propagate it to its observer’s `onError` method and will not invoke its backup Observable.\n\n- Javadoc: [`onExceptionResumeNext(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onExceptionResumeNext(rx.Observable))\n\n### RxJava 1․x `onErrorResumeNext onErrorReturn onExceptionResumeNext`\n\nRxJava implements the Catch operator with three distinct operators:\n\n`onErrorReturn`  \ninstructs an Observable to emit a particular item when it encounters an error, and then terminate normally\n\n`onErrorResumeNext`  \ninstructs an Observable to begin emitting a second Observable sequence if it encounters an error\n\n`onExceptionResumeNext`  \ninstructs an Observable to continue emitting items after it encounters an exception (but not another variety of throwable)\n\n#### `onErrorReturn`\n\nThe `onErrorReturn` method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes `onError` in which case, rather than propagating that error to the observer, `onErrorReturn` will instead emit a specified item and invoke the observer’s `onCompleted` method.\n\n- Javadoc: [`onErrorReturn(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onErrorReturn(rx.functions.Func1))\n\n#### `onErrorResumeNext`\n\nThe `onErrorResumeNext` method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes `onError` in which case, rather than propagating that error to the observer, `onErrorResumeNext` will instead begin mirroring a second, backup Observable.\n\n- Javadoc: [`onErrorResumeNext(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onErrorResumeNext(rx.functions.Func1))\n- Javadoc: [`onErrorResumeNext(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onErrorResumeNext(rx.Observable))\n\n#### `onExceptionResumeNext`\n\nMuch like `onErrorResumeNext` method, this returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes `onError` in which case, if the Throwable passed to `onError` is an Exception, rather than propagating that Exception to the observer, `onExceptionResumeNext` will instead begin mirroring a second, backup Observable. If the Throwable is not an Exception, the Observable returned by `onExceptionResumeNext` will propagate it to its observer’s `onError` method and will not invoke its backup Observable.\n\n- Javadoc: [`onExceptionResumeNext(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#onExceptionResumeNext(rx.Observable))\n\n### RxJS `catch onErrorResumeNext`\n\nRxJS implements the Catch operator with two distinct operators:\n\n`catch`  \ninstructs an Observable to begin emitting a second Observable sequence if it encounters an error\n\n`onErrorResumeNext`  \ninstructs an Observable to begin emitting a second Observable sequence if it encounters an error or if the source Observable terminates normally\n\n#### `catch`\n\n`catch` is found in the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n#### `onErrorResumeNext`\n\nThis implementation borrows the confusing nomenclature from Rx.NET, in which `onErrorResumeNext` switches to a back-up Observable both on an error *and* on a normal, error-free termination of the source Observable.\n\n`onErrorResumeNext` is found in the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n\n### RxKotlin `onErrorResumeNext onErrorReturn onExceptionResumeNext`\n\nRxKotlin implements the Catch operator in the same way as does RxJava. There are three distinct operators that provide this functionality:\n\n`onErrorReturn`  \ninstructs an Observable to emit a particular item when it encounters an error, and then terminate normally\n\n`onErrorResumeNext`  \ninstructs an Observable to begin emitting a second Observable sequence if it encounters an error\n\n`onExceptionResumeNext`  \ninstructs an Observable to continue emitting items after it encounters an exception (but not another variety of throwable)\n\n#### `onErrorReturn`\n\nThe `onErrorReturn` method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes `onError` in which case, rather than propagating that error to the observer, `onErrorReturn` will instead emit a specified item and invoke the observer’s `onCompleted` method.\n\n#### `onErrorResumeNext`\n\nThe `onErrorResumeNext` method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes `onError` in which case, rather than propagating that error to the observer, `onErrorResumeNext` will instead begin mirroring a second, backup Observable.\n\n#### `onExceptionResumeNext`\n\nMuch like `onErrorResumeNext` method, this returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes `onError` in which case, if the Throwable passed to `onError` is an Exception, rather than propagating that Exception to the observer, `onExceptionResumeNext` will instead begin mirroring a second, backup Observable. If the Throwable is not an Exception, the Observable returned by `onExceptionResumeNext` will propagate it to its observer’s `onError` method and will not invoke its backup Observable.\n\n### RxNET `Catch OnErrorResumeNext`\n\nRx.NET implements the Catch operator with two distinct operators:\n\n`Catch`  \ninstructs an Observable to begin emitting a second Observable sequence if it encounters an error\n\n`OnErrorResumeNext`  \ninstructs an Observable to begin emitting a second Observable sequence if it encounters an error or if the source Observable terminates normally\n\n#### `Catch`\n\nThe `Catch` operator has a variant that allows you to specify which sort of Exception you want to catch. If you use that variant of the operator, any other Exceptions will be passed through to the observer as if the `Catch` operator had not been applied.\n\n#### `OnErrorResumeNext`\n\nThis implementation introduces a confusing nomenclature, in which in spite of its name `OnErrorResumeNext` switches to a back-up Observable both on an error *and* on a normal, error-free termination of the source Observable. It is therefore more like a concatenation operator.\n\n### RxPHP `catch`\n\nRxPHP implements this operator as `catch`.\n\nContinues an observable sequence that is terminated by an exception with the next observable sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/catch/catch.php\n\n$obs2 = Rx\\Observable::of(42);\n\n$source = \\Rx\\Observable::error(new Exception('Some error'))\n    ->catch(function (Throwable $e, \\Rx\\Observable $sourceObs) use ($obs2) {\n        return $obs2;\n    });\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 42\nComplete!\n```\n\n### RxPY `catch_exception on_error_resume_next`\n\nRxPY implements the Catch operator with two distinct operators:\n\n`catch_exception`  \ninstructs an Observable, if it encounters an error, to begin emitting items from a set of other Observables, one Observable at a time, until one of those Observables terminates successfully\n\n`on_error_resume_next`  \ninstructs an Observable to concatenate items emitted by a set of other Observables, one Observable at a time, regardless of whether the source Observable or any subsequent Observable terminates with an error\n\n#### `catch_exception`\n\nYou may pass `catch_exception` a set of back-up Observables either as individual function parameters or as a single array of Observables. If it encounters an `onError` notification from the source Observable, it will subscribe to and begin mirroring the first of these back-up Observables. If this back-up Observable itself issues an `onError` notification, `catch_exception` will swallow it and switch over to the next back-up Observable. If any of these Observables issues an `onCompleted` notification, `catch_exception` will pass this along and will stop.\n\n#### `on_error_resume_next`\n\nYou may pass `on_error_resume_next` a set of back-up Observables either as individual function parameters, as a single array of Observables, or as a factory function that generates Observables. When the source Observable terminates, whether normally or with an error, `on_error_resume_next` will subscribe to and begin mirroring the first of these back-up Observables, and then will recursively continue this concatenation process for each additional Observable until there are no more Observables to mirror, at which time it will pass on the `onError` or `onCompleted` notification from the last of these Observables.\n\n### Rxrb `on_error_resume_next rescue_error`\n\nRx.rb implements the Catch operator with two distinct operators:\n\n`rescue_error`  \ninstructs an Observable to begin emitting items from another Observable, or from an Observable returned from an action, if it encounters an error\n\n`on_error_resume_next`  \ninstructs an Observable to concatenate items emitted by another Observable to the sequence emitted by the source Observable, regardless of whether the source Observable terminates normally or with an error\n\n#### `rescue_error`\n\nYou may pass `rescue_error` either an Observable or a factory action that generates an Observable.\n\n#### `on_error_resume_next`\n\nIn Rx.rb, `on_error_resume_next` inherits the misleading nomenclature from Rx.NET in that it concatenates the second Observable sequence to the source sequence whether that source sequence terminates normally or with an error.\n\n### RxScala `onErrorFlatMap onErrorResumeNext onErrorReturn onExceptionResumeNext`\n\nRx.rb implements the Catch operator with four distinct operators:\n\n`onErrorFlatMap`  \nreplaces all `onError` notifications from a misbehaving Observable into the emissions from a secondary Observable\n\n`onErrorResumeNext`  \ninstructs an Observable to begin emitting a second Observable sequence if it encounters an error\n\n`onErrorReturn`  \ninstructs an Observable to emit a particular item when it encounters an error, and then terminate normally\n\n`onExceptionResumeNext`  \ninstructs an Observable to continue emitting items after it encounters an exception (but not another variety of throwable)\n\n#### `onErrorFlatMap`\n\n`onErrorFlatMap` handles a special case: a source Observable that is noncompliant with [the Observable contract](../contract) in such a way that it may interleave `onError` notifications with its emissions without terminating. This operator allows you to replace those `onError` notifications with the emissions of an Observable of your choosing without unsubscribing from the source, so that any future items emitted from the source will be passed along to observers as though the sequence had not been interrupted with an `onError` notification.\n\nBecause `onErrorFlatMap` is designed to work with pathological source Observables that do not terminate after issuing an error, it is mostly useful in debugging/testing scenarios.\n\nNote that you should apply `onErrorFlatMap` directly to the pathological source Observable, and not to that Observable after it has been modified by additional operators, as such operators may effectively renormalize the source Observable by unsubscribing from it immediately after it issues an error. Above, for example, is an illustration showing how `onErrorFlatMap` will respond to two error-generating Observables that have been merged by the [Merge](merge) operator:\n\nNote that `onErrorFlatMap` will not react to both errors generated by both Observables, but only to the single error passed along by `merge`.\n\n#### `onErrorResumeNext`\n\nThe `onErrorResumeNext` method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes `onError` in which case, rather than propagating that error to the observer, `onErrorResumeNext` will instead begin mirroring a second, backup Observable.\n\n#### `onErrorReturn`\n\nThe `onErrorReturn` method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes `onError` in which case, rather than propagating that error to the observer, `onErrorReturn` will instead emit a specified item and invoke the observer’s `onCompleted` method.\n\n#### `onExceptionResumeNext`\n\nMuch like `onErrorResumeNext` method, this returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes `onError` in which case, if the Throwable passed to `onError` is an Exception, rather than propagating that Exception to the observer, `onExceptionResumeNext` will instead begin mirroring a second, backup Observable. If the Throwable is not an Exception, the Observable returned by `onExceptionResumeNext` will propagate it to its observer’s `onError` method and will not invoke its backup Observable.\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/catch.html](http://reactivex.io/documentation/operators/catch.html)"
- name: CombineLatest
  id: documentation/operators/combinelatest
  summary: The CombineLatest operator behaves in a similar way to Zip, but while Zip emits items only when each of the zipped source Observables have emitted a previously unzipped item, CombineLatest emits an item whenever any of the source Observables emits an item (so long as each of the source Observables has emitted at least one item)
  description: "# CombineLatest\n\nwhen an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#combineLatest)\n\nThe CombineLatest operator behaves in a similar way to Zip, but while Zip emits items only when *each* of the zipped source Observables have emitted a previously unzipped item, CombineLatest emits an item whenever *any* of the source Observables emits an item (so long as each of the source Observables has emitted at least one item). When any of the source Observables emits an item, CombineLatest combines the most recently emitted items from each of the other source Observables, using a function you provide, and emits the return value from that function.\n\n#### See Also\n\n- [Zip](zip)\n- [Introduction to Rx: CombineLatest](http://www.introtorx.com/Content/v1.0.10621.0/12_CombiningSequences.html#CombineLatest)\n- [RxMarbles: `combineLatest`](http://rxmarbles.com/#combineLatest)\n- [RxMarbles: `withLatestFrom`](http://rxmarbles.com/#withLatestFrom)\n- [101 Rx Samples: CombineLatest — Parallel Execution](http://rxwiki.wikidot.com/101samples#toc3)\n- [101 Rx Samples: CombineLatest](http://rxwiki.wikidot.com/101samples#toc50)\n\n## Language-Specific Information\n\n### RxGroovy `combineLatest withLatestFrom`\n\nRxGroovy implements this operator as `combineLatest`. It may take between two and nine Observables (as well as the combining function) as parameters, or a single `List` of Observables (as well as the combining function). It does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`combineLatest(List,FuncN)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(java.util.List,%20rx.functions.FuncN))\n- Javadoc: [`combineLatest(Observable,Observable,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(rx.Observable,%20rx.Observable,%20rx.functions.Func2)) (there are also versions that take up to nine Observables)\n\nUnder development, but not part of the 1.0 release, is the `withLatestFrom` operator. It is similar to `combineLatest`, but only emits items when the single source Observable emits an item (not when *any* of the Observables that are passed to the operator do, as `combineLatest` does).\n\n### RxJava 1․x `combineLatest withLatestFrom`\n\nRxJava implements this operator as `combineLatest`. It may take between two and nine Observables (as well as the combining function) as parameters, or a single `List` of Observables (as well as the combining function). It does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`combineLatest(List,FuncN)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(java.util.List,%20rx.functions.FuncN))\n- Javadoc: [`combineLatest(Observable,Observable,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(rx.Observable,%20rx.Observable,%20rx.functions.Func2)) (there are also versions that take up to nine Observables)\n\nUnder development, but not part of the 1.0 release, is the `withLatestFrom` operator. It is similar to `combineLatest`, but only emits items when the single source Observable emits an item (not when *any* of the Observables that are passed to the operator do, as `combineLatest` does).\n\n### RxJS `combineLatest withLatestFrom`\n\nRxJS implements this operator as `combineLatest`. It may take a variable number of individual Observables (as well as the combining function) as parameters, or a single `Array` of Observables (as well as the combining function).\n\n#### Sample Code\n\n``` javascript\n/* Have staggering intervals */\nvar source1 = Rx.Observable.interval(100)\n    .map(function (i) { return 'First: ' + i; });\n\nvar source2 = Rx.Observable.interval(150)\n    .map(function (i) { return 'Second: ' + i; });\n\n// Combine latest of source1 and source2 whenever either gives a value\nvar source = source1.combineLatest(\n        source2,\n        function (s1, s2) { return s1 + ', ' + s2; }\n    ).take(4);\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x.toString());\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nNext: First: 0, Second: 0\nNext: First: 1, Second: 0\nNext: First: 1, Second: 1\nNext: First: 2, Second: 1\nCompleted\n```\n\nRxJS also has a `withLatestFrom` operator. It is similar to `combineLatest`, but only emits items when the single source Observable emits an item (not when *any* of the Observables that are passed to the operator do, as `combineLatest` does).\n\n#### Sample Code\n\n``` javascript\n/* Have staggering intervals */\nvar source1 = Rx.Observable.interval(140)\n    .map(function (i) { return 'First: ' + i; });\n\nvar source2 = Rx.Observable.interval(50)\n    .map(function (i) { return 'Second: ' + i; });\n\n// When source1 emits a value, combine it with the latest emission from source2.\nvar source = source1.withLatestFrom(\n    source2,\n    function (s1, s2) { return s1 + ', ' + s2; }\n).take(4);\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x.toString());\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nNext: First: 0, Second: 1\nNext: First: 1, Second: 4\nNext: First: 2, Second: 7\nNext: First: 3, Second: 10\nCompleted\n```\n\nThese two operators are both available in each of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `combineLatest withLatestFrom`\n\nRxPHP implements this operator as `combineLatest`.\n\nMerges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element. Observables need to be an array. If the result selector is omitted, a list with the elements will be yielded.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/combineLatest/combineLatest.php\n\n/* Have staggering intervals */\n$source1 = \\Rx\\Observable::interval(100);\n$source2 = \\Rx\\Observable::interval(120);\n\n$source = $source1->combineLatest([$source2], function ($value1, $value2) {\n    return \"First: {$value1}, Second: {$value2}\";\n})->take(4);\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: First: 0, Second: 0\nNext value: First: 1, Second: 0\nNext value: First: 1, Second: 1\nNext value: First: 2, Second: 1\nComplete!\n```\n\nRxPHP also has an operator `withLatestFrom`.\n\nMerges the specified observable sequences into one observable sequence by using the selector function only when the (first) source observable sequence produces an element.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/withLatestFrom/withLatestFrom.php\n\n/* Have staggering intervals */\n$source1 = \\Rx\\Observable::interval(140)\n    ->map(function ($i) {\n        return 'First: ' . $i;\n    });\n$source2 = \\Rx\\Observable::interval(50)\n    ->map(function ($i) {\n        return 'Second: ' . $i;\n    });\n\n$source3 = \\Rx\\Observable::interval(100)\n    ->map(function ($i) {\n        return 'Third: ' . $i;\n    });\n\n$source = $source1->withLatestFrom([$source2, $source3], function ($value1, $value2, $value3) {\n    return $value1 . ', ' . $value2 . ', ' . $value3;\n})->take(4);\n\n$source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: First: 0, Second: 1, Third: 0\nNext value: First: 1, Second: 4, Third: 1\nNext value: First: 2, Second: 7, Third: 3\nNext value: First: 3, Second: 10, Third: 4\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/combinelatest.html](http://reactivex.io/documentation/operators/combinelatest.html)"
- name: Concat
  id: documentation/operators/concat
  summary: The Concat operator concatenates the output of multiple Observables so that they act like a single Observable, with all of the items emitted by the first Observable being emitted before any of the items emitted by the second Observable (and so forth, if there are more than two)
  description: "# Concat\n\nemit the emissions from two or more Observables without interleaving them\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#concat)\n\nThe Concat operator concatenates the output of multiple Observables so that they act like a single Observable, with all of the items emitted by the first Observable being emitted before any of the items emitted by the second Observable (and so forth, if there are more than two).\n\nConcat waits to subscribe to each additional Observable that you pass to it until the previous Observable completes. Note that because of this, if you try to concatenate a “hot” Observable, that is, one that begins emitting items immediately and before it is subscribed to, Concat will not see, and therefore will not emit, any items that Observable emits before all previous Observables complete and Concat subscribes to the “hot” Observable.\n\nIn some ReactiveX implementations there is also a ConcatMap operator (a.k.a. `concat_all`, `concat_map`, `concatMapObserver`, `for`, `forIn`/`for_in`, `mapcat`, `selectConcat`, or `selectConcatObserver`) that transforms the items emitted by a source Observable into corresponding Observables and then concatenates the items emitted by each of these Observables in the order in which they are observed and transformed.\n\nThe [StartWith](startwith) operator is similar to Concat, but *prepends*, rather than appends, items or emissions of items to those emitted by a source Observable.\n\nThe [Merge](merge) operator is also similar. It combines the emissions of two or more Observables, but may interleave them, whereas Concat never interleaves the emissions from multiple Observables.\n\n#### See Also\n\n- [Catch](catch)\n- [Merge](merge)\n- [StartWith](startwith)\n- [Introduction to Rx: Concat](http://www.introtorx.com/Content/v1.0.10621.0/12_CombiningSequences.html#Concat)\n- [RxMarbles: `concat`](http://rxmarbles.com/#concat)\n- [101 Rx Samples: Concat — cold observable](http://rxwiki.wikidot.com/101samples#toc51)\n- [101 Rx Samples: Concat — hot observable](http://rxwiki.wikidot.com/101samples#toc52)\n- [Loading data from multiple sources with RxJava](http://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/) by Dan Lew (example using Concat and First)\n\n## Language-Specific Information\n\n### RxClojure `concat concat*`\n\nIn RxClojure `concat` concatenates some number of individual Observables together in the order in which they are given.\n\nThe `concat*` operator concatenates the Observables emitted by an Observable together, in the order in which they are emitted.\n\n### RxCpp `concat`\n\nRxCpp implements this operator as `concat`:\n\n### RxGroovy `concat concatWith`\n\nRxGroovy implements this operator as `concat`. There are variants of this operator that take between two and nine Observables as parameters, and that concatenate them in the order they appear in the parameter list. There is also a variant that takes as a parameter an Observable of Observables, and concatenates each of these Observables in the order that they are emitted.\n\n#### Sample Code\n\n``` groovy\nodds  = Observable.from([1, 3, 5, 7]);\nevens = Observable.from([2, 4, 6]);\n\nObservable.concat(odds, evens).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n1\n3\n5\n7\n2\n4\n6\nSequence complete\n```\n\n- Javadoc: [`concat(Observable<Observable>)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable))\n- Javadoc: [`concat(Observable,Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable,%20rx.Observable)) (there are also versions that take up to nine Observables)\n\nThere is also an instance method, `concatWith`, such that `Observable.concat(a,b)` is equivalent to `a.concatWith(b)`.\n\n- Javadoc: [`concatWith(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatWith(rx.Observable))\n\n### RxJava 1․x `concat concatWith`\n\nRxJava implements this operator as `concat`. There are variants of this operator that take between two and nine Observables as parameters, and that concatenate them in the order they appear in the parameter list. There is also a variant that takes as a parameter an Observable of Observables, and concatenates each of these Observables in the order that they are emitted.\n\n- Javadoc: [`concat(Observable<Observable>)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable))\n- Javadoc: [`concat(Observable,Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable,%20rx.Observable)) (there are also versions that take up to nine Observables)\n\nThere is also an instance method, `concatWith`, such that `Observable.concat(a,b)` is equivalent to `a.concatWith(b)`.\n\n- Javadoc: [`concatWith(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatWith(rx.Observable))\n\n### RxJS `concat concatAll`\n\nRxJS implements this operator as `concat` and `concatAll`.\n\n`concat` takes a variable number of Observables (or Promises) as parameters (or a single array of Observables or Promises), and concatenates them in the order they appear in the parameter list (or array). It exists as both an Observable prototype method and as an instance method.\n\n`concatAll` is an instance method that operates on an Observable of Observables, concatinating each of these Observables in the order they are emitted.\n\n`concat` and `concatAll` are found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxKotlin `concat concatWith`\n\nRxKotlin implements this operator as `concat`. There are variants of this operator that take between two and nine Observables as parameters, and that concatenate them in the order they appear in the parameter list. There is also a variant that takes as a parameter an Observable of Observables, and concatenates each of these Observables in the order that they are emitted.\n\nThere is also an instance method, `concatWith`, such that `Observable.concat(a,b)` is equivalent to `a.concatWith(b)`.\n\n### RxNET `Concat`\n\nRx.NET implements this operator as `Concat`. It accepts either an enumerable of Observables, an Observable of Observables, or two Observables as parameters, and concatenates these in the order given.\n\n### RxPHP `concat concatAll`\n\nRxPHP implements this operator as `concat`.\n\nConcatenate an observable sequence onto the end of the source observable.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/concat/concat.php\n\n\n$source1 = \\Rx\\Observable::of(42);\n$source2 = \\Rx\\Observable::of(56);\n\n$source = \\Rx\\Observable::empty()->concat($source1)->concat($source2);\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 42\nNext value: 56\nComplete!\n```\n\nRxPHP also has an operator `concatAll`.\n\nConcatenates a sequence of observable sequences into a single observable sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/concat/concatAll.php\n\n$source = Rx\\Observable::range(0, 3)\n    ->map(function ($x) {\n        return \\Rx\\Observable::range($x, 3);\n    })\n    ->concatAll();\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 0\nNext value: 1\nNext value: 2\nNext value: 1\nNext value: 2\nNext value: 3\nNext value: 2\nNext value: 3\nNext value: 4\nComplete!\n```\n\n### RxPY `concat concatAll`\n\nIn RxPY `concat` takes a variable number of Observables as parameters (or an array of Observables), and concatenates them in the order they appear in the parameter list (or array).\n\n`concatAll` operates on an Observable of Observables, concatinating each of these Observables in the order they are emitted.\n\n### Rxrb `concat merge_all`\n\nIn Rx.rb, the `concat` operator operates on two Observables as an instance operator, or on an array of Observables as a class method.\n\nThe `merge_all` operator, despite its name, really behaves like a Concat variant in Rx.rb. It accepts an Observable of Observables as its parameter, and concatenates the emissions from these Observables.\n\n### RxScala `concat ++`\n\nRxScala implements this operator in two ways. There is a `concat` operator that accepts an Observable of Observables as its parameter, and then concatenates each of these Observables in the order they are emitted. There is also a `++` operator that concatenates one Observable to another.\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/concat.html](http://reactivex.io/documentation/operators/concat.html)"
- name: Connect
  id: documentation/operators/connect
  summary: A connectable Observable resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when the Connect operator is applied to it
  description: "# Connect\n\ninstruct a connectable Observable to begin emitting items to its subscribers\n\nA connectable Observable resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when the Connect operator is applied to it. In this way you can wait for all intended observers to subscribe to the Observable before the Observable begins emitting items.\n\n#### See Also\n\n- [Publish](publish)\n- [RefCount](refcount)\n- [Replay](replay)\n- [Introduction to Rx: Publish & Connect](http://www.introtorx.com/Content/v1.0.10621.0/14_HotAndColdObservables.html#PublishAndConnect)\n\n## Language-Specific Information\n\n### RxGroovy `connect`\n\nIn RxGroovy, the `connect` operator is a method of the `ConnectableObservable` interface. You can use the `publish` operator to convert an ordinary Observable into a `ConnectableObservable`.\n\nCall a `ConnectableObservable`’s `connect` method to instruct it to begin emitting the items from its underlying Observable to its Subscribers.\n\nThe `connect` method returns a `Subscription`. You can call that `Subscription` object’s `unsubscribe` method to instruct the Observable to stop emitting items to its Subscribers.\n\nYou can also use the `connect` method to instruct an Observable to begin emitting items (or, to begin generating items that would be emitted) even before any Subscriber has subscribed to it. In this way you can turn a cold Observable into a hot one.\n\n- Javadoc: [`connect()`](http://reactivex.io/RxJava/javadoc/rx/observables/ConnectableObservable.html#connect())\n- Javadoc: [`connect(Action1)`](http://reactivex.io/RxJava/javadoc/rx/observables/ConnectableObservable.html#connect(rx.functions.Action1))\n\n### RxJava 1․x `connect`\n\nIn RxJava, the `connect` operator is a method of the `ConnectableObservable` interface. You can use the `publish` operator to convert an ordinary Observable into a `ConnectableObservable`.\n\nCall a `ConnectableObservable`’s `connect` method to instruct it to begin emitting the items from its underlying Observable to its Subscribers.\n\nThe `connect` method returns a `Subscription`. You can call that `Subscription` object’s `unsubscribe` method to instruct the Observable to stop emitting items to its Subscribers.\n\nYou can also use the `connect` method to instruct an Observable to begin emitting items (or, to begin generating items that would be emitted) even before any Subscriber has subscribed to it. In this way you can turn a cold Observable into a hot one.\n\n- Javadoc: [`connect()`](http://reactivex.io/RxJava/javadoc/rx/observables/ConnectableObservable.html#connect())\n- Javadoc: [`connect(Action1)`](http://reactivex.io/RxJava/javadoc/rx/observables/ConnectableObservable.html#connect(rx.functions.Action1))\n\n### RxJS `connect`\n\nIn RxJS, the `connect` operator is a method of the `ConnectableObservable` prototype. You can use the `publish` operator to convert an ordinary Observable into a `ConnectableObservable`.\n\nCall a `ConnectableObservable`’s `connect` method to instruct it to begin emitting the items from its underlying Observable to its Subscribers.\n\nThe `connect` method returns a `Disposable`. You can call that `Disposable` object’s `dispose` method to instruct the Observable to stop emitting items to its Subscribers.\n\nYou can also use the `connect` method to instruct an Observable to begin emitting items (or, to begin generating items that would be emitted) even before any Subscriber has subscribed to it. In this way you can turn a cold Observable into a hot one.\n\n#### Sample Code\n\n``` javascript\nvar interval = Rx.Observable.interval(1000);\n\nvar source = interval\n    .take(2)\n    .do(function (x) { console.log('Side effect'); });\n\nvar published = source.publish();\n\npublished.subscribe(createObserver('SourceA'));\npublished.subscribe(createObserver('SourceB'));\n\n// Connect the source\nvar connection = published.connect();\n\nfunction createObserver(tag) {\n    return Rx.Observer.create(\n        function (x) { console.log('Next: ' + tag + x); },\n        function (err) { console.log('Error: ' + err); },\n        function () { console.log('Completed'); });\n}\n```\n\n``` javascript\nSide effect\nNext: SourceA0\nNext: SourceB0\nSide effect\nNext: SourceA1\nNext: SourceB1\nCompleted\nCompleted\n```\n\n`connect` is found in the following packages:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.all.binding.js`\n\n`connect` requires one of the following packages:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/connect.html](http://reactivex.io/documentation/operators/connect.html)"
- name: Contains
  id: documentation/operators/contains
  summary: Pass the Contains operator a particular item, and the Observable it returns will emit true if that item is emitted by the source Observable, or false if the source Observable terminates without emitting that item
  description: "# Contains\n\ndetermine whether an Observable emits a particular item or not\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#contains)\n\nPass the Contains operator a particular item, and the Observable it returns will emit `true` if that item is emitted by the source Observable, or `false` if the source Observable terminates without emitting that item.\n\nA related operator, IsEmpty returns an Observable that emits `true` if and only if the source Observable completes without emitting any items. It emits `false` if the source Observable emits an item.\n\n#### See Also\n\n- [All](all)\n- [Introduction to Rx: Contains](http://www.introtorx.com/Content/v1.0.10621.0/06_Inspection.html#Contains)\n- [RxMarbles: `contains`](http://rxmarbles.com/#contains)\n- [RxMarbles: `some`](http://rxmarbles.com/#some)\n\n## Language-Specific Information\n\n### RxGroovy `contains exists isEmpty`\n\nRxGroovy implements this operator as `contains`. It does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`contains(Object)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#contains(java.lang.Object))\n\nRxGroovy also implements the `exists` operator. It is similar to `contains` but tests items emitted by the source Observable against a predicate function you supply, rather than testing them for identity with a particular object. The Observable returned from `exists` will return `true` if the source Observable emits an item that satisfies your predicate function, and `false` if it completes without emitting such an item.\n\nIt does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`exists(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#exists(rx.functions.Func1))\n\nRxGroovy also implements the `isEmpty` operator. The Observable returned from `isEmpty` will return `false` if the source Observable emits an item, and `true` if it completes without emitting an item.\n\nIt does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`isEmpty()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#isEmpty())\n\n### RxJava 1․x `contains exists isEmpty`\n\nRxJava implements this operator as `contains`. It does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`contains(Object)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#contains(java.lang.Object))\n\nRxJava also implements the `exists` operator. It is similar to `contains` but tests items emitted by the source Observable against a predicate function you supply, rather than testing them for identity with a particular object. The Observable returned from `exists` will return `true` if the source Observable emits an item that satisfies your predicate function, and `false` if it completes without emitting such an item.\n\nIt does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`exists(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#exists(rx.functions.Func1))\n\nRxJava also implements the `isEmpty` operator. The Observable returned from `isEmpty` will return `false` if the source Observable emits an item, and `true` if it completes without emitting an item.\n\nIt does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`isEmpty()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#isEmpty())\n\n### RxJava 2․x `any contains isEmpty`\n\n### RxJS `contains findIndex indexOf isEmpty`\n\nThe `contains` operator in RxJS takes an optional second parameter: a zero-based index into the source Observable’s sequence at which to start searching for the item.\n\n#### Sample Code\n\n``` javascript\n/* Without an index */\nvar source = Rx.Observable.of(42)\n  .contains(42);\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: true\nCompleted\n```\n\n``` javascript\n/* With an index */\nvar source = Rx.Observable.of(1,2,3)\n  .contains(2, 1);\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: true\nCompleted\n```\n\n`contains` is found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\nIt requires one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThe `indexOf` operator in RxJS is similar to `contains` but rather than returning an Observable that emits `true` or `false` it returns an Observable that emits the index of the item in the source Observable sequence, or `−1` if no such item was emitted.\n\nThe `indexOf` operator takes an optional second parameter: a zero-based index into the source Observable’s sequence at which to start searching for the item. The index value that the resulting Observable emits will be relative to this start point, not to the beginning of the sequence.\n\n#### Sample Code\n\n``` javascript\n/* Without an index */\nvar source = Rx.Observable.of(42)\n  .indexOf(42);\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0 \nCompleted\n```\n\n``` javascript\n/* With an index */\nvar source = Rx.Observable.of(1,2,3)\n  .indexOf(2, 1);\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0 \nCompleted\n```\n\n`indexOf` is found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\nIt requires one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThe `findIndex` operator in RxJS takes as its parameter a predicate function. It returns an Observable that emits either a single number — the zero-based index of the first item in the source Observable sequence that matches the predicate — or `−1` if no such item matches.\n\nThe predicate function takes three parameters:\n\n- the item emitted by the source Observable\n- the zero-based index of that item\n- the source Observable itself\n\nYou can also pass an object to `findIndex` as an optional second parameter, and that object will be available to the predicate function as “`this`”.\n\n#### Sample Code\n\n``` javascript\n/* Found an element */\nvar array = [1,2,3,4];\n\nvar source = Rx.Observable.fromArray(array)\n    .findIndex(function (x, i, obs) {\n        return x === 1;\n    });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nCompleted\n```\n\n``` javascript\n/* Not found */\nvar array = [1,2,3,4];\n\nvar source = Rx.Observable.fromArray(array)\n    .findIndex(function (x, i, obs) {\n        return x === 5;\n    });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: -1\nCompleted\n```\n\n`findIndex` is found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\nIt requires one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nRxJS also implements the `isEmpty` operator. The Observable returned from `isEmpty` will return `false` if the source Observable emits an item, and `true` if it completes without emitting an item.\n\n#### Sample Code\n\n``` javascript\n/* Not empty */\nvar source = Rx.Observable.range(0, 5)\n    .isEmpty()\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: false\nCompleted\n```\n\n``` javascript\n/* Empty */\nvar source = Rx.Observable.empty()\n    .isEmpty()\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: true\nCompleted\n```\n\n`isEmpty` is found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\nIt requires one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `isEmpty`\n\nRxPHP implements this operator as `isEmpty`.\n\nIf the source Observable is empty it returns an Observable that emits true, otherwise it emits false.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/isEmpty/isEmpty.php\n\n$source = \\Rx\\Observable::emptyObservable()\n    ->isEmpty();\n\n$source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 1\nComplete!\n```\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/isEmpty/isEmpty-false.php\n\n$source = \\Rx\\Observable::just(1)\n    ->isEmpty();\n\n$source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 0\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/contains.html](http://reactivex.io/documentation/operators/contains.html)"
- name: Count
  id: documentation/operators/count
  summary: The Count operator transforms an Observable that emits items into an Observable that emits a single value that represents the number of items emitted by the source Observable
  description: "# Count\n\ncount the number of items emitted by the source Observable and emit only this value\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#count)\n\nThe Count operator transforms an Observable that emits items into an Observable that emits a single value that represents the number of items emitted by the source Observable.\n\nIf the source Observable terminates with an error, Count will pass this error notification along without emitting an item first. If the source Observable does not terminate at all, Count will neither emit an item nor terminate.\n\n#### See Also\n\n- [Introduction to Rx: Count](http://www.introtorx.com/Content/v1.0.10621.0/07_Aggregation.html#Count)\n- [RxMarbles: `count`](http://rxmarbles.com/#count)\n\n## Language-Specific Information\n\n### RxClojure `count longCount`\n\nRxClojure has both `count` and `longCount` variants of this operator, but both of these in fact return long values.\n\n### RxCpp `count`\n\nRxCpp implements this operator as `count`.\n\n### RxGroovy `count countLong`\n\nIn RxGroovy the operator is called `count` and the Observable it creates emits an Integer value. There is also a `countLong` whose Observable emits a Long value.\n\n#### Sample Code\n\n``` groovy\ndef myObservable = Observable.create({ aSubscriber ->\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext('Three');\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext('Two');\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext('One');\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onCompleted();\n});\n\nmyObservable.count().subscribe(\n   { println(it); },                          // onNext\n   { println(\"Error: \" + it.getMessage()); }, // onError\n   { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n3\nSequence complete\n```\n\n- Javadoc: [`count()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#count())\n- Javadoc: [`countLong()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#countLong())\n\n### RxJava 1․x `count countLong`\n\nIn RxJava the operator is called `count` and the Observable it creates emits an Integer value. There is also a `countLong` whose Observable emits a Long value.\n\n#### Sample Code\n\n``` java\nString[] items = new String[] { \"one\", \"two\", \"three\" };\nassertEquals( new Integer(3), Observable.from(items).count().toBlocking().single() );\n```\n\n- Javadoc: [`count()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#count())\n- Javadoc: [`countLong()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#countLong())\n\n### RxJS `count`\n\nIn RxJS the operator `count` counts the number of items in the source Observable that satisfy a specified predicate. That predicate takes the form of a function that takes three parameters:\n\n1.  the emitted item\n2.  the index of that item in the sequence of emitted items\n3.  the source Observable\n\nIf the predicate function returns `true`, `count` will increment the tally of items that it will report when the source Observable completes. If you want to count *all* of the items emitted by the source Observable, simply pass `count` a predicate that always returns `true`:\n\n#### Sample Code\n\n``` javascript\nnumberOfItems = someObservable.count(function() { return true; });\n```\n\n`count` is part of the following packages:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\n`count` requires one of any of the following packages:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxKotlin `count`\n\nRxKotlin implements this operator as `count`.\n\n#### Sample Code\n\n``` kotlin\nval list = listOf(1, 2, 3, 4, 5)\nassertEquals( 5, Observable.from(list)!!.count()!!.toBlocking()!!.single() )\n```\n\n### RxNET `Count LongCount`\n\nIn Rx.NET the Observable this operator creates emits an Integer value, but there is also a `LongCount` whose Observable emits a Long value. With both variants, you can either pass the source Observable in to the operator as a parameter or you can call the operator as an instance method of the source Observable (in which case you omit the parameter).\n\n### RxPHP `count`\n\nRxPHP implements this operator as `count`.\n\nReturns an observable sequence containing a value that represents how many elements in the specified observable sequence satisfy a condition if provided, else the count of items.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/count/count.php\n\n$source = \\Rx\\Observable::fromArray(range(1, 10));\n\n$subscription = $source->count()->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 10\nComplete!\n```\n\n### RxPY `count`\n\nIn RxPY you have the option to pass `count` a predicate that takes an item emitted by the source Observable as a parameter. If you do so, `count` will emit a count only of those items from the source Observable that the predicate evaluates as `true`. Otherwise, it will emit a count of all items emitted by the source Observable.\n\n#### Sample Code\n\n``` python\nnumberOfItems = someObservable.count()\nnumberOfNegativeItems = someObservable.count(lambda x: x < 0)\n```\n\n### Rxrb `count`\n\nIn Rx.rb you have the option to pass `count` a predicate that takes an item emitted by the source Observable as a parameter. If you do so, `count` will emit a count only of those items from the source Observable that the predicate evaluates as `true`. Otherwise it will emit a count of all items emitted by the source Observable.\n\n### RxScala `count length longCount size`\n\nIn RxScala the operator `count` counts the number of items in the source Observable that satisfy a specified predicate. That predicate accepts an emitted item as a parameter and returns a Boolean. `count` will emit a count of all items for which this predicate returned `true`.\n\nUse `length` or `size` instead if you want to count *all* of the items emitted by the source Observable and emit this count as an Integer, or use `longCount` to emit it as a Long.\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/count.html](http://reactivex.io/documentation/operators/count.html)"
- name: Create
  id: documentation/operators/create
  summary: You can create an Observable from scratch by using the Create operator
  description: "# Create\n\ncreate an Observable from scratch by means of a function\n\nYou can create an Observable from scratch by using the Create operator. You pass this operator a function that accepts the observer as its parameter. Write this function so that it behaves as an Observable — by calling the observer’s `onNext`, `onError`, and `onCompleted` methods appropriately.\n\nA well-formed finite Observable must attempt to call either the observer’s `onCompleted` method exactly once or its `onError` method exactly once, and must not thereafter attempt to call any of the observer’s other methods.\n\n#### See Also\n\n- [Introduction to Rx: Create](http://www.introtorx.com/Content/v1.0.10621.0/04_CreatingObservableSequences.html#ObservableCreate)\n- [Introduction to Rx: Generate](http://www.introtorx.com/Content/v1.0.10621.0/04_CreatingObservableSequences.html#ObservableGenerate)\n- [101 Rx Samples: Generate](http://rxwiki.wikidot.com/101samples#toc42)\n- [RxJava Tutorial 03: Observable from, just, & create methods](https://www.youtube.com/watch?v=sDqrlNprY24)\n\n## Language-Specific Information\n\n### RxGroovy `create`\n\nRxGroovy implements this operator as `create`.\n\n#### Sample Code\n\n``` groovy\ndef myObservable = Observable.create({ aSubscriber ->\n  try {\n    for (int i = 1; i < 1000000; i++) {\n      if (aSubscriber.isUnsubscribed()) {\n        return;\n      }\n      aSubscriber.onNext(i);\n    }\n    if (!aSubscriber.isUnsubscribed()) {\n      aSubscriber.onCompleted();\n    }\n  } catch(Throwable t) {\n    if (!aSubscriber.isUnsubscribed()) {\n      aSubscriber.onError(t);\n    }\n  }\n})\n```\n\nIt is good practice to check the observer’s `isUnsubscribed` state so that your Observable can stop emitting items or doing expensive calculations when there is no longer an interested observer.\n\n`create` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`create(OnSubscribe)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#create(rx.Observable.OnSubscribe))\n\n### RxJava 1․x `create`\n\nRxJava implements this operator as `create`.\n\nIt is good practice to check the observer’s `isUnsubscribed` state from within the function you pass to `create` so that your Observable can stop emitting items or doing expensive calculations when there is no longer an interested observer.\n\n#### Sample Code\n\n``` java\nObservable.create(new Observable.OnSubscribe<Integer>() {\n    @Override\n    public void call(Subscriber<? super Integer> observer) {\n        try {\n            if (!observer.isUnsubscribed()) {\n                for (int i = 1; i < 5; i++) {\n                    observer.onNext(i);\n                }\n                observer.onCompleted();\n            }\n        } catch (Exception e) {\n            observer.onError(e);\n        }\n    }\n } ).subscribe(new Subscriber<Integer>() {\n        @Override\n        public void onNext(Integer item) {\n            System.out.println(\"Next: \" + item);\n        }\n\n        @Override\n        public void onError(Throwable error) {\n            System.err.println(\"Error: \" + error.getMessage());\n        }\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"Sequence complete.\");\n        }\n    });\n```\n\n``` javascript\nNext: 1\nNext: 2\nNext: 3\nNext: 4\nSequence complete.\n```\n\n`create` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`create(OnSubscribe)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#create(rx.Observable.OnSubscribe))\n\n### RxJS `create createWithDisposable generate generateWithAbsoluteTime generateWithRelativeTime`\n\nRxJS implements this operator as `create` (there is also an alternate name for the same operator: `createWithDisposable`).\n\n#### Sample Code\n\n``` javascript\n/* Using a function */\nvar source = Rx.Observable.create(function (observer) {\n    observer.onNext(42);\n    observer.onCompleted();\n\n    // Note that this is optional, you do not have to return this if you require no cleanup\n    return function () { console.log('disposed'); };\n});\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 42\nCompleted\n```\n\n``` javascript\n/* Using a disposable */\nvar source = Rx.Observable.create(function (observer) {\n    observer.onNext(42);\n    observer.onCompleted();\n\n    // Note that this is optional, you do not have to return this if you require no cleanup\n    return Rx.Disposable.create(function () {\n        console.log('disposed');\n    });\n});\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 42\nCompleted\n```\n\n`create` is found in the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nYou can use the `generate` operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of `generate` takes four parameters:\n\n1.  the first item to emit\n2.  a function to test an item to determine whether to emit it (`true`) or terminate the Observable (`false`)\n3.  a function to generate the next item to test and emit based on the value of the previous item\n4.  a function to transform items before emitting them\n\nYou can also pass in as an optional fifth parameter a [Scheduler](../scheduler) that `generate` will use to create and emit its sequence (it uses `currentThread` by default).\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.generate(\n    0,\n    function (x) { return x < 3; },\n    function (x) { return x + 1; },\n    function (x) { return x; }\n);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nCompleted\n```\n\n`generate` is found in the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nYou can use the `generateWithRelativeTime` operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of `generateWithRelativeTime` takes five parameters:\n\n1.  the first item to emit\n2.  a function to test an item to determine whether to emit it (`true`) or terminate the Observable (`false`)\n3.  a function to generate the next item to test and emit based on the value of the previous item\n4.  a function to transform items before emitting them\n5.  a function to indicate how long, in milliseconds, the generator should wait after the emission of the previous item before emitting this item\n\nYou can also pass in as an optional sixth parameter a [Scheduler](../scheduler) that `generate` will use to create and emit its sequence (it uses `currentThread` by default).\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.generateWithRelativeTime(\n    1,\n    function (x) { return x < 4; },\n    function (x) { return x + 1; },\n    function (x) { return x; },\n    function (x) { return 100 * x; }\n).timeInterval();\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: {value: 1, interval: 100}\nNext: {value: 2, interval: 200}\nNext: {value: 3, interval: 300}\nCompleted\n```\n\n`generateWithRelativeTime` is found in the following distributions:\n\n- `rx.lite.js`\n- `rx.lite.compat.js`\n- `rx.time.js` (requires `rx.js` or `rx.compat.js`)\n\nYou can use the `generateWithAbsoluteTime` operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of `generateWithAbsoluteTime` takes five parameters:\n\n1.  the first item to emit\n2.  a function to test an item to determine whether to emit it (`true`) or terminate the Observable (`false`)\n3.  a function to generate the next item to test and emit based on the value of the previous item\n4.  a function to transform items before emitting them\n5.  a function to indicate at what time (expressed as a `Date`) the generator should emit the the new item\n\nYou can also pass in as an optional sixth parameter a [Scheduler](../scheduler) that `generate` will use to create and emit its sequence (it uses `currentThread` by default).\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.generate(\n    1,\n    function (x) { return x < 4; },\n    function (x) { return x + 1; },\n    function (x) { return x; },\n    function (x) { return Date.now() + (100 * x); }\n).timeInterval();\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: {value: 1, interval: 100}\nNext: {value: 2, interval: 200}\nNext: {value: 3, interval: 300}\nCompleted\n```\n\n`generateWithAbsoluteTime` is found in the following distribution:\n\n- `rx.time.js` (requires `rx.js` or `rx.compat.js`)\n\n### RxPHP `create`\n\nRxPHP implements this operator as `create`.\n\nCreates an observable sequence from a specified subscribeAction callable implementation.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/create/create.php\n\n//With static method\n$source = \\Rx\\Observable::create(function (\\Rx\\ObserverInterface $observer) {\n    $observer->onNext(42);\n    $observer->onCompleted();\n\n    return new CallbackDisposable(function () {\n        echo \"Disposed\\n\";\n    });\n});\n\n$subscription = $source->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 42\nComplete!\nDisposed\n```\n\n### RxSwift `create generate`\n\nRxSwift implements this operator as `create`.\n\n#### Sample Code\n\n``` swift\nlet source : Observable = Observable.create { observer in\n    for i in 1...5 {\n        observer.on(.next(i))\n    }\n    observer.on(.completed)\n\n    // Note that this is optional. If you require no cleanup you can return\n    // `Disposables.create()` (which returns the `NopDisposable` singleton)\n    return Disposables.create {\n        print(\"disposed\")\n    }\n}\n\nsource.subscribe {\n    print($0)\n}\n```\n\n``` javascript\nnext(1)\nnext(2)\nnext(3)\nnext(4)\nnext(5)\ncompleted\ndisposed\n```\n\nYou can use the `generate` operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of `generate` takes three parameters:\n\n1.  the first item to emit\n2.  a function to test an item to determine whether to emit it (`true`) or terminate the Observable (`false`)\n3.  a function to generate the next item to test and emit based on the value of the previous item\n\nYou can also pass in as an optional fourth parameter a [Scheduler](../scheduler) that `generate` will use to create and emit its sequence (it uses `CurrentThreadScheduler` by default).\n\n#### Sample Code\n\n``` swift\nlet source = Observable.generate(\n   initialState: 0,\n   condition: { $0 < 3 },\n   iterate: { $0 + 1 }\n)\n\nsource.subscribe {\n   print($0)\n}\n```\n\n``` javascript\nnext(0)\nnext(1)\nnext(2)\ncompleted\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/create.html](http://reactivex.io/documentation/operators/create.html)"
- name: Debounce
  id: documentation/operators/debounce
  summary: The Debounce operator filters out items emitted by the source Observable that are rapidly followed by another emitted item
  description: "# Debounce\n\nonly emit an item from an Observable if a particular timespan has passed without it emitting another item\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#debounce)\n\nThe Debounce operator filters out items emitted by the source Observable that are rapidly followed by another emitted item.\n\n#### See Also\n\n- [Backpressure-related Operators](backpressure)\n- [Sample](sample)\n- [Window](window)\n- [Introduction to Rx: Throttle](http://www.introtorx.com/Content/v1.0.10621.0/13_TimeShiftedSequences.html#Throttle)\n- [RxMarbles: `debounce`](http://rxmarbles.com/#debounce)\n- [RxMarbles: `debounceWithSelector`](http://rxmarbles.com/#debounceWithSelector)\n- [101 Rx Samples: Throttle — Simple](http://rxwiki.wikidot.com/101samples#toc30)\n\n## Language-Specific Information\n\n### RxGroovy `debounce throttleWithTimeout`\n\nRxGroovy implements this operator as `throttleWithTimeout` and `debounce`.\n\nNote that the last item emitted by the source Observable will be emitted in turn by this operator even if the source Observable’s `onCompleted` notification is issued within the time window you specify since that item’s emission. That is to say: an `onCompleted` notification will not trigger a throttle.\n\nOne variant of `throtleWithTimeout`/`debounce` (two names for the same operator variant) throttles at a periodic time interval that you choose by passing in a `TimeUnit` and a quantity of such units as parameters to the operator.\n\nThis variant operates by default on the `computation` [Scheduler](../scheduler), but you can optionally pass in a Scheduler of your choosing as a third parameter.\n\n- Javadoc: [`throttleWithTimeout(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleWithTimeout(long,%20java.util.concurrent.TimeUnit)) and [`debounce(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`throttleWithTimeout(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleWithTimeout(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)) and [`debounce(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nThere ia also a variant of `debounce` (that does not have a `throttleWithTimeout` alias) that throttles the source Observable by applying a function to each item it emits, this function generating an Observable. If the source Observable emits another item before this newly-generated Observable terminates, `debounce` will suppress the item.\n\nThis variant of `debounce` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`debounce(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(rx.functions.Func1))\n\n### RxJava 1․x `debounce throttleWithTimeout`\n\nRxJava implements this operator as `throttleWithTimeout` and `debounce`.\n\nNote that the last item emitted by the source Observable will be emitted in turn by this operator even if the source Observable’s `onCompleted` notification is issued within the time window you specify since that item’s emission. That is to say: an `onCompleted` notification will not trigger a throttle.\n\nOne variant of `throtleWithTimeout`/`debounce` (two names for the same operator variant) throttles at a periodic time interval that you choose by passing in a `TimeUnit` and a quantity of such units as parameters to the operator.\n\nThis variant operates by default on the `computation` [Scheduler](../scheduler), but you can optionally pass in a Scheduler of your choosing as a third parameter.\n\n- Javadoc: [`throttleWithTimeout(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleWithTimeout(long,%20java.util.concurrent.TimeUnit)) and [`debounce(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`throttleWithTimeout(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleWithTimeout(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)) and [`debounce(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nThere ia also a variant of `debounce` (that does not have a `throttleWithTimeout` alias) that throttles the source Observable by applying a function to each item it emits, this function generating an Observable. If the source Observable emits another item before this newly-generated Observable terminates, `debounce` will suppress the item.\n\nThis variant of `debounce` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`debounce(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(rx.functions.Func1))\n\n### RxJS `debounce debounceWithSelector throttleWithTimeout`\n\nThe first variant — called either `debounce` or `throttleWithTimeout` — accepts as its parameter a duration, defined as an integer number of milliseconds, and it suppresses any emitted items that are followed by other emitted items during that duration since the first item’s emission.\n\n#### Sample Code\n\n``` javascript\nvar times = [\n    { value: 0, time: 100 },\n    { value: 1, time: 600 },\n    { value: 2, time: 400 },\n    { value: 3, time: 700 },\n    { value: 4, time: 200 }\n];\n\n// Delay each item by time and project value;\nvar source = Rx.Observable.from(times)\n  .flatMap(function (item) {\n    return Rx.Observable\n      .of(item.value)\n      .delay(item.time);\n  })\n  .debounce(500 /* ms */);\n\nvar subscription = source.subscribe(\n  function (x) {\n    console.log('Next: %s', x);\n  },\n  function (err) {\n    console.log('Error: %s', err);\n  },\n  function () {\n    console.log('Completed');\n  });\n```\n\n``` javascript\nNext: 0\nNext: 2\nNext: 4\nCompleted\n```\n\nThe `debounceWithSelector` operator throttles the source Observable by applying a function to each item it emits, this function generating an Observable. If the source Observable emits another item before this newly-generated Observable terminates, `debounce` will suppress the item.\n\n#### Sample Code\n\n``` javascript\nvar array = [\n    800,\n    700,\n    600,\n    500\n];\n\nvar source = Rx.Observable.for(\n    array,\n    function (x) {\n        return Rx.Observable.timer(x)\n    })\n    .map(function(x, i) { return i; })\n    .throttleWithSelector(function (x) {\n        return Rx.Observable.timer(700);\n    });\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x);\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nNext: 0\nNext: 3\nCompleted\n```\n\n`debounce` and `debounceWithSelector` are found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.time.js` (requires `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `throttle`\n\nRxPHP implements this operator as `throttle`.\n\nReturns an Observable that emits only the first item emitted by the source Observable during sequential time windows of a specified duration. If items are emitted on the source observable prior to the expiration of the time period, the last item emitted on the source observable will be emitted.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/throttle/throttle.php\n\n$times = [\n    ['value' => 0, 'time' => 10],\n    ['value' => 1, 'time' => 200],\n    ['value' => 2, 'time' => 400],\n    ['value' => 3, 'time' => 500],\n    ['value' => 4, 'time' => 900]\n];\n\n// Delay each item by time and project value;\n$source = Observable::fromArray($times)\n    ->flatMap(function ($item) {\n        return Observable::of($item['value'])\n            ->delay($item['time']);\n    })\n    ->throttle(300 /* ms */);\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 0\nNext value: 1\nNext value: 3\nNext value: 4\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/debounce.html](http://reactivex.io/documentation/operators/debounce.html)"
- name: DefaultIfEmpty
  id: documentation/operators/defaultifempty
  summary: The DefaultIfEmpty operator simply mirrors the source Observable exactly if the source Observable emits any items
  description: "# DefaultIfEmpty\n\nemit items from the source Observable, or a default item if the source Observable emits nothing\n\nThe DefaultIfEmpty operator simply mirrors the source Observable exactly if the source Observable emits any items. If the source Observable terminates normally (with an `onComplete`) without emitting any items, the Observable returned from DefaultIfEmpty will instead emit a default item of your choosing before it too completes.\n\n#### See Also\n\n- [Introduction to Rx: DefaultIfEmpty](http://www.introtorx.com/Content/v1.0.10621.0/06_Inspection.html#DefaultIfEmpty)\n\n## Language-Specific Information\n\n### RxGroovy `defaultIfEmpty switchIfEmpty`\n\nRxGroovy implements this operator as `defaultIfEmpty`.\n\nThis operator does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`defaultIfEmpty(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#defaultIfEmpty(T))\n\nThere is also a new operator in RxGroovy 1.1 called `switchIfEmpty` that, rather than emitting a backup *value* if the source Observable terminates without having emitted any items, it emits the emissions from a backup *Observable*.\n\n### RxJava 1․x `defaultIfEmpty switchIfEmpty`\n\nRxJava implements this operator as `defaultIfEmpty`.\n\nThis operator does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`defaultIfEmpty(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#defaultIfEmpty(T))\n\nThere is also a new operator in RxJava 1.1 called `switchIfEmpty` that, rather than emitting a backup *value* if the source Observable terminates without having emitted any items, it emits the emissions from a backup *Observable*.\n\n#### Sample Code\n\n``` java\nObservable.empty().defaultIfEmpty(10).subscribe(\n    val -> System.out.println(\"next: \" + val),\n    err -> System.err.println(err) ,\n    () -> System.out.println(\"completed\")\n);\n```\n\n``` javascript\nnext: 10\ncompleted\n```\n\n### RxJava 2․x `defaultIfEmpty switchIfEmpty`\n\nRxJava implements this operator as `defaultIfEmpty`.\n\nThis operator does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`defaultIfEmpty(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#defaultIfEmpty(T))\n\n#### Sample Code\n\n``` java\nFlowable.empty().defaultIfEmpty(10).subscribe(\n    val -> System.out.println(\"next: \" + val),\n    err -> System.err.println(err) ,\n    () -> System.out.println(\"completed\")\n);\n```\n\n``` javascript\nnext: 10\ncompleted\n```\n\n### RxJS `defaultIfEmpty`\n\nRxJS implements `defaultIfEmpty`, but the parameter that sets the default value is optional. If you do not pass this default value, `defaultIfEmpty` will emit a “`null`” if the source Observable completes without emitting anything. (Note that an emission of a “`null`” is *not* the same as no emission.)\n\n#### Sample Code\n\n``` javascript\n/* Without a default value */\nvar source = Rx.Observable.empty().defaultIfEmpty();\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x.toString()); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: null\nCompleted\n```\n\n``` javascript\n/* With a defaultValue */\nvar source = Rx.Observable.empty().defaultIfEmpty(false);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x.toString()); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: false\nCompleted\n```\n\n`defaultIfEmpty` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `defaultIfEmpty`\n\nRxPHP implements this operator as `defaultIfEmpty`.\n\nReturns the specified value of an observable if the sequence is empty.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/defaultIfEmpty/defaultIfEmpty.php\n\n$source = \\Rx\\Observable::empty()->defaultIfEmpty(Rx\\Observable::of('something'));\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: something\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/defaultifempty.html](http://reactivex.io/documentation/operators/defaultifempty.html)"
- name: Defer
  id: documentation/operators/defer
  summary: The Defer operator waits until an observer subscribes to it, and then it generates an Observable, typically with an Observable factory function
  description: "# Defer\n\ndo not create the Observable until the observer subscribes, and create a fresh Observable for each observer\n\nThe Defer operator waits until an observer subscribes to it, and then it generates an Observable, typically with an Observable factory function. It does this afresh for each subscriber, so although each subscriber may think it is subscribing to the same Observable, in fact each subscriber gets its own individual sequence.\n\nIn some circumstances, waiting until the last minute (that is, until subscription time) to generate the Observable can ensure that this Observable contains the freshest data.\n\n#### See Also:\n\n- [Deferring Observable code until subscription in RxJava](http://blog.danlew.net/2015/07/23/deferring-observable-code-until-subscription-in-rxjava/) by Dan Lew\n\n## Language-Specific Information\n\n### RxGroovy `defer ifThen switchCase`\n\nRxGroovy implements this operator as `defer`. This operator takes as its sole parameter an Observable factory function of your choosing. This function takes no parameters and returns an Observable.\n\n`defer` does not by default operate on a particular [Scheduler](../scheduler).\n\n- Javadoc: [`defer()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#defer(rx.functions.Func0))\n\nThere is a somewhat similar operator in the optional `rxjava-computation-expressions` package (it is not part of the standard RxGroovy set of operators). The `switchCase` operator conditionally creates and returns one of a set of possible Observables.\n\nAn even simpler operator in the optional `rxjava-computation-expressions` package (also not part of the standard RxGroovy set of operators) is `ifThen`. This operator checks a condition and then either mirrors the source Observable or an empty Observable depending on the result.\n\n### RxJava 1․x `defer ifThen switchCase`\n\nRxJava implements this operator as `defer`. This operator takes as its sole parameter an Observable factory function of your choosing. This function takes no parameters and returns an Observable.\n\n`defer` does not by default operate on a particular [Scheduler](../scheduler).\n\n- Javadoc: [`defer()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#defer(rx.functions.Func0))\n\nThere is a somewhat similar operator in the optional `rxjava-computation-expressions` package (it is not part of the standard RxJava set of operators). The `switchCase` operator conditionally creates and returns one of a set of possible Observables.\n\nAn even simpler operator in the optional `rxjava-computation-expressions` package (also not part of the standard RxGroovy set of operators) is `ifThen`. This operator checks a condition and then either mirrors the source Observable or an empty Observable depending on the result.\n\n### RxJS `case defer if switchCase`\n\nRxJS implements this operator as `defer`. This operator takes as its sole parameter an Observable factory function of your choosing. This function takes no parameters and returns an Observable or a Promise.\n\n#### Sample Code\n\n``` javascript\n/* Using an observable sequence */\nvar source = Rx.Observable.defer(function () {\n    return Rx.Observable.return(42);\n});\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); } );\n```\n\n``` javascript\nNext: 42\nCompleted\n```\n\n``` javascript\nvar source = Rx.Observable.defer(function () {\n    return RSVP.Promise.resolve(42);\n});\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); } );\n```\n\n``` javascript\nNext: 42\nCompleted\n```\n\n`defer` is found in the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nRxJS also implements the `if` operator. It takes as parameters a function that returns a boolean, an Observable to mirror if that function returns a true value, and optionally a second Observable to mirror if that function returns a false value (if you omit this parameter, `if` will mirror an empty Observable in such a case).\n\n#### Sample Code\n\n``` javascript\nvar shouldRun = false;\n\nvar source = Rx.Observable.if(\n    function () { return shouldRun; },\n    Rx.Observable.return(42),\n    Rx.Observable.return(56)\n);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 56\nCompleted\n```\n\n`if` is found in the following distributions:\n\n- `rx.all.js`\n- `rx.experimental.js` (requires `rx.js`, `rx.compat.js`, `rx.lite.js`, or `rx.lite.compat.js`)\n\nRxJS implements a somewhat similar operator called `case` (or “`switchCase`”). This operator conditionally creates and returns one of a set of possible Observables. It takes the following parameters:\n\n1.  a function that returns the key that determines which Observable to emit\n2.  an object that associates those keys with particular Observables\n3.  (optional) a [Scheduler](../scheduler) or an Observable:\n    Scheduler  \n    the Scheduler you want this operator to use\n\n    Observable  \n    the default Observable to emit if the key does not associate with any Observables\n\n#### Sample Code\n\n``` javascript\nvar sources = {\n    'foo': Rx.Observable.return(42),\n    'bar': Rx.Observable.return(56)\n};\n\nvar defaultSource = Rx.Observable.empty();\n\nvar source = Rx.Observable.case(\n    function () {\n        return 'foo';\n    },\n    sources,\n    defaultSource);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); } );\n```\n\n``` javascript\nNext: 42\nCompleted\n```\n\n`case`/`switchCase` is found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.experimental.js` (requires `rx.js`, `rx.compat.js`, `rx.lite.js`, or `rx.lite.compat.js`)\n\n### RxPHP `defer`\n\nRxPHP implements this operator as `defer`.\n\nReturns an observable sequence that invokes the specified factory function whenever a new observer subscribes.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/defer/defer.php\n\n\n$source = \\Rx\\Observable::defer(function () {\n    return \\Rx\\Observable::of(42);\n});\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 42\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/defer.html](http://reactivex.io/documentation/operators/defer.html)"
- name: Delay
  id: documentation/operators/delay
  summary: The Delay operator modifies its source Observable by pausing for a particular increment of time (that you specify) before emitting each of the source Observable’s items
  description: "# Delay\n\nshift the emissions from an Observable forward in time by a particular amount\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#delay)\n\nThe Delay operator modifies its source Observable by pausing for a particular increment of time (that you specify) before emitting each of the source Observable’s items. This has the effect of shifting the entire sequence of items emitted by the Observable forward in time by that specified increment.\n\n#### See Also\n\n- [Introduction to Rx: Delay](http://www.introtorx.com/Content/v1.0.10621.0/13_TimeShiftedSequences.html#Delay)\n- [RxMarbles: `delay`](http://rxmarbles.com/#delay)\n- [RxMarbles: `delayWithSelector`](http://rxmarbles.com/#delayWithSelector)\n- [101 Rx Samples: Delay — Simple](http://rxwiki.wikidot.com/101samples#toc27)\n\n## Language-Specific Information\n\n### RxGroovy `delay delaySubscription`\n\nRxGroovy implements this operator as variants of `delay` and `delaySubscription`.\n\nThe first variant of `delay` accepts parameters that define a duration of time (a quantity of time, and a `TimeUnit` that this quantity is denominated in). Each time the source Observable emits an item, `delay` starts a timer, and when that timer reaches the given duration, the Observable returned from `delay` emits the same item.\n\nNote that `delay` will not time-shift an `onError` notification in this fashion but it will forward such a notification immediately to its subscribers while dropping any pending `onNext` notifications. It will however time shift an `onCompleted` notification.\n\nBy default this variant of `delay` operates on the `computation` [Scheduler](../scheduler), but you can choose a different Scheduler by passing it in as an optional third parameter to `delay`\n\n- Javadoc: [`delay(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`delay()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nAnother variant of `delay` does not use a constant delay duration, but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable emits a item or completes, the Observable returned by `delay` emits the associated item.\n\nThis variant of `delay` does not by default run on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`delay(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(rx.functions.Func1))\n\nThe variant of `delay` that uses a per-item Observable to set the delay has a variant that allows you to pass in a function that returns an Observable that acts as a delay timer for the subscription to the source Observable (in the absence of this, `delay` subscribes to the source Observable as soon as an observer subscribes to the Observable returned by `delay`).\n\nThis variant of `delay` does not by default run on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`delay(Func0,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(rx.functions.Func0,%20rx.functions.Func1))\n\nThere is also an operator with which you can delay the subscription to the source Observable: `delaySubscription`. It accepts parameters that define the amount of time to delay (a quantity of time, and a `TimeUnit` that this quantity is denominated in).\n\nThis variant of `delay` by default runs on the `computation` [Scheduler](../scheduler), but you can choose a different Scheduler by passing it in as an optional third parameter to `delaySubscription`.\n\n- Javadoc: [`delaySubscription(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#delaySubscription(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`delaySubscription(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#delaySubscription(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nAnd there is a variant of `delaySubscription` that uses an Observable (returned by a function you supply) rather than a fixed duration in order to set the subscription delay.\n\nThis variant of `delaySubscription` does not by default run on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`delaySubscription(Func0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#delaySubscription(rx.functions.Func0))\n\n### RxJava 1․x `delay delaySubscription`\n\nRxJava implements this operator as variants of `delay` and `delaySubscription`.\n\nThe first variant of `delay` accepts parameters that define a duration of time (a quantity of time, and a `TimeUnit` that this quantity is denominated in). Each time the source Observable emits an item, `delay` starts a timer, and when that timer reaches the given duration, the Observable returned from `delay` emits the same item.\n\nNote that `delay` will not time-shift an `onError` notification in this fashion but it will forward such a notification immediately to its subscribers while dropping any pending `onNext` notifications. It will however time shift an `onCompleted` notification.\n\nBy default this variant of `delay` operates on the `computation` [Scheduler](../scheduler), but you can choose a different Scheduler by passing it in as an optional third parameter to `delay`\n\n- Javadoc: [`delay(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`delay()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nAnother variant of `delay` does not use a constant delay duration, but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable emits an item or completes, the Observable returned by `delay` emits the associated item.\n\nThis variant of `delay` does not by default run on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`delay(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(rx.functions.Func1))\n\nThe variant of `delay` that uses a per-item Observable to set the delay has a variant that allows you to pass in a function that returns an Observable that acts as a delay timer for the subscription to the source Observable (in the absence of this, `delay` subscribes to the source Observable as soon as an observer subscribes to the Observable returned by `delay`).\n\nThis variant of `delay` does not by default run on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`delay(Func0,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(rx.functions.Func0,%20rx.functions.Func1))\n\nThere is also an operator with which you can delay the subscription to the source Observable: `delaySubscription`. It accepts parameters that define the amount of time to delay (a quantity of time, and a `TimeUnit` that this quantity is denominated in).\n\nThis variant of `delay` by default runs on the `computation` [Scheduler](../scheduler), but you can choose a different Scheduler by passing it in as an optional third parameter to `delaySubscription`.\n\n- Javadoc: [`delaySubscription(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#delaySubscription(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`delaySubscription(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#delaySubscription(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nAnd there is a variant of `delaySubscription` that uses an Observable (returned by a function you supply) rather than a fixed duration in order to set the subscription delay.\n\nThis variant of `delaySubscription` does not by default run on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`delaySubscription(Func0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#delaySubscription(rx.functions.Func0))\n\n### RxJS `delay delaySubscription delayWithSelector`\n\nIn RxJS you can set the per-item delay in two ways: by passing a number of milliseconds into the `delay` operator (which will delay each emission by that amount of time), or by passing in a `Date` object (which will delay the beginning of the sequence of emissions until that absolute point in time).\n\nThis operator operates by default on the `timeout` [Scheduler](../scheduler), but you can override this by passing in another Scheduler as an optional second parameter.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 3)\n    .delay(new Date(Date.now() + 1000));\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x.toString()); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nCompleted\n```\n\n``` javascript\nvar source = Rx.Observable.range(0, 3)\n    .delay(1000);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x.toString()); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nCompleted\n```\n\n`delaySubscription` is similar to `delay` but rather than timeshifting the emissions from the source Observable, it timeshifts the moment of subscription to that Observable. You pass to this operator a time value (either a `Number`, in which case this sets the number of milliseconds of delay, or a `Date`, in which case this sets an absolute future time at which `delaySubscription` will trigger the subscription). You may optionally pass a [Scheduler](../scheduler) as a second parameter, which `delaySubscription` will use to govern the delay period or trigger time.\n\n#### Sample Code\n\n``` javascript\nvar start = Date.now();\nvar source = Rx.Observable.range(0, 3).delaySubscription(5000);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: %s, %s', x, Date.now() - start); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0, 5001\nNext: 1, 5002\nNext: 2, 5003\nCompleted\n```\n\n`delayWithSelector` is like `delay` but does not use a constant delay duration (or absolute time), but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable completes, the Observable returned by `delay` emits the associated item.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable\n    .range(0, 3)\n    .delayWithSelector(\n        function (x) {\n            return Rx.Observable.timer(x * 400);\n        })\n    .timeInterval()\n    .map(function (x) { return x.value + ':' + x.interval; });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0:0\nNext: 1:400\nNext: 2:400\nCompleted\n```\n\nThere is also a version of `delayWithSelector` that takes an additional (first) argument: an Observable that sets a delay before `delayWithSelector` subscribes to the source Observable after it itself is subscribed to.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable\n    .range(0, 3)\n    .delayWithSelector(\n        Rx.Observable.timer(300),\n        function (x) {\n            return Rx.Observable.timer(x * 400);\n        }\n    )\n    .timeInterval()\n    .map(function (x) { return x.value + ':' + x.interval; });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0:300\nNext: 1:400\nNext: 2:400\nCompleted\n```\n\n`delay`, `delaySubscription`, and `delayWithSelector` require `rx.lite.js` or `rx.lite.compat.js` and are found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.time.js` (requires `rx.js` or `rx.compat.js`)\n\n### RxPHP `delay`\n\nRxPHP implements this operator as `delay`.\n\nTime shifts the observable sequence by dueTime. The relative time intervals between the values are preserved.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/delay/delay.php\n\n\\Rx\\Observable::interval(1000)\n    ->doOnNext(function ($x) {\n        echo 'Side effect: ' . $x . \"\\n\";\n    })\n    ->delay(500)\n    ->take(5)\n    ->subscribe($createStdoutObserver());\n```\n\n``` javascript\nSide effect: 0\nNext value: 0\nSide effect: 1\nNext value: 1\nSide effect: 2\nNext value: 2\nSide effect: 3\nNext value: 3\nSide effect: 4\nNext value: 4\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/delay.html](http://reactivex.io/documentation/operators/delay.html)"
- name: Distinct
  id: documentation/operators/distinct
  summary: The Distinct operator filters an Observable by only allowing items through that have not already been emitted
  description: "# Distinct\n\nsuppress duplicate items emitted by an Observable\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#distinct)\n\nThe Distinct operator filters an Observable by only allowing items through that have not already been emitted.\n\nIn some implementations there are variants that allow you to adjust the criteria by which two items are considered “distinct.” In some, there is a variant of the operator that only compares an item against its immediate predecessor for distinctness, thereby filtering only *consecutive* duplicate items from the sequence.\n\n#### See Also\n\n- [Filter](filter)\n- [Introduction to Rx: Distinct and DistinctUntilChanged](http://www.introtorx.com/Content/v1.0.10621.0/05_Filtering.html#Distinct)\n- [RxMarbles: `distinct`](http://rxmarbles.com/#distinct)\n- [RxMarbles: `distinctUntilChanged`](http://rxmarbles.com/#distinctUntilChanged)\n\n## Language-Specific Information\n\n### RxGroovy `distinct distinctUntilChanged`\n\nRxGroovy implements this operator as `distinct`.\n\n- Javadoc: [`distinct()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinct())\n\nThere is also a variant of this operator that takes a function as a parameter. This function operates on items emitted by the source Observable to generate a “key.” It is these keys, then, and not the items themselves, that `distinct` will compare to determine whether or not two items are distinct.\n\n- Javadoc: [`distinct(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinct(rx.functions.Func1))\n\nRxGroovy also implements the `distinctUntilChanged` operator. It only compares emitted items from the source Observable against their immediate predecessors in order to determine whether or not they are distinct.\n\n- Javadoc: [`distinctUntilChanged()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinctUntilChanged())\n\nAs with `distinct`, there is also a version of `distinctUntilChanged` that accepts a key selector function and that uses the resulting key to determine whether or not two adjacently-emitted items are distinct.\n\n- Javadoc: [`distinctUntilChanged(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinctUntilChanged(rx.functions.Func1))\n\n`distinct` and `distinctUntilChanged` do not by default operate on any particular [Scheduler](../scheduler).\n\n### RxJava 1․x `distinct distinctUntilChanged`\n\nRxJava implements this operator as `distinct`.\n\n#### Sample Code\n\n``` java\nObservable.just(1, 2, 1, 1, 2, 3)\n          .distinct()\n          .subscribe(new Subscriber<Integer>() {\n        @Override\n        public void onNext(Integer item) {\n            System.out.println(\"Next: \" + item);\n        }\n\n        @Override\n        public void onError(Throwable error) {\n            System.err.println(\"Error: \" + error.getMessage());\n        }\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"Sequence complete.\");\n        }\n    });\n```\n\n``` javascript\nNext: 1\nNext: 2\nNext: 3\nSequence complete.\n```\n\n- Javadoc: [`distinct()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinct())\n\nThere is also a variant of this operator that takes a function as a parameter. This function operates on items emitted by the source Observable to generate a “key.” It is these keys, then, and not the items themselves, that `distinct` will compare to determine whether or not two items are distinct.\n\n- Javadoc: [`distinct(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinct(rx.functions.Func1))\n\nRxJava also implements the `distinctUntilChanged` operator. It only compares emitted items from the source Observable against their immediate predecessors in order to determine whether or not they are distinct.\n\n- Javadoc: [`distinctUntilChanged()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinctUntilChanged())\n\nAs with `distinct`, there is also a version of `distinctUntilChanged` that accepts a key selector function and that uses the resulting key to determine whether or not two adjacently-emitted items are distinct.\n\n- Javadoc: [`distinctUntilChanged(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinctUntilChanged(rx.functions.Func1))\n\n`distinct` and `distinctUntilChanged` do not by default operate on any particular [Scheduler](../scheduler).\n\n### RxJS `distinct distinctUntilChanged`\n\nIn RxJS, the `distinct` operator has two optional parameters:\n\n1.  a function that accepts an item emitted by the source Observable and returns a *key* which will be used instead of the item itself when comparing two items for distinctness\n2.  a function that accepts two items (or two keys) and compares them for distinctness, returning `false` if they are distinct (an equality function is the default if you do not supply your own function here)\n\n#### Sample Code\n\n``` javascript\n/* Without key selector */\nvar source = Rx.Observable.fromArray([\n        42, 24, 42, 24\n    ])\n    .distinct();\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x.toString()); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 42\nNext: 24\nCompleted\n```\n\n``` javascript\n/* With key selector */\nvar source = Rx.Observable.fromArray([\n        {value: 42}, {value: 24}, {value: 42}, {value: 24}\n    ])\n    .distinct(function (x) { return x.value; });\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x.toString());\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nNext: { value: 42 }\nNext: { value: 24 }\nCompleted\n```\n\nRxJS also has a `distinctUntilChanged` operator. It only compares emitted items from the source Observable against their immediate predecessors in order to determine whether or not they are distinct. It takes the same two optional parameters as the `distinct` operator.\n\n#### Sample Code\n\n``` javascript\n/* Without key selector */\nvar source = Rx.Observable.fromArray([\n        24, 42, 24, 24\n    ])\n    .distinctUntilChanged();\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 24\nNext: 42\nNext: 24\nCompleted\n```\n\n``` javascript\n/* With key selector */\nvar source = Rx.Observable.fromArray([\n        {value: 24}, {value: 42}, {value: 42}, {value: 24}\n    ])\n    .distinctUntilChanged(function (x) { return x.value; });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x.toString()); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: { value: 24 }\nNext: { value: 42 }\nNext: { value: 24 }\nCompleted\n```\n\n`distinct` and `distinctUntilChanged` are found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `distinct distinctKey distinctUntilChanged distinctUntilKeyChanged`\n\nRxPHP implements this operator as `distinct`.\n\nReturns an observable sequence that contains only distinct elements according to the keySelector and the comparer. Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow large.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/distinct/distinct.php\n\n$source = \\Rx\\Observable::fromArray([\n    42, 24, 42, 24\n])->distinct();\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 42\nNext value: 24\nComplete!\n```\n\nRxPHP also has an operator `distinctKey`.\n\nVariant of distinct that takes a key selector\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/distinct/distinctKey.php\n\n$source = \\Rx\\Observable::fromArray([\n    ['id' => '42'],\n    ['id' => '24'],\n    ['id' => '42'],\n    ['id' => '24']\n])\n    ->distinctKey(function ($x) {\n        return $x['id'];\n    })\n    ->map(function ($x) {\n        return $x['id'];\n    });\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 42\nNext value: 24\nComplete!\n```\n\nRxPHP also has an operator `distinctUntilChanged`.\n\nA variant of distinct that only compares emitted items from the source Observable against their immediate predecessors in order to determine whether or not they are distinct.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/distinct/distinctUntilChanged.php\n\n$source = \\Rx\\Observable::fromArray([\n    24, 42, 24, 24\n])->distinctUntilChanged();\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 24\nNext value: 42\nNext value: 24\nComplete!\n```\n\nRxPHP also has an operator `distinctUntilKeyChanged`.\n\nVariant of distinctUntilChanged that takes a key selector and the comparer.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/distinct/distinctUntilKeyChanged.php\n\n$source = \\Rx\\Observable::fromArray([\n    ['id' => '24'],\n    ['id' => '42'],\n    ['id' => '24'],\n    ['id' => '24']\n])\n    ->distinctUntilKeyChanged(function ($x) {\n        return $x['id'];\n    })\n    ->map(function ($x) {\n        return $x['id'];\n    });\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 24\nNext value: 42\nNext value: 24\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/distinct.html](http://reactivex.io/documentation/operators/distinct.html)"
- name: Do
  id: documentation/operators/do
  summary: You can register callbacks that ReactiveX will call when certain events take place on an Observable, where those callbacks will be called independently from the normal set of notifications associated with an Observable cascade
  description: "# Do\n\nregister an action to take upon a variety of Observable lifecycle events\n\nYou can register callbacks that ReactiveX will call when certain events take place on an Observable, where those callbacks will be called independently from the normal set of notifications associated with an Observable cascade. There are a variety of operators that various ReactiveX implementations have designed to allow for this.\n\n#### See Also\n\n- [Subscribe](subscribe)\n- [Introduction to Rx: Do](http://www.introtorx.com/Content/v1.0.10621.0/09_SideEffects.html#Do)\n- [Introduction to Rx: Finally](http://www.introtorx.com/Content/v1.0.10621.0/11_AdvancedErrorHandling.html#Finally)\n\n## Language-Specific Information\n\n### RxGroovy `doOnCompleted doOnEach doOnError doOnNext doOnRequest doOnSubscribe doOnTerminate doOnUnsubscribe finallyDo`\n\nRxGroovy has several Do variants.\n\nThe `doOnEach` operator allows you to establish a callback that the resulting Observable will call each time it emits an item. You can pass this callback either in the form of an `Action` that takes an `onNext` variety of `Notification` as its sole parameter, or you can pass in an Observer whose `onNext` method will be called as if it had subscribed to the Observable.\n\n- Javadoc: [`doOnEach(Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnEach(rx.functions.Action1))\n- Javadoc: [`doOnEach(Observer)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnEach(rx.Observer))\n\nThe `doOnNext` operator is much like `doOnEach(Action1)` except that the `Action` that you pass it as a parameter does not accept a `Notification` but instead simply accepts the emitted item.\n\n- Javadoc: [`doOnNext(Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnNext(rx.functions.Action1))\n\nThe `doOnRequest` operator (new in RxGroovy 1.1) registers an `Action` which will be called whenever an observer requests additional items from the resulting Observable. That `Action` receives as its parameter the number of items that the observer is requesting.\n\n- Javadoc: [`doOnRequest(Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnRequest(rx.functions.Action1))\n\nThe `doOnSubscribe` operator registers an `Action` which will be called whenever an observer subscribes to the resulting Observable.\n\n- Javadoc: [`doOnSubscribe(Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnSubscribe(rx.functions.Action0))\n\nThe `doOnUnsubscribe` operator registers an `Action` which will be called whenever an observer unsubscribes from the resulting Observable.\n\n- Javadoc: [`doOnUnsubscribe(Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnUnsubscribe(rx.functions.Action0))\n\nThe `doOnCompleted` operator registers an `Action` which will be called if the resulting Observable terminates normally, calling `onCompleted`.\n\n- Javadoc: [`doOnCompleted(Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnCompleted(rx.functions.Action0))\n\nThe `doOnError` operator registers an `Action` which will be called if the resulting Observable terminates abnormally, calling `onError`. This `Action` will be passed the `Throwable` representing the error.\n\n- Javadoc: [`doOnError(Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnError(rx.functions.Action1))\n\nThe `doOnTerminate` operator registers an `Action` which will be called just *before* the resulting Observable terminates, whether normally or with an error.\n\n- Javadoc: [`doOnTerminate(Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnTerminate(rx.functions.Action0))\n\nThe `finallyDo` operator registers an `Action` which will be called just *after* the resulting Observable terminates, whether normally or with an error.\n\n#### Sample Code\n\n``` groovy\ndef numbers = Observable.from([1, 2, 3, 4, 5]);\n\nnumbers.finallyDo({ println('Finally'); }).subscribe(\n   { println(it); },                          // onNext\n   { println(\"Error: \" + it.getMessage()); }, // onError\n   { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n1\n2\n3\n4\n5\nSequence complete\nFinally\n```\n\n- Javadoc: [`finallyDo(Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#finallyDo(rx.functions.Action0))\n\n### RxJava 1․x `doOnCompleted doOnEach doOnError doOnNext doOnRequest doOnSubscribe doOnTerminate doOnUnsubscribe finallyDo doAfterTerminate`\n\nRxJava has several Do variants.\n\nThe `doOnEach` operator allows you to establish a callback that the resulting Observable will call each time it emits an item. You can pass this callback either in the form of an `Action` that takes an `onNext` variety of `Notification` as its sole parameter, or you can pass in an Observer whose `onNext` method will be called as if it had subscribed to the Observable.\n\n- Javadoc: [`doOnEach(Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnEach(rx.functions.Action1))\n- Javadoc: [`doOnEach(Observer)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnEach(rx.Observer))\n\nThe `doOnNext` operator is much like `doOnEach(Action1)` except that the `Action` that you pass it as a parameter does not accept a `Notification` but instead simply accepts the emitted item.\n\n#### Sample Code\n\n``` java\nObservable.just(1, 2, 3)\n          .doOnNext(new Action1<Integer>() {\n          @Override\n          public void call(Integer item) {\n            if( item > 1 ) {\n              throw new RuntimeException( \"Item exceeds maximum value\" );\n            }\n          }\n        }).subscribe(new Subscriber<Integer>() {\n        @Override\n        public void onNext(Integer item) {\n            System.out.println(\"Next: \" + item);\n        }\n\n        @Override\n        public void onError(Throwable error) {\n            System.err.println(\"Error: \" + error.getMessage());\n        }\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"Sequence complete.\");\n        }\n    });\n```\n\n``` javascript\nNext: 1\nError: Item exceeds maximum value\n```\n\n- Javadoc: [`doOnNext(Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnNext(rx.functions.Action1))\n\nThe `doOnRequest` operator (new in RxJava 1.1) registers an `Action` which will be called whenever an observer requests additional items from the resulting Observable. That `Action` receives as its parameter the number of items that the observer is requesting.\n\n- Javadoc: [`doOnRequest(Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnRequest(rx.functions.Action1))\n\nThe `doOnSubscribe` operator registers an `Action` which will be called whenever an observer subscribes to the resulting Observable.\n\n- Javadoc: [`doOnSubscribe(Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnSubscribe(rx.functions.Action0))\n\nThe `doOnUnsubscribe` operator registers an `Action` which will be called whenever an observer unsubscribes from the resulting Observable.\n\n- Javadoc: [`doOnUnsubscribe(Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnUnsubscribe(rx.functions.Action0))\n\nThe `doOnCompleted` operator registers an `Action` which will be called if the resulting Observable terminates normally, calling `onCompleted`.\n\n- Javadoc: [`doOnCompleted(Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnCompleted(rx.functions.Action0))\n\nThe `doOnError` operator registers an `Action` which will be called if the resulting Observable terminates abnormally, calling `onError`. This `Action` will be passed the `Throwable` representing the error.\n\n- Javadoc: [`doOnError(Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnError(rx.functions.Action1))\n\nThe `doOnTerminate` operator registers an `Action` which will be called just *before* the resulting Observable terminates, whether normally or with an error.\n\n- Javadoc: [`doOnTerminate(Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnTerminate(rx.functions.Action0))\n\n`finallyDo` is deprecated since RxJava 1.1.1, in favor of `doAfterTerminate` with the same behavior.\n\nThe `finallyDo` operator registers an `Action` which will be called just *after* the resulting Observable terminates, whether normally or with an error.\n\n- Javadoc: [`finallyDo(Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#finallyDo(rx.functions.Action0))\n\nThe `doAfterTerminate` operator registers an `Action` which will be called just *after* the resulting Observable terminates, whether normally or with an error.\n\n- Javadoc: [`doAfterTerminate(Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#doAfterTerminate(rx.functions.Action0))\n\n### RxJS `do doOnCompleted doOnError doOnNext finally tap tapOnCompleted tapOnError tapOnNext`\n\nRxJS implements the basic Do operator as `do` or `tap` (two names for the same operator). You have two choices for how to use this operator:\n\n1.  You can pass it an Observer, in which case `do`/`tap` will call that Observer’s methods as though that Observer had subscribed to the resulting Observable.\n2.  You can pass in a set of 1–3 individual functions (`onNext`, `onError`, and `onCompleted`) that `do`/`tap` will call along with the similarly-named functions of any of its observers.\n\n#### Sample Code\n\n``` javascript\n/* Using an observer */\nvar observer = Rx.Observer.create(\n  function (x) { console.log('Do Next: %s', x); },\n  function (err) { console.log('Do Error: %s', err); },\n  function () { console.log('Do Completed'); }\n);\n\nvar source = Rx.Observable.range(0, 3)\n    .do(observer);\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nDo Next: 0\nNext: 0\nDo Next: 1\nNext: 1\nDo Next: 2\nNext: 2\nDo Completed\nCompleted\n```\n\n``` javascript\n/* Using a function */\nvar source = Rx.Observable.range(0, 3)\n  .do(\n    function (x)   { console.log('Do Next:', x); },\n    function (err) { console.log('Do Error:', err); },\n    function ()    { console.log('Do Completed'); }\n  );\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nDo Next: 0\nNext: 0\nDo Next: 1\nNext: 1\nDo Next: 2\nNext: 2\nDo Completed\nCompleted\n```\n\nRxJS also implements `doOnNext` or `tapOnNext` (two names for the same operator). It is a specialized form of Do that responds only to the `onNext` case, by calling a callback function you provide as a parameter. You may also optionally pass a second parameter that will be the “`this`” object from the point of view of your callback function when it executes.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 3)\n  .doOnNext(\n    function () { this.log('Do Next: %s', x); },\n    console\n  );\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nDo Next: 0\nNext: 0\nDo Next: 1\nNext: 1\nDo Next: 2\nNext: 2\nCompleted\n```\n\nRxJS also implements `doOnError` or `tapOnError` (two names for the same operator). It is a specialized form of Do that responds only to the `onError` case, by calling a callback function you provide as a parameter. You may also optionally pass a second parameter that will be the “`this`” object from the point of view of your callback function when it executes.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.throw(new Error());\n  .doOnError(\n    function (err) { this.log('Do Error: %s', err); },\n    console\n  );\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nDo Error: Error\nError: Error\n```\n\nRxJS also implements `doOnCompleted` or `tapOnCompleted` (two names for the same operator). It is a specialized form of Do that responds only to the `onCompleted` case, by calling a callback function you provide as a parameter. You may also optionally pass a second parameter that will be the “`this`” object from the point of view of your callback function when it executes.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 3)\n  .doOnCompleted(\n    function () { this.log('Do Completed'); },\n    console\n  );\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nDo Completed\nCompleted\n```\n\nRxJS also implements a `finally` operator. It takes a function that will be called after the resulting Observable terminates, whether normally (`onCompleted`) or abnormally (`onError`).\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.throw(new Error())\n    .finally(function () {\n        console.log('Finally');\n    });\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: ' + x); },\n  function (err) { console.log('Error: ' + err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nError: Error\nFinally\n```\n\n`do`/`tap`, `doOnNext`/`tapOnNext`, `doOnError`/`tapOnError`, `doOnCompleted`/`tapOnCompleted`, and `finally` are found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `do doOnError doOnCompleted finally`\n\nRxPHP implements this operator as `do`.\n\nInvokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence. This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline. When using do, it is important to note that the Observer may receive additional events after a stream has completed or errored (such as when using a repeat or resubscribing). If you are using an Observable that extends the AbstractObservable, you will not receive these events. For this special case, use the DoObserver. doOnNext, doOnError, and doOnCompleted uses the DoObserver internally and will receive these additional events.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/do/do.php\n\n$source = \\Rx\\Observable::range(0, 3)\n    ->do(\n        function ($x) {\n            echo 'Do Next:', $x, PHP_EOL;\n        },\n        function (Throwable $err) {\n            echo 'Do Error:', $err->getMessage(), PHP_EOL;\n        },\n        function () {\n            echo 'Do Completed', PHP_EOL;\n        }\n    );\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nDo Next:0\nNext value: 0\nDo Next:1\nNext value: 1\nDo Next:2\nNext value: 2\nDo Completed\nComplete!\n```\n\nRxPHP also has an operator `doOnError`.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/do/doOnError.php\n\n$source = \\Rx\\Observable::error(new Exception('Oops'))\n    ->doOnError(function (Throwable $err) {\n        echo 'Do Error:', $err->getMessage(), PHP_EOL;\n    });\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nDo Error:Oops\nException: Oops\n```\n\nRxPHP also has an operator `doOnCompleted`.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/do/doOnCompleted.php\n\n$source = \\Rx\\Observable::empty()\n    ->doOnCompleted(function () {\n        echo 'Do Completed', PHP_EOL;\n    });\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nDo Completed\nComplete!\n```\n\nRxPHP also has an operator `finally`.\n\nWill call a specified function when the source terminates on complete or error.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/finally/finally.php\n\nRx\\Observable::range(1, 3)\n    ->finally(function() {\n        echo \"Finally\\n\";\n    })\n    ->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 1\nNext value: 2\nNext value: 3\nComplete!\nFinally\n```\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/finally/finally-error.php\n\nRx\\Observable::range(1, 3)\n    ->map(function($value) {\n        if ($value == 2) {\n            throw new \\Exception('error');\n        }\n        return $value;\n    })\n    ->finally(function() {\n        echo \"Finally\\n\";\n    })\n    ->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 1\nException: error\nFinally\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/do.html](http://reactivex.io/documentation/operators/do.html)"
- name: ElementAt
  id: documentation/operators/elementat
  summary: The ElementAt operator pulls an item located at a specified index location in the sequence of items emitted by the source Observable and emits that item as its own sole emission
  description: "# ElementAt\n\nemit only item *n* emitted by an Observable\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#elementAt)\n\nThe `ElementAt` operator pulls an item located at a specified index location in the sequence of items emitted by the source Observable and emits that item as its own sole emission.\n\n#### See Also\n\n- [First](first)\n- [Last](last)\n- [Introduction to Rx: ElementAt and ElementAtUntilChanged](http://www.introtorx.com/Content/v1.0.10621.0/06_Inspection.html#ElementAt)\n- [RxMarbles: `elementAt`](http://rxmarbles.com/#elementAt)\n\n## Language-Specific Information\n\n### RxGroovy `elementAt elementAtOrDefault`\n\nRxGroovy implements this operator as `elementAt`. Pass `elementAt` a zero-based index value and it will emit the solitary item from the source Observable’s sequence that matches that index value (for example, if you pass the index value 5, `elementAt` will emit the sixth item emitted by the source Observable).\n\nIf you pass in a negative index value, or if the source Observable emits fewer than *`index value`*` + 1` items, `elementAt` will throw an `IndexOutOfBoundsException`.\n\n- Javadoc: [`elementAt(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#elementAt(int))\n\nRxGroovy also implements the `elementAtOrDefault` operator. It differs from `elementAt` in that it will not throw an exception if the source Observable emits fewer than *`index value`*` + 1` items. Instead, it will emit a “default” item that you specify with an additional parameter to `elementAtOrDefault`.\n\nIf you pass in a negative index value, `elementAt` will throw an `IndexOutOfBoundsException`.\n\n- Javadoc: [`elementAtOrDefault(int,T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#elementAtOrDefault(int,%20T))\n\n`elementAt` and `elementAtOrDefault` do not by default operate on any particular [Scheduler](../scheduler).\n\n### RxJava 1․x `elementAt elementAtOrDefault`\n\nRxGroovy implements this operator as `elementAt`. Pass `elementAt` a zero-based index value and it will emit the solitary item from the source Observable’s sequence that matches that index value (for example, if you pass the index value 5, `elementAt` will emit the sixth item emitted by the source Observable).\n\nIf you pass in a negative index value, or if the source Observable emits fewer than *`index value`*` + 1` items, `elementAt` will throw an `IndexOutOfBoundsException`.\n\n- Javadoc: [`elementAt(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#elementAt(int))\n\nRxGroovy also implements the `elementAtOrDefault` operator. It differs from `elementAt` in that it will not throw an exception if the source Observable emits fewer than *`index value`*` + 1` items. Instead, it will emit a “default” item that you specify with an additional parameter to `elementAtOrDefault`.\n\nIf you pass in a negative index value, `elementAt` will throw an `IndexOutOfBoundsException`.\n\n- Javadoc: [`elementAtOrDefault(int,T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#elementAtOrDefault(int,%20T))\n\n`elementAt` and `elementAtOrDefault` do not by default operate on any particular [Scheduler](../scheduler).\n\n### RxJS `elementAt`\n\nRxJS implements this operator as `elementAt`. Pass `elementAt` a zero-based index value and it will emit the solitary item from the source Observable’s sequence that matches that index value (for example, if you pass the index value 5, `elementAt` will emit the sixth item emitted by the source Observable).\n\nIf there is no element in the source sequence with the index value you specify, `elementAt` will issue an `onError` notification: “`Argument out of range`”\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.fromArray([1,2,3,4])\n    .elementAt(1);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 2\nCompleted\n```\n\nYou may optionally pass in a default value that `elementAt` will emit if the source Observable emits no values:\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.fromArray([])\n    .element({defaultValue: 23});\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 23\nCompleted\n```\n\n`elementAt` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\nThey require one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/elementat](http://reactivex.io/documentation/operators/elementat)"
- name: Empty
  id: documentation/operators/empty-never-throw
  summary: The Empty, Never, and Throw operators generate Observables with very specific and limited behavior
  description: "# Empty\n\ncreate an Observable that emits no items but terminates normally\n\n## Never\n\n### create an Observable that emits no items and does not terminate\n\n## Throw\n\n### create an Observable that emits no items and terminates with an error\n\nThe Empty, Never, and Throw operators generate Observables with very specific and limited behavior. These are useful for testing purposes, and sometimes also for combining with other Observables or as parameters to operators that expect other Observables as parameters.\n\n#### See Also\n\n- [Introduction to Rx: Simple Factory Methods](http://www.introtorx.com/Content/v1.0.10621.0/04_CreatingObservableSequences.html#SimpleFactoryMethods)\n\n## Language-Specific Information\n\n### RxGroovy `empty never error`\n\nRxGroovy implements these operators as `empty`, `never`, and `error`. The `error` operator takes as a parameter the `Throwable` with which you want the Observable to terminate.\n\nThese operators do not operate by default on any particular [Scheduler](../scheduler), but `empty` and `error` optionally take a Scheduler as a parameter, and if you pass them a Scheduler they will issue their termination notifications on that Scheduler.\n\n#### Sample Code\n\n``` groovy\nprintln(\"*** empty() ***\");\nObservable.empty().subscribe(\n  { println(\"empty: \" + it); },                      // onNext\n  { println(\"empty: error - \" + it.getMessage()); }, // onError\n  { println(\"empty: Sequence complete\"); }           // onCompleted\n);\n\nprintln(\"*** error() ***\");\nObservable.error(new Throwable(\"badness\")).subscribe(\n  { println(\"error: \" + it); },                      // onNext\n  { println(\"error: error - \" + it.getMessage()); }, // onError\n  { println(\"error: Sequence complete\"); }           // onCompleted\n);\n\nprintln(\"*** never() ***\");\nObservable.never().subscribe(\n  { println(\"never: \" + it); },                      // onNext\n  { println(\"never: error - \" + it.getMessage()); }, // onError\n  { println(\"never: Sequence complete\"); }           // onCompleted\n);\nprintln(\"*** END ***\");\n```\n\n``` javascript\n*** empty() ***\nempty: Sequence complete\n*** error() ***\nerror: error - badness\n*** never() ***\n*** END ***\n```\n\n- Javadoc: [`empty()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#empty())\n- Javadoc: [`never()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#never())\n- Javadoc: [`error(throwable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#error(java.lang.Throwable))\n\n### RxJava 1․x `empty never error`\n\nRxJava 1.x implements these operators as `empty`, `never`, and `error`. The `error` operator takes as a parameter the `Throwable` with which you want the Observable to terminate.\n\nThese operators do not operate by default on any particular [Scheduler](../scheduler), but `empty` and `error` optionally take a Scheduler as a parameter, and if you pass them a Scheduler they will issue their termination notifications on that Scheduler.\n\n- Javadoc: [`empty()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#empty())\n- Javadoc: [`never()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#never())\n- Javadoc: [`error(throwable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#error(java.lang.Throwable))\n\n### RxJava 2․x `empty never error`\n\nRxJava 2.x implements these operators as `empty`, `never`, and `error`. The `error` operator takes as a parameter the `Throwable` with which you want the Observable to terminate, or a `Callable` that returns such a `Throwable`.\n\nThese operators do not operate by default on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`empty()`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#empty())\n- Javadoc: [`never()`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#never())\n- Javadoc: [`error(Callable)`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.util.concurrent.Callable))\n- Javadoc: [`error(Throwable)`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.lang.Throwable))\n\n### RxJS `empty never throw`\n\nRxJS implements these operators as `empty`, `never`, and `throw`.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.empty();\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nCompleted\n```\n\n``` javascript\n// This will never produce a value, hence never calling any of the callbacks\nvar source = Rx.Observable.never();\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nvar source = Rx.Observable.return(42)\n    .selectMany(Rx.Observable.throw(new Error('error!')));\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nError: Error: error!\n```\n\n`empty` is found in the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n`never` is found in the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n`throw` is found in the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `empty never error`\n\nRxPHP implements this operator as `empty`.\n\nReturns an empty observable sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/empty/empty.php\n\n$observable = \\Rx\\Observable::empty();\n$observable->subscribe($stdoutObserver);\n```\n\n``` javascript\nComplete!\n```\n\nRxPHP also has an operator `never`.\n\nReturns a non-terminating observable sequence, which can be used to denote an infinite duration.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/never/never.php\n\n$observable = \\Rx\\Observable::never();\n$observable->subscribe($stdoutObserver);\n```\n\nRxPHP also has an operator `error`.\n\nReturns an observable sequence that terminates with an exception.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/error-observable/error-observable.php\n\n$observable = Rx\\Observable::error(new Exception('Oops!'));\n$observable->subscribe($stdoutObserver);\n```\n\n``` javascript\nException: Oops!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/empty-never-throw.html](http://reactivex.io/documentation/operators/empty-never-throw.html)"
- name: Filter
  id: documentation/operators/filter
  summary: The Filter operator filters an Observable by only allowing items through that pass a test that you specify in the form of a predicate function
  description: "# Filter\n\nemit only those items from an Observable that pass a predicate test\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#filter)\n\nThe Filter operator filters an Observable by only allowing items through that pass a test that you specify in the form of a predicate function.\n\n#### See Also\n\n- [Introduction to Rx: Where](http://www.introtorx.com/Content/v1.0.10621.0/05_Filtering.html#Where)\n- [Introduction to Rx: Cast and OfType](http://www.introtorx.com/Content/v1.0.10621.0/08_Transformation.html#CastAndOfType)\n- [RxMarbles: `filter`](http://rxmarbles.com/#filter)\n\n## Language-Specific Information\n\n### RxGroovy `filter ofType`\n\nRxGroovy implements this operator as `filter`. You can filter an Observable, discarding any items that do not meet some test, by passing a filtering function into the `filter` operator. For example, the following code filters a list of integers, emitting only those that are even (that is, where the remainder from dividing the number by two is zero):\n\n#### Sample Code\n\n``` groovy\nnumbers = Observable.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\nnumbers.filter({ 0 == (it % 2) }).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n2\n4\n6\n8\nSequence complete\n```\n\n`filter` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`filter(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#filter(rx.functions.Func1))\n\nThere is also a specialized form of the Filter operator in RxGroovy that filters an Observable so that it only emits items of a particular class.\n\n`ofType` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`ofType(Class)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#ofType(java.lang.Class))\n\n### RxJava 1․x `filter ofType`\n\nRxJava implements this operator as `filter`.\n\n#### Sample Code\n\n``` java\nObservable.just(1, 2, 3, 4, 5)\n          .filter(new Func1<Integer, Boolean>() {\n              @Override\n              public Boolean call(Integer item) {\n                return( item < 4 );\n              }\n          }).subscribe(new Subscriber<Integer>() {\n        @Override\n        public void onNext(Integer item) {\n            System.out.println(\"Next: \" + item);\n        }\n\n        @Override\n        public void onError(Throwable error) {\n            System.err.println(\"Error: \" + error.getMessage());\n        }\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"Sequence complete.\");\n        }\n    });\n```\n\n``` javascript\nNext: 1\nNext: 2\nNext: 3\nSequence complete.\n```\n\n`filter` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`filter(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#filter(rx.functions.Func1))\n\nThere is also a specialized form of the Filter operator in RxJava that filters an Observable so that it only emits items of a particular class.\n\n`ofType` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`ofType(Class)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#ofType(java.lang.Class))\n\n### RxJS `filter where`\n\nRxJS implements this operator under two names, but with identical behavior: `filter` and `where`. This operator takes two parameters: the predicate function, and an optional object that will represent that function’s “`this`” context when it executes.\n\nThe predicate function itself takes three arguments:\n\n1.  the item from the source Observable to be, or not be, filtered\n2.  the zero-based index of this item in the source Observable’s sequence\n3.  the source Observable object\n\nWrite the predicate function so that it returns `true` for those items you want to pass through the filter to the next observer, and `false` for those items you want the filter to block and suppress.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 5)\n  .filter(function (x, idx, obs) {\n    return x % 2 === 0;\n  });\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 2\nNext: 4\nCompleted\n```\n\n`filter` and `where` are found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `filter where`\n\nRxPHP implements this operator as `filter`.\n\nEmit only those items from an Observable that pass a predicate test.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/filter/filter.php\n\n$observable = Rx\\Observable::fromArray([21, 42, 84]);\n$observable\n    ->filter(function ($elem) {\n        return $elem >= 42;\n    })\n    ->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 42\nNext value: 84\nComplete!\n```\n\nRxPHP also has an operator `where`.\n\nAlias for filter\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/filter.html](http://reactivex.io/documentation/operators/filter.html)"
- name: First
  id: documentation/operators/first
  summary: If you are only interested in the first item emitted by an Observable, or the first item that meets some criteria, you can filter the Observable with the First operator
  description: "# First\n\nemit only the first item (or the first item that meets some condition) emitted by an Observable\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#first)\n\nIf you are only interested in the first item emitted by an Observable, or the first item that meets some criteria, you can filter the Observable with the First operator.\n\nIn some implementations, `First` is not implemented as a filtering operator that returns an Observable, but as a blocking function that returns a particular item at such time as the source Observable emits that item. In those implementations, if you instead want a filtering operator, you may have better luck with [`Take(1)`](take) or [`ElementAt(0)`](elementat).\n\nIn some implementations there is also a Single operator. It behaves similarly to First except that it waits until the source Observable terminates in order to guarantee that it only emits a single item (otherwise, rather than emitting that item, it terminates with an error). You can use this to not only take the first item from the source Observable but to also guarantee that there was only one item.\n\n#### See Also\n\n- [ElementAt](elementat)\n- [Last](last)\n- [Take](take)\n- [Introduction to Rx: First](http://www.introtorx.com/Content/v1.0.10621.0/07_Aggregation.html#First)\n- [Introduction to Rx: Single](http://www.introtorx.com/Content/v1.0.10621.0/07_Aggregation.html#Single)\n- [Loading data from multiple sources with RxJava](http://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/) by Dan Lew (example using Concat and First)\n- [RxMarbles: `find`](http://rxmarbles.com/#find)\n- [RxMarbles: `findIndex`](http://rxmarbles.com/#findIndex)\n- [RxMarbles: `first`](http://rxmarbles.com/#first)\n\n## Language-Specific Information\n\n### RxGroovy `first firstOrDefault latest mostRecent next single singleOrDefault takeFirst`\n\nIn RxGroovy, this filtering operator is implemented as `first`, `firstOrDefault`, and `takeFirst`.\n\nSomewhat confusingly, there are also `BlockingObservable` operators called `first` and `firstOrDefault` that block and then return items, rather than immediately returning Observables.\n\nThere are also several other operators that perform similar functions.\n\n### The Filtering Operators\n\nTo filter an Observable so that only its first emission is emitted, use the `first` operator with no parameters.\n\n- Javadoc: [`first()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#first())\n\nYou can also pass a predicate function to `first`, in which case it will produce an Observable that emits only the first item from the source Observable that the predicate evaluates as `true`.\n\n- Javadoc: [`first(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#first(rx.functions.Func1))\n\nThe `firstOrDefault` operator is similar to `first`, but you pass it a default item that it can emit if the source Observable fails to emit any items\n\n- Javadoc: [`firstOrDefault(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#firstOrDefault(T))\n\n`firstOrDefault` also has a variant to which you can pass a predicate function, so that its Observable will emit the first item from the source Observable that the predicate evaluates as `true`, or the default item if no items emitted by the source Observable pass the predicate.\n\n- Javadoc: [`firstOrDefault(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#firstOrDefault(T))\n\nThe `takeFirst` operator behaves similarly to `first`, with the exception of how these operators behave wihen the source Observable emits no items that satisfy the predicate. In such a case, `first` will throw a `NoSuchElementException` while `takeFirst` will return an empty Observable (one that calls `onCompleted` but never calls `onNext`).\n\n- Javadoc: [`takeFirst(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeFirst(rx.functions.Func1))\n\nThe `single` operator is similar to `first`, but throws a `NoSuchElementException` if the source Observable does not emit exactly one item before successfully completing.\n\n- Javadoc: [`single()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#single())\n\n`single` also has a version that accepts a predicate, and emits the sole item emitted by the source Observable that matches that predicate, or notifies of an exception if exactly one such item does not match.\n\n- Javadoc: [`single(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#single(rx.functions.Func1))\n\nAs with `firstOrDefault` there is also a `singleOrDefault` that emits a default item if the source Observable is empty, although it will still notify of an error if the source Observable emits more than one item.\n\n- Javadoc: [`singleOrDefault(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#singleOrDefault(T))\n\nAnd there is also a verion of `singleOrDefault` that takes a predicate function and emits the sole item from the source Observable that matches that predicate, if any; the default item if no such items match; and makes an error notification if multiple items match.\n\n- Javadoc: [`singleOrDefault(Func1,T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#singleOrDefault(rx.functions.Func1,%20T))\n\n`first`, `firstOrDefault`, `single`, `singleOrDefault`, and `takeFirst` do not by default operate on any particular [Scheduler](../scheduler).\n\n### The `BlockingObservable` Methods\n\nThe `BlockingObservable` methods do not transform an Observable into another, filtered Observable, but rather they break out of the Observable cascade, blocking until the Observable emits the desired item, and then return that item itself.\n\nTo turn an Observable into a `BlockingObservable` so that you can use these methods, you can use either the `Observable.toBlocking` or `BlockingObservable.from` methods.\n\n- Javadoc: [`Observable.toBlocking()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toBlocking())\n- Javadoc: [`BlockingObservable.from(Observable)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#from(rx.Observable))\n\nTo retrieve the first emission from a `BlockingObservable`, use the `first` method with no parameters.\n\n- Javadoc: [`BlockingObservable.first()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#first())\n\nYou can also pass a predicate function to the `first` method to retrieve the first emission from a `BlockingObservable` that satisfies the predicate.\n\n- Javadoc: [`BlockingObservable.first(Func1)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#first(rx.functions.Func1))\n\nAs with the filtering operators, the `first` method of `BlockingObservable` will throw a `NoSuchElementException` if there is no first element in the source `BlockingObservable`. To return a default item instead in such cases, use the `firstOrDefault` method.\n\n- Javadoc: [`BlockingObservable.firstOrDefault()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#firstOrDefault(T))\n\nAnd, as with `first`, there is a `firstOrDefault` variant that takes a predicate function as an argument and returns the first item from the source `BlockingObservable` that satisfies that predicate, or a default item instead if no satisfying item was emitted.\n\n- Javadoc: [`BlockingObservable.firstOrDefault(Func1)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#firstOrDefault(T,%20rx.functions.Func1))\n\nThe `single` operator is similar to `first`, but throws a `NoSuchElementException` if the source Observable does not emit exactly one item before successfully completing.\n\n- Javadoc: [`single()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#single())\n\n`single` also has a version that accepts a predicate, and returns the sole item emitted by the source Observable that matches that predicate, or throws an exception if exactly one such item does not match.\n\n- Javadoc: [`single(Func1)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#single(rx.functions.Func1))\n\nAs with `firstOrDefault` there is also a `singleOrDefault` that returns a default item if the source Observable is empty, although it will still throw an error if the source Observable emits more than one item.\n\n- Javadoc: [`singleOrDefault(T)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#singleOrDefault(T))\n\nAnd there is also a verion of `singleOrDefault` that takes a predicate function and returns the sole item from the source Observable that matches that predicate, if any; the default item if no such items match; and throws an error if multiple items match.\n\n- Javadoc: [`singleOrDefault(Func1,T)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#singleOrDefault(rx.functions.Func1,%20T))\n\nThe `next` operator blocks until the `BlockingObservable` emits another item, and then returns that item. You can call this function repeatedly to get successive items from the `BlockingObservable`, effectively iterating over its emissions in a blocking fashion.\n\nThe `latest` operator is similar, but rather than blocking to wait for the next emitted item, it immediately returns the most-recently-emitted item, and only blocks if the Observable has not yet emitted anything.\n\n- Javadoc: [`next()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#next())\n- Javadoc: [`latest()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#latest())\n\nThe `mostRecent` operator similarly allows you to iterate over the emissions of a `BlockingObservable`, but its Iterable always immediately returns a value: either a default item you provide (if the `BlockingObservable` has not yet emitted an item), or the latest item the `BlockingObservable` has emitted.\n\n- Javadoc: [`mostRecent(T)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#mostRecent(T))\n\n### RxJava 1․x `first firstOrDefault latest mostRecent next single singleOrDefault takeFirst`\n\nIn RxJava, this filtering operator is implemented as `first`, `firstOrDefault`, and `takeFirst`.\n\nSomewhat confusingly, there are also `BlockingObservable` operators called `first` and `firstOrDefault` that block and then return items, rather than immediately returning Observables.\n\nThere are also several other operators that perform similar functions.\n\n### The Filtering Operators\n\nTo filter an Observable so that only its first emission is emitted, use the `first` operator with no parameters.\n\n#### Sample Code\n\n``` java\nObservable.just(1, 2, 3)\n          .first()\n          .subscribe(new Subscriber<Integer>() {\n        @Override\n        public void onNext(Integer item) {\n            System.out.println(\"Next: \" + item);\n        }\n\n        @Override\n        public void onError(Throwable error) {\n            System.err.println(\"Error: \" + error.getMessage());\n        }\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"Sequence complete.\");\n        }\n    });\n```\n\n``` javascript\nNext: 1\nSequence complete.\n```\n\n- Javadoc: [`first()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#first())\n\nYou can also pass a predicate function to `first`, in which case it will produce an Observable that emits only the first item from the source Observable that the predicate evaluates as `true`.\n\n- Javadoc: [`first(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#first(rx.functions.Func1))\n\nThe `firstOrDefault` operator is similar to `first`, but you pass it a default item that it can emit if the source Observable fails to emit any items\n\n- Javadoc: [`firstOrDefault(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#firstOrDefault(T))\n\n`firstOrDefault` also has a variant to which you can pass a predicate function, so that its Observable will emit the first item from the source Observable that the predicate evaluates as `true`, or the default item if no items emitted by the source Observable pass the predicate.\n\n- Javadoc: [`firstOrDefault(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#firstOrDefault(T))\n\nThe `takeFirst` operator behaves similarly to `first`, with the exception of how these operators behave wihen the source Observable emits no items that satisfy the predicate. In such a case, `first` will throw a `NoSuchElementException` while `takeFirst` will return an empty Observable (one that calls `onCompleted` but never calls `onNext`).\n\n- Javadoc: [`takeFirst(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeFirst(rx.functions.Func1))\n\nThe `single` operator is similar to `first`, but throws a `NoSuchElementException` if the source Observable does not emit exactly one item before successfully completing.\n\n- Javadoc: [`single()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#single())\n\n`single` also has a version that accepts a predicate, and emits the sole item emitted by the source Observable that matches that predicate, or notifies of an exception if exactly one such item does not match.\n\n- Javadoc: [`single(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#single(rx.functions.Func1))\n\nAs with `firstOrDefault` there is also a `singleOrDefault` that emits a default item if the source Observable is empty, although it will still notify of an error if the source Observable emits more than one item.\n\n- Javadoc: [`singleOrDefault(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#singleOrDefault(T))\n\nAnd there is also a verion of `singleOrDefault` that takes a predicate function and emits the sole item from the source Observable that matches that predicate, if any; the default item if no such items match; and makes an error notification if multiple items match.\n\n- Javadoc: [`singleOrDefault(Func1,T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#singleOrDefault(rx.functions.Func1,%20T))\n\n`first`, `firstOrDefault`, `single`, `singleOrDefault`, and `takeFirst` do not by default operate on any particular [Scheduler](../scheduler).\n\n### The `BlockingObservable` Methods\n\nThe `BlockingObservable` methods do not transform an Observable into another, filtered Observable, but rather they break out of the Observable cascade, blocking until the Observable emits the desired item, and then return that item itself.\n\nTo turn an Observable into a `BlockingObservable` so that you can use these methods, you can use either the `Observable.toBlocking` or `BlockingObservable.from` methods.\n\n- Javadoc: [`Observable.toBlocking()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toBlocking())\n- Javadoc: [`BlockingObservable.from(Observable)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#from(rx.Observable))\n\nTo retrieve the first emission from a `BlockingObservable`, use the `first` method with no parameters.\n\n- Javadoc: [`BlockingObservable.first()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#first())\n\nYou can also pass a predicate function to the `first` method to retrieve the first emission from a `BlockingObservable` that satisfies the predicate.\n\n- Javadoc: [`BlockingObservable.first(Func1)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#first(rx.functions.Func1))\n\nAs with the filtering operators, the `first` method of `BlockingObservable` will throw a `NoSuchElementException` if there is no first element in the source `BlockingObservable`. To return a default item instead in such cases, use the `firstOrDefault` method.\n\n- Javadoc: [`BlockingObservable.firstOrDefault()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#firstOrDefault(T))\n\nAnd, as with `first`, there is a `firstOrDefault` variant that takes a predicate function as an argument and retrieves the first item from the source `BlockingObservable` that satisfies that predicate, or a default item instead if no satisfying item was emitted.\n\n- Javadoc: [`BlockingObservable.firstOrDefault(Func1)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#firstOrDefault(T,%20rx.functions.Func1))\n\nThe `single` operator is similar to `first`, but throws a `NoSuchElementException` if the source Observable does not emit exactly one item before successfully completing.\n\n- Javadoc: [`single()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#single())\n\n`single` also has a version that accepts a predicate, and returns the sole item emitted by the source Observable that matches that predicate, or throws an exception if exactly one such item does not match.\n\n- Javadoc: [`single(Func1)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#single(rx.functions.Func1))\n\nAs with `firstOrDefault` there is also a `singleOrDefault` that returns a default item if the source Observable is empty, although it will still throw an error if the source Observable emits more than one item.\n\n- Javadoc: [`singleOrDefault(T)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#singleOrDefault(T))\n\nAnd there is also a verion of `singleOrDefault` that takes a predicate function and returns the sole item from the source Observable that matches that predicate, if any; the default item if no such items match; and throws an error if multiple items match.\n\n- Javadoc: [`singleOrDefault(Func1,T)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#singleOrDefault(rx.functions.Func1,%20T))\n\nThe `next` operator blocks until the `BlockingObservable` emits another item, and then returns that item. You can call this function repeatedly to get successive items from the `BlockingObservable`, effectively iterating over its emissions in a blocking fashion.\n\nThe `latest` operator is similar, but rather than blocking to wait for the next emitted item, it immediately returns the most-recently-emitted item, and only blocks if the Observable has not yet emitted anything.\n\n- Javadoc: [`next()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#next())\n- Javadoc: [`latest()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#latest())\n\nThe `mostRecent` operator similarly allows you to iterate over the emissions of a `BlockingObservable`, but its Iterable always immediately returns a value: either a default item you provide (if the `BlockingObservable` has not yet emitted an item), or the latest item the `BlockingObservable` has emitted.\n\n- Javadoc: [`mostRecent(T)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#mostRecent(T))\n\n### RxJS `find findIndex first single`\n\nRxJS implements the `first` operator. It optionally takes a predicate function as a parameter, in which case, rather than emitting the first item from the source Observable, the resulting Observable will emit the first item from the source Observable that satisfies the predicate.\n\nThe predicate function itself takes three arguments:\n\n1.  the item from the source Observable to be, or not be, filtered\n2.  the zero-based index of this item in the source Observable’s sequence\n3.  the source Observable object\n\nAn optional third parameter (named `defaultValue`) allows you to choose an item that `first` will emit if the source Observable does not emit any items (or if it does not emit the *n*^(th) item that it expected.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 10)\n    .first(function (x, idx, obs) { return x % 2 === 1; });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 1\nCompleted\n```\n\nIf the source Observable emits no items (or no items that match the predicate), `first` will terminate with a “`Sequence contains no elements.`” `onError` notification.\n\nThe `single` operator is similar, except that it only emits its item once the source Observable successfully completes after emitting one item (or one item that matches the predicate). If it emits either no such items or more than one such item, `single` will terminate with an `onError` notitifcation (“`Sequence contains no elements.`”).\n\nThe `find` operator is much like `first` except that the predicate argument is mandatory, and it behaves differently if no item from the source Observable matches the predicate. While `first` will send an `onError` notification in such a case, `find` will instead emit an `undefined` item.\n\n#### Sample Code\n\n``` javascript\nvar array = [1,2,3,4];\n\nvar source = Rx.Observable.fromArray(array)\n    .find(function (x, i, obs) {\n        return x === 5;\n    });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: undefined\nCompleted\n```\n\nThe `findIndex` operator is similar to `find`, except that instead of emitting the item that matches the predicate (or `undefined`), it emits the zero-based index of that item in the source Observable’s sequence (or `-1`).\n\n#### Sample Code\n\n``` javascript\nvar array = [1,2,3,4];\n\nvar source = Rx.Observable.fromArray(array)\n    .findIndex(function (x, i, obs) {\n        return x === 5;\n    });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: -1\nCompleted\n```\n\n`find`, `findIndex`, and `first` are found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\nThey each require one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/first.html](http://reactivex.io/documentation/operators/first.html)"
- name: FlatMap
  id: documentation/operators/flatmap
  summary: The FlatMap operator transforms an Observable by applying a function that you specify to each item emitted by the source Observable, where that function returns an Observable that itself emits items
  description: "# FlatMap\n\ntransform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable\n\nThe FlatMap operator transforms an Observable by applying a function that you specify to each item emitted by the source Observable, where that function returns an Observable that itself emits items. FlatMap then merges the emissions of these resulting Observables, emitting these merged results as its own sequence.\n\nThis method is useful, for example, when you have an Observable that emits a series of items that themselves have Observable members or are in other ways transformable into Observables, so that you can create a new Observable that emits the complete collection of items emitted by the sub-Observables of these items.\n\nNote that FlatMap *merges* the emissions of these Observables, so that they may interleave.\n\nIn several of the language-specific implementations there is also an operator that does *not* interleave the emissions from the transformed Observables, but instead emits these emissions in strict order, often called ConcatMap or something similar.\n\n#### See Also\n\n- [Map](map)\n- [Grokking RxJava: Operator, Operator](http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/) by Dan Lew\n- [Introduction to Rx: SelectMany](http://www.introtorx.com/Content/v1.0.10621.0/08_Transformation.html#SelectMany)\n- [Recursive Observables with RxJava](http://jschneider.io/2014/11/26/Recursive-Observables-with-Rx-Java.html) by Jon Schneider\n- [RxJava Observable transformation: concatMap() vs. flatMap()](http://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/) by Fernando Cejas\n\n## Language-Specific Information\n\n### RxGroovy `concatMap flatMap flatMapIterable StringObservable.split switchMap`\n\nRxGroovy implements the `flatMap` operator.\n\n#### Sample Code\n\n``` groovy\n// this closure is an Observable that emits three numbers\nnumbers   = Observable.from([1, 2, 3]);\n// this closure is an Observable that emits two numbers based on what number it is passed\nmultiples = { n -> Observable.from([ n*2, n*3 ]) };\n\nnumbers.flatMap(multiples).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n2\n3\n4\n6\n6\n9\nSequence complete\n```\n\nNote that if any of the individual Observables mapped to the items from the source Observable by `flatMap` aborts by invoking `onError`, the Observable produced by `flatMap` will itself immediately abort and invoke `onError`.\n\nA version of this variant of the operator (still in Beta as of this writing) takes an additional `int` parameter. This parameter sets the maximum number of concurrent subscriptions that `flatMap` will attempt to have to the Observables that the items emitted by the source Observable map to. When it reaches this maximum number, it will wait for one of those Observables to terminate before subscribing to another.\n\n- Javadoc: [`flatMap(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1))\n- Javadoc: [`flatMap(Func1,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20int))\n\nAnother version of `flatMap` creates (and flattens) a new Observable for each item *and notification* from the source Observable.\n\nA version of this variant of the operator (still in Beta as of this writing) takes an additional `int` parameter. This parameter sets the maximum number of concurrent subscriptions that `flatMap` will attempt to have to the Observables that the items emitted by the source Observable map to. When it reaches this maximum number, it will wait for one of those Observables to terminate before subscribing to another.\n\n- Javadoc: [`flatMap(Func1,Func1,Func0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0))\n- Javadoc: [`flatMap(Func1,Func1,Func0,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0,%20int))\n\nAnother version combines items from the source Observable with the Observable triggered by those source items, and emits these combinations.\n\nA version of this variant of the operator (still in Beta as of this writing) takes an additional `int` parameter. This parameter sets the maximum number of concurrent subscriptions that `flatMap` will attempt to have to the Observables that the items emitted by the source Observable map to. When it reaches this maximum number, it will wait for one of those Observables to terminate before subscribing to another.\n\n- Javadoc: [`flatMap(Func1,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func2))\n- Javadoc: [`flatMap(Func1,Func2,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func2,%20int))\n\nThe `flatMapIterable` variants pair up source items and generated `Iterable`s rather than source items and generated Observables, but otherwise work in much the same way.\n\n- Javadoc: [`flatMapIterable(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMapIterable(rx.functions.Func1))\n- Javadoc: [`flatMapIterable(Func1,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMapIterable(rx.functions.Func1,%20rx.functions.Func2))\n\nThere is also a `concatMap` operator, which is like the simpler version of the `flatMap` operator, but it concatenates rather than merges the resulting Observables in order to generate its own sequence.\n\n- Javadoc: [`concatMap(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMap(rx.functions.Func1))\n\nRxGroovy also implements the `switchMap` operator. It behaves much like `flatMap`, except that whenever a new item is emitted by the source Observable, it will unsubscribe to and stop mirroring the Observable that was generated from the previously-emitted item, and begin only mirroring the current one.\n\n- Javadoc: [`switchMap(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#switchMap(rx.functions.Func1))\n\nIn the distinct `StringObservable` class (not part of RxGroovy by default) there is also a `split` operator that converts an Observable of Strings into an Observable of Strings that treats the source sequence as a stream and splits it on a specified regex boundary, then merges the results of this split.\n\n#### See Also\n\n- [Aligning packets with JSON documents](http://www.nurkiewicz.com/2014/12/accessing-meetups-streaming-api-with.html) with the `split` operator\n\n### RxJava 1․x `concatMap flatMap flatMapIterable StringObervable.split switchMap`\n\nRxJava implements the `flatMap` operator.\n\nNote that if any of the individual Observables mapped to the items from the source Observable by `flatMap` aborts by invoking `onError`, the Observable produced by `flatMap` will itself immediately abort and invoke `onError`.\n\nA version of this variant of the operator (still in Beta as of this writing) takes an additional `int` parameter. This parameter sets the maximum number of concurrent subscriptions that `flatMap` will attempt to have to the Observables that the items emitted by the source Observable map to. When it reaches this maximum number, it will wait for one of those Observables to terminate before subscribing to another.\n\n- Javadoc: [`flatMap(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1))\n- Javadoc: [`flatMap(Func1,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20int))\n\nAnother version of `flatMap` creates (and flattens) a new Observable for each item *and notification* from the source Observable.\n\nA version of this variant of the operator (still in Beta as of this writing) takes an additional `int` parameter. This parameter sets the maximum number of concurrent subscriptions that `flatMap` will attempt to have to the Observables that the items emitted by the source Observable map to. When it reaches this maximum number, it will wait for one of those Observables to terminate before subscribing to another.\n\n- Javadoc: [`flatMap(Func1,Func1,Func0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0))\n- Javadoc: [`flatMap(Func1,Func1,Func0,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0,%20int))\n\nAnother version combines items from the source Observable with the Observable triggered by those source items, and emits these combinations.\n\nA version of this variant of the operator (still in Beta as of this writing) takes an additional `int` parameter. This parameter sets the maximum number of concurrent subscriptions that `flatMap` will attempt to have to the Observables that the items emitted by the source Observable map to. When it reaches this maximum number, it will wait for one of those Observables to terminate before subscribing to another.\n\n- Javadoc: [`flatMap(Func1,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func2))\n- Javadoc: [`flatMap(Func1,Func2,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1,%20rx.functions.Func2,%20int))\n\nThe `flatMapIterable` variants pair up source items and generated `Iterable`s rather than source items and generated Observables, but otherwise work in much the same way.\n\n- Javadoc: [`flatMapIterable(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMapIterable(rx.functions.Func1))\n- Javadoc: [`flatMapIterable(Func1,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMapIterable(rx.functions.Func1,%20rx.functions.Func2))\n\nThere is also a `concatMap` operator, which is like the simpler version of the `flatMap` operator, but it concatenates rather than merges the resulting Observables in order to generate its own sequence.\n\n- Javadoc: [`concatMap(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMap(rx.functions.Func1))\n\nRxJava also implements the `switchMap` operator. It behaves much like `flatMap`, except that whenever a new item is emitted by the source Observable, it will unsubscribe to and stop mirroring the Observable that was generated from the previously-emitted item, and begin only mirroring the current one.\n\n- Javadoc: [`switchMap(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#switchMap(rx.functions.Func1))\n\nIn the distinct `StringObservable` class (not part of RxJava by default) there is also a `split` operator that converts an Observable of Strings into an Observable of Strings that treats the source sequence as a stream and splits it on a specified regex boundary, then merges the results of this split.\n\n### RxJS `concatMap concatMapObserver flatMap flatMapFirst flatMapLatest flatMapObserver flatMapWithMaxConcurrency for forIn manySelect selectConcat selectConcatObserver selectMany selectManyObserver selectSwitch selectSwitchFirst selectWithMatchConcurrent switchMap`\n\nRxJS has a wealth of operators that perform FlatMap-like operations. In RxJS, the functions that transform items emitted by the source Observable into Observables typically take as parameters both the item and the index of the item in the Observable sequence.\n\nRxJS implements the basic `flatMap` operator. It has a variant that allows you to apply a transformative function (an optional second parameter to `flatMap`) to the items emitted by the Observables generated for each item in the source Observable, before merging and emitting those items.\n\n`flatMap` works just as well if the function you provide transforms items from the source Observables into Observables, into Promises, or into arrays.\n\n“`selectMany`” is an alias for `flatMap`.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable\n    .range(1, 2)\n    .selectMany(function (x) {\n        return Rx.Observable.range(x, 2);\n    });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 1\nNext: 2\nNext: 2\nNext: 3\nCompleted\n```\n\n``` javascript\n// Using a promise\nvar source = Rx.Observable.of(1,2,3,4)\n    .selectMany(function (x, i) {\n        return Promise.resolve(x + i);\n    });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 1\nNext: 3\nNext: 5\nNext: 7\nCompleted\n```\n\n``` javascript\n// Using an array\nRx.Observable.of(1,2,3)\n  .flatMap(\n    function (x, i) { return [x,i]; },\n    function (x, y, ix, iy) { return x + y + ix + iy; }\n  );\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 2\nNext: 2\nNext: 5\nNext: 5\nNext: 8\nNext: 8\nCompleted\n```\n\n`flatMap` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThe `flatMapLatest` operator behaves much like the standard FlatMap operator, except that whenever a new item is emitted by the source Observable, it will unsubscribe to and stop mirroring the Observable that was generated from the previously-emitted item, and begin only mirroring the current one.\n\n“`selectSwitch`” is an alias for `flatMapLatest`.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable\n    .range(1, 2)\n    .flatMapLatest(function (x) {\n        return Rx.Observable.range(x, 2);\n    });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 1\nNext: 2\nNext: 3\nCompleted\n```\n\n`flatMapLatest` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n`flatMapObserver` creates (and flattens) a new Observable for each item *and notification* from the source Observable. It accepts a different transformation function to respond to `onNext`, `onError`, and `onCompleted` notifications and to return an Observable for each.\n\n“`selectManyObserver`” is an alias for `flatMapObserver`.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(1, 3)\n    .flatMapObserver(\n        function (x, i) {\n            return Rx.Observable.repeat(x, i);\n        },\n        function (err) {\n            return Rx.Observable.return(42);\n        },\n        function () {\n            return Rx.Observable.empty();\n        });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 2\nNext: 3\nNext: 3\nCompleted\n```\n\n`flatMapObserver` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n\nThere is also a `concatMap` operator, which is like the `flatMap` operator, but it concatenates rather than merges the resulting Observables in order to generate its own sequence.\n\nAs with `flatMap`, `concatMap` works just as well if the function you provide transforms items from the source Observables into Observables, into Promises, or into arrays.\n\n“`selectConcat`” is an alias for `concatMap`.\n\n`concatMap` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThe `for` operator (and its alias, `forIn`) is very similar to `concatMap`, though it has a converse flexibility. While `concatMap` operates on an Observable source and can use Observable, Promise, or array intermediaries to generate its output sequence; `for` always uses Observables as its intermediaries, but can operate on a source that is either an Observable, a Promise, or an array.\n\n`concatMap` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.experimental.js` (requires either `rx.js`, `rx.compat.js`, `rx.lite.js`, or `rx.lite.compat.js`)\n\nThere is also a `concatMapObserver` operator, which is like the `flatMapObserver` operator, in that it creates Observables to merge from both the emissions and terminal notifications of the source Observable, but it concatenates rather than merges these resulting Observables in order to generate its own sequence.\n\n“`selectConcatObserver`” is an alias for `concatMapObserver`.\n\n`concatMapObserver` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n\nThe `manySelect` operator is often described as a “comonadic bind.” If that clears things up for you, you’re welcome. Elsewise, here’s an explanation:\n\n`manySelect` internally transforms each item emitted by the source Observable into an Observable that emits that item and all items subsequently emitted by the source Observable, in the same order. So, for example, it internally transforms an Observable that emits the numbers 1,2,3 into three Observables: one that emits 1,2,3, one that emits 2,3, and one that emits 3.\n\nThen `manySelect` passes each of these Observables into a function that you provide, and emits, as the emissions from the Observable that `manySelect` returns, the return values from those function calls.\n\nIn this way, each item emitted by the resulting Observable is a function of the corresponding item in the source Observable and all of the items emitted by the source Observable after it.\n\n`manySelect` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.experimental.js`\n\n`manySelect` requires one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n#### See Also\n\n- [Microsoft Developer Network: “What does the new ManySelect operator do?”](https://social.msdn.microsoft.com/Forums/en-US/e70fe8b6-6d9d-486a-a8d0-c1bc66551ded/what-does-the-new-manyselect-operator-do?forum=rx)\n\n### RxPHP `flatMap flatMapTo selectMany flatMapLatest concatMap concatMapTo`\n\nRxPHP implements this operator as `flatMap`.\n\nProjects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/flatMap/flatMap.php\n\n$observable = Rx\\Observable::range(1, 2);\n\n$selectManyObservable = $observable->flatMap(function ($value) {\n    return Rx\\Observable::range($value, 2);\n});\n\n$selectManyObservable->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 1\nNext value: 2\nNext value: 2\nNext value: 3\nComplete!\n```\n\nRxPHP also has an operator `flatMapTo`.\n\nProjects each element of the source observable sequence to the other observable sequence and merges the resulting observable sequences into one observable sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/concat/concatMapTo.php\n\n$obs = \\Rx\\Observable::interval(100)\n    ->take(3)\n    ->mapWithIndex(function ($i) {\n        return $i;\n    });\n\n$source = Rx\\Observable::range(0, 5)\n    ->concatMapTo($obs);\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 0\nNext value: 1\nNext value: 2\nNext value: 3\nNext value: 4\nNext value: 5\nNext value: 6\nNext value: 7\nNext value: 8\nNext value: 9\nNext value: 10\nNext value: 11\nNext value: 12\nNext value: 13\nNext value: 14\nComplete!\n```\n\nRxPHP also has an operator `selectMany`.\n\nAlias for flatMap\n\nRxPHP also has an operator `flatMapLatest`.\n\nBypasses a specified number of elements in an observable sequence and then returns the remaining elements. Transform the items emitted by an Observable into Observables, and mirror those items emitted by the most-recently transformed Observable. The flatMapLatest operator is similar to the flatMap and concatMap methods described above, however, rather than emitting all of the items emitted by all of the Observables that the operator generates by transforming items from the source Observable, flatMapLatest instead emits items from each such transformed Observable only until the next such Observable is emitted, then it ignores the previous one and begins emitting items emitted by the new one.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/flatMap/flatMapLatest.php\n\n$source = \\Rx\\Observable::range(1, 3)\n    ->flatMapLatest(function ($x) {\n        return \\Rx\\Observable::fromArray([$x . 'a', $x . 'b']);\n    });\n\n$source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 1a\nNext value: 2a\nNext value: 3a\nNext value: 3b\nComplete!\n```\n\nRxPHP also has an operator `concatMap`.\n\nProjects each element of an observable sequence to an observable sequence and concatenates the resulting observable sequences into one observable sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/concat/concatMap.php\n\n$source = Rx\\Observable::range(0, 5)\n    ->concatMap(function ($x, $i) {\n        return \\Rx\\Observable::interval(100)\n            ->take($x)\n            ->map(function () use ($i) {\n                return $i;\n            });\n    });\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 1\nNext value: 2\nNext value: 2\nNext value: 3\nNext value: 3\nNext value: 3\nNext value: 4\nNext value: 4\nNext value: 4\nNext value: 4\nComplete!\n```\n\nRxPHP also has an operator `concatMapTo`.\n\nProjects each element of the source observable sequence to the other observable sequence and merges the resulting observable sequences into one observable sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/concat/concatMapTo.php\n\n$obs = \\Rx\\Observable::interval(100)\n    ->take(3)\n    ->mapWithIndex(function ($i) {\n        return $i;\n    });\n\n$source = Rx\\Observable::range(0, 5)\n    ->concatMapTo($obs);\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 0\nNext value: 1\nNext value: 2\nNext value: 3\nNext value: 4\nNext value: 5\nNext value: 6\nNext value: 7\nNext value: 8\nNext value: 9\nNext value: 10\nNext value: 11\nNext value: 12\nNext value: 13\nNext value: 14\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/flatmap.html](http://reactivex.io/documentation/operators/flatmap.html)"
- name: From
  id: documentation/operators/from
  summary: When you work with Observables, it can be more convenient if all of the data you mean to work with can be represented as Observables, rather than as a mixture of Observables and other types
  description: "# From\n\nconvert various other objects and data types into Observables\n\nWhen you work with Observables, it can be more convenient if all of the data you mean to work with can be represented as Observables, rather than as a mixture of Observables and other types. This allows you to use a single set of operators to govern the entire lifespan of the data stream.\n\nIterables, for example, can be thought of as a sort of synchronous Observable; Futures, as a sort of Observable that always emits only a single item. By explicitly converting such objects to Observables, you allow them to interact as peers with other Observables.\n\nFor this reason, most ReactiveX implementations have methods that allow you to convert certain language-specific objects and data structures into Observables.\n\n## See Also\n\n- [Just](just)\n- [Start](start)\n- [101 Rx Samples: Observation Operators](http://rxwiki.wikidot.com/101samples#toc5)\n- [RxJava Tutorial 03: Observable from, just, & create methods](https://www.youtube.com/watch?v=sDqrlNprY24)\n\n## Language-Specific Information\n\n### RxGroovy `decode from fromAction fromCallable fromFunc0 fromRunnable runAsync`\n\nIn RxGroovy, the `from` operator can convert a Future, an Iterable, or an Array. In the case of an Iterable or an Array, the resulting Observable will emit each item contained in the Iterable or Array.\n\nIn the case of a Future, it will emit the single result of the `get` call. You may optionally pass the version of `from` that accepts a future two additional parameters indicating a timeout span and the units of time that span is denominated in. The resulting Observable will terminate with an error if that span of time passes before the Future responds with a value.\n\n`from` does not by default operate on any particular [Scheduler](../scheduler), however you can pass the variant that converts a Future a Scheduler as an optional second parameter, and it will use that Scheduler to govern the Future.\n\n- Javadoc: [`from(array)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(T%5B%5D))\n- Javadoc: [`from(Iterable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.lang.Iterable))\n- Javadoc: [`from(Future)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future))\n- Javadoc: [`from(Future,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future,%20rx.Scheduler))\n- Javadoc: [`from(Future,timout,timeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future,%20long,%20java.util.concurrent.TimeUnit))\n\nIn addition, in the `RxJavaAsyncUtil` package, you have available to you the following operators that convert actions, callables, functions, and runnables into Observables that emit the results of those things:\n\n- `fromAction`\n- `fromCallable`\n- `fromFunc0`\n- `fromRunnable`\n\nSee the [Start](start) operator for more information about those operators.\n\nNote that there is also a `from` operator that is a method of the optional `StringObservable` class. It converts a stream of characters or a `Reader` into an Observable that emits byte arrays or Strings.\n\nIn the separate `RxJavaAsyncUtil` package, which is not included by default with RxGroovy, there is also a `runAsync` function. Pass `runAsync` an `Action` and a [`Scheduler`](../scheduler), and it will return a `StoppableObservable` that uses the specified `Action` to generate items that it emits.\n\nThe `Action` accepts an `Observer` and a `Subscription`. It uses the `Subscription` to check for the `isUnsubscribed` condition, upon which it will stop emitting items. You can also manually stop a `StoppableObservable` at any time by calling its `unsubscribe` method (which will also unsubscribe the `Subscription` you have associated with the `StoppableObservable`).\n\nBecause `runAsync` immediately invokes the `Action` and begins emitting the items, it is possible that some items may be lost in the interval between when you establish the `StoppableObservable` with this method and when your `Observer` is ready to receive items. If this is a problem, you can use the variant of `runAsync` that also accepts a [`Subject`](../subject) and pass a `ReplaySubject` with which you can retrieve the otherwise-missing items.\n\nThe `StringObservable` class, which is not a default part of RxGroovy, also includes the `decode` operator which converts a stream of multibyte characters into an Observable that emits byte arrays that respect the character boundaries.\n\n### RxJava 1․x `decode from fromAction fromCallable fromFunc0 fromRunnable runAsync`\n\nIn RxJava, the `from` operator can convert a Future, an Iterable, or an Array. In the case of an Iterable or an Array, the resulting Observable will emit each item contained in the Iterable or Array.\n\n#### Sample Code\n\n``` java\nInteger[] items = { 0, 1, 2, 3, 4, 5 };\nObservable myObservable = Observable.from(items);\n\nmyObservable.subscribe(\n    new Action1<Integer>() {\n        @Override\n        public void call(Integer item) {\n            System.out.println(item);\n        }\n    },\n    new Action1<Throwable>() {\n        @Override\n        public void call(Throwable error) {\n            System.out.println(\"Error encountered: \" + error.getMessage());\n        }\n    },\n    new Action0() {\n        @Override\n        public void call() {\n            System.out.println(\"Sequence complete\");\n        }\n    }\n);\n```\n\n``` javascript\n0\n1\n2\n3\n4\n5\nSequence complete\n```\n\nIn the case of a Future, it will emit the single result of the `get` call. You may optionally pass the version of `from` that accepts a future two additional parameters indicating a timeout span and the units of time that span is denominated in. The resulting Observable will terminate with an error if that span of time passes before the Future responds with a value.\n\n`from` does not by default operate on any particular [Scheduler](../scheduler), however you can pass the variant that converts a Future a Scheduler as an optional second parameter, and it will use that Scheduler to govern the Future.\n\n- Javadoc: [`from(array)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(T%5B%5D))\n- Javadoc: [`from(Iterable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.lang.Iterable))\n- Javadoc: [`from(Future)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future))\n- Javadoc: [`from(Future,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future,%20rx.Scheduler))\n- Javadoc: [`from(Future,timout,timeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future,%20long,%20java.util.concurrent.TimeUnit))\n\nIn addition, in the `RxJavaAsyncUtil` package, you have available to you the following operators that convert actions, callables, functions, and runnables into Observables that emit the results of those things:\n\n- `fromAction`\n- `fromCallable`\n- `fromFunc0`\n- `fromRunnable`\n\nSee the [Start](start) operator for more information about those operators.\n\nNote that there is also a `from` operator that is a method of the optional `StringObservable` class. It converts a stream of characters or a `Reader` into an Observable that emits byte arrays or Strings.\n\nIn the separate `RxJavaAsyncUtil` package, which is not included by default with RxJava, there is also a `runAsync` function. Pass `runAsync` an `Action` and a [`Scheduler`](../scheduler), and it will return a `StoppableObservable` that uses the specified `Action` to generate items that it emits.\n\nThe `Action` accepts an `Observer` and a `Subscription`. It uses the `Subscription` to check for the `isUnsubscribed` condition, upon which it will stop emitting items. You can also manually stop a `StoppableObservable` at any time by calling its `unsubscribe` method (which will also unsubscribe the `Subscription` you have associated with the `StoppableObservable`).\n\nBecause `runAsync` immediately invokes the `Action` and begins emitting the items, it is possible that some items may be lost in the interval between when you establish the `StoppableObservable` with this method and when your `Observer` is ready to receive items. If this is a problem, you can use the variant of `runAsync` that also accepts a [`Subject`](../subject) and pass a `ReplaySubject` with which you can retrieve the otherwise-missing items.\n\nThe `StringObservable` class, which is not a default part of RxGroovy, also includes the `decode` operator which converts a stream of multibyte characters into an Observable that emits byte arrays that respect the character boundaries.\n\n### RxJS `from fromCallback fromEvent fromEventPattern fromNodeCallback fromPromise of ofArrayChanges ofObjectChanges ofWithScheduler pairs`\n\nThere are several, specialized From variants in RxJS:\n\nIn RxJS, the `from` operator converts an array-like or iterable object into an Observable that emits the items in that array or iterable. A String, in this context, is treated as an array of characters.\n\nThis operator also takes three additional, optional parameters:\n\n2.  a transforming function that takes an item from the array or iterable as input and produces an item to be emitted by the resulting Observable as output\n3.  a second argument to pass into the transforming function as additional context information\n4.  a [Scheduler](../scheduler) on which this operator should operate\n\n#### Sample Code\n\n``` javascript\n// Array-like object (arguments) to Observable\nfunction f() {\n  return Rx.Observable.from(arguments);\n}\n\nf(1, 2, 3).subscribe(\n  function (x) { console.log('Next: ' + x); },\n  function (err) { console.log('Error: ' + err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 1\nNext: 2\nNext: 3\nCompleted\n```\n\n``` javascript\n// Any iterable object...\n// Set\nvar s = new Set(['foo', window]);\nRx.Observable.from(s).subscribe(\n  function (x) { console.log('Next: ' + x); },\n  function (err) { console.log('Error: ' + err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: foo\nNext: window\nCompleted\n```\n\n``` javascript\n// Map\nvar m = new Map([[1, 2], [2, 4], [4, 8]]);\nRx.Observable.from(m).subscribe(\n  function (x) { console.log('Next: ' + x); },\n  function (err) { console.log('Error: ' + err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: [1, 2]\nNext: [2, 4]\nNext: [4, 8]\nCompleted\n```\n\n``` javascript\n// String\nRx.Observable.from(\"foo\").subscribe(\n  function (x) { console.log('Next: ' + x); },\n  function (err) { console.log('Error: ' + err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: f\nNext: o\nNext: o\nCompleted\n```\n\n``` javascript\n// Using an arrow function as the map function to manipulate the elements\nRx.Observable.from([1, 2, 3], function (x) { return x + x; }).subscribe(\n  function (x) { console.log('Next: ' + x); },\n  function (err) { console.log('Error: ' + err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 2\nNext: 4\nNext: 6\nCompleted\n```\n\n``` javascript\n// Generate a sequence of numbers\nRx.Observable.from({length: 5}, function(v, k) { return k; }).subscribe(\n  function (x) { console.log('Next: ' + x); },\n  function (err) { console.log('Error: ' + err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nNext: 3\nNext: 4\nCompleted\n```\n\n`from` is found in the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThe `fromCallback` operator takes a function as a parameter, calls this function, and emits the value returned from it as its single emission.\n\nThis operator also takes two additional, optional parameters:\n\n2.  a parameter to pass to the callback function\n3.  a tranforming function that takes the return value of the callback function as input and returns an item to be emitted by the resulting Observable\n\n#### Sample Code\n\n``` javascript\nvar fs = require('fs'),\n    Rx = require('rx');\n\n// Wrap fs.exists\nvar exists = Rx.Observable.fromCallback(fs.exists);\n\n// Check if file.txt exists\nvar source = exists('file.txt');\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: true\nCompleted\n```\n\n`fromCallback` is found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.async.js` (requires `rx.binding.js` and either `rx.js` or `rx.compat.js`)\n- `rx.async.compat.js` (requires `rx.binding.js` and either `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThere is also a `fromNodeCallback` operator, which is specialized for the types of callback functions found in Node.js.\n\nThis operator takes three additional, optional parameters:\n\n2.  a [Scheduler](../scheduler) on which you want to run the Node.js callback\n3.  a parameter to give to the callback function\n4.  a tranforming function that takes the return value of the callback function as input and returns an item to be emitted by the resulting Observable\n\n#### Sample Code\n\n``` javascript\nvar fs = require('fs'),\n    Rx = require('rx');\n\n// Wrap fs.exists\nvar rename = Rx.Observable.fromNodeCallback(fs.rename);\n\n// Rename file which returns no parameters except an error\nvar source = rename('file1.txt', 'file2.txt');\n\nvar subscription = source.subscribe(\n    function () { console.log('Next: success!'); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: success!\nCompleted\n```\n\n`fromNodeCallback` is found in the following distributions:\n\n- `rx.async.js` (requires `rx.binding.js` and either `rx.js` or `rx.compat.js`)\n- `rx.async.compat.js` (requires `rx.binding.js` and either `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThe `fromEvent` operator takes an “element” and an event name as parameters, and it then listens for events of that name taking place on that element. It returns an Observable that emits those events. An “element” may be a simple DOM element, or a NodeList, jQuery element, Zepto Element, Angular element, Ember.js element, or EventEmitter.\n\nThis operator also takes an optional third parameter: a function that accepts the arguments from the event handler as parameters and returns an item to be emitted by the resulting Observable in place of the event.\n\n#### Sample Code\n\n``` javascript\n// using a jQuery element\nvar input = $('#input');\n\nvar source = Rx.Observable.fromEvent(input, 'click');\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: Clicked!'); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n\ninput.trigger('click');\n```\n\n``` javascript\nNext: Clicked!\n```\n\n``` javascript\n// using a Node.js EventEmitter and the optional third parameter\nvar EventEmitter = require('events').EventEmitter,\n    Rx = require('rx');\n\nvar eventEmitter = new EventEmitter();\n\nvar source = Rx.Observable.fromEvent(\n    eventEmitter,\n    'data',\n    function (first, second) {\n        return { foo: first, bar: second };\n    });\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: foo -' + x.foo + ', bar -' + x.bar);\n    },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n\neventEmitter.emit('data', 'baz', 'quux');\n```\n\n``` javascript\nNext: foo - baz, bar - quux\n```\n\n`fromEvent` is found in the following distributions:\n\n- `rx.async.js` (requires `rx.binding.js` and either `rx.js` or `rx.compat.js`)\n- `rx.async.compat.js` (requires `rx.binding.js` and either `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThe `fromEventPattern` operator is similar, except that instead of taking an element and an event name as parameters, it takes two functions as parameters. The first function attaches an event listener to a variety of events on a variety of elements; the second function removes this set of listeners. In this way you can establish a single Observable that emits items representing a variety of events and a variety of target elements.\n\n#### Sample Code\n\n``` javascript\nvar input = $('#input');\n\nvar source = Rx.Observable.fromEventPattern(\n    function add (h) {\n        input.bind('click', h);\n    },\n    function remove (h) {\n        input.unbind('click', h);\n    }\n);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: Clicked!'); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n\ninput.trigger('click');\n```\n\n``` javascript\nNext: Clicked!\n```\n\nThe `of` operator accepts a number of items as parameters, and returns an Observable that emits each of these parameters, in order, as its emitted sequence.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.of(1,2,3);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 1\nNext: 2\nNext: 3\nCompleted\n```\n\n`of` is found in the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nA variant of this operator, called `ofWithScheduler` takes a [Scheduler](../scheduler) as its first parameter, and operates the resulting Observable on this Scheduler.\n\nThere is also a `fromPromise` operator that converts a Promise into an Observable, converting its `resolve` calls into `onNext` notifications, and its `reject` calls into `onError` notifications.\n\n`fromPromise` is found in the following distributions:\n\n- `rx.async.js` (requires `rx.binding.js` and either `rx.js` or `rx.compat.js`)\n- `rx.async.compat.js` (requires `rx.binding.js` and either `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n#### Sample Code\n\n``` javascript\nvar promise = new RSVP.Promise(function (resolve, reject) {\n   resolve(42);\n});\n\nvar source = Rx.Observable.fromPromise(promise);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (e) { console.log('Error: ' + e); },\n    function ( ) { console.log('Completed'); });\n```\n\n``` javascript\nNext: 42:\nCompleted\n```\n\n``` javascript\nvar promise = new RSVP.Promise(function (resolve, reject) {\n   reject(new Error('reason'));\n});\n\nvar source = Rx.Observable.fromPromise(promise);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (e) { console.log('Error: ' + e); },\n    function ( ) { console.log('Completed'); });\n```\n\n``` javascript\nError: Error: reject\n```\n\nThere is also an `ofArrayChanges` operator that monitors an Array with the `Array.observe` method, and returns an Observable that emits any changes that take place in the array. This operator is found only in the `rx.all.js` distribution.\n\n#### Sample Code\n\n``` javascript\nvar arr = [1,2,3];\nvar source = Rx.Observable.ofArrayChanges(arr);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (e) { console.log('Error: ' + e); },\n    function ( ) { console.log('Completed'); });\n\narr.push(4)\n```\n\n``` javascript\nNext: {type: \"splice\", object: Array[4], index: 3, removed: Array[0], addedCount: 1}\n```\n\nA similar operator is `ofObjectChanges`. It returns an Observable that emits any changes made to a particular object, as reported by its `Object.observe` method. It is also found only in the `rx.all.js` distribution.\n\n#### Sample Code\n\n``` javascript\nvar obj = {x: 1};\nvar source = Rx.Observable.ofObjectChanges(obj);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (e) { console.log('Error: ' + e); },\n    function ( ) { console.log('Completed'); });\n\nobj.x = 42;\n```\n\n``` javascript\nNext: {type: \"update\", object: Object, name: \"x\", oldValue: 1}\n```\n\nThere is also a `pairs` operator. This operator accepts an Object, and returns an Observable that emits, as key/value pairs, the attributes of that object.\n\n#### Sample Code\n\n``` javascript\nvar obj = {\n  foo: 42,\n  bar: 56,\n  baz: 78\n};\n\nvar source = Rx.Observable.pairs(obj);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (e) { console.log('Error: ' + e); },\n    function ( ) { console.log('Completed'); });\n```\n\n``` javascript\nNext: ['foo', 42]\nNext: ['bar', 56]\nNext: ['baz', 78]\nCompleted\n```\n\n`pairs` is found in the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `fromArray fromIterator asObservable fromPromise`\n\nRxPHP implements this operator as `fromArray`.\n\nConverts an array to an observable sequence\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/fromArray/fromArray.php\n\n$source = \\Rx\\Observable::fromArray([1, 2, 3, 4]);\n\n$subscription = $source->subscribe($stdoutObserver);\n\n//Next value: 1\n//Next value: 2\n//Next value: 3\n//Next value: 4\n//Complete!\n```\n\n``` javascript\nNext value: 1\nNext value: 2\nNext value: 3\nNext value: 4\nComplete!\n```\n\nRxPHP also has an operator `fromIterator`.\n\nConverts an Iterator into an observable sequence\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/iterator/iterator.php\n\n$generator = function () {\n    for ($i = 1; $i <= 3; $i++) {\n        yield $i;\n    }\n\n    return 4;\n};\n\n$source = Rx\\Observable::fromIterator($generator());\n\n$source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 1\nNext value: 2\nNext value: 3\nNext value: 4\nComplete!\n```\n\nRxPHP also has an operator `asObservable`.\n\nHides the identity of an observable sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/asObservable/asObservable.php\n\n// Create subject\n$subject = new \\Rx\\Subject\\AsyncSubject();\n\n// Send a value\n$subject->onNext(42);\n$subject->onCompleted();\n\n// Hide its type\n$source = $subject->asObservable();\n\n$source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 42\nComplete!\n```\n\nRxPHP also has an operator `fromPromise`.\n\nConverts a promise into an observable\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/promise/fromPromise.php\n\n$promise = \\React\\Promise\\resolve(42);\n\n$source = \\Rx\\Observable::fromPromise($promise);\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 42\nComplete!\n```\n\n### RxSwift `from toObservable`\n\nIn Swift, this is implemented using the `Observable.from` class method.\n\nEach element of the array is produced as an emission. The difference between this method and `Observable.just` is that the latter emits the whole array as one emission.\n\n#### Sample Code\n\n``` swift\nlet numbers = [1,2,3,4,5]\n\nlet source = Observable.from(numbers)\n\nsource.subscribe {\n    print($0)\n}\n```\n\n``` javascript\nnext(1)\nnext(2)\nnext(3)\nnext(4)\nnext(5)\ncompleted\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/from.html](http://reactivex.io/documentation/operators/from.html)"
- name: GroupBy
  id: documentation/operators/groupby
  summary: The GroupBy operator divides an Observable that emits items into an Observable that emits Observables, each one of which emits some subset of the items from the original source Observable
  description: "# GroupBy\n\ndivide an Observable into a set of Observables that each emit a different subset of items from the original Observable\n\nThe GroupBy operator divides an Observable that emits items into an Observable that emits Observables, each one of which emits some subset of the items from the original source Observable. Which items end up on which Observable is typically decided by a discriminating function that evaluates each item and assigns it a key. All items with the same key are emitted by the same Observable.\n\n#### See Also\n\n- [Window](window)\n- [Introduction to Rx: GroupBy](http://www.introtorx.com/Content/v1.0.10621.0/07_Aggregation.html#GroupBy)\n- [Animations of Rx operators: GroupBy](http://blogs.microsoft.co.il/iblogger/2015/08/11/animations-of-rx-operators-groupby/) by Tamir Dresher\n\n## Language-Specific Information\n\n### RxGroovy `groupBy`\n\nRxGroovy implements the `groupBy` operator. The Observable it returns emits items of a particular subclass of Observable — the `GroupedObservable`. Objects that implement the `GroupedObservable` interface have an additional method — `getkey` — by which you can retrieve the key by which items were designated for this particular `GroupedObservable`.\n\nThe following sample code uses `groupBy` to transform a list of numbers into two lists, grouped by whether or not the numbers are even:\n\n#### Sample Code\n\n``` groovy\ndef numbers = Observable.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\ndef groupFunc = { return(0 == (it % 2)); };\n\nnumbers.groupBy(groupFunc).flatMap({ it.reduce([it.getKey()], {a, b -> a << b}) }).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n[false, 1, 3, 5, 7, 9]\n[true, 2, 4, 6, 8]\nSequence complete\n```\n\nAnother version of `groupBy` allows you to pass in a transformative function that changes the elements before they are emitted by the resulting `GroupedObservable`s.\n\nNote that when `groupBy` splits up the source Observable into an Observable that emits `GroupedObservable`s, each of these `GroupedObservable`s begins to buffer the items that it will emit upon subscription. For this reason, if you ignore any of these `GroupedObservable`s (you neither subscribe to it or apply an operator to it that subscribes to it), this buffer will present a potential memory leak. For this reason, rather than ignoring a `GroupedObservable` that you have no interest in observing, you should instead apply an operator like [`take(0)`](take) to it as a way of signalling to it that it may discard its buffer.\n\nIf you unsubscribe from one of the `GroupedObservable`s, or if an operator like `take` that you apply to the `GroupedObservable` unsubscribes from it, that `GroupedObservable` will be terminated. If the source Observable later emits an item whose key matches the `GroupedObservable` that was terminated in this way, `groupBy` will create and emit a *new* `GroupedObservable` to match the key. In other words, unsubscribing from a `GroupedObservable` will *not* cause `groupBy` to swallow items from its group. For example, see the following code:\n\n#### Sample Code\n\n``` groovy\nObservable.range(1,5)\n          .groupBy({ 0 })\n          .flatMap({ this.take(1) })\n          .subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n1\n2\n3\n4\n5\n```\n\nIn the above code, the source Observable emits the sequence `{ 1 2 3 4 5 }`. When it emits the first item in this sequence, the `groupBy` operator creates and emits a `GroupedObservable` with the key of `0`. The `flatMap` operator applies the `take(1)` operator to that `GroupedObservable`, which gives it the item (`1`) that it emits and that also unsubscribes from the `GroupedObservable`, which is terminated. When the source Observable emits the second item in its sequence, the `groupBy` operator creates and emits a *second* `GroupedObservable` with the same key (`0`) to replace the one that was terminated. `flatMap` again applies `take(1)` to this new `GroupedObservable` to retrieve the new item to emit (`2`) and to unsubscribe from and terminate the `GroupedObservable`, and this process repeats for the remaining items in the source sequence.\n\n`groupBy` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`groupBy(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#groupBy(rx.functions.Func1))\n- Javadoc: [`groupBy(Func1,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#groupBy(rx.functions.Func1,%20rx.functions.Func1))\n\n### RxJava 1․x `groupBy`\n\nRxJava implements the `groupBy` operator. The Observable it returns emits items of a particular subclass of Observable — the `GroupedObservable`. Objects that implement the `GroupedObservable` interface have an additional method — `getkey` — by which you can retrieve the key by which items were designated for this particular `GroupedObservable`.\n\nAnother version of `groupBy` allows you to pass in a transformative function that changes the elements before they are emitted by the resulting `GroupedObservable`s.\n\nNote that when `groupBy` splits up the source Observable into an Observable that emits `GroupedObservable`s, each of these `GroupedObservable`s begins to buffer the items that it will emit upon subscription. For this reason, if you ignore any of these `GroupedObservable`s (you neither subscribe to it or apply an operator to it that subscribes to it), this buffer will present a potential memory leak. For this reason, rather than ignoring a `GroupedObservable` that you have no interest in observing, you should instead apply an operator like [`take(0)`](take) to it as a way of signalling to it that it may discard its buffer.\n\nIf you unsubscribe from one of the `GroupedObservable`s, that `GroupedObservable` will be terminated. If the source Observable later emits an item whose key matches the `GroupedObservable` that was terminated in this way, `groupBy` will create and emit a new `GroupedObservable` to match the key.\n\n`groupBy` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`groupBy(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#groupBy(rx.functions.Func1))\n- Javadoc: [`groupBy(Func1,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#groupBy(rx.functions.Func1,%20rx.functions.Func1))\n\n### RxJS `groupBy groupByUntil`\n\nRxJS implements `groupBy`. It takes one to three parameters:\n\n1.  (required) a function that accepts an item from the source Observable and returns its key\n2.  a function that accepts an item from the source Observable and returns an item to be emitted in its place by one of the resulting Observables\n3.  a function used to compare two keys for identity (that is, whether items with two keys should be emitted on the same Observable)\n\n#### Sample Code\n\n``` javascript\nvar codes = [\n    { keyCode: 38}, // up\n    { keyCode: 38}, // up\n    { keyCode: 40}, // down\n    { keyCode: 40}, // down\n    { keyCode: 37}, // left\n    { keyCode: 39}, // right\n    { keyCode: 37}, // left\n    { keyCode: 39}, // right\n    { keyCode: 66}, // b\n    { keyCode: 65}  // a\n];\n\nvar source = Rx.Observable.fromArray(codes)\n    .groupBy(\n        function (x) { return x.keyCode; },\n        function (x) { return x.keyCode; });\n\nvar subscription = source.subscribe(\n    function (obs) {\n        // Print the count\n        obs.count().subscribe(function (x) {\n            console.log('Count: ' + x);\n        });\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nCount: 2\nCount: 2\nCount: 2\nCount: 2\nCount: 1\nCount: 1\nCompleted\n```\n\n`groupBy` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.coincidence.js`\n\nRxJS also implements `groupByUntil`. It monitors an additional Observable, and whenever that Observable emits an item, it closes any of the keyed Observables it has opened (it will open new ones if additional items are emitted by the source Observable that match the key). `groupByUntil` takes from two to four parameters:\n\n1.  (required) a function that accepts an item from the source Observable and returns its key\n2.  a function that accepts an item from the source Observable and returns an item to be emitted in its place by one of the resulting Observables\n3.  (required) a function that returns an Observable, the emissions from which trigger the termination of any open Observables\n4.  a function used to compare two keys for identity (that is, whether items with two keys should be emitted on the same Observable)\n\n#### Sample Code\n\n``` javascript\nvar codes = [\n    { keyCode: 38}, // up\n    { keyCode: 38}, // up\n    { keyCode: 40}, // down\n    { keyCode: 40}, // down\n    { keyCode: 37}, // left\n    { keyCode: 39}, // right\n    { keyCode: 37}, // left\n    { keyCode: 39}, // right\n    { keyCode: 66}, // b\n    { keyCode: 65}  // a\n];\n\nvar source = Rx.Observable\n    .for(codes, function (x) { return Rx.Observable.return(x).delay(1000); })\n    .groupByUntil(\n        function (x) { return x.keyCode; },\n        function (x) { return x.keyCode; },\n        function (x) { return Rx.Observable.timer(2000); });\n\nvar subscription = source.subscribe(\n    function (obs) {\n        // Print the count\n        obs.count().subscribe(function (x) { console.log('Count: ' + x); });\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nCount: 2\nCount: 2\nCount: 1\nCount: 1\nCount: 1\nCount: 1\nCount: 1\nCount: 1\nCompleted\n```\n\n`groupByUntil` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.coincidence.js`\n\n### RxPHP `groupBy groupByUntil partition`\n\nRxPHP implements this operator as `groupBy`.\n\nGroups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/groupBy/groupBy.php\n\n$observable = \\Rx\\Observable::fromArray([21, 42, 21, 42, 21, 42]);\n$observable\n    ->groupBy(\n        function ($elem) {\n            if ($elem === 42) {\n                return 0;\n            }\n\n            return 1;\n        },\n        null,\n        function ($key) {\n            return $key;\n        }\n    )\n    ->subscribe(function ($groupedObserver) use ($createStdoutObserver) {\n        $groupedObserver->subscribe($createStdoutObserver($groupedObserver->getKey() . \": \"));\n    });\n```\n\n``` javascript\n1: Next value: 21\n0: Next value: 42\n1: Next value: 21\n0: Next value: 42\n1: Next value: 21\n0: Next value: 42\n1: Complete!\n0: Complete!\n```\n\nRxPHP also has an operator `groupByUntil`.\n\nGroups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/groupBy/groupByUntil.php\n\n$codes = [\n    ['id' => 38],\n    ['id' => 38],\n    ['id' => 40],\n    ['id' => 40],\n    ['id' => 37],\n    ['id' => 39],\n    ['id' => 37],\n    ['id' => 39],\n    ['id' => 66],\n    ['id' => 65]\n];\n\n$source = Rx\\Observable\n    ::fromArray($codes)\n    ->concatMap(function ($x) {\n        return \\Rx\\Observable::timer(100)->mapTo($x);\n    })\n    ->groupByUntil(\n        function ($x) {\n            return $x['id'];\n        },\n        function ($x) {\n            return $x['id'];\n        },\n        function ($x) {\n            return Rx\\Observable::timer(200);\n        });\n\n$subscription = $source->subscribe(new CallbackObserver(\n    function (\\Rx\\Observable $obs) {\n        // Print the count\n        $obs->count()->subscribe(new CallbackObserver(\n            function ($x) {\n                echo 'Count: ', $x, PHP_EOL;\n            }));\n    },\n    function (Throwable $err) {\n        echo 'Error', $err->getMessage(), PHP_EOL;\n    },\n    function () {\n        echo 'Completed', PHP_EOL;\n    }));\n```\n\n``` javascript\nCount: 2\nCount: 2\nCount: 1\nCount: 1\nCount: 1\nCount: 1\nCount: 1\nCount: 1\nCompleted\n```\n\nRxPHP also has an operator `partition`.\n\nReturns two observables which partition the observations of the source by the given function. The first will trigger observations for those values for which the predicate returns true. The second will trigger observations for those values where the predicate returns false. The predicate is executed once for each subscribed observer. Both also propagate all error observations arising from the source and each completes when the source completes.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/partition/partition.php\n\nlist($evens, $odds) = \\Rx\\Observable::range(0, 10, \\Rx\\Scheduler::getImmediate())\n    ->partition(function ($x) {\n        return $x % 2 === 0;\n    });\n\n//Because we used the immediate scheduler with range, the subscriptions are not asynchronous.\n$evens->subscribe($createStdoutObserver('Evens '));\n$odds->subscribe($createStdoutObserver('Odds '));\n```\n\n``` javascript\nEvens Next value: 0\nEvens Next value: 2\nEvens Next value: 4\nEvens Next value: 6\nEvens Next value: 8\nEvens Complete!\nOdds Next value: 1\nOdds Next value: 3\nOdds Next value: 5\nOdds Next value: 7\nOdds Next value: 9\nOdds Complete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/groupby.html](http://reactivex.io/documentation/operators/groupby.html)"
- name: IgnoreElements
  id: documentation/operators/ignoreelements
  summary: The IgnoreElements operator suppresses all of the items emitted by the source Observable, but allows its termination notification (either onError or onCompleted) to pass through unchanged
  description: "# IgnoreElements\n\ndo not emit any items from an Observable but mirror its termination notification\n\nThe IgnoreElements operator suppresses all of the items emitted by the source Observable, but allows its termination notification (either `onError` or `onCompleted`) to pass through unchanged.\n\nIf you do not care about the items being emitted by an Observable, but you do want to be notified when it completes or when it terminates with an error, you can apply the `ignoreElements` operator to the Observable, which will ensure that it will never call its observers’ `onNext` handlers.\n\n#### See Also\n\n- [Introduction to Rx: IgnoreElements](http://www.introtorx.com/Content/v1.0.10621.0/05_Filtering.html#IgnoreElements)\n\n## Language-Specific Information\n\n### RxGroovy `ignoreElements`\n\nRxGroovy implements this operator as `ignoreElements`.\n\n- Javadoc: [`ignoreElements()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#ignoreElements())\n\n`ignoreElements` does not by default operate on any particular [Scheduler](../scheduler).\n\n### RxJava 1․x `ignoreElements`\n\nRxJava implements this operator as `ignoreElements`.\n\n- Javadoc: [`ignoreElements()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#ignoreElements())\n\n`ignoreElements` does not by default operate on any particular [Scheduler](../scheduler).\n\n### RxJS `ignoreElements`\n\nRxJS implements this operator as `ignoreElements`.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 10)\n    .ignoreElements();\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nCompleted\n```\n\n`ignoreElements` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/ignoreelements.html](http://reactivex.io/documentation/operators/ignoreelements.html)"
- name: Implementing Your Own Operators
  id: documentation/implement-operator
  summary: You can implement your own Observable operators
  description: "# Implementing Your Own Operators\n\nYou can implement your own Observable operators. This page shows you how.\n\nIf your operator is designed to *originate* an Observable, rather than to transform or react to a source Observable, use the [`create( )`](operators/create) method rather than trying to implement `Observable` manually. Otherwise, follow the instructions below.\n\n## Chaining Your Custom Operators with Standard RxJava Operators\n\nThe following example shows how you can chain a custom operator (in this example: `myOperator`) along with standard RxJava operators by using the `lift( )` operator:\n\n``` javascript\nObservable foo = barObservable.ofType(Integer).map({it*2}).lift(new myOperator<T>()).map({\"transformed by myOperator: \" + it});\n```\n\nThe following section will show how to form the scaffolding of your operator so that it will work correctly with `lift( )`.\n\n## Implementing Your Operator\n\nDefine your operator as a public class that implements the [`Operator`](http://reactivex.io/RxJava/javadoc/rx/Observable.Operator.html) interface, like so:\n\n``` javascript\npublic class myOperator<T> implements Operator<T> {\n  public myOperator( /* any necessary params here */ ) {\n    /* any necessary initialization here */\n  }\n\n  @Override\n  public Subscriber<? super T> call(final Subscriber<? super T> s) {\n    return new Subscriber<t>(s) {\n      @Override\n      public void onCompleted() {\n        /* add your own onCompleted behavior here, or just pass the completed notification through: */\n        if(!s.isUnsubscribed()) {\n          s.onCompleted();\n        }\n      }\n\n      @Override\n      public void onError(Throwable t) {\n        /* add your own onError behavior here, or just pass the error notification through: */\n        if(!s.isUnsubscribed()) {\n          s.onError(t);\n        }\n      }\n\n      @Override\n      public void onNext(T item) {\n        /* this example performs some sort of simple transformation on each incoming item and then passes it along */\n        if(!s.isUnsubscribed()) {\n          transformedItem = myOperatorTransformOperation(item);\n          s.onNext(transformedItem);\n        }\n      }\n    };\n  }\n}\n```\n\n## Other Considerations\n\n- Your operator should check [its Subscriber's `isUnsubscribed( )` status](observable#unsubscribing) before it emits any item to (or sends any notification to) the Subscriber. Do not waste time generating items that no Subscriber is interested in seeing.\n- Your operator should obey the core tenets of the Observable contract:\n  - It may call a Subscriber's [`onNext( )`](observable#onnext-oncompleted-and-onerror) method any number of times, but these calls must be non-overlapping.\n  - It may call either a Subscriber's [`onCompleted( )`](observable#onnext-oncompleted-and-onerror) or [`onError( )`](observable#onnext-oncompleted-and-onerror) method, but not both, exactly once, and it may not subsequently call a Subscriber's [`onNext( )`](observable#onnext-oncompleted-and-onerror) method.\n  - If you are unable to guarantee that your operator conforms to the above two tenets, you can add the [`serialize( )`](observable-utility-operators#serialize) operator to it to force the correct behavior.\n- Do not block within your operator.\n- It is usually best that you compose new operators by combining existing ones, to the extent that this is possible, rather than reinventing the wheel. RxJava itself does this with some of its standard operators, for example:\n  - [`first( )`](filtering-observables#wiki-first-and-takefirst) is defined as [`take(1)`](filtering-observables#wiki-take)`.`[`single( )`](observable-utility-operators#wiki-single-and-singleordefault)\n  - [`ignoreElements( )`](filtering-observables#wiki-ignoreelements) is defined as [`filter(alwaysFalse( ))`](filtering-observables#wiki-filter)\n  - [`reduce(a)`](mathematical-and-aggregate-operators#wiki-reduce) is defined as [`scan(a)`](transforming-observables#wiki-scan)`.`[`last( )`](filtering-observables#wiki-last)\n- If your operator uses functions or lambdas that are passed in as parameters (predicates, for instance), note that these may be sources of exceptions, and be prepared to catch these and notify subscribers via `onError( )` calls.\n- In general, notify subscribers of error conditions immediately, rather than making an effort to emit more items first.\n- In some ReactiveX implementations, your operator may need to be sensitive to that implementation’s “backpressure” strategies. (See, for example: [Pitfalls of Operator Implementations (part 2)](http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html) by Dávid Karnok.)\n\n## See Also\n\n- [Pitfalls of Operator Implementations (part 1)](http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations.html) and [(part 2)](http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html) by Dávid Karnok.\n- [Implementing Your Own Observable Operators](http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/implementing_your_own_operators.html) (in RxJS) by Dennis Stoyanov\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/implement-operator.html](http://reactivex.io/documentation/implement-operator.html)"
- name: Interval
  id: documentation/operators/interval
  summary: The Interval operator returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time of your choosing between emissions
  description: "# Interval\n\ncreate an Observable that emits a sequence of integers spaced by a given time interval\n\nThe Interval operator returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time of your choosing between emissions.\n\n#### See Also\n\n- [Range](range)\n- [Repeat](repeat)\n- [Timer](timer)\n- [Introduction to Rx: Interval](http://www.introtorx.com/Content/v1.0.10621.0/04_CreatingObservableSequences.html#ObservableInterval)\n- [101 Rx Samples: Observing the Passing of Time](http://rxwiki.wikidot.com/101samples#toc15)\n- [101 Rx Samples: Interval — Simple](http://rxwiki.wikidot.com/101samples#toc28)\n- [ad-hockery: Simple Background Polling with RxJava](http://blog.freeside.co/2015/01/29/simple-background-polling-with-rxjava/)\n\n## Language-Specific Information\n\n### RxGroovy `interval`\n\nRxGroovy implements this operator as `interval`. It accepts as its parameters a span of time to wait between emissions and the `TimeUnit` in which this span is measured.\n\n- Javadoc: [`interval(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`interval(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long,%20java.util.concurrent.TimeUnit%20rx.Scheduler))\n\nThere is also a version of `interval` that returns an Observable that emits a single zero after a specified delay, and then emits incrementally increasing numbers periodically thereafter on a specified periodicity. This version of `interval` was called [`timer`](timer) in RxGroovy 1.0.0, but that method has since been deprecated in favor of the one named `interval` with the same behavior.\n\n- Javadoc: [`interval(long,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`interval(long,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n`interval` operates by default on the `computation` [Scheduler](../scheduler). There are also variants that allow you to set the Scheduler by passing one in as a parameter.\n\n### RxJava 1․x `interval`\n\nRxJava implements this operator as `interval`. It accepts as its parameters a span of time to wait between emissions and the `TimeUnit` in which this span is measured.\n\n- Javadoc: [`interval(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`interval(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long,%20java.util.concurrent.TimeUnit%20rx.Scheduler))\n\nThere is also a version of `interval` that returns an Observable that emits a single zero after a specified delay, and then emits incrementally increasing numbers periodically thereafter on a specified periodicity. This version of `interval` was called [`timer`](timer) in RxJava 1.0.0, but that method has since been deprecated in favor of the one named `interval` with the same behavior.\n\n- Javadoc: [`interval(long,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`interval(long,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n`interval` operates by default on the `computation` [Scheduler](../scheduler). There are also variants that allow you to set the Scheduler by passing one in as a parameter.\n\n### RxJS `interval`\n\nRxJS implements this operator as `interval`. It accepts as its parameter the number of milliseconds to wait between emissions.\n\n`interval` operates by default on the `timeout` [Scheduler](../scheduler), or you can optionally pass in a different Scheduler as a second parameter, and `interval` will operate on that Scheduler instead.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable\n    .interval(500 /* ms */)\n    .timeInterval()\n    .take(3);\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x);\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nNext: {value: 0, interval: 500}\nNext: {value: 1, interval: 500}\nNext: {value: 2, interval: 500}\nCompleted\n```\n\n`interval` is found in the following distributions:\n\n- `rx.lite.js`\n- `rx.lite.compat.js`\n- `rx.timejs` (requires `rx.js` or `rx.compat.js`)\n\n### RxPHP `interval`\n\nRxPHP implements this operator as `interval`.\n\nReturns an Observable that emits an infinite sequence of ascending integers starting at 0, with a constant interval of time of your choosing between emissions.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/interval/interval.php\n\n\\Rx\\Observable::interval(1000)\n    ->take(5)\n    ->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 0\nNext value: 1\nNext value: 2\nNext value: 3\nNext value: 4\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/interval.html](http://reactivex.io/documentation/operators/interval.html)"
- name: Introduction
  id: documentation/operators
  summary: Each language-specific implementation of ReactiveX implements a set of operators
  description: "# Introduction\n\nEach language-specific implementation of ReactiveX implements a set of operators. Although there is much overlap between implementations, there are also some operators that are only implemented in certain implementations. Also, each implementation tends to name its operators to resemble those of similar methods that are already familiar from other contexts in that language.\n\n## Chaining Operators\n\nMost operators operate on an Observable and return an Observable. This allows you to apply these operators one after the other, in a chain. Each operator in the chain modifies the Observable that results from the operation of the previous operator.\n\nThere are other patterns, like the Builder Pattern, in which a variety of methods of a particular class operate on an item of that same class by modifying that object through the operation of the method. These patterns also allow you to chain the methods in a similar way. But while in the Builder Pattern, the order in which the methods appear in the chain does not usually matter, with the Observable operators *order matters*.\n\nA chain of Observable operators do not operate independently on the original Observable that originates the chain, but they operate *in turn*, each one operating on the Observable generated by the operator immediately previous in the chain.\n\n## The Operators of ReactiveX\n\nThis page first lists what could be considered the “core” operators in ReactiveX, and links to pages that have more in-depth information on how these operators work and how particular language-specific ReactiveX versions have implemented these operators.\n\nNext is a “decision tree” that may help you choose the operator that is most appropriate to your use case.\n\nFinally, there is an alphabetical list of most of the operators available in the many language-specific implementations of ReactiveX. These link to the page that documents the core operator that most closely resembles the language-specific operator (so, for instance, the Rx.NET “SelectMany” operator links to the documentation of the FlatMap ReactiveX operator, of which “SelectMany” is the Rx.NET implementation).\n\nIf you want to implement your own operator, see [Implementing Your Own Operators](implement-operator).\n\n#### Contents\n\n1.  [Operators By Category](#categorized)\n2.  [A Decision Tree of Observable Operators](#tree)\n3.  [An Alphabetical List of Observable Operators](#alphabetical)\n\n## Operators By Category\n\n## Creating Observables\n\nOperators that originate new Observables.\n\n- [`Create`](operators/create) — create an Observable from scratch by calling observer methods programmatically\n- [`Defer`](operators/defer) — do not create the Observable until the observer subscribes, and create a fresh Observable for each observer\n- [`Empty`/`Never`/`Throw`](operators/empty-never-throw) — create Observables that have very precise and limited behavior\n- [`From`](operators/from) — convert some other object or data structure into an Observable\n- [`Interval`](operators/interval) — create an Observable that emits a sequence of integers spaced by a particular time interval\n- [`Just`](operators/just) — convert an object or a set of objects into an Observable that emits that or those objects\n- [`Range`](operators/range) — create an Observable that emits a range of sequential integers\n- [`Repeat`](operators/repeat) — create an Observable that emits a particular item or sequence of items repeatedly\n- [`Start`](operators/start) — create an Observable that emits the return value of a function\n- [`Timer`](operators/timer) — create an Observable that emits a single item after a given delay\n\n## Transforming Observables\n\nOperators that transform items that are emitted by an Observable.\n\n- [`Buffer`](operators/buffer) — periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time\n- [`FlatMap`](operators/flatmap) — transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable\n- [`GroupBy`](operators/groupby) — divide an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key\n- [`Map`](operators/map) — transform the items emitted by an Observable by applying a function to each item\n- [`Scan`](operators/scan) — apply a function to each item emitted by an Observable, sequentially, and emit each successive value\n- [`Window`](operators/window) — periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time\n\n## Filtering Observables\n\nOperators that selectively emit items from a source Observable.\n\n- [`Debounce`](operators/debounce) — only emit an item from an Observable if a particular timespan has passed without it emitting another item\n- [`Distinct`](operators/distinct) — suppress duplicate items emitted by an Observable\n- [`ElementAt`](operators/elementat) — emit only item *n* emitted by an Observable\n- [`Filter`](operators/filter) — emit only those items from an Observable that pass a predicate test\n- [`First`](operators/first) — emit only the first item, or the first item that meets a condition, from an Observable\n- [`IgnoreElements`](operators/ignoreelements) — do not emit any items from an Observable but mirror its termination notification\n- [`Last`](operators/last) — emit only the last item emitted by an Observable\n- [`Sample`](operators/sample) — emit the most recent item emitted by an Observable within periodic time intervals\n- [`Skip`](operators/skip) — suppress the first *n* items emitted by an Observable\n- [`SkipLast`](operators/skiplast) — suppress the last *n* items emitted by an Observable\n- [`Take`](operators/take) — emit only the first *n* items emitted by an Observable\n- [`TakeLast`](operators/takelast) — emit only the last *n* items emitted by an Observable\n\n## Combining Observables\n\nOperators that work with multiple source Observables to create a single Observable\n\n- [`And`/`Then`/`When`](operators/and-then-when) — combine sets of items emitted by two or more Observables by means of `Pattern` and `Plan` intermediaries\n- [`CombineLatest`](operators/combinelatest) — when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function\n- [`Join`](operators/join) — combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable\n- [`Merge`](operators/merge) — combine multiple Observables into one by merging their emissions\n- [`StartWith`](operators/startwith) — emit a specified sequence of items before beginning to emit the items from the source Observable\n- [`Switch`](operators/switch) — convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables\n- [`Zip`](operators/zip) — combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function\n\n## Error Handling Operators\n\nOperators that help to recover from error notifications from an Observable\n\n- [`Catch`](operators/catch) — recover from an `onError` notification by continuing the sequence without error\n- [`Retry`](operators/retry) — if a source Observable sends an `onError` notification, resubscribe to it in the hopes that it will complete without error\n\n## Observable Utility Operators\n\nA toolbox of useful Operators for working with Observables\n\n- [`Delay`](operators/delay) — shift the emissions from an Observable forward in time by a particular amount\n- [`Do`](operators/do) — register an action to take upon a variety of Observable lifecycle events\n- [`Materialize`/`Dematerialize`](operators/materialize-dematerialize) — represent both the items emitted and the notifications sent as emitted items, or reverse this process\n- [`ObserveOn`](operators/observeon) — specify the scheduler on which an observer will observe this Observable\n- [`Serialize`](operators/serialize) — force an Observable to make serialized calls and to be well-behaved\n- [`Subscribe`](operators/subscribe) — operate upon the emissions and notifications from an Observable\n- [`SubscribeOn`](operators/subscribeon) — specify the scheduler an Observable should use when it is subscribed to\n- [`TimeInterval`](operators/timeinterval) — convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions\n- [`Timeout`](operators/timeout) — mirror the source Observable, but issue an error notification if a particular period of time elapses without any emitted items\n- [`Timestamp`](operators/timestamp) — attach a timestamp to each item emitted by an Observable\n- [`Using`](operators/using) — create a disposable resource that has the same lifespan as the Observable\n\n## Conditional and Boolean Operators\n\nOperators that evaluate one or more Observables or items emitted by Observables\n\n- [`All`](operators/all) — determine whether all items emitted by an Observable meet some criteria\n- [`Amb`](operators/amb) — given two or more source Observables, emit all of the items from only the first of these Observables to emit an item\n- [`Contains`](operators/contains) — determine whether an Observable emits a particular item or not\n- [`DefaultIfEmpty`](operators/defaultifempty) — emit items from the source Observable, or a default item if the source Observable emits nothing\n- [`SequenceEqual`](operators/sequenceequal) — determine whether two Observables emit the same sequence of items\n- [`SkipUntil`](operators/skipuntil) — discard items emitted by an Observable until a second Observable emits an item\n- [`SkipWhile`](operators/skipwhile) — discard items emitted by an Observable until a specified condition becomes false\n- [`TakeUntil`](operators/takeuntil) — discard items emitted by an Observable after a second Observable emits an item or terminates\n- [`TakeWhile`](operators/takewhile) — discard items emitted by an Observable after a specified condition becomes false\n\n## Mathematical and Aggregate Operators\n\nOperators that operate on the entire sequence of items emitted by an Observable\n\n- [`Average`](operators/average) — calculates the average of numbers emitted by an Observable and emits this average\n- [`Concat`](operators/concat) — emit the emissions from two or more Observables without interleaving them\n- [`Count`](operators/count) — count the number of items emitted by the source Observable and emit only this value\n- [`Max`](operators/max) — determine, and emit, the maximum-valued item emitted by an Observable\n- [`Min`](operators/min) — determine, and emit, the minimum-valued item emitted by an Observable\n- [`Reduce`](operators/reduce) — apply a function to each item emitted by an Observable, sequentially, and emit the final value\n- [`Sum`](operators/sum) — calculate the sum of numbers emitted by an Observable and emit this sum\n\n## Backpressure Operators\n\n- [**backpressure operators**](operators/backpressure) — strategies for coping with Observables that produce items more rapidly than their observers consume them\n\n## Connectable Observable Operators\n\nSpecialty Observables that have more precisely-controlled subscription dynamics\n\n- [`Connect`](operators/connect) — instruct a connectable Observable to begin emitting items to its subscribers\n- [`Publish`](operators/publish) — convert an ordinary Observable into a connectable Observable\n- [`RefCount`](operators/refcount) — make a Connectable Observable behave like an ordinary Observable\n- [`Replay`](operators/replay) — ensure that all observers see the same sequence of emitted items, even if they subscribe after the Observable has begun emitting items\n\n## Operators to Convert Observables\n\n- [`To`](operators/to) — convert an Observable into another object or data structure\n\n## A Decision Tree of Observable Operators\n\nThis tree can help you find the ReactiveX Observable operator you’re looking for.\n\nI want to create a new Observable  \nthat emits a particular item  \n[Just](operators/just)\n\nthat was returned from a function called at subscribe-time  \n[Start](operators/start)\n\nthat was returned from an `Action`, `Callable`, `Runnable`, or something of that sort, called at subscribe-time  \n[From](operators/from)\n\nafter a specified delay  \n[Timer](operators/timer)\n\nthat pulls its emissions from a particular `Array`, `Iterable`, or something like that  \n[From](operators/from)\n\nby retrieving it from a Future  \n[Start](operators/start)\n\nthat obtains its sequence from a Future  \n[From](operators/from)\n\nthat emits a sequence of items repeatedly  \n[Repeat](operators/repeat)\n\nfrom scratch, with custom logic  \n[Create](operators/create)\n\nfor each observer that subscribes  \n[Defer](operators/defer)\n\nthat emits a sequence of integers  \n[Range](operators/range)\n\nat particular intervals of time  \n[Interval](operators/interval)\n\nafter a specified delay  \n[Timer](operators/timer)\n\nthat completes without emitting items  \n[Empty](operators/empty-never-throw)\n\nthat does nothing at all  \n[Never](operators/empty-never-throw)\n\nI want to create an Observable by combining other Observables  \nand emitting all of the items from all of the Observables in whatever order they are received  \n[Merge](operators/merge)\n\nand emitting all of the items from all of the Observables, one Observable at a time  \n[Concat](operators/concat)\n\nby combining the items from two or more Observables sequentially to come up with new items to emit  \nwhenever *each* of the Observables has emitted a new item  \n[Zip](operators/zip)\n\nwhenever *any* of the Observables has emitted a new item  \n[CombineLatest](operators/combinelatest)\n\nwhenever an item is emitted by one Observable in a window defined by an item emitted by another  \n[Join](operators/join)\n\nby means of `Pattern` and `Plan` intermediaries  \n[And/Then/When](operators/and-then-when)\n\nand emitting the items from only the most-recently emitted of those Observables  \n[Switch](operators/switch)\n\nI want to emit the items from an Observable after transforming them  \none at a time with a function  \n[Map](operators/map)\n\nby emitting all of the items emitted by corresponding Observables  \n[FlatMap](operators/flatmap)\n\none Observable at a time, in the order they are emitted  \n[ConcatMap](operators/flatmap)\n\nbased on all of the items that preceded them  \n[Scan](operators/scan)\n\nby attaching a timestamp to them  \n[Timestamp](operators/timestamp)\n\ninto an indicator of the amount of time that lapsed before the emission of the item  \n[TimeInterval](operators/timeinterval)\n\nI want to shift the items emitted by an Observable forward in time before reemitting them  \n[Delay](operators/delay)\n\nI want to transform items *and* notifications from an Observable into items and reemit them  \nby wrapping them in `Notification` objects  \n[Materialize](operators/materialize-dematerialize)\n\nwhich I can then unwrap again with  \n[Dematerialize](operators/materialize-dematerialize)\n\nI want to ignore all items emitted by an Observable and only pass along its completed/error notification  \n[IgnoreElements](operators/ignoreelements)\n\nI want to mirror an Observable but prefix items to its sequence  \n[StartWith](operators/startwith)\n\nonly if its sequence is empty  \n[DefaultIfEmpty](operators/defaultifempty)\n\nI want to collect items from an Observable and reemit them as buffers of items  \n[Buffer](operators/buffer)\n\ncontaining only the last items emitted  \n[TakeLastBuffer](operators/takelast)\n\nI want to split one Observable into multiple Observables  \n[Window](operators/window)\n\nso that similar items end up on the same Observable  \n[GroupBy](operators/groupby)\n\nI want to retrieve a particular item emitted by an Observable:  \nthe last item emitted before it completed  \n[Last](operators/last)\n\nthe sole item it emitted  \n[Single](operators/first)\n\nthe first item it emitted  \n[First](operators/first)\n\nI want to reemit only certain items from an Observable  \nby filtering out those that do not match some predicate  \n[Filter](operators/filter)\n\nthat is, only the first item  \n[First](operators/first)\n\nthat is, only the first item*s*  \n[Take](operators/take)\n\nthat is, only the last item  \n[Last](operators/last)\n\nthat is, only item *n*  \n[ElementAt](operators/elementat)\n\nthat is, only those items after the first items  \nthat is, after the first *n* items  \n[Skip](operators/skip)\n\nthat is, until one of those items matches a predicate  \n[SkipWhile](operators/skipwhile)\n\nthat is, after an initial period of time  \n[Skip](operators/skip)\n\nthat is, after a second Observable emits an item  \n[SkipUntil](operators/skipuntil)\n\nthat is, those items except the last items  \nthat is, except the last *n* items  \n[SkipLast](operators/skiplast)\n\nthat is, until one of those items matches a predicate  \n[TakeWhile](operators/takewhile)\n\nthat is, except items emitted during a period of time before the source completes  \n[SkipLast](operators/skiplast)\n\nthat is, except items emitted after a second Observable emits an item  \n[TakeUntil](operators/takeuntil)\n\nby sampling the Observable periodically  \n[Sample](operators/sample)\n\nby only emitting items that are not followed by other items within some duration  \n[Debounce](operators/debounce)\n\nby suppressing items that are duplicates of already-emitted items  \n[Distinct](operators/distinct)\n\nif they immediately follow the item they are duplicates of  \n[DistinctUntilChanged](operators/distinct)\n\nby delaying my subscription to it for some time after it begins emitting items  \n[DelaySubscription](operators/delay)\n\nI want to reemit items from an Observable only on condition that it was the first of a collection of Observables to emit an item  \n[Amb](operators/amb)\n\nI want to evaluate the entire sequence of items emitted by an Observable  \nand emit a single boolean indicating if *all* of the items pass some test  \n[All](operators/all)\n\nand emit a single boolean indicating if the Observable emitted *any* item (that passes some test)  \n[Contains](operators/contains)\n\nand emit a single boolean indicating if the Observable emitted *no* items  \n[IsEmpty](operators/contains)\n\nand emit a single boolean indicating if the sequence is identical to one emitted by a second Observable  \n[SequenceEqual](operators/sequenceequal)\n\nand emit the average of all of their values  \n[Average](operators/average)\n\nand emit the sum of all of their values  \n[Sum](operators/sum)\n\nand emit a number indicating how many items were in the sequence  \n[Count](operators/count)\n\nand emit the item with the maximum value  \n[Max](operators/max)\n\nand emit the item with the minimum value  \n[Min](operators/min)\n\nby applying an aggregation function to each item in turn and emitting the result  \n[Scan](operators/scan)\n\nI want to convert the entire sequence of items emitted by an Observable into some other data structure  \n[To](operators/to)\n\nI want an operator to operate on a particular [Scheduler](http://reactivex.io/scheduler.html)  \n[SubscribeOn](operators/subscribeon)\n\nwhen it notifies observers  \n[ObserveOn](operators/observeon)\n\nI want an Observable to invoke a particular action when certain events occur  \n[Do](operators/do)\n\nI want an Observable that will notify observers of an error  \n[Throw](operators/empty-never-throw)\n\nif a specified period of time elapses without it emitting an item  \n[Timeout](operators/timeout)\n\nI want an Observable to recover gracefully  \nfrom a timeout by switching to a backup Observable  \n[Timeout](operators/timeout)\n\nfrom an upstream error notification  \n[Catch](operators/catch)\n\nby attempting to resubscribe to the upstream Observable  \n[Retry](operators/retry)\n\nI want to create a resource that has the same lifespan as the Observable  \n[Using](operators/using)\n\nI want to subscribe to an Observable and receive a `Future` that blocks until the Observable completes  \n[Start](operators/start)\n\nI want an Observable that does not start emitting items to subscribers until asked  \n[Publish](operators/publish)\n\nand then only emits the last item in its sequence  \n[PublishLast](operators/publish)\n\nand then emits the complete sequence, even to those who subscribe after the sequence has begun  \n[Replay](operators/replay)\n\nbut I want it to go away once all of its subscribers unsubscribe  \n[RefCount](operators/refcount)\n\nand then I want to ask it to start  \n[Connect](operators/connect)\n\n#### See Also\n\n- [Which Operator do I use?](http://xgrommx.github.io/rx-book/content/which_operator_do_i_use/index.html) by Dennis Stoyanov (a similar decision tree, specific to RxJS operators)\n\n## An Alphabetical List of Observable Operators\n\nCanonical, core operator names are in **boldface**. Other entries represent language-specific variants of these operators or specialty operators outside of the main ReactiveX core set of operators.\n\n- [`Aggregate`](operators/reduce)\n- [`All`](operators/all)\n- [`Amb`](operators/amb)\n- [`ambArray`](operators/amb)\n- [`ambWith`](operators/amb)\n- [`and_`](operators/and-then-when)\n- [`And`](operators/and-then-when)\n- [`Any`](operators/contains)\n- [`apply`](operators/create)\n- [`as_blocking`](operators/to)\n- [`asObservable`](operators/from)\n- [`AssertEqual`](operators/sequenceequal)\n- [`asyncAction`](operators/start)\n- [`asyncFunc`](operators/start)\n- [`Average`](operators/average)\n- [`averageDouble`](operators/average)\n- [`averageFloat`](operators/average)\n- [`averageInteger`](operators/average)\n- [`averageLong`](operators/average)\n- [`blocking`](operators/to)\n- [`blockingFirst`](operators/first)\n- [`blockingForEach`](operators/subscribe)\n- [`blockingIterable`](operators/to)\n- [`blockingLast`](operators/last)\n- [`blockingLatest`](operators/to)\n- [`blockingMostRecent`](operators/to)\n- [`blockingNext`](operators/to)\n- [`blockingSingle`](operators/first)\n- [`blockingSubscribe`](operators/subscribe)\n- [`Buffer`](operators/buffer)\n- [`bufferWithCount`](operators/buffer)\n- [`bufferWithTime`](operators/buffer)\n- [`bufferWithTimeOrCount`](operators/buffer)\n- [`byLine`](operators/map)\n- [`cache`](operators/replay)\n- [`cacheWithInitialCapacity`](operators/replay)\n- [`case`](operators/defer)\n- [`Cast`](operators/map)\n- [`Catch`](operators/catch)\n- [`catchError`](operators/catch)\n- [`catchException`](operators/catch)\n- [`collect`](operators/reduce)\n- [`collect`](operators/filter) (RxScala version of **`Filter`**)\n- [`collectInto`](operators/reduce)\n- [`CombineLatest`](operators/combinelatest)\n- [`combineLatestDelayError`](operators/combinelatest)\n- [`combineLatestWith`](operators/combinelatest)\n- [`Concat`](operators/concat)\n- [`concat_all`](operators/flatmap)\n- [`concatAll`](operators/concat)\n- [`concatArray`](operators/concat)\n- [`concatArrayDelayError`](operators/concat)\n- [`concatArrayEager`](operators/concat)\n- [`concatDelayError`](operators/concat)\n- [`concatEager`](operators/concat)\n- [`concatMap`](operators/flatmap)\n- [`concatMapDelayError`](operators/flatmap)\n- [`concatMapEager`](operators/flatmap)\n- [`concatMapEagerDelayError`](operators/flatmap)\n- [`concatMapIterable`](operators/flatmap)\n- [`concatMapObserver`](operators/flatmap)\n- [`concatMapTo`](operators/flatmap)\n- [`concatWith`](operators/concat)\n- [`Connect`](operators/connect)\n- [`connect_forever`](operators/connect)\n- [`cons`](operators/startwith)\n- [`Contains`](operators/contains)\n- [`controlled`](operators/backpressure)\n- [`Count`](operators/count)\n- [`countLong`](operators/count)\n- [`Create`](operators/create)\n- [`cycle`](operators/repeat)\n- [`Debounce`](operators/debounce)\n- [`decode`](operators/from)\n- [`DefaultIfEmpty`](operators/defaultifempty)\n- [`Defer`](operators/defer)\n- [`deferFuture`](operators/start)\n- [`Delay`](operators/delay)\n- [`delaySubscription`](operators/delay)\n- [`delayWithSelector`](operators/delay)\n- [`Dematerialize`](operators/materialize-dematerialize)\n- [`Distinct`](operators/distinct)\n- [`distinctKey`](operators/distinct)\n- [`distinctUntilChanged`](operators/distinct)\n- [`distinctUntilKeyChanged`](operators/distinct)\n- [`Do`](operators/do)\n- [`doAction`](operators/do)\n- [`doAfterTerminate`](operators/do)\n- [`doOnComplete`](operators/do)\n- [`doOnCompleted`](operators/do)\n- [`doOnDispose`](operators/do)\n- [`doOnEach`](operators/do)\n- [`doOnError`](operators/do)\n- [`doOnLifecycle`](operators/do)\n- [`doOnNext`](operators/do)\n- [`doOnRequest`](operators/do)\n- [`doOnSubscribe`](operators/do)\n- [`doOnTerminate`](operators/do)\n- [`doOnUnsubscribe`](operators/do)\n- [`doseq`](operators/subscribe)\n- [`doWhile`](operators/repeat)\n- [`drop`](operators/skip)\n- [`dropRight`](operators/skiplast)\n- [`dropUntil`](operators/skipuntil)\n- [`dropWhile`](operators/skipwhile)\n- [`ElementAt`](operators/elementat)\n- [`ElementAtOrDefault`](operators/elementat)\n- [`Empty`](operators/empty-never-throw)\n- [`emptyObservable`](operators/empty-never-throw)\n- [`empty?`](operators/contains)\n- [`encode`](operators/map)\n- [`ensures`](operators/do)\n- [`error`](operators/empty-never-throw)\n- [`every`](operators/all)\n- [`exclusive`](operators/switch)\n- [`exists`](operators/contains)\n- [`expand`](operators/flatmap)\n- [`failWith`](operators/empty-never-throw)\n- [`Filter`](operators/filter)\n- [`filterNot`](operators/filter)\n- [`Finally`](operators/do)\n- [`finallyAction`](operators/do)\n- [`finallyDo`](operators/do)\n- [`find`](operators/contains)\n- [`findIndex`](operators/contains)\n- [`First`](operators/first)\n- [`firstElement`](operators/first)\n- [`FirstOrDefault`](operators/first)\n- [`firstOrElse`](operators/first)\n- [`FlatMap`](operators/flatmap)\n- [`flatMapFirst`](operators/flatmap)\n- [`flatMapIterable`](operators/flatmap)\n- [`flatMapIterableWith`](operators/flatmap)\n- [`flatMapLatest`](operators/flatmap)\n- [`flatMapObserver`](operators/flatmap)\n- [`flatMapWith`](operators/flatmap)\n- [`flatMapWithMaxConcurrent`](operators/flatmap)\n- [`flat_map_with_index`](operators/flatmap)\n- [`flatten`](operators/merge)\n- [`flattenDelayError`](operators/merge)\n- [`foldl`](operators/reduce)\n- [`foldLeft`](operators/reduce)\n- [`for`](operators/flatmap)\n- [`forall`](operators/all)\n- [`ForEach`](operators/subscribe)\n- [`forEachFuture`](operators/start)\n- [`forEachWhile`](operators/subscribe)\n- [`forIn`](operators/flatmap)\n- [`forkJoin`](operators/zip)\n- [`From`](operators/from)\n- [`fromAction`](operators/from)\n- [`fromArray`](operators/from)\n- [`FromAsyncPattern`](operators/from)\n- [`fromCallable`](operators/from)\n- [`fromCallback`](operators/from)\n- [`FromEvent`](operators/from)\n- [`FromEventPattern`](operators/from)\n- [`fromFunc0`](operators/from)\n- [`fromFuture`](operators/from)\n- [`fromIterable`](operators/from)\n- [`fromIterator`](operators/from)\n- [`from_list`](operators/from)\n- [`fromNodeCallback`](operators/from)\n- [`fromPromise`](operators/from)\n- [`fromPublisher`](operators/from)\n- [`fromRunnable`](operators/from)\n- [`Generate`](operators/create)\n- [`generateWithAbsoluteTime`](operators/create)\n- [`generateWithRelativeTime`](operators/create)\n- [`generator`](operators/create)\n- [`GetEnumerator`](operators/to)\n- [`getIterator`](operators/to)\n- [`GroupBy`](operators/groupby)\n- [`GroupByUntil`](operators/groupby)\n- [`GroupJoin`](operators/join)\n- [`head`](operators/first)\n- [`headOption`](operators/first)\n- [`headOrElse`](operators/first)\n- [`if`](operators/defer)\n- [`ifThen`](operators/defer)\n- [`IgnoreElements`](operators/ignoreelements)\n- [`indexOf`](operators/contains)\n- [`interleave`](operators/merge)\n- [`interpose`](operators/to)\n- [`Interval`](operators/interval)\n- [`intervalRange`](operators/range)\n- [`into`](operators/reduce)\n- [`isEmpty`](operators/contains)\n- [`items`](operators/just)\n- [`Join`](operators/join)\n- [`join`](operators/sum) (string)\n- [`jortSort`](operators/all)\n- [`jortSortUntil`](operators/all)\n- [`Just`](operators/just)\n- [`keep`](operators/map)\n- [`keep-indexed`](operators/map)\n- [`Last`](operators/last)\n- [`lastElement`](operators/last)\n- [`lastOption`](operators/last)\n- [`LastOrDefault`](operators/last)\n- [`lastOrElse`](operators/last)\n- [`Latest`](operators/first)\n- [`latest`](operators/switch) (Rx.rb version of **`Switch`**)\n- [`length`](operators/count)\n- [`let`](operators/publish)\n- [`letBind`](operators/publish)\n- [`lift`](implement-operator)\n- [`limit`](operators/take)\n- [`LongCount`](operators/count)\n- [`ManySelect`](operators/flatmap)\n- [`Map`](operators/map)\n- [`map`](operators/zip) (RxClojure version of **`Zip`**)\n- [`MapCat`](operators/flatmap)\n- [`mapCat`](operators/zip) (RxClojure version of **`Zip`**)\n- [`map-indexed`](operators/map)\n- [`mapTo`](operators/map)\n- [`mapWithIndex`](operators/map)\n- [`Materialize`](operators/materialize-dematerialize)\n- [`Max`](operators/max)\n- [`MaxBy`](operators/max)\n- [`Merge`](operators/merge)\n- [`mergeAll`](operators/merge)\n- [`mergeArray`](operators/merge)\n- [`mergeArrayDelayError`](operators/merge)\n- [`merge_concurrent`](operators/merge)\n- [`mergeDelayError`](operators/merge)\n- [`mergeObservable`](operators/merge)\n- [`mergeWith`](operators/merge)\n- [`Min`](operators/min)\n- [`MinBy`](operators/min)\n- [`MostRecent`](operators/first)\n- [`Multicast`](operators/publish)\n- [`multicastWithSelector`](operators/publish)\n- [`nest`](operators/to)\n- [`Never`](operators/empty-never-throw)\n- [`Next`](operators/takelast)\n- [`Next`](operators/first) (BlockingObservable version)\n- [`none`](operators/contains)\n- [`nonEmpty`](operators/contains)\n- [`nth`](operators/elementat)\n- [`ObserveOn`](operators/observeon)\n- [`ObserveOnDispatcher`](operators/observeon)\n- [`observeSingleOn`](operators/observeon)\n- [`of`](operators/from)\n- [`of_array`](operators/from)\n- [`ofArrayChanges`](operators/from)\n- [`of_enumerable`](operators/from)\n- [`of_enumerator`](operators/from)\n- [`ofObjectChanges`](operators/from)\n- [`OfType`](operators/filter)\n- [`ofWithScheduler`](operators/from)\n- [`onBackpressureBlock`](operators/backpressure)\n- [`onBackpressureBuffer`](operators/backpressure)\n- [`onBackpressureDrop`](operators/backpressure)\n- [`OnErrorResumeNext`](operators/catch)\n- [`onErrorReturn`](operators/catch)\n- [`onErrorReturnItem`](operators/catch)\n- [`onExceptionResumeNext`](operators/catch)\n- [`onTerminateDetach`](operators/do)\n- [`orElse`](operators/defaultifempty)\n- [`pairs`](operators/from)\n- [`pairwise`](operators/buffer)\n- [`partition`](operators/groupby)\n- [`partition-all`](operators/window)\n- [`pausable`](operators/backpressure)\n- [`pausableBuffered`](operators/backpressure)\n- [`pluck`](operators/map)\n- [`product`](operators/sum)\n- [`Publish`](operators/publish)\n- [`PublishLast`](operators/publish)\n- [`publish_synchronized`](operators/replay)\n- [`publishValue`](operators/publish)\n- [`raise_error`](operators/empty-never-throw)\n- [`Range`](operators/range)\n- [`Reduce`](operators/reduce)\n- [`reduceWith`](operators/reduce)\n- [`reductions`](operators/scan)\n- [`RefCount`](operators/refcount)\n- [`Repeat`](operators/repeat)\n- [`repeat_infinitely`](operators/repeat)\n- [`repeatUntil`](operators/repeat)\n- [`repeatWhen`](operators/repeat)\n- [`Replay`](operators/replay)\n- [`rescue_error`](operators/catch)\n- [`rest`](operators/first)\n- [`Retry`](operators/retry)\n- [`retry_infinitely`](operators/retry)\n- [`retryUntil`](operators/retry)\n- [`retryWhen`](operators/retry)\n- [`Return`](operators/just)\n- [`returnElement`](operators/just)\n- [`returnValue`](operators/just)\n- [`runAsync`](operators/from)\n- [`safeSubscribe`](operators/subscribe)\n- [`Sample`](operators/sample)\n- [`Scan`](operators/scan)\n- [`scanWith`](operators/scan)\n- [`scope`](operators/using)\n- [`Select`](operators/map) (alternate name of **`Map`**)\n- [`select`](operators/filter) (alternate name of **`Filter`**)\n- [`selectConcat`](operators/flatmap)\n- [`selectConcatObserver`](operators/flatmap)\n- [`SelectMany`](operators/flatmap)\n- [`selectManyObserver`](operators/flatmap)\n- [`select_switch`](operators/switch)\n- [`selectSwitch`](operators/flatmap)\n- [`selectSwitchFirst`](operators/flatmap)\n- [`selectWithMaxConcurrent`](operators/flatmap)\n- [`select_with_index`](operators/filter)\n- [`seq`](operators/from)\n- [`SequenceEqual`](operators/sequenceequal)\n- [`sequence_eql?`](operators/sequenceequal)\n- [`SequenceEqualWith`](operators/sequenceequal)\n- [`Serialize`](operators/serialize)\n- [`share`](operators/refcount)\n- [`shareReplay`](operators/replay)\n- [`shareValue`](operators/refcount)\n- [`Single`](operators/first)\n- [`singleElement`](operators/first)\n- [`SingleOrDefault`](operators/first)\n- [`singleOption`](operators/first)\n- [`singleOrElse`](operators/first)\n- [`size`](operators/count)\n- [`Skip`](operators/skip)\n- [`SkipLast`](operators/skiplast)\n- [`skipLastWithTime`](operators/skiplast)\n- [`SkipUntil`](operators/skipuntil)\n- [`skipUntilWithTime`](operators/skipuntil)\n- [`SkipWhile`](operators/skipwhile)\n- [`skipWhileWithIndex`](operators/skipwhile)\n- [`skip_with_time`](operators/skip)\n- [`slice`](operators/filter)\n- [`sliding`](operators/window)\n- [`slidingBuffer`](operators/buffer)\n- [`some`](operators/contains)\n- [`sort`](operators/to)\n- [`sorted`](operators/to)\n- [`sort-by`](operators/to)\n- [`sorted-list-by`](operators/to)\n- [`split`](operators/flatmap)\n- [`split-with`](operators/groupby)\n- [`Start`](operators/start)\n- [`startAsync`](operators/start)\n- [`startFuture`](operators/start)\n- [`StartWith`](operators/startwith)\n- [`startWithArray`](operators/startwith)\n- [`stringConcat`](operators/sum)\n- [`stopAndWait`](operators/backpressure)\n- [`subscribe`](operators/subscribe)\n- [`subscribeActual`](operators/subscribe)\n- [`SubscribeOn`](operators/subscribeon)\n- [`SubscribeOnDispatcher`](operators/subscribeon)\n- [`subscribeOnCompleted`](operators/subscribe)\n- [`subscribeOnError`](operators/subscribe)\n- [`subscribeOnNext`](operators/subscribe)\n- [`subscribeWith`](operators/subscribe)\n- [`Sum`](operators/sum)\n- [`sumDouble`](operators/sum)\n- [`sumFloat`](operators/sum)\n- [`sumInteger`](operators/sum)\n- [`sumLong`](operators/sum)\n- [`Switch`](operators/switch)\n- [`switchCase`](operators/defer)\n- [`switchIfEmpty`](operators/defaultifempty)\n- [`switchLatest`](operators/switch)\n- [`switchMap`](operators/flatmap)\n- [`switchMapDelayError`](operators/flatmap)\n- [`switchOnNext`](operators/switch)\n- [`switchOnNextDelayError`](operators/switch)\n- [`Synchronize`](operators/serialize)\n- [`Take`](operators/take)\n- [`take_with_time`](operators/take)\n- [`takeFirst`](operators/first)\n- [`TakeLast`](operators/takelast)\n- [`takeLastBuffer`](operators/takelast)\n- [`takeLastBufferWithTime`](operators/takelast)\n- [`takeLastWithTime`](operators/takelast)\n- [`takeRight`](operators/last) (see also: [`TakeLast`](operators/takelast))\n- [`TakeUntil`](operators/takeuntil)\n- [`takeUntilWithTime`](operators/takeuntil)\n- [`TakeWhile`](operators/takewhile)\n- [`takeWhileWithIndex`](operators/takewhile)\n- [`tail`](operators/takelast)\n- [`tap`](operators/do)\n- [`tapOnCompleted`](operators/do)\n- [`tapOnError`](operators/do)\n- [`tapOnNext`](operators/do)\n- [`Then`](operators/and-then-when)\n- [`thenDo`](operators/and-then-when)\n- [`Throttle`](operators/debounce)\n- [`throttleFirst`](operators/sample)\n- [`throttleLast`](operators/sample)\n- [`throttleWithSelector`](operators/debounce)\n- [`throttleWithTimeout`](operators/debounce)\n- [`Throw`](operators/empty-never-throw)\n- [`throwError`](operators/empty-never-throw)\n- [`throwException`](operators/empty-never-throw)\n- [`TimeInterval`](operators/timeinterval)\n- [`Timeout`](operators/timeout)\n- [`timeoutWithSelector`](operators/timeout)\n- [`Timer`](operators/timer)\n- [`Timestamp`](operators/timestamp)\n- [`To`](operators/to)\n- [`to_a`](operators/to)\n- [`ToArray`](operators/to)\n- [`ToAsync`](operators/start)\n- [`toBlocking`](operators/to)\n- [`toBuffer`](operators/to)\n- [`to_dict`](operators/to)\n- [`ToDictionary`](operators/to)\n- [`ToEnumerable`](operators/to)\n- [`ToEvent`](operators/to)\n- [`ToEventPattern`](operators/to)\n- [`ToFlowable`](operators/to)\n- [`ToFuture`](operators/to)\n- [`to_h`](operators/to)\n- [`toIndexedSeq`](operators/to)\n- [`toIterable`](operators/to)\n- [`toIterator`](operators/to)\n- [`ToList`](operators/to)\n- [`ToLookup`](operators/to)\n- [`toMap`](operators/to)\n- [`toMultiMap`](operators/to)\n- [`ToObservable`](operators/from)\n- [`toSet`](operators/to)\n- [`toSortedList`](operators/to)\n- [`toStream`](operators/to)\n- [`ToTask`](operators/to)\n- [`toTraversable`](operators/to)\n- [`toVector`](operators/to)\n- [`tumbling`](operators/window)\n- [`tumblingBuffer`](operators/buffer)\n- [`unsafeCreate`](operators/create)\n- [`unsubscribeOn`](operators/subscribeon)\n- [`Using`](operators/using)\n- [`When`](operators/and-then-when)\n- [`Where`](operators/filter)\n- [`while`](operators/repeat)\n- [`whileDo`](operators/repeat)\n- [`Window`](operators/window)\n- [`windowWithCount`](operators/window)\n- [`windowWithTime`](operators/window)\n- [`windowWithTimeOrCount`](operators/window)\n- [`windowed`](operators/backpressure)\n- [`withFilter`](operators/filter)\n- [`withLatestFrom`](operators/combinelatest)\n- [`Zip`](operators/zip)\n- [`zipArray`](operators/zip)\n- [`zipIterable`](operators/zip)\n- [`zipWith`](operators/zip)\n- [`zipWithIndex`](operators/zip)\n- [`++`](operators/concat)\n- [`+:`](operators/startwith)\n- [`:+`](operators/just)\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html)"
- name: Join
  id: documentation/operators/join
  summary: The Join operator combines the items emitted by two Observables, and selects which items to combine based on duration-windows that you define on a per-item basis
  description: "# Join\n\ncombine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable\n\nThe `Join` operator combines the items emitted by two Observables, and selects which items to combine based on duration-windows that you define on a per-item basis. You implement these windows as Observables whose lifespans begin with each item emitted by either Observable. When such a window-defining Observable either emits an item or completes, the window for the item it is associated with closes. So long as an item’s window is open, it will combine with any item emitted by the other Observable. You define the function by which the items combine.\n\nMost ReactiveX implementations that have a `Join` operator also have a `GroupJoin` operator that is similar, except that the function you define to combine items emitted by the two Observables pairs individual items emitted by the source Observable not with an item from the second Observable, but with an Observable that emits items from the second Observable that fall in the same window.\n\n#### See Also\n\n- [CombineLatest](combinelatest)\n- [Zip](zip)\n- [Introduction to Rx: Join](http://www.introtorx.com/Content/v1.0.10621.0/17_SequencesOfCoincidence.html#Join)\n- [Introduction to Rx: GroupJoin](http://www.introtorx.com/Content/v1.0.10621.0/17_SequencesOfCoincidence.html#GroupJoin)\n- [101 Rx Samples: GroupJoin — Joins two streams by matching by one of their attributes](http://rxwiki.wikidot.com/101samples#toc39)\n\n## Language-Specific Information\n\n### RxGroovy `join groupJoin`\n\nThe `join` operator takes four parameters:\n\n1.  the second Observable to combine with the source Observable\n2.  a function that accepts an item from the source Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the second Observable\n3.  a function that accepts an item from the second Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the first Observable\n4.  a function that accepts an item from the first Observable and an item from the second Observable and returns an item to be emitted by the Observable returned from `join`\n\n`join` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`Join(Observable,Func1,Func1,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#join(rx.Observable,%20rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func2))\n\nThe `groupJoin` operator takes four parameters:\n\n1.  the second Observable to combine with the source Observable\n2.  a function that accepts an item from the source Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the second Observable\n3.  a function that accepts an item from the second Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the first Observable\n4.  a function that accepts an item from the first Observable and an Observable that emits items from the second Observable and returns an item to be emitted by the Observable returned from `groupJoin`\n\n`groupJoin` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`groupJoin(Observable,Func1,Func1,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#groupJoin(rx.Observable,%20rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func2))\n\nNote that there is also a `join` operator in the optional `StringObservable` class. It converts an Observable that emits a sequence of strings into an Observable that emits a single string that concatenates them all, separating them by a specified string delimiter.\n\n### RxJava 1․x `join groupJoin`\n\nThe `join` operator takes four parameters:\n\n1.  the second Observable to combine with the source Observable\n2.  a function that accepts an item from the source Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the second Observable\n3.  a function that accepts an item from the second Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the first Observable\n4.  a function that accepts an item from the first Observable and an item from the second Observable and returns an item to be emitted by the Observable returned from `join`\n\n`join` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`Join(Observable,Func1,Func1,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#join(rx.Observable,%20rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func2))\n\nThe `groupJoin` operator takes four parameters:\n\n1.  the second Observable to combine with the source Observable\n2.  a function that accepts an item from the source Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the second Observable\n3.  a function that accepts an item from the second Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the first Observable\n4.  a function that accepts an item from the first Observable and an Observable that emits items from the second Observable and returns an item to be emitted by the Observable returned from `groupJoin`\n\n`groupJoin` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`groupJoin(Observable,Func1,Func1,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#groupJoin(rx.Observable,%20rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func2))\n\nNote that there is also a `join` operator in the optional `StringObservable` class. It converts an Observable that emits a sequence of strings into an Observable that emits a single string that concatenates them all, separating them by a specified string delimiter.\n\n### RxJS `join groupJoin`\n\nThe `join` operator takes four parameters:\n\n1.  the second Observable to combine with the source Observable\n2.  a function that accepts an item from the source Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the second Observable\n3.  a function that accepts an item from the second Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the first Observable\n4.  a function that accepts an item from the first Observable and an item from the second Observable and returns an item to be emitted by the Observable returned from `join`\n\n#### Sample Code\n\n``` javascript\nvar xs = Rx.Observable.interval(100)\n    .map(function (x) { return 'first' + x; });\n\nvar ys = Rx.Observable.interval(100)\n    .map(function (x) { return 'second' + x; });\n\nvar source = xs\n    .join(\n        ys,\n        function () { return Rx.Observable.timer(0); },\n        function () { return Rx.Observable.timer(0); },\n        function (x, y) { return x + y; }\n    )\n    .take(5);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: first0second0\nNext: first1second1\nNext: first2second2\nNext: first3second3\nNext: first4second4\nCompleted\n```\n\nThe `groupJoin` operator takes four parameters:\n\n1.  the second Observable to combine with the source Observable\n2.  a function that accepts an item from the source Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the second Observable\n3.  a function that accepts an item from the second Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the first Observable\n4.  a function that accepts an item from the first Observable and an Observable that emits items from the second Observable and returns an item to be emitted by the Observable returned from `groupJoin`\n\n#### Sample Code\n\n``` javascript\nar xs = Rx.Observable.interval(100)\n    .map(function (x) { return 'first' + x; });\n\nvar ys = Rx.Observable.interval(100)\n    .map(function (x) { return 'second' + x; });\n\nvar source = xs.groupJoin(\n    ys,\n    function () { return Rx.Observable.timer(0); },\n    function () { return Rx.Observable.timer(0); },\n    function (x, yy) {\n        return yy.select(function (y) {\n            return x + y;\n        })\n    }).mergeAll().take(5);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: first0second0\nNext: first1second1\nNext: first2second2\nNext: first3second3\nNext: first4second4\nCompleted\n```\n\n`join` and `groupJoin` are found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.coincidence.js`\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/join.html](http://reactivex.io/documentation/operators/join.html)"
- name: Just
  id: documentation/operators/just
  summary: The Just operator converts an item into an Observable that emits that item
  description: "# Just\n\ncreate an Observable that emits a particular item\n\nThe Just operator converts an item into an Observable that emits that item.\n\nJust is similar to From, but note that From will dive into an array or an iterable or something of that sort to pull out items to emit, while Just will simply emit the array or iterable or what-have-you as it is, unchanged, as a single item.\n\nNote that if you pass `null` to Just, it will return an Observable that *emits* `null` as an item. Do not make the mistake of assuming that this will return an empty Observable (one that emits no items at all). For that, you will need the [Empty](empty-never-throw) operator.\n\n#### See Also\n\n- [From](from)\n- [Repeat](repeat)\n- [Start](start)\n- [Timer](timer)\n- [Introduction to Rx: Return](http://www.introtorx.com/Content/v1.0.10621.0/04_CreatingObservableSequences.html#ObservableReturn)\n- [RxJava Tutorial 03: Observable from, just, & create methods](https://www.youtube.com/watch?v=sDqrlNprY24)\n\n## Language-Specific Information\n\n### RxGroovy `just`\n\nRxGroovy implements this operator as `just`. It accepts between one and nine items as parameters, and returns an Observable that emits these items in the same order as they are given in the parameter list.\n\n`just` does not by default operate on any particular [Scheduler](../scheduler).\n\n#### Sample Code\n\n``` groovy\n// Observable emits \"some string\" as a single item\ndef observableThatEmitsAString = Observable.just(\"some string\"); \n// Observable emits the list [1, 2, 3, 4, 5] as a single item\ndef observableThatEmitsAList = Observable.just([1, 2, 3, 4, 5]); \n// Observable emits 1, 2, 3, 4, and 5 as distinct items\ndef observableThatEmitsSeveralNumbers = Observable.just( 1, 2, 3, 4, 5 );\n```\n\n- Javadoc: [`just(item)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#just(T)) (there are also versions that accept between two and nine items as parameters)\n\n### RxJava 1․x `just`\n\nRxJava implements this operator as `just`. It accepts between one and nine items as parameters, and returns an Observable that emits these items in the same order as they are given in the parameter list.\n\n`just` does not by default operate on any particular [Scheduler](../scheduler).\n\n#### Sample Code\n\n``` java\nObservable.just(1, 2, 3)\n          .subscribe(new Subscriber<Integer>() {\n        @Override\n        public void onNext(Integer item) {\n            System.out.println(\"Next: \" + item);\n        }\n\n        @Override\n        public void onError(Throwable error) {\n            System.err.println(\"Error: \" + error.getMessage());\n        }\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"Sequence complete.\");\n        }\n    });\n```\n\n``` javascript\nNext: 1\nNext: 2\nNext: 3\nSequence complete.\n```\n\n- Javadoc: [`just(item)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#just(T)) (there are also versions that accept between two and nine items as parameters)\n\n### RxJS `just return`\n\nRxJS implements this operator as `return` and as `just` (two names for the same operator with the same behavior). It accepts a single item as a parameter and returns an Observable that emits that single item as its sole emission.\n\n`return`/`just` operates by default on the `immediate` [Scheduler](../scheduler), but you can also pass in a Scheduler of your choosing as an optional second parameter, in which case it will operate on that Scheduler instead.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.just(42);\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 42\nCompleted\n```\n\n`return`/`just` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `of`\n\nRxPHP implements this operator as `of`.\n\nReturns an observable sequence that contains a single element.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/of/of.php\n\n\n$source =  \\Rx\\Observable::of(42);\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 42\nComplete!\n```\n\n### RxSwift `just sequenceOf`\n\nIn Swift, this is implemented using the `Observable.just` class method.\n\nThe parameter, whether a tuple (i.e. `(1, 2, 3)`) or an array (i.e. `[1,2,3]`) is produced as one emission.\n\n#### Sample Code\n\n``` swift\nlet source = Observable.just(1, 2, 3)\n\nsource.subscribe {\n    print($0)\n}\n\nlet source2 = Observable.just([1,2,3])\n\nsource2.subscribe {\n    print($0)\n}\n```\n\n``` javascript\nnext((1, 2, 3))\ncompleted\nnext([1, 2, 3])\ncompleted\n```\n\nThe difference between this and `Observable.from` is that the latter's parameter is an array or a sequence, and emits each of its element as one emission.\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/just.html](http://reactivex.io/documentation/operators/just.html)"
- name: Last
  id: documentation/operators/last
  summary: If you are only interested in the last item emitted by an Observable, or the last item that meets some criteria, you can filter the Observable with the Last operator
  description: "# Last\n\nemit only the last item (or the last item that meets some condition) emitted by an Observable\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#last)\n\nIf you are only interested in the last item emitted by an Observable, or the last item that meets some criteria, you can filter the Observable with the Last operator.\n\nIn some implementations, `Last` is not implemented as a filtering operator that returns an Observable, but as a blocking function that returns a particular item when the source Observable terminates. In those implementations, if you instead want a filtering operator, you may have better luck with [`TakeLast(1)`](take).\n\n#### See Also\n\n- [ElementAt](elementat)\n- [First](first)\n- [Take](take)\n- [TakeLast](takelast)\n- [Introduction to Rx: Last](http://www.introtorx.com/Content/v1.0.10621.0/07_Aggregation.html#Last)\n- [RxMarbles: `last`](http://rxmarbles.com/#last)\n\n## Language-Specific Information\n\n### RxGroovy `last lastOrDefault`\n\nIn RxGroovy, this filtering operator is implemented as `last` and `lastOrDefault`.\n\nSomewhat confusingly, there are also `BlockingObservable` operators called `last` and `lastOrDefault` that block and then return items, rather than immediately returning Observables.\n\n### The Filtering Operators\n\nTo filter an Observable so that only its last emission is emitted, use the `last` operator with no parameters.\n\n- Javadoc: [`last()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#last())\n\nYou can also pass a predicate function to `last`, in which case it will produce an Observable that emits only the last item from the source Observable that the predicate evaluates as `true`.\n\n- Javadoc: [`last(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#last(rx.functions.Func1))\n\nThe `lastOrDefault` operator is similar to `last`, but you pass it a default item that it can emit if the source Observable fails to emit any items.\n\n- Javadoc: [`lastOrDefault(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#lastOrDefault(T))\n\n`lastOrDefault` also has a variant to which you can pass a predicate function, so that its Observable will emit the last item from the source Observable that the predicate evaluates as `true`, or the default item if no items emitted by the source Observable pass the predicate.\n\n- Javadoc: [`lastOrDefault(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#lastOrDefault(T))\n\n`last` and `lastOrDefault` do not by default operate on any particular [Scheduler](../scheduler).\n\n### The `BlockingObservable` Methods\n\nThe `BlockingObservable` methods do not transform an Observable into another, filtered Observable, but rather they break out of the Observable cascade, blocking until the Observable emits the desired item, and then return that item itself.\n\nTo turn an Observable into a `BlockingObservable` so that you can use these methods, you can use either the `Observable.toBlocking` or `BlockingObservable.from` methods.\n\n- Javadoc: [`Observable.toBlocking()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toBlocking())\n- Javadoc: [`BlockingObservable.from(Observable)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#from(rx.Observable))\n\nTo retrieve the last emission from a `BlockingObservable`, use the `last` method with no parameters.\n\n- Javadoc: [`BlockingObservable.last()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#last())\n\nYou can also pass a predicate function to the `last` method to retrieve the last emission from a `BlockingObservable` that satisfies the predicate.\n\n- Javadoc: [`BlockingObservable.last(Func1)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#last(rx.functions.Func1))\n\nAs with the filtering operators, the `last` method of `BlockingObservable` will throw a `NoSuchElementException` if there is no last element in the source `BlockingObservable`. To return a default item instead in such cases, use the `lastOrDefault` method.\n\n- Javadoc: [`BlockingObservable.lastOrDefault()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#lastOrDefault(T))\n\nAnd, as with `last`, there is a `lastOrDefault` variant that takes a predicate function as an argument and retrieves the last item from the source `BlockingObservable` that satisfies that predicate, or a default item instead if no satisfying item was emitted.\n\n- Javadoc: [`BlockingObservable.lastOrDefault(Func1)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#lastOrDefault(T,%20rx.functions.Func1))\n\n### RxJava 1․x `last lastOrDefault`\n\nIn RxJava, this filtering operator is implemented as `last` and `lastOrDefault`.\n\nSomewhat confusingly, there are also `BlockingObservable` operators called `last` and `lastOrDefault` that block and then return items, rather than immediately returning Observables.\n\n### The Filtering Operators\n\nTo filter an Observable so that only its last emission is emitted, use the `last` operator with no parameters.\n\n#### Sample Code\n\n``` java\nObservable.just(1, 2, 3)\n          .last()\n          .subscribe(new Subscriber<Integer>() {\n        @Override\n        public void onNext(Integer item) {\n            System.out.println(\"Next: \" + item);\n        }\n\n        @Override\n        public void onError(Throwable error) {\n            System.err.println(\"Error: \" + error.getMessage());\n        }\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"Sequence complete.\");\n        }\n    });\n```\n\n``` javascript\nNext: 3\nSequence complete.\n```\n\n- Javadoc: [`last()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#last())\n\nYou can also pass a predicate function to `last`, in which case it will produce an Observable that emits only the last item from the source Observable that the predicate evaluates as `true`.\n\n- Javadoc: [`last(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#last(rx.functions.Func1))\n\nThe `lastOrDefault` operator is similar to `last`, but you pass it a default item that it can emit if the source Observable fails to emit any items.\n\n- Javadoc: [`lastOrDefault(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#lastOrDefault(T))\n\n`lastOrDefault` also has a variant to which you can pass a predicate function, so that its Observable will emit the last item from the source Observable that the predicate evaluates as `true`, or the default item if no items emitted by the source Observable pass the predicate.\n\n- Javadoc: [`lastOrDefault(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#lastOrDefault(T))\n\n`last` and `lastOrDefault` do not by default operate on any particular [Scheduler](../scheduler).\n\n### The `BlockingObservable` Methods\n\nThe `BlockingObservable` methods do not transform an Observable into another, filtered Observable, but rather they break out of the Observable cascade, blocking until the Observable emits the desired item, and then return that item itself.\n\nTo turn an Observable into a `BlockingObservable` so that you can use these methods, you can use either the `Observable.toBlocking` or `BlockingObservable.from` methods.\n\n- Javadoc: [`Observable.toBlocking()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toBlocking())\n- Javadoc: [`BlockingObservable.from(Observable)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#from(rx.Observable))\n\nTo retrieve the last emission from a `BlockingObservable`, use the `last` method with no parameters.\n\n- Javadoc: [`BlockingObservable.last()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#last())\n\nYou can also pass a predicate function to the `last` method to retrieve the last emission from a `BlockingObservable` that satisfies the predicate.\n\n- Javadoc: [`BlockingObservable.last(Func1)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#last(rx.functions.Func1))\n\nAs with the filtering operators, the `last` method of `BlockingObservable` will throw a `NoSuchElementException` if there is no last element in the source `BlockingObservable`. To return a default item instead in such cases, use the `lastOrDefault` method.\n\n- Javadoc: [`BlockingObservable.lastOrDefault()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#lastOrDefault(T))\n\nAnd, as with `last`, there is a `lastOrDefault` variant that takes a predicate function as an argument and retrieves the last item from the source `BlockingObservable` that satisfies that predicate, or a default item instead if no satisfying item was emitted.\n\n- Javadoc: [`BlockingObservable.lastOrDefault(Func1)`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#lastOrDefault(T,%20rx.functions.Func1))\n\n### RxJS `last`\n\nRxJS implements the `last` operator. It optionally takes a predicate function as a parameter, in which case, rather than emitting the last item from the source Observable, the resulting Observable will emit the last item from the source Observable that satisfies the predicate.\n\nThe predicate function itself takes three arguments:\n\n1.  the item from the source Observable to be, or not be, filtered\n2.  the zero-based index of this item in the source Observable’s sequence\n3.  the source Observable object\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 10)\n    .last(function (x, idx, obs) { return x % 2 === 1; });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 8\nCompleted\n```\n\nIf the source Observable emits no items (or no items that match the predicate), `last` will terminate with a “`Sequence contains no elements.`” `onError` notification.\n\nIf instead you want the Observable to emit a default value in such a case, you can pass a second parameter (named `defaultValue`) to `last`:\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 10)\n    .last(function (x, idx, obs) { return x > 42; }, 88 );\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 88\nCompleted\n```\n\n`last` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\nIt requires one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/last.html](http://reactivex.io/documentation/operators/last.html)"
- name: Map
  id: documentation/operators/map
  summary: The Map operator applies a function of your choosing to each item emitted by the source Observable, and returns an Observable that emits the results of these function applications
  description: "# Map\n\ntransform the items emitted by an Observable by applying a function to each item\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#map)\n\nThe Map operator applies a function of your choosing to each item emitted by the source Observable, and returns an Observable that emits the results of these function applications.\n\n#### See Also\n\n- [FlatMap](flatmap)\n- [Introduction to Rx: Select](http://www.introtorx.com/Content/v1.0.10621.0/08_Transformation.html#Select)\n- [RxMarbles: `map`](http://rxmarbles.com/#map)\n- [101 Rx Samples: Select — Indexed](http://rxwiki.wikidot.com/101samples#toc22)\n- [Using the map method with Observable](https://egghead.io/lessons/javascript-using-the-map-method-with-observable) by Jafar Husain (JavaScript Video Tutorial)\n\n## Language-Specific Information\n\n### RxGroovy `byLine cast encode map`\n\nRxGroovy implements this operator as `map`. For example, the following code maps a function that squares the incoming value onto the values in `numbers`:\n\n#### Sample Code\n\n``` javascript\nnumbers = Observable.from([1, 2, 3, 4, 5]);\n\nnumbers.map({it * it}).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n1\n4\n9\n16\n25\nSequence complete\n```\n\nThis operator does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`map(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#map(rx.functions.Func1))\n\nThe `cast` operator is a specialized version of Map that transforms each item from the source Observable by casting it into a particular Class before reemitting it.\n\n- Javadoc: [`cast(Class)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#cast(java.lang.Class))\n\nIn the `StringObservable` class that is not part of the RxGroovy core there is also a specialty mapping operator, `encode`, that transforms an Observable that emits strings into an Observable that emits byte arrays that respect character boundaries of multibyte characters in the original strings.\n\nAlso in the `StringObservable` class that is not part of the RxGroovy core there is a specialty mapping operator called `byLine`, that transforms an Observable that emits strings into an Observable that emits lines of text, by buffering the strings from the source Observable until a line-feed is found in one of them.\n\n### RxJava 1․x `byLine cast encode map`\n\nRxJava implements this operator as `map`.\n\nThis operator does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`map(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#map(rx.functions.Func1))\n\nThe `cast` operator is a specialized version of Map that transforms each item from the source Observable by casting it into a particular Class before reemitting it.\n\n- Javadoc: [`cast(Class)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#cast(java.lang.Class))\n\nIn the `StringObservable` class that is not part of the RxJava core there is also a specialty mapping operator, `encode`, that transforms an Observable that emits strings into an Observable that emits byte arrays that respect character boundaries of multibyte characters in the original strings.\n\nAlso in the `StringObservable` class that is not part of the RxJava core there is a specialty mapping operator called `byLine`, that transforms an Observable that emits strings into an Observable that emits lines of text, by buffering the strings from the source Observable until a line-feed is found in one of them.\n\n### RxJS `map pluck select`\n\nRxJS implements this operator as `map` or `select` (the two are synonymous). In addition to the transforming function, you may pass this operator an optional second parameter that will become the “`this`” context in which the transforming function will execute.\n\nThe transforming function gets three parameters:\n\n1.  the emitted item\n2.  the index of that item in the sequence of emitted items\n3.  the Observable from which that item was emitted\n\n#### Sample Code\n\n``` javascript\n// Using a value\nvar md = Rx.Observable.fromEvent(document, 'mousedown').map(true);\nvar mu = Rx.Observable.fromEvent(document, 'mouseup').map(false);\n\n// Using a function\nvar source = Rx.Observable.range(1, 3)\n    .select(function (x, idx, obs) {\n        return x * x;\n    });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 1\nNext: 4\nNext: 9\nCompleted\n```\n\nThere is also an operator called `pluck` which is a simpler version of this operator. It transforms the elements emitted by the source Observable by extracting a single named property from those elements and emitting that property in their place.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable\n    .fromArray([\n        { value: 0 },\n        { value: 1 },\n        { value: 2 }\n    ])\n    .pluck('value');\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nCompleted\n```\n\n`map`/`select` and `pluck` are found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n#### See Also\n\n- [`Rx.helpers.pluck(property)`](http://xgrommx.github.io/rx-book/content/helpers/pluck.html) from Dennis Stoyanov’s RxJS book\n\n### RxPHP `map mapWithIndex mapTo select pluck`\n\nRxPHP implements this operator as `map`.\n\nTakes a transforming function that operates on each element.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/map/map.php\n\n$observable = \\Rx\\Observable::fromArray([21, 42]);\n$observable\n    ->map(function ($elem) {\n        return $elem * 2;\n    })\n    ->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 42\nNext value: 84\nComplete!\n```\n\nRxPHP also has an operator `mapWithIndex`.\n\nMaps operator variant that calls the map selector with the index and value\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/map/mapWithIndex.php\n\n$subscriptions = Rx\\Observable::fromArray([21, 42])\n    ->mapWithIndex(function ($index, $elem) {\n        return $index + $elem;\n    })\n    ->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 21\nNext value: 43\nComplete!\n```\n\nRxPHP also has an operator `mapTo`.\n\nMaps every value to the same value every time\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/map/mapTo.php\n\n$subscription = Rx\\Observable::fromArray([21, 42])\n    ->mapTo(1)\n    ->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 1\nNext value: 1\nComplete!\n```\n\nRxPHP also has an operator `select`.\n\nAlias for Map\n\nRxPHP also has an operator `pluck`.\n\nReturns an Observable containing the value of a specified array index (if array) or property (if object) from all elements in the Observable sequence. If a property can't be resolved the observable will error.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/pluck/pluck.php\n\n$source = Rx\\Observable::fromArray([\n    (object)['value' => 0],\n    (object)['value' => 1],\n    (object)['value' => 2]\n])\n    ->pluck('value');\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 0\nNext value: 1\nNext value: 2\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/map.html](http://reactivex.io/documentation/operators/map.html)"
- name: Materialize/Dematerialize
  id: documentation/operators/materialize-dematerialize
  summary: A well-formed, finite Observable will invoke its observer’s onNext method zero or more times, and then will invoke either the onCompleted or onError method exactly once
  description: "# Materialize/Dematerialize\n\nrepresent both the items emitted and the notifications sent as emitted items, or reverse this process\n\nA well-formed, finite Observable will invoke its observer’s `onNext` method zero or more times, and then will invoke either the `onCompleted` or `onError` method exactly once. The Materialize operator converts this series of invocations — both the original `onNext` notifications and the terminal `onCompleted` or `onError` notification — into a series of *items* emitted by an Observable.\n\nThe Dematerialize operator reverses this process. It operates on an Observable that has previously been transformed by Materialize and returns it to its original form.\n\n#### See Also\n\n- [Introduction to Rx: Materialize and Dematerialize](http://www.introtorx.com/Content/v1.0.10621.0/08_Transformation.html#MaterializeAndDematerialize)\n\n## Language-Specific Information\n\n### RxGroovy `dematerialize materialize`\n\nIn RxGroovy, `materialize` transforms the notifications from the source Observable into `Notification` objects and emits them as the emissions from the Observable it returns. For example:\n\n#### Sample Code\n\n``` groovy\nnumbers = Observable.from([1, 2, 3]);\n\nnumbers.materialize().subscribe(\n  { if(rx.Notification.Kind.OnNext == it.kind) { println(\"Next: \" + it.value); }\n    else if(rx.Notification.Kind.OnCompleted == it.kind) { println(\"Completed\"); }\n    else if(rx.Notification.Kind.OnError == it.kind) { println(\"Error: \" + it.exception); } },\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\nNext: 1\nNext: 2\nNext: 3\nCompleted\nSequence complete\n```\n\n`materialize` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`materialize()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#materialize())\n\n`dematerialize` reverses this process: converting the emitted `Notification` objects from the source Observable into notifications from the resulting Observable. The following example dematerializes the materialized Observable from the previous section:\n\n#### Sample Code\n\n``` groovy\nnumbers = Observable.from([1, 2, 3]);\n\nnumbers.materialize().dematerialize().subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n1\n2\n3\nSequence complete\n```\n\n`dematerialize` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`dematerialize()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#dematerialize())\n\n### RxJava 1․x `dematerialize materialize`\n\nIn RxJava, `materialize` transforms the notifications from the source Observable into `Notification` objects and emits them as the emissions from the Observable it returns.\n\n`materialize` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`materialize()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#materialize())\n\n`dematerialize` reverses this process: converting the emitted `Notification` objects from the source Observable into notifications from the resulting Observable.\n\n`dematerialize` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`dematerialize()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#dematerialize())\n\n### RxJS `dematerialize`\n\nRxJS only implements the `dematerialize` operator. If you want a “materialized” Observable, you have to assemble it by hand by manually creating and emitting the `Notification` objects that represent Observable notification calls.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable\n    .fromArray([\n        Rx.Notification.createOnNext(42),\n        Rx.Notification.createOnError(new Error('woops'))\n    ])\n    .dematerialize();\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x.toString()); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 42\nError: Error: woops\n```\n\n`dematerialize` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `materialize dematerialize`\n\nRxPHP implements this operator as `materialize`.\n\nMaterializes the implicit notifications of an observable sequence as explicit notifications.\n\nRxPHP also has an operator `dematerialize`.\n\nDematerializes the explicit notification values of an observable sequence as implicit notifications.\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/materialize-dematerialize.html](http://reactivex.io/documentation/operators/materialize-dematerialize.html)"
- name: Max
  id: documentation/operators/max
  summary: 'The Max operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single item: the item with the largest number'
  description: "# Max\n\nemits the item from the source Observable that had the maximum value\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#max)\n\nThe Max operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single item: the item with the largest number.\n\n#### See Also\n\n- [Min](min)\n- [Introduction to Rx: Min, Max, Sum, and Average](http://www.introtorx.com/Content/v1.0.10621.0/07_Aggregation.html#MaxAndMin)\n- [RxMarbles: `max`](http://rxmarbles.com/#max)\n\n## Language-Specific Information\n\n### RxGroovy `max maxBy`\n\nIn RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct `rxjava-math` module.\n\nRxGroovy implements a `max` operator. It takes an optional comparator that it will use instead of its default to compare the value of two items. If more than one item has the identical maximum value, `max` will emit the *last* such item emitted by the source Observable.\n\nThe `maxBy` operator is similar to `max`, but instead of emitting the item with the maximum value, it emits the item with the maximum *key*, where that key is generated based on a function you provide to `maxBy`\n\n### RxJava 1․x `max maxBy`\n\nIn RxJava, this operator is not in the ReactiveX core, but is part of the distinct `rxjava-math` module.\n\nRxJava implements a `max` operator. It takes an optional comparator that it will use instead of its default to compare the value of two items. If more than one item has the identical maximum value, `max` will emit the *last* such item emitted by the source Observable.\n\nThe `maxBy` operator is similar to `max`, but instead of emitting the item with the maximum value, it emits the item with the maximum *key*, where that key is generated based on a function you provide to `maxBy`\n\n### RxJS `max maxBy`\n\nRxJS implements the `max` operator. It takes an optional comparer function that it will use instead of its default to compare the value of two items.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.fromArray([1,3,5,7,9,2,4,6,8]).max();\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: ' + x); },\n  function (err) { console.log('Error: ' + err); },\n  function () { console.log('Completed'); } );\n```\n\n``` javascript\nNext: 9\nCompleted\n```\n\nThe `maxBy` operator is similar to `max`, but instead of emitting the item with the maximum value, it emits the item with the maximum *key*, where that key is generated based on a function you provide to `maxBy`. `maxBy` also takes an optional second parameter: a comparer function that it will use instead of its default to compare the keys of the two items.\n\n`maxBy` emits a list. If more than one item has the maximum key value, each such item will be represented in the list.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.fromArray([1,3,5,7,9,2,4,6,8,9])\n               .maxBy( function (x) { return x; } );\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: ' + x); },\n  function (err) { console.log('Error: ' + err); },\n  function () { console.log('Completed'); } );\n```\n\n``` javascript\nNext: 9,9\nCompleted\n```\n\n`max` and `maxBy` are found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\nThey requires one of the following:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `max`\n\nRxPHP implements this operator as `max`.\n\nReturns the maximum value in an observable sequence according to the specified comparer.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/max/max.php\n\n/* Without comparer */\n$source = \\Rx\\Observable::fromArray([1, 3, 5, 7, 9, 2, 4, 6, 8])\n    ->max();\n\n$subscription = $source->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 9\nComplete!\n```\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/max/max-with-comparer.php\n\n/* With a comparer */\n$comparer = function ($x, $y) {\n    if ($x > $y) {\n        return 1;\n    } elseif ($x < $y) {\n        return -1;\n    }\n    return 0;\n};\n\n$source = \\Rx\\Observable::fromArray([1, 3, 5, 7, 9, 2, 4, 6, 8])\n    ->max($comparer);\n\n$subscription = $source->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 9\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/max.html](http://reactivex.io/documentation/operators/max.html)"
- name: Merge
  id: documentation/operators/merge
  summary: You can combine the output of multiple Observables so that they act like a single Observable, by using the Merge operator
  description: "# Merge\n\ncombine multiple Observables into one by merging their emissions\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#merge)\n\nYou can combine the output of multiple Observables so that they act like a single Observable, by using the Merge operator.\n\nMerge may interleave the items emitted by the merged Observables (a similar operator, [Concat](concat), does not interleave items, but emits all of each source Observable’s items in turn before beginning to emit items from the next source Observable).\n\nAs shown in the above diagram, an `onError` notification from any of the source Observables will immediately be passed through to observers and will terminate the merged Observable.\n\nIn many ReactiveX implementations there is a second operator, MergeDelayError, that changes this behavior — reserving `onError` notifications until all of the merged Observables complete and only then passing it along to the observers:\n\n#### See Also\n\n- [Concat](concat)\n- [Introduction to Rx: Merge](http://www.introtorx.com/Content/v1.0.10621.0/12_CombiningSequences.html#Merge)\n- [RxMarbles: `merge`](http://rxmarbles.com/#merge)\n- [101 Rx Samples: Merge](http://rxwiki.wikidot.com/101samples#toc47)\n\n## Language-Specific Information\n\n### RxClojure `interleave interleave* merge merge* merge-delay-error merge-delay-error*`\n\nIn RxClojure there are six operators of concern here:\n\n`merge` converts two or more Observables into a single Observable that emits all of the items emitted by all of those Observables.\n\n`merge*` converts an Observable that emits Observables into a single Observable that emits all of the items emitted by all of the emitted Observables.\n\n`merge-delay-error` is like `merge`, but will emit all items from all of the merged Observables even if one or more of those Observables terminates with an `onError` notification while emissions are still pending.\n\n`merge-delay-error*` is a similarly-modified version of `merge*`.\n\n`interleave` is like `merge`, but more deliberate about how it interleaves the items from the source Observables: the resulting Observable emits the first item emitted by the first source Observable, then the first item emitted by the second source Observable, and so forth, and having reached the last source Observable, then emits the second item emitted by the first source Observable, the second item emitted by the second source Observable, and so forth, until all of the source Observables terminate.\n\n`interleave*` is similar but operates on an Observable of Observables.\n\n### RxCpp `merge`\n\nRxCpp implements this operator as `merge`.\n\n### RxGroovy `merge mergeDelayError mergeWith`\n\nRxGroovy implements this operator as `merge`, `mergeWith`, and `mergeDelayError`.\n\nFor example, the following code merges the `odds` and `evens` into a single Observable. (The `subscribeOn` operator makes `odds` operate on a different thread from `evens` so that the two Observables may both emit items at the same time, to demonstrate how Merge may interleave these items.)\n\n#### Sample Code\n\n``` groovy\nodds  = Observable.from([1, 3, 5, 7]).subscribeOn(someScheduler);\nevens = Observable.from([2, 4, 6]);\n\nObservable.merge(odds,evens).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n1\n3\n2\n5\n4\n7\n6\nSequence complete\n```\n\nInstead of passing multiple Observables (up to nine) into `merge`, you could also pass in a `List<>` (or other Iterable) of Observables, an Array of Observables, or even an Observable that emits Observables, and `merge` will merge their output into the output of a single Observable:\n\n- Javadoc: [`merge(Iterable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(java.lang.Iterable))\n- Javadoc: [`merge(Iterable,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(java.lang.Iterable,%20int))\n- Javadoc: [`merge(Observable[])`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(rx.Observable%5B%5D))\n- Javadoc: [`merge(Observable[], int)` (RxGroovy 1.1)](http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(rx.Observable%5B%5D,%20int))\n- Javadoc: [`merge(Observable, Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(rx.Observable,%20rx.Observable)) (there are also versions that take up to nine Observables)\n\nIf you pass in an Observable of Observables, you have the option of also passing in a value indicating to `merge` the maximum number of those Observables it should attempt to be subscribed to simultaneously. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an `onCompleted` notification.\n\n- Javadoc: [`merge(Observable<Observable>)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(rx.Observable))\n- Javadoc: [`merge(Observable<Observable>,int)` (RxGroovy 1.1)](http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(rx.Observable,%20int))\n\nThe instance version of `merge` is `mergeWith`, so, for example, in the code sample above, instead of writing `Observable.merge(odds,evens)` you could also write `odds.mergeWith(evens)`.\n\n- Javadoc: [`mergeWith(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#mergeWith(rx.Observable))\n\nIf any of the individual Observables passed into `merge` terminates with an `onError` notification, the Observable produced by `merge` itself will immediately terminate with an `onError` notification. If you would prefer a merge that continues emitting the results of the remaining, error-free Observables before reporting the error, use `mergeDelayError` instead.\n\n`mergeDelayError` behaves much like `merge`. The exception is when one of the Observables being merged terminates with an `onError` notification. If this happens with `merge`, the merged Observable will immediately issue an `onError` notification and terminate. `mergeDelayError`, on the other hand, will hold off on reporting the error until it has given any other non-error-producing Observables that it is merging a chance to finish emitting their items, and it will emit those itself, and will only terminate with an `onError` notification when all of the other merged Observables have finished.\n\nBecause it is possible that more than one of the merged Observables encountered an error, `mergeDelayError` may pass information about *multiple* errors in the `onError` notification (it will never invoke the observer’s `onError` method more than once). For this reason, if you want to know the nature of these errors, you should write your observers’ `onError` methods so that they accept a parameter of the class `CompositeException`.\n\n`mergeDelayError` has fewer variants. You cannot pass it an Iterable or Array of Observables, but you can pass it an Observable that emits Observables or between one and nine individual Observables as parameters. There is not an instance method version of `mergeDelayError` as there is for `merge`.\n\n- Javadoc: [`mergeDelayError(Observable<Observable>)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#mergeDelayError(rx.Observable))\n- Javadoc: [`mergeDelayError(Observable,Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#mergeDelayError(rx.Observable,%20rx.Observable)) (there are also versions that take up to nine Observables)\n\n### RxJava 1․x `merge mergeDelayError mergeWith`\n\nRxJava implements this operator as `merge`, `mergeWith`, and `mergeDelayError`.\n\n#### Sample Code\n\n``` java\nObservable<Integer> odds = Observable.just(1, 3, 5).subscribeOn(someScheduler);\nObservable<Integer> evens = Observable.just(2, 4, 6);\n\nObservable.merge(odds, evens)\n          .subscribe(new Subscriber<Integer>() {\n        @Override\n        public void onNext(Integer item) {\n            System.out.println(\"Next: \" + item);\n        }\n\n        @Override\n        public void onError(Throwable error) {\n            System.err.println(\"Error: \" + error.getMessage());\n        }\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"Sequence complete.\");\n        }\n    });\n```\n\n``` javascript\nNext: 1\nNext: 3\nNext: 5\nNext: 2\nNext: 4\nNext: 6\nSequence complete.\n```\n\n- Javadoc: [`merge(Iterable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(java.lang.Iterable))\n- Javadoc: [`merge(Iterable,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(java.lang.Iterable,%20int))\n- Javadoc: [`merge(Observable[])`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(rx.Observable%5B%5D))\n- Javadoc: [`merge(Observable[], int)` (RxJava 1.1)](http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(rx.Observable%5B%5D,%20int))\n- Javadoc: [`merge(Observable, Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(rx.Observable,%20rx.Observable)) (there are also versions that take up to nine Observables)\n\nInstead of passing multiple Observables (up to nine) into `merge`, you could also pass in a `List<>` (or other Iterable) of Observables, an Array of Observables, or even an Observable that emits Observables, and `merge` will merge their output into the output of a single Observable:\n\nIf you pass in an Observable of Observables, you have the option of also passing in a value indicating to `merge` the maximum number of those Observables it should attempt to be subscribed to simultaneously. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an `onCompleted` notification.\n\n- Javadoc: [`merge(Observable<Observable>)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(rx.Observable))\n- Javadoc: [`merge(Observable<Observable>, int)` (RxJava 1.1)](http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(rx.Observable,%20int))\n\nThe instance version of `merge` is `mergeWith`, so, for example, instead of writing `Observable.merge(odds,evens)` you could also write `odds.mergeWith(evens)`.\n\nIf any of the individual Observables passed into `merge` terminates with an `onError` notification, the Observable produced by `merge` itself will immediately terminate with an `onError` notification. If you would prefer a merge that continues emitting the results of the remaining, error-free Observables before reporting the error, use `mergeDelayError` instead.\n\n`mergeDelayError` behaves much like `merge`. The exception is when one of the Observables being merged terminates with an `onError` notification. If this happens with `merge`, the merged Observable will immediately issue an `onError` notification and terminate. `mergeDelayError`, on the other hand, will hold off on reporting the error until it has given any other non-error-producing Observables that it is merging a chance to finish emitting their items, and it will emit those itself, and will only terminate with an `onError` notification when all of the other merged Observables have finished.\n\nBecause it is possible that more than one of the merged Observables encountered an error, `mergeDelayError` may pass information about *multiple* errors in the `onError` notification (it will never invoke the observer’s `onError` method more than once). For this reason, if you want to know the nature of these errors, you should write your observers’ `onError` methods so that they accept a parameter of the class `CompositeException`.\n\n`mergeDelayError` has fewer variants. You cannot pass it an Iterable or Array of Observables, but you can pass it an Observable that emits Observables or between one and nine individual Observables as parameters. There is not an instance method version of `mergeDelayError` as there is for `merge`.\n\n- Javadoc: [`mergeDelayError(Observable<Observable>)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#mergeDelayError(rx.Observable))\n- Javadoc: [`mergeDelayError(Observable,Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#mergeDelayError(rx.Observable,%20rx.Observable)) (there are also versions that take up to nine Observables)\n\n### RxJS `merge mergeAll mergeDelayError`\n\nThe first variant of `merge` is an instance operator that takes a variable number of Observables as parameters, merging each of these Observables with the source (instance) Observables to produce its single output Observable.\n\nThis first variant of `merge` is found in the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThe second variant of `merge` is a prototype (class) operator that accepts two parameters. The second of these is an Observable that emits the Observables you want to merge. The first is a number that indicates the maximum number of these emitted Observables that you want `merge` to attempt to be subscribed to at any moment. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an `onCompleted` notification.\n\nThis second variant of `merge` is found in the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n`mergeAll` is like this second variant of `merge` except that it does not allow you to set this maximum subscription count. It only takes the single parameter of an Observable of Observables.\n\n`mergeAll` is found in the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nIf any of the individual Observables passed into `merge` or `mergeAll` terminates with an `onError` notification, the resulting Observable will immediately terminate with an `onError` notification. If you would prefer a merge that continues emitting the results of the remaining, error-free Observables before reporting the error, use `mergeDelayError` instead.\n\n#### Sample Code\n\n``` javascript\nvar source1 = Rx.Observable.of(1,2,3);\nvar source2 = Rx.Observable.throwError(new Error('whoops!'));\nvar source3 = Rx.Observable.of(4,5,6);\n\nvar merged = Rx.Observable.mergeDelayError(source1, source2, source3);\n\nvar subscription = merged.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); }\n  function () { console.log('Completed' } );\n```\n\n``` javascript\n1\n2\n3\n4\n5\n6\nError: Error: whoops!\n```\n\n`mergeDelayError` is found in the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxKotlin `merge mergeDelayError mergeWith`\n\nRxKotlin implements this operator as `merge`, `mergeWith`, and `mergeDelayError`.\n\nInstead of passing multiple Observables (up to nine) into `merge`, you could also pass in a `List<>` (or other Iterable) of Observables, an Array of Observables, or even an Observable that emits Observables, and `merge` will merge their output into the output of a single Observable:\n\nIf you pass in an Observable of Observables, you have the option of also passing in a value indicating to `merge` the maximum number of those Observables it should attempt to be subscribed to simultaneously. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an `onCompleted` notification.\n\nThe instance version of `merge` is `mergeWith`, so, for example, instead of writing `Observable.merge(odds,evens)` you could also write `odds.mergeWith(evens)`.\n\nIf any of the individual Observables passed into `merge` terminates with an `onError` notification, the Observable produced by `merge` itself will immediately terminate with an `onError` notification. If you would prefer a merge that continues emitting the results of the remaining, error-free Observables before reporting the error, use `mergeDelayError` instead.\n\n`mergeDelayError` behaves much like `merge`. The exception is when one of the Observables being merged terminates with an `onError` notification. If this happens with `merge`, the merged Observable will immediately issue an `onError` notification and terminate. `mergeDelayError`, on the other hand, will hold off on reporting the error until it has given any other non-error-producing Observables that it is merging a chance to finish emitting their items, and it will emit those itself, and will only terminate with an `onError` notification when all of the other merged Observables have finished.\n\nBecause it is possible that more than one of the merged Observables encountered an error, `mergeDelayError` may pass information about *multiple* errors in the `onError` notification (it will never invoke the observer’s `onError` method more than once). For this reason, if you want to know the nature of these errors, you should write your observers’ `onError` methods so that they accept a parameter of the class `CompositeException`.\n\n`mergeDelayError` has fewer variants. You cannot pass it an Iterable or Array of Observables, but you can pass it an Observable that emits Observables or between one and nine individual Observables as parameters. There is not an instance method version of `mergeDelayError` as there is for `merge`.\n\n### RxNET `Merge`\n\nRx.NET implements this operator as `Merge`.\n\nYou can pass `Merge` an Array of Observables, an Enumerable of Observables, an Observable of Observables, or two individual Observables.\n\nIf you pass an Enumerable or Observable of Observables, you have the option of also passing in an integer indicating the maximum number of those Observables it should attempt to be subscribed to simultaneously. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an `onCompleted` notification.\n\n### RxPHP `merge mergeAll`\n\nRxPHP implements this operator as `merge`.\n\nCombine an Observable together with another Observable by merging their emissions into a single Observable.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/merge/merge.php\n\n$observable       = Rx\\Observable::of(42)->repeat();\n$otherObservable  = Rx\\Observable::of(21)->repeat();\n$mergedObservable = $observable\n    ->merge($otherObservable)\n    ->take(10);\n\n$disposable = $mergedObservable->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 42\nNext value: 21\nNext value: 42\nNext value: 21\nNext value: 42\nNext value: 21\nNext value: 42\nNext value: 21\nNext value: 42\nNext value: 21\nComplete!\n```\n\nRxPHP also has an operator `mergeAll`.\n\nMerges an observable sequence of observables into an observable sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/merge/merge-all.php\n\n$sources = Rx\\Observable::range(0, 3)\n    ->map(function ($x) {\n        return Rx\\Observable::range($x, 3);\n    });\n\n$merged = $sources->mergeAll();\n\n$disposable = $merged->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 0\nNext value: 1\nNext value: 1\nNext value: 2\nNext value: 2\nNext value: 2\nNext value: 3\nNext value: 3\nNext value: 4\nComplete!\n```\n\n### RxPY `merge merge_all merge_observable`\n\nRxPY implements this operator as `merge` and `merge_all`/`merge_observable`.\n\nYou can either pass `merge` a set of Observables as individual parameters, or as a single parameter containing an array of those Observables.\n\n`merge_all` and its alias `merge_observable` take as their single parameter an Observable that emits Observables. They merge the emissions of all of these Observables to create their own Observable.\n\n### Rxrb `merge merge_all merge_concurrent`\n\nRx.rb implements this operator as `merge`, `merge_concurrent`, and `merge_all`.\n\n`merge` merges a second Observable into the one it is operating on to create a new merged Observable.\n\n`merge_concurrent` operates on an Observable that emits Observables, merging the emissions from each of these Observables into its own emissions. You can optionally pass it an integer parameter indicating how many of these emitted Observables `merge_concurrent` should try to subscribe to concurrently. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an `onCompleted` notification. The default is 1, which makes it equivalent to `merge_all`.\n\n`merge_all` is like `merge_concurrent(1)`. It subscribes to each emitted Observable one at a time, mirroring its emissions as its own, and waiting to subscribe to the next Observable until the present one terminates with an `onCompleted` notification. In this respect it is more like a Concat variant.\n\n### RxScala `flatten flattenDelayError merge mergeDelayError`\n\nRxScala implements this operator as `flatten`, `flattenDelayError`, `merge`, and `mergeDelayError`.\n\n`merge` takes a second Observable as a parameter and merges that Observable with the one the `merge` operator is applied to in order to create a new output Observable.\n\n`mergeDelayError` is similar to `merge` except that it will always emit all items from both Observables even if one of the Observables terminates with an `onError` notification before the other Observable has finished emitting items.\n\n`flatten` takes as its parameter an Observable that emits Observables. It merges the items emitted by each of these Observables to create its own single Observable sequence. A variant of this operator allows you to pass in an `Int` indicating the maximum number of these emitted Observables you want `flatten` to try to be subscribed to at any time. It it hits this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an `onCompleted` notification.\n\n`flattenDelayError` is similar to `flatten` except that it will always emit all items from all of the emitted Observables even if one or more of those Observables terminates with an `onError` notification before the other Observables have finished emitting items.\n\n### RxSwift `merge`\n\nRxSwift implements this operator as `merge`.\n\n`merge` takes as its parameter an Observable that emits Observables. It merges the items emitted by each of these Observables to create its own single Observable sequence.\n\nA variant of this operator `merge(maxConcurrent:)` allows you to pass in an `Int` indicating the maximum number of these emitted Observables you want `merge` to try to be subscribed to at any time. If it hits this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an `onCompleted` notification.\n\n#### Sample Code\n\n``` swift\nlet subject1 = PublishSubject()\nlet subject2 = PublishSubject()\n\nObservable.of(subject1, subject2)\n   .merge()\n   .subscribe {\n       print($0)\n   }\n\nsubject1.on(.Next(10))\nsubject1.on(.Next(11))\nsubject1.on(.Next(12))\nsubject2.on(.Next(20))\nsubject2.on(.Next(21))\nsubject1.on(.Next(14))\nsubject1.on(.Completed)\nsubject2.on(.Next(22))\nsubject2.on(.Completed)\n```\n\n``` javascript\nNext(10)\nNext(11)\nNext(12)\nNext(20)\nNext(21)\nNext(14)\nNext(22)\nCompleted\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/merge.html](http://reactivex.io/documentation/operators/merge.html)"
- name: Min
  id: documentation/operators/min
  summary: 'The Min operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single item: the item with the smallest number'
  description: "# Min\n\nemits the item from the source Observable that had the minimum value\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#min)\n\nThe Min operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single item: the item with the smallest number.\n\n#### See Also\n\n- [Min](min)\n- [Introduction to Rx: Min, Max, Sum, and Average](http://www.introtorx.com/Content/v1.0.10621.0/07_Aggregation.html#MaxAndMin)\n- [RxMarbles: `min`](http://rxmarbles.com/#min)\n\n## Language-Specific Information\n\n### RxGroovy `min minBy`\n\nIn RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct `rxjava-math` module.\n\nRxGroovy implements a `min` operator. It takes an optional comparator that it will use instead of its default to compare the value of two items. If more than one item has the identical minimum value, `min` will emit the *last* such item emitted by the source Observable.\n\nThe `minBy` operator is similar to `min`, but instead of emitting the item with the minimum value, it emits the item with the minimum *key*, where that key is generated based on a function you provide to `minBy`\n\n### RxJava 1․x `min minBy`\n\nIn RxJava, this operator is not in the ReactiveX core, but is part of the distinct `rxjava-math` module.\n\nRxJava implements a `min` operator. It takes an optional comparator that it will use instead of its default to compare the value of two items. If more than one item has the identical minimum value, `min` will emit the *last* such item emitted by the source Observable.\n\nThe `minBy` operator is similar to `min`, but instead of emitting the item with the minimum value, it emits the item with the minimum *key*, where that key is generated based on a function you provide to `minBy`\n\n### RxJS `min minBy`\n\nRxJS implements the `min` operator. It takes an optional comparer function that it will use instead of its default to compare the value of two items.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.fromArray([1,3,5,7,9,2,4,6,8]).min();\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: ' + x); },\n  function (err) { console.log('Error: ' + err); },\n  function () { console.log('Completed'); } );\n```\n\n``` javascript\nNext: 1\nCompleted\n```\n\nThe `minBy` operator is similar to `min`, but instead of emitting the item with the minimum value, it emits the item with the minimum *key*, where that key is generated based on a function you provide to `minBy`. `minBy` also takes an optional second parameter: a comparer function that it will use instead of its default to compare the keys of the two items.\n\n`minBy` emits a list. If more than one item has the minimum key value, each such item will be represented in the list.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.fromArray([1,3,5,7,9,2,4,6,8,1])\n               .minBy( function (x) { return x; } );\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: ' + x); },\n  function (err) { console.log('Error: ' + err); },\n  function () { console.log('Completed'); } );\n```\n\n``` javascript\nNext: 1,1\nCompleted\n```\n\n`min` and `minBy` are found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\nThey requires one of the following:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `min`\n\nRxPHP implements this operator as `min`.\n\nReturns the minimum value in an observable sequence according to the specified comparer.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/min/min.php\n\n/* Without comparer */\n$source = \\Rx\\Observable::fromArray([1, 3, 5, 7, 9, 2, 4, 6, 8])\n    ->min();\n\n$subscription = $source->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 1\nComplete!\n```\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/min/min-with-comparer.php\n\n/* With a comparer */\n$comparer = function ($x, $y) {\n    if ($x > $y) {\n        return 1;\n    } elseif ($x < $y) {\n        return -1;\n    }\n    return 0;\n};\n\n$source = \\Rx\\Observable::fromArray([1, 3, 5, 7, 9, 2, 4, 6, 8])\n    ->min($comparer);\n\n$subscription = $source->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 1\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/min.html](http://reactivex.io/documentation/operators/min.html)"
- name: Observable
  id: documentation/observable
  summary: In ReactiveX an observer subscribes to an Observable
  description: "# Observable\n\nIn ReactiveX an observer subscribes to an Observable. Then that observer reacts to whatever item or sequence of items the Observable emits. This pattern facilitates concurrent operations because it does not need to block while waiting for the Observable to emit objects, but instead it creates a sentry in the form of an observer that stands ready to react appropriately at whatever future time the Observable does so.\n\nThis page explains what the reactive pattern is and what Observables and observers are (and how observers subscribe to Observables). Other pages show how you use [the variety of Observable operators](operators) to link Observables together and change their behaviors.\n\nThis documentation accompanies its explanations with “marble diagrams.” Here is how marble diagrams represent Observables and transformations of Observables:\n\n#### See Also\n\n- [`Single`](single) — a specialized version of an Observable that emits only a single item\n- [Rx Workshop: Introduction](http://channel9.msdn.com/Series/Rx-Workshop/Rx-Workshop-Introduction)\n- [Introduction to Rx: IObservable](http://www.introtorx.com/Content/v1.0.10621.0/02_KeyTypes.html#IObservable)\n- [Mastering observables](http://docs.couchbase.com/developer/java-2.0/observables.html) (from the Couchbase Server documentation)\n- [2 minute introduction to Rx](https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877) by Andre Staltz (“Think of an Observable as an asynchronous immutable array.”)\n- [Introducing the Observable](https://egghead.io/lessons/javascript-introducing-the-observable) by Jafar Husain (JavaScript Video Tutorial)\n- [Observable object](http://xgrommx.github.io/rx-book/content/observable/index.html) (RxJS) by Dennis Stoyanov\n- [Turning a callback into an Rx Observable](https://afterecho.uk/blog/turning-a-callback-into-an-rx-observable.html) by @afterecho\n\n## Background\n\nIn many software programming tasks, you more or less expect that the instructions you write will execute and complete incrementally, one-at-a-time, in order as you have written them. But in ReactiveX, many instructions may execute in parallel and their results are later captured, in arbitrary order, by “observers.” Rather than *calling* a method, you define a mechanism for retrieving and transforming the data, in the form of an “Observable,” and then *subscribe* an observer to it, at which point the previously-defined mechanism fires into action with the observer standing sentry to capture and respond to its emissions whenever they are ready.\n\nAn advantage of this approach is that when you have a bunch of tasks that are not dependent on each other, you can start them all at the same time rather than waiting for each one to finish before starting the next one — that way, your entire bundle of tasks only takes as long to complete as the longest task in the bundle.\n\nThere are many terms used to describe this model of asynchronous programming and design. This document will use the following terms: An observer subscribes to an Observable. An Observable emits items or sends notifications to its observers by calling the observers’ methods.\n\nIn other documents and other contexts, what we are calling an “observer” is sometimes called a “subscriber,” “watcher,” or “reactor.” This model in general is often referred to as the [“reactor pattern”](http://en.wikipedia.org/wiki/Reactor_pattern).\n\n## Establishing Observers\n\nThis page uses Groovy-like pseudocode for its examples, but there are ReactiveX implementations in many languages.\n\nIn an ordinary method call — that is, *not* the sort of asynchronous, parallel calls typical in ReactiveX — the flow is something like this:\n\n1.  Call a method.\n2.  Store the return value from that method in a variable.\n3.  Use that variable and its new value to do something useful.\n\nOr, something like this:\n\n``` groovy\n// make the call, assign its return value to `returnVal`\nreturnVal = someMethod(itsParameters);\n// do something useful with returnVal\n```\n\nIn the asynchronous model the flow goes more like this:\n\n1.  Define a method that does something useful with the return value from the asynchronous call; this method is part of the *observer*.\n2.  Define the asynchronous call itself as an *Observable*.\n3.  Attach the observer to that Observable by *subscribing* it (this also initiates the actions of the Observable).\n4.  Go on with your business; whenever the call returns, the observer’s method will begin to operate on its return value or values — the *items* emitted by the Observable.\n\nWhich looks something like this:\n\n``` groovy\n// defines, but does not invoke, the Subscriber's onNext handler\n// (in this example, the observer is very simple and has only an onNext handler)\ndef myOnNext = { it -> do something useful with it };\n// defines, but does not invoke, the Observable\ndef myObservable = someObservable(itsParameters);\n// subscribes the Subscriber to the Observable, and invokes the Observable\nmyObservable.subscribe(myOnNext);\n// go on about my business\n```\n\n## onNext, onCompleted, and onError\n\n[The `Subscribe` method](operators/subscribe) is how you connect an observer to an Observable. Your observer implements some subset of the following methods:\n\n`onNext`  \nAn Observable calls this method whenever the Observable emits an item. This method takes as a parameter the item emitted by the Observable.\n\n`onError`  \nAn Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error. It will not make further calls to `onNext` or `onCompleted`. The `onError` method takes as its parameter an indication of what caused the error.\n\n`onCompleted`  \nAn Observable calls this method after it has called `onNext` for the final time, if it has not encountered any errors.\n\nBy the terms of [the Observable contract](contract), it may call `onNext` zero or more times, and then may follow those calls with a call to either `onCompleted` or `onError` but not both, which will be its last call. By convention, in this document, calls to `onNext` are usually called “emissions” of items, whereas calls to `onCompleted` or `onError` are called “notifications.”\n\nA more complete `subscribe` call example looks like this:\n\n``` groovy\ndef myOnNext     = { item -> /* do something useful with item */ };\ndef myError      = { throwable -> /* react sensibly to a failed call */ };\ndef myComplete   = { /* clean up after the final response */ };\ndef myObservable = someMethod(itsParameters);\nmyObservable.subscribe(myOnNext, myError, myComplete);\n// go on about my business\n```\n\n#### See Also\n\n- [Introduction to Rx: IObserver](http://www.introtorx.com/Content/v1.0.10621.0/02_KeyTypes.html#IObserver)\n\n## Unsubscribing\n\nIn some ReactiveX implementations, there is a specialized observer interface, `Subscriber`, that implements an `unsubscribe` method. You can call this method to indicate that the Subscriber is no longer interested in any of the Observables it is currently subscribed to. Those Observables can then (if they have no other interested observers) choose to stop generating new items to emit.\n\nThe results of this unsubscription will cascade back through the chain of operators that applies to the Observable that the observer subscribed to, and this will cause each link in the chain to stop emitting items. This is not guaranteed to happen immediately, however, and it is possible for an Observable to generate and attempt to emit items for a while even after no observers remain to observe these emissions.\n\n## Some Notes on Naming Conventions\n\nEach language-specific implementation of ReactiveX has its own naming quirks. There is no canonical naming standard, though there are many commonalities between implementations.\n\nFurthermore, some of these names have different implications in other contexts, or seem awkward in the idiom of a particular implementing language.\n\nFor example there is the `on`*`Event`* naming pattern (e.g. `onNext`, `onCompleted`, `onError`). In some contexts such names would indicate methods by means of which event handlers are *registered*. In ReactiveX, however, they name the event handlers themselves.\n\n## “Hot” and “Cold” Observables\n\nWhen does an Observable begin emitting its sequence of items? It depends on the Observable. A “hot” Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle. A “cold” Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning.\n\nIn some implementations of ReactiveX, there is also something called a “Connectable” Observable. Such an Observable does not begin emitting items until its [Connect](operators/connect) method is called, whether or not any observers have subscribed to it.\n\n## Composition via Observable Operators\n\nObservables and observers are only the start of ReactiveX. By themselves they’d be nothing more than a slight extension of the standard observer pattern, better suited to handling a sequence of events rather than a single callback.\n\nThe real power comes with the “reactive extensions” (hence “ReactiveX”) — operators that allow you to transform, combine, manipulate, and work with the sequences of items emitted by Observables.\n\nThese Rx operators allow you to compose asynchronous sequences together in a declarative manner with all the efficiency benefits of callbacks but without the drawbacks of nesting callback handlers that are typically associated with asynchronous systems.\n\nThis documentation groups information about [the various operators](operators#alphabetical) and examples of their usage into the following pages:\n\n[Creating Observables](operators#creating)  \n`Create`, `Defer`, `Empty`/`Never`/`Throw`, `From`, `Interval`, `Just`, `Range`, `Repeat`, `Start`, and `Timer`\n\n[Transforming Observable Items](operators#transforming)  \n`Buffer`, `FlatMap`, `GroupBy`, `Map`, `Scan`, and `Window`\n\n[Filtering Observables](operators#filtering)  \n`Debounce`, `Distinct`, `ElementAt`, `Filter`, `First`, `IgnoreElements`, `Last`, `Sample`, `Skip`, `SkipLast`, `Take`, and `TakeLast`\n\n[Combining Observables](operators#combining)  \n`And`/`Then`/`When`, `CombineLatest`, `Join`, `Merge`, `StartWith`, `Switch`, and `Zip`\n\n[Error Handling Operators](operators#error)  \n`Catch` and `Retry`\n\n[Utility Operators](operators#utility)  \n`Delay`, `Do`, `Materialize`/`Dematerialize`, `ObserveOn`, `Serialize`, `Subscribe`, `SubscribeOn`, `TimeInterval`, `Timeout`, `Timestamp`, and `Using`\n\n[Conditional and Boolean Operators](operators#conditional)  \n`All`, `Amb`, `Contains`, `DefaultIfEmpty`, `SequenceEqual`, `SkipUntil`, `SkipWhile`, `TakeUntil`, and `TakeWhile`\n\n[Mathematical and Aggregate Operators](operators#mathematical)  \n`Average`, `Concat`, `Count`, `Max`, `Min`, `Reduce`, and `Sum`\n\n[Converting Observables](operators#conversion)  \n`To`\n\n[Connectable Observable Operators](operators#connectable)  \n`Connect`, `Publish`, `RefCount`, and `Replay`\n\n[Backpressure Operators](operators/backpressure)  \na variety of operators that enforce particular flow-control policies\n\nThese pages include information about some operators that are not part of the core of ReactiveX but are implemented in one or more of language-specific implementations and/or optional modules.\n\n## Chaining Operators\n\nMost operators operate on an Observable and return an Observable. This allows you to apply these operators one after the other, in a chain. Each operator in the chain modifies the Observable that results from the operation of the previous operator.\n\nThere are other patterns, like the Builder Pattern, in which a variety of methods of a particular class operate on an item of that same class by modifying that object through the operation of the method. These patterns also allow you to chain the methods in a similar way. But while in the Builder Pattern, the order in which the methods appear in the chain does not usually matter, with the Observable operators *order matters*.\n\nA chain of Observable operators do not operate independently on the original Observable that originates the chain, but they operate *in turn*, each one operating on the Observable generated by the operator immediately previous in the chain.\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/observable.html](http://reactivex.io/documentation/observable.html)"
- name: ObserveOn
  id: documentation/operators/observeon
  summary: Many implementations of ReactiveX use “Schedulers” to govern an Observable’s transitions between threads in a multi-threaded environment
  description: "# ObserveOn\n\nspecify the Scheduler on which an observer will observe this Observable\n\nMany implementations of ReactiveX use [“`Scheduler`s”](../scheduler) to govern an Observable’s transitions between threads in a multi-threaded environment. You can instruct an Observable to send its notifications to observers on a particular Scheduler by means of the ObserveOn operator.\n\nNote that ObserveOn will forward an `onError` termination notification immediately if it receives one, and will not wait for a slow-consuming observer to receive any not-yet-emitted items that it is aware of first. This may mean that the `onError` notification jumps ahead of (and swallows) items emitted by the source Observable, as in the diagram above.\n\nThe [SubscribeOn](subscribeon) operator is similar, but it instructs the Observable to *itself* operate on the specified Scheduler, as well as notifying its observers on that Scheduler.\n\nBy default, an Observable and the chain of operators that you apply to it will do its work, and will notify its observers, on the same thread on which its `Subscribe` method is called. The SubscribeOn operator changes this behavior by specifying a different Scheduler on which the Observable should operate. The ObserveOn operator specifies a different Scheduler that the Observable will use to send notifications to its observers.\n\nAs shown in this illustration, the SubscribeOn operator designates which thread the Observable will begin operating on, no matter at what point in the chain of operators that operator is called. ObserveOn, on the other hand, affects the thread that the Observable will use *below* where that operator appears. For this reason, you may call ObserveOn multiple times at various points during the chain of Observable operators in order to change on which threads certain of those operators operate.\n\n#### See Also\n\n- [`Scheduler`](../scheduler)\n- [SubscribeOn](subscribeon)\n- [Rx Workshop: Schedulers](http://channel9.msdn.com/Series/Rx-Workshop/Rx-Workshop-Schedulers)\n- [RxJava Threading Examples by Graham Lea](http://www.grahamlea.com/2014/07/rxjava-threading-examples/)\n- [Introduction to Rx: SubscribeOn and ObserveOn](http://www.introtorx.com/Content/v1.0.10621.0/15_SchedulingAndThreading.html#SubscribeOnObserveOn)\n- [RxJava: Understanding observeOn() and subscribeOn()](http://tomstechnicalblog.blogspot.hu/2016/02/rxjava-understanding-observeon-and.html) by Thomas Nield\n- [Advanced Reactive Java: SubscribeOn and ObserveOn](http://akarnokd.blogspot.hu/2016/03/subscribeon-and-observeon.html) by Dávid Karnok\n\n## Language-Specific Information\n\n### RxGroovy `observeOn`\n\nTo specify on which Scheduler the Observable should invoke its observers’ `onNext`, `onCompleted`, and `onError` methods, use the `observeOn` operator, passing it the appropriate `Scheduler`.\n\n- Javadoc: [`observeOn(Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#observeOn(rx.Scheduler))\n\n### RxJava 1․x `observeOn`\n\nTo specify on which Scheduler the Observable should invoke its observers’ `onNext`, `onCompleted`, and `onError` methods, use the `observeOn` operator, passing it the appropriate `Scheduler`.\n\n- Javadoc: [`observeOn(Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#observeOn(rx.Scheduler))\n\n### RxJS `observeOn`\n\nTo specify on which Scheduler the Observable should invoke its observers’ `onNext`, `onCompleted`, and `onError` methods, use the `observeOn` operator, passing it the appropriate `Scheduler`.\n\n#### Sample Code\n\n``` javascript\n/* Change from immediate scheduler to timeout */\nvar source = Rx.Observable.return(42, Rx.Scheduler.immediate)\n    .observeOn(Rx.Scheduler.timeout);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 42\nCompleted\n```\n\n`observeOn` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/observeon.html](http://reactivex.io/documentation/operators/observeon.html)"
- name: Publish
  id: documentation/operators/publish
  summary: A connectable Observable resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when the Connect operator is applied to it
  description: "# Publish\n\nconvert an ordinary Observable into a connectable Observable\n\nA connectable Observable resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when the Connect operator is applied to it. In this way you can prompt an Observable to begin emitting items at a time of your choosing.\n\n#### See Also\n\n- [Connect](connect)\n- [RefCount](refcount)\n- [Replay](replay)\n- [Introduction to Rx: Publish & Connect](http://www.introtorx.com/Content/v1.0.10621.0/14_HotAndColdObservables.html#PublishAndConnect)\n- [101 Rx Samples: Publish — Sharing a subscription with multiple Observers](http://rxwiki.wikidot.com/101samples#toc48)\n- [Wedding Party: Share, Publish, Refcount, and All That Jazz](http://blog.kaush.co/2015/01/21/rxjava-tip-for-the-day-share-publish-refcount-and-all-that-jazz/) by Kaushik Gopal\n\n## Language-Specific Information\n\n### RxGroovy `publish`\n\nRxGroovy implements this operator as `publish`.\n\n- Javadoc: [`publish()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#publish())\n\nThere is also a variant that takes a function as a parameter. This function takes an emitted item from the source Observable as a parameter and produces the item that will be emitted in its place by the resulting Observable.\n\n- Javadoc: [`publish(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#publish(rx.functions.Func1))\n\n### RxJava 1․x `publish`\n\nRxJava implements this operator as `publish`.\n\n- Javadoc: [`publish()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#publish())\n\nThere is also a variant that takes a function as a parameter. This function takes as a parameter the `ConnectableObservable` that shares a single subscription to the underlying Observable sequence. This function produces and returns a new Observable sequence.\n\n- Javadoc: [`publish(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#publish(rx.functions.Func1))\n\n### RxJS `let letBind multicast publish publishLast publishValue`\n\nIn RxJS, the `publish` operator takes a function as a parameter. This function takes an emitted item from the source Observable as a parameter and produces the item that will be emitted in its place by the returned `ConnectableObservable`.\n\n#### Sample Code\n\n``` javascript\nvar interval = Rx.Observable.interval(1000);\n\nvar source = interval\n    .take(2)\n    .doAction(function (x) {\n        console.log('Side effect');\n    });\n\nvar published = source.publish();\n\npublished.subscribe(createObserver('SourceA'));\npublished.subscribe(createObserver('SourceB'));\n\nvar connection = published.connect();\n\nfunction createObserver(tag) {\n    return Rx.Observer.create(\n        function (x) { console.log('Next: ' + tag + x); },\n        function (err) { console.log('Error: ' + err); },\n        function () { console.log('Completed'); });\n}\n```\n\n``` javascript\nSide effect\nNext: SourceA0\nNext: SourceB0\nSide effect\nNext: SourceA1\nNext: SourceB1\nCompleted\n```\n\nThe `publishValue` operator takes, in addition to the function described above, an initial item to be emitted by the resulting `ConnectableObservable` at connection time before emitting the items from the source Observable. It will not, however, emit this initial item to observers that subscribe after the time of connection.\n\n#### Sample Code\n\n``` javascript\nvar interval = Rx.Observable.interval(1000);\n\nvar source = interval\n    .take(2)\n    .doAction(function (x) {\n        console.log('Side effect');\n    });\n\nvar published = source.publishValue(42);\n\npublished.subscribe(createObserver('SourceA'));\npublished.subscribe(createObserver('SourceB'));\n\nvar connection = published.connect();\n\nfunction createObserver(tag) {\n    return Rx.Observer.create(\n        function (x) { console.log('Next: ' + tag + x); },\n        function (err) { console.log('Error: ' + err); },\n        function () { console.log('Completed'); });\n}\n```\n\n``` javascript\nNext: SourceA42\nNext: SourceB42\nSide effect\nNext: SourceA0\nNext: SourceB0\nSide effect\nNext: SourceA1\nNext: SourceB1\nCompleted\nCompleted\n```\n\nThe `publishLast` operator is similar to `publish`, and takes a similarly-behaving function as its parameter. It differs from `publish` in that instead of applying that function to, and emitting an item for *every* item emitted by the source Observable subsequent to the connection, it only applies that function to and emits an item for the *last* item that was emitted by the source Observable, when that source Observable terminates normally.\n\n#### Sample Code\n\n``` javascript\nvar interval = Rx.Observable.interval(1000);\n\nvar source = interval\n    .take(2)\n    .doAction(function (x) {\n        console.log('Side effect');\n    });\n\nvar published = source.publishLast();\n\npublished.subscribe(createObserver('SourceA'));\npublished.subscribe(createObserver('SourceB'));\n\nvar connection = published.connect();\n\nfunction createObserver(tag) {\n    return Rx.Observer.create(\n        function (x) { console.log('Next: ' + tag + x); },\n        function (err) { console.log('Error: ' + err); },\n        function () { console.log('Completed'); });\n}\n```\n\n``` javascript\nSide effect\nSide effect\nNext: SourceA1\nCompleted\nNext: SourceB1\nCompleted\n```\n\nThe above operators are available in the following packages:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.binding.js` (requires either `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nRxJS also has a `multicast` operator which operates on an ordinary Observable, multicasts that Observable by means of a particular Subject that you specify, applies a transformative function to each emission, and then emits those transformed values as its own ordinary Observable sequence. Each subscription to this new Observable will trigger a new subscription to the underlying multicast Observable.\n\n#### Sample Code\n\n``` javascript\nvar subject = new Rx.Subject();\nvar source = Rx.Observable.range(0, 3)\n    .multicast(subject);\n\nvar observer = Rx.Observer.create(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); }\n);\n\nvar subscription = source.subscribe(observer);\nsubject.subscribe(observer);\n\nvar connected = source.connect();\n\nsubscription.dispose();\n```\n\n``` javascript\nNext: 0\nNext: 0\nNext: 1\nNext: 1\nNext: 2\nNext: 2\nCompleted\n```\n\nThe `multicast` operator is available in the following packages:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.binding.js` (requires either `rx.lite.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThere is also a `let` operator (the alias `letBind` is available for browsers such as Internet Explorer before IE9 where “`let`” is forbidden). It is similar to `multicast` but does not multicast the underlying Observable through a Subject:\n\n#### Sample Code\n\n``` javascript\nvar obs = Rx.Observable.range(1, 3);\n\nvar source = obs.let(function (o) { return o.concat(o); });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 1\nNext: 2\nNext: 3\nNext: 1\nNext: 2\nNext: 3\nCompleted\n```\n\nThe `let` (or `letBind`) operator is available in the following packages:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.experimental.js`\n\nIt requires one of the following packages:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `multicast multicastWithSelector publish publishLast publishValue`\n\nRxPHP implements this operator as `multicast`.\n\nMulticasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function. Each subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's invocation. For specializations with fixed subject types, see Publish, PublishLast, and Replay.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/multicast/multicast.php\n\n$subject = new \\Rx\\Subject\\Subject();\n$source  = \\Rx\\Observable::range(0, 3)->multicast($subject);\n\n$subscription = $source->subscribe($stdoutObserver);\n$subject->subscribe($stdoutObserver);\n\n$connected = $source->connect();\n```\n\n``` javascript\nNext value: 0\nNext value: 0\nNext value: 1\nNext value: 1\nNext value: 2\nNext value: 2\nComplete!\n```\n\nRxPHP also has an operator `multicastWithSelector`.\n\nMulticasts the source sequence notifications through an instantiated subject from a subject selector factory, into all uses of the sequence within a selector function. Each subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's invocation. For specializations with fixed subject types, see Publish, PublishLast, and Replay.\n\nRxPHP also has an operator `publish`.\n\nReturns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence. This operator is a specialization of Multicast using a regular Subject.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/publish/publish.php\n\n/* With publish */\n$interval = \\Rx\\Observable::range(0, 10);\n\n$source = $interval\n    ->take(2)\n    ->doOnNext(function ($x) {\n        echo \"Side effect\\n\";\n    });\n\n$published = $source->publish();\n\n$published->subscribe($createStdoutObserver('SourceC '));\n$published->subscribe($createStdoutObserver('SourceD '));\n\n$published->connect();\n```\n\n``` javascript\nSide effect\nSourceC Next value: 0\nSourceD Next value: 0\nSide effect\nSourceC Next value: 1\nSourceD Next value: 1\nSourceC Complete!\nSourceD Complete!\n```\n\nRxPHP also has an operator `publishLast`.\n\nReturns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence containing only the last notification. This operator is a specialization of Multicast using a AsyncSubject.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/publish/publishLast.php\n\n$range = \\Rx\\Observable::fromArray(range(0, 1000));\n\n$source = $range\n    ->take(2)\n    ->doOnNext(function ($x) {\n        echo \"Side effect\\n\";\n    });\n\n$published = $source->publishLast();\n\n$published->subscribe($createStdoutObserver('SourceA'));\n$published->subscribe($createStdoutObserver('SourceB'));\n\n$connection = $published->connect();\n```\n\n``` javascript\nSide effect\nSide effect\nSourceANext value: 1\nSourceBNext value: 1\nSourceAComplete!\nSourceBComplete!\n```\n\nRxPHP also has an operator `publishValue`.\n\nReturns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence and starts with initialValue. This operator is a specialization of Multicast using a BehaviorSubject.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/publish/publishValue.php\n\n$range = \\Rx\\Observable::fromArray(range(0, 1000));\n\n$source = $range\n    ->take(2)\n    ->doOnNext(function ($x) {\n        echo \"Side effect\\n\";\n    });\n\n$published = $source->publishValue(42);\n\n$published->subscribe($createStdoutObserver('SourceA'));\n$published->subscribe($createStdoutObserver('SourceB'));\n\n$connection = $published->connect();\n```\n\n``` javascript\nSourceANext value: 42\nSourceBNext value: 42\nSide effect\nSourceANext value: 0\nSourceBNext value: 0\nSide effect\nSourceANext value: 1\nSourceBNext value: 1\nSourceAComplete!\nSourceBComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/publish.html](http://reactivex.io/documentation/operators/publish.html)"
- name: Range
  id: documentation/operators/range
  summary: The Range operator emits a range of sequential integers, in order, where you select the start of the range and its length
  description: "# Range\n\ncreate an Observable that emits a particular range of sequential integers\n\nThe Range operator emits a range of sequential integers, in order, where you select the start of the range and its length.\n\n#### See Also\n\n- [Interval](interval)\n- [Introduction to Rx: Range](http://www.introtorx.com/Content/v1.0.10621.0/04_CreatingObservableSequences.html#ObservableRange)\n- [101 Rx Samples: Range](http://rxwiki.wikidot.com/101samples#toc40)\n\n## Language-Specific Information\n\n### RxGroovy `range`\n\nRxGroovy implements this operator as `range`. It accepts as its parameters the start value of the range and the number of items in the range. If you set that number of items to zero, the resulting Observable will emit no values (if you set it to a negative number, `range` will cause an exception).\n\n`range` does not by default operate on any particular [Scheduler](../scheduler), but there is a variant that allows you to set the Scheduler by passing one in as a parameter.\n\n#### Sample Code\n\n``` groovy\n// myObservable emits the integers 5, 6, and 7 before completing:\ndef myObservable = Observable.range(5, 3);\n```\n\n- Javadoc: [`range(int,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#range(int,%20int))\n- Javadoc: [`range(int,int,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#range(int,%20int%20rx.Scheduler))\n\n### RxJava 1․x `range`\n\nRxJava implements this operator as `range`. It accepts as its parameters the start value of the range and the number of items in the range. If you set that number of items to zero, the resulting Observable will emit no values (if you set it to a negative number, `range` will cause an exception).\n\n`range` does not by default operate on any particular [Scheduler](../scheduler), but there is a variant that allows you to set the Scheduler by passing one in as a parameter.\n\n- Javadoc: [`range(int,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#range(int,%20int))\n- Javadoc: [`range(int,int,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#range(int,%20int%20rx.Scheduler))\n\n### RxJS `range`\n\nRxJS implements this operator as `range`. It accepts as its parameters the start value of the range and the number of items in the range.\n\n`range` operates by default on the `currentThread` [Scheduler](../scheduler), but there is a variant that allows you to set the Scheduler by passing one in as the optional third parameter.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 3);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nCompleted\n```\n\n`range` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `range`\n\nRxPHP implements this operator as `range`.\n\nGenerates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/range/range.php\n\n$observable = \\Rx\\Observable::range(0, 3);\n\n$observable->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 0\nNext value: 1\nNext value: 2\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/range.html](http://reactivex.io/documentation/operators/range.html)"
- name: Reduce
  id: documentation/operators/reduce
  summary: The Reduce operator applies a function to the first item emitted by the source Observable and then feeds the result of the function back into the function along with the second item emitted by the source Observable, continuing this process until the source Observable emits its final item and completes, whereupon the Observable returned from Reduce emits the final value returned from the function
  description: "# Reduce\n\napply a function to each item emitted by an Observable, sequentially, and emit the final value\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#reduce)\n\nThe Reduce operator applies a function to the first item emitted by the source Observable and then feeds the result of the function back into the function along with the second item emitted by the source Observable, continuing this process until the source Observable emits its final item and completes, whereupon the Observable returned from Reduce emits the final value returned from the function.\n\nThis sort of operation is sometimes called “accumulate,” “aggregate,” “compress,” “fold,” or “inject” in other contexts.\n\n#### See Also\n\n- [Scan](scan)\n- [Introduction to Rx: Aggregate](http://www.introtorx.com/Content/v1.0.10621.0/07_Aggregation.html#Aggregate)\n- [RxMarbles: `reduce`](http://rxmarbles.com/#reduce)\n- [Experimentation with RxJava](http://blog.joanzapata.com/experimentation-with-rx/) by Joan Zapata\n\n## Language-Specific Information\n\n### RxGroovy `collect reduce`\n\nThe `reduce` operator returns an Observable that applies a function of your choosing to the first item emitted by a source Observable, then feeds the result of that function along with the second item emitted by the source Observable into the same function, then feeds the result of that function along with the third item into the same function, and so on until all items have been emitted by the source Observable. Then it emits the final result from the final call to your function as the sole output from the returned Observable.\n\nNote that if the source Observable does not emit any items, `reduce` will fail with an `IllegalArgumentException`.\n\nFor example, the following code uses `reduce` to compute, and then emit as an Observable, the sum of the numbers emitted by the source Observable:\n\n#### Sample Code\n\n``` groovy\nnumbers = Observable.from([1, 2, 3, 4, 5]);\n\nnumbers.reduce({ a, b -> a+b }).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n15\nSequence complete\n```\n\n`reduce` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`reduce(Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#reduce(rx.functions.Func2))\n\nThere is also a version of `reduce` to which you can pass a seed item in addition to an accumulator function. Note that passing a `null` seed is not the same as not passing a seed. The behavior will be different. If you pass a seed of `null`, you will be seeding your reduction with the item `null`. Note also that if you do pass in a seed, and the source Observable emits no items, reduce will emit the seed and complete normally without error.\n\n`reduce` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`reduce(R,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#reduce(R,%20rx.functions.Func2))\n\nIt is a bad idea to use `reduce` to collect emitted items into a mutable data structure. Instead, use `collect` for that purpose.\n\nThe `collect` operator is similar to `reduce` but is specialized for the purpose of collecting the whole set of items emitted by the source Observable into a single mutable data structure to be emitted by the resulting Observable. Pass it two parameters:\n\n1.  a function that returns the mutable data structure\n2.  a function that, when given the data structure and an item emitted by the source Observable, modifies the data structure appropriately\n\n`collect` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`collect(Func0,Action2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#collect(rx.functions.Func0,%20rx.functions.Action2))\n\n### RxJava 1․x `collect reduce`\n\nThe `reduce` operator returns an Observable that applies a function of your choosing to the first item emitted by a source Observable, then feeds the result of that function along with the second item emitted by the source Observable into the same function, then feeds the result of that function along with the third item into the same function, and so on until all items have been emitted by the source Observable. Then it emits the final result from the final call to your function as the sole output from the returned Observable.\n\nNote that if the source Observable does not emit any items, `reduce` will fail with an `IllegalArgumentException`.\n\n`reduce` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`reduce(Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#reduce(rx.functions.Func2))\n\nThere is also a version of `reduce` to which you can pass a seed item in addition to an accumulator function. Note that passing a `null` seed is not the same as not passing a seed. The behavior will be different. If you pass a seed of `null`, you will be seeding your reduction with the item `null`. Note also that if you do pass in a seed, and the source Observable emits no items, reduce will emit the seed and complete normally without error.\n\n`reduce` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`reduce(R,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#reduce(R,%20rx.functions.Func2))\n\nIt is a bad idea to use `reduce` to collect emitted items into a mutable data structure. Instead, use `collect` for that purpose.\n\nThe `collect` operator is similar to `reduce` but is specialized for the purpose of collecting the whole set of items emitted by the source Observable into a single mutable data structure to be emitted by the resulting Observable. Pass it two parameters:\n\n1.  a function that returns the mutable data structure\n2.  a function that, when given the data structure and an item emitted by the source Observable, modifies the data structure appropriately\n\n`collect` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`collect(Func0,Action2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#collect(rx.functions.Func0,%20rx.functions.Action2))\n\n### RxJS `reduce`\n\nRxJS implements the `reduce` operator. Pass it an accumulator function, and, optionally, a seed value to pass into the accumulator function with the first item emitted by the source Observable.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(1, 3)\n    .reduce(function (acc, x) {\n        return acc * x;\n    }, 1)\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 6\nCompleted\n```\n\n`reduce` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\n`reduce` requires one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `reduce`\n\nRxPHP implements this operator as `reduce`.\n\nApplies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/reduce/reduce.php\n\n//Without a seed\n$source = \\Rx\\Observable::fromArray(range(1, 3));\n\n$subscription = $source\n    ->reduce(function ($acc, $x) {\n        return $acc + $x;\n    })\n    ->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 6\nComplete!\n```\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/reduce/reduce-with-seed.php\n\n//With a seed\n$source = \\Rx\\Observable::fromArray(range(1, 3));\n\n$subscription = $source\n    ->reduce(function ($acc, $x) {\n        return $acc * $x;\n    }, 1)\n    ->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 6\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/reduce.html](http://reactivex.io/documentation/operators/reduce.html)"
- name: RefCount
  id: documentation/operators/refcount
  summary: A connectable Observable resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when the Connect operator is applied to it
  description: "# RefCount\n\nmake a Connectable Observable behave like an ordinary Observable\n\nA connectable Observable resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when the Connect operator is applied to it. In this way you can prompt an Observable to begin emitting items at a time of your choosing.\n\nThe RefCount operator automates the process of connecting to and disconnecting from a connectable Observable. It operates on a connectable Observable and returns an ordinary Observable. When the first observer subscribes to this Observable, RefCount connects to the underlying connectable Observable. RefCount then keeps track of how many other observers subscribe to it and does not disconnect from the underlying connectable Observable until the last observer has done so.\n\n#### See Also\n\n- [Connect](connect)\n- [Publish](publish)\n- [Replay](replay)\n- [Introduction to Rx: RefCount](http://www.introtorx.com/Content/v1.0.10621.0/14_HotAndColdObservables.html#RefCount)\n- [Wedding Party: Share, Publish, Refcount, and All That Jazz](http://blog.kaush.co/2015/01/21/rxjava-tip-for-the-day-share-publish-refcount-and-all-that-jazz/) by Kaushik Gopal\n\n## Language-Specific Information\n\n### RxGroovy `refCount share`\n\nRxGroovy implements this operator as `refCount`.\n\n- Javadoc: [`refCount()`](http://reactivex.io/RxJava/javadoc/rx/observables/ConnectableObservable.html#refCount())\n\nThere is also a `share` operator, which is the equivalent of applying both the `publish` and `refCount` operators to an Observable, in that order.\n\n- Javadoc: [`share()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#share())\n\n### RxJava 1․x `refCount share`\n\nRxJava implements this operator as `refCount`.\n\n- Javadoc: [`refCount()`](http://reactivex.io/RxJava/javadoc/rx/observables/ConnectableObservable.html#refCount())\n\nThere is also a `share` operator, which is the equivalent of applying both the `publish` and `refCount` operators to an Observable, in that order.\n\n- Javadoc: [`share()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#share())\n\n### RxJS `refCount share shareValue`\n\nRxJava implements this operator as `refCount`.\n\n#### Sample Code\n\n``` javascript\nvar interval = Rx.Observable.interval(1000);\n\nvar source = interval\n    .take(2)\n    .doAction(function (x) { console.log('Side effect'); });\n\nvar published = source.publish().refCount();\n\npublished.subscribe(createObserver('SourceA'));\npublished.subscribe(createObserver('SourceB'));\n\nfunction createObserver(tag) {\n    return Rx.Observer.create(\n        function (x) { console.log('Next: ' + tag + x); },\n        function (err) { console.log('Error: ' + err); },\n        function () { console.log('Completed'); });\n}\n```\n\n``` javascript\nSide effect\nNext: SourceA0\nNext: SourceB0\nSide effect\nNext: SourceA1\nNext: SourceB1\nCompleted\nCompleted\n```\n\n`refCount` is found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.binding.js` (requires `rx.js`, `rx.compat.js`, `rx.lite.js`, or `rx.lite.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThere is also a `share` operator, which is the equivalent of applying both the `publish` and `refCount` operators to an Observable, in that order. A variant called `shareValue` takes as a parameter a single item that it will emit to any subscribers before beginning to emit items from the source Observable.\n\n#### Sample Code\n\n``` javascript\nvar interval = Rx.Observable.interval(1000);\n\nvar source = interval\n    .take(2)\n    .do(\n        function (x) { console.log('Side effect'); });\n\nvar published = source.share();\n\n// When the number of observers subscribed to published observable goes from\n// 0 to 1, we connect to the underlying observable sequence.\npublished.subscribe(createObserver('SourceA'));\n// When the second subscriber is added, no additional subscriptions are added to the\n// underlying observable sequence. As a result the operations that result in side\n// effects are not repeated per subscriber.\npublished.subscribe(createObserver('SourceB'));\n\nfunction createObserver(tag) {\n    return Rx.Observer.create(\n        function (x) { console.log('Next: ' + tag + x); },\n        function (err) { console.log('Error: ' + err); },\n        function () { console.log('Completed'); });\n}\n```\n\n``` javascript\nSide effect\nNext: SourceA0\nNext: SourceB0\nSide effect\nNext: SourceA1\nNext: SourceB1\nCompleted\n```\n\n`share` and `shareValue` are found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.binding.js` (requires `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `share singleInstance shareValue`\n\nRxPHP implements this operator as `share`.\n\nReturns an observable sequence that shares a single subscription to the underlying sequence. This operator is a specialization of publish which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/share/share.php\n\n//With Share\n$source = \\Rx\\Observable::interval(1000)\n    ->take(2)\n    ->doOnNext(function ($x) {\n        echo \"Side effect\\n\";\n    });\n\n$published = $source->share();\n\n$published->subscribe($createStdoutObserver('SourceA '));\n$published->subscribe($createStdoutObserver('SourceB '));\n```\n\n``` javascript\nSide effect\nSourceA Next value: 0\nSourceB Next value: 0\nSide effect\nSourceA Next value: 1\nSourceB Next value: 1\nSourceA Complete!\nSourceB Complete!\n```\n\nRxPHP also has an operator `singleInstance`.\n\nReturns an observable sequence that shares a single subscription to the underlying sequence. This observable sequence can be resubscribed to, even if all prior subscriptions have ended. This operator behaves like share() in RxJS 5\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/share/singleInstance.php\n\n$interval = Rx\\Observable::interval(1000);\n\n$source = $interval\n    ->take(2)\n    ->do(function () {\n        echo 'Side effect', PHP_EOL;\n    });\n\n$single = $source->singleInstance();\n\n// two simultaneous subscriptions, lasting 2 seconds\n$single->subscribe($createStdoutObserver('SourceA '));\n$single->subscribe($createStdoutObserver('SourceB '));\n\n\\Rx\\Observable::timer(5000)->subscribe(function () use ($single, &$createStdoutObserver) {\n    // resubscribe two times again, more than 5 seconds later,\n    // long after the original two subscriptions have ended\n    $single->subscribe($createStdoutObserver('SourceC '));\n    $single->subscribe($createStdoutObserver('SourceD '));\n});\n```\n\n``` javascript\nSide effect\nSourceA Next value: 0\nSourceB Next value: 0\nSide effect\nSourceA Next value: 1\nSourceB Next value: 1\nSourceA Complete!\nSourceB Complete!\nSide effect\nSourceC Next value: 0\nSourceD Next value: 0\nSide effect\nSourceC Next value: 1\nSourceD Next value: 1\nSourceC Complete!\nSourceD Complete!\n```\n\nRxPHP also has an operator `shareValue`.\n\nReturns an observable sequence that shares a single subscription to the underlying sequence and starts with an initialValue. This operator is a specialization of publishValue which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/share/shareValue.php\n\n$source = \\Rx\\Observable::interval(1000)\n    ->take(2)\n    ->doOnNext(function ($x) {\n        echo \"Side effect\\n\";\n    });\n\n$published = $source->shareValue(42);\n\n$published->subscribe($createStdoutObserver('SourceA '));\n$published->subscribe($createStdoutObserver('SourceB '));\n```\n\n``` javascript\nSourceA Next value: 42\nSourceB Next value: 42\nSide effect\nSourceA Next value: 0\nSourceB Next value: 0\nSide effect\nSourceA Next value: 1\nSourceB Next value: 1\nSourceA Complete!\nSourceB Complete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/refcount.html](http://reactivex.io/documentation/operators/refcount.html)"
- name: Repeat
  id: documentation/operators/repeat
  summary: The Repeat operator emits an item repeatedly
  description: "# Repeat\n\ncreate an Observable that emits a particular item multiple times\n\nThe Repeat operator emits an item repeatedly. Some implementations of this operator allow you to repeat a *sequence* of items, and some permit you to limit the number of repetitions.\n\n#### See Also\n\n- [Interval](interval)\n- [Range](range)\n- [Introduction to Rx: Repeat](http://www.introtorx.com/Content/v1.0.10621.0/12_CombiningSequences.html#Repeat)\n\n## Language-Specific Information\n\n### RxGroovy `doWhile repeat repeatWhen whileDo`\n\nRxGroovy implements this operator as `repeat`. It does not initiate an Observable, but operates on an Observable in such a way that it repeats the sequence emitted by the source Observable as its own sequence, either infinitely, or in the case of `repeat(`*`n`*`)`, *n* times.\n\n`repeat` operates by default on the `trampoline` [Scheduler](../scheduler). There is also a variant that allows you to set the Scheduler by passing one in as a parameter.\n\n- Javadoc: [`repeat()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeat())\n- Javadoc: [`repeat(long)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeat(long))\n- Javadoc: [`repeat(Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeat(rx.Scheduler))\n- Javadoc: [`repeat(long,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeat(long,%20rx.Scheduler))\n\nThere is also an operator called `repeatWhen`. Rather than buffering and replaying the sequence from the source Observable, it *resubscribes* to and mirrors the source Observable, but only conditionally.\n\nIt decides whether to resubscribe and remirror the source Observable by passing that Observable’s termination notifications (error or completed) to a notification handler as `void` emissions. This notification handler acts as an Observable operator, taking an Observable that emits these `void` notifications as input, and returning an Observable that emits `void` items (meaning, resubscribe and mirror the source Observable) or terminates (meaning, terminate the sequence emitted by `repeatWhen`).\n\n`repeatWhen` operates by default on the `trampoline` [Scheduler](../scheduler). There is also a variant that allows you to set the Scheduler by passing one in as a parameter.\n\n- Javadoc: [`repeatWhen(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeatWhen(rx.functions.Func1))\n- Javadoc: [`repeatWhen(Func1,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeatWhen(rx.functions.Func1,%20rx.Scheduler))\n\nIn RxGroovy, `doWhile` is not part of the standard set of operators, but is part of the optional `rxjava-computation-expressions` package. `doWhile` checks a condition after each repetition of the source sequence, and only repeats it if that condition is true.\n\nIn RxGroovy, `whileDo` is not part of the standard set of operators, but is part of the optional `rxjava-computation-expressions` package. `whileDo` checks a condition before each repetition of the source sequence, and only repeats it if that condition is true.\n\n### RxJava 1․x `doWhile repeat repeatWhen whileDo`\n\nRxJava implements this operator as `repeat`. It does not initiate an Observable, but operates on an Observable in such a way that it repeats the sequence emitted by the source Observable as its own sequence, either infinitely, or in the case of `repeat(`*`n`*`)`, *n* times.\n\n`repeat` operates by default on the `trampoline` [Scheduler](../scheduler). There is also a variant that allows you to set the Scheduler by passing one in as a parameter.\n\n- Javadoc: [`repeat()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeat())\n- Javadoc: [`repeat(long)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeat(long))\n- Javadoc: [`repeat(Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeat(rx.Scheduler))\n- Javadoc: [`repeat(long,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeat(long,%20rx.Scheduler))\n\nThere is also an operator called `repeatWhen`. Rather than buffering and replaying the sequence from the source Observable, it *resubscribes* to and mirrors the source Observable, but only conditionally.\n\nIt decides whether to resubscribe and remirror the source Observable by passing that Observable’s termination notifications (error or completed) to a notification handler as `void` emissions. This notification handler acts as an Observable operator, taking an Observable that emits these `void` notifications as input, and returning an Observable that emits `void` items (meaning, resubscribe and mirror the source Observable) or terminates (meaning, terminate the sequence emitted by `repeatWhen`).\n\n`repeatWhen` operates by default on the `trampoline` [Scheduler](../scheduler). There is also a variant that allows you to set the Scheduler by passing one in as a parameter.\n\n- Javadoc: [`repeatWhen(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeatWhen(rx.functions.Func1))\n- Javadoc: [`repeatWhen(Func1,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeatWhen(rx.functions.Func1,%20rx.Scheduler))\n\nIn RxJava, `doWhile` is not part of the standard set of operators, but is part of the optional `rxjava-computation-expressions` package. `doWhile` checks a condition after each repetition of the source sequence, and only repeats it if that condition is true.\n\nIn RxJava, `whileDo` is not part of the standard set of operators, but is part of the optional `rxjava-computation-expressions` package. `whileDo` checks a condition before each repetition of the source sequence, and only repeats it if that condition is true.\n\n### RxJS `doWhile repeat while`\n\nRxJS implements this operator as `repeat`. It accepts as its parameter the item to repeat, and optionally two other parameters: the number of times you want the item to repeat, and the [Scheduler](../scheduler) on which you want to perform this operation (it uses the `immediate` Scheduler by default).\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.repeat(42, 3);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 42\nNext: 42\nNext: 42\nCompleted\n```\n\n`repeat` is found in the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nRxJS also implements the `doWhile` operator. It repeats the source Observable’s sequence of emissions only so long as a condition you specify remains true.\n\n``` javascript\nvar i = 0;\n\nvar source = Rx.Observable.return(42).doWhile(\n    function (x) { return ++i < 2; });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 42\nNext: 42\nCompleted\n```\n\n`doWhile` is found in each of the following distributions.\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.experimental.js`\n\nIt requires one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nRxJS also implements the `while` operator. It repeats the source Observable’s sequence of emissions only if a condition you specify is true.\n\n``` javascript\nvar i = 0;\n\n// Repeat until condition no longer holds\nvar source = Rx.Observable.while(\n    function () { return i++ < 3 },\n    Rx.Observable.return(42)\n);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 42\nNext: 42\nNext: 42\nCompleted\n```\n\n`while` is found in the `rx.experimental.js` distribution. It requires one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `repeat repeatWhen`\n\nRxPHP implements this operator as `repeat`.\n\nGenerates an observable sequence that repeats the given element the specified number of times.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/repeat/repeat.php\n\n$source = \\Rx\\Observable::range(1, 3)\n    ->repeat(3);\n\n$subscription = $source->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 1\nNext value: 2\nNext value: 3\nNext value: 1\nNext value: 2\nNext value: 3\nNext value: 1\nNext value: 2\nNext value: 3\nComplete!\n```\n\nRxPHP also has an operator `repeatWhen`.\n\nReturns an Observable that emits the same values as the source Observable with the exception of an onCompleted. An onCompleted notification from the source will result in the emission of a count item to the Observable provided as an argument to the notificationHandler function. If that Observable calls onComplete or onError then repeatWhen will call onCompleted or onError on the child subscription. Otherwise, this Observable will resubscribe to the source observable.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/repeat/repeatWhen.php\n\n$source = Rx\\Observable::of(42)\n    ->repeatWhen(function (\\Rx\\Observable $notifications) {\n        return $notifications\n            ->scan(function ($acc, $x) {\n                return $acc + $x;\n            }, 0)\n            ->delay(1000)\n            ->doOnNext(function () {\n                echo \"1 second delay\", PHP_EOL;\n            })\n            ->takeWhile(function ($count) {\n                return $count < 2;\n            });\n    });\n\n$subscription = $source->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 42\n1 second delay\nNext value: 42\n1 second delay\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/repeat.html](http://reactivex.io/documentation/operators/repeat.html)"
- name: Replay
  id: documentation/operators/replay
  summary: A connectable Observable resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when the Connect operator is applied to it
  description: "# Replay\n\nensure that all observers see the same sequence of emitted items, even if they subscribe after the Observable has begun emitting items\n\nA connectable Observable resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when the Connect operator is applied to it. In this way you can prompt an Observable to begin emitting items at a time of your choosing.\n\nIf you apply the Replay operator to an Observable before you convert it into a connectable Observable, the resulting connectable Observable will always emit the same complete sequence to any future observers, even those observers that subscribe after the connectable Observable has begun to emit items to other subscribed observers.\n\n#### See Also\n\n- [Connect](connect)\n- [Publish](publish)\n- [RefCount](refcount)\n- [Introduction to Rx: Replay](http://www.introtorx.com/Content/v1.0.10621.0/14_HotAndColdObservables.html#Replay)\n\n## Language-Specific Information\n\n### RxGroovy `replay cache`\n\nIn RxGroovy there is a variety of the `replay` operator that returns a connectable Observable. You must [Publish](publish) this connectable Observable before observers can subscribe to it, and then [Connect](connect) to it in order to observe its emissions.\n\nVariants of this variety of the `replay` operator permit you to set a maximum buffer size to limit the number of items `replay` will buffer and replay to subsequent observers, and/or to establish a moving time window that defines when emitted items become too old to buffer and replay.\n\n- Javadoc: [`replay()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay())\n- Javadoc: [`replay(Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.Scheduler))\n- Javadoc: [`replay(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int))\n- Javadoc: [`replay(int,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int,%20rx.Scheduler))\n- Javadoc: [`replay(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`replay(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n- Javadoc: [`replay(int,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`replay(int,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nThere is also a variety of `replay` that returns an ordinary Observable. These variants take as a parameter a transformative function; this function accepts an item emitted by the source Observable as its parameter, and returns an item to be emitted by the resulting Observable. So really, this operator does not replay the source Observable but instead replays the source Observable *as transformed* by this function.\n\nVariants of this variety of the `replay` operator permit you to set a maximum buffer size to limit the number of items `replay` will buffer and replay to subsequent observers, and/or to establish a moving time window that defines when emitted items become too old to buffer and replay.\n\n- Javadoc: [`replay(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1))\n- Javadoc: [`replay(Func1,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20rx.Scheduler))\n- Javadoc: [`replay(Func1,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int))\n- Javadoc: [`replay(Func1,int,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int,%20rx.Scheduler))\n- Javadoc: [`replay(Func1,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`replay(Func1,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n- Javadoc: [`replay(Func1,int,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`replay(Func1,int,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n### RxJava 1․x `cache replay`\n\nIn RxJava there is a variety of the `replay` operator that returns a connectable Observable. You must [Publish](publish) this connectable Observable before observers can subscribe to it, and then [Connect](connect) to it in order to observe its emissions.\n\nVariants of this variety of the `replay` operator permit you to set a maximum buffer size to limit the number of items `replay` will buffer and replay to subsequent observers, and/or to establish a moving time window that defines when emitted items become too old to buffer and replay.\n\n- Javadoc: [`replay()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay())\n- Javadoc: [`replay(Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.Scheduler))\n- Javadoc: [`replay(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int))\n- Javadoc: [`replay(int,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int,%20rx.Scheduler))\n- Javadoc: [`replay(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`replay(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n- Javadoc: [`replay(int,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`replay(int,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nThere is also a variety of `replay` that returns an ordinary Observable. These variants take as a parameter a transformative function; this function accepts an item emitted by the source Observable as its parameter, and returns an item to be emitted by the resulting Observable. So really, this operator does not replay the source Observable but instead replays the source Observable *as transformed* by this function.\n\nVariants of this variety of the `replay` operator permit you to set a maximum buffer size to limit the number of items `replay` will buffer and replay to subsequent observers, and/or to establish a moving time window that defines when emitted items become too old to buffer and replay.\n\n- Javadoc: [`replay(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1))\n- Javadoc: [`replay(Func1,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20rx.Scheduler))\n- Javadoc: [`replay(Func1,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int))\n- Javadoc: [`replay(Func1,int,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int,%20rx.Scheduler))\n- Javadoc: [`replay(Func1,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`replay(Func1,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n- Javadoc: [`replay(Func1,int,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`replay(Func1,int,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n### RxJS `replay shareReplay`\n\nIn RxJs the `replay` operator takes four optional parameters and returns an ordinary Observable:\n\n`selector`  \na transforming function that takes an item emitted by the source Observable as its parameter and returns an item to be emitted by the resulting Observable\n\n`bufferSize`  \nthe maximum number of items to buffer and replay to subsequent observers\n\n`window`  \nthe age, in milliseconds, at which items in this buffer may be discarded without being emitted to subsequent observers\n\n`scheduler`  \nthe [Scheduler](../scheduler) on which this operator will operate\n\n#### Sample Code\n\n``` javascript\nvar interval = Rx.Observable.interval(1000);\n\nvar source = interval\n    .take(2)\n    .do(function (x) {\n        console.log('Side effect');\n    });\n\nvar published = source\n    .replay(function (x) {\n        return x.take(2).repeat(2);\n    }, 3);\n\npublished.subscribe(createObserver('SourceA'));\npublished.subscribe(createObserver('SourceB'));\n\nfunction createObserver(tag) {\n    return Rx.Observer.create(\n        function (x) { console.log('Next: ' + tag + x); },\n        function (err) { console.log('Error: ' + err); },\n        function () { console.log('Completed'); });\n}\n```\n\n``` javascript\nSide effect\nNext: SourceA0\nSide effect\nNext: SourceB0\nSide effect\nNext: SourceA1\nNext: SourceA0\nNext: SourceA1\nCompleted\nSide effect\nNext: SourceB1\nNext: SourceB0\nNext: SourceB1\nCompleted\n```\n\nThere is also a `shareReplay` operator, which keeps track of the number of observers, and disconnects from the source Observable when that number drops to zero. `shareReplay` takes three optional parameters and returns an ordinary Observable:\n\n`bufferSize`  \nthe maximum number of items to buffer and replay to subsequent observers\n\n`window`  \nthe age, in milliseconds, at which items in this buffer may be discarded without being emitted to subsequent observers\n\n`scheduler`  \nthe [Scheduler](../scheduler) on which this operator will operate\n\n#### Sample Code\n\n``` javascript\nvar interval = Rx.Observable.interval(1000);\n\nvar source = interval\n    .take(4)\n    .doAction(function (x) {\n        console.log('Side effect');\n    });\n\nvar published = source\n    .shareReplay(3);\n\npublished.subscribe(createObserver('SourceA'));\npublished.subscribe(createObserver('SourceB'));\n\n// Creating a third subscription after the previous two subscriptions have\n// completed. Notice that no side effects result from this subscription,\n// because the notifications are cached and replayed.\nRx.Observable\n    .return(true)\n    .delay(6000)\n    .flatMap(published)\n    .subscribe(createObserver('SourceC'));\n\nfunction createObserver(tag) {\n    return Rx.Observer.create(\n        function (x) { console.log('Next: ' + tag + x); },\n        function (err) { console.log('Error: ' + err); },\n        function () { console.log('Completed'); });\n}\n```\n\n``` javascript\nSide effect\nNext: SourceA0\nNext: SourceB0\nSide effect\nNext: SourceA1\nNext: SourceB1\nSide effect\nNext: SourceA2\nNext: SourceB2\nSide effect\nNext: SourceA3\nNext: SourceB3\nCompleted\nCompleted\nNext: SourceC1\nNext: SourceC2\nNext: SourceC3\nCompleted\n```\n\n`replay` and `shareReplay` are found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.binding.js` (requires `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `replay shareReplay`\n\nRxPHP implements this operator as `replay`.\n\nReturns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer. This operator is a specialization of Multicast using a ReplaySubject.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/replay/replay.php\n\n$interval = \\Rx\\Observable::interval(1000);\n\n$source = $interval\n    ->take(2)\n    ->doOnNext(function ($x) {\n        echo $x, ' something', PHP_EOL;\n        echo 'Side effect', PHP_EOL;\n    });\n\n$published = $source\n    ->replay(function (\\Rx\\Observable $x) {\n        return $x->take(2)->repeat(2);\n    }, 3);\n\n$published->subscribe($createStdoutObserver('SourceA '));\n$published->subscribe($createStdoutObserver('SourceB '));\n```\n\n``` javascript\n0 something\nSide effect\n0 something\nSide effect\nSourceA Next value: 0\nSourceB Next value: 0\nSourceA Next value: 0\nSourceB Next value: 0\nSourceA Next value: 0\nSourceB Next value: 0\nSourceA Next value: 0\nSourceA Complete!\nSourceB Next value: 0\nSourceB Complete!\n1 something\nSide effect\n1 something\nSide effect\n```\n\nRxPHP also has an operator `shareReplay`.\n\nReturns an observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer. This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/share/shareReplay.php\n\n$interval = Rx\\Observable::interval(1000);\n\n$source = $interval\n    ->take(4)\n    ->doOnNext(function ($x) {\n        echo 'Side effect', PHP_EOL;\n    });\n\n$published = $source\n    ->shareReplay(3);\n\n$published->subscribe($createStdoutObserver('SourceA '));\n$published->subscribe($createStdoutObserver('SourceB '));\n\nRx\\Observable\n    ::of(true)\n    ->concatMapTo(\\Rx\\Observable::timer(6000))\n    ->flatMap(function () use ($published) {\n        return $published;\n    })\n    ->subscribe($createStdoutObserver('SourceC '));\n```\n\n``` javascript\nSide effect\nSourceA Next value: 0\nSourceB Next value: 0\nSide effect\nSourceA Next value: 1\nSourceB Next value: 1\nSide effect\nSourceA Next value: 2\nSourceB Next value: 2\nSide effect\nSourceA Next value: 3\nSourceB Next value: 3\nSourceA Complete!\nSourceB Complete!\nSourceC Next value: 1\nSourceC Next value: 2\nSourceC Next value: 3\nSourceC Complete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/replay.html](http://reactivex.io/documentation/operators/replay.html)"
- name: Retry
  id: documentation/operators/retry
  summary: The Retry operator responds to an onError notification from the source Observable by not passing that call through to its observers, but instead by resubscribing to the source Observable and giving it another opportunity to complete its sequence without error
  description: "# Retry\n\nif a source Observable emits an error, resubscribe to it in the hopes that it will complete without error\n\nThe Retry operator responds to an `onError` notification from the source Observable by not passing that call through to its observers, but instead by resubscribing to the source Observable and giving it another opportunity to complete its sequence without error. Retry always passes `onNext` notifications through to its observers, even from sequences that terminate with an error, so this can cause duplicate emissions (as shown in the diagram above).\n\n#### See Also\n\n- [Catch](catch)\n- [Introduction to Rx: Retry](http://www.introtorx.com/Content/v1.0.10621.0/11_AdvancedErrorHandling.html#Retry)\n\n## Language-Specific Information\n\n### RxClojure\n\nRxClojure does not implement the Retry operator.\n\n### RxCpp `retry`\n\nRxCpp implements this operator as `retry`:\n\n`retry` takes a single argument, a count of the number of times it should try resubscribing to the source Observable when it encounters errors. If this count is exceeded, `retry` will not attempt to resubscribe and will instead pass the `onError` notification to its observers.\n\n### RxGroovy `retry retryWhen`\n\nRxGroovy has two versions of this operator: `retry` and `retryWhen`.\n\nOne variant of `retry` takes no parameters. It will continue to resubscribe to and mirror the source Observable no matter how many `onError` notifications it receives.\n\nAnother variant of `retry` takes a single parameter: a count of the number of times it should try to resubscribe to the source Observable when it encounters errors. If this count is exceeded, `retry` will not attempt to resubscribe again and will instead pass the latest `onError` notification to its observers.\n\nA third variant of `retry` takes a predicate function as a parameter. You write this function to accept two arguments: an Integer count of how many retries have taken place thusfar, and a Throwable indicating the error that caused the `onError` notification. This function returns a Boolean to indicate whether or not `retry` should resubscribe to and mirror the source Observable. If it does not, then `retry` passes the latest `onError` notification to its observers.\n\n`retry` by default operates on the `trampoline` [Scheduler](../scheduler).\n\n- Javadoc: [`retry()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#retry())\n- Javadoc: [`retry(long)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#retry(long))\n- Javadoc: [`retry(Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#retry(rx.functions.Func2))\n\nThe `retryWhen` operator is similar to `retry` but decides whether or not to resubscribe to and mirror the source Observable by passing the Throwable from the `onError` notification to a function that generates a second Observable, and observes its result to determine what to do. If that result is an emitted item, `retryWhen` resubscribes to and mirrors the source and the process repeats; if that result is an `onError` notification, `retryWhen` passes this notification on to its observers and terminates.\n\n`retryWhen` by default operates on the `trampoline` [Scheduler](../scheduler), and there is also a version that accepts a Scheduler as a parameter.\n\n- Javadoc: [`retryWhen(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#retryWhen(rx.functions.Func1))\n- Javadoc: [`retryWhen(Func1,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#retryWhen(rx.functions.Func1,%20rx.Scheduler))\n\n### RxJava 1․x `retry retryWhen`\n\nRxJava has two versions of this operator: `retry` and `retryWhen`.\n\nOne variant of `retry` takes no parameters. It will continue to resubscribe to and mirror the source Observable no matter how many `onError` notifications it receives.\n\nAnother variant of `retry` takes a single parameter: a count of the number of times it should try to resubscribe to the source Observable when it encounters errors. If this count is exceeded, `retry` will not attempt to resubscribe again and will instead pass the latest `onError` notification to its observers.\n\nA third variant of `retry` takes a predicate function as a parameter. You write this function to accept two arguments: an Integer count of how many retries have taken place thusfar, and a Throwable indicating the error that caused the `onError` notification. This function returns a Boolean to indicate whether or not `retry` should resubscribe to and mirror the source Observable. If it does not, then `retry` passes the latest `onError` notification to its observers.\n\n`retry` by default operates on the `trampoline` [Scheduler](../scheduler).\n\n- Javadoc: [`retry()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#retry())\n- Javadoc: [`retry(long)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#retry(long))\n- Javadoc: [`retry(Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#retry(rx.functions.Func2))\n\nThe `retryWhen` operator is similar to `retry` but decides whether or not to resubscribe to and mirror the source Observable by passing the Throwable from the `onError` notification to a function that generates a second Observable, and observes its result to determine what to do. If that result is an emitted item, `retryWhen` resubscribes to and mirrors the source and the process repeats; if that result is an `onError` notification, `retryWhen` passes this notification on to its observers and terminates.\n\n`retryWhen` by default operates on the `trampoline` [Scheduler](../scheduler), and there is also a version that accepts a Scheduler as a parameter.\n\n#### Sample Code\n\n``` java\nObservable.create((Subscriber<? super String> s) -> {\n      System.out.println(\"subscribing\");\n      s.onError(new RuntimeException(\"always fails\"));\n  }).retryWhen(attempts -> {\n      return attempts.zipWith(Observable.range(1, 3), (n, i) -> i).flatMap(i -> {\n          System.out.println(\"delay retry by \" + i + \" second(s)\");\n          return Observable.timer(i, TimeUnit.SECONDS);\n      });\n  }).toBlocking().forEach(System.out::println);\n```\n\n``` javascript\nsubscribing\ndelay retry by 1 second(s)\nsubscribing\ndelay retry by 2 second(s)\nsubscribing\ndelay retry by 3 second(s)\nsubscribing\n```\n\n- Javadoc: [`retryWhen(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#retryWhen(rx.functions.Func1))\n- Javadoc: [`retryWhen(Func1,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#retryWhen(rx.functions.Func1,%20rx.Scheduler))\n\n### RxJS `retry`\n\nRxJS implements this operator as `retry`.\n\nOne variant of `retry` takes no parameters. It will continue to resubscribe to and mirror the source Observable no matter how many `onError` notifications it receives.\n\nAnother variant of `retry` takes a single parameter: a count of the number of `onError` notification it should be willing to accept before it too fails and passes the `onError` to its observers. For example, `retry(2)` means that `retry` will resubscribe to and mirror the source Observable the first time it receives an `onError` notification, but will terminate with an error the second time this happens.\n\n`retry` is found in the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxKotlin `retry retryWhen`\n\nRxKotlin has two versions of this operator: `retry` and `retryWhen`.\n\nOne variant of `retry` takes no parameters. It will continue to resubscribe to and mirror the source Observable no matter how many `onError` notifications it receives.\n\nAnother variant of `retry` takes a single parameter: a count of the number of times it should try to resubscribe to the source Observable when it encounters errors. If this count is exceeded, `retry` will not attempt to resubscribe again and will instead pass the latest `onError` notification to its observers.\n\nA third variant of `retry` takes a predicate function as a parameter. You write this function to accept two arguments: an Integer count of how many retries have taken place thusfar, and a Throwable indicating the error that caused the `onError` notification. This function returns a Boolean to indicate whether or not `retry` should resubscribe to and mirror the source Observable. If it does not, then `retry` passes the latest `onError` notification to its observers.\n\nThe `retryWhen` operator is similar to `retry` but decides whether or not to resubscribe to and mirror the source Observable by passing the Throwable from the `onError` notification to a function that generates a second Observable, and observes its result to determine what to do. If that result is an emitted item, `retryWhen` resubscribes to and mirrors the source and the process repeats; if that result is an `onError` notification, `retryWhen` passes this notification on to its observers and terminates.\n\n### RxNET `Retry`\n\nRx.NET implements this operator as `Retry`.\n\nOne variant of `Retry` takes no parameters. It will continue to resubscribe to and mirror the source Observable no matter how many `onError` notifications it receives.\n\nAnother variant of `Retry` takes a single parameter: a count of the number of `onError` notification it should be willing to accept before it too fails and passes the `onError` to its observers. For example, `Retry(2)` means that `Retry` will resubscribe to and mirror the source Observable the first time it receives an `onError` notification, but will terminate with an error the second time this happens.\n\n### RxPHP `retry retryWhen`\n\nRxPHP implements this operator as `retry`.\n\nRepeats the source observable sequence the specified number of times or until it successfully terminates. If the retry count is not specified, it retries indefinitely. Note if you encounter an error and want it to retry once, then you must use -\\>retry(2).\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/retry/retry.php\n\n$count = 0;\n\n$observable = Rx\\Observable::interval(1000)\n    ->flatMap(function ($x) use (&$count) {\n        if (++$count < 2) {\n            return Rx\\Observable::error(new \\Exception('Something'));\n        }\n        return Rx\\Observable::of(42);\n    })\n    ->retry(3)\n    ->take(1);\n\n$observable->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 42\nComplete!\n```\n\nRxPHP also has an operator `retryWhen`.\n\nRepeats the source observable sequence on error when the notifier emits a next value. If the source observable errors and the notifier completes, it will complete the source sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/retry/retryWhen.php\n\n$source = Rx\\Observable::interval(1000)\n    ->map(function ($n) {\n        if ($n === 2) {\n            throw new Exception();\n        }\n        return $n;\n    })\n    ->retryWhen(function (\\Rx\\Observable $errors) {\n        return $errors->delay(200);\n    })\n    ->take(6);\n\n$subscription = $source->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 0\nNext value: 1\nNext value: 0\nNext value: 1\nNext value: 0\nNext value: 1\nComplete!\n```\n\n### RxPY `retry`\n\nRxPY implements this operator as `retry`:\n\n`retry` takes a single optional parameter, a count of the number of times it should try resubscribing to and mirroring the source Observable when it encounters errors. If this count is exceeded, `retry` will not attempt to resubscribe and will instead pass the `onError` notification to its observers. If you omit this parameter, `retry` will attempt to resubscribe and mirror indefinitely, no matter how many `onError` notifications it receives.\n\n### Rxrb `retry retry_infinitely`\n\nRx.rb has two versions of this operator: `retry` and `retry_infinitely`.\n\n`retry` takes a single optional parameter, a count of the number of times it should try resubscribing to and mirroring the source Observable when it encounters errors. If this count is exceeded, `retry` will not attempt to resubscribe and will instead pass the `onError` notification to its observers.\n\n`retryInfinitely`, on the other hand, will attempt to resubscribe to and mirror the source Observable indefinitely, no matter how many `onError` notifications it receives.\n\n### RxScala `retry retryWhen`\n\nRxScala has two versions of this operator: `retry` and `retryWhen`.\n\nOne variant of `retry` takes no parameters. It will continue to resubscribe to and mirror the source Observable no matter how many `onError` notifications it receives.\n\nAnother variant of `retry` takes a single parameter: a count of the number of times it should try to resubscribe to the source Observable when it encounters errors. If this count is exceeded, `retry` will not attempt to resubscribe again and will instead pass the latest `onError` notification to its observers.\n\nA third variant of `retry` takes a predicate function as a parameter. You write this function to accept two arguments: an Int count of how many retries have taken place thusfar, and a Throwable indicating the error that caused the `onError` notification. This function returns a Boolean to indicate whether or not `retry` should resubscribe to and mirror the source Observable. If it does not, then `retry` passes the latest `onError` notification to its observers.\n\nThe `retryWhen` operator is similar to `retry` but decides whether or not to resubscribe to and mirror the source Observable by passing the Throwable from the `onError` notification to a function that generates a second Observable, and observes its result to determine what to do. If that result is an emitted item, `retryWhen` resubscribes to and mirrors the source and the process repeats; if that result is an `onError` notification, `retryWhen` passes this notification on to its observers and terminates.\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/retry.html](http://reactivex.io/documentation/operators/retry.html)"
- name: Sample
  id: documentation/operators/sample
  summary: The Sample operator periodically looks at an Observable and emits whichever item it has most recently emitted since the previous sampling
  description: "# Sample\n\nemit the most recent items emitted by an Observable within periodic time intervals\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#sample)\n\nThe Sample operator periodically looks at an Observable and emits whichever item it has most recently emitted since the previous sampling.\n\nIn some implementations, there is also a ThrottleFirst operator that is similar, but emits not the most-recently emitted item in the sample period, but the *first* item that was emitted during that period.\n\n#### See Also\n\n- [Backpressure-related Operators](backpressure)\n- [Debounce](debounce)\n- [Window](window)\n- [Introduction to Rx: Sample](http://www.introtorx.com/Content/v1.0.10621.0/13_TimeShiftedSequences.html#Sample)\n- [RxMarbles: `sample`](http://rxmarbles.com/#sample)\n- [101 Rx Samples: Sample — Simple](http://rxwiki.wikidot.com/101samples#toc29)\n\n## Language-Specific Information\n\n### RxGroovy `sample throttleFirst throttleLast`\n\nRxGroovy implements this operator as `sample` and `throttleLast`.\n\nNote that if the source Observable has emitted no items since the last time it was sampled, the Observable that results from this operator will emit no item for that sampling period.\n\nOne variant of `sample` (or its alias, `throttleLast`) samples at a periodic time interval that you choose by passing in a `TimeUnit` and a quantity of such units as parameters to `sample`.\n\nThe following code constructs an Observable that emits the numbers between one and a million, and then samples that Observable every ten milliseconds to see what number it is emitting at that moment.\n\n#### Sample Code\n\n``` groovy\ndef numbers = Observable.range( 1, 1000000 );\n\nnumbers.sample(10, java.util.concurrent.TimeUnit.MILLISECONDS).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n339707\n547810\n891282\nSequence complete\n```\n\nThis variant of `sample` operates by default on the `computation` [Scheduler](../scheduler), but you can optionally pass in a Scheduler of your choosing as a third parameter.\n\n- Javadoc: [`sample(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#sample(long,%20java.util.concurrent.TimeUnit)) and [`throttleLast(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleLast(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`sample(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#sample(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)) and [`throttleLast(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleLast(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nThere ia also a variant of `sample` (that does not have a `throttleLast` alias) that samples the source Observable each time a second Observable emits an item (or when it terminates). You pass in that second Observable as the parameter to `sample`.\n\nThis variant of `sample` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`sample(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#sample(rx.Observable))\n\nThere is also a `throttleFirst` operator, which differs from `throttleLast`/`sample` in that it emits the *first* item emitted by the source Observable in each sampling period rather than the *most recently emitted* item.\n\n#### Sample Code\n\n``` groovy\nScheduler s = new TestScheduler();\nPublishSubject<Integer> o = PublishSubject.create();\no.throttleFirst(500, TimeUnit.MILLISECONDS, s).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n// send events with simulated time increments\ns.advanceTimeTo(0, TimeUnit.MILLISECONDS);\no.onNext(1); // deliver\no.onNext(2); // skip\ns.advanceTimeTo(501, TimeUnit.MILLISECONDS);\no.onNext(3); // deliver\ns.advanceTimeTo(600, TimeUnit.MILLISECONDS);\no.onNext(4); // skip\ns.advanceTimeTo(700, TimeUnit.MILLISECONDS);\no.onNext(5); // skip\no.onNext(6); // skip\ns.advanceTimeTo(1001, TimeUnit.MILLISECONDS);\no.onNext(7); // deliver\ns.advanceTimeTo(1501, TimeUnit.MILLISECONDS);\no.onCompleted();\n```\n\n``` javascript\n1\n3\n7\nSequence complete\n```\n\n`throttleFirst` operates by default on the `computation` [Scheduler](../scheduler), but you can optionally pass in a Scheduler of your choosing as a third parameter.\n\n- [`throttleFirst(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleFirst(long,%20java.util.concurrent.TimeUnit))\n- [`throttleFirst(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleFirst(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n### RxJava 1․x `sample throttleFirst throttleLast`\n\nRxJava implements this operator as `sample` and `throttleLast`.\n\nNote that if the source Observable has emitted no items since the last time it was sampled, the Observable that results from this operator will emit no item for that sampling period.\n\nOne variant of `sample` (or its alias, `throttleLast`) samples at a periodic time interval that you choose by passing in a `TimeUnit` and a quantity of such units as parameters to `sample`.\n\nThis variant of `sample` operates by default on the `computation` [Scheduler](../scheduler), but you can optionally pass in a Scheduler of your choosing as a third parameter.\n\n- Javadoc: [`sample(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#sample(long,%20java.util.concurrent.TimeUnit)) and [`throttleLast(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleLast(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`sample(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#sample(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)) and [`throttleLast(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleLast(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nThere ia also a variant of `sample` (that does not have a `throttleLast` alias) that samples the source Observable each time a second Observable emits an item (or when it terminates). You pass in that second Observable as the parameter to `sample`.\n\nThis variant of `sample` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`sample(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#sample(rx.Observable))\n\nThere is also a `throttleFirst` operator, which differs from `throttleLast`/`sample` in that it emits the *first* item emitted by the source Observable in each sampling period rather than the *most recently emitted* item.\n\n`throttleFirst` operates by default on the `computation` [Scheduler](../scheduler), but you can optionally pass in a Scheduler of your choosing as a third parameter.\n\n- [`throttleFirst(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleFirst(long,%20java.util.concurrent.TimeUnit))\n- [`throttleFirst(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleFirst(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n### RxJS `sample throttleFirst`\n\nRxJS implements this operator with two variants of `sample`.\n\nThe first variant accepts as its parameter a periodicity, defined as an integer number of milliseconds, and it samples the source Observable periodically at that frequency.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.interval(1000)\n    .sample(5000)\n    .take(2);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 3\nNext: 8\nCompleted\n```\n\nThe second variant accepts as its parameter an Observable, and it samples the source Observable whenever this second Observable emits an item.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.interval(1000)\n    .sample(Rx.Observable.interval(5000))\n    .take(2);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 3\nNext: 8\nCompleted\n```\n\nThere is also a `throttleFirst` operator, which differs from `sample` in that it emits the *first* item emitted by the source Observable in each sampling period rather than the *most recently emitted* item.\n\nIt does not have the variant that uses the emissions from a second Observable to regulate the sampling periodicity.\n\n#### Sample Code\n\n``` javascript\nvar times = [\n    { value: 0, time: 100 },\n    { value: 1, time: 600 },\n    { value: 2, time: 400 },\n    { value: 3, time: 900 },\n    { value: 4, time: 200 }\n];\n\n// Delay each item by time and project value;\nvar source = Rx.Observable.from(times)\n  .flatMap(function (item) {\n    return Rx.Observable\n      .of(item.value)\n      .delay(item.time);\n  })\n  .throttleFirst(300 /* ms */);\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 2\nNext: 3\nCompleted\n```\n\n`sample` and `throttleFirst` operate by default on the `timeout` [Scheduler](../scheduler). They are found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.time.js` (requires `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/sample.html](http://reactivex.io/documentation/operators/sample.html)"
- name: Scan
  id: documentation/operators/scan
  summary: The Scan operator applies a function to the first item emitted by the source Observable and then emits the result of that function as its own first emission
  description: "# Scan\n\napply a function to each item emitted by an Observable, sequentially, and emit each successive value\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#scan)\n\nThe Scan operator applies a function to the first item emitted by the source Observable and then emits the result of that function as its own first emission. It also feeds the result of the function back into the function along with the second item emitted by the source Observable in order to generate its second emission. It continues to feed back its own subsequent emissions along with the subsequent emissions from the source Observable in order to create the rest of its sequence.\n\nThis sort of operator is sometimes called an “accumulator” in other contexts.\n\n#### See Also\n\n- [Reduce](reduce)\n- [Introduction to Rx: Scan](http://www.introtorx.com/Content/v1.0.10621.0/07_Aggregation.html#Scan)\n- [RxMarbles: `scan`](http://rxmarbles.com/#scan)\n\n## Language-Specific Information\n\n### RxGroovy `scan`\n\nRxGroovy implements this operator as `scan`. The following code, for example, takes an Observable that emits a consecutive sequence of *n* integers starting with `1` and converts it, via `scan`, into an Observable that emits the first *n* [triangular numbers](http://en.wikipedia.org/wiki/Triangular_number):\n\n#### Sample Code\n\n``` javascript\nnumbers = Observable.from([1, 2, 3, 4, 5]);\n\nnumbers.scan({ a, b -> a+b }).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n1\n3\n6\n10\n15\nSequence complete\n```\n\n- Javadoc: [`scan(Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#scan(rx.functions.Func2))\n\nThere is also a variant of `scan` to which you can pass a seed value to pass to the accumulator function the first time it is called (for the first emission from the source Observable) in place of the result from the missing prior call to the accumulator. Note that if you use this version, `scan` will emit this seed value as its own initial emission. Note also that passing a seed of `null` is *not* the same as passing no seed at all. A `null` seed is a valid variety of seed.\n\n- Javadoc: [`scan(R,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#scan(R,%20rx.functions.Func2))\n\nThis operator does not by default operate on any particular [Scheduler](../scheduler).\n\n### RxJava 1․x `scan`\n\nRxJava implements this operator as `scan`.\n\n#### Sample Code\n\n``` java\nObservable.just(1, 2, 3, 4, 5)\n    .scan(new Func2<Integer, Integer, Integer>() {\n        @Override\n        public Integer call(Integer sum, Integer item) {\n            return sum + item;\n        }\n    }).subscribe(new Subscriber<Integer>() {\n        @Override\n        public void onNext(Integer item) {\n            System.out.println(\"Next: \" + item);\n        }\n\n        @Override\n        public void onError(Throwable error) {\n            System.err.println(\"Error: \" + error.getMessage());\n        }\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"Sequence complete.\");\n        }\n    });\n```\n\n``` javascript\nNext: 1\nNext: 3\nNext: 6\nNext: 10\nNext: 15\nSequence complete.\n```\n\n- Javadoc: [`scan(Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#scan(rx.functions.Func2))\n\nThere is also a variant of `scan` to which you can pass a seed value to pass to the accumulator function the first time it is called (for the first emission from the source Observable) in place of the result from the missing prior call to the accumulator. Note that if you use this version, `scan` will emit this seed value as its own initial emission. Note also that passing a seed of `null` is *not* the same as passing no seed at all. A `null` seed is a valid variety of seed.\n\n- Javadoc: [`scan(R,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#scan(R,%20rx.functions.Func2))\n\nThis operator does not by default operate on any particular [Scheduler](../scheduler).\n\n### RxJS `expand scan`\n\nRxJS implements the `scan` operator.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(1, 3)\n    .scan(\n        function (acc, x) {\n            return acc + x;\n        });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 1\nNext: 3\nNext: 6\nCompleted\n```\n\nYou can optionally pass `scan` a seed value as an additional parameter. `scan` will pass this seed value to the accumulator function the first time it is called (for the first emission from the source Observable) in place of the result from the missing prior call to the accumulator.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(1, 3)\n    .scan( function (acc, x) {\n            return acc * x;\n           }, 1 );\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 1\nNext: 2\nNext: 6\nCompleted\n```\n\n`scan` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nRxJS also implements the `expand` operator, which is somewhat similar. Rather than applying the function to the previous return value of the function combined with the next item emitted from the source Observable, such that the number of items it emits is equal to the number emitted by the source Observable, `expand` simply feeds the return value from the function back into the function without regard to future emissions from the Observable, such that it will just continue to create new values at its own pace.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.return(42)\n    .expand(function (x) { return Rx.Observable.return(42 + x); })\n    .take(5);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 42\nNext: 84\nNext: 126\nNext: 168\nNext: 210\nCompleted\n```\n\n`expand` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.experimental.js`\n\n`expand` requires one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `scan`\n\nRxPHP implements this operator as `scan`.\n\nApplies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/scan/scan.php\n\n//Without a seed\n$source = Rx\\Observable::range(1, 3);\n\n$subscription = $source\n    ->scan(function ($acc, $x) {\n        return $acc + $x;\n    })\n    ->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 1\nNext value: 3\nNext value: 6\nComplete!\n```\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/scan/scan-with-seed.php\n\n//With a seed\n$source = Rx\\Observable::range(1, 3);\n\n$subscription = $source\n    ->scan(function ($acc, $x) {\n        return $acc * $x;\n    }, 1)\n    ->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 1\nNext value: 2\nNext value: 6\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/scan.html](http://reactivex.io/documentation/operators/scan.html)"
- name: Scheduler
  id: documentation/scheduler
  summary: If you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular Schedulers
  description: "# Scheduler\n\nIf you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular Schedulers.\n\nSome ReactiveX Observable operators have variants that take a Scheduler as a parameter. These instruct the operator to do some or all of its work on a particular Scheduler.\n\nBy default, an Observable and the chain of operators that you apply to it will do its work, and will notify its observers, on the same thread on which its `Subscribe` method is called. The SubscribeOn operator changes this behavior by specifying a different Scheduler on which the Observable should operate. The ObserveOn operator specifies a different Scheduler that the Observable will use to send notifications to its observers.\n\nAs shown in this illustration, the SubscribeOn operator designates which thread the Observable will begin operating on, no matter at what point in the chain of operators that operator is called. ObserveOn, on the other hand, affects the thread that the Observable will use *below* where that operator appears. For this reason, you may call ObserveOn multiple times at various points during the chain of Observable operators in order to change on which threads certain of those operators operate.\n\n#### See Also\n\n- [Introduction to Rx: Scheduling and Threading](http://www.introtorx.com/Content/v1.0.10621.0/15_SchedulingAndThreading.html)\n- [Rx Workshop: Schedulers](http://channel9.msdn.com/Series/Rx-Workshop/Rx-Workshop-Schedulers)\n- [Using Schedulers](http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/scheduling_and_concurrency.html) by Dennis Stoyanov\n\n## Language-Specific Information\n\n### RxGroovy\n\n## Varieties of Scheduler\n\nYou obtain a Scheduler from the factory methods described in [the `Schedulers` class](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html). The following table shows the varieties of Scheduler that are available to you by means of these methods in RxGroovy:\n\n| Scheduler                                                                                                                           | purpose                                                                                                                                                                                                                                                                                                                                               |\n|-------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| [`Schedulers.computation( )`](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html#computation())                       | meant for computational work such as event-loops and callback processing; do not use this scheduler for I/O (use `Schedulers.io( )` instead); the number of threads, by default, is equal to the number of processors                                                                                                                                 |\n| [`Schedulers.from(executor)`](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html#from(java.util.concurrent.Executor)) | uses the specified `Executor` as a Scheduler                                                                                                                                                                                                                                                                                                          |\n| [`Schedulers.immediate( )`](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html#immediate())                           | schedules work to begin immediately in the current thread                                                                                                                                                                                                                                                                                             |\n| [`Schedulers.io( )`](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html#io())                                         | meant for I/O-bound work such as asynchronous performance of blocking I/O, this scheduler is backed by a thread-pool that will grow as needed; for ordinary computational work, switch to `Schedulers.computation( )`; `Schedulers.io( )` by default is a `CachedThreadScheduler`, which is something like a new thread scheduler with thread caching |\n| [`Schedulers.newThread( )`](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html#newThread())                           | creates a new thread for each unit of work                                                                                                                                                                                                                                                                                                            |\n| [`Schedulers.trampoline( )`](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html#trampoline())                         | queues work to begin on the current thread after any already-queued work                                                                                                                                                                                                                                                                              |\n\n## Default Schedulers for RxGroovy Observable Operators\n\nSome Observable operators in RxGroovy have alternate forms that allow you to set which Scheduler the operator will use for (at least some part of) its operation. Others do not operate on any particular Scheduler, or operate on a particular default Scheduler. Those that have a particular default Scheduler include:\n\n| operator                                                                     | Scheduler     |\n|------------------------------------------------------------------------------|---------------|\n| [`buffer(timespan)`](operators/buffer)                                       | `computation` |\n| [`buffer(timespan, count)`](operators/buffer)                                | `computation` |\n| [`buffer(timespan, timeshift)`](operators/buffer)                            | `computation` |\n| [`debounce(timeout, unit)`](operators/debounce)                              | `computation` |\n| [`delay(delay, unit)`](operators/delay)                                      | `computation` |\n| [`delaySubscription(delay, unit)`](operators/delay)                          | `computation` |\n| [`interval`](operators/interval)                                             | `computation` |\n| [`repeat`](operators/repeat)                                                 | `trampoline`  |\n| [`replay(time, unit)`](operators/replay)                                     | `computation` |\n| [`replay(buffersize, time, unit)`](operators/replay)                         | `computation` |\n| [`replay(selector, time, unit)`](operators/replay)                           | `computation` |\n| [`replay(selector, buffersize, time, unit)`](operators/replay)               | `computation` |\n| [`retry`](operators/retry)                                                   | `trampoline`  |\n| [`sample(period, unit)`](operators/sample)                                   | `computation` |\n| [`skip(time, unit)`](operators/skip)                                         | `computation` |\n| [`skipLast(time, unit)`](operators/skiplast)                                 | `computation` |\n| [`take(time, unit)`](operators/take)                                         | `computation` |\n| [`takeLast(time, unit)`](operators/takelast)                                 | `computation` |\n| [`takeLast(count, time, unit)`](operators/takelast)                          | `computation` |\n| [`takeLastBuffer(time, unit)`](operators/takelast)                           | `computation` |\n| [`takeLastBuffer(count, time, unit)`](operators/takelast)                    | `computation` |\n| [`throttleFirst`](operators/sample)                                          | `computation` |\n| [`throttleLast`](operators/sample)                                           | `computation` |\n| [`throttleWithTimeout`](operators/debounce)                                  | `computation` |\n| [`timeInterval`](operators/timeinterval)                                     | `immediate`   |\n| [`timeout(timeoutSelector)`](operators/timeout)                              | `immediate`   |\n| [`timeout(firstTimeoutSelector, timeoutSelector)`](operators/timeout)        | `immediate`   |\n| [`timeout(timeoutSelector, other)`](operators/timeout)                       | `immediate`   |\n| [`timeout(timeout, timeUnit)`](operators/timeout)                            | `computation` |\n| [`timeout(firstTimeoutSelector, timeoutSelector, other)`](operators/timeout) | `immediate`   |\n| [`timeout(timeout, timeUnit, other)`](operators/timeout)                     | `computation` |\n| [`timer`](operators/timer)                                                   | `computation` |\n| [`timestamp`](operators/timestamp)                                           | `immediate`   |\n| [`window(timespan)`](operators/window)                                       | `computation` |\n| [`window(timespan, count)`](operators/window)                                | `computation` |\n| [`window(timespan, timeshift)`](operators/window)                            | `computation` |\n\n## Test Scheduler\n\n[The `TestScheduler`](http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html) allows you to exercise fine-tuned manual control over how the Scheduler’s clock behaves. This can be useful for testing interactions that depend on precise arrangements of actions in time. This Scheduler has three additional methods:\n\n[`advanceTimeTo(time,unit)`](http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html#advanceTimeTo(long,%20java.util.concurrent.TimeUnit))  \nadvances the Scheduler’s clock to a particular point in time\n\n[`advanceTimeBy(time,unit)`](http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html#advanceTimeBy(long,%20java.util.concurrent.TimeUnit))  \nadvances the Scheduler’s clock forward by a particular amount of time\n\n[`triggerActions( )`](http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html#triggerActions())  \nstart any unstarted actions that have been scheduled for a time equal to or earlier than the present time according to the Scheduler’s clock\n\n#### See Also\n\n- [Testing Reactive Applications](https://speakerdeck.com/benjchristensen/applying-rxjava-to-existing-applications-at-philly-ete-2015) by Ben Christensen\n- [RxJava Threading Examples](http://www.grahamlea.com/2014/07/rxjava-threading-examples/) by Graham Lea\n- Advanced RxJava: Schedulers ([part 1](http://akarnokd.blogspot.hu/2015/05/schedulers-part-1.html)) ([part 2](http://akarnokd.blogspot.hu/2015/06/schedulers-part-2.html)) ([part 3](http://akarnokd.blogspot.hu/2015/06/schedulers-part-3.html)) ([part 4](http://akarnokd.blogspot.hu/2015/06/schedulers-part-4-final.html)) by Dávid Karnok\n\n### RxJava 1․x\n\n## Varieties of Scheduler\n\nYou obtain a Scheduler from the factory methods described in [the `Schedulers` class](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html). The following table shows the varieties of Scheduler that are available to you by means of these methods in RxJava:\n\n| Scheduler                                                                                                                           | purpose                                                                                                                                                                                                                                                                                                                                               |\n|-------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| [`Schedulers.computation( )`](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html#computation())                       | meant for computational work such as event-loops and callback processing; do not use this scheduler for I/O (use `Schedulers.io( )` instead); the number of threads, by default, is equal to the number of processors                                                                                                                                 |\n| [`Schedulers.from(executor)`](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html#from(java.util.concurrent.Executor)) | uses the specified `Executor` as a Scheduler                                                                                                                                                                                                                                                                                                          |\n| [`Schedulers.immediate( )`](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html#immediate())                           | schedules work to begin immediately in the current thread                                                                                                                                                                                                                                                                                             |\n| [`Schedulers.io( )`](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html#io())                                         | meant for I/O-bound work such as asynchronous performance of blocking I/O, this scheduler is backed by a thread-pool that will grow as needed; for ordinary computational work, switch to `Schedulers.computation( )`; `Schedulers.io( )` by default is a `CachedThreadScheduler`, which is something like a new thread scheduler with thread caching |\n| [`Schedulers.newThread( )`](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html#newThread())                           | creates a new thread for each unit of work                                                                                                                                                                                                                                                                                                            |\n| [`Schedulers.trampoline( )`](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html#trampoline())                         | queues work to begin on the current thread after any already-queued work                                                                                                                                                                                                                                                                              |\n\n## Default Schedulers for RxJava 1.x Observable Operators\n\nSome Observable operators in RxJava have alternate forms that allow you to set which Scheduler the operator will use for (at least some part of) its operation. Others do not operate on any particular Scheduler, or operate on a particular default Scheduler. Those that have a particular default Scheduler include:\n\n| operator                                                                     | Scheduler     |\n|------------------------------------------------------------------------------|---------------|\n| [`buffer(timespan)`](operators/buffer)                                       | `computation` |\n| [`buffer(timespan, count)`](operators/buffer)                                | `computation` |\n| [`buffer(timespan, timeshift)`](operators/buffer)                            | `computation` |\n| [`debounce(timeout, unit)`](operators/debounce)                              | `computation` |\n| [`delay(delay, unit)`](operators/delay)                                      | `computation` |\n| [`delaySubscription(delay, unit)`](operators/delay)                          | `computation` |\n| [`interval`](operators/interval)                                             | `computation` |\n| [`repeat`](operators/repeat)                                                 | `trampoline`  |\n| [`replay(time, unit)`](operators/replay)                                     | `computation` |\n| [`replay(buffersize, time, unit)`](operators/replay)                         | `computation` |\n| [`replay(selector, time, unit)`](operators/replay)                           | `computation` |\n| [`replay(selector, buffersize, time, unit)`](operators/replay)               | `computation` |\n| [`retry`](operators/retry)                                                   | `trampoline`  |\n| [`sample(period, unit)`](operators/sample)                                   | `computation` |\n| [`skip(time, unit)`](operators/skip)                                         | `computation` |\n| [`skipLast(time, unit)`](operators/skiplast)                                 | `computation` |\n| [`take(time, unit)`](operators/take)                                         | `computation` |\n| [`takeLast(time, unit)`](operators/takelast)                                 | `computation` |\n| [`takeLast(count, time, unit)`](operators/takelast)                          | `computation` |\n| [`takeLastBuffer(time, unit)`](operators/takelast)                           | `computation` |\n| [`takeLastBuffer(count, time, unit)`](operators/takelast)                    | `computation` |\n| [`throttleFirst`](operators/sample)                                          | `computation` |\n| [`throttleLast`](operators/sample)                                           | `computation` |\n| [`throttleWithTimeout`](operators/debounce)                                  | `computation` |\n| [`timeInterval`](operators/timeinterval)                                     | `immediate`   |\n| [`timeout(timeoutSelector)`](operators/timeout)                              | `immediate`   |\n| [`timeout(firstTimeoutSelector, timeoutSelector)`](operators/timeout)        | `immediate`   |\n| [`timeout(timeoutSelector, other)`](operators/timeout)                       | `immediate`   |\n| [`timeout(timeout, timeUnit)`](operators/timeout)                            | `computation` |\n| [`timeout(firstTimeoutSelector, timeoutSelector, other)`](operators/timeout) | `immediate`   |\n| [`timeout(timeout, timeUnit, other)`](operators/timeout)                     | `computation` |\n| [`timer`](operators/timer)                                                   | `computation` |\n| [`timestamp`](operators/timestamp)                                           | `immediate`   |\n| [`window(timespan)`](operators/window)                                       | `computation` |\n| [`window(timespan, count)`](operators/window)                                | `computation` |\n| [`window(timespan, timeshift)`](operators/window)                            | `computation` |\n\n## Using Schedulers\n\nAside from passing these Schedulers in to RxJava Observable operators, you can also use them to schedule your own work on Subscriptions. The following example uses [the `schedule` method](http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0)) of [the `Scheduler.Worker` class](http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html) to schedule work on the `newThread` Scheduler:\n\n``` java\nworker = Schedulers.newThread().createWorker();\nworker.schedule(new Action0() {\n\n    @Override\n    public void call() {\n        yourWork();\n    }\n\n});\n// some time later...\nworker.unsubscribe();\n```\n\n### Recursive Schedulers\n\nTo schedule recursive calls, you can use `schedule` and then `schedule(this)` on the Worker object:\n\n``` java\nworker = Schedulers.newThread().createWorker();\nworker.schedule(new Action0() {\n\n    @Override\n    public void call() {\n        yourWork();\n        // recurse until unsubscribed (schedule will do nothing if unsubscribed)\n        worker.schedule(this);\n    }\n\n});\n// some time later...\nworker.unsubscribe();\n```\n\n### Checking or Setting Unsubscribed Status\n\nObjects of the `Worker` class implement [the `Subscription` interface](http://reactivex.io/RxJava/javadoc/rx/Subscription.html), with its [`isUnsubscribed`](http://reactivex.io/RxJava/javadoc/rx/Subscription.html#isUnsubscribed()) and [`unsubscribe`](http://reactivex.io/RxJava/javadoc/rx/Subscription.html#unsubscribe()) methods, so you can stop work when a subscription is cancelled, or you can cancel the subscription from within the scheduled task:\n\n``` java\nWorker worker = Schedulers.newThread().createWorker();\nSubscription mySubscription = worker.schedule(new Action0() {\n\n    @Override\n    public void call() {\n        while(!worker.isUnsubscribed()) {\n            status = yourWork();\n            if(QUIT == status) { worker.unsubscribe(); }\n        }\n    }\n\n});\n```\n\nThe `Worker` is also a `Subscription` and so you can (and should, eventually) call its `unsubscribe` method to signal that it can halt work and release resources:\n\n``` java\nworker.unsubscribe();\n```\n\n### Delayed and Periodic Schedulers\n\nYou can also use [a version of `schedule`](http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0,%20long,%20java.util.concurrent.TimeUnit)) that delays your action on the given Scheduler until a certain timespan has passed. The following example schedules `someAction` to be performed on `someScheduler` after 500ms have passed according to that Scheduler’s clock:\n\n``` java\nsomeScheduler.schedule(someAction, 500, TimeUnit.MILLISECONDS);\n```\n\n[Another `Scheduler` method](http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedulePeriodically(rx.functions.Action0,%20long,%20long,%20java.util.concurrent.TimeUnit)) allows you to schedule an action to take place at regular intervals. The following example schedules `someAction` to be performed on `someScheduler` after 500ms have passed, and then every 250ms thereafter:\n\n``` java\nsomeScheduler.schedulePeriodically(someAction, 500, 250, TimeUnit.MILLISECONDS);\n```\n\n## Test Scheduler\n\n[The `TestScheduler`](http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html) allows you to exercise fine-tuned manual control over how the Scheduler’s clock behaves. This can be useful for testing interactions that depend on precise arrangements of actions in time. This Scheduler has three additional methods:\n\n[`advanceTimeTo(time,unit)`](http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html#advanceTimeTo(long,%20java.util.concurrent.TimeUnit))  \nadvances the Scheduler’s clock to a particular point in time\n\n[`advanceTimeBy(time,unit)`](http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html#advanceTimeBy(long,%20java.util.concurrent.TimeUnit))  \nadvances the Scheduler’s clock forward by a particular amount of time\n\n[`triggerActions( )`](http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html#triggerActions())  \nstart any unstarted actions that have been scheduled for a time equal to or earlier than the present time according to the Scheduler’s clock\n\n#### See Also\n\n- [RxJava Threading Examples](http://www.grahamlea.com/2014/07/rxjava-threading-examples/) by Graham Lea\n- [Testing Reactive Applications](https://speakerdeck.com/benjchristensen/applying-rxjava-to-existing-applications-at-philly-ete-2015) by Ben Christensen\n- Advanced RxJava: Schedulers ([part 1](http://akarnokd.blogspot.hu/2015/05/schedulers-part-1.html)) ([part 2](http://akarnokd.blogspot.hu/2015/06/schedulers-part-2.html)) ([part 3](http://akarnokd.blogspot.hu/2015/06/schedulers-part-3.html)) ([part 4](http://akarnokd.blogspot.hu/2015/06/schedulers-part-4-final.html)) by Dávid Karnok\n\n### RxJS\n\nIn RxJS you obtain Schedulers from the `Rx.Scheduler` object or as independently-implemented objects. The following table shows the varieties of Scheduler that are available to you in RxJS:.\n\n| Scheduler                    | purpose                                                                       |\n|------------------------------|-------------------------------------------------------------------------------|\n| `Rx.Scheduler.currentThread` | schedules work as soon as possible on the current thread                      |\n| `Rx.HistoricalScheduler`     | schedules work as though it were occurring at an arbitrary historical time    |\n| `Rx.Scheduler.immediate`     | schedules work immediately on the current thread                              |\n| `Rx.TestScheduler`           | for unit testing; this allows you to manually manipulate the movement of time |\n| `Rx.Scheduler.timeout`       | schedules work by means of a timed callback                                   |\n\n#### See Also\n\n- [StackOverflow: What is a “Scheduler” in RxJS](http://stackoverflow.com/questions/28145890/what-is-a-scheduler-in-rxjs)\n- [Schedulers](http://xgrommx.github.io/rx-book/content/schedulers/index.html) by Dennis Stoyanov\n- [RxJava Threading Examlpes](http://www.grahamlea.com/2014/07/rxjava-threading-examples/) by Graham Lea\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/scheduler.html](http://reactivex.io/documentation/scheduler.html)"
- name: SequenceEqual
  id: documentation/operators/sequenceequal
  summary: Pass SequenceEqual two Observables, and it will compare the items emitted by each Observable, and the Observable it returns will emit true only if both sequences are the same (the same items, in the same order, with the same termination state)
  description: "# SequenceEqual\n\ndetermine whether two Observables emit the same sequence of items\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#sequenceEqual)\n\nPass SequenceEqual two Observables, and it will compare the items emitted by each Observable, and the Observable it returns will emit `true` only if both sequences are the same (the same items, in the same order, with the same termination state).\n\n#### See Also\n\n- [Introduction to Rx: SequenceEqual](http://www.introtorx.com/Content/v1.0.10621.0/06_Inspection.html#SequenceEqual)\n- [RxMarbles: `sequenceEqual`](http://rxmarbles.com/#sequenceEqual)\n\n## Language-Specific Information\n\n### RxGroovy `sequenceEqual`\n\nPass `sequenceEqual` two Observables, and it will compare the items emitted by each Observable, and the Observable it returns will emit `true` only if both sequences terminate normally after emitting the same sequence of items in the same order; otherwise it will emit `false`. You can optionally pass a third parameter: a function that accepts two items and returns `true` if they are equal according to a standard of your choosing.\n\n#### Sample Code\n\n``` groovy\ndef firstfour = Observable.from([1, 2, 3, 4]);\ndef firstfouragain = Observable.from([1, 2, 3, 4]);\ndef firstfive = Observable.from([1, 2, 3, 4, 5]);\ndef firstfourscrambled = Observable.from([3, 2, 1, 4]);\n\nprintln('firstfour == firstfive?');\nObservable.sequenceEqual(firstfour, firstfive).subscribe({ println(it); });\nprintln('firstfour == firstfouragain?');\nObservable.sequenceEqual(firstfour, firstfouragain).subscribe({ println(it); });\nprintln('firstfour == firstfourscrambled?');\nObservable.sequenceEqual(firstfour, firstfourscrambled).subscribe({ println(it); });\n```\n\n``` javascript\nfirstfour == firstfive?\nfalse\nfirstfour == firstfouragain?\ntrue\nfirstfour == firstfourscrambled?\nfalse\n```\n\nThis operator does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`sequenceEqual(Observable,Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#sequenceEqual(rx.Observable,%20rx.Observable))\n- Javadoc: [`sequenceEqual(Observable,Observable,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#sequenceEqual(rx.Observable,%20rx.Observable,%20rx.functions.Func2))\n\n### RxJava 1․x `sequenceEqual`\n\nPass `sequenceEqual` two Observables, and it will compare the items emitted by each Observable, and the Observable it returns will emit `true` only if both sequences terminate normally after emitting the same sequence of items in the same order; otherwise it will emit `false`. You can optionally pass a third parameter: a function that accepts two items and returns `true` if they are equal according to a standard of your choosing.\n\nThis operator does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`sequenceEqual(Observable,Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#sequenceEqual(rx.Observable,%20rx.Observable))\n- Javadoc: [`sequenceEqual(Observable,Observable,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#sequenceEqual(rx.Observable,%20rx.Observable,%20rx.functions.Func2))\n\n### RxJS `sequenceEqual`\n\nIn RxJS, `sequenceEqual` is a method of a particular Observable instance, so you pass it exactly one other Observable to compare the instance to. You can optionally pass a second parameter: a function that accepts two items and returns `true` if they are equal according to a standard of your choosing. `sequenceEqual` returns an Observable that will emit a `true` if the two Observables emit the same set of items in the same order before completing, or a `false` otherwise.\n\n#### Sample Code\n\n``` javascript\nvar source1 = Rx.Observable.return(42);\nvar source2 = Rx.Observable.return(42);\n\nvar source = source1.sequenceEqual(source2);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: true\nCompleted\n```\n\n`sequenceEqual` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\n`sequenceEqual` requires one of the following distributions:\n\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/sequenceequal.html](http://reactivex.io/documentation/operators/sequenceequal.html)"
- name: Serialize
  id: documentation/operators/serialize
  summary: It is possible for an Observable to invoke its observers’ methods asynchronously, perhaps from different threads
  description: "# Serialize\n\nforce an Observable to make serialized calls and to be well-behaved\n\nIt is possible for an Observable to invoke its observers’ methods asynchronously, perhaps from different threads. This could make such an Observable violate [the Observable contract](../contract), in that it might try to send an `OnCompleted` or `OnError` notification before one of its `OnNext` notifications, or it might make an `OnNext` notification from two different threads concurrently. You can force such an Observable to be well-behaved and synchronous by applying the Serialize operator to it.\n\n## Language-Specific Information\n\n### RxGroovy `serialize`\n\nRxGroovy implements this operator as `serialize`. It does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`serialize()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#serialize())\n\n### RxJava 1․x `serialize`\n\nRxJava implements this operator as `serialize`. It does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`serialize()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#serialize())\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/serialize.html](http://reactivex.io/documentation/operators/serialize.html)"
- name: Single
  id: documentation/single
  summary: A Single is something like an Observable, but instead of emitting a series of values — anywhere from none at all to an infinite number — it always either emits one value or an error notification
  description: "# Single\n\nRxJava (and its derivatives like RxGroovy & RxScala) has developed an [Observable](observable) variant called “Single.”\n\nA Single is something like an Observable, but instead of emitting a series of values — anywhere from none at all to an infinite number — it always either emits one value or an error notification.\n\nFor this reason, instead of subscribing to a Single with the three methods you use to respond to notifications from an Observable (`onNext`, `onError`, and `onCompleted`), you only use two methods to subscribe:\n\nonSuccess  \na Single passes this method the sole item that the Single emits\n\nonError  \na Single passes this method the Throwable that caused the Single to be unable to emit an item\n\nA Single will call only one of these methods, and will only call it once. Upon calling either method, the Single terminates and the subscription to it ends.\n\n## Composition via Single Operators\n\nLike Observables, Singles can be manipulated by means of a variety of operators. Some operators also allow for an interface between the Observable world and the Single world so that you can mix the two varieties:\n\n| operator                  | returns      | description                                                                                                                |\n|---------------------------|--------------|----------------------------------------------------------------------------------------------------------------------------|\n| `compose`                 | `Single`     | allows you create a custom operator                                                                                        |\n| `concat` and `concatWith` | `Observable` | concatenates the items emitted by multiple Singles as Observable emissions                                                 |\n| `create`                  | `Single`     | create a Single from scratch by calling subscriber methods explicitly                                                      |\n| `delay`                   | `Single`     | move the emission of an item from a Single forward in time                                                                 |\n| `doOnError`               | `Single`     | returns a Single that also calls a method you specify when it calls onError                                                |\n| `doOnSuccess`             | `Single`     | returns a Single that also calls a method you specify when it calls onSuccess                                              |\n| `error`                   | `Single`     | returns a Single that immediately notifies subscribers of an error                                                         |\n| `flatMap`                 | `Single`     | returns a Single that is the result of a function applied to an item emitted by a Single                                   |\n| `flatMapObservable`       | `Observable` | returns an Observable that is the result of a function applied to an item emitted by a Single                              |\n| `from`                    | `Single`     | converts a Future into a Single                                                                                            |\n| `just`                    | `Single`     | returns a Single that emits a specified item                                                                               |\n| `map`                     | `Single`     | returns a Single that emits the result of a function applied to the item emitted by the source Single                      |\n| `merge`                   | `Single`     | converts a Single that emits a second Single into a Single that emits the item emitted by the second Single                |\n| `merge` and `mergeWith`   | `Observable` | merges the items emitted by multiple Singles as Observable emissions                                                       |\n| `observeOn`               | `Single`     | instructs the Single to call the subscriber methods on a particular [Scheduler](scheduler)                                 |\n| `onErrorReturn`           | `Single`     | converts a Single that makes an error notification into a Single that emits a specified item                               |\n| `subscribeOn`             | `Single`     | instructs the Single to operate on a particular [Scheduler](scheduler)                                                     |\n| `timeout`                 | `Single`     | returns a Single that makes an error notification if the source Single does not emit a value in a specified time period    |\n| `toSingle`                | `Single`     | converts an Observable that emits a single item into a Single that emits that item                                         |\n| `toObservable`            | `Observable` | converts a Single into an Observable that emits the item emitted by the Single and then completes                          |\n| `zip` and `zipWith`       | `Single`     | returns a Single that emits an item that is the result of a function applied to items emitted by two or more other Singles |\n\nThe following sections of this page will give marble diagrams that explain these operators schematically. This diagram explains how Singles are represented in marble diagrams:\n\n## compose\n\n## concat and concatWith\n\nThere is also an instance version of this operator:\n\n## create\n\n## delay\n\nThere is also a version of this operator that allows you to perform the delay on a particular [Scheduler](scheduler):\n\n## doOnError\n\n## doOnSuccess\n\n## error\n\n## flatMap\n\n## flatMapObservable\n\n## from\n\nThere is also a variety that takes a [Scheduler](scheduler) as an argument:\n\n## just\n\n## map\n\n## merge and mergeWith\n\nOne version of merge takes a Single that emits a second Single and converts it into a Single that emits the item emitted by that second Single:\n\nAnother version takes two or more Singles and merges them into an Observable that emits the items emitted by the source Singles (in an arbitrary order):\n\n## observeOn\n\n## onErrorReturn\n\n## subscribeOn\n\n## timeout\n\nTimeout will cause a Single to abort with an error notification if it does not emit an item in a specified period of time after it is subscribed to. One version allows you to set this time out by means of a number of specified time units:\n\nYou can also specify a particular [Scheduler](scheduler) for the timer to operate on:\n\nA version of the timeout operator allows you to switch to a backup Single rather than sending an error notification if the timeout expires:\n\nThis, too, has a [Scheduler](scheduler)-specific version:\n\n## toObservable\n\n## zip and zipWith\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/single.html](http://reactivex.io/documentation/single.html)"
- name: Skip
  id: documentation/operators/skip
  summary: You can ignore the first n items emitted by an Observable and attend only to those items that come after, by modifying the Observable with the Skip operator
  description: "# Skip\n\nsuppress the first *n* items emitted by an Observable\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#skip)\n\nYou can ignore the first *n* items emitted by an Observable and attend only to those items that come after, by modifying the Observable with the Skip operator.\n\n#### See Also\n\n- [Last](last)\n- [SkipLast](skiplast)\n- [SkipUntil](skipuntil)\n- [SkipWhile](skipwhile)\n- [Take](take)\n- [TakeLast](takelast)\n- [TakeUntil](takeuntil)\n- [TakeWhile](takewhile)\n- [Introduction to Rx: Skip and Take](http://www.introtorx.com/Content/v1.0.10621.0/05_Filtering.html#SkipAndTake)\n- [RxMarbles: `skip`](http://rxmarbles.com/#skip)\n\n## Language-Specific Information\n\n### RxGroovy `skip`\n\nIn RxGroovy, this operator is implemented as `skip`.\n\n#### Sample Code\n\n``` groovy\nnumbers = Observable.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nnumbers.skip(3).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n4\n5\n6\n7\n8\nSequence complete\n```\n\nThis variant of `skip` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`skip(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skip(int))\n\nThere is also a variant of `skip` that takes a temporal duration rather than a quantity of items. It drops those items that are emitted during that initial duration of the source Observable’s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to `skip`.\n\nThis variant of `skip` by default operates on the `computation` [Scheduler](../scheduler), but you may also pass in a Scheduler of your choosing as an optional third parameter.\n\n- Javadoc: [`skip(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skip(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`skip(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skip(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n### RxJava 1․x `skip`\n\nIn RxJava, this operator is implemented as `skip`.\n\nThis variant of `skip` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`skip(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skip(int))\n\nThere is also a variant of `skip` that takes a temporal duration rather than a quantity of items. It drops those items that are emitted during that initial duration of the source Observable’s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to `skip`.\n\nThis variant of `skip` by default operates on the `computation` [Scheduler](../scheduler), but you may also pass in a Scheduler of your choosing as an optional third parameter.\n\n- Javadoc: [`skip(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skip(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`skip(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skip(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n### RxJS `skip skipUntilWithTime`\n\nRxJS implements the `skip` operator.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 5)\n    .skip(3);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 3\nNext: 4\nCompleted\n```\n\n`skip` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nRxJS also implements a `skipUntilWithTime` operator that does not skip a particular quantity of items from the source Observable, but skips items based on chronology. You set this skip period by passing in a parameter to `skipUntilWithTime`, in either of these formats:\n\na number  \nskips items from the source Observable until this many milliseconds have passed since the Observable was subscribed to\n\na `Date`  \nskips items from the source Observable until this absolute time\n\nYou may also, optionally, pass in a [Scheduler](../scheduler) as a second parameter, and the timer will operate on that Scheduler (`skipUntilWithTime` uses the `timeout` Scheduler by default).\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.timer(0, 1000)\n    .skipUntilWithTime(5000);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 6\nNext: 7\nNext: 8\nCompleted\n```\n\n`skipUntilWithTime` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.time.js` (requires `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `skip`\n\nRxPHP implements this operator as `skip`.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/skip/skip.php\n\nuse Rx\\Observable\\ArrayObservable;\n\n$observable = Rx\\Observable::fromArray([1, 1, 2, 3, 5, 8, 13]);\n$observable\n    ->skip(3)\n    ->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 3\nNext value: 5\nNext value: 8\nNext value: 13\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/skip.html](http://reactivex.io/documentation/operators/skip.html)"
- name: SkipLast
  id: documentation/operators/skiplast
  summary: You can ignore the final n items emitted by an Observable and attend only to those items that come before them, by modifying the Observable with the SkipLast operator
  description: "# SkipLast\n\nsuppress the final *n* items emitted by an Observable\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#skipLast)\n\nYou can ignore the final *n* items emitted by an Observable and attend only to those items that come before them, by modifying the Observable with the SkipLast operator.\n\n#### See Also\n\n- [Last](last)\n- [Skip](skip)\n- [SkipUntil](skipuntil)\n- [SkipWhile](skipwhile)\n- [Take](take)\n- [TakeLast](takelast)\n- [TakeUntil](takeuntil)\n- [TakeWhile](takewhile)\n- [Introduction to Rx: SkipLast and TakeLast](http://www.introtorx.com/Content/v1.0.10621.0/05_Filtering.html#SkipLastTakeLast)\n- [RxMarbles: `skipLast`](http://rxmarbles.com/#skipLast)\n\n## Language-Specific Information\n\n### RxGroovy `skipLast`\n\nYou can ignore the final *n* items emitted by an Observable and attend only to those items that precede them, by modifying the Observable with the `skipLast(`*`n`*`)` operator. Note that the mechanism by which this is implemented will delay the emission of any item from the source Observable until *n* additional items have been emitted by that Observable.\n\nThis variant of `skipLast` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`skipLast(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipLast(int))\n\nThere is also a variant of `skipLast` that takes a temporal duration rather than a quantity of items. It drops those items that are emitted during that final duration of the source Observable’s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to `skipLast`.\n\nNote that the mechanism by which this is implemented will delay the emission of any item from the source Observable until the given duration passes since its emission.\n\nThis variant of `skipLast` by default operates on the `computation` [Scheduler](../scheduler), but you may also pass in a Scheduler of your choosing as an optional third parameter.\n\n- Javadoc: [`skipLast(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipLast(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`skipLast(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipLast(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n### RxJava 1․x `skipLast`\n\nYou can ignore the final *n* items emitted by an Observable and attend only to those items that precede them, by modifying the Observable with the `skipLast(`*`n`*`)` operator. Note that the mechanism by which this is implemented will delay the emission of any item from the source Observable until *n* additional items have been emitted by that Observable.\n\nThis variant of `skipLast` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`skipLast(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipLast(int))\n\nThere is also a variant of `skipLast` that takes a temporal duration rather than a quantity of items. It drops those items that are emitted during that final duration of the source Observable’s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to `skipLast`.\n\nNote that the mechanism by which this is implemented will delay the emission of any item from the source Observable until the given duration passes since its emission.\n\nThis variant of `skipLast` by default operates on the `computation` [Scheduler](../scheduler), but you may also pass in a Scheduler of your choosing as an optional third parameter.\n\n- Javadoc: [`skipLast(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipLast(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`skipLast(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipLast(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n### RxJS `skipLast skipLastWithTime`\n\nYou can ignore the final *n* items emitted by an Observable and attend only to those items that precede them, by modifying the Observable with the `skipLast(`*`n`*`)` operator. Note that the mechanism by which this is implemented will delay the emission of any item from the source Observable until *n* additional items have been emitted by that Observable.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 5)\n    .skipLast(3);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nCompleted\n```\n\n`skipLast` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThe `skipLastWithTime` operator takes a temporal duration rather than a quantity of items. It drops those items that are emitted during that final duration of the source Observable’s lifespan. You set this duration by passing in a number of milliseconds as a parameter to `skipLastWithTime`.\n\nNote that the mechanism by which this is implemented will delay the emission of any item from the source Observable until the given duration passes since its emission.\n\n`skipLastWithTime` by default operates on the `timeout` [Scheduler](../scheduler), but you may also pass in a Scheduler of your choosing as an optional second parameter.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.timer(0, 1000)\n    .take(10)\n    .skipLastWithTime(5000);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nNext: 3\nNext: 4\nCompleted\n```\n\n`skipLastWithTime` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.time.js` (requires `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `skipLast`\n\nRxPHP implements this operator as `skipLast`.\n\nBypasses a specified number of elements at the end of an observable sequence. This operator accumulates a queue with a length enough to store the first \\`count\\` elements. As more elements are received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/skip/skipLast.php\n\n$observable = Rx\\Observable::range(0, 5)\n    ->skipLast(3);\n\n$observable->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 0\nNext value: 1\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/skiplast.html](http://reactivex.io/documentation/operators/skiplast.html)"
- name: SkipUntil
  id: documentation/operators/skipuntil
  summary: The SkipUntil subscribes to the source Observable, but ignores its emissions until such time as a second Observable emits an item, at which point SkipUntil begins to mirror the source Observable
  description: "# SkipUntil\n\ndiscard items emitted by an Observable until a second Observable emits an item\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#skipUntil)\n\nThe SkipUntil subscribes to the source Observable, but ignores its emissions until such time as a second Observable emits an item, at which point SkipUntil begins to mirror the source Observable.\n\n#### See Also\n\n- [Skip](skip)\n- [SkipLast](skiplast)\n- [SkipWhile](skipwhile)\n- [Take](take)\n- [TakeLast](takelast)\n- [TakeUntil](takeuntil)\n- [TakeWhile](takewhile)\n- [Introduction to Rx: SkipUntil and TakeUntil](http://www.introtorx.com/Content/v1.0.10621.0/05_Filtering.html#SkipUntilTakeUntil)\n- [RxMarbles: `skipUntil`](http://rxmarbles.com/#skipUntil)\n\n## Language-Specific Information\n\n### RxGroovy `skipUntil`\n\nIn RxGroovy, this operator is implemented as `skipUntil`.\n\n`skipUntil` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`skipUntil(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipUntil(rx.Observable))\n\n### RxJava 1․x `skipUntil`\n\nIn RxJava, this operator is implemented as `skipUntil`.\n\n`skipUntil` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`skipUntil(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipUntil(rx.Observable))\n\n### RxJS `skipUntil`\n\nRxJS implements the `skipUntil` operator. You can pass it either an Observable or a `Promise` that it will monitor for an item that triggers `skipUntil` to begin mirroring the source Observable.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.timer(0, 1000)\n    .skipUntil(Rx.Observable.timer(5000));\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 6\nNext: 7\nNext: 8\nCompleted\n```\n\n`skipUntil` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThere is also a `skipUntilWithTime` operator to which you can pass an absolute time or an initial duration in place of an Observable, but this is described on the [Skip](skip) operator page.\n\n### RxPHP `skipUntil`\n\nRxPHP implements this operator as `skipUntil`.\n\nReturns the values from the source observable sequence only after the other observable sequence produces a value.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/skip/skipUntil.php\n\n$observable = Rx\\Observable::interval(1000)\n    ->skipUntil(\\Rx\\Observable::timer(5000))\n    ->take(3);\n\n$observable->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 4\nNext value: 5\nNext value: 6\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/skipuntil.html](http://reactivex.io/documentation/operators/skipuntil.html)"
- name: SkipWhile
  id: documentation/operators/skipwhile
  summary: The SkipWhile subscribes to the source Observable, but ignores its emissions until such time as some condition you specify becomes false, at which point SkipWhile begins to mirror the source Observable
  description: "# SkipWhile\n\ndiscard items emitted by an Observable until a specified condition becomes false\n\nThe SkipWhile subscribes to the source Observable, but ignores its emissions until such time as some condition you specify becomes false, at which point SkipWhile begins to mirror the source Observable.\n\n#### See Also\n\n- [Skip](skip)\n- [SkipLast](skiplast)\n- [SkipUntil](skipuntil)\n- [Take](take)\n- [TakeLast](takelast)\n- [TakeUntil](takeuntil)\n- [TakeWhile](takewhile)\n- [Introduction to Rx: SkipWhile and TakeWhile](http://www.introtorx.com/Content/v1.0.10621.0/05_Filtering.html#SkipWhileTakeWhile)\n\n## Language-Specific Information\n\n### RxGroovy `skipWhile`\n\nThe `skipWhile` operator returns an Observable that discards items emitted by the source Observable until such time as a function, applied to an item emitted by that Observable, returns `false`, whereupon the new Observable emits that item and the remainder of the items emitted by the source Observable.\n\n``` groovy\nnumbers = Observable.from( [1, 2, 3, 4, 5, 6, 7, 8, 9] );\n\nnumbers.skipWhile({ (5 != it) }).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n5\n6\n7\n8\n9\nSequence complete\n```\n\n`skipWhile` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`skipWhile(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipWhile(rx.functions.Func1))\n\n### RxJava 1․x `skipWhile`\n\nThe `skipWhile` operator returns an Observable that discards items emitted by the source Observable until such time as a function, applied to an item emitted by that Observable, returns `false`, whereupon the new Observable emits that item and the remainder of the items emitted by the source Observable.\n\n`skipWhile` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`skipWhile(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipWhile(rx.functions.Func1))\n\n### RxJS `skipWhile`\n\nRxJS implements the `skipWhile` operator. You pass it a function that governs the skipping process. `skipWhile` calls that function for each item emitted by the source Observable until such time as the function returns `false`, whereupon `skipWhile` begins mirroring the source Observable (starting with that item). The function takes three parameters:\n\n1.  the emitted item\n2.  the zero-based index of that item in the sequence of emissions\n3.  the source Observable\n\nYou may optionally pass a second parameter to `skipWhile`. If so, that item will also be available to your predicate function as “`this`”.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(1, 5)\n    .skipWhile(function (x) { return x < 3; });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 3\nNext: 4\nNext: 5\nCompleted\n```\n\n`skipWhile` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `skipWhile skipWhileWithIndex`\n\nRxPHP implements this operator as `skipWhile`.\n\nBypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/skip/skipWhile.php\n\n$observable = Rx\\Observable::range(1, 5)\n    ->skipWhile(function ($x) {\n        return $x < 3;\n    });\n\n$observable->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 3\nNext value: 4\nNext value: 5\nComplete!\n```\n\nRxPHP also has an operator `skipWhileWithIndex`.\n\nBypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements. The element's index is used in the logic of the predicate function.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/skip/skipWhileWithIndex.php\n\n$observable = Rx\\Observable::range(1, 5)\n    ->skipWhileWithIndex(function ($i, $value) {\n        return $i < 3;\n    });\n\n$observable->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 4\nNext value: 5\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/skipwhile.html](http://reactivex.io/documentation/operators/skipwhile.html)"
- name: Start
  id: documentation/operators/start
  summary: There are a number of ways that programming languages have for obtaining values as the result of calculations, with names like functions, futures, actions, callables, runnables, and so forth
  description: "# Start\n\ncreate an Observable that emits the return value of a function-like directive\n\nThere are a number of ways that programming languages have for obtaining values as the result of calculations, with names like functions, futures, actions, callables, runnables, and so forth. The operators grouped here under the Start operator category make these things behave like Observables so that they can be chained with other Observables in an Observable cascade\n\n## See Also\n\n- [From](from)\n- [Just](just)\n- [101 Rx Samples: Start — Run Code Asynchronously](http://rxwiki.wikidot.com/101samples#toc1)\n\n## Language-Specific Information\n\n### RxGroovy `asyncAction asyncFunc deferFuture forEachFuture fromAction fromCallable fromFunc0 fromRunnable start startFuture toAsync`\n\nThe various RxGroovy implementations of Start are found in the optional `rxjava-async` module.\n\nThe `rxjava-async` module includes the `start` operator, which accepts a function as its parameter, calls that function to retrieve a value, and then returns an Observable that will emit that value to each subsequent observer.\n\nNote that the function will only be executed once, even if more than one observer subscribes to the resulting Observable.\n\nThe `rxjava-async` module also includes the `toAsync`, `asyncAction`, and `asyncFunc` operators. These accept a function or an Action as their parameter. In the case of a function, this variant of the operator calls that function to retrieve a value, and then returns an Observable that will emit that value to each subsequent observer (just as the `start` operator does).\n\nIn the case of Action, the process is similar, but there is no return value. In this case, the Observable created by this operator will emit a `null` before terminating.\n\nNote that the function or Action will only be executed once, even if more than one observer subscribes to the resulting Observable.\n\nThe `rxjava-async` module also includes the `startFuture` operator. You pass it a function that returns a `Future`. `startFuture` calls this function immediately to obtain the `Future`, and calls the `Future`’s `get` method to try to obtain its value. It returns an Observable to which it will emit this value to any subsequent observers.\n\nThe `rxjava-async` module also includes the `deferFuture` operator. You pass it a function that returns a `Future` that returns an Observable. `deferFuture` returns an Observable, but does not call the function you provide until such time as an observer subscribes to the Observable it returns. When it does so, it immediately calls `get` on the resulting `Future`, and then mirrors the emissions from the Observable returned by the `Future` as its own emissions.\n\nIn this way you can include a `Future` that returns an Observable in a cascade of Observables as a peer to other Observables.\n\nThe `rxjava-async` module also includes the `fromAction` operator. It accepts an `Action` as its parameter, and returns an Observable that emits the item you pass to `fromAction` upon termination of the `Action`\n\nThe `rxjava-async` module also includes the `fromCallable` operator. It accepts a `Callable` as its parameter, and returns an Observable that emits the result of this callable as its sole emission.\n\nThe `rxjava-async` module also includes the `fromRunnable` operator. It accepts a `Runnable` as its parameter, and returns an Observable that emits the item you pass to `fromRunnable` upon termination of the `Runnable`\n\nThe `rxjava-async` module also includes the `forEachFuture` operator. It is not really a variant of the Start operator, but something all its own. You pass `forEachFuture` some subset of the typical observer methods (`onNext`, `onError`, and `onCompleted`) and the Observable will call these methods in the usual way. But `forEachFuture` itself returns a `Future` that blocks on `get` until the source Observable completes, then returns either the completion or error, depending on how the Observable completed.\n\nYou can use this if you need a function that blocks until the completion of an Observable.\n\nThe `rxjava-async` module also includes the `runAsync` operator. It is peculiar in that it creates a specialization of an Observable called a `StoppableObservable`.\n\nPass `runAsync` an `Action` and a [`Scheduler`](../scheduler), and it will return a `StoppableObservable` that uses the specified `Action` to generate items that it emits. The `Action` accepts an `Observer` and a `Subscription`. It uses the `Subscription` to check for the `unsubscribed` condition, upon which it will stop emitting items. You can also manually stop a `StoppableObservable` at any time by calling its `unsubscribe` method (which will also unsubscribe the `Subscription` you have associated with the `StoppableObservable`).\n\nBecause `runAsync` immediately invokes the `Action` and begins emitting the items (that is, it produces a *hot* Observable), it is possible that some items may be lost in the interval between when you establish the `StoppableObservable` with this operator and when your `Observer` is ready to receive items. If this is a problem, you can use the variant of `runAsync` that also accepts a `Subject` and pass a `ReplaySubject` with which you can retrieve the otherwise-missing items.\n\nIn RxGroovy there is also a version of the [From](from) operator that converts a `Future` into an Observable, and in this way resembles the Start operator.\n\n### RxJava 1․x `asyncAction asyncFunc deferFuture forEachFuture fromAction fromCallable fromFunc0 fromRunnable start startFuture toAsync`\n\nThe various RxJava implementations of Start are found in the optional `rxjava-async` module.\n\nThe `rxjava-async` module includes the `start` operator, which accepts a function as its parameter, calls that function to retrieve a value, and then returns an Observable that will emit that value to each subsequent observer.\n\nNote that the function will only be executed once, even if more than one observer subscribes to the resulting Observable.\n\nThe `rxjava-async` module also includes the `toAsync`, `asyncAction`, and `asyncFunc` operators. These accept a function or an Action as their parameter. In the case of a function, this variant of the operator calls that function to retrieve a value, and then returns an Observable that will emit that value to each subsequent observer (just as the `start` operator does).\n\nIn the case of Action, the process is similar, but there is no return value. In this case, the Observable created by this operator will emit a `null` before terminating.\n\nNote that the function or Action will only be executed once, even if more than one observer subscribes to the resulting Observable.\n\nThe `rxjava-async` module also includes the `startFuture` operator. You pass it a function that returns a `Future`. `startFuture` calls this function immediately to obtain the `Future`, and calls the `Future`’s `get` method to try to obtain its value. It returns an Observable to which it will emit this value to any subsequent observers.\n\nThe `rxjava-async` module also includes the `deferFuture` operator. You pass it a function that returns a `Future` that returns an Observable. `deferFuture` returns an Observable, but does not call the function you provide until such time as an observer subscribes to the Observable it returns. When it does so, it immediately calls `get` on the resulting `Future`, and then mirrors the emissions from the Observable returned by the `Future` as its own emissions.\n\nIn this way you can include a `Future` that returns an Observable in a cascade of Observables as a peer to other Observables.\n\nThe `rxjava-async` module also includes the `fromAction` operator. It accepts an `Action` as its parameter, and returns an Observable that emits the item you pass to `fromAction` upon termination of the `Action`\n\nThe `rxjava-async` module also includes the `fromCallable` operator. It accepts a `Callable` as its parameter, and returns an Observable that emits the result of this callable as its sole emission.\n\nThe `rxjava-async` module also includes the `fromRunnable` operator. It accepts a `Runnable` as its parameter, and returns an Observable that emits the item you pass to `fromRunnable` upon termination of the `Runnable`\n\nThe `rxjava-async` module also includes the `forEachFuture` operator. It is not really a variant of the Start operator, but something all its own. You pass `forEachFuture` some subset of the typical observer methods (`onNext`, `onError`, and `onCompleted`) and the Observable will call these methods in the usual way. But `forEachFuture` itself returns a `Future` that blocks on `get` until the source Observable completes, then returns either the completion or error, depending on how the Observable completed.\n\nYou can use this if you need a function that blocks until the completion of an Observable.\n\nThe `rxjava-async` module also includes the `runAsync` operator. It is peculiar in that it creates a specialization of an Observable called a `StoppableObservable`.\n\nPass `runAsync` an `Action` and a [`Scheduler`](../scheduler), and it will return a `StoppableObservable` that uses the specified `Action` to generate items that it emits. The `Action` accepts an `Observer` and a `Subscription`. It uses the `Subscription` to check for the `unsubscribed` condition, upon which it will stop emitting items. You can also manually stop a `StoppableObservable` at any time by calling its `unsubscribe` method (which will also unsubscribe the `Subscription` you have associated with the `StoppableObservable`).\n\nBecause `runAsync` immediately invokes the `Action` and begins emitting the items (that is, it produces a *hot* Observable), it is possible that some items may be lost in the interval between when you establish the `StoppableObservable` with this operator and when your `Observer` is ready to receive items. If this is a problem, you can use the variant of `runAsync` that also accepts a `Subject` and pass a `ReplaySubject` with which you can retrieve the otherwise-missing items.\n\nIn RxJava there is also a version of the [From](from) operator that converts a `Future` into an Observable, and in this way resembles the Start operator.\n\n### RxJS `start startAsync toAsync`\n\nRxJS implements the `start` operator. It takes as its parameters a function whose return value will be the emission from the resulting Observable, and, optionally, any additional parameter to that function and a [Scheduler](../scheduler) on which to run the function.\n\n#### Sample Code\n\n``` javascript\nvar context = { value: 42 };\n\nvar source = Rx.Observable.start(\n    function () {\n        return this.value;\n    },\n    context,\n    Rx.Scheduler.timeout\n);\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x);\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nNext: 42\nCompleted\n```\n\n`start` is found in the following distributions:\n\n- `rx.async.js` (requires `rx.binding.js` and either `rx.js` or `rx.compat.js`)\n- `rx.async.compat.js` (requires `rx.binding.js` and either `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nRxJS also implements the `startAsync` operator. It takes as its parameters an asynchronous function whose return value will be the emission from the resulting Observable.\n\nYou can convert a function into an asynchronous function with the `toAsync` method. It takes a function, function parameter, and [Scheduler](../scheduler) as parameters, and returns an asynchronous function that will be invoked on the specified Scheduler. The last two parameters are optional; if you do not specify a Scheduler, the `timeout` Scheduler will be used by default.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.startAsync(function () {\n    return RSVP.Promise.resolve(42);\n});\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x);\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nNext: 42\nCompleted\n```\n\n`startAsync` is found in the following distributions:\n\n- `rx.async.js` (requires `rx.binding.js` and either `rx.js` or `rx.compat.js`)\n- `rx.async.compat.js` (requires `rx.binding.js` and either `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n`toAsync` is found in the following distributions:\n\n- `rx.async.js` (requires `rx.binding.js` and either `rx.js` or `rx.compat.js`)\n- `rx.async.compat.js` (requires `rx.binding.js` and either `rx.js` or `rx.compat.js`)\n\n### RxPHP `start`\n\nRxPHP implements this operator as `start`.\n\nInvokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/start/start.php\n\n$source = Rx\\Observable::start(function () {\n    return 42;\n});\n\n$source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 42\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/start.html](http://reactivex.io/documentation/operators/start.html)"
- name: StartWith
  id: documentation/operators/startwith
  summary: If you want an Observable to emit a specific sequence of items before it begins emitting the items normally expected from it, apply the StartWith operator to it
  description: "# StartWith\n\nemit a specified sequence of items before beginning to emit the items from the source Observable\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#startWith)\n\nIf you want an Observable to emit a specific sequence of items before it begins emitting the items normally expected from it, apply the StartWith operator to it.\n\n(If, on the other hand, you want to append a sequence of items to the end of those normally emitted by an Observable, you want the [Concat](concat) operator.)\n\n#### See Also\n\n- [Concat](concat)\n- [Introduction to Rx: StartWith](http://www.introtorx.com/Content/v1.0.10621.0/12_CombiningSequences.html#StartWith)\n- [RxMarbles: `startWith`](http://rxmarbles.com/#startWith)\n\n## Language-Specific Information\n\n### RxClojure `cons`\n\nRxClojure implements this operator as `cons`. It takes an item and an Observable as parameters, and prepends the item to the items emitted by the Observable as its own Observable sequence.\n\n### RxCpp `start_with`\n\nRxCpp implements this operator as `start_with`. It takes an Observable and one or more items as parameters, and prepends these items, in the order they are given in the parameter list, to the items emitted by the Observable as its own Observable sequence.\n\n### RxGroovy `startWith`\n\nRxGroovy implements this operator as `startWith`.\n\nYou can pass the values you want to prepend to the Observable sequence to `startWith` either in a single Iterable or as a series of one to nine function parameters.\n\n#### Sample Code\n\n``` groovy\ndef myObservable = Observable.from([1, 2, 3]);\n\nmyObservable.startWith(-3, -2, -1, 0).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n-3\n-2\n-1\n0\n1\n2\n3\n```\n\n- Javadoc: [`startWith(Iterable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#startWith(java.lang.Iterable))\n- Javadoc: [`startWith(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#startWith(T)) (there are also versions that take up to nine individual items)\n\nYou can also pass `startWith` an Observable, and it will prepend the emissions from that Observable to those of the source Observable to make its own set of emissions. This is a sort of inverted Concat operation.\n\n- Javadoc: [`startWith(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#startWith(rx.Observable))\n\n### RxJava 1․x `startWith`\n\nRxJava implements this operator as `startWith`.\n\nYou can pass the values you want to prepend to the Observable sequence to `startWith` either in a single Iterable or as a series of one to nine function parameters.\n\n- Javadoc: [`startWith(Iterable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#startWith(java.lang.Iterable))\n- Javadoc: [`startWith(T)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#startWith(T)) (there are also versions that take up to nine individual items)\n\nYou can also pass `startWith` an Observable, and it will prepend the emissions from that Observable to those of the source Observable to make its own set of emissions. This is a sort of inverted Concat operation.\n\n- Javadoc: [`startWith(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#startWith(rx.Observable))\n\n### RxJS `startWith`\n\nRxJS implements this operator as `startWith`. It accepts a variable number of function parameters and treats each one as an item that it will prepend to the resulting Observable sequence in the order they are given in the parameter list.\n\n`startWith` is found in the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxKotlin `startWith`\n\nRxKotlin implements this operator as `startWith`.\n\nYou can pass the values you want to prepend to the Observable sequence to `startWith` either in a single Iterable or as a series of one to nine function parameters.\n\nYou can also pass `startWith` an Observable, and it will prepend the emissions from that Observable to those of the source Observable to make its own set of emissions. This is a sort of inverted Concat operation.\n\n### RxNet `StartWith`\n\nRx.NET implements this operator as `StartWith`. It accepts an array of items which it prepends to the resulting Observable sequence in the order they appear in the array before it emits the items from the source Observable.\n\n### RxPHP `startWith startWithArray`\n\nRxPHP implements this operator as `startWith`.\n\nPrepends a value to an observable sequence with an argument of a signal value to prepend.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/startWith/startWith.php\n\n$source = \\Rx\\Observable::of(2)\n    ->startWith(1);\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 1\nNext value: 2\nComplete!\n```\n\nRxPHP also has an operator `startWithArray`.\n\nPrepends a sequence of values to an observable sequence with an argument of an array of values to prepend.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/startWith/startWithArray.php\n\n$source = \\Rx\\Observable::of(4)\n    ->startWithArray([1, 2, 3]);\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 1\nNext value: 2\nNext value: 3\nNext value: 4\nComplete!\n```\n\n### RxPY `start_with`\n\nRxPY implements this operator as `start_with`. It accepts an array of items which it prepends to the resulting Observable sequence in the order they appear in the array before it emits the items from the source Observable.\n\n### Rxrb `start_with`\n\nRx.rb implements this operator as `start_with`. It accepts an array of items which it prepends to the resulting Observable sequence in the order they appear in the array before it emits the items from the source Observable.\n\n### RxScala `+:`\n\nRxScala implements this operator with `+:` It takes an item and an Observable as parameters, and prepends the item to the items emitted by the Observable as its own Observable sequence.\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/startwith.html](http://reactivex.io/documentation/operators/startwith.html)"
- name: Subject
  id: documentation/subject
  summary: A Subject is a sort of bridge or proxy that is available in some implementations of ReactiveX that acts both as an observer and as an Observable
  description: "# Subject\n\nA Subject is a sort of bridge or proxy that is available in some implementations of ReactiveX that acts both as an observer and as an Observable. Because it is an observer, it can subscribe to one or more Observables, and because it is an Observable, it can pass through the items it observes by reemitting them, and it can also emit new items.\n\nBecause a Subject subscribes to an Observable, it will trigger that Observable to begin emitting items (if that Observable is “cold” — that is, if it waits for a subscription before it begins to emit items). This can have the effect of making the resulting Subject a “hot” Observable variant of the original “cold” Observable.\n\n#### See Also\n\n- [To Use or Not to Use Subject](http://davesexton.com/blog/post/To-Use-Subject-Or-Not-To-Use-Subject.aspx) from Dave Sexton’s blog\n- [Introduction to Rx: Subject](http://www.introtorx.com/Content/v1.0.10621.0/02_KeyTypes.html#Subject)\n- [101 Rx Samples: ISubject\\<T\\> and ISubject\\<T1,T2\\>](http://rxwiki.wikidot.com/101samples#toc44)\n- [Advanced RxJava: Subject](http://akarnokd.blogspot.hu/2015/06/subjects-part-1.html) by Dávid Karnok\n- [Using Subjects](http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/subjects.html) by Dennis Stoyanov\n\n## Varieties of Subject\n\nThere are four varieties of `Subject` that are designed for particular use cases. Not all of these are available in all implementations, and some implementations use other naming conventions (for example, in RxScala, what is called a “PublishSubject” here is known simply as a “Subject”):\n\n### AsyncSubject\n\nAn `AsyncSubject` emits the last value (and only the last value) emitted by the source Observable, and only after that source Observable completes. (If the source Observable does not emit any values, the `AsyncSubject` also completes without emitting any values.)\n\nIt will also emit this same final value to any subsequent observers. However, if the source Observable terminates with an error, the `AsyncSubject` will not emit any items, but will simply pass along the error notification from the source Observable.\n\n#### See Also\n\n- [Introduction to Rx: AsyncSubject](http://www.introtorx.com/Content/v1.0.10621.0/02_KeyTypes.html#AsyncSubject)\n\n### BehaviorSubject\n\nWhen an observer subscribes to a `BehaviorSubject`, it begins by emitting the item most recently emitted by the source Observable (or a seed/default value if none has yet been emitted) and then continues to emit any other items emitted later by the source Observable(s).\n\nHowever, if the source Observable terminates with an error, the `BehaviorSubject` will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.\n\n#### See Also\n\n- [Introduction to Rx: BehaviorSubject](http://www.introtorx.com/Content/v1.0.10621.0/02_KeyTypes.html#BehaviorSubject)\n\n### PublishSubject\n\n`PublishSubject` emits to an observer only those items that are emitted by the source Observable(s) subsequent to the time of the subscription.\n\nNote that a `PublishSubject` may begin emitting items immediately upon creation (unless you have taken steps to prevent this), and so there is a risk that one or more items may be lost between the time the Subject is created and the observer subscribes to it. If you need to guarantee delivery of all items from the source Observable, you’ll need either to form that Observable with [`Create`](operators/create) so that you can manually reintroduce “cold” Observable behavior (checking to see that all observers have subscribed before beginning to emit items), or switch to using a `ReplaySubject` instead.\n\nIf the source Observable terminates with an error, the `PublishSubject` will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.\n\n### ReplaySubject\n\n`ReplaySubject` emits to any observer all of the items that were emitted by the source Observable(s), regardless of when the observer subscribes.\n\nThere are also versions of `ReplaySubject` that will throw away old items once the replay buffer threatens to grow beyond a certain size, or when a specified timespan has passed since the items were originally emitted.\n\nIf you use a `ReplaySubject` as an observer, take care not to call its `onNext` method (or its other `on` methods) from multiple threads, as this could lead to coincident (non-sequential) calls, which violates [the Observable contract](contract) and creates an ambiguity in the resulting Subject as to which item or notification should be replayed first.\n\n#### See Also\n\n- [Introduction to Rx: ReplaySubject](http://www.introtorx.com/Content/v1.0.10621.0/02_KeyTypes.html#ReplaySubject)\n\n## Language-Specific Information\n\n### RxGroovy\n\nIf you have a `Subject` and you want to pass it along to some other agent without exposing its `Subscriber` interface, you can mask it by calling its `asObservable` method, which will return the Subject as a pure `Observable`.\n\n#### See Also\n\n- Javadoc: [`AsyncSubject`](http://reactivex.io/RxJava/javadoc/rx/subjects/AsyncSubject.html)\n- Javadoc: [`BehaviorSubject`](http://reactivex.io/RxJava/javadoc/rx/subjects/BehaviorSubject.html)\n- Javadoc: [`PublishSubject`](http://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html)\n- Javadoc: [`ReplaySubject`](http://reactivex.io/RxJava/javadoc/rx/subjects/ReplaySubject.html)\n\n### RxJava 1․x\n\nIf you have a `Subject` and you want to pass it along to some other agent without exposing its `Subscriber` interface, you can mask it by calling its `asObservable` method, which will return the Subject as a pure `Observable`.\n\n#### See Also\n\n- Javadoc: [`AsyncSubject`](http://reactivex.io/RxJava/javadoc/rx/subjects/AsyncSubject.html)\n- Javadoc: [`BehaviorSubject`](http://reactivex.io/RxJava/javadoc/rx/subjects/BehaviorSubject.html)\n- Javadoc: [`PublishSubject`](http://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html)\n- Javadoc: [`ReplaySubject`](http://reactivex.io/RxJava/javadoc/rx/subjects/ReplaySubject.html)\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)"
- name: Subscribe
  id: documentation/operators/subscribe
  summary: The Subscribe operator is the glue that connects an observer to an Observable
  description: "# Subscribe\n\noperate upon the emissions and notifications from an Observable\n\nThe Subscribe operator is the glue that connects an observer to an Observable. In order for an observer to see the items being emitted by an Observable, or to receive error or completed notifications from the Observable, it must first subscribe to that Observable with this operator.\n\nA typical implementation of the Subscribe operator may accept one to three methods (which then constitute the observer), or it may accept an object (sometimes called an `Observer` or `Subscriber`) that implements the interface which includes those three methods:\n\n`onNext`  \nAn Observable calls this method whenever the Observable emits an item. This method takes as a parameter the item emitted by the Observable.\n\n`onError`  \nAn Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error. This stops the Observable and it will not make further calls to `onNext` or `onCompleted`. The `onError` method takes as its parameter an indication of what caused the error (sometimes an object like an Exception or Throwable, other times a simple string, depending on the implementation).\n\n`onCompleted`  \nAn Observable calls this method after it has called `onNext` for the final time, if it has not encountered any errors.\n\nAn Observable is called a “cold” Observable if it does not begin to emit items until an observer has subscribed to it; an Observable is called a “hot” Observable if it may begin emitting items at any time, and a subscriber may begin observing the sequence of emitted items at some point after its commencement, missing out on any items emitted previously to the time of the subscription.\n\n#### See Also\n\n- [Do](do)\n- [Introduction to Rx: IObserver](http://www.introtorx.com/Content/v1.0.10621.0/02_KeyTypes.html#IObserver)\n\n## Language-Specific Information\n\n### RxGroovy `BlockingObservable.forEach forEach subscribe`\n\nRxGroovy implements several variants of `subscribe`.\n\nIf you pass it no parameters, it will trigger a subscription to the underlying Observable, but will ignore its emissions and notifications. This will activate a cold Observable.\n\nYou can also pass it between one and three functions; these will be interpreted as follows:\n\n1.  `onNext`\n2.  `onNext` and `onError`\n3.  `onNext`, `onError`, and `onCompleted`\n\nFinally, you can pass it an object that implements either of the `Observer` or `Subscriber` interfaces. The `Observer` interface consists of the three previously-described “`on`” methods. The `Subscriber` interface implements these also, and adds a number of additional methods that facilitate reactive pull backpressure and that permit the Subscriber to unsubscribe to an Observable before it completes.\n\nThe call to `subscribe` returns an object that implements the `Subscription` interface. This interface includes the `unsubscribe` method that you can call at any time to sever the subscription that `subscribe` established between the Observable and the observer (or the methods that stand in for the observer).\n\n- Javadoc: [`subscribe()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe())\n- Javadoc: [`subscribe(Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.functions.Action1))\n- Javadoc: [`subscribe(Action1,Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.functions.Action1,%20rx.functions.Action1))\n- Javadoc: [`subscribe(Action1,Action1,Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.functions.Action1,%20rx.functions.Action1,%20rx.functions.Action0))\n- Javadoc: [`subscribe(Observer)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.Observer))\n- Javadoc: [`subscribe(Subscriber)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.Subscriber))\n\nThe `forEach` operators are simpler versions of `subscribe`. You can pass them between one and three functions, which will be interpreted as follows:\n\n1.  `onNext`\n2.  `onNext` and `onError`\n3.  `onNext`, `onError`, and `onCompleted`\n\nUnlike `subscribe`, `forEach` does not return an object with which you can cancel the subscription. Nor do you have the option of passing a parameter that has this capability. So you should only use this operator if you definitely need to operate on all of the emissions and notifications from the Observable.\n\n- Javadoc: [`forEach(Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#forEach(rx.functions.Action1))\n- Javadoc: [`forEach(Action1,Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#forEach(rx.functions.Action1,%20rx.functions.Action1))\n- Javadoc: [`forEach(Action1,Action1,Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#forEach(rx.functions.Action1,%20rx.functions.Action1,%20rx.functions.Action0))\n\nThere is also a `BlockingObservable` method called `forEach` that is somewhat similar. In order to use it, you must first convert your source Observable into a `BlockingObservable` by means of either the `BlockingObservable.from` method or the `Observable.toBlocking` operator.\n\n`BlockingObservable.forEach` takes a single function as its parameter, and this function behaves much like an `onNext` function in the subscription to an ordinary Observable. The `forEach` operator itself blocks until the `BlockingObservable` completes, and it is by unblocking, rather than by calling a callback function, that it indicates that it is complete. If it encounters an error it will throw a `RuntimeException` (rather than calling an analogue to the `onError` callback).\n\n- Javadoc: [BlockingObservable.forEach(Action1)](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#forEach(rx.functions.Action1))\n\n### RxJava 1․x `BlockingObservable.forEach forEach subscribe`\n\nRxJava implements several variants of `subscribe`.\n\nIf you pass it no parameters, it will trigger a subscription to the underlying Observable, but will ignore its emissions and notifications. This will activate a cold Observable.\n\nYou can also pass it between one and three functions; these will be interpreted as follows:\n\n1.  `onNext`\n2.  `onNext` and `onError`\n3.  `onNext`, `onError`, and `onCompleted`\n\nFinally, you can pass it an object that implements either of the `Observer` or `Subscriber` interfaces. The `Observer` interface consists of the three previously-described “`on`” methods. The `Subscriber` interface implements these also, and adds a number of additional methods that facilitate reactive pull backpressure and that permit the Subscriber to unsubscribe to an Observable before it completes.\n\nThe call to `subscribe` returns an object that implements the `Subscription` interface. This interface includes the `unsubscribe` method that you can call at any time to sever the subscription that `subscribe` established between the Observable and the observer (or the methods that stand in for the observer).\n\n- Javadoc: [`subscribe()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe())\n- Javadoc: [`subscribe(Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.functions.Action1))\n- Javadoc: [`subscribe(Action1,Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.functions.Action1,%20rx.functions.Action1))\n- Javadoc: [`subscribe(Action1,Action1,Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.functions.Action1,%20rx.functions.Action1,%20rx.functions.Action0))\n- Javadoc: [`subscribe(Observer)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.Observer))\n- Javadoc: [`subscribe(Subscriber)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.Subscriber))\n\nThe `forEach` operators are simpler versions of `subscribe`. You can pass them between one and three functions, which will be interpreted as follows:\n\n1.  `onNext`\n2.  `onNext` and `onError`\n3.  `onNext`, `onError`, and `onCompleted`\n\nUnlike `subscribe`, `forEach` does not return an object with which you can cancel the subscription. Nor do you have the option of passing a parameter that has this capability. So you should only use this operator if you definitely need to operate on all of the emissions and notifications from the Observable.\n\n- Javadoc: [`forEach(Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#forEach(rx.functions.Action1))\n- Javadoc: [`forEach(Action1,Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#forEach(rx.functions.Action1,%20rx.functions.Action1))\n- Javadoc: [`forEach(Action1,Action1,Action0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#forEach(rx.functions.Action1,%20rx.functions.Action1,%20rx.functions.Action0))\n\nThere is also a `BlockingObservable` method called `forEach` that is somewhat similar. In order to use it, you must first convert your source Observable into a `BlockingObservable` by means of either the `BlockingObservable.from` method or the `Observable.toBlocking` operator.\n\n`BlockingObservable.forEach` takes a single function as its parameter, and this function behaves much like an `onNext` function in the subscription to an ordinary Observable. The `forEach` operator itself blocks until the `BlockingObservable` completes, and it is by unblocking, rather than by calling a callback function, that it indicates that it is complete. If it encounters an error it will throw a `RuntimeException` (rather than calling an analogue to the `onError` callback).\n\n- Javadoc: [BlockingObservable.forEach(Action1)](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#forEach(rx.functions.Action1))\n\n### RxJS `forEach subscribe subscribeOnCompleted subscribeOnError subscribeOnNext`\n\nIn RxJS, you can subscribe to an Observable in two ways:\n\n1.  subscribe a single function to either the `onNext`, the `onCompleted`, or `onError` notifications from an Observable, with `subscribeOnNext`, `subscribeOnCompleted`, or `subscribeOnError` respectively\n2.  subscribe by passing zero to three individual functions, or an object that implements those three functions, into either the `subscribe` or `forEach` operator (those operators behave identically).\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 3)\n\nvar subscription = source.subscribeOnNext(\n  function (x) {\n    console.log('Next: %s', x);\n  });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\n```\n\n``` javascript\nvar source = Rx.Observable.range(0, 3);\n\nvar subscription = source.subscribeOnCompleted(\n  function () {\n    console.log('Completed');\n  });\n```\n\n``` javascript\nCompleted\n```\n\n``` javascript\nvar source = Rx.Observable.throw(new Error());\n\nvar subscription = source.subscribeOnError(\n  function (err) {\n    console.log('Error: %s', err);\n  });\n```\n\n``` javascript\nError: Error\n```\n\n``` javascript\nvar observer = Rx.Observer.create(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n\nvar source = Rx.Observable.range(0, 3)\n\nvar subscription = source.subscribe(observer);\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nCompleted\n```\n\n``` javascript\nvar source = Rx.Observable.range(0, 3)\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nCompleted\n```\n\nThe functions described in this section are all found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `subscribe`\n\nRxPHP implements this operator as `subscribe`.\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/subscribe.html](http://reactivex.io/documentation/operators/subscribe.html)"
- name: SubscribeOn
  id: documentation/operators/subscribeon
  summary: Many implementations of ReactiveX use “Schedulers” to govern an Observable’s transitions between threads in a multi-threaded environment
  description: "# SubscribeOn\n\nspecify the Scheduler on which an Observable will operate\n\nMany implementations of ReactiveX use [“`Scheduler`s”](../scheduler) to govern an Observable’s transitions between threads in a multi-threaded environment. You can instruct an Observable to do its work on a particular Scheduler by calling the Observable’s SubscribeOn operator.\n\nThe [ObserveOn](observeon) operator is similar, but more limited. It instructs the Observable to send notifications to observers on a specified Scheduler.\n\nIn some implementations there is also an UnsubscribeOn operator.\n\nBy default, an Observable and the chain of operators that you apply to it will do its work, and will notify its observers, on the same thread on which its `Subscribe` method is called. The SubscribeOn operator changes this behavior by specifying a different Scheduler on which the Observable should operate. The ObserveOn operator specifies a different Scheduler that the Observable will use to send notifications to its observers.\n\nAs shown in this illustration, the SubscribeOn operator designates which thread the Observable will begin operating on, no matter at what point in the chain of operators that operator is called. ObserveOn, on the other hand, affects the thread that the Observable will use *below* where that operator appears. For this reason, you may call ObserveOn multiple times at various points during the chain of Observable operators in order to change on which threads certain of those operators operate.\n\n#### See Also\n\n- [`Scheduler`](../scheduler)\n- [ObserveOn](observeon)\n- [Rx Workshop: Schedulers](http://channel9.msdn.com/Series/Rx-Workshop/Rx-Workshop-Schedulers)\n- [RxJava Threading Examples](http://www.grahamlea.com/2014/07/rxjava-threading-examples/) by Graham Lea\n- [Introduction to Rx: SubscribeOn and ObserveOn](http://www.introtorx.com/Content/v1.0.10621.0/15_SchedulingAndThreading.html#SubscribeOnObserveOn)\n- [Async Abstractions using rx-java](http://java.dzone.com/articles/async-abstractios-using-rx) by Biju Kunjummen, DZone\n- [RxJava: Understanding observeOn() and subscribeOn()](http://tomstechnicalblog.blogspot.hu/2016/02/rxjava-understanding-observeon-and.html) by Thomas Nield\n- [Advanced Reactive Java: SubscribeOn and ObserveOn](http://akarnokd.blogspot.hu/2016/03/subscribeon-and-observeon.html) by Dávid Karnok\n\n## Language-Specific Information\n\n### RxGroovy `subscribeOn unsubscribeOn`\n\nTo specify on which Scheduler the Observable should operate, use the `subscribeOn` operator, passing it the appropriate `Scheduler`.\n\n- Javadoc: [`subscribeOn(Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribeOn(rx.Scheduler))\n\nTo specify which Scheduler observers will use to unsubscribe from an Observable, use the `unsubscribeOn` operator, passing it the appropriate `Scheduler`.\n\n- Javadoc: [`unsubscribeOn(Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#unsubscribeOn(rx.Scheduler))\n\n### RxJava 1․x `subscribeOn unsubscribeOn`\n\nTo specify on which Scheduler the Observable should operate, use the `subscribeOn` operator, passing it the appropriate `Scheduler`.\n\n- Javadoc: [`subscribeOn(Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribeOn(rx.Scheduler))\n\nTo specify which Scheduler observers will use to unsubscribe from an Observable, use the `unsubscribeOn` operator, passing it the appropriate `Scheduler`.\n\n- Javadoc: [`unsubscribeOn(Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#unsubscribeOn(rx.Scheduler))\n\n### RxJS `subscribeOn`\n\nTo specify on which Scheduler the Observable should operate, use the `subscribeOn` operator, passing it the appropriate `Scheduler`.\n\n#### Sample Code\n\n``` javascript\n/* Change from immediate scheduler to timeout */\nvar source = Rx.Observable.return(42, Rx.Scheduler.immediate)\n    .subscribeOn(Rx.Scheduler.timeout);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 42\nCompleted\n```\n\n`subscribeOn` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/subscribeon.html](http://reactivex.io/documentation/operators/subscribeon.html)"
- name: Sum
  id: documentation/operators/sum
  summary: 'The Sum operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single value: the sum of all of the numbers emitted by the source Observable'
  description: "# Sum\n\ncalculates the sum of numbers emitted by an Observable and emits this sum\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#sum)\n\nThe Sum operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single value: the sum of all of the numbers emitted by the source Observable.\n\n#### See Also\n\n- [Average](average)\n- [Introduction to Rx: Min, Max, Sum, and Average](http://www.introtorx.com/Content/v1.0.10621.0/07_Aggregation.html#MaxAndMin)\n- [RxMarbles: `sum`](http://rxmarbles.com/#sum)\n\n## Language-Specific Information\n\n### RxGroovy `sumDouble sumFloat sumInteger sumLong StringObservable.join StringObservable.stringConcat`\n\nIn RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct `rxjava-math` module, where it is implemented with four type-specific operators: `sumDouble`, `sumFloat`, `sumInteger`, and `sumLong`. The following example shows how these operators work:\n\n#### Sample Code\n\n``` groovy\ndef myObservable = Observable.create({ aSubscriber ->\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext(4);\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext(3);\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext(2);\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onNext(1);\n  if(false == aSubscriber.isUnsubscribed()) aSubscriber.onCompleted();\n});\n\nObservable.sumInteger(myObservable).subscribe(\n  { println(it); },                  // onNext\n  { println(\"Error encountered\"); }, // onError\n  { println(\"Sequence complete\"); }  // onCompleted\n);\n```\n\n``` javascript\n10\nSequence complete\n```\n\nYou can also sum not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the sum of the number of sides on the figures emitted by the source Observable.\n\nIn the distinct `StringObservable` class (not part of RxGroovy by default) there is also a `stringConcat` operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of them all.\n\nIn the distinct `StringObservable` class (not part of RxGroovy by default) there is also a `join` operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of each of them, delimited by a string of your choosing.\n\n### RxJava 1․x `sumDouble sumFloat sumInteger sumLong StringObservable.join StringObservable.stringConcat`\n\nThis operator is not in the RxJava core, but is part of the distinct `rxjava-math` module, where it is implemented with four type-specific operators: `sumDouble`, `sumFloat`, `sumInteger`, and `sumLong`.\n\nYou can also sum not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the sum of the number of sides on the figures emitted by the source Observable.\n\nIn the distinct `StringObservable` class (not part of RxJava by default) there is also a `stringConcat` operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of them all.\n\nIn the distinct `StringObservable` class (not part of RxJava by default) there is also a `join` operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of each of them, delimited by a string of your choosing.\n\n### RxJS `sum`\n\nRxJS implements this operator as `sum`. The following code sample shows how to use it:\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 9).sum();\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x);\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nNext: 45\nCompleted\n```\n\nYou can also sum not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the sum number of sides on the figures emitted by the source Observable.\n\n#### Sample Code\n\n``` javascript\nvar arr = [\n    { value: 1 },\n    { value: 2 },\n    { value: 3 }\n];\n\nvar source = Rx.Observable.fromArray(arr).sum(function (x) {\n    return x.value;\n});\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x);\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nNext: 6\nCompleted\n```\n\n`sum` is found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\nIt requires one of the following:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `sum`\n\nRxPHP implements this operator as `sum`.\n\nComputes the sum of a sequence of values\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/sum/sum.php\n\n$source = Rx\\Observable::range(1, 10)\n    ->sum();\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 55\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/sum.html](http://reactivex.io/documentation/operators/sum.html)"
- name: Switch
  id: documentation/operators/switch
  summary: Switch subscribes to an Observable that emits Observables
  description: "# Switch\n\nconvert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables\n\nSwitch subscribes to an Observable that emits Observables. Each time it observes one of these emitted Observables, the Observable returned by Switch unsubscribes from the previously-emitted Observable begins emitting items from the latest Observable. Note that it will unsubscribe from the previously-emitted Observable when a new Observable is emitted from the source Observable, not when the new Observable emits an item. This means that items emitted by the previous Observable between the time the subsequent Observable is emitted and the time that subsequent Observable itself begins emitting items will be dropped (as with the yellow circle in the diagram above).\n\n#### See Also\n\n- [Amb](amb)\n- [Concat](concat)\n- [FlatMap](flatmap)\n- [Introduction to Rx: Switch](http://www.introtorx.com/Content/v1.0.10621.0/12_CombiningSequences.html#Switch)\n\n## Language-Specific Information\n\n### RxGroovy `switchOnNext`\n\nRxGroovy implements this operator as `switchOnNext`. It does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`switchOnNext(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#switchOnNext(rx.Observable))\n\n### RxJava 1․x `switchOnNext`\n\nRxJava implements this operator as `switchOnNext`. It does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`switchOnNext(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#switchOnNext(rx.Observable))\n\n### RxJS `switch`\n\nRxJS implements this operator as `switch`\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 3)\n    .select(function (x) { return Rx.Observable.range(x, 3); })\n    .switch();\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nNext: 3\nNext: 4\nCompleted\n```\n\n`switch` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `switch switchFirst`\n\nRxPHP implements this operator as `switch`.\n\nTransforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/switch/switch.php\n\n$source = Rx\\Observable::range(0, 3)\n    ->map(function ($x) {\n        return \\Rx\\Observable::range($x, 3);\n    })\n    ->switch();\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 0\nNext value: 1\nNext value: 2\nNext value: 3\nNext value: 4\nComplete!\n```\n\nRxPHP also has an operator `switchFirst`.\n\nReceives an Observable of Observables and propagates the first Observable exclusively until it completes before it begins subscribes to the next Observable. Observables that come before the current Observable completes will be dropped and will not propagate. This operator is similar to concatAll() except that it will not hold onto Observables that come in before the current one is finished completed.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/switch/switchFirst.php\n\n$source = Rx\\Observable::fromArray([\n    \\Rx\\Observable::interval(100)->mapTo('a'),\n    \\Rx\\Observable::interval(200)->mapTo('b'),\n    \\Rx\\Observable::interval(300)->mapTo('c'),\n])\n    ->switchFirst()\n    ->take(3);\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: a\nNext value: a\nNext value: a\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/switch.html](http://reactivex.io/documentation/operators/switch.html)"
- name: Take
  id: documentation/operators/take
  summary: You can emit only the first n items emitted by an Observable and then complete while ignoring the remainder, by modifying the Observable with the Take operator
  description: "# Take\n\nemit only the first *n* items emitted by an Observable\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#take)\n\nYou can emit only the first *n* items emitted by an Observable and then complete while ignoring the remainder, by modifying the Observable with the Take operator.\n\n#### See Also\n\n- [First](first)\n- [Skip](skip)\n- [SkipLast](skiplast)\n- [SkipUntil](skipuntil)\n- [SkipWhile](skipwhile)\n- [TakeLast](takelast)\n- [TakeUntil](takeuntil)\n- [TakeWhile](takewhile)\n- [Introduction to Rx: Skip and Take](http://www.introtorx.com/Content/v1.0.10621.0/05_Filtering.html#SkipAndTake)\n- [RxMarbles: `take`](http://rxmarbles.com/#take)\n\n## Language-Specific Information\n\n### RxGroovy `limit take`\n\nIn RxGroovy, this operator is implemented as `take`.\n\nIf you use the `take(`*`n`*`)` operator (or its synonym, `limit(`*`n`*`)`) on an Observable, and that Observable emits fewer than *n* items before completing, the new, `take`-modified Observable will not throw an exception or invoke `onError`, but will merely emit this same fewer number of items before it completes.\n\n#### Sample Code\n\n``` groovy\nnumbers = Observable.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nnumbers.take(3).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n1\n2\n3\nSequence complete\n```\n\nThis variant of `take` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`take(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#take(int))\n\nThere is also a variant of `take` that takes a temporal duration rather than a quantity of items. It results in an Observable that emits only those items that are emitted during that initial duration of the source Observable’s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to `take`.\n\nThis variant of `take` by default operates on the `computation` [Scheduler](../scheduler), but you may also pass in a Scheduler of your choosing as an optional third parameter.\n\n- Javadoc: [`take(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#take(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`take(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#take(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n### RxJava 1․x `limit take`\n\nIn RxJava, this operator is implemented as `take`.\n\nIf you use the `take(`*`n`*`)` operator (or its synonym, `limit(`*`n`*`)`) on an Observable, and that Observable emits fewer than *n* items before completing, the new, `take`-modified Observable will not throw an exception or invoke `onError`, but will merely emit this same fewer number of items before it completes.\n\n#### Sample Code\n\n``` java\nObservable.just(1, 2, 3, 4, 5, 6, 7, 8)\n          .take(4)\n          .subscribe(new Subscriber<Integer>() {\n        @Override\n        public void onNext(Integer item) {\n            System.out.println(\"Next: \" + item);\n        }\n\n        @Override\n        public void onError(Throwable error) {\n            System.err.println(\"Error: \" + error.getMessage());\n        }\n\n        @Override\n        public void onCompleted() {\n            System.out.println(\"Sequence complete.\");\n        }\n    });\n```\n\n``` javascript\nNext: 1\nNext: 2\nNext: 3\nNext: 4\nSequence complete.\n```\n\nThis variant of `take` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`take(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#take(int))\n\nThere is also a variant of `take` that takes a temporal duration rather than a quantity of items. It results in an Observable that emits only those items that are emitted during that initial duration of the source Observable’s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to `take`.\n\nThis variant of `take` by default operates on the `computation` [Scheduler](../scheduler), but you may also pass in a Scheduler of your choosing as an optional third parameter.\n\n- Javadoc: [`take(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#take(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`take(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#take(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n### RxJS `take takeUntilWithTime`\n\nRxJS implements the `take` operator.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 5)\n    .take(3);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nCompleted\n```\n\nFor the special case of `take(0)` you can also pass as a second parameter a [Scheduler](../scheduler) that `take` will use to immediately schedule a call to `onCompleted`.\n\n`take` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nRxJS also implements a `takeUntilWithTime` operator, which is like `take` except that rather than taking a particular quantity of items, it takes all of the items that are emitted during an initial period of time. You establish this period of by passing in a parameter to `takeUntilWithTime`, in either of these formats:\n\na number  \nmirrors items from the source Observable until this many milliseconds have passed since the Observable was subscribed to\n\na `Date`  \nmirrors items from the source Observable until this absolute time\n\nYou may also, optionally, pass in a [Scheduler](../scheduler) as a second parameter, and the timer will operate on that Scheduler (`takeUntilWithTime` uses the `timeout` Scheduler by default).\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.timer(0, 1000)\n    .takeUntilWithTime(5000);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nNext: 3\nNext: 4\nCompleted\n```\n\n`takeUntilWithTime` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.time.js` (requires `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `take takeUntil`\n\nRxPHP implements this operator as `take`.\n\nReturns a specified number of contiguous elements from the start of an observable sequence\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/take/take.php\n\n$observable = Rx\\Observable::fromArray([21, 42, 63]);\n$observable\n    ->take(2)\n    ->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 21\nNext value: 42\nComplete!\n```\n\nRxPHP also has an operator `takeUntil`.\n\nReturns the values from the source observable sequence until the other observable sequence produces a value.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/take/takeUntil.php\n\n$source = \\Rx\\Observable::interval(105)\n    ->takeUntil(\\Rx\\Observable::timer(1000));\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 0\nNext value: 1\nNext value: 2\nNext value: 3\nNext value: 4\nNext value: 5\nNext value: 6\nNext value: 7\nNext value: 8\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/take.html](http://reactivex.io/documentation/operators/take.html)"
- name: TakeLast
  id: documentation/operators/takelast
  summary: You can emit only the final n items emitted by an Observable and ignore those items that come before them, by modifying the Observable with the TakeLast operator
  description: "# TakeLast\n\nemit only the final *n* items emitted by an Observable\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#takeLast)\n\nYou can emit only the final *n* items emitted by an Observable and ignore those items that come before them, by modifying the Observable with the TakeLast operator.\n\n#### See Also\n\n- [Last](last)\n- [Skip](skip)\n- [SkipLast](skiplast)\n- [SkipUntil](skipuntil)\n- [SkipWhile](skipwhile)\n- [Take](take)\n- [TakeUntil](takeuntil)\n- [TakeWhile](takewhile)\n- [Introduction to Rx: SkipLast and TakeLast](http://www.introtorx.com/Content/v1.0.10621.0/05_Filtering.html#SkipLastTakeLast)\n- [RxMarbles: `takeLast`](http://rxmarbles.com/#takeLast)\n\n## Language-Specific Information\n\n### RxGroovy `takeLast takeLastBuffer`\n\nYou can emit only the final *n* items emitted by an Observable and ignore those items that precede them, by modifying the Observable with the `takeLast(`*`n`*`)` operator. Note that this will delay the emission of any item from the source Observable until the source Observable completes.\n\n#### Sample Code\n\n``` groovy\nnumbers = Observable.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\nnumbers.takeLast(2).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n8\n9\nSequence complete\n```\n\nThis variant of `takeLast` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`takeLast(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLast(int))\n\nThere is also a variant of `takeLast` that takes a temporal duration rather than a quantity of items. It emits only those items that are emitted during that final duration of the source Observable’s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to `takeLast`.\n\nNote that this will delay the emission of any item from the source Observable until the source Observable completes.\n\nThis variant of `takeLast` by default operates on the `computation` [Scheduler](../scheduler), but you may also pass in a Scheduler of your choosing as an optional third parameter.\n\n- Javadoc: [`takeLast(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLast(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`takeLast(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLast(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nThere is also a variant that combines the two methods. It emits the minimum of the number of items emitted during a specified time window *or* a particular count of items.\n\nThis variant of `takeLast` by default operates on the `computation` [Scheduler](../scheduler), but you may also pass in a Scheduler of your choosing as an optional fourth parameter.\n\n- Javadoc: [`takeLast(int,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLast(int,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`takeLast(int,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLast(int,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nThere is also an operator called `takeLastBuffer`. It exists in the same set of variants as described above for `takeLast`, and only differs in behavior by emitting its items not individually but collected into a single `List` of items that is emitted as a single item.\n\n- Javadoc: [`takeLastBuffer(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(int))\n- Javadoc: [`takeLastBuffer(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`takeLastBuffer(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n- Javadoc: [`takeLastBuffer(int,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(int,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`takeLastBuffer(int,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(int,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n### RxJava 1․x `takeLast takeLastBuffer`\n\nYou can emit only the final *n* items emitted by an Observable and ignore those items that precede them, by modifying the Observable with the `takeLast(`*`n`*`)` operator. Note that this will delay the emission of any item from the source Observable until the source Observable completes.\n\nThis variant of `takeLast` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`takeLast(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLast(int))\n\nThere is also a variant of `takeLast` that takes a temporal duration rather than a quantity of items. It emits only those items that are emitted during that final duration of the source Observable’s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to `takeLast`.\n\nNote that this will delay the emission of any item from the source Observable until the source Observable completes.\n\nThis variant of `takeLast` by default operates on the `computation` [Scheduler](../scheduler), but you may also pass in a Scheduler of your choosing as an optional third parameter.\n\n- Javadoc: [`takeLast(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLast(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`takeLast(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLast(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nThere is also a variant that combines the two methods. It emits the minimum of the number of items emitted during a specified time window *or* a particular count of items.\n\nThis variant of `takeLast` by default operates on the `computation` [Scheduler](../scheduler), but you may also pass in a Scheduler of your choosing as an optional fourth parameter.\n\n- Javadoc: [`takeLast(int,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLast(int,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`takeLast(int,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLast(int,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nThere is also an operator called `takeLastBuffer`. It exists in the same set of variants as described above for `takeLast`, and only differs in behavior by emitting its items not individually but collected into a single `List` of items that is emitted as a single item.\n\n- Javadoc: [`takeLastBuffer(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(int))\n- Javadoc: [`takeLastBuffer(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`takeLastBuffer(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n- Javadoc: [`takeLastBuffer(int,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(int,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`takeLastBuffer(int,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(int,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n### RxJS `takeLast takeLastBuffer takeLastBufferWithTime takeLastWithTime`\n\nYou can emit only the final *n* items emitted by an Observable and ignore those items that precede them, by modifying the Observable with the `takeLast(`*`n`*`)` operator. Note that this will delay the emission of any item from the source Observable until that Observable completes.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 5)\n    .takeLast(3);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 2\nNext: 3\nNext: 4\nCompleted\n```\n\n`takeLast` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.alljs`\n- `rx.all.compatjs`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThe `takeLastWithTime` operator takes a temporal duration rather than a quantity of items. It emits only those items that are emitted during that final duration of the source Observable’s lifespan. You set this duration by passing in a number of milliseconds as a parameter to `takeLastWithTime`.\n\nNote that the mechanism by which this is implemented will delay the emission of any item from the source Observable until that Observable completes.\n\n`takeLastWithTime` by default operates the timer on the `timeout` [Scheduler](../scheduler) and emits items on the `currentThread` Scheduler, but you may also pass in Schedulers of your choosing to override these, as an optional second and third parameters, respectively.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.timer(0, 1000)\n    .take(10)\n    .takeLastWithTime(5000);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 5\nNext: 6\nNext: 7\nNext: 8\nNext: 9\nCompleted\n```\n\n`takeLastWithTime` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.time.js` (requires `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThere is also an operator called `takeLastBuffer`. It differs in behavior from `takeLast` by emitting its items not individually but collected into a single array of items that is emitted as a single item.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(0, 5)\n    .takeLastBuffer(3);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 2,3,4\nCompleted\n```\n\n`takeLastBuffer` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n`takeLastBuffer` also has its duration-based variant, `takeLastBufferWithTime`, which is similar to `takeLastWithTime` except that it emits its items not individually but collected into a single array of items that is emitted as a single item.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable\n    .timer(0, 1000)\n    .take(10)\n    .takeLastBufferWithTime(5000);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 5,6,7,8,9\nCompleted\n```\n\n`takeLastBufferWithTime` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.time.js` (requires `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `takeLast`\n\nRxPHP implements this operator as `takeLast`.\n\nReturns a specified number of contiguous elements from the end of an observable sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/take/takeLast.php\n\n$source = \\Rx\\Observable::range(0, 5)\n    ->takeLast(3);\n\n$source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 2\nNext value: 3\nNext value: 4\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/takelast.html](http://reactivex.io/documentation/operators/takelast.html)"
- name: TakeUntil
  id: documentation/operators/takeuntil
  summary: The TakeUntil subscribes and begins mirroring the source Observable
  description: "# TakeUntil\n\ndiscard any items emitted by an Observable after a second Observable emits an item or terminates\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#takeUntil)\n\nThe TakeUntil subscribes and begins mirroring the source Observable. It also monitors a second Observable that you provide. If this second Observable emits an item or sends a termination notification, the Observable returned by TakeUntil stops mirroring the source Observable and terminates.\n\n#### See Also\n\n- [Skip](skip)\n- [SkipLast](skiplast)\n- [SkipUntil](skipuntil)\n- [SkipWhile](skipwhile)\n- [Take](take)\n- [TakeLast](takelast)\n- [TakeWhile](takewhile)\n- [Introduction to Rx: SkipUntil and TakeUntil](http://www.introtorx.com/Content/v1.0.10621.0/05_Filtering.html#SkipUntilTakeUntil)\n- [RxMarbles: `takeUntil`](http://rxmarbles.com/#takeUntil)\n\n## Language-Specific Information\n\n### RxGroovy `takeUntil`\n\nIn RxGroovy, this operator is implemented as `takeUntil`. Note that the second Observable can cause `takeUntil` to quit emitting items either by emitting an item or by issuing an `onError` or `onCompleted` notification.\n\n`takeUntil` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`takeUntil(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeUntil(rx.Observable))\n\nA second version of this operator was released in RxGroovy 1.1. It uses a predicate function that evaluates the items emitted by the source Observable, rather than a second Observable, to terminate the resulting Observable sequence. In this way, it behaves in a similar way to [TakeWhile](takewhile).\n\n- Javadoc: [`takeUntil(Func1)` (RxGroovy 1.1)](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeUntil(rx.functions.Func1))\n\n### RxJava 1․x `takeUntil`\n\nIn RxJava, this operator is implemented as `takeUntil`. Note that the second Observable can cause `takeUntil` to quit emitting items either by emitting an item or by issuing an `onError` or `onCompleted` notification.\n\n`takeUntil` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`takeUntil(Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeUntil(rx.Observable))\n\nA second version of this operator was released in RxJava 1.1. It uses a predicate function that evaluates the items emitted by the source Observable, rather than a second Observable, to terminate the resulting Observable sequence. In this way, it behaves in a similar way to [TakeWhile](takewhile).\n\n- Javadoc: [`takeUntil(Func1)` (RxJava 1.1)](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeUntil(rx.functions.Func1))\n\n### RxJS `takeUntil`\n\nRxJS implements the `takeUntil` operator. You can pass it either an Observable or a `Promise` that it will monitor for an item that triggers `takeUntil` to stop mirroring the source Observable.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.timer(0, 1000)\n    .takeUntil(Rx.Observable.timer(5000));\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nNext: 3\nNext: 4\nCompleted\n```\n\n`takeUntil` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThere is also a `takeUntilWithTime` operator to which you can pass an absolute time or an initial duration, but this is described on the [Take](take) operator page.\n\n### RxPHP `takeUntil`\n\nRxPHP implements this operator as `takeUntil`.\n\nReturns the values from the source observable sequence until the other observable sequence produces a value.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/take/take.php\n\n$observable = Rx\\Observable::fromArray([21, 42, 63]);\n$observable\n    ->take(2)\n    ->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 21\nNext value: 42\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/takeuntil.html](http://reactivex.io/documentation/operators/takeuntil.html)"
- name: TakeWhile
  id: documentation/operators/takewhile
  summary: The TakeWhile mirrors the source Observable until such time as some condition you specify becomes false, at which point TakeWhile stops mirroring the source Observable and terminates its own Observable
  description: "# TakeWhile\n\nmirror items emitted by an Observable until a specified condition becomes false\n\nThe TakeWhile mirrors the source Observable until such time as some condition you specify becomes false, at which point TakeWhile stops mirroring the source Observable and terminates its own Observable.\n\n#### See Also\n\n- [Skip](skip)\n- [SkipLast](skiplast)\n- [SkipUntil](skipuntil)\n- [SkipWhile](skipwhile)\n- [Take](take)\n- [TakeLast](takelast)\n- [TakeUntil](takeuntil)\n- [Introduction to Rx: SkipWhile and TakeWhile](http://www.introtorx.com/Content/v1.0.10621.0/05_Filtering.html#SkipWhileTakeWhile)\n\n## Language-Specific Information\n\n### RxGroovy `takeWhile`\n\nThe `takeWhile` operator returns an Observable that mirrors the behavior of the source Observable until such time as a function, applied to an item emitted by that Observable, returns `false`, whereupon the new Observable terminates with an `onCompleted` notification.\n\n``` groovy\nnumbers = Observable.from( [1, 2, 3, 4, 5, 6, 7, 8, 9] );\n\nnumbers.takeWhile({ ((it < 6) || (0 == (it % 2))) }).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n1\n2\n3\n4\n5\n6\nSequence complete\n```\n\n`takeWhile` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`takeWhile(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeWhile(rx.functions.Func1))\n\n### RxJava 1․x `takeWhile`\n\nThe `takeWhile` operator returns an Observable that mirrors the behavior of the source Observable until such time as a function, applied to an item emitted by that Observable, returns `false`, whereupon the new Observable terminates with an `onCompleted` notification.\n\n`takeWhile` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`takeWhile(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeWhile(rx.functions.Func1))\n\n### RxJS `takeWhile`\n\nRxJS implements the `takeWhile` operator. You pass it a function that governs the takeping process. `takeWhile` calls that function for each item emitted by the source Observable until such time as the function returns `false`, whereupon `takeWhile` stops mirroring the source Observable (starting with that item) and issues an `onCompleted` notification. The function takes three parameters:\n\n1.  the emitted item\n2.  the zero-based index of that item in the sequence of emissions\n3.  the source Observable\n\nYou may optionally pass a second parameter to `takeWhile`. If so, that item will also be available to your predicate function as “`this`”.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.range(1, 5)\n    .takeWhile(function (x) { return x < 3; });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nCompleted\n```\n\n`takeWhile` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `takeWhile takeWhileWithIndex`\n\nRxPHP implements this operator as `takeWhile`.\n\nReturns elements from an observable sequence as long as a specified condition is true. It takes as a parameter a a callback to test each source element for a condition. The callback predicate is called with the value of the element.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/take/takeWhile.php\n\n\n$source = \\Rx\\Observable::range(1, 5)\n    ->takeWhile(function ($x) {\n        return $x < 3;\n    });\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 1\nNext value: 2\nComplete!\n```\n\nRxPHP also has an operator `takeWhileWithIndex`.\n\nReturns elements from an observable sequence as long as a specified condition is true. It takes as a parameter a a callback to test each source element for a condition. The callback predicate is called with the index and the value of the element.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/take/takeWhileWithIndex.php\n\n\n$source = \\Rx\\Observable::range(1, 5)\n    ->takeWhileWithIndex(function ($i) {\n        return $i < 3;\n    });\n\n$subscription = $source->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 1\nNext value: 2\nNext value: 3\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/takewhile.html](http://reactivex.io/documentation/operators/takewhile.html)"
- name: The Observable Contract
  id: documentation/contract
  summary: “The Observable Contract,” which you may see referenced in various places in source documentation and in the pages on this site, is an attempt at a formal definition of an Observable, based originally on the 2010 document Rx Design Guidelines from Microsoft that described its Rx.NET implementation of ReactiveX
  description: "# The Observable Contract\n\n“The Observable Contract,” which you may see referenced in various places in source documentation and in the pages on this site, is an attempt at a formal definition of an Observable, based originally on the 2010 document [Rx Design Guidelines](https://go.microsoft.com/fwlink/?LinkID=205219) from Microsoft that described its Rx.NET implementation of ReactiveX.\n\nThis page summarizes The Observable Contract.\n\n## Notifications\n\nAn Observable communicates with its observers with the following *notifications*:\n\nOnNext  \nconveys an *item* that is *emitted* by the Observable to the observer\n\nOnCompleted  \nindicates that the Observable has completed successfully and that it will be emitting no further items\n\nOnError  \nindicates that the Observable has terminated with a specified error condition and that it will be emitting no further items\n\nOnSubscribe (optional)  \nindicates that the Observable is ready to accept Request notifications from the observer (see *Backpressure* below)\n\nAn observer communicates with its Observable by means of the following notifications:\n\nSubscribe  \nindicates that the observer is ready to receive notifications from the Observable\n\nUnsubscribe  \nindicates that the observer no longer wants to receive notifications from the Observable\n\nRequest (optional)  \nindicates that the observer wants no more than a particular number of additional OnNext notifications from the Observable (see *Backpressure* below)\n\n## The Contract Governing Notifications\n\nAn Observable may make zero or more OnNext notifications, each representing a single emitted item, and it may then follow those emission notifications by either an OnCompleted or an OnError notification, but not both. Upon issuing an OnCompleted or OnError notification, it may not thereafter issue any further notifications.\n\nAn Observable may emit no items at all. An Observable may also never terminate with either an OnCompleted or an OnError notification. That is to say that it is proper for an Observable to issue no notifications, to issue only an OnCompleted or an OnError notification, or to issue only OnNext notifications.\n\nObservables must issue notifications to observers serially (not in parallel). They may issue these notifications from different threads, but there must be a formal *happens-before* relationship between the notifications.\n\n## Observable Termination\n\nIf an Observable has not issued an OnCompleted or OnError notification, an observer may consider it to be still active (even if it is not currently emitting items) and may issue it notifications (such as an Unsubscribe or Request notification). When an Observable does issue an OnCompleted or OnError notification, the Observable may release its resources and terminate, and its observers should not attempt to communicate with it any further.\n\nAn OnError notification must contain the cause of the error (that is to say, it is invalid to call OnError with a `null` value).\n\nBefore an Observable terminates it must first issue either an OnCompleted or OnError notification to all of the observers that are subscribed to it.\n\n## Subscribing and Unsubscribing\n\nAn Observable may begin issuing notifications to an observer immediately after the Observable receives a Subscribe notification from the observer.\n\nWhen an observer issues an Unsubscribe notification to an Observable, the Observable will attempt to stop issuing notifications to the observer. It is not guaranteed, however, that the Observable will issue *no* notifications to the observer after an observer issues it an Unsubscribe notification.\n\nWhen an Observable issues an OnError or OnComplete notification to its observers, this ends the subscription. Observers do not need to issue an Unsubscribe notification to end subscriptions that are ended by the Observable in this way.\n\n## Multiple Observers\n\nIf a second observer subscribes to an Observable that is already emitting items to a first observer, it is up to the Observable whether it will thenceforth emit the same items to each observer, or whether it will replay the complete sequence of items from the beginning to the second observer, or whether it will emit a wholly different sequence of items to the second observer. There is no general guarantee that two observers of the same Observable will see the same sequence of items.\n\n## Backpressure\n\nBackpressure is optional; not all ReactiveX implementations include backpressure, and in those that do, not all Observables or operators honor backpressure. An Observable *may* implement backpressure if it detects that its observer implements *Request* notifications and understands *OnSubscribe* notifications.\n\nIf an Observable implements backpressure and its observer employs backpressure, the Observable will not begin to emit items to the observer immediately upon subscription. Instead, it will issue an OnSubscribe notification to the observer.\n\nAt any time after it receives an OnSubscribe notification, an observer may issue a Request notification to the Observable it has subscribed to. This notification requests a particular number of items. The Observable responds to such a Request by emitting no more items to the observer than the number of items the observer requests. However the Observable may, in addition, issue an OnCompleted or OnError notification, and it may even issue such a notification before the observer requests any items at all.\n\nAn Observable that does not implement backpressure should respond to a Request notification from an observer by issuing an OnError notification that indicates that backpressure is not supported.\n\nRequests are cumulative. For example, if an observer issues three Request notifications to an Observable, for 3, 5, and 10 items respectively, that Observable may emit as many as 18 items to the observer, no matter when those Request notifications arrived relative to when the Observable emitted items in response.\n\nIf the Observable produces more items than the observer requests, it is up to the Observable whether it will discard the excess items, store them to emit at a later time, or use some other strategy to deal with the overflow.\n\n## See Also\n\n- [Rx Design Guidelines](https://go.microsoft.com/fwlink/?LinkID=205219)\n- [RxJS Design Guidelines](http://xgrommx.github.io/rx-book/content/guidelines/index.html)\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/contract.html](http://reactivex.io/documentation/contract.html)"
- name: TimeInterval
  id: documentation/operators/timeinterval
  summary: The TimeInterval operator intercepts the items from the source Observable and emits in their place objects that indicate the amount of time that elapsed between pairs of emissions
  description: "# TimeInterval\n\nconvert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions\n\nThe TimeInterval operator intercepts the items from the source Observable and emits in their place objects that indicate the amount of time that elapsed between pairs of emissions.\n\n#### See Also\n\n- [Timestamp](timestamp)\n- [Introduction to Rx: Timestamp and TimeInterval](http://www.introtorx.com/Content/v1.0.10621.0/08_Transformation.html#TimeStampAndTimeInterval)\n- [101 Rx Samples: Interval — With TimeInterval()](http://rxwiki.wikidot.com/101samples#toc31)\n\n## Language-Specific Information\n\n### RxGroovy `timeInterval`\n\nThe timeInterval operator converts a source Observable into an Observable that emits indications of the amount of time lapsed between consecutive emissions of the source Observable. The first emission from this new Observable indicates the amount of time lapsed between the time when the observer subscribed to the Observable and the time when the source Observable emitted its first item. There is no corresponding emission marking the amount of time lapsed between the last emission of the source Observable and the subsequent call to `onCompleted`.\n\n`timeInterval` by default operates on the `immediate` [Scheduler](../scheduler), but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.\n\n- Javadoc: [`timeInterval()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeInterval())\n- Javadoc: [`timeInterval(Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeInterval(rx.Scheduler))\n\n### RxJava 1․x `timeInterval`\n\nThe timeInterval operator converts a source Observable into an Observable that emits indications of the amount of time lapsed between consecutive emissions of the source Observable. The first emission from this new Observable indicates the amount of time lapsed between the time when the observer subscribed to the Observable and the time when the source Observable emitted its first item. There is no corresponding emission marking the amount of time lapsed between the last emission of the source Observable and the subsequent call to `onCompleted`.\n\n`timeInterval` by default operates on the `immediate` [Scheduler](../scheduler), but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.\n\n- Javadoc: [`timeInterval()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeInterval())\n- Javadoc: [`timeInterval(Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeInterval(rx.Scheduler))\n\n### RxJS `timeInterval`\n\nThe `timeInterval` operator converts a source Observable into an Observable that emits indications of the amount of time lapsed between consecutive emissions of the source Observable. The first emission from this new Observable indicates the amount of time lapsed between the time when the observer subscribed to the Observable and the time when the source Observable emitted its first item. There is no corresponding emission marking the amount of time lapsed between the last emission of the source Observable and the subsequent call to `onCompleted`.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.timer(0, 1000)\n    .timeInterval()\n    .map(function (x) { return x.value + ':' + x.interval; })\n    .take(5);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0:0\nNext: 1:1000\nNext: 2:1000\nNext: 3:1000\nNext: 4:1000\nCompleted\n```\n\n`timeInterval` by default operates on the `timeout` [Scheduler](../scheduler), but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.\n\n`timeInterval` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.time.js` (requires `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/timeinterval.html](http://reactivex.io/documentation/operators/timeinterval.html)"
- name: Timeout
  id: documentation/operators/timeout
  summary: The Timeout operator allows you to abort an Observable with an onError termination if that Observable fails to emit any items during a specified span of time
  description: "# Timeout\n\nmirror the source Observable, but issue an error notification if a particular period of time elapses without any emitted items\n\nThe Timeout operator allows you to abort an Observable with an `onError` termination if that Observable fails to emit any items during a specified span of time.\n\n#### See Also\n\n- [Debounce](debounce)\n- [Introduction to Rx: Timeout](http://www.introtorx.com/Content/v1.0.10621.0/13_TimeShiftedSequences.html#Timeout)\n- [101 Rx Samples: Timeout — Simple](http://rxwiki.wikidot.com/101samples#toc33)\n\n## Language-Specific Information\n\n### RxGroovy `timeout`\n\nRxGroovy implements this operator as `timeout`, but in several variants.\n\nThe first variant accepts parameters that define a duration of time (a quantity of time, and a `TimeUnit` that this quantity is denominated in). Each time the source Observable emits an item, `timeout` starts a timer, and if that timer exceeds the duration before the source Observable emits another item, `timeout` terminates its Observable with an error (`TimeoutException`).\n\nBy default this variant of `timeout` operates on the `computation` [Scheduler](../scheduler), but you can choose a different Scheduler by passing it in as an optional third parameter to `timeout`\n\n- Javadoc: [`timeout(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`timeout()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nA second variant of `timeout` differs from the first in that instead of issuing an error notification in case of a timeout condition, it instead immediately switches to a backup Observable that you specify.\n\nBy default this variant of `timeout` operates on the `computation` [Scheduler](../scheduler), but you can choose a different Scheduler by passing it in as an optional third parameter to `timeout`\n\n- Javadoc: [`timeout(long,TimeUnit,Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(long,%20java.util.concurrent.TimeUnit,%20rx.Observable))\n- Javadoc: [`timeout(long,TimeUnit,Observable,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(long,%20java.util.concurrent.TimeUnit,%20rx.Observable,%20rx.Scheduler))\n\nA third variant of `timeout` does not use a constant timeout duration, but sets its timeout duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. If any such Observable completes before the source Observable emits another item, this is considered a timeout condition, and triggers an `onError` notification (“`TimeoutException`”) from the Observable `timeout` returns.\n\nThis variant of `timeout` by default runs on the `immediate` [Scheduler](../scheduler).\n\n- Javadoc: [`timeout(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(rx.functions.Func1))\n\nThere is also a variant of `timeout` that both uses a per-item Observable to set the timeout duration and switches to a backup Observable in case of a timeout.\n\nThis variant of `timeout` by default runs on the `immediate` [Scheduler](../scheduler).\n\n- Javadoc: [`timeout(Func1,Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(rx.functions.Func1,%20rx.Observable))\n\nThe variant of `timeout` that uses a per-item Observable to set the timeout has a variant that allows you to pass in a function that returns an Observable that acts as a timeout timer for the very first item emitted by the source Observable (in the absence of this, there would be no timeout for the first item).\n\nThis variant of `timeout` by default runs on the `immediate` [Scheduler](../scheduler).\n\n- Javadoc: [`timeout(Func0,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(rx.functions.Func0,%20rx.functions.Func1))\n\nAnd that variant also has a cousin that will switch to a specified backup Observable rather than emitting an error upon hitting a timeout condition.\n\nThis variant of `timeout` by default runs on the `immediate` [Scheduler](../scheduler).\n\n- Javadoc: [`timeout(Func0,Func1,Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(rx.functions.Func0,%20rx.functions.Func1,%20rx.Observable))\n\n### RxJava 1․x `timeout`\n\nRxJava implements this operator as `timeout`, but in several variants.\n\nThe first variant accepts parameters that define a duration of time (a quantity of time, and a `TimeUnit` that this quantity is denominated in). Each time the source Observable emits an item, `timeout` starts a timer, and if that timer exceeds the duration before the source Observable emits another item, `timeout` terminates its Observable with an error (`TimeoutException`).\n\nBy default this variant of `timeout` operates on the `computation` [Scheduler](../scheduler), but you can choose a different Scheduler by passing it in as an optional third parameter to `timeout`\n\n- Javadoc: [`timeout(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`timeout()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nA second variant of `timeout` differs from the first in that instead of issuing an error notification in case of a timeout condition, it instead immediately switches to a backup Observable that you specify.\n\nBy default this variant of `timeout` operates on the `computation` [Scheduler](../scheduler), but you can choose a different Scheduler by passing it in as an optional third parameter to `timeout`.\n\n- Javadoc: [`timeout(long,TimeUnit,Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(long,%20java.util.concurrent.TimeUnit,%20rx.Observable))\n- Javadoc: [`timeout(long,TimeUnit,Observable,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(long,%20java.util.concurrent.TimeUnit,%20rx.Observable,%20rx.Scheduler))\n\nA third variant of `timeout` does not use a constant timeout duration, but sets its timeout duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. If any such Observable completes before the source Observable emits another item, this is considered a timeout condition, and triggers an `onError` notification (“`TimeoutException`”) from the Observable `timeout` returns.\n\nThis variant of `timeout` by default runs on the `immediate` [Scheduler](../scheduler).\n\n- Javadoc: [`timeout(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(rx.functions.Func1))\n\nThere is also a variant of `timeout` that both uses a per-item Observable to set the timeout duration and switches to a backup Observable in case of a timeout.\n\nThis variant of `timeout` by default runs on the `immediate` [Scheduler](../scheduler).\n\n- Javadoc: [`timeout(Func1,Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(rx.functions.Func1,%20rx.Observable))\n\nThe variant of `timeout` that uses a per-item Observable to set the timeout has a variant that allows you to pass in a function that returns an Observable that acts as a timeout timer for the very first item emitted by the source Observable (in the absence of this, there would be no timeout for the first item).\n\nThis variant of `timeout` by default runs on the `immediate` [Scheduler](../scheduler).\n\n- Javadoc: [`timeout(Func0,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(rx.functions.Func0,%20rx.functions.Func1))\n\nAnd that variant also has a cousin that will switch to a specified backup Observable rather than emitting an error upon hitting a timeout condition.\n\nThis variant of `timeout` by default runs on the `immediate` [Scheduler](../scheduler).\n\n- Javadoc: [`timeout(Func0,Func1,Observable)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(rx.functions.Func0,%20rx.functions.Func1,%20rx.Observable))\n\n### RxJS `timeout timeoutWithSelector`\n\nRxJS implements this operator as `timeout` and `timeoutWithSelector`:\n\nOne variant of `timeout` accepts a duration of time (in milliseconds). Each time the source Observable emits an item, `timeout` starts a timer, and if that timer exceeds the duration before the source Observable emits another item, `timeout` terminates its Observable with an error (“`Timeout`” or a string of your choice that you pass as an optional second parameter).\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable\n    .return(42)\n    .delay(5000)\n    .timeout(200, 'Timeout has occurred.');\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nError: Timeout has occurred.\n```\n\nAnother variant allows you to instruct `timeout` to switch to a backup Observable that you specify, rather than terminating with an error, if the timeout condition is triggered. To use this variant, pass the backup Observable (or `Promise`) as the second parameter to `timeout`.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable\n  .return(42)\n  .delay(5000)\n  .timeout(200, Promise.resolve(42));\n\nvar subscription = source.subscribe(\n  function (x) { console.log('Next: %s', x); },\n  function (err) { console.log('Error: %s', err); },\n  function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 42\nCompleted\n```\n\n`timeoutWithSelector` does not use a constant timeout duration, but sets its timeout duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. If any such Observable completes before the source Observable emits another item, this is considered a timeout condition, and triggers an `onError` notification (“`Error: Timeout`”) from the Observable `timeoutWithSelector` returns.\n\n#### Sample Code\n\n``` javascript\nvar array = [\n    200,\n    300,\n    350,\n    400\n];\n\nvar source = Rx.Observable\n    .for(array, function (x) {\n        return Rx.Observable.timer(x);\n    })\n    .map(function (x, i) { return i; })\n    .timeoutWithSelector(function (x) {\n        return Rx.Observable.timer(400);\n    });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nError: Error: Timeout\n```\n\nThere is also a variant of `timeoutWithSelector` that both uses a per-item Observable to set the timeout duration and switches to a backup Observable in case of a timeout.\n\n#### Sample Code\n\n``` javascript\nvar array = [\n    200,\n    300,\n    350,\n    400\n];\n\nvar source = Rx.Observable\n    .for(array, function (x) {\n        return Rx.Observable.timer(x);\n    })\n    .map(function (x, i) { return i; })\n    .timeoutWithSelector(function (x) {\n        return Rx.Observable.timer(400);\n    }, Rx.Observable.return(42));\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nNext: 42\nCompleted\n```\n\nThe variant of `timeoutWithSelector` that uses a per-item Observable to set the timeout has a variant that allows you to pass in an Observable that acts as a timeout timer for the very first item emitted by the source Observable (in the absence of this, there would be no timeout for the first item; that is to say, the default Observable that governs this first timeout period is `Rx.Observable.never()`).\n\n#### Sample Code\n\n``` javascript\nvar array = [\n    200,\n    300,\n    350,\n    400\n];\n\nvar source = Rx.Observable\n    .for(array, function (x) {\n        return Rx.Observable.timer(x);\n    })\n    .map(function (x, i) { return i; })\n    .timeoutWithSelector(Rx.Observable.timer(250), function (x) {\n        return Rx.Observable.timer(400);\n    });\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nError: Error: Timeout\n```\n\nAnd that variant also has a cousin that will switch to a specified backup Observable rather than emitting an error upon hitting a timeout condition.\n\n#### Sample Code\n\n``` javascript\nvar array = [\n    200,\n    300,\n    350,\n    400\n];\n\nvar source = Rx.Observable\n    .for(array, function (x) {\n        return Rx.Observable.timer(x);\n    })\n    .map(function (x, i) { return i; })\n    .timeoutWithSelector(Rx.Observable.timer(250), function (x) {\n        return Rx.Observable.timer(400);\n    }, Rx.Observable.return(42));\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0\nNext: 1\nNext: 2\nNext: 42\nCompleted\n```\n\n`timeout` and `timeoutWithSelector` are found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.time.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThey require one of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `timeout`\n\nRxPHP implements this operator as `timeout`.\n\nErrors the observable sequence if no item is emitted in the specified time. When a timeout occurs, this operator errors with an instance of Rx\\Exception\\TimeoutException\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/timeout/timeout.php\n\nRx\\Observable::interval(1000)\n    ->timeout(500)\n    ->subscribe($createStdoutObserver('One second - '));\n\nRx\\Observable::interval(100)\n    ->take(3)\n    ->timeout(500)\n    ->subscribe($createStdoutObserver('100 ms     - '));\n```\n\n``` javascript\n100 ms     - Next value: 0\n100 ms     - Next value: 1\n100 ms     - Next value: 2\n100 ms     - Complete!\nOne second - Exception: timeout\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/timeout.html](http://reactivex.io/documentation/operators/timeout.html)"
- name: Timer
  id: documentation/operators/timer
  summary: The Timer operator creates an Observable that emits one particular item after a span of time that you specify
  description: "# Timer\n\ncreate an Observable that emits a particular item after a given delay\n\nThe Timer operator creates an Observable that emits one particular item after a span of time that you specify.\n\n#### See Also\n\n- [From](from)\n- [Interval](interval)\n- [Just](just)\n- [Introduction to Rx: Timer](http://www.introtorx.com/Content/v1.0.10621.0/04_CreatingObservableSequences.html#ObservableTimer)\n- [101 Rx Samples: Timer — Simple](http://rxwiki.wikidot.com/101samples#toc34)\n\n## Language-Specific Information\n\n### RxGroovy `timer`\n\nRxGroovy implements this operator as `timer`.\n\n`timer` returns an Observable that emits a single number zero after a delay period you specify.\n\n`timer` by default operates on the `computation` [Scheduler](../scheduler), or you can override this by passing in a Scheduler as a final parameter.\n\n- Javadoc: [`timer(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timer(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`timer(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n### RxJava 1․x `timer`\n\nRxJava implements this operator as `timer`.\n\n`timer` returns an Observable that emits a single number zero after a delay period you specify.\n\n`timer` by default operates on the `computation` [Scheduler](../scheduler), or you can override this by passing in a Scheduler as a final parameter.\n\n- Javadoc: [`timer(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timer(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`timer(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n### RxJS `timer`\n\nIn RxJS there are two versions of the `timer` operator.\n\nThe first version of `timer` returns an Observable that emits a single item after a delay period you specify. You can specify the delay either as a `Date` object (which means, delay until that absolute moment) or as an integer (which means, delay that many milliseconds).\n\nThere is also a version of `timer` that returns an Observable that emits a single item after a specified delay, and then emits items periodically thereafter on a specified periodicity. In this way it behaves a bit more like the [Interval](interval) operator.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.timer(200, 100)\n    .timeInterval()\n    .pluck('interval')\n    .take(3);\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x);\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nNext: 200\nNext: 100\nNext: 100\nCompleted\n```\n\n`timer` by default operates on the `timeout` [Scheduler](../scheduler), or you can override this by passing in a Scheduler as a final parameter.\n\n`timer` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.time.js` (requires either `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `timer`\n\nRxPHP implements this operator as `timer`.\n\nReturns an observable sequence that produces a value after dueTime has elapsed.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/timer/timer.php\n\n$source = \\Rx\\Observable::timer(200);\n\n$source->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 0\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/timer.html](http://reactivex.io/documentation/operators/timer.html)"
- name: Timestamp
  id: documentation/operators/timestamp
  summary: The Timestamp operator attaches a timestamp to each item emitted by the source Observable before reemitting that item in its own sequence
  description: "# Timestamp\n\nattach a timestamp to each item emitted by an Observable indicating when it was emitted\n\nThe Timestamp operator attaches a timestamp to each item emitted by the source Observable before reemitting that item in its own sequence. The timestamp indicates at what time the item was emitted.\n\n#### See Also\n\n- [Timestamp](timestamp)\n- [Introduction to Rx: Timestamp and TimeInterval](http://www.introtorx.com/Content/v1.0.10621.0/08_Transformation.html#TimeStampAndTimeInterval)\n- [101 Rx Samples: Timestamp](http://rxwiki.wikidot.com/101samples#toc35)\n\n## Language-Specific Information\n\n### RxGroovy `timestamp`\n\nThe `timestamp` method converts an Observable that emits items of type *T* into one that emits objects of type `Timestamped<`*`T`*`>`, where each such object is stamped with the time at which it was originally emitted.\n\n``` groovy\ndef myObservable = Observable.range(1, 1000000).filter({ 0 == (it % 200000) });\n\nmyObservable.timestamp().subscribe(\n  { println(it.toString()); },               // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\nTimestamped(timestampMillis = 1369252582698, value = 200000)\nTimestamped(timestampMillis = 1369252582740, value = 400000)\nTimestamped(timestampMillis = 1369252582782, value = 600000)\nTimestamped(timestampMillis = 1369252582823, value = 800000)\nTimestamped(timestampMillis = 1369252582864, value = 1000000)\nSequence complete\n```\n\n`timestamp` by default operates on the `immediate` [Scheduler](../scheduler) but also has a variant that allows you to choose the Scheduler by passing it in as a parameter.\n\n- Javadoc: [`timestamp()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timestamp())\n- Javadoc: [`timestamp(Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timestamp(rx.Scheduler))\n\n### RxJava 1․x `timestamp`\n\nThe `timestamp` method converts an Observable that emits items of type *T* into one that emits objects of type `Timestamped<`*`T`*`>`, where each such object is stamped with the time at which it was originally emitted.\n\n`timestamp` by default operates on the `immediate` [Scheduler](../scheduler) but also has a variant that allows you to choose the Scheduler by passing it in as a parameter.\n\n- Javadoc: [`timestamp()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timestamp())\n- Javadoc: [`timestamp(Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#timestamp(rx.Scheduler))\n\n### RxJS `timestamp`\n\nThe `timestamp` method attaches a timestamp to each item emitted by the source Observable before emitting that item as part of its own sequence. The timestamp indicates when the item was emitted by the source Observable.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.timer(0, 1000)\n    .timestamp()\n    .map(function (x) { return x.value + ':' + x.timestamp; })\n    .take(5);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 0:1378690776351\nNext: 1:1378690777313\nNext: 2:1378690778316\nNext: 3:1378690779317\nNext: 4:1378690780319\nCompleted\n```\n\n`timestamp` by default operates on the `timeout` [Scheduler](../scheduler), but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.\n\n`timestamp` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.time.js` (requires `rx.js` or `rx.compat.js`)\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\n### RxPHP `timestamp`\n\nRxPHP implements this operator as `timestamp`.\n\nRecords the timestamp for each value in an observable sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/timestamp/timestamp.php\n\n$source = \\Rx\\Observable::interval(1000)\n    ->timestamp()\n    ->map(function (\\Rx\\Timestamped $x) {\n        return $x->getValue() . ':' . $x->getTimestampMillis();\n    })\n    ->take(5);\n\n$source->subscribe($createStdoutObserver());\n\n// Next value: 0:1460781738354\n// Next value: 1:1460781739358\n// Next value: 2:1460781740359\n// Next value: 3:1460781741362\n// Next value: 4:1460781742367\n// Complete!\n```\n\n``` javascript\nNext value: 0:1489535638531\nNext value: 1:1489535639534\nNext value: 2:1489535640532\nNext value: 3:1489535641528\nNext value: 4:1489535642528\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/timestamp.html](http://reactivex.io/documentation/operators/timestamp.html)"
- name: To
  id: documentation/operators/to
  summary: The various language-specific implementations of ReactiveX have a variety of operators that you can use to convert an Observable, or a sequence of items emitted by an Observable, into another variety of object or data structure
  description: "# To\n\nconvert an Observable into another object or data structure\n\nThe various language-specific implementations of ReactiveX have a variety of operators that you can use to convert an Observable, or a sequence of items emitted by an Observable, into another variety of object or data structure. Some of these block until the Observable terminates and then produce an equivalent object or data structure; others return an Observable that emits such an object or data structure.\n\nIn some implementations of ReactiveX, there is also an operator that converts an Observable into a “Blocking” Observable. A Blocking Observable extends the ordinary Observable by providing a set of methods, operating on the items emitted by the Observable, that block. Some of the To operators are in this Blocking Observable set of extended operations.\n\n#### See Also\n\n- [Introduction to Rx: Leaving the monad](http://www.introtorx.com/Content/v1.0.10621.0/10_LeavingTheMonad.html#LeavingTheMonad)\n\n## Language-Specific Information\n\n### RxGroovy `BlockingObservable.from BlockingObservable.getIterator nest toBlocking BlockingObservable.toFuture BlockingObservable.toIterable toList toMap toMultiMap toSortedList`\n\nThe `getIterator` operator applies to the `BlockingObservable` subclass, so in order to use it, you must first convert your source Observable into a `BlockingObservable` by means of either the `BlockingObservable.from` method or the `Observable.toBlocking` operator.\n\nThis operator converts an Observable into an `Iterator` with which you can iterate over the set of items emitted by the source Observable.\n\n- Javadoc: [`BlockingObservable.getIterator()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#getIterator())\n\nThe `toFuture` operator applies to the `BlockingObservable` subclass, so in order to use it, you must first convert your source Observable into a `BlockingObservable` by means of either the `BlockingObservable.from` method or the `Observable.toBlocking` operator.\n\nThis operator converts an Observable into an `Future` that will return the single item emitted by the source Observable. If the source Observable emits more than one item, the `Future` will receive an `IllegalArgumentException`; if it completes after emitting no items, the `Future` will receive a `NoSuchElementException`.\n\nIf you want to convert an Observable that may emit multiple items into a `Future`, try something like this: `myObservable.toList().toBlocking().toFuture()`.\n\n- Javadoc: [`BlockingObservable.toFuture()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#toFuture())\n\nThe `toIterable` operator applies to the `BlockingObservable` subclass, so in order to use it, you must first convert your source Observable into a `BlockingObservable` by means of either the `BlockingObservable.from` method or the `Observable.toBlocking` operator.\n\nThis operator converts an Observable into an `Iterable` with which you can iterate over the set of items emitted by the source Observable.\n\n- Javadoc: [`BlockingObservable.toIterable()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#toIterable())\n\nNormally, an Observable that emits multiple items will do so by invoking its observer’s `onNext` method for each such item. You can change this behavior, instructing the Observable to compose a list of these multiple items and then to invoke the observer’s `onNext` method only once, passing it the entire list, by applying the `toList` operator to the Observable.\n\nFor example, the following rather pointless code takes a list of integers, converts it into an Observable, then converts that Observable into one that emits the original list as a single item:\n\n#### Sample Code\n\n``` groovy\nnumbers = Observable.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\nnumbers.toList().subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\nSequence complete\n```\n\nIf the source Observable invokes `onCompleted` before emitting any items, the Observable returned by `toList` will emit an empty list before invoking `onCompleted`. If the source Observable invokes `onError`, the Observable returned by `toList` will immediately invoke the `onError` methods of its observers.\n\n`toList` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`toList()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toList())\n\nThe `toMap` operator collects the items emitted by the source Observable into a map (by default, a `HashMap`, but you can optionally supply a factory function that generates another `Map` variety) and then emits that map. You supply a function that generates the key for each emitted item. You may also optionally supply a function that converts an emitted item into the value to be stored in the map (by default, the item itself is this value).\n\n`toMap` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`toMap(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1))\n- Javadoc: [`toMap(Func1,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1,%20rx.functions.Func1))\n- Javadoc: [`toMap(Func1,Func1,Func0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0))\n\nThe `toMultiMap` operator is similar to `toMap` except that the map it generates is also an `ArrayList` (by default; or you can pass an optional factory method as a fourth parameter by which you generate the variety of collection you prefer).\n\n`toMultiMap` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`toMultiMap(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1))\n- Javadoc: [`toMultiMap(Func1,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1))\n- Javadoc: [`toMultiMap(Func1,Func1,Func0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0))\n- Javadoc: [`toMultiMap(Func1,Func1,Func0,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0,%20rx.functions.Func1))\n\nThe `toSortedList` operator behaves much like `toList` except that it sorts the resulting list. By default it sorts the list naturally in ascending order by means of the `Comparable` interface. If any of the items emitted by the Observable does not support `Comparable` with respect to the type of every other item emitted by the Observable, `toSortedList` will throw an exception. However, you can change this default behavior by also passing in to `toSortedList` a function that takes as its parameters two items and returns a number; `toSortedList` will then use that function instead of `Comparable` to sort the items.\n\nFor example, the following code takes a list of unsorted integers, converts it into an Observable, then converts that Observable into one that emits the original list in sorted form as a single item:\n\n#### Sample Code\n\n``` groovy\nnumbers = Observable.from([8, 6, 4, 2, 1, 3, 5, 7, 9]);\n\nnumbers.toSortedList().subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\nSequence complete\n```\n\nHere is an example that provides its own sorting function: in this case, one that sorts numbers according to how close they are to the number 5.\n\n``` groovy\nnumbers = Observable.from([8, 6, 4, 2, 1, 3, 5, 7, 9]);\n\nnumbers.toSortedList({ n, m -> Math.abs(5-n) - Math.abs(5-m) }).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n[5, 6, 4, 3, 7, 8, 2, 1, 9]\nSequence complete\n```\n\n`toSortedList` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`toSortedList()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toSortedList())\n- Javadoc: [`toSortedList(Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toSortedList(rx.functions.Func2))\n\nRxGroovy also has a `nest` operator that has one particular purpose: it converts a source Observable into an Observable that emits that source Observable as its sole item.\n\n### RxJava 1․x `BlockingObservable.from BlockingObservable.getIterator nest toBlocking BlockingObservable.toFuture BlockingObservable.toIterable toList toMap toMultiMap toSortedList`\n\nThe `getIterator` operator applies to the `BlockingObservable` subclass, so in order to use it, you must first convert your source Observable into a `BlockingObservable` by means of either the `BlockingObservable.from` method or the `Observable.toBlocking` operator.\n\nThis operator converts an Observable into an `Iterator` with which you can iterate over the set of items emitted by the source Observable.\n\n- Javadoc: [`BlockingObservable.getIterator()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#getIterator())\n\nThe `toFuture` operator applies to the `BlockingObservable` subclass, so in order to use it, you must first convert your source Observable into a `BlockingObservable` by means of either the `BlockingObservable.from` method or the `Observable.toBlocking` operator.\n\nThis operator converts an Observable into an `Future` that will return the single item emitted by the source Observable. If the source Observable emits more than one item, the `Future` will receive an `IllegalArgumentException`; if it completes after emitting no items, the `Future` will receive a `NoSuchElementException`.\n\nIf you want to convert an Observable that may emit multiple items into a `Future`, try something like this: `myObservable.toList().toBlocking().toFuture()`.\n\n- Javadoc: [`BlockingObservable.toFuture()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#toFuture())\n\nThe `toIterable` operator applies to the `BlockingObservable` subclass, so in order to use it, you must first convert your source Observable into a `BlockingObservable` by means of either the `BlockingObservable.from` method or the `Observable.toBlocking` operator.\n\nThis operator converts an Observable into an `Iterable` with which you can iterate over the set of items emitted by the source Observable.\n\n- Javadoc: [`BlockingObservable.toIterable()`](http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#toIterable())\n\nNormally, an Observable that emits multiple items will do so by invoking its observer’s `onNext` method for each such item. You can change this behavior, instructing the Observable to compose a list of these multiple items and then to invoke the observer’s `onNext` method only once, passing it the entire list, by applying the `toList` operator to the Observable.\n\nIf the source Observable invokes `onCompleted` before emitting any items, the Observable returned by `toList` will emit an empty list before invoking `onCompleted`. If the source Observable invokes `onError`, the Observable returned by `toList` will immediately invoke the `onError` methods of its observers.\n\n`toList` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`toList()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toList())\n\nThe `toMap` operator collects the items emitted by the source Observable into a map (by default, a `HashMap`, but you can optionally supply a factory function that generates another `Map` variety) and then emits that map. You supply a function that generates the key for each emitted item. You may also optionally supply a function that converts an emitted item into the value to be stored in the map (by default, the item itself is this value).\n\n`toMap` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`toMap(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1))\n- Javadoc: [`toMap(Func1,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1,%20rx.functions.Func1))\n- Javadoc: [`toMap(Func1,Func1,Func0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0))\n\nThe `toMultiMap` operator is similar to `toMap` except that the map it generates is also an `ArrayList` (by default; or you can pass an optional factory method as a fourth parameter by which you generate the variety of collection you prefer).\n\n`toMultiMap` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`toMultiMap(Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1))\n- Javadoc: [`toMultiMap(Func1,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1))\n- Javadoc: [`toMultiMap(Func1,Func1,Func0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0))\n- Javadoc: [`toMultiMap(Func1,Func1,Func0,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0,%20rx.functions.Func1))\n\nThe `toSortedList` operator behaves much like `toList` except that it sorts the resulting list. By default it sorts the list naturally in ascending order by means of the `Comparable` interface. If any of the items emitted by the Observable does not support `Comparable` with respect to the type of every other item emitted by the Observable, `toSortedList` will throw an exception. However, you can change this default behavior by also passing in to `toSortedList` a function that takes as its parameters two items and returns a number; `toSortedList` will then use that function instead of `Comparable` to sort the items.\n\n`toSortedList` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`toSortedList()`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toSortedList())\n- Javadoc: [`toSortedList(Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#toSortedList(rx.functions.Func2))\n\nRxJava also has a `nest` operator that has one particular purpose: it converts a source Observable into an Observable that emits that source Observable as its sole item.\n\n### RxJS `toArray toMap toSet`\n\nNormally, an Observable that emits multiple items will do so by invoking its observer’s `onNext` method for each such item. You can change this behavior, instructing the Observable to compose an array of these multiple items and then to invoke the observer’s `onNext` method only once, passing it the entire array, by applying the `toArray` operator to the Observable.\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.timer(0, 1000)\n    .take(5)\n    .toArray();\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: [0,1,2,3,4]\nCompleted\n```\n\n`toArray` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.compat.js`\n- `rx.lite.js`\n- `rx.lite.compat.js`\n\nThe `toMap` operator collects the items emitted by the source Observable into a `Map` and then emits that map. You supply a function that generates the key for each emitted item. You may also optionally supply a function that converts an emitted item into the value to be stored in the map (by default, the item itself is this value).\n\n#### Sample Code\n\n``` javascript\nvar source = Rx.Observable.timer(0, 1000)\n    .take(5)\n    .toMap(function (x) { return x * 2; }, function (x) { return x * 4; });\n\nvar subscription = source.subscribe(\n    function (x) {\n        var arr = [];\n        x.forEach(function (value, key) { arr.push(value, key); })\n        console.log('Next: ' + arr);\n    },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: [0,0,2,4,4,8,6,12,8,16]\nCompleted\n```\n\n`toMap` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\nNormally, an Observable that emits multiple items will do so by invoking its observer’s `onNext` method for each such item. You can change this behavior, instructing the Observable to compose a `Set` of these multiple items and then to invoke the observer’s `onNext` method only once, passing it the entire `Set`, by applying the `toSet` operator to the Observable.\n\nNote that this only works in an ES6 environment or polyfilled.\n\n``` javascript\nvar source = Rx.Observable.timer(0, 1000)\n    .take(5)\n    .toSet();\n\nvar subscription = source.subscribe(\n    function (x) {\n        var arr = [];\n        x.forEach(function (i) { arr.push(i); })\n        console.log('Next: ' + arr);\n    },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: [0,1,2,3,4]\nCompleted\n```\n\n`toSet` is found in each of the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.aggregates.js`\n\n### RxPHP `toArray`\n\nRxPHP implements this operator as `toArray`.\n\nCreates an observable sequence containing a single element which is an array containing all the elements of the source sequence.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/toArray/toArray.php\n\n$source = \\Rx\\Observable::fromArray([1, 2, 3, 4]);\n\n$observer = $createStdoutObserver();\n\n$subscription = $source->toArray()\n    ->subscribe(new CallbackObserver(\n        function ($array) use ($observer) {\n            $observer->onNext(json_encode($array));\n        },\n        [$observer, \"onError\"],\n        [$observer, \"onCompleted\"]\n    ));\n```\n\n``` javascript\nNext value: [1,2,3,4]\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/to.html](http://reactivex.io/documentation/operators/to.html)"
- name: Using
  id: documentation/operators/using
  summary: The Using operator is a way you can instruct an Observable to create a resource that exists only during the lifespan of the Observable and is disposed of when the Observable terminates
  description: "# Using\n\ncreate a disposable resource that has the same lifespan as the Observable\n\nThe Using operator is a way you can instruct an Observable to create a resource that exists only during the lifespan of the Observable and is disposed of when the Observable terminates.\n\n#### See Also\n\n- [Introduction to Rx: Using](http://www.introtorx.com/Content/v1.0.10621.0/11_AdvancedErrorHandling.html#Using)\n\n## Language-Specific Information\n\n### RxGroovy `using`\n\nYou pass the `using` operator three parameters:\n\n1.  a factory function that creates a disposable resource\n2.  a factory function that creates an Observable\n3.  a function that disposes of the resource\n\nWhen an observer subscribes to the Observable returned from `using`, `using` will use the Observable factory function to create the Observable the observer will observe, while at the same time using the resource factory function to create whichever resource you have designed it to make. When the observer unsubscribes from the Observable, or when the Observable terminates (normally or with an error), `using` will call the third function to dispose of the resource it created.\n\n`using` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`using(Func0,Func1,Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#using(rx.functions.Func0,%20rx.functions.Func1,%20rx.functions.Action1))\n\n### RxJava 1․x `using`\n\nYou pass the `using` operator three parameters:\n\n1.  a factory function that creates a disposable resource\n2.  a factory function that creates an Observable\n3.  a function that disposes of the resource\n\nWhen an observer subscribes to the Observable returned from `using`, `using` will use the Observable factory function to create the Observable the observer will observe, while at the same time using the resource factory function to create whichever resource you have designed it to make. When the observer unsubscribes from the Observable, or when the Observable terminates (normally or with an error), `using` will call the third function to dispose of the resource it created.\n\n`using` does not by default operate on any particular [Scheduler](../scheduler).\n\n- Javadoc: [`using(Func0,Func1,Action1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#using(rx.functions.Func0,%20rx.functions.Func1,%20rx.functions.Action1))\n\n### RxJS `using`\n\nYou pass the `using` operator two parameters:\n\n1.  a factory function that creates a disposable resource\n2.  a factory function that creates an Observable\n\nWhen an observer subscribes to the Observable returned from `using`, `using` will use the Observable factory function to create the Observable the observer will observe, while at the same time using the resource factory function to create whichever resource you have designed it to make. To dispose of the resource, call the `dispose` method of the subscription that was returned from the `subscribe` call you used to subscribe an observer to the Observable that you modified with `using`.\n\n#### Sample Code\n\n``` javascript\n/* Using an AsyncSubject as a resource which supports the .dispose method */\nfunction DisposableResource(value) {\n  this.value = value;\n  this.disposed = false;\n}\n\nDisposableResource.prototype.getValue = function () {\n  if (this.disposed) {\n    throw new Error('Object is disposed');\n  }\n  return this.value;\n};\n\nDisposableResource.prototype.dispose = function () {\n  if (!this.disposed) {\n    this.disposed = true;\n    this.value = null;\n  }\n  console.log('Disposed');\n};\n\nvar source = Rx.Observable.using(\n  function () { return new DisposableResource(42); },\n  function (resource) {\n    var subject = new Rx.AsyncSubject();\n    subject.onNext(resource.getValue());\n    subject.onCompleted();\n    return subject;\n  }\n);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 42\nCompleted\n```\n\n``` javascript\nsubscription.dispose();\n```\n\n``` javascript\nDisposed\n```\n\n`using` is found in each of the following distributions:\n\n- `rx.js`\n- `rx.compat.js`\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/using.html](http://reactivex.io/documentation/operators/using.html)"
- name: Window
  id: documentation/operators/window
  summary: Window is similar to Buffer, but rather than emitting packets of items from the source Observable, it emits Observables, each one of which emits a subset of items from the source Observable and then terminates with an onCompleted notification
  description: "# Window\n\nperiodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time\n\nWindow is similar to [Buffer](buffer), but rather than emitting packets of items from the source Observable, it emits Observables, each one of which emits a subset of items from the source Observable and then terminates with an `onCompleted` notification.\n\nLike Buffer, Window has many varieties, each with its own way of subdividing the original Observable into the resulting Observable emissions, each one of which contains a “window” onto the original emitted items. In the terminology of the Window operator, when a window “opens,” this means that a new Observable is emitted and that Observable will begin emitting items emitted by the source Observable. When a window “closes,” this means that the emitted Observable stops emitting items from the source Observable and terminates with an `onCompleted` notification to its observers.\n\n#### See Also\n\n- [Buffer](buffer)\n- [Introduction to Rx: Window](http://www.introtorx.com/Content/v1.0.10621.0/17_SequencesOfCoincidence.html#Window)\n- [101 Rx Samples: Window](http://rxwiki.wikidot.com/101samples#toc38)\n\n## Language-Specific Information\n\n### RxClojure `partition-all`\n\nRxClojure implements this operator as `partition-all`:\n\n`partition-all` opens its first window immediately. It opens a new window beginning with every `step` item from the source Observable (so, for example, if `step` is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted `n` items or if it receives an `onCompleted` or `onError` notification from the source Observable. If `step = n` (which is the default if you omit the `step` parameter) then the window size is the same as the step size and there will be a one-to-one correspondence between the items emitted by the source Observable and the items emitted by the collection of window Observables. If `step < n` the windows will overlap by `n − step` items; if `step > n` the windows will drop `step − n` items from the source Observable between every window.\n\n### RxCpp `window window_with_time window_with_time_or_count`\n\nRxCpp implements this operator as two variants of `window`, two variants of `window_with_time`, and as `window_with_time_or_count`:\n\n#### `window(count)`\n\nThis variant of `window` opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n#### `window(count, skip)`\n\nThis variant of `window` opens its first window immediately. It opens a new window beginning with every `skip` item from the source Observable (so, for example, if `skip` is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted `count` items or if it receives an `onCompleted` or `onError` notification from the source Observable. If `skip = count` then this behaves the same as `window(source, count)`; if `skip < count` this will emit windows that overlap by `count − skip` items; if `skip > count` this will emit windows that drop `skip − count` items from the source Observable between every window.\n\n#### `window_with_time(period`\\[`, coordination`\\]`)`\n\nThis variant of `window_with_time` opens its first window immediately. It closes the currently open window and opens another one every `period` of time (a Duration, optionally computed by a given Coordination). It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window_with_time` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n#### `window_with_time(period, skip`\\[`, coordination`\\]`)`\n\nThis variant of `window_with_time` opens its first window immediately. It closes the currently open window after `period` amount of time has passed since it was opened, and opens a new window after `skip` amount of time has passed since the previous window was opened (both times are Durations, optionally computed by a given Coordination). It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window_with_time` may emit windows that overlap or that have gaps, depending on whether `skip` is less than or greater than `period`.\n\n#### `window_with_time_or_count(period, count`\\[`, coordination`\\]`)`\n\n`window_with_time_or_count` opens its first window immediately. It closes the currently open window and opens another one every `period` of time (optionally computed by a given Coordination) or whenever the currently open window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. `window_with_time_or_count` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n### RxGroovy `window`\n\nThere are several varieties of Window in RxGroovy.\n\n#### `window(closingSelector)`\n\nThis variant of `window` opens its first window immediately. It closes the currently open window and immediately opens a new one each time it observes an object emitted by the Observable that is returned from `closingSelector`. In this way, this variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n- Javadoc: [`window(Func0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(rx.functions.Func0))\n\n#### `window(windowOpenings, closingSelector)`\n\nThis variant of `window` opens a window whenever it observes the `windowOpenings` Observable emit an `Opening` object and at the same time calls `closingSelector` to generate a closing Observable associated with that window. When that closing Observable emits an object, `window` closes that window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent Observables, this variant of `window` may create windows that overlap (duplicating items from the source Observable) or that leave gaps (discarding items from the source Observable).\n\n- Javadoc: [`window(Observable,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(rx.Observable,%20rx.functions.Func1))\n\n#### `window(count)`\n\nThis variant of `window` opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n- Javadoc: [`window(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(int))\n\n#### `window(count, skip)`\n\nThis variant of `window` opens its first window immediately. It opens a new window beginning with every `skip` item from the source Observable (so, for example, if `skip` is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted `count` items or if it receives an `onCompleted` or `onError` notification from the source Observable. If `skip = count` then this behaves the same as `window(source, count)`; if `skip < count` this will emit windows that overlap by `count − skip` items; if `skip > count` this will emit windows that drop `skip − count` items from the source Observable between every window.\n\n- Javadoc: [`window(int,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(int,%20int))\n\n#### `window(timespan, unit`\\[`, scheduler`\\]`)`\n\nThis variant of `window` opens its first window immediately. It closes the currently open window and opens another one every `timespan` period of time (measured in `unit`, and optionally on a particular [`Scheduler`](../scheduler)). It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\nIf you do not specify a Scheduler, this variant of `window` uses the `computation` Scheduler for its timer by default.\n\n- Javadoc: [`window(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`window(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n#### `window(timespan, unit, count`\\[`, scheduler`\\]`)`\n\nThis variant of `window` opens its first window immediately. It closes the currently open window and opens another one every `timespan` period of time (measured in `unit`, and optionally on a particular [`Scheduler`](../scheduler)) or whenever the currently open window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\nIf you do not specify a Scheduler, this variant of `window` uses the `computation` Scheduler for its timer by default.\n\n- Javadoc: [`window(long,TimeUnit,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20int))\n- Javadoc: [`window(long,TimeUnit,int,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler))\n\n#### `window(timespan, timeshift, unit`\\[`, scheduler`\\]`)`\n\nThis variant of `window` opens its first window immediately, and thereafter opens a new window every `timeshift` period of time (measured in `unit`, and optionally on a particular [`Scheduler`](../scheduler)). It closes a currently open window after `timespan` period of time has passed since that window was opened. It will also close any currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. Depending on how you set `timespan` and `timeshift` the windows that result from this operation may overlap or may have gaps.\n\nIf you do not specify a Scheduler, this variant of `window` uses the `computation` Scheduler for its timer by default.\n\n- Javadoc: [`window(long,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`window(long,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nYou can use the Window operator to implement backpressure (that is, to cope with an Observable that may produce items too quickly for its observer to consume).\n\nWindow can reduce a sequence of many items to a sequence of fewer windows-of-items, making them more manageable. You could, for example, emit a window of items from a bursty Observable periodically, at a regular interval of time.\n\n#### Sample Code\n\n``` groovy\nObservable<Observable<Integer>> burstyWindowed = bursty.window(500, TimeUnit.MILLISECONDS);\n```\n\nOr you could choose to emit a new window of items for every *n* items emitted by the bursty Observable.\n\n#### Sample Code\n\n``` groovy\nObservable<Observable<Integer>> burstyWindowed = bursty.window(5);\n```\n\n### RxJava 1․x `window`\n\nThere are several varieties of Window in RxJava.\n\n#### `window(closingSelector)`\n\nThis variant of `window` opens its first window immediately. It closes the currently open window and immediately opens a new one each time it observes an object emitted by the Observable that is returned from `closingSelector`. In this way, this variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n- Javadoc: [`window(Func0)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(rx.functions.Func0))\n\n#### `window(windowOpenings, closingSelector)`\n\nThis variant of `window` opens a window whenever it observes the `windowOpenings` Observable emit an `Opening` object and at the same time calls `closingSelector` to generate a closing Observable associated with that window. When that closing Observable emits an object, `window` closes that window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent Observables, this variant of `window` may create windows that overlap (duplicating items from the source Observable) or that leave gaps (discarding items from the source Observable).\n\n- Javadoc: [`window(Observable,Func1)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(rx.Observable,%20rx.functions.Func1))\n\n#### `window(count)`\n\nThis variant of `window` opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n- Javadoc: [`window(int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(int))\n\n#### `window(count, skip)`\n\nThis variant of `window` opens its first window immediately. It opens a new window beginning with every `skip` item from the source Observable (so, for example, if `skip` is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted `count` items or if it receives an `onCompleted` or `onError` notification from the source Observable. If `skip = count` then this behaves the same as `window(source, count)`; if `skip < count` this will emit windows that overlap by `count − skip` items; if `skip > count` this will emit windows that drop `skip − count` items from the source Observable between every window.\n\n- Javadoc: [`window(int,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(int,%20int))\n\n#### `window(timespan, unit`\\[`, scheduler`\\]`)`\n\nThis variant of `window` opens its first window immediately. It closes the currently open window and opens another one every `timespan` period of time (measured in `unit`, and optionally on a particular [`Scheduler`](../scheduler)). It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\nIf you do not specify a Scheduler, this variant of `window` uses the `computation` Scheduler for its timer by default.\n\n- Javadoc: [`window(long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`window(long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\n#### `window(timespan, unit, count`\\[`, scheduler`\\]`)`\n\nThis variant of `window` opens its first window immediately. It closes the currently open window and opens another one every `timespan` period of time (measured in `unit`, and optionally on a particular [`Scheduler`](../scheduler)) or whenever the currently open window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\nIf you do not specify a Scheduler, this variant of `window` uses the `computation` Scheduler for its timer by default.\n\n- Javadoc: [`window(long,TimeUnit,int)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20int))\n- Javadoc: [`window(long,TimeUnit,int,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler))\n\n#### `window(timespan, timeshift, unit`\\[`, scheduler`\\]`)`\n\nThis variant of `window` opens its first window immediately, and thereafter opens a new window every `timeshift` period of time (measured in `unit`, and optionally on a particular [`Scheduler`](../scheduler)). It closes a currently open window after `timespan` period of time has passed since that window was opened. It will also close any currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. Depending on how you set `timespan` and `timeshift` the windows that result from this operation may overlap or may have gaps.\n\nIf you do not specify a Scheduler, this variant of `window` uses the `computation` Scheduler for its timer by default.\n\n- Javadoc: [`window(long,long,TimeUnit)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20long,%20java.util.concurrent.TimeUnit))\n- Javadoc: [`window(long,long,TimeUnit,Scheduler)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler))\n\nYou can use the Window operator to implement backpressure (that is, to cope with an Observable that may produce items too quickly for its observer to consume).\n\nWindow can reduce a sequence of many items to a sequence of fewer windows-of-items, making them more manageable. You could, for example, emit a window of items from a bursty Observable periodically, at a regular interval of time.\n\n#### Sample Code\n\n``` java\nObservable<Observable<Integer>> burstyWindowed = bursty.window(500, TimeUnit.MILLISECONDS);\n```\n\nOr you could choose to emit a new window of items for every *n* items emitted by the bursty Observable.\n\n#### Sample Code\n\n``` java\nObservable<Observable<Integer>> burstyWindowed = bursty.window(5);\n```\n\n### RxJS `window windowWithCount windowWithTime windowWithTimeOrCount`\n\n#### `window(windowClosingSelector)`\n\n#### `window(windowOpenings, windowClosingSelector)`\n\n#### `window(windowBoundaries)`\n\nThis variant of `window` takes a second Observable as a parameter. Whenever this second Observable emits an item, `window` closes the current Observable window (if any) and opens a new one.\n\n#### `windowWithCount(count)`\n\nThis variant of `windowWithCount` opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `windowWithCount` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n#### `windowWithCount(count, skip)`\n\nThis variant of `windowWithCount` opens its first window immediately. It opens a new window beginning with every `skip` item from the source Observable (so, for example, if `skip` is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted `count` items or if it receives an `onCompleted` or `onError` notification from the source Observable. If `skip = count` then this behaves the same as `windowWithCount(count)`; if `skip < count` this will emit windows that overlap by `count − skip` items; if `skip > count` this will emit windows that drop `skip − count` items from the source Observable between every window.\n\n#### `windowWithTime(timeSpan`\\[`,scheduler`\\]`)`\n\nThis variant of `windowWithTime` opens its first window immediately. It closes the currently open window and opens another one every `timespan` period of time (in milliseconds, optionally measured on a particular [Scheduler](../scheduler)). It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `windowWithTime` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\nIf you do not specify a Scheduler, this variant of `windowWithTime` uses the `timeout` Scheduler for its timer by default.\n\n#### `windowWithTime(timeSpan,timeShift`\\[`,scheduler`\\]`)`\n\nThis variant of `windowWithTime` opens its first window immediately, and thereafter opens a new window every `timeshift` milliseconds (optionally measured on a particular [Scheduler](../scheduler)). It closes a currently open window after `timespan` milliseconds have passed since that window was opened. It will also close any currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. Depending on how you set `timespan` and `timeshift` the windows that result from this operation may overlap or may have gaps.\n\nIf you do not specify a Scheduler, this variant of `windowWithTime` uses the `timeout` Scheduler for its timer by default.\n\n#### `windowWithTimeOrCount(timeSpan,count`\\[`,scheduler`\\]`)`\n\n`windowWithTimeOrCount` opens its first window immediately. It closes the currently open window and opens another one every `timespan` milliseconds (optionally measured on a particular [Scheduler](../scheduler)) or whenever the currently open window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. `windowWithTimeOrCount` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\nIf you do not specify a Scheduler, this variant of `windowWithTimeOrCount` uses the `timeout` Scheduler for its timer by default.\n\n### RxKotlin `window`\n\nThere are several varieties of Window in RxKotlin.\n\n#### `window(closingSelector)`\n\nThis variant of `window` opens its first window immediately. It closes the currently open window and immediately opens a new one each time it observes an object emitted by the Observable that is returned from `closingSelector`. In this way, this variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n#### `window(windowOpenings, closingSelector)`\n\nThis variant of `window` opens a window whenever it observes the `windowOpenings` Observable emit an `Opening` object and at the same time calls `closingSelector` to generate a closing Observable associated with that window. When that closing Observable emits an object, `window` closes that window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent Observables, this variant of `window` may create windows that overlap (duplicating items from the source Observable) or that leave gaps (discarding items from the source Observable).\n\n#### `window(count)`\n\nThis variant of `window` opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n#### `window(count, skip)`\n\nThis variant of `window` opens its first window immediately. It opens a new window beginning with every `skip` item from the source Observable (so, for example, if `skip` is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted `count` items or if it receives an `onCompleted` or `onError` notification from the source Observable. If `skip = count` then this behaves the same as `window(source, count)`; if `skip < count` this will emit windows that overlap by `count − skip` items; if `skip > count` this will emit windows that drop `skip − count` items from the source Observable between every window.\n\n#### `window(timespan, unit`\\[`, scheduler`\\]`)`\n\nThis variant of `window` opens its first window immediately. It closes the currently open window and opens another one every `timespan` period of time (measured in `unit`, and optionally on a particular [`Scheduler`](../scheduler)). It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\nIf you do not specify a Scheduler, this variant of `window` uses the `computation` Scheduler for its timer by default.\n\n#### `window(timespan, unit, count`\\[`, scheduler`\\]`)`\n\nThis variant of `window` opens its first window immediately. It closes the currently open window and opens another one every `timespan` period of time (measured in `unit`, and optionally on a particular [`Scheduler`](../scheduler)) or whenever the currently open window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\nIf you do not specify a Scheduler, this variant of `window` uses the `computation` Scheduler for its timer by default.\n\n#### `window(timespan, timeshift, unit`\\[`, scheduler`\\]`)`\n\nThis variant of `window` opens its first window immediately, and thereafter opens a new window every `timeshift` period of time (measured in `unit`, and optionally on a particular [`Scheduler`](../scheduler)). It closes a currently open window after `timespan` period of time has passed since that window was opened. It will also close any currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. Depending on how you set `timespan` and `timeshift` the windows that result from this operation may overlap or may have gaps.\n\nIf you do not specify a Scheduler, this variant of `window` uses the `computation` Scheduler for its timer by default.\n\n### RxNET `Window`\n\nThere are several variants of the Window operator in Rx.NET.\n\n#### `Window(windowClosingSelector)`\n\nThis variant of `Window` opens its first window immediately and calls the `windowClosingSelector` function to obtain a second Observable. Whenever this second Observable emits a `TWindowClosing` object, `Window` closes the currently open window, and immediately opens a new one. It repeats this process until either Observable terminates. In this way, this variant of `Window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable, until the closing selector observable terminates.\n\n#### `Window(count)`\n\nThis variant of `Window` opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `Window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n#### `Window(timeSpan`\\[`,scheduler`\\]`)`\n\nThis variant of `Window` opens its first window immediately. It closes the currently open window and opens another one every `timespan` period of time (in the form of a `TimeSpan` object, and optionally on a particular [`IScheduler`](../scheduler)). It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `Window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n#### `Window(count,skip)`\n\nThis variant of `Window` opens its first window immediately. It opens a new window beginning with every `skip` item from the source Observable (so, for example, if `skip` is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted `count` items or if it receives an `onCompleted` or `onError` notification from the source Observable. If `skip = count` then this behaves the same as `Window(source, count)`; if `skip < count` this will emit windows that overlap by `count − skip` items; if `skip > count` this will emit windows that drop `skip − count` items from the source Observable between every window.\n\n#### `Window(windowOpenings,windowClosingSelector)`\n\nThis variant of `Window` opens a window whenever it observes the `windowOpenings` Observable emit an `TWindowOpening` object and at the same time calls the `windowClosingSelector`, passing it that `TWindowOpening` object, to generate a closing Observable associated with that window. When that closing Observable emits a `TWindowClosing` object, `Window` closes the associated window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent Observables, this variant of `Window` may create windows that overlap (duplicating items from the source Observable) or that leave gaps (discarding items from the source Observable).\n\n#### `Window(timeSpan,count`\\[`,scheduler`\\]`)`\n\nThis variant of `Window` opens its first window immediately. It closes the currently open window and opens another one every `timeSpan` period of time (in the form of a `TimeSpan` object, and optionally on a particular [`IScheduler`](../scheduler)) or whenever the currently open window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n#### `Window(timeSpan,timeShift`\\[`,scheduler`\\]`)`\n\nThis variant of `Window` opens its first window immediately, and thereafter opens a new window every `timeShift` period of time (in the form of a `TimeSpan` object, and optionally on a particular [`IScheduler`](../scheduler)). It closes a currently open window after `timeSpan` period of time has passed since that window was opened. It will also close any currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. Depending on how you set `timeSpan` and `timeShift` the windows that result from this operation may overlap or may have gaps.\n\n### RxPY `window window_with_count window_with_time window_with_time_or_count`\n\nRxPY implements this operator with several variants of four different functions.\n\n#### `window(window_closing_selector)`\n\nThis variant of `window` opens its first window immediately and calls the `closing_selector` function to obtain a second Observable. When this second Observable emits an item, `window` closes the currently open window, immediately opens a new one, and again calls the `closing_selector` function to obtain a fresh Observable. It repeats this process until the source Observable terminates. In this way, this variant of `window` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n#### `window(window_openings,window_closing_selector)`\n\nThis variant of `window` opens a window whenever it observes the `window_openings` Observable emit an item, and at the same time calls `closing_selector` to generate a closing Observable associated with that window. When that closing Observable emits an object, `window` closes that window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent Observables, this variant of `window` may create windows that overlap (duplicating items from the source Observable) or that leave gaps (discarding items from the source Observable).\n\n#### `window(window_openings)`\n\nThis variant of `window` takes a second Observable as a parameter. Whenever this second Observable emits an item, `window` closes the current Observable window (if any) and opens a new one.\n\n#### `window_with_count(count)`\n\nThis variant of `window_with_count` opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window_with_count` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\n#### `window_with_count(count,skip)`\n\nThis variant of `window_with_count` opens its first window immediately. It opens a new window beginning with every `skip` item from the source Observable (so, for example, if `skip` is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted `count` items or if it receives an `onCompleted` or `onError` notification from the source Observable. If `skip = count` then this behaves the same as `window_with_count(count)`; if `skip < count` this will emit windows that overlap by `count − skip` items; if `skip > count` this will emit windows that drop `skip − count` items from the source Observable between every window.\n\n#### `window_with_time(timespan`\\[`,scheduler`\\]`)`\n\n#### `window_with_time(timespan,timeshift`\\[`,scheduler`\\]`)`\n\nThis variant of `window_with_time` opens its first window immediately. It closes the currently open window and opens another one every `timespan` milliseconds (optionally measured on a particular [`Scheduler`](../scheduler)). It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. This variant of `window_with_time` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\nIf you do not specify a Scheduler, this variant of `window_with_time` uses the `timeout` Scheduler for its timer by default.\n\n#### `window_with_time_or_count(timespan,count`\\[`,scheduler`\\]`)`\n\n`window_with_time_or_count` opens its first window immediately. It closes the currently open window and opens another one every `timespan` milliseconds (optionally measured on a particular [Scheduler](../scheduler)) or whenever the currently open window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable. `window_with_time_or_count` emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.\n\nIf you do not specify a Scheduler, this variant of `window_with_time_or_count` uses the `timeout` Scheduler for its timer by default.\n\n### Rxrb `window_with_count`\n\n#### `window_with_count(count,skip)`\n\nRx.rb implements this operator as `window_with_count`. It opens its first window immediately. It then opens a new window beginning with every `skip` item from the source Observable (so, for example, if `skip` is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted `count` items or if it receives an `onCompleted` or `onError` notification from the source Observable. If `skip = count` then there is a one-to-one correspondence between the items emitted by the source Observable and those emitted by the window Observables; if `skip < count` the windows will overlap by `count − skip` items; if `skip > count` the windows will drop `skip − count` items from the source Observable between every window.\n\n### RxScala `sliding tumbling`\n\nRxScala implements this operator as `sliding` (creates windows that may overlap or have gaps) and `tumbling` (creates windows whose collective emissions match those of the source Observable one-to-one).\n\n#### `sliding(timespan,timeshift,count`\\[`,scheduler`\\]`)`\n\nThis variant of `sliding` opens its first window immediately, and thereafter opens a new window every `timeshift` period of time (in the form of a `Duration` object, and optionally on a particular [`Scheduler`](../scheduler)). It closes a currently open window after `timespan` period of time has passed since that window was opened or once `count` items have been emitted on that window. It will also close any currently open window if it receives an `onCompleted` or `onError` notification from the source Observable.\n\n#### `sliding(timespan,timeshift`\\[`,scheduler`\\]`)`\n\nThis variant of `sliding` opens its first window immediately, and thereafter opens a new window every `timeshift` period of time (in the form of a `Duration` object, and optionally on a particular [`Scheduler`](../scheduler)). It closes a currently open window after `timespan` period of time has passed since that window was opened. It will also close any currently open window if it receives an `onCompleted` or `onError` notification from the source Observable.\n\n#### `sliding(count,skip)`\n\nThis variant of `sliding` opens its first window immediately. It opens a new window beginning with every `skip` item from the source Observable (so, for example, if `skip` is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted `count` items or if it receives an `onCompleted` or `onError` notification from the source Observable. If `skip = count` then this behaves the same as `tumbling(count)`; if `skip < count` this will emit windows that overlap by `count − skip` items; if `skip > count` this will emit windows that drop `skip − count` items from the source Observable between every window.\n\n#### `sliding(openings,closings)`\n\nThis variant of `sliding` opens a window whenever it observes the `openings` Observable emit an `Opening` object and at the same time calls `closings` to generate a closing Observable associated with that window. When that closing Observable emits an item, `sliding` closes that window.\n\n#### `tumbling(timespan,count`\\[`,scheduler`\\]`)`\n\nThis variant of `tumbling` opens its first window immediately. It closes the currently open window and opens another one every `timespan` period of time (a `Duration`, optionally measured on a particular [`Scheduler`](../scheduler)) or whenever the currently open window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable.\n\n#### `tumbling(timespan`\\[`,scheduler`\\]`)`\n\nThis variant of `tumbling` opens its first window immediately. It closes the currently open window and opens another one every `timespan` period of time (a `Duration`, optionally measured on a particular [`scheduler`](../scheduler)). It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable.\n\n#### `tumbling(count)`\n\nThis variant of `tumbling` opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted `count` items. It will also close the currently open window if it receives an `onCompleted` or `onError` notification from the source Observable.\n\n#### `tumbling(boundary)`\n\nThis variant of `tumbling` takes a second Observable as a parameter. Whenever this second Observable emits an item, `tumbling` closes the current Observable window (if any) and opens a new one.\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/window.html](http://reactivex.io/documentation/operators/window.html)"
- name: Zip
  id: documentation/operators/zip
  summary: The Zip method returns an Observable that applies a function of your choosing to the combination of items emitted, in sequence, by two (or more) other Observables, with the results of this function becoming the items emitted by the returned Observable
  description: "# Zip\n\ncombine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function\n\n[Open interactive diagram on rxmarbles.com](https://rxmarbles.com/#zip)\n\nThe `Zip` method returns an Observable that applies a function of your choosing to the combination of items emitted, in sequence, by two (or more) other Observables, with the results of this function becoming the items emitted by the returned Observable. It applies this function in strict sequence, so the first item emitted by the new Observable will be the result of the function applied to the first item emitted by Observable \\#1 and the first item emitted by Observable \\#2; the second item emitted by the new zip-Observable will be the result of the function applied to the second item emitted by Observable \\#1 and the second item emitted by Observable \\#2; and so forth. It will only emit as many items as the number of items emitted by the source Observable that emits the fewest items.\n\n#### See Also\n\n- [And/Then/When](and-then-when)\n- [CombineLatest](combinelatest)\n- [Introduction to Rx: Zip](http://www.introtorx.com/Content/v1.0.10621.0/12_CombiningSequences.html#Zip)\n- [RxMarbles: `zip`](http://rxmarbles.com/#zip)\n- [101 Rx Samples: Zip](http://rxwiki.wikidot.com/101samples#toc49)\n\n## Language-Specific Information\n\n### RxGroovy `zip zipWith`\n\nRxGroovy implements this operator as several variants of `zip` and also as `zipWith`, an instance function version of the operator.\n\nThe last argument to `zip` is a function that accepts an item from each of the Observables being zipped and emits an item to be emitted in response by the Observable returned from `zip`. You can provide the Observables to be zipped together to `zip` either as between two and nine individual parameters, or as a single parameter: either an Iterable of Observables or an Observable that emits Observables (as in the illustration above).\n\n#### Sample Code\n\n``` groovy\nodds  = Observable.from([1, 3, 5, 7, 9]);\nevens = Observable.from([2, 4, 6]);\n\nObservable.zip(odds, evens, {o, e -> [o, e]}).subscribe(\n  { println(it); },                          // onNext\n  { println(\"Error: \" + it.getMessage()); }, // onError\n  { println(\"Sequence complete\"); }          // onCompleted\n);\n```\n\n``` javascript\n[1, 2]\n[3, 4]\n[5, 6]\nSequence complete\n```\n\nNote that in this example, the resulting Observable completes normally after emitting three items, which is the number of items emitted by the shorter of the two component Observbles (`evens`, which emits three items).\n\n- Javadoc: [`zip(Iterable<Observable>,FuncN)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#zip(java.lang.Iterable,%20rx.functions.FuncN))\n- Javadoc: [`zip(Observable<Observable>,FuncN)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#zip(rx.Observable,%20rx.functions.FuncN))\n- Javadoc: [`zip(Observable,Observable,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#zip(rx.Observable,%20rx.Observable,%20rx.functions.Func2)) (there are also versions that take up to nine Observables)\n\nThe `zipWith` instance version of this operator always takes two parameters. The first parameter may be either a simple Observable, or an iterable (as in the illustration above).\n\n- Javadoc: [`zipWith(Observable,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#zipWith(rx.Observable,%20rx.functions.Func2))\n- Javadoc: [`zipWith(Iterable,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#zipWith(java.lang.Iterable,%20rx.functions.Func2))\n\n`zip` and `zipWith` do not by default operate on any particular [Scheduler](../scheduler).\n\n### RxJava 1․x `zip zipWith`\n\nRxJava implements this operator as several variants of `zip` and also as `zipWith`, an instance function version of the operator.\n\nThe last argument to `zip` is a function that accepts an item from each of the Observables being zipped and emits an item to be emitted in response by the Observable returned from `zip`. You can provide the Observables to be zipped together to `zip` either as between two and nine individual parameters, or as a single parameter: either an Iterable of Observables or an Observable that emits Observables (as in the illustration above).\n\n- Javadoc: [`zip(Iterable<Observable>,FuncN)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#zip(java.lang.Iterable,%20rx.functions.FuncN))\n- Javadoc: [`zip(Observable<Observable>,FuncN)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#zip(rx.Observable,%20rx.functions.FuncN))\n- Javadoc: [`zip(Observable,Observable,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#zip(rx.Observable,%20rx.Observable,%20rx.functions.Func2)) (there are also versions that take up to nine Observables)\n\nThe `zipWith` instance version of this operator always takes two parameters. The first parameter may be either a simple Observable, or an iterable (as in the illustration above).\n\n- Javadoc: [`zipWith(Observable,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#zipWith(rx.Observable,%20rx.functions.Func2))\n- Javadoc: [`zipWith(Iterable,Func2)`](http://reactivex.io/RxJava/javadoc/rx/Observable.html#zipWith(java.lang.Iterable,%20rx.functions.Func2))\n\n`zip` and `zipWith` do not by default operate on any particular [Scheduler](../scheduler).\n\n### RxJS `forkJoin zip zipArray`\n\nRxJS implements this operator as `zip` and `zipArray`.\n\n`zip` accepts a variable number of Observables or Promises as parameters, followed by a function that accepts one item emitted by each of those Observables or resolved by those Promises as input and produces a single item to be emitted by the resulting Observable.\n\n#### Sample Code\n\n``` javascript\n/* Using arguments */\nvar range = Rx.Observable.range(0, 5);\n\nvar source = Observable.zip(\n    range,\n    range.skip(1),\n    range.skip(2),\n    function (s1, s2, s3) {\n        return s1 + ':' + s2 + ':' + s3;\n    }\n);\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x);\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nNext: 0:1:2\nNext: 1:2:3\nNext: 2:3:4\nCompleted\n```\n\n``` javascript\n/* Using promises and Observables */\nvar range = Rx.Observable.range(0, 5);\n\nvar source = Observable.zip(\n    RSVP.Promise.resolve(0),\n    RSVP.Promise.resolve(1),\n    Rx.Observable.return(2)\n    function (s1, s2, s3) {\n        return s1 + ':' + s2 + ':' + s3;\n    }\n);\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x);\n    },\n    function (err) {\n        console.log('Error: ' + err);\n    },\n    function () {\n        console.log('Completed');\n    });\n```\n\n``` javascript\nNext: 0:1:2\nCompleted\n```\n\n`zipArray` accepts a variable number of Observables as parameters and returns an Observable that emits arrays, each one containing the *n*^(th) item from each source Observable.\n\n#### Sample Code\n\n``` javascript\nvar range = Rx.Observable.range(0, 5);\n\nvar source = Rx.Observable.zipArray(\n    range,\n    range.skip(1), \n    range.skip(2)\n);\n\nvar subscription = source.subscribe(\n    function (x) {\n        console.log('Next: ' + x);\n    },\n    function (err) {\n        console.log('Error: ' + err);   \n    },\n    function () {\n        console.log('Completed');   \n    });\n```\n\n``` javascript\nNext: [0,1,2]\nNext: [1,2,3]\nNext: [2,3,4]\nCompleted\n```\n\nRxJS also implements a similar operator, `forkJoin`. There are two varieties of this operator. The first collects the last element emitted by each of the source Observables into an array and emits this array as its own sole emitted item. You can either pass a list of Observables to `forkJoin` as individual parameters or as an array of Observables.\n\n``` javascript\nvar source = Rx.Observable.forkJoin(\n    Rx.Observable.return(42),\n    Rx.Observable.range(0, 10),\n    Rx.Observable.fromArray([1,2,3]),\n    RSVP.Promise.resolve(56)\n);\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: [42, 9, 3, 56]\nCompleted\n```\n\nA second variant of `forkJoin` exists as a prototype function, and you call it on an instance of one source Observable, passing it another source Observable as a parameter. As a second parameter, you pass it a function that combines the final item emitted by the two source Observables into the sole item to be emitted by the resulting Observable.\n\n``` javascript\nvar source1 = Rx.Observable.return(42);\nvar source2 = Rx.Observable.range(0, 3);\n\nvar source = source1.forkJoin(source2, function (s1, s2) {\n    return s1 + s2;\n});\n\nvar subscription = source.subscribe(\n    function (x) { console.log('Next: ' + x); },\n    function (err) { console.log('Error: ' + err); },\n    function () { console.log('Completed'); });\n```\n\n``` javascript\nNext: 44\nCompleted\n```\n\n`forkJoin` is found in the following distributions:\n\n- `rx.all.js`\n- `rx.all.compat.js`\n- `rx.experimental.js` (requires `rx.js`, `rx.compat.js`, `rx.lite.js`, or `rx.lite.compat.js`)\n\n### RxPHP `zip forkJoin`\n\nRxPHP implements this operator as `zip`.\n\nMerges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index. If the result selector function is omitted, a list with the elements of the observable sequences at corresponding indexes will be yielded.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/zip/zip.php\n\n//Without a result selector\n$range = \\Rx\\Observable::fromArray(range(0, 4));\n\n$source = $range\n    ->zip([\n        $range->skip(1),\n        $range->skip(2)\n    ]);\n\n$observer = $createStdoutObserver();\n\n$subscription = $source\n    ->subscribe(new CallbackObserver(\n        function ($array) use ($observer) {\n            $observer->onNext(json_encode($array));\n        },\n        [$observer, 'onError'],\n        [$observer, 'onCompleted']\n    ));\n```\n\n``` javascript\nNext value: [0,1,2]\nNext value: [1,2,3]\nNext value: [2,3,4]\nComplete!\n```\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/zip/zip-result-selector.php\n\n//With a result selector\n$range = \\Rx\\Observable::fromArray(range(0, 4));\n\n$source = $range\n    ->zip([\n        $range->skip(1),\n        $range->skip(2)\n    ], function ($s1, $s2, $s3) {\n        return $s1 . ':' . $s2 . ':' . $s3;\n    });\n\n$observer = $createStdoutObserver();\n\n$subscription = $source->subscribe($createStdoutObserver());\n```\n\n``` javascript\nNext value: 0:1:2\nNext value: 1:2:3\nNext value: 2:3:4\nComplete!\n```\n\nRxPHP also has an operator `forkJoin`.\n\nRuns all observable sequences in parallel and collect their last elements.\n\n#### Sample Code\n\n``` php\n//from https://github.com/ReactiveX/RxPHP/blob/master/demo/forkJoin/forkJoin.php\n\nuse Rx\\Observable;\n\n$obs1 = Observable::range(1, 4);\n$obs2 = Observable::range(3, 5);\n$obs3 = Observable::fromArray(['a', 'b', 'c']);\n\n$observable = Observable::forkJoin([$obs1, $obs2, $obs3], function($v1, $v2, $v3) {\n    return $v1 . $v2 . $v3;\n});\n$observable->subscribe($stdoutObserver);\n```\n\n``` javascript\nNext value: 47c\nComplete!\n```\n\n© ReactiveX contributors  \nLicensed under the Apache License 2.0.  \n[http://reactivex.io/documentation/operators/zip.html](http://reactivex.io/documentation/operators/zip.html)"
