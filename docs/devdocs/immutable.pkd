---
name: Immutable.js
slug: immutable
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © 2014–present, Lee Byron and other contributors
  Licensed under the 3-clause BSD License.
  https://immutable-js.com/docs/v4.2.1/
homepage: https://immutable-js.com/

---
- name: Collection
  id: collection/index
  summary: The Collection is a set of (key, value) entries which can be iterated, and is the base class for all collections in immutable, allowing them to make use of all the Collection methods (such as map and filter)
  description: "# Collection\n\nThe [`Collection`](index) is a set of (key, value) entries which can be iterated, and is the base class for all collections in `immutable`, allowing them to make use of all the Collection methods (such as [`map`](index#map()) and [`filter`](index#filter())).\n\n``` ts\ntype Collection<K, V> extends ValueObject\n```\n\n#### Discussion\n\nNote: A collection is always iterated in the same order, however that order may not always be well defined, as is the case for the [`Map`](../map/index) and [`Set`](../collection.set/index).\n\nCollection is the abstract base class for concrete data structures. It cannot be constructed directly.\n\nImplementations should extend one of the subclasses, [`Collection.Keyed`](../collection.keyed/index), [`Collection.Indexed`](../collection.indexed/index), or [`Collection.Set`](../collection.set/index).\n\n### Construction\n\n#### [Collection()](index#Collection())\n\n``` ts\nCollection<I>(collection: I): I\nCollection<T>(collection: Iterable<T> | ArrayLike<T>): Collection.Indexed<T>\nCollection<V>(obj: {[key: string]: V}): Collection.Keyed<string, V>\nCollection<K, V>(): Collection<K, V>\n```\n\n### Value equality\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Overrides\n\n[`ValueObject#equals()`](../valueobject/index#equals())\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Overrides\n\n[`ValueObject#hashCode()`](../valueobject/index#hashCode())\n\n#### Discussion\n\nThe [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nIf two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.\n\n### Reading values\n\n#### [get()](index#get())\n\n``` ts\nget<NSV>(key: K, notSetValue: NSV): V | NSV\nget(key: K): V | undefined\n```\n\n#### [has()](index#has())\n\nTrue if a key exists within this [`Collection`](index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nhas(key: K): boolean\n```\n\n#### [includes()](index#includes())\n\nTrue if a value exists within this [`Collection`](index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nincludes(value: V): boolean\n```\n\n#### alias\n\n`contains()`\n\n#### [first()](index#first())\n\nIn case the [`Collection`](index) is not empty returns the first element of the [`Collection`](index). In case the [`Collection`](index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nfirst<NSV>(notSetValue?: NSV): V | NSV\n```\n\n#### [last()](index#last())\n\nIn case the [`Collection`](index) is not empty returns the last element of the [`Collection`](index). In case the [`Collection`](index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nlast<NSV>(notSetValue?: NSV): V | NSV\n```\n\n### Reading deep values\n\n#### [getIn()](index#getIn())\n\nReturns the value found by following a path of keys or indices through nested Collections.\n\n``` ts\ngetIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown\n```\n\n#### Discussion\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: [ { y: 123 } ] });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\n#### [hasIn()](index#hasIn())\n\nTrue if the result of following a path of keys or indices through nested Collections results in a set value.\n\n``` ts\nhasIn(searchKeyPath: Iterable<unknown>): boolean\n```\n\n### Persistent changes\n\n#### [update()](index#update())\n\nThis can be very useful as a way to \"chain\" a normal function into a sequence of methods. RxJS calls this \"let\" and lodash calls it \"thru\".\n\n``` ts\nupdate<R>(updater: (value: this) => R): R\n```\n\n#### Discussion\n\nFor example, to sum a Seq after mapping and filtering:\n\n``` ts\nconst { Seq } = require('immutable')\n\nfunction sum(collection) {\n  return collection.reduce((sum, x) => sum + x, 0)\n}\nSeq([ 1, 2, 3 ])\n  .map(x => x + 1)\n  .filter(x => x % 2 === 0)\n  .update(sum)\n// 6run it\n```\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Collection to equivalent native JavaScript Array or Object.\n\n``` ts\ntoJS(): Array<DeepCopy<V>> | {[key: string]: DeepCopy<V>}\n```\n\n#### Discussion\n\n[`Collection.Indexed`](../collection.indexed/index), and [`Collection.Set`](../collection.set/index) become [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array), while [`Collection.Keyed`](../collection.keyed/index) become [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object), converting keys to Strings.\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Collection to equivalent native JavaScript Array or Object.\n\n``` ts\ntoJSON(): Array<V> | {[key: string]: V}\n```\n\n#### Discussion\n\n[`Collection.Indexed`](../collection.indexed/index), and [`Collection.Set`](../collection.set/index) become [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array), while [`Collection.Keyed`](../collection.keyed/index) become [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object), converting keys to Strings.\n\n#### [toArray()](index#toArray())\n\nShallowly converts this collection to an Array.\n\n``` ts\ntoArray(): Array<V> | Array<[K, V]>\n```\n\n#### Discussion\n\n[`Collection.Indexed`](../collection.indexed/index), and [`Collection.Set`](../collection.set/index) produce an Array of values. [`Collection.Keyed`](../collection.keyed/index) produce an Array of \\[key, value\\] tuples.\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Collection to an Object.\n\n``` ts\ntoObject(): {[key: string]: V}\n```\n\n#### Discussion\n\nConverts keys to Strings.\n\n### Conversion to Collections\n\n#### [toMap()](index#toMap())\n\nConverts this Collection to a Map, Throws if keys are not hashable.\n\n``` ts\ntoMap(): Map<K, V>\n```\n\n#### Discussion\n\nNote: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toOrderedMap()](index#toOrderedMap())\n\nConverts this Collection to a Map, maintaining the order of iteration.\n\n``` ts\ntoOrderedMap(): OrderedMap<K, V>\n```\n\n#### Discussion\n\nNote: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toSet()](index#toSet())\n\nConverts this Collection to a Set, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoSet(): Set<V>\n```\n\n#### Discussion\n\nNote: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.\n\n#### [toOrderedSet()](index#toOrderedSet())\n\nConverts this Collection to a Set, maintaining the order of iteration and discarding keys.\n\n``` ts\ntoOrderedSet(): OrderedSet<V>\n```\n\n#### Discussion\n\nNote: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toList()](index#toList())\n\nConverts this Collection to a List, discarding keys.\n\n``` ts\ntoList(): List<V>\n```\n\n#### Discussion\n\nThis is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.\n\n``` ts\nconst { Map, List } = require('immutable')\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\nList(myMap) // List [ [ \"a\", \"Apple\" ], [ \"b\", \"Banana\" ] ]\nmyMap.toList() // List [ \"Apple\", \"Banana\" ]run it\n```\n\n#### [toStack()](index#toStack())\n\nConverts this Collection to a Stack, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoStack(): Stack<V>\n```\n\n#### Discussion\n\nNote: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.\n\n### Conversion to Seq\n\n#### [toSeq()](index#toSeq())\n\nConverts this Collection to a Seq of the same kind (indexed, keyed, or set).\n\n``` ts\ntoSeq(): Seq<K, V>\n```\n\n#### [toKeyedSeq()](index#toKeyedSeq())\n\nReturns a Seq.Keyed from this Collection where indices are treated as keys.\n\n``` ts\ntoKeyedSeq(): Seq.Keyed<K, V>\n```\n\n#### Discussion\n\nThis is useful if you want to operate on an Collection.Indexed and preserve the \\[index, value\\] pairs.\n\nThe returned Seq will have identical iteration order as this Collection.\n\n``` ts\nconst { Seq } = require('immutable')\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\n// Seq [ \"A\", \"B\", \"C\" ]\nindexedSeq.filter(v => v === 'B')\n// Seq [ \"B\" ]\nconst keyedSeq = indexedSeq.toKeyedSeq()\n// Seq { 0: \"A\", 1: \"B\", 2: \"C\" }\nkeyedSeq.filter(v => v === 'B')\n// Seq { 1: \"B\" }run it\n```\n\n#### [toIndexedSeq()](index#toIndexedSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\ntoIndexedSeq(): Seq.Indexed<V>\n```\n\n#### [toSetSeq()](index#toSetSeq())\n\nReturns a Seq.Set of the values of this Collection, discarding keys.\n\n``` ts\ntoSetSeq(): Seq.Set<V>\n```\n\n### Iterators\n\n#### [keys()](index#keys())\n\nAn iterator of this [`Collection`](index)'s keys.\n\n``` ts\nkeys(): IterableIterator<K>\n```\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.\n\n#### [values()](index#values())\n\nAn iterator of this [`Collection`](index)'s values.\n\n``` ts\nvalues(): IterableIterator<V>\n```\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.\n\n#### [entries()](index#entries())\n\nAn iterator of this [`Collection`](index)'s entries as `[ key, value ]` tuples.\n\n``` ts\nentries(): IterableIterator<[K, V]>\n```\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<unknown>\n```\n\n### Collections (Seq)\n\n#### [keySeq()](index#keySeq())\n\nReturns a new Seq.Indexed of the keys of this Collection, discarding values.\n\n``` ts\nkeySeq(): Seq.Indexed<K>\n```\n\n#### [valueSeq()](index#valueSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\nvalueSeq(): Seq.Indexed<V>\n```\n\n#### [entrySeq()](index#entrySeq())\n\nReturns a new Seq.Indexed of \\[key, value\\] tuples.\n\n``` ts\nentrySeq(): Seq.Indexed<[K, V]>\n```\n\n### Sequence algorithms\n\n#### [map()](index#map())\n\nReturns a new Collection of the same type with values passed through a `mapper` function.\n\n``` ts\nmap<M>(mapper: (value: V, key: K, iter: this) => M,context?: unknown): Collection<K, M>\n```\n\n#### Discussion\n\n``` ts\nconst { Collection } = require('immutable')\nCollection({ a: 1, b: 2 }).map(x => 10 * x)\n// Seq { \"a\": 10, \"b\": 20 }run it\n```\n\nNote: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.\n\n#### [filter()](index#filter())\n\n``` ts\nfilter<F>(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): Collection<K, F>\nfilter(predicate: (value: V, key: K, iter: this) => unknown,context?: unknown): this\n```\n\n#### [filterNot()](index#filterNot())\n\nReturns a new Collection of the same type with only the entries for which the `predicate` function returns false.\n\n``` ts\nfilterNot(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }run it\n```\n\nNote: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.\n\n#### [partition()](index#partition())\n\n``` ts\npartition<F, C>(predicate: (this: C, value: V, key: K, iter: this) => boolean,context?: C): [Collection<K, V>, Collection<K, F>]\npartition<C>(predicate: (this: C, value: V, key: K, iter: this) => unknown,context?: C): [this, this]\n```\n\n#### [reverse()](index#reverse())\n\nReturns a new Collection of the same type in reverse order.\n\n``` ts\nreverse(): this\n```\n\n#### [sort()](index#sort())\n\nReturns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.\n\n``` ts\nsort(comparator?: (valueA: V, valueB: V) => number): this\n```\n\n#### Discussion\n\nIf a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n- Returns `0` if the elements should not be swapped.\n- Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n- Returns `1` (or any positive number) if `valueA` comes after `valueB`\n- Is pure, i.e. it must always return the same value for the same pair of values.\n\nWhen sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n``` ts\nconst { Map } = require('immutable')\nMap({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// OrderedMap { \"a\": 1, \"b\": 2, \"c\": 3 }run it\n```\n\nNote: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [sortBy()](index#sortBy())\n\nLike [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:\n\n``` ts\nsortBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this\n```\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst beattles = Map({\n  John: { name: \"Lennon\" },\n  Paul: { name: \"McCartney\" },\n  George: { name: \"Harrison\" },\n  Ringo: { name: \"Starr\" },\n});\nbeattles.sortBy(member => member.name);run it\n```\n\nNote: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [groupBy()](index#groupBy())\n\nReturns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.\n\n``` ts\ngroupBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<K, V>>\n```\n\n#### Discussion\n\nNote: This is always an eager operation.\n\n``` ts\nconst { List, Map } = require('immutable')\nconst listOfMaps = List([\n  Map({ v: 0 }),\n  Map({ v: 1 }),\n  Map({ v: 1 }),\n  Map({ v: 0 }),\n  Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ Map{ \"v\": 0 }, Map { \"v\": 0 } ],\n//   1: List [ Map{ \"v\": 1 }, Map { \"v\": 1 } ],\n//   2: List [ Map{ \"v\": 2 } ],\n// }run it\n```\n\n### Side effects\n\n#### [forEach()](index#forEach())\n\nThe `sideEffect` is executed for every entry in the Collection.\n\n``` ts\nforEach(sideEffect: (value: V, key: K, iter: this) => unknown,context?: unknown): number\n```\n\n#### Discussion\n\nUnlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).\n\n### Creating subsets\n\n#### [slice()](index#slice())\n\nReturns a new Collection of the same type representing a portion of this Collection from start up to but not including end.\n\n``` ts\nslice(begin?: number, end?: number): this\n```\n\n#### Discussion\n\nIf begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.\n\nIf the requested slice is equivalent to the current Collection, then it will return itself.\n\n#### [rest()](index#rest())\n\nReturns a new Collection of the same type containing all entries except the first.\n\n``` ts\nrest(): this\n```\n\n#### [butLast()](index#butLast())\n\nReturns a new Collection of the same type containing all entries except the last.\n\n``` ts\nbutLast(): this\n```\n\n#### [skip()](index#skip())\n\nReturns a new Collection of the same type which excludes the first `amount` entries from this Collection.\n\n``` ts\nskip(amount: number): this\n```\n\n#### [skipLast()](index#skipLast())\n\nReturns a new Collection of the same type which excludes the last `amount` entries from this Collection.\n\n``` ts\nskipLast(amount: number): this\n```\n\n#### [skipWhile()](index#skipWhile())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns false.\n\n``` ts\nskipWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipWhile(x => x.match(/g/))\n// List [ \"cat\", \"hat\", \"god\" ]run it\n```\n\n#### [skipUntil()](index#skipUntil())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns true.\n\n``` ts\nskipUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipUntil(x => x.match(/hat/))\n// List [ \"hat\", \"god\" ]run it\n```\n\n#### [take()](index#take())\n\nReturns a new Collection of the same type which includes the first `amount` entries from this Collection.\n\n``` ts\ntake(amount: number): this\n```\n\n#### [takeLast()](index#takeLast())\n\nReturns a new Collection of the same type which includes the last `amount` entries from this Collection.\n\n``` ts\ntakeLast(amount: number): this\n```\n\n#### [takeWhile()](index#takeWhile())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.\n\n``` ts\ntakeWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeWhile(x => x.match(/o/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n#### [takeUntil()](index#takeUntil())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.\n\n``` ts\ntakeUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeUntil(x => x.match(/at/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n### Combination\n\n#### [concat()](index#concat())\n\nReturns a new Collection of the same type with other values and collection-like concatenated to this one.\n\n``` ts\nconcat(...valuesOrCollections: Array<unknown>): Collection<unknown, unknown>\n```\n\n#### Discussion\n\nFor Seqs, all entries will be present in the resulting Seq, even if they have the same key.\n\n#### [flatten()](index#flatten())\n\n``` ts\nflatten(depth?: number): Collection<unknown, unknown>\nflatten(shallow?: boolean): Collection<unknown, unknown>\n```\n\n#### [flatMap()](index#flatMap())\n\nFlat-maps the Collection, returning a Collection of the same type.\n\n``` ts\nflatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>,context?: unknown): Collection<K, M>\nflatMap<KM, VM>(mapper: (value: V, key: K, iter: this) => Iterable<[KM, VM]>,context?: unknown): Collection<KM, VM>\n```\n\n#### Discussion\n\nSimilar to `collection.map(...).flatten(true)`. Used for Dictionaries only.\n\n### Reducing a value\n\n#### [reduce()](index#reduce())\n\n``` ts\nreduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R\nreduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R\n```\n\n#### [reduceRight()](index#reduceRight())\n\n``` ts\nreduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R\nreduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R\n```\n\n#### [every()](index#every())\n\nTrue if `predicate` returns true for all entries in the Collection.\n\n``` ts\nevery(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### [some()](index#some())\n\nTrue if `predicate` returns true for any entry in the Collection.\n\n``` ts\nsome(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### [join()](index#join())\n\nJoins values together as a string, inserting a separator between each. The default separator is `\",\"`.\n\n``` ts\njoin(separator?: string): string\n```\n\n#### [isEmpty()](index#isEmpty())\n\nReturns true if this Collection includes no values.\n\n``` ts\nisEmpty(): boolean\n```\n\n#### Discussion\n\nFor some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.\n\n#### [count()](index#count())\n\n``` ts\ncount(): number\ncount(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): number\n```\n\n#### [countBy()](index#countBy())\n\nReturns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.\n\n``` ts\ncountBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Map<G, number>\n```\n\n#### Discussion\n\nNote: This is not a lazy operation.\n\n### Search for value\n\n#### [find()](index#find())\n\nReturns the first value for which the `predicate` returns true.\n\n``` ts\nfind(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined\n```\n\n#### [findLast()](index#findLast())\n\nReturns the last value for which the `predicate` returns true.\n\n``` ts\nfindLast(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined\n```\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findEntry()](index#findEntry())\n\nReturns the first \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined\n```\n\n#### [findLastEntry()](index#findLastEntry())\n\nReturns the last \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindLastEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined\n```\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findKey()](index#findKey())\n\nReturns the key for which the `predicate` returns true.\n\n``` ts\nfindKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined\n```\n\n#### [findLastKey()](index#findLastKey())\n\nReturns the last key for which the `predicate` returns true.\n\n``` ts\nfindLastKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined\n```\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [keyOf()](index#keyOf())\n\nReturns the key associated with the search value, or undefined.\n\n``` ts\nkeyOf(searchValue: V): K | undefined\n```\n\n#### [lastKeyOf()](index#lastKeyOf())\n\nReturns the last key associated with the search value, or undefined.\n\n``` ts\nlastKeyOf(searchValue: V): K | undefined\n```\n\n#### [max()](index#max())\n\nReturns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmax(comparator?: (valueA: V, valueB: V) => number): V | undefined\n```\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](index#sort()). If it is not provided, the default comparator is `>`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [maxBy()](index#maxBy())\n\nLike [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nmaxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined\n```\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it\n```\n\n#### [min()](index#min())\n\nReturns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmin(comparator?: (valueA: V, valueB: V) => number): V | undefined\n```\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](index#sort()). If it is not provided, the default comparator is `<`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [minBy()](index#minBy())\n\nLike [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nminBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined\n```\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it\n```\n\n### Comparison\n\n#### [isSubset()](index#isSubset())\n\nTrue if `iter` includes every value in this Collection.\n\n``` ts\nisSubset(iter: Iterable<V>): boolean\n```\n\n#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<V>): boolean\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Collection/](https://immutable-js.com/docs/v4.2.1/Collection/)"
- name: Collection.[Symbol.iterator]()
  id: collection/index#[Symbol.iterator]()
  summary: null
  belongs_to: Collection
  description: |-
    #### [\[Symbol.iterator\]()](index#%5BSymbol.iterator%5D())

    ``` ts
    [Symbol.iterator](): IterableIterator<unknown>
    ```

    ### Collections (Seq)
- name: Collection.butLast()
  id: collection/index#butLast()
  summary: Returns a new Collection of the same type containing all entries except the last
  belongs_to: Collection
  description: |-
    #### [butLast()](index#butLast())

    Returns a new Collection of the same type containing all entries except the last.

    ``` ts
    butLast(): this
    ```
- name: Collection.Collection()
  id: collection/index#Collection()
  summary: null
  belongs_to: Collection
  description: |-
    #### [Collection()](index#Collection())

    ``` ts
    Collection<I>(collection: I): I
    Collection<T>(collection: Iterable<T> | ArrayLike<T>): Collection.Indexed<T>
    Collection<V>(obj: {[key: string]: V}): Collection.Keyed<string, V>
    Collection<K, V>(): Collection<K, V>
    ```

    ### Value equality
- name: Collection.concat()
  id: collection/index#concat()
  summary: Returns a new Collection of the same type with other values and collection-like concatenated to this one
  belongs_to: Collection
  description: |-
    #### [concat()](index#concat())

    Returns a new Collection of the same type with other values and collection-like concatenated to this one.

    ``` ts
    concat(...valuesOrCollections: Array<unknown>): Collection<unknown, unknown>
    ```

    #### Discussion

    For Seqs, all entries will be present in the resulting Seq, even if they have the same key.
- name: Collection.count()
  id: collection/index#count()
  summary: null
  belongs_to: Collection
  description: |-
    #### [count()](index#count())

    ``` ts
    count(): number
    count(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): number
    ```
- name: Collection.countBy()
  id: collection/index#countBy()
  summary: Returns a Seq.Keyed of counts, grouped by the return value of the grouper function
  belongs_to: Collection
  description: |-
    #### [countBy()](index#countBy())

    Returns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.

    ``` ts
    countBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Map<G, number>
    ```

    #### Discussion

    Note: This is not a lazy operation.

    ### Search for value
- name: Collection.entries()
  id: collection/index#entries()
  summary: An iterator of this Collection's entries as [ key, value ] tuples
  belongs_to: Collection
  description: |-
    #### [entries()](index#entries())

    An iterator of this [`Collection`](index)'s entries as `[ key, value ]` tuples.

    ``` ts
    entries(): IterableIterator<[K, V]>
    ```

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.
- name: Collection.entrySeq()
  id: collection/index#entrySeq()
  summary: Returns a new Seq.Indexed of [key, value] tuples
  belongs_to: Collection
  description: |-
    #### [entrySeq()](index#entrySeq())

    Returns a new Seq.Indexed of \[key, value\] tuples.

    ``` ts
    entrySeq(): Seq.Indexed<[K, V]>
    ```

    ### Sequence algorithms
- name: Collection.equals()
  id: collection/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: Collection
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Overrides

    [`ValueObject#equals()`](../valueobject/index#equals())

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: Collection.every()
  id: collection/index#every()
  summary: True if predicate returns true for all entries in the Collection
  belongs_to: Collection
  description: |-
    #### [every()](index#every())

    True if `predicate` returns true for all entries in the Collection.

    ``` ts
    every(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean
    ```
- name: Collection.filter()
  id: collection/index#filter()
  summary: null
  belongs_to: Collection
  description: |-
    #### [filter()](index#filter())

    ``` ts
    filter<F>(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): Collection<K, F>
    filter(predicate: (value: V, key: K, iter: this) => unknown,context?: unknown): this
    ```
- name: Collection.filterNot()
  id: collection/index#filterNot()
  summary: Returns a new Collection of the same type with only the entries for which the predicate function returns false
  belongs_to: Collection
  description: |-
    #### [filterNot()](index#filterNot())

    Returns a new Collection of the same type with only the entries for which the `predicate` function returns false.

    ``` ts
    filterNot(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
    // Map { "a": 1, "c": 3 }run it
    ```

    Note: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.
- name: Collection.find()
  id: collection/index#find()
  summary: Returns the first value for which the predicate returns true
  belongs_to: Collection
  description: |-
    #### [find()](index#find())

    Returns the first value for which the `predicate` returns true.

    ``` ts
    find(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined
    ```
- name: Collection.findEntry()
  id: collection/index#findEntry()
  summary: Returns the first [key, value] entry for which the predicate returns true
  belongs_to: Collection
  description: |-
    #### [findEntry()](index#findEntry())

    Returns the first \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
    ```
- name: Collection.findKey()
  id: collection/index#findKey()
  summary: Returns the key for which the predicate returns true
  belongs_to: Collection
  description: |-
    #### [findKey()](index#findKey())

    Returns the key for which the `predicate` returns true.

    ``` ts
    findKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined
    ```
- name: Collection.findLast()
  id: collection/index#findLast()
  summary: Returns the last value for which the predicate returns true
  belongs_to: Collection
  description: |-
    #### [findLast()](index#findLast())

    Returns the last value for which the `predicate` returns true.

    ``` ts
    findLast(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined
    ```

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Collection.findLastEntry()
  id: collection/index#findLastEntry()
  summary: Returns the last [key, value] entry for which the predicate returns true
  belongs_to: Collection
  description: |-
    #### [findLastEntry()](index#findLastEntry())

    Returns the last \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findLastEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
    ```

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Collection.findLastKey()
  id: collection/index#findLastKey()
  summary: Returns the last key for which the predicate returns true
  belongs_to: Collection
  description: |-
    #### [findLastKey()](index#findLastKey())

    Returns the last key for which the `predicate` returns true.

    ``` ts
    findLastKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined
    ```

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Collection.first()
  id: collection/index#first()
  summary: In case the Collection is not empty returns the first element of the Collection
  belongs_to: Collection
  description: |-
    #### [first()](index#first())

    In case the [`Collection`](index) is not empty returns the first element of the [`Collection`](index). In case the [`Collection`](index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    first<NSV>(notSetValue?: NSV): V | NSV
    ```
- name: Collection.flatMap()
  id: collection/index#flatMap()
  summary: Flat-maps the Collection, returning a Collection of the same type
  belongs_to: Collection
  description: |-
    #### [flatMap()](index#flatMap())

    Flat-maps the Collection, returning a Collection of the same type.

    ``` ts
    flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>,context?: unknown): Collection<K, M>
    flatMap<KM, VM>(mapper: (value: V, key: K, iter: this) => Iterable<[KM, VM]>,context?: unknown): Collection<KM, VM>
    ```

    #### Discussion

    Similar to `collection.map(...).flatten(true)`. Used for Dictionaries only.

    ### Reducing a value
- name: Collection.flatten()
  id: collection/index#flatten()
  summary: null
  belongs_to: Collection
  description: |-
    #### [flatten()](index#flatten())

    ``` ts
    flatten(depth?: number): Collection<unknown, unknown>
    flatten(shallow?: boolean): Collection<unknown, unknown>
    ```
- name: Collection.forEach()
  id: collection/index#forEach()
  summary: The sideEffect is executed for every entry in the Collection
  belongs_to: Collection
  description: |-
    #### [forEach()](index#forEach())

    The `sideEffect` is executed for every entry in the Collection.

    ``` ts
    forEach(sideEffect: (value: V, key: K, iter: this) => unknown,context?: unknown): number
    ```

    #### Discussion

    Unlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).

    ### Creating subsets
- name: Collection.get()
  id: collection/index#get()
  summary: null
  belongs_to: Collection
  description: |-
    #### [get()](index#get())

    ``` ts
    get<NSV>(key: K, notSetValue: NSV): V | NSV
    get(key: K): V | undefined
    ```
- name: Collection.getIn()
  id: collection/index#getIn()
  summary: Returns the value found by following a path of keys or indices through nested Collections
  belongs_to: Collection
  description: |-
    #### [getIn()](index#getIn())

    Returns the value found by following a path of keys or indices through nested Collections.

    ``` ts
    getIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown
    ```

    #### Discussion

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: [ { y: 123 } ] });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```
- name: Collection.groupBy()
  id: collection/index#groupBy()
  summary: Returns a Collection.Keyed of Collection.Keyeds, grouped by the return value of the grouper function
  belongs_to: Collection
  description: |-
    #### [groupBy()](index#groupBy())

    Returns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.

    ``` ts
    groupBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<K, V>>
    ```

    #### Discussion

    Note: This is always an eager operation.

    ``` ts
    const { List, Map } = require('immutable')
    const listOfMaps = List([
      Map({ v: 0 }),
      Map({ v: 1 }),
      Map({ v: 1 }),
      Map({ v: 0 }),
      Map({ v: 2 })
    ])
    const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
    // Map {
    //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
    //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
    //   2: List [ Map{ "v": 2 } ],
    // }run it
    ```

    ### Side effects
- name: Collection.has()
  id: collection/index#has()
  summary: null
  belongs_to: Collection
  description: |-
    #### [has()](index#has())

    True if a key exists within this [`Collection`](index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    has(key: K): boolean
    ```
- name: Collection.hashCode()
  id: collection/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: Collection
  description: |-
    #### [hashCode()](index#hashCode())

    Computes and returns the hashed identity for this Collection.

    ``` ts
    hashCode(): number
    ```

    #### Overrides

    [`ValueObject#hashCode()`](../valueobject/index#hashCode())

    #### Discussion

    The [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.

    ``` ts
    const a = List([ 1, 2, 3 ]);
    const b = List([ 1, 2, 3 ]);
    assert.notStrictEqual(a, b); // different instances
    const set = Set([ a ]);
    assert.equal(set.has(b), true);run it
    ```

    If two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.

    ### Reading values
- name: Collection.hasIn()
  id: collection/index#hasIn()
  summary: True if the result of following a path of keys or indices through nested Collections results in a set value
  belongs_to: Collection
  description: |-
    #### [hasIn()](index#hasIn())

    True if the result of following a path of keys or indices through nested Collections results in a set value.

    ``` ts
    hasIn(searchKeyPath: Iterable<unknown>): boolean
    ```

    ### Persistent changes
- name: Collection.includes()
  id: collection/index#includes()
  summary: null
  belongs_to: Collection
  description: |-
    #### [includes()](index#includes())

    True if a value exists within this [`Collection`](index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    includes(value: V): boolean
    ```

    #### alias

    `contains()`
- name: Collection.Indexed
  id: collection.indexed/index
  summary: Indexed Collections have incrementing numeric keys
  description: "# Collection.Indexed\n\nIndexed Collections have incrementing numeric keys. They exhibit slightly different behavior than [`Collection.Keyed`](../collection.keyed/index) for some methods in order to better mirror the behavior of JavaScript's [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array), and add methods which do not make sense on non-indexed Collections such as [`indexOf`](index#indexOf()).\n\n``` ts\ntype Collection.Indexed<T> extends Collection<number, T>\n```\n\n#### Discussion\n\nUnlike JavaScript arrays, [`Collection.Indexed`](index)s are always dense. \"Unset\" indices and `undefined` indices are indistinguishable, and all indices from 0 to `size` are visited when iterated.\n\nAll Collection.Indexed methods return re-indexed Collections. In other words, indices always start at 0 and increment until size. If you wish to preserve indices, using them as keys, convert to a Collection.Keyed by calling [`toKeyedSeq`](index#toKeyedSeq()).\n\n### Construction\n\n#### [Collection.Indexed()](index#Collection.Indexed())\n\nCreates a new Collection.Indexed.\n\n``` ts\nCollection.Indexed<T>(collection?: Iterable<T> | ArrayLike<T>): Collection.Indexed<T>\n```\n\n#### Discussion\n\nNote: [`Collection.Indexed`](index) is a conversion function and not a class, and does not use the `new` keyword during construction.\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Indexed collection to equivalent native JavaScript Array.\n\n``` ts\ntoJS(): Array<DeepCopy<T>>\n```\n\n#### Overrides\n\n[`Collection#toJS()`](../collection/index#toJS())\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Indexed collection to equivalent native JavaScript Array.\n\n``` ts\ntoJSON(): Array<T>\n```\n\n#### Overrides\n\n[`Collection#toJSON()`](../collection/index#toJSON())\n\n#### [toArray()](index#toArray())\n\nShallowly converts this collection to an Array.\n\n``` ts\ntoArray(): Array<T>\n```\n\n#### Overrides\n\n[`Collection#toArray()`](../collection/index#toArray())\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Collection to an Object.\n\n``` ts\ntoObject(): {[key: string]: T}\n```\n\n#### Inherited from\n\n[`Collection#toObject()`](../collection/index#toObject())\n\n#### Discussion\n\nConverts keys to Strings.\n\n### Reading values\n\n#### [get()](index#get())\n\n``` ts\nget<NSV>(index: number, notSetValue: NSV): T | NSV\nget(index: number): T | undefined\n```\n\n#### Overrides\n\n[`Collection#get()`](../collection/index#get())\n\n#### [has()](index#has())\n\nTrue if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nhas(key: number): boolean\n```\n\n#### Inherited from\n\n[`Collection#has()`](../collection/index#has())\n\n#### [includes()](index#includes())\n\nTrue if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nincludes(value: T): boolean\n```\n\n#### Inherited from\n\n[`Collection#includes()`](../collection/index#includes())\n\n#### alias\n\n`contains()`\n\n#### [first()](index#first())\n\nIn case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nfirst<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#first()`](../collection/index#first())\n\n#### [last()](index#last())\n\nIn case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nlast<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#last()`](../collection/index#last())\n\n### Conversion to Seq\n\n#### [toSeq()](index#toSeq())\n\nReturns Seq.Indexed.\n\n``` ts\ntoSeq(): Seq.Indexed<T>\n```\n\n#### Overrides\n\n[`Collection#toSeq()`](../collection/index#toSeq())\n\n#### [fromEntrySeq()](index#fromEntrySeq())\n\nIf this is a collection of \\[key, value\\] entry tuples, it will return a Seq.Keyed of those entries.\n\n``` ts\nfromEntrySeq(): Seq.Keyed<unknown, unknown>\n```\n\n#### [toKeyedSeq()](index#toKeyedSeq())\n\nReturns a Seq.Keyed from this Collection where indices are treated as keys.\n\n``` ts\ntoKeyedSeq(): Seq.Keyed<number, T>\n```\n\n#### Inherited from\n\n[`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())\n\n#### Discussion\n\nThis is useful if you want to operate on an Collection.Indexed and preserve the \\[index, value\\] pairs.\n\nThe returned Seq will have identical iteration order as this Collection.\n\n``` ts\nconst { Seq } = require('immutable')\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\n// Seq [ \"A\", \"B\", \"C\" ]\nindexedSeq.filter(v => v === 'B')\n// Seq [ \"B\" ]\nconst keyedSeq = indexedSeq.toKeyedSeq()\n// Seq { 0: \"A\", 1: \"B\", 2: \"C\" }\nkeyedSeq.filter(v => v === 'B')\n// Seq { 1: \"B\" }run it\n```\n\n#### [toIndexedSeq()](index#toIndexedSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\ntoIndexedSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())\n\n#### [toSetSeq()](index#toSetSeq())\n\nReturns a Seq.Set of the values of this Collection, discarding keys.\n\n``` ts\ntoSetSeq(): Seq.Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSetSeq()`](../collection/index#toSetSeq())\n\n### Combination\n\n#### [interpose()](index#interpose())\n\nReturns a Collection of the same type with `separator` between each item in this Collection.\n\n``` ts\ninterpose(separator: T): this\n```\n\n#### [interleave()](index#interleave())\n\nReturns a Collection of the same type with the provided `collections` interleaved into this collection.\n\n``` ts\ninterleave(...collections: Array<Collection<unknown, T>>): this\n```\n\n#### Discussion\n\nThe resulting Collection includes the first item from each, then the second from each, etc.\n\n``` ts\nconst { List } = require('immutable')\nList([ 1, 2, 3 ]).interleave(List([ 'A', 'B', 'C' ]))\n// List [ 1, \"A\", 2, \"B\", 3, \"C\" ]run it\n```\n\nThe shortest Collection stops interleave.\n\n``` ts\nList([ 1, 2, 3 ]).interleave(\n  List([ 'A', 'B' ]),\n  List([ 'X', 'Y', 'Z' ])\n)\n// List [ 1, \"A\", \"X\", 2, \"B\", \"Y\" ]run it\n```\n\nSince [`interleave()`](../list/index#interleave()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.\n\nNote: [`interleave`](../list/index#interleave()) *cannot* be used in [`withMutations`](../list/index#withMutations()).\n\n#### [splice()](index#splice())\n\nSplice returns a new indexed Collection by replacing a region of this Collection with new values. If values are not provided, it only skips the region to be removed.\n\n``` ts\nsplice(index: number, removeNum: number, ...values: Array<T>): this\n```\n\n#### Discussion\n\n`index` may be a negative number, which indexes back from the end of the Collection. `s.splice(-2)` splices after the second to last item.\n\n``` ts\nconst { List } = require('immutable')\nList([ 'a', 'b', 'c', 'd' ]).splice(1, 2, 'q', 'r', 's')\n// List [ \"a\", \"q\", \"r\", \"s\", \"d\" ]run it\n```\n\nSince [`splice()`](../list/index#splice()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.\n\nNote: [`splice`](../list/index#splice()) *cannot* be used in [`withMutations`](../list/index#withMutations()).\n\n#### [zip()](index#zip())\n\n``` ts\nzip<U>(other: Collection<unknown, U>): Collection.Indexed<[T, U]>\nzip<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): Collection.Indexed<[T, U, V]>\nzip(...collections: Array<Collection<unknown, unknown>>): Collection.Indexed<unknown>\n```\n\n#### [zipAll()](index#zipAll())\n\n``` ts\nzipAll<U>(other: Collection<unknown, U>): Collection.Indexed<[T, U]>\nzipAll<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): Collection.Indexed<[T, U, V]>\nzipAll(...collections: Array<Collection<unknown, unknown>>): Collection.Indexed<unknown>\n```\n\n#### [zipWith()](index#zipWith())\n\n``` ts\nzipWith<U, Z>(zipper: (value: T, otherValue: U) => Z,otherCollection: Collection<unknown, U>): Collection.Indexed<Z>\nzipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z,otherCollection: Collection<unknown, U>,thirdCollection: Collection<unknown, V>): Collection.Indexed<Z>\nzipWith<Z>(zipper: (...values: Array<unknown>) => Z,...collections: Array<Collection<unknown, unknown>>): Collection.Indexed<Z>\n```\n\n#### [flatten()](index#flatten())\n\n``` ts\nflatten(depth?: number): Collection<unknown, unknown>\nflatten(shallow?: boolean): Collection<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection#flatten()`](../collection/index#flatten())\n\n### Search for value\n\n#### [indexOf()](index#indexOf())\n\nReturns the first index at which a given value can be found in the Collection, or -1 if it is not present.\n\n``` ts\nindexOf(searchValue: T): number\n```\n\n#### [lastIndexOf()](index#lastIndexOf())\n\nReturns the last index at which a given value can be found in the Collection, or -1 if it is not present.\n\n``` ts\nlastIndexOf(searchValue: T): number\n```\n\n#### [findIndex()](index#findIndex())\n\nReturns the first index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.\n\n``` ts\nfindIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number\n```\n\n#### [findLastIndex()](index#findLastIndex())\n\nReturns the last index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.\n\n``` ts\nfindLastIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number\n```\n\n#### [find()](index#find())\n\nReturns the first value for which the `predicate` returns true.\n\n``` ts\nfind(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#find()`](../collection/index#find())\n\n#### [findLast()](index#findLast())\n\nReturns the last value for which the `predicate` returns true.\n\n``` ts\nfindLast(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLast()`](../collection/index#findLast())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findEntry()](index#findEntry())\n\nReturns the first \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findEntry()`](../collection/index#findEntry())\n\n#### [findLastEntry()](index#findLastEntry())\n\nReturns the last \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindLastEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastEntry()`](../collection/index#findLastEntry())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findKey()](index#findKey())\n\nReturns the key for which the `predicate` returns true.\n\n``` ts\nfindKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#findKey()`](../collection/index#findKey())\n\n#### [findLastKey()](index#findLastKey())\n\nReturns the last key for which the `predicate` returns true.\n\n``` ts\nfindLastKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastKey()`](../collection/index#findLastKey())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [keyOf()](index#keyOf())\n\nReturns the key associated with the search value, or undefined.\n\n``` ts\nkeyOf(searchValue: T): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#keyOf()`](../collection/index#keyOf())\n\n#### [lastKeyOf()](index#lastKeyOf())\n\nReturns the last key associated with the search value, or undefined.\n\n``` ts\nlastKeyOf(searchValue: T): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#lastKeyOf()`](../collection/index#lastKeyOf())\n\n#### [max()](index#max())\n\nReturns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmax(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#max()`](../collection/index#max())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [maxBy()](index#maxBy())\n\nLike [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nmaxBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#maxBy()`](../collection/index#maxBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it\n```\n\n#### [min()](index#min())\n\nReturns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmin(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#min()`](../collection/index#min())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [minBy()](index#minBy())\n\nLike [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nminBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#minBy()`](../collection/index#minBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it\n```\n\n### Sequence algorithms\n\n#### [concat()](index#concat())\n\nReturns a new Collection with other collections concatenated to this one.\n\n``` ts\nconcat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Collection.Indexed<T | C>\n```\n\n#### Overrides\n\n[`Collection#concat()`](../collection/index#concat())\n\n#### [map()](index#map())\n\nReturns a new Collection.Indexed with values passed through a `mapper` function.\n\n``` ts\nmap<M>(mapper: (value: T, key: number, iter: this) => M,context?: unknown): Collection.Indexed<M>\n```\n\n#### Overrides\n\n[`Collection#map()`](../collection/index#map())\n\n#### Example\n\n``` ts\nconst { Collection } = require('immutable')\nCollection.Indexed([1,2]).map(x => 10 * x)\n// Seq [ 1, 2 ]\n```\n\nNote: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.\n\n#### [flatMap()](index#flatMap())\n\nFlat-maps the Collection, returning a Collection of the same type.\n\n``` ts\nflatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>,context?: unknown): Collection.Indexed<M>\n```\n\n#### Overrides\n\n[`Collection#flatMap()`](../collection/index#flatMap())\n\n#### Discussion\n\nSimilar to `collection.map(...).flatten(true)`.\n\n#### [filter()](index#filter())\n\n``` ts\nfilter<F>(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): Collection.Indexed<F>\nfilter(predicate: (value: T, index: number, iter: this) => unknown,context?: unknown): this\n```\n\n#### Overrides\n\n[`Collection#filter()`](../collection/index#filter())\n\n#### [partition()](index#partition())\n\n``` ts\npartition<F, C>(predicate: (this: C, value: T, index: number, iter: this) => boolean,context?: C): [Collection.Indexed<T>, Collection.Indexed<F>]\npartition<C>(predicate: (this: C, value: T, index: number, iter: this) => unknown,context?: C): [this, this]\n```\n\n#### Overrides\n\n[`Collection#partition()`](../collection/index#partition())\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<T>\n```\n\n#### Overrides\n\n[`Collection#[Symbol.iterator]()`](../collection/index#%5BSymbol.iterator%5D())\n\n#### [filterNot()](index#filterNot())\n\nReturns a new Collection of the same type with only the entries for which the `predicate` function returns false.\n\n``` ts\nfilterNot(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#filterNot()`](../collection/index#filterNot())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }run it\n```\n\nNote: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.\n\n#### [reverse()](index#reverse())\n\nReturns a new Collection of the same type in reverse order.\n\n``` ts\nreverse(): this\n```\n\n#### Inherited from\n\n[`Collection#reverse()`](../collection/index#reverse())\n\n#### [sort()](index#sort())\n\nReturns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.\n\n``` ts\nsort(comparator?: (valueA: T, valueB: T) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sort()`](../collection/index#sort())\n\n#### Discussion\n\nIf a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n- Returns `0` if the elements should not be swapped.\n- Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n- Returns `1` (or any positive number) if `valueA` comes after `valueB`\n- Is pure, i.e. it must always return the same value for the same pair of values.\n\nWhen sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n``` ts\nconst { Map } = require('immutable')\nMap({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// OrderedMap { \"a\": 1, \"b\": 2, \"c\": 3 }run it\n```\n\nNote: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [sortBy()](index#sortBy())\n\nLike [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:\n\n``` ts\nsortBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sortBy()`](../collection/index#sortBy())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst beattles = Map({\n  John: { name: \"Lennon\" },\n  Paul: { name: \"McCartney\" },\n  George: { name: \"Harrison\" },\n  Ringo: { name: \"Starr\" },\n});\nbeattles.sortBy(member => member.name);run it\n```\n\nNote: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [groupBy()](index#groupBy())\n\nReturns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.\n\n``` ts\ngroupBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<number, T>>\n```\n\n#### Inherited from\n\n[`Collection#groupBy()`](../collection/index#groupBy())\n\n#### Discussion\n\nNote: This is always an eager operation.\n\n``` ts\nconst { List, Map } = require('immutable')\nconst listOfMaps = List([\n  Map({ v: 0 }),\n  Map({ v: 1 }),\n  Map({ v: 1 }),\n  Map({ v: 0 }),\n  Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ Map{ \"v\": 0 }, Map { \"v\": 0 } ],\n//   1: List [ Map{ \"v\": 1 }, Map { \"v\": 1 } ],\n//   2: List [ Map{ \"v\": 2 } ],\n// }run it\n```\n\n### Value equality\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#equals()`](../collection/index#equals())\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Inherited from\n\n[`Collection#hashCode()`](../collection/index#hashCode())\n\n#### Discussion\n\nThe [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nIf two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.\n\n### Reading deep values\n\n#### [getIn()](index#getIn())\n\nReturns the value found by following a path of keys or indices through nested Collections.\n\n``` ts\ngetIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown\n```\n\n#### Inherited from\n\n[`Collection#getIn()`](../collection/index#getIn())\n\n#### Discussion\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: [ { y: 123 } ] });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\n#### [hasIn()](index#hasIn())\n\nTrue if the result of following a path of keys or indices through nested Collections results in a set value.\n\n``` ts\nhasIn(searchKeyPath: Iterable<unknown>): boolean\n```\n\n#### Inherited from\n\n[`Collection#hasIn()`](../collection/index#hasIn())\n\n### Persistent changes\n\n#### [update()](index#update())\n\nThis can be very useful as a way to \"chain\" a normal function into a sequence of methods. RxJS calls this \"let\" and lodash calls it \"thru\".\n\n``` ts\nupdate<R>(updater: (value: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#update()`](../collection/index#update())\n\n#### Discussion\n\nFor example, to sum a Seq after mapping and filtering:\n\n``` ts\nconst { Seq } = require('immutable')\n\nfunction sum(collection) {\n  return collection.reduce((sum, x) => sum + x, 0)\n}\nSeq([ 1, 2, 3 ])\n  .map(x => x + 1)\n  .filter(x => x % 2 === 0)\n  .update(sum)\n// 6run it\n```\n\n### Conversion to Collections\n\n#### [toMap()](index#toMap())\n\nConverts this Collection to a Map, Throws if keys are not hashable.\n\n``` ts\ntoMap(): Map<number, T>\n```\n\n#### Inherited from\n\n[`Collection#toMap()`](../collection/index#toMap())\n\n#### Discussion\n\nNote: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toOrderedMap()](index#toOrderedMap())\n\nConverts this Collection to a Map, maintaining the order of iteration.\n\n``` ts\ntoOrderedMap(): OrderedMap<number, T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedMap()`](../collection/index#toOrderedMap())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toSet()](index#toSet())\n\nConverts this Collection to a Set, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoSet(): Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSet()`](../collection/index#toSet())\n\n#### Discussion\n\nNote: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.\n\n#### [toOrderedSet()](index#toOrderedSet())\n\nConverts this Collection to a Set, maintaining the order of iteration and discarding keys.\n\n``` ts\ntoOrderedSet(): OrderedSet<T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedSet()`](../collection/index#toOrderedSet())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toList()](index#toList())\n\nConverts this Collection to a List, discarding keys.\n\n``` ts\ntoList(): List<T>\n```\n\n#### Inherited from\n\n[`Collection#toList()`](../collection/index#toList())\n\n#### Discussion\n\nThis is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.\n\n``` ts\nconst { Map, List } = require('immutable')\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\nList(myMap) // List [ [ \"a\", \"Apple\" ], [ \"b\", \"Banana\" ] ]\nmyMap.toList() // List [ \"Apple\", \"Banana\" ]run it\n```\n\n#### [toStack()](index#toStack())\n\nConverts this Collection to a Stack, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoStack(): Stack<T>\n```\n\n#### Inherited from\n\n[`Collection#toStack()`](../collection/index#toStack())\n\n#### Discussion\n\nNote: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.\n\n### Iterators\n\n#### [keys()](index#keys())\n\nAn iterator of this [`Collection`](../collection/index)'s keys.\n\n``` ts\nkeys(): IterableIterator<number>\n```\n\n#### Inherited from\n\n[`Collection#keys()`](../collection/index#keys())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.\n\n#### [values()](index#values())\n\nAn iterator of this [`Collection`](../collection/index)'s values.\n\n``` ts\nvalues(): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection#values()`](../collection/index#values())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.\n\n#### [entries()](index#entries())\n\nAn iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.\n\n``` ts\nentries(): IterableIterator<[number, T]>\n```\n\n#### Inherited from\n\n[`Collection#entries()`](../collection/index#entries())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.\n\n### Collections (Seq)\n\n#### [keySeq()](index#keySeq())\n\nReturns a new Seq.Indexed of the keys of this Collection, discarding values.\n\n``` ts\nkeySeq(): Seq.Indexed<number>\n```\n\n#### Inherited from\n\n[`Collection#keySeq()`](../collection/index#keySeq())\n\n#### [valueSeq()](index#valueSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\nvalueSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#valueSeq()`](../collection/index#valueSeq())\n\n#### [entrySeq()](index#entrySeq())\n\nReturns a new Seq.Indexed of \\[key, value\\] tuples.\n\n``` ts\nentrySeq(): Seq.Indexed<[number, T]>\n```\n\n#### Inherited from\n\n[`Collection#entrySeq()`](../collection/index#entrySeq())\n\n### Side effects\n\n#### [forEach()](index#forEach())\n\nThe `sideEffect` is executed for every entry in the Collection.\n\n``` ts\nforEach(sideEffect: (value: T, key: number, iter: this) => unknown,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#forEach()`](../collection/index#forEach())\n\n#### Discussion\n\nUnlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).\n\n### Creating subsets\n\n#### [slice()](index#slice())\n\nReturns a new Collection of the same type representing a portion of this Collection from start up to but not including end.\n\n``` ts\nslice(begin?: number, end?: number): this\n```\n\n#### Inherited from\n\n[`Collection#slice()`](../collection/index#slice())\n\n#### Discussion\n\nIf begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.\n\nIf the requested slice is equivalent to the current Collection, then it will return itself.\n\n#### [rest()](index#rest())\n\nReturns a new Collection of the same type containing all entries except the first.\n\n``` ts\nrest(): this\n```\n\n#### Inherited from\n\n[`Collection#rest()`](../collection/index#rest())\n\n#### [butLast()](index#butLast())\n\nReturns a new Collection of the same type containing all entries except the last.\n\n``` ts\nbutLast(): this\n```\n\n#### Inherited from\n\n[`Collection#butLast()`](../collection/index#butLast())\n\n#### [skip()](index#skip())\n\nReturns a new Collection of the same type which excludes the first `amount` entries from this Collection.\n\n``` ts\nskip(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skip()`](../collection/index#skip())\n\n#### [skipLast()](index#skipLast())\n\nReturns a new Collection of the same type which excludes the last `amount` entries from this Collection.\n\n``` ts\nskipLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skipLast()`](../collection/index#skipLast())\n\n#### [skipWhile()](index#skipWhile())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns false.\n\n``` ts\nskipWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipWhile()`](../collection/index#skipWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipWhile(x => x.match(/g/))\n// List [ \"cat\", \"hat\", \"god\" ]run it\n```\n\n#### [skipUntil()](index#skipUntil())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns true.\n\n``` ts\nskipUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipUntil()`](../collection/index#skipUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipUntil(x => x.match(/hat/))\n// List [ \"hat\", \"god\" ]run it\n```\n\n#### [take()](index#take())\n\nReturns a new Collection of the same type which includes the first `amount` entries from this Collection.\n\n``` ts\ntake(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#take()`](../collection/index#take())\n\n#### [takeLast()](index#takeLast())\n\nReturns a new Collection of the same type which includes the last `amount` entries from this Collection.\n\n``` ts\ntakeLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#takeLast()`](../collection/index#takeLast())\n\n#### [takeWhile()](index#takeWhile())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.\n\n``` ts\ntakeWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeWhile()`](../collection/index#takeWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeWhile(x => x.match(/o/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n#### [takeUntil()](index#takeUntil())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.\n\n``` ts\ntakeUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeUntil()`](../collection/index#takeUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeUntil(x => x.match(/at/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n### Reducing a value\n\n#### [reduce()](index#reduce())\n\n``` ts\nreduce<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R\nreduce<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduce()`](../collection/index#reduce())\n\n#### [reduceRight()](index#reduceRight())\n\n``` ts\nreduceRight<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R\nreduceRight<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduceRight()`](../collection/index#reduceRight())\n\n#### [every()](index#every())\n\nTrue if `predicate` returns true for all entries in the Collection.\n\n``` ts\nevery(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#every()`](../collection/index#every())\n\n#### [some()](index#some())\n\nTrue if `predicate` returns true for any entry in the Collection.\n\n``` ts\nsome(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#some()`](../collection/index#some())\n\n#### [join()](index#join())\n\nJoins values together as a string, inserting a separator between each. The default separator is `\",\"`.\n\n``` ts\njoin(separator?: string): string\n```\n\n#### Inherited from\n\n[`Collection#join()`](../collection/index#join())\n\n#### [isEmpty()](index#isEmpty())\n\nReturns true if this Collection includes no values.\n\n``` ts\nisEmpty(): boolean\n```\n\n#### Inherited from\n\n[`Collection#isEmpty()`](../collection/index#isEmpty())\n\n#### Discussion\n\nFor some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.\n\n#### [count()](index#count())\n\n``` ts\ncount(): number\ncount(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#count()`](../collection/index#count())\n\n#### [countBy()](index#countBy())\n\nReturns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.\n\n``` ts\ncountBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Map<G, number>\n```\n\n#### Inherited from\n\n[`Collection#countBy()`](../collection/index#countBy())\n\n#### Discussion\n\nNote: This is not a lazy operation.\n\n### Comparison\n\n#### [isSubset()](index#isSubset())\n\nTrue if `iter` includes every value in this Collection.\n\n``` ts\nisSubset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSubset()`](../collection/index#isSubset())\n\n#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Collection.Indexed/](https://immutable-js.com/docs/v4.2.1/Collection.Indexed/)"
- name: Collection.Indexed.[Symbol.iterator]()
  id: collection.indexed/index#[Symbol.iterator]()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [\[Symbol.iterator\]()](index#%5BSymbol.iterator%5D())

    ``` ts
    [Symbol.iterator](): IterableIterator<T>
    ```

    #### Overrides

    [`Collection#[Symbol.iterator]()`](../collection/index#%5BSymbol.iterator%5D())
- name: Collection.Indexed.butLast()
  id: collection.indexed/index#butLast()
  summary: Returns a new Collection of the same type containing all entries except the last
  belongs_to: Collection.Indexed
  description: |-
    #### [butLast()](index#butLast())

    Returns a new Collection of the same type containing all entries except the last.

    ``` ts
    butLast(): this
    ```

    #### Inherited from

    [`Collection#butLast()`](../collection/index#butLast())
- name: Collection.Indexed.Collection.Indexed()
  id: collection.indexed/index#Collection.Indexed()
  summary: Creates a new Collection.Indexed
  belongs_to: Collection.Indexed
  description: |-
    #### [Collection.Indexed()](index#Collection.Indexed())

    Creates a new Collection.Indexed.

    ``` ts
    Collection.Indexed<T>(collection?: Iterable<T> | ArrayLike<T>): Collection.Indexed<T>
    ```

    #### Discussion

    Note: [`Collection.Indexed`](index) is a conversion function and not a class, and does not use the `new` keyword during construction.

    ### Conversion to JavaScript types
- name: Collection.Indexed.concat()
  id: collection.indexed/index#concat()
  summary: Returns a new Collection with other collections concatenated to this one
  belongs_to: Collection.Indexed
  description: |-
    #### [concat()](index#concat())

    Returns a new Collection with other collections concatenated to this one.

    ``` ts
    concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Collection.Indexed<T | C>
    ```

    #### Overrides

    [`Collection#concat()`](../collection/index#concat())
- name: Collection.Indexed.count()
  id: collection.indexed/index#count()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [count()](index#count())

    ``` ts
    count(): number
    count(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#count()`](../collection/index#count())
- name: Collection.Indexed.countBy()
  id: collection.indexed/index#countBy()
  summary: Returns a Seq.Keyed of counts, grouped by the return value of the grouper function
  belongs_to: Collection.Indexed
  description: |-
    #### [countBy()](index#countBy())

    Returns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.

    ``` ts
    countBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Map<G, number>
    ```

    #### Inherited from

    [`Collection#countBy()`](../collection/index#countBy())

    #### Discussion

    Note: This is not a lazy operation.

    ### Comparison
- name: Collection.Indexed.entries()
  id: collection.indexed/index#entries()
  summary: An iterator of this Collection's entries as [ key, value ] tuples
  belongs_to: Collection.Indexed
  description: |-
    #### [entries()](index#entries())

    An iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.

    ``` ts
    entries(): IterableIterator<[number, T]>
    ```

    #### Inherited from

    [`Collection#entries()`](../collection/index#entries())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.

    ### Collections (Seq)
- name: Collection.Indexed.entrySeq()
  id: collection.indexed/index#entrySeq()
  summary: Returns a new Seq.Indexed of [key, value] tuples
  belongs_to: Collection.Indexed
  description: |-
    #### [entrySeq()](index#entrySeq())

    Returns a new Seq.Indexed of \[key, value\] tuples.

    ``` ts
    entrySeq(): Seq.Indexed<[number, T]>
    ```

    #### Inherited from

    [`Collection#entrySeq()`](../collection/index#entrySeq())

    ### Side effects
- name: Collection.Indexed.equals()
  id: collection.indexed/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: Collection.Indexed
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Inherited from

    [`Collection#equals()`](../collection/index#equals())

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: Collection.Indexed.every()
  id: collection.indexed/index#every()
  summary: True if predicate returns true for all entries in the Collection
  belongs_to: Collection.Indexed
  description: |-
    #### [every()](index#every())

    True if `predicate` returns true for all entries in the Collection.

    ``` ts
    every(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#every()`](../collection/index#every())
- name: Collection.Indexed.filter()
  id: collection.indexed/index#filter()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [filter()](index#filter())

    ``` ts
    filter<F>(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): Collection.Indexed<F>
    filter(predicate: (value: T, index: number, iter: this) => unknown,context?: unknown): this
    ```

    #### Overrides

    [`Collection#filter()`](../collection/index#filter())
- name: Collection.Indexed.filterNot()
  id: collection.indexed/index#filterNot()
  summary: Returns a new Collection of the same type with only the entries for which the predicate function returns false
  belongs_to: Collection.Indexed
  description: |-
    #### [filterNot()](index#filterNot())

    Returns a new Collection of the same type with only the entries for which the `predicate` function returns false.

    ``` ts
    filterNot(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#filterNot()`](../collection/index#filterNot())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
    // Map { "a": 1, "c": 3 }run it
    ```

    Note: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.
- name: Collection.Indexed.find()
  id: collection.indexed/index#find()
  summary: Returns the first value for which the predicate returns true
  belongs_to: Collection.Indexed
  description: |-
    #### [find()](index#find())

    Returns the first value for which the `predicate` returns true.

    ``` ts
    find(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#find()`](../collection/index#find())
- name: Collection.Indexed.findEntry()
  id: collection.indexed/index#findEntry()
  summary: Returns the first [key, value] entry for which the predicate returns true
  belongs_to: Collection.Indexed
  description: |-
    #### [findEntry()](index#findEntry())

    Returns the first \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined
    ```

    #### Inherited from

    [`Collection#findEntry()`](../collection/index#findEntry())
- name: Collection.Indexed.findIndex()
  id: collection.indexed/index#findIndex()
  summary: Returns the first index in the Collection where a value satisfies the provided predicate function
  belongs_to: Collection.Indexed
  description: |-
    #### [findIndex()](index#findIndex())

    Returns the first index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.

    ``` ts
    findIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number
    ```
- name: Collection.Indexed.findKey()
  id: collection.indexed/index#findKey()
  summary: Returns the key for which the predicate returns true
  belongs_to: Collection.Indexed
  description: |-
    #### [findKey()](index#findKey())

    Returns the key for which the `predicate` returns true.

    ``` ts
    findKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined
    ```

    #### Inherited from

    [`Collection#findKey()`](../collection/index#findKey())
- name: Collection.Indexed.findLast()
  id: collection.indexed/index#findLast()
  summary: Returns the last value for which the predicate returns true
  belongs_to: Collection.Indexed
  description: |-
    #### [findLast()](index#findLast())

    Returns the last value for which the `predicate` returns true.

    ``` ts
    findLast(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#findLast()`](../collection/index#findLast())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Collection.Indexed.findLastEntry()
  id: collection.indexed/index#findLastEntry()
  summary: Returns the last [key, value] entry for which the predicate returns true
  belongs_to: Collection.Indexed
  description: |-
    #### [findLastEntry()](index#findLastEntry())

    Returns the last \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findLastEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined
    ```

    #### Inherited from

    [`Collection#findLastEntry()`](../collection/index#findLastEntry())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Collection.Indexed.findLastIndex()
  id: collection.indexed/index#findLastIndex()
  summary: Returns the last index in the Collection where a value satisfies the provided predicate function
  belongs_to: Collection.Indexed
  description: |-
    #### [findLastIndex()](index#findLastIndex())

    Returns the last index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.

    ``` ts
    findLastIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number
    ```
- name: Collection.Indexed.findLastKey()
  id: collection.indexed/index#findLastKey()
  summary: Returns the last key for which the predicate returns true
  belongs_to: Collection.Indexed
  description: |-
    #### [findLastKey()](index#findLastKey())

    Returns the last key for which the `predicate` returns true.

    ``` ts
    findLastKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined
    ```

    #### Inherited from

    [`Collection#findLastKey()`](../collection/index#findLastKey())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Collection.Indexed.first()
  id: collection.indexed/index#first()
  summary: In case the Collection is not empty returns the first element of the Collection
  belongs_to: Collection.Indexed
  description: |-
    #### [first()](index#first())

    In case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    first<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#first()`](../collection/index#first())
- name: Collection.Indexed.flatMap()
  id: collection.indexed/index#flatMap()
  summary: Flat-maps the Collection, returning a Collection of the same type
  belongs_to: Collection.Indexed
  description: |-
    #### [flatMap()](index#flatMap())

    Flat-maps the Collection, returning a Collection of the same type.

    ``` ts
    flatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>,context?: unknown): Collection.Indexed<M>
    ```

    #### Overrides

    [`Collection#flatMap()`](../collection/index#flatMap())

    #### Discussion

    Similar to `collection.map(...).flatten(true)`.
- name: Collection.Indexed.flatten()
  id: collection.indexed/index#flatten()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [flatten()](index#flatten())

    ``` ts
    flatten(depth?: number): Collection<unknown, unknown>
    flatten(shallow?: boolean): Collection<unknown, unknown>
    ```

    #### Inherited from

    [`Collection#flatten()`](../collection/index#flatten())

    ### Search for value
- name: Collection.Indexed.forEach()
  id: collection.indexed/index#forEach()
  summary: The sideEffect is executed for every entry in the Collection
  belongs_to: Collection.Indexed
  description: |-
    #### [forEach()](index#forEach())

    The `sideEffect` is executed for every entry in the Collection.

    ``` ts
    forEach(sideEffect: (value: T, key: number, iter: this) => unknown,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#forEach()`](../collection/index#forEach())

    #### Discussion

    Unlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).

    ### Creating subsets
- name: Collection.Indexed.fromEntrySeq()
  id: collection.indexed/index#fromEntrySeq()
  summary: If this is a collection of [key, value] entry tuples, it will return a Seq.Keyed of those entries
  belongs_to: Collection.Indexed
  description: |-
    #### [fromEntrySeq()](index#fromEntrySeq())

    If this is a collection of \[key, value\] entry tuples, it will return a Seq.Keyed of those entries.

    ``` ts
    fromEntrySeq(): Seq.Keyed<unknown, unknown>
    ```
- name: Collection.Indexed.get()
  id: collection.indexed/index#get()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [get()](index#get())

    ``` ts
    get<NSV>(index: number, notSetValue: NSV): T | NSV
    get(index: number): T | undefined
    ```

    #### Overrides

    [`Collection#get()`](../collection/index#get())
- name: Collection.Indexed.getIn()
  id: collection.indexed/index#getIn()
  summary: Returns the value found by following a path of keys or indices through nested Collections
  belongs_to: Collection.Indexed
  description: |-
    #### [getIn()](index#getIn())

    Returns the value found by following a path of keys or indices through nested Collections.

    ``` ts
    getIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown
    ```

    #### Inherited from

    [`Collection#getIn()`](../collection/index#getIn())

    #### Discussion

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: [ { y: 123 } ] });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```
- name: Collection.Indexed.groupBy()
  id: collection.indexed/index#groupBy()
  summary: Returns a Collection.Keyed of Collection.Keyeds, grouped by the return value of the grouper function
  belongs_to: Collection.Indexed
  description: |-
    #### [groupBy()](index#groupBy())

    Returns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.

    ``` ts
    groupBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<number, T>>
    ```

    #### Inherited from

    [`Collection#groupBy()`](../collection/index#groupBy())

    #### Discussion

    Note: This is always an eager operation.

    ``` ts
    const { List, Map } = require('immutable')
    const listOfMaps = List([
      Map({ v: 0 }),
      Map({ v: 1 }),
      Map({ v: 1 }),
      Map({ v: 0 }),
      Map({ v: 2 })
    ])
    const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
    // Map {
    //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
    //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
    //   2: List [ Map{ "v": 2 } ],
    // }run it
    ```

    ### Value equality
- name: Collection.Indexed.has()
  id: collection.indexed/index#has()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [has()](index#has())

    True if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    has(key: number): boolean
    ```

    #### Inherited from

    [`Collection#has()`](../collection/index#has())
- name: Collection.Indexed.hashCode()
  id: collection.indexed/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: Collection.Indexed
  description: |-
    #### [hashCode()](index#hashCode())

    Computes and returns the hashed identity for this Collection.

    ``` ts
    hashCode(): number
    ```

    #### Inherited from

    [`Collection#hashCode()`](../collection/index#hashCode())

    #### Discussion

    The [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.

    ``` ts
    const a = List([ 1, 2, 3 ]);
    const b = List([ 1, 2, 3 ]);
    assert.notStrictEqual(a, b); // different instances
    const set = Set([ a ]);
    assert.equal(set.has(b), true);run it
    ```

    If two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.

    ### Reading deep values
- name: Collection.Indexed.hasIn()
  id: collection.indexed/index#hasIn()
  summary: True if the result of following a path of keys or indices through nested Collections results in a set value
  belongs_to: Collection.Indexed
  description: |-
    #### [hasIn()](index#hasIn())

    True if the result of following a path of keys or indices through nested Collections results in a set value.

    ``` ts
    hasIn(searchKeyPath: Iterable<unknown>): boolean
    ```

    #### Inherited from

    [`Collection#hasIn()`](../collection/index#hasIn())

    ### Persistent changes
- name: Collection.Indexed.includes()
  id: collection.indexed/index#includes()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [includes()](index#includes())

    True if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    includes(value: T): boolean
    ```

    #### Inherited from

    [`Collection#includes()`](../collection/index#includes())

    #### alias

    `contains()`
- name: Collection.Indexed.indexOf()
  id: collection.indexed/index#indexOf()
  summary: Returns the first index at which a given value can be found in the Collection, or -1 if it is not present
  belongs_to: Collection.Indexed
  description: |-
    #### [indexOf()](index#indexOf())

    Returns the first index at which a given value can be found in the Collection, or -1 if it is not present.

    ``` ts
    indexOf(searchValue: T): number
    ```
- name: Collection.Indexed.interleave()
  id: collection.indexed/index#interleave()
  summary: Returns a Collection of the same type with the provided collections interleaved into this collection
  belongs_to: Collection.Indexed
  description: |-
    #### [interleave()](index#interleave())

    Returns a Collection of the same type with the provided `collections` interleaved into this collection.

    ``` ts
    interleave(...collections: Array<Collection<unknown, T>>): this
    ```

    #### Discussion

    The resulting Collection includes the first item from each, then the second from each, etc.

    ``` ts
    const { List } = require('immutable')
    List([ 1, 2, 3 ]).interleave(List([ 'A', 'B', 'C' ]))
    // List [ 1, "A", 2, "B", 3, "C" ]run it
    ```

    The shortest Collection stops interleave.

    ``` ts
    List([ 1, 2, 3 ]).interleave(
      List([ 'A', 'B' ]),
      List([ 'X', 'Y', 'Z' ])
    )
    // List [ 1, "A", "X", 2, "B", "Y" ]run it
    ```

    Since [`interleave()`](../list/index#interleave()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.

    Note: [`interleave`](../list/index#interleave()) *cannot* be used in [`withMutations`](../list/index#withMutations()).
- name: Collection.Indexed.interpose()
  id: collection.indexed/index#interpose()
  summary: Returns a Collection of the same type with separator between each item in this Collection
  belongs_to: Collection.Indexed
  description: |-
    #### [interpose()](index#interpose())

    Returns a Collection of the same type with `separator` between each item in this Collection.

    ``` ts
    interpose(separator: T): this
    ```
- name: Collection.Indexed.isEmpty()
  id: collection.indexed/index#isEmpty()
  summary: Returns true if this Collection includes no values
  belongs_to: Collection.Indexed
  description: |-
    #### [isEmpty()](index#isEmpty())

    Returns true if this Collection includes no values.

    ``` ts
    isEmpty(): boolean
    ```

    #### Inherited from

    [`Collection#isEmpty()`](../collection/index#isEmpty())

    #### Discussion

    For some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.
- name: Collection.Indexed.isSubset()
  id: collection.indexed/index#isSubset()
  summary: True if iter includes every value in this Collection
  belongs_to: Collection.Indexed
  description: |-
    #### [isSubset()](index#isSubset())

    True if `iter` includes every value in this Collection.

    ``` ts
    isSubset(iter: Iterable<T>): boolean
    ```

    #### Inherited from

    [`Collection#isSubset()`](../collection/index#isSubset())
- name: Collection.Indexed.isSuperset()
  id: collection.indexed/index#isSuperset()
  summary: True if this Collection includes every value in iter
  belongs_to: Collection.Indexed
  description: "#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Collection.Indexed/](https://immutable-js.com/docs/v4.2.1/Collection.Indexed/)"
- name: Collection.Indexed.join()
  id: collection.indexed/index#join()
  summary: Joins values together as a string, inserting a separator between each
  belongs_to: Collection.Indexed
  description: |-
    #### [join()](index#join())

    Joins values together as a string, inserting a separator between each. The default separator is `","`.

    ``` ts
    join(separator?: string): string
    ```

    #### Inherited from

    [`Collection#join()`](../collection/index#join())
- name: Collection.Indexed.keyOf()
  id: collection.indexed/index#keyOf()
  summary: Returns the key associated with the search value, or undefined
  belongs_to: Collection.Indexed
  description: |-
    #### [keyOf()](index#keyOf())

    Returns the key associated with the search value, or undefined.

    ``` ts
    keyOf(searchValue: T): number | undefined
    ```

    #### Inherited from

    [`Collection#keyOf()`](../collection/index#keyOf())
- name: Collection.Indexed.keys()
  id: collection.indexed/index#keys()
  summary: An iterator of this Collection's keys
  belongs_to: Collection.Indexed
  description: |-
    #### [keys()](index#keys())

    An iterator of this [`Collection`](../collection/index)'s keys.

    ``` ts
    keys(): IterableIterator<number>
    ```

    #### Inherited from

    [`Collection#keys()`](../collection/index#keys())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.
- name: Collection.Indexed.keySeq()
  id: collection.indexed/index#keySeq()
  summary: Returns a new Seq.Indexed of the keys of this Collection, discarding values
  belongs_to: Collection.Indexed
  description: |-
    #### [keySeq()](index#keySeq())

    Returns a new Seq.Indexed of the keys of this Collection, discarding values.

    ``` ts
    keySeq(): Seq.Indexed<number>
    ```

    #### Inherited from

    [`Collection#keySeq()`](../collection/index#keySeq())
- name: Collection.Indexed.last()
  id: collection.indexed/index#last()
  summary: In case the Collection is not empty returns the last element of the Collection
  belongs_to: Collection.Indexed
  description: |-
    #### [last()](index#last())

    In case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    last<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#last()`](../collection/index#last())

    ### Conversion to Seq
- name: Collection.Indexed.lastIndexOf()
  id: collection.indexed/index#lastIndexOf()
  summary: Returns the last index at which a given value can be found in the Collection, or -1 if it is not present
  belongs_to: Collection.Indexed
  description: |-
    #### [lastIndexOf()](index#lastIndexOf())

    Returns the last index at which a given value can be found in the Collection, or -1 if it is not present.

    ``` ts
    lastIndexOf(searchValue: T): number
    ```
- name: Collection.Indexed.lastKeyOf()
  id: collection.indexed/index#lastKeyOf()
  summary: Returns the last key associated with the search value, or undefined
  belongs_to: Collection.Indexed
  description: |-
    #### [lastKeyOf()](index#lastKeyOf())

    Returns the last key associated with the search value, or undefined.

    ``` ts
    lastKeyOf(searchValue: T): number | undefined
    ```

    #### Inherited from

    [`Collection#lastKeyOf()`](../collection/index#lastKeyOf())
- name: Collection.Indexed.map()
  id: collection.indexed/index#map()
  summary: Returns a new Collection.Indexed with values passed through a mapper function
  belongs_to: Collection.Indexed
  description: |-
    #### [map()](index#map())

    Returns a new Collection.Indexed with values passed through a `mapper` function.

    ``` ts
    map<M>(mapper: (value: T, key: number, iter: this) => M,context?: unknown): Collection.Indexed<M>
    ```

    #### Overrides

    [`Collection#map()`](../collection/index#map())

    #### Example

    ``` ts
    const { Collection } = require('immutable')
    Collection.Indexed([1,2]).map(x => 10 * x)
    // Seq [ 1, 2 ]
    ```

    Note: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.
- name: Collection.Indexed.max()
  id: collection.indexed/index#max()
  summary: Returns the maximum value in this collection
  belongs_to: Collection.Indexed
  description: |-
    #### [max()](index#max())

    Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    max(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#max()`](../collection/index#max())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Collection.Indexed.maxBy()
  id: collection.indexed/index#maxBy()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [maxBy()](index#maxBy())

    Like [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    maxBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#maxBy()`](../collection/index#maxBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it
    ```
- name: Collection.Indexed.min()
  id: collection.indexed/index#min()
  summary: Returns the minimum value in this collection
  belongs_to: Collection.Indexed
  description: |-
    #### [min()](index#min())

    Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    min(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#min()`](../collection/index#min())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Collection.Indexed.minBy()
  id: collection.indexed/index#minBy()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [minBy()](index#minBy())

    Like [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    minBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#minBy()`](../collection/index#minBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it
    ```

    ### Sequence algorithms
- name: Collection.Indexed.partition()
  id: collection.indexed/index#partition()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [partition()](index#partition())

    ``` ts
    partition<F, C>(predicate: (this: C, value: T, index: number, iter: this) => boolean,context?: C): [Collection.Indexed<T>, Collection.Indexed<F>]
    partition<C>(predicate: (this: C, value: T, index: number, iter: this) => unknown,context?: C): [this, this]
    ```

    #### Overrides

    [`Collection#partition()`](../collection/index#partition())
- name: Collection.Indexed.reduce()
  id: collection.indexed/index#reduce()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [reduce()](index#reduce())

    ``` ts
    reduce<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R
    reduce<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduce()`](../collection/index#reduce())
- name: Collection.Indexed.reduceRight()
  id: collection.indexed/index#reduceRight()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [reduceRight()](index#reduceRight())

    ``` ts
    reduceRight<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R
    reduceRight<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduceRight()`](../collection/index#reduceRight())
- name: Collection.Indexed.rest()
  id: collection.indexed/index#rest()
  summary: Returns a new Collection of the same type containing all entries except the first
  belongs_to: Collection.Indexed
  description: |-
    #### [rest()](index#rest())

    Returns a new Collection of the same type containing all entries except the first.

    ``` ts
    rest(): this
    ```

    #### Inherited from

    [`Collection#rest()`](../collection/index#rest())
- name: Collection.Indexed.reverse()
  id: collection.indexed/index#reverse()
  summary: Returns a new Collection of the same type in reverse order
  belongs_to: Collection.Indexed
  description: |-
    #### [reverse()](index#reverse())

    Returns a new Collection of the same type in reverse order.

    ``` ts
    reverse(): this
    ```

    #### Inherited from

    [`Collection#reverse()`](../collection/index#reverse())
- name: Collection.Indexed.skip()
  id: collection.indexed/index#skip()
  summary: Returns a new Collection of the same type which excludes the first amount entries from this Collection
  belongs_to: Collection.Indexed
  description: |-
    #### [skip()](index#skip())

    Returns a new Collection of the same type which excludes the first `amount` entries from this Collection.

    ``` ts
    skip(amount: number): this
    ```

    #### Inherited from

    [`Collection#skip()`](../collection/index#skip())
- name: Collection.Indexed.skipLast()
  id: collection.indexed/index#skipLast()
  summary: Returns a new Collection of the same type which excludes the last amount entries from this Collection
  belongs_to: Collection.Indexed
  description: |-
    #### [skipLast()](index#skipLast())

    Returns a new Collection of the same type which excludes the last `amount` entries from this Collection.

    ``` ts
    skipLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#skipLast()`](../collection/index#skipLast())
- name: Collection.Indexed.skipUntil()
  id: collection.indexed/index#skipUntil()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns true
  belongs_to: Collection.Indexed
  description: |-
    #### [skipUntil()](index#skipUntil())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns true.

    ``` ts
    skipUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipUntil()`](../collection/index#skipUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipUntil(x => x.match(/hat/))
    // List [ "hat", "god" ]run it
    ```
- name: Collection.Indexed.skipWhile()
  id: collection.indexed/index#skipWhile()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns false
  belongs_to: Collection.Indexed
  description: |-
    #### [skipWhile()](index#skipWhile())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns false.

    ``` ts
    skipWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipWhile()`](../collection/index#skipWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipWhile(x => x.match(/g/))
    // List [ "cat", "hat", "god" ]run it
    ```
- name: Collection.Indexed.slice()
  id: collection.indexed/index#slice()
  summary: Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end
  belongs_to: Collection.Indexed
  description: |-
    #### [slice()](index#slice())

    Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.

    ``` ts
    slice(begin?: number, end?: number): this
    ```

    #### Inherited from

    [`Collection#slice()`](../collection/index#slice())

    #### Discussion

    If begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.

    If end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.

    If the requested slice is equivalent to the current Collection, then it will return itself.
- name: Collection.Indexed.some()
  id: collection.indexed/index#some()
  summary: True if predicate returns true for any entry in the Collection
  belongs_to: Collection.Indexed
  description: |-
    #### [some()](index#some())

    True if `predicate` returns true for any entry in the Collection.

    ``` ts
    some(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#some()`](../collection/index#some())
- name: Collection.Indexed.sort()
  id: collection.indexed/index#sort()
  summary: Returns a new Collection of the same type which includes the same entries, stably sorted by using a comparator
  belongs_to: Collection.Indexed
  description: |-
    #### [sort()](index#sort())

    Returns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.

    ``` ts
    sort(comparator?: (valueA: T, valueB: T) => number): this
    ```

    #### Inherited from

    [`Collection#sort()`](../collection/index#sort())

    #### Discussion

    If a `comparator` is not provided, a default comparator uses `<` and `>`.

    `comparator(valueA, valueB)`:

    - Returns `0` if the elements should not be swapped.
    - Returns `-1` (or any negative number) if `valueA` comes before `valueB`
    - Returns `1` (or any positive number) if `valueA` comes after `valueB`
    - Is pure, i.e. it must always return the same value for the same pair of values.

    When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.

    ``` ts
    const { Map } = require('immutable')
    Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
      if (a < b) { return -1; }
      if (a > b) { return 1; }
      if (a === b) { return 0; }
    });
    // OrderedMap { "a": 1, "b": 2, "c": 3 }run it
    ```

    Note: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Collection.Indexed.sortBy()
  id: collection.indexed/index#sortBy()
  summary: 'Note: sortBy() Always returns a new instance, even if the original was already sorted'
  belongs_to: Collection.Indexed
  description: |-
    #### [sortBy()](index#sortBy())

    Like [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:

    ``` ts
    sortBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this
    ```

    #### Inherited from

    [`Collection#sortBy()`](../collection/index#sortBy())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const beattles = Map({
      John: { name: "Lennon" },
      Paul: { name: "McCartney" },
      George: { name: "Harrison" },
      Ringo: { name: "Starr" },
    });
    beattles.sortBy(member => member.name);run it
    ```

    Note: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Collection.Indexed.splice()
  id: collection.indexed/index#splice()
  summary: Splice returns a new indexed Collection by replacing a region of this Collection with new values
  belongs_to: Collection.Indexed
  description: |-
    #### [splice()](index#splice())

    Splice returns a new indexed Collection by replacing a region of this Collection with new values. If values are not provided, it only skips the region to be removed.

    ``` ts
    splice(index: number, removeNum: number, ...values: Array<T>): this
    ```

    #### Discussion

    `index` may be a negative number, which indexes back from the end of the Collection. `s.splice(-2)` splices after the second to last item.

    ``` ts
    const { List } = require('immutable')
    List([ 'a', 'b', 'c', 'd' ]).splice(1, 2, 'q', 'r', 's')
    // List [ "a", "q", "r", "s", "d" ]run it
    ```

    Since [`splice()`](../list/index#splice()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.

    Note: [`splice`](../list/index#splice()) *cannot* be used in [`withMutations`](../list/index#withMutations()).
- name: Collection.Indexed.take()
  id: collection.indexed/index#take()
  summary: Returns a new Collection of the same type which includes the first amount entries from this Collection
  belongs_to: Collection.Indexed
  description: |-
    #### [take()](index#take())

    Returns a new Collection of the same type which includes the first `amount` entries from this Collection.

    ``` ts
    take(amount: number): this
    ```

    #### Inherited from

    [`Collection#take()`](../collection/index#take())
- name: Collection.Indexed.takeLast()
  id: collection.indexed/index#takeLast()
  summary: Returns a new Collection of the same type which includes the last amount entries from this Collection
  belongs_to: Collection.Indexed
  description: |-
    #### [takeLast()](index#takeLast())

    Returns a new Collection of the same type which includes the last `amount` entries from this Collection.

    ``` ts
    takeLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#takeLast()`](../collection/index#takeLast())
- name: Collection.Indexed.takeUntil()
  id: collection.indexed/index#takeUntil()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns false
  belongs_to: Collection.Indexed
  description: |-
    #### [takeUntil()](index#takeUntil())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.

    ``` ts
    takeUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeUntil()`](../collection/index#takeUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeUntil(x => x.match(/at/))
    // List [ "dog", "frog" ]run it
    ```

    ### Reducing a value
- name: Collection.Indexed.takeWhile()
  id: collection.indexed/index#takeWhile()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns true
  belongs_to: Collection.Indexed
  description: |-
    #### [takeWhile()](index#takeWhile())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.

    ``` ts
    takeWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeWhile()`](../collection/index#takeWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeWhile(x => x.match(/o/))
    // List [ "dog", "frog" ]run it
    ```
- name: Collection.Indexed.toArray()
  id: collection.indexed/index#toArray()
  summary: Shallowly converts this collection to an Array
  belongs_to: Collection.Indexed
  description: |-
    #### [toArray()](index#toArray())

    Shallowly converts this collection to an Array.

    ``` ts
    toArray(): Array<T>
    ```

    #### Overrides

    [`Collection#toArray()`](../collection/index#toArray())
- name: Collection.Indexed.toIndexedSeq()
  id: collection.indexed/index#toIndexedSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Collection.Indexed
  description: |-
    #### [toIndexedSeq()](index#toIndexedSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    toIndexedSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())
- name: Collection.Indexed.toJS()
  id: collection.indexed/index#toJS()
  summary: Deeply converts this Indexed collection to equivalent native JavaScript Array
  belongs_to: Collection.Indexed
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Indexed collection to equivalent native JavaScript Array.

    ``` ts
    toJS(): Array<DeepCopy<T>>
    ```

    #### Overrides

    [`Collection#toJS()`](../collection/index#toJS())
- name: Collection.Indexed.toJSON()
  id: collection.indexed/index#toJSON()
  summary: Shallowly converts this Indexed collection to equivalent native JavaScript Array
  belongs_to: Collection.Indexed
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Indexed collection to equivalent native JavaScript Array.

    ``` ts
    toJSON(): Array<T>
    ```

    #### Overrides

    [`Collection#toJSON()`](../collection/index#toJSON())
- name: Collection.Indexed.toKeyedSeq()
  id: collection.indexed/index#toKeyedSeq()
  summary: Returns a Seq.Keyed from this Collection where indices are treated as keys
  belongs_to: Collection.Indexed
  description: |-
    #### [toKeyedSeq()](index#toKeyedSeq())

    Returns a Seq.Keyed from this Collection where indices are treated as keys.

    ``` ts
    toKeyedSeq(): Seq.Keyed<number, T>
    ```

    #### Inherited from

    [`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())

    #### Discussion

    This is useful if you want to operate on an Collection.Indexed and preserve the \[index, value\] pairs.

    The returned Seq will have identical iteration order as this Collection.

    ``` ts
    const { Seq } = require('immutable')
    const indexedSeq = Seq([ 'A', 'B', 'C' ])
    // Seq [ "A", "B", "C" ]
    indexedSeq.filter(v => v === 'B')
    // Seq [ "B" ]
    const keyedSeq = indexedSeq.toKeyedSeq()
    // Seq { 0: "A", 1: "B", 2: "C" }
    keyedSeq.filter(v => v === 'B')
    // Seq { 1: "B" }run it
    ```
- name: Collection.Indexed.toList()
  id: collection.indexed/index#toList()
  summary: Converts this Collection to a List, discarding keys
  belongs_to: Collection.Indexed
  description: |-
    #### [toList()](index#toList())

    Converts this Collection to a List, discarding keys.

    ``` ts
    toList(): List<T>
    ```

    #### Inherited from

    [`Collection#toList()`](../collection/index#toList())

    #### Discussion

    This is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.

    ``` ts
    const { Map, List } = require('immutable')
    var myMap = Map({ a: 'Apple', b: 'Banana' })
    List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
    myMap.toList() // List [ "Apple", "Banana" ]run it
    ```
- name: Collection.Indexed.toMap()
  id: collection.indexed/index#toMap()
  summary: Converts this Collection to a Map, Throws if keys are not hashable
  belongs_to: Collection.Indexed
  description: |-
    #### [toMap()](index#toMap())

    Converts this Collection to a Map, Throws if keys are not hashable.

    ``` ts
    toMap(): Map<number, T>
    ```

    #### Inherited from

    [`Collection#toMap()`](../collection/index#toMap())

    #### Discussion

    Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Collection.Indexed.toObject()
  id: collection.indexed/index#toObject()
  summary: Shallowly converts this Collection to an Object
  belongs_to: Collection.Indexed
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Collection to an Object.

    ``` ts
    toObject(): {[key: string]: T}
    ```

    #### Inherited from

    [`Collection#toObject()`](../collection/index#toObject())

    #### Discussion

    Converts keys to Strings.

    ### Reading values
- name: Collection.Indexed.toOrderedMap()
  id: collection.indexed/index#toOrderedMap()
  summary: Converts this Collection to a Map, maintaining the order of iteration
  belongs_to: Collection.Indexed
  description: |-
    #### [toOrderedMap()](index#toOrderedMap())

    Converts this Collection to a Map, maintaining the order of iteration.

    ``` ts
    toOrderedMap(): OrderedMap<number, T>
    ```

    #### Inherited from

    [`Collection#toOrderedMap()`](../collection/index#toOrderedMap())

    #### Discussion

    Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Collection.Indexed.toOrderedSet()
  id: collection.indexed/index#toOrderedSet()
  summary: Converts this Collection to a Set, maintaining the order of iteration and discarding keys
  belongs_to: Collection.Indexed
  description: |-
    #### [toOrderedSet()](index#toOrderedSet())

    Converts this Collection to a Set, maintaining the order of iteration and discarding keys.

    ``` ts
    toOrderedSet(): OrderedSet<T>
    ```

    #### Inherited from

    [`Collection#toOrderedSet()`](../collection/index#toOrderedSet())

    #### Discussion

    Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.
- name: Collection.Indexed.toSeq()
  id: collection.indexed/index#toSeq()
  summary: Returns Seq.Indexed
  belongs_to: Collection.Indexed
  description: |-
    #### [toSeq()](index#toSeq())

    Returns Seq.Indexed.

    ``` ts
    toSeq(): Seq.Indexed<T>
    ```

    #### Overrides

    [`Collection#toSeq()`](../collection/index#toSeq())
- name: Collection.Indexed.toSet()
  id: collection.indexed/index#toSet()
  summary: Converts this Collection to a Set, discarding keys
  belongs_to: Collection.Indexed
  description: |-
    #### [toSet()](index#toSet())

    Converts this Collection to a Set, discarding keys. Throws if values are not hashable.

    ``` ts
    toSet(): Set<T>
    ```

    #### Inherited from

    [`Collection#toSet()`](../collection/index#toSet())

    #### Discussion

    Note: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.
- name: Collection.Indexed.toSetSeq()
  id: collection.indexed/index#toSetSeq()
  summary: Returns a Seq.Set of the values of this Collection, discarding keys
  belongs_to: Collection.Indexed
  description: |-
    #### [toSetSeq()](index#toSetSeq())

    Returns a Seq.Set of the values of this Collection, discarding keys.

    ``` ts
    toSetSeq(): Seq.Set<T>
    ```

    #### Inherited from

    [`Collection#toSetSeq()`](../collection/index#toSetSeq())

    ### Combination
- name: Collection.Indexed.toStack()
  id: collection.indexed/index#toStack()
  summary: Converts this Collection to a Stack, discarding keys
  belongs_to: Collection.Indexed
  description: |-
    #### [toStack()](index#toStack())

    Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.

    ``` ts
    toStack(): Stack<T>
    ```

    #### Inherited from

    [`Collection#toStack()`](../collection/index#toStack())

    #### Discussion

    Note: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.

    ### Iterators
- name: Collection.Indexed.update()
  id: collection.indexed/index#update()
  summary: This can be very useful as a way to "chain" a normal function into a sequence of methods
  belongs_to: Collection.Indexed
  description: |-
    #### [update()](index#update())

    This can be very useful as a way to "chain" a normal function into a sequence of methods. RxJS calls this "let" and lodash calls it "thru".

    ``` ts
    update<R>(updater: (value: this) => R): R
    ```

    #### Inherited from

    [`Collection#update()`](../collection/index#update())

    #### Discussion

    For example, to sum a Seq after mapping and filtering:

    ``` ts
    const { Seq } = require('immutable')

    function sum(collection) {
      return collection.reduce((sum, x) => sum + x, 0)
    }
    Seq([ 1, 2, 3 ])
      .map(x => x + 1)
      .filter(x => x % 2 === 0)
      .update(sum)
    // 6run it
    ```

    ### Conversion to Collections
- name: Collection.Indexed.values()
  id: collection.indexed/index#values()
  summary: An iterator of this Collection's values
  belongs_to: Collection.Indexed
  description: |-
    #### [values()](index#values())

    An iterator of this [`Collection`](../collection/index)'s values.

    ``` ts
    values(): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection#values()`](../collection/index#values())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.
- name: Collection.Indexed.valueSeq()
  id: collection.indexed/index#valueSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Collection.Indexed
  description: |-
    #### [valueSeq()](index#valueSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    valueSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#valueSeq()`](../collection/index#valueSeq())
- name: Collection.Indexed.zip()
  id: collection.indexed/index#zip()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [zip()](index#zip())

    ``` ts
    zip<U>(other: Collection<unknown, U>): Collection.Indexed<[T, U]>
    zip<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): Collection.Indexed<[T, U, V]>
    zip(...collections: Array<Collection<unknown, unknown>>): Collection.Indexed<unknown>
    ```
- name: Collection.Indexed.zipAll()
  id: collection.indexed/index#zipAll()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [zipAll()](index#zipAll())

    ``` ts
    zipAll<U>(other: Collection<unknown, U>): Collection.Indexed<[T, U]>
    zipAll<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): Collection.Indexed<[T, U, V]>
    zipAll(...collections: Array<Collection<unknown, unknown>>): Collection.Indexed<unknown>
    ```
- name: Collection.Indexed.zipWith()
  id: collection.indexed/index#zipWith()
  summary: null
  belongs_to: Collection.Indexed
  description: |-
    #### [zipWith()](index#zipWith())

    ``` ts
    zipWith<U, Z>(zipper: (value: T, otherValue: U) => Z,otherCollection: Collection<unknown, U>): Collection.Indexed<Z>
    zipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z,otherCollection: Collection<unknown, U>,thirdCollection: Collection<unknown, V>): Collection.Indexed<Z>
    zipWith<Z>(zipper: (...values: Array<unknown>) => Z,...collections: Array<Collection<unknown, unknown>>): Collection.Indexed<Z>
    ```
- name: Collection.isEmpty()
  id: collection/index#isEmpty()
  summary: Returns true if this Collection includes no values
  belongs_to: Collection
  description: |-
    #### [isEmpty()](index#isEmpty())

    Returns true if this Collection includes no values.

    ``` ts
    isEmpty(): boolean
    ```

    #### Discussion

    For some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.
- name: Collection.isSubset()
  id: collection/index#isSubset()
  summary: True if iter includes every value in this Collection
  belongs_to: Collection
  description: |-
    #### [isSubset()](index#isSubset())

    True if `iter` includes every value in this Collection.

    ``` ts
    isSubset(iter: Iterable<V>): boolean
    ```
- name: Collection.isSuperset()
  id: collection/index#isSuperset()
  summary: True if this Collection includes every value in iter
  belongs_to: Collection
  description: "#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<V>): boolean\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Collection/](https://immutable-js.com/docs/v4.2.1/Collection/)"
- name: Collection.join()
  id: collection/index#join()
  summary: Joins values together as a string, inserting a separator between each
  belongs_to: Collection
  description: |-
    #### [join()](index#join())

    Joins values together as a string, inserting a separator between each. The default separator is `","`.

    ``` ts
    join(separator?: string): string
    ```
- name: Collection.Keyed
  id: collection.keyed/index
  summary: Keyed Collections have discrete keys tied to each value
  description: "# Collection.Keyed\n\nKeyed Collections have discrete keys tied to each value.\n\n``` ts\ntype Collection.Keyed<K, V> extends Collection<K, V>\n```\n\n#### Discussion\n\nWhen iterating [`Collection.Keyed`](index), each iteration will yield a `[K, V]` tuple, in other words, [`Collection#entries`](../collection/index#entries()) is the default iterator for Keyed Collections.\n\n### Construction\n\n#### [Collection.Keyed()](index#Collection.Keyed())\n\n``` ts\nCollection.Keyed<K, V>(collection?: Iterable<[K, V]>): Collection.Keyed<K, V>\nCollection.Keyed<V>(obj: {[key: string]: V}): Collection.Keyed<string, V>\n```\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Keyed collection to equivalent native JavaScript Object.\n\n``` ts\ntoJS(): {[key: string]: DeepCopy<V>}\n```\n\n#### Overrides\n\n[`Collection#toJS()`](../collection/index#toJS())\n\n#### Discussion\n\nConverts keys to Strings.\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Keyed collection to equivalent native JavaScript Object.\n\n``` ts\ntoJSON(): {[key: string]: V}\n```\n\n#### Overrides\n\n[`Collection#toJSON()`](../collection/index#toJSON())\n\n#### Discussion\n\nConverts keys to Strings.\n\n#### [toArray()](index#toArray())\n\nShallowly converts this collection to an Array.\n\n``` ts\ntoArray(): Array<[K, V]>\n```\n\n#### Overrides\n\n[`Collection#toArray()`](../collection/index#toArray())\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Collection to an Object.\n\n``` ts\ntoObject(): {[key: string]: V}\n```\n\n#### Inherited from\n\n[`Collection#toObject()`](../collection/index#toObject())\n\n#### Discussion\n\nConverts keys to Strings.\n\n### Conversion to Seq\n\n#### [toSeq()](index#toSeq())\n\nReturns Seq.Keyed.\n\n``` ts\ntoSeq(): Seq.Keyed<K, V>\n```\n\n#### Overrides\n\n[`Collection#toSeq()`](../collection/index#toSeq())\n\n#### [toKeyedSeq()](index#toKeyedSeq())\n\nReturns a Seq.Keyed from this Collection where indices are treated as keys.\n\n``` ts\ntoKeyedSeq(): Seq.Keyed<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())\n\n#### Discussion\n\nThis is useful if you want to operate on an Collection.Indexed and preserve the \\[index, value\\] pairs.\n\nThe returned Seq will have identical iteration order as this Collection.\n\n``` ts\nconst { Seq } = require('immutable')\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\n// Seq [ \"A\", \"B\", \"C\" ]\nindexedSeq.filter(v => v === 'B')\n// Seq [ \"B\" ]\nconst keyedSeq = indexedSeq.toKeyedSeq()\n// Seq { 0: \"A\", 1: \"B\", 2: \"C\" }\nkeyedSeq.filter(v => v === 'B')\n// Seq { 1: \"B\" }run it\n```\n\n#### [toIndexedSeq()](index#toIndexedSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\ntoIndexedSeq(): Seq.Indexed<V>\n```\n\n#### Inherited from\n\n[`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())\n\n#### [toSetSeq()](index#toSetSeq())\n\nReturns a Seq.Set of the values of this Collection, discarding keys.\n\n``` ts\ntoSetSeq(): Seq.Set<V>\n```\n\n#### Inherited from\n\n[`Collection#toSetSeq()`](../collection/index#toSetSeq())\n\n### Sequence functions\n\n#### [flip()](index#flip())\n\nReturns a new Collection.Keyed of the same type where the keys and values have been flipped.\n\n``` ts\nflip(): Collection.Keyed<V, K>\n```\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 'z', b: 'y' }).flip()\n// Map { \"z\": \"a\", \"y\": \"b\" }run it\n```\n\n#### [concat()](index#concat())\n\n``` ts\nconcat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Collection.Keyed<K | KC, V | VC>\nconcat<C>(...collections: Array<{[key: string]: C}>): Collection.Keyed<K | string, V | C>\n```\n\n#### Overrides\n\n[`Collection#concat()`](../collection/index#concat())\n\n#### [map()](index#map())\n\nReturns a new Collection.Keyed with values passed through a `mapper` function.\n\n``` ts\nmap<M>(mapper: (value: V, key: K, iter: this) => M,context?: unknown): Collection.Keyed<K, M>\n```\n\n#### Overrides\n\n[`Collection#map()`](../collection/index#map())\n\n#### Example\n\n``` ts\nconst { Collection } = require('immutable')\nCollection.Keyed({ a: 1, b: 2 }).map(x => 10 * x)\n// Seq { \"a\": 10, \"b\": 20 }\n```\n\nNote: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.\n\n#### [mapKeys()](index#mapKeys())\n\nReturns a new Collection.Keyed of the same type with keys passed through a `mapper` function.\n\n``` ts\nmapKeys<M>(mapper: (key: K, value: V, iter: this) => M,context?: unknown): Collection.Keyed<M, V>\n```\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2 }).mapKeys(x => x.toUpperCase())\n// Map { \"A\": 1, \"B\": 2 }run it\n```\n\nNote: [`mapKeys()`](index#mapKeys()) always returns a new instance, even if it produced the same key at every step.\n\n#### [mapEntries()](index#mapEntries())\n\nReturns a new Collection.Keyed of the same type with entries (\\[key, value\\] tuples) passed through a `mapper` function.\n\n``` ts\nmapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM] | undefined,context?: unknown): Collection.Keyed<KM, VM>\n```\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2 })\n  .mapEntries(([ k, v ]) => [ k.toUpperCase(), v * 2 ])\n// Map { \"A\": 2, \"B\": 4 }run it\n```\n\nNote: [`mapEntries()`](index#mapEntries()) always returns a new instance, even if it produced the same entry at every step.\n\nIf the mapper function returns `undefined`, then the entry will be filtered\n\n#### [flatMap()](index#flatMap())\n\nFlat-maps the Collection, returning a Collection of the same type.\n\n``` ts\nflatMap<KM, VM>(mapper: (value: V, key: K, iter: this) => Iterable<[KM, VM]>,context?: unknown): Collection.Keyed<KM, VM>\n```\n\n#### Overrides\n\n[`Collection#flatMap()`](../collection/index#flatMap())\n\n#### Discussion\n\nSimilar to `collection.map(...).flatten(true)`.\n\n#### [filter()](index#filter())\n\n``` ts\nfilter<F>(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): Collection.Keyed<K, F>\nfilter(predicate: (value: V, key: K, iter: this) => unknown,context?: unknown): this\n```\n\n#### Overrides\n\n[`Collection#filter()`](../collection/index#filter())\n\n#### [partition()](index#partition())\n\n``` ts\npartition<F, C>(predicate: (this: C, value: V, key: K, iter: this) => boolean,context?: C): [Collection.Keyed<K, V>, Collection.Keyed<K, F>]\npartition<C>(predicate: (this: C, value: V, key: K, iter: this) => unknown,context?: C): [this, this]\n```\n\n#### Overrides\n\n[`Collection#partition()`](../collection/index#partition())\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<[K, V]>\n```\n\n#### Overrides\n\n[`Collection#[Symbol.iterator]()`](../collection/index#%5BSymbol.iterator%5D())\n\n### Value equality\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#equals()`](../collection/index#equals())\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Inherited from\n\n[`Collection#hashCode()`](../collection/index#hashCode())\n\n#### Discussion\n\nThe [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nIf two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.\n\n### Reading values\n\n#### [get()](index#get())\n\n``` ts\nget<NSV>(key: K, notSetValue: NSV): V | NSV\nget(key: K): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#get()`](../collection/index#get())\n\n#### [has()](index#has())\n\nTrue if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nhas(key: K): boolean\n```\n\n#### Inherited from\n\n[`Collection#has()`](../collection/index#has())\n\n#### [includes()](index#includes())\n\nTrue if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nincludes(value: V): boolean\n```\n\n#### Inherited from\n\n[`Collection#includes()`](../collection/index#includes())\n\n#### alias\n\n`contains()`\n\n#### [first()](index#first())\n\nIn case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nfirst<NSV>(notSetValue?: NSV): V | NSV\n```\n\n#### Inherited from\n\n[`Collection#first()`](../collection/index#first())\n\n#### [last()](index#last())\n\nIn case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nlast<NSV>(notSetValue?: NSV): V | NSV\n```\n\n#### Inherited from\n\n[`Collection#last()`](../collection/index#last())\n\n### Reading deep values\n\n#### [getIn()](index#getIn())\n\nReturns the value found by following a path of keys or indices through nested Collections.\n\n``` ts\ngetIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown\n```\n\n#### Inherited from\n\n[`Collection#getIn()`](../collection/index#getIn())\n\n#### Discussion\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: [ { y: 123 } ] });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\n#### [hasIn()](index#hasIn())\n\nTrue if the result of following a path of keys or indices through nested Collections results in a set value.\n\n``` ts\nhasIn(searchKeyPath: Iterable<unknown>): boolean\n```\n\n#### Inherited from\n\n[`Collection#hasIn()`](../collection/index#hasIn())\n\n### Persistent changes\n\n#### [update()](index#update())\n\nThis can be very useful as a way to \"chain\" a normal function into a sequence of methods. RxJS calls this \"let\" and lodash calls it \"thru\".\n\n``` ts\nupdate<R>(updater: (value: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#update()`](../collection/index#update())\n\n#### Discussion\n\nFor example, to sum a Seq after mapping and filtering:\n\n``` ts\nconst { Seq } = require('immutable')\n\nfunction sum(collection) {\n  return collection.reduce((sum, x) => sum + x, 0)\n}\nSeq([ 1, 2, 3 ])\n  .map(x => x + 1)\n  .filter(x => x % 2 === 0)\n  .update(sum)\n// 6run it\n```\n\n### Conversion to Collections\n\n#### [toMap()](index#toMap())\n\nConverts this Collection to a Map, Throws if keys are not hashable.\n\n``` ts\ntoMap(): Map<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toMap()`](../collection/index#toMap())\n\n#### Discussion\n\nNote: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toOrderedMap()](index#toOrderedMap())\n\nConverts this Collection to a Map, maintaining the order of iteration.\n\n``` ts\ntoOrderedMap(): OrderedMap<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedMap()`](../collection/index#toOrderedMap())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toSet()](index#toSet())\n\nConverts this Collection to a Set, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoSet(): Set<V>\n```\n\n#### Inherited from\n\n[`Collection#toSet()`](../collection/index#toSet())\n\n#### Discussion\n\nNote: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.\n\n#### [toOrderedSet()](index#toOrderedSet())\n\nConverts this Collection to a Set, maintaining the order of iteration and discarding keys.\n\n``` ts\ntoOrderedSet(): OrderedSet<V>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedSet()`](../collection/index#toOrderedSet())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toList()](index#toList())\n\nConverts this Collection to a List, discarding keys.\n\n``` ts\ntoList(): List<V>\n```\n\n#### Inherited from\n\n[`Collection#toList()`](../collection/index#toList())\n\n#### Discussion\n\nThis is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.\n\n``` ts\nconst { Map, List } = require('immutable')\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\nList(myMap) // List [ [ \"a\", \"Apple\" ], [ \"b\", \"Banana\" ] ]\nmyMap.toList() // List [ \"Apple\", \"Banana\" ]run it\n```\n\n#### [toStack()](index#toStack())\n\nConverts this Collection to a Stack, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoStack(): Stack<V>\n```\n\n#### Inherited from\n\n[`Collection#toStack()`](../collection/index#toStack())\n\n#### Discussion\n\nNote: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.\n\n### Iterators\n\n#### [keys()](index#keys())\n\nAn iterator of this [`Collection`](../collection/index)'s keys.\n\n``` ts\nkeys(): IterableIterator<K>\n```\n\n#### Inherited from\n\n[`Collection#keys()`](../collection/index#keys())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.\n\n#### [values()](index#values())\n\nAn iterator of this [`Collection`](../collection/index)'s values.\n\n``` ts\nvalues(): IterableIterator<V>\n```\n\n#### Inherited from\n\n[`Collection#values()`](../collection/index#values())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.\n\n#### [entries()](index#entries())\n\nAn iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.\n\n``` ts\nentries(): IterableIterator<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection#entries()`](../collection/index#entries())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.\n\n### Collections (Seq)\n\n#### [keySeq()](index#keySeq())\n\nReturns a new Seq.Indexed of the keys of this Collection, discarding values.\n\n``` ts\nkeySeq(): Seq.Indexed<K>\n```\n\n#### Inherited from\n\n[`Collection#keySeq()`](../collection/index#keySeq())\n\n#### [valueSeq()](index#valueSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\nvalueSeq(): Seq.Indexed<V>\n```\n\n#### Inherited from\n\n[`Collection#valueSeq()`](../collection/index#valueSeq())\n\n#### [entrySeq()](index#entrySeq())\n\nReturns a new Seq.Indexed of \\[key, value\\] tuples.\n\n``` ts\nentrySeq(): Seq.Indexed<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection#entrySeq()`](../collection/index#entrySeq())\n\n### Sequence algorithms\n\n#### [filterNot()](index#filterNot())\n\nReturns a new Collection of the same type with only the entries for which the `predicate` function returns false.\n\n``` ts\nfilterNot(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#filterNot()`](../collection/index#filterNot())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }run it\n```\n\nNote: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.\n\n#### [reverse()](index#reverse())\n\nReturns a new Collection of the same type in reverse order.\n\n``` ts\nreverse(): this\n```\n\n#### Inherited from\n\n[`Collection#reverse()`](../collection/index#reverse())\n\n#### [sort()](index#sort())\n\nReturns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.\n\n``` ts\nsort(comparator?: (valueA: V, valueB: V) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sort()`](../collection/index#sort())\n\n#### Discussion\n\nIf a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n- Returns `0` if the elements should not be swapped.\n- Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n- Returns `1` (or any positive number) if `valueA` comes after `valueB`\n- Is pure, i.e. it must always return the same value for the same pair of values.\n\nWhen sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n``` ts\nconst { Map } = require('immutable')\nMap({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// OrderedMap { \"a\": 1, \"b\": 2, \"c\": 3 }run it\n```\n\nNote: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [sortBy()](index#sortBy())\n\nLike [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:\n\n``` ts\nsortBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sortBy()`](../collection/index#sortBy())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst beattles = Map({\n  John: { name: \"Lennon\" },\n  Paul: { name: \"McCartney\" },\n  George: { name: \"Harrison\" },\n  Ringo: { name: \"Starr\" },\n});\nbeattles.sortBy(member => member.name);run it\n```\n\nNote: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [groupBy()](index#groupBy())\n\nReturns a [`Collection.Keyed`](index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.\n\n``` ts\ngroupBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<K, V>>\n```\n\n#### Inherited from\n\n[`Collection#groupBy()`](../collection/index#groupBy())\n\n#### Discussion\n\nNote: This is always an eager operation.\n\n``` ts\nconst { List, Map } = require('immutable')\nconst listOfMaps = List([\n  Map({ v: 0 }),\n  Map({ v: 1 }),\n  Map({ v: 1 }),\n  Map({ v: 0 }),\n  Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ Map{ \"v\": 0 }, Map { \"v\": 0 } ],\n//   1: List [ Map{ \"v\": 1 }, Map { \"v\": 1 } ],\n//   2: List [ Map{ \"v\": 2 } ],\n// }run it\n```\n\n### Side effects\n\n#### [forEach()](index#forEach())\n\nThe `sideEffect` is executed for every entry in the Collection.\n\n``` ts\nforEach(sideEffect: (value: V, key: K, iter: this) => unknown,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#forEach()`](../collection/index#forEach())\n\n#### Discussion\n\nUnlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).\n\n### Creating subsets\n\n#### [slice()](index#slice())\n\nReturns a new Collection of the same type representing a portion of this Collection from start up to but not including end.\n\n``` ts\nslice(begin?: number, end?: number): this\n```\n\n#### Inherited from\n\n[`Collection#slice()`](../collection/index#slice())\n\n#### Discussion\n\nIf begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.\n\nIf the requested slice is equivalent to the current Collection, then it will return itself.\n\n#### [rest()](index#rest())\n\nReturns a new Collection of the same type containing all entries except the first.\n\n``` ts\nrest(): this\n```\n\n#### Inherited from\n\n[`Collection#rest()`](../collection/index#rest())\n\n#### [butLast()](index#butLast())\n\nReturns a new Collection of the same type containing all entries except the last.\n\n``` ts\nbutLast(): this\n```\n\n#### Inherited from\n\n[`Collection#butLast()`](../collection/index#butLast())\n\n#### [skip()](index#skip())\n\nReturns a new Collection of the same type which excludes the first `amount` entries from this Collection.\n\n``` ts\nskip(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skip()`](../collection/index#skip())\n\n#### [skipLast()](index#skipLast())\n\nReturns a new Collection of the same type which excludes the last `amount` entries from this Collection.\n\n``` ts\nskipLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skipLast()`](../collection/index#skipLast())\n\n#### [skipWhile()](index#skipWhile())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns false.\n\n``` ts\nskipWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipWhile()`](../collection/index#skipWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipWhile(x => x.match(/g/))\n// List [ \"cat\", \"hat\", \"god\" ]run it\n```\n\n#### [skipUntil()](index#skipUntil())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns true.\n\n``` ts\nskipUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipUntil()`](../collection/index#skipUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipUntil(x => x.match(/hat/))\n// List [ \"hat\", \"god\" ]run it\n```\n\n#### [take()](index#take())\n\nReturns a new Collection of the same type which includes the first `amount` entries from this Collection.\n\n``` ts\ntake(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#take()`](../collection/index#take())\n\n#### [takeLast()](index#takeLast())\n\nReturns a new Collection of the same type which includes the last `amount` entries from this Collection.\n\n``` ts\ntakeLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#takeLast()`](../collection/index#takeLast())\n\n#### [takeWhile()](index#takeWhile())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.\n\n``` ts\ntakeWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeWhile()`](../collection/index#takeWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeWhile(x => x.match(/o/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n#### [takeUntil()](index#takeUntil())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.\n\n``` ts\ntakeUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeUntil()`](../collection/index#takeUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeUntil(x => x.match(/at/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n### Combination\n\n#### [flatten()](index#flatten())\n\n``` ts\nflatten(depth?: number): Collection<unknown, unknown>\nflatten(shallow?: boolean): Collection<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection#flatten()`](../collection/index#flatten())\n\n### Reducing a value\n\n#### [reduce()](index#reduce())\n\n``` ts\nreduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R\nreduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduce()`](../collection/index#reduce())\n\n#### [reduceRight()](index#reduceRight())\n\n``` ts\nreduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R\nreduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduceRight()`](../collection/index#reduceRight())\n\n#### [every()](index#every())\n\nTrue if `predicate` returns true for all entries in the Collection.\n\n``` ts\nevery(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#every()`](../collection/index#every())\n\n#### [some()](index#some())\n\nTrue if `predicate` returns true for any entry in the Collection.\n\n``` ts\nsome(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#some()`](../collection/index#some())\n\n#### [join()](index#join())\n\nJoins values together as a string, inserting a separator between each. The default separator is `\",\"`.\n\n``` ts\njoin(separator?: string): string\n```\n\n#### Inherited from\n\n[`Collection#join()`](../collection/index#join())\n\n#### [isEmpty()](index#isEmpty())\n\nReturns true if this Collection includes no values.\n\n``` ts\nisEmpty(): boolean\n```\n\n#### Inherited from\n\n[`Collection#isEmpty()`](../collection/index#isEmpty())\n\n#### Discussion\n\nFor some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.\n\n#### [count()](index#count())\n\n``` ts\ncount(): number\ncount(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#count()`](../collection/index#count())\n\n#### [countBy()](index#countBy())\n\nReturns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.\n\n``` ts\ncountBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Map<G, number>\n```\n\n#### Inherited from\n\n[`Collection#countBy()`](../collection/index#countBy())\n\n#### Discussion\n\nNote: This is not a lazy operation.\n\n### Search for value\n\n#### [find()](index#find())\n\nReturns the first value for which the `predicate` returns true.\n\n``` ts\nfind(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#find()`](../collection/index#find())\n\n#### [findLast()](index#findLast())\n\nReturns the last value for which the `predicate` returns true.\n\n``` ts\nfindLast(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLast()`](../collection/index#findLast())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findEntry()](index#findEntry())\n\nReturns the first \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findEntry()`](../collection/index#findEntry())\n\n#### [findLastEntry()](index#findLastEntry())\n\nReturns the last \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindLastEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastEntry()`](../collection/index#findLastEntry())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findKey()](index#findKey())\n\nReturns the key for which the `predicate` returns true.\n\n``` ts\nfindKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#findKey()`](../collection/index#findKey())\n\n#### [findLastKey()](index#findLastKey())\n\nReturns the last key for which the `predicate` returns true.\n\n``` ts\nfindLastKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastKey()`](../collection/index#findLastKey())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [keyOf()](index#keyOf())\n\nReturns the key associated with the search value, or undefined.\n\n``` ts\nkeyOf(searchValue: V): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#keyOf()`](../collection/index#keyOf())\n\n#### [lastKeyOf()](index#lastKeyOf())\n\nReturns the last key associated with the search value, or undefined.\n\n``` ts\nlastKeyOf(searchValue: V): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#lastKeyOf()`](../collection/index#lastKeyOf())\n\n#### [max()](index#max())\n\nReturns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmax(comparator?: (valueA: V, valueB: V) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#max()`](../collection/index#max())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [maxBy()](index#maxBy())\n\nLike [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nmaxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#maxBy()`](../collection/index#maxBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it\n```\n\n#### [min()](index#min())\n\nReturns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmin(comparator?: (valueA: V, valueB: V) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#min()`](../collection/index#min())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [minBy()](index#minBy())\n\nLike [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nminBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#minBy()`](../collection/index#minBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it\n```\n\n### Comparison\n\n#### [isSubset()](index#isSubset())\n\nTrue if `iter` includes every value in this Collection.\n\n``` ts\nisSubset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSubset()`](../collection/index#isSubset())\n\n#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Collection.Keyed/](https://immutable-js.com/docs/v4.2.1/Collection.Keyed/)"
- name: Collection.Keyed.[Symbol.iterator]()
  id: collection.keyed/index#[Symbol.iterator]()
  summary: null
  belongs_to: Collection.Keyed
  description: |-
    #### [\[Symbol.iterator\]()](index#%5BSymbol.iterator%5D())

    ``` ts
    [Symbol.iterator](): IterableIterator<[K, V]>
    ```

    #### Overrides

    [`Collection#[Symbol.iterator]()`](../collection/index#%5BSymbol.iterator%5D())

    ### Value equality
- name: Collection.Keyed.butLast()
  id: collection.keyed/index#butLast()
  summary: Returns a new Collection of the same type containing all entries except the last
  belongs_to: Collection.Keyed
  description: |-
    #### [butLast()](index#butLast())

    Returns a new Collection of the same type containing all entries except the last.

    ``` ts
    butLast(): this
    ```

    #### Inherited from

    [`Collection#butLast()`](../collection/index#butLast())
- name: Collection.Keyed.Collection.Keyed()
  id: collection.keyed/index#Collection.Keyed()
  summary: null
  belongs_to: Collection.Keyed
  description: |-
    #### [Collection.Keyed()](index#Collection.Keyed())

    ``` ts
    Collection.Keyed<K, V>(collection?: Iterable<[K, V]>): Collection.Keyed<K, V>
    Collection.Keyed<V>(obj: {[key: string]: V}): Collection.Keyed<string, V>
    ```

    ### Conversion to JavaScript types
- name: Collection.Keyed.concat()
  id: collection.keyed/index#concat()
  summary: null
  belongs_to: Collection.Keyed
  description: |-
    #### [concat()](index#concat())

    ``` ts
    concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Collection.Keyed<K | KC, V | VC>
    concat<C>(...collections: Array<{[key: string]: C}>): Collection.Keyed<K | string, V | C>
    ```

    #### Overrides

    [`Collection#concat()`](../collection/index#concat())
- name: Collection.Keyed.count()
  id: collection.keyed/index#count()
  summary: null
  belongs_to: Collection.Keyed
  description: |-
    #### [count()](index#count())

    ``` ts
    count(): number
    count(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#count()`](../collection/index#count())
- name: Collection.Keyed.countBy()
  id: collection.keyed/index#countBy()
  summary: Returns a Seq.Keyed of counts, grouped by the return value of the grouper function
  belongs_to: Collection.Keyed
  description: |-
    #### [countBy()](index#countBy())

    Returns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.

    ``` ts
    countBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Map<G, number>
    ```

    #### Inherited from

    [`Collection#countBy()`](../collection/index#countBy())

    #### Discussion

    Note: This is not a lazy operation.

    ### Search for value
- name: Collection.Keyed.entries()
  id: collection.keyed/index#entries()
  summary: An iterator of this Collection's entries as [ key, value ] tuples
  belongs_to: Collection.Keyed
  description: |-
    #### [entries()](index#entries())

    An iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.

    ``` ts
    entries(): IterableIterator<[K, V]>
    ```

    #### Inherited from

    [`Collection#entries()`](../collection/index#entries())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.

    ### Collections (Seq)
- name: Collection.Keyed.entrySeq()
  id: collection.keyed/index#entrySeq()
  summary: Returns a new Seq.Indexed of [key, value] tuples
  belongs_to: Collection.Keyed
  description: |-
    #### [entrySeq()](index#entrySeq())

    Returns a new Seq.Indexed of \[key, value\] tuples.

    ``` ts
    entrySeq(): Seq.Indexed<[K, V]>
    ```

    #### Inherited from

    [`Collection#entrySeq()`](../collection/index#entrySeq())

    ### Sequence algorithms
- name: Collection.Keyed.equals()
  id: collection.keyed/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: Collection.Keyed
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Inherited from

    [`Collection#equals()`](../collection/index#equals())

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: Collection.Keyed.every()
  id: collection.keyed/index#every()
  summary: True if predicate returns true for all entries in the Collection
  belongs_to: Collection.Keyed
  description: |-
    #### [every()](index#every())

    True if `predicate` returns true for all entries in the Collection.

    ``` ts
    every(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#every()`](../collection/index#every())
- name: Collection.Keyed.filter()
  id: collection.keyed/index#filter()
  summary: null
  belongs_to: Collection.Keyed
  description: |-
    #### [filter()](index#filter())

    ``` ts
    filter<F>(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): Collection.Keyed<K, F>
    filter(predicate: (value: V, key: K, iter: this) => unknown,context?: unknown): this
    ```

    #### Overrides

    [`Collection#filter()`](../collection/index#filter())
- name: Collection.Keyed.filterNot()
  id: collection.keyed/index#filterNot()
  summary: Returns a new Collection of the same type with only the entries for which the predicate function returns false
  belongs_to: Collection.Keyed
  description: |-
    #### [filterNot()](index#filterNot())

    Returns a new Collection of the same type with only the entries for which the `predicate` function returns false.

    ``` ts
    filterNot(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#filterNot()`](../collection/index#filterNot())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
    // Map { "a": 1, "c": 3 }run it
    ```

    Note: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.
- name: Collection.Keyed.find()
  id: collection.keyed/index#find()
  summary: Returns the first value for which the predicate returns true
  belongs_to: Collection.Keyed
  description: |-
    #### [find()](index#find())

    Returns the first value for which the `predicate` returns true.

    ``` ts
    find(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined
    ```

    #### Inherited from

    [`Collection#find()`](../collection/index#find())
- name: Collection.Keyed.findEntry()
  id: collection.keyed/index#findEntry()
  summary: Returns the first [key, value] entry for which the predicate returns true
  belongs_to: Collection.Keyed
  description: |-
    #### [findEntry()](index#findEntry())

    Returns the first \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
    ```

    #### Inherited from

    [`Collection#findEntry()`](../collection/index#findEntry())
- name: Collection.Keyed.findKey()
  id: collection.keyed/index#findKey()
  summary: Returns the key for which the predicate returns true
  belongs_to: Collection.Keyed
  description: |-
    #### [findKey()](index#findKey())

    Returns the key for which the `predicate` returns true.

    ``` ts
    findKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined
    ```

    #### Inherited from

    [`Collection#findKey()`](../collection/index#findKey())
- name: Collection.Keyed.findLast()
  id: collection.keyed/index#findLast()
  summary: Returns the last value for which the predicate returns true
  belongs_to: Collection.Keyed
  description: |-
    #### [findLast()](index#findLast())

    Returns the last value for which the `predicate` returns true.

    ``` ts
    findLast(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined
    ```

    #### Inherited from

    [`Collection#findLast()`](../collection/index#findLast())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Collection.Keyed.findLastEntry()
  id: collection.keyed/index#findLastEntry()
  summary: Returns the last [key, value] entry for which the predicate returns true
  belongs_to: Collection.Keyed
  description: |-
    #### [findLastEntry()](index#findLastEntry())

    Returns the last \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findLastEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
    ```

    #### Inherited from

    [`Collection#findLastEntry()`](../collection/index#findLastEntry())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Collection.Keyed.findLastKey()
  id: collection.keyed/index#findLastKey()
  summary: Returns the last key for which the predicate returns true
  belongs_to: Collection.Keyed
  description: |-
    #### [findLastKey()](index#findLastKey())

    Returns the last key for which the `predicate` returns true.

    ``` ts
    findLastKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined
    ```

    #### Inherited from

    [`Collection#findLastKey()`](../collection/index#findLastKey())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Collection.Keyed.first()
  id: collection.keyed/index#first()
  summary: In case the Collection is not empty returns the first element of the Collection
  belongs_to: Collection.Keyed
  description: |-
    #### [first()](index#first())

    In case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    first<NSV>(notSetValue?: NSV): V | NSV
    ```

    #### Inherited from

    [`Collection#first()`](../collection/index#first())
- name: Collection.Keyed.flatMap()
  id: collection.keyed/index#flatMap()
  summary: Flat-maps the Collection, returning a Collection of the same type
  belongs_to: Collection.Keyed
  description: |-
    #### [flatMap()](index#flatMap())

    Flat-maps the Collection, returning a Collection of the same type.

    ``` ts
    flatMap<KM, VM>(mapper: (value: V, key: K, iter: this) => Iterable<[KM, VM]>,context?: unknown): Collection.Keyed<KM, VM>
    ```

    #### Overrides

    [`Collection#flatMap()`](../collection/index#flatMap())

    #### Discussion

    Similar to `collection.map(...).flatten(true)`.
- name: Collection.Keyed.flatten()
  id: collection.keyed/index#flatten()
  summary: null
  belongs_to: Collection.Keyed
  description: |-
    #### [flatten()](index#flatten())

    ``` ts
    flatten(depth?: number): Collection<unknown, unknown>
    flatten(shallow?: boolean): Collection<unknown, unknown>
    ```

    #### Inherited from

    [`Collection#flatten()`](../collection/index#flatten())

    ### Reducing a value
- name: Collection.Keyed.flip()
  id: collection.keyed/index#flip()
  summary: Returns a new Collection.Keyed of the same type where the keys and values have been flipped
  belongs_to: Collection.Keyed
  description: |-
    #### [flip()](index#flip())

    Returns a new Collection.Keyed of the same type where the keys and values have been flipped.

    ``` ts
    flip(): Collection.Keyed<V, K>
    ```

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 'z', b: 'y' }).flip()
    // Map { "z": "a", "y": "b" }run it
    ```
- name: Collection.Keyed.forEach()
  id: collection.keyed/index#forEach()
  summary: The sideEffect is executed for every entry in the Collection
  belongs_to: Collection.Keyed
  description: |-
    #### [forEach()](index#forEach())

    The `sideEffect` is executed for every entry in the Collection.

    ``` ts
    forEach(sideEffect: (value: V, key: K, iter: this) => unknown,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#forEach()`](../collection/index#forEach())

    #### Discussion

    Unlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).

    ### Creating subsets
- name: Collection.Keyed.get()
  id: collection.keyed/index#get()
  summary: null
  belongs_to: Collection.Keyed
  description: |-
    #### [get()](index#get())

    ``` ts
    get<NSV>(key: K, notSetValue: NSV): V | NSV
    get(key: K): V | undefined
    ```

    #### Inherited from

    [`Collection#get()`](../collection/index#get())
- name: Collection.Keyed.getIn()
  id: collection.keyed/index#getIn()
  summary: Returns the value found by following a path of keys or indices through nested Collections
  belongs_to: Collection.Keyed
  description: |-
    #### [getIn()](index#getIn())

    Returns the value found by following a path of keys or indices through nested Collections.

    ``` ts
    getIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown
    ```

    #### Inherited from

    [`Collection#getIn()`](../collection/index#getIn())

    #### Discussion

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: [ { y: 123 } ] });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```
- name: Collection.Keyed.groupBy()
  id: collection.keyed/index#groupBy()
  summary: Returns a Collection.Keyed of Collection.Keyeds, grouped by the return value of the grouper function
  belongs_to: Collection.Keyed
  description: |-
    #### [groupBy()](index#groupBy())

    Returns a [`Collection.Keyed`](index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.

    ``` ts
    groupBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<K, V>>
    ```

    #### Inherited from

    [`Collection#groupBy()`](../collection/index#groupBy())

    #### Discussion

    Note: This is always an eager operation.

    ``` ts
    const { List, Map } = require('immutable')
    const listOfMaps = List([
      Map({ v: 0 }),
      Map({ v: 1 }),
      Map({ v: 1 }),
      Map({ v: 0 }),
      Map({ v: 2 })
    ])
    const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
    // Map {
    //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
    //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
    //   2: List [ Map{ "v": 2 } ],
    // }run it
    ```

    ### Side effects
- name: Collection.Keyed.has()
  id: collection.keyed/index#has()
  summary: null
  belongs_to: Collection.Keyed
  description: |-
    #### [has()](index#has())

    True if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    has(key: K): boolean
    ```

    #### Inherited from

    [`Collection#has()`](../collection/index#has())
- name: Collection.Keyed.hashCode()
  id: collection.keyed/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: Collection.Keyed
  description: |-
    #### [hashCode()](index#hashCode())

    Computes and returns the hashed identity for this Collection.

    ``` ts
    hashCode(): number
    ```

    #### Inherited from

    [`Collection#hashCode()`](../collection/index#hashCode())

    #### Discussion

    The [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.

    ``` ts
    const a = List([ 1, 2, 3 ]);
    const b = List([ 1, 2, 3 ]);
    assert.notStrictEqual(a, b); // different instances
    const set = Set([ a ]);
    assert.equal(set.has(b), true);run it
    ```

    If two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.

    ### Reading values
- name: Collection.Keyed.hasIn()
  id: collection.keyed/index#hasIn()
  summary: True if the result of following a path of keys or indices through nested Collections results in a set value
  belongs_to: Collection.Keyed
  description: |-
    #### [hasIn()](index#hasIn())

    True if the result of following a path of keys or indices through nested Collections results in a set value.

    ``` ts
    hasIn(searchKeyPath: Iterable<unknown>): boolean
    ```

    #### Inherited from

    [`Collection#hasIn()`](../collection/index#hasIn())

    ### Persistent changes
- name: Collection.Keyed.includes()
  id: collection.keyed/index#includes()
  summary: null
  belongs_to: Collection.Keyed
  description: |-
    #### [includes()](index#includes())

    True if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    includes(value: V): boolean
    ```

    #### Inherited from

    [`Collection#includes()`](../collection/index#includes())

    #### alias

    `contains()`
- name: Collection.Keyed.isEmpty()
  id: collection.keyed/index#isEmpty()
  summary: Returns true if this Collection includes no values
  belongs_to: Collection.Keyed
  description: |-
    #### [isEmpty()](index#isEmpty())

    Returns true if this Collection includes no values.

    ``` ts
    isEmpty(): boolean
    ```

    #### Inherited from

    [`Collection#isEmpty()`](../collection/index#isEmpty())

    #### Discussion

    For some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.
- name: Collection.Keyed.isSubset()
  id: collection.keyed/index#isSubset()
  summary: True if iter includes every value in this Collection
  belongs_to: Collection.Keyed
  description: |-
    #### [isSubset()](index#isSubset())

    True if `iter` includes every value in this Collection.

    ``` ts
    isSubset(iter: Iterable<V>): boolean
    ```

    #### Inherited from

    [`Collection#isSubset()`](../collection/index#isSubset())
- name: Collection.Keyed.isSuperset()
  id: collection.keyed/index#isSuperset()
  summary: True if this Collection includes every value in iter
  belongs_to: Collection.Keyed
  description: "#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Collection.Keyed/](https://immutable-js.com/docs/v4.2.1/Collection.Keyed/)"
- name: Collection.Keyed.join()
  id: collection.keyed/index#join()
  summary: Joins values together as a string, inserting a separator between each
  belongs_to: Collection.Keyed
  description: |-
    #### [join()](index#join())

    Joins values together as a string, inserting a separator between each. The default separator is `","`.

    ``` ts
    join(separator?: string): string
    ```

    #### Inherited from

    [`Collection#join()`](../collection/index#join())
- name: Collection.Keyed.keyOf()
  id: collection.keyed/index#keyOf()
  summary: Returns the key associated with the search value, or undefined
  belongs_to: Collection.Keyed
  description: |-
    #### [keyOf()](index#keyOf())

    Returns the key associated with the search value, or undefined.

    ``` ts
    keyOf(searchValue: V): K | undefined
    ```

    #### Inherited from

    [`Collection#keyOf()`](../collection/index#keyOf())
- name: Collection.Keyed.keys()
  id: collection.keyed/index#keys()
  summary: An iterator of this Collection's keys
  belongs_to: Collection.Keyed
  description: |-
    #### [keys()](index#keys())

    An iterator of this [`Collection`](../collection/index)'s keys.

    ``` ts
    keys(): IterableIterator<K>
    ```

    #### Inherited from

    [`Collection#keys()`](../collection/index#keys())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.
- name: Collection.Keyed.keySeq()
  id: collection.keyed/index#keySeq()
  summary: Returns a new Seq.Indexed of the keys of this Collection, discarding values
  belongs_to: Collection.Keyed
  description: |-
    #### [keySeq()](index#keySeq())

    Returns a new Seq.Indexed of the keys of this Collection, discarding values.

    ``` ts
    keySeq(): Seq.Indexed<K>
    ```

    #### Inherited from

    [`Collection#keySeq()`](../collection/index#keySeq())
- name: Collection.Keyed.last()
  id: collection.keyed/index#last()
  summary: In case the Collection is not empty returns the last element of the Collection
  belongs_to: Collection.Keyed
  description: |-
    #### [last()](index#last())

    In case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    last<NSV>(notSetValue?: NSV): V | NSV
    ```

    #### Inherited from

    [`Collection#last()`](../collection/index#last())

    ### Reading deep values
- name: Collection.Keyed.lastKeyOf()
  id: collection.keyed/index#lastKeyOf()
  summary: Returns the last key associated with the search value, or undefined
  belongs_to: Collection.Keyed
  description: |-
    #### [lastKeyOf()](index#lastKeyOf())

    Returns the last key associated with the search value, or undefined.

    ``` ts
    lastKeyOf(searchValue: V): K | undefined
    ```

    #### Inherited from

    [`Collection#lastKeyOf()`](../collection/index#lastKeyOf())
- name: Collection.Keyed.map()
  id: collection.keyed/index#map()
  summary: Returns a new Collection.Keyed with values passed through a mapper function
  belongs_to: Collection.Keyed
  description: |-
    #### [map()](index#map())

    Returns a new Collection.Keyed with values passed through a `mapper` function.

    ``` ts
    map<M>(mapper: (value: V, key: K, iter: this) => M,context?: unknown): Collection.Keyed<K, M>
    ```

    #### Overrides

    [`Collection#map()`](../collection/index#map())

    #### Example

    ``` ts
    const { Collection } = require('immutable')
    Collection.Keyed({ a: 1, b: 2 }).map(x => 10 * x)
    // Seq { "a": 10, "b": 20 }
    ```

    Note: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.
- name: Collection.Keyed.mapEntries()
  id: collection.keyed/index#mapEntries()
  summary: Returns a new Collection.Keyed of the same type with entries ([key, value] tuples) passed through a mapper function
  belongs_to: Collection.Keyed
  description: |-
    #### [mapEntries()](index#mapEntries())

    Returns a new Collection.Keyed of the same type with entries (\[key, value\] tuples) passed through a `mapper` function.

    ``` ts
    mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM] | undefined,context?: unknown): Collection.Keyed<KM, VM>
    ```

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2 })
      .mapEntries(([ k, v ]) => [ k.toUpperCase(), v * 2 ])
    // Map { "A": 2, "B": 4 }run it
    ```

    Note: [`mapEntries()`](index#mapEntries()) always returns a new instance, even if it produced the same entry at every step.

    If the mapper function returns `undefined`, then the entry will be filtered
- name: Collection.Keyed.mapKeys()
  id: collection.keyed/index#mapKeys()
  summary: Returns a new Collection.Keyed of the same type with keys passed through a mapper function
  belongs_to: Collection.Keyed
  description: |-
    #### [mapKeys()](index#mapKeys())

    Returns a new Collection.Keyed of the same type with keys passed through a `mapper` function.

    ``` ts
    mapKeys<M>(mapper: (key: K, value: V, iter: this) => M,context?: unknown): Collection.Keyed<M, V>
    ```

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2 }).mapKeys(x => x.toUpperCase())
    // Map { "A": 1, "B": 2 }run it
    ```

    Note: [`mapKeys()`](index#mapKeys()) always returns a new instance, even if it produced the same key at every step.
- name: Collection.Keyed.max()
  id: collection.keyed/index#max()
  summary: Returns the maximum value in this collection
  belongs_to: Collection.Keyed
  description: |-
    #### [max()](index#max())

    Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    max(comparator?: (valueA: V, valueB: V) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#max()`](../collection/index#max())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Collection.Keyed.maxBy()
  id: collection.keyed/index#maxBy()
  summary: null
  belongs_to: Collection.Keyed
  description: |-
    #### [maxBy()](index#maxBy())

    Like [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    maxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#maxBy()`](../collection/index#maxBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it
    ```
- name: Collection.Keyed.min()
  id: collection.keyed/index#min()
  summary: Returns the minimum value in this collection
  belongs_to: Collection.Keyed
  description: |-
    #### [min()](index#min())

    Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    min(comparator?: (valueA: V, valueB: V) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#min()`](../collection/index#min())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Collection.Keyed.minBy()
  id: collection.keyed/index#minBy()
  summary: null
  belongs_to: Collection.Keyed
  description: |-
    #### [minBy()](index#minBy())

    Like [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    minBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#minBy()`](../collection/index#minBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it
    ```

    ### Comparison
- name: Collection.Keyed.partition()
  id: collection.keyed/index#partition()
  summary: null
  belongs_to: Collection.Keyed
  description: |-
    #### [partition()](index#partition())

    ``` ts
    partition<F, C>(predicate: (this: C, value: V, key: K, iter: this) => boolean,context?: C): [Collection.Keyed<K, V>, Collection.Keyed<K, F>]
    partition<C>(predicate: (this: C, value: V, key: K, iter: this) => unknown,context?: C): [this, this]
    ```

    #### Overrides

    [`Collection#partition()`](../collection/index#partition())
- name: Collection.Keyed.reduce()
  id: collection.keyed/index#reduce()
  summary: null
  belongs_to: Collection.Keyed
  description: |-
    #### [reduce()](index#reduce())

    ``` ts
    reduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R
    reduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduce()`](../collection/index#reduce())
- name: Collection.Keyed.reduceRight()
  id: collection.keyed/index#reduceRight()
  summary: null
  belongs_to: Collection.Keyed
  description: |-
    #### [reduceRight()](index#reduceRight())

    ``` ts
    reduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R
    reduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduceRight()`](../collection/index#reduceRight())
- name: Collection.Keyed.rest()
  id: collection.keyed/index#rest()
  summary: Returns a new Collection of the same type containing all entries except the first
  belongs_to: Collection.Keyed
  description: |-
    #### [rest()](index#rest())

    Returns a new Collection of the same type containing all entries except the first.

    ``` ts
    rest(): this
    ```

    #### Inherited from

    [`Collection#rest()`](../collection/index#rest())
- name: Collection.Keyed.reverse()
  id: collection.keyed/index#reverse()
  summary: Returns a new Collection of the same type in reverse order
  belongs_to: Collection.Keyed
  description: |-
    #### [reverse()](index#reverse())

    Returns a new Collection of the same type in reverse order.

    ``` ts
    reverse(): this
    ```

    #### Inherited from

    [`Collection#reverse()`](../collection/index#reverse())
- name: Collection.Keyed.skip()
  id: collection.keyed/index#skip()
  summary: Returns a new Collection of the same type which excludes the first amount entries from this Collection
  belongs_to: Collection.Keyed
  description: |-
    #### [skip()](index#skip())

    Returns a new Collection of the same type which excludes the first `amount` entries from this Collection.

    ``` ts
    skip(amount: number): this
    ```

    #### Inherited from

    [`Collection#skip()`](../collection/index#skip())
- name: Collection.Keyed.skipLast()
  id: collection.keyed/index#skipLast()
  summary: Returns a new Collection of the same type which excludes the last amount entries from this Collection
  belongs_to: Collection.Keyed
  description: |-
    #### [skipLast()](index#skipLast())

    Returns a new Collection of the same type which excludes the last `amount` entries from this Collection.

    ``` ts
    skipLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#skipLast()`](../collection/index#skipLast())
- name: Collection.Keyed.skipUntil()
  id: collection.keyed/index#skipUntil()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns true
  belongs_to: Collection.Keyed
  description: |-
    #### [skipUntil()](index#skipUntil())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns true.

    ``` ts
    skipUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipUntil()`](../collection/index#skipUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipUntil(x => x.match(/hat/))
    // List [ "hat", "god" ]run it
    ```
- name: Collection.Keyed.skipWhile()
  id: collection.keyed/index#skipWhile()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns false
  belongs_to: Collection.Keyed
  description: |-
    #### [skipWhile()](index#skipWhile())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns false.

    ``` ts
    skipWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipWhile()`](../collection/index#skipWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipWhile(x => x.match(/g/))
    // List [ "cat", "hat", "god" ]run it
    ```
- name: Collection.Keyed.slice()
  id: collection.keyed/index#slice()
  summary: Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end
  belongs_to: Collection.Keyed
  description: |-
    #### [slice()](index#slice())

    Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.

    ``` ts
    slice(begin?: number, end?: number): this
    ```

    #### Inherited from

    [`Collection#slice()`](../collection/index#slice())

    #### Discussion

    If begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.

    If end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.

    If the requested slice is equivalent to the current Collection, then it will return itself.
- name: Collection.Keyed.some()
  id: collection.keyed/index#some()
  summary: True if predicate returns true for any entry in the Collection
  belongs_to: Collection.Keyed
  description: |-
    #### [some()](index#some())

    True if `predicate` returns true for any entry in the Collection.

    ``` ts
    some(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#some()`](../collection/index#some())
- name: Collection.Keyed.sort()
  id: collection.keyed/index#sort()
  summary: Returns a new Collection of the same type which includes the same entries, stably sorted by using a comparator
  belongs_to: Collection.Keyed
  description: |-
    #### [sort()](index#sort())

    Returns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.

    ``` ts
    sort(comparator?: (valueA: V, valueB: V) => number): this
    ```

    #### Inherited from

    [`Collection#sort()`](../collection/index#sort())

    #### Discussion

    If a `comparator` is not provided, a default comparator uses `<` and `>`.

    `comparator(valueA, valueB)`:

    - Returns `0` if the elements should not be swapped.
    - Returns `-1` (or any negative number) if `valueA` comes before `valueB`
    - Returns `1` (or any positive number) if `valueA` comes after `valueB`
    - Is pure, i.e. it must always return the same value for the same pair of values.

    When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.

    ``` ts
    const { Map } = require('immutable')
    Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
      if (a < b) { return -1; }
      if (a > b) { return 1; }
      if (a === b) { return 0; }
    });
    // OrderedMap { "a": 1, "b": 2, "c": 3 }run it
    ```

    Note: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Collection.Keyed.sortBy()
  id: collection.keyed/index#sortBy()
  summary: 'Note: sortBy() Always returns a new instance, even if the original was already sorted'
  belongs_to: Collection.Keyed
  description: |-
    #### [sortBy()](index#sortBy())

    Like [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:

    ``` ts
    sortBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this
    ```

    #### Inherited from

    [`Collection#sortBy()`](../collection/index#sortBy())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const beattles = Map({
      John: { name: "Lennon" },
      Paul: { name: "McCartney" },
      George: { name: "Harrison" },
      Ringo: { name: "Starr" },
    });
    beattles.sortBy(member => member.name);run it
    ```

    Note: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Collection.Keyed.take()
  id: collection.keyed/index#take()
  summary: Returns a new Collection of the same type which includes the first amount entries from this Collection
  belongs_to: Collection.Keyed
  description: |-
    #### [take()](index#take())

    Returns a new Collection of the same type which includes the first `amount` entries from this Collection.

    ``` ts
    take(amount: number): this
    ```

    #### Inherited from

    [`Collection#take()`](../collection/index#take())
- name: Collection.Keyed.takeLast()
  id: collection.keyed/index#takeLast()
  summary: Returns a new Collection of the same type which includes the last amount entries from this Collection
  belongs_to: Collection.Keyed
  description: |-
    #### [takeLast()](index#takeLast())

    Returns a new Collection of the same type which includes the last `amount` entries from this Collection.

    ``` ts
    takeLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#takeLast()`](../collection/index#takeLast())
- name: Collection.Keyed.takeUntil()
  id: collection.keyed/index#takeUntil()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns false
  belongs_to: Collection.Keyed
  description: |-
    #### [takeUntil()](index#takeUntil())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.

    ``` ts
    takeUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeUntil()`](../collection/index#takeUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeUntil(x => x.match(/at/))
    // List [ "dog", "frog" ]run it
    ```

    ### Combination
- name: Collection.Keyed.takeWhile()
  id: collection.keyed/index#takeWhile()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns true
  belongs_to: Collection.Keyed
  description: |-
    #### [takeWhile()](index#takeWhile())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.

    ``` ts
    takeWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeWhile()`](../collection/index#takeWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeWhile(x => x.match(/o/))
    // List [ "dog", "frog" ]run it
    ```
- name: Collection.Keyed.toArray()
  id: collection.keyed/index#toArray()
  summary: Shallowly converts this collection to an Array
  belongs_to: Collection.Keyed
  description: |-
    #### [toArray()](index#toArray())

    Shallowly converts this collection to an Array.

    ``` ts
    toArray(): Array<[K, V]>
    ```

    #### Overrides

    [`Collection#toArray()`](../collection/index#toArray())
- name: Collection.Keyed.toIndexedSeq()
  id: collection.keyed/index#toIndexedSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Collection.Keyed
  description: |-
    #### [toIndexedSeq()](index#toIndexedSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    toIndexedSeq(): Seq.Indexed<V>
    ```

    #### Inherited from

    [`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())
- name: Collection.Keyed.toJS()
  id: collection.keyed/index#toJS()
  summary: Deeply converts this Keyed collection to equivalent native JavaScript Object
  belongs_to: Collection.Keyed
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Keyed collection to equivalent native JavaScript Object.

    ``` ts
    toJS(): {[key: string]: DeepCopy<V>}
    ```

    #### Overrides

    [`Collection#toJS()`](../collection/index#toJS())

    #### Discussion

    Converts keys to Strings.
- name: Collection.Keyed.toJSON()
  id: collection.keyed/index#toJSON()
  summary: Shallowly converts this Keyed collection to equivalent native JavaScript Object
  belongs_to: Collection.Keyed
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Keyed collection to equivalent native JavaScript Object.

    ``` ts
    toJSON(): {[key: string]: V}
    ```

    #### Overrides

    [`Collection#toJSON()`](../collection/index#toJSON())

    #### Discussion

    Converts keys to Strings.
- name: Collection.Keyed.toKeyedSeq()
  id: collection.keyed/index#toKeyedSeq()
  summary: Returns a Seq.Keyed from this Collection where indices are treated as keys
  belongs_to: Collection.Keyed
  description: |-
    #### [toKeyedSeq()](index#toKeyedSeq())

    Returns a Seq.Keyed from this Collection where indices are treated as keys.

    ``` ts
    toKeyedSeq(): Seq.Keyed<K, V>
    ```

    #### Inherited from

    [`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())

    #### Discussion

    This is useful if you want to operate on an Collection.Indexed and preserve the \[index, value\] pairs.

    The returned Seq will have identical iteration order as this Collection.

    ``` ts
    const { Seq } = require('immutable')
    const indexedSeq = Seq([ 'A', 'B', 'C' ])
    // Seq [ "A", "B", "C" ]
    indexedSeq.filter(v => v === 'B')
    // Seq [ "B" ]
    const keyedSeq = indexedSeq.toKeyedSeq()
    // Seq { 0: "A", 1: "B", 2: "C" }
    keyedSeq.filter(v => v === 'B')
    // Seq { 1: "B" }run it
    ```
- name: Collection.Keyed.toList()
  id: collection.keyed/index#toList()
  summary: Converts this Collection to a List, discarding keys
  belongs_to: Collection.Keyed
  description: |-
    #### [toList()](index#toList())

    Converts this Collection to a List, discarding keys.

    ``` ts
    toList(): List<V>
    ```

    #### Inherited from

    [`Collection#toList()`](../collection/index#toList())

    #### Discussion

    This is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.

    ``` ts
    const { Map, List } = require('immutable')
    var myMap = Map({ a: 'Apple', b: 'Banana' })
    List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
    myMap.toList() // List [ "Apple", "Banana" ]run it
    ```
- name: Collection.Keyed.toMap()
  id: collection.keyed/index#toMap()
  summary: Converts this Collection to a Map, Throws if keys are not hashable
  belongs_to: Collection.Keyed
  description: |-
    #### [toMap()](index#toMap())

    Converts this Collection to a Map, Throws if keys are not hashable.

    ``` ts
    toMap(): Map<K, V>
    ```

    #### Inherited from

    [`Collection#toMap()`](../collection/index#toMap())

    #### Discussion

    Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Collection.Keyed.toObject()
  id: collection.keyed/index#toObject()
  summary: Shallowly converts this Collection to an Object
  belongs_to: Collection.Keyed
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Collection to an Object.

    ``` ts
    toObject(): {[key: string]: V}
    ```

    #### Inherited from

    [`Collection#toObject()`](../collection/index#toObject())

    #### Discussion

    Converts keys to Strings.

    ### Conversion to Seq
- name: Collection.Keyed.toOrderedMap()
  id: collection.keyed/index#toOrderedMap()
  summary: Converts this Collection to a Map, maintaining the order of iteration
  belongs_to: Collection.Keyed
  description: |-
    #### [toOrderedMap()](index#toOrderedMap())

    Converts this Collection to a Map, maintaining the order of iteration.

    ``` ts
    toOrderedMap(): OrderedMap<K, V>
    ```

    #### Inherited from

    [`Collection#toOrderedMap()`](../collection/index#toOrderedMap())

    #### Discussion

    Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Collection.Keyed.toOrderedSet()
  id: collection.keyed/index#toOrderedSet()
  summary: Converts this Collection to a Set, maintaining the order of iteration and discarding keys
  belongs_to: Collection.Keyed
  description: |-
    #### [toOrderedSet()](index#toOrderedSet())

    Converts this Collection to a Set, maintaining the order of iteration and discarding keys.

    ``` ts
    toOrderedSet(): OrderedSet<V>
    ```

    #### Inherited from

    [`Collection#toOrderedSet()`](../collection/index#toOrderedSet())

    #### Discussion

    Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.
- name: Collection.Keyed.toSeq()
  id: collection.keyed/index#toSeq()
  summary: Returns Seq.Keyed
  belongs_to: Collection.Keyed
  description: |-
    #### [toSeq()](index#toSeq())

    Returns Seq.Keyed.

    ``` ts
    toSeq(): Seq.Keyed<K, V>
    ```

    #### Overrides

    [`Collection#toSeq()`](../collection/index#toSeq())
- name: Collection.Keyed.toSet()
  id: collection.keyed/index#toSet()
  summary: Converts this Collection to a Set, discarding keys
  belongs_to: Collection.Keyed
  description: |-
    #### [toSet()](index#toSet())

    Converts this Collection to a Set, discarding keys. Throws if values are not hashable.

    ``` ts
    toSet(): Set<V>
    ```

    #### Inherited from

    [`Collection#toSet()`](../collection/index#toSet())

    #### Discussion

    Note: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.
- name: Collection.Keyed.toSetSeq()
  id: collection.keyed/index#toSetSeq()
  summary: Returns a Seq.Set of the values of this Collection, discarding keys
  belongs_to: Collection.Keyed
  description: |-
    #### [toSetSeq()](index#toSetSeq())

    Returns a Seq.Set of the values of this Collection, discarding keys.

    ``` ts
    toSetSeq(): Seq.Set<V>
    ```

    #### Inherited from

    [`Collection#toSetSeq()`](../collection/index#toSetSeq())

    ### Sequence functions
- name: Collection.Keyed.toStack()
  id: collection.keyed/index#toStack()
  summary: Converts this Collection to a Stack, discarding keys
  belongs_to: Collection.Keyed
  description: |-
    #### [toStack()](index#toStack())

    Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.

    ``` ts
    toStack(): Stack<V>
    ```

    #### Inherited from

    [`Collection#toStack()`](../collection/index#toStack())

    #### Discussion

    Note: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.

    ### Iterators
- name: Collection.Keyed.update()
  id: collection.keyed/index#update()
  summary: This can be very useful as a way to "chain" a normal function into a sequence of methods
  belongs_to: Collection.Keyed
  description: |-
    #### [update()](index#update())

    This can be very useful as a way to "chain" a normal function into a sequence of methods. RxJS calls this "let" and lodash calls it "thru".

    ``` ts
    update<R>(updater: (value: this) => R): R
    ```

    #### Inherited from

    [`Collection#update()`](../collection/index#update())

    #### Discussion

    For example, to sum a Seq after mapping and filtering:

    ``` ts
    const { Seq } = require('immutable')

    function sum(collection) {
      return collection.reduce((sum, x) => sum + x, 0)
    }
    Seq([ 1, 2, 3 ])
      .map(x => x + 1)
      .filter(x => x % 2 === 0)
      .update(sum)
    // 6run it
    ```

    ### Conversion to Collections
- name: Collection.Keyed.values()
  id: collection.keyed/index#values()
  summary: An iterator of this Collection's values
  belongs_to: Collection.Keyed
  description: |-
    #### [values()](index#values())

    An iterator of this [`Collection`](../collection/index)'s values.

    ``` ts
    values(): IterableIterator<V>
    ```

    #### Inherited from

    [`Collection#values()`](../collection/index#values())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.
- name: Collection.Keyed.valueSeq()
  id: collection.keyed/index#valueSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Collection.Keyed
  description: |-
    #### [valueSeq()](index#valueSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    valueSeq(): Seq.Indexed<V>
    ```

    #### Inherited from

    [`Collection#valueSeq()`](../collection/index#valueSeq())
- name: Collection.keyOf()
  id: collection/index#keyOf()
  summary: Returns the key associated with the search value, or undefined
  belongs_to: Collection
  description: |-
    #### [keyOf()](index#keyOf())

    Returns the key associated with the search value, or undefined.

    ``` ts
    keyOf(searchValue: V): K | undefined
    ```
- name: Collection.keys()
  id: collection/index#keys()
  summary: An iterator of this Collection's keys
  belongs_to: Collection
  description: |-
    #### [keys()](index#keys())

    An iterator of this [`Collection`](index)'s keys.

    ``` ts
    keys(): IterableIterator<K>
    ```

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.
- name: Collection.keySeq()
  id: collection/index#keySeq()
  summary: Returns a new Seq.Indexed of the keys of this Collection, discarding values
  belongs_to: Collection
  description: |-
    #### [keySeq()](index#keySeq())

    Returns a new Seq.Indexed of the keys of this Collection, discarding values.

    ``` ts
    keySeq(): Seq.Indexed<K>
    ```
- name: Collection.last()
  id: collection/index#last()
  summary: In case the Collection is not empty returns the last element of the Collection
  belongs_to: Collection
  description: |-
    #### [last()](index#last())

    In case the [`Collection`](index) is not empty returns the last element of the [`Collection`](index). In case the [`Collection`](index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    last<NSV>(notSetValue?: NSV): V | NSV
    ```

    ### Reading deep values
- name: Collection.lastKeyOf()
  id: collection/index#lastKeyOf()
  summary: Returns the last key associated with the search value, or undefined
  belongs_to: Collection
  description: |-
    #### [lastKeyOf()](index#lastKeyOf())

    Returns the last key associated with the search value, or undefined.

    ``` ts
    lastKeyOf(searchValue: V): K | undefined
    ```
- name: Collection.map()
  id: collection/index#map()
  summary: Returns a new Collection of the same type with values passed through a mapper function
  belongs_to: Collection
  description: |-
    #### [map()](index#map())

    Returns a new Collection of the same type with values passed through a `mapper` function.

    ``` ts
    map<M>(mapper: (value: V, key: K, iter: this) => M,context?: unknown): Collection<K, M>
    ```

    #### Discussion

    ``` ts
    const { Collection } = require('immutable')
    Collection({ a: 1, b: 2 }).map(x => 10 * x)
    // Seq { "a": 10, "b": 20 }run it
    ```

    Note: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.
- name: Collection.max()
  id: collection/index#max()
  summary: Returns the maximum value in this collection
  belongs_to: Collection
  description: |-
    #### [max()](index#max())

    Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    max(comparator?: (valueA: V, valueB: V) => number): V | undefined
    ```

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](index#sort()). If it is not provided, the default comparator is `>`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Collection.maxBy()
  id: collection/index#maxBy()
  summary: null
  belongs_to: Collection
  description: |-
    #### [maxBy()](index#maxBy())

    Like [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    maxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined
    ```

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it
    ```
- name: Collection.min()
  id: collection/index#min()
  summary: Returns the minimum value in this collection
  belongs_to: Collection
  description: |-
    #### [min()](index#min())

    Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    min(comparator?: (valueA: V, valueB: V) => number): V | undefined
    ```

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](index#sort()). If it is not provided, the default comparator is `<`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Collection.minBy()
  id: collection/index#minBy()
  summary: null
  belongs_to: Collection
  description: |-
    #### [minBy()](index#minBy())

    Like [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    minBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined
    ```

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it
    ```

    ### Comparison
- name: Collection.partition()
  id: collection/index#partition()
  summary: null
  belongs_to: Collection
  description: |-
    #### [partition()](index#partition())

    ``` ts
    partition<F, C>(predicate: (this: C, value: V, key: K, iter: this) => boolean,context?: C): [Collection<K, V>, Collection<K, F>]
    partition<C>(predicate: (this: C, value: V, key: K, iter: this) => unknown,context?: C): [this, this]
    ```
- name: Collection.reduce()
  id: collection/index#reduce()
  summary: null
  belongs_to: Collection
  description: |-
    #### [reduce()](index#reduce())

    ``` ts
    reduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R
    reduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R
    ```
- name: Collection.reduceRight()
  id: collection/index#reduceRight()
  summary: null
  belongs_to: Collection
  description: |-
    #### [reduceRight()](index#reduceRight())

    ``` ts
    reduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R
    reduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R
    ```
- name: Collection.rest()
  id: collection/index#rest()
  summary: Returns a new Collection of the same type containing all entries except the first
  belongs_to: Collection
  description: |-
    #### [rest()](index#rest())

    Returns a new Collection of the same type containing all entries except the first.

    ``` ts
    rest(): this
    ```
- name: Collection.reverse()
  id: collection/index#reverse()
  summary: Returns a new Collection of the same type in reverse order
  belongs_to: Collection
  description: |-
    #### [reverse()](index#reverse())

    Returns a new Collection of the same type in reverse order.

    ``` ts
    reverse(): this
    ```
- name: Collection.Set
  id: collection.set/index
  summary: Set Collections only represent values
  description: "# Collection.Set\n\nSet Collections only represent values. They have no associated keys or indices. Duplicate values are possible in the lazy [`Seq.Set`](../seq.set/index)s, however the concrete [`Set`](../set/index) Collection does not allow duplicate values.\n\n``` ts\ntype Collection.Set<T> extends Collection<T, T>\n```\n\n#### Discussion\n\nCollection methods on Collection.Set such as [`map`](index#map()) and [`forEach`](index#forEach()) will provide the value as both the first and second arguments to the provided function.\n\n``` ts\nconst { Collection } = require('immutable')\nconst seq = Collection.Set([ 'A', 'B', 'C' ])\n// Seq { \"A\", \"B\", \"C\" }\nseq.forEach((v, k) =>\n assert.equal(v, k)\n)\n```\n\n### Construction\n\n#### [Collection.Set()](index#Collection.Set())\n\nSimilar to [`Collection()`](../collection/index), but always returns a Collection.Set.\n\n``` ts\nCollection.Set<T>(collection?: Iterable<T> | ArrayLike<T>): Collection.Set<T>\n```\n\n#### Discussion\n\nNote: [`Collection.Set`](index) is a factory function and not a class, and does not use the `new` keyword during construction.\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Set collection to equivalent native JavaScript Array.\n\n``` ts\ntoJS(): Array<DeepCopy<T>>\n```\n\n#### Overrides\n\n[`Collection#toJS()`](../collection/index#toJS())\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Set collection to equivalent native JavaScript Array.\n\n``` ts\ntoJSON(): Array<T>\n```\n\n#### Overrides\n\n[`Collection#toJSON()`](../collection/index#toJSON())\n\n#### [toArray()](index#toArray())\n\nShallowly converts this collection to an Array.\n\n``` ts\ntoArray(): Array<T>\n```\n\n#### Overrides\n\n[`Collection#toArray()`](../collection/index#toArray())\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Collection to an Object.\n\n``` ts\ntoObject(): {[key: string]: T}\n```\n\n#### Inherited from\n\n[`Collection#toObject()`](../collection/index#toObject())\n\n#### Discussion\n\nConverts keys to Strings.\n\n### Conversion to Seq\n\n#### [toSeq()](index#toSeq())\n\nReturns Seq.Set.\n\n``` ts\ntoSeq(): Seq.Set<T>\n```\n\n#### Overrides\n\n[`Collection#toSeq()`](../collection/index#toSeq())\n\n#### [toKeyedSeq()](index#toKeyedSeq())\n\nReturns a Seq.Keyed from this Collection where indices are treated as keys.\n\n``` ts\ntoKeyedSeq(): Seq.Keyed<T, T>\n```\n\n#### Inherited from\n\n[`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())\n\n#### Discussion\n\nThis is useful if you want to operate on an Collection.Indexed and preserve the \\[index, value\\] pairs.\n\nThe returned Seq will have identical iteration order as this Collection.\n\n``` ts\nconst { Seq } = require('immutable')\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\n// Seq [ \"A\", \"B\", \"C\" ]\nindexedSeq.filter(v => v === 'B')\n// Seq [ \"B\" ]\nconst keyedSeq = indexedSeq.toKeyedSeq()\n// Seq { 0: \"A\", 1: \"B\", 2: \"C\" }\nkeyedSeq.filter(v => v === 'B')\n// Seq { 1: \"B\" }run it\n```\n\n#### [toIndexedSeq()](index#toIndexedSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\ntoIndexedSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())\n\n#### [toSetSeq()](index#toSetSeq())\n\nReturns a Seq.Set of the values of this Collection, discarding keys.\n\n``` ts\ntoSetSeq(): Seq.Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSetSeq()`](../collection/index#toSetSeq())\n\n### Sequence algorithms\n\n#### [concat()](index#concat())\n\nReturns a new Collection with other collections concatenated to this one.\n\n``` ts\nconcat<U>(...collections: Array<Iterable<U>>): Collection.Set<T | U>\n```\n\n#### Overrides\n\n[`Collection#concat()`](../collection/index#concat())\n\n#### [map()](index#map())\n\nReturns a new Collection.Set with values passed through a `mapper` function.\n\n``` ts\nmap<M>(mapper: (value: T, key: T, iter: this) => M,context?: unknown): Collection.Set<M>\n```\n\n#### Overrides\n\n[`Collection#map()`](../collection/index#map())\n\n#### Example\n\n``` ts\nCollection.Set([ 1, 2 ]).map(x => 10 * x)\n// Seq { 1, 2 }\n```\n\nNote: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.\n\n#### [flatMap()](index#flatMap())\n\nFlat-maps the Collection, returning a Collection of the same type.\n\n``` ts\nflatMap<M>(mapper: (value: T, key: T, iter: this) => Iterable<M>,context?: unknown): Collection.Set<M>\n```\n\n#### Overrides\n\n[`Collection#flatMap()`](../collection/index#flatMap())\n\n#### Discussion\n\nSimilar to `collection.map(...).flatten(true)`.\n\n#### [filter()](index#filter())\n\n``` ts\nfilter<F>(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): Collection.Set<F>\nfilter(predicate: (value: T, key: T, iter: this) => unknown,context?: unknown): this\n```\n\n#### Overrides\n\n[`Collection#filter()`](../collection/index#filter())\n\n#### [partition()](index#partition())\n\n``` ts\npartition<F, C>(predicate: (this: C, value: T, key: T, iter: this) => boolean,context?: C): [Collection.Set<T>, Collection.Set<F>]\npartition<C>(predicate: (this: C, value: T, key: T, iter: this) => unknown,context?: C): [this, this]\n```\n\n#### Overrides\n\n[`Collection#partition()`](../collection/index#partition())\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<T>\n```\n\n#### Overrides\n\n[`Collection#[Symbol.iterator]()`](../collection/index#%5BSymbol.iterator%5D())\n\n#### [filterNot()](index#filterNot())\n\nReturns a new Collection of the same type with only the entries for which the `predicate` function returns false.\n\n``` ts\nfilterNot(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#filterNot()`](../collection/index#filterNot())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }run it\n```\n\nNote: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.\n\n#### [reverse()](index#reverse())\n\nReturns a new Collection of the same type in reverse order.\n\n``` ts\nreverse(): this\n```\n\n#### Inherited from\n\n[`Collection#reverse()`](../collection/index#reverse())\n\n#### [sort()](index#sort())\n\nReturns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.\n\n``` ts\nsort(comparator?: (valueA: T, valueB: T) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sort()`](../collection/index#sort())\n\n#### Discussion\n\nIf a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n- Returns `0` if the elements should not be swapped.\n- Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n- Returns `1` (or any positive number) if `valueA` comes after `valueB`\n- Is pure, i.e. it must always return the same value for the same pair of values.\n\nWhen sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n``` ts\nconst { Map } = require('immutable')\nMap({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// OrderedMap { \"a\": 1, \"b\": 2, \"c\": 3 }run it\n```\n\nNote: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [sortBy()](index#sortBy())\n\nLike [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:\n\n``` ts\nsortBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sortBy()`](../collection/index#sortBy())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst beattles = Map({\n  John: { name: \"Lennon\" },\n  Paul: { name: \"McCartney\" },\n  George: { name: \"Harrison\" },\n  Ringo: { name: \"Starr\" },\n});\nbeattles.sortBy(member => member.name);run it\n```\n\nNote: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [groupBy()](index#groupBy())\n\nReturns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.\n\n``` ts\ngroupBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<T, T>>\n```\n\n#### Inherited from\n\n[`Collection#groupBy()`](../collection/index#groupBy())\n\n#### Discussion\n\nNote: This is always an eager operation.\n\n``` ts\nconst { List, Map } = require('immutable')\nconst listOfMaps = List([\n  Map({ v: 0 }),\n  Map({ v: 1 }),\n  Map({ v: 1 }),\n  Map({ v: 0 }),\n  Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ Map{ \"v\": 0 }, Map { \"v\": 0 } ],\n//   1: List [ Map{ \"v\": 1 }, Map { \"v\": 1 } ],\n//   2: List [ Map{ \"v\": 2 } ],\n// }run it\n```\n\n### Value equality\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#equals()`](../collection/index#equals())\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Inherited from\n\n[`Collection#hashCode()`](../collection/index#hashCode())\n\n#### Discussion\n\nThe [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nIf two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.\n\n### Reading values\n\n#### [get()](index#get())\n\n``` ts\nget<NSV>(key: T, notSetValue: NSV): T | NSV\nget(key: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#get()`](../collection/index#get())\n\n#### [has()](index#has())\n\nTrue if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nhas(key: T): boolean\n```\n\n#### Inherited from\n\n[`Collection#has()`](../collection/index#has())\n\n#### [includes()](index#includes())\n\nTrue if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nincludes(value: T): boolean\n```\n\n#### Inherited from\n\n[`Collection#includes()`](../collection/index#includes())\n\n#### alias\n\n`contains()`\n\n#### [first()](index#first())\n\nIn case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nfirst<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#first()`](../collection/index#first())\n\n#### [last()](index#last())\n\nIn case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nlast<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#last()`](../collection/index#last())\n\n### Reading deep values\n\n#### [getIn()](index#getIn())\n\nReturns the value found by following a path of keys or indices through nested Collections.\n\n``` ts\ngetIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown\n```\n\n#### Inherited from\n\n[`Collection#getIn()`](../collection/index#getIn())\n\n#### Discussion\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: [ { y: 123 } ] });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\n#### [hasIn()](index#hasIn())\n\nTrue if the result of following a path of keys or indices through nested Collections results in a set value.\n\n``` ts\nhasIn(searchKeyPath: Iterable<unknown>): boolean\n```\n\n#### Inherited from\n\n[`Collection#hasIn()`](../collection/index#hasIn())\n\n### Persistent changes\n\n#### [update()](index#update())\n\nThis can be very useful as a way to \"chain\" a normal function into a sequence of methods. RxJS calls this \"let\" and lodash calls it \"thru\".\n\n``` ts\nupdate<R>(updater: (value: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#update()`](../collection/index#update())\n\n#### Discussion\n\nFor example, to sum a Seq after mapping and filtering:\n\n``` ts\nconst { Seq } = require('immutable')\n\nfunction sum(collection) {\n  return collection.reduce((sum, x) => sum + x, 0)\n}\nSeq([ 1, 2, 3 ])\n  .map(x => x + 1)\n  .filter(x => x % 2 === 0)\n  .update(sum)\n// 6run it\n```\n\n### Conversion to Collections\n\n#### [toMap()](index#toMap())\n\nConverts this Collection to a Map, Throws if keys are not hashable.\n\n``` ts\ntoMap(): Map<T, T>\n```\n\n#### Inherited from\n\n[`Collection#toMap()`](../collection/index#toMap())\n\n#### Discussion\n\nNote: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toOrderedMap()](index#toOrderedMap())\n\nConverts this Collection to a Map, maintaining the order of iteration.\n\n``` ts\ntoOrderedMap(): OrderedMap<T, T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedMap()`](../collection/index#toOrderedMap())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toSet()](index#toSet())\n\nConverts this Collection to a Set, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoSet(): Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSet()`](../collection/index#toSet())\n\n#### Discussion\n\nNote: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.\n\n#### [toOrderedSet()](index#toOrderedSet())\n\nConverts this Collection to a Set, maintaining the order of iteration and discarding keys.\n\n``` ts\ntoOrderedSet(): OrderedSet<T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedSet()`](../collection/index#toOrderedSet())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toList()](index#toList())\n\nConverts this Collection to a List, discarding keys.\n\n``` ts\ntoList(): List<T>\n```\n\n#### Inherited from\n\n[`Collection#toList()`](../collection/index#toList())\n\n#### Discussion\n\nThis is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.\n\n``` ts\nconst { Map, List } = require('immutable')\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\nList(myMap) // List [ [ \"a\", \"Apple\" ], [ \"b\", \"Banana\" ] ]\nmyMap.toList() // List [ \"Apple\", \"Banana\" ]run it\n```\n\n#### [toStack()](index#toStack())\n\nConverts this Collection to a Stack, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoStack(): Stack<T>\n```\n\n#### Inherited from\n\n[`Collection#toStack()`](../collection/index#toStack())\n\n#### Discussion\n\nNote: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.\n\n### Iterators\n\n#### [keys()](index#keys())\n\nAn iterator of this [`Collection`](../collection/index)'s keys.\n\n``` ts\nkeys(): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection#keys()`](../collection/index#keys())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.\n\n#### [values()](index#values())\n\nAn iterator of this [`Collection`](../collection/index)'s values.\n\n``` ts\nvalues(): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection#values()`](../collection/index#values())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.\n\n#### [entries()](index#entries())\n\nAn iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.\n\n``` ts\nentries(): IterableIterator<[T, T]>\n```\n\n#### Inherited from\n\n[`Collection#entries()`](../collection/index#entries())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.\n\n### Collections (Seq)\n\n#### [keySeq()](index#keySeq())\n\nReturns a new Seq.Indexed of the keys of this Collection, discarding values.\n\n``` ts\nkeySeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#keySeq()`](../collection/index#keySeq())\n\n#### [valueSeq()](index#valueSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\nvalueSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#valueSeq()`](../collection/index#valueSeq())\n\n#### [entrySeq()](index#entrySeq())\n\nReturns a new Seq.Indexed of \\[key, value\\] tuples.\n\n``` ts\nentrySeq(): Seq.Indexed<[T, T]>\n```\n\n#### Inherited from\n\n[`Collection#entrySeq()`](../collection/index#entrySeq())\n\n### Side effects\n\n#### [forEach()](index#forEach())\n\nThe `sideEffect` is executed for every entry in the Collection.\n\n``` ts\nforEach(sideEffect: (value: T, key: T, iter: this) => unknown,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#forEach()`](../collection/index#forEach())\n\n#### Discussion\n\nUnlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).\n\n### Creating subsets\n\n#### [slice()](index#slice())\n\nReturns a new Collection of the same type representing a portion of this Collection from start up to but not including end.\n\n``` ts\nslice(begin?: number, end?: number): this\n```\n\n#### Inherited from\n\n[`Collection#slice()`](../collection/index#slice())\n\n#### Discussion\n\nIf begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.\n\nIf the requested slice is equivalent to the current Collection, then it will return itself.\n\n#### [rest()](index#rest())\n\nReturns a new Collection of the same type containing all entries except the first.\n\n``` ts\nrest(): this\n```\n\n#### Inherited from\n\n[`Collection#rest()`](../collection/index#rest())\n\n#### [butLast()](index#butLast())\n\nReturns a new Collection of the same type containing all entries except the last.\n\n``` ts\nbutLast(): this\n```\n\n#### Inherited from\n\n[`Collection#butLast()`](../collection/index#butLast())\n\n#### [skip()](index#skip())\n\nReturns a new Collection of the same type which excludes the first `amount` entries from this Collection.\n\n``` ts\nskip(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skip()`](../collection/index#skip())\n\n#### [skipLast()](index#skipLast())\n\nReturns a new Collection of the same type which excludes the last `amount` entries from this Collection.\n\n``` ts\nskipLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skipLast()`](../collection/index#skipLast())\n\n#### [skipWhile()](index#skipWhile())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns false.\n\n``` ts\nskipWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipWhile()`](../collection/index#skipWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipWhile(x => x.match(/g/))\n// List [ \"cat\", \"hat\", \"god\" ]run it\n```\n\n#### [skipUntil()](index#skipUntil())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns true.\n\n``` ts\nskipUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipUntil()`](../collection/index#skipUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipUntil(x => x.match(/hat/))\n// List [ \"hat\", \"god\" ]run it\n```\n\n#### [take()](index#take())\n\nReturns a new Collection of the same type which includes the first `amount` entries from this Collection.\n\n``` ts\ntake(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#take()`](../collection/index#take())\n\n#### [takeLast()](index#takeLast())\n\nReturns a new Collection of the same type which includes the last `amount` entries from this Collection.\n\n``` ts\ntakeLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#takeLast()`](../collection/index#takeLast())\n\n#### [takeWhile()](index#takeWhile())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.\n\n``` ts\ntakeWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeWhile()`](../collection/index#takeWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeWhile(x => x.match(/o/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n#### [takeUntil()](index#takeUntil())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.\n\n``` ts\ntakeUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeUntil()`](../collection/index#takeUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeUntil(x => x.match(/at/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n### Combination\n\n#### [flatten()](index#flatten())\n\n``` ts\nflatten(depth?: number): Collection<unknown, unknown>\nflatten(shallow?: boolean): Collection<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection#flatten()`](../collection/index#flatten())\n\n### Reducing a value\n\n#### [reduce()](index#reduce())\n\n``` ts\nreduce<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R\nreduce<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduce()`](../collection/index#reduce())\n\n#### [reduceRight()](index#reduceRight())\n\n``` ts\nreduceRight<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R\nreduceRight<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduceRight()`](../collection/index#reduceRight())\n\n#### [every()](index#every())\n\nTrue if `predicate` returns true for all entries in the Collection.\n\n``` ts\nevery(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#every()`](../collection/index#every())\n\n#### [some()](index#some())\n\nTrue if `predicate` returns true for any entry in the Collection.\n\n``` ts\nsome(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#some()`](../collection/index#some())\n\n#### [join()](index#join())\n\nJoins values together as a string, inserting a separator between each. The default separator is `\",\"`.\n\n``` ts\njoin(separator?: string): string\n```\n\n#### Inherited from\n\n[`Collection#join()`](../collection/index#join())\n\n#### [isEmpty()](index#isEmpty())\n\nReturns true if this Collection includes no values.\n\n``` ts\nisEmpty(): boolean\n```\n\n#### Inherited from\n\n[`Collection#isEmpty()`](../collection/index#isEmpty())\n\n#### Discussion\n\nFor some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.\n\n#### [count()](index#count())\n\n``` ts\ncount(): number\ncount(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#count()`](../collection/index#count())\n\n#### [countBy()](index#countBy())\n\nReturns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.\n\n``` ts\ncountBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Map<G, number>\n```\n\n#### Inherited from\n\n[`Collection#countBy()`](../collection/index#countBy())\n\n#### Discussion\n\nNote: This is not a lazy operation.\n\n### Search for value\n\n#### [find()](index#find())\n\nReturns the first value for which the `predicate` returns true.\n\n``` ts\nfind(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#find()`](../collection/index#find())\n\n#### [findLast()](index#findLast())\n\nReturns the last value for which the `predicate` returns true.\n\n``` ts\nfindLast(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLast()`](../collection/index#findLast())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findEntry()](index#findEntry())\n\nReturns the first \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findEntry()`](../collection/index#findEntry())\n\n#### [findLastEntry()](index#findLastEntry())\n\nReturns the last \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindLastEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastEntry()`](../collection/index#findLastEntry())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findKey()](index#findKey())\n\nReturns the key for which the `predicate` returns true.\n\n``` ts\nfindKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findKey()`](../collection/index#findKey())\n\n#### [findLastKey()](index#findLastKey())\n\nReturns the last key for which the `predicate` returns true.\n\n``` ts\nfindLastKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastKey()`](../collection/index#findLastKey())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [keyOf()](index#keyOf())\n\nReturns the key associated with the search value, or undefined.\n\n``` ts\nkeyOf(searchValue: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#keyOf()`](../collection/index#keyOf())\n\n#### [lastKeyOf()](index#lastKeyOf())\n\nReturns the last key associated with the search value, or undefined.\n\n``` ts\nlastKeyOf(searchValue: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#lastKeyOf()`](../collection/index#lastKeyOf())\n\n#### [max()](index#max())\n\nReturns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmax(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#max()`](../collection/index#max())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [maxBy()](index#maxBy())\n\nLike [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nmaxBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#maxBy()`](../collection/index#maxBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it\n```\n\n#### [min()](index#min())\n\nReturns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmin(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#min()`](../collection/index#min())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [minBy()](index#minBy())\n\nLike [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nminBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#minBy()`](../collection/index#minBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it\n```\n\n### Comparison\n\n#### [isSubset()](index#isSubset())\n\nTrue if `iter` includes every value in this Collection.\n\n``` ts\nisSubset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSubset()`](../collection/index#isSubset())\n\n#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Collection.Set/](https://immutable-js.com/docs/v4.2.1/Collection.Set/)"
- name: Collection.Set.[Symbol.iterator]()
  id: collection.set/index#[Symbol.iterator]()
  summary: null
  belongs_to: Collection.Set
  description: |-
    #### [\[Symbol.iterator\]()](index#%5BSymbol.iterator%5D())

    ``` ts
    [Symbol.iterator](): IterableIterator<T>
    ```

    #### Overrides

    [`Collection#[Symbol.iterator]()`](../collection/index#%5BSymbol.iterator%5D())
- name: Collection.Set.butLast()
  id: collection.set/index#butLast()
  summary: Returns a new Collection of the same type containing all entries except the last
  belongs_to: Collection.Set
  description: |-
    #### [butLast()](index#butLast())

    Returns a new Collection of the same type containing all entries except the last.

    ``` ts
    butLast(): this
    ```

    #### Inherited from

    [`Collection#butLast()`](../collection/index#butLast())
- name: Collection.Set.Collection.Set()
  id: collection.set/index#Collection.Set()
  summary: Similar to Collection(), but always returns a Collection.Set
  belongs_to: Collection.Set
  description: |-
    #### [Collection.Set()](index#Collection.Set())

    Similar to [`Collection()`](../collection/index), but always returns a Collection.Set.

    ``` ts
    Collection.Set<T>(collection?: Iterable<T> | ArrayLike<T>): Collection.Set<T>
    ```

    #### Discussion

    Note: [`Collection.Set`](index) is a factory function and not a class, and does not use the `new` keyword during construction.

    ### Conversion to JavaScript types
- name: Collection.Set.concat()
  id: collection.set/index#concat()
  summary: Returns a new Collection with other collections concatenated to this one
  belongs_to: Collection.Set
  description: |-
    #### [concat()](index#concat())

    Returns a new Collection with other collections concatenated to this one.

    ``` ts
    concat<U>(...collections: Array<Iterable<U>>): Collection.Set<T | U>
    ```

    #### Overrides

    [`Collection#concat()`](../collection/index#concat())
- name: Collection.Set.count()
  id: collection.set/index#count()
  summary: null
  belongs_to: Collection.Set
  description: |-
    #### [count()](index#count())

    ``` ts
    count(): number
    count(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#count()`](../collection/index#count())
- name: Collection.Set.countBy()
  id: collection.set/index#countBy()
  summary: Returns a Seq.Keyed of counts, grouped by the return value of the grouper function
  belongs_to: Collection.Set
  description: |-
    #### [countBy()](index#countBy())

    Returns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.

    ``` ts
    countBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Map<G, number>
    ```

    #### Inherited from

    [`Collection#countBy()`](../collection/index#countBy())

    #### Discussion

    Note: This is not a lazy operation.

    ### Search for value
- name: Collection.Set.entries()
  id: collection.set/index#entries()
  summary: An iterator of this Collection's entries as [ key, value ] tuples
  belongs_to: Collection.Set
  description: |-
    #### [entries()](index#entries())

    An iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.

    ``` ts
    entries(): IterableIterator<[T, T]>
    ```

    #### Inherited from

    [`Collection#entries()`](../collection/index#entries())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.

    ### Collections (Seq)
- name: Collection.Set.entrySeq()
  id: collection.set/index#entrySeq()
  summary: Returns a new Seq.Indexed of [key, value] tuples
  belongs_to: Collection.Set
  description: |-
    #### [entrySeq()](index#entrySeq())

    Returns a new Seq.Indexed of \[key, value\] tuples.

    ``` ts
    entrySeq(): Seq.Indexed<[T, T]>
    ```

    #### Inherited from

    [`Collection#entrySeq()`](../collection/index#entrySeq())

    ### Side effects
- name: Collection.Set.equals()
  id: collection.set/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: Collection.Set
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Inherited from

    [`Collection#equals()`](../collection/index#equals())

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: Collection.Set.every()
  id: collection.set/index#every()
  summary: True if predicate returns true for all entries in the Collection
  belongs_to: Collection.Set
  description: |-
    #### [every()](index#every())

    True if `predicate` returns true for all entries in the Collection.

    ``` ts
    every(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#every()`](../collection/index#every())
- name: Collection.Set.filter()
  id: collection.set/index#filter()
  summary: null
  belongs_to: Collection.Set
  description: |-
    #### [filter()](index#filter())

    ``` ts
    filter<F>(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): Collection.Set<F>
    filter(predicate: (value: T, key: T, iter: this) => unknown,context?: unknown): this
    ```

    #### Overrides

    [`Collection#filter()`](../collection/index#filter())
- name: Collection.Set.filterNot()
  id: collection.set/index#filterNot()
  summary: Returns a new Collection of the same type with only the entries for which the predicate function returns false
  belongs_to: Collection.Set
  description: |-
    #### [filterNot()](index#filterNot())

    Returns a new Collection of the same type with only the entries for which the `predicate` function returns false.

    ``` ts
    filterNot(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#filterNot()`](../collection/index#filterNot())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
    // Map { "a": 1, "c": 3 }run it
    ```

    Note: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.
- name: Collection.Set.find()
  id: collection.set/index#find()
  summary: Returns the first value for which the predicate returns true
  belongs_to: Collection.Set
  description: |-
    #### [find()](index#find())

    Returns the first value for which the `predicate` returns true.

    ``` ts
    find(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#find()`](../collection/index#find())
- name: Collection.Set.findEntry()
  id: collection.set/index#findEntry()
  summary: Returns the first [key, value] entry for which the predicate returns true
  belongs_to: Collection.Set
  description: |-
    #### [findEntry()](index#findEntry())

    Returns the first \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined
    ```

    #### Inherited from

    [`Collection#findEntry()`](../collection/index#findEntry())
- name: Collection.Set.findKey()
  id: collection.set/index#findKey()
  summary: Returns the key for which the predicate returns true
  belongs_to: Collection.Set
  description: |-
    #### [findKey()](index#findKey())

    Returns the key for which the `predicate` returns true.

    ``` ts
    findKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined
    ```

    #### Inherited from

    [`Collection#findKey()`](../collection/index#findKey())
- name: Collection.Set.findLast()
  id: collection.set/index#findLast()
  summary: Returns the last value for which the predicate returns true
  belongs_to: Collection.Set
  description: |-
    #### [findLast()](index#findLast())

    Returns the last value for which the `predicate` returns true.

    ``` ts
    findLast(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#findLast()`](../collection/index#findLast())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Collection.Set.findLastEntry()
  id: collection.set/index#findLastEntry()
  summary: Returns the last [key, value] entry for which the predicate returns true
  belongs_to: Collection.Set
  description: |-
    #### [findLastEntry()](index#findLastEntry())

    Returns the last \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findLastEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined
    ```

    #### Inherited from

    [`Collection#findLastEntry()`](../collection/index#findLastEntry())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Collection.Set.findLastKey()
  id: collection.set/index#findLastKey()
  summary: Returns the last key for which the predicate returns true
  belongs_to: Collection.Set
  description: |-
    #### [findLastKey()](index#findLastKey())

    Returns the last key for which the `predicate` returns true.

    ``` ts
    findLastKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined
    ```

    #### Inherited from

    [`Collection#findLastKey()`](../collection/index#findLastKey())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Collection.Set.first()
  id: collection.set/index#first()
  summary: In case the Collection is not empty returns the first element of the Collection
  belongs_to: Collection.Set
  description: |-
    #### [first()](index#first())

    In case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    first<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#first()`](../collection/index#first())
- name: Collection.Set.flatMap()
  id: collection.set/index#flatMap()
  summary: Flat-maps the Collection, returning a Collection of the same type
  belongs_to: Collection.Set
  description: |-
    #### [flatMap()](index#flatMap())

    Flat-maps the Collection, returning a Collection of the same type.

    ``` ts
    flatMap<M>(mapper: (value: T, key: T, iter: this) => Iterable<M>,context?: unknown): Collection.Set<M>
    ```

    #### Overrides

    [`Collection#flatMap()`](../collection/index#flatMap())

    #### Discussion

    Similar to `collection.map(...).flatten(true)`.
- name: Collection.Set.flatten()
  id: collection.set/index#flatten()
  summary: null
  belongs_to: Collection.Set
  description: |-
    #### [flatten()](index#flatten())

    ``` ts
    flatten(depth?: number): Collection<unknown, unknown>
    flatten(shallow?: boolean): Collection<unknown, unknown>
    ```

    #### Inherited from

    [`Collection#flatten()`](../collection/index#flatten())

    ### Reducing a value
- name: Collection.Set.forEach()
  id: collection.set/index#forEach()
  summary: The sideEffect is executed for every entry in the Collection
  belongs_to: Collection.Set
  description: |-
    #### [forEach()](index#forEach())

    The `sideEffect` is executed for every entry in the Collection.

    ``` ts
    forEach(sideEffect: (value: T, key: T, iter: this) => unknown,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#forEach()`](../collection/index#forEach())

    #### Discussion

    Unlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).

    ### Creating subsets
- name: Collection.Set.get()
  id: collection.set/index#get()
  summary: null
  belongs_to: Collection.Set
  description: |-
    #### [get()](index#get())

    ``` ts
    get<NSV>(key: T, notSetValue: NSV): T | NSV
    get(key: T): T | undefined
    ```

    #### Inherited from

    [`Collection#get()`](../collection/index#get())
- name: Collection.Set.getIn()
  id: collection.set/index#getIn()
  summary: Returns the value found by following a path of keys or indices through nested Collections
  belongs_to: Collection.Set
  description: |-
    #### [getIn()](index#getIn())

    Returns the value found by following a path of keys or indices through nested Collections.

    ``` ts
    getIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown
    ```

    #### Inherited from

    [`Collection#getIn()`](../collection/index#getIn())

    #### Discussion

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: [ { y: 123 } ] });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```
- name: Collection.Set.groupBy()
  id: collection.set/index#groupBy()
  summary: Returns a Collection.Keyed of Collection.Keyeds, grouped by the return value of the grouper function
  belongs_to: Collection.Set
  description: |-
    #### [groupBy()](index#groupBy())

    Returns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.

    ``` ts
    groupBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<T, T>>
    ```

    #### Inherited from

    [`Collection#groupBy()`](../collection/index#groupBy())

    #### Discussion

    Note: This is always an eager operation.

    ``` ts
    const { List, Map } = require('immutable')
    const listOfMaps = List([
      Map({ v: 0 }),
      Map({ v: 1 }),
      Map({ v: 1 }),
      Map({ v: 0 }),
      Map({ v: 2 })
    ])
    const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
    // Map {
    //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
    //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
    //   2: List [ Map{ "v": 2 } ],
    // }run it
    ```

    ### Value equality
- name: Collection.Set.has()
  id: collection.set/index#has()
  summary: null
  belongs_to: Collection.Set
  description: |-
    #### [has()](index#has())

    True if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    has(key: T): boolean
    ```

    #### Inherited from

    [`Collection#has()`](../collection/index#has())
- name: Collection.Set.hashCode()
  id: collection.set/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: Collection.Set
  description: |-
    #### [hashCode()](index#hashCode())

    Computes and returns the hashed identity for this Collection.

    ``` ts
    hashCode(): number
    ```

    #### Inherited from

    [`Collection#hashCode()`](../collection/index#hashCode())

    #### Discussion

    The [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.

    ``` ts
    const a = List([ 1, 2, 3 ]);
    const b = List([ 1, 2, 3 ]);
    assert.notStrictEqual(a, b); // different instances
    const set = Set([ a ]);
    assert.equal(set.has(b), true);run it
    ```

    If two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.

    ### Reading values
- name: Collection.Set.hasIn()
  id: collection.set/index#hasIn()
  summary: True if the result of following a path of keys or indices through nested Collections results in a set value
  belongs_to: Collection.Set
  description: |-
    #### [hasIn()](index#hasIn())

    True if the result of following a path of keys or indices through nested Collections results in a set value.

    ``` ts
    hasIn(searchKeyPath: Iterable<unknown>): boolean
    ```

    #### Inherited from

    [`Collection#hasIn()`](../collection/index#hasIn())

    ### Persistent changes
- name: Collection.Set.includes()
  id: collection.set/index#includes()
  summary: null
  belongs_to: Collection.Set
  description: |-
    #### [includes()](index#includes())

    True if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    includes(value: T): boolean
    ```

    #### Inherited from

    [`Collection#includes()`](../collection/index#includes())

    #### alias

    `contains()`
- name: Collection.Set.isEmpty()
  id: collection.set/index#isEmpty()
  summary: Returns true if this Collection includes no values
  belongs_to: Collection.Set
  description: |-
    #### [isEmpty()](index#isEmpty())

    Returns true if this Collection includes no values.

    ``` ts
    isEmpty(): boolean
    ```

    #### Inherited from

    [`Collection#isEmpty()`](../collection/index#isEmpty())

    #### Discussion

    For some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.
- name: Collection.Set.isSubset()
  id: collection.set/index#isSubset()
  summary: True if iter includes every value in this Collection
  belongs_to: Collection.Set
  description: |-
    #### [isSubset()](index#isSubset())

    True if `iter` includes every value in this Collection.

    ``` ts
    isSubset(iter: Iterable<T>): boolean
    ```

    #### Inherited from

    [`Collection#isSubset()`](../collection/index#isSubset())
- name: Collection.Set.isSuperset()
  id: collection.set/index#isSuperset()
  summary: True if this Collection includes every value in iter
  belongs_to: Collection.Set
  description: "#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Collection.Set/](https://immutable-js.com/docs/v4.2.1/Collection.Set/)"
- name: Collection.Set.join()
  id: collection.set/index#join()
  summary: Joins values together as a string, inserting a separator between each
  belongs_to: Collection.Set
  description: |-
    #### [join()](index#join())

    Joins values together as a string, inserting a separator between each. The default separator is `","`.

    ``` ts
    join(separator?: string): string
    ```

    #### Inherited from

    [`Collection#join()`](../collection/index#join())
- name: Collection.Set.keyOf()
  id: collection.set/index#keyOf()
  summary: Returns the key associated with the search value, or undefined
  belongs_to: Collection.Set
  description: |-
    #### [keyOf()](index#keyOf())

    Returns the key associated with the search value, or undefined.

    ``` ts
    keyOf(searchValue: T): T | undefined
    ```

    #### Inherited from

    [`Collection#keyOf()`](../collection/index#keyOf())
- name: Collection.Set.keys()
  id: collection.set/index#keys()
  summary: An iterator of this Collection's keys
  belongs_to: Collection.Set
  description: |-
    #### [keys()](index#keys())

    An iterator of this [`Collection`](../collection/index)'s keys.

    ``` ts
    keys(): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection#keys()`](../collection/index#keys())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.
- name: Collection.Set.keySeq()
  id: collection.set/index#keySeq()
  summary: Returns a new Seq.Indexed of the keys of this Collection, discarding values
  belongs_to: Collection.Set
  description: |-
    #### [keySeq()](index#keySeq())

    Returns a new Seq.Indexed of the keys of this Collection, discarding values.

    ``` ts
    keySeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#keySeq()`](../collection/index#keySeq())
- name: Collection.Set.last()
  id: collection.set/index#last()
  summary: In case the Collection is not empty returns the last element of the Collection
  belongs_to: Collection.Set
  description: |-
    #### [last()](index#last())

    In case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    last<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#last()`](../collection/index#last())

    ### Reading deep values
- name: Collection.Set.lastKeyOf()
  id: collection.set/index#lastKeyOf()
  summary: Returns the last key associated with the search value, or undefined
  belongs_to: Collection.Set
  description: |-
    #### [lastKeyOf()](index#lastKeyOf())

    Returns the last key associated with the search value, or undefined.

    ``` ts
    lastKeyOf(searchValue: T): T | undefined
    ```

    #### Inherited from

    [`Collection#lastKeyOf()`](../collection/index#lastKeyOf())
- name: Collection.Set.map()
  id: collection.set/index#map()
  summary: Returns a new Collection.Set with values passed through a mapper function
  belongs_to: Collection.Set
  description: |-
    #### [map()](index#map())

    Returns a new Collection.Set with values passed through a `mapper` function.

    ``` ts
    map<M>(mapper: (value: T, key: T, iter: this) => M,context?: unknown): Collection.Set<M>
    ```

    #### Overrides

    [`Collection#map()`](../collection/index#map())

    #### Example

    ``` ts
    Collection.Set([ 1, 2 ]).map(x => 10 * x)
    // Seq { 1, 2 }
    ```

    Note: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.
- name: Collection.Set.max()
  id: collection.set/index#max()
  summary: Returns the maximum value in this collection
  belongs_to: Collection.Set
  description: |-
    #### [max()](index#max())

    Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    max(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#max()`](../collection/index#max())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Collection.Set.maxBy()
  id: collection.set/index#maxBy()
  summary: null
  belongs_to: Collection.Set
  description: |-
    #### [maxBy()](index#maxBy())

    Like [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    maxBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#maxBy()`](../collection/index#maxBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it
    ```
- name: Collection.Set.min()
  id: collection.set/index#min()
  summary: Returns the minimum value in this collection
  belongs_to: Collection.Set
  description: |-
    #### [min()](index#min())

    Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    min(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#min()`](../collection/index#min())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Collection.Set.minBy()
  id: collection.set/index#minBy()
  summary: null
  belongs_to: Collection.Set
  description: |-
    #### [minBy()](index#minBy())

    Like [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    minBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#minBy()`](../collection/index#minBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it
    ```

    ### Comparison
- name: Collection.Set.partition()
  id: collection.set/index#partition()
  summary: null
  belongs_to: Collection.Set
  description: |-
    #### [partition()](index#partition())

    ``` ts
    partition<F, C>(predicate: (this: C, value: T, key: T, iter: this) => boolean,context?: C): [Collection.Set<T>, Collection.Set<F>]
    partition<C>(predicate: (this: C, value: T, key: T, iter: this) => unknown,context?: C): [this, this]
    ```

    #### Overrides

    [`Collection#partition()`](../collection/index#partition())
- name: Collection.Set.reduce()
  id: collection.set/index#reduce()
  summary: null
  belongs_to: Collection.Set
  description: |-
    #### [reduce()](index#reduce())

    ``` ts
    reduce<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R
    reduce<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduce()`](../collection/index#reduce())
- name: Collection.Set.reduceRight()
  id: collection.set/index#reduceRight()
  summary: null
  belongs_to: Collection.Set
  description: |-
    #### [reduceRight()](index#reduceRight())

    ``` ts
    reduceRight<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R
    reduceRight<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduceRight()`](../collection/index#reduceRight())
- name: Collection.Set.rest()
  id: collection.set/index#rest()
  summary: Returns a new Collection of the same type containing all entries except the first
  belongs_to: Collection.Set
  description: |-
    #### [rest()](index#rest())

    Returns a new Collection of the same type containing all entries except the first.

    ``` ts
    rest(): this
    ```

    #### Inherited from

    [`Collection#rest()`](../collection/index#rest())
- name: Collection.Set.reverse()
  id: collection.set/index#reverse()
  summary: Returns a new Collection of the same type in reverse order
  belongs_to: Collection.Set
  description: |-
    #### [reverse()](index#reverse())

    Returns a new Collection of the same type in reverse order.

    ``` ts
    reverse(): this
    ```

    #### Inherited from

    [`Collection#reverse()`](../collection/index#reverse())
- name: Collection.Set.skip()
  id: collection.set/index#skip()
  summary: Returns a new Collection of the same type which excludes the first amount entries from this Collection
  belongs_to: Collection.Set
  description: |-
    #### [skip()](index#skip())

    Returns a new Collection of the same type which excludes the first `amount` entries from this Collection.

    ``` ts
    skip(amount: number): this
    ```

    #### Inherited from

    [`Collection#skip()`](../collection/index#skip())
- name: Collection.Set.skipLast()
  id: collection.set/index#skipLast()
  summary: Returns a new Collection of the same type which excludes the last amount entries from this Collection
  belongs_to: Collection.Set
  description: |-
    #### [skipLast()](index#skipLast())

    Returns a new Collection of the same type which excludes the last `amount` entries from this Collection.

    ``` ts
    skipLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#skipLast()`](../collection/index#skipLast())
- name: Collection.Set.skipUntil()
  id: collection.set/index#skipUntil()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns true
  belongs_to: Collection.Set
  description: |-
    #### [skipUntil()](index#skipUntil())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns true.

    ``` ts
    skipUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipUntil()`](../collection/index#skipUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipUntil(x => x.match(/hat/))
    // List [ "hat", "god" ]run it
    ```
- name: Collection.Set.skipWhile()
  id: collection.set/index#skipWhile()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns false
  belongs_to: Collection.Set
  description: |-
    #### [skipWhile()](index#skipWhile())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns false.

    ``` ts
    skipWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipWhile()`](../collection/index#skipWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipWhile(x => x.match(/g/))
    // List [ "cat", "hat", "god" ]run it
    ```
- name: Collection.Set.slice()
  id: collection.set/index#slice()
  summary: Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end
  belongs_to: Collection.Set
  description: |-
    #### [slice()](index#slice())

    Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.

    ``` ts
    slice(begin?: number, end?: number): this
    ```

    #### Inherited from

    [`Collection#slice()`](../collection/index#slice())

    #### Discussion

    If begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.

    If end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.

    If the requested slice is equivalent to the current Collection, then it will return itself.
- name: Collection.Set.some()
  id: collection.set/index#some()
  summary: True if predicate returns true for any entry in the Collection
  belongs_to: Collection.Set
  description: |-
    #### [some()](index#some())

    True if `predicate` returns true for any entry in the Collection.

    ``` ts
    some(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#some()`](../collection/index#some())
- name: Collection.Set.sort()
  id: collection.set/index#sort()
  summary: Returns a new Collection of the same type which includes the same entries, stably sorted by using a comparator
  belongs_to: Collection.Set
  description: |-
    #### [sort()](index#sort())

    Returns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.

    ``` ts
    sort(comparator?: (valueA: T, valueB: T) => number): this
    ```

    #### Inherited from

    [`Collection#sort()`](../collection/index#sort())

    #### Discussion

    If a `comparator` is not provided, a default comparator uses `<` and `>`.

    `comparator(valueA, valueB)`:

    - Returns `0` if the elements should not be swapped.
    - Returns `-1` (or any negative number) if `valueA` comes before `valueB`
    - Returns `1` (or any positive number) if `valueA` comes after `valueB`
    - Is pure, i.e. it must always return the same value for the same pair of values.

    When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.

    ``` ts
    const { Map } = require('immutable')
    Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
      if (a < b) { return -1; }
      if (a > b) { return 1; }
      if (a === b) { return 0; }
    });
    // OrderedMap { "a": 1, "b": 2, "c": 3 }run it
    ```

    Note: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Collection.Set.sortBy()
  id: collection.set/index#sortBy()
  summary: 'Note: sortBy() Always returns a new instance, even if the original was already sorted'
  belongs_to: Collection.Set
  description: |-
    #### [sortBy()](index#sortBy())

    Like [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:

    ``` ts
    sortBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this
    ```

    #### Inherited from

    [`Collection#sortBy()`](../collection/index#sortBy())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const beattles = Map({
      John: { name: "Lennon" },
      Paul: { name: "McCartney" },
      George: { name: "Harrison" },
      Ringo: { name: "Starr" },
    });
    beattles.sortBy(member => member.name);run it
    ```

    Note: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Collection.Set.take()
  id: collection.set/index#take()
  summary: Returns a new Collection of the same type which includes the first amount entries from this Collection
  belongs_to: Collection.Set
  description: |-
    #### [take()](index#take())

    Returns a new Collection of the same type which includes the first `amount` entries from this Collection.

    ``` ts
    take(amount: number): this
    ```

    #### Inherited from

    [`Collection#take()`](../collection/index#take())
- name: Collection.Set.takeLast()
  id: collection.set/index#takeLast()
  summary: Returns a new Collection of the same type which includes the last amount entries from this Collection
  belongs_to: Collection.Set
  description: |-
    #### [takeLast()](index#takeLast())

    Returns a new Collection of the same type which includes the last `amount` entries from this Collection.

    ``` ts
    takeLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#takeLast()`](../collection/index#takeLast())
- name: Collection.Set.takeUntil()
  id: collection.set/index#takeUntil()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns false
  belongs_to: Collection.Set
  description: |-
    #### [takeUntil()](index#takeUntil())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.

    ``` ts
    takeUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeUntil()`](../collection/index#takeUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeUntil(x => x.match(/at/))
    // List [ "dog", "frog" ]run it
    ```

    ### Combination
- name: Collection.Set.takeWhile()
  id: collection.set/index#takeWhile()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns true
  belongs_to: Collection.Set
  description: |-
    #### [takeWhile()](index#takeWhile())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.

    ``` ts
    takeWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeWhile()`](../collection/index#takeWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeWhile(x => x.match(/o/))
    // List [ "dog", "frog" ]run it
    ```
- name: Collection.Set.toArray()
  id: collection.set/index#toArray()
  summary: Shallowly converts this collection to an Array
  belongs_to: Collection.Set
  description: |-
    #### [toArray()](index#toArray())

    Shallowly converts this collection to an Array.

    ``` ts
    toArray(): Array<T>
    ```

    #### Overrides

    [`Collection#toArray()`](../collection/index#toArray())
- name: Collection.Set.toIndexedSeq()
  id: collection.set/index#toIndexedSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Collection.Set
  description: |-
    #### [toIndexedSeq()](index#toIndexedSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    toIndexedSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())
- name: Collection.Set.toJS()
  id: collection.set/index#toJS()
  summary: Deeply converts this Set collection to equivalent native JavaScript Array
  belongs_to: Collection.Set
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Set collection to equivalent native JavaScript Array.

    ``` ts
    toJS(): Array<DeepCopy<T>>
    ```

    #### Overrides

    [`Collection#toJS()`](../collection/index#toJS())
- name: Collection.Set.toJSON()
  id: collection.set/index#toJSON()
  summary: Shallowly converts this Set collection to equivalent native JavaScript Array
  belongs_to: Collection.Set
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Set collection to equivalent native JavaScript Array.

    ``` ts
    toJSON(): Array<T>
    ```

    #### Overrides

    [`Collection#toJSON()`](../collection/index#toJSON())
- name: Collection.Set.toKeyedSeq()
  id: collection.set/index#toKeyedSeq()
  summary: Returns a Seq.Keyed from this Collection where indices are treated as keys
  belongs_to: Collection.Set
  description: |-
    #### [toKeyedSeq()](index#toKeyedSeq())

    Returns a Seq.Keyed from this Collection where indices are treated as keys.

    ``` ts
    toKeyedSeq(): Seq.Keyed<T, T>
    ```

    #### Inherited from

    [`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())

    #### Discussion

    This is useful if you want to operate on an Collection.Indexed and preserve the \[index, value\] pairs.

    The returned Seq will have identical iteration order as this Collection.

    ``` ts
    const { Seq } = require('immutable')
    const indexedSeq = Seq([ 'A', 'B', 'C' ])
    // Seq [ "A", "B", "C" ]
    indexedSeq.filter(v => v === 'B')
    // Seq [ "B" ]
    const keyedSeq = indexedSeq.toKeyedSeq()
    // Seq { 0: "A", 1: "B", 2: "C" }
    keyedSeq.filter(v => v === 'B')
    // Seq { 1: "B" }run it
    ```
- name: Collection.Set.toList()
  id: collection.set/index#toList()
  summary: Converts this Collection to a List, discarding keys
  belongs_to: Collection.Set
  description: |-
    #### [toList()](index#toList())

    Converts this Collection to a List, discarding keys.

    ``` ts
    toList(): List<T>
    ```

    #### Inherited from

    [`Collection#toList()`](../collection/index#toList())

    #### Discussion

    This is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.

    ``` ts
    const { Map, List } = require('immutable')
    var myMap = Map({ a: 'Apple', b: 'Banana' })
    List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
    myMap.toList() // List [ "Apple", "Banana" ]run it
    ```
- name: Collection.Set.toMap()
  id: collection.set/index#toMap()
  summary: Converts this Collection to a Map, Throws if keys are not hashable
  belongs_to: Collection.Set
  description: |-
    #### [toMap()](index#toMap())

    Converts this Collection to a Map, Throws if keys are not hashable.

    ``` ts
    toMap(): Map<T, T>
    ```

    #### Inherited from

    [`Collection#toMap()`](../collection/index#toMap())

    #### Discussion

    Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Collection.Set.toObject()
  id: collection.set/index#toObject()
  summary: Shallowly converts this Collection to an Object
  belongs_to: Collection.Set
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Collection to an Object.

    ``` ts
    toObject(): {[key: string]: T}
    ```

    #### Inherited from

    [`Collection#toObject()`](../collection/index#toObject())

    #### Discussion

    Converts keys to Strings.

    ### Conversion to Seq
- name: Collection.Set.toOrderedMap()
  id: collection.set/index#toOrderedMap()
  summary: Converts this Collection to a Map, maintaining the order of iteration
  belongs_to: Collection.Set
  description: |-
    #### [toOrderedMap()](index#toOrderedMap())

    Converts this Collection to a Map, maintaining the order of iteration.

    ``` ts
    toOrderedMap(): OrderedMap<T, T>
    ```

    #### Inherited from

    [`Collection#toOrderedMap()`](../collection/index#toOrderedMap())

    #### Discussion

    Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Collection.Set.toOrderedSet()
  id: collection.set/index#toOrderedSet()
  summary: Converts this Collection to a Set, maintaining the order of iteration and discarding keys
  belongs_to: Collection.Set
  description: |-
    #### [toOrderedSet()](index#toOrderedSet())

    Converts this Collection to a Set, maintaining the order of iteration and discarding keys.

    ``` ts
    toOrderedSet(): OrderedSet<T>
    ```

    #### Inherited from

    [`Collection#toOrderedSet()`](../collection/index#toOrderedSet())

    #### Discussion

    Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.
- name: Collection.Set.toSeq()
  id: collection.set/index#toSeq()
  summary: Returns Seq.Set
  belongs_to: Collection.Set
  description: |-
    #### [toSeq()](index#toSeq())

    Returns Seq.Set.

    ``` ts
    toSeq(): Seq.Set<T>
    ```

    #### Overrides

    [`Collection#toSeq()`](../collection/index#toSeq())
- name: Collection.Set.toSet()
  id: collection.set/index#toSet()
  summary: Converts this Collection to a Set, discarding keys
  belongs_to: Collection.Set
  description: |-
    #### [toSet()](index#toSet())

    Converts this Collection to a Set, discarding keys. Throws if values are not hashable.

    ``` ts
    toSet(): Set<T>
    ```

    #### Inherited from

    [`Collection#toSet()`](../collection/index#toSet())

    #### Discussion

    Note: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.
- name: Collection.Set.toSetSeq()
  id: collection.set/index#toSetSeq()
  summary: Returns a Seq.Set of the values of this Collection, discarding keys
  belongs_to: Collection.Set
  description: |-
    #### [toSetSeq()](index#toSetSeq())

    Returns a Seq.Set of the values of this Collection, discarding keys.

    ``` ts
    toSetSeq(): Seq.Set<T>
    ```

    #### Inherited from

    [`Collection#toSetSeq()`](../collection/index#toSetSeq())

    ### Sequence algorithms
- name: Collection.Set.toStack()
  id: collection.set/index#toStack()
  summary: Converts this Collection to a Stack, discarding keys
  belongs_to: Collection.Set
  description: |-
    #### [toStack()](index#toStack())

    Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.

    ``` ts
    toStack(): Stack<T>
    ```

    #### Inherited from

    [`Collection#toStack()`](../collection/index#toStack())

    #### Discussion

    Note: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.

    ### Iterators
- name: Collection.Set.update()
  id: collection.set/index#update()
  summary: This can be very useful as a way to "chain" a normal function into a sequence of methods
  belongs_to: Collection.Set
  description: |-
    #### [update()](index#update())

    This can be very useful as a way to "chain" a normal function into a sequence of methods. RxJS calls this "let" and lodash calls it "thru".

    ``` ts
    update<R>(updater: (value: this) => R): R
    ```

    #### Inherited from

    [`Collection#update()`](../collection/index#update())

    #### Discussion

    For example, to sum a Seq after mapping and filtering:

    ``` ts
    const { Seq } = require('immutable')

    function sum(collection) {
      return collection.reduce((sum, x) => sum + x, 0)
    }
    Seq([ 1, 2, 3 ])
      .map(x => x + 1)
      .filter(x => x % 2 === 0)
      .update(sum)
    // 6run it
    ```

    ### Conversion to Collections
- name: Collection.Set.values()
  id: collection.set/index#values()
  summary: An iterator of this Collection's values
  belongs_to: Collection.Set
  description: |-
    #### [values()](index#values())

    An iterator of this [`Collection`](../collection/index)'s values.

    ``` ts
    values(): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection#values()`](../collection/index#values())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.
- name: Collection.Set.valueSeq()
  id: collection.set/index#valueSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Collection.Set
  description: |-
    #### [valueSeq()](index#valueSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    valueSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#valueSeq()`](../collection/index#valueSeq())
- name: Collection.skip()
  id: collection/index#skip()
  summary: Returns a new Collection of the same type which excludes the first amount entries from this Collection
  belongs_to: Collection
  description: |-
    #### [skip()](index#skip())

    Returns a new Collection of the same type which excludes the first `amount` entries from this Collection.

    ``` ts
    skip(amount: number): this
    ```
- name: Collection.skipLast()
  id: collection/index#skipLast()
  summary: Returns a new Collection of the same type which excludes the last amount entries from this Collection
  belongs_to: Collection
  description: |-
    #### [skipLast()](index#skipLast())

    Returns a new Collection of the same type which excludes the last `amount` entries from this Collection.

    ``` ts
    skipLast(amount: number): this
    ```
- name: Collection.skipUntil()
  id: collection/index#skipUntil()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns true
  belongs_to: Collection
  description: |-
    #### [skipUntil()](index#skipUntil())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns true.

    ``` ts
    skipUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipUntil(x => x.match(/hat/))
    // List [ "hat", "god" ]run it
    ```
- name: Collection.skipWhile()
  id: collection/index#skipWhile()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns false
  belongs_to: Collection
  description: |-
    #### [skipWhile()](index#skipWhile())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns false.

    ``` ts
    skipWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipWhile(x => x.match(/g/))
    // List [ "cat", "hat", "god" ]run it
    ```
- name: Collection.slice()
  id: collection/index#slice()
  summary: Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end
  belongs_to: Collection
  description: |-
    #### [slice()](index#slice())

    Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.

    ``` ts
    slice(begin?: number, end?: number): this
    ```

    #### Discussion

    If begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.

    If end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.

    If the requested slice is equivalent to the current Collection, then it will return itself.
- name: Collection.some()
  id: collection/index#some()
  summary: True if predicate returns true for any entry in the Collection
  belongs_to: Collection
  description: |-
    #### [some()](index#some())

    True if `predicate` returns true for any entry in the Collection.

    ``` ts
    some(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean
    ```
- name: Collection.sort()
  id: collection/index#sort()
  summary: Returns a new Collection of the same type which includes the same entries, stably sorted by using a comparator
  belongs_to: Collection
  description: |-
    #### [sort()](index#sort())

    Returns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.

    ``` ts
    sort(comparator?: (valueA: V, valueB: V) => number): this
    ```

    #### Discussion

    If a `comparator` is not provided, a default comparator uses `<` and `>`.

    `comparator(valueA, valueB)`:

    - Returns `0` if the elements should not be swapped.
    - Returns `-1` (or any negative number) if `valueA` comes before `valueB`
    - Returns `1` (or any positive number) if `valueA` comes after `valueB`
    - Is pure, i.e. it must always return the same value for the same pair of values.

    When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.

    ``` ts
    const { Map } = require('immutable')
    Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
      if (a < b) { return -1; }
      if (a > b) { return 1; }
      if (a === b) { return 0; }
    });
    // OrderedMap { "a": 1, "b": 2, "c": 3 }run it
    ```

    Note: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Collection.sortBy()
  id: collection/index#sortBy()
  summary: 'Note: sortBy() Always returns a new instance, even if the original was already sorted'
  belongs_to: Collection
  description: |-
    #### [sortBy()](index#sortBy())

    Like [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:

    ``` ts
    sortBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this
    ```

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const beattles = Map({
      John: { name: "Lennon" },
      Paul: { name: "McCartney" },
      George: { name: "Harrison" },
      Ringo: { name: "Starr" },
    });
    beattles.sortBy(member => member.name);run it
    ```

    Note: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Collection.take()
  id: collection/index#take()
  summary: Returns a new Collection of the same type which includes the first amount entries from this Collection
  belongs_to: Collection
  description: |-
    #### [take()](index#take())

    Returns a new Collection of the same type which includes the first `amount` entries from this Collection.

    ``` ts
    take(amount: number): this
    ```
- name: Collection.takeLast()
  id: collection/index#takeLast()
  summary: Returns a new Collection of the same type which includes the last amount entries from this Collection
  belongs_to: Collection
  description: |-
    #### [takeLast()](index#takeLast())

    Returns a new Collection of the same type which includes the last `amount` entries from this Collection.

    ``` ts
    takeLast(amount: number): this
    ```
- name: Collection.takeUntil()
  id: collection/index#takeUntil()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns false
  belongs_to: Collection
  description: |-
    #### [takeUntil()](index#takeUntil())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.

    ``` ts
    takeUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeUntil(x => x.match(/at/))
    // List [ "dog", "frog" ]run it
    ```

    ### Combination
- name: Collection.takeWhile()
  id: collection/index#takeWhile()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns true
  belongs_to: Collection
  description: |-
    #### [takeWhile()](index#takeWhile())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.

    ``` ts
    takeWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeWhile(x => x.match(/o/))
    // List [ "dog", "frog" ]run it
    ```
- name: Collection.toArray()
  id: collection/index#toArray()
  summary: Shallowly converts this collection to an Array
  belongs_to: Collection
  description: |-
    #### [toArray()](index#toArray())

    Shallowly converts this collection to an Array.

    ``` ts
    toArray(): Array<V> | Array<[K, V]>
    ```

    #### Discussion

    [`Collection.Indexed`](../collection.indexed/index), and [`Collection.Set`](../collection.set/index) produce an Array of values. [`Collection.Keyed`](../collection.keyed/index) produce an Array of \[key, value\] tuples.
- name: Collection.toIndexedSeq()
  id: collection/index#toIndexedSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Collection
  description: |-
    #### [toIndexedSeq()](index#toIndexedSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    toIndexedSeq(): Seq.Indexed<V>
    ```
- name: Collection.toJS()
  id: collection/index#toJS()
  summary: Deeply converts this Collection to equivalent native JavaScript Array or Object
  belongs_to: Collection
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Collection to equivalent native JavaScript Array or Object.

    ``` ts
    toJS(): Array<DeepCopy<V>> | {[key: string]: DeepCopy<V>}
    ```

    #### Discussion

    [`Collection.Indexed`](../collection.indexed/index), and [`Collection.Set`](../collection.set/index) become [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array), while [`Collection.Keyed`](../collection.keyed/index) become [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object), converting keys to Strings.
- name: Collection.toJSON()
  id: collection/index#toJSON()
  summary: Shallowly converts this Collection to equivalent native JavaScript Array or Object
  belongs_to: Collection
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Collection to equivalent native JavaScript Array or Object.

    ``` ts
    toJSON(): Array<V> | {[key: string]: V}
    ```

    #### Discussion

    [`Collection.Indexed`](../collection.indexed/index), and [`Collection.Set`](../collection.set/index) become [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array), while [`Collection.Keyed`](../collection.keyed/index) become [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object), converting keys to Strings.
- name: Collection.toKeyedSeq()
  id: collection/index#toKeyedSeq()
  summary: Returns a Seq.Keyed from this Collection where indices are treated as keys
  belongs_to: Collection
  description: |-
    #### [toKeyedSeq()](index#toKeyedSeq())

    Returns a Seq.Keyed from this Collection where indices are treated as keys.

    ``` ts
    toKeyedSeq(): Seq.Keyed<K, V>
    ```

    #### Discussion

    This is useful if you want to operate on an Collection.Indexed and preserve the \[index, value\] pairs.

    The returned Seq will have identical iteration order as this Collection.

    ``` ts
    const { Seq } = require('immutable')
    const indexedSeq = Seq([ 'A', 'B', 'C' ])
    // Seq [ "A", "B", "C" ]
    indexedSeq.filter(v => v === 'B')
    // Seq [ "B" ]
    const keyedSeq = indexedSeq.toKeyedSeq()
    // Seq { 0: "A", 1: "B", 2: "C" }
    keyedSeq.filter(v => v === 'B')
    // Seq { 1: "B" }run it
    ```
- name: Collection.toList()
  id: collection/index#toList()
  summary: Converts this Collection to a List, discarding keys
  belongs_to: Collection
  description: |-
    #### [toList()](index#toList())

    Converts this Collection to a List, discarding keys.

    ``` ts
    toList(): List<V>
    ```

    #### Discussion

    This is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.

    ``` ts
    const { Map, List } = require('immutable')
    var myMap = Map({ a: 'Apple', b: 'Banana' })
    List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
    myMap.toList() // List [ "Apple", "Banana" ]run it
    ```
- name: Collection.toMap()
  id: collection/index#toMap()
  summary: Converts this Collection to a Map, Throws if keys are not hashable
  belongs_to: Collection
  description: |-
    #### [toMap()](index#toMap())

    Converts this Collection to a Map, Throws if keys are not hashable.

    ``` ts
    toMap(): Map<K, V>
    ```

    #### Discussion

    Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Collection.toObject()
  id: collection/index#toObject()
  summary: Shallowly converts this Collection to an Object
  belongs_to: Collection
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Collection to an Object.

    ``` ts
    toObject(): {[key: string]: V}
    ```

    #### Discussion

    Converts keys to Strings.

    ### Conversion to Collections
- name: Collection.toOrderedMap()
  id: collection/index#toOrderedMap()
  summary: Converts this Collection to a Map, maintaining the order of iteration
  belongs_to: Collection
  description: |-
    #### [toOrderedMap()](index#toOrderedMap())

    Converts this Collection to a Map, maintaining the order of iteration.

    ``` ts
    toOrderedMap(): OrderedMap<K, V>
    ```

    #### Discussion

    Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Collection.toOrderedSet()
  id: collection/index#toOrderedSet()
  summary: Converts this Collection to a Set, maintaining the order of iteration and discarding keys
  belongs_to: Collection
  description: |-
    #### [toOrderedSet()](index#toOrderedSet())

    Converts this Collection to a Set, maintaining the order of iteration and discarding keys.

    ``` ts
    toOrderedSet(): OrderedSet<V>
    ```

    #### Discussion

    Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.
- name: Collection.toSeq()
  id: collection/index#toSeq()
  summary: Converts this Collection to a Seq of the same kind (indexed, keyed, or set)
  belongs_to: Collection
  description: |-
    #### [toSeq()](index#toSeq())

    Converts this Collection to a Seq of the same kind (indexed, keyed, or set).

    ``` ts
    toSeq(): Seq<K, V>
    ```
- name: Collection.toSet()
  id: collection/index#toSet()
  summary: Converts this Collection to a Set, discarding keys
  belongs_to: Collection
  description: |-
    #### [toSet()](index#toSet())

    Converts this Collection to a Set, discarding keys. Throws if values are not hashable.

    ``` ts
    toSet(): Set<V>
    ```

    #### Discussion

    Note: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.
- name: Collection.toSetSeq()
  id: collection/index#toSetSeq()
  summary: Returns a Seq.Set of the values of this Collection, discarding keys
  belongs_to: Collection
  description: |-
    #### [toSetSeq()](index#toSetSeq())

    Returns a Seq.Set of the values of this Collection, discarding keys.

    ``` ts
    toSetSeq(): Seq.Set<V>
    ```

    ### Iterators
- name: Collection.toStack()
  id: collection/index#toStack()
  summary: Converts this Collection to a Stack, discarding keys
  belongs_to: Collection
  description: |-
    #### [toStack()](index#toStack())

    Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.

    ``` ts
    toStack(): Stack<V>
    ```

    #### Discussion

    Note: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.

    ### Conversion to Seq
- name: Collection.update()
  id: collection/index#update()
  summary: This can be very useful as a way to "chain" a normal function into a sequence of methods
  belongs_to: Collection
  description: |-
    #### [update()](index#update())

    This can be very useful as a way to "chain" a normal function into a sequence of methods. RxJS calls this "let" and lodash calls it "thru".

    ``` ts
    update<R>(updater: (value: this) => R): R
    ```

    #### Discussion

    For example, to sum a Seq after mapping and filtering:

    ``` ts
    const { Seq } = require('immutable')

    function sum(collection) {
      return collection.reduce((sum, x) => sum + x, 0)
    }
    Seq([ 1, 2, 3 ])
      .map(x => x + 1)
      .filter(x => x % 2 === 0)
      .update(sum)
    // 6run it
    ```

    ### Conversion to JavaScript types
- name: Collection.values()
  id: collection/index#values()
  summary: An iterator of this Collection's values
  belongs_to: Collection
  description: |-
    #### [values()](index#values())

    An iterator of this [`Collection`](index)'s values.

    ``` ts
    values(): IterableIterator<V>
    ```

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.
- name: Collection.valueSeq()
  id: collection/index#valueSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Collection
  description: |-
    #### [valueSeq()](index#valueSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    valueSeq(): Seq.Indexed<V>
    ```
- name: fromJS()
  id: fromjs()/index
  summary: Deeply converts plain JS objects and arrays to Immutable Maps and Lists
  description: "# fromJS()\n\nDeeply converts plain JS objects and arrays to Immutable Maps and Lists.\n\n``` ts\nfromJS(jsValue: unknown,reviver?: (key: string | number,sequence: Collection.Keyed<string, unknown> | Collection.Indexed<unknown>,path?: Array<string | number>) => unknown): Collection<unknown, unknown>\n```\n\n#### Discussion\n\n[`fromJS`](index) will convert Arrays and [array-like objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects \"Working with array-like objects\") to a List, and plain objects (without a custom prototype) to a Map. [Iterable objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol \"The iterable protocol\") may be converted to List, Map, or Set.\n\nIf a `reviver` is optionally provided, it will be called with every collection as a Seq (beginning with the most nested collections and proceeding to the top-level collection itself), along with the key referring to each collection and the parent JS object provided as `this`. For the top level, object, the key will be `\"\"`. This `reviver` is expected to return a new Immutable Collection, allowing for custom conversions from deep JS objects. Finally, a `path` is provided which is the sequence of keys to this value from the starting value.\n\n`reviver` acts similarly to the [same parameter in [`JSON.parse`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter \"Using the reviver parameter\").\n\nIf `reviver` is not provided, the default behavior will convert Objects into Maps and Arrays into Lists like so:\n\n``` ts\nconst { fromJS, isKeyed } = require('immutable')\nfunction (key, value) {\n  return isKeyed(value) ? value.toMap() : value.toList()\n}run it\n```\n\nAccordingly, this example converts native JS data to OrderedMap and List:\n\n``` ts\nconst { fromJS, isKeyed } = require('immutable')\nfromJS({ a: {b: [10, 20, 30]}, c: 40}, function (key, value, path) {\n  console.log(key, value, path)\n  return isKeyed(value) ? value.toOrderedMap() : value.toList()\n})\n\n> \"b\", [ 10, 20, 30 ], [ \"a\", \"b\" ]\n> \"a\", {b: [10, 20, 30]}, [ \"a\" ]\n> \"\", {a: {b: [10, 20, 30]}, c: 40}, []run it\n```\n\nKeep in mind, when using JS objects to construct Immutable Maps, that JavaScript Object properties are always strings, even if written in a quote-less shorthand, while Immutable Maps accept keys of any type.\n\n``` ts\nconst { Map } = require('immutable')\nlet obj = { 1: \"one\" };\nObject.keys(obj); // [ \"1\" ]\nassert.equal(obj[\"1\"], obj[1]); // \"one\" === \"one\"\n\nlet map = Map(obj);\nassert.notEqual(map.get(\"1\"), map.get(1)); // \"one\" !== undefinedrun it\n```\n\nProperty access for JavaScript Objects first converts the key to a string, but since Immutable Map keys can be of any type the argument to [`get()`](../get()/index) is not altered.\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/fromJS()/](https://immutable-js.com/docs/v4.2.1/fromJS()/)"
- name: get()
  id: get()/index
  summary: This documentation is generated from immutable.d.ts
  description: "# get()\n\n``` ts\nget<K, V>(collection: Collection<K, V>, key: K): V | undefined\nget<K, V, NSV>(collection: Collection<K, V>, key: K, notSetValue: NSV): V | NSV\nget<TProps, K>(record: Record<TProps>, key: K, notSetValue: unknown): TProps,[K]\nget<V>(collection: Array<V>, key: number): V | undefined\nget<V, NSV>(collection: Array<V>, key: number, notSetValue: NSV): V | NSV\nget<C, K>(object: C, key: K, notSetValue: unknown): C,[K]\nget<V>(collection: {[key: string]: V}, key: string): V | undefined\nget<V, NSV>(collection: {[key: string]: V},key: string,notSetValue: NSV): V | NSV\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/get()/](https://immutable-js.com/docs/v4.2.1/get()/)"
- name: getIn()
  id: getin()/index
  summary: Returns the value at the provided key path starting at the provided collection, or notSetValue if the key path is not defined
  description: "# getIn()\n\nReturns the value at the provided key path starting at the provided collection, or notSetValue if the key path is not defined.\n\n``` ts\ngetIn(collection: unknown,keyPath: Iterable<unknown>,notSetValue?: unknown): unknown\n```\n\n#### Discussion\n\nA functional alternative to `collection.getIn(keypath)` which will also work with plain Objects and Arrays.\n\n``` ts\nconst { getIn } = require('immutable')\ngetIn({ x: { y: { z: 123 }}}, ['x', 'y', 'z']) // 123\ngetIn({ x: { y: { z: 123 }}}, ['x', 'q', 'p'], 'ifNotSet') // 'ifNotSet'run it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/getIn()/](https://immutable-js.com/docs/v4.2.1/getIn()/)"
- name: has()
  id: has()/index
  summary: Returns true if the key is defined in the provided collection
  description: "# has()\n\nReturns true if the key is defined in the provided collection.\n\n``` ts\nhas(collection: object, key: unknown): boolean\n```\n\n#### Discussion\n\nA functional alternative to `collection.has(key)` which will also work with plain Objects and Arrays as an alternative for `collection.hasOwnProperty(key)`.\n\n``` ts\nconst { has } = require('immutable')\nhas([ 'dog', 'frog', 'cat' ], 2) // true\nhas([ 'dog', 'frog', 'cat' ], 5) // false\nhas({ x: 123, y: 456 }, 'x') // true\nhas({ x: 123, y: 456 }, 'z') // falserun it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/has()/](https://immutable-js.com/docs/v4.2.1/has()/)"
- name: hash()
  id: hash()/index
  summary: The hash() function is an important part of how Immutable determines if two values are equivalent and is used to determine how to store those values
  description: "# hash()\n\nThe [`hash()`](index) function is an important part of how Immutable determines if two values are equivalent and is used to determine how to store those values. Provided with any value, [`hash()`](index) will return a 31-bit integer.\n\n``` ts\nhash(value: unknown): number\n```\n\n#### Discussion\n\nWhen designing Objects which may be equal, it's important that when a `.equals()` method returns true, that both values `.hashCode()` method return the same value. [`hash()`](index) may be used to produce those values.\n\nFor non-Immutable Objects that do not provide a `.hashCode()` functions (including plain Objects, plain Arrays, Date objects, etc), a unique hash value will be created for each *instance*. That is, the create hash represents referential equality, and not value equality for Objects. This ensures that if that Object is mutated over time that its hash code will remain consistent, allowing Objects to be used as keys and values in Immutable.js collections.\n\nNote that [`hash()`](index) attempts to balance between speed and avoiding collisions, however it makes no attempt to produce secure hashes.\n\n*New in Version 4.0*\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/hash()/](https://immutable-js.com/docs/v4.2.1/hash()/)"
- name: hasIn()
  id: hasin()/index
  summary: Returns true if the key path is defined in the provided collection
  description: "# hasIn()\n\nReturns true if the key path is defined in the provided collection.\n\n``` ts\nhasIn(collection: unknown, keyPath: Iterable<unknown>): boolean\n```\n\n#### Discussion\n\nA functional alternative to `collection.hasIn(keypath)` which will also work with plain Objects and Arrays.\n\n``` ts\nconst { hasIn } = require('immutable')\nhasIn({ x: { y: { z: 123 }}}, ['x', 'y', 'z']) // true\nhasIn({ x: { y: { z: 123 }}}, ['x', 'q', 'p']) // falserun it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/hasIn()/](https://immutable-js.com/docs/v4.2.1/hasIn()/)"
- name: is()
  id: is()/index
  summary: Value equality check with semantics similar to Object.is, but treats Immutable Collections as values, equal if the second Collection includes equivalent values
  description: "# is()\n\nValue equality check with semantics similar to [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is), but treats Immutable [`Collection`](../collection/index)s as values, equal if the second [`Collection`](../collection/index) includes equivalent values.\n\n``` ts\nis(first: unknown, second: unknown): boolean\n```\n\n#### Discussion\n\nIt's used throughout Immutable when checking for equality, including [`Map`](../map/index) key equality and [`Set`](../set/index) membership.\n\n``` ts\nconst { Map, is } = require('immutable')\nconst map1 = Map({ a: 1, b: 1, c: 1 })\nconst map2 = Map({ a: 1, b: 1, c: 1 })\nassert.equal(map1 !== map2, true)\nassert.equal(Object.is(map1, map2), false)\nassert.equal(is(map1, map2), true)run it\n```\n\n[`is()`](index) compares primitive types like strings and numbers, Immutable.js collections like [`Map`](../map/index) and [`List`](../list/index), but also any custom object which implements [`ValueObject`](../valueobject/index) by providing `equals()` and `hashCode()` methods.\n\nNote: Unlike [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is), [`Immutable.is`](index) assumes `0` and `-0` are the same value, matching the behavior of ES6 Map key equality.\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/is()/](https://immutable-js.com/docs/v4.2.1/is()/)"
- name: isAssociative()
  id: isassociative()/index
  summary: True if maybeAssociative is either a Keyed or Indexed Collection
  description: "# isAssociative()\n\nTrue if `maybeAssociative` is either a Keyed or Indexed Collection.\n\n``` ts\nisAssociative(maybeAssociative: unknown): boolean\n```\n\n#### Discussion\n\n``` ts\nconst { isAssociative, Map, List, Stack, Set } = require('immutable');\nisAssociative([]); // false\nisAssociative({}); // false\nisAssociative(Map()); // true\nisAssociative(List()); // true\nisAssociative(Stack()); // true\nisAssociative(Set()); // falserun it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isAssociative()/](https://immutable-js.com/docs/v4.2.1/isAssociative()/)"
- name: isCollection()
  id: iscollection()/index
  summary: True if maybeCollection is a Collection, or any of its subclasses
  description: "# isCollection()\n\nTrue if `maybeCollection` is a Collection, or any of its subclasses.\n\n``` ts\nisCollection(maybeCollection: unknown): boolean\n```\n\n#### Discussion\n\n``` ts\nconst { isCollection, Map, List, Stack } = require('immutable');\nisCollection([]); // false\nisCollection({}); // false\nisCollection(Map()); // true\nisCollection(List()); // true\nisCollection(Stack()); // truerun it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isCollection()/](https://immutable-js.com/docs/v4.2.1/isCollection()/)"
- name: isImmutable()
  id: isimmutable()/index
  summary: True if maybeImmutable is an Immutable Collection or Record
  description: "# isImmutable()\n\nTrue if `maybeImmutable` is an Immutable Collection or Record.\n\n``` ts\nisImmutable(maybeImmutable: unknown): boolean\n```\n\n#### Discussion\n\nNote: Still returns true even if the collections is within a `withMutations()`.\n\n``` ts\nconst { isImmutable, Map, List, Stack } = require('immutable');\nisImmutable([]); // false\nisImmutable({}); // false\nisImmutable(Map()); // true\nisImmutable(List()); // true\nisImmutable(Stack()); // true\nisImmutable(Map().asMutable()); // truerun it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isImmutable()/](https://immutable-js.com/docs/v4.2.1/isImmutable()/)"
- name: isIndexed()
  id: isindexed()/index
  summary: True if maybeIndexed is a Collection.Indexed, or any of its subclasses
  description: "# isIndexed()\n\nTrue if `maybeIndexed` is a Collection.Indexed, or any of its subclasses.\n\n``` ts\nisIndexed(maybeIndexed: unknown): boolean\n```\n\n#### Discussion\n\n``` ts\nconst { isIndexed, Map, List, Stack, Set } = require('immutable');\nisIndexed([]); // false\nisIndexed({}); // false\nisIndexed(Map()); // false\nisIndexed(List()); // true\nisIndexed(Stack()); // true\nisIndexed(Set()); // falserun it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isIndexed()/](https://immutable-js.com/docs/v4.2.1/isIndexed()/)"
- name: isKeyed()
  id: iskeyed()/index
  summary: True if maybeKeyed is a Collection.Keyed, or any of its subclasses
  description: "# isKeyed()\n\nTrue if `maybeKeyed` is a Collection.Keyed, or any of its subclasses.\n\n``` ts\nisKeyed(maybeKeyed: unknown): boolean\n```\n\n#### Discussion\n\n``` ts\nconst { isKeyed, Map, List, Stack } = require('immutable');\nisKeyed([]); // false\nisKeyed({}); // false\nisKeyed(Map()); // true\nisKeyed(List()); // false\nisKeyed(Stack()); // falserun it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isKeyed()/](https://immutable-js.com/docs/v4.2.1/isKeyed()/)"
- name: isList()
  id: islist()/index
  summary: True if maybeList is a List
  description: "# isList()\n\nTrue if `maybeList` is a List.\n\n``` ts\nisList(maybeList: unknown): boolean\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isList()/](https://immutable-js.com/docs/v4.2.1/isList()/)"
- name: isMap()
  id: ismap()/index
  summary: True if maybeMap is a Map
  description: "# isMap()\n\nTrue if `maybeMap` is a Map.\n\n``` ts\nisMap(maybeMap: unknown): boolean\n```\n\n#### Discussion\n\nAlso true for OrderedMaps.\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isMap()/](https://immutable-js.com/docs/v4.2.1/isMap()/)"
- name: isOrdered()
  id: isordered()/index
  summary: True if maybeOrdered is a Collection where iteration order is well defined
  description: "# isOrdered()\n\nTrue if `maybeOrdered` is a Collection where iteration order is well defined. True for Collection.Indexed as well as OrderedMap and OrderedSet.\n\n``` ts\nisOrdered(maybeOrdered: unknown): boolean\n```\n\n#### Discussion\n\n``` ts\nconst { isOrdered, Map, OrderedMap, List, Set } = require('immutable');\nisOrdered([]); // false\nisOrdered({}); // false\nisOrdered(Map()); // false\nisOrdered(OrderedMap()); // true\nisOrdered(List()); // true\nisOrdered(Set()); // falserun it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isOrdered()/](https://immutable-js.com/docs/v4.2.1/isOrdered()/)"
- name: isOrderedMap()
  id: isorderedmap()/index
  summary: True if maybeOrderedMap is an OrderedMap
  description: "# isOrderedMap()\n\nTrue if `maybeOrderedMap` is an OrderedMap.\n\n``` ts\nisOrderedMap(maybeOrderedMap: unknown): boolean\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isOrderedMap()/](https://immutable-js.com/docs/v4.2.1/isOrderedMap()/)"
- name: isOrderedSet()
  id: isorderedset()/index
  summary: True if maybeOrderedSet is an OrderedSet
  description: "# isOrderedSet()\n\nTrue if `maybeOrderedSet` is an OrderedSet.\n\n``` ts\nisOrderedSet(maybeOrderedSet: unknown): boolean\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isOrderedSet()/](https://immutable-js.com/docs/v4.2.1/isOrderedSet()/)"
- name: isRecord()
  id: isrecord()/index
  summary: True if maybeRecord is a Record
  description: "# isRecord()\n\nTrue if `maybeRecord` is a Record.\n\n``` ts\nisRecord(maybeRecord: unknown): boolean\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isRecord()/](https://immutable-js.com/docs/v4.2.1/isRecord()/)"
- name: isSeq()
  id: isseq()/index
  summary: True if maybeSeq is a Seq
  description: "# isSeq()\n\nTrue if `maybeSeq` is a Seq.\n\n``` ts\nisSeq(maybeSeq: unknown): boolean\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isSeq()/](https://immutable-js.com/docs/v4.2.1/isSeq()/)"
- name: isSet()
  id: isset()/index
  summary: True if maybeSet is a Set
  description: "# isSet()\n\nTrue if `maybeSet` is a Set.\n\n``` ts\nisSet(maybeSet: unknown): boolean\n```\n\n#### Discussion\n\nAlso true for OrderedSets.\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isSet()/](https://immutable-js.com/docs/v4.2.1/isSet()/)"
- name: isStack()
  id: isstack()/index
  summary: True if maybeStack is a Stack
  description: "# isStack()\n\nTrue if `maybeStack` is a Stack.\n\n``` ts\nisStack(maybeStack: unknown): boolean\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isStack()/](https://immutable-js.com/docs/v4.2.1/isStack()/)"
- name: isValueObject()
  id: isvalueobject()/index
  summary: True if maybeValue is a JavaScript Object which has both equals() and hashCode() methods
  description: "# isValueObject()\n\nTrue if `maybeValue` is a JavaScript Object which has *both* `equals()` and `hashCode()` methods.\n\n``` ts\nisValueObject(maybeValue: unknown): boolean\n```\n\n#### Discussion\n\nAny two instances of *value objects* can be compared for value equality with [`Immutable.is()`](../is()/index) and can be used as keys in a [`Map`](../map/index) or members in a [`Set`](../set/index).\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/isValueObject()/](https://immutable-js.com/docs/v4.2.1/isValueObject()/)"
- name: List
  id: list/index
  summary: Lists are ordered indexed dense collections, much like a JavaScript Array
  description: "# List\n\nLists are ordered indexed dense collections, much like a JavaScript Array.\n\n``` ts\ntype List<T> extends Collection.Indexed<T>\n```\n\n#### Discussion\n\nLists are immutable and fully persistent with O(log32 N) gets and sets, and O(1) push and pop.\n\nLists implement Deque, with efficient addition and removal from both the end ([`push`](index#push()), [`pop`](index#pop())) and beginning ([`unshift`](index#unshift()), [`shift`](index#shift())).\n\nUnlike a JavaScript Array, there is no distinction between an \"unset\" index and an index set to `undefined`. [`List#forEach`](index#forEach()) visits all indices from 0 to size, regardless of whether they were explicitly defined.\n\n### Construction\n\n#### [List()](index#List())\n\nCreate a new immutable List containing the values of the provided collection-like.\n\n``` ts\nList<T>(collection?: Iterable<T> | ArrayLike<T>): List<T>\n```\n\n#### Discussion\n\nNote: [`List`](index) is a factory function and not a class, and does not use the `new` keyword during construction.\n\n``` ts\nconst { List, Set } = require('immutable')\n\nconst emptyList = List()\n// List []\n\nconst plainArray = [ 1, 2, 3, 4 ]\nconst listFromPlainArray = List(plainArray)\n// List [ 1, 2, 3, 4 ]\n\nconst plainSet = Set([ 1, 2, 3, 4 ])\nconst listFromPlainSet = List(plainSet)\n// List [ 1, 2, 3, 4 ]\n\nconst arrayIterator = plainArray[Symbol.iterator]()\nconst listFromCollectionArray = List(arrayIterator)\n// List [ 1, 2, 3, 4 ]\n\nlistFromPlainArray.equals(listFromCollectionArray) // true\nlistFromPlainSet.equals(listFromCollectionArray) // true\nlistFromPlainSet.equals(listFromPlainArray) // truerun it\n```\n\n### Static methods\n\n#### [List.isList()](index#isList())\n\n``` ts\nList.isList(maybeList: unknown): boolean\n```\n\n#### [List.of()](index#of())\n\n``` ts\nList.of<T>(...values: Array<T>): List<T>\n```\n\n### Members\n\n#### [size](index#size)\n\nThe number of items in this List.\n\n``` ts\nsize: number\n```\n\n### Persistent changes\n\n#### [set()](index#set())\n\nReturns a new List which includes `value` at `index`. If `index` already exists in this List, it will be replaced.\n\n``` ts\nset(index: number, value: T): List<T>\n```\n\n#### Discussion\n\n`index` may be a negative number, which indexes back from the end of the List. `v.set(-1, \"value\")` sets the last item in the List.\n\nIf `index` larger than [`size`](index#size), the returned List's [`size`](index#size) will be large enough to include the `index`.\n\n``` ts\nconst originalList = List([ 0 ]);\n// List [ 0 ]\noriginalList.set(1, 1);\n// List [ 0, 1 ]\noriginalList.set(0, 'overwritten');\n// List [ \"overwritten\" ]\noriginalList.set(2, 2);\n// List [ 0, undefined, 2 ]\n\nList().set(50000, 'value').size;\n// 50001run it\n```\n\nNote: [`set`](index#set()) can be used in [`withMutations`](index#withMutations()).\n\n#### [delete()](index#delete())\n\nReturns a new List which excludes this `index` and with a size 1 less than this List. Values at indices above `index` are shifted down by 1 to fill the position.\n\n``` ts\ndelete(index: number): List<T>\n```\n\n#### alias\n\n`remove()`\n\n#### Discussion\n\nThis is synonymous with `list.splice(index, 1)`.\n\n`index` may be a negative number, which indexes back from the end of the List. `v.delete(-1)` deletes the last item in the List.\n\nNote: [`delete`](index#delete()) cannot be safely used in IE8\n\n``` ts\nList([ 0, 1, 2, 3, 4 ]).delete(0);\n// List [ 1, 2, 3, 4 ]run it\n```\n\nSince [`delete()`](index#delete()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.\n\nNote: [`delete`](index#delete()) *cannot* be used in [`withMutations`](index#withMutations()).\n\n#### [insert()](index#insert())\n\nReturns a new List with `value` at `index` with a size 1 more than this List. Values at indices above `index` are shifted over by 1.\n\n``` ts\ninsert(index: number, value: T): List<T>\n```\n\n#### Discussion\n\nThis is synonymous with `list.splice(index, 0, value)`.\n\n``` ts\nList([ 0, 1, 2, 3, 4 ]).insert(6, 5)\n// List [ 0, 1, 2, 3, 4, 5 ]run it\n```\n\nSince [`insert()`](index#insert()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.\n\nNote: [`insert`](index#insert()) *cannot* be used in [`withMutations`](index#withMutations()).\n\n#### [clear()](index#clear())\n\nReturns a new List with 0 size and no values in constant time.\n\n``` ts\nclear(): List<T>\n```\n\n#### Discussion\n\n``` ts\nList([ 1, 2, 3, 4 ]).clear()\n// List []run it\n```\n\nNote: [`clear`](index#clear()) can be used in [`withMutations`](index#withMutations()).\n\n#### [push()](index#push())\n\nReturns a new List with the provided `values` appended, starting at this List's [`size`](index#size).\n\n``` ts\npush(...values: Array<T>): List<T>\n```\n\n#### Discussion\n\n``` ts\nList([ 1, 2, 3, 4 ]).push(5)\n// List [ 1, 2, 3, 4, 5 ]run it\n```\n\nNote: [`push`](index#push()) can be used in [`withMutations`](index#withMutations()).\n\n#### [pop()](index#pop())\n\nReturns a new List with a size ones less than this List, excluding the last index in this List.\n\n``` ts\npop(): List<T>\n```\n\n#### Discussion\n\nNote: this differs from [`Array#pop`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop) because it returns a new List rather than the removed value. Use [`last()`](index#last()) to get the last value in this List.\n\n``` ts\nList([ 1, 2, 3, 4 ]).pop()\n// List[ 1, 2, 3 ]\n```\n\nNote: [`pop`](index#pop()) can be used in [`withMutations`](index#withMutations()).\n\n#### [unshift()](index#unshift())\n\nReturns a new List with the provided `values` prepended, shifting other values ahead to higher indices.\n\n``` ts\nunshift(...values: Array<T>): List<T>\n```\n\n#### Discussion\n\n``` ts\nList([ 2, 3, 4]).unshift(1);\n// List [ 1, 2, 3, 4 ]run it\n```\n\nNote: [`unshift`](index#unshift()) can be used in [`withMutations`](index#withMutations()).\n\n#### [shift()](index#shift())\n\nReturns a new List with a size ones less than this List, excluding the first index in this List, shifting all other values to a lower index.\n\n``` ts\nshift(): List<T>\n```\n\n#### Discussion\n\nNote: this differs from [`Array#shift`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift) because it returns a new List rather than the removed value. Use [`first()`](index#first()) to get the first value in this List.\n\n``` ts\nList([ 0, 1, 2, 3, 4 ]).shift();\n// List [ 1, 2, 3, 4 ]run it\n```\n\nNote: [`shift`](index#shift()) can be used in [`withMutations`](index#withMutations()).\n\n#### [update()](index#update())\n\n``` ts\nupdate(index: number, notSetValue: T, updater: (value: T) => T): this\nupdate(index: number, updater: (value: T | undefined) => T): this\nupdate<R>(updater: (value: this) => R): R\n```\n\n#### Overrides\n\n[`Collection#update()`](../collection/index#update())\n\n#### [setSize()](index#setSize())\n\nReturns a new List with size `size`. If `size` is less than this List's size, the new List will exclude values at the higher indices. If `size` is greater than this List's size, the new List will have undefined values for the newly available indices.\n\n``` ts\nsetSize(size: number): List<T>\n```\n\n#### Discussion\n\nWhen building a new List and the final size is known up front, [`setSize`](index#setSize()) used in conjunction with [`withMutations`](index#withMutations()) may result in the more performant construction.\n\n### Deep persistent changes\n\n#### [setIn()](index#setIn())\n\nReturns a new List having set `value` at this `keyPath`. If any keys in `keyPath` do not exist, a new immutable Map will be created at that key.\n\n``` ts\nsetIn(keyPath: Iterable<unknown>, value: unknown): this\n```\n\n#### Discussion\n\nIndex numbers are used as keys to determine the path to follow in the List.\n\n``` ts\nconst { List } = require('immutable')\nconst list = List([ 0, 1, 2, List([ 3, 4 ])])\nlist.setIn([3, 0], 999);\n// List [ 0, 1, 2, List [ 999, 4 ] ]run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and setIn() can update those values as well, treating them immutably by creating new copies of those values with the changes applied.\n\n``` ts\nconst { List } = require('immutable')\nconst list = List([ 0, 1, 2, { plain: 'object' }])\nlist.setIn([3, 'plain'], 'value');\n// List([ 0, 1, 2, { plain: 'value' }])run it\n```\n\nNote: [`setIn`](index#setIn()) can be used in [`withMutations`](index#withMutations()).\n\n#### [deleteIn()](index#deleteIn())\n\nReturns a new List having removed the value at this `keyPath`. If any keys in `keyPath` do not exist, no change will occur.\n\n``` ts\ndeleteIn(keyPath: Iterable<unknown>): this\n```\n\n#### alias\n\n`removeIn()`\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nconst list = List([ 0, 1, 2, List([ 3, 4 ])])\nlist.deleteIn([3, 0]);\n// List [ 0, 1, 2, List [ 4 ] ]run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and removeIn() can update those values as well, treating them immutably by creating new copies of those values with the changes applied.\n\n``` ts\nconst { List } = require('immutable')\nconst list = List([ 0, 1, 2, { plain: 'object' }])\nlist.removeIn([3, 'plain']);\n// List([ 0, 1, 2, {}])run it\n```\n\nNote: [`deleteIn`](index#deleteIn()) *cannot* be safely used in [`withMutations`](index#withMutations()).\n\n#### [updateIn()](index#updateIn())\n\n``` ts\nupdateIn(keyPath: Iterable<unknown>,notSetValue: unknown,updater: (value: unknown) => unknown): this\nupdateIn(keyPath: Iterable<unknown>, updater: (value: unknown) => unknown): this\n```\n\n#### [mergeIn()](index#mergeIn())\n\nNote: [`mergeIn`](index#mergeIn()) can be used in [`withMutations`](index#withMutations()).\n\n``` ts\nmergeIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this\n```\n\n#### see\n\n[`Map#mergeIn`](../map/index#mergeIn())\n\n#### [mergeDeepIn()](index#mergeDeepIn())\n\nNote: [`mergeDeepIn`](index#mergeDeepIn()) can be used in [`withMutations`](index#withMutations()).\n\n``` ts\nmergeDeepIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this\n```\n\n#### see\n\n[`Map#mergeDeepIn`](../map/index#mergeDeepIn())\n\n### Transient changes\n\n#### [withMutations()](index#withMutations())\n\nNote: Not all methods can be safely used on a mutable collection or within [`withMutations`](index#withMutations())! Check the documentation for each method to see if it allows being used in [`withMutations`](index#withMutations()).\n\n``` ts\nwithMutations(mutator: (mutable: this) => unknown): this\n```\n\n#### see\n\n[`Map#withMutations`](../map/index#withMutations())\n\n#### [asMutable()](index#asMutable())\n\nAn alternative API for withMutations()\n\n``` ts\nasMutable(): this\n```\n\n#### see\n\n[`Map#asMutable`](../map/index#asMutable())\n\n#### Discussion\n\nNote: Not all methods can be safely used on a mutable collection or within [`withMutations`](index#withMutations())! Check the documentation for each method to see if it allows being used in [`withMutations`](index#withMutations()).\n\n#### [wasAltered()](index#wasAltered())\n\n``` ts\nwasAltered(): boolean\n```\n\n#### see\n\n[`Map#wasAltered`](../map/index#wasAltered())\n\n#### [asImmutable()](index#asImmutable())\n\n``` ts\nasImmutable(): this\n```\n\n#### see\n\n[`Map#asImmutable`](../map/index#asImmutable())\n\n### Sequence algorithms\n\n#### [concat()](index#concat())\n\nReturns a new List with other values or collections concatenated to this one.\n\n``` ts\nconcat<C>(...valuesOrCollections: Array<Iterable<C> | C>): List<T | C>\n```\n\n#### Overrides\n\n[`Collection.Indexed#concat()`](../collection.indexed/index#concat())\n\n#### alias\n\n`merge()`\n\n#### Discussion\n\nNote: [`concat`](index#concat()) can be used in [`withMutations`](index#withMutations()).\n\n#### [map()](index#map())\n\nReturns a new List with values passed through a `mapper` function.\n\n``` ts\nmap<M>(mapper: (value: T, key: number, iter: this) => M,context?: unknown): List<M>\n```\n\n#### Overrides\n\n[`Collection.Indexed#map()`](../collection.indexed/index#map())\n\n#### Discussion\n\n``` ts\nList([ 1, 2 ]).map(x => 10 * x)\n// List [ 10, 20 ]run it\n```\n\n#### [flatMap()](index#flatMap())\n\nFlat-maps the List, returning a new List.\n\n``` ts\nflatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>,context?: unknown): List<M>\n```\n\n#### Overrides\n\n[`Collection.Indexed#flatMap()`](../collection.indexed/index#flatMap())\n\n#### Discussion\n\nSimilar to `list.map(...).flatten(true)`.\n\n#### [filter()](index#filter())\n\n``` ts\nfilter<F>(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): List<F>\nfilter(predicate: (value: T, index: number, iter: this) => unknown,context?: unknown): this\n```\n\n#### Overrides\n\n[`Collection.Indexed#filter()`](../collection.indexed/index#filter())\n\n#### [partition()](index#partition())\n\n``` ts\npartition<F, C>(predicate: (this: C, value: T, index: number, iter: this) => boolean,context?: C): [List<T>, List<F>]\npartition<C>(predicate: (this: C, value: T, index: number, iter: this) => unknown,context?: C): [this, this]\n```\n\n#### Overrides\n\n[`Collection.Indexed#partition()`](../collection.indexed/index#partition())\n\n#### [zip()](index#zip())\n\n``` ts\nzip<U>(other: Collection<unknown, U>): List<[T, U]>\nzip<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): List<[T, U, V]>\nzip(...collections: Array<Collection<unknown, unknown>>): List<unknown>\n```\n\n#### Overrides\n\n[`Collection.Indexed#zip()`](../collection.indexed/index#zip())\n\n#### [zipAll()](index#zipAll())\n\n``` ts\nzipAll<U>(other: Collection<unknown, U>): List<[T, U]>\nzipAll<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): List<[T, U, V]>\nzipAll(...collections: Array<Collection<unknown, unknown>>): List<unknown>\n```\n\n#### Overrides\n\n[`Collection.Indexed#zipAll()`](../collection.indexed/index#zipAll())\n\n#### [zipWith()](index#zipWith())\n\n``` ts\nzipWith<U, Z>(zipper: (value: T, otherValue: U) => Z,otherCollection: Collection<unknown, U>): List<Z>\nzipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z,otherCollection: Collection<unknown, U>,thirdCollection: Collection<unknown, V>): List<Z>\nzipWith<Z>(zipper: (...values: Array<unknown>) => Z,...collections: Array<Collection<unknown, unknown>>): List<Z>\n```\n\n#### Overrides\n\n[`Collection.Indexed#zipWith()`](../collection.indexed/index#zipWith())\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection.Indexed#[Symbol.iterator]()`](../collection.indexed/index#%5BSymbol.iterator%5D())\n\n#### [filterNot()](index#filterNot())\n\nReturns a new Collection of the same type with only the entries for which the `predicate` function returns false.\n\n``` ts\nfilterNot(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#filterNot()`](../collection/index#filterNot())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }run it\n```\n\nNote: [`filterNot()`](index#filterNot()) always returns a new instance, even if it results in not filtering out any values.\n\n#### [reverse()](index#reverse())\n\nReturns a new Collection of the same type in reverse order.\n\n``` ts\nreverse(): this\n```\n\n#### Inherited from\n\n[`Collection#reverse()`](../collection/index#reverse())\n\n#### [sort()](index#sort())\n\nReturns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.\n\n``` ts\nsort(comparator?: (valueA: T, valueB: T) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sort()`](../collection/index#sort())\n\n#### Discussion\n\nIf a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n- Returns `0` if the elements should not be swapped.\n- Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n- Returns `1` (or any positive number) if `valueA` comes after `valueB`\n- Is pure, i.e. it must always return the same value for the same pair of values.\n\nWhen sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n``` ts\nconst { Map } = require('immutable')\nMap({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// OrderedMap { \"a\": 1, \"b\": 2, \"c\": 3 }run it\n```\n\nNote: [`sort()`](index#sort()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [sortBy()](index#sortBy())\n\nLike [`sort`](index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:\n\n``` ts\nsortBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sortBy()`](../collection/index#sortBy())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst beattles = Map({\n  John: { name: \"Lennon\" },\n  Paul: { name: \"McCartney\" },\n  George: { name: \"Harrison\" },\n  Ringo: { name: \"Starr\" },\n});\nbeattles.sortBy(member => member.name);run it\n```\n\nNote: [`sortBy()`](index#sortBy()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [groupBy()](index#groupBy())\n\nReturns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.\n\n``` ts\ngroupBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<number, T>>\n```\n\n#### Inherited from\n\n[`Collection#groupBy()`](../collection/index#groupBy())\n\n#### Discussion\n\nNote: This is always an eager operation.\n\n``` ts\nconst { List, Map } = require('immutable')\nconst listOfMaps = List([\n  Map({ v: 0 }),\n  Map({ v: 1 }),\n  Map({ v: 1 }),\n  Map({ v: 0 }),\n  Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ Map{ \"v\": 0 }, Map { \"v\": 0 } ],\n//   1: List [ Map{ \"v\": 1 }, Map { \"v\": 1 } ],\n//   2: List [ Map{ \"v\": 2 } ],\n// }run it\n```\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Indexed collection to equivalent native JavaScript Array.\n\n``` ts\ntoJS(): Array<DeepCopy<T>>\n```\n\n#### Inherited from\n\n[`Collection.Indexed#toJS()`](../collection.indexed/index#toJS())\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Indexed collection to equivalent native JavaScript Array.\n\n``` ts\ntoJSON(): Array<T>\n```\n\n#### Inherited from\n\n[`Collection.Indexed#toJSON()`](../collection.indexed/index#toJSON())\n\n#### [toArray()](index#toArray())\n\nShallowly converts this collection to an Array.\n\n``` ts\ntoArray(): Array<T>\n```\n\n#### Inherited from\n\n[`Collection.Indexed#toArray()`](../collection.indexed/index#toArray())\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Collection to an Object.\n\n``` ts\ntoObject(): {[key: string]: T}\n```\n\n#### Inherited from\n\n[`Collection#toObject()`](../collection/index#toObject())\n\n#### Discussion\n\nConverts keys to Strings.\n\n### Reading values\n\n#### [get()](index#get())\n\n``` ts\nget<NSV>(index: number, notSetValue: NSV): T | NSV\nget(index: number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection.Indexed#get()`](../collection.indexed/index#get())\n\n#### [has()](index#has())\n\nTrue if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nhas(key: number): boolean\n```\n\n#### Inherited from\n\n[`Collection#has()`](../collection/index#has())\n\n#### [includes()](index#includes())\n\nTrue if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nincludes(value: T): boolean\n```\n\n#### Inherited from\n\n[`Collection#includes()`](../collection/index#includes())\n\n#### alias\n\n`contains()`\n\n#### [first()](index#first())\n\nIn case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nfirst<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#first()`](../collection/index#first())\n\n#### [last()](index#last())\n\nIn case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nlast<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#last()`](../collection/index#last())\n\n### Conversion to Seq\n\n#### [toSeq()](index#toSeq())\n\nReturns Seq.Indexed.\n\n``` ts\ntoSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection.Indexed#toSeq()`](../collection.indexed/index#toSeq())\n\n#### [fromEntrySeq()](index#fromEntrySeq())\n\nIf this is a collection of \\[key, value\\] entry tuples, it will return a Seq.Keyed of those entries.\n\n``` ts\nfromEntrySeq(): Seq.Keyed<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection.Indexed#fromEntrySeq()`](../collection.indexed/index#fromEntrySeq())\n\n#### [toKeyedSeq()](index#toKeyedSeq())\n\nReturns a Seq.Keyed from this Collection where indices are treated as keys.\n\n``` ts\ntoKeyedSeq(): Seq.Keyed<number, T>\n```\n\n#### Inherited from\n\n[`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())\n\n#### Discussion\n\nThis is useful if you want to operate on an Collection.Indexed and preserve the \\[index, value\\] pairs.\n\nThe returned Seq will have identical iteration order as this Collection.\n\n``` ts\nconst { Seq } = require('immutable')\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\n// Seq [ \"A\", \"B\", \"C\" ]\nindexedSeq.filter(v => v === 'B')\n// Seq [ \"B\" ]\nconst keyedSeq = indexedSeq.toKeyedSeq()\n// Seq { 0: \"A\", 1: \"B\", 2: \"C\" }\nkeyedSeq.filter(v => v === 'B')\n// Seq { 1: \"B\" }run it\n```\n\n#### [toIndexedSeq()](index#toIndexedSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\ntoIndexedSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())\n\n#### [toSetSeq()](index#toSetSeq())\n\nReturns a Seq.Set of the values of this Collection, discarding keys.\n\n``` ts\ntoSetSeq(): Seq.Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSetSeq()`](../collection/index#toSetSeq())\n\n### Combination\n\n#### [interpose()](index#interpose())\n\nReturns a Collection of the same type with `separator` between each item in this Collection.\n\n``` ts\ninterpose(separator: T): this\n```\n\n#### Inherited from\n\n[`Collection.Indexed#interpose()`](../collection.indexed/index#interpose())\n\n#### [interleave()](index#interleave())\n\nReturns a Collection of the same type with the provided `collections` interleaved into this collection.\n\n``` ts\ninterleave(...collections: Array<Collection<unknown, T>>): this\n```\n\n#### Inherited from\n\n[`Collection.Indexed#interleave()`](../collection.indexed/index#interleave())\n\n#### Discussion\n\nThe resulting Collection includes the first item from each, then the second from each, etc.\n\n``` ts\nconst { List } = require('immutable')\nList([ 1, 2, 3 ]).interleave(List([ 'A', 'B', 'C' ]))\n// List [ 1, \"A\", 2, \"B\", 3, \"C\" ]run it\n```\n\nThe shortest Collection stops interleave.\n\n``` ts\nList([ 1, 2, 3 ]).interleave(\n  List([ 'A', 'B' ]),\n  List([ 'X', 'Y', 'Z' ])\n)\n// List [ 1, \"A\", \"X\", 2, \"B\", \"Y\" ]run it\n```\n\nSince [`interleave()`](index#interleave()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.\n\nNote: [`interleave`](index#interleave()) *cannot* be used in [`withMutations`](index#withMutations()).\n\n#### [splice()](index#splice())\n\nSplice returns a new indexed Collection by replacing a region of this Collection with new values. If values are not provided, it only skips the region to be removed.\n\n``` ts\nsplice(index: number, removeNum: number, ...values: Array<T>): this\n```\n\n#### Inherited from\n\n[`Collection.Indexed#splice()`](../collection.indexed/index#splice())\n\n#### Discussion\n\n`index` may be a negative number, which indexes back from the end of the Collection. `s.splice(-2)` splices after the second to last item.\n\n``` ts\nconst { List } = require('immutable')\nList([ 'a', 'b', 'c', 'd' ]).splice(1, 2, 'q', 'r', 's')\n// List [ \"a\", \"q\", \"r\", \"s\", \"d\" ]run it\n```\n\nSince [`splice()`](index#splice()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.\n\nNote: [`splice`](index#splice()) *cannot* be used in [`withMutations`](index#withMutations()).\n\n#### [flatten()](index#flatten())\n\n``` ts\nflatten(depth?: number): Collection<unknown, unknown>\nflatten(shallow?: boolean): Collection<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection#flatten()`](../collection/index#flatten())\n\n### Search for value\n\n#### [indexOf()](index#indexOf())\n\nReturns the first index at which a given value can be found in the Collection, or -1 if it is not present.\n\n``` ts\nindexOf(searchValue: T): number\n```\n\n#### Inherited from\n\n[`Collection.Indexed#indexOf()`](../collection.indexed/index#indexOf())\n\n#### [lastIndexOf()](index#lastIndexOf())\n\nReturns the last index at which a given value can be found in the Collection, or -1 if it is not present.\n\n``` ts\nlastIndexOf(searchValue: T): number\n```\n\n#### Inherited from\n\n[`Collection.Indexed#lastIndexOf()`](../collection.indexed/index#lastIndexOf())\n\n#### [findIndex()](index#findIndex())\n\nReturns the first index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.\n\n``` ts\nfindIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection.Indexed#findIndex()`](../collection.indexed/index#findIndex())\n\n#### [findLastIndex()](index#findLastIndex())\n\nReturns the last index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.\n\n``` ts\nfindLastIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection.Indexed#findLastIndex()`](../collection.indexed/index#findLastIndex())\n\n#### [find()](index#find())\n\nReturns the first value for which the `predicate` returns true.\n\n``` ts\nfind(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#find()`](../collection/index#find())\n\n#### [findLast()](index#findLast())\n\nReturns the last value for which the `predicate` returns true.\n\n``` ts\nfindLast(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLast()`](../collection/index#findLast())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findEntry()](index#findEntry())\n\nReturns the first \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findEntry()`](../collection/index#findEntry())\n\n#### [findLastEntry()](index#findLastEntry())\n\nReturns the last \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindLastEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastEntry()`](../collection/index#findLastEntry())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findKey()](index#findKey())\n\nReturns the key for which the `predicate` returns true.\n\n``` ts\nfindKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#findKey()`](../collection/index#findKey())\n\n#### [findLastKey()](index#findLastKey())\n\nReturns the last key for which the `predicate` returns true.\n\n``` ts\nfindLastKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastKey()`](../collection/index#findLastKey())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [keyOf()](index#keyOf())\n\nReturns the key associated with the search value, or undefined.\n\n``` ts\nkeyOf(searchValue: T): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#keyOf()`](../collection/index#keyOf())\n\n#### [lastKeyOf()](index#lastKeyOf())\n\nReturns the last key associated with the search value, or undefined.\n\n``` ts\nlastKeyOf(searchValue: T): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#lastKeyOf()`](../collection/index#lastKeyOf())\n\n#### [max()](index#max())\n\nReturns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmax(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#max()`](../collection/index#max())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [maxBy()](index#maxBy())\n\nLike [`max`](index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nmaxBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#maxBy()`](../collection/index#maxBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it\n```\n\n#### [min()](index#min())\n\nReturns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmin(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#min()`](../collection/index#min())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [minBy()](index#minBy())\n\nLike [`min`](index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nminBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#minBy()`](../collection/index#minBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it\n```\n\n### Value equality\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#equals()`](../collection/index#equals())\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Inherited from\n\n[`Collection#hashCode()`](../collection/index#hashCode())\n\n#### Discussion\n\nThe [`hashCode`](index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nIf two values have the same [`hashCode`](index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](index#hashCode())s, they must not be equal.\n\n### Reading deep values\n\n#### [getIn()](index#getIn())\n\nReturns the value found by following a path of keys or indices through nested Collections.\n\n``` ts\ngetIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown\n```\n\n#### Inherited from\n\n[`Collection#getIn()`](../collection/index#getIn())\n\n#### Discussion\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: [ { y: 123 } ] });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\n#### [hasIn()](index#hasIn())\n\nTrue if the result of following a path of keys or indices through nested Collections results in a set value.\n\n``` ts\nhasIn(searchKeyPath: Iterable<unknown>): boolean\n```\n\n#### Inherited from\n\n[`Collection#hasIn()`](../collection/index#hasIn())\n\n### Conversion to Collections\n\n#### [toMap()](index#toMap())\n\nConverts this Collection to a Map, Throws if keys are not hashable.\n\n``` ts\ntoMap(): Map<number, T>\n```\n\n#### Inherited from\n\n[`Collection#toMap()`](../collection/index#toMap())\n\n#### Discussion\n\nNote: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toOrderedMap()](index#toOrderedMap())\n\nConverts this Collection to a Map, maintaining the order of iteration.\n\n``` ts\ntoOrderedMap(): OrderedMap<number, T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedMap()`](../collection/index#toOrderedMap())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toSet()](index#toSet())\n\nConverts this Collection to a Set, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoSet(): Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSet()`](../collection/index#toSet())\n\n#### Discussion\n\nNote: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.\n\n#### [toOrderedSet()](index#toOrderedSet())\n\nConverts this Collection to a Set, maintaining the order of iteration and discarding keys.\n\n``` ts\ntoOrderedSet(): OrderedSet<T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedSet()`](../collection/index#toOrderedSet())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toList()](index#toList())\n\nConverts this Collection to a List, discarding keys.\n\n``` ts\ntoList(): List<T>\n```\n\n#### Inherited from\n\n[`Collection#toList()`](../collection/index#toList())\n\n#### Discussion\n\nThis is similar to [`List(collection)`](index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](index) creates a list of entry tuples.\n\n``` ts\nconst { Map, List } = require('immutable')\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\nList(myMap) // List [ [ \"a\", \"Apple\" ], [ \"b\", \"Banana\" ] ]\nmyMap.toList() // List [ \"Apple\", \"Banana\" ]run it\n```\n\n#### [toStack()](index#toStack())\n\nConverts this Collection to a Stack, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoStack(): Stack<T>\n```\n\n#### Inherited from\n\n[`Collection#toStack()`](../collection/index#toStack())\n\n#### Discussion\n\nNote: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.\n\n### Iterators\n\n#### [keys()](index#keys())\n\nAn iterator of this [`Collection`](../collection/index)'s keys.\n\n``` ts\nkeys(): IterableIterator<number>\n```\n\n#### Inherited from\n\n[`Collection#keys()`](../collection/index#keys())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](index#keySeq()) instead, if this is what you want.\n\n#### [values()](index#values())\n\nAn iterator of this [`Collection`](../collection/index)'s values.\n\n``` ts\nvalues(): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection#values()`](../collection/index#values())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](index#valueSeq()) instead, if this is what you want.\n\n#### [entries()](index#entries())\n\nAn iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.\n\n``` ts\nentries(): IterableIterator<[number, T]>\n```\n\n#### Inherited from\n\n[`Collection#entries()`](../collection/index#entries())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](index#entrySeq()) instead, if this is what you want.\n\n### Collections (Seq)\n\n#### [keySeq()](index#keySeq())\n\nReturns a new Seq.Indexed of the keys of this Collection, discarding values.\n\n``` ts\nkeySeq(): Seq.Indexed<number>\n```\n\n#### Inherited from\n\n[`Collection#keySeq()`](../collection/index#keySeq())\n\n#### [valueSeq()](index#valueSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\nvalueSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#valueSeq()`](../collection/index#valueSeq())\n\n#### [entrySeq()](index#entrySeq())\n\nReturns a new Seq.Indexed of \\[key, value\\] tuples.\n\n``` ts\nentrySeq(): Seq.Indexed<[number, T]>\n```\n\n#### Inherited from\n\n[`Collection#entrySeq()`](../collection/index#entrySeq())\n\n### Side effects\n\n#### [forEach()](index#forEach())\n\nThe `sideEffect` is executed for every entry in the Collection.\n\n``` ts\nforEach(sideEffect: (value: T, key: number, iter: this) => unknown,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#forEach()`](../collection/index#forEach())\n\n#### Discussion\n\nUnlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).\n\n### Creating subsets\n\n#### [slice()](index#slice())\n\nReturns a new Collection of the same type representing a portion of this Collection from start up to but not including end.\n\n``` ts\nslice(begin?: number, end?: number): this\n```\n\n#### Inherited from\n\n[`Collection#slice()`](../collection/index#slice())\n\n#### Discussion\n\nIf begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.\n\nIf the requested slice is equivalent to the current Collection, then it will return itself.\n\n#### [rest()](index#rest())\n\nReturns a new Collection of the same type containing all entries except the first.\n\n``` ts\nrest(): this\n```\n\n#### Inherited from\n\n[`Collection#rest()`](../collection/index#rest())\n\n#### [butLast()](index#butLast())\n\nReturns a new Collection of the same type containing all entries except the last.\n\n``` ts\nbutLast(): this\n```\n\n#### Inherited from\n\n[`Collection#butLast()`](../collection/index#butLast())\n\n#### [skip()](index#skip())\n\nReturns a new Collection of the same type which excludes the first `amount` entries from this Collection.\n\n``` ts\nskip(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skip()`](../collection/index#skip())\n\n#### [skipLast()](index#skipLast())\n\nReturns a new Collection of the same type which excludes the last `amount` entries from this Collection.\n\n``` ts\nskipLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skipLast()`](../collection/index#skipLast())\n\n#### [skipWhile()](index#skipWhile())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns false.\n\n``` ts\nskipWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipWhile()`](../collection/index#skipWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipWhile(x => x.match(/g/))\n// List [ \"cat\", \"hat\", \"god\" ]run it\n```\n\n#### [skipUntil()](index#skipUntil())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns true.\n\n``` ts\nskipUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipUntil()`](../collection/index#skipUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipUntil(x => x.match(/hat/))\n// List [ \"hat\", \"god\" ]run it\n```\n\n#### [take()](index#take())\n\nReturns a new Collection of the same type which includes the first `amount` entries from this Collection.\n\n``` ts\ntake(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#take()`](../collection/index#take())\n\n#### [takeLast()](index#takeLast())\n\nReturns a new Collection of the same type which includes the last `amount` entries from this Collection.\n\n``` ts\ntakeLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#takeLast()`](../collection/index#takeLast())\n\n#### [takeWhile()](index#takeWhile())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.\n\n``` ts\ntakeWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeWhile()`](../collection/index#takeWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeWhile(x => x.match(/o/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n#### [takeUntil()](index#takeUntil())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.\n\n``` ts\ntakeUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeUntil()`](../collection/index#takeUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeUntil(x => x.match(/at/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n### Reducing a value\n\n#### [reduce()](index#reduce())\n\n``` ts\nreduce<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R\nreduce<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduce()`](../collection/index#reduce())\n\n#### [reduceRight()](index#reduceRight())\n\n``` ts\nreduceRight<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R\nreduceRight<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduceRight()`](../collection/index#reduceRight())\n\n#### [every()](index#every())\n\nTrue if `predicate` returns true for all entries in the Collection.\n\n``` ts\nevery(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#every()`](../collection/index#every())\n\n#### [some()](index#some())\n\nTrue if `predicate` returns true for any entry in the Collection.\n\n``` ts\nsome(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#some()`](../collection/index#some())\n\n#### [join()](index#join())\n\nJoins values together as a string, inserting a separator between each. The default separator is `\",\"`.\n\n``` ts\njoin(separator?: string): string\n```\n\n#### Inherited from\n\n[`Collection#join()`](../collection/index#join())\n\n#### [isEmpty()](index#isEmpty())\n\nReturns true if this Collection includes no values.\n\n``` ts\nisEmpty(): boolean\n```\n\n#### Inherited from\n\n[`Collection#isEmpty()`](../collection/index#isEmpty())\n\n#### Discussion\n\nFor some lazy [`Seq`](../seq/index), [`isEmpty`](index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.\n\n#### [count()](index#count())\n\n``` ts\ncount(): number\ncount(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#count()`](../collection/index#count())\n\n#### [countBy()](index#countBy())\n\nReturns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.\n\n``` ts\ncountBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Map<G, number>\n```\n\n#### Inherited from\n\n[`Collection#countBy()`](../collection/index#countBy())\n\n#### Discussion\n\nNote: This is not a lazy operation.\n\n### Comparison\n\n#### [isSubset()](index#isSubset())\n\nTrue if `iter` includes every value in this Collection.\n\n``` ts\nisSubset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSubset()`](../collection/index#isSubset())\n\n#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/List/](https://immutable-js.com/docs/v4.2.1/List/)"
- name: List.[Symbol.iterator]()
  id: list/index#[Symbol.iterator]()
  summary: null
  belongs_to: List
  description: |-
    #### [\[Symbol.iterator\]()](index#%5BSymbol.iterator%5D())

    ``` ts
    [Symbol.iterator](): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection.Indexed#[Symbol.iterator]()`](../collection.indexed/index#%5BSymbol.iterator%5D())
- name: List.asImmutable()
  id: list/index#asImmutable()
  summary: null
  belongs_to: List
  description: |-
    #### [asImmutable()](index#asImmutable())

    ``` ts
    asImmutable(): this
    ```

    #### see

    [`Map#asImmutable`](../map/index#asImmutable())

    ### Sequence algorithms
- name: List.asMutable()
  id: list/index#asMutable()
  summary: 'Note: Not all methods can be safely used on a mutable collection or within withMutations! Check the documentation for each method to see if it allows being used in withMutations'
  belongs_to: List
  description: |-
    #### [asMutable()](index#asMutable())

    An alternative API for withMutations()

    ``` ts
    asMutable(): this
    ```

    #### see

    [`Map#asMutable`](../map/index#asMutable())

    #### Discussion

    Note: Not all methods can be safely used on a mutable collection or within [`withMutations`](index#withMutations())! Check the documentation for each method to see if it allows being used in [`withMutations`](index#withMutations()).
- name: List.butLast()
  id: list/index#butLast()
  summary: Returns a new Collection of the same type containing all entries except the last
  belongs_to: List
  description: |-
    #### [butLast()](index#butLast())

    Returns a new Collection of the same type containing all entries except the last.

    ``` ts
    butLast(): this
    ```

    #### Inherited from

    [`Collection#butLast()`](../collection/index#butLast())
- name: List.clear()
  id: list/index#clear()
  summary: Returns a new List with 0 size and no values in constant time
  belongs_to: List
  description: |-
    #### [clear()](index#clear())

    Returns a new List with 0 size and no values in constant time.

    ``` ts
    clear(): List<T>
    ```

    #### Discussion

    ``` ts
    List([ 1, 2, 3, 4 ]).clear()
    // List []run it
    ```

    Note: [`clear`](index#clear()) can be used in [`withMutations`](index#withMutations()).
- name: List.concat()
  id: list/index#concat()
  summary: Returns a new List with other values or collections concatenated to this one
  belongs_to: List
  description: |-
    #### [concat()](index#concat())

    Returns a new List with other values or collections concatenated to this one.

    ``` ts
    concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): List<T | C>
    ```

    #### Overrides

    [`Collection.Indexed#concat()`](../collection.indexed/index#concat())

    #### alias

    `merge()`

    #### Discussion

    Note: [`concat`](index#concat()) can be used in [`withMutations`](index#withMutations()).
- name: List.count()
  id: list/index#count()
  summary: null
  belongs_to: List
  description: |-
    #### [count()](index#count())

    ``` ts
    count(): number
    count(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#count()`](../collection/index#count())
- name: List.countBy()
  id: list/index#countBy()
  summary: Returns a Seq.Keyed of counts, grouped by the return value of the grouper function
  belongs_to: List
  description: |-
    #### [countBy()](index#countBy())

    Returns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.

    ``` ts
    countBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Map<G, number>
    ```

    #### Inherited from

    [`Collection#countBy()`](../collection/index#countBy())

    #### Discussion

    Note: This is not a lazy operation.

    ### Comparison
- name: List.delete()
  id: list/index#delete()
  summary: Returns a new List which excludes this index and with a size 1 less than this List
  belongs_to: List
  description: |-
    #### [delete()](index#delete())

    Returns a new List which excludes this `index` and with a size 1 less than this List. Values at indices above `index` are shifted down by 1 to fill the position.

    ``` ts
    delete(index: number): List<T>
    ```

    #### alias

    `remove()`

    #### Discussion

    This is synonymous with `list.splice(index, 1)`.

    `index` may be a negative number, which indexes back from the end of the List. `v.delete(-1)` deletes the last item in the List.

    Note: [`delete`](index#delete()) cannot be safely used in IE8

    ``` ts
    List([ 0, 1, 2, 3, 4 ]).delete(0);
    // List [ 1, 2, 3, 4 ]run it
    ```

    Since [`delete()`](index#delete()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.

    Note: [`delete`](index#delete()) *cannot* be used in [`withMutations`](index#withMutations()).
- name: List.deleteIn()
  id: list/index#deleteIn()
  summary: Returns a new List having removed the value at this keyPath
  belongs_to: List
  description: |-
    #### [deleteIn()](index#deleteIn())

    Returns a new List having removed the value at this `keyPath`. If any keys in `keyPath` do not exist, no change will occur.

    ``` ts
    deleteIn(keyPath: Iterable<unknown>): this
    ```

    #### alias

    `removeIn()`

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    const list = List([ 0, 1, 2, List([ 3, 4 ])])
    list.deleteIn([3, 0]);
    // List [ 0, 1, 2, List [ 4 ] ]run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and removeIn() can update those values as well, treating them immutably by creating new copies of those values with the changes applied.

    ``` ts
    const { List } = require('immutable')
    const list = List([ 0, 1, 2, { plain: 'object' }])
    list.removeIn([3, 'plain']);
    // List([ 0, 1, 2, {}])run it
    ```

    Note: [`deleteIn`](index#deleteIn()) *cannot* be safely used in [`withMutations`](index#withMutations()).
- name: List.entries()
  id: list/index#entries()
  summary: An iterator of this Collection's entries as [ key, value ] tuples
  belongs_to: List
  description: |-
    #### [entries()](index#entries())

    An iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.

    ``` ts
    entries(): IterableIterator<[number, T]>
    ```

    #### Inherited from

    [`Collection#entries()`](../collection/index#entries())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](index#entrySeq()) instead, if this is what you want.

    ### Collections (Seq)
- name: List.entrySeq()
  id: list/index#entrySeq()
  summary: Returns a new Seq.Indexed of [key, value] tuples
  belongs_to: List
  description: |-
    #### [entrySeq()](index#entrySeq())

    Returns a new Seq.Indexed of \[key, value\] tuples.

    ``` ts
    entrySeq(): Seq.Indexed<[number, T]>
    ```

    #### Inherited from

    [`Collection#entrySeq()`](../collection/index#entrySeq())

    ### Side effects
- name: List.equals()
  id: list/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: List
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Inherited from

    [`Collection#equals()`](../collection/index#equals())

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: List.every()
  id: list/index#every()
  summary: True if predicate returns true for all entries in the Collection
  belongs_to: List
  description: |-
    #### [every()](index#every())

    True if `predicate` returns true for all entries in the Collection.

    ``` ts
    every(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#every()`](../collection/index#every())
- name: List.filter()
  id: list/index#filter()
  summary: null
  belongs_to: List
  description: |-
    #### [filter()](index#filter())

    ``` ts
    filter<F>(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): List<F>
    filter(predicate: (value: T, index: number, iter: this) => unknown,context?: unknown): this
    ```

    #### Overrides

    [`Collection.Indexed#filter()`](../collection.indexed/index#filter())
- name: List.filterNot()
  id: list/index#filterNot()
  summary: Returns a new Collection of the same type with only the entries for which the predicate function returns false
  belongs_to: List
  description: |-
    #### [filterNot()](index#filterNot())

    Returns a new Collection of the same type with only the entries for which the `predicate` function returns false.

    ``` ts
    filterNot(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#filterNot()`](../collection/index#filterNot())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
    // Map { "a": 1, "c": 3 }run it
    ```

    Note: [`filterNot()`](index#filterNot()) always returns a new instance, even if it results in not filtering out any values.
- name: List.find()
  id: list/index#find()
  summary: Returns the first value for which the predicate returns true
  belongs_to: List
  description: |-
    #### [find()](index#find())

    Returns the first value for which the `predicate` returns true.

    ``` ts
    find(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#find()`](../collection/index#find())
- name: List.findEntry()
  id: list/index#findEntry()
  summary: Returns the first [key, value] entry for which the predicate returns true
  belongs_to: List
  description: |-
    #### [findEntry()](index#findEntry())

    Returns the first \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined
    ```

    #### Inherited from

    [`Collection#findEntry()`](../collection/index#findEntry())
- name: List.findIndex()
  id: list/index#findIndex()
  summary: Returns the first index in the Collection where a value satisfies the provided predicate function
  belongs_to: List
  description: |-
    #### [findIndex()](index#findIndex())

    Returns the first index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.

    ``` ts
    findIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection.Indexed#findIndex()`](../collection.indexed/index#findIndex())
- name: List.findKey()
  id: list/index#findKey()
  summary: Returns the key for which the predicate returns true
  belongs_to: List
  description: |-
    #### [findKey()](index#findKey())

    Returns the key for which the `predicate` returns true.

    ``` ts
    findKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined
    ```

    #### Inherited from

    [`Collection#findKey()`](../collection/index#findKey())
- name: List.findLast()
  id: list/index#findLast()
  summary: Returns the last value for which the predicate returns true
  belongs_to: List
  description: |-
    #### [findLast()](index#findLast())

    Returns the last value for which the `predicate` returns true.

    ``` ts
    findLast(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#findLast()`](../collection/index#findLast())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: List.findLastEntry()
  id: list/index#findLastEntry()
  summary: Returns the last [key, value] entry for which the predicate returns true
  belongs_to: List
  description: |-
    #### [findLastEntry()](index#findLastEntry())

    Returns the last \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findLastEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined
    ```

    #### Inherited from

    [`Collection#findLastEntry()`](../collection/index#findLastEntry())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: List.findLastIndex()
  id: list/index#findLastIndex()
  summary: Returns the last index in the Collection where a value satisfies the provided predicate function
  belongs_to: List
  description: |-
    #### [findLastIndex()](index#findLastIndex())

    Returns the last index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.

    ``` ts
    findLastIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection.Indexed#findLastIndex()`](../collection.indexed/index#findLastIndex())
- name: List.findLastKey()
  id: list/index#findLastKey()
  summary: Returns the last key for which the predicate returns true
  belongs_to: List
  description: |-
    #### [findLastKey()](index#findLastKey())

    Returns the last key for which the `predicate` returns true.

    ``` ts
    findLastKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined
    ```

    #### Inherited from

    [`Collection#findLastKey()`](../collection/index#findLastKey())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: List.first()
  id: list/index#first()
  summary: In case the Collection is not empty returns the first element of the Collection
  belongs_to: List
  description: |-
    #### [first()](index#first())

    In case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    first<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#first()`](../collection/index#first())
- name: List.flatMap()
  id: list/index#flatMap()
  summary: Flat-maps the List, returning a new List
  belongs_to: List
  description: |-
    #### [flatMap()](index#flatMap())

    Flat-maps the List, returning a new List.

    ``` ts
    flatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>,context?: unknown): List<M>
    ```

    #### Overrides

    [`Collection.Indexed#flatMap()`](../collection.indexed/index#flatMap())

    #### Discussion

    Similar to `list.map(...).flatten(true)`.
- name: List.flatten()
  id: list/index#flatten()
  summary: null
  belongs_to: List
  description: |-
    #### [flatten()](index#flatten())

    ``` ts
    flatten(depth?: number): Collection<unknown, unknown>
    flatten(shallow?: boolean): Collection<unknown, unknown>
    ```

    #### Inherited from

    [`Collection#flatten()`](../collection/index#flatten())

    ### Search for value
- name: List.forEach()
  id: list/index#forEach()
  summary: The sideEffect is executed for every entry in the Collection
  belongs_to: List
  description: |-
    #### [forEach()](index#forEach())

    The `sideEffect` is executed for every entry in the Collection.

    ``` ts
    forEach(sideEffect: (value: T, key: number, iter: this) => unknown,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#forEach()`](../collection/index#forEach())

    #### Discussion

    Unlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).

    ### Creating subsets
- name: List.fromEntrySeq()
  id: list/index#fromEntrySeq()
  summary: If this is a collection of [key, value] entry tuples, it will return a Seq.Keyed of those entries
  belongs_to: List
  description: |-
    #### [fromEntrySeq()](index#fromEntrySeq())

    If this is a collection of \[key, value\] entry tuples, it will return a Seq.Keyed of those entries.

    ``` ts
    fromEntrySeq(): Seq.Keyed<unknown, unknown>
    ```

    #### Inherited from

    [`Collection.Indexed#fromEntrySeq()`](../collection.indexed/index#fromEntrySeq())
- name: List.get()
  id: list/index#get()
  summary: null
  belongs_to: List
  description: |-
    #### [get()](index#get())

    ``` ts
    get<NSV>(index: number, notSetValue: NSV): T | NSV
    get(index: number): T | undefined
    ```

    #### Inherited from

    [`Collection.Indexed#get()`](../collection.indexed/index#get())
- name: List.getIn()
  id: list/index#getIn()
  summary: Returns the value found by following a path of keys or indices through nested Collections
  belongs_to: List
  description: |-
    #### [getIn()](index#getIn())

    Returns the value found by following a path of keys or indices through nested Collections.

    ``` ts
    getIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown
    ```

    #### Inherited from

    [`Collection#getIn()`](../collection/index#getIn())

    #### Discussion

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: [ { y: 123 } ] });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```
- name: List.groupBy()
  id: list/index#groupBy()
  summary: Returns a Collection.Keyed of Collection.Keyeds, grouped by the return value of the grouper function
  belongs_to: List
  description: |-
    #### [groupBy()](index#groupBy())

    Returns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.

    ``` ts
    groupBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<number, T>>
    ```

    #### Inherited from

    [`Collection#groupBy()`](../collection/index#groupBy())

    #### Discussion

    Note: This is always an eager operation.

    ``` ts
    const { List, Map } = require('immutable')
    const listOfMaps = List([
      Map({ v: 0 }),
      Map({ v: 1 }),
      Map({ v: 1 }),
      Map({ v: 0 }),
      Map({ v: 2 })
    ])
    const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
    // Map {
    //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
    //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
    //   2: List [ Map{ "v": 2 } ],
    // }run it
    ```

    ### Conversion to JavaScript types
- name: List.has()
  id: list/index#has()
  summary: null
  belongs_to: List
  description: |-
    #### [has()](index#has())

    True if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    has(key: number): boolean
    ```

    #### Inherited from

    [`Collection#has()`](../collection/index#has())
- name: List.hashCode()
  id: list/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: List
  description: |-
    #### [hashCode()](index#hashCode())

    Computes and returns the hashed identity for this Collection.

    ``` ts
    hashCode(): number
    ```

    #### Inherited from

    [`Collection#hashCode()`](../collection/index#hashCode())

    #### Discussion

    The [`hashCode`](index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.

    ``` ts
    const a = List([ 1, 2, 3 ]);
    const b = List([ 1, 2, 3 ]);
    assert.notStrictEqual(a, b); // different instances
    const set = Set([ a ]);
    assert.equal(set.has(b), true);run it
    ```

    If two values have the same [`hashCode`](index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](index#hashCode())s, they must not be equal.

    ### Reading deep values
- name: List.hasIn()
  id: list/index#hasIn()
  summary: True if the result of following a path of keys or indices through nested Collections results in a set value
  belongs_to: List
  description: |-
    #### [hasIn()](index#hasIn())

    True if the result of following a path of keys or indices through nested Collections results in a set value.

    ``` ts
    hasIn(searchKeyPath: Iterable<unknown>): boolean
    ```

    #### Inherited from

    [`Collection#hasIn()`](../collection/index#hasIn())

    ### Conversion to Collections
- name: List.includes()
  id: list/index#includes()
  summary: null
  belongs_to: List
  description: |-
    #### [includes()](index#includes())

    True if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    includes(value: T): boolean
    ```

    #### Inherited from

    [`Collection#includes()`](../collection/index#includes())

    #### alias

    `contains()`
- name: List.indexOf()
  id: list/index#indexOf()
  summary: Returns the first index at which a given value can be found in the Collection, or -1 if it is not present
  belongs_to: List
  description: |-
    #### [indexOf()](index#indexOf())

    Returns the first index at which a given value can be found in the Collection, or -1 if it is not present.

    ``` ts
    indexOf(searchValue: T): number
    ```

    #### Inherited from

    [`Collection.Indexed#indexOf()`](../collection.indexed/index#indexOf())
- name: List.insert()
  id: list/index#insert()
  summary: Returns a new List with value at index with a size 1 more than this List
  belongs_to: List
  description: |-
    #### [insert()](index#insert())

    Returns a new List with `value` at `index` with a size 1 more than this List. Values at indices above `index` are shifted over by 1.

    ``` ts
    insert(index: number, value: T): List<T>
    ```

    #### Discussion

    This is synonymous with `list.splice(index, 0, value)`.

    ``` ts
    List([ 0, 1, 2, 3, 4 ]).insert(6, 5)
    // List [ 0, 1, 2, 3, 4, 5 ]run it
    ```

    Since [`insert()`](index#insert()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.

    Note: [`insert`](index#insert()) *cannot* be used in [`withMutations`](index#withMutations()).
- name: List.interleave()
  id: list/index#interleave()
  summary: Returns a Collection of the same type with the provided collections interleaved into this collection
  belongs_to: List
  description: |-
    #### [interleave()](index#interleave())

    Returns a Collection of the same type with the provided `collections` interleaved into this collection.

    ``` ts
    interleave(...collections: Array<Collection<unknown, T>>): this
    ```

    #### Inherited from

    [`Collection.Indexed#interleave()`](../collection.indexed/index#interleave())

    #### Discussion

    The resulting Collection includes the first item from each, then the second from each, etc.

    ``` ts
    const { List } = require('immutable')
    List([ 1, 2, 3 ]).interleave(List([ 'A', 'B', 'C' ]))
    // List [ 1, "A", 2, "B", 3, "C" ]run it
    ```

    The shortest Collection stops interleave.

    ``` ts
    List([ 1, 2, 3 ]).interleave(
      List([ 'A', 'B' ]),
      List([ 'X', 'Y', 'Z' ])
    )
    // List [ 1, "A", "X", 2, "B", "Y" ]run it
    ```

    Since [`interleave()`](index#interleave()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.

    Note: [`interleave`](index#interleave()) *cannot* be used in [`withMutations`](index#withMutations()).
- name: List.interpose()
  id: list/index#interpose()
  summary: Returns a Collection of the same type with separator between each item in this Collection
  belongs_to: List
  description: |-
    #### [interpose()](index#interpose())

    Returns a Collection of the same type with `separator` between each item in this Collection.

    ``` ts
    interpose(separator: T): this
    ```

    #### Inherited from

    [`Collection.Indexed#interpose()`](../collection.indexed/index#interpose())
- name: List.isEmpty()
  id: list/index#isEmpty()
  summary: Returns true if this Collection includes no values
  belongs_to: List
  description: |-
    #### [isEmpty()](index#isEmpty())

    Returns true if this Collection includes no values.

    ``` ts
    isEmpty(): boolean
    ```

    #### Inherited from

    [`Collection#isEmpty()`](../collection/index#isEmpty())

    #### Discussion

    For some lazy [`Seq`](../seq/index), [`isEmpty`](index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.
- name: List.isSubset()
  id: list/index#isSubset()
  summary: True if iter includes every value in this Collection
  belongs_to: List
  description: |-
    #### [isSubset()](index#isSubset())

    True if `iter` includes every value in this Collection.

    ``` ts
    isSubset(iter: Iterable<T>): boolean
    ```

    #### Inherited from

    [`Collection#isSubset()`](../collection/index#isSubset())
- name: List.isSuperset()
  id: list/index#isSuperset()
  summary: True if this Collection includes every value in iter
  belongs_to: List
  description: "#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/List/](https://immutable-js.com/docs/v4.2.1/List/)"
- name: List.join()
  id: list/index#join()
  summary: Joins values together as a string, inserting a separator between each
  belongs_to: List
  description: |-
    #### [join()](index#join())

    Joins values together as a string, inserting a separator between each. The default separator is `","`.

    ``` ts
    join(separator?: string): string
    ```

    #### Inherited from

    [`Collection#join()`](../collection/index#join())
- name: List.keyOf()
  id: list/index#keyOf()
  summary: Returns the key associated with the search value, or undefined
  belongs_to: List
  description: |-
    #### [keyOf()](index#keyOf())

    Returns the key associated with the search value, or undefined.

    ``` ts
    keyOf(searchValue: T): number | undefined
    ```

    #### Inherited from

    [`Collection#keyOf()`](../collection/index#keyOf())
- name: List.keys()
  id: list/index#keys()
  summary: An iterator of this Collection's keys
  belongs_to: List
  description: |-
    #### [keys()](index#keys())

    An iterator of this [`Collection`](../collection/index)'s keys.

    ``` ts
    keys(): IterableIterator<number>
    ```

    #### Inherited from

    [`Collection#keys()`](../collection/index#keys())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](index#keySeq()) instead, if this is what you want.
- name: List.keySeq()
  id: list/index#keySeq()
  summary: Returns a new Seq.Indexed of the keys of this Collection, discarding values
  belongs_to: List
  description: |-
    #### [keySeq()](index#keySeq())

    Returns a new Seq.Indexed of the keys of this Collection, discarding values.

    ``` ts
    keySeq(): Seq.Indexed<number>
    ```

    #### Inherited from

    [`Collection#keySeq()`](../collection/index#keySeq())
- name: List.last()
  id: list/index#last()
  summary: In case the Collection is not empty returns the last element of the Collection
  belongs_to: List
  description: |-
    #### [last()](index#last())

    In case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    last<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#last()`](../collection/index#last())

    ### Conversion to Seq
- name: List.lastIndexOf()
  id: list/index#lastIndexOf()
  summary: Returns the last index at which a given value can be found in the Collection, or -1 if it is not present
  belongs_to: List
  description: |-
    #### [lastIndexOf()](index#lastIndexOf())

    Returns the last index at which a given value can be found in the Collection, or -1 if it is not present.

    ``` ts
    lastIndexOf(searchValue: T): number
    ```

    #### Inherited from

    [`Collection.Indexed#lastIndexOf()`](../collection.indexed/index#lastIndexOf())
- name: List.lastKeyOf()
  id: list/index#lastKeyOf()
  summary: Returns the last key associated with the search value, or undefined
  belongs_to: List
  description: |-
    #### [lastKeyOf()](index#lastKeyOf())

    Returns the last key associated with the search value, or undefined.

    ``` ts
    lastKeyOf(searchValue: T): number | undefined
    ```

    #### Inherited from

    [`Collection#lastKeyOf()`](../collection/index#lastKeyOf())
- name: List.List()
  id: list/index#List()
  summary: Create a new immutable List containing the values of the provided collection-like
  belongs_to: List
  description: |-
    #### [List()](index#List())

    Create a new immutable List containing the values of the provided collection-like.

    ``` ts
    List<T>(collection?: Iterable<T> | ArrayLike<T>): List<T>
    ```

    #### Discussion

    Note: [`List`](index) is a factory function and not a class, and does not use the `new` keyword during construction.

    ``` ts
    const { List, Set } = require('immutable')

    const emptyList = List()
    // List []

    const plainArray = [ 1, 2, 3, 4 ]
    const listFromPlainArray = List(plainArray)
    // List [ 1, 2, 3, 4 ]

    const plainSet = Set([ 1, 2, 3, 4 ])
    const listFromPlainSet = List(plainSet)
    // List [ 1, 2, 3, 4 ]

    const arrayIterator = plainArray[Symbol.iterator]()
    const listFromCollectionArray = List(arrayIterator)
    // List [ 1, 2, 3, 4 ]

    listFromPlainArray.equals(listFromCollectionArray) // true
    listFromPlainSet.equals(listFromCollectionArray) // true
    listFromPlainSet.equals(listFromPlainArray) // truerun it
    ```

    ### Static methods
- name: List.List.isList()
  id: list/index#isList()
  summary: null
  belongs_to: List
  description: |-
    #### [List.isList()](index#isList())

    ``` ts
    List.isList(maybeList: unknown): boolean
    ```
- name: List.List.of()
  id: list/index#of()
  summary: null
  belongs_to: List
  description: |-
    #### [List.of()](index#of())

    ``` ts
    List.of<T>(...values: Array<T>): List<T>
    ```

    ### Members
- name: List.map()
  id: list/index#map()
  summary: Returns a new List with values passed through a mapper function
  belongs_to: List
  description: |-
    #### [map()](index#map())

    Returns a new List with values passed through a `mapper` function.

    ``` ts
    map<M>(mapper: (value: T, key: number, iter: this) => M,context?: unknown): List<M>
    ```

    #### Overrides

    [`Collection.Indexed#map()`](../collection.indexed/index#map())

    #### Discussion

    ``` ts
    List([ 1, 2 ]).map(x => 10 * x)
    // List [ 10, 20 ]run it
    ```
- name: List.max()
  id: list/index#max()
  summary: Returns the maximum value in this collection
  belongs_to: List
  description: |-
    #### [max()](index#max())

    Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    max(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#max()`](../collection/index#max())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: List.maxBy()
  id: list/index#maxBy()
  summary: null
  belongs_to: List
  description: |-
    #### [maxBy()](index#maxBy())

    Like [`max`](index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    maxBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#maxBy()`](../collection/index#maxBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it
    ```
- name: List.mergeDeepIn()
  id: list/index#mergeDeepIn()
  summary: 'Note: mergeDeepIn can be used in withMutations'
  belongs_to: List
  description: |-
    #### [mergeDeepIn()](index#mergeDeepIn())

    Note: [`mergeDeepIn`](index#mergeDeepIn()) can be used in [`withMutations`](index#withMutations()).

    ``` ts
    mergeDeepIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this
    ```

    #### see

    [`Map#mergeDeepIn`](../map/index#mergeDeepIn())

    ### Transient changes
- name: List.mergeIn()
  id: list/index#mergeIn()
  summary: 'Note: mergeIn can be used in withMutations'
  belongs_to: List
  description: |-
    #### [mergeIn()](index#mergeIn())

    Note: [`mergeIn`](index#mergeIn()) can be used in [`withMutations`](index#withMutations()).

    ``` ts
    mergeIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this
    ```

    #### see

    [`Map#mergeIn`](../map/index#mergeIn())
- name: List.min()
  id: list/index#min()
  summary: Returns the minimum value in this collection
  belongs_to: List
  description: |-
    #### [min()](index#min())

    Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    min(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#min()`](../collection/index#min())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: List.minBy()
  id: list/index#minBy()
  summary: null
  belongs_to: List
  description: |-
    #### [minBy()](index#minBy())

    Like [`min`](index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    minBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#minBy()`](../collection/index#minBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it
    ```

    ### Value equality
- name: List.partition()
  id: list/index#partition()
  summary: null
  belongs_to: List
  description: |-
    #### [partition()](index#partition())

    ``` ts
    partition<F, C>(predicate: (this: C, value: T, index: number, iter: this) => boolean,context?: C): [List<T>, List<F>]
    partition<C>(predicate: (this: C, value: T, index: number, iter: this) => unknown,context?: C): [this, this]
    ```

    #### Overrides

    [`Collection.Indexed#partition()`](../collection.indexed/index#partition())
- name: List.pop()
  id: list/index#pop()
  summary: Returns a new List with a size ones less than this List, excluding the last index in this List
  belongs_to: List
  description: |-
    #### [pop()](index#pop())

    Returns a new List with a size ones less than this List, excluding the last index in this List.

    ``` ts
    pop(): List<T>
    ```

    #### Discussion

    Note: this differs from [`Array#pop`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop) because it returns a new List rather than the removed value. Use [`last()`](index#last()) to get the last value in this List.

    ``` ts
    List([ 1, 2, 3, 4 ]).pop()
    // List[ 1, 2, 3 ]
    ```

    Note: [`pop`](index#pop()) can be used in [`withMutations`](index#withMutations()).
- name: List.push()
  id: list/index#push()
  summary: Returns a new List with the provided values appended, starting at this List's size
  belongs_to: List
  description: |-
    #### [push()](index#push())

    Returns a new List with the provided `values` appended, starting at this List's [`size`](index#size).

    ``` ts
    push(...values: Array<T>): List<T>
    ```

    #### Discussion

    ``` ts
    List([ 1, 2, 3, 4 ]).push(5)
    // List [ 1, 2, 3, 4, 5 ]run it
    ```

    Note: [`push`](index#push()) can be used in [`withMutations`](index#withMutations()).
- name: List.reduce()
  id: list/index#reduce()
  summary: null
  belongs_to: List
  description: |-
    #### [reduce()](index#reduce())

    ``` ts
    reduce<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R
    reduce<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduce()`](../collection/index#reduce())
- name: List.reduceRight()
  id: list/index#reduceRight()
  summary: null
  belongs_to: List
  description: |-
    #### [reduceRight()](index#reduceRight())

    ``` ts
    reduceRight<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R
    reduceRight<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduceRight()`](../collection/index#reduceRight())
- name: List.rest()
  id: list/index#rest()
  summary: Returns a new Collection of the same type containing all entries except the first
  belongs_to: List
  description: |-
    #### [rest()](index#rest())

    Returns a new Collection of the same type containing all entries except the first.

    ``` ts
    rest(): this
    ```

    #### Inherited from

    [`Collection#rest()`](../collection/index#rest())
- name: List.reverse()
  id: list/index#reverse()
  summary: Returns a new Collection of the same type in reverse order
  belongs_to: List
  description: |-
    #### [reverse()](index#reverse())

    Returns a new Collection of the same type in reverse order.

    ``` ts
    reverse(): this
    ```

    #### Inherited from

    [`Collection#reverse()`](../collection/index#reverse())
- name: List.set()
  id: list/index#set()
  summary: Returns a new List which includes value at index
  belongs_to: List
  description: |-
    #### [set()](index#set())

    Returns a new List which includes `value` at `index`. If `index` already exists in this List, it will be replaced.

    ``` ts
    set(index: number, value: T): List<T>
    ```

    #### Discussion

    `index` may be a negative number, which indexes back from the end of the List. `v.set(-1, "value")` sets the last item in the List.

    If `index` larger than [`size`](index#size), the returned List's [`size`](index#size) will be large enough to include the `index`.

    ``` ts
    const originalList = List([ 0 ]);
    // List [ 0 ]
    originalList.set(1, 1);
    // List [ 0, 1 ]
    originalList.set(0, 'overwritten');
    // List [ "overwritten" ]
    originalList.set(2, 2);
    // List [ 0, undefined, 2 ]

    List().set(50000, 'value').size;
    // 50001run it
    ```

    Note: [`set`](index#set()) can be used in [`withMutations`](index#withMutations()).
- name: List.setIn()
  id: list/index#setIn()
  summary: Returns a new List having set value at this keyPath
  belongs_to: List
  description: |-
    #### [setIn()](index#setIn())

    Returns a new List having set `value` at this `keyPath`. If any keys in `keyPath` do not exist, a new immutable Map will be created at that key.

    ``` ts
    setIn(keyPath: Iterable<unknown>, value: unknown): this
    ```

    #### Discussion

    Index numbers are used as keys to determine the path to follow in the List.

    ``` ts
    const { List } = require('immutable')
    const list = List([ 0, 1, 2, List([ 3, 4 ])])
    list.setIn([3, 0], 999);
    // List [ 0, 1, 2, List [ 999, 4 ] ]run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and setIn() can update those values as well, treating them immutably by creating new copies of those values with the changes applied.

    ``` ts
    const { List } = require('immutable')
    const list = List([ 0, 1, 2, { plain: 'object' }])
    list.setIn([3, 'plain'], 'value');
    // List([ 0, 1, 2, { plain: 'value' }])run it
    ```

    Note: [`setIn`](index#setIn()) can be used in [`withMutations`](index#withMutations()).
- name: List.setSize()
  id: list/index#setSize()
  summary: Returns a new List with size size
  belongs_to: List
  description: |-
    #### [setSize()](index#setSize())

    Returns a new List with size `size`. If `size` is less than this List's size, the new List will exclude values at the higher indices. If `size` is greater than this List's size, the new List will have undefined values for the newly available indices.

    ``` ts
    setSize(size: number): List<T>
    ```

    #### Discussion

    When building a new List and the final size is known up front, [`setSize`](index#setSize()) used in conjunction with [`withMutations`](index#withMutations()) may result in the more performant construction.

    ### Deep persistent changes
- name: List.shift()
  id: list/index#shift()
  summary: Returns a new List with a size ones less than this List, excluding the first index in this List, shifting all other values to a lower index
  belongs_to: List
  description: |-
    #### [shift()](index#shift())

    Returns a new List with a size ones less than this List, excluding the first index in this List, shifting all other values to a lower index.

    ``` ts
    shift(): List<T>
    ```

    #### Discussion

    Note: this differs from [`Array#shift`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift) because it returns a new List rather than the removed value. Use [`first()`](index#first()) to get the first value in this List.

    ``` ts
    List([ 0, 1, 2, 3, 4 ]).shift();
    // List [ 1, 2, 3, 4 ]run it
    ```

    Note: [`shift`](index#shift()) can be used in [`withMutations`](index#withMutations()).
- name: List.size
  id: list/index#size
  summary: The number of items in this List
  belongs_to: List
  description: |-
    #### [size](index#size)

    The number of items in this List.

    ``` ts
    size: number
    ```

    ### Persistent changes
- name: List.skip()
  id: list/index#skip()
  summary: Returns a new Collection of the same type which excludes the first amount entries from this Collection
  belongs_to: List
  description: |-
    #### [skip()](index#skip())

    Returns a new Collection of the same type which excludes the first `amount` entries from this Collection.

    ``` ts
    skip(amount: number): this
    ```

    #### Inherited from

    [`Collection#skip()`](../collection/index#skip())
- name: List.skipLast()
  id: list/index#skipLast()
  summary: Returns a new Collection of the same type which excludes the last amount entries from this Collection
  belongs_to: List
  description: |-
    #### [skipLast()](index#skipLast())

    Returns a new Collection of the same type which excludes the last `amount` entries from this Collection.

    ``` ts
    skipLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#skipLast()`](../collection/index#skipLast())
- name: List.skipUntil()
  id: list/index#skipUntil()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns true
  belongs_to: List
  description: |-
    #### [skipUntil()](index#skipUntil())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns true.

    ``` ts
    skipUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipUntil()`](../collection/index#skipUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipUntil(x => x.match(/hat/))
    // List [ "hat", "god" ]run it
    ```
- name: List.skipWhile()
  id: list/index#skipWhile()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns false
  belongs_to: List
  description: |-
    #### [skipWhile()](index#skipWhile())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns false.

    ``` ts
    skipWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipWhile()`](../collection/index#skipWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipWhile(x => x.match(/g/))
    // List [ "cat", "hat", "god" ]run it
    ```
- name: List.slice()
  id: list/index#slice()
  summary: Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end
  belongs_to: List
  description: |-
    #### [slice()](index#slice())

    Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.

    ``` ts
    slice(begin?: number, end?: number): this
    ```

    #### Inherited from

    [`Collection#slice()`](../collection/index#slice())

    #### Discussion

    If begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.

    If end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.

    If the requested slice is equivalent to the current Collection, then it will return itself.
- name: List.some()
  id: list/index#some()
  summary: True if predicate returns true for any entry in the Collection
  belongs_to: List
  description: |-
    #### [some()](index#some())

    True if `predicate` returns true for any entry in the Collection.

    ``` ts
    some(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#some()`](../collection/index#some())
- name: List.sort()
  id: list/index#sort()
  summary: Returns a new Collection of the same type which includes the same entries, stably sorted by using a comparator
  belongs_to: List
  description: |-
    #### [sort()](index#sort())

    Returns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.

    ``` ts
    sort(comparator?: (valueA: T, valueB: T) => number): this
    ```

    #### Inherited from

    [`Collection#sort()`](../collection/index#sort())

    #### Discussion

    If a `comparator` is not provided, a default comparator uses `<` and `>`.

    `comparator(valueA, valueB)`:

    - Returns `0` if the elements should not be swapped.
    - Returns `-1` (or any negative number) if `valueA` comes before `valueB`
    - Returns `1` (or any positive number) if `valueA` comes after `valueB`
    - Is pure, i.e. it must always return the same value for the same pair of values.

    When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.

    ``` ts
    const { Map } = require('immutable')
    Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
      if (a < b) { return -1; }
      if (a > b) { return 1; }
      if (a === b) { return 0; }
    });
    // OrderedMap { "a": 1, "b": 2, "c": 3 }run it
    ```

    Note: [`sort()`](index#sort()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: List.sortBy()
  id: list/index#sortBy()
  summary: 'Note: sortBy() Always returns a new instance, even if the original was already sorted'
  belongs_to: List
  description: |-
    #### [sortBy()](index#sortBy())

    Like [`sort`](index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:

    ``` ts
    sortBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this
    ```

    #### Inherited from

    [`Collection#sortBy()`](../collection/index#sortBy())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const beattles = Map({
      John: { name: "Lennon" },
      Paul: { name: "McCartney" },
      George: { name: "Harrison" },
      Ringo: { name: "Starr" },
    });
    beattles.sortBy(member => member.name);run it
    ```

    Note: [`sortBy()`](index#sortBy()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: List.splice()
  id: list/index#splice()
  summary: Splice returns a new indexed Collection by replacing a region of this Collection with new values
  belongs_to: List
  description: |-
    #### [splice()](index#splice())

    Splice returns a new indexed Collection by replacing a region of this Collection with new values. If values are not provided, it only skips the region to be removed.

    ``` ts
    splice(index: number, removeNum: number, ...values: Array<T>): this
    ```

    #### Inherited from

    [`Collection.Indexed#splice()`](../collection.indexed/index#splice())

    #### Discussion

    `index` may be a negative number, which indexes back from the end of the Collection. `s.splice(-2)` splices after the second to last item.

    ``` ts
    const { List } = require('immutable')
    List([ 'a', 'b', 'c', 'd' ]).splice(1, 2, 'q', 'r', 's')
    // List [ "a", "q", "r", "s", "d" ]run it
    ```

    Since [`splice()`](index#splice()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.

    Note: [`splice`](index#splice()) *cannot* be used in [`withMutations`](index#withMutations()).
- name: List.take()
  id: list/index#take()
  summary: Returns a new Collection of the same type which includes the first amount entries from this Collection
  belongs_to: List
  description: |-
    #### [take()](index#take())

    Returns a new Collection of the same type which includes the first `amount` entries from this Collection.

    ``` ts
    take(amount: number): this
    ```

    #### Inherited from

    [`Collection#take()`](../collection/index#take())
- name: List.takeLast()
  id: list/index#takeLast()
  summary: Returns a new Collection of the same type which includes the last amount entries from this Collection
  belongs_to: List
  description: |-
    #### [takeLast()](index#takeLast())

    Returns a new Collection of the same type which includes the last `amount` entries from this Collection.

    ``` ts
    takeLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#takeLast()`](../collection/index#takeLast())
- name: List.takeUntil()
  id: list/index#takeUntil()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns false
  belongs_to: List
  description: |-
    #### [takeUntil()](index#takeUntil())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.

    ``` ts
    takeUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeUntil()`](../collection/index#takeUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeUntil(x => x.match(/at/))
    // List [ "dog", "frog" ]run it
    ```

    ### Reducing a value
- name: List.takeWhile()
  id: list/index#takeWhile()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns true
  belongs_to: List
  description: |-
    #### [takeWhile()](index#takeWhile())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.

    ``` ts
    takeWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeWhile()`](../collection/index#takeWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeWhile(x => x.match(/o/))
    // List [ "dog", "frog" ]run it
    ```
- name: List.toArray()
  id: list/index#toArray()
  summary: Shallowly converts this collection to an Array
  belongs_to: List
  description: |-
    #### [toArray()](index#toArray())

    Shallowly converts this collection to an Array.

    ``` ts
    toArray(): Array<T>
    ```

    #### Inherited from

    [`Collection.Indexed#toArray()`](../collection.indexed/index#toArray())
- name: List.toIndexedSeq()
  id: list/index#toIndexedSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: List
  description: |-
    #### [toIndexedSeq()](index#toIndexedSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    toIndexedSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())
- name: List.toJS()
  id: list/index#toJS()
  summary: Deeply converts this Indexed collection to equivalent native JavaScript Array
  belongs_to: List
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Indexed collection to equivalent native JavaScript Array.

    ``` ts
    toJS(): Array<DeepCopy<T>>
    ```

    #### Inherited from

    [`Collection.Indexed#toJS()`](../collection.indexed/index#toJS())
- name: List.toJSON()
  id: list/index#toJSON()
  summary: Shallowly converts this Indexed collection to equivalent native JavaScript Array
  belongs_to: List
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Indexed collection to equivalent native JavaScript Array.

    ``` ts
    toJSON(): Array<T>
    ```

    #### Inherited from

    [`Collection.Indexed#toJSON()`](../collection.indexed/index#toJSON())
- name: List.toKeyedSeq()
  id: list/index#toKeyedSeq()
  summary: Returns a Seq.Keyed from this Collection where indices are treated as keys
  belongs_to: List
  description: |-
    #### [toKeyedSeq()](index#toKeyedSeq())

    Returns a Seq.Keyed from this Collection where indices are treated as keys.

    ``` ts
    toKeyedSeq(): Seq.Keyed<number, T>
    ```

    #### Inherited from

    [`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())

    #### Discussion

    This is useful if you want to operate on an Collection.Indexed and preserve the \[index, value\] pairs.

    The returned Seq will have identical iteration order as this Collection.

    ``` ts
    const { Seq } = require('immutable')
    const indexedSeq = Seq([ 'A', 'B', 'C' ])
    // Seq [ "A", "B", "C" ]
    indexedSeq.filter(v => v === 'B')
    // Seq [ "B" ]
    const keyedSeq = indexedSeq.toKeyedSeq()
    // Seq { 0: "A", 1: "B", 2: "C" }
    keyedSeq.filter(v => v === 'B')
    // Seq { 1: "B" }run it
    ```
- name: List.toList()
  id: list/index#toList()
  summary: Converts this Collection to a List, discarding keys
  belongs_to: List
  description: |-
    #### [toList()](index#toList())

    Converts this Collection to a List, discarding keys.

    ``` ts
    toList(): List<T>
    ```

    #### Inherited from

    [`Collection#toList()`](../collection/index#toList())

    #### Discussion

    This is similar to [`List(collection)`](index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](index) creates a list of entry tuples.

    ``` ts
    const { Map, List } = require('immutable')
    var myMap = Map({ a: 'Apple', b: 'Banana' })
    List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
    myMap.toList() // List [ "Apple", "Banana" ]run it
    ```
- name: List.toMap()
  id: list/index#toMap()
  summary: Converts this Collection to a Map, Throws if keys are not hashable
  belongs_to: List
  description: |-
    #### [toMap()](index#toMap())

    Converts this Collection to a Map, Throws if keys are not hashable.

    ``` ts
    toMap(): Map<number, T>
    ```

    #### Inherited from

    [`Collection#toMap()`](../collection/index#toMap())

    #### Discussion

    Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: List.toObject()
  id: list/index#toObject()
  summary: Shallowly converts this Collection to an Object
  belongs_to: List
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Collection to an Object.

    ``` ts
    toObject(): {[key: string]: T}
    ```

    #### Inherited from

    [`Collection#toObject()`](../collection/index#toObject())

    #### Discussion

    Converts keys to Strings.

    ### Reading values
- name: List.toOrderedMap()
  id: list/index#toOrderedMap()
  summary: Converts this Collection to a Map, maintaining the order of iteration
  belongs_to: List
  description: |-
    #### [toOrderedMap()](index#toOrderedMap())

    Converts this Collection to a Map, maintaining the order of iteration.

    ``` ts
    toOrderedMap(): OrderedMap<number, T>
    ```

    #### Inherited from

    [`Collection#toOrderedMap()`](../collection/index#toOrderedMap())

    #### Discussion

    Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: List.toOrderedSet()
  id: list/index#toOrderedSet()
  summary: Converts this Collection to a Set, maintaining the order of iteration and discarding keys
  belongs_to: List
  description: |-
    #### [toOrderedSet()](index#toOrderedSet())

    Converts this Collection to a Set, maintaining the order of iteration and discarding keys.

    ``` ts
    toOrderedSet(): OrderedSet<T>
    ```

    #### Inherited from

    [`Collection#toOrderedSet()`](../collection/index#toOrderedSet())

    #### Discussion

    Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.
- name: List.toSeq()
  id: list/index#toSeq()
  summary: Returns Seq.Indexed
  belongs_to: List
  description: |-
    #### [toSeq()](index#toSeq())

    Returns Seq.Indexed.

    ``` ts
    toSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection.Indexed#toSeq()`](../collection.indexed/index#toSeq())
- name: List.toSet()
  id: list/index#toSet()
  summary: Converts this Collection to a Set, discarding keys
  belongs_to: List
  description: |-
    #### [toSet()](index#toSet())

    Converts this Collection to a Set, discarding keys. Throws if values are not hashable.

    ``` ts
    toSet(): Set<T>
    ```

    #### Inherited from

    [`Collection#toSet()`](../collection/index#toSet())

    #### Discussion

    Note: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.
- name: List.toSetSeq()
  id: list/index#toSetSeq()
  summary: Returns a Seq.Set of the values of this Collection, discarding keys
  belongs_to: List
  description: |-
    #### [toSetSeq()](index#toSetSeq())

    Returns a Seq.Set of the values of this Collection, discarding keys.

    ``` ts
    toSetSeq(): Seq.Set<T>
    ```

    #### Inherited from

    [`Collection#toSetSeq()`](../collection/index#toSetSeq())

    ### Combination
- name: List.toStack()
  id: list/index#toStack()
  summary: Converts this Collection to a Stack, discarding keys
  belongs_to: List
  description: |-
    #### [toStack()](index#toStack())

    Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.

    ``` ts
    toStack(): Stack<T>
    ```

    #### Inherited from

    [`Collection#toStack()`](../collection/index#toStack())

    #### Discussion

    Note: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.

    ### Iterators
- name: List.unshift()
  id: list/index#unshift()
  summary: Returns a new List with the provided values prepended, shifting other values ahead to higher indices
  belongs_to: List
  description: |-
    #### [unshift()](index#unshift())

    Returns a new List with the provided `values` prepended, shifting other values ahead to higher indices.

    ``` ts
    unshift(...values: Array<T>): List<T>
    ```

    #### Discussion

    ``` ts
    List([ 2, 3, 4]).unshift(1);
    // List [ 1, 2, 3, 4 ]run it
    ```

    Note: [`unshift`](index#unshift()) can be used in [`withMutations`](index#withMutations()).
- name: List.update()
  id: list/index#update()
  summary: null
  belongs_to: List
  description: |-
    #### [update()](index#update())

    ``` ts
    update(index: number, notSetValue: T, updater: (value: T) => T): this
    update(index: number, updater: (value: T | undefined) => T): this
    update<R>(updater: (value: this) => R): R
    ```

    #### Overrides

    [`Collection#update()`](../collection/index#update())
- name: List.updateIn()
  id: list/index#updateIn()
  summary: null
  belongs_to: List
  description: |-
    #### [updateIn()](index#updateIn())

    ``` ts
    updateIn(keyPath: Iterable<unknown>,notSetValue: unknown,updater: (value: unknown) => unknown): this
    updateIn(keyPath: Iterable<unknown>, updater: (value: unknown) => unknown): this
    ```
- name: List.values()
  id: list/index#values()
  summary: An iterator of this Collection's values
  belongs_to: List
  description: |-
    #### [values()](index#values())

    An iterator of this [`Collection`](../collection/index)'s values.

    ``` ts
    values(): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection#values()`](../collection/index#values())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](index#valueSeq()) instead, if this is what you want.
- name: List.valueSeq()
  id: list/index#valueSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: List
  description: |-
    #### [valueSeq()](index#valueSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    valueSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#valueSeq()`](../collection/index#valueSeq())
- name: List.wasAltered()
  id: list/index#wasAltered()
  summary: null
  belongs_to: List
  description: |-
    #### [wasAltered()](index#wasAltered())

    ``` ts
    wasAltered(): boolean
    ```

    #### see

    [`Map#wasAltered`](../map/index#wasAltered())
- name: List.withMutations()
  id: list/index#withMutations()
  summary: 'Note: Not all methods can be safely used on a mutable collection or within withMutations! Check the documentation for each method to see if it allows being used in withMutations'
  belongs_to: List
  description: |-
    #### [withMutations()](index#withMutations())

    Note: Not all methods can be safely used on a mutable collection or within [`withMutations`](index#withMutations())! Check the documentation for each method to see if it allows being used in [`withMutations`](index#withMutations()).

    ``` ts
    withMutations(mutator: (mutable: this) => unknown): this
    ```

    #### see

    [`Map#withMutations`](../map/index#withMutations())
- name: List.zip()
  id: list/index#zip()
  summary: null
  belongs_to: List
  description: |-
    #### [zip()](index#zip())

    ``` ts
    zip<U>(other: Collection<unknown, U>): List<[T, U]>
    zip<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): List<[T, U, V]>
    zip(...collections: Array<Collection<unknown, unknown>>): List<unknown>
    ```

    #### Overrides

    [`Collection.Indexed#zip()`](../collection.indexed/index#zip())
- name: List.zipAll()
  id: list/index#zipAll()
  summary: null
  belongs_to: List
  description: |-
    #### [zipAll()](index#zipAll())

    ``` ts
    zipAll<U>(other: Collection<unknown, U>): List<[T, U]>
    zipAll<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): List<[T, U, V]>
    zipAll(...collections: Array<Collection<unknown, unknown>>): List<unknown>
    ```

    #### Overrides

    [`Collection.Indexed#zipAll()`](../collection.indexed/index#zipAll())
- name: List.zipWith()
  id: list/index#zipWith()
  summary: null
  belongs_to: List
  description: |-
    #### [zipWith()](index#zipWith())

    ``` ts
    zipWith<U, Z>(zipper: (value: T, otherValue: U) => Z,otherCollection: Collection<unknown, U>): List<Z>
    zipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z,otherCollection: Collection<unknown, U>,thirdCollection: Collection<unknown, V>): List<Z>
    zipWith<Z>(zipper: (...values: Array<unknown>) => Z,...collections: Array<Collection<unknown, unknown>>): List<Z>
    ```

    #### Overrides

    [`Collection.Indexed#zipWith()`](../collection.indexed/index#zipWith())
- name: Map
  id: map/index
  summary: Immutable Map is an unordered Collection.Keyed of (key, value) pairs with O(log32 N) gets and O(log32 N) persistent sets
  description: "# Map\n\nImmutable Map is an unordered Collection.Keyed of (key, value) pairs with `O(log32 N)` gets and `O(log32 N)` persistent sets.\n\n``` ts\ntype Map<K, V> extends Collection.Keyed<K, V>\n```\n\n#### Discussion\n\nIteration order of a Map is undefined, however is stable. Multiple iterations of the same Map will iterate in the same order.\n\nMap's keys can be of any type, and use [`Immutable.is`](../is()/index) to determine key equality. This allows the use of any value (including NaN) as a key.\n\nBecause [`Immutable.is`](../is()/index) returns equality based on value semantics, and Immutable collections are treated as values, any Immutable collection may be used as a key.\n\n``` ts\nconst { Map, List } = require('immutable');\nMap().set(List([ 1 ]), 'listofone').get(List([ 1 ]));\n// 'listofone'run it\n```\n\nAny JavaScript object may be used as a key, however strict identity is used to evaluate key equality. Two similar looking objects will represent two different keys.\n\nImplemented by a hash-array mapped trie.\n\n### Construction\n\n#### [Map()](index#Map())\n\n``` ts\nMap<K, V>(collection?: Iterable<[K, V]>): Map<K, V>\nMap<V>(obj: {[key: string]: V}): Map<string, V>\nMap<K, V>(obj: {[key: string]: V}): Map<K, V>\n```\n\n### Static methods\n\n#### [Map.isMap()](index#isMap())\n\n``` ts\nMap.isMap(maybeMap: unknown): boolean\n```\n\n### Members\n\n#### [size](index#size)\n\nThe number of entries in this Map.\n\n``` ts\nsize: number\n```\n\n### Persistent changes\n\n#### [set()](index#set())\n\nReturns a new Map also containing the new key, value pair. If an equivalent key already exists in this Map, it will be replaced.\n\n``` ts\nset(key: K, value: V): this\n```\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst originalMap = Map()\nconst newerMap = originalMap.set('key', 'value')\nconst newestMap = newerMap.set('key', 'newer value')\n\noriginalMap\n// Map {}\nnewerMap\n// Map { \"key\": \"value\" }\nnewestMap\n// Map { \"key\": \"newer value\" }run it\n```\n\nNote: [`set`](index#set()) can be used in [`withMutations`](index#withMutations()).\n\n#### [delete()](index#delete())\n\nReturns a new Map which excludes this `key`.\n\n``` ts\ndelete(key: K): this\n```\n\n#### alias\n\n`remove()`\n\n#### Discussion\n\nNote: [`delete`](index#delete()) cannot be safely used in IE8, but is provided to mirror the ES6 collection API.\n\n``` ts\nconst { Map } = require('immutable')\nconst originalMap = Map({\n  key: 'value',\n  otherKey: 'other value'\n})\n// Map { \"key\": \"value\", \"otherKey\": \"other value\" }\noriginalMap.delete('otherKey')\n// Map { \"key\": \"value\" }run it\n```\n\nNote: [`delete`](index#delete()) can be used in [`withMutations`](index#withMutations()).\n\n#### [deleteAll()](index#deleteAll())\n\nReturns a new Map which excludes the provided `keys`.\n\n``` ts\ndeleteAll(keys: Iterable<K>): this\n```\n\n#### alias\n\n`removeAll()`\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst names = Map({ a: \"Aaron\", b: \"Barry\", c: \"Connor\" })\nnames.deleteAll([ 'a', 'c' ])\n// Map { \"b\": \"Barry\" }run it\n```\n\nNote: [`deleteAll`](index#deleteAll()) can be used in [`withMutations`](index#withMutations()).\n\n#### [clear()](index#clear())\n\nReturns a new Map containing no keys or values.\n\n``` ts\nclear(): this\n```\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ key: 'value' }).clear()\n// Map {}run it\n```\n\nNote: [`clear`](index#clear()) can be used in [`withMutations`](index#withMutations()).\n\n#### [update()](index#update())\n\n``` ts\nupdate(key: K, notSetValue: V, updater: (value: V) => V): this\nupdate(key: K, updater: (value: V | undefined) => V): this\nupdate<R>(updater: (value: this) => R): R\n```\n\n#### Overrides\n\n[`Collection#update()`](../collection/index#update())\n\n#### [merge()](index#merge())\n\n``` ts\nmerge<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Map<K | KC, V | VC>\nmerge<C>(...collections: Array<{[key: string]: C}>): Map<K | string, V | C>\n```\n\n#### [mergeWith()](index#mergeWith())\n\nLike [`merge()`](index#merge()), [`mergeWith()`](index#mergeWith()) returns a new Map resulting from merging the provided Collections (or JS objects) into this Map, but uses the `merger` function for dealing with conflicts.\n\n``` ts\nmergeWith(merger: (oldVal: V, newVal: V, key: K) => V,...collections: Array<Iterable<[K, V]> | {[key: string]: V}>): this\n```\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst one = Map({ a: 10, b: 20, c: 30 })\nconst two = Map({ b: 40, a: 50, d: 60 })\none.mergeWith((oldVal, newVal) => oldVal / newVal, two)\n// { \"a\": 0.2, \"b\": 0.5, \"c\": 30, \"d\": 60 }\ntwo.mergeWith((oldVal, newVal) => oldVal / newVal, one)\n// { \"b\": 2, \"a\": 5, \"d\": 60, \"c\": 30 }run it\n```\n\nNote: [`mergeWith`](index#mergeWith()) can be used in [`withMutations`](index#withMutations()).\n\n#### [mergeDeep()](index#mergeDeep())\n\nLike [`merge()`](index#merge()), but when two compatible collections are encountered with the same key, it merges them as well, recursing deeply through the nested data. Two collections are considered to be compatible (and thus will be merged together) if they both fall into one of three categories: keyed (e.g., [`Map`](index)s, [`Record`](../record/index)s, and objects), indexed (e.g., [`List`](../list/index)s and arrays), or set-like (e.g., [`Set`](../set/index)s). If they fall into separate categories, [`mergeDeep`](index#mergeDeep()) will replace the existing collection with the collection being merged in. This behavior can be customized by using [`mergeDeepWith()`](index#mergeDeepWith()).\n\n``` ts\nmergeDeep(...collections: Array<Iterable<[K, V]> | {[key: string]: V}>): this\n```\n\n#### Discussion\n\nNote: Indexed and set-like collections are merged using [`concat()`](index#concat())/`union()` and therefore do not recurse.\n\n``` ts\nconst { Map } = require('immutable')\nconst one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })\nconst two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })\none.mergeDeep(two)\n// Map {\n//   \"a\": Map { \"x\": 2, \"y\": 10 },\n//   \"b\": Map { \"x\": 20, \"y\": 5 },\n//   \"c\": Map { \"z\": 3 }\n// }run it\n```\n\nNote: [`mergeDeep`](index#mergeDeep()) can be used in [`withMutations`](index#withMutations()).\n\n#### [mergeDeepWith()](index#mergeDeepWith())\n\nLike [`mergeDeep()`](index#mergeDeep()), but when two non-collections or incompatible collections are encountered at the same key, it uses the `merger` function to determine the resulting value. Collections are considered incompatible if they fall into separate categories between keyed, indexed, and set-like.\n\n``` ts\nmergeDeepWith(merger: (oldVal: unknown, newVal: unknown, key: unknown) => unknown,...collections: Array<Iterable<[K, V]> | {[key: string]: V}>): this\n```\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })\nconst two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })\none.mergeDeepWith((oldVal, newVal) => oldVal / newVal, two)\n// Map {\n//   \"a\": Map { \"x\": 5, \"y\": 10 },\n//   \"b\": Map { \"x\": 20, \"y\": 10 },\n//   \"c\": Map { \"z\": 3 }\n// }run it\n```\n\nNote: [`mergeDeepWith`](index#mergeDeepWith()) can be used in [`withMutations`](index#withMutations()).\n\n### Deep persistent changes\n\n#### [setIn()](index#setIn())\n\nReturns a new Map having set `value` at this `keyPath`. If any keys in `keyPath` do not exist, a new immutable Map will be created at that key.\n\n``` ts\nsetIn(keyPath: Iterable<unknown>, value: unknown): this\n```\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst originalMap = Map({\n  subObject: Map({\n    subKey: 'subvalue',\n    subSubObject: Map({\n      subSubKey: 'subSubValue'\n    })\n  })\n})\n```\n\nconst newMap = originalMap.setIn(\\['subObject', 'subKey'\\], 'ha ha!') // Map { // \"subObject\": Map { // \"subKey\": \"ha ha!\", // \"subSubObject\": Map { \"subSubKey\": \"subSubValue\" } // } // } const newerMap = originalMap.setIn( \\['subObject', 'subSubObject', 'subSubKey'\\], 'ha ha ha!' ) // Map { // \"subObject\": Map { // \"subKey\": \"subvalue\", // \"subSubObject\": Map { \"subSubKey\": \"ha ha ha!\" } // } // }run it\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and setIn() can update those values as well, treating them immutably by creating new copies of those values with the changes applied.\n\n``` ts\nconst { Map } = require('immutable')\nconst originalMap = Map({\n  subObject: {\n    subKey: 'subvalue',\n    subSubObject: {\n      subSubKey: 'subSubValue'\n    }\n  }\n})\n```\n\noriginalMap.setIn(\\['subObject', 'subKey'\\], 'ha ha!') // Map { // \"subObject\": { // subKey: \"ha ha!\", // subSubObject: { subSubKey: \"subSubValue\" } // } // }run it\n\nIf any key in the path exists but cannot be updated (such as a primitive like number or a custom Object like Date), an error will be thrown.\n\nNote: [`setIn`](index#setIn()) can be used in [`withMutations`](index#withMutations()).\n\n#### [deleteIn()](index#deleteIn())\n\nReturns a new Map having removed the value at this `keyPath`. If any keys in `keyPath` do not exist, no change will occur.\n\n``` ts\ndeleteIn(keyPath: Iterable<unknown>): this\n```\n\n#### alias\n\n`removeIn()`\n\n#### Discussion\n\nNote: [`deleteIn`](index#deleteIn()) can be used in [`withMutations`](index#withMutations()).\n\n#### [updateIn()](index#updateIn())\n\n``` ts\nupdateIn(keyPath: Iterable<unknown>,notSetValue: unknown,updater: (value: unknown) => unknown): this\nupdateIn(keyPath: Iterable<unknown>, updater: (value: unknown) => unknown): this\n```\n\n#### [mergeIn()](index#mergeIn())\n\nA combination of [`updateIn`](index#updateIn()) and [`merge`](index#merge()), returning a new Map, but performing the merge at a point arrived at by following the keyPath. In other words, these two lines are equivalent:\n\n``` ts\nmergeIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this\n```\n\n#### Discussion\n\n``` ts\nmap.updateIn(['a', 'b', 'c'], abc => abc.merge(y))\nmap.mergeIn(['a', 'b', 'c'], y)\n```\n\nNote: [`mergeIn`](index#mergeIn()) can be used in [`withMutations`](index#withMutations()).\n\n#### [mergeDeepIn()](index#mergeDeepIn())\n\nA combination of [`updateIn`](index#updateIn()) and [`mergeDeep`](index#mergeDeep()), returning a new Map, but performing the deep merge at a point arrived at by following the keyPath. In other words, these two lines are equivalent:\n\n``` ts\nmergeDeepIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this\n```\n\n#### Discussion\n\n``` ts\nmap.updateIn(['a', 'b', 'c'], abc => abc.mergeDeep(y))\nmap.mergeDeepIn(['a', 'b', 'c'], y)\n```\n\nNote: [`mergeDeepIn`](index#mergeDeepIn()) can be used in [`withMutations`](index#withMutations()).\n\n### Transient changes\n\n#### [withMutations()](index#withMutations())\n\nEvery time you call one of the above functions, a new immutable Map is created. If a pure function calls a number of these to produce a final return value, then a penalty on performance and memory has been paid by creating all of the intermediate immutable Maps.\n\n``` ts\nwithMutations(mutator: (mutable: this) => unknown): this\n```\n\n#### Discussion\n\nIf you need to apply a series of mutations to produce a new immutable Map, [`withMutations()`](index#withMutations()) creates a temporary mutable copy of the Map which can apply mutations in a highly performant manner. In fact, this is exactly how complex mutations like [`merge`](index#merge()) are done.\n\nAs an example, this results in the creation of 2, not 4, new Maps:\n\n``` ts\nconst { Map } = require('immutable')\nconst map1 = Map()\nconst map2 = map1.withMutations(map => {\n  map.set('a', 1).set('b', 2).set('c', 3)\n})\nassert.equal(map1.size, 0)\nassert.equal(map2.size, 3)run it\n```\n\nNote: Not all methods can be used on a mutable collection or within [`withMutations`](index#withMutations())! Read the documentation for each method to see if it is safe to use in [`withMutations`](index#withMutations()).\n\n#### [asMutable()](index#asMutable())\n\nAnother way to avoid creation of intermediate Immutable maps is to create a mutable copy of this collection. Mutable copies *always* return `this`, and thus shouldn't be used for equality. Your function should never return a mutable copy of a collection, only use it internally to create a new collection.\n\n``` ts\nasMutable(): this\n```\n\n#### see\n\n[`Map#asImmutable`](index#asImmutable())\n\n#### Discussion\n\nIf possible, use [`withMutations`](index#withMutations()) to work with temporary mutable copies as it provides an easier to use API and considers many common optimizations.\n\nNote: if the collection is already mutable, [`asMutable`](index#asMutable()) returns itself.\n\nNote: Not all methods can be used on a mutable collection or within [`withMutations`](index#withMutations())! Read the documentation for each method to see if it is safe to use in [`withMutations`](index#withMutations()).\n\n#### [wasAltered()](index#wasAltered())\n\nReturns true if this is a mutable copy (see [`asMutable()`](index#asMutable())) and mutative alterations have been applied.\n\n``` ts\nwasAltered(): boolean\n```\n\n#### see\n\n[`Map#asMutable`](index#asMutable())\n\n#### [asImmutable()](index#asImmutable())\n\nThe yin to [`asMutable`](index#asMutable())'s yang. Because it applies to mutable collections, this operation is *mutable* and may return itself (though may not return itself, i.e. if the result is an empty collection). Once performed, the original mutable copy must no longer be mutated since it may be the immutable result.\n\n``` ts\nasImmutable(): this\n```\n\n#### see\n\n[`Map#asMutable`](index#asMutable())\n\n#### Discussion\n\nIf possible, use [`withMutations`](index#withMutations()) to work with temporary mutable copies as it provides an easier to use API and considers many common optimizations.\n\n### Sequence algorithms\n\n#### [map()](index#map())\n\nReturns a new Map with values passed through a `mapper` function.\n\n``` ts\nmap<M>(mapper: (value: V, key: K, iter: this) => M,context?: unknown): Map<K, M>\n```\n\n#### Overrides\n\n[`Collection.Keyed#map()`](../collection.keyed/index#map())\n\n#### Example\n\n``` ts\nMap({ a: 1, b: 2 }).map(x => 10 * x)\n// Map { a: 10, b: 20 }\n```\n\n#### [mapKeys()](index#mapKeys())\n\n``` ts\nmapKeys<M>(mapper: (key: K, value: V, iter: this) => M,context?: unknown): Map<M, V>\n```\n\n#### Overrides\n\n[`Collection.Keyed#mapKeys()`](../collection.keyed/index#mapKeys())\n\n#### see\n\nCollection.Keyed.mapKeys\n\n#### [mapEntries()](index#mapEntries())\n\n``` ts\nmapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM] | undefined,context?: unknown): Map<KM, VM>\n```\n\n#### Overrides\n\n[`Collection.Keyed#mapEntries()`](../collection.keyed/index#mapEntries())\n\n#### see\n\nCollection.Keyed.mapEntries\n\n#### [flatMap()](index#flatMap())\n\nFlat-maps the Map, returning a new Map.\n\n``` ts\nflatMap<KM, VM>(mapper: (value: V, key: K, iter: this) => Iterable<[KM, VM]>,context?: unknown): Map<KM, VM>\n```\n\n#### Overrides\n\n[`Collection.Keyed#flatMap()`](../collection.keyed/index#flatMap())\n\n#### Discussion\n\nSimilar to `data.map(...).flatten(true)`.\n\n#### [filter()](index#filter())\n\n``` ts\nfilter<F>(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): Map<K, F>\nfilter(predicate: (value: V, key: K, iter: this) => unknown,context?: unknown): this\n```\n\n#### Overrides\n\n[`Collection.Keyed#filter()`](../collection.keyed/index#filter())\n\n#### [partition()](index#partition())\n\n``` ts\npartition<F, C>(predicate: (this: C, value: V, key: K, iter: this) => boolean,context?: C): [Map<K, V>, Map<K, F>]\npartition<C>(predicate: (this: C, value: V, key: K, iter: this) => unknown,context?: C): [this, this]\n```\n\n#### Overrides\n\n[`Collection.Keyed#partition()`](../collection.keyed/index#partition())\n\n#### [flip()](index#flip())\n\n``` ts\nflip(): Map<V, K>\n```\n\n#### Overrides\n\n[`Collection.Keyed#flip()`](../collection.keyed/index#flip())\n\n#### see\n\nCollection.Keyed.flip\n\n#### [filterNot()](index#filterNot())\n\nReturns a new Collection of the same type with only the entries for which the `predicate` function returns false.\n\n``` ts\nfilterNot(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#filterNot()`](../collection/index#filterNot())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }run it\n```\n\nNote: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.\n\n#### [reverse()](index#reverse())\n\nReturns a new Collection of the same type in reverse order.\n\n``` ts\nreverse(): this\n```\n\n#### Inherited from\n\n[`Collection#reverse()`](../collection/index#reverse())\n\n#### [sort()](index#sort())\n\nReturns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.\n\n``` ts\nsort(comparator?: (valueA: V, valueB: V) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sort()`](../collection/index#sort())\n\n#### Discussion\n\nIf a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n- Returns `0` if the elements should not be swapped.\n- Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n- Returns `1` (or any positive number) if `valueA` comes after `valueB`\n- Is pure, i.e. it must always return the same value for the same pair of values.\n\nWhen sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n``` ts\nconst { Map } = require('immutable')\nMap({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// OrderedMap { \"a\": 1, \"b\": 2, \"c\": 3 }run it\n```\n\nNote: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [sortBy()](index#sortBy())\n\nLike [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:\n\n``` ts\nsortBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sortBy()`](../collection/index#sortBy())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst beattles = Map({\n  John: { name: \"Lennon\" },\n  Paul: { name: \"McCartney\" },\n  George: { name: \"Harrison\" },\n  Ringo: { name: \"Starr\" },\n});\nbeattles.sortBy(member => member.name);run it\n```\n\nNote: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [groupBy()](index#groupBy())\n\nReturns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.\n\n``` ts\ngroupBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<K, V>>\n```\n\n#### Inherited from\n\n[`Collection#groupBy()`](../collection/index#groupBy())\n\n#### Discussion\n\nNote: This is always an eager operation.\n\n``` ts\nconst { List, Map } = require('immutable')\nconst listOfMaps = List([\n  Map({ v: 0 }),\n  Map({ v: 1 }),\n  Map({ v: 1 }),\n  Map({ v: 0 }),\n  Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ Map{ \"v\": 0 }, Map { \"v\": 0 } ],\n//   1: List [ Map{ \"v\": 1 }, Map { \"v\": 1 } ],\n//   2: List [ Map{ \"v\": 2 } ],\n// }run it\n```\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Keyed collection to equivalent native JavaScript Object.\n\n``` ts\ntoJS(): {[key: string]: DeepCopy<V>}\n```\n\n#### Inherited from\n\n[`Collection.Keyed#toJS()`](../collection.keyed/index#toJS())\n\n#### Discussion\n\nConverts keys to Strings.\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Keyed collection to equivalent native JavaScript Object.\n\n``` ts\ntoJSON(): {[key: string]: V}\n```\n\n#### Inherited from\n\n[`Collection.Keyed#toJSON()`](../collection.keyed/index#toJSON())\n\n#### Discussion\n\nConverts keys to Strings.\n\n#### [toArray()](index#toArray())\n\nShallowly converts this collection to an Array.\n\n``` ts\ntoArray(): Array<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection.Keyed#toArray()`](../collection.keyed/index#toArray())\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Collection to an Object.\n\n``` ts\ntoObject(): {[key: string]: V}\n```\n\n#### Inherited from\n\n[`Collection#toObject()`](../collection/index#toObject())\n\n#### Discussion\n\nConverts keys to Strings.\n\n### Conversion to Seq\n\n#### [toSeq()](index#toSeq())\n\nReturns Seq.Keyed.\n\n``` ts\ntoSeq(): Seq.Keyed<K, V>\n```\n\n#### Inherited from\n\n[`Collection.Keyed#toSeq()`](../collection.keyed/index#toSeq())\n\n#### [toKeyedSeq()](index#toKeyedSeq())\n\nReturns a Seq.Keyed from this Collection where indices are treated as keys.\n\n``` ts\ntoKeyedSeq(): Seq.Keyed<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())\n\n#### Discussion\n\nThis is useful if you want to operate on an Collection.Indexed and preserve the \\[index, value\\] pairs.\n\nThe returned Seq will have identical iteration order as this Collection.\n\n``` ts\nconst { Seq } = require('immutable')\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\n// Seq [ \"A\", \"B\", \"C\" ]\nindexedSeq.filter(v => v === 'B')\n// Seq [ \"B\" ]\nconst keyedSeq = indexedSeq.toKeyedSeq()\n// Seq { 0: \"A\", 1: \"B\", 2: \"C\" }\nkeyedSeq.filter(v => v === 'B')\n// Seq { 1: \"B\" }run it\n```\n\n#### [toIndexedSeq()](index#toIndexedSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\ntoIndexedSeq(): Seq.Indexed<V>\n```\n\n#### Inherited from\n\n[`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())\n\n#### [toSetSeq()](index#toSetSeq())\n\nReturns a Seq.Set of the values of this Collection, discarding keys.\n\n``` ts\ntoSetSeq(): Seq.Set<V>\n```\n\n#### Inherited from\n\n[`Collection#toSetSeq()`](../collection/index#toSetSeq())\n\n### Sequence functions\n\n#### [concat()](index#concat())\n\n``` ts\nconcat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Collection.Keyed<K | KC, V | VC>\nconcat<C>(...collections: Array<{[key: string]: C}>): Collection.Keyed<K | string, V | C>\n```\n\n#### Inherited from\n\n[`Collection.Keyed#concat()`](../collection.keyed/index#concat())\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection.Keyed#[Symbol.iterator]()`](../collection.keyed/index#%5BSymbol.iterator%5D())\n\n### Value equality\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#equals()`](../collection/index#equals())\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Inherited from\n\n[`Collection#hashCode()`](../collection/index#hashCode())\n\n#### Discussion\n\nThe [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](index), enabling lookup via a different instance.\n\n``` ts\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nIf two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.\n\n### Reading values\n\n#### [get()](index#get())\n\n``` ts\nget<NSV>(key: K, notSetValue: NSV): V | NSV\nget(key: K): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#get()`](../collection/index#get())\n\n#### [has()](index#has())\n\nTrue if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nhas(key: K): boolean\n```\n\n#### Inherited from\n\n[`Collection#has()`](../collection/index#has())\n\n#### [includes()](index#includes())\n\nTrue if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nincludes(value: V): boolean\n```\n\n#### Inherited from\n\n[`Collection#includes()`](../collection/index#includes())\n\n#### alias\n\n`contains()`\n\n#### [first()](index#first())\n\nIn case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nfirst<NSV>(notSetValue?: NSV): V | NSV\n```\n\n#### Inherited from\n\n[`Collection#first()`](../collection/index#first())\n\n#### [last()](index#last())\n\nIn case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nlast<NSV>(notSetValue?: NSV): V | NSV\n```\n\n#### Inherited from\n\n[`Collection#last()`](../collection/index#last())\n\n### Reading deep values\n\n#### [getIn()](index#getIn())\n\nReturns the value found by following a path of keys or indices through nested Collections.\n\n``` ts\ngetIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown\n```\n\n#### Inherited from\n\n[`Collection#getIn()`](../collection/index#getIn())\n\n#### Discussion\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: [ { y: 123 } ] });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\n#### [hasIn()](index#hasIn())\n\nTrue if the result of following a path of keys or indices through nested Collections results in a set value.\n\n``` ts\nhasIn(searchKeyPath: Iterable<unknown>): boolean\n```\n\n#### Inherited from\n\n[`Collection#hasIn()`](../collection/index#hasIn())\n\n### Conversion to Collections\n\n#### [toMap()](index#toMap())\n\nConverts this Collection to a Map, Throws if keys are not hashable.\n\n``` ts\ntoMap(): Map<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toMap()`](../collection/index#toMap())\n\n#### Discussion\n\nNote: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toOrderedMap()](index#toOrderedMap())\n\nConverts this Collection to a Map, maintaining the order of iteration.\n\n``` ts\ntoOrderedMap(): OrderedMap<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedMap()`](../collection/index#toOrderedMap())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toSet()](index#toSet())\n\nConverts this Collection to a Set, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoSet(): Set<V>\n```\n\n#### Inherited from\n\n[`Collection#toSet()`](../collection/index#toSet())\n\n#### Discussion\n\nNote: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.\n\n#### [toOrderedSet()](index#toOrderedSet())\n\nConverts this Collection to a Set, maintaining the order of iteration and discarding keys.\n\n``` ts\ntoOrderedSet(): OrderedSet<V>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedSet()`](../collection/index#toOrderedSet())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toList()](index#toList())\n\nConverts this Collection to a List, discarding keys.\n\n``` ts\ntoList(): List<V>\n```\n\n#### Inherited from\n\n[`Collection#toList()`](../collection/index#toList())\n\n#### Discussion\n\nThis is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.\n\n``` ts\nconst { Map, List } = require('immutable')\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\nList(myMap) // List [ [ \"a\", \"Apple\" ], [ \"b\", \"Banana\" ] ]\nmyMap.toList() // List [ \"Apple\", \"Banana\" ]run it\n```\n\n#### [toStack()](index#toStack())\n\nConverts this Collection to a Stack, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoStack(): Stack<V>\n```\n\n#### Inherited from\n\n[`Collection#toStack()`](../collection/index#toStack())\n\n#### Discussion\n\nNote: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.\n\n### Iterators\n\n#### [keys()](index#keys())\n\nAn iterator of this [`Collection`](../collection/index)'s keys.\n\n``` ts\nkeys(): IterableIterator<K>\n```\n\n#### Inherited from\n\n[`Collection#keys()`](../collection/index#keys())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.\n\n#### [values()](index#values())\n\nAn iterator of this [`Collection`](../collection/index)'s values.\n\n``` ts\nvalues(): IterableIterator<V>\n```\n\n#### Inherited from\n\n[`Collection#values()`](../collection/index#values())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.\n\n#### [entries()](index#entries())\n\nAn iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.\n\n``` ts\nentries(): IterableIterator<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection#entries()`](../collection/index#entries())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.\n\n### Collections (Seq)\n\n#### [keySeq()](index#keySeq())\n\nReturns a new Seq.Indexed of the keys of this Collection, discarding values.\n\n``` ts\nkeySeq(): Seq.Indexed<K>\n```\n\n#### Inherited from\n\n[`Collection#keySeq()`](../collection/index#keySeq())\n\n#### [valueSeq()](index#valueSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\nvalueSeq(): Seq.Indexed<V>\n```\n\n#### Inherited from\n\n[`Collection#valueSeq()`](../collection/index#valueSeq())\n\n#### [entrySeq()](index#entrySeq())\n\nReturns a new Seq.Indexed of \\[key, value\\] tuples.\n\n``` ts\nentrySeq(): Seq.Indexed<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection#entrySeq()`](../collection/index#entrySeq())\n\n### Side effects\n\n#### [forEach()](index#forEach())\n\nThe `sideEffect` is executed for every entry in the Collection.\n\n``` ts\nforEach(sideEffect: (value: V, key: K, iter: this) => unknown,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#forEach()`](../collection/index#forEach())\n\n#### Discussion\n\nUnlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).\n\n### Creating subsets\n\n#### [slice()](index#slice())\n\nReturns a new Collection of the same type representing a portion of this Collection from start up to but not including end.\n\n``` ts\nslice(begin?: number, end?: number): this\n```\n\n#### Inherited from\n\n[`Collection#slice()`](../collection/index#slice())\n\n#### Discussion\n\nIf begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.\n\nIf the requested slice is equivalent to the current Collection, then it will return itself.\n\n#### [rest()](index#rest())\n\nReturns a new Collection of the same type containing all entries except the first.\n\n``` ts\nrest(): this\n```\n\n#### Inherited from\n\n[`Collection#rest()`](../collection/index#rest())\n\n#### [butLast()](index#butLast())\n\nReturns a new Collection of the same type containing all entries except the last.\n\n``` ts\nbutLast(): this\n```\n\n#### Inherited from\n\n[`Collection#butLast()`](../collection/index#butLast())\n\n#### [skip()](index#skip())\n\nReturns a new Collection of the same type which excludes the first `amount` entries from this Collection.\n\n``` ts\nskip(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skip()`](../collection/index#skip())\n\n#### [skipLast()](index#skipLast())\n\nReturns a new Collection of the same type which excludes the last `amount` entries from this Collection.\n\n``` ts\nskipLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skipLast()`](../collection/index#skipLast())\n\n#### [skipWhile()](index#skipWhile())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns false.\n\n``` ts\nskipWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipWhile()`](../collection/index#skipWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipWhile(x => x.match(/g/))\n// List [ \"cat\", \"hat\", \"god\" ]run it\n```\n\n#### [skipUntil()](index#skipUntil())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns true.\n\n``` ts\nskipUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipUntil()`](../collection/index#skipUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipUntil(x => x.match(/hat/))\n// List [ \"hat\", \"god\" ]run it\n```\n\n#### [take()](index#take())\n\nReturns a new Collection of the same type which includes the first `amount` entries from this Collection.\n\n``` ts\ntake(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#take()`](../collection/index#take())\n\n#### [takeLast()](index#takeLast())\n\nReturns a new Collection of the same type which includes the last `amount` entries from this Collection.\n\n``` ts\ntakeLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#takeLast()`](../collection/index#takeLast())\n\n#### [takeWhile()](index#takeWhile())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.\n\n``` ts\ntakeWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeWhile()`](../collection/index#takeWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeWhile(x => x.match(/o/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n#### [takeUntil()](index#takeUntil())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.\n\n``` ts\ntakeUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeUntil()`](../collection/index#takeUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeUntil(x => x.match(/at/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n### Combination\n\n#### [flatten()](index#flatten())\n\n``` ts\nflatten(depth?: number): Collection<unknown, unknown>\nflatten(shallow?: boolean): Collection<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection#flatten()`](../collection/index#flatten())\n\n### Reducing a value\n\n#### [reduce()](index#reduce())\n\n``` ts\nreduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R\nreduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduce()`](../collection/index#reduce())\n\n#### [reduceRight()](index#reduceRight())\n\n``` ts\nreduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R\nreduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduceRight()`](../collection/index#reduceRight())\n\n#### [every()](index#every())\n\nTrue if `predicate` returns true for all entries in the Collection.\n\n``` ts\nevery(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#every()`](../collection/index#every())\n\n#### [some()](index#some())\n\nTrue if `predicate` returns true for any entry in the Collection.\n\n``` ts\nsome(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#some()`](../collection/index#some())\n\n#### [join()](index#join())\n\nJoins values together as a string, inserting a separator between each. The default separator is `\",\"`.\n\n``` ts\njoin(separator?: string): string\n```\n\n#### Inherited from\n\n[`Collection#join()`](../collection/index#join())\n\n#### [isEmpty()](index#isEmpty())\n\nReturns true if this Collection includes no values.\n\n``` ts\nisEmpty(): boolean\n```\n\n#### Inherited from\n\n[`Collection#isEmpty()`](../collection/index#isEmpty())\n\n#### Discussion\n\nFor some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.\n\n#### [count()](index#count())\n\n``` ts\ncount(): number\ncount(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#count()`](../collection/index#count())\n\n#### [countBy()](index#countBy())\n\nReturns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.\n\n``` ts\ncountBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Map<G, number>\n```\n\n#### Inherited from\n\n[`Collection#countBy()`](../collection/index#countBy())\n\n#### Discussion\n\nNote: This is not a lazy operation.\n\n### Search for value\n\n#### [find()](index#find())\n\nReturns the first value for which the `predicate` returns true.\n\n``` ts\nfind(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#find()`](../collection/index#find())\n\n#### [findLast()](index#findLast())\n\nReturns the last value for which the `predicate` returns true.\n\n``` ts\nfindLast(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLast()`](../collection/index#findLast())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findEntry()](index#findEntry())\n\nReturns the first \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findEntry()`](../collection/index#findEntry())\n\n#### [findLastEntry()](index#findLastEntry())\n\nReturns the last \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindLastEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastEntry()`](../collection/index#findLastEntry())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findKey()](index#findKey())\n\nReturns the key for which the `predicate` returns true.\n\n``` ts\nfindKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#findKey()`](../collection/index#findKey())\n\n#### [findLastKey()](index#findLastKey())\n\nReturns the last key for which the `predicate` returns true.\n\n``` ts\nfindLastKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastKey()`](../collection/index#findLastKey())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [keyOf()](index#keyOf())\n\nReturns the key associated with the search value, or undefined.\n\n``` ts\nkeyOf(searchValue: V): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#keyOf()`](../collection/index#keyOf())\n\n#### [lastKeyOf()](index#lastKeyOf())\n\nReturns the last key associated with the search value, or undefined.\n\n``` ts\nlastKeyOf(searchValue: V): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#lastKeyOf()`](../collection/index#lastKeyOf())\n\n#### [max()](index#max())\n\nReturns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmax(comparator?: (valueA: V, valueB: V) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#max()`](../collection/index#max())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [maxBy()](index#maxBy())\n\nLike [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nmaxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#maxBy()`](../collection/index#maxBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it\n```\n\n#### [min()](index#min())\n\nReturns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmin(comparator?: (valueA: V, valueB: V) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#min()`](../collection/index#min())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [minBy()](index#minBy())\n\nLike [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nminBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#minBy()`](../collection/index#minBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it\n```\n\n### Comparison\n\n#### [isSubset()](index#isSubset())\n\nTrue if `iter` includes every value in this Collection.\n\n``` ts\nisSubset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSubset()`](../collection/index#isSubset())\n\n#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Map/](https://immutable-js.com/docs/v4.2.1/Map/)"
- name: Map.[Symbol.iterator]()
  id: map/index#[Symbol.iterator]()
  summary: null
  belongs_to: Map
  description: |-
    #### [\[Symbol.iterator\]()](index#%5BSymbol.iterator%5D())

    ``` ts
    [Symbol.iterator](): IterableIterator<[K, V]>
    ```

    #### Inherited from

    [`Collection.Keyed#[Symbol.iterator]()`](../collection.keyed/index#%5BSymbol.iterator%5D())

    ### Value equality
- name: Map.asImmutable()
  id: map/index#asImmutable()
  summary: The yin to asMutable's yang
  belongs_to: Map
  description: |-
    #### [asImmutable()](index#asImmutable())

    The yin to [`asMutable`](index#asMutable())'s yang. Because it applies to mutable collections, this operation is *mutable* and may return itself (though may not return itself, i.e. if the result is an empty collection). Once performed, the original mutable copy must no longer be mutated since it may be the immutable result.

    ``` ts
    asImmutable(): this
    ```

    #### see

    [`Map#asMutable`](index#asMutable())

    #### Discussion

    If possible, use [`withMutations`](index#withMutations()) to work with temporary mutable copies as it provides an easier to use API and considers many common optimizations.

    ### Sequence algorithms
- name: Map.asMutable()
  id: map/index#asMutable()
  summary: Another way to avoid creation of intermediate Immutable maps is to create a mutable copy of this collection
  belongs_to: Map
  description: |-
    #### [asMutable()](index#asMutable())

    Another way to avoid creation of intermediate Immutable maps is to create a mutable copy of this collection. Mutable copies *always* return `this`, and thus shouldn't be used for equality. Your function should never return a mutable copy of a collection, only use it internally to create a new collection.

    ``` ts
    asMutable(): this
    ```

    #### see

    [`Map#asImmutable`](index#asImmutable())

    #### Discussion

    If possible, use [`withMutations`](index#withMutations()) to work with temporary mutable copies as it provides an easier to use API and considers many common optimizations.

    Note: if the collection is already mutable, [`asMutable`](index#asMutable()) returns itself.

    Note: Not all methods can be used on a mutable collection or within [`withMutations`](index#withMutations())! Read the documentation for each method to see if it is safe to use in [`withMutations`](index#withMutations()).
- name: Map.butLast()
  id: map/index#butLast()
  summary: Returns a new Collection of the same type containing all entries except the last
  belongs_to: Map
  description: |-
    #### [butLast()](index#butLast())

    Returns a new Collection of the same type containing all entries except the last.

    ``` ts
    butLast(): this
    ```

    #### Inherited from

    [`Collection#butLast()`](../collection/index#butLast())
- name: Map.clear()
  id: map/index#clear()
  summary: Returns a new Map containing no keys or values
  belongs_to: Map
  description: |-
    #### [clear()](index#clear())

    Returns a new Map containing no keys or values.

    ``` ts
    clear(): this
    ```

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ key: 'value' }).clear()
    // Map {}run it
    ```

    Note: [`clear`](index#clear()) can be used in [`withMutations`](index#withMutations()).
- name: Map.concat()
  id: map/index#concat()
  summary: null
  belongs_to: Map
  description: |-
    #### [concat()](index#concat())

    ``` ts
    concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Collection.Keyed<K | KC, V | VC>
    concat<C>(...collections: Array<{[key: string]: C}>): Collection.Keyed<K | string, V | C>
    ```

    #### Inherited from

    [`Collection.Keyed#concat()`](../collection.keyed/index#concat())
- name: Map.count()
  id: map/index#count()
  summary: null
  belongs_to: Map
  description: |-
    #### [count()](index#count())

    ``` ts
    count(): number
    count(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#count()`](../collection/index#count())
- name: Map.countBy()
  id: map/index#countBy()
  summary: Returns a Seq.Keyed of counts, grouped by the return value of the grouper function
  belongs_to: Map
  description: |-
    #### [countBy()](index#countBy())

    Returns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.

    ``` ts
    countBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Map<G, number>
    ```

    #### Inherited from

    [`Collection#countBy()`](../collection/index#countBy())

    #### Discussion

    Note: This is not a lazy operation.

    ### Search for value
- name: Map.delete()
  id: map/index#delete()
  summary: Returns a new Map which excludes this key
  belongs_to: Map
  description: |-
    #### [delete()](index#delete())

    Returns a new Map which excludes this `key`.

    ``` ts
    delete(key: K): this
    ```

    #### alias

    `remove()`

    #### Discussion

    Note: [`delete`](index#delete()) cannot be safely used in IE8, but is provided to mirror the ES6 collection API.

    ``` ts
    const { Map } = require('immutable')
    const originalMap = Map({
      key: 'value',
      otherKey: 'other value'
    })
    // Map { "key": "value", "otherKey": "other value" }
    originalMap.delete('otherKey')
    // Map { "key": "value" }run it
    ```

    Note: [`delete`](index#delete()) can be used in [`withMutations`](index#withMutations()).
- name: Map.deleteAll()
  id: map/index#deleteAll()
  summary: Returns a new Map which excludes the provided keys
  belongs_to: Map
  description: |-
    #### [deleteAll()](index#deleteAll())

    Returns a new Map which excludes the provided `keys`.

    ``` ts
    deleteAll(keys: Iterable<K>): this
    ```

    #### alias

    `removeAll()`

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const names = Map({ a: "Aaron", b: "Barry", c: "Connor" })
    names.deleteAll([ 'a', 'c' ])
    // Map { "b": "Barry" }run it
    ```

    Note: [`deleteAll`](index#deleteAll()) can be used in [`withMutations`](index#withMutations()).
- name: Map.deleteIn()
  id: map/index#deleteIn()
  summary: Returns a new Map having removed the value at this keyPath
  belongs_to: Map
  description: |-
    #### [deleteIn()](index#deleteIn())

    Returns a new Map having removed the value at this `keyPath`. If any keys in `keyPath` do not exist, no change will occur.

    ``` ts
    deleteIn(keyPath: Iterable<unknown>): this
    ```

    #### alias

    `removeIn()`

    #### Discussion

    Note: [`deleteIn`](index#deleteIn()) can be used in [`withMutations`](index#withMutations()).
- name: Map.entries()
  id: map/index#entries()
  summary: An iterator of this Collection's entries as [ key, value ] tuples
  belongs_to: Map
  description: |-
    #### [entries()](index#entries())

    An iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.

    ``` ts
    entries(): IterableIterator<[K, V]>
    ```

    #### Inherited from

    [`Collection#entries()`](../collection/index#entries())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.

    ### Collections (Seq)
- name: Map.entrySeq()
  id: map/index#entrySeq()
  summary: Returns a new Seq.Indexed of [key, value] tuples
  belongs_to: Map
  description: |-
    #### [entrySeq()](index#entrySeq())

    Returns a new Seq.Indexed of \[key, value\] tuples.

    ``` ts
    entrySeq(): Seq.Indexed<[K, V]>
    ```

    #### Inherited from

    [`Collection#entrySeq()`](../collection/index#entrySeq())

    ### Side effects
- name: Map.equals()
  id: map/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: Map
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Inherited from

    [`Collection#equals()`](../collection/index#equals())

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: Map.every()
  id: map/index#every()
  summary: True if predicate returns true for all entries in the Collection
  belongs_to: Map
  description: |-
    #### [every()](index#every())

    True if `predicate` returns true for all entries in the Collection.

    ``` ts
    every(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#every()`](../collection/index#every())
- name: Map.filter()
  id: map/index#filter()
  summary: null
  belongs_to: Map
  description: |-
    #### [filter()](index#filter())

    ``` ts
    filter<F>(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): Map<K, F>
    filter(predicate: (value: V, key: K, iter: this) => unknown,context?: unknown): this
    ```

    #### Overrides

    [`Collection.Keyed#filter()`](../collection.keyed/index#filter())
- name: Map.filterNot()
  id: map/index#filterNot()
  summary: Returns a new Collection of the same type with only the entries for which the predicate function returns false
  belongs_to: Map
  description: |-
    #### [filterNot()](index#filterNot())

    Returns a new Collection of the same type with only the entries for which the `predicate` function returns false.

    ``` ts
    filterNot(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#filterNot()`](../collection/index#filterNot())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
    // Map { "a": 1, "c": 3 }run it
    ```

    Note: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.
- name: Map.find()
  id: map/index#find()
  summary: Returns the first value for which the predicate returns true
  belongs_to: Map
  description: |-
    #### [find()](index#find())

    Returns the first value for which the `predicate` returns true.

    ``` ts
    find(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined
    ```

    #### Inherited from

    [`Collection#find()`](../collection/index#find())
- name: Map.findEntry()
  id: map/index#findEntry()
  summary: Returns the first [key, value] entry for which the predicate returns true
  belongs_to: Map
  description: |-
    #### [findEntry()](index#findEntry())

    Returns the first \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
    ```

    #### Inherited from

    [`Collection#findEntry()`](../collection/index#findEntry())
- name: Map.findKey()
  id: map/index#findKey()
  summary: Returns the key for which the predicate returns true
  belongs_to: Map
  description: |-
    #### [findKey()](index#findKey())

    Returns the key for which the `predicate` returns true.

    ``` ts
    findKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined
    ```

    #### Inherited from

    [`Collection#findKey()`](../collection/index#findKey())
- name: Map.findLast()
  id: map/index#findLast()
  summary: Returns the last value for which the predicate returns true
  belongs_to: Map
  description: |-
    #### [findLast()](index#findLast())

    Returns the last value for which the `predicate` returns true.

    ``` ts
    findLast(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined
    ```

    #### Inherited from

    [`Collection#findLast()`](../collection/index#findLast())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Map.findLastEntry()
  id: map/index#findLastEntry()
  summary: Returns the last [key, value] entry for which the predicate returns true
  belongs_to: Map
  description: |-
    #### [findLastEntry()](index#findLastEntry())

    Returns the last \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findLastEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
    ```

    #### Inherited from

    [`Collection#findLastEntry()`](../collection/index#findLastEntry())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Map.findLastKey()
  id: map/index#findLastKey()
  summary: Returns the last key for which the predicate returns true
  belongs_to: Map
  description: |-
    #### [findLastKey()](index#findLastKey())

    Returns the last key for which the `predicate` returns true.

    ``` ts
    findLastKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined
    ```

    #### Inherited from

    [`Collection#findLastKey()`](../collection/index#findLastKey())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Map.first()
  id: map/index#first()
  summary: In case the Collection is not empty returns the first element of the Collection
  belongs_to: Map
  description: |-
    #### [first()](index#first())

    In case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    first<NSV>(notSetValue?: NSV): V | NSV
    ```

    #### Inherited from

    [`Collection#first()`](../collection/index#first())
- name: Map.flatMap()
  id: map/index#flatMap()
  summary: Flat-maps the Map, returning a new Map
  belongs_to: Map
  description: |-
    #### [flatMap()](index#flatMap())

    Flat-maps the Map, returning a new Map.

    ``` ts
    flatMap<KM, VM>(mapper: (value: V, key: K, iter: this) => Iterable<[KM, VM]>,context?: unknown): Map<KM, VM>
    ```

    #### Overrides

    [`Collection.Keyed#flatMap()`](../collection.keyed/index#flatMap())

    #### Discussion

    Similar to `data.map(...).flatten(true)`.
- name: Map.flatten()
  id: map/index#flatten()
  summary: null
  belongs_to: Map
  description: |-
    #### [flatten()](index#flatten())

    ``` ts
    flatten(depth?: number): Collection<unknown, unknown>
    flatten(shallow?: boolean): Collection<unknown, unknown>
    ```

    #### Inherited from

    [`Collection#flatten()`](../collection/index#flatten())

    ### Reducing a value
- name: Map.flip()
  id: map/index#flip()
  summary: null
  belongs_to: Map
  description: |-
    #### [flip()](index#flip())

    ``` ts
    flip(): Map<V, K>
    ```

    #### Overrides

    [`Collection.Keyed#flip()`](../collection.keyed/index#flip())

    #### see

    Collection.Keyed.flip
- name: Map.forEach()
  id: map/index#forEach()
  summary: The sideEffect is executed for every entry in the Collection
  belongs_to: Map
  description: |-
    #### [forEach()](index#forEach())

    The `sideEffect` is executed for every entry in the Collection.

    ``` ts
    forEach(sideEffect: (value: V, key: K, iter: this) => unknown,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#forEach()`](../collection/index#forEach())

    #### Discussion

    Unlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).

    ### Creating subsets
- name: Map.get()
  id: map/index#get()
  summary: null
  belongs_to: Map
  description: |-
    #### [get()](index#get())

    ``` ts
    get<NSV>(key: K, notSetValue: NSV): V | NSV
    get(key: K): V | undefined
    ```

    #### Inherited from

    [`Collection#get()`](../collection/index#get())
- name: Map.getIn()
  id: map/index#getIn()
  summary: Returns the value found by following a path of keys or indices through nested Collections
  belongs_to: Map
  description: |-
    #### [getIn()](index#getIn())

    Returns the value found by following a path of keys or indices through nested Collections.

    ``` ts
    getIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown
    ```

    #### Inherited from

    [`Collection#getIn()`](../collection/index#getIn())

    #### Discussion

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: [ { y: 123 } ] });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```
- name: Map.groupBy()
  id: map/index#groupBy()
  summary: Returns a Collection.Keyed of Collection.Keyeds, grouped by the return value of the grouper function
  belongs_to: Map
  description: |-
    #### [groupBy()](index#groupBy())

    Returns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.

    ``` ts
    groupBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<K, V>>
    ```

    #### Inherited from

    [`Collection#groupBy()`](../collection/index#groupBy())

    #### Discussion

    Note: This is always an eager operation.

    ``` ts
    const { List, Map } = require('immutable')
    const listOfMaps = List([
      Map({ v: 0 }),
      Map({ v: 1 }),
      Map({ v: 1 }),
      Map({ v: 0 }),
      Map({ v: 2 })
    ])
    const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
    // Map {
    //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
    //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
    //   2: List [ Map{ "v": 2 } ],
    // }run it
    ```

    ### Conversion to JavaScript types
- name: Map.has()
  id: map/index#has()
  summary: null
  belongs_to: Map
  description: |-
    #### [has()](index#has())

    True if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    has(key: K): boolean
    ```

    #### Inherited from

    [`Collection#has()`](../collection/index#has())
- name: Map.hashCode()
  id: map/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: Map
  description: |-
    #### [hashCode()](index#hashCode())

    Computes and returns the hashed identity for this Collection.

    ``` ts
    hashCode(): number
    ```

    #### Inherited from

    [`Collection#hashCode()`](../collection/index#hashCode())

    #### Discussion

    The [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](index), enabling lookup via a different instance.

    ``` ts
    const a = List([ 1, 2, 3 ]);
    const b = List([ 1, 2, 3 ]);
    assert.notStrictEqual(a, b); // different instances
    const set = Set([ a ]);
    assert.equal(set.has(b), true);run it
    ```

    If two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.

    ### Reading values
- name: Map.hasIn()
  id: map/index#hasIn()
  summary: True if the result of following a path of keys or indices through nested Collections results in a set value
  belongs_to: Map
  description: |-
    #### [hasIn()](index#hasIn())

    True if the result of following a path of keys or indices through nested Collections results in a set value.

    ``` ts
    hasIn(searchKeyPath: Iterable<unknown>): boolean
    ```

    #### Inherited from

    [`Collection#hasIn()`](../collection/index#hasIn())

    ### Conversion to Collections
- name: Map.includes()
  id: map/index#includes()
  summary: null
  belongs_to: Map
  description: |-
    #### [includes()](index#includes())

    True if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    includes(value: V): boolean
    ```

    #### Inherited from

    [`Collection#includes()`](../collection/index#includes())

    #### alias

    `contains()`
- name: Map.isEmpty()
  id: map/index#isEmpty()
  summary: Returns true if this Collection includes no values
  belongs_to: Map
  description: |-
    #### [isEmpty()](index#isEmpty())

    Returns true if this Collection includes no values.

    ``` ts
    isEmpty(): boolean
    ```

    #### Inherited from

    [`Collection#isEmpty()`](../collection/index#isEmpty())

    #### Discussion

    For some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.
- name: Map.isSubset()
  id: map/index#isSubset()
  summary: True if iter includes every value in this Collection
  belongs_to: Map
  description: |-
    #### [isSubset()](index#isSubset())

    True if `iter` includes every value in this Collection.

    ``` ts
    isSubset(iter: Iterable<V>): boolean
    ```

    #### Inherited from

    [`Collection#isSubset()`](../collection/index#isSubset())
- name: Map.isSuperset()
  id: map/index#isSuperset()
  summary: True if this Collection includes every value in iter
  belongs_to: Map
  description: "#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Map/](https://immutable-js.com/docs/v4.2.1/Map/)"
- name: Map.join()
  id: map/index#join()
  summary: Joins values together as a string, inserting a separator between each
  belongs_to: Map
  description: |-
    #### [join()](index#join())

    Joins values together as a string, inserting a separator between each. The default separator is `","`.

    ``` ts
    join(separator?: string): string
    ```

    #### Inherited from

    [`Collection#join()`](../collection/index#join())
- name: Map.keyOf()
  id: map/index#keyOf()
  summary: Returns the key associated with the search value, or undefined
  belongs_to: Map
  description: |-
    #### [keyOf()](index#keyOf())

    Returns the key associated with the search value, or undefined.

    ``` ts
    keyOf(searchValue: V): K | undefined
    ```

    #### Inherited from

    [`Collection#keyOf()`](../collection/index#keyOf())
- name: Map.keys()
  id: map/index#keys()
  summary: An iterator of this Collection's keys
  belongs_to: Map
  description: |-
    #### [keys()](index#keys())

    An iterator of this [`Collection`](../collection/index)'s keys.

    ``` ts
    keys(): IterableIterator<K>
    ```

    #### Inherited from

    [`Collection#keys()`](../collection/index#keys())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.
- name: Map.keySeq()
  id: map/index#keySeq()
  summary: Returns a new Seq.Indexed of the keys of this Collection, discarding values
  belongs_to: Map
  description: |-
    #### [keySeq()](index#keySeq())

    Returns a new Seq.Indexed of the keys of this Collection, discarding values.

    ``` ts
    keySeq(): Seq.Indexed<K>
    ```

    #### Inherited from

    [`Collection#keySeq()`](../collection/index#keySeq())
- name: Map.last()
  id: map/index#last()
  summary: In case the Collection is not empty returns the last element of the Collection
  belongs_to: Map
  description: |-
    #### [last()](index#last())

    In case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    last<NSV>(notSetValue?: NSV): V | NSV
    ```

    #### Inherited from

    [`Collection#last()`](../collection/index#last())

    ### Reading deep values
- name: Map.lastKeyOf()
  id: map/index#lastKeyOf()
  summary: Returns the last key associated with the search value, or undefined
  belongs_to: Map
  description: |-
    #### [lastKeyOf()](index#lastKeyOf())

    Returns the last key associated with the search value, or undefined.

    ``` ts
    lastKeyOf(searchValue: V): K | undefined
    ```

    #### Inherited from

    [`Collection#lastKeyOf()`](../collection/index#lastKeyOf())
- name: Map.Map()
  id: map/index#Map()
  summary: null
  belongs_to: Map
  description: |-
    #### [Map()](index#Map())

    ``` ts
    Map<K, V>(collection?: Iterable<[K, V]>): Map<K, V>
    Map<V>(obj: {[key: string]: V}): Map<string, V>
    Map<K, V>(obj: {[key: string]: V}): Map<K, V>
    ```

    ### Static methods
- name: Map.map()
  id: map/index#map()
  summary: null
  belongs_to: Map
  description: |-
    #### [Map()](index#Map())

    ``` ts
    Map<K, V>(collection?: Iterable<[K, V]>): Map<K, V>
    Map<V>(obj: {[key: string]: V}): Map<string, V>
    Map<K, V>(obj: {[key: string]: V}): Map<K, V>
    ```

    ### Static methods
- name: Map.Map.isMap()
  id: map/index#isMap()
  summary: null
  belongs_to: Map
  description: |-
    #### [Map.isMap()](index#isMap())

    ``` ts
    Map.isMap(maybeMap: unknown): boolean
    ```

    ### Members
- name: Map.mapEntries()
  id: map/index#mapEntries()
  summary: null
  belongs_to: Map
  description: |-
    #### [mapEntries()](index#mapEntries())

    ``` ts
    mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM] | undefined,context?: unknown): Map<KM, VM>
    ```

    #### Overrides

    [`Collection.Keyed#mapEntries()`](../collection.keyed/index#mapEntries())

    #### see

    Collection.Keyed.mapEntries
- name: Map.mapKeys()
  id: map/index#mapKeys()
  summary: null
  belongs_to: Map
  description: |-
    #### [mapKeys()](index#mapKeys())

    ``` ts
    mapKeys<M>(mapper: (key: K, value: V, iter: this) => M,context?: unknown): Map<M, V>
    ```

    #### Overrides

    [`Collection.Keyed#mapKeys()`](../collection.keyed/index#mapKeys())

    #### see

    Collection.Keyed.mapKeys
- name: Map.max()
  id: map/index#max()
  summary: Returns the maximum value in this collection
  belongs_to: Map
  description: |-
    #### [max()](index#max())

    Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    max(comparator?: (valueA: V, valueB: V) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#max()`](../collection/index#max())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Map.maxBy()
  id: map/index#maxBy()
  summary: null
  belongs_to: Map
  description: |-
    #### [maxBy()](index#maxBy())

    Like [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    maxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#maxBy()`](../collection/index#maxBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it
    ```
- name: Map.merge()
  id: map/index#merge()
  summary: null
  belongs_to: Map
  description: |-
    #### [merge()](index#merge())

    ``` ts
    merge<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Map<K | KC, V | VC>
    merge<C>(...collections: Array<{[key: string]: C}>): Map<K | string, V | C>
    ```
- name: Map.mergeDeep()
  id: map/index#mergeDeep()
  summary: Like merge(), but when two compatible collections are encountered with the same key, it merges them as well, recursing deeply through the nested data
  belongs_to: Map
  description: |-
    #### [mergeDeep()](index#mergeDeep())

    Like [`merge()`](index#merge()), but when two compatible collections are encountered with the same key, it merges them as well, recursing deeply through the nested data. Two collections are considered to be compatible (and thus will be merged together) if they both fall into one of three categories: keyed (e.g., [`Map`](index)s, [`Record`](../record/index)s, and objects), indexed (e.g., [`List`](../list/index)s and arrays), or set-like (e.g., [`Set`](../set/index)s). If they fall into separate categories, [`mergeDeep`](index#mergeDeep()) will replace the existing collection with the collection being merged in. This behavior can be customized by using [`mergeDeepWith()`](index#mergeDeepWith()).

    ``` ts
    mergeDeep(...collections: Array<Iterable<[K, V]> | {[key: string]: V}>): this
    ```

    #### Discussion

    Note: Indexed and set-like collections are merged using [`concat()`](index#concat())/`union()` and therefore do not recurse.

    ``` ts
    const { Map } = require('immutable')
    const one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })
    const two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })
    one.mergeDeep(two)
    // Map {
    //   "a": Map { "x": 2, "y": 10 },
    //   "b": Map { "x": 20, "y": 5 },
    //   "c": Map { "z": 3 }
    // }run it
    ```

    Note: [`mergeDeep`](index#mergeDeep()) can be used in [`withMutations`](index#withMutations()).
- name: Map.mergeDeepIn()
  id: map/index#mergeDeepIn()
  summary: A combination of updateIn and mergeDeep, returning a new Map, but performing the deep merge at a point arrived at by following the keyPath
  belongs_to: Map
  description: |-
    #### [mergeDeepIn()](index#mergeDeepIn())

    A combination of [`updateIn`](index#updateIn()) and [`mergeDeep`](index#mergeDeep()), returning a new Map, but performing the deep merge at a point arrived at by following the keyPath. In other words, these two lines are equivalent:

    ``` ts
    mergeDeepIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this
    ```

    #### Discussion

    ``` ts
    map.updateIn(['a', 'b', 'c'], abc => abc.mergeDeep(y))
    map.mergeDeepIn(['a', 'b', 'c'], y)
    ```

    Note: [`mergeDeepIn`](index#mergeDeepIn()) can be used in [`withMutations`](index#withMutations()).

    ### Transient changes
- name: Map.mergeDeepWith()
  id: map/index#mergeDeepWith()
  summary: Like mergeDeep(), but when two non-collections or incompatible collections are encountered at the same key, it uses the merger function to determine the resulting value
  belongs_to: Map
  description: |-
    #### [mergeDeepWith()](index#mergeDeepWith())

    Like [`mergeDeep()`](index#mergeDeep()), but when two non-collections or incompatible collections are encountered at the same key, it uses the `merger` function to determine the resulting value. Collections are considered incompatible if they fall into separate categories between keyed, indexed, and set-like.

    ``` ts
    mergeDeepWith(merger: (oldVal: unknown, newVal: unknown, key: unknown) => unknown,...collections: Array<Iterable<[K, V]> | {[key: string]: V}>): this
    ```

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })
    const two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })
    one.mergeDeepWith((oldVal, newVal) => oldVal / newVal, two)
    // Map {
    //   "a": Map { "x": 5, "y": 10 },
    //   "b": Map { "x": 20, "y": 10 },
    //   "c": Map { "z": 3 }
    // }run it
    ```

    Note: [`mergeDeepWith`](index#mergeDeepWith()) can be used in [`withMutations`](index#withMutations()).

    ### Deep persistent changes
- name: Map.mergeIn()
  id: map/index#mergeIn()
  summary: A combination of updateIn and merge, returning a new Map, but performing the merge at a point arrived at by following the keyPath
  belongs_to: Map
  description: |-
    #### [mergeIn()](index#mergeIn())

    A combination of [`updateIn`](index#updateIn()) and [`merge`](index#merge()), returning a new Map, but performing the merge at a point arrived at by following the keyPath. In other words, these two lines are equivalent:

    ``` ts
    mergeIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this
    ```

    #### Discussion

    ``` ts
    map.updateIn(['a', 'b', 'c'], abc => abc.merge(y))
    map.mergeIn(['a', 'b', 'c'], y)
    ```

    Note: [`mergeIn`](index#mergeIn()) can be used in [`withMutations`](index#withMutations()).
- name: Map.mergeWith()
  id: map/index#mergeWith()
  summary: Like merge(), mergeWith() returns a new Map resulting from merging the provided Collections (or JS objects) into this Map, but uses the merger function for dealing with conflicts
  belongs_to: Map
  description: |-
    #### [mergeWith()](index#mergeWith())

    Like [`merge()`](index#merge()), [`mergeWith()`](index#mergeWith()) returns a new Map resulting from merging the provided Collections (or JS objects) into this Map, but uses the `merger` function for dealing with conflicts.

    ``` ts
    mergeWith(merger: (oldVal: V, newVal: V, key: K) => V,...collections: Array<Iterable<[K, V]> | {[key: string]: V}>): this
    ```

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const one = Map({ a: 10, b: 20, c: 30 })
    const two = Map({ b: 40, a: 50, d: 60 })
    one.mergeWith((oldVal, newVal) => oldVal / newVal, two)
    // { "a": 0.2, "b": 0.5, "c": 30, "d": 60 }
    two.mergeWith((oldVal, newVal) => oldVal / newVal, one)
    // { "b": 2, "a": 5, "d": 60, "c": 30 }run it
    ```

    Note: [`mergeWith`](index#mergeWith()) can be used in [`withMutations`](index#withMutations()).
- name: Map.min()
  id: map/index#min()
  summary: Returns the minimum value in this collection
  belongs_to: Map
  description: |-
    #### [min()](index#min())

    Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    min(comparator?: (valueA: V, valueB: V) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#min()`](../collection/index#min())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Map.minBy()
  id: map/index#minBy()
  summary: null
  belongs_to: Map
  description: |-
    #### [minBy()](index#minBy())

    Like [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    minBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#minBy()`](../collection/index#minBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it
    ```

    ### Comparison
- name: Map.partition()
  id: map/index#partition()
  summary: null
  belongs_to: Map
  description: |-
    #### [partition()](index#partition())

    ``` ts
    partition<F, C>(predicate: (this: C, value: V, key: K, iter: this) => boolean,context?: C): [Map<K, V>, Map<K, F>]
    partition<C>(predicate: (this: C, value: V, key: K, iter: this) => unknown,context?: C): [this, this]
    ```

    #### Overrides

    [`Collection.Keyed#partition()`](../collection.keyed/index#partition())
- name: Map.reduce()
  id: map/index#reduce()
  summary: null
  belongs_to: Map
  description: |-
    #### [reduce()](index#reduce())

    ``` ts
    reduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R
    reduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduce()`](../collection/index#reduce())
- name: Map.reduceRight()
  id: map/index#reduceRight()
  summary: null
  belongs_to: Map
  description: |-
    #### [reduceRight()](index#reduceRight())

    ``` ts
    reduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R
    reduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduceRight()`](../collection/index#reduceRight())
- name: Map.rest()
  id: map/index#rest()
  summary: Returns a new Collection of the same type containing all entries except the first
  belongs_to: Map
  description: |-
    #### [rest()](index#rest())

    Returns a new Collection of the same type containing all entries except the first.

    ``` ts
    rest(): this
    ```

    #### Inherited from

    [`Collection#rest()`](../collection/index#rest())
- name: Map.reverse()
  id: map/index#reverse()
  summary: Returns a new Collection of the same type in reverse order
  belongs_to: Map
  description: |-
    #### [reverse()](index#reverse())

    Returns a new Collection of the same type in reverse order.

    ``` ts
    reverse(): this
    ```

    #### Inherited from

    [`Collection#reverse()`](../collection/index#reverse())
- name: Map.set()
  id: map/index#set()
  summary: Returns a new Map also containing the new key, value pair
  belongs_to: Map
  description: |-
    #### [set()](index#set())

    Returns a new Map also containing the new key, value pair. If an equivalent key already exists in this Map, it will be replaced.

    ``` ts
    set(key: K, value: V): this
    ```

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const originalMap = Map()
    const newerMap = originalMap.set('key', 'value')
    const newestMap = newerMap.set('key', 'newer value')

    originalMap
    // Map {}
    newerMap
    // Map { "key": "value" }
    newestMap
    // Map { "key": "newer value" }run it
    ```

    Note: [`set`](index#set()) can be used in [`withMutations`](index#withMutations()).
- name: Map.setIn()
  id: map/index#setIn()
  summary: Returns a new Map having set value at this keyPath
  belongs_to: Map
  description: |-
    #### [setIn()](index#setIn())

    Returns a new Map having set `value` at this `keyPath`. If any keys in `keyPath` do not exist, a new immutable Map will be created at that key.

    ``` ts
    setIn(keyPath: Iterable<unknown>, value: unknown): this
    ```

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const originalMap = Map({
      subObject: Map({
        subKey: 'subvalue',
        subSubObject: Map({
          subSubKey: 'subSubValue'
        })
      })
    })
    ```

    const newMap = originalMap.setIn(\['subObject', 'subKey'\], 'ha ha!') // Map { // "subObject": Map { // "subKey": "ha ha!", // "subSubObject": Map { "subSubKey": "subSubValue" } // } // } const newerMap = originalMap.setIn( \['subObject', 'subSubObject', 'subSubKey'\], 'ha ha ha!' ) // Map { // "subObject": Map { // "subKey": "subvalue", // "subSubObject": Map { "subSubKey": "ha ha ha!" } // } // }run it

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and setIn() can update those values as well, treating them immutably by creating new copies of those values with the changes applied.

    ``` ts
    const { Map } = require('immutable')
    const originalMap = Map({
      subObject: {
        subKey: 'subvalue',
        subSubObject: {
          subSubKey: 'subSubValue'
        }
      }
    })
    ```

    originalMap.setIn(\['subObject', 'subKey'\], 'ha ha!') // Map { // "subObject": { // subKey: "ha ha!", // subSubObject: { subSubKey: "subSubValue" } // } // }run it

    If any key in the path exists but cannot be updated (such as a primitive like number or a custom Object like Date), an error will be thrown.

    Note: [`setIn`](index#setIn()) can be used in [`withMutations`](index#withMutations()).
- name: Map.size
  id: map/index#size
  summary: The number of entries in this Map
  belongs_to: Map
  description: |-
    #### [size](index#size)

    The number of entries in this Map.

    ``` ts
    size: number
    ```

    ### Persistent changes
- name: Map.skip()
  id: map/index#skip()
  summary: Returns a new Collection of the same type which excludes the first amount entries from this Collection
  belongs_to: Map
  description: |-
    #### [skip()](index#skip())

    Returns a new Collection of the same type which excludes the first `amount` entries from this Collection.

    ``` ts
    skip(amount: number): this
    ```

    #### Inherited from

    [`Collection#skip()`](../collection/index#skip())
- name: Map.skipLast()
  id: map/index#skipLast()
  summary: Returns a new Collection of the same type which excludes the last amount entries from this Collection
  belongs_to: Map
  description: |-
    #### [skipLast()](index#skipLast())

    Returns a new Collection of the same type which excludes the last `amount` entries from this Collection.

    ``` ts
    skipLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#skipLast()`](../collection/index#skipLast())
- name: Map.skipUntil()
  id: map/index#skipUntil()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns true
  belongs_to: Map
  description: |-
    #### [skipUntil()](index#skipUntil())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns true.

    ``` ts
    skipUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipUntil()`](../collection/index#skipUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipUntil(x => x.match(/hat/))
    // List [ "hat", "god" ]run it
    ```
- name: Map.skipWhile()
  id: map/index#skipWhile()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns false
  belongs_to: Map
  description: |-
    #### [skipWhile()](index#skipWhile())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns false.

    ``` ts
    skipWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipWhile()`](../collection/index#skipWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipWhile(x => x.match(/g/))
    // List [ "cat", "hat", "god" ]run it
    ```
- name: Map.slice()
  id: map/index#slice()
  summary: Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end
  belongs_to: Map
  description: |-
    #### [slice()](index#slice())

    Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.

    ``` ts
    slice(begin?: number, end?: number): this
    ```

    #### Inherited from

    [`Collection#slice()`](../collection/index#slice())

    #### Discussion

    If begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.

    If end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.

    If the requested slice is equivalent to the current Collection, then it will return itself.
- name: Map.some()
  id: map/index#some()
  summary: True if predicate returns true for any entry in the Collection
  belongs_to: Map
  description: |-
    #### [some()](index#some())

    True if `predicate` returns true for any entry in the Collection.

    ``` ts
    some(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#some()`](../collection/index#some())
- name: Map.sort()
  id: map/index#sort()
  summary: Returns a new Collection of the same type which includes the same entries, stably sorted by using a comparator
  belongs_to: Map
  description: |-
    #### [sort()](index#sort())

    Returns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.

    ``` ts
    sort(comparator?: (valueA: V, valueB: V) => number): this
    ```

    #### Inherited from

    [`Collection#sort()`](../collection/index#sort())

    #### Discussion

    If a `comparator` is not provided, a default comparator uses `<` and `>`.

    `comparator(valueA, valueB)`:

    - Returns `0` if the elements should not be swapped.
    - Returns `-1` (or any negative number) if `valueA` comes before `valueB`
    - Returns `1` (or any positive number) if `valueA` comes after `valueB`
    - Is pure, i.e. it must always return the same value for the same pair of values.

    When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.

    ``` ts
    const { Map } = require('immutable')
    Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
      if (a < b) { return -1; }
      if (a > b) { return 1; }
      if (a === b) { return 0; }
    });
    // OrderedMap { "a": 1, "b": 2, "c": 3 }run it
    ```

    Note: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Map.sortBy()
  id: map/index#sortBy()
  summary: 'Note: sortBy() Always returns a new instance, even if the original was already sorted'
  belongs_to: Map
  description: |-
    #### [sortBy()](index#sortBy())

    Like [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:

    ``` ts
    sortBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this
    ```

    #### Inherited from

    [`Collection#sortBy()`](../collection/index#sortBy())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const beattles = Map({
      John: { name: "Lennon" },
      Paul: { name: "McCartney" },
      George: { name: "Harrison" },
      Ringo: { name: "Starr" },
    });
    beattles.sortBy(member => member.name);run it
    ```

    Note: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Map.take()
  id: map/index#take()
  summary: Returns a new Collection of the same type which includes the first amount entries from this Collection
  belongs_to: Map
  description: |-
    #### [take()](index#take())

    Returns a new Collection of the same type which includes the first `amount` entries from this Collection.

    ``` ts
    take(amount: number): this
    ```

    #### Inherited from

    [`Collection#take()`](../collection/index#take())
- name: Map.takeLast()
  id: map/index#takeLast()
  summary: Returns a new Collection of the same type which includes the last amount entries from this Collection
  belongs_to: Map
  description: |-
    #### [takeLast()](index#takeLast())

    Returns a new Collection of the same type which includes the last `amount` entries from this Collection.

    ``` ts
    takeLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#takeLast()`](../collection/index#takeLast())
- name: Map.takeUntil()
  id: map/index#takeUntil()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns false
  belongs_to: Map
  description: |-
    #### [takeUntil()](index#takeUntil())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.

    ``` ts
    takeUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeUntil()`](../collection/index#takeUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeUntil(x => x.match(/at/))
    // List [ "dog", "frog" ]run it
    ```

    ### Combination
- name: Map.takeWhile()
  id: map/index#takeWhile()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns true
  belongs_to: Map
  description: |-
    #### [takeWhile()](index#takeWhile())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.

    ``` ts
    takeWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeWhile()`](../collection/index#takeWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeWhile(x => x.match(/o/))
    // List [ "dog", "frog" ]run it
    ```
- name: Map.toArray()
  id: map/index#toArray()
  summary: Shallowly converts this collection to an Array
  belongs_to: Map
  description: |-
    #### [toArray()](index#toArray())

    Shallowly converts this collection to an Array.

    ``` ts
    toArray(): Array<[K, V]>
    ```

    #### Inherited from

    [`Collection.Keyed#toArray()`](../collection.keyed/index#toArray())
- name: Map.toIndexedSeq()
  id: map/index#toIndexedSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Map
  description: |-
    #### [toIndexedSeq()](index#toIndexedSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    toIndexedSeq(): Seq.Indexed<V>
    ```

    #### Inherited from

    [`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())
- name: Map.toJS()
  id: map/index#toJS()
  summary: Deeply converts this Keyed collection to equivalent native JavaScript Object
  belongs_to: Map
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Keyed collection to equivalent native JavaScript Object.

    ``` ts
    toJS(): {[key: string]: DeepCopy<V>}
    ```

    #### Inherited from

    [`Collection.Keyed#toJS()`](../collection.keyed/index#toJS())

    #### Discussion

    Converts keys to Strings.
- name: Map.toJSON()
  id: map/index#toJSON()
  summary: Shallowly converts this Keyed collection to equivalent native JavaScript Object
  belongs_to: Map
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Keyed collection to equivalent native JavaScript Object.

    ``` ts
    toJSON(): {[key: string]: V}
    ```

    #### Inherited from

    [`Collection.Keyed#toJSON()`](../collection.keyed/index#toJSON())

    #### Discussion

    Converts keys to Strings.
- name: Map.toKeyedSeq()
  id: map/index#toKeyedSeq()
  summary: Returns a Seq.Keyed from this Collection where indices are treated as keys
  belongs_to: Map
  description: |-
    #### [toKeyedSeq()](index#toKeyedSeq())

    Returns a Seq.Keyed from this Collection where indices are treated as keys.

    ``` ts
    toKeyedSeq(): Seq.Keyed<K, V>
    ```

    #### Inherited from

    [`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())

    #### Discussion

    This is useful if you want to operate on an Collection.Indexed and preserve the \[index, value\] pairs.

    The returned Seq will have identical iteration order as this Collection.

    ``` ts
    const { Seq } = require('immutable')
    const indexedSeq = Seq([ 'A', 'B', 'C' ])
    // Seq [ "A", "B", "C" ]
    indexedSeq.filter(v => v === 'B')
    // Seq [ "B" ]
    const keyedSeq = indexedSeq.toKeyedSeq()
    // Seq { 0: "A", 1: "B", 2: "C" }
    keyedSeq.filter(v => v === 'B')
    // Seq { 1: "B" }run it
    ```
- name: Map.toList()
  id: map/index#toList()
  summary: Converts this Collection to a List, discarding keys
  belongs_to: Map
  description: |-
    #### [toList()](index#toList())

    Converts this Collection to a List, discarding keys.

    ``` ts
    toList(): List<V>
    ```

    #### Inherited from

    [`Collection#toList()`](../collection/index#toList())

    #### Discussion

    This is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.

    ``` ts
    const { Map, List } = require('immutable')
    var myMap = Map({ a: 'Apple', b: 'Banana' })
    List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
    myMap.toList() // List [ "Apple", "Banana" ]run it
    ```
- name: Map.toMap()
  id: map/index#toMap()
  summary: Converts this Collection to a Map, Throws if keys are not hashable
  belongs_to: Map
  description: |-
    #### [toMap()](index#toMap())

    Converts this Collection to a Map, Throws if keys are not hashable.

    ``` ts
    toMap(): Map<K, V>
    ```

    #### Inherited from

    [`Collection#toMap()`](../collection/index#toMap())

    #### Discussion

    Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Map.toObject()
  id: map/index#toObject()
  summary: Shallowly converts this Collection to an Object
  belongs_to: Map
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Collection to an Object.

    ``` ts
    toObject(): {[key: string]: V}
    ```

    #### Inherited from

    [`Collection#toObject()`](../collection/index#toObject())

    #### Discussion

    Converts keys to Strings.

    ### Conversion to Seq
- name: Map.toOrderedMap()
  id: map/index#toOrderedMap()
  summary: Converts this Collection to a Map, maintaining the order of iteration
  belongs_to: Map
  description: |-
    #### [toOrderedMap()](index#toOrderedMap())

    Converts this Collection to a Map, maintaining the order of iteration.

    ``` ts
    toOrderedMap(): OrderedMap<K, V>
    ```

    #### Inherited from

    [`Collection#toOrderedMap()`](../collection/index#toOrderedMap())

    #### Discussion

    Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Map.toOrderedSet()
  id: map/index#toOrderedSet()
  summary: Converts this Collection to a Set, maintaining the order of iteration and discarding keys
  belongs_to: Map
  description: |-
    #### [toOrderedSet()](index#toOrderedSet())

    Converts this Collection to a Set, maintaining the order of iteration and discarding keys.

    ``` ts
    toOrderedSet(): OrderedSet<V>
    ```

    #### Inherited from

    [`Collection#toOrderedSet()`](../collection/index#toOrderedSet())

    #### Discussion

    Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.
- name: Map.toSeq()
  id: map/index#toSeq()
  summary: Returns Seq.Keyed
  belongs_to: Map
  description: |-
    #### [toSeq()](index#toSeq())

    Returns Seq.Keyed.

    ``` ts
    toSeq(): Seq.Keyed<K, V>
    ```

    #### Inherited from

    [`Collection.Keyed#toSeq()`](../collection.keyed/index#toSeq())
- name: Map.toSet()
  id: map/index#toSet()
  summary: Converts this Collection to a Set, discarding keys
  belongs_to: Map
  description: |-
    #### [toSet()](index#toSet())

    Converts this Collection to a Set, discarding keys. Throws if values are not hashable.

    ``` ts
    toSet(): Set<V>
    ```

    #### Inherited from

    [`Collection#toSet()`](../collection/index#toSet())

    #### Discussion

    Note: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.
- name: Map.toSetSeq()
  id: map/index#toSetSeq()
  summary: Returns a Seq.Set of the values of this Collection, discarding keys
  belongs_to: Map
  description: |-
    #### [toSetSeq()](index#toSetSeq())

    Returns a Seq.Set of the values of this Collection, discarding keys.

    ``` ts
    toSetSeq(): Seq.Set<V>
    ```

    #### Inherited from

    [`Collection#toSetSeq()`](../collection/index#toSetSeq())

    ### Sequence functions
- name: Map.toStack()
  id: map/index#toStack()
  summary: Converts this Collection to a Stack, discarding keys
  belongs_to: Map
  description: |-
    #### [toStack()](index#toStack())

    Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.

    ``` ts
    toStack(): Stack<V>
    ```

    #### Inherited from

    [`Collection#toStack()`](../collection/index#toStack())

    #### Discussion

    Note: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.

    ### Iterators
- name: Map.update()
  id: map/index#update()
  summary: null
  belongs_to: Map
  description: |-
    #### [update()](index#update())

    ``` ts
    update(key: K, notSetValue: V, updater: (value: V) => V): this
    update(key: K, updater: (value: V | undefined) => V): this
    update<R>(updater: (value: this) => R): R
    ```

    #### Overrides

    [`Collection#update()`](../collection/index#update())
- name: Map.updateIn()
  id: map/index#updateIn()
  summary: null
  belongs_to: Map
  description: |-
    #### [updateIn()](index#updateIn())

    ``` ts
    updateIn(keyPath: Iterable<unknown>,notSetValue: unknown,updater: (value: unknown) => unknown): this
    updateIn(keyPath: Iterable<unknown>, updater: (value: unknown) => unknown): this
    ```
- name: Map.values()
  id: map/index#values()
  summary: An iterator of this Collection's values
  belongs_to: Map
  description: |-
    #### [values()](index#values())

    An iterator of this [`Collection`](../collection/index)'s values.

    ``` ts
    values(): IterableIterator<V>
    ```

    #### Inherited from

    [`Collection#values()`](../collection/index#values())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.
- name: Map.valueSeq()
  id: map/index#valueSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Map
  description: |-
    #### [valueSeq()](index#valueSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    valueSeq(): Seq.Indexed<V>
    ```

    #### Inherited from

    [`Collection#valueSeq()`](../collection/index#valueSeq())
- name: Map.wasAltered()
  id: map/index#wasAltered()
  summary: Returns true if this is a mutable copy (see asMutable()) and mutative alterations have been applied
  belongs_to: Map
  description: |-
    #### [wasAltered()](index#wasAltered())

    Returns true if this is a mutable copy (see [`asMutable()`](index#asMutable())) and mutative alterations have been applied.

    ``` ts
    wasAltered(): boolean
    ```

    #### see

    [`Map#asMutable`](index#asMutable())
- name: Map.withMutations()
  id: map/index#withMutations()
  summary: Every time you call one of the above functions, a new immutable Map is created
  belongs_to: Map
  description: |-
    #### [withMutations()](index#withMutations())

    Every time you call one of the above functions, a new immutable Map is created. If a pure function calls a number of these to produce a final return value, then a penalty on performance and memory has been paid by creating all of the intermediate immutable Maps.

    ``` ts
    withMutations(mutator: (mutable: this) => unknown): this
    ```

    #### Discussion

    If you need to apply a series of mutations to produce a new immutable Map, [`withMutations()`](index#withMutations()) creates a temporary mutable copy of the Map which can apply mutations in a highly performant manner. In fact, this is exactly how complex mutations like [`merge`](index#merge()) are done.

    As an example, this results in the creation of 2, not 4, new Maps:

    ``` ts
    const { Map } = require('immutable')
    const map1 = Map()
    const map2 = map1.withMutations(map => {
      map.set('a', 1).set('b', 2).set('c', 3)
    })
    assert.equal(map1.size, 0)
    assert.equal(map2.size, 3)run it
    ```

    Note: Not all methods can be used on a mutable collection or within [`withMutations`](index#withMutations())! Read the documentation for each method to see if it is safe to use in [`withMutations`](index#withMutations()).
- name: merge()
  id: merge()/index
  summary: Returns a copy of the collection with the remaining collections merged in
  description: "# merge()\n\nReturns a copy of the collection with the remaining collections merged in.\n\n``` ts\nmerge<C>(collection: C,...collections: Array<Iterable<unknown> | Iterable<[unknown, unknown]> | {[key: string]: unknown}>): C\n```\n\n#### Discussion\n\nA functional alternative to `collection.merge()` which will also work with plain Objects and Arrays.\n\n``` ts\nconst { merge } = require('immutable')\nconst original = { x: 123, y: 456 }\nmerge(original, { y: 789, z: 'abc' }) // { x: 123, y: 789, z: 'abc' }\nconsole.log(original) // { x: 123, y: 456 }run it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/merge()/](https://immutable-js.com/docs/v4.2.1/merge()/)"
- name: mergeDeep()
  id: mergedeep()/index
  summary: Like merge(), but when two compatible collections are encountered with the same key, it merges them as well, recursing deeply through the nested data
  description: "# mergeDeep()\n\nLike [`merge()`](../merge()/index), but when two compatible collections are encountered with the same key, it merges them as well, recursing deeply through the nested data. Two collections are considered to be compatible (and thus will be merged together) if they both fall into one of three categories: keyed (e.g., [`Map`](../map/index)s, [`Record`](../record/index)s, and objects), indexed (e.g., [`List`](../list/index)s and arrays), or set-like (e.g., [`Set`](../set/index)s). If they fall into separate categories, [`mergeDeep`](index) will replace the existing collection with the collection being merged in. This behavior can be customized by using [`mergeDeepWith()`](../mergedeepwith()/index).\n\n``` ts\nmergeDeep<C>(collection: C,...collections: Array<Iterable<unknown> | Iterable<[unknown, unknown]> | {[key: string]: unknown}>): C\n```\n\n#### Discussion\n\nNote: Indexed and set-like collections are merged using `concat()`/`union()` and therefore do not recurse.\n\nA functional alternative to `collection.mergeDeep()` which will also work with plain Objects and Arrays.\n\n``` ts\nconst { mergeDeep } = require('immutable')\nconst original = { x: { y: 123 }}\nmergeDeep(original, { x: { z: 456 }}) // { x: { y: 123, z: 456 }}\nconsole.log(original) // { x: { y: 123 }}run it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/mergeDeep()/](https://immutable-js.com/docs/v4.2.1/mergeDeep()/)"
- name: mergeDeepWith()
  id: mergedeepwith()/index
  summary: Like mergeDeep(), but when two non-collections or incompatible collections are encountered at the same key, it uses the merger function to determine the resulting value
  description: "# mergeDeepWith()\n\nLike [`mergeDeep()`](../mergedeep()/index), but when two non-collections or incompatible collections are encountered at the same key, it uses the `merger` function to determine the resulting value. Collections are considered incompatible if they fall into separate categories between keyed, indexed, and set-like.\n\n``` ts\nmergeDeepWith<C>(merger: (oldVal: unknown, newVal: unknown, key: unknown) => unknown,collection: C,...collections: Array<Iterable<unknown> | Iterable<[unknown, unknown]> | {[key: string]: unknown}>): C\n```\n\n#### Discussion\n\nA functional alternative to `collection.mergeDeepWith()` which will also work with plain Objects and Arrays.\n\n``` ts\nconst { mergeDeepWith } = require('immutable')\nconst original = { x: { y: 123 }}\nmergeDeepWith(\n  (oldVal, newVal) => oldVal + newVal,\n  original,\n  { x: { y: 456 }}\n) // { x: { y: 579 }}\nconsole.log(original) // { x: { y: 123 }}run it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/mergeDeepWith()/](https://immutable-js.com/docs/v4.2.1/mergeDeepWith()/)"
- name: mergeWith()
  id: mergewith()/index
  summary: Returns a copy of the collection with the remaining collections merged in, calling the merger function whenever an existing value is encountered
  description: "# mergeWith()\n\nReturns a copy of the collection with the remaining collections merged in, calling the `merger` function whenever an existing value is encountered.\n\n``` ts\nmergeWith<C>(merger: (oldVal: unknown, newVal: unknown, key: unknown) => unknown,collection: C,...collections: Array<Iterable<unknown> | Iterable<[unknown, unknown]> | {[key: string]: unknown}>): C\n```\n\n#### Discussion\n\nA functional alternative to `collection.mergeWith()` which will also work with plain Objects and Arrays.\n\n``` ts\nconst { mergeWith } = require('immutable')\nconst original = { x: 123, y: 456 }\nmergeWith(\n  (oldVal, newVal) => oldVal + newVal,\n  original,\n  { y: 789, z: 'abc' }\n) // { x: 123, y: 1245, z: 'abc' }\nconsole.log(original) // { x: 123, y: 456 }run it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/mergeWith()/](https://immutable-js.com/docs/v4.2.1/mergeWith()/)"
- name: OrderedMap
  id: orderedmap/index
  summary: A type of Map that has the additional guarantee that the iteration order of entries will be the order in which they were set()
  description: "# OrderedMap\n\nA type of Map that has the additional guarantee that the iteration order of entries will be the order in which they were set().\n\n``` ts\ntype OrderedMap<K, V> extends Map<K, V>\n```\n\n#### Discussion\n\nThe iteration behavior of OrderedMap is the same as native ES6 Map and JavaScript Object.\n\nNote that [`OrderedMap`](index) are more expensive than non-ordered [`Map`](../map/index) and may consume more memory. [`OrderedMap#set`](index#set()) is amortized O(log32 N), but not stable.\n\n### Construction\n\n#### [OrderedMap()](index#OrderedMap())\n\n``` ts\nOrderedMap<K, V>(collection?: Iterable<[K, V]>): OrderedMap<K, V>\nOrderedMap<V>(obj: {[key: string]: V}): OrderedMap<string, V>\n```\n\n### Static methods\n\n#### [OrderedMap.isOrderedMap()](index#isOrderedMap())\n\n``` ts\nOrderedMap.isOrderedMap(maybeOrderedMap: unknown): boolean\n```\n\n### Members\n\n#### [size](index#size)\n\nThe number of entries in this OrderedMap.\n\n``` ts\nsize: number\n```\n\n#### Overrides\n\n[`Map#size`](../map/index#size)\n\n### Persistent changes\n\n#### [set()](index#set())\n\nReturns a new OrderedMap also containing the new key, value pair. If an equivalent key already exists in this OrderedMap, it will be replaced while maintaining the existing order.\n\n``` ts\nset(key: K, value: V): this\n```\n\n#### Overrides\n\n[`Map#set()`](../map/index#set())\n\n#### Discussion\n\n``` ts\nconst { OrderedMap } = require('immutable')\nconst originalMap = OrderedMap({a:1, b:1, c:1})\nconst updatedMap = originalMap.set('b', 2)\n\noriginalMap\n// OrderedMap {a: 1, b: 1, c: 1}\nupdatedMap\n// OrderedMap {a: 1, b: 2, c: 1}run it\n```\n\nNote: [`set`](index#set()) can be used in [`withMutations`](index#withMutations()).\n\n#### [merge()](index#merge())\n\n``` ts\nmerge<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): OrderedMap<K | KC, V | VC>\nmerge<C>(...collections: Array<{[key: string]: C}>): OrderedMap<K | string, V | C>\n```\n\n#### Overrides\n\n[`Map#merge()`](../map/index#merge())\n\n#### [delete()](index#delete())\n\nReturns a new Map which excludes this `key`.\n\n``` ts\ndelete(key: K): this\n```\n\n#### Inherited from\n\n[`Map#delete()`](../map/index#delete())\n\n#### alias\n\n`remove()`\n\n#### Discussion\n\nNote: [`delete`](../map/index#delete()) cannot be safely used in IE8, but is provided to mirror the ES6 collection API.\n\n``` ts\nconst { Map } = require('immutable')\nconst originalMap = Map({\n  key: 'value',\n  otherKey: 'other value'\n})\n// Map { \"key\": \"value\", \"otherKey\": \"other value\" }\noriginalMap.delete('otherKey')\n// Map { \"key\": \"value\" }run it\n```\n\nNote: [`delete`](../map/index#delete()) can be used in [`withMutations`](../map/index#withMutations()).\n\n#### [deleteAll()](index#deleteAll())\n\nReturns a new Map which excludes the provided `keys`.\n\n``` ts\ndeleteAll(keys: Iterable<K>): this\n```\n\n#### Inherited from\n\n[`Map#deleteAll()`](../map/index#deleteAll())\n\n#### alias\n\n`removeAll()`\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst names = Map({ a: \"Aaron\", b: \"Barry\", c: \"Connor\" })\nnames.deleteAll([ 'a', 'c' ])\n// Map { \"b\": \"Barry\" }run it\n```\n\nNote: [`deleteAll`](../map/index#deleteAll()) can be used in [`withMutations`](../map/index#withMutations()).\n\n#### [clear()](index#clear())\n\nReturns a new Map containing no keys or values.\n\n``` ts\nclear(): this\n```\n\n#### Inherited from\n\n[`Map#clear()`](../map/index#clear())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ key: 'value' }).clear()\n// Map {}run it\n```\n\nNote: [`clear`](../map/index#clear()) can be used in [`withMutations`](../map/index#withMutations()).\n\n#### [update()](index#update())\n\n``` ts\nupdate(key: K, notSetValue: V, updater: (value: V) => V): this\nupdate(key: K, updater: (value: V | undefined) => V): this\nupdate<R>(updater: (value: this) => R): R\n```\n\n#### Inherited from\n\n[`Map#update()`](../map/index#update())\n\n#### [mergeWith()](index#mergeWith())\n\nLike [`merge()`](../map/index#merge()), [`mergeWith()`](../map/index#mergeWith()) returns a new Map resulting from merging the provided Collections (or JS objects) into this Map, but uses the `merger` function for dealing with conflicts.\n\n``` ts\nmergeWith(merger: (oldVal: V, newVal: V, key: K) => V,...collections: Array<Iterable<[K, V]> | {[key: string]: V}>): this\n```\n\n#### Inherited from\n\n[`Map#mergeWith()`](../map/index#mergeWith())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst one = Map({ a: 10, b: 20, c: 30 })\nconst two = Map({ b: 40, a: 50, d: 60 })\none.mergeWith((oldVal, newVal) => oldVal / newVal, two)\n// { \"a\": 0.2, \"b\": 0.5, \"c\": 30, \"d\": 60 }\ntwo.mergeWith((oldVal, newVal) => oldVal / newVal, one)\n// { \"b\": 2, \"a\": 5, \"d\": 60, \"c\": 30 }run it\n```\n\nNote: [`mergeWith`](../map/index#mergeWith()) can be used in [`withMutations`](../map/index#withMutations()).\n\n#### [mergeDeep()](index#mergeDeep())\n\nLike [`merge()`](../map/index#merge()), but when two compatible collections are encountered with the same key, it merges them as well, recursing deeply through the nested data. Two collections are considered to be compatible (and thus will be merged together) if they both fall into one of three categories: keyed (e.g., [`Map`](../map/index)s, [`Record`](../record/index)s, and objects), indexed (e.g., [`List`](../list/index)s and arrays), or set-like (e.g., [`Set`](../set/index)s). If they fall into separate categories, [`mergeDeep`](../map/index#mergeDeep()) will replace the existing collection with the collection being merged in. This behavior can be customized by using [`mergeDeepWith()`](../map/index#mergeDeepWith()).\n\n``` ts\nmergeDeep(...collections: Array<Iterable<[K, V]> | {[key: string]: V}>): this\n```\n\n#### Inherited from\n\n[`Map#mergeDeep()`](../map/index#mergeDeep())\n\n#### Discussion\n\nNote: Indexed and set-like collections are merged using [`concat()`](../map/index#concat())/`union()` and therefore do not recurse.\n\n``` ts\nconst { Map } = require('immutable')\nconst one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })\nconst two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })\none.mergeDeep(two)\n// Map {\n//   \"a\": Map { \"x\": 2, \"y\": 10 },\n//   \"b\": Map { \"x\": 20, \"y\": 5 },\n//   \"c\": Map { \"z\": 3 }\n// }run it\n```\n\nNote: [`mergeDeep`](../map/index#mergeDeep()) can be used in [`withMutations`](../map/index#withMutations()).\n\n#### [mergeDeepWith()](index#mergeDeepWith())\n\nLike [`mergeDeep()`](../map/index#mergeDeep()), but when two non-collections or incompatible collections are encountered at the same key, it uses the `merger` function to determine the resulting value. Collections are considered incompatible if they fall into separate categories between keyed, indexed, and set-like.\n\n``` ts\nmergeDeepWith(merger: (oldVal: unknown, newVal: unknown, key: unknown) => unknown,...collections: Array<Iterable<[K, V]> | {[key: string]: V}>): this\n```\n\n#### Inherited from\n\n[`Map#mergeDeepWith()`](../map/index#mergeDeepWith())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })\nconst two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })\none.mergeDeepWith((oldVal, newVal) => oldVal / newVal, two)\n// Map {\n//   \"a\": Map { \"x\": 5, \"y\": 10 },\n//   \"b\": Map { \"x\": 20, \"y\": 10 },\n//   \"c\": Map { \"z\": 3 }\n// }run it\n```\n\nNote: [`mergeDeepWith`](../map/index#mergeDeepWith()) can be used in [`withMutations`](../map/index#withMutations()).\n\n### Sequence algorithms\n\n#### [map()](index#map())\n\nReturns a new OrderedMap with values passed through a `mapper` function.\n\n``` ts\nmap<M>(mapper: (value: V, key: K, iter: this) => M,context?: unknown): OrderedMap<K, M>\n```\n\n#### Overrides\n\n[`Map#map()`](../map/index#map())\n\n#### Example\n\n``` ts\nOrderedMap({ a: 1, b: 2 }).map(x => 10 * x)\n// OrderedMap { \"a\": 10, \"b\": 20 }\n```\n\nNote: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.\n\n#### [mapKeys()](index#mapKeys())\n\n``` ts\nmapKeys<M>(mapper: (key: K, value: V, iter: this) => M,context?: unknown): OrderedMap<M, V>\n```\n\n#### Overrides\n\n[`Map#mapKeys()`](../map/index#mapKeys())\n\n#### see\n\nCollection.Keyed.mapKeys\n\n#### [mapEntries()](index#mapEntries())\n\n``` ts\nmapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM] | undefined,context?: unknown): OrderedMap<KM, VM>\n```\n\n#### Overrides\n\n[`Map#mapEntries()`](../map/index#mapEntries())\n\n#### see\n\nCollection.Keyed.mapEntries\n\n#### [flatMap()](index#flatMap())\n\nFlat-maps the OrderedMap, returning a new OrderedMap.\n\n``` ts\nflatMap<KM, VM>(mapper: (value: V, key: K, iter: this) => Iterable<[KM, VM]>,context?: unknown): OrderedMap<KM, VM>\n```\n\n#### Overrides\n\n[`Map#flatMap()`](../map/index#flatMap())\n\n#### Discussion\n\nSimilar to `data.map(...).flatten(true)`.\n\n#### [filter()](index#filter())\n\n``` ts\nfilter<F>(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): OrderedMap<K, F>\nfilter(predicate: (value: V, key: K, iter: this) => unknown,context?: unknown): this\n```\n\n#### Overrides\n\n[`Map#filter()`](../map/index#filter())\n\n#### [partition()](index#partition())\n\n``` ts\npartition<F, C>(predicate: (this: C, value: V, key: K, iter: this) => boolean,context?: C): [OrderedMap<K, V>, OrderedMap<K, F>]\npartition<C>(predicate: (this: C, value: V, key: K, iter: this) => unknown,context?: C): [this, this]\n```\n\n#### Overrides\n\n[`Map#partition()`](../map/index#partition())\n\n#### [flip()](index#flip())\n\n``` ts\nflip(): OrderedMap<V, K>\n```\n\n#### Overrides\n\n[`Map#flip()`](../map/index#flip())\n\n#### see\n\nCollection.Keyed.flip\n\n#### [filterNot()](index#filterNot())\n\nReturns a new Collection of the same type with only the entries for which the `predicate` function returns false.\n\n``` ts\nfilterNot(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#filterNot()`](../collection/index#filterNot())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }run it\n```\n\nNote: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.\n\n#### [reverse()](index#reverse())\n\nReturns a new Collection of the same type in reverse order.\n\n``` ts\nreverse(): this\n```\n\n#### Inherited from\n\n[`Collection#reverse()`](../collection/index#reverse())\n\n#### [sort()](index#sort())\n\nReturns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.\n\n``` ts\nsort(comparator?: (valueA: V, valueB: V) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sort()`](../collection/index#sort())\n\n#### Discussion\n\nIf a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n- Returns `0` if the elements should not be swapped.\n- Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n- Returns `1` (or any positive number) if `valueA` comes after `valueB`\n- Is pure, i.e. it must always return the same value for the same pair of values.\n\nWhen sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n``` ts\nconst { Map } = require('immutable')\nMap({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// OrderedMap { \"a\": 1, \"b\": 2, \"c\": 3 }run it\n```\n\nNote: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [sortBy()](index#sortBy())\n\nLike [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:\n\n``` ts\nsortBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sortBy()`](../collection/index#sortBy())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst beattles = Map({\n  John: { name: \"Lennon\" },\n  Paul: { name: \"McCartney\" },\n  George: { name: \"Harrison\" },\n  Ringo: { name: \"Starr\" },\n});\nbeattles.sortBy(member => member.name);run it\n```\n\nNote: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [groupBy()](index#groupBy())\n\nReturns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.\n\n``` ts\ngroupBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<K, V>>\n```\n\n#### Inherited from\n\n[`Collection#groupBy()`](../collection/index#groupBy())\n\n#### Discussion\n\nNote: This is always an eager operation.\n\n``` ts\nconst { List, Map } = require('immutable')\nconst listOfMaps = List([\n  Map({ v: 0 }),\n  Map({ v: 1 }),\n  Map({ v: 1 }),\n  Map({ v: 0 }),\n  Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ Map{ \"v\": 0 }, Map { \"v\": 0 } ],\n//   1: List [ Map{ \"v\": 1 }, Map { \"v\": 1 } ],\n//   2: List [ Map{ \"v\": 2 } ],\n// }run it\n```\n\n### Deep persistent changes\n\n#### [setIn()](index#setIn())\n\nReturns a new Map having set `value` at this `keyPath`. If any keys in `keyPath` do not exist, a new immutable Map will be created at that key.\n\n``` ts\nsetIn(keyPath: Iterable<unknown>, value: unknown): this\n```\n\n#### Inherited from\n\n[`Map#setIn()`](../map/index#setIn())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst originalMap = Map({\n  subObject: Map({\n    subKey: 'subvalue',\n    subSubObject: Map({\n      subSubKey: 'subSubValue'\n    })\n  })\n})\n```\n\nconst newMap = originalMap.setIn(\\['subObject', 'subKey'\\], 'ha ha!') // Map { // \"subObject\": Map { // \"subKey\": \"ha ha!\", // \"subSubObject\": Map { \"subSubKey\": \"subSubValue\" } // } // } const newerMap = originalMap.setIn( \\['subObject', 'subSubObject', 'subSubKey'\\], 'ha ha ha!' ) // Map { // \"subObject\": Map { // \"subKey\": \"subvalue\", // \"subSubObject\": Map { \"subSubKey\": \"ha ha ha!\" } // } // }run it\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and setIn() can update those values as well, treating them immutably by creating new copies of those values with the changes applied.\n\n``` ts\nconst { Map } = require('immutable')\nconst originalMap = Map({\n  subObject: {\n    subKey: 'subvalue',\n    subSubObject: {\n      subSubKey: 'subSubValue'\n    }\n  }\n})\n```\n\noriginalMap.setIn(\\['subObject', 'subKey'\\], 'ha ha!') // Map { // \"subObject\": { // subKey: \"ha ha!\", // subSubObject: { subSubKey: \"subSubValue\" } // } // }run it\n\nIf any key in the path exists but cannot be updated (such as a primitive like number or a custom Object like Date), an error will be thrown.\n\nNote: [`setIn`](../map/index#setIn()) can be used in [`withMutations`](../map/index#withMutations()).\n\n#### [deleteIn()](index#deleteIn())\n\nReturns a new Map having removed the value at this `keyPath`. If any keys in `keyPath` do not exist, no change will occur.\n\n``` ts\ndeleteIn(keyPath: Iterable<unknown>): this\n```\n\n#### Inherited from\n\n[`Map#deleteIn()`](../map/index#deleteIn())\n\n#### alias\n\n`removeIn()`\n\n#### Discussion\n\nNote: [`deleteIn`](../map/index#deleteIn()) can be used in [`withMutations`](../map/index#withMutations()).\n\n#### [updateIn()](index#updateIn())\n\n``` ts\nupdateIn(keyPath: Iterable<unknown>,notSetValue: unknown,updater: (value: unknown) => unknown): this\nupdateIn(keyPath: Iterable<unknown>, updater: (value: unknown) => unknown): this\n```\n\n#### Inherited from\n\n[`Map#updateIn()`](../map/index#updateIn())\n\n#### [mergeIn()](index#mergeIn())\n\nA combination of [`updateIn`](../map/index#updateIn()) and [`merge`](../map/index#merge()), returning a new Map, but performing the merge at a point arrived at by following the keyPath. In other words, these two lines are equivalent:\n\n``` ts\nmergeIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this\n```\n\n#### Inherited from\n\n[`Map#mergeIn()`](../map/index#mergeIn())\n\n#### Discussion\n\n``` ts\nmap.updateIn(['a', 'b', 'c'], abc => abc.merge(y))\nmap.mergeIn(['a', 'b', 'c'], y)\n```\n\nNote: [`mergeIn`](../map/index#mergeIn()) can be used in [`withMutations`](../map/index#withMutations()).\n\n#### [mergeDeepIn()](index#mergeDeepIn())\n\nA combination of [`updateIn`](../map/index#updateIn()) and [`mergeDeep`](../map/index#mergeDeep()), returning a new Map, but performing the deep merge at a point arrived at by following the keyPath. In other words, these two lines are equivalent:\n\n``` ts\nmergeDeepIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this\n```\n\n#### Inherited from\n\n[`Map#mergeDeepIn()`](../map/index#mergeDeepIn())\n\n#### Discussion\n\n``` ts\nmap.updateIn(['a', 'b', 'c'], abc => abc.mergeDeep(y))\nmap.mergeDeepIn(['a', 'b', 'c'], y)\n```\n\nNote: [`mergeDeepIn`](../map/index#mergeDeepIn()) can be used in [`withMutations`](../map/index#withMutations()).\n\n### Transient changes\n\n#### [withMutations()](index#withMutations())\n\nEvery time you call one of the above functions, a new immutable Map is created. If a pure function calls a number of these to produce a final return value, then a penalty on performance and memory has been paid by creating all of the intermediate immutable Maps.\n\n``` ts\nwithMutations(mutator: (mutable: this) => unknown): this\n```\n\n#### Inherited from\n\n[`Map#withMutations()`](../map/index#withMutations())\n\n#### Discussion\n\nIf you need to apply a series of mutations to produce a new immutable Map, [`withMutations()`](../map/index#withMutations()) creates a temporary mutable copy of the Map which can apply mutations in a highly performant manner. In fact, this is exactly how complex mutations like [`merge`](../map/index#merge()) are done.\n\nAs an example, this results in the creation of 2, not 4, new Maps:\n\n``` ts\nconst { Map } = require('immutable')\nconst map1 = Map()\nconst map2 = map1.withMutations(map => {\n  map.set('a', 1).set('b', 2).set('c', 3)\n})\nassert.equal(map1.size, 0)\nassert.equal(map2.size, 3)run it\n```\n\nNote: Not all methods can be used on a mutable collection or within [`withMutations`](../map/index#withMutations())! Read the documentation for each method to see if it is safe to use in [`withMutations`](../map/index#withMutations()).\n\n#### [asMutable()](index#asMutable())\n\nAnother way to avoid creation of intermediate Immutable maps is to create a mutable copy of this collection. Mutable copies *always* return `this`, and thus shouldn't be used for equality. Your function should never return a mutable copy of a collection, only use it internally to create a new collection.\n\n``` ts\nasMutable(): this\n```\n\n#### Inherited from\n\n[`Map#asMutable()`](../map/index#asMutable())\n\n#### see\n\n[`Map#asImmutable`](../map/index#asImmutable())\n\n#### Discussion\n\nIf possible, use [`withMutations`](../map/index#withMutations()) to work with temporary mutable copies as it provides an easier to use API and considers many common optimizations.\n\nNote: if the collection is already mutable, [`asMutable`](../map/index#asMutable()) returns itself.\n\nNote: Not all methods can be used on a mutable collection or within [`withMutations`](../map/index#withMutations())! Read the documentation for each method to see if it is safe to use in [`withMutations`](../map/index#withMutations()).\n\n#### [wasAltered()](index#wasAltered())\n\nReturns true if this is a mutable copy (see [`asMutable()`](../map/index#asMutable())) and mutative alterations have been applied.\n\n``` ts\nwasAltered(): boolean\n```\n\n#### Inherited from\n\n[`Map#wasAltered()`](../map/index#wasAltered())\n\n#### see\n\n[`Map#asMutable`](../map/index#asMutable())\n\n#### [asImmutable()](index#asImmutable())\n\nThe yin to [`asMutable`](../map/index#asMutable())'s yang. Because it applies to mutable collections, this operation is *mutable* and may return itself (though may not return itself, i.e. if the result is an empty collection). Once performed, the original mutable copy must no longer be mutated since it may be the immutable result.\n\n``` ts\nasImmutable(): this\n```\n\n#### Inherited from\n\n[`Map#asImmutable()`](../map/index#asImmutable())\n\n#### see\n\n[`Map#asMutable`](../map/index#asMutable())\n\n#### Discussion\n\nIf possible, use [`withMutations`](../map/index#withMutations()) to work with temporary mutable copies as it provides an easier to use API and considers many common optimizations.\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Keyed collection to equivalent native JavaScript Object.\n\n``` ts\ntoJS(): {[key: string]: DeepCopy<V>}\n```\n\n#### Inherited from\n\n[`Collection.Keyed#toJS()`](../collection.keyed/index#toJS())\n\n#### Discussion\n\nConverts keys to Strings.\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Keyed collection to equivalent native JavaScript Object.\n\n``` ts\ntoJSON(): {[key: string]: V}\n```\n\n#### Inherited from\n\n[`Collection.Keyed#toJSON()`](../collection.keyed/index#toJSON())\n\n#### Discussion\n\nConverts keys to Strings.\n\n#### [toArray()](index#toArray())\n\nShallowly converts this collection to an Array.\n\n``` ts\ntoArray(): Array<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection.Keyed#toArray()`](../collection.keyed/index#toArray())\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Collection to an Object.\n\n``` ts\ntoObject(): {[key: string]: V}\n```\n\n#### Inherited from\n\n[`Collection#toObject()`](../collection/index#toObject())\n\n#### Discussion\n\nConverts keys to Strings.\n\n### Conversion to Seq\n\n#### [toSeq()](index#toSeq())\n\nReturns Seq.Keyed.\n\n``` ts\ntoSeq(): Seq.Keyed<K, V>\n```\n\n#### Inherited from\n\n[`Collection.Keyed#toSeq()`](../collection.keyed/index#toSeq())\n\n#### [toKeyedSeq()](index#toKeyedSeq())\n\nReturns a Seq.Keyed from this Collection where indices are treated as keys.\n\n``` ts\ntoKeyedSeq(): Seq.Keyed<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())\n\n#### Discussion\n\nThis is useful if you want to operate on an Collection.Indexed and preserve the \\[index, value\\] pairs.\n\nThe returned Seq will have identical iteration order as this Collection.\n\n``` ts\nconst { Seq } = require('immutable')\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\n// Seq [ \"A\", \"B\", \"C\" ]\nindexedSeq.filter(v => v === 'B')\n// Seq [ \"B\" ]\nconst keyedSeq = indexedSeq.toKeyedSeq()\n// Seq { 0: \"A\", 1: \"B\", 2: \"C\" }\nkeyedSeq.filter(v => v === 'B')\n// Seq { 1: \"B\" }run it\n```\n\n#### [toIndexedSeq()](index#toIndexedSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\ntoIndexedSeq(): Seq.Indexed<V>\n```\n\n#### Inherited from\n\n[`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())\n\n#### [toSetSeq()](index#toSetSeq())\n\nReturns a Seq.Set of the values of this Collection, discarding keys.\n\n``` ts\ntoSetSeq(): Seq.Set<V>\n```\n\n#### Inherited from\n\n[`Collection#toSetSeq()`](../collection/index#toSetSeq())\n\n### Sequence functions\n\n#### [concat()](index#concat())\n\n``` ts\nconcat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Collection.Keyed<K | KC, V | VC>\nconcat<C>(...collections: Array<{[key: string]: C}>): Collection.Keyed<K | string, V | C>\n```\n\n#### Inherited from\n\n[`Collection.Keyed#concat()`](../collection.keyed/index#concat())\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection.Keyed#[Symbol.iterator]()`](../collection.keyed/index#%5BSymbol.iterator%5D())\n\n### Value equality\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#equals()`](../collection/index#equals())\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Inherited from\n\n[`Collection#hashCode()`](../collection/index#hashCode())\n\n#### Discussion\n\nThe [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nIf two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.\n\n### Reading values\n\n#### [get()](index#get())\n\n``` ts\nget<NSV>(key: K, notSetValue: NSV): V | NSV\nget(key: K): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#get()`](../collection/index#get())\n\n#### [has()](index#has())\n\nTrue if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nhas(key: K): boolean\n```\n\n#### Inherited from\n\n[`Collection#has()`](../collection/index#has())\n\n#### [includes()](index#includes())\n\nTrue if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nincludes(value: V): boolean\n```\n\n#### Inherited from\n\n[`Collection#includes()`](../collection/index#includes())\n\n#### alias\n\n`contains()`\n\n#### [first()](index#first())\n\nIn case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nfirst<NSV>(notSetValue?: NSV): V | NSV\n```\n\n#### Inherited from\n\n[`Collection#first()`](../collection/index#first())\n\n#### [last()](index#last())\n\nIn case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nlast<NSV>(notSetValue?: NSV): V | NSV\n```\n\n#### Inherited from\n\n[`Collection#last()`](../collection/index#last())\n\n### Reading deep values\n\n#### [getIn()](index#getIn())\n\nReturns the value found by following a path of keys or indices through nested Collections.\n\n``` ts\ngetIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown\n```\n\n#### Inherited from\n\n[`Collection#getIn()`](../collection/index#getIn())\n\n#### Discussion\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: [ { y: 123 } ] });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\n#### [hasIn()](index#hasIn())\n\nTrue if the result of following a path of keys or indices through nested Collections results in a set value.\n\n``` ts\nhasIn(searchKeyPath: Iterable<unknown>): boolean\n```\n\n#### Inherited from\n\n[`Collection#hasIn()`](../collection/index#hasIn())\n\n### Conversion to Collections\n\n#### [toMap()](index#toMap())\n\nConverts this Collection to a Map, Throws if keys are not hashable.\n\n``` ts\ntoMap(): Map<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toMap()`](../collection/index#toMap())\n\n#### Discussion\n\nNote: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toOrderedMap()](index#toOrderedMap())\n\nConverts this Collection to a Map, maintaining the order of iteration.\n\n``` ts\ntoOrderedMap(): OrderedMap<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedMap()`](../collection/index#toOrderedMap())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toSet()](index#toSet())\n\nConverts this Collection to a Set, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoSet(): Set<V>\n```\n\n#### Inherited from\n\n[`Collection#toSet()`](../collection/index#toSet())\n\n#### Discussion\n\nNote: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.\n\n#### [toOrderedSet()](index#toOrderedSet())\n\nConverts this Collection to a Set, maintaining the order of iteration and discarding keys.\n\n``` ts\ntoOrderedSet(): OrderedSet<V>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedSet()`](../collection/index#toOrderedSet())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toList()](index#toList())\n\nConverts this Collection to a List, discarding keys.\n\n``` ts\ntoList(): List<V>\n```\n\n#### Inherited from\n\n[`Collection#toList()`](../collection/index#toList())\n\n#### Discussion\n\nThis is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.\n\n``` ts\nconst { Map, List } = require('immutable')\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\nList(myMap) // List [ [ \"a\", \"Apple\" ], [ \"b\", \"Banana\" ] ]\nmyMap.toList() // List [ \"Apple\", \"Banana\" ]run it\n```\n\n#### [toStack()](index#toStack())\n\nConverts this Collection to a Stack, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoStack(): Stack<V>\n```\n\n#### Inherited from\n\n[`Collection#toStack()`](../collection/index#toStack())\n\n#### Discussion\n\nNote: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.\n\n### Iterators\n\n#### [keys()](index#keys())\n\nAn iterator of this [`Collection`](../collection/index)'s keys.\n\n``` ts\nkeys(): IterableIterator<K>\n```\n\n#### Inherited from\n\n[`Collection#keys()`](../collection/index#keys())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.\n\n#### [values()](index#values())\n\nAn iterator of this [`Collection`](../collection/index)'s values.\n\n``` ts\nvalues(): IterableIterator<V>\n```\n\n#### Inherited from\n\n[`Collection#values()`](../collection/index#values())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.\n\n#### [entries()](index#entries())\n\nAn iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.\n\n``` ts\nentries(): IterableIterator<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection#entries()`](../collection/index#entries())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.\n\n### Collections (Seq)\n\n#### [keySeq()](index#keySeq())\n\nReturns a new Seq.Indexed of the keys of this Collection, discarding values.\n\n``` ts\nkeySeq(): Seq.Indexed<K>\n```\n\n#### Inherited from\n\n[`Collection#keySeq()`](../collection/index#keySeq())\n\n#### [valueSeq()](index#valueSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\nvalueSeq(): Seq.Indexed<V>\n```\n\n#### Inherited from\n\n[`Collection#valueSeq()`](../collection/index#valueSeq())\n\n#### [entrySeq()](index#entrySeq())\n\nReturns a new Seq.Indexed of \\[key, value\\] tuples.\n\n``` ts\nentrySeq(): Seq.Indexed<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection#entrySeq()`](../collection/index#entrySeq())\n\n### Side effects\n\n#### [forEach()](index#forEach())\n\nThe `sideEffect` is executed for every entry in the Collection.\n\n``` ts\nforEach(sideEffect: (value: V, key: K, iter: this) => unknown,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#forEach()`](../collection/index#forEach())\n\n#### Discussion\n\nUnlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).\n\n### Creating subsets\n\n#### [slice()](index#slice())\n\nReturns a new Collection of the same type representing a portion of this Collection from start up to but not including end.\n\n``` ts\nslice(begin?: number, end?: number): this\n```\n\n#### Inherited from\n\n[`Collection#slice()`](../collection/index#slice())\n\n#### Discussion\n\nIf begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.\n\nIf the requested slice is equivalent to the current Collection, then it will return itself.\n\n#### [rest()](index#rest())\n\nReturns a new Collection of the same type containing all entries except the first.\n\n``` ts\nrest(): this\n```\n\n#### Inherited from\n\n[`Collection#rest()`](../collection/index#rest())\n\n#### [butLast()](index#butLast())\n\nReturns a new Collection of the same type containing all entries except the last.\n\n``` ts\nbutLast(): this\n```\n\n#### Inherited from\n\n[`Collection#butLast()`](../collection/index#butLast())\n\n#### [skip()](index#skip())\n\nReturns a new Collection of the same type which excludes the first `amount` entries from this Collection.\n\n``` ts\nskip(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skip()`](../collection/index#skip())\n\n#### [skipLast()](index#skipLast())\n\nReturns a new Collection of the same type which excludes the last `amount` entries from this Collection.\n\n``` ts\nskipLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skipLast()`](../collection/index#skipLast())\n\n#### [skipWhile()](index#skipWhile())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns false.\n\n``` ts\nskipWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipWhile()`](../collection/index#skipWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipWhile(x => x.match(/g/))\n// List [ \"cat\", \"hat\", \"god\" ]run it\n```\n\n#### [skipUntil()](index#skipUntil())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns true.\n\n``` ts\nskipUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipUntil()`](../collection/index#skipUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipUntil(x => x.match(/hat/))\n// List [ \"hat\", \"god\" ]run it\n```\n\n#### [take()](index#take())\n\nReturns a new Collection of the same type which includes the first `amount` entries from this Collection.\n\n``` ts\ntake(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#take()`](../collection/index#take())\n\n#### [takeLast()](index#takeLast())\n\nReturns a new Collection of the same type which includes the last `amount` entries from this Collection.\n\n``` ts\ntakeLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#takeLast()`](../collection/index#takeLast())\n\n#### [takeWhile()](index#takeWhile())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.\n\n``` ts\ntakeWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeWhile()`](../collection/index#takeWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeWhile(x => x.match(/o/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n#### [takeUntil()](index#takeUntil())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.\n\n``` ts\ntakeUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeUntil()`](../collection/index#takeUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeUntil(x => x.match(/at/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n### Combination\n\n#### [flatten()](index#flatten())\n\n``` ts\nflatten(depth?: number): Collection<unknown, unknown>\nflatten(shallow?: boolean): Collection<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection#flatten()`](../collection/index#flatten())\n\n### Reducing a value\n\n#### [reduce()](index#reduce())\n\n``` ts\nreduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R\nreduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduce()`](../collection/index#reduce())\n\n#### [reduceRight()](index#reduceRight())\n\n``` ts\nreduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R\nreduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduceRight()`](../collection/index#reduceRight())\n\n#### [every()](index#every())\n\nTrue if `predicate` returns true for all entries in the Collection.\n\n``` ts\nevery(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#every()`](../collection/index#every())\n\n#### [some()](index#some())\n\nTrue if `predicate` returns true for any entry in the Collection.\n\n``` ts\nsome(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#some()`](../collection/index#some())\n\n#### [join()](index#join())\n\nJoins values together as a string, inserting a separator between each. The default separator is `\",\"`.\n\n``` ts\njoin(separator?: string): string\n```\n\n#### Inherited from\n\n[`Collection#join()`](../collection/index#join())\n\n#### [isEmpty()](index#isEmpty())\n\nReturns true if this Collection includes no values.\n\n``` ts\nisEmpty(): boolean\n```\n\n#### Inherited from\n\n[`Collection#isEmpty()`](../collection/index#isEmpty())\n\n#### Discussion\n\nFor some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.\n\n#### [count()](index#count())\n\n``` ts\ncount(): number\ncount(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#count()`](../collection/index#count())\n\n#### [countBy()](index#countBy())\n\nReturns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.\n\n``` ts\ncountBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Map<G, number>\n```\n\n#### Inherited from\n\n[`Collection#countBy()`](../collection/index#countBy())\n\n#### Discussion\n\nNote: This is not a lazy operation.\n\n### Search for value\n\n#### [find()](index#find())\n\nReturns the first value for which the `predicate` returns true.\n\n``` ts\nfind(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#find()`](../collection/index#find())\n\n#### [findLast()](index#findLast())\n\nReturns the last value for which the `predicate` returns true.\n\n``` ts\nfindLast(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLast()`](../collection/index#findLast())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findEntry()](index#findEntry())\n\nReturns the first \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findEntry()`](../collection/index#findEntry())\n\n#### [findLastEntry()](index#findLastEntry())\n\nReturns the last \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindLastEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastEntry()`](../collection/index#findLastEntry())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findKey()](index#findKey())\n\nReturns the key for which the `predicate` returns true.\n\n``` ts\nfindKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#findKey()`](../collection/index#findKey())\n\n#### [findLastKey()](index#findLastKey())\n\nReturns the last key for which the `predicate` returns true.\n\n``` ts\nfindLastKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastKey()`](../collection/index#findLastKey())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [keyOf()](index#keyOf())\n\nReturns the key associated with the search value, or undefined.\n\n``` ts\nkeyOf(searchValue: V): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#keyOf()`](../collection/index#keyOf())\n\n#### [lastKeyOf()](index#lastKeyOf())\n\nReturns the last key associated with the search value, or undefined.\n\n``` ts\nlastKeyOf(searchValue: V): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#lastKeyOf()`](../collection/index#lastKeyOf())\n\n#### [max()](index#max())\n\nReturns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmax(comparator?: (valueA: V, valueB: V) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#max()`](../collection/index#max())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [maxBy()](index#maxBy())\n\nLike [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nmaxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#maxBy()`](../collection/index#maxBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it\n```\n\n#### [min()](index#min())\n\nReturns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmin(comparator?: (valueA: V, valueB: V) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#min()`](../collection/index#min())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [minBy()](index#minBy())\n\nLike [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nminBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#minBy()`](../collection/index#minBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it\n```\n\n### Comparison\n\n#### [isSubset()](index#isSubset())\n\nTrue if `iter` includes every value in this Collection.\n\n``` ts\nisSubset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSubset()`](../collection/index#isSubset())\n\n#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/OrderedMap/](https://immutable-js.com/docs/v4.2.1/OrderedMap/)"
- name: OrderedMap.[Symbol.iterator]()
  id: orderedmap/index#[Symbol.iterator]()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [\[Symbol.iterator\]()](index#%5BSymbol.iterator%5D())

    ``` ts
    [Symbol.iterator](): IterableIterator<[K, V]>
    ```

    #### Inherited from

    [`Collection.Keyed#[Symbol.iterator]()`](../collection.keyed/index#%5BSymbol.iterator%5D())

    ### Value equality
- name: OrderedMap.asImmutable()
  id: orderedmap/index#asImmutable()
  summary: The yin to asMutable's yang
  belongs_to: OrderedMap
  description: |-
    #### [asImmutable()](index#asImmutable())

    The yin to [`asMutable`](../map/index#asMutable())'s yang. Because it applies to mutable collections, this operation is *mutable* and may return itself (though may not return itself, i.e. if the result is an empty collection). Once performed, the original mutable copy must no longer be mutated since it may be the immutable result.

    ``` ts
    asImmutable(): this
    ```

    #### Inherited from

    [`Map#asImmutable()`](../map/index#asImmutable())

    #### see

    [`Map#asMutable`](../map/index#asMutable())

    #### Discussion

    If possible, use [`withMutations`](../map/index#withMutations()) to work with temporary mutable copies as it provides an easier to use API and considers many common optimizations.

    ### Conversion to JavaScript types
- name: OrderedMap.asMutable()
  id: orderedmap/index#asMutable()
  summary: Another way to avoid creation of intermediate Immutable maps is to create a mutable copy of this collection
  belongs_to: OrderedMap
  description: |-
    #### [asMutable()](index#asMutable())

    Another way to avoid creation of intermediate Immutable maps is to create a mutable copy of this collection. Mutable copies *always* return `this`, and thus shouldn't be used for equality. Your function should never return a mutable copy of a collection, only use it internally to create a new collection.

    ``` ts
    asMutable(): this
    ```

    #### Inherited from

    [`Map#asMutable()`](../map/index#asMutable())

    #### see

    [`Map#asImmutable`](../map/index#asImmutable())

    #### Discussion

    If possible, use [`withMutations`](../map/index#withMutations()) to work with temporary mutable copies as it provides an easier to use API and considers many common optimizations.

    Note: if the collection is already mutable, [`asMutable`](../map/index#asMutable()) returns itself.

    Note: Not all methods can be used on a mutable collection or within [`withMutations`](../map/index#withMutations())! Read the documentation for each method to see if it is safe to use in [`withMutations`](../map/index#withMutations()).
- name: OrderedMap.butLast()
  id: orderedmap/index#butLast()
  summary: Returns a new Collection of the same type containing all entries except the last
  belongs_to: OrderedMap
  description: |-
    #### [butLast()](index#butLast())

    Returns a new Collection of the same type containing all entries except the last.

    ``` ts
    butLast(): this
    ```

    #### Inherited from

    [`Collection#butLast()`](../collection/index#butLast())
- name: OrderedMap.clear()
  id: orderedmap/index#clear()
  summary: Returns a new Map containing no keys or values
  belongs_to: OrderedMap
  description: |-
    #### [clear()](index#clear())

    Returns a new Map containing no keys or values.

    ``` ts
    clear(): this
    ```

    #### Inherited from

    [`Map#clear()`](../map/index#clear())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ key: 'value' }).clear()
    // Map {}run it
    ```

    Note: [`clear`](../map/index#clear()) can be used in [`withMutations`](../map/index#withMutations()).
- name: OrderedMap.concat()
  id: orderedmap/index#concat()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [concat()](index#concat())

    ``` ts
    concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Collection.Keyed<K | KC, V | VC>
    concat<C>(...collections: Array<{[key: string]: C}>): Collection.Keyed<K | string, V | C>
    ```

    #### Inherited from

    [`Collection.Keyed#concat()`](../collection.keyed/index#concat())
- name: OrderedMap.count()
  id: orderedmap/index#count()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [count()](index#count())

    ``` ts
    count(): number
    count(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#count()`](../collection/index#count())
- name: OrderedMap.countBy()
  id: orderedmap/index#countBy()
  summary: Returns a Seq.Keyed of counts, grouped by the return value of the grouper function
  belongs_to: OrderedMap
  description: |-
    #### [countBy()](index#countBy())

    Returns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.

    ``` ts
    countBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Map<G, number>
    ```

    #### Inherited from

    [`Collection#countBy()`](../collection/index#countBy())

    #### Discussion

    Note: This is not a lazy operation.

    ### Search for value
- name: OrderedMap.delete()
  id: orderedmap/index#delete()
  summary: Returns a new Map which excludes this key
  belongs_to: OrderedMap
  description: |-
    #### [delete()](index#delete())

    Returns a new Map which excludes this `key`.

    ``` ts
    delete(key: K): this
    ```

    #### Inherited from

    [`Map#delete()`](../map/index#delete())

    #### alias

    `remove()`

    #### Discussion

    Note: [`delete`](../map/index#delete()) cannot be safely used in IE8, but is provided to mirror the ES6 collection API.

    ``` ts
    const { Map } = require('immutable')
    const originalMap = Map({
      key: 'value',
      otherKey: 'other value'
    })
    // Map { "key": "value", "otherKey": "other value" }
    originalMap.delete('otherKey')
    // Map { "key": "value" }run it
    ```

    Note: [`delete`](../map/index#delete()) can be used in [`withMutations`](../map/index#withMutations()).
- name: OrderedMap.deleteAll()
  id: orderedmap/index#deleteAll()
  summary: Returns a new Map which excludes the provided keys
  belongs_to: OrderedMap
  description: |-
    #### [deleteAll()](index#deleteAll())

    Returns a new Map which excludes the provided `keys`.

    ``` ts
    deleteAll(keys: Iterable<K>): this
    ```

    #### Inherited from

    [`Map#deleteAll()`](../map/index#deleteAll())

    #### alias

    `removeAll()`

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const names = Map({ a: "Aaron", b: "Barry", c: "Connor" })
    names.deleteAll([ 'a', 'c' ])
    // Map { "b": "Barry" }run it
    ```

    Note: [`deleteAll`](../map/index#deleteAll()) can be used in [`withMutations`](../map/index#withMutations()).
- name: OrderedMap.deleteIn()
  id: orderedmap/index#deleteIn()
  summary: Returns a new Map having removed the value at this keyPath
  belongs_to: OrderedMap
  description: |-
    #### [deleteIn()](index#deleteIn())

    Returns a new Map having removed the value at this `keyPath`. If any keys in `keyPath` do not exist, no change will occur.

    ``` ts
    deleteIn(keyPath: Iterable<unknown>): this
    ```

    #### Inherited from

    [`Map#deleteIn()`](../map/index#deleteIn())

    #### alias

    `removeIn()`

    #### Discussion

    Note: [`deleteIn`](../map/index#deleteIn()) can be used in [`withMutations`](../map/index#withMutations()).
- name: OrderedMap.entries()
  id: orderedmap/index#entries()
  summary: An iterator of this Collection's entries as [ key, value ] tuples
  belongs_to: OrderedMap
  description: |-
    #### [entries()](index#entries())

    An iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.

    ``` ts
    entries(): IterableIterator<[K, V]>
    ```

    #### Inherited from

    [`Collection#entries()`](../collection/index#entries())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.

    ### Collections (Seq)
- name: OrderedMap.entrySeq()
  id: orderedmap/index#entrySeq()
  summary: Returns a new Seq.Indexed of [key, value] tuples
  belongs_to: OrderedMap
  description: |-
    #### [entrySeq()](index#entrySeq())

    Returns a new Seq.Indexed of \[key, value\] tuples.

    ``` ts
    entrySeq(): Seq.Indexed<[K, V]>
    ```

    #### Inherited from

    [`Collection#entrySeq()`](../collection/index#entrySeq())

    ### Side effects
- name: OrderedMap.equals()
  id: orderedmap/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: OrderedMap
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Inherited from

    [`Collection#equals()`](../collection/index#equals())

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: OrderedMap.every()
  id: orderedmap/index#every()
  summary: True if predicate returns true for all entries in the Collection
  belongs_to: OrderedMap
  description: |-
    #### [every()](index#every())

    True if `predicate` returns true for all entries in the Collection.

    ``` ts
    every(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#every()`](../collection/index#every())
- name: OrderedMap.filter()
  id: orderedmap/index#filter()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [filter()](index#filter())

    ``` ts
    filter<F>(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): OrderedMap<K, F>
    filter(predicate: (value: V, key: K, iter: this) => unknown,context?: unknown): this
    ```

    #### Overrides

    [`Map#filter()`](../map/index#filter())
- name: OrderedMap.filterNot()
  id: orderedmap/index#filterNot()
  summary: Returns a new Collection of the same type with only the entries for which the predicate function returns false
  belongs_to: OrderedMap
  description: |-
    #### [filterNot()](index#filterNot())

    Returns a new Collection of the same type with only the entries for which the `predicate` function returns false.

    ``` ts
    filterNot(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#filterNot()`](../collection/index#filterNot())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
    // Map { "a": 1, "c": 3 }run it
    ```

    Note: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.
- name: OrderedMap.find()
  id: orderedmap/index#find()
  summary: Returns the first value for which the predicate returns true
  belongs_to: OrderedMap
  description: |-
    #### [find()](index#find())

    Returns the first value for which the `predicate` returns true.

    ``` ts
    find(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined
    ```

    #### Inherited from

    [`Collection#find()`](../collection/index#find())
- name: OrderedMap.findEntry()
  id: orderedmap/index#findEntry()
  summary: Returns the first [key, value] entry for which the predicate returns true
  belongs_to: OrderedMap
  description: |-
    #### [findEntry()](index#findEntry())

    Returns the first \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
    ```

    #### Inherited from

    [`Collection#findEntry()`](../collection/index#findEntry())
- name: OrderedMap.findKey()
  id: orderedmap/index#findKey()
  summary: Returns the key for which the predicate returns true
  belongs_to: OrderedMap
  description: |-
    #### [findKey()](index#findKey())

    Returns the key for which the `predicate` returns true.

    ``` ts
    findKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined
    ```

    #### Inherited from

    [`Collection#findKey()`](../collection/index#findKey())
- name: OrderedMap.findLast()
  id: orderedmap/index#findLast()
  summary: Returns the last value for which the predicate returns true
  belongs_to: OrderedMap
  description: |-
    #### [findLast()](index#findLast())

    Returns the last value for which the `predicate` returns true.

    ``` ts
    findLast(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined
    ```

    #### Inherited from

    [`Collection#findLast()`](../collection/index#findLast())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: OrderedMap.findLastEntry()
  id: orderedmap/index#findLastEntry()
  summary: Returns the last [key, value] entry for which the predicate returns true
  belongs_to: OrderedMap
  description: |-
    #### [findLastEntry()](index#findLastEntry())

    Returns the last \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findLastEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
    ```

    #### Inherited from

    [`Collection#findLastEntry()`](../collection/index#findLastEntry())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: OrderedMap.findLastKey()
  id: orderedmap/index#findLastKey()
  summary: Returns the last key for which the predicate returns true
  belongs_to: OrderedMap
  description: |-
    #### [findLastKey()](index#findLastKey())

    Returns the last key for which the `predicate` returns true.

    ``` ts
    findLastKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined
    ```

    #### Inherited from

    [`Collection#findLastKey()`](../collection/index#findLastKey())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: OrderedMap.first()
  id: orderedmap/index#first()
  summary: In case the Collection is not empty returns the first element of the Collection
  belongs_to: OrderedMap
  description: |-
    #### [first()](index#first())

    In case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    first<NSV>(notSetValue?: NSV): V | NSV
    ```

    #### Inherited from

    [`Collection#first()`](../collection/index#first())
- name: OrderedMap.flatMap()
  id: orderedmap/index#flatMap()
  summary: Flat-maps the OrderedMap, returning a new OrderedMap
  belongs_to: OrderedMap
  description: |-
    #### [flatMap()](index#flatMap())

    Flat-maps the OrderedMap, returning a new OrderedMap.

    ``` ts
    flatMap<KM, VM>(mapper: (value: V, key: K, iter: this) => Iterable<[KM, VM]>,context?: unknown): OrderedMap<KM, VM>
    ```

    #### Overrides

    [`Map#flatMap()`](../map/index#flatMap())

    #### Discussion

    Similar to `data.map(...).flatten(true)`.
- name: OrderedMap.flatten()
  id: orderedmap/index#flatten()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [flatten()](index#flatten())

    ``` ts
    flatten(depth?: number): Collection<unknown, unknown>
    flatten(shallow?: boolean): Collection<unknown, unknown>
    ```

    #### Inherited from

    [`Collection#flatten()`](../collection/index#flatten())

    ### Reducing a value
- name: OrderedMap.flip()
  id: orderedmap/index#flip()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [flip()](index#flip())

    ``` ts
    flip(): OrderedMap<V, K>
    ```

    #### Overrides

    [`Map#flip()`](../map/index#flip())

    #### see

    Collection.Keyed.flip
- name: OrderedMap.forEach()
  id: orderedmap/index#forEach()
  summary: The sideEffect is executed for every entry in the Collection
  belongs_to: OrderedMap
  description: |-
    #### [forEach()](index#forEach())

    The `sideEffect` is executed for every entry in the Collection.

    ``` ts
    forEach(sideEffect: (value: V, key: K, iter: this) => unknown,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#forEach()`](../collection/index#forEach())

    #### Discussion

    Unlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).

    ### Creating subsets
- name: OrderedMap.get()
  id: orderedmap/index#get()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [get()](index#get())

    ``` ts
    get<NSV>(key: K, notSetValue: NSV): V | NSV
    get(key: K): V | undefined
    ```

    #### Inherited from

    [`Collection#get()`](../collection/index#get())
- name: OrderedMap.getIn()
  id: orderedmap/index#getIn()
  summary: Returns the value found by following a path of keys or indices through nested Collections
  belongs_to: OrderedMap
  description: |-
    #### [getIn()](index#getIn())

    Returns the value found by following a path of keys or indices through nested Collections.

    ``` ts
    getIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown
    ```

    #### Inherited from

    [`Collection#getIn()`](../collection/index#getIn())

    #### Discussion

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: [ { y: 123 } ] });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```
- name: OrderedMap.groupBy()
  id: orderedmap/index#groupBy()
  summary: Returns a Collection.Keyed of Collection.Keyeds, grouped by the return value of the grouper function
  belongs_to: OrderedMap
  description: |-
    #### [groupBy()](index#groupBy())

    Returns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.

    ``` ts
    groupBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<K, V>>
    ```

    #### Inherited from

    [`Collection#groupBy()`](../collection/index#groupBy())

    #### Discussion

    Note: This is always an eager operation.

    ``` ts
    const { List, Map } = require('immutable')
    const listOfMaps = List([
      Map({ v: 0 }),
      Map({ v: 1 }),
      Map({ v: 1 }),
      Map({ v: 0 }),
      Map({ v: 2 })
    ])
    const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
    // Map {
    //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
    //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
    //   2: List [ Map{ "v": 2 } ],
    // }run it
    ```

    ### Deep persistent changes
- name: OrderedMap.has()
  id: orderedmap/index#has()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [has()](index#has())

    True if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    has(key: K): boolean
    ```

    #### Inherited from

    [`Collection#has()`](../collection/index#has())
- name: OrderedMap.hashCode()
  id: orderedmap/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: OrderedMap
  description: |-
    #### [hashCode()](index#hashCode())

    Computes and returns the hashed identity for this Collection.

    ``` ts
    hashCode(): number
    ```

    #### Inherited from

    [`Collection#hashCode()`](../collection/index#hashCode())

    #### Discussion

    The [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.

    ``` ts
    const a = List([ 1, 2, 3 ]);
    const b = List([ 1, 2, 3 ]);
    assert.notStrictEqual(a, b); // different instances
    const set = Set([ a ]);
    assert.equal(set.has(b), true);run it
    ```

    If two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.

    ### Reading values
- name: OrderedMap.hasIn()
  id: orderedmap/index#hasIn()
  summary: True if the result of following a path of keys or indices through nested Collections results in a set value
  belongs_to: OrderedMap
  description: |-
    #### [hasIn()](index#hasIn())

    True if the result of following a path of keys or indices through nested Collections results in a set value.

    ``` ts
    hasIn(searchKeyPath: Iterable<unknown>): boolean
    ```

    #### Inherited from

    [`Collection#hasIn()`](../collection/index#hasIn())

    ### Conversion to Collections
- name: OrderedMap.includes()
  id: orderedmap/index#includes()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [includes()](index#includes())

    True if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    includes(value: V): boolean
    ```

    #### Inherited from

    [`Collection#includes()`](../collection/index#includes())

    #### alias

    `contains()`
- name: OrderedMap.isEmpty()
  id: orderedmap/index#isEmpty()
  summary: Returns true if this Collection includes no values
  belongs_to: OrderedMap
  description: |-
    #### [isEmpty()](index#isEmpty())

    Returns true if this Collection includes no values.

    ``` ts
    isEmpty(): boolean
    ```

    #### Inherited from

    [`Collection#isEmpty()`](../collection/index#isEmpty())

    #### Discussion

    For some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.
- name: OrderedMap.isSubset()
  id: orderedmap/index#isSubset()
  summary: True if iter includes every value in this Collection
  belongs_to: OrderedMap
  description: |-
    #### [isSubset()](index#isSubset())

    True if `iter` includes every value in this Collection.

    ``` ts
    isSubset(iter: Iterable<V>): boolean
    ```

    #### Inherited from

    [`Collection#isSubset()`](../collection/index#isSubset())
- name: OrderedMap.isSuperset()
  id: orderedmap/index#isSuperset()
  summary: True if this Collection includes every value in iter
  belongs_to: OrderedMap
  description: "#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/OrderedMap/](https://immutable-js.com/docs/v4.2.1/OrderedMap/)"
- name: OrderedMap.join()
  id: orderedmap/index#join()
  summary: Joins values together as a string, inserting a separator between each
  belongs_to: OrderedMap
  description: |-
    #### [join()](index#join())

    Joins values together as a string, inserting a separator between each. The default separator is `","`.

    ``` ts
    join(separator?: string): string
    ```

    #### Inherited from

    [`Collection#join()`](../collection/index#join())
- name: OrderedMap.keyOf()
  id: orderedmap/index#keyOf()
  summary: Returns the key associated with the search value, or undefined
  belongs_to: OrderedMap
  description: |-
    #### [keyOf()](index#keyOf())

    Returns the key associated with the search value, or undefined.

    ``` ts
    keyOf(searchValue: V): K | undefined
    ```

    #### Inherited from

    [`Collection#keyOf()`](../collection/index#keyOf())
- name: OrderedMap.keys()
  id: orderedmap/index#keys()
  summary: An iterator of this Collection's keys
  belongs_to: OrderedMap
  description: |-
    #### [keys()](index#keys())

    An iterator of this [`Collection`](../collection/index)'s keys.

    ``` ts
    keys(): IterableIterator<K>
    ```

    #### Inherited from

    [`Collection#keys()`](../collection/index#keys())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.
- name: OrderedMap.keySeq()
  id: orderedmap/index#keySeq()
  summary: Returns a new Seq.Indexed of the keys of this Collection, discarding values
  belongs_to: OrderedMap
  description: |-
    #### [keySeq()](index#keySeq())

    Returns a new Seq.Indexed of the keys of this Collection, discarding values.

    ``` ts
    keySeq(): Seq.Indexed<K>
    ```

    #### Inherited from

    [`Collection#keySeq()`](../collection/index#keySeq())
- name: OrderedMap.last()
  id: orderedmap/index#last()
  summary: In case the Collection is not empty returns the last element of the Collection
  belongs_to: OrderedMap
  description: |-
    #### [last()](index#last())

    In case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    last<NSV>(notSetValue?: NSV): V | NSV
    ```

    #### Inherited from

    [`Collection#last()`](../collection/index#last())

    ### Reading deep values
- name: OrderedMap.lastKeyOf()
  id: orderedmap/index#lastKeyOf()
  summary: Returns the last key associated with the search value, or undefined
  belongs_to: OrderedMap
  description: |-
    #### [lastKeyOf()](index#lastKeyOf())

    Returns the last key associated with the search value, or undefined.

    ``` ts
    lastKeyOf(searchValue: V): K | undefined
    ```

    #### Inherited from

    [`Collection#lastKeyOf()`](../collection/index#lastKeyOf())
- name: OrderedMap.map()
  id: orderedmap/index#map()
  summary: Returns a new OrderedMap with values passed through a mapper function
  belongs_to: OrderedMap
  description: |-
    #### [map()](index#map())

    Returns a new OrderedMap with values passed through a `mapper` function.

    ``` ts
    map<M>(mapper: (value: V, key: K, iter: this) => M,context?: unknown): OrderedMap<K, M>
    ```

    #### Overrides

    [`Map#map()`](../map/index#map())

    #### Example

    ``` ts
    OrderedMap({ a: 1, b: 2 }).map(x => 10 * x)
    // OrderedMap { "a": 10, "b": 20 }
    ```

    Note: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.
- name: OrderedMap.mapEntries()
  id: orderedmap/index#mapEntries()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [mapEntries()](index#mapEntries())

    ``` ts
    mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM] | undefined,context?: unknown): OrderedMap<KM, VM>
    ```

    #### Overrides

    [`Map#mapEntries()`](../map/index#mapEntries())

    #### see

    Collection.Keyed.mapEntries
- name: OrderedMap.mapKeys()
  id: orderedmap/index#mapKeys()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [mapKeys()](index#mapKeys())

    ``` ts
    mapKeys<M>(mapper: (key: K, value: V, iter: this) => M,context?: unknown): OrderedMap<M, V>
    ```

    #### Overrides

    [`Map#mapKeys()`](../map/index#mapKeys())

    #### see

    Collection.Keyed.mapKeys
- name: OrderedMap.max()
  id: orderedmap/index#max()
  summary: Returns the maximum value in this collection
  belongs_to: OrderedMap
  description: |-
    #### [max()](index#max())

    Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    max(comparator?: (valueA: V, valueB: V) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#max()`](../collection/index#max())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: OrderedMap.maxBy()
  id: orderedmap/index#maxBy()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [maxBy()](index#maxBy())

    Like [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    maxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#maxBy()`](../collection/index#maxBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it
    ```
- name: OrderedMap.merge()
  id: orderedmap/index#merge()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [merge()](index#merge())

    ``` ts
    merge<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): OrderedMap<K | KC, V | VC>
    merge<C>(...collections: Array<{[key: string]: C}>): OrderedMap<K | string, V | C>
    ```

    #### Overrides

    [`Map#merge()`](../map/index#merge())
- name: OrderedMap.mergeDeep()
  id: orderedmap/index#mergeDeep()
  summary: Like merge(), but when two compatible collections are encountered with the same key, it merges them as well, recursing deeply through the nested data
  belongs_to: OrderedMap
  description: |-
    #### [mergeDeep()](index#mergeDeep())

    Like [`merge()`](../map/index#merge()), but when two compatible collections are encountered with the same key, it merges them as well, recursing deeply through the nested data. Two collections are considered to be compatible (and thus will be merged together) if they both fall into one of three categories: keyed (e.g., [`Map`](../map/index)s, [`Record`](../record/index)s, and objects), indexed (e.g., [`List`](../list/index)s and arrays), or set-like (e.g., [`Set`](../set/index)s). If they fall into separate categories, [`mergeDeep`](../map/index#mergeDeep()) will replace the existing collection with the collection being merged in. This behavior can be customized by using [`mergeDeepWith()`](../map/index#mergeDeepWith()).

    ``` ts
    mergeDeep(...collections: Array<Iterable<[K, V]> | {[key: string]: V}>): this
    ```

    #### Inherited from

    [`Map#mergeDeep()`](../map/index#mergeDeep())

    #### Discussion

    Note: Indexed and set-like collections are merged using [`concat()`](../map/index#concat())/`union()` and therefore do not recurse.

    ``` ts
    const { Map } = require('immutable')
    const one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })
    const two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })
    one.mergeDeep(two)
    // Map {
    //   "a": Map { "x": 2, "y": 10 },
    //   "b": Map { "x": 20, "y": 5 },
    //   "c": Map { "z": 3 }
    // }run it
    ```

    Note: [`mergeDeep`](../map/index#mergeDeep()) can be used in [`withMutations`](../map/index#withMutations()).
- name: OrderedMap.mergeDeepIn()
  id: orderedmap/index#mergeDeepIn()
  summary: A combination of updateIn and mergeDeep, returning a new Map, but performing the deep merge at a point arrived at by following the keyPath
  belongs_to: OrderedMap
  description: |-
    #### [mergeDeepIn()](index#mergeDeepIn())

    A combination of [`updateIn`](../map/index#updateIn()) and [`mergeDeep`](../map/index#mergeDeep()), returning a new Map, but performing the deep merge at a point arrived at by following the keyPath. In other words, these two lines are equivalent:

    ``` ts
    mergeDeepIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this
    ```

    #### Inherited from

    [`Map#mergeDeepIn()`](../map/index#mergeDeepIn())

    #### Discussion

    ``` ts
    map.updateIn(['a', 'b', 'c'], abc => abc.mergeDeep(y))
    map.mergeDeepIn(['a', 'b', 'c'], y)
    ```

    Note: [`mergeDeepIn`](../map/index#mergeDeepIn()) can be used in [`withMutations`](../map/index#withMutations()).

    ### Transient changes
- name: OrderedMap.mergeDeepWith()
  id: orderedmap/index#mergeDeepWith()
  summary: Like mergeDeep(), but when two non-collections or incompatible collections are encountered at the same key, it uses the merger function to determine the resulting value
  belongs_to: OrderedMap
  description: |-
    #### [mergeDeepWith()](index#mergeDeepWith())

    Like [`mergeDeep()`](../map/index#mergeDeep()), but when two non-collections or incompatible collections are encountered at the same key, it uses the `merger` function to determine the resulting value. Collections are considered incompatible if they fall into separate categories between keyed, indexed, and set-like.

    ``` ts
    mergeDeepWith(merger: (oldVal: unknown, newVal: unknown, key: unknown) => unknown,...collections: Array<Iterable<[K, V]> | {[key: string]: V}>): this
    ```

    #### Inherited from

    [`Map#mergeDeepWith()`](../map/index#mergeDeepWith())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })
    const two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })
    one.mergeDeepWith((oldVal, newVal) => oldVal / newVal, two)
    // Map {
    //   "a": Map { "x": 5, "y": 10 },
    //   "b": Map { "x": 20, "y": 10 },
    //   "c": Map { "z": 3 }
    // }run it
    ```

    Note: [`mergeDeepWith`](../map/index#mergeDeepWith()) can be used in [`withMutations`](../map/index#withMutations()).

    ### Sequence algorithms
- name: OrderedMap.mergeIn()
  id: orderedmap/index#mergeIn()
  summary: A combination of updateIn and merge, returning a new Map, but performing the merge at a point arrived at by following the keyPath
  belongs_to: OrderedMap
  description: |-
    #### [mergeIn()](index#mergeIn())

    A combination of [`updateIn`](../map/index#updateIn()) and [`merge`](../map/index#merge()), returning a new Map, but performing the merge at a point arrived at by following the keyPath. In other words, these two lines are equivalent:

    ``` ts
    mergeIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this
    ```

    #### Inherited from

    [`Map#mergeIn()`](../map/index#mergeIn())

    #### Discussion

    ``` ts
    map.updateIn(['a', 'b', 'c'], abc => abc.merge(y))
    map.mergeIn(['a', 'b', 'c'], y)
    ```

    Note: [`mergeIn`](../map/index#mergeIn()) can be used in [`withMutations`](../map/index#withMutations()).
- name: OrderedMap.mergeWith()
  id: orderedmap/index#mergeWith()
  summary: Like merge(), mergeWith() returns a new Map resulting from merging the provided Collections (or JS objects) into this Map, but uses the merger function for dealing with conflicts
  belongs_to: OrderedMap
  description: |-
    #### [mergeWith()](index#mergeWith())

    Like [`merge()`](../map/index#merge()), [`mergeWith()`](../map/index#mergeWith()) returns a new Map resulting from merging the provided Collections (or JS objects) into this Map, but uses the `merger` function for dealing with conflicts.

    ``` ts
    mergeWith(merger: (oldVal: V, newVal: V, key: K) => V,...collections: Array<Iterable<[K, V]> | {[key: string]: V}>): this
    ```

    #### Inherited from

    [`Map#mergeWith()`](../map/index#mergeWith())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const one = Map({ a: 10, b: 20, c: 30 })
    const two = Map({ b: 40, a: 50, d: 60 })
    one.mergeWith((oldVal, newVal) => oldVal / newVal, two)
    // { "a": 0.2, "b": 0.5, "c": 30, "d": 60 }
    two.mergeWith((oldVal, newVal) => oldVal / newVal, one)
    // { "b": 2, "a": 5, "d": 60, "c": 30 }run it
    ```

    Note: [`mergeWith`](../map/index#mergeWith()) can be used in [`withMutations`](../map/index#withMutations()).
- name: OrderedMap.min()
  id: orderedmap/index#min()
  summary: Returns the minimum value in this collection
  belongs_to: OrderedMap
  description: |-
    #### [min()](index#min())

    Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    min(comparator?: (valueA: V, valueB: V) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#min()`](../collection/index#min())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: OrderedMap.minBy()
  id: orderedmap/index#minBy()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [minBy()](index#minBy())

    Like [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    minBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#minBy()`](../collection/index#minBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it
    ```

    ### Comparison
- name: OrderedMap.OrderedMap()
  id: orderedmap/index#OrderedMap()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [OrderedMap()](index#OrderedMap())

    ``` ts
    OrderedMap<K, V>(collection?: Iterable<[K, V]>): OrderedMap<K, V>
    OrderedMap<V>(obj: {[key: string]: V}): OrderedMap<string, V>
    ```

    ### Static methods
- name: OrderedMap.OrderedMap.isOrderedMap()
  id: orderedmap/index#isOrderedMap()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [OrderedMap.isOrderedMap()](index#isOrderedMap())

    ``` ts
    OrderedMap.isOrderedMap(maybeOrderedMap: unknown): boolean
    ```

    ### Members
- name: OrderedMap.partition()
  id: orderedmap/index#partition()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [partition()](index#partition())

    ``` ts
    partition<F, C>(predicate: (this: C, value: V, key: K, iter: this) => boolean,context?: C): [OrderedMap<K, V>, OrderedMap<K, F>]
    partition<C>(predicate: (this: C, value: V, key: K, iter: this) => unknown,context?: C): [this, this]
    ```

    #### Overrides

    [`Map#partition()`](../map/index#partition())
- name: OrderedMap.reduce()
  id: orderedmap/index#reduce()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [reduce()](index#reduce())

    ``` ts
    reduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R
    reduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduce()`](../collection/index#reduce())
- name: OrderedMap.reduceRight()
  id: orderedmap/index#reduceRight()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [reduceRight()](index#reduceRight())

    ``` ts
    reduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R
    reduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduceRight()`](../collection/index#reduceRight())
- name: OrderedMap.rest()
  id: orderedmap/index#rest()
  summary: Returns a new Collection of the same type containing all entries except the first
  belongs_to: OrderedMap
  description: |-
    #### [rest()](index#rest())

    Returns a new Collection of the same type containing all entries except the first.

    ``` ts
    rest(): this
    ```

    #### Inherited from

    [`Collection#rest()`](../collection/index#rest())
- name: OrderedMap.reverse()
  id: orderedmap/index#reverse()
  summary: Returns a new Collection of the same type in reverse order
  belongs_to: OrderedMap
  description: |-
    #### [reverse()](index#reverse())

    Returns a new Collection of the same type in reverse order.

    ``` ts
    reverse(): this
    ```

    #### Inherited from

    [`Collection#reverse()`](../collection/index#reverse())
- name: OrderedMap.set()
  id: orderedmap/index#set()
  summary: Returns a new OrderedMap also containing the new key, value pair
  belongs_to: OrderedMap
  description: |-
    #### [set()](index#set())

    Returns a new OrderedMap also containing the new key, value pair. If an equivalent key already exists in this OrderedMap, it will be replaced while maintaining the existing order.

    ``` ts
    set(key: K, value: V): this
    ```

    #### Overrides

    [`Map#set()`](../map/index#set())

    #### Discussion

    ``` ts
    const { OrderedMap } = require('immutable')
    const originalMap = OrderedMap({a:1, b:1, c:1})
    const updatedMap = originalMap.set('b', 2)

    originalMap
    // OrderedMap {a: 1, b: 1, c: 1}
    updatedMap
    // OrderedMap {a: 1, b: 2, c: 1}run it
    ```

    Note: [`set`](index#set()) can be used in [`withMutations`](index#withMutations()).
- name: OrderedMap.setIn()
  id: orderedmap/index#setIn()
  summary: Returns a new Map having set value at this keyPath
  belongs_to: OrderedMap
  description: |-
    #### [setIn()](index#setIn())

    Returns a new Map having set `value` at this `keyPath`. If any keys in `keyPath` do not exist, a new immutable Map will be created at that key.

    ``` ts
    setIn(keyPath: Iterable<unknown>, value: unknown): this
    ```

    #### Inherited from

    [`Map#setIn()`](../map/index#setIn())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const originalMap = Map({
      subObject: Map({
        subKey: 'subvalue',
        subSubObject: Map({
          subSubKey: 'subSubValue'
        })
      })
    })
    ```

    const newMap = originalMap.setIn(\['subObject', 'subKey'\], 'ha ha!') // Map { // "subObject": Map { // "subKey": "ha ha!", // "subSubObject": Map { "subSubKey": "subSubValue" } // } // } const newerMap = originalMap.setIn( \['subObject', 'subSubObject', 'subSubKey'\], 'ha ha ha!' ) // Map { // "subObject": Map { // "subKey": "subvalue", // "subSubObject": Map { "subSubKey": "ha ha ha!" } // } // }run it

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and setIn() can update those values as well, treating them immutably by creating new copies of those values with the changes applied.

    ``` ts
    const { Map } = require('immutable')
    const originalMap = Map({
      subObject: {
        subKey: 'subvalue',
        subSubObject: {
          subSubKey: 'subSubValue'
        }
      }
    })
    ```

    originalMap.setIn(\['subObject', 'subKey'\], 'ha ha!') // Map { // "subObject": { // subKey: "ha ha!", // subSubObject: { subSubKey: "subSubValue" } // } // }run it

    If any key in the path exists but cannot be updated (such as a primitive like number or a custom Object like Date), an error will be thrown.

    Note: [`setIn`](../map/index#setIn()) can be used in [`withMutations`](../map/index#withMutations()).
- name: OrderedMap.size
  id: orderedmap/index#size
  summary: The number of entries in this OrderedMap
  belongs_to: OrderedMap
  description: |-
    #### [size](index#size)

    The number of entries in this OrderedMap.

    ``` ts
    size: number
    ```

    #### Overrides

    [`Map#size`](../map/index#size)

    ### Persistent changes
- name: OrderedMap.skip()
  id: orderedmap/index#skip()
  summary: Returns a new Collection of the same type which excludes the first amount entries from this Collection
  belongs_to: OrderedMap
  description: |-
    #### [skip()](index#skip())

    Returns a new Collection of the same type which excludes the first `amount` entries from this Collection.

    ``` ts
    skip(amount: number): this
    ```

    #### Inherited from

    [`Collection#skip()`](../collection/index#skip())
- name: OrderedMap.skipLast()
  id: orderedmap/index#skipLast()
  summary: Returns a new Collection of the same type which excludes the last amount entries from this Collection
  belongs_to: OrderedMap
  description: |-
    #### [skipLast()](index#skipLast())

    Returns a new Collection of the same type which excludes the last `amount` entries from this Collection.

    ``` ts
    skipLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#skipLast()`](../collection/index#skipLast())
- name: OrderedMap.skipUntil()
  id: orderedmap/index#skipUntil()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns true
  belongs_to: OrderedMap
  description: |-
    #### [skipUntil()](index#skipUntil())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns true.

    ``` ts
    skipUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipUntil()`](../collection/index#skipUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipUntil(x => x.match(/hat/))
    // List [ "hat", "god" ]run it
    ```
- name: OrderedMap.skipWhile()
  id: orderedmap/index#skipWhile()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns false
  belongs_to: OrderedMap
  description: |-
    #### [skipWhile()](index#skipWhile())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns false.

    ``` ts
    skipWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipWhile()`](../collection/index#skipWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipWhile(x => x.match(/g/))
    // List [ "cat", "hat", "god" ]run it
    ```
- name: OrderedMap.slice()
  id: orderedmap/index#slice()
  summary: Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end
  belongs_to: OrderedMap
  description: |-
    #### [slice()](index#slice())

    Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.

    ``` ts
    slice(begin?: number, end?: number): this
    ```

    #### Inherited from

    [`Collection#slice()`](../collection/index#slice())

    #### Discussion

    If begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.

    If end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.

    If the requested slice is equivalent to the current Collection, then it will return itself.
- name: OrderedMap.some()
  id: orderedmap/index#some()
  summary: True if predicate returns true for any entry in the Collection
  belongs_to: OrderedMap
  description: |-
    #### [some()](index#some())

    True if `predicate` returns true for any entry in the Collection.

    ``` ts
    some(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#some()`](../collection/index#some())
- name: OrderedMap.sort()
  id: orderedmap/index#sort()
  summary: Returns a new Collection of the same type which includes the same entries, stably sorted by using a comparator
  belongs_to: OrderedMap
  description: |-
    #### [sort()](index#sort())

    Returns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.

    ``` ts
    sort(comparator?: (valueA: V, valueB: V) => number): this
    ```

    #### Inherited from

    [`Collection#sort()`](../collection/index#sort())

    #### Discussion

    If a `comparator` is not provided, a default comparator uses `<` and `>`.

    `comparator(valueA, valueB)`:

    - Returns `0` if the elements should not be swapped.
    - Returns `-1` (or any negative number) if `valueA` comes before `valueB`
    - Returns `1` (or any positive number) if `valueA` comes after `valueB`
    - Is pure, i.e. it must always return the same value for the same pair of values.

    When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.

    ``` ts
    const { Map } = require('immutable')
    Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
      if (a < b) { return -1; }
      if (a > b) { return 1; }
      if (a === b) { return 0; }
    });
    // OrderedMap { "a": 1, "b": 2, "c": 3 }run it
    ```

    Note: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: OrderedMap.sortBy()
  id: orderedmap/index#sortBy()
  summary: 'Note: sortBy() Always returns a new instance, even if the original was already sorted'
  belongs_to: OrderedMap
  description: |-
    #### [sortBy()](index#sortBy())

    Like [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:

    ``` ts
    sortBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this
    ```

    #### Inherited from

    [`Collection#sortBy()`](../collection/index#sortBy())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const beattles = Map({
      John: { name: "Lennon" },
      Paul: { name: "McCartney" },
      George: { name: "Harrison" },
      Ringo: { name: "Starr" },
    });
    beattles.sortBy(member => member.name);run it
    ```

    Note: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: OrderedMap.take()
  id: orderedmap/index#take()
  summary: Returns a new Collection of the same type which includes the first amount entries from this Collection
  belongs_to: OrderedMap
  description: |-
    #### [take()](index#take())

    Returns a new Collection of the same type which includes the first `amount` entries from this Collection.

    ``` ts
    take(amount: number): this
    ```

    #### Inherited from

    [`Collection#take()`](../collection/index#take())
- name: OrderedMap.takeLast()
  id: orderedmap/index#takeLast()
  summary: Returns a new Collection of the same type which includes the last amount entries from this Collection
  belongs_to: OrderedMap
  description: |-
    #### [takeLast()](index#takeLast())

    Returns a new Collection of the same type which includes the last `amount` entries from this Collection.

    ``` ts
    takeLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#takeLast()`](../collection/index#takeLast())
- name: OrderedMap.takeUntil()
  id: orderedmap/index#takeUntil()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns false
  belongs_to: OrderedMap
  description: |-
    #### [takeUntil()](index#takeUntil())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.

    ``` ts
    takeUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeUntil()`](../collection/index#takeUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeUntil(x => x.match(/at/))
    // List [ "dog", "frog" ]run it
    ```

    ### Combination
- name: OrderedMap.takeWhile()
  id: orderedmap/index#takeWhile()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns true
  belongs_to: OrderedMap
  description: |-
    #### [takeWhile()](index#takeWhile())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.

    ``` ts
    takeWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeWhile()`](../collection/index#takeWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeWhile(x => x.match(/o/))
    // List [ "dog", "frog" ]run it
    ```
- name: OrderedMap.toArray()
  id: orderedmap/index#toArray()
  summary: Shallowly converts this collection to an Array
  belongs_to: OrderedMap
  description: |-
    #### [toArray()](index#toArray())

    Shallowly converts this collection to an Array.

    ``` ts
    toArray(): Array<[K, V]>
    ```

    #### Inherited from

    [`Collection.Keyed#toArray()`](../collection.keyed/index#toArray())
- name: OrderedMap.toIndexedSeq()
  id: orderedmap/index#toIndexedSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: OrderedMap
  description: |-
    #### [toIndexedSeq()](index#toIndexedSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    toIndexedSeq(): Seq.Indexed<V>
    ```

    #### Inherited from

    [`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())
- name: OrderedMap.toJS()
  id: orderedmap/index#toJS()
  summary: Deeply converts this Keyed collection to equivalent native JavaScript Object
  belongs_to: OrderedMap
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Keyed collection to equivalent native JavaScript Object.

    ``` ts
    toJS(): {[key: string]: DeepCopy<V>}
    ```

    #### Inherited from

    [`Collection.Keyed#toJS()`](../collection.keyed/index#toJS())

    #### Discussion

    Converts keys to Strings.
- name: OrderedMap.toJSON()
  id: orderedmap/index#toJSON()
  summary: Shallowly converts this Keyed collection to equivalent native JavaScript Object
  belongs_to: OrderedMap
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Keyed collection to equivalent native JavaScript Object.

    ``` ts
    toJSON(): {[key: string]: V}
    ```

    #### Inherited from

    [`Collection.Keyed#toJSON()`](../collection.keyed/index#toJSON())

    #### Discussion

    Converts keys to Strings.
- name: OrderedMap.toKeyedSeq()
  id: orderedmap/index#toKeyedSeq()
  summary: Returns a Seq.Keyed from this Collection where indices are treated as keys
  belongs_to: OrderedMap
  description: |-
    #### [toKeyedSeq()](index#toKeyedSeq())

    Returns a Seq.Keyed from this Collection where indices are treated as keys.

    ``` ts
    toKeyedSeq(): Seq.Keyed<K, V>
    ```

    #### Inherited from

    [`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())

    #### Discussion

    This is useful if you want to operate on an Collection.Indexed and preserve the \[index, value\] pairs.

    The returned Seq will have identical iteration order as this Collection.

    ``` ts
    const { Seq } = require('immutable')
    const indexedSeq = Seq([ 'A', 'B', 'C' ])
    // Seq [ "A", "B", "C" ]
    indexedSeq.filter(v => v === 'B')
    // Seq [ "B" ]
    const keyedSeq = indexedSeq.toKeyedSeq()
    // Seq { 0: "A", 1: "B", 2: "C" }
    keyedSeq.filter(v => v === 'B')
    // Seq { 1: "B" }run it
    ```
- name: OrderedMap.toList()
  id: orderedmap/index#toList()
  summary: Converts this Collection to a List, discarding keys
  belongs_to: OrderedMap
  description: |-
    #### [toList()](index#toList())

    Converts this Collection to a List, discarding keys.

    ``` ts
    toList(): List<V>
    ```

    #### Inherited from

    [`Collection#toList()`](../collection/index#toList())

    #### Discussion

    This is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.

    ``` ts
    const { Map, List } = require('immutable')
    var myMap = Map({ a: 'Apple', b: 'Banana' })
    List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
    myMap.toList() // List [ "Apple", "Banana" ]run it
    ```
- name: OrderedMap.toMap()
  id: orderedmap/index#toMap()
  summary: Converts this Collection to a Map, Throws if keys are not hashable
  belongs_to: OrderedMap
  description: |-
    #### [toMap()](index#toMap())

    Converts this Collection to a Map, Throws if keys are not hashable.

    ``` ts
    toMap(): Map<K, V>
    ```

    #### Inherited from

    [`Collection#toMap()`](../collection/index#toMap())

    #### Discussion

    Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: OrderedMap.toObject()
  id: orderedmap/index#toObject()
  summary: Shallowly converts this Collection to an Object
  belongs_to: OrderedMap
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Collection to an Object.

    ``` ts
    toObject(): {[key: string]: V}
    ```

    #### Inherited from

    [`Collection#toObject()`](../collection/index#toObject())

    #### Discussion

    Converts keys to Strings.

    ### Conversion to Seq
- name: OrderedMap.toOrderedMap()
  id: orderedmap/index#toOrderedMap()
  summary: Converts this Collection to a Map, maintaining the order of iteration
  belongs_to: OrderedMap
  description: |-
    #### [toOrderedMap()](index#toOrderedMap())

    Converts this Collection to a Map, maintaining the order of iteration.

    ``` ts
    toOrderedMap(): OrderedMap<K, V>
    ```

    #### Inherited from

    [`Collection#toOrderedMap()`](../collection/index#toOrderedMap())

    #### Discussion

    Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: OrderedMap.toOrderedSet()
  id: orderedmap/index#toOrderedSet()
  summary: Converts this Collection to a Set, maintaining the order of iteration and discarding keys
  belongs_to: OrderedMap
  description: |-
    #### [toOrderedSet()](index#toOrderedSet())

    Converts this Collection to a Set, maintaining the order of iteration and discarding keys.

    ``` ts
    toOrderedSet(): OrderedSet<V>
    ```

    #### Inherited from

    [`Collection#toOrderedSet()`](../collection/index#toOrderedSet())

    #### Discussion

    Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.
- name: OrderedMap.toSeq()
  id: orderedmap/index#toSeq()
  summary: Returns Seq.Keyed
  belongs_to: OrderedMap
  description: |-
    #### [toSeq()](index#toSeq())

    Returns Seq.Keyed.

    ``` ts
    toSeq(): Seq.Keyed<K, V>
    ```

    #### Inherited from

    [`Collection.Keyed#toSeq()`](../collection.keyed/index#toSeq())
- name: OrderedMap.toSet()
  id: orderedmap/index#toSet()
  summary: Converts this Collection to a Set, discarding keys
  belongs_to: OrderedMap
  description: |-
    #### [toSet()](index#toSet())

    Converts this Collection to a Set, discarding keys. Throws if values are not hashable.

    ``` ts
    toSet(): Set<V>
    ```

    #### Inherited from

    [`Collection#toSet()`](../collection/index#toSet())

    #### Discussion

    Note: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.
- name: OrderedMap.toSetSeq()
  id: orderedmap/index#toSetSeq()
  summary: Returns a Seq.Set of the values of this Collection, discarding keys
  belongs_to: OrderedMap
  description: |-
    #### [toSetSeq()](index#toSetSeq())

    Returns a Seq.Set of the values of this Collection, discarding keys.

    ``` ts
    toSetSeq(): Seq.Set<V>
    ```

    #### Inherited from

    [`Collection#toSetSeq()`](../collection/index#toSetSeq())

    ### Sequence functions
- name: OrderedMap.toStack()
  id: orderedmap/index#toStack()
  summary: Converts this Collection to a Stack, discarding keys
  belongs_to: OrderedMap
  description: |-
    #### [toStack()](index#toStack())

    Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.

    ``` ts
    toStack(): Stack<V>
    ```

    #### Inherited from

    [`Collection#toStack()`](../collection/index#toStack())

    #### Discussion

    Note: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.

    ### Iterators
- name: OrderedMap.update()
  id: orderedmap/index#update()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [update()](index#update())

    ``` ts
    update(key: K, notSetValue: V, updater: (value: V) => V): this
    update(key: K, updater: (value: V | undefined) => V): this
    update<R>(updater: (value: this) => R): R
    ```

    #### Inherited from

    [`Map#update()`](../map/index#update())
- name: OrderedMap.updateIn()
  id: orderedmap/index#updateIn()
  summary: null
  belongs_to: OrderedMap
  description: |-
    #### [updateIn()](index#updateIn())

    ``` ts
    updateIn(keyPath: Iterable<unknown>,notSetValue: unknown,updater: (value: unknown) => unknown): this
    updateIn(keyPath: Iterable<unknown>, updater: (value: unknown) => unknown): this
    ```

    #### Inherited from

    [`Map#updateIn()`](../map/index#updateIn())
- name: OrderedMap.values()
  id: orderedmap/index#values()
  summary: An iterator of this Collection's values
  belongs_to: OrderedMap
  description: |-
    #### [values()](index#values())

    An iterator of this [`Collection`](../collection/index)'s values.

    ``` ts
    values(): IterableIterator<V>
    ```

    #### Inherited from

    [`Collection#values()`](../collection/index#values())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.
- name: OrderedMap.valueSeq()
  id: orderedmap/index#valueSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: OrderedMap
  description: |-
    #### [valueSeq()](index#valueSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    valueSeq(): Seq.Indexed<V>
    ```

    #### Inherited from

    [`Collection#valueSeq()`](../collection/index#valueSeq())
- name: OrderedMap.wasAltered()
  id: orderedmap/index#wasAltered()
  summary: Returns true if this is a mutable copy (see asMutable()) and mutative alterations have been applied
  belongs_to: OrderedMap
  description: |-
    #### [wasAltered()](index#wasAltered())

    Returns true if this is a mutable copy (see [`asMutable()`](../map/index#asMutable())) and mutative alterations have been applied.

    ``` ts
    wasAltered(): boolean
    ```

    #### Inherited from

    [`Map#wasAltered()`](../map/index#wasAltered())

    #### see

    [`Map#asMutable`](../map/index#asMutable())
- name: OrderedMap.withMutations()
  id: orderedmap/index#withMutations()
  summary: Every time you call one of the above functions, a new immutable Map is created
  belongs_to: OrderedMap
  description: |-
    #### [withMutations()](index#withMutations())

    Every time you call one of the above functions, a new immutable Map is created. If a pure function calls a number of these to produce a final return value, then a penalty on performance and memory has been paid by creating all of the intermediate immutable Maps.

    ``` ts
    withMutations(mutator: (mutable: this) => unknown): this
    ```

    #### Inherited from

    [`Map#withMutations()`](../map/index#withMutations())

    #### Discussion

    If you need to apply a series of mutations to produce a new immutable Map, [`withMutations()`](../map/index#withMutations()) creates a temporary mutable copy of the Map which can apply mutations in a highly performant manner. In fact, this is exactly how complex mutations like [`merge`](../map/index#merge()) are done.

    As an example, this results in the creation of 2, not 4, new Maps:

    ``` ts
    const { Map } = require('immutable')
    const map1 = Map()
    const map2 = map1.withMutations(map => {
      map.set('a', 1).set('b', 2).set('c', 3)
    })
    assert.equal(map1.size, 0)
    assert.equal(map2.size, 3)run it
    ```

    Note: Not all methods can be used on a mutable collection or within [`withMutations`](../map/index#withMutations())! Read the documentation for each method to see if it is safe to use in [`withMutations`](../map/index#withMutations()).
- name: OrderedSet
  id: orderedset/index
  summary: A type of Set that has the additional guarantee that the iteration order of values will be the order in which they were added
  description: "# OrderedSet\n\nA type of Set that has the additional guarantee that the iteration order of values will be the order in which they were [`add`](index#add())ed.\n\n``` ts\ntype OrderedSet<T> extends Set<T>\n```\n\n#### Discussion\n\nThe iteration behavior of OrderedSet is the same as native ES6 Set.\n\nNote that [`OrderedSet`](index) are more expensive than non-ordered [`Set`](../set/index) and may consume more memory. [`OrderedSet#add`](index#add()) is amortized O(log32 N), but not stable.\n\n### Construction\n\n#### [OrderedSet()](index#OrderedSet())\n\nCreate a new immutable OrderedSet containing the values of the provided collection-like.\n\n``` ts\nOrderedSet<T>(collection?: Iterable<T> | ArrayLike<T>): OrderedSet<T>\n```\n\n#### Discussion\n\nNote: [`OrderedSet`](index) is a factory function and not a class, and does not use the `new` keyword during construction.\n\n### Static methods\n\n#### [OrderedSet.isOrderedSet()](index#isOrderedSet())\n\n``` ts\nOrderedSet.isOrderedSet(maybeOrderedSet: unknown): boolean\n```\n\n#### [OrderedSet.of()](index#of())\n\n``` ts\nOrderedSet.of<T>(...values: Array<T>): OrderedSet<T>\n```\n\n#### [OrderedSet.fromKeys()](index#fromKeys())\n\n``` ts\nOrderedSet.fromKeys<T>(iter: Collection<T, unknown>): OrderedSet<T>\nOrderedSet.fromKeys(obj: {[key: string]: unknown}): OrderedSet<string>\n```\n\n### Members\n\n#### [size](index#size)\n\nThe number of items in this OrderedSet.\n\n``` ts\nsize: number\n```\n\n#### Overrides\n\n[`Set#size`](../set/index#size)\n\n### Persistent changes\n\n#### [union()](index#union())\n\nReturns an OrderedSet including any value from `collections` that does not already exist in this OrderedSet.\n\n``` ts\nunion<C>(...collections: Array<Iterable<C>>): OrderedSet<T | C>\n```\n\n#### Overrides\n\n[`Set#union()`](../set/index#union())\n\n#### alias\n\n`merge()`\n\n#### alias\n\n`concat()`\n\n#### Discussion\n\nNote: [`union`](index#union()) can be used in [`withMutations`](index#withMutations()).\n\n#### [add()](index#add())\n\nReturns a new Set which also includes this value.\n\n``` ts\nadd(value: T): this\n```\n\n#### Inherited from\n\n[`Set#add()`](../set/index#add())\n\n#### Discussion\n\nNote: [`add`](../set/index#add()) can be used in [`withMutations`](../set/index#withMutations()).\n\n#### [delete()](index#delete())\n\nReturns a new Set which excludes this value.\n\n``` ts\ndelete(value: T): this\n```\n\n#### Inherited from\n\n[`Set#delete()`](../set/index#delete())\n\n#### alias\n\n`remove()`\n\n#### Discussion\n\nNote: [`delete`](../set/index#delete()) can be used in [`withMutations`](../set/index#withMutations()).\n\nNote: [`delete`](../set/index#delete()) **cannot** be safely used in IE8, use [`remove`](../remove()/index) if supporting old browsers.\n\n#### [clear()](index#clear())\n\nReturns a new Set containing no values.\n\n``` ts\nclear(): this\n```\n\n#### Inherited from\n\n[`Set#clear()`](../set/index#clear())\n\n#### Discussion\n\nNote: [`clear`](../set/index#clear()) can be used in [`withMutations`](../set/index#withMutations()).\n\n#### [intersect()](index#intersect())\n\nReturns a Set which has removed any values not also contained within `collections`.\n\n``` ts\nintersect(...collections: Array<Iterable<T>>): this\n```\n\n#### Inherited from\n\n[`Set#intersect()`](../set/index#intersect())\n\n#### Discussion\n\nNote: [`intersect`](../set/index#intersect()) can be used in [`withMutations`](../set/index#withMutations()).\n\n#### [subtract()](index#subtract())\n\nReturns a Set excluding any values contained within `collections`.\n\n``` ts\nsubtract(...collections: Array<Iterable<T>>): this\n```\n\n#### Inherited from\n\n[`Set#subtract()`](../set/index#subtract())\n\n#### Discussion\n\n``` ts\nconst { OrderedSet } = require('immutable')\nOrderedSet([ 1, 2, 3 ]).subtract([1, 3])\n// OrderedSet [2]run it\n```\n\nNote: [`subtract`](../set/index#subtract()) can be used in [`withMutations`](../set/index#withMutations()).\n\n#### [update()](index#update())\n\nThis can be very useful as a way to \"chain\" a normal function into a sequence of methods. RxJS calls this \"let\" and lodash calls it \"thru\".\n\n``` ts\nupdate<R>(updater: (value: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#update()`](../collection/index#update())\n\n#### Discussion\n\nFor example, to sum a Seq after mapping and filtering:\n\n``` ts\nconst { Seq } = require('immutable')\n\nfunction sum(collection) {\n  return collection.reduce((sum, x) => sum + x, 0)\n}\nSeq([ 1, 2, 3 ])\n  .map(x => x + 1)\n  .filter(x => x % 2 === 0)\n  .update(sum)\n// 6run it\n```\n\n### Sequence algorithms\n\n#### [map()](index#map())\n\nReturns a new Set with values passed through a `mapper` function.\n\n``` ts\nmap<M>(mapper: (value: T, key: T, iter: this) => M,context?: unknown): OrderedSet<M>\n```\n\n#### Overrides\n\n[`Set#map()`](../set/index#map())\n\n#### Example\n\n``` ts\nOrderedSet([ 1, 2 ]).map(x => 10 * x)\n// OrderedSet [10, 20]\n```\n\n#### [flatMap()](index#flatMap())\n\nFlat-maps the OrderedSet, returning a new OrderedSet.\n\n``` ts\nflatMap<M>(mapper: (value: T, key: T, iter: this) => Iterable<M>,context?: unknown): OrderedSet<M>\n```\n\n#### Overrides\n\n[`Set#flatMap()`](../set/index#flatMap())\n\n#### Discussion\n\nSimilar to `set.map(...).flatten(true)`.\n\n#### [filter()](index#filter())\n\n``` ts\nfilter<F>(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): OrderedSet<F>\nfilter(predicate: (value: T, key: T, iter: this) => unknown,context?: unknown): this\n```\n\n#### Overrides\n\n[`Set#filter()`](../set/index#filter())\n\n#### [partition()](index#partition())\n\n``` ts\npartition<F, C>(predicate: (this: C, value: T, key: T, iter: this) => boolean,context?: C): [OrderedSet<T>, OrderedSet<F>]\npartition<C>(predicate: (this: C, value: T, key: T, iter: this) => unknown,context?: C): [this, this]\n```\n\n#### Overrides\n\n[`Set#partition()`](../set/index#partition())\n\n#### [zip()](index#zip())\n\n``` ts\nzip<U>(other: Collection<unknown, U>): OrderedSet<[T, U]>\nzip<U, V>(other1: Collection<unknown, U>,other2: Collection<unknown, V>): OrderedSet<[T, U, V]>\nzip(...collections: Array<Collection<unknown, unknown>>): OrderedSet<unknown>\n```\n\n#### [zipAll()](index#zipAll())\n\n``` ts\nzipAll<U>(other: Collection<unknown, U>): OrderedSet<[T, U]>\nzipAll<U, V>(other1: Collection<unknown, U>,other2: Collection<unknown, V>): OrderedSet<[T, U, V]>\nzipAll(...collections: Array<Collection<unknown, unknown>>): OrderedSet<unknown>\n```\n\n#### [zipWith()](index#zipWith())\n\n``` ts\nzipWith<U, Z>(zipper: (value: T, otherValue: U) => Z,otherCollection: Collection<unknown, U>): OrderedSet<Z>\nzipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z,otherCollection: Collection<unknown, U>,thirdCollection: Collection<unknown, V>): OrderedSet<Z>\nzipWith<Z>(zipper: (...values: Array<unknown>) => Z,...collections: Array<Collection<unknown, unknown>>): OrderedSet<Z>\n```\n\n#### [concat()](index#concat())\n\nReturns a new Collection with other collections concatenated to this one.\n\n``` ts\nconcat<U>(...collections: Array<Iterable<U>>): Collection.Set<T | U>\n```\n\n#### Inherited from\n\n[`Collection.Set#concat()`](../collection.set/index#concat())\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection.Set#[Symbol.iterator]()`](../collection.set/index#%5BSymbol.iterator%5D())\n\n#### [filterNot()](index#filterNot())\n\nReturns a new Collection of the same type with only the entries for which the `predicate` function returns false.\n\n``` ts\nfilterNot(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#filterNot()`](../collection/index#filterNot())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }run it\n```\n\nNote: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.\n\n#### [reverse()](index#reverse())\n\nReturns a new Collection of the same type in reverse order.\n\n``` ts\nreverse(): this\n```\n\n#### Inherited from\n\n[`Collection#reverse()`](../collection/index#reverse())\n\n#### [sort()](index#sort())\n\nReturns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.\n\n``` ts\nsort(comparator?: (valueA: T, valueB: T) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sort()`](../collection/index#sort())\n\n#### Discussion\n\nIf a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n- Returns `0` if the elements should not be swapped.\n- Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n- Returns `1` (or any positive number) if `valueA` comes after `valueB`\n- Is pure, i.e. it must always return the same value for the same pair of values.\n\nWhen sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n``` ts\nconst { Map } = require('immutable')\nMap({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// OrderedMap { \"a\": 1, \"b\": 2, \"c\": 3 }run it\n```\n\nNote: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [sortBy()](index#sortBy())\n\nLike [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:\n\n``` ts\nsortBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sortBy()`](../collection/index#sortBy())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst beattles = Map({\n  John: { name: \"Lennon\" },\n  Paul: { name: \"McCartney\" },\n  George: { name: \"Harrison\" },\n  Ringo: { name: \"Starr\" },\n});\nbeattles.sortBy(member => member.name);run it\n```\n\nNote: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [groupBy()](index#groupBy())\n\nReturns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.\n\n``` ts\ngroupBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<T, T>>\n```\n\n#### Inherited from\n\n[`Collection#groupBy()`](../collection/index#groupBy())\n\n#### Discussion\n\nNote: This is always an eager operation.\n\n``` ts\nconst { List, Map } = require('immutable')\nconst listOfMaps = List([\n  Map({ v: 0 }),\n  Map({ v: 1 }),\n  Map({ v: 1 }),\n  Map({ v: 0 }),\n  Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ Map{ \"v\": 0 }, Map { \"v\": 0 } ],\n//   1: List [ Map{ \"v\": 1 }, Map { \"v\": 1 } ],\n//   2: List [ Map{ \"v\": 2 } ],\n// }run it\n```\n\n### Transient changes\n\n#### [withMutations()](index#withMutations())\n\nNote: Not all methods can be used on a mutable collection or within [`withMutations`](../set/index#withMutations())! Check the documentation for each method to see if it mentions being safe to use in [`withMutations`](../set/index#withMutations()).\n\n``` ts\nwithMutations(mutator: (mutable: this) => unknown): this\n```\n\n#### Inherited from\n\n[`Set#withMutations()`](../set/index#withMutations())\n\n#### see\n\n[`Map#withMutations`](../map/index#withMutations())\n\n#### [asMutable()](index#asMutable())\n\nNote: Not all methods can be used on a mutable collection or within [`withMutations`](../set/index#withMutations())! Check the documentation for each method to see if it mentions being safe to use in [`withMutations`](../set/index#withMutations()).\n\n``` ts\nasMutable(): this\n```\n\n#### Inherited from\n\n[`Set#asMutable()`](../set/index#asMutable())\n\n#### see\n\n[`Map#asMutable`](../map/index#asMutable())\n\n#### [wasAltered()](index#wasAltered())\n\n``` ts\nwasAltered(): boolean\n```\n\n#### Inherited from\n\n[`Set#wasAltered()`](../set/index#wasAltered())\n\n#### see\n\n[`Map#wasAltered`](../map/index#wasAltered())\n\n#### [asImmutable()](index#asImmutable())\n\n``` ts\nasImmutable(): this\n```\n\n#### Inherited from\n\n[`Set#asImmutable()`](../set/index#asImmutable())\n\n#### see\n\n[`Map#asImmutable`](../map/index#asImmutable())\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Set collection to equivalent native JavaScript Array.\n\n``` ts\ntoJS(): Array<DeepCopy<T>>\n```\n\n#### Inherited from\n\n[`Collection.Set#toJS()`](../collection.set/index#toJS())\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Set collection to equivalent native JavaScript Array.\n\n``` ts\ntoJSON(): Array<T>\n```\n\n#### Inherited from\n\n[`Collection.Set#toJSON()`](../collection.set/index#toJSON())\n\n#### [toArray()](index#toArray())\n\nShallowly converts this collection to an Array.\n\n``` ts\ntoArray(): Array<T>\n```\n\n#### Inherited from\n\n[`Collection.Set#toArray()`](../collection.set/index#toArray())\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Collection to an Object.\n\n``` ts\ntoObject(): {[key: string]: T}\n```\n\n#### Inherited from\n\n[`Collection#toObject()`](../collection/index#toObject())\n\n#### Discussion\n\nConverts keys to Strings.\n\n### Conversion to Seq\n\n#### [toSeq()](index#toSeq())\n\nReturns Seq.Set.\n\n``` ts\ntoSeq(): Seq.Set<T>\n```\n\n#### Inherited from\n\n[`Collection.Set#toSeq()`](../collection.set/index#toSeq())\n\n#### [toKeyedSeq()](index#toKeyedSeq())\n\nReturns a Seq.Keyed from this Collection where indices are treated as keys.\n\n``` ts\ntoKeyedSeq(): Seq.Keyed<T, T>\n```\n\n#### Inherited from\n\n[`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())\n\n#### Discussion\n\nThis is useful if you want to operate on an Collection.Indexed and preserve the \\[index, value\\] pairs.\n\nThe returned Seq will have identical iteration order as this Collection.\n\n``` ts\nconst { Seq } = require('immutable')\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\n// Seq [ \"A\", \"B\", \"C\" ]\nindexedSeq.filter(v => v === 'B')\n// Seq [ \"B\" ]\nconst keyedSeq = indexedSeq.toKeyedSeq()\n// Seq { 0: \"A\", 1: \"B\", 2: \"C\" }\nkeyedSeq.filter(v => v === 'B')\n// Seq { 1: \"B\" }run it\n```\n\n#### [toIndexedSeq()](index#toIndexedSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\ntoIndexedSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())\n\n#### [toSetSeq()](index#toSetSeq())\n\nReturns a Seq.Set of the values of this Collection, discarding keys.\n\n``` ts\ntoSetSeq(): Seq.Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSetSeq()`](../collection/index#toSetSeq())\n\n### Value equality\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#equals()`](../collection/index#equals())\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Inherited from\n\n[`Collection#hashCode()`](../collection/index#hashCode())\n\n#### Discussion\n\nThe [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nIf two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.\n\n### Reading values\n\n#### [get()](index#get())\n\n``` ts\nget<NSV>(key: T, notSetValue: NSV): T | NSV\nget(key: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#get()`](../collection/index#get())\n\n#### [has()](index#has())\n\nTrue if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nhas(key: T): boolean\n```\n\n#### Inherited from\n\n[`Collection#has()`](../collection/index#has())\n\n#### [includes()](index#includes())\n\nTrue if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nincludes(value: T): boolean\n```\n\n#### Inherited from\n\n[`Collection#includes()`](../collection/index#includes())\n\n#### alias\n\n`contains()`\n\n#### [first()](index#first())\n\nIn case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nfirst<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#first()`](../collection/index#first())\n\n#### [last()](index#last())\n\nIn case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nlast<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#last()`](../collection/index#last())\n\n### Reading deep values\n\n#### [getIn()](index#getIn())\n\nReturns the value found by following a path of keys or indices through nested Collections.\n\n``` ts\ngetIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown\n```\n\n#### Inherited from\n\n[`Collection#getIn()`](../collection/index#getIn())\n\n#### Discussion\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: [ { y: 123 } ] });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\n#### [hasIn()](index#hasIn())\n\nTrue if the result of following a path of keys or indices through nested Collections results in a set value.\n\n``` ts\nhasIn(searchKeyPath: Iterable<unknown>): boolean\n```\n\n#### Inherited from\n\n[`Collection#hasIn()`](../collection/index#hasIn())\n\n### Conversion to Collections\n\n#### [toMap()](index#toMap())\n\nConverts this Collection to a Map, Throws if keys are not hashable.\n\n``` ts\ntoMap(): Map<T, T>\n```\n\n#### Inherited from\n\n[`Collection#toMap()`](../collection/index#toMap())\n\n#### Discussion\n\nNote: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toOrderedMap()](index#toOrderedMap())\n\nConverts this Collection to a Map, maintaining the order of iteration.\n\n``` ts\ntoOrderedMap(): OrderedMap<T, T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedMap()`](../collection/index#toOrderedMap())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toSet()](index#toSet())\n\nConverts this Collection to a Set, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoSet(): Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSet()`](../collection/index#toSet())\n\n#### Discussion\n\nNote: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.\n\n#### [toOrderedSet()](index#toOrderedSet())\n\nConverts this Collection to a Set, maintaining the order of iteration and discarding keys.\n\n``` ts\ntoOrderedSet(): OrderedSet<T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedSet()`](../collection/index#toOrderedSet())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toList()](index#toList())\n\nConverts this Collection to a List, discarding keys.\n\n``` ts\ntoList(): List<T>\n```\n\n#### Inherited from\n\n[`Collection#toList()`](../collection/index#toList())\n\n#### Discussion\n\nThis is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.\n\n``` ts\nconst { Map, List } = require('immutable')\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\nList(myMap) // List [ [ \"a\", \"Apple\" ], [ \"b\", \"Banana\" ] ]\nmyMap.toList() // List [ \"Apple\", \"Banana\" ]run it\n```\n\n#### [toStack()](index#toStack())\n\nConverts this Collection to a Stack, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoStack(): Stack<T>\n```\n\n#### Inherited from\n\n[`Collection#toStack()`](../collection/index#toStack())\n\n#### Discussion\n\nNote: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.\n\n### Iterators\n\n#### [keys()](index#keys())\n\nAn iterator of this [`Collection`](../collection/index)'s keys.\n\n``` ts\nkeys(): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection#keys()`](../collection/index#keys())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.\n\n#### [values()](index#values())\n\nAn iterator of this [`Collection`](../collection/index)'s values.\n\n``` ts\nvalues(): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection#values()`](../collection/index#values())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.\n\n#### [entries()](index#entries())\n\nAn iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.\n\n``` ts\nentries(): IterableIterator<[T, T]>\n```\n\n#### Inherited from\n\n[`Collection#entries()`](../collection/index#entries())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.\n\n### Collections (Seq)\n\n#### [keySeq()](index#keySeq())\n\nReturns a new Seq.Indexed of the keys of this Collection, discarding values.\n\n``` ts\nkeySeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#keySeq()`](../collection/index#keySeq())\n\n#### [valueSeq()](index#valueSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\nvalueSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#valueSeq()`](../collection/index#valueSeq())\n\n#### [entrySeq()](index#entrySeq())\n\nReturns a new Seq.Indexed of \\[key, value\\] tuples.\n\n``` ts\nentrySeq(): Seq.Indexed<[T, T]>\n```\n\n#### Inherited from\n\n[`Collection#entrySeq()`](../collection/index#entrySeq())\n\n### Side effects\n\n#### [forEach()](index#forEach())\n\nThe `sideEffect` is executed for every entry in the Collection.\n\n``` ts\nforEach(sideEffect: (value: T, key: T, iter: this) => unknown,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#forEach()`](../collection/index#forEach())\n\n#### Discussion\n\nUnlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).\n\n### Creating subsets\n\n#### [slice()](index#slice())\n\nReturns a new Collection of the same type representing a portion of this Collection from start up to but not including end.\n\n``` ts\nslice(begin?: number, end?: number): this\n```\n\n#### Inherited from\n\n[`Collection#slice()`](../collection/index#slice())\n\n#### Discussion\n\nIf begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.\n\nIf the requested slice is equivalent to the current Collection, then it will return itself.\n\n#### [rest()](index#rest())\n\nReturns a new Collection of the same type containing all entries except the first.\n\n``` ts\nrest(): this\n```\n\n#### Inherited from\n\n[`Collection#rest()`](../collection/index#rest())\n\n#### [butLast()](index#butLast())\n\nReturns a new Collection of the same type containing all entries except the last.\n\n``` ts\nbutLast(): this\n```\n\n#### Inherited from\n\n[`Collection#butLast()`](../collection/index#butLast())\n\n#### [skip()](index#skip())\n\nReturns a new Collection of the same type which excludes the first `amount` entries from this Collection.\n\n``` ts\nskip(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skip()`](../collection/index#skip())\n\n#### [skipLast()](index#skipLast())\n\nReturns a new Collection of the same type which excludes the last `amount` entries from this Collection.\n\n``` ts\nskipLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skipLast()`](../collection/index#skipLast())\n\n#### [skipWhile()](index#skipWhile())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns false.\n\n``` ts\nskipWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipWhile()`](../collection/index#skipWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipWhile(x => x.match(/g/))\n// List [ \"cat\", \"hat\", \"god\" ]run it\n```\n\n#### [skipUntil()](index#skipUntil())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns true.\n\n``` ts\nskipUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipUntil()`](../collection/index#skipUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipUntil(x => x.match(/hat/))\n// List [ \"hat\", \"god\" ]run it\n```\n\n#### [take()](index#take())\n\nReturns a new Collection of the same type which includes the first `amount` entries from this Collection.\n\n``` ts\ntake(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#take()`](../collection/index#take())\n\n#### [takeLast()](index#takeLast())\n\nReturns a new Collection of the same type which includes the last `amount` entries from this Collection.\n\n``` ts\ntakeLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#takeLast()`](../collection/index#takeLast())\n\n#### [takeWhile()](index#takeWhile())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.\n\n``` ts\ntakeWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeWhile()`](../collection/index#takeWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeWhile(x => x.match(/o/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n#### [takeUntil()](index#takeUntil())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.\n\n``` ts\ntakeUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeUntil()`](../collection/index#takeUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeUntil(x => x.match(/at/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n### Combination\n\n#### [flatten()](index#flatten())\n\n``` ts\nflatten(depth?: number): Collection<unknown, unknown>\nflatten(shallow?: boolean): Collection<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection#flatten()`](../collection/index#flatten())\n\n### Reducing a value\n\n#### [reduce()](index#reduce())\n\n``` ts\nreduce<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R\nreduce<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduce()`](../collection/index#reduce())\n\n#### [reduceRight()](index#reduceRight())\n\n``` ts\nreduceRight<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R\nreduceRight<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduceRight()`](../collection/index#reduceRight())\n\n#### [every()](index#every())\n\nTrue if `predicate` returns true for all entries in the Collection.\n\n``` ts\nevery(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#every()`](../collection/index#every())\n\n#### [some()](index#some())\n\nTrue if `predicate` returns true for any entry in the Collection.\n\n``` ts\nsome(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#some()`](../collection/index#some())\n\n#### [join()](index#join())\n\nJoins values together as a string, inserting a separator between each. The default separator is `\",\"`.\n\n``` ts\njoin(separator?: string): string\n```\n\n#### Inherited from\n\n[`Collection#join()`](../collection/index#join())\n\n#### [isEmpty()](index#isEmpty())\n\nReturns true if this Collection includes no values.\n\n``` ts\nisEmpty(): boolean\n```\n\n#### Inherited from\n\n[`Collection#isEmpty()`](../collection/index#isEmpty())\n\n#### Discussion\n\nFor some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.\n\n#### [count()](index#count())\n\n``` ts\ncount(): number\ncount(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#count()`](../collection/index#count())\n\n#### [countBy()](index#countBy())\n\nReturns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.\n\n``` ts\ncountBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Map<G, number>\n```\n\n#### Inherited from\n\n[`Collection#countBy()`](../collection/index#countBy())\n\n#### Discussion\n\nNote: This is not a lazy operation.\n\n### Search for value\n\n#### [find()](index#find())\n\nReturns the first value for which the `predicate` returns true.\n\n``` ts\nfind(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#find()`](../collection/index#find())\n\n#### [findLast()](index#findLast())\n\nReturns the last value for which the `predicate` returns true.\n\n``` ts\nfindLast(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLast()`](../collection/index#findLast())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findEntry()](index#findEntry())\n\nReturns the first \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findEntry()`](../collection/index#findEntry())\n\n#### [findLastEntry()](index#findLastEntry())\n\nReturns the last \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindLastEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastEntry()`](../collection/index#findLastEntry())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findKey()](index#findKey())\n\nReturns the key for which the `predicate` returns true.\n\n``` ts\nfindKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findKey()`](../collection/index#findKey())\n\n#### [findLastKey()](index#findLastKey())\n\nReturns the last key for which the `predicate` returns true.\n\n``` ts\nfindLastKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastKey()`](../collection/index#findLastKey())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [keyOf()](index#keyOf())\n\nReturns the key associated with the search value, or undefined.\n\n``` ts\nkeyOf(searchValue: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#keyOf()`](../collection/index#keyOf())\n\n#### [lastKeyOf()](index#lastKeyOf())\n\nReturns the last key associated with the search value, or undefined.\n\n``` ts\nlastKeyOf(searchValue: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#lastKeyOf()`](../collection/index#lastKeyOf())\n\n#### [max()](index#max())\n\nReturns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmax(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#max()`](../collection/index#max())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [maxBy()](index#maxBy())\n\nLike [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nmaxBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#maxBy()`](../collection/index#maxBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it\n```\n\n#### [min()](index#min())\n\nReturns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmin(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#min()`](../collection/index#min())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [minBy()](index#minBy())\n\nLike [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nminBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#minBy()`](../collection/index#minBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it\n```\n\n### Comparison\n\n#### [isSubset()](index#isSubset())\n\nTrue if `iter` includes every value in this Collection.\n\n``` ts\nisSubset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSubset()`](../collection/index#isSubset())\n\n#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/OrderedSet/](https://immutable-js.com/docs/v4.2.1/OrderedSet/)"
- name: OrderedSet.[Symbol.iterator]()
  id: orderedset/index#[Symbol.iterator]()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [\[Symbol.iterator\]()](index#%5BSymbol.iterator%5D())

    ``` ts
    [Symbol.iterator](): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection.Set#[Symbol.iterator]()`](../collection.set/index#%5BSymbol.iterator%5D())
- name: OrderedSet.add()
  id: orderedset/index#add()
  summary: Returns a new Set which also includes this value
  belongs_to: OrderedSet
  description: |-
    #### [add()](index#add())

    Returns a new Set which also includes this value.

    ``` ts
    add(value: T): this
    ```

    #### Inherited from

    [`Set#add()`](../set/index#add())

    #### Discussion

    Note: [`add`](../set/index#add()) can be used in [`withMutations`](../set/index#withMutations()).
- name: OrderedSet.asImmutable()
  id: orderedset/index#asImmutable()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [asImmutable()](index#asImmutable())

    ``` ts
    asImmutable(): this
    ```

    #### Inherited from

    [`Set#asImmutable()`](../set/index#asImmutable())

    #### see

    [`Map#asImmutable`](../map/index#asImmutable())

    ### Conversion to JavaScript types
- name: OrderedSet.asMutable()
  id: orderedset/index#asMutable()
  summary: 'Note: Not all methods can be used on a mutable collection or within withMutations! Check the documentation for each method to see if it mentions being safe to use in withMutations'
  belongs_to: OrderedSet
  description: |-
    #### [asMutable()](index#asMutable())

    Note: Not all methods can be used on a mutable collection or within [`withMutations`](../set/index#withMutations())! Check the documentation for each method to see if it mentions being safe to use in [`withMutations`](../set/index#withMutations()).

    ``` ts
    asMutable(): this
    ```

    #### Inherited from

    [`Set#asMutable()`](../set/index#asMutable())

    #### see

    [`Map#asMutable`](../map/index#asMutable())
- name: OrderedSet.butLast()
  id: orderedset/index#butLast()
  summary: Returns a new Collection of the same type containing all entries except the last
  belongs_to: OrderedSet
  description: |-
    #### [butLast()](index#butLast())

    Returns a new Collection of the same type containing all entries except the last.

    ``` ts
    butLast(): this
    ```

    #### Inherited from

    [`Collection#butLast()`](../collection/index#butLast())
- name: OrderedSet.clear()
  id: orderedset/index#clear()
  summary: Returns a new Set containing no values
  belongs_to: OrderedSet
  description: |-
    #### [clear()](index#clear())

    Returns a new Set containing no values.

    ``` ts
    clear(): this
    ```

    #### Inherited from

    [`Set#clear()`](../set/index#clear())

    #### Discussion

    Note: [`clear`](../set/index#clear()) can be used in [`withMutations`](../set/index#withMutations()).
- name: OrderedSet.concat()
  id: orderedset/index#concat()
  summary: Returns a new Collection with other collections concatenated to this one
  belongs_to: OrderedSet
  description: |-
    #### [concat()](index#concat())

    Returns a new Collection with other collections concatenated to this one.

    ``` ts
    concat<U>(...collections: Array<Iterable<U>>): Collection.Set<T | U>
    ```

    #### Inherited from

    [`Collection.Set#concat()`](../collection.set/index#concat())
- name: OrderedSet.count()
  id: orderedset/index#count()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [count()](index#count())

    ``` ts
    count(): number
    count(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#count()`](../collection/index#count())
- name: OrderedSet.countBy()
  id: orderedset/index#countBy()
  summary: Returns a Seq.Keyed of counts, grouped by the return value of the grouper function
  belongs_to: OrderedSet
  description: |-
    #### [countBy()](index#countBy())

    Returns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.

    ``` ts
    countBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Map<G, number>
    ```

    #### Inherited from

    [`Collection#countBy()`](../collection/index#countBy())

    #### Discussion

    Note: This is not a lazy operation.

    ### Search for value
- name: OrderedSet.delete()
  id: orderedset/index#delete()
  summary: Returns a new Set which excludes this value
  belongs_to: OrderedSet
  description: |-
    #### [delete()](index#delete())

    Returns a new Set which excludes this value.

    ``` ts
    delete(value: T): this
    ```

    #### Inherited from

    [`Set#delete()`](../set/index#delete())

    #### alias

    `remove()`

    #### Discussion

    Note: [`delete`](../set/index#delete()) can be used in [`withMutations`](../set/index#withMutations()).

    Note: [`delete`](../set/index#delete()) **cannot** be safely used in IE8, use [`remove`](../remove()/index) if supporting old browsers.
- name: OrderedSet.entries()
  id: orderedset/index#entries()
  summary: An iterator of this Collection's entries as [ key, value ] tuples
  belongs_to: OrderedSet
  description: |-
    #### [entries()](index#entries())

    An iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.

    ``` ts
    entries(): IterableIterator<[T, T]>
    ```

    #### Inherited from

    [`Collection#entries()`](../collection/index#entries())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.

    ### Collections (Seq)
- name: OrderedSet.entrySeq()
  id: orderedset/index#entrySeq()
  summary: Returns a new Seq.Indexed of [key, value] tuples
  belongs_to: OrderedSet
  description: |-
    #### [entrySeq()](index#entrySeq())

    Returns a new Seq.Indexed of \[key, value\] tuples.

    ``` ts
    entrySeq(): Seq.Indexed<[T, T]>
    ```

    #### Inherited from

    [`Collection#entrySeq()`](../collection/index#entrySeq())

    ### Side effects
- name: OrderedSet.equals()
  id: orderedset/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: OrderedSet
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Inherited from

    [`Collection#equals()`](../collection/index#equals())

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: OrderedSet.every()
  id: orderedset/index#every()
  summary: True if predicate returns true for all entries in the Collection
  belongs_to: OrderedSet
  description: |-
    #### [every()](index#every())

    True if `predicate` returns true for all entries in the Collection.

    ``` ts
    every(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#every()`](../collection/index#every())
- name: OrderedSet.filter()
  id: orderedset/index#filter()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [filter()](index#filter())

    ``` ts
    filter<F>(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): OrderedSet<F>
    filter(predicate: (value: T, key: T, iter: this) => unknown,context?: unknown): this
    ```

    #### Overrides

    [`Set#filter()`](../set/index#filter())
- name: OrderedSet.filterNot()
  id: orderedset/index#filterNot()
  summary: Returns a new Collection of the same type with only the entries for which the predicate function returns false
  belongs_to: OrderedSet
  description: |-
    #### [filterNot()](index#filterNot())

    Returns a new Collection of the same type with only the entries for which the `predicate` function returns false.

    ``` ts
    filterNot(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#filterNot()`](../collection/index#filterNot())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
    // Map { "a": 1, "c": 3 }run it
    ```

    Note: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.
- name: OrderedSet.find()
  id: orderedset/index#find()
  summary: Returns the first value for which the predicate returns true
  belongs_to: OrderedSet
  description: |-
    #### [find()](index#find())

    Returns the first value for which the `predicate` returns true.

    ``` ts
    find(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#find()`](../collection/index#find())
- name: OrderedSet.findEntry()
  id: orderedset/index#findEntry()
  summary: Returns the first [key, value] entry for which the predicate returns true
  belongs_to: OrderedSet
  description: |-
    #### [findEntry()](index#findEntry())

    Returns the first \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined
    ```

    #### Inherited from

    [`Collection#findEntry()`](../collection/index#findEntry())
- name: OrderedSet.findKey()
  id: orderedset/index#findKey()
  summary: Returns the key for which the predicate returns true
  belongs_to: OrderedSet
  description: |-
    #### [findKey()](index#findKey())

    Returns the key for which the `predicate` returns true.

    ``` ts
    findKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined
    ```

    #### Inherited from

    [`Collection#findKey()`](../collection/index#findKey())
- name: OrderedSet.findLast()
  id: orderedset/index#findLast()
  summary: Returns the last value for which the predicate returns true
  belongs_to: OrderedSet
  description: |-
    #### [findLast()](index#findLast())

    Returns the last value for which the `predicate` returns true.

    ``` ts
    findLast(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#findLast()`](../collection/index#findLast())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: OrderedSet.findLastEntry()
  id: orderedset/index#findLastEntry()
  summary: Returns the last [key, value] entry for which the predicate returns true
  belongs_to: OrderedSet
  description: |-
    #### [findLastEntry()](index#findLastEntry())

    Returns the last \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findLastEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined
    ```

    #### Inherited from

    [`Collection#findLastEntry()`](../collection/index#findLastEntry())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: OrderedSet.findLastKey()
  id: orderedset/index#findLastKey()
  summary: Returns the last key for which the predicate returns true
  belongs_to: OrderedSet
  description: |-
    #### [findLastKey()](index#findLastKey())

    Returns the last key for which the `predicate` returns true.

    ``` ts
    findLastKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined
    ```

    #### Inherited from

    [`Collection#findLastKey()`](../collection/index#findLastKey())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: OrderedSet.first()
  id: orderedset/index#first()
  summary: In case the Collection is not empty returns the first element of the Collection
  belongs_to: OrderedSet
  description: |-
    #### [first()](index#first())

    In case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    first<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#first()`](../collection/index#first())
- name: OrderedSet.flatMap()
  id: orderedset/index#flatMap()
  summary: Flat-maps the OrderedSet, returning a new OrderedSet
  belongs_to: OrderedSet
  description: |-
    #### [flatMap()](index#flatMap())

    Flat-maps the OrderedSet, returning a new OrderedSet.

    ``` ts
    flatMap<M>(mapper: (value: T, key: T, iter: this) => Iterable<M>,context?: unknown): OrderedSet<M>
    ```

    #### Overrides

    [`Set#flatMap()`](../set/index#flatMap())

    #### Discussion

    Similar to `set.map(...).flatten(true)`.
- name: OrderedSet.flatten()
  id: orderedset/index#flatten()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [flatten()](index#flatten())

    ``` ts
    flatten(depth?: number): Collection<unknown, unknown>
    flatten(shallow?: boolean): Collection<unknown, unknown>
    ```

    #### Inherited from

    [`Collection#flatten()`](../collection/index#flatten())

    ### Reducing a value
- name: OrderedSet.forEach()
  id: orderedset/index#forEach()
  summary: The sideEffect is executed for every entry in the Collection
  belongs_to: OrderedSet
  description: |-
    #### [forEach()](index#forEach())

    The `sideEffect` is executed for every entry in the Collection.

    ``` ts
    forEach(sideEffect: (value: T, key: T, iter: this) => unknown,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#forEach()`](../collection/index#forEach())

    #### Discussion

    Unlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).

    ### Creating subsets
- name: OrderedSet.get()
  id: orderedset/index#get()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [get()](index#get())

    ``` ts
    get<NSV>(key: T, notSetValue: NSV): T | NSV
    get(key: T): T | undefined
    ```

    #### Inherited from

    [`Collection#get()`](../collection/index#get())
- name: OrderedSet.getIn()
  id: orderedset/index#getIn()
  summary: Returns the value found by following a path of keys or indices through nested Collections
  belongs_to: OrderedSet
  description: |-
    #### [getIn()](index#getIn())

    Returns the value found by following a path of keys or indices through nested Collections.

    ``` ts
    getIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown
    ```

    #### Inherited from

    [`Collection#getIn()`](../collection/index#getIn())

    #### Discussion

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: [ { y: 123 } ] });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```
- name: OrderedSet.groupBy()
  id: orderedset/index#groupBy()
  summary: Returns a Collection.Keyed of Collection.Keyeds, grouped by the return value of the grouper function
  belongs_to: OrderedSet
  description: |-
    #### [groupBy()](index#groupBy())

    Returns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.

    ``` ts
    groupBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<T, T>>
    ```

    #### Inherited from

    [`Collection#groupBy()`](../collection/index#groupBy())

    #### Discussion

    Note: This is always an eager operation.

    ``` ts
    const { List, Map } = require('immutable')
    const listOfMaps = List([
      Map({ v: 0 }),
      Map({ v: 1 }),
      Map({ v: 1 }),
      Map({ v: 0 }),
      Map({ v: 2 })
    ])
    const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
    // Map {
    //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
    //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
    //   2: List [ Map{ "v": 2 } ],
    // }run it
    ```

    ### Transient changes
- name: OrderedSet.has()
  id: orderedset/index#has()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [has()](index#has())

    True if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    has(key: T): boolean
    ```

    #### Inherited from

    [`Collection#has()`](../collection/index#has())
- name: OrderedSet.hashCode()
  id: orderedset/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: OrderedSet
  description: |-
    #### [hashCode()](index#hashCode())

    Computes and returns the hashed identity for this Collection.

    ``` ts
    hashCode(): number
    ```

    #### Inherited from

    [`Collection#hashCode()`](../collection/index#hashCode())

    #### Discussion

    The [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.

    ``` ts
    const a = List([ 1, 2, 3 ]);
    const b = List([ 1, 2, 3 ]);
    assert.notStrictEqual(a, b); // different instances
    const set = Set([ a ]);
    assert.equal(set.has(b), true);run it
    ```

    If two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.

    ### Reading values
- name: OrderedSet.hasIn()
  id: orderedset/index#hasIn()
  summary: True if the result of following a path of keys or indices through nested Collections results in a set value
  belongs_to: OrderedSet
  description: |-
    #### [hasIn()](index#hasIn())

    True if the result of following a path of keys or indices through nested Collections results in a set value.

    ``` ts
    hasIn(searchKeyPath: Iterable<unknown>): boolean
    ```

    #### Inherited from

    [`Collection#hasIn()`](../collection/index#hasIn())

    ### Conversion to Collections
- name: OrderedSet.includes()
  id: orderedset/index#includes()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [includes()](index#includes())

    True if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    includes(value: T): boolean
    ```

    #### Inherited from

    [`Collection#includes()`](../collection/index#includes())

    #### alias

    `contains()`
- name: OrderedSet.intersect()
  id: orderedset/index#intersect()
  summary: Returns a Set which has removed any values not also contained within collections
  belongs_to: OrderedSet
  description: |-
    #### [intersect()](index#intersect())

    Returns a Set which has removed any values not also contained within `collections`.

    ``` ts
    intersect(...collections: Array<Iterable<T>>): this
    ```

    #### Inherited from

    [`Set#intersect()`](../set/index#intersect())

    #### Discussion

    Note: [`intersect`](../set/index#intersect()) can be used in [`withMutations`](../set/index#withMutations()).
- name: OrderedSet.isEmpty()
  id: orderedset/index#isEmpty()
  summary: Returns true if this Collection includes no values
  belongs_to: OrderedSet
  description: |-
    #### [isEmpty()](index#isEmpty())

    Returns true if this Collection includes no values.

    ``` ts
    isEmpty(): boolean
    ```

    #### Inherited from

    [`Collection#isEmpty()`](../collection/index#isEmpty())

    #### Discussion

    For some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.
- name: OrderedSet.isSubset()
  id: orderedset/index#isSubset()
  summary: True if iter includes every value in this Collection
  belongs_to: OrderedSet
  description: |-
    #### [isSubset()](index#isSubset())

    True if `iter` includes every value in this Collection.

    ``` ts
    isSubset(iter: Iterable<T>): boolean
    ```

    #### Inherited from

    [`Collection#isSubset()`](../collection/index#isSubset())
- name: OrderedSet.isSuperset()
  id: orderedset/index#isSuperset()
  summary: True if this Collection includes every value in iter
  belongs_to: OrderedSet
  description: "#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/OrderedSet/](https://immutable-js.com/docs/v4.2.1/OrderedSet/)"
- name: OrderedSet.join()
  id: orderedset/index#join()
  summary: Joins values together as a string, inserting a separator between each
  belongs_to: OrderedSet
  description: |-
    #### [join()](index#join())

    Joins values together as a string, inserting a separator between each. The default separator is `","`.

    ``` ts
    join(separator?: string): string
    ```

    #### Inherited from

    [`Collection#join()`](../collection/index#join())
- name: OrderedSet.keyOf()
  id: orderedset/index#keyOf()
  summary: Returns the key associated with the search value, or undefined
  belongs_to: OrderedSet
  description: |-
    #### [keyOf()](index#keyOf())

    Returns the key associated with the search value, or undefined.

    ``` ts
    keyOf(searchValue: T): T | undefined
    ```

    #### Inherited from

    [`Collection#keyOf()`](../collection/index#keyOf())
- name: OrderedSet.keys()
  id: orderedset/index#keys()
  summary: An iterator of this Collection's keys
  belongs_to: OrderedSet
  description: |-
    #### [keys()](index#keys())

    An iterator of this [`Collection`](../collection/index)'s keys.

    ``` ts
    keys(): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection#keys()`](../collection/index#keys())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.
- name: OrderedSet.keySeq()
  id: orderedset/index#keySeq()
  summary: Returns a new Seq.Indexed of the keys of this Collection, discarding values
  belongs_to: OrderedSet
  description: |-
    #### [keySeq()](index#keySeq())

    Returns a new Seq.Indexed of the keys of this Collection, discarding values.

    ``` ts
    keySeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#keySeq()`](../collection/index#keySeq())
- name: OrderedSet.last()
  id: orderedset/index#last()
  summary: In case the Collection is not empty returns the last element of the Collection
  belongs_to: OrderedSet
  description: |-
    #### [last()](index#last())

    In case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    last<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#last()`](../collection/index#last())

    ### Reading deep values
- name: OrderedSet.lastKeyOf()
  id: orderedset/index#lastKeyOf()
  summary: Returns the last key associated with the search value, or undefined
  belongs_to: OrderedSet
  description: |-
    #### [lastKeyOf()](index#lastKeyOf())

    Returns the last key associated with the search value, or undefined.

    ``` ts
    lastKeyOf(searchValue: T): T | undefined
    ```

    #### Inherited from

    [`Collection#lastKeyOf()`](../collection/index#lastKeyOf())
- name: OrderedSet.map()
  id: orderedset/index#map()
  summary: Returns a new Set with values passed through a mapper function
  belongs_to: OrderedSet
  description: |-
    #### [map()](index#map())

    Returns a new Set with values passed through a `mapper` function.

    ``` ts
    map<M>(mapper: (value: T, key: T, iter: this) => M,context?: unknown): OrderedSet<M>
    ```

    #### Overrides

    [`Set#map()`](../set/index#map())

    #### Example

    ``` ts
    OrderedSet([ 1, 2 ]).map(x => 10 * x)
    // OrderedSet [10, 20]
    ```
- name: OrderedSet.max()
  id: orderedset/index#max()
  summary: Returns the maximum value in this collection
  belongs_to: OrderedSet
  description: |-
    #### [max()](index#max())

    Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    max(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#max()`](../collection/index#max())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: OrderedSet.maxBy()
  id: orderedset/index#maxBy()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [maxBy()](index#maxBy())

    Like [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    maxBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#maxBy()`](../collection/index#maxBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it
    ```
- name: OrderedSet.min()
  id: orderedset/index#min()
  summary: Returns the minimum value in this collection
  belongs_to: OrderedSet
  description: |-
    #### [min()](index#min())

    Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    min(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#min()`](../collection/index#min())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: OrderedSet.minBy()
  id: orderedset/index#minBy()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [minBy()](index#minBy())

    Like [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    minBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#minBy()`](../collection/index#minBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it
    ```

    ### Comparison
- name: OrderedSet.OrderedSet()
  id: orderedset/index#OrderedSet()
  summary: Create a new immutable OrderedSet containing the values of the provided collection-like
  belongs_to: OrderedSet
  description: |-
    #### [OrderedSet()](index#OrderedSet())

    Create a new immutable OrderedSet containing the values of the provided collection-like.

    ``` ts
    OrderedSet<T>(collection?: Iterable<T> | ArrayLike<T>): OrderedSet<T>
    ```

    #### Discussion

    Note: [`OrderedSet`](index) is a factory function and not a class, and does not use the `new` keyword during construction.

    ### Static methods
- name: OrderedSet.OrderedSet.fromKeys()
  id: orderedset/index#fromKeys()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [OrderedSet.fromKeys()](index#fromKeys())

    ``` ts
    OrderedSet.fromKeys<T>(iter: Collection<T, unknown>): OrderedSet<T>
    OrderedSet.fromKeys(obj: {[key: string]: unknown}): OrderedSet<string>
    ```

    ### Members
- name: OrderedSet.OrderedSet.isOrderedSet()
  id: orderedset/index#isOrderedSet()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [OrderedSet.isOrderedSet()](index#isOrderedSet())

    ``` ts
    OrderedSet.isOrderedSet(maybeOrderedSet: unknown): boolean
    ```
- name: OrderedSet.OrderedSet.of()
  id: orderedset/index#of()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [OrderedSet.of()](index#of())

    ``` ts
    OrderedSet.of<T>(...values: Array<T>): OrderedSet<T>
    ```
- name: OrderedSet.partition()
  id: orderedset/index#partition()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [partition()](index#partition())

    ``` ts
    partition<F, C>(predicate: (this: C, value: T, key: T, iter: this) => boolean,context?: C): [OrderedSet<T>, OrderedSet<F>]
    partition<C>(predicate: (this: C, value: T, key: T, iter: this) => unknown,context?: C): [this, this]
    ```

    #### Overrides

    [`Set#partition()`](../set/index#partition())
- name: OrderedSet.reduce()
  id: orderedset/index#reduce()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [reduce()](index#reduce())

    ``` ts
    reduce<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R
    reduce<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduce()`](../collection/index#reduce())
- name: OrderedSet.reduceRight()
  id: orderedset/index#reduceRight()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [reduceRight()](index#reduceRight())

    ``` ts
    reduceRight<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R
    reduceRight<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduceRight()`](../collection/index#reduceRight())
- name: OrderedSet.rest()
  id: orderedset/index#rest()
  summary: Returns a new Collection of the same type containing all entries except the first
  belongs_to: OrderedSet
  description: |-
    #### [rest()](index#rest())

    Returns a new Collection of the same type containing all entries except the first.

    ``` ts
    rest(): this
    ```

    #### Inherited from

    [`Collection#rest()`](../collection/index#rest())
- name: OrderedSet.reverse()
  id: orderedset/index#reverse()
  summary: Returns a new Collection of the same type in reverse order
  belongs_to: OrderedSet
  description: |-
    #### [reverse()](index#reverse())

    Returns a new Collection of the same type in reverse order.

    ``` ts
    reverse(): this
    ```

    #### Inherited from

    [`Collection#reverse()`](../collection/index#reverse())
- name: OrderedSet.size
  id: orderedset/index#size
  summary: The number of items in this OrderedSet
  belongs_to: OrderedSet
  description: |-
    #### [size](index#size)

    The number of items in this OrderedSet.

    ``` ts
    size: number
    ```

    #### Overrides

    [`Set#size`](../set/index#size)

    ### Persistent changes
- name: OrderedSet.skip()
  id: orderedset/index#skip()
  summary: Returns a new Collection of the same type which excludes the first amount entries from this Collection
  belongs_to: OrderedSet
  description: |-
    #### [skip()](index#skip())

    Returns a new Collection of the same type which excludes the first `amount` entries from this Collection.

    ``` ts
    skip(amount: number): this
    ```

    #### Inherited from

    [`Collection#skip()`](../collection/index#skip())
- name: OrderedSet.skipLast()
  id: orderedset/index#skipLast()
  summary: Returns a new Collection of the same type which excludes the last amount entries from this Collection
  belongs_to: OrderedSet
  description: |-
    #### [skipLast()](index#skipLast())

    Returns a new Collection of the same type which excludes the last `amount` entries from this Collection.

    ``` ts
    skipLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#skipLast()`](../collection/index#skipLast())
- name: OrderedSet.skipUntil()
  id: orderedset/index#skipUntil()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns true
  belongs_to: OrderedSet
  description: |-
    #### [skipUntil()](index#skipUntil())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns true.

    ``` ts
    skipUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipUntil()`](../collection/index#skipUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipUntil(x => x.match(/hat/))
    // List [ "hat", "god" ]run it
    ```
- name: OrderedSet.skipWhile()
  id: orderedset/index#skipWhile()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns false
  belongs_to: OrderedSet
  description: |-
    #### [skipWhile()](index#skipWhile())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns false.

    ``` ts
    skipWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipWhile()`](../collection/index#skipWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipWhile(x => x.match(/g/))
    // List [ "cat", "hat", "god" ]run it
    ```
- name: OrderedSet.slice()
  id: orderedset/index#slice()
  summary: Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end
  belongs_to: OrderedSet
  description: |-
    #### [slice()](index#slice())

    Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.

    ``` ts
    slice(begin?: number, end?: number): this
    ```

    #### Inherited from

    [`Collection#slice()`](../collection/index#slice())

    #### Discussion

    If begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.

    If end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.

    If the requested slice is equivalent to the current Collection, then it will return itself.
- name: OrderedSet.some()
  id: orderedset/index#some()
  summary: True if predicate returns true for any entry in the Collection
  belongs_to: OrderedSet
  description: |-
    #### [some()](index#some())

    True if `predicate` returns true for any entry in the Collection.

    ``` ts
    some(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#some()`](../collection/index#some())
- name: OrderedSet.sort()
  id: orderedset/index#sort()
  summary: Returns a new Collection of the same type which includes the same entries, stably sorted by using a comparator
  belongs_to: OrderedSet
  description: |-
    #### [sort()](index#sort())

    Returns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.

    ``` ts
    sort(comparator?: (valueA: T, valueB: T) => number): this
    ```

    #### Inherited from

    [`Collection#sort()`](../collection/index#sort())

    #### Discussion

    If a `comparator` is not provided, a default comparator uses `<` and `>`.

    `comparator(valueA, valueB)`:

    - Returns `0` if the elements should not be swapped.
    - Returns `-1` (or any negative number) if `valueA` comes before `valueB`
    - Returns `1` (or any positive number) if `valueA` comes after `valueB`
    - Is pure, i.e. it must always return the same value for the same pair of values.

    When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.

    ``` ts
    const { Map } = require('immutable')
    Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
      if (a < b) { return -1; }
      if (a > b) { return 1; }
      if (a === b) { return 0; }
    });
    // OrderedMap { "a": 1, "b": 2, "c": 3 }run it
    ```

    Note: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: OrderedSet.sortBy()
  id: orderedset/index#sortBy()
  summary: 'Note: sortBy() Always returns a new instance, even if the original was already sorted'
  belongs_to: OrderedSet
  description: |-
    #### [sortBy()](index#sortBy())

    Like [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:

    ``` ts
    sortBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this
    ```

    #### Inherited from

    [`Collection#sortBy()`](../collection/index#sortBy())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const beattles = Map({
      John: { name: "Lennon" },
      Paul: { name: "McCartney" },
      George: { name: "Harrison" },
      Ringo: { name: "Starr" },
    });
    beattles.sortBy(member => member.name);run it
    ```

    Note: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: OrderedSet.subtract()
  id: orderedset/index#subtract()
  summary: Returns a Set excluding any values contained within collections
  belongs_to: OrderedSet
  description: |-
    #### [subtract()](index#subtract())

    Returns a Set excluding any values contained within `collections`.

    ``` ts
    subtract(...collections: Array<Iterable<T>>): this
    ```

    #### Inherited from

    [`Set#subtract()`](../set/index#subtract())

    #### Discussion

    ``` ts
    const { OrderedSet } = require('immutable')
    OrderedSet([ 1, 2, 3 ]).subtract([1, 3])
    // OrderedSet [2]run it
    ```

    Note: [`subtract`](../set/index#subtract()) can be used in [`withMutations`](../set/index#withMutations()).
- name: OrderedSet.take()
  id: orderedset/index#take()
  summary: Returns a new Collection of the same type which includes the first amount entries from this Collection
  belongs_to: OrderedSet
  description: |-
    #### [take()](index#take())

    Returns a new Collection of the same type which includes the first `amount` entries from this Collection.

    ``` ts
    take(amount: number): this
    ```

    #### Inherited from

    [`Collection#take()`](../collection/index#take())
- name: OrderedSet.takeLast()
  id: orderedset/index#takeLast()
  summary: Returns a new Collection of the same type which includes the last amount entries from this Collection
  belongs_to: OrderedSet
  description: |-
    #### [takeLast()](index#takeLast())

    Returns a new Collection of the same type which includes the last `amount` entries from this Collection.

    ``` ts
    takeLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#takeLast()`](../collection/index#takeLast())
- name: OrderedSet.takeUntil()
  id: orderedset/index#takeUntil()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns false
  belongs_to: OrderedSet
  description: |-
    #### [takeUntil()](index#takeUntil())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.

    ``` ts
    takeUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeUntil()`](../collection/index#takeUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeUntil(x => x.match(/at/))
    // List [ "dog", "frog" ]run it
    ```

    ### Combination
- name: OrderedSet.takeWhile()
  id: orderedset/index#takeWhile()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns true
  belongs_to: OrderedSet
  description: |-
    #### [takeWhile()](index#takeWhile())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.

    ``` ts
    takeWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeWhile()`](../collection/index#takeWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeWhile(x => x.match(/o/))
    // List [ "dog", "frog" ]run it
    ```
- name: OrderedSet.toArray()
  id: orderedset/index#toArray()
  summary: Shallowly converts this collection to an Array
  belongs_to: OrderedSet
  description: |-
    #### [toArray()](index#toArray())

    Shallowly converts this collection to an Array.

    ``` ts
    toArray(): Array<T>
    ```

    #### Inherited from

    [`Collection.Set#toArray()`](../collection.set/index#toArray())
- name: OrderedSet.toIndexedSeq()
  id: orderedset/index#toIndexedSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: OrderedSet
  description: |-
    #### [toIndexedSeq()](index#toIndexedSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    toIndexedSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())
- name: OrderedSet.toJS()
  id: orderedset/index#toJS()
  summary: Deeply converts this Set collection to equivalent native JavaScript Array
  belongs_to: OrderedSet
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Set collection to equivalent native JavaScript Array.

    ``` ts
    toJS(): Array<DeepCopy<T>>
    ```

    #### Inherited from

    [`Collection.Set#toJS()`](../collection.set/index#toJS())
- name: OrderedSet.toJSON()
  id: orderedset/index#toJSON()
  summary: Shallowly converts this Set collection to equivalent native JavaScript Array
  belongs_to: OrderedSet
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Set collection to equivalent native JavaScript Array.

    ``` ts
    toJSON(): Array<T>
    ```

    #### Inherited from

    [`Collection.Set#toJSON()`](../collection.set/index#toJSON())
- name: OrderedSet.toKeyedSeq()
  id: orderedset/index#toKeyedSeq()
  summary: Returns a Seq.Keyed from this Collection where indices are treated as keys
  belongs_to: OrderedSet
  description: |-
    #### [toKeyedSeq()](index#toKeyedSeq())

    Returns a Seq.Keyed from this Collection where indices are treated as keys.

    ``` ts
    toKeyedSeq(): Seq.Keyed<T, T>
    ```

    #### Inherited from

    [`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())

    #### Discussion

    This is useful if you want to operate on an Collection.Indexed and preserve the \[index, value\] pairs.

    The returned Seq will have identical iteration order as this Collection.

    ``` ts
    const { Seq } = require('immutable')
    const indexedSeq = Seq([ 'A', 'B', 'C' ])
    // Seq [ "A", "B", "C" ]
    indexedSeq.filter(v => v === 'B')
    // Seq [ "B" ]
    const keyedSeq = indexedSeq.toKeyedSeq()
    // Seq { 0: "A", 1: "B", 2: "C" }
    keyedSeq.filter(v => v === 'B')
    // Seq { 1: "B" }run it
    ```
- name: OrderedSet.toList()
  id: orderedset/index#toList()
  summary: Converts this Collection to a List, discarding keys
  belongs_to: OrderedSet
  description: |-
    #### [toList()](index#toList())

    Converts this Collection to a List, discarding keys.

    ``` ts
    toList(): List<T>
    ```

    #### Inherited from

    [`Collection#toList()`](../collection/index#toList())

    #### Discussion

    This is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.

    ``` ts
    const { Map, List } = require('immutable')
    var myMap = Map({ a: 'Apple', b: 'Banana' })
    List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
    myMap.toList() // List [ "Apple", "Banana" ]run it
    ```
- name: OrderedSet.toMap()
  id: orderedset/index#toMap()
  summary: Converts this Collection to a Map, Throws if keys are not hashable
  belongs_to: OrderedSet
  description: |-
    #### [toMap()](index#toMap())

    Converts this Collection to a Map, Throws if keys are not hashable.

    ``` ts
    toMap(): Map<T, T>
    ```

    #### Inherited from

    [`Collection#toMap()`](../collection/index#toMap())

    #### Discussion

    Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: OrderedSet.toObject()
  id: orderedset/index#toObject()
  summary: Shallowly converts this Collection to an Object
  belongs_to: OrderedSet
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Collection to an Object.

    ``` ts
    toObject(): {[key: string]: T}
    ```

    #### Inherited from

    [`Collection#toObject()`](../collection/index#toObject())

    #### Discussion

    Converts keys to Strings.

    ### Conversion to Seq
- name: OrderedSet.toOrderedMap()
  id: orderedset/index#toOrderedMap()
  summary: Converts this Collection to a Map, maintaining the order of iteration
  belongs_to: OrderedSet
  description: |-
    #### [toOrderedMap()](index#toOrderedMap())

    Converts this Collection to a Map, maintaining the order of iteration.

    ``` ts
    toOrderedMap(): OrderedMap<T, T>
    ```

    #### Inherited from

    [`Collection#toOrderedMap()`](../collection/index#toOrderedMap())

    #### Discussion

    Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: OrderedSet.toOrderedSet()
  id: orderedset/index#toOrderedSet()
  summary: Converts this Collection to a Set, maintaining the order of iteration and discarding keys
  belongs_to: OrderedSet
  description: |-
    #### [toOrderedSet()](index#toOrderedSet())

    Converts this Collection to a Set, maintaining the order of iteration and discarding keys.

    ``` ts
    toOrderedSet(): OrderedSet<T>
    ```

    #### Inherited from

    [`Collection#toOrderedSet()`](../collection/index#toOrderedSet())

    #### Discussion

    Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.
- name: OrderedSet.toSeq()
  id: orderedset/index#toSeq()
  summary: Returns Seq.Set
  belongs_to: OrderedSet
  description: |-
    #### [toSeq()](index#toSeq())

    Returns Seq.Set.

    ``` ts
    toSeq(): Seq.Set<T>
    ```

    #### Inherited from

    [`Collection.Set#toSeq()`](../collection.set/index#toSeq())
- name: OrderedSet.toSet()
  id: orderedset/index#toSet()
  summary: Converts this Collection to a Set, discarding keys
  belongs_to: OrderedSet
  description: |-
    #### [toSet()](index#toSet())

    Converts this Collection to a Set, discarding keys. Throws if values are not hashable.

    ``` ts
    toSet(): Set<T>
    ```

    #### Inherited from

    [`Collection#toSet()`](../collection/index#toSet())

    #### Discussion

    Note: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.
- name: OrderedSet.toSetSeq()
  id: orderedset/index#toSetSeq()
  summary: Returns a Seq.Set of the values of this Collection, discarding keys
  belongs_to: OrderedSet
  description: |-
    #### [toSetSeq()](index#toSetSeq())

    Returns a Seq.Set of the values of this Collection, discarding keys.

    ``` ts
    toSetSeq(): Seq.Set<T>
    ```

    #### Inherited from

    [`Collection#toSetSeq()`](../collection/index#toSetSeq())

    ### Value equality
- name: OrderedSet.toStack()
  id: orderedset/index#toStack()
  summary: Converts this Collection to a Stack, discarding keys
  belongs_to: OrderedSet
  description: |-
    #### [toStack()](index#toStack())

    Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.

    ``` ts
    toStack(): Stack<T>
    ```

    #### Inherited from

    [`Collection#toStack()`](../collection/index#toStack())

    #### Discussion

    Note: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.

    ### Iterators
- name: OrderedSet.union()
  id: orderedset/index#union()
  summary: Returns an OrderedSet including any value from collections that does not already exist in this OrderedSet
  belongs_to: OrderedSet
  description: |-
    #### [union()](index#union())

    Returns an OrderedSet including any value from `collections` that does not already exist in this OrderedSet.

    ``` ts
    union<C>(...collections: Array<Iterable<C>>): OrderedSet<T | C>
    ```

    #### Overrides

    [`Set#union()`](../set/index#union())

    #### alias

    `merge()`

    #### alias

    `concat()`

    #### Discussion

    Note: [`union`](index#union()) can be used in [`withMutations`](index#withMutations()).
- name: OrderedSet.update()
  id: orderedset/index#update()
  summary: This can be very useful as a way to "chain" a normal function into a sequence of methods
  belongs_to: OrderedSet
  description: |-
    #### [update()](index#update())

    This can be very useful as a way to "chain" a normal function into a sequence of methods. RxJS calls this "let" and lodash calls it "thru".

    ``` ts
    update<R>(updater: (value: this) => R): R
    ```

    #### Inherited from

    [`Collection#update()`](../collection/index#update())

    #### Discussion

    For example, to sum a Seq after mapping and filtering:

    ``` ts
    const { Seq } = require('immutable')

    function sum(collection) {
      return collection.reduce((sum, x) => sum + x, 0)
    }
    Seq([ 1, 2, 3 ])
      .map(x => x + 1)
      .filter(x => x % 2 === 0)
      .update(sum)
    // 6run it
    ```

    ### Sequence algorithms
- name: OrderedSet.values()
  id: orderedset/index#values()
  summary: An iterator of this Collection's values
  belongs_to: OrderedSet
  description: |-
    #### [values()](index#values())

    An iterator of this [`Collection`](../collection/index)'s values.

    ``` ts
    values(): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection#values()`](../collection/index#values())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.
- name: OrderedSet.valueSeq()
  id: orderedset/index#valueSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: OrderedSet
  description: |-
    #### [valueSeq()](index#valueSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    valueSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#valueSeq()`](../collection/index#valueSeq())
- name: OrderedSet.wasAltered()
  id: orderedset/index#wasAltered()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [wasAltered()](index#wasAltered())

    ``` ts
    wasAltered(): boolean
    ```

    #### Inherited from

    [`Set#wasAltered()`](../set/index#wasAltered())

    #### see

    [`Map#wasAltered`](../map/index#wasAltered())
- name: OrderedSet.withMutations()
  id: orderedset/index#withMutations()
  summary: 'Note: Not all methods can be used on a mutable collection or within withMutations! Check the documentation for each method to see if it mentions being safe to use in withMutations'
  belongs_to: OrderedSet
  description: |-
    #### [withMutations()](index#withMutations())

    Note: Not all methods can be used on a mutable collection or within [`withMutations`](../set/index#withMutations())! Check the documentation for each method to see if it mentions being safe to use in [`withMutations`](../set/index#withMutations()).

    ``` ts
    withMutations(mutator: (mutable: this) => unknown): this
    ```

    #### Inherited from

    [`Set#withMutations()`](../set/index#withMutations())

    #### see

    [`Map#withMutations`](../map/index#withMutations())
- name: OrderedSet.zip()
  id: orderedset/index#zip()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [zip()](index#zip())

    ``` ts
    zip<U>(other: Collection<unknown, U>): OrderedSet<[T, U]>
    zip<U, V>(other1: Collection<unknown, U>,other2: Collection<unknown, V>): OrderedSet<[T, U, V]>
    zip(...collections: Array<Collection<unknown, unknown>>): OrderedSet<unknown>
    ```
- name: OrderedSet.zipAll()
  id: orderedset/index#zipAll()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [zipAll()](index#zipAll())

    ``` ts
    zipAll<U>(other: Collection<unknown, U>): OrderedSet<[T, U]>
    zipAll<U, V>(other1: Collection<unknown, U>,other2: Collection<unknown, V>): OrderedSet<[T, U, V]>
    zipAll(...collections: Array<Collection<unknown, unknown>>): OrderedSet<unknown>
    ```
- name: OrderedSet.zipWith()
  id: orderedset/index#zipWith()
  summary: null
  belongs_to: OrderedSet
  description: |-
    #### [zipWith()](index#zipWith())

    ``` ts
    zipWith<U, Z>(zipper: (value: T, otherValue: U) => Z,otherCollection: Collection<unknown, U>): OrderedSet<Z>
    zipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z,otherCollection: Collection<unknown, U>,thirdCollection: Collection<unknown, V>): OrderedSet<Z>
    zipWith<Z>(zipper: (...values: Array<unknown>) => Z,...collections: Array<Collection<unknown, unknown>>): OrderedSet<Z>
    ```
- name: Range()
  id: range()/index
  summary: Returns a Seq.Indexed of numbers from start (inclusive) to end (exclusive), by step, where start defaults to 0, step to 1, and end to infinity
  description: "# Range()\n\nReturns a Seq.Indexed of numbers from `start` (inclusive) to `end` (exclusive), by `step`, where `start` defaults to 0, `step` to 1, and `end` to infinity. When `start` is equal to `end`, returns empty range.\n\n``` ts\nRange(start?: number, end?: number, step?: number): Seq.Indexed<number>\n```\n\n#### Discussion\n\nNote: [`Range`](index) is a factory function and not a class, and does not use the `new` keyword during construction.\n\n``` ts\nconst { Range } = require('immutable')\nRange() // [ 0, 1, 2, 3, ... ]\nRange(10) // [ 10, 11, 12, 13, ... ]\nRange(10, 15) // [ 10, 11, 12, 13, 14 ]\nRange(10, 30, 5) // [ 10, 15, 20, 25 ]\nRange(30, 10, 5) // [ 30, 25, 20, 15 ]\nRange(30, 30, 5) // []\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Range()/](https://immutable-js.com/docs/v4.2.1/Range()/)"
- name: Record
  id: record/index
  summary: A record is similar to a JS object, but enforces a specific set of allowed string keys, and has default values
  description: "# Record\n\nA record is similar to a JS object, but enforces a specific set of allowed string keys, and has default values.\n\n``` ts\ntype Record<TProps>\n```\n\n#### Discussion\n\nThe [`Record()`](index) function produces new Record Factories, which when called create Record instances.\n\n``` ts\nconst { Record } = require('immutable')\nconst ABRecord = Record({ a: 1, b: 2 })\nconst myRecord = ABRecord({ b: 3 })\n```\n\nRecords always have a value for the keys they define. [`remove`](../remove()/index)ing a key from a record simply resets it to the default value for that key.\n\n``` ts\nmyRecord.get('a') // 1\nmyRecord.get('b') // 3\nconst myRecordWithoutB = myRecord.remove('b')\nmyRecordWithoutB.get('b') // 2\n```\n\nValues provided to the constructor not found in the Record type will be ignored. For example, in this case, ABRecord is provided a key \"x\" even though only \"a\" and \"b\" have been defined. The value for \"x\" will be ignored for this record.\n\n``` ts\nconst myRecord = ABRecord({ b: 3, x: 10 })\nmyRecord.get('x') // undefined\n```\n\nBecause Records have a known set of string keys, property get access works as expected, however property sets will throw an Error.\n\nNote: IE8 does not support property access. Only use [`get()`](index#get()) when supporting IE8.\n\n``` ts\nmyRecord.b // 3\nmyRecord.b = 5 // throws Error\n```\n\nRecord Types can be extended as well, allowing for custom methods on your Record. This is not a common pattern in functional environments, but is in many JS programs.\n\nHowever Record Types are more restricted than typical JavaScript classes. They do not use a class constructor, which also means they cannot use class properties (since those are technically part of a constructor).\n\nWhile Record Types can be syntactically created with the JavaScript `class` form, the resulting Record function is actually a factory function, not a class constructor. Even though Record Types are not classes, JavaScript currently requires the use of `new` when creating new Record instances if they are defined as a `class`.\n\n``` ts\nclass ABRecord extends Record({ a: 1, b: 2 }) {\n  getAB() {\n    return this.a + this.b;\n  }\n}\n\nvar myRecord = new ABRecord({b: 3})\nmyRecord.getAB() // 4\n```\n\n**Flow Typing Records:**\n\nImmutable.js exports two Flow types designed to make it easier to use Records with flow typed code, `RecordOf<TProps>` and `RecordFactory<TProps>`.\n\nWhen defining a new kind of Record factory function, use a flow type that describes the values the record contains along with `RecordFactory<TProps>`. To type instances of the Record (which the factory function returns), use `RecordOf<TProps>`.\n\nTypically, new Record definitions will export both the Record factory function as well as the Record instance type for use in other code.\n\n``` ts\nimport type { RecordFactory, RecordOf } from 'immutable';\n\n// Use RecordFactory<TProps> for defining new Record factory functions.\ntype Point3DProps = { x: number, y: number, z: number };\nconst defaultValues: Point3DProps = { x: 0, y: 0, z: 0 };\nconst makePoint3D: RecordFactory<Point3DProps> = Record(defaultValues);\nexport makePoint3D;\n\n// Use RecordOf<T> for defining new instances of that Record.\nexport type Point3D = RecordOf<Point3DProps>;\nconst some3DPoint: Point3D = makePoint3D({ x: 10, y: 20, z: 30 });\n```\n\n**Flow Typing Record Subclasses:**\n\nRecords can be subclassed as a means to add additional methods to Record instances. This is generally discouraged in favor of a more functional API, since Subclasses have some minor overhead. However the ability to create a rich API on Record types can be quite valuable.\n\nWhen using Flow to type Subclasses, do not use `RecordFactory<TProps>`, instead apply the props type when subclassing:\n\n``` ts\ntype PersonProps = {name: string, age: number};\nconst defaultValues: PersonProps = {name: 'Aristotle', age: 2400};\nconst PersonRecord = Record(defaultValues);\nclass Person extends PersonRecord<PersonProps> {\n  getName(): string {\n    return this.get('name')\n  }\n\n  setName(name: string): this {\n    return this.set('name', name);\n  }\n}\n```\n\n**Choosing Records vs plain JavaScript objects**\n\nRecords offer a persistently immutable alternative to plain JavaScript objects, however they're not required to be used within Immutable.js collections. In fact, the deep-access and deep-updating functions like [`getIn()`](index#getIn()) and [`setIn()`](index#setIn()) work with plain JavaScript Objects as well.\n\nDeciding to use Records or Objects in your application should be informed by the tradeoffs and relative benefits of each:\n\n- *Runtime immutability*: plain JS objects may be carefully treated as immutable, however Record instances will *throw* if attempted to be mutated directly. Records provide this additional guarantee, however at some marginal runtime cost. While JS objects are mutable by nature, the use of type-checking tools like [Flow](https://medium.com/@gcanti/immutability-with-flow-faa050a1aef4) can help gain confidence in code written to favor immutability.\n\n- *Value equality*: Records use value equality when compared with [`is()`](../is()/index) or `record.equals()`. That is, two Records with the same keys and values are equal. Plain objects use *reference equality*. Two objects with the same keys and values are not equal since they are different objects. This is important to consider when using objects as keys in a [`Map`](../map/index) or values in a [`Set`](../set/index), which use equality when retrieving values.\n\n- *API methods*: Records have a full featured API, with methods like `.getIn()`, and `.equals()`. These can make working with these values easier, but comes at the cost of not allowing keys with those names.\n\n- *Default values*: Records provide default values for every key, which can be useful when constructing Records with often unchanging values. However default values can make using Flow and TypeScript more laborious.\n\n- *Serialization*: Records use a custom internal representation to efficiently store and update their values. Converting to and from this form isn't free. If converting Records to plain objects is common, consider sticking with plain objects to begin with.\n\n### Construction\n\n#### [Record()](index#Record())\n\nUnlike other types in Immutable.js, the [`Record()`](index) function creates a new Record Factory, which is a function that creates Record instances.\n\n``` ts\nRecord<TProps>(defaultValues: TProps, name?: string): Record.Factory<TProps>\n```\n\n#### Discussion\n\nSee above for examples of using [`Record()`](index).\n\nNote: [`Record`](index) is a factory function and not a class, and does not use the `new` keyword during construction.\n\n### Static methods\n\n#### [Record.isRecord()](index#isRecord())\n\n``` ts\nRecord.isRecord(maybeRecord: unknown): boolean\n```\n\n#### [Record.getDescriptiveName()](index#getDescriptiveName())\n\n``` ts\nRecord.getDescriptiveName(record: Record<any>): string\n```\n\n### Reading values\n\n#### [has()](index#has())\n\n``` ts\nhas(key: string): boolean\n```\n\n#### [get()](index#get())\n\n``` ts\nget<K>(key: K, notSetValue?: unknown): TProps,[K]\nget<T>(key: string, notSetValue: T): T\n```\n\n### Reading deep values\n\n#### [hasIn()](index#hasIn())\n\n``` ts\nhasIn(keyPath: Iterable<unknown>): boolean\n```\n\n#### [getIn()](index#getIn())\n\n``` ts\ngetIn(keyPath: Iterable<unknown>): unknown\n```\n\n### Value equality\n\n#### [equals()](index#equals())\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### [hashCode()](index#hashCode())\n\n``` ts\nhashCode(): number\n```\n\n### Persistent changes\n\n#### [set()](index#set())\n\n``` ts\nset<K>(key: K, value: TProps,[K]): this\n```\n\n#### [update()](index#update())\n\n``` ts\nupdate<K>(key: K, updater: (value: TProps,[K]) => TProps,[K]): this\n```\n\n#### [merge()](index#merge())\n\n``` ts\nmerge(...collections: Array<Partial<TProps> | Iterable<[string, unknown]>>): this\n```\n\n#### [mergeDeep()](index#mergeDeep())\n\n``` ts\nmergeDeep(...collections: Array<Partial<TProps> | Iterable<[string, unknown]>>): this\n```\n\n#### [mergeWith()](index#mergeWith())\n\n``` ts\nmergeWith(merger: (oldVal: unknown, newVal: unknown, key: keyof TProps) => unknown,...collections: Array<Partial<TProps> | Iterable<[string, unknown]>>): this\n```\n\n#### [mergeDeepWith()](index#mergeDeepWith())\n\n``` ts\nmergeDeepWith(merger: (oldVal: unknown, newVal: unknown, key: unknown) => unknown,...collections: Array<Partial<TProps> | Iterable<[string, unknown]>>): this\n```\n\n#### [delete()](index#delete())\n\nReturns a new instance of this Record type with the value for the specific key set to its default value.\n\n``` ts\ndelete<K>(key: K): this\n```\n\n#### alias\n\n`remove()`\n\n#### [clear()](index#clear())\n\nReturns a new instance of this Record type with all values set to their default values.\n\n``` ts\nclear(): this\n```\n\n### Deep persistent changes\n\n#### [setIn()](index#setIn())\n\n``` ts\nsetIn(keyPath: Iterable<unknown>, value: unknown): this\n```\n\n#### [updateIn()](index#updateIn())\n\n``` ts\nupdateIn(keyPath: Iterable<unknown>, updater: (value: unknown) => unknown): this\n```\n\n#### [mergeIn()](index#mergeIn())\n\n``` ts\nmergeIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this\n```\n\n#### [mergeDeepIn()](index#mergeDeepIn())\n\n``` ts\nmergeDeepIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this\n```\n\n#### [deleteIn()](index#deleteIn())\n\n``` ts\ndeleteIn(keyPath: Iterable<unknown>): this\n```\n\n#### alias\n\n`removeIn()`\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Record to equivalent native JavaScript Object.\n\n``` ts\ntoJS(): DeepCopy<TProps>\n```\n\n#### Discussion\n\nNote: This method may not be overridden. Objects with custom serialization to plain JS may override toJSON() instead.\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Record to equivalent native JavaScript Object.\n\n``` ts\ntoJSON(): TProps\n```\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Record to equivalent JavaScript Object.\n\n``` ts\ntoObject(): TProps\n```\n\n### Transient changes\n\n#### [withMutations()](index#withMutations())\n\nNote: Not all methods can be used on a mutable collection or within [`withMutations`](index#withMutations())! Only [`set`](index#set()) may be used mutatively.\n\n``` ts\nwithMutations(mutator: (mutable: this) => unknown): this\n```\n\n#### see\n\n[`Map#withMutations`](../map/index#withMutations())\n\n#### [asMutable()](index#asMutable())\n\n``` ts\nasMutable(): this\n```\n\n#### see\n\n[`Map#asMutable`](../map/index#asMutable())\n\n#### [wasAltered()](index#wasAltered())\n\n``` ts\nwasAltered(): boolean\n```\n\n#### see\n\n[`Map#wasAltered`](../map/index#wasAltered())\n\n#### [asImmutable()](index#asImmutable())\n\n``` ts\nasImmutable(): this\n```\n\n#### see\n\n[`Map#asImmutable`](../map/index#asImmutable())\n\n### Sequence algorithms\n\n#### [toSeq()](index#toSeq())\n\n``` ts\ntoSeq(): Seq.Keyed<keyof TProps, TProps,[keyof TProps]>\n```\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<[keyof TProps, TProps,[keyof TProps]]>\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Record/](https://immutable-js.com/docs/v4.2.1/Record/)"
- name: Record.[Symbol.iterator]()
  id: record/index#[Symbol.iterator]()
  summary: This documentation is generated from immutable.d.ts
  belongs_to: Record
  description: "#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<[keyof TProps, TProps,[keyof TProps]]>\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Record/](https://immutable-js.com/docs/v4.2.1/Record/)"
- name: Record.asImmutable()
  id: record/index#asImmutable()
  summary: null
  belongs_to: Record
  description: |-
    #### [asImmutable()](index#asImmutable())

    ``` ts
    asImmutable(): this
    ```

    #### see

    [`Map#asImmutable`](../map/index#asImmutable())

    ### Sequence algorithms
- name: Record.asMutable()
  id: record/index#asMutable()
  summary: null
  belongs_to: Record
  description: |-
    #### [asMutable()](index#asMutable())

    ``` ts
    asMutable(): this
    ```

    #### see

    [`Map#asMutable`](../map/index#asMutable())
- name: Record.clear()
  id: record/index#clear()
  summary: Returns a new instance of this Record type with all values set to their default values
  belongs_to: Record
  description: |-
    #### [clear()](index#clear())

    Returns a new instance of this Record type with all values set to their default values.

    ``` ts
    clear(): this
    ```

    ### Deep persistent changes
- name: Record.delete()
  id: record/index#delete()
  summary: Returns a new instance of this Record type with the value for the specific key set to its default value
  belongs_to: Record
  description: |-
    #### [delete()](index#delete())

    Returns a new instance of this Record type with the value for the specific key set to its default value.

    ``` ts
    delete<K>(key: K): this
    ```

    #### alias

    `remove()`
- name: Record.deleteIn()
  id: record/index#deleteIn()
  summary: null
  belongs_to: Record
  description: |-
    #### [deleteIn()](index#deleteIn())

    ``` ts
    deleteIn(keyPath: Iterable<unknown>): this
    ```

    #### alias

    `removeIn()`

    ### Conversion to JavaScript types
- name: Record.equals()
  id: record/index#equals()
  summary: null
  belongs_to: Record
  description: |-
    #### [equals()](index#equals())

    ``` ts
    equals(other: unknown): boolean
    ```
- name: Record.Factory
  id: record.factory/index
  summary: A Record.Factory is created by the Record() function
  description: "# Record.Factory\n\nA Record.Factory is created by the [`Record()`](../record/index) function. Record instances are created by passing it some of the accepted values for that Record type:\n\n``` ts\ntype Record.Factory<TProps>\n```\n\n#### Discussion\n\n``` ts\n// makePerson is a Record Factory function\nconst makePerson = Record({ name: null, favoriteColor: 'unknown' });\n\n// alan is a Record instance\nconst alan = makePerson({ name: 'Alan' });run it\n```\n\nNote that Record Factories return `Record<TProps> & Readonly<TProps>`, this allows use of both the Record instance API, and direct property access on the resulting instances:\n\n``` ts\n// Use the Record API\nconsole.log('Record API: ' + alan.get('name'))\n\n// Or direct property access (Readonly)\nconsole.log('property access: ' + alan.name)run it\n```\n\n**Flow Typing Records:**\n\nUse the `RecordFactory<TProps>` Flow type to get high quality type checking of Records:\n\n``` ts\nimport type { RecordFactory, RecordOf } from 'immutable';\n\n// Use RecordFactory<TProps> for defining new Record factory functions.\ntype PersonProps = { name: ?string, favoriteColor: string };\nconst makePerson: RecordFactory<PersonProps> = Record({ name: null, favoriteColor: 'unknown' });\n\n// Use RecordOf<T> for defining new instances of that Record.\ntype Person = RecordOf<PersonProps>;\nconst alan: Person = makePerson({ name: 'Alan' });\n```\n\n### Construction\n\n#### [Record.Factory()](index#Record.Factory())\n\n``` ts\nRecord.Factory<TProps>(values?: Partial<TProps> | Iterable<[string, unknown]>): Record<TProps> & Readonly<TProps>\n```\n\n### Members\n\n#### [displayName](index#displayName)\n\nThe name provided to `Record(values, name)` can be accessed with [`displayName`](index#displayName).\n\n``` ts\ndisplayName: string\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Record.Factory/](https://immutable-js.com/docs/v4.2.1/Record.Factory/)"
- name: Record.Factory.displayName
  id: record.factory/index#displayName
  summary: The name provided to Record(values, name) can be accessed with displayName
  belongs_to: Record.Factory
  description: "#### [displayName](index#displayName)\n\nThe name provided to `Record(values, name)` can be accessed with [`displayName`](index#displayName).\n\n``` ts\ndisplayName: string\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Record.Factory/](https://immutable-js.com/docs/v4.2.1/Record.Factory/)"
- name: Record.Factory.Record.Factory()
  id: record.factory/index#Record.Factory()
  summary: null
  belongs_to: Record.Factory
  description: |-
    #### [Record.Factory()](index#Record.Factory())

    ``` ts
    Record.Factory<TProps>(values?: Partial<TProps> | Iterable<[string, unknown]>): Record<TProps> & Readonly<TProps>
    ```

    ### Members
- name: Record.get()
  id: record/index#get()
  summary: null
  belongs_to: Record
  description: |-
    #### [get()](index#get())

    ``` ts
    get<K>(key: K, notSetValue?: unknown): TProps,[K]
    get<T>(key: string, notSetValue: T): T
    ```

    ### Reading deep values
- name: Record.getIn()
  id: record/index#getIn()
  summary: null
  belongs_to: Record
  description: |-
    #### [getIn()](index#getIn())

    ``` ts
    getIn(keyPath: Iterable<unknown>): unknown
    ```

    ### Value equality
- name: Record.has()
  id: record/index#has()
  summary: null
  belongs_to: Record
  description: |-
    #### [has()](index#has())

    ``` ts
    has(key: string): boolean
    ```
- name: Record.hashCode()
  id: record/index#hashCode()
  summary: null
  belongs_to: Record
  description: |-
    #### [hashCode()](index#hashCode())

    ``` ts
    hashCode(): number
    ```

    ### Persistent changes
- name: Record.hasIn()
  id: record/index#hasIn()
  summary: null
  belongs_to: Record
  description: |-
    #### [hasIn()](index#hasIn())

    ``` ts
    hasIn(keyPath: Iterable<unknown>): boolean
    ```
- name: Record.merge()
  id: record/index#merge()
  summary: null
  belongs_to: Record
  description: |-
    #### [merge()](index#merge())

    ``` ts
    merge(...collections: Array<Partial<TProps> | Iterable<[string, unknown]>>): this
    ```
- name: Record.mergeDeep()
  id: record/index#mergeDeep()
  summary: null
  belongs_to: Record
  description: |-
    #### [mergeDeep()](index#mergeDeep())

    ``` ts
    mergeDeep(...collections: Array<Partial<TProps> | Iterable<[string, unknown]>>): this
    ```
- name: Record.mergeDeepIn()
  id: record/index#mergeDeepIn()
  summary: null
  belongs_to: Record
  description: |-
    #### [mergeDeepIn()](index#mergeDeepIn())

    ``` ts
    mergeDeepIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this
    ```
- name: Record.mergeDeepWith()
  id: record/index#mergeDeepWith()
  summary: null
  belongs_to: Record
  description: |-
    #### [mergeDeepWith()](index#mergeDeepWith())

    ``` ts
    mergeDeepWith(merger: (oldVal: unknown, newVal: unknown, key: unknown) => unknown,...collections: Array<Partial<TProps> | Iterable<[string, unknown]>>): this
    ```
- name: Record.mergeIn()
  id: record/index#mergeIn()
  summary: null
  belongs_to: Record
  description: |-
    #### [mergeIn()](index#mergeIn())

    ``` ts
    mergeIn(keyPath: Iterable<unknown>, ...collections: Array<unknown>): this
    ```
- name: Record.mergeWith()
  id: record/index#mergeWith()
  summary: null
  belongs_to: Record
  description: |-
    #### [mergeWith()](index#mergeWith())

    ``` ts
    mergeWith(merger: (oldVal: unknown, newVal: unknown, key: keyof TProps) => unknown,...collections: Array<Partial<TProps> | Iterable<[string, unknown]>>): this
    ```
- name: Record.Record()
  id: record/index#Record()
  summary: Unlike other types in Immutable.js, the Record() function creates a new Record Factory, which is a function that creates Record instances
  belongs_to: Record
  description: |-
    #### [Record()](index#Record())

    Unlike other types in Immutable.js, the [`Record()`](index) function creates a new Record Factory, which is a function that creates Record instances.

    ``` ts
    Record<TProps>(defaultValues: TProps, name?: string): Record.Factory<TProps>
    ```

    #### Discussion

    See above for examples of using [`Record()`](index).

    Note: [`Record`](index) is a factory function and not a class, and does not use the `new` keyword during construction.

    ### Static methods
- name: Record.Record.getDescriptiveName()
  id: record/index#getDescriptiveName()
  summary: null
  belongs_to: Record
  description: |-
    #### [Record.getDescriptiveName()](index#getDescriptiveName())

    ``` ts
    Record.getDescriptiveName(record: Record<any>): string
    ```

    ### Reading values
- name: Record.Record.isRecord()
  id: record/index#isRecord()
  summary: null
  belongs_to: Record
  description: |-
    #### [Record.isRecord()](index#isRecord())

    ``` ts
    Record.isRecord(maybeRecord: unknown): boolean
    ```
- name: Record.set()
  id: record/index#set()
  summary: null
  belongs_to: Record
  description: |-
    #### [set()](index#set())

    ``` ts
    set<K>(key: K, value: TProps,[K]): this
    ```
- name: Record.setIn()
  id: record/index#setIn()
  summary: null
  belongs_to: Record
  description: |-
    #### [setIn()](index#setIn())

    ``` ts
    setIn(keyPath: Iterable<unknown>, value: unknown): this
    ```
- name: Record.toJS()
  id: record/index#toJS()
  summary: Deeply converts this Record to equivalent native JavaScript Object
  belongs_to: Record
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Record to equivalent native JavaScript Object.

    ``` ts
    toJS(): DeepCopy<TProps>
    ```

    #### Discussion

    Note: This method may not be overridden. Objects with custom serialization to plain JS may override toJSON() instead.
- name: Record.toJSON()
  id: record/index#toJSON()
  summary: Shallowly converts this Record to equivalent native JavaScript Object
  belongs_to: Record
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Record to equivalent native JavaScript Object.

    ``` ts
    toJSON(): TProps
    ```
- name: Record.toObject()
  id: record/index#toObject()
  summary: Shallowly converts this Record to equivalent JavaScript Object
  belongs_to: Record
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Record to equivalent JavaScript Object.

    ``` ts
    toObject(): TProps
    ```

    ### Transient changes
- name: Record.toSeq()
  id: record/index#toSeq()
  summary: null
  belongs_to: Record
  description: |-
    #### [toSeq()](index#toSeq())

    ``` ts
    toSeq(): Seq.Keyed<keyof TProps, TProps,[keyof TProps]>
    ```
- name: Record.update()
  id: record/index#update()
  summary: null
  belongs_to: Record
  description: |-
    #### [update()](index#update())

    ``` ts
    update<K>(key: K, updater: (value: TProps,[K]) => TProps,[K]): this
    ```
- name: Record.updateIn()
  id: record/index#updateIn()
  summary: null
  belongs_to: Record
  description: |-
    #### [updateIn()](index#updateIn())

    ``` ts
    updateIn(keyPath: Iterable<unknown>, updater: (value: unknown) => unknown): this
    ```
- name: Record.wasAltered()
  id: record/index#wasAltered()
  summary: null
  belongs_to: Record
  description: |-
    #### [wasAltered()](index#wasAltered())

    ``` ts
    wasAltered(): boolean
    ```

    #### see

    [`Map#wasAltered`](../map/index#wasAltered())
- name: Record.withMutations()
  id: record/index#withMutations()
  summary: 'Note: Not all methods can be used on a mutable collection or within withMutations! Only set may be used mutatively'
  belongs_to: Record
  description: |-
    #### [withMutations()](index#withMutations())

    Note: Not all methods can be used on a mutable collection or within [`withMutations`](index#withMutations())! Only [`set`](index#set()) may be used mutatively.

    ``` ts
    withMutations(mutator: (mutable: this) => unknown): this
    ```

    #### see

    [`Map#withMutations`](../map/index#withMutations())
- name: remove()
  id: remove()/index
  summary: This documentation is generated from immutable.d.ts
  description: "# remove()\n\n``` ts\nremove<K, C>(collection: C, key: K): C\nremove<TProps, C, K>(collection: C, key: K): C\nremove<C>(collection: C, key: number): C\nremove<C, K>(collection: C, key: K): C\nremove<C, K>(collection: C, key: K): C\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/remove()/](https://immutable-js.com/docs/v4.2.1/remove()/)"
- name: removeIn()
  id: removein()/index
  summary: Returns a copy of the collection with the value at the key path removed
  description: "# removeIn()\n\nReturns a copy of the collection with the value at the key path removed.\n\n``` ts\nremoveIn<C>(collection: C, keyPath: Iterable<unknown>): C\n```\n\n#### Discussion\n\nA functional alternative to `collection.removeIn(keypath)` which will also work with plain Objects and Arrays.\n\n``` ts\nconst { removeIn } = require('immutable')\nconst original = { x: { y: { z: 123 }}}\nremoveIn(original, ['x', 'y', 'z']) // { x: { y: {}}}\nconsole.log(original) // { x: { y: { z: 123 }}}run it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/removeIn()/](https://immutable-js.com/docs/v4.2.1/removeIn()/)"
- name: Repeat()
  id: repeat()/index
  summary: Returns a Seq.Indexed of value repeated times times
  description: "# Repeat()\n\nReturns a Seq.Indexed of `value` repeated `times` times. When `times` is not defined, returns an infinite [`Seq`](../seq/index) of `value`.\n\n``` ts\nRepeat<T>(value: T, times?: number): Seq.Indexed<T>\n```\n\n#### Discussion\n\nNote: [`Repeat`](index) is a factory function and not a class, and does not use the `new` keyword during construction.\n\n``` ts\nconst { Repeat } = require('immutable')\nRepeat('foo') // [ 'foo', 'foo', 'foo', ... ]\nRepeat('bar', 4) // [ 'bar', 'bar', 'bar', 'bar' ]\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Repeat()/](https://immutable-js.com/docs/v4.2.1/Repeat()/)"
- name: Seq
  id: seq/index
  summary: Seq describes a lazy operation, allowing them to efficiently chain use of all the higher-order collection methods (such as map and filter) by not creating intermediate collections
  description: "# Seq\n\n[`Seq`](index) describes a lazy operation, allowing them to efficiently chain use of all the higher-order collection methods (such as [`map`](index#map()) and [`filter`](index#filter())) by not creating intermediate collections.\n\n``` ts\ntype Seq<K, V> extends Collection<K, V>\n```\n\n#### Discussion\n\n**Seq is immutable** — Once a Seq is created, it cannot be changed, appended to, rearranged or otherwise modified. Instead, any mutative method called on a [`Seq`](index) will return a new [`Seq`](index).\n\n**Seq is lazy** — [`Seq`](index) does as little work as necessary to respond to any method call. Values are often created during iteration, including implicit iteration when reducing or converting to a concrete data structure such as a [`List`](../list/index) or JavaScript [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).\n\nFor example, the following performs no work, because the resulting [`Seq`](index)'s values are never iterated:\n\n``` ts\nconst { Seq } = require('immutable')\nconst oddSquares = Seq([ 1, 2, 3, 4, 5, 6, 7, 8 ])\n  .filter(x => x % 2 !== 0)\n  .map(x => x * x)\n```\n\nOnce the [`Seq`](index) is used, it performs only the work necessary. In this example, no intermediate arrays are ever created, filter is called three times, and map is only called once:\n\n``` ts\noddSquares.get(1); // 9\n```\n\nAny collection can be converted to a lazy Seq with [`Seq()`](index).\n\n``` ts\nconst { Map } = require('immutable')\nconst map = Map({ a: 1, b: 2, c: 3 })\nconst lazySeq = Seq(map)run it\n```\n\n[`Seq`](index) allows for the efficient chaining of operations, allowing for the expression of logic that can otherwise be very tedious:\n\n``` ts\nlazySeq\n  .flip()\n  .map(key => key.toUpperCase())\n  .flip()\n// Seq { A: 1, B: 1, C: 1 }\n```\n\nAs well as expressing logic that would otherwise seem memory or time limited, for example [`Range`](../range()/index) is a special kind of Lazy sequence.\n\n``` ts\nconst { Range } = require('immutable')\nRange(1, Infinity)\n  .skip(1000)\n  .map(n => -n)\n  .filter(n => n % 2 === 0)\n  .take(2)\n  .reduce((r, n) => r * n, 1)\n// 1006008run it\n```\n\nSeq is often used to provide a rich collection API to JavaScript Object.\n\n``` ts\nSeq({ x: 0, y: 1, z: 2 }).map(v => v * 2).toObject();\n// { x: 0, y: 2, z: 4 }\n```\n\n### Construction\n\n#### [Seq()](index#Seq())\n\n``` ts\nSeq<S>(seq: S): S\nSeq<K, V>(collection: Collection.Keyed<K, V>): Seq.Keyed<K, V>\nSeq<T>(collection: Collection.Set<T>): Seq.Set<T>\nSeq<T>(collection: Collection.Indexed<T> | Iterable<T> | ArrayLike<T>): Seq.Indexed<T>\nSeq<V>(obj: {[key: string]: V}): Seq.Keyed<string, V>\nSeq<K, V>(): Seq<K, V>\n```\n\n### Static methods\n\n#### [Seq.isSeq()](index#isSeq())\n\n``` ts\nSeq.isSeq(maybeSeq: unknown): boolean\n```\n\n### Members\n\n#### [size](index#size)\n\nSome Seqs can describe their size lazily. When this is the case, size will be an integer. Otherwise it will be undefined.\n\n``` ts\nsize: number | undefined\n```\n\n#### Discussion\n\nFor example, Seqs returned from [`map()`](index#map()) or [`reverse()`](index#reverse()) preserve the size of the original [`Seq`](index) while [`filter()`](index#filter()) does not.\n\nNote: [`Range`](../range()/index), [`Repeat`](../repeat()/index) and [`Seq`](index)s made from [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)s and [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)s will always have a size.\n\n### Force evaluation\n\n#### [cacheResult()](index#cacheResult())\n\nBecause Sequences are lazy and designed to be chained together, they do not cache their results. For example, this map function is called a total of 6 times, as each [`join`](index#join()) iterates the Seq of three values.\n\n``` ts\ncacheResult(): this\n```\n\n#### Discussion\n\n``` ts\nvar squares = Seq([ 1, 2, 3 ]).map(x => x  x)\nsquares.join() + squares.join()\n```\n\nIf you know a [`Seq`](index) will be used multiple times, it may be more efficient to first cache it in memory. Here, the map function is called only 3 times.\n\n``` ts\nvar squares = Seq([ 1, 2, 3 ]).map(x => x  x).cacheResult()\nsquares.join() + squares.join()\n```\n\nUse this method judiciously, as it must fully evaluate a Seq which can be a burden on memory and possibly performance.\n\nNote: after calling [`cacheResult`](index#cacheResult()), a Seq will always have a [`size`](index#size).\n\n### Sequence algorithms\n\n#### [map()](index#map())\n\nReturns a new Seq with values passed through a `mapper` function.\n\n``` ts\nmap<M>(mapper: (value: V, key: K, iter: this) => M,context?: unknown): Seq<K, M>\nmap<M>(mapper: (value: V, key: K, iter: this) => M,context?: unknown): Seq<M, M>\n```\n\n#### Overrides\n\n[`Collection#map()`](../collection/index#map())\n\n#### Example\n\n``` ts\nconst { Seq } = require('immutable')\nSeq([ 1, 2 ]).map(x => 10 * x)\n// Seq [ 10, 20 ]\n```\n\nNote: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step. Note: used only for sets.\n\n#### [flatMap()](index#flatMap())\n\nFlat-maps the Seq, returning a Seq of the same type.\n\n``` ts\nflatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>,context?: unknown): Seq<K, M>\nflatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>,context?: unknown): Seq<M, M>\n```\n\n#### Overrides\n\n[`Collection#flatMap()`](../collection/index#flatMap())\n\n#### Discussion\n\nSimilar to `seq.map(...).flatten(true)`. Note: Used only for sets.\n\n#### [filter()](index#filter())\n\n``` ts\nfilter<F>(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): Seq<K, F>\nfilter(predicate: (value: V, key: K, iter: this) => unknown,context?: unknown): this\n```\n\n#### Overrides\n\n[`Collection#filter()`](../collection/index#filter())\n\n#### [partition()](index#partition())\n\n``` ts\npartition<F, C>(predicate: (this: C, value: V, key: K, iter: this) => boolean,context?: C): [Seq<K, V>, Seq<K, F>]\npartition<C>(predicate: (this: C, value: V, key: K, iter: this) => unknown,context?: C): [this, this]\n```\n\n#### Overrides\n\n[`Collection#partition()`](../collection/index#partition())\n\n#### [filterNot()](index#filterNot())\n\nReturns a new Collection of the same type with only the entries for which the `predicate` function returns false.\n\n``` ts\nfilterNot(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#filterNot()`](../collection/index#filterNot())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }run it\n```\n\nNote: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.\n\n#### [reverse()](index#reverse())\n\nReturns a new Collection of the same type in reverse order.\n\n``` ts\nreverse(): this\n```\n\n#### Inherited from\n\n[`Collection#reverse()`](../collection/index#reverse())\n\n#### [sort()](index#sort())\n\nReturns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.\n\n``` ts\nsort(comparator?: (valueA: V, valueB: V) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sort()`](../collection/index#sort())\n\n#### Discussion\n\nIf a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n- Returns `0` if the elements should not be swapped.\n- Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n- Returns `1` (or any positive number) if `valueA` comes after `valueB`\n- Is pure, i.e. it must always return the same value for the same pair of values.\n\nWhen sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n``` ts\nconst { Map } = require('immutable')\nMap({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// OrderedMap { \"a\": 1, \"b\": 2, \"c\": 3 }run it\n```\n\nNote: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [sortBy()](index#sortBy())\n\nLike [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:\n\n``` ts\nsortBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sortBy()`](../collection/index#sortBy())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst beattles = Map({\n  John: { name: \"Lennon\" },\n  Paul: { name: \"McCartney\" },\n  George: { name: \"Harrison\" },\n  Ringo: { name: \"Starr\" },\n});\nbeattles.sortBy(member => member.name);run it\n```\n\nNote: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [groupBy()](index#groupBy())\n\nReturns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.\n\n``` ts\ngroupBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<K, V>>\n```\n\n#### Inherited from\n\n[`Collection#groupBy()`](../collection/index#groupBy())\n\n#### Discussion\n\nNote: This is always an eager operation.\n\n``` ts\nconst { List, Map } = require('immutable')\nconst listOfMaps = List([\n  Map({ v: 0 }),\n  Map({ v: 1 }),\n  Map({ v: 1 }),\n  Map({ v: 0 }),\n  Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ Map{ \"v\": 0 }, Map { \"v\": 0 } ],\n//   1: List [ Map{ \"v\": 1 }, Map { \"v\": 1 } ],\n//   2: List [ Map{ \"v\": 2 } ],\n// }run it\n```\n\n### Value equality\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#equals()`](../collection/index#equals())\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Inherited from\n\n[`Collection#hashCode()`](../collection/index#hashCode())\n\n#### Discussion\n\nThe [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nIf two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.\n\n### Reading values\n\n#### [get()](index#get())\n\n``` ts\nget<NSV>(key: K, notSetValue: NSV): V | NSV\nget(key: K): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#get()`](../collection/index#get())\n\n#### [has()](index#has())\n\nTrue if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nhas(key: K): boolean\n```\n\n#### Inherited from\n\n[`Collection#has()`](../collection/index#has())\n\n#### [includes()](index#includes())\n\nTrue if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nincludes(value: V): boolean\n```\n\n#### Inherited from\n\n[`Collection#includes()`](../collection/index#includes())\n\n#### alias\n\n`contains()`\n\n#### [first()](index#first())\n\nIn case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nfirst<NSV>(notSetValue?: NSV): V | NSV\n```\n\n#### Inherited from\n\n[`Collection#first()`](../collection/index#first())\n\n#### [last()](index#last())\n\nIn case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nlast<NSV>(notSetValue?: NSV): V | NSV\n```\n\n#### Inherited from\n\n[`Collection#last()`](../collection/index#last())\n\n### Reading deep values\n\n#### [getIn()](index#getIn())\n\nReturns the value found by following a path of keys or indices through nested Collections.\n\n``` ts\ngetIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown\n```\n\n#### Inherited from\n\n[`Collection#getIn()`](../collection/index#getIn())\n\n#### Discussion\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: [ { y: 123 } ] });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\n#### [hasIn()](index#hasIn())\n\nTrue if the result of following a path of keys or indices through nested Collections results in a set value.\n\n``` ts\nhasIn(searchKeyPath: Iterable<unknown>): boolean\n```\n\n#### Inherited from\n\n[`Collection#hasIn()`](../collection/index#hasIn())\n\n### Persistent changes\n\n#### [update()](index#update())\n\nThis can be very useful as a way to \"chain\" a normal function into a sequence of methods. RxJS calls this \"let\" and lodash calls it \"thru\".\n\n``` ts\nupdate<R>(updater: (value: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#update()`](../collection/index#update())\n\n#### Discussion\n\nFor example, to sum a Seq after mapping and filtering:\n\n``` ts\nconst { Seq } = require('immutable')\n\nfunction sum(collection) {\n  return collection.reduce((sum, x) => sum + x, 0)\n}\nSeq([ 1, 2, 3 ])\n  .map(x => x + 1)\n  .filter(x => x % 2 === 0)\n  .update(sum)\n// 6run it\n```\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Collection to equivalent native JavaScript Array or Object.\n\n``` ts\ntoJS(): Array<DeepCopy<V>> | {[key: string]: DeepCopy<V>}\n```\n\n#### Inherited from\n\n[`Collection#toJS()`](../collection/index#toJS())\n\n#### Discussion\n\n[`Collection.Indexed`](../collection.indexed/index), and [`Collection.Set`](../collection.set/index) become [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array), while [`Collection.Keyed`](../collection.keyed/index) become [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object), converting keys to Strings.\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Collection to equivalent native JavaScript Array or Object.\n\n``` ts\ntoJSON(): Array<V> | {[key: string]: V}\n```\n\n#### Inherited from\n\n[`Collection#toJSON()`](../collection/index#toJSON())\n\n#### Discussion\n\n[`Collection.Indexed`](../collection.indexed/index), and [`Collection.Set`](../collection.set/index) become [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array), while [`Collection.Keyed`](../collection.keyed/index) become [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object), converting keys to Strings.\n\n#### [toArray()](index#toArray())\n\nShallowly converts this collection to an Array.\n\n``` ts\ntoArray(): Array<V> | Array<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection#toArray()`](../collection/index#toArray())\n\n#### Discussion\n\n[`Collection.Indexed`](../collection.indexed/index), and [`Collection.Set`](../collection.set/index) produce an Array of values. [`Collection.Keyed`](../collection.keyed/index) produce an Array of \\[key, value\\] tuples.\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Collection to an Object.\n\n``` ts\ntoObject(): {[key: string]: V}\n```\n\n#### Inherited from\n\n[`Collection#toObject()`](../collection/index#toObject())\n\n#### Discussion\n\nConverts keys to Strings.\n\n### Conversion to Collections\n\n#### [toMap()](index#toMap())\n\nConverts this Collection to a Map, Throws if keys are not hashable.\n\n``` ts\ntoMap(): Map<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toMap()`](../collection/index#toMap())\n\n#### Discussion\n\nNote: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toOrderedMap()](index#toOrderedMap())\n\nConverts this Collection to a Map, maintaining the order of iteration.\n\n``` ts\ntoOrderedMap(): OrderedMap<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedMap()`](../collection/index#toOrderedMap())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toSet()](index#toSet())\n\nConverts this Collection to a Set, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoSet(): Set<V>\n```\n\n#### Inherited from\n\n[`Collection#toSet()`](../collection/index#toSet())\n\n#### Discussion\n\nNote: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.\n\n#### [toOrderedSet()](index#toOrderedSet())\n\nConverts this Collection to a Set, maintaining the order of iteration and discarding keys.\n\n``` ts\ntoOrderedSet(): OrderedSet<V>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedSet()`](../collection/index#toOrderedSet())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toList()](index#toList())\n\nConverts this Collection to a List, discarding keys.\n\n``` ts\ntoList(): List<V>\n```\n\n#### Inherited from\n\n[`Collection#toList()`](../collection/index#toList())\n\n#### Discussion\n\nThis is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.\n\n``` ts\nconst { Map, List } = require('immutable')\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\nList(myMap) // List [ [ \"a\", \"Apple\" ], [ \"b\", \"Banana\" ] ]\nmyMap.toList() // List [ \"Apple\", \"Banana\" ]run it\n```\n\n#### [toStack()](index#toStack())\n\nConverts this Collection to a Stack, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoStack(): Stack<V>\n```\n\n#### Inherited from\n\n[`Collection#toStack()`](../collection/index#toStack())\n\n#### Discussion\n\nNote: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.\n\n### Conversion to Seq\n\n#### [toSeq()](index#toSeq())\n\nConverts this Collection to a Seq of the same kind (indexed, keyed, or set).\n\n``` ts\ntoSeq(): Seq<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toSeq()`](../collection/index#toSeq())\n\n#### [toKeyedSeq()](index#toKeyedSeq())\n\nReturns a Seq.Keyed from this Collection where indices are treated as keys.\n\n``` ts\ntoKeyedSeq(): Seq.Keyed<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())\n\n#### Discussion\n\nThis is useful if you want to operate on an Collection.Indexed and preserve the \\[index, value\\] pairs.\n\nThe returned Seq will have identical iteration order as this Collection.\n\n``` ts\nconst { Seq } = require('immutable')\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\n// Seq [ \"A\", \"B\", \"C\" ]\nindexedSeq.filter(v => v === 'B')\n// Seq [ \"B\" ]\nconst keyedSeq = indexedSeq.toKeyedSeq()\n// Seq { 0: \"A\", 1: \"B\", 2: \"C\" }\nkeyedSeq.filter(v => v === 'B')\n// Seq { 1: \"B\" }run it\n```\n\n#### [toIndexedSeq()](index#toIndexedSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\ntoIndexedSeq(): Seq.Indexed<V>\n```\n\n#### Inherited from\n\n[`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())\n\n#### [toSetSeq()](index#toSetSeq())\n\nReturns a Seq.Set of the values of this Collection, discarding keys.\n\n``` ts\ntoSetSeq(): Seq.Set<V>\n```\n\n#### Inherited from\n\n[`Collection#toSetSeq()`](../collection/index#toSetSeq())\n\n### Iterators\n\n#### [keys()](index#keys())\n\nAn iterator of this [`Collection`](../collection/index)'s keys.\n\n``` ts\nkeys(): IterableIterator<K>\n```\n\n#### Inherited from\n\n[`Collection#keys()`](../collection/index#keys())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.\n\n#### [values()](index#values())\n\nAn iterator of this [`Collection`](../collection/index)'s values.\n\n``` ts\nvalues(): IterableIterator<V>\n```\n\n#### Inherited from\n\n[`Collection#values()`](../collection/index#values())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.\n\n#### [entries()](index#entries())\n\nAn iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.\n\n``` ts\nentries(): IterableIterator<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection#entries()`](../collection/index#entries())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<unknown>\n```\n\n#### Inherited from\n\n[`Collection#[Symbol.iterator]()`](../collection/index#%5BSymbol.iterator%5D())\n\n### Collections (Seq)\n\n#### [keySeq()](index#keySeq())\n\nReturns a new Seq.Indexed of the keys of this Collection, discarding values.\n\n``` ts\nkeySeq(): Seq.Indexed<K>\n```\n\n#### Inherited from\n\n[`Collection#keySeq()`](../collection/index#keySeq())\n\n#### [valueSeq()](index#valueSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\nvalueSeq(): Seq.Indexed<V>\n```\n\n#### Inherited from\n\n[`Collection#valueSeq()`](../collection/index#valueSeq())\n\n#### [entrySeq()](index#entrySeq())\n\nReturns a new Seq.Indexed of \\[key, value\\] tuples.\n\n``` ts\nentrySeq(): Seq.Indexed<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection#entrySeq()`](../collection/index#entrySeq())\n\n### Side effects\n\n#### [forEach()](index#forEach())\n\nThe `sideEffect` is executed for every entry in the Collection.\n\n``` ts\nforEach(sideEffect: (value: V, key: K, iter: this) => unknown,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#forEach()`](../collection/index#forEach())\n\n#### Discussion\n\nUnlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).\n\n### Creating subsets\n\n#### [slice()](index#slice())\n\nReturns a new Collection of the same type representing a portion of this Collection from start up to but not including end.\n\n``` ts\nslice(begin?: number, end?: number): this\n```\n\n#### Inherited from\n\n[`Collection#slice()`](../collection/index#slice())\n\n#### Discussion\n\nIf begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.\n\nIf the requested slice is equivalent to the current Collection, then it will return itself.\n\n#### [rest()](index#rest())\n\nReturns a new Collection of the same type containing all entries except the first.\n\n``` ts\nrest(): this\n```\n\n#### Inherited from\n\n[`Collection#rest()`](../collection/index#rest())\n\n#### [butLast()](index#butLast())\n\nReturns a new Collection of the same type containing all entries except the last.\n\n``` ts\nbutLast(): this\n```\n\n#### Inherited from\n\n[`Collection#butLast()`](../collection/index#butLast())\n\n#### [skip()](index#skip())\n\nReturns a new Collection of the same type which excludes the first `amount` entries from this Collection.\n\n``` ts\nskip(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skip()`](../collection/index#skip())\n\n#### [skipLast()](index#skipLast())\n\nReturns a new Collection of the same type which excludes the last `amount` entries from this Collection.\n\n``` ts\nskipLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skipLast()`](../collection/index#skipLast())\n\n#### [skipWhile()](index#skipWhile())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns false.\n\n``` ts\nskipWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipWhile()`](../collection/index#skipWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipWhile(x => x.match(/g/))\n// List [ \"cat\", \"hat\", \"god\" ]run it\n```\n\n#### [skipUntil()](index#skipUntil())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns true.\n\n``` ts\nskipUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipUntil()`](../collection/index#skipUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipUntil(x => x.match(/hat/))\n// List [ \"hat\", \"god\" ]run it\n```\n\n#### [take()](index#take())\n\nReturns a new Collection of the same type which includes the first `amount` entries from this Collection.\n\n``` ts\ntake(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#take()`](../collection/index#take())\n\n#### [takeLast()](index#takeLast())\n\nReturns a new Collection of the same type which includes the last `amount` entries from this Collection.\n\n``` ts\ntakeLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#takeLast()`](../collection/index#takeLast())\n\n#### [takeWhile()](index#takeWhile())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.\n\n``` ts\ntakeWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeWhile()`](../collection/index#takeWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeWhile(x => x.match(/o/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n#### [takeUntil()](index#takeUntil())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.\n\n``` ts\ntakeUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeUntil()`](../collection/index#takeUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeUntil(x => x.match(/at/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n### Combination\n\n#### [concat()](index#concat())\n\nReturns a new Collection of the same type with other values and collection-like concatenated to this one.\n\n``` ts\nconcat(...valuesOrCollections: Array<unknown>): Collection<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection#concat()`](../collection/index#concat())\n\n#### Discussion\n\nFor Seqs, all entries will be present in the resulting Seq, even if they have the same key.\n\n#### [flatten()](index#flatten())\n\n``` ts\nflatten(depth?: number): Collection<unknown, unknown>\nflatten(shallow?: boolean): Collection<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection#flatten()`](../collection/index#flatten())\n\n### Reducing a value\n\n#### [reduce()](index#reduce())\n\n``` ts\nreduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R\nreduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduce()`](../collection/index#reduce())\n\n#### [reduceRight()](index#reduceRight())\n\n``` ts\nreduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R\nreduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduceRight()`](../collection/index#reduceRight())\n\n#### [every()](index#every())\n\nTrue if `predicate` returns true for all entries in the Collection.\n\n``` ts\nevery(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#every()`](../collection/index#every())\n\n#### [some()](index#some())\n\nTrue if `predicate` returns true for any entry in the Collection.\n\n``` ts\nsome(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#some()`](../collection/index#some())\n\n#### [join()](index#join())\n\nJoins values together as a string, inserting a separator between each. The default separator is `\",\"`.\n\n``` ts\njoin(separator?: string): string\n```\n\n#### Inherited from\n\n[`Collection#join()`](../collection/index#join())\n\n#### [isEmpty()](index#isEmpty())\n\nReturns true if this Collection includes no values.\n\n``` ts\nisEmpty(): boolean\n```\n\n#### Inherited from\n\n[`Collection#isEmpty()`](../collection/index#isEmpty())\n\n#### Discussion\n\nFor some lazy [`Seq`](index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.\n\n#### [count()](index#count())\n\n``` ts\ncount(): number\ncount(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#count()`](../collection/index#count())\n\n#### [countBy()](index#countBy())\n\nReturns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.\n\n``` ts\ncountBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Map<G, number>\n```\n\n#### Inherited from\n\n[`Collection#countBy()`](../collection/index#countBy())\n\n#### Discussion\n\nNote: This is not a lazy operation.\n\n### Search for value\n\n#### [find()](index#find())\n\nReturns the first value for which the `predicate` returns true.\n\n``` ts\nfind(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#find()`](../collection/index#find())\n\n#### [findLast()](index#findLast())\n\nReturns the last value for which the `predicate` returns true.\n\n``` ts\nfindLast(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLast()`](../collection/index#findLast())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findEntry()](index#findEntry())\n\nReturns the first \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findEntry()`](../collection/index#findEntry())\n\n#### [findLastEntry()](index#findLastEntry())\n\nReturns the last \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindLastEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastEntry()`](../collection/index#findLastEntry())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findKey()](index#findKey())\n\nReturns the key for which the `predicate` returns true.\n\n``` ts\nfindKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#findKey()`](../collection/index#findKey())\n\n#### [findLastKey()](index#findLastKey())\n\nReturns the last key for which the `predicate` returns true.\n\n``` ts\nfindLastKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastKey()`](../collection/index#findLastKey())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [keyOf()](index#keyOf())\n\nReturns the key associated with the search value, or undefined.\n\n``` ts\nkeyOf(searchValue: V): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#keyOf()`](../collection/index#keyOf())\n\n#### [lastKeyOf()](index#lastKeyOf())\n\nReturns the last key associated with the search value, or undefined.\n\n``` ts\nlastKeyOf(searchValue: V): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#lastKeyOf()`](../collection/index#lastKeyOf())\n\n#### [max()](index#max())\n\nReturns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmax(comparator?: (valueA: V, valueB: V) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#max()`](../collection/index#max())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [maxBy()](index#maxBy())\n\nLike [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nmaxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#maxBy()`](../collection/index#maxBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it\n```\n\n#### [min()](index#min())\n\nReturns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmin(comparator?: (valueA: V, valueB: V) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#min()`](../collection/index#min())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [minBy()](index#minBy())\n\nLike [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nminBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#minBy()`](../collection/index#minBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it\n```\n\n### Comparison\n\n#### [isSubset()](index#isSubset())\n\nTrue if `iter` includes every value in this Collection.\n\n``` ts\nisSubset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSubset()`](../collection/index#isSubset())\n\n#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Seq/](https://immutable-js.com/docs/v4.2.1/Seq/)"
- name: Seq.[Symbol.iterator]()
  id: seq/index#[Symbol.iterator]()
  summary: null
  belongs_to: Seq
  description: |-
    #### [\[Symbol.iterator\]()](index#%5BSymbol.iterator%5D())

    ``` ts
    [Symbol.iterator](): IterableIterator<unknown>
    ```

    #### Inherited from

    [`Collection#[Symbol.iterator]()`](../collection/index#%5BSymbol.iterator%5D())

    ### Collections (Seq)
- name: Seq.butLast()
  id: seq/index#butLast()
  summary: Returns a new Collection of the same type containing all entries except the last
  belongs_to: Seq
  description: |-
    #### [butLast()](index#butLast())

    Returns a new Collection of the same type containing all entries except the last.

    ``` ts
    butLast(): this
    ```

    #### Inherited from

    [`Collection#butLast()`](../collection/index#butLast())
- name: Seq.cacheResult()
  id: seq/index#cacheResult()
  summary: Because Sequences are lazy and designed to be chained together, they do not cache their results
  belongs_to: Seq
  description: |-
    #### [cacheResult()](index#cacheResult())

    Because Sequences are lazy and designed to be chained together, they do not cache their results. For example, this map function is called a total of 6 times, as each [`join`](index#join()) iterates the Seq of three values.

    ``` ts
    cacheResult(): this
    ```

    #### Discussion

    ``` ts
    var squares = Seq([ 1, 2, 3 ]).map(x => x  x)
    squares.join() + squares.join()
    ```

    If you know a [`Seq`](index) will be used multiple times, it may be more efficient to first cache it in memory. Here, the map function is called only 3 times.

    ``` ts
    var squares = Seq([ 1, 2, 3 ]).map(x => x  x).cacheResult()
    squares.join() + squares.join()
    ```

    Use this method judiciously, as it must fully evaluate a Seq which can be a burden on memory and possibly performance.

    Note: after calling [`cacheResult`](index#cacheResult()), a Seq will always have a [`size`](index#size).

    ### Sequence algorithms
- name: Seq.concat()
  id: seq/index#concat()
  summary: Returns a new Collection of the same type with other values and collection-like concatenated to this one
  belongs_to: Seq
  description: |-
    #### [concat()](index#concat())

    Returns a new Collection of the same type with other values and collection-like concatenated to this one.

    ``` ts
    concat(...valuesOrCollections: Array<unknown>): Collection<unknown, unknown>
    ```

    #### Inherited from

    [`Collection#concat()`](../collection/index#concat())

    #### Discussion

    For Seqs, all entries will be present in the resulting Seq, even if they have the same key.
- name: Seq.count()
  id: seq/index#count()
  summary: null
  belongs_to: Seq
  description: |-
    #### [count()](index#count())

    ``` ts
    count(): number
    count(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#count()`](../collection/index#count())
- name: Seq.countBy()
  id: seq/index#countBy()
  summary: Returns a Seq.Keyed of counts, grouped by the return value of the grouper function
  belongs_to: Seq
  description: |-
    #### [countBy()](index#countBy())

    Returns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.

    ``` ts
    countBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Map<G, number>
    ```

    #### Inherited from

    [`Collection#countBy()`](../collection/index#countBy())

    #### Discussion

    Note: This is not a lazy operation.

    ### Search for value
- name: Seq.entries()
  id: seq/index#entries()
  summary: An iterator of this Collection's entries as [ key, value ] tuples
  belongs_to: Seq
  description: |-
    #### [entries()](index#entries())

    An iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.

    ``` ts
    entries(): IterableIterator<[K, V]>
    ```

    #### Inherited from

    [`Collection#entries()`](../collection/index#entries())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.
- name: Seq.entrySeq()
  id: seq/index#entrySeq()
  summary: Returns a new Seq.Indexed of [key, value] tuples
  belongs_to: Seq
  description: |-
    #### [entrySeq()](index#entrySeq())

    Returns a new Seq.Indexed of \[key, value\] tuples.

    ``` ts
    entrySeq(): Seq.Indexed<[K, V]>
    ```

    #### Inherited from

    [`Collection#entrySeq()`](../collection/index#entrySeq())

    ### Side effects
- name: Seq.equals()
  id: seq/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: Seq
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Inherited from

    [`Collection#equals()`](../collection/index#equals())

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: Seq.every()
  id: seq/index#every()
  summary: True if predicate returns true for all entries in the Collection
  belongs_to: Seq
  description: |-
    #### [every()](index#every())

    True if `predicate` returns true for all entries in the Collection.

    ``` ts
    every(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#every()`](../collection/index#every())
- name: Seq.filter()
  id: seq/index#filter()
  summary: null
  belongs_to: Seq
  description: |-
    #### [filter()](index#filter())

    ``` ts
    filter<F>(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): Seq<K, F>
    filter(predicate: (value: V, key: K, iter: this) => unknown,context?: unknown): this
    ```

    #### Overrides

    [`Collection#filter()`](../collection/index#filter())
- name: Seq.filterNot()
  id: seq/index#filterNot()
  summary: Returns a new Collection of the same type with only the entries for which the predicate function returns false
  belongs_to: Seq
  description: |-
    #### [filterNot()](index#filterNot())

    Returns a new Collection of the same type with only the entries for which the `predicate` function returns false.

    ``` ts
    filterNot(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#filterNot()`](../collection/index#filterNot())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
    // Map { "a": 1, "c": 3 }run it
    ```

    Note: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.
- name: Seq.find()
  id: seq/index#find()
  summary: Returns the first value for which the predicate returns true
  belongs_to: Seq
  description: |-
    #### [find()](index#find())

    Returns the first value for which the `predicate` returns true.

    ``` ts
    find(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined
    ```

    #### Inherited from

    [`Collection#find()`](../collection/index#find())
- name: Seq.findEntry()
  id: seq/index#findEntry()
  summary: Returns the first [key, value] entry for which the predicate returns true
  belongs_to: Seq
  description: |-
    #### [findEntry()](index#findEntry())

    Returns the first \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
    ```

    #### Inherited from

    [`Collection#findEntry()`](../collection/index#findEntry())
- name: Seq.findKey()
  id: seq/index#findKey()
  summary: Returns the key for which the predicate returns true
  belongs_to: Seq
  description: |-
    #### [findKey()](index#findKey())

    Returns the key for which the `predicate` returns true.

    ``` ts
    findKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined
    ```

    #### Inherited from

    [`Collection#findKey()`](../collection/index#findKey())
- name: Seq.findLast()
  id: seq/index#findLast()
  summary: Returns the last value for which the predicate returns true
  belongs_to: Seq
  description: |-
    #### [findLast()](index#findLast())

    Returns the last value for which the `predicate` returns true.

    ``` ts
    findLast(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined
    ```

    #### Inherited from

    [`Collection#findLast()`](../collection/index#findLast())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Seq.findLastEntry()
  id: seq/index#findLastEntry()
  summary: Returns the last [key, value] entry for which the predicate returns true
  belongs_to: Seq
  description: |-
    #### [findLastEntry()](index#findLastEntry())

    Returns the last \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findLastEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
    ```

    #### Inherited from

    [`Collection#findLastEntry()`](../collection/index#findLastEntry())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Seq.findLastKey()
  id: seq/index#findLastKey()
  summary: Returns the last key for which the predicate returns true
  belongs_to: Seq
  description: |-
    #### [findLastKey()](index#findLastKey())

    Returns the last key for which the `predicate` returns true.

    ``` ts
    findLastKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined
    ```

    #### Inherited from

    [`Collection#findLastKey()`](../collection/index#findLastKey())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Seq.first()
  id: seq/index#first()
  summary: In case the Collection is not empty returns the first element of the Collection
  belongs_to: Seq
  description: |-
    #### [first()](index#first())

    In case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    first<NSV>(notSetValue?: NSV): V | NSV
    ```

    #### Inherited from

    [`Collection#first()`](../collection/index#first())
- name: Seq.flatMap()
  id: seq/index#flatMap()
  summary: Flat-maps the Seq, returning a Seq of the same type
  belongs_to: Seq
  description: |-
    #### [flatMap()](index#flatMap())

    Flat-maps the Seq, returning a Seq of the same type.

    ``` ts
    flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>,context?: unknown): Seq<K, M>
    flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>,context?: unknown): Seq<M, M>
    ```

    #### Overrides

    [`Collection#flatMap()`](../collection/index#flatMap())

    #### Discussion

    Similar to `seq.map(...).flatten(true)`. Note: Used only for sets.
- name: Seq.flatten()
  id: seq/index#flatten()
  summary: null
  belongs_to: Seq
  description: |-
    #### [flatten()](index#flatten())

    ``` ts
    flatten(depth?: number): Collection<unknown, unknown>
    flatten(shallow?: boolean): Collection<unknown, unknown>
    ```

    #### Inherited from

    [`Collection#flatten()`](../collection/index#flatten())

    ### Reducing a value
- name: Seq.forEach()
  id: seq/index#forEach()
  summary: The sideEffect is executed for every entry in the Collection
  belongs_to: Seq
  description: |-
    #### [forEach()](index#forEach())

    The `sideEffect` is executed for every entry in the Collection.

    ``` ts
    forEach(sideEffect: (value: V, key: K, iter: this) => unknown,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#forEach()`](../collection/index#forEach())

    #### Discussion

    Unlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).

    ### Creating subsets
- name: Seq.get()
  id: seq/index#get()
  summary: null
  belongs_to: Seq
  description: |-
    #### [get()](index#get())

    ``` ts
    get<NSV>(key: K, notSetValue: NSV): V | NSV
    get(key: K): V | undefined
    ```

    #### Inherited from

    [`Collection#get()`](../collection/index#get())
- name: Seq.getIn()
  id: seq/index#getIn()
  summary: Returns the value found by following a path of keys or indices through nested Collections
  belongs_to: Seq
  description: |-
    #### [getIn()](index#getIn())

    Returns the value found by following a path of keys or indices through nested Collections.

    ``` ts
    getIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown
    ```

    #### Inherited from

    [`Collection#getIn()`](../collection/index#getIn())

    #### Discussion

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: [ { y: 123 } ] });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```
- name: Seq.groupBy()
  id: seq/index#groupBy()
  summary: Returns a Collection.Keyed of Collection.Keyeds, grouped by the return value of the grouper function
  belongs_to: Seq
  description: |-
    #### [groupBy()](index#groupBy())

    Returns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.

    ``` ts
    groupBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<K, V>>
    ```

    #### Inherited from

    [`Collection#groupBy()`](../collection/index#groupBy())

    #### Discussion

    Note: This is always an eager operation.

    ``` ts
    const { List, Map } = require('immutable')
    const listOfMaps = List([
      Map({ v: 0 }),
      Map({ v: 1 }),
      Map({ v: 1 }),
      Map({ v: 0 }),
      Map({ v: 2 })
    ])
    const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
    // Map {
    //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
    //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
    //   2: List [ Map{ "v": 2 } ],
    // }run it
    ```

    ### Value equality
- name: Seq.has()
  id: seq/index#has()
  summary: null
  belongs_to: Seq
  description: |-
    #### [has()](index#has())

    True if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    has(key: K): boolean
    ```

    #### Inherited from

    [`Collection#has()`](../collection/index#has())
- name: Seq.hashCode()
  id: seq/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: Seq
  description: |-
    #### [hashCode()](index#hashCode())

    Computes and returns the hashed identity for this Collection.

    ``` ts
    hashCode(): number
    ```

    #### Inherited from

    [`Collection#hashCode()`](../collection/index#hashCode())

    #### Discussion

    The [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.

    ``` ts
    const a = List([ 1, 2, 3 ]);
    const b = List([ 1, 2, 3 ]);
    assert.notStrictEqual(a, b); // different instances
    const set = Set([ a ]);
    assert.equal(set.has(b), true);run it
    ```

    If two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.

    ### Reading values
- name: Seq.hasIn()
  id: seq/index#hasIn()
  summary: True if the result of following a path of keys or indices through nested Collections results in a set value
  belongs_to: Seq
  description: |-
    #### [hasIn()](index#hasIn())

    True if the result of following a path of keys or indices through nested Collections results in a set value.

    ``` ts
    hasIn(searchKeyPath: Iterable<unknown>): boolean
    ```

    #### Inherited from

    [`Collection#hasIn()`](../collection/index#hasIn())

    ### Persistent changes
- name: Seq.includes()
  id: seq/index#includes()
  summary: null
  belongs_to: Seq
  description: |-
    #### [includes()](index#includes())

    True if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    includes(value: V): boolean
    ```

    #### Inherited from

    [`Collection#includes()`](../collection/index#includes())

    #### alias

    `contains()`
- name: Seq.Indexed
  id: seq.indexed/index
  summary: Seq which represents an ordered indexed list of values
  description: "# Seq.Indexed\n\n[`Seq`](../seq/index) which represents an ordered indexed list of values.\n\n``` ts\ntype Seq.Indexed<T> extends Seq<number, T>, Collection.Indexed<T>\n```\n\n### Construction\n\n#### [Seq.Indexed()](index#Seq.Indexed())\n\nAlways returns Seq.Indexed, discarding associated keys and supplying incrementing indices.\n\n``` ts\nSeq.Indexed<T>(collection?: Iterable<T> | ArrayLike<T>): Seq.Indexed<T>\n```\n\n#### Discussion\n\nNote: [`Seq.Indexed`](index) is a conversion function and not a class, and does not use the `new` keyword during construction.\n\n### Static methods\n\n#### [Seq.Indexed.of()](index#of())\n\n``` ts\nSeq.Indexed.of<T>(...values: Array<T>): Seq.Indexed<T>\n```\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Indexed Seq to equivalent native JavaScript Array.\n\n``` ts\ntoJS(): Array<DeepCopy<T>>\n```\n\n#### Overrides\n\n[`Collection#toJS()`](../collection/index#toJS())\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Indexed Seq to equivalent native JavaScript Array.\n\n``` ts\ntoJSON(): Array<T>\n```\n\n#### Overrides\n\n[`Collection#toJSON()`](../collection/index#toJSON())\n\n#### [toArray()](index#toArray())\n\nShallowly converts this collection to an Array.\n\n``` ts\ntoArray(): Array<T>\n```\n\n#### Overrides\n\n[`Collection#toArray()`](../collection/index#toArray())\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Collection to an Object.\n\n``` ts\ntoObject(): {[key: string]: T}\n```\n\n#### Inherited from\n\n[`Collection#toObject()`](../collection/index#toObject())\n\n#### Discussion\n\nConverts keys to Strings.\n\n### Conversion to Seq\n\n#### [toSeq()](index#toSeq())\n\nReturns itself\n\n``` ts\ntoSeq(): this\n```\n\n#### Overrides\n\n[`Collection#toSeq()`](../collection/index#toSeq())\n\n#### [toKeyedSeq()](index#toKeyedSeq())\n\nReturns a Seq.Keyed from this Collection where indices are treated as keys.\n\n``` ts\ntoKeyedSeq(): Seq.Keyed<number, T>\n```\n\n#### Inherited from\n\n[`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())\n\n#### Discussion\n\nThis is useful if you want to operate on an Collection.Indexed and preserve the \\[index, value\\] pairs.\n\nThe returned Seq will have identical iteration order as this Collection.\n\n``` ts\nconst { Seq } = require('immutable')\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\n// Seq [ \"A\", \"B\", \"C\" ]\nindexedSeq.filter(v => v === 'B')\n// Seq [ \"B\" ]\nconst keyedSeq = indexedSeq.toKeyedSeq()\n// Seq { 0: \"A\", 1: \"B\", 2: \"C\" }\nkeyedSeq.filter(v => v === 'B')\n// Seq { 1: \"B\" }run it\n```\n\n#### [toIndexedSeq()](index#toIndexedSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\ntoIndexedSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())\n\n#### [toSetSeq()](index#toSetSeq())\n\nReturns a Seq.Set of the values of this Collection, discarding keys.\n\n``` ts\ntoSetSeq(): Seq.Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSetSeq()`](../collection/index#toSetSeq())\n\n#### [fromEntrySeq()](index#fromEntrySeq())\n\nIf this is a collection of \\[key, value\\] entry tuples, it will return a Seq.Keyed of those entries.\n\n``` ts\nfromEntrySeq(): Seq.Keyed<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection.Indexed#fromEntrySeq()`](../collection.indexed/index#fromEntrySeq())\n\n### Combination\n\n#### [concat()](index#concat())\n\nReturns a new Seq with other collections concatenated to this one.\n\n``` ts\nconcat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Seq.Indexed<T | C>\n```\n\n#### Overrides\n\n[`Collection#concat()`](../collection/index#concat())\n\n#### [zip()](index#zip())\n\n``` ts\nzip<U>(other: Collection<unknown, U>): Seq.Indexed<[T, U]>\nzip<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): Seq.Indexed<[T, U, V]>\nzip(...collections: Array<Collection<unknown, unknown>>): Seq.Indexed<unknown>\n```\n\n#### Overrides\n\n[`Collection.Indexed#zip()`](../collection.indexed/index#zip())\n\n#### [zipAll()](index#zipAll())\n\n``` ts\nzipAll<U>(other: Collection<unknown, U>): Seq.Indexed<[T, U]>\nzipAll<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): Seq.Indexed<[T, U, V]>\nzipAll(...collections: Array<Collection<unknown, unknown>>): Seq.Indexed<unknown>\n```\n\n#### Overrides\n\n[`Collection.Indexed#zipAll()`](../collection.indexed/index#zipAll())\n\n#### [zipWith()](index#zipWith())\n\n``` ts\nzipWith<U, Z>(zipper: (value: T, otherValue: U) => Z,otherCollection: Collection<unknown, U>): Seq.Indexed<Z>\nzipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z,otherCollection: Collection<unknown, U>,thirdCollection: Collection<unknown, V>): Seq.Indexed<Z>\nzipWith<Z>(zipper: (...values: Array<unknown>) => Z,...collections: Array<Collection<unknown, unknown>>): Seq.Indexed<Z>\n```\n\n#### Overrides\n\n[`Collection.Indexed#zipWith()`](../collection.indexed/index#zipWith())\n\n#### [flatten()](index#flatten())\n\n``` ts\nflatten(depth?: number): Collection<unknown, unknown>\nflatten(shallow?: boolean): Collection<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection#flatten()`](../collection/index#flatten())\n\n#### [interpose()](index#interpose())\n\nReturns a Collection of the same type with `separator` between each item in this Collection.\n\n``` ts\ninterpose(separator: T): this\n```\n\n#### Inherited from\n\n[`Collection.Indexed#interpose()`](../collection.indexed/index#interpose())\n\n#### [interleave()](index#interleave())\n\nReturns a Collection of the same type with the provided `collections` interleaved into this collection.\n\n``` ts\ninterleave(...collections: Array<Collection<unknown, T>>): this\n```\n\n#### Inherited from\n\n[`Collection.Indexed#interleave()`](../collection.indexed/index#interleave())\n\n#### Discussion\n\nThe resulting Collection includes the first item from each, then the second from each, etc.\n\n``` ts\nconst { List } = require('immutable')\nList([ 1, 2, 3 ]).interleave(List([ 'A', 'B', 'C' ]))\n// List [ 1, \"A\", 2, \"B\", 3, \"C\" ]run it\n```\n\nThe shortest Collection stops interleave.\n\n``` ts\nList([ 1, 2, 3 ]).interleave(\n  List([ 'A', 'B' ]),\n  List([ 'X', 'Y', 'Z' ])\n)\n// List [ 1, \"A\", \"X\", 2, \"B\", \"Y\" ]run it\n```\n\nSince [`interleave()`](../list/index#interleave()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.\n\nNote: [`interleave`](../list/index#interleave()) *cannot* be used in [`withMutations`](../list/index#withMutations()).\n\n#### [splice()](index#splice())\n\nSplice returns a new indexed Collection by replacing a region of this Collection with new values. If values are not provided, it only skips the region to be removed.\n\n``` ts\nsplice(index: number, removeNum: number, ...values: Array<T>): this\n```\n\n#### Inherited from\n\n[`Collection.Indexed#splice()`](../collection.indexed/index#splice())\n\n#### Discussion\n\n`index` may be a negative number, which indexes back from the end of the Collection. `s.splice(-2)` splices after the second to last item.\n\n``` ts\nconst { List } = require('immutable')\nList([ 'a', 'b', 'c', 'd' ]).splice(1, 2, 'q', 'r', 's')\n// List [ \"a\", \"q\", \"r\", \"s\", \"d\" ]run it\n```\n\nSince [`splice()`](../list/index#splice()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.\n\nNote: [`splice`](../list/index#splice()) *cannot* be used in [`withMutations`](../list/index#withMutations()).\n\n### Sequence algorithms\n\n#### [map()](index#map())\n\nReturns a new Seq.Indexed with values passed through a `mapper` function.\n\n``` ts\nmap<M>(mapper: (value: T, key: number, iter: this) => M,context?: unknown): Seq.Indexed<M>\n```\n\n#### Overrides\n\n[`Seq#map()`](../seq/index#map())\n\n#### Example\n\n``` ts\nconst { Seq } = require('immutable')\nSeq.Indexed([ 1, 2 ]).map(x => 10 * x)\n// Seq [ 10, 20 ]\n```\n\nNote: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.\n\n#### [flatMap()](index#flatMap())\n\nFlat-maps the Seq, returning a a Seq of the same type.\n\n``` ts\nflatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>,context?: unknown): Seq.Indexed<M>\n```\n\n#### Overrides\n\n[`Seq#flatMap()`](../seq/index#flatMap())\n\n#### Discussion\n\nSimilar to `seq.map(...).flatten(true)`.\n\n#### [filter()](index#filter())\n\n``` ts\nfilter<F>(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): Seq.Indexed<F>\nfilter(predicate: (value: T, index: number, iter: this) => unknown,context?: unknown): this\n```\n\n#### Overrides\n\n[`Seq#filter()`](../seq/index#filter())\n\n#### [partition()](index#partition())\n\n``` ts\npartition<F, C>(predicate: (this: C, value: T, index: number, iter: this) => boolean,context?: C): [Seq.Indexed<T>, Seq.Indexed<F>]\npartition<C>(predicate: (this: C, value: T, index: number, iter: this) => unknown,context?: C): [this, this]\n```\n\n#### Overrides\n\n[`Seq#partition()`](../seq/index#partition())\n\n#### [filterNot()](index#filterNot())\n\nReturns a new Collection of the same type with only the entries for which the `predicate` function returns false.\n\n``` ts\nfilterNot(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#filterNot()`](../collection/index#filterNot())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }run it\n```\n\nNote: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.\n\n#### [reverse()](index#reverse())\n\nReturns a new Collection of the same type in reverse order.\n\n``` ts\nreverse(): this\n```\n\n#### Inherited from\n\n[`Collection#reverse()`](../collection/index#reverse())\n\n#### [sort()](index#sort())\n\nReturns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.\n\n``` ts\nsort(comparator?: (valueA: T, valueB: T) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sort()`](../collection/index#sort())\n\n#### Discussion\n\nIf a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n- Returns `0` if the elements should not be swapped.\n- Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n- Returns `1` (or any positive number) if `valueA` comes after `valueB`\n- Is pure, i.e. it must always return the same value for the same pair of values.\n\nWhen sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n``` ts\nconst { Map } = require('immutable')\nMap({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// OrderedMap { \"a\": 1, \"b\": 2, \"c\": 3 }run it\n```\n\nNote: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [sortBy()](index#sortBy())\n\nLike [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:\n\n``` ts\nsortBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sortBy()`](../collection/index#sortBy())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst beattles = Map({\n  John: { name: \"Lennon\" },\n  Paul: { name: \"McCartney\" },\n  George: { name: \"Harrison\" },\n  Ringo: { name: \"Starr\" },\n});\nbeattles.sortBy(member => member.name);run it\n```\n\nNote: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [groupBy()](index#groupBy())\n\nReturns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.\n\n``` ts\ngroupBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<number, T>>\n```\n\n#### Inherited from\n\n[`Collection#groupBy()`](../collection/index#groupBy())\n\n#### Discussion\n\nNote: This is always an eager operation.\n\n``` ts\nconst { List, Map } = require('immutable')\nconst listOfMaps = List([\n  Map({ v: 0 }),\n  Map({ v: 1 }),\n  Map({ v: 1 }),\n  Map({ v: 0 }),\n  Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ Map{ \"v\": 0 }, Map { \"v\": 0 } ],\n//   1: List [ Map{ \"v\": 1 }, Map { \"v\": 1 } ],\n//   2: List [ Map{ \"v\": 2 } ],\n// }run it\n```\n\n### Iterators\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<T>\n```\n\n#### Overrides\n\n[`Collection#[Symbol.iterator]()`](../collection/index#%5BSymbol.iterator%5D())\n\n#### [keys()](index#keys())\n\nAn iterator of this [`Collection`](../collection/index)'s keys.\n\n``` ts\nkeys(): IterableIterator<number>\n```\n\n#### Inherited from\n\n[`Collection#keys()`](../collection/index#keys())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.\n\n#### [values()](index#values())\n\nAn iterator of this [`Collection`](../collection/index)'s values.\n\n``` ts\nvalues(): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection#values()`](../collection/index#values())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.\n\n#### [entries()](index#entries())\n\nAn iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.\n\n``` ts\nentries(): IterableIterator<[number, T]>\n```\n\n#### Inherited from\n\n[`Collection#entries()`](../collection/index#entries())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.\n\n### Members\n\n#### [size](index#size)\n\nSome Seqs can describe their size lazily. When this is the case, size will be an integer. Otherwise it will be undefined.\n\n``` ts\nsize: number | undefined\n```\n\n#### Inherited from\n\n[`Seq#size`](../seq/index#size)\n\n#### Discussion\n\nFor example, Seqs returned from [`map()`](../seq/index#map()) or [`reverse()`](../seq/index#reverse()) preserve the size of the original [`Seq`](../seq/index) while [`filter()`](../seq/index#filter()) does not.\n\nNote: [`Range`](../range()/index), [`Repeat`](../repeat()/index) and [`Seq`](../seq/index)s made from [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)s and [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)s will always have a size.\n\n### Force evaluation\n\n#### [cacheResult()](index#cacheResult())\n\nBecause Sequences are lazy and designed to be chained together, they do not cache their results. For example, this map function is called a total of 6 times, as each [`join`](../seq/index#join()) iterates the Seq of three values.\n\n``` ts\ncacheResult(): this\n```\n\n#### Inherited from\n\n[`Seq#cacheResult()`](../seq/index#cacheResult())\n\n#### Discussion\n\n``` ts\nvar squares = Seq([ 1, 2, 3 ]).map(x => x  x)\nsquares.join() + squares.join()\n```\n\nIf you know a [`Seq`](../seq/index) will be used multiple times, it may be more efficient to first cache it in memory. Here, the map function is called only 3 times.\n\n``` ts\nvar squares = Seq([ 1, 2, 3 ]).map(x => x  x).cacheResult()\nsquares.join() + squares.join()\n```\n\nUse this method judiciously, as it must fully evaluate a Seq which can be a burden on memory and possibly performance.\n\nNote: after calling [`cacheResult`](../seq/index#cacheResult()), a Seq will always have a [`size`](../seq/index#size).\n\n### Value equality\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#equals()`](../collection/index#equals())\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Inherited from\n\n[`Collection#hashCode()`](../collection/index#hashCode())\n\n#### Discussion\n\nThe [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nIf two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.\n\n### Reading values\n\n#### [get()](index#get())\n\n``` ts\nget<NSV>(key: number, notSetValue: NSV): T | NSV\nget(key: number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#get()`](../collection/index#get())\n\n#### [has()](index#has())\n\nTrue if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nhas(key: number): boolean\n```\n\n#### Inherited from\n\n[`Collection#has()`](../collection/index#has())\n\n#### [includes()](index#includes())\n\nTrue if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nincludes(value: T): boolean\n```\n\n#### Inherited from\n\n[`Collection#includes()`](../collection/index#includes())\n\n#### alias\n\n`contains()`\n\n#### [first()](index#first())\n\nIn case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nfirst<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#first()`](../collection/index#first())\n\n#### [last()](index#last())\n\nIn case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nlast<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#last()`](../collection/index#last())\n\n### Reading deep values\n\n#### [getIn()](index#getIn())\n\nReturns the value found by following a path of keys or indices through nested Collections.\n\n``` ts\ngetIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown\n```\n\n#### Inherited from\n\n[`Collection#getIn()`](../collection/index#getIn())\n\n#### Discussion\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: [ { y: 123 } ] });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\n#### [hasIn()](index#hasIn())\n\nTrue if the result of following a path of keys or indices through nested Collections results in a set value.\n\n``` ts\nhasIn(searchKeyPath: Iterable<unknown>): boolean\n```\n\n#### Inherited from\n\n[`Collection#hasIn()`](../collection/index#hasIn())\n\n### Persistent changes\n\n#### [update()](index#update())\n\nThis can be very useful as a way to \"chain\" a normal function into a sequence of methods. RxJS calls this \"let\" and lodash calls it \"thru\".\n\n``` ts\nupdate<R>(updater: (value: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#update()`](../collection/index#update())\n\n#### Discussion\n\nFor example, to sum a Seq after mapping and filtering:\n\n``` ts\nconst { Seq } = require('immutable')\n\nfunction sum(collection) {\n  return collection.reduce((sum, x) => sum + x, 0)\n}\nSeq([ 1, 2, 3 ])\n  .map(x => x + 1)\n  .filter(x => x % 2 === 0)\n  .update(sum)\n// 6run it\n```\n\n### Conversion to Collections\n\n#### [toMap()](index#toMap())\n\nConverts this Collection to a Map, Throws if keys are not hashable.\n\n``` ts\ntoMap(): Map<number, T>\n```\n\n#### Inherited from\n\n[`Collection#toMap()`](../collection/index#toMap())\n\n#### Discussion\n\nNote: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toOrderedMap()](index#toOrderedMap())\n\nConverts this Collection to a Map, maintaining the order of iteration.\n\n``` ts\ntoOrderedMap(): OrderedMap<number, T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedMap()`](../collection/index#toOrderedMap())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toSet()](index#toSet())\n\nConverts this Collection to a Set, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoSet(): Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSet()`](../collection/index#toSet())\n\n#### Discussion\n\nNote: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.\n\n#### [toOrderedSet()](index#toOrderedSet())\n\nConverts this Collection to a Set, maintaining the order of iteration and discarding keys.\n\n``` ts\ntoOrderedSet(): OrderedSet<T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedSet()`](../collection/index#toOrderedSet())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toList()](index#toList())\n\nConverts this Collection to a List, discarding keys.\n\n``` ts\ntoList(): List<T>\n```\n\n#### Inherited from\n\n[`Collection#toList()`](../collection/index#toList())\n\n#### Discussion\n\nThis is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.\n\n``` ts\nconst { Map, List } = require('immutable')\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\nList(myMap) // List [ [ \"a\", \"Apple\" ], [ \"b\", \"Banana\" ] ]\nmyMap.toList() // List [ \"Apple\", \"Banana\" ]run it\n```\n\n#### [toStack()](index#toStack())\n\nConverts this Collection to a Stack, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoStack(): Stack<T>\n```\n\n#### Inherited from\n\n[`Collection#toStack()`](../collection/index#toStack())\n\n#### Discussion\n\nNote: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.\n\n### Collections (Seq)\n\n#### [keySeq()](index#keySeq())\n\nReturns a new Seq.Indexed of the keys of this Collection, discarding values.\n\n``` ts\nkeySeq(): Seq.Indexed<number>\n```\n\n#### Inherited from\n\n[`Collection#keySeq()`](../collection/index#keySeq())\n\n#### [valueSeq()](index#valueSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\nvalueSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#valueSeq()`](../collection/index#valueSeq())\n\n#### [entrySeq()](index#entrySeq())\n\nReturns a new Seq.Indexed of \\[key, value\\] tuples.\n\n``` ts\nentrySeq(): Seq.Indexed<[number, T]>\n```\n\n#### Inherited from\n\n[`Collection#entrySeq()`](../collection/index#entrySeq())\n\n### Side effects\n\n#### [forEach()](index#forEach())\n\nThe `sideEffect` is executed for every entry in the Collection.\n\n``` ts\nforEach(sideEffect: (value: T, key: number, iter: this) => unknown,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#forEach()`](../collection/index#forEach())\n\n#### Discussion\n\nUnlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).\n\n### Creating subsets\n\n#### [slice()](index#slice())\n\nReturns a new Collection of the same type representing a portion of this Collection from start up to but not including end.\n\n``` ts\nslice(begin?: number, end?: number): this\n```\n\n#### Inherited from\n\n[`Collection#slice()`](../collection/index#slice())\n\n#### Discussion\n\nIf begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.\n\nIf the requested slice is equivalent to the current Collection, then it will return itself.\n\n#### [rest()](index#rest())\n\nReturns a new Collection of the same type containing all entries except the first.\n\n``` ts\nrest(): this\n```\n\n#### Inherited from\n\n[`Collection#rest()`](../collection/index#rest())\n\n#### [butLast()](index#butLast())\n\nReturns a new Collection of the same type containing all entries except the last.\n\n``` ts\nbutLast(): this\n```\n\n#### Inherited from\n\n[`Collection#butLast()`](../collection/index#butLast())\n\n#### [skip()](index#skip())\n\nReturns a new Collection of the same type which excludes the first `amount` entries from this Collection.\n\n``` ts\nskip(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skip()`](../collection/index#skip())\n\n#### [skipLast()](index#skipLast())\n\nReturns a new Collection of the same type which excludes the last `amount` entries from this Collection.\n\n``` ts\nskipLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skipLast()`](../collection/index#skipLast())\n\n#### [skipWhile()](index#skipWhile())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns false.\n\n``` ts\nskipWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipWhile()`](../collection/index#skipWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipWhile(x => x.match(/g/))\n// List [ \"cat\", \"hat\", \"god\" ]run it\n```\n\n#### [skipUntil()](index#skipUntil())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns true.\n\n``` ts\nskipUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipUntil()`](../collection/index#skipUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipUntil(x => x.match(/hat/))\n// List [ \"hat\", \"god\" ]run it\n```\n\n#### [take()](index#take())\n\nReturns a new Collection of the same type which includes the first `amount` entries from this Collection.\n\n``` ts\ntake(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#take()`](../collection/index#take())\n\n#### [takeLast()](index#takeLast())\n\nReturns a new Collection of the same type which includes the last `amount` entries from this Collection.\n\n``` ts\ntakeLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#takeLast()`](../collection/index#takeLast())\n\n#### [takeWhile()](index#takeWhile())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.\n\n``` ts\ntakeWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeWhile()`](../collection/index#takeWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeWhile(x => x.match(/o/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n#### [takeUntil()](index#takeUntil())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.\n\n``` ts\ntakeUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeUntil()`](../collection/index#takeUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeUntil(x => x.match(/at/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n### Reducing a value\n\n#### [reduce()](index#reduce())\n\n``` ts\nreduce<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R\nreduce<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduce()`](../collection/index#reduce())\n\n#### [reduceRight()](index#reduceRight())\n\n``` ts\nreduceRight<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R\nreduceRight<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduceRight()`](../collection/index#reduceRight())\n\n#### [every()](index#every())\n\nTrue if `predicate` returns true for all entries in the Collection.\n\n``` ts\nevery(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#every()`](../collection/index#every())\n\n#### [some()](index#some())\n\nTrue if `predicate` returns true for any entry in the Collection.\n\n``` ts\nsome(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#some()`](../collection/index#some())\n\n#### [join()](index#join())\n\nJoins values together as a string, inserting a separator between each. The default separator is `\",\"`.\n\n``` ts\njoin(separator?: string): string\n```\n\n#### Inherited from\n\n[`Collection#join()`](../collection/index#join())\n\n#### [isEmpty()](index#isEmpty())\n\nReturns true if this Collection includes no values.\n\n``` ts\nisEmpty(): boolean\n```\n\n#### Inherited from\n\n[`Collection#isEmpty()`](../collection/index#isEmpty())\n\n#### Discussion\n\nFor some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.\n\n#### [count()](index#count())\n\n``` ts\ncount(): number\ncount(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#count()`](../collection/index#count())\n\n#### [countBy()](index#countBy())\n\nReturns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.\n\n``` ts\ncountBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Map<G, number>\n```\n\n#### Inherited from\n\n[`Collection#countBy()`](../collection/index#countBy())\n\n#### Discussion\n\nNote: This is not a lazy operation.\n\n### Search for value\n\n#### [find()](index#find())\n\nReturns the first value for which the `predicate` returns true.\n\n``` ts\nfind(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#find()`](../collection/index#find())\n\n#### [findLast()](index#findLast())\n\nReturns the last value for which the `predicate` returns true.\n\n``` ts\nfindLast(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLast()`](../collection/index#findLast())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findEntry()](index#findEntry())\n\nReturns the first \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findEntry()`](../collection/index#findEntry())\n\n#### [findLastEntry()](index#findLastEntry())\n\nReturns the last \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindLastEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastEntry()`](../collection/index#findLastEntry())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findKey()](index#findKey())\n\nReturns the key for which the `predicate` returns true.\n\n``` ts\nfindKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#findKey()`](../collection/index#findKey())\n\n#### [findLastKey()](index#findLastKey())\n\nReturns the last key for which the `predicate` returns true.\n\n``` ts\nfindLastKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastKey()`](../collection/index#findLastKey())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [keyOf()](index#keyOf())\n\nReturns the key associated with the search value, or undefined.\n\n``` ts\nkeyOf(searchValue: T): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#keyOf()`](../collection/index#keyOf())\n\n#### [lastKeyOf()](index#lastKeyOf())\n\nReturns the last key associated with the search value, or undefined.\n\n``` ts\nlastKeyOf(searchValue: T): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#lastKeyOf()`](../collection/index#lastKeyOf())\n\n#### [max()](index#max())\n\nReturns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmax(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#max()`](../collection/index#max())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [maxBy()](index#maxBy())\n\nLike [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nmaxBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#maxBy()`](../collection/index#maxBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it\n```\n\n#### [min()](index#min())\n\nReturns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmin(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#min()`](../collection/index#min())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [minBy()](index#minBy())\n\nLike [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nminBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#minBy()`](../collection/index#minBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it\n```\n\n#### [indexOf()](index#indexOf())\n\nReturns the first index at which a given value can be found in the Collection, or -1 if it is not present.\n\n``` ts\nindexOf(searchValue: T): number\n```\n\n#### Inherited from\n\n[`Collection.Indexed#indexOf()`](../collection.indexed/index#indexOf())\n\n#### [lastIndexOf()](index#lastIndexOf())\n\nReturns the last index at which a given value can be found in the Collection, or -1 if it is not present.\n\n``` ts\nlastIndexOf(searchValue: T): number\n```\n\n#### Inherited from\n\n[`Collection.Indexed#lastIndexOf()`](../collection.indexed/index#lastIndexOf())\n\n#### [findIndex()](index#findIndex())\n\nReturns the first index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.\n\n``` ts\nfindIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection.Indexed#findIndex()`](../collection.indexed/index#findIndex())\n\n#### [findLastIndex()](index#findLastIndex())\n\nReturns the last index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.\n\n``` ts\nfindLastIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection.Indexed#findLastIndex()`](../collection.indexed/index#findLastIndex())\n\n### Comparison\n\n#### [isSubset()](index#isSubset())\n\nTrue if `iter` includes every value in this Collection.\n\n``` ts\nisSubset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSubset()`](../collection/index#isSubset())\n\n#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Seq.Indexed/](https://immutable-js.com/docs/v4.2.1/Seq.Indexed/)"
- name: Seq.Indexed.[Symbol.iterator]()
  id: seq.indexed/index#[Symbol.iterator]()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [\[Symbol.iterator\]()](index#%5BSymbol.iterator%5D())

    ``` ts
    [Symbol.iterator](): IterableIterator<T>
    ```

    #### Overrides

    [`Collection#[Symbol.iterator]()`](../collection/index#%5BSymbol.iterator%5D())
- name: Seq.Indexed.butLast()
  id: seq.indexed/index#butLast()
  summary: Returns a new Collection of the same type containing all entries except the last
  belongs_to: Seq.Indexed
  description: |-
    #### [butLast()](index#butLast())

    Returns a new Collection of the same type containing all entries except the last.

    ``` ts
    butLast(): this
    ```

    #### Inherited from

    [`Collection#butLast()`](../collection/index#butLast())
- name: Seq.Indexed.cacheResult()
  id: seq.indexed/index#cacheResult()
  summary: Because Sequences are lazy and designed to be chained together, they do not cache their results
  belongs_to: Seq.Indexed
  description: |-
    #### [cacheResult()](index#cacheResult())

    Because Sequences are lazy and designed to be chained together, they do not cache their results. For example, this map function is called a total of 6 times, as each [`join`](../seq/index#join()) iterates the Seq of three values.

    ``` ts
    cacheResult(): this
    ```

    #### Inherited from

    [`Seq#cacheResult()`](../seq/index#cacheResult())

    #### Discussion

    ``` ts
    var squares = Seq([ 1, 2, 3 ]).map(x => x  x)
    squares.join() + squares.join()
    ```

    If you know a [`Seq`](../seq/index) will be used multiple times, it may be more efficient to first cache it in memory. Here, the map function is called only 3 times.

    ``` ts
    var squares = Seq([ 1, 2, 3 ]).map(x => x  x).cacheResult()
    squares.join() + squares.join()
    ```

    Use this method judiciously, as it must fully evaluate a Seq which can be a burden on memory and possibly performance.

    Note: after calling [`cacheResult`](../seq/index#cacheResult()), a Seq will always have a [`size`](../seq/index#size).

    ### Value equality
- name: Seq.Indexed.concat()
  id: seq.indexed/index#concat()
  summary: Returns a new Seq with other collections concatenated to this one
  belongs_to: Seq.Indexed
  description: |-
    #### [concat()](index#concat())

    Returns a new Seq with other collections concatenated to this one.

    ``` ts
    concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Seq.Indexed<T | C>
    ```

    #### Overrides

    [`Collection#concat()`](../collection/index#concat())
- name: Seq.Indexed.count()
  id: seq.indexed/index#count()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [count()](index#count())

    ``` ts
    count(): number
    count(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#count()`](../collection/index#count())
- name: Seq.Indexed.countBy()
  id: seq.indexed/index#countBy()
  summary: Returns a Seq.Keyed of counts, grouped by the return value of the grouper function
  belongs_to: Seq.Indexed
  description: |-
    #### [countBy()](index#countBy())

    Returns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.

    ``` ts
    countBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Map<G, number>
    ```

    #### Inherited from

    [`Collection#countBy()`](../collection/index#countBy())

    #### Discussion

    Note: This is not a lazy operation.

    ### Search for value
- name: Seq.Indexed.entries()
  id: seq.indexed/index#entries()
  summary: An iterator of this Collection's entries as [ key, value ] tuples
  belongs_to: Seq.Indexed
  description: |-
    #### [entries()](index#entries())

    An iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.

    ``` ts
    entries(): IterableIterator<[number, T]>
    ```

    #### Inherited from

    [`Collection#entries()`](../collection/index#entries())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.

    ### Members
- name: Seq.Indexed.entrySeq()
  id: seq.indexed/index#entrySeq()
  summary: Returns a new Seq.Indexed of [key, value] tuples
  belongs_to: Seq.Indexed
  description: |-
    #### [entrySeq()](index#entrySeq())

    Returns a new Seq.Indexed of \[key, value\] tuples.

    ``` ts
    entrySeq(): Seq.Indexed<[number, T]>
    ```

    #### Inherited from

    [`Collection#entrySeq()`](../collection/index#entrySeq())

    ### Side effects
- name: Seq.Indexed.equals()
  id: seq.indexed/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: Seq.Indexed
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Inherited from

    [`Collection#equals()`](../collection/index#equals())

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: Seq.Indexed.every()
  id: seq.indexed/index#every()
  summary: True if predicate returns true for all entries in the Collection
  belongs_to: Seq.Indexed
  description: |-
    #### [every()](index#every())

    True if `predicate` returns true for all entries in the Collection.

    ``` ts
    every(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#every()`](../collection/index#every())
- name: Seq.Indexed.filter()
  id: seq.indexed/index#filter()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [filter()](index#filter())

    ``` ts
    filter<F>(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): Seq.Indexed<F>
    filter(predicate: (value: T, index: number, iter: this) => unknown,context?: unknown): this
    ```

    #### Overrides

    [`Seq#filter()`](../seq/index#filter())
- name: Seq.Indexed.filterNot()
  id: seq.indexed/index#filterNot()
  summary: Returns a new Collection of the same type with only the entries for which the predicate function returns false
  belongs_to: Seq.Indexed
  description: |-
    #### [filterNot()](index#filterNot())

    Returns a new Collection of the same type with only the entries for which the `predicate` function returns false.

    ``` ts
    filterNot(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#filterNot()`](../collection/index#filterNot())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
    // Map { "a": 1, "c": 3 }run it
    ```

    Note: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.
- name: Seq.Indexed.find()
  id: seq.indexed/index#find()
  summary: Returns the first value for which the predicate returns true
  belongs_to: Seq.Indexed
  description: |-
    #### [find()](index#find())

    Returns the first value for which the `predicate` returns true.

    ``` ts
    find(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#find()`](../collection/index#find())
- name: Seq.Indexed.findEntry()
  id: seq.indexed/index#findEntry()
  summary: Returns the first [key, value] entry for which the predicate returns true
  belongs_to: Seq.Indexed
  description: |-
    #### [findEntry()](index#findEntry())

    Returns the first \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined
    ```

    #### Inherited from

    [`Collection#findEntry()`](../collection/index#findEntry())
- name: Seq.Indexed.findIndex()
  id: seq.indexed/index#findIndex()
  summary: Returns the first index in the Collection where a value satisfies the provided predicate function
  belongs_to: Seq.Indexed
  description: |-
    #### [findIndex()](index#findIndex())

    Returns the first index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.

    ``` ts
    findIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection.Indexed#findIndex()`](../collection.indexed/index#findIndex())
- name: Seq.Indexed.findKey()
  id: seq.indexed/index#findKey()
  summary: Returns the key for which the predicate returns true
  belongs_to: Seq.Indexed
  description: |-
    #### [findKey()](index#findKey())

    Returns the key for which the `predicate` returns true.

    ``` ts
    findKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined
    ```

    #### Inherited from

    [`Collection#findKey()`](../collection/index#findKey())
- name: Seq.Indexed.findLast()
  id: seq.indexed/index#findLast()
  summary: Returns the last value for which the predicate returns true
  belongs_to: Seq.Indexed
  description: |-
    #### [findLast()](index#findLast())

    Returns the last value for which the `predicate` returns true.

    ``` ts
    findLast(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#findLast()`](../collection/index#findLast())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Seq.Indexed.findLastEntry()
  id: seq.indexed/index#findLastEntry()
  summary: Returns the last [key, value] entry for which the predicate returns true
  belongs_to: Seq.Indexed
  description: |-
    #### [findLastEntry()](index#findLastEntry())

    Returns the last \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findLastEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined
    ```

    #### Inherited from

    [`Collection#findLastEntry()`](../collection/index#findLastEntry())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Seq.Indexed.findLastIndex()
  id: seq.indexed/index#findLastIndex()
  summary: Returns the last index in the Collection where a value satisfies the provided predicate function
  belongs_to: Seq.Indexed
  description: |-
    #### [findLastIndex()](index#findLastIndex())

    Returns the last index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.

    ``` ts
    findLastIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection.Indexed#findLastIndex()`](../collection.indexed/index#findLastIndex())

    ### Comparison
- name: Seq.Indexed.findLastKey()
  id: seq.indexed/index#findLastKey()
  summary: Returns the last key for which the predicate returns true
  belongs_to: Seq.Indexed
  description: |-
    #### [findLastKey()](index#findLastKey())

    Returns the last key for which the `predicate` returns true.

    ``` ts
    findLastKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined
    ```

    #### Inherited from

    [`Collection#findLastKey()`](../collection/index#findLastKey())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Seq.Indexed.first()
  id: seq.indexed/index#first()
  summary: In case the Collection is not empty returns the first element of the Collection
  belongs_to: Seq.Indexed
  description: |-
    #### [first()](index#first())

    In case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    first<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#first()`](../collection/index#first())
- name: Seq.Indexed.flatMap()
  id: seq.indexed/index#flatMap()
  summary: Flat-maps the Seq, returning a a Seq of the same type
  belongs_to: Seq.Indexed
  description: |-
    #### [flatMap()](index#flatMap())

    Flat-maps the Seq, returning a a Seq of the same type.

    ``` ts
    flatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>,context?: unknown): Seq.Indexed<M>
    ```

    #### Overrides

    [`Seq#flatMap()`](../seq/index#flatMap())

    #### Discussion

    Similar to `seq.map(...).flatten(true)`.
- name: Seq.Indexed.flatten()
  id: seq.indexed/index#flatten()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [flatten()](index#flatten())

    ``` ts
    flatten(depth?: number): Collection<unknown, unknown>
    flatten(shallow?: boolean): Collection<unknown, unknown>
    ```

    #### Inherited from

    [`Collection#flatten()`](../collection/index#flatten())
- name: Seq.Indexed.forEach()
  id: seq.indexed/index#forEach()
  summary: The sideEffect is executed for every entry in the Collection
  belongs_to: Seq.Indexed
  description: |-
    #### [forEach()](index#forEach())

    The `sideEffect` is executed for every entry in the Collection.

    ``` ts
    forEach(sideEffect: (value: T, key: number, iter: this) => unknown,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#forEach()`](../collection/index#forEach())

    #### Discussion

    Unlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).

    ### Creating subsets
- name: Seq.Indexed.fromEntrySeq()
  id: seq.indexed/index#fromEntrySeq()
  summary: If this is a collection of [key, value] entry tuples, it will return a Seq.Keyed of those entries
  belongs_to: Seq.Indexed
  description: |-
    #### [fromEntrySeq()](index#fromEntrySeq())

    If this is a collection of \[key, value\] entry tuples, it will return a Seq.Keyed of those entries.

    ``` ts
    fromEntrySeq(): Seq.Keyed<unknown, unknown>
    ```

    #### Inherited from

    [`Collection.Indexed#fromEntrySeq()`](../collection.indexed/index#fromEntrySeq())

    ### Combination
- name: Seq.Indexed.get()
  id: seq.indexed/index#get()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [get()](index#get())

    ``` ts
    get<NSV>(key: number, notSetValue: NSV): T | NSV
    get(key: number): T | undefined
    ```

    #### Inherited from

    [`Collection#get()`](../collection/index#get())
- name: Seq.Indexed.getIn()
  id: seq.indexed/index#getIn()
  summary: Returns the value found by following a path of keys or indices through nested Collections
  belongs_to: Seq.Indexed
  description: |-
    #### [getIn()](index#getIn())

    Returns the value found by following a path of keys or indices through nested Collections.

    ``` ts
    getIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown
    ```

    #### Inherited from

    [`Collection#getIn()`](../collection/index#getIn())

    #### Discussion

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: [ { y: 123 } ] });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```
- name: Seq.Indexed.groupBy()
  id: seq.indexed/index#groupBy()
  summary: Returns a Collection.Keyed of Collection.Keyeds, grouped by the return value of the grouper function
  belongs_to: Seq.Indexed
  description: |-
    #### [groupBy()](index#groupBy())

    Returns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.

    ``` ts
    groupBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<number, T>>
    ```

    #### Inherited from

    [`Collection#groupBy()`](../collection/index#groupBy())

    #### Discussion

    Note: This is always an eager operation.

    ``` ts
    const { List, Map } = require('immutable')
    const listOfMaps = List([
      Map({ v: 0 }),
      Map({ v: 1 }),
      Map({ v: 1 }),
      Map({ v: 0 }),
      Map({ v: 2 })
    ])
    const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
    // Map {
    //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
    //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
    //   2: List [ Map{ "v": 2 } ],
    // }run it
    ```

    ### Iterators
- name: Seq.Indexed.has()
  id: seq.indexed/index#has()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [has()](index#has())

    True if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    has(key: number): boolean
    ```

    #### Inherited from

    [`Collection#has()`](../collection/index#has())
- name: Seq.Indexed.hashCode()
  id: seq.indexed/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: Seq.Indexed
  description: |-
    #### [hashCode()](index#hashCode())

    Computes and returns the hashed identity for this Collection.

    ``` ts
    hashCode(): number
    ```

    #### Inherited from

    [`Collection#hashCode()`](../collection/index#hashCode())

    #### Discussion

    The [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.

    ``` ts
    const a = List([ 1, 2, 3 ]);
    const b = List([ 1, 2, 3 ]);
    assert.notStrictEqual(a, b); // different instances
    const set = Set([ a ]);
    assert.equal(set.has(b), true);run it
    ```

    If two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.

    ### Reading values
- name: Seq.Indexed.hasIn()
  id: seq.indexed/index#hasIn()
  summary: True if the result of following a path of keys or indices through nested Collections results in a set value
  belongs_to: Seq.Indexed
  description: |-
    #### [hasIn()](index#hasIn())

    True if the result of following a path of keys or indices through nested Collections results in a set value.

    ``` ts
    hasIn(searchKeyPath: Iterable<unknown>): boolean
    ```

    #### Inherited from

    [`Collection#hasIn()`](../collection/index#hasIn())

    ### Persistent changes
- name: Seq.Indexed.includes()
  id: seq.indexed/index#includes()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [includes()](index#includes())

    True if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    includes(value: T): boolean
    ```

    #### Inherited from

    [`Collection#includes()`](../collection/index#includes())

    #### alias

    `contains()`
- name: Seq.Indexed.indexOf()
  id: seq.indexed/index#indexOf()
  summary: Returns the first index at which a given value can be found in the Collection, or -1 if it is not present
  belongs_to: Seq.Indexed
  description: |-
    #### [indexOf()](index#indexOf())

    Returns the first index at which a given value can be found in the Collection, or -1 if it is not present.

    ``` ts
    indexOf(searchValue: T): number
    ```

    #### Inherited from

    [`Collection.Indexed#indexOf()`](../collection.indexed/index#indexOf())
- name: Seq.Indexed.interleave()
  id: seq.indexed/index#interleave()
  summary: Returns a Collection of the same type with the provided collections interleaved into this collection
  belongs_to: Seq.Indexed
  description: |-
    #### [interleave()](index#interleave())

    Returns a Collection of the same type with the provided `collections` interleaved into this collection.

    ``` ts
    interleave(...collections: Array<Collection<unknown, T>>): this
    ```

    #### Inherited from

    [`Collection.Indexed#interleave()`](../collection.indexed/index#interleave())

    #### Discussion

    The resulting Collection includes the first item from each, then the second from each, etc.

    ``` ts
    const { List } = require('immutable')
    List([ 1, 2, 3 ]).interleave(List([ 'A', 'B', 'C' ]))
    // List [ 1, "A", 2, "B", 3, "C" ]run it
    ```

    The shortest Collection stops interleave.

    ``` ts
    List([ 1, 2, 3 ]).interleave(
      List([ 'A', 'B' ]),
      List([ 'X', 'Y', 'Z' ])
    )
    // List [ 1, "A", "X", 2, "B", "Y" ]run it
    ```

    Since [`interleave()`](../list/index#interleave()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.

    Note: [`interleave`](../list/index#interleave()) *cannot* be used in [`withMutations`](../list/index#withMutations()).
- name: Seq.Indexed.interpose()
  id: seq.indexed/index#interpose()
  summary: Returns a Collection of the same type with separator between each item in this Collection
  belongs_to: Seq.Indexed
  description: |-
    #### [interpose()](index#interpose())

    Returns a Collection of the same type with `separator` between each item in this Collection.

    ``` ts
    interpose(separator: T): this
    ```

    #### Inherited from

    [`Collection.Indexed#interpose()`](../collection.indexed/index#interpose())
- name: Seq.Indexed.isEmpty()
  id: seq.indexed/index#isEmpty()
  summary: Returns true if this Collection includes no values
  belongs_to: Seq.Indexed
  description: |-
    #### [isEmpty()](index#isEmpty())

    Returns true if this Collection includes no values.

    ``` ts
    isEmpty(): boolean
    ```

    #### Inherited from

    [`Collection#isEmpty()`](../collection/index#isEmpty())

    #### Discussion

    For some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.
- name: Seq.Indexed.isSubset()
  id: seq.indexed/index#isSubset()
  summary: True if iter includes every value in this Collection
  belongs_to: Seq.Indexed
  description: |-
    #### [isSubset()](index#isSubset())

    True if `iter` includes every value in this Collection.

    ``` ts
    isSubset(iter: Iterable<T>): boolean
    ```

    #### Inherited from

    [`Collection#isSubset()`](../collection/index#isSubset())
- name: Seq.Indexed.isSuperset()
  id: seq.indexed/index#isSuperset()
  summary: True if this Collection includes every value in iter
  belongs_to: Seq.Indexed
  description: "#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Seq.Indexed/](https://immutable-js.com/docs/v4.2.1/Seq.Indexed/)"
- name: Seq.Indexed.join()
  id: seq.indexed/index#join()
  summary: Joins values together as a string, inserting a separator between each
  belongs_to: Seq.Indexed
  description: |-
    #### [join()](index#join())

    Joins values together as a string, inserting a separator between each. The default separator is `","`.

    ``` ts
    join(separator?: string): string
    ```

    #### Inherited from

    [`Collection#join()`](../collection/index#join())
- name: Seq.Indexed.keyOf()
  id: seq.indexed/index#keyOf()
  summary: Returns the key associated with the search value, or undefined
  belongs_to: Seq.Indexed
  description: |-
    #### [keyOf()](index#keyOf())

    Returns the key associated with the search value, or undefined.

    ``` ts
    keyOf(searchValue: T): number | undefined
    ```

    #### Inherited from

    [`Collection#keyOf()`](../collection/index#keyOf())
- name: Seq.Indexed.keys()
  id: seq.indexed/index#keys()
  summary: An iterator of this Collection's keys
  belongs_to: Seq.Indexed
  description: |-
    #### [keys()](index#keys())

    An iterator of this [`Collection`](../collection/index)'s keys.

    ``` ts
    keys(): IterableIterator<number>
    ```

    #### Inherited from

    [`Collection#keys()`](../collection/index#keys())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.
- name: Seq.Indexed.keySeq()
  id: seq.indexed/index#keySeq()
  summary: Returns a new Seq.Indexed of the keys of this Collection, discarding values
  belongs_to: Seq.Indexed
  description: |-
    #### [keySeq()](index#keySeq())

    Returns a new Seq.Indexed of the keys of this Collection, discarding values.

    ``` ts
    keySeq(): Seq.Indexed<number>
    ```

    #### Inherited from

    [`Collection#keySeq()`](../collection/index#keySeq())
- name: Seq.Indexed.last()
  id: seq.indexed/index#last()
  summary: In case the Collection is not empty returns the last element of the Collection
  belongs_to: Seq.Indexed
  description: |-
    #### [last()](index#last())

    In case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    last<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#last()`](../collection/index#last())

    ### Reading deep values
- name: Seq.Indexed.lastIndexOf()
  id: seq.indexed/index#lastIndexOf()
  summary: Returns the last index at which a given value can be found in the Collection, or -1 if it is not present
  belongs_to: Seq.Indexed
  description: |-
    #### [lastIndexOf()](index#lastIndexOf())

    Returns the last index at which a given value can be found in the Collection, or -1 if it is not present.

    ``` ts
    lastIndexOf(searchValue: T): number
    ```

    #### Inherited from

    [`Collection.Indexed#lastIndexOf()`](../collection.indexed/index#lastIndexOf())
- name: Seq.Indexed.lastKeyOf()
  id: seq.indexed/index#lastKeyOf()
  summary: Returns the last key associated with the search value, or undefined
  belongs_to: Seq.Indexed
  description: |-
    #### [lastKeyOf()](index#lastKeyOf())

    Returns the last key associated with the search value, or undefined.

    ``` ts
    lastKeyOf(searchValue: T): number | undefined
    ```

    #### Inherited from

    [`Collection#lastKeyOf()`](../collection/index#lastKeyOf())
- name: Seq.Indexed.map()
  id: seq.indexed/index#map()
  summary: Returns a new Seq.Indexed with values passed through a mapper function
  belongs_to: Seq.Indexed
  description: |-
    #### [map()](index#map())

    Returns a new Seq.Indexed with values passed through a `mapper` function.

    ``` ts
    map<M>(mapper: (value: T, key: number, iter: this) => M,context?: unknown): Seq.Indexed<M>
    ```

    #### Overrides

    [`Seq#map()`](../seq/index#map())

    #### Example

    ``` ts
    const { Seq } = require('immutable')
    Seq.Indexed([ 1, 2 ]).map(x => 10 * x)
    // Seq [ 10, 20 ]
    ```

    Note: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.
- name: Seq.Indexed.max()
  id: seq.indexed/index#max()
  summary: Returns the maximum value in this collection
  belongs_to: Seq.Indexed
  description: |-
    #### [max()](index#max())

    Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    max(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#max()`](../collection/index#max())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Seq.Indexed.maxBy()
  id: seq.indexed/index#maxBy()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [maxBy()](index#maxBy())

    Like [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    maxBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#maxBy()`](../collection/index#maxBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it
    ```
- name: Seq.Indexed.min()
  id: seq.indexed/index#min()
  summary: Returns the minimum value in this collection
  belongs_to: Seq.Indexed
  description: |-
    #### [min()](index#min())

    Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    min(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#min()`](../collection/index#min())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Seq.Indexed.minBy()
  id: seq.indexed/index#minBy()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [minBy()](index#minBy())

    Like [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    minBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#minBy()`](../collection/index#minBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it
    ```
- name: Seq.Indexed.partition()
  id: seq.indexed/index#partition()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [partition()](index#partition())

    ``` ts
    partition<F, C>(predicate: (this: C, value: T, index: number, iter: this) => boolean,context?: C): [Seq.Indexed<T>, Seq.Indexed<F>]
    partition<C>(predicate: (this: C, value: T, index: number, iter: this) => unknown,context?: C): [this, this]
    ```

    #### Overrides

    [`Seq#partition()`](../seq/index#partition())
- name: Seq.Indexed.reduce()
  id: seq.indexed/index#reduce()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [reduce()](index#reduce())

    ``` ts
    reduce<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R
    reduce<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduce()`](../collection/index#reduce())
- name: Seq.Indexed.reduceRight()
  id: seq.indexed/index#reduceRight()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [reduceRight()](index#reduceRight())

    ``` ts
    reduceRight<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R
    reduceRight<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduceRight()`](../collection/index#reduceRight())
- name: Seq.Indexed.rest()
  id: seq.indexed/index#rest()
  summary: Returns a new Collection of the same type containing all entries except the first
  belongs_to: Seq.Indexed
  description: |-
    #### [rest()](index#rest())

    Returns a new Collection of the same type containing all entries except the first.

    ``` ts
    rest(): this
    ```

    #### Inherited from

    [`Collection#rest()`](../collection/index#rest())
- name: Seq.Indexed.reverse()
  id: seq.indexed/index#reverse()
  summary: Returns a new Collection of the same type in reverse order
  belongs_to: Seq.Indexed
  description: |-
    #### [reverse()](index#reverse())

    Returns a new Collection of the same type in reverse order.

    ``` ts
    reverse(): this
    ```

    #### Inherited from

    [`Collection#reverse()`](../collection/index#reverse())
- name: Seq.Indexed.Seq.Indexed()
  id: seq.indexed/index#Seq.Indexed()
  summary: Always returns Seq.Indexed, discarding associated keys and supplying incrementing indices
  belongs_to: Seq.Indexed
  description: |-
    #### [Seq.Indexed()](index#Seq.Indexed())

    Always returns Seq.Indexed, discarding associated keys and supplying incrementing indices.

    ``` ts
    Seq.Indexed<T>(collection?: Iterable<T> | ArrayLike<T>): Seq.Indexed<T>
    ```

    #### Discussion

    Note: [`Seq.Indexed`](index) is a conversion function and not a class, and does not use the `new` keyword during construction.

    ### Static methods
- name: Seq.Indexed.Seq.Indexed.of()
  id: seq.indexed/index#of()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [Seq.Indexed.of()](index#of())

    ``` ts
    Seq.Indexed.of<T>(...values: Array<T>): Seq.Indexed<T>
    ```

    ### Conversion to JavaScript types
- name: Seq.Indexed.size
  id: seq.indexed/index#size
  summary: Some Seqs can describe their size lazily
  belongs_to: Seq.Indexed
  description: |-
    #### [size](index#size)

    Some Seqs can describe their size lazily. When this is the case, size will be an integer. Otherwise it will be undefined.

    ``` ts
    size: number | undefined
    ```

    #### Inherited from

    [`Seq#size`](../seq/index#size)

    #### Discussion

    For example, Seqs returned from [`map()`](../seq/index#map()) or [`reverse()`](../seq/index#reverse()) preserve the size of the original [`Seq`](../seq/index) while [`filter()`](../seq/index#filter()) does not.

    Note: [`Range`](../range()/index), [`Repeat`](../repeat()/index) and [`Seq`](../seq/index)s made from [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)s and [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)s will always have a size.

    ### Force evaluation
- name: Seq.Indexed.skip()
  id: seq.indexed/index#skip()
  summary: Returns a new Collection of the same type which excludes the first amount entries from this Collection
  belongs_to: Seq.Indexed
  description: |-
    #### [skip()](index#skip())

    Returns a new Collection of the same type which excludes the first `amount` entries from this Collection.

    ``` ts
    skip(amount: number): this
    ```

    #### Inherited from

    [`Collection#skip()`](../collection/index#skip())
- name: Seq.Indexed.skipLast()
  id: seq.indexed/index#skipLast()
  summary: Returns a new Collection of the same type which excludes the last amount entries from this Collection
  belongs_to: Seq.Indexed
  description: |-
    #### [skipLast()](index#skipLast())

    Returns a new Collection of the same type which excludes the last `amount` entries from this Collection.

    ``` ts
    skipLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#skipLast()`](../collection/index#skipLast())
- name: Seq.Indexed.skipUntil()
  id: seq.indexed/index#skipUntil()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns true
  belongs_to: Seq.Indexed
  description: |-
    #### [skipUntil()](index#skipUntil())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns true.

    ``` ts
    skipUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipUntil()`](../collection/index#skipUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipUntil(x => x.match(/hat/))
    // List [ "hat", "god" ]run it
    ```
- name: Seq.Indexed.skipWhile()
  id: seq.indexed/index#skipWhile()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns false
  belongs_to: Seq.Indexed
  description: |-
    #### [skipWhile()](index#skipWhile())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns false.

    ``` ts
    skipWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipWhile()`](../collection/index#skipWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipWhile(x => x.match(/g/))
    // List [ "cat", "hat", "god" ]run it
    ```
- name: Seq.Indexed.slice()
  id: seq.indexed/index#slice()
  summary: Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end
  belongs_to: Seq.Indexed
  description: |-
    #### [slice()](index#slice())

    Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.

    ``` ts
    slice(begin?: number, end?: number): this
    ```

    #### Inherited from

    [`Collection#slice()`](../collection/index#slice())

    #### Discussion

    If begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.

    If end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.

    If the requested slice is equivalent to the current Collection, then it will return itself.
- name: Seq.Indexed.some()
  id: seq.indexed/index#some()
  summary: True if predicate returns true for any entry in the Collection
  belongs_to: Seq.Indexed
  description: |-
    #### [some()](index#some())

    True if `predicate` returns true for any entry in the Collection.

    ``` ts
    some(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#some()`](../collection/index#some())
- name: Seq.Indexed.sort()
  id: seq.indexed/index#sort()
  summary: Returns a new Collection of the same type which includes the same entries, stably sorted by using a comparator
  belongs_to: Seq.Indexed
  description: |-
    #### [sort()](index#sort())

    Returns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.

    ``` ts
    sort(comparator?: (valueA: T, valueB: T) => number): this
    ```

    #### Inherited from

    [`Collection#sort()`](../collection/index#sort())

    #### Discussion

    If a `comparator` is not provided, a default comparator uses `<` and `>`.

    `comparator(valueA, valueB)`:

    - Returns `0` if the elements should not be swapped.
    - Returns `-1` (or any negative number) if `valueA` comes before `valueB`
    - Returns `1` (or any positive number) if `valueA` comes after `valueB`
    - Is pure, i.e. it must always return the same value for the same pair of values.

    When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.

    ``` ts
    const { Map } = require('immutable')
    Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
      if (a < b) { return -1; }
      if (a > b) { return 1; }
      if (a === b) { return 0; }
    });
    // OrderedMap { "a": 1, "b": 2, "c": 3 }run it
    ```

    Note: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Seq.Indexed.sortBy()
  id: seq.indexed/index#sortBy()
  summary: 'Note: sortBy() Always returns a new instance, even if the original was already sorted'
  belongs_to: Seq.Indexed
  description: |-
    #### [sortBy()](index#sortBy())

    Like [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:

    ``` ts
    sortBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this
    ```

    #### Inherited from

    [`Collection#sortBy()`](../collection/index#sortBy())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const beattles = Map({
      John: { name: "Lennon" },
      Paul: { name: "McCartney" },
      George: { name: "Harrison" },
      Ringo: { name: "Starr" },
    });
    beattles.sortBy(member => member.name);run it
    ```

    Note: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Seq.Indexed.splice()
  id: seq.indexed/index#splice()
  summary: Splice returns a new indexed Collection by replacing a region of this Collection with new values
  belongs_to: Seq.Indexed
  description: |-
    #### [splice()](index#splice())

    Splice returns a new indexed Collection by replacing a region of this Collection with new values. If values are not provided, it only skips the region to be removed.

    ``` ts
    splice(index: number, removeNum: number, ...values: Array<T>): this
    ```

    #### Inherited from

    [`Collection.Indexed#splice()`](../collection.indexed/index#splice())

    #### Discussion

    `index` may be a negative number, which indexes back from the end of the Collection. `s.splice(-2)` splices after the second to last item.

    ``` ts
    const { List } = require('immutable')
    List([ 'a', 'b', 'c', 'd' ]).splice(1, 2, 'q', 'r', 's')
    // List [ "a", "q", "r", "s", "d" ]run it
    ```

    Since [`splice()`](../list/index#splice()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.

    Note: [`splice`](../list/index#splice()) *cannot* be used in [`withMutations`](../list/index#withMutations()).

    ### Sequence algorithms
- name: Seq.Indexed.take()
  id: seq.indexed/index#take()
  summary: Returns a new Collection of the same type which includes the first amount entries from this Collection
  belongs_to: Seq.Indexed
  description: |-
    #### [take()](index#take())

    Returns a new Collection of the same type which includes the first `amount` entries from this Collection.

    ``` ts
    take(amount: number): this
    ```

    #### Inherited from

    [`Collection#take()`](../collection/index#take())
- name: Seq.Indexed.takeLast()
  id: seq.indexed/index#takeLast()
  summary: Returns a new Collection of the same type which includes the last amount entries from this Collection
  belongs_to: Seq.Indexed
  description: |-
    #### [takeLast()](index#takeLast())

    Returns a new Collection of the same type which includes the last `amount` entries from this Collection.

    ``` ts
    takeLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#takeLast()`](../collection/index#takeLast())
- name: Seq.Indexed.takeUntil()
  id: seq.indexed/index#takeUntil()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns false
  belongs_to: Seq.Indexed
  description: |-
    #### [takeUntil()](index#takeUntil())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.

    ``` ts
    takeUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeUntil()`](../collection/index#takeUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeUntil(x => x.match(/at/))
    // List [ "dog", "frog" ]run it
    ```

    ### Reducing a value
- name: Seq.Indexed.takeWhile()
  id: seq.indexed/index#takeWhile()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns true
  belongs_to: Seq.Indexed
  description: |-
    #### [takeWhile()](index#takeWhile())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.

    ``` ts
    takeWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeWhile()`](../collection/index#takeWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeWhile(x => x.match(/o/))
    // List [ "dog", "frog" ]run it
    ```
- name: Seq.Indexed.toArray()
  id: seq.indexed/index#toArray()
  summary: Shallowly converts this collection to an Array
  belongs_to: Seq.Indexed
  description: |-
    #### [toArray()](index#toArray())

    Shallowly converts this collection to an Array.

    ``` ts
    toArray(): Array<T>
    ```

    #### Overrides

    [`Collection#toArray()`](../collection/index#toArray())
- name: Seq.Indexed.toIndexedSeq()
  id: seq.indexed/index#toIndexedSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Seq.Indexed
  description: |-
    #### [toIndexedSeq()](index#toIndexedSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    toIndexedSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())
- name: Seq.Indexed.toJS()
  id: seq.indexed/index#toJS()
  summary: Deeply converts this Indexed Seq to equivalent native JavaScript Array
  belongs_to: Seq.Indexed
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Indexed Seq to equivalent native JavaScript Array.

    ``` ts
    toJS(): Array<DeepCopy<T>>
    ```

    #### Overrides

    [`Collection#toJS()`](../collection/index#toJS())
- name: Seq.Indexed.toJSON()
  id: seq.indexed/index#toJSON()
  summary: Shallowly converts this Indexed Seq to equivalent native JavaScript Array
  belongs_to: Seq.Indexed
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Indexed Seq to equivalent native JavaScript Array.

    ``` ts
    toJSON(): Array<T>
    ```

    #### Overrides

    [`Collection#toJSON()`](../collection/index#toJSON())
- name: Seq.Indexed.toKeyedSeq()
  id: seq.indexed/index#toKeyedSeq()
  summary: Returns a Seq.Keyed from this Collection where indices are treated as keys
  belongs_to: Seq.Indexed
  description: |-
    #### [toKeyedSeq()](index#toKeyedSeq())

    Returns a Seq.Keyed from this Collection where indices are treated as keys.

    ``` ts
    toKeyedSeq(): Seq.Keyed<number, T>
    ```

    #### Inherited from

    [`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())

    #### Discussion

    This is useful if you want to operate on an Collection.Indexed and preserve the \[index, value\] pairs.

    The returned Seq will have identical iteration order as this Collection.

    ``` ts
    const { Seq } = require('immutable')
    const indexedSeq = Seq([ 'A', 'B', 'C' ])
    // Seq [ "A", "B", "C" ]
    indexedSeq.filter(v => v === 'B')
    // Seq [ "B" ]
    const keyedSeq = indexedSeq.toKeyedSeq()
    // Seq { 0: "A", 1: "B", 2: "C" }
    keyedSeq.filter(v => v === 'B')
    // Seq { 1: "B" }run it
    ```
- name: Seq.Indexed.toList()
  id: seq.indexed/index#toList()
  summary: Converts this Collection to a List, discarding keys
  belongs_to: Seq.Indexed
  description: |-
    #### [toList()](index#toList())

    Converts this Collection to a List, discarding keys.

    ``` ts
    toList(): List<T>
    ```

    #### Inherited from

    [`Collection#toList()`](../collection/index#toList())

    #### Discussion

    This is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.

    ``` ts
    const { Map, List } = require('immutable')
    var myMap = Map({ a: 'Apple', b: 'Banana' })
    List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
    myMap.toList() // List [ "Apple", "Banana" ]run it
    ```
- name: Seq.Indexed.toMap()
  id: seq.indexed/index#toMap()
  summary: Converts this Collection to a Map, Throws if keys are not hashable
  belongs_to: Seq.Indexed
  description: |-
    #### [toMap()](index#toMap())

    Converts this Collection to a Map, Throws if keys are not hashable.

    ``` ts
    toMap(): Map<number, T>
    ```

    #### Inherited from

    [`Collection#toMap()`](../collection/index#toMap())

    #### Discussion

    Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Seq.Indexed.toObject()
  id: seq.indexed/index#toObject()
  summary: Shallowly converts this Collection to an Object
  belongs_to: Seq.Indexed
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Collection to an Object.

    ``` ts
    toObject(): {[key: string]: T}
    ```

    #### Inherited from

    [`Collection#toObject()`](../collection/index#toObject())

    #### Discussion

    Converts keys to Strings.

    ### Conversion to Seq
- name: Seq.Indexed.toOrderedMap()
  id: seq.indexed/index#toOrderedMap()
  summary: Converts this Collection to a Map, maintaining the order of iteration
  belongs_to: Seq.Indexed
  description: |-
    #### [toOrderedMap()](index#toOrderedMap())

    Converts this Collection to a Map, maintaining the order of iteration.

    ``` ts
    toOrderedMap(): OrderedMap<number, T>
    ```

    #### Inherited from

    [`Collection#toOrderedMap()`](../collection/index#toOrderedMap())

    #### Discussion

    Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Seq.Indexed.toOrderedSet()
  id: seq.indexed/index#toOrderedSet()
  summary: Converts this Collection to a Set, maintaining the order of iteration and discarding keys
  belongs_to: Seq.Indexed
  description: |-
    #### [toOrderedSet()](index#toOrderedSet())

    Converts this Collection to a Set, maintaining the order of iteration and discarding keys.

    ``` ts
    toOrderedSet(): OrderedSet<T>
    ```

    #### Inherited from

    [`Collection#toOrderedSet()`](../collection/index#toOrderedSet())

    #### Discussion

    Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.
- name: Seq.Indexed.toSeq()
  id: seq.indexed/index#toSeq()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [toSeq()](index#toSeq())

    Returns itself

    ``` ts
    toSeq(): this
    ```

    #### Overrides

    [`Collection#toSeq()`](../collection/index#toSeq())
- name: Seq.Indexed.toSet()
  id: seq.indexed/index#toSet()
  summary: Converts this Collection to a Set, discarding keys
  belongs_to: Seq.Indexed
  description: |-
    #### [toSet()](index#toSet())

    Converts this Collection to a Set, discarding keys. Throws if values are not hashable.

    ``` ts
    toSet(): Set<T>
    ```

    #### Inherited from

    [`Collection#toSet()`](../collection/index#toSet())

    #### Discussion

    Note: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.
- name: Seq.Indexed.toSetSeq()
  id: seq.indexed/index#toSetSeq()
  summary: Returns a Seq.Set of the values of this Collection, discarding keys
  belongs_to: Seq.Indexed
  description: |-
    #### [toSetSeq()](index#toSetSeq())

    Returns a Seq.Set of the values of this Collection, discarding keys.

    ``` ts
    toSetSeq(): Seq.Set<T>
    ```

    #### Inherited from

    [`Collection#toSetSeq()`](../collection/index#toSetSeq())
- name: Seq.Indexed.toStack()
  id: seq.indexed/index#toStack()
  summary: Converts this Collection to a Stack, discarding keys
  belongs_to: Seq.Indexed
  description: |-
    #### [toStack()](index#toStack())

    Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.

    ``` ts
    toStack(): Stack<T>
    ```

    #### Inherited from

    [`Collection#toStack()`](../collection/index#toStack())

    #### Discussion

    Note: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.

    ### Collections (Seq)
- name: Seq.Indexed.update()
  id: seq.indexed/index#update()
  summary: This can be very useful as a way to "chain" a normal function into a sequence of methods
  belongs_to: Seq.Indexed
  description: |-
    #### [update()](index#update())

    This can be very useful as a way to "chain" a normal function into a sequence of methods. RxJS calls this "let" and lodash calls it "thru".

    ``` ts
    update<R>(updater: (value: this) => R): R
    ```

    #### Inherited from

    [`Collection#update()`](../collection/index#update())

    #### Discussion

    For example, to sum a Seq after mapping and filtering:

    ``` ts
    const { Seq } = require('immutable')

    function sum(collection) {
      return collection.reduce((sum, x) => sum + x, 0)
    }
    Seq([ 1, 2, 3 ])
      .map(x => x + 1)
      .filter(x => x % 2 === 0)
      .update(sum)
    // 6run it
    ```

    ### Conversion to Collections
- name: Seq.Indexed.values()
  id: seq.indexed/index#values()
  summary: An iterator of this Collection's values
  belongs_to: Seq.Indexed
  description: |-
    #### [values()](index#values())

    An iterator of this [`Collection`](../collection/index)'s values.

    ``` ts
    values(): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection#values()`](../collection/index#values())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.
- name: Seq.Indexed.valueSeq()
  id: seq.indexed/index#valueSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Seq.Indexed
  description: |-
    #### [valueSeq()](index#valueSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    valueSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#valueSeq()`](../collection/index#valueSeq())
- name: Seq.Indexed.zip()
  id: seq.indexed/index#zip()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [zip()](index#zip())

    ``` ts
    zip<U>(other: Collection<unknown, U>): Seq.Indexed<[T, U]>
    zip<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): Seq.Indexed<[T, U, V]>
    zip(...collections: Array<Collection<unknown, unknown>>): Seq.Indexed<unknown>
    ```

    #### Overrides

    [`Collection.Indexed#zip()`](../collection.indexed/index#zip())
- name: Seq.Indexed.zipAll()
  id: seq.indexed/index#zipAll()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [zipAll()](index#zipAll())

    ``` ts
    zipAll<U>(other: Collection<unknown, U>): Seq.Indexed<[T, U]>
    zipAll<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): Seq.Indexed<[T, U, V]>
    zipAll(...collections: Array<Collection<unknown, unknown>>): Seq.Indexed<unknown>
    ```

    #### Overrides

    [`Collection.Indexed#zipAll()`](../collection.indexed/index#zipAll())
- name: Seq.Indexed.zipWith()
  id: seq.indexed/index#zipWith()
  summary: null
  belongs_to: Seq.Indexed
  description: |-
    #### [zipWith()](index#zipWith())

    ``` ts
    zipWith<U, Z>(zipper: (value: T, otherValue: U) => Z,otherCollection: Collection<unknown, U>): Seq.Indexed<Z>
    zipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z,otherCollection: Collection<unknown, U>,thirdCollection: Collection<unknown, V>): Seq.Indexed<Z>
    zipWith<Z>(zipper: (...values: Array<unknown>) => Z,...collections: Array<Collection<unknown, unknown>>): Seq.Indexed<Z>
    ```

    #### Overrides

    [`Collection.Indexed#zipWith()`](../collection.indexed/index#zipWith())
- name: Seq.isEmpty()
  id: seq/index#isEmpty()
  summary: Returns true if this Collection includes no values
  belongs_to: Seq
  description: |-
    #### [isEmpty()](index#isEmpty())

    Returns true if this Collection includes no values.

    ``` ts
    isEmpty(): boolean
    ```

    #### Inherited from

    [`Collection#isEmpty()`](../collection/index#isEmpty())

    #### Discussion

    For some lazy [`Seq`](index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.
- name: Seq.isSubset()
  id: seq/index#isSubset()
  summary: True if iter includes every value in this Collection
  belongs_to: Seq
  description: |-
    #### [isSubset()](index#isSubset())

    True if `iter` includes every value in this Collection.

    ``` ts
    isSubset(iter: Iterable<V>): boolean
    ```

    #### Inherited from

    [`Collection#isSubset()`](../collection/index#isSubset())
- name: Seq.isSuperset()
  id: seq/index#isSuperset()
  summary: True if this Collection includes every value in iter
  belongs_to: Seq
  description: "#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Seq/](https://immutable-js.com/docs/v4.2.1/Seq/)"
- name: Seq.join()
  id: seq/index#join()
  summary: Joins values together as a string, inserting a separator between each
  belongs_to: Seq
  description: |-
    #### [join()](index#join())

    Joins values together as a string, inserting a separator between each. The default separator is `","`.

    ``` ts
    join(separator?: string): string
    ```

    #### Inherited from

    [`Collection#join()`](../collection/index#join())
- name: Seq.Keyed
  id: seq.keyed/index
  summary: Seq which represents key-value pairs
  description: "# Seq.Keyed\n\n[`Seq`](../seq/index) which represents key-value pairs.\n\n``` ts\ntype Seq.Keyed<K, V> extends Seq<K, V>, Collection.Keyed<K, V>\n```\n\n### Construction\n\n#### [Seq.Keyed()](index#Seq.Keyed())\n\n``` ts\nSeq.Keyed<K, V>(collection?: Iterable<[K, V]>): Seq.Keyed<K, V>\nSeq.Keyed<V>(obj: {[key: string]: V}): Seq.Keyed<string, V>\n```\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Keyed Seq to equivalent native JavaScript Object.\n\n``` ts\ntoJS(): {[key: string]: DeepCopy<V>}\n```\n\n#### Overrides\n\n[`Collection#toJS()`](../collection/index#toJS())\n\n#### Discussion\n\nConverts keys to Strings.\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Keyed Seq to equivalent native JavaScript Object.\n\n``` ts\ntoJSON(): {[key: string]: V}\n```\n\n#### Overrides\n\n[`Collection#toJSON()`](../collection/index#toJSON())\n\n#### Discussion\n\nConverts keys to Strings.\n\n#### [toArray()](index#toArray())\n\nShallowly converts this collection to an Array.\n\n``` ts\ntoArray(): Array<[K, V]>\n```\n\n#### Overrides\n\n[`Collection#toArray()`](../collection/index#toArray())\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Collection to an Object.\n\n``` ts\ntoObject(): {[key: string]: V}\n```\n\n#### Inherited from\n\n[`Collection#toObject()`](../collection/index#toObject())\n\n#### Discussion\n\nConverts keys to Strings.\n\n### Conversion to Seq\n\n#### [toSeq()](index#toSeq())\n\nReturns itself\n\n``` ts\ntoSeq(): this\n```\n\n#### Overrides\n\n[`Collection#toSeq()`](../collection/index#toSeq())\n\n#### [toKeyedSeq()](index#toKeyedSeq())\n\nReturns a Seq.Keyed from this Collection where indices are treated as keys.\n\n``` ts\ntoKeyedSeq(): Seq.Keyed<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())\n\n#### Discussion\n\nThis is useful if you want to operate on an Collection.Indexed and preserve the \\[index, value\\] pairs.\n\nThe returned Seq will have identical iteration order as this Collection.\n\n``` ts\nconst { Seq } = require('immutable')\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\n// Seq [ \"A\", \"B\", \"C\" ]\nindexedSeq.filter(v => v === 'B')\n// Seq [ \"B\" ]\nconst keyedSeq = indexedSeq.toKeyedSeq()\n// Seq { 0: \"A\", 1: \"B\", 2: \"C\" }\nkeyedSeq.filter(v => v === 'B')\n// Seq { 1: \"B\" }run it\n```\n\n#### [toIndexedSeq()](index#toIndexedSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\ntoIndexedSeq(): Seq.Indexed<V>\n```\n\n#### Inherited from\n\n[`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())\n\n#### [toSetSeq()](index#toSetSeq())\n\nReturns a Seq.Set of the values of this Collection, discarding keys.\n\n``` ts\ntoSetSeq(): Seq.Set<V>\n```\n\n#### Inherited from\n\n[`Collection#toSetSeq()`](../collection/index#toSetSeq())\n\n### Combination\n\n#### [concat()](index#concat())\n\n``` ts\nconcat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Seq.Keyed<K | KC, V | VC>\nconcat<C>(...collections: Array<{[key: string]: C}>): Seq.Keyed<K | string, V | C>\n```\n\n#### Overrides\n\n[`Collection#concat()`](../collection/index#concat())\n\n#### [flatten()](index#flatten())\n\n``` ts\nflatten(depth?: number): Collection<unknown, unknown>\nflatten(shallow?: boolean): Collection<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection#flatten()`](../collection/index#flatten())\n\n### Sequence algorithms\n\n#### [map()](index#map())\n\nReturns a new Seq.Keyed with values passed through a `mapper` function.\n\n``` ts\nmap<M>(mapper: (value: V, key: K, iter: this) => M,context?: unknown): Seq.Keyed<K, M>\n```\n\n#### Overrides\n\n[`Seq#map()`](../seq/index#map())\n\n#### Example\n\n``` ts\nconst { Seq } = require('immutable')\nSeq.Keyed({ a: 1, b: 2 }).map(x => 10 * x)\n// Seq { \"a\": 10, \"b\": 20 }\n```\n\nNote: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.\n\n#### [flatMap()](index#flatMap())\n\nFlat-maps the Seq, returning a Seq of the same type.\n\n``` ts\nflatMap<KM, VM>(mapper: (value: V, key: K, iter: this) => Iterable<[KM, VM]>,context?: unknown): Seq.Keyed<KM, VM>\n```\n\n#### Overrides\n\n[`Seq#flatMap()`](../seq/index#flatMap())\n\n#### Discussion\n\nSimilar to `seq.map(...).flatten(true)`.\n\n#### [filter()](index#filter())\n\n``` ts\nfilter<F>(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): Seq.Keyed<K, F>\nfilter(predicate: (value: V, key: K, iter: this) => unknown,context?: unknown): this\n```\n\n#### Overrides\n\n[`Seq#filter()`](../seq/index#filter())\n\n#### [partition()](index#partition())\n\n``` ts\npartition<F, C>(predicate: (this: C, value: V, key: K, iter: this) => boolean,context?: C): [Seq.Keyed<K, V>, Seq.Keyed<K, F>]\npartition<C>(predicate: (this: C, value: V, key: K, iter: this) => unknown,context?: C): [this, this]\n```\n\n#### Overrides\n\n[`Seq#partition()`](../seq/index#partition())\n\n#### [filterNot()](index#filterNot())\n\nReturns a new Collection of the same type with only the entries for which the `predicate` function returns false.\n\n``` ts\nfilterNot(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#filterNot()`](../collection/index#filterNot())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }run it\n```\n\nNote: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.\n\n#### [reverse()](index#reverse())\n\nReturns a new Collection of the same type in reverse order.\n\n``` ts\nreverse(): this\n```\n\n#### Inherited from\n\n[`Collection#reverse()`](../collection/index#reverse())\n\n#### [sort()](index#sort())\n\nReturns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.\n\n``` ts\nsort(comparator?: (valueA: V, valueB: V) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sort()`](../collection/index#sort())\n\n#### Discussion\n\nIf a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n- Returns `0` if the elements should not be swapped.\n- Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n- Returns `1` (or any positive number) if `valueA` comes after `valueB`\n- Is pure, i.e. it must always return the same value for the same pair of values.\n\nWhen sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n``` ts\nconst { Map } = require('immutable')\nMap({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// OrderedMap { \"a\": 1, \"b\": 2, \"c\": 3 }run it\n```\n\nNote: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [sortBy()](index#sortBy())\n\nLike [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:\n\n``` ts\nsortBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sortBy()`](../collection/index#sortBy())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst beattles = Map({\n  John: { name: \"Lennon\" },\n  Paul: { name: \"McCartney\" },\n  George: { name: \"Harrison\" },\n  Ringo: { name: \"Starr\" },\n});\nbeattles.sortBy(member => member.name);run it\n```\n\nNote: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [groupBy()](index#groupBy())\n\nReturns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.\n\n``` ts\ngroupBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<K, V>>\n```\n\n#### Inherited from\n\n[`Collection#groupBy()`](../collection/index#groupBy())\n\n#### Discussion\n\nNote: This is always an eager operation.\n\n``` ts\nconst { List, Map } = require('immutable')\nconst listOfMaps = List([\n  Map({ v: 0 }),\n  Map({ v: 1 }),\n  Map({ v: 1 }),\n  Map({ v: 0 }),\n  Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ Map{ \"v\": 0 }, Map { \"v\": 0 } ],\n//   1: List [ Map{ \"v\": 1 }, Map { \"v\": 1 } ],\n//   2: List [ Map{ \"v\": 2 } ],\n// }run it\n```\n\n### Sequence functions\n\n#### [mapKeys()](index#mapKeys())\n\n``` ts\nmapKeys<M>(mapper: (key: K, value: V, iter: this) => M,context?: unknown): Seq.Keyed<M, V>\n```\n\n#### Overrides\n\n[`Collection.Keyed#mapKeys()`](../collection.keyed/index#mapKeys())\n\n#### see\n\nCollection.Keyed.mapKeys\n\n#### [mapEntries()](index#mapEntries())\n\n``` ts\nmapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM] | undefined,context?: unknown): Seq.Keyed<KM, VM>\n```\n\n#### Overrides\n\n[`Collection.Keyed#mapEntries()`](../collection.keyed/index#mapEntries())\n\n#### see\n\nCollection.Keyed.mapEntries\n\n#### [flip()](index#flip())\n\n``` ts\nflip(): Seq.Keyed<V, K>\n```\n\n#### Overrides\n\n[`Collection.Keyed#flip()`](../collection.keyed/index#flip())\n\n#### see\n\nCollection.Keyed.flip\n\n### Iterators\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<[K, V]>\n```\n\n#### Overrides\n\n[`Collection#[Symbol.iterator]()`](../collection/index#%5BSymbol.iterator%5D())\n\n#### [keys()](index#keys())\n\nAn iterator of this [`Collection`](../collection/index)'s keys.\n\n``` ts\nkeys(): IterableIterator<K>\n```\n\n#### Inherited from\n\n[`Collection#keys()`](../collection/index#keys())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.\n\n#### [values()](index#values())\n\nAn iterator of this [`Collection`](../collection/index)'s values.\n\n``` ts\nvalues(): IterableIterator<V>\n```\n\n#### Inherited from\n\n[`Collection#values()`](../collection/index#values())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.\n\n#### [entries()](index#entries())\n\nAn iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.\n\n``` ts\nentries(): IterableIterator<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection#entries()`](../collection/index#entries())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.\n\n### Members\n\n#### [size](index#size)\n\nSome Seqs can describe their size lazily. When this is the case, size will be an integer. Otherwise it will be undefined.\n\n``` ts\nsize: number | undefined\n```\n\n#### Inherited from\n\n[`Seq#size`](../seq/index#size)\n\n#### Discussion\n\nFor example, Seqs returned from [`map()`](../seq/index#map()) or [`reverse()`](../seq/index#reverse()) preserve the size of the original [`Seq`](../seq/index) while [`filter()`](../seq/index#filter()) does not.\n\nNote: [`Range`](../range()/index), [`Repeat`](../repeat()/index) and [`Seq`](../seq/index)s made from [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)s and [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)s will always have a size.\n\n### Force evaluation\n\n#### [cacheResult()](index#cacheResult())\n\nBecause Sequences are lazy and designed to be chained together, they do not cache their results. For example, this map function is called a total of 6 times, as each [`join`](../seq/index#join()) iterates the Seq of three values.\n\n``` ts\ncacheResult(): this\n```\n\n#### Inherited from\n\n[`Seq#cacheResult()`](../seq/index#cacheResult())\n\n#### Discussion\n\n``` ts\nvar squares = Seq([ 1, 2, 3 ]).map(x => x  x)\nsquares.join() + squares.join()\n```\n\nIf you know a [`Seq`](../seq/index) will be used multiple times, it may be more efficient to first cache it in memory. Here, the map function is called only 3 times.\n\n``` ts\nvar squares = Seq([ 1, 2, 3 ]).map(x => x  x).cacheResult()\nsquares.join() + squares.join()\n```\n\nUse this method judiciously, as it must fully evaluate a Seq which can be a burden on memory and possibly performance.\n\nNote: after calling [`cacheResult`](../seq/index#cacheResult()), a Seq will always have a [`size`](../seq/index#size).\n\n### Value equality\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#equals()`](../collection/index#equals())\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Inherited from\n\n[`Collection#hashCode()`](../collection/index#hashCode())\n\n#### Discussion\n\nThe [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nIf two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.\n\n### Reading values\n\n#### [get()](index#get())\n\n``` ts\nget<NSV>(key: K, notSetValue: NSV): V | NSV\nget(key: K): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#get()`](../collection/index#get())\n\n#### [has()](index#has())\n\nTrue if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nhas(key: K): boolean\n```\n\n#### Inherited from\n\n[`Collection#has()`](../collection/index#has())\n\n#### [includes()](index#includes())\n\nTrue if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nincludes(value: V): boolean\n```\n\n#### Inherited from\n\n[`Collection#includes()`](../collection/index#includes())\n\n#### alias\n\n`contains()`\n\n#### [first()](index#first())\n\nIn case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nfirst<NSV>(notSetValue?: NSV): V | NSV\n```\n\n#### Inherited from\n\n[`Collection#first()`](../collection/index#first())\n\n#### [last()](index#last())\n\nIn case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nlast<NSV>(notSetValue?: NSV): V | NSV\n```\n\n#### Inherited from\n\n[`Collection#last()`](../collection/index#last())\n\n### Reading deep values\n\n#### [getIn()](index#getIn())\n\nReturns the value found by following a path of keys or indices through nested Collections.\n\n``` ts\ngetIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown\n```\n\n#### Inherited from\n\n[`Collection#getIn()`](../collection/index#getIn())\n\n#### Discussion\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: [ { y: 123 } ] });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\n#### [hasIn()](index#hasIn())\n\nTrue if the result of following a path of keys or indices through nested Collections results in a set value.\n\n``` ts\nhasIn(searchKeyPath: Iterable<unknown>): boolean\n```\n\n#### Inherited from\n\n[`Collection#hasIn()`](../collection/index#hasIn())\n\n### Persistent changes\n\n#### [update()](index#update())\n\nThis can be very useful as a way to \"chain\" a normal function into a sequence of methods. RxJS calls this \"let\" and lodash calls it \"thru\".\n\n``` ts\nupdate<R>(updater: (value: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#update()`](../collection/index#update())\n\n#### Discussion\n\nFor example, to sum a Seq after mapping and filtering:\n\n``` ts\nconst { Seq } = require('immutable')\n\nfunction sum(collection) {\n  return collection.reduce((sum, x) => sum + x, 0)\n}\nSeq([ 1, 2, 3 ])\n  .map(x => x + 1)\n  .filter(x => x % 2 === 0)\n  .update(sum)\n// 6run it\n```\n\n### Conversion to Collections\n\n#### [toMap()](index#toMap())\n\nConverts this Collection to a Map, Throws if keys are not hashable.\n\n``` ts\ntoMap(): Map<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toMap()`](../collection/index#toMap())\n\n#### Discussion\n\nNote: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toOrderedMap()](index#toOrderedMap())\n\nConverts this Collection to a Map, maintaining the order of iteration.\n\n``` ts\ntoOrderedMap(): OrderedMap<K, V>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedMap()`](../collection/index#toOrderedMap())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toSet()](index#toSet())\n\nConverts this Collection to a Set, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoSet(): Set<V>\n```\n\n#### Inherited from\n\n[`Collection#toSet()`](../collection/index#toSet())\n\n#### Discussion\n\nNote: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.\n\n#### [toOrderedSet()](index#toOrderedSet())\n\nConverts this Collection to a Set, maintaining the order of iteration and discarding keys.\n\n``` ts\ntoOrderedSet(): OrderedSet<V>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedSet()`](../collection/index#toOrderedSet())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toList()](index#toList())\n\nConverts this Collection to a List, discarding keys.\n\n``` ts\ntoList(): List<V>\n```\n\n#### Inherited from\n\n[`Collection#toList()`](../collection/index#toList())\n\n#### Discussion\n\nThis is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.\n\n``` ts\nconst { Map, List } = require('immutable')\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\nList(myMap) // List [ [ \"a\", \"Apple\" ], [ \"b\", \"Banana\" ] ]\nmyMap.toList() // List [ \"Apple\", \"Banana\" ]run it\n```\n\n#### [toStack()](index#toStack())\n\nConverts this Collection to a Stack, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoStack(): Stack<V>\n```\n\n#### Inherited from\n\n[`Collection#toStack()`](../collection/index#toStack())\n\n#### Discussion\n\nNote: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.\n\n### Collections (Seq)\n\n#### [keySeq()](index#keySeq())\n\nReturns a new Seq.Indexed of the keys of this Collection, discarding values.\n\n``` ts\nkeySeq(): Seq.Indexed<K>\n```\n\n#### Inherited from\n\n[`Collection#keySeq()`](../collection/index#keySeq())\n\n#### [valueSeq()](index#valueSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\nvalueSeq(): Seq.Indexed<V>\n```\n\n#### Inherited from\n\n[`Collection#valueSeq()`](../collection/index#valueSeq())\n\n#### [entrySeq()](index#entrySeq())\n\nReturns a new Seq.Indexed of \\[key, value\\] tuples.\n\n``` ts\nentrySeq(): Seq.Indexed<[K, V]>\n```\n\n#### Inherited from\n\n[`Collection#entrySeq()`](../collection/index#entrySeq())\n\n### Side effects\n\n#### [forEach()](index#forEach())\n\nThe `sideEffect` is executed for every entry in the Collection.\n\n``` ts\nforEach(sideEffect: (value: V, key: K, iter: this) => unknown,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#forEach()`](../collection/index#forEach())\n\n#### Discussion\n\nUnlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).\n\n### Creating subsets\n\n#### [slice()](index#slice())\n\nReturns a new Collection of the same type representing a portion of this Collection from start up to but not including end.\n\n``` ts\nslice(begin?: number, end?: number): this\n```\n\n#### Inherited from\n\n[`Collection#slice()`](../collection/index#slice())\n\n#### Discussion\n\nIf begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.\n\nIf the requested slice is equivalent to the current Collection, then it will return itself.\n\n#### [rest()](index#rest())\n\nReturns a new Collection of the same type containing all entries except the first.\n\n``` ts\nrest(): this\n```\n\n#### Inherited from\n\n[`Collection#rest()`](../collection/index#rest())\n\n#### [butLast()](index#butLast())\n\nReturns a new Collection of the same type containing all entries except the last.\n\n``` ts\nbutLast(): this\n```\n\n#### Inherited from\n\n[`Collection#butLast()`](../collection/index#butLast())\n\n#### [skip()](index#skip())\n\nReturns a new Collection of the same type which excludes the first `amount` entries from this Collection.\n\n``` ts\nskip(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skip()`](../collection/index#skip())\n\n#### [skipLast()](index#skipLast())\n\nReturns a new Collection of the same type which excludes the last `amount` entries from this Collection.\n\n``` ts\nskipLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skipLast()`](../collection/index#skipLast())\n\n#### [skipWhile()](index#skipWhile())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns false.\n\n``` ts\nskipWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipWhile()`](../collection/index#skipWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipWhile(x => x.match(/g/))\n// List [ \"cat\", \"hat\", \"god\" ]run it\n```\n\n#### [skipUntil()](index#skipUntil())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns true.\n\n``` ts\nskipUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipUntil()`](../collection/index#skipUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipUntil(x => x.match(/hat/))\n// List [ \"hat\", \"god\" ]run it\n```\n\n#### [take()](index#take())\n\nReturns a new Collection of the same type which includes the first `amount` entries from this Collection.\n\n``` ts\ntake(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#take()`](../collection/index#take())\n\n#### [takeLast()](index#takeLast())\n\nReturns a new Collection of the same type which includes the last `amount` entries from this Collection.\n\n``` ts\ntakeLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#takeLast()`](../collection/index#takeLast())\n\n#### [takeWhile()](index#takeWhile())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.\n\n``` ts\ntakeWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeWhile()`](../collection/index#takeWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeWhile(x => x.match(/o/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n#### [takeUntil()](index#takeUntil())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.\n\n``` ts\ntakeUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeUntil()`](../collection/index#takeUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeUntil(x => x.match(/at/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n### Reducing a value\n\n#### [reduce()](index#reduce())\n\n``` ts\nreduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R\nreduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduce()`](../collection/index#reduce())\n\n#### [reduceRight()](index#reduceRight())\n\n``` ts\nreduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R\nreduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduceRight()`](../collection/index#reduceRight())\n\n#### [every()](index#every())\n\nTrue if `predicate` returns true for all entries in the Collection.\n\n``` ts\nevery(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#every()`](../collection/index#every())\n\n#### [some()](index#some())\n\nTrue if `predicate` returns true for any entry in the Collection.\n\n``` ts\nsome(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#some()`](../collection/index#some())\n\n#### [join()](index#join())\n\nJoins values together as a string, inserting a separator between each. The default separator is `\",\"`.\n\n``` ts\njoin(separator?: string): string\n```\n\n#### Inherited from\n\n[`Collection#join()`](../collection/index#join())\n\n#### [isEmpty()](index#isEmpty())\n\nReturns true if this Collection includes no values.\n\n``` ts\nisEmpty(): boolean\n```\n\n#### Inherited from\n\n[`Collection#isEmpty()`](../collection/index#isEmpty())\n\n#### Discussion\n\nFor some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.\n\n#### [count()](index#count())\n\n``` ts\ncount(): number\ncount(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#count()`](../collection/index#count())\n\n#### [countBy()](index#countBy())\n\nReturns a [`Seq.Keyed`](index) of counts, grouped by the return value of the `grouper` function.\n\n``` ts\ncountBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Map<G, number>\n```\n\n#### Inherited from\n\n[`Collection#countBy()`](../collection/index#countBy())\n\n#### Discussion\n\nNote: This is not a lazy operation.\n\n### Search for value\n\n#### [find()](index#find())\n\nReturns the first value for which the `predicate` returns true.\n\n``` ts\nfind(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#find()`](../collection/index#find())\n\n#### [findLast()](index#findLast())\n\nReturns the last value for which the `predicate` returns true.\n\n``` ts\nfindLast(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLast()`](../collection/index#findLast())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findEntry()](index#findEntry())\n\nReturns the first \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findEntry()`](../collection/index#findEntry())\n\n#### [findLastEntry()](index#findLastEntry())\n\nReturns the last \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindLastEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastEntry()`](../collection/index#findLastEntry())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findKey()](index#findKey())\n\nReturns the key for which the `predicate` returns true.\n\n``` ts\nfindKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#findKey()`](../collection/index#findKey())\n\n#### [findLastKey()](index#findLastKey())\n\nReturns the last key for which the `predicate` returns true.\n\n``` ts\nfindLastKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastKey()`](../collection/index#findLastKey())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [keyOf()](index#keyOf())\n\nReturns the key associated with the search value, or undefined.\n\n``` ts\nkeyOf(searchValue: V): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#keyOf()`](../collection/index#keyOf())\n\n#### [lastKeyOf()](index#lastKeyOf())\n\nReturns the last key associated with the search value, or undefined.\n\n``` ts\nlastKeyOf(searchValue: V): K | undefined\n```\n\n#### Inherited from\n\n[`Collection#lastKeyOf()`](../collection/index#lastKeyOf())\n\n#### [max()](index#max())\n\nReturns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmax(comparator?: (valueA: V, valueB: V) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#max()`](../collection/index#max())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [maxBy()](index#maxBy())\n\nLike [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nmaxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#maxBy()`](../collection/index#maxBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it\n```\n\n#### [min()](index#min())\n\nReturns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmin(comparator?: (valueA: V, valueB: V) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#min()`](../collection/index#min())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [minBy()](index#minBy())\n\nLike [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nminBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined\n```\n\n#### Inherited from\n\n[`Collection#minBy()`](../collection/index#minBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it\n```\n\n### Comparison\n\n#### [isSubset()](index#isSubset())\n\nTrue if `iter` includes every value in this Collection.\n\n``` ts\nisSubset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSubset()`](../collection/index#isSubset())\n\n#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Seq.Keyed/](https://immutable-js.com/docs/v4.2.1/Seq.Keyed/)"
- name: Seq.Keyed.[Symbol.iterator]()
  id: seq.keyed/index#[Symbol.iterator]()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [\[Symbol.iterator\]()](index#%5BSymbol.iterator%5D())

    ``` ts
    [Symbol.iterator](): IterableIterator<[K, V]>
    ```

    #### Overrides

    [`Collection#[Symbol.iterator]()`](../collection/index#%5BSymbol.iterator%5D())
- name: Seq.Keyed.butLast()
  id: seq.keyed/index#butLast()
  summary: Returns a new Collection of the same type containing all entries except the last
  belongs_to: Seq.Keyed
  description: |-
    #### [butLast()](index#butLast())

    Returns a new Collection of the same type containing all entries except the last.

    ``` ts
    butLast(): this
    ```

    #### Inherited from

    [`Collection#butLast()`](../collection/index#butLast())
- name: Seq.Keyed.cacheResult()
  id: seq.keyed/index#cacheResult()
  summary: Because Sequences are lazy and designed to be chained together, they do not cache their results
  belongs_to: Seq.Keyed
  description: |-
    #### [cacheResult()](index#cacheResult())

    Because Sequences are lazy and designed to be chained together, they do not cache their results. For example, this map function is called a total of 6 times, as each [`join`](../seq/index#join()) iterates the Seq of three values.

    ``` ts
    cacheResult(): this
    ```

    #### Inherited from

    [`Seq#cacheResult()`](../seq/index#cacheResult())

    #### Discussion

    ``` ts
    var squares = Seq([ 1, 2, 3 ]).map(x => x  x)
    squares.join() + squares.join()
    ```

    If you know a [`Seq`](../seq/index) will be used multiple times, it may be more efficient to first cache it in memory. Here, the map function is called only 3 times.

    ``` ts
    var squares = Seq([ 1, 2, 3 ]).map(x => x  x).cacheResult()
    squares.join() + squares.join()
    ```

    Use this method judiciously, as it must fully evaluate a Seq which can be a burden on memory and possibly performance.

    Note: after calling [`cacheResult`](../seq/index#cacheResult()), a Seq will always have a [`size`](../seq/index#size).

    ### Value equality
- name: Seq.Keyed.concat()
  id: seq.keyed/index#concat()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [concat()](index#concat())

    ``` ts
    concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Seq.Keyed<K | KC, V | VC>
    concat<C>(...collections: Array<{[key: string]: C}>): Seq.Keyed<K | string, V | C>
    ```

    #### Overrides

    [`Collection#concat()`](../collection/index#concat())
- name: Seq.Keyed.count()
  id: seq.keyed/index#count()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [count()](index#count())

    ``` ts
    count(): number
    count(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#count()`](../collection/index#count())
- name: Seq.Keyed.countBy()
  id: seq.keyed/index#countBy()
  summary: Returns a Seq.Keyed of counts, grouped by the return value of the grouper function
  belongs_to: Seq.Keyed
  description: |-
    #### [countBy()](index#countBy())

    Returns a [`Seq.Keyed`](index) of counts, grouped by the return value of the `grouper` function.

    ``` ts
    countBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Map<G, number>
    ```

    #### Inherited from

    [`Collection#countBy()`](../collection/index#countBy())

    #### Discussion

    Note: This is not a lazy operation.

    ### Search for value
- name: Seq.Keyed.entries()
  id: seq.keyed/index#entries()
  summary: An iterator of this Collection's entries as [ key, value ] tuples
  belongs_to: Seq.Keyed
  description: |-
    #### [entries()](index#entries())

    An iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.

    ``` ts
    entries(): IterableIterator<[K, V]>
    ```

    #### Inherited from

    [`Collection#entries()`](../collection/index#entries())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.

    ### Members
- name: Seq.Keyed.entrySeq()
  id: seq.keyed/index#entrySeq()
  summary: Returns a new Seq.Indexed of [key, value] tuples
  belongs_to: Seq.Keyed
  description: |-
    #### [entrySeq()](index#entrySeq())

    Returns a new Seq.Indexed of \[key, value\] tuples.

    ``` ts
    entrySeq(): Seq.Indexed<[K, V]>
    ```

    #### Inherited from

    [`Collection#entrySeq()`](../collection/index#entrySeq())

    ### Side effects
- name: Seq.Keyed.equals()
  id: seq.keyed/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: Seq.Keyed
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Inherited from

    [`Collection#equals()`](../collection/index#equals())

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: Seq.Keyed.every()
  id: seq.keyed/index#every()
  summary: True if predicate returns true for all entries in the Collection
  belongs_to: Seq.Keyed
  description: |-
    #### [every()](index#every())

    True if `predicate` returns true for all entries in the Collection.

    ``` ts
    every(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#every()`](../collection/index#every())
- name: Seq.Keyed.filter()
  id: seq.keyed/index#filter()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [filter()](index#filter())

    ``` ts
    filter<F>(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): Seq.Keyed<K, F>
    filter(predicate: (value: V, key: K, iter: this) => unknown,context?: unknown): this
    ```

    #### Overrides

    [`Seq#filter()`](../seq/index#filter())
- name: Seq.Keyed.filterNot()
  id: seq.keyed/index#filterNot()
  summary: Returns a new Collection of the same type with only the entries for which the predicate function returns false
  belongs_to: Seq.Keyed
  description: |-
    #### [filterNot()](index#filterNot())

    Returns a new Collection of the same type with only the entries for which the `predicate` function returns false.

    ``` ts
    filterNot(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#filterNot()`](../collection/index#filterNot())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
    // Map { "a": 1, "c": 3 }run it
    ```

    Note: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.
- name: Seq.Keyed.find()
  id: seq.keyed/index#find()
  summary: Returns the first value for which the predicate returns true
  belongs_to: Seq.Keyed
  description: |-
    #### [find()](index#find())

    Returns the first value for which the `predicate` returns true.

    ``` ts
    find(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined
    ```

    #### Inherited from

    [`Collection#find()`](../collection/index#find())
- name: Seq.Keyed.findEntry()
  id: seq.keyed/index#findEntry()
  summary: Returns the first [key, value] entry for which the predicate returns true
  belongs_to: Seq.Keyed
  description: |-
    #### [findEntry()](index#findEntry())

    Returns the first \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
    ```

    #### Inherited from

    [`Collection#findEntry()`](../collection/index#findEntry())
- name: Seq.Keyed.findKey()
  id: seq.keyed/index#findKey()
  summary: Returns the key for which the predicate returns true
  belongs_to: Seq.Keyed
  description: |-
    #### [findKey()](index#findKey())

    Returns the key for which the `predicate` returns true.

    ``` ts
    findKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined
    ```

    #### Inherited from

    [`Collection#findKey()`](../collection/index#findKey())
- name: Seq.Keyed.findLast()
  id: seq.keyed/index#findLast()
  summary: Returns the last value for which the predicate returns true
  belongs_to: Seq.Keyed
  description: |-
    #### [findLast()](index#findLast())

    Returns the last value for which the `predicate` returns true.

    ``` ts
    findLast(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): V | undefined
    ```

    #### Inherited from

    [`Collection#findLast()`](../collection/index#findLast())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Seq.Keyed.findLastEntry()
  id: seq.keyed/index#findLastEntry()
  summary: Returns the last [key, value] entry for which the predicate returns true
  belongs_to: Seq.Keyed
  description: |-
    #### [findLastEntry()](index#findLastEntry())

    Returns the last \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findLastEntry(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
    ```

    #### Inherited from

    [`Collection#findLastEntry()`](../collection/index#findLastEntry())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Seq.Keyed.findLastKey()
  id: seq.keyed/index#findLastKey()
  summary: Returns the last key for which the predicate returns true
  belongs_to: Seq.Keyed
  description: |-
    #### [findLastKey()](index#findLastKey())

    Returns the last key for which the `predicate` returns true.

    ``` ts
    findLastKey(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): K | undefined
    ```

    #### Inherited from

    [`Collection#findLastKey()`](../collection/index#findLastKey())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Seq.Keyed.first()
  id: seq.keyed/index#first()
  summary: In case the Collection is not empty returns the first element of the Collection
  belongs_to: Seq.Keyed
  description: |-
    #### [first()](index#first())

    In case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    first<NSV>(notSetValue?: NSV): V | NSV
    ```

    #### Inherited from

    [`Collection#first()`](../collection/index#first())
- name: Seq.Keyed.flatMap()
  id: seq.keyed/index#flatMap()
  summary: Flat-maps the Seq, returning a Seq of the same type
  belongs_to: Seq.Keyed
  description: |-
    #### [flatMap()](index#flatMap())

    Flat-maps the Seq, returning a Seq of the same type.

    ``` ts
    flatMap<KM, VM>(mapper: (value: V, key: K, iter: this) => Iterable<[KM, VM]>,context?: unknown): Seq.Keyed<KM, VM>
    ```

    #### Overrides

    [`Seq#flatMap()`](../seq/index#flatMap())

    #### Discussion

    Similar to `seq.map(...).flatten(true)`.
- name: Seq.Keyed.flatten()
  id: seq.keyed/index#flatten()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [flatten()](index#flatten())

    ``` ts
    flatten(depth?: number): Collection<unknown, unknown>
    flatten(shallow?: boolean): Collection<unknown, unknown>
    ```

    #### Inherited from

    [`Collection#flatten()`](../collection/index#flatten())

    ### Sequence algorithms
- name: Seq.Keyed.flip()
  id: seq.keyed/index#flip()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [flip()](index#flip())

    ``` ts
    flip(): Seq.Keyed<V, K>
    ```

    #### Overrides

    [`Collection.Keyed#flip()`](../collection.keyed/index#flip())

    #### see

    Collection.Keyed.flip

    ### Iterators
- name: Seq.Keyed.forEach()
  id: seq.keyed/index#forEach()
  summary: The sideEffect is executed for every entry in the Collection
  belongs_to: Seq.Keyed
  description: |-
    #### [forEach()](index#forEach())

    The `sideEffect` is executed for every entry in the Collection.

    ``` ts
    forEach(sideEffect: (value: V, key: K, iter: this) => unknown,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#forEach()`](../collection/index#forEach())

    #### Discussion

    Unlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).

    ### Creating subsets
- name: Seq.Keyed.get()
  id: seq.keyed/index#get()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [get()](index#get())

    ``` ts
    get<NSV>(key: K, notSetValue: NSV): V | NSV
    get(key: K): V | undefined
    ```

    #### Inherited from

    [`Collection#get()`](../collection/index#get())
- name: Seq.Keyed.getIn()
  id: seq.keyed/index#getIn()
  summary: Returns the value found by following a path of keys or indices through nested Collections
  belongs_to: Seq.Keyed
  description: |-
    #### [getIn()](index#getIn())

    Returns the value found by following a path of keys or indices through nested Collections.

    ``` ts
    getIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown
    ```

    #### Inherited from

    [`Collection#getIn()`](../collection/index#getIn())

    #### Discussion

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: [ { y: 123 } ] });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```
- name: Seq.Keyed.groupBy()
  id: seq.keyed/index#groupBy()
  summary: Returns a Collection.Keyed of Collection.Keyeds, grouped by the return value of the grouper function
  belongs_to: Seq.Keyed
  description: |-
    #### [groupBy()](index#groupBy())

    Returns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.

    ``` ts
    groupBy<G>(grouper: (value: V, key: K, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<K, V>>
    ```

    #### Inherited from

    [`Collection#groupBy()`](../collection/index#groupBy())

    #### Discussion

    Note: This is always an eager operation.

    ``` ts
    const { List, Map } = require('immutable')
    const listOfMaps = List([
      Map({ v: 0 }),
      Map({ v: 1 }),
      Map({ v: 1 }),
      Map({ v: 0 }),
      Map({ v: 2 })
    ])
    const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
    // Map {
    //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
    //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
    //   2: List [ Map{ "v": 2 } ],
    // }run it
    ```

    ### Sequence functions
- name: Seq.Keyed.has()
  id: seq.keyed/index#has()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [has()](index#has())

    True if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    has(key: K): boolean
    ```

    #### Inherited from

    [`Collection#has()`](../collection/index#has())
- name: Seq.Keyed.hashCode()
  id: seq.keyed/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: Seq.Keyed
  description: |-
    #### [hashCode()](index#hashCode())

    Computes and returns the hashed identity for this Collection.

    ``` ts
    hashCode(): number
    ```

    #### Inherited from

    [`Collection#hashCode()`](../collection/index#hashCode())

    #### Discussion

    The [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.

    ``` ts
    const a = List([ 1, 2, 3 ]);
    const b = List([ 1, 2, 3 ]);
    assert.notStrictEqual(a, b); // different instances
    const set = Set([ a ]);
    assert.equal(set.has(b), true);run it
    ```

    If two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.

    ### Reading values
- name: Seq.Keyed.hasIn()
  id: seq.keyed/index#hasIn()
  summary: True if the result of following a path of keys or indices through nested Collections results in a set value
  belongs_to: Seq.Keyed
  description: |-
    #### [hasIn()](index#hasIn())

    True if the result of following a path of keys or indices through nested Collections results in a set value.

    ``` ts
    hasIn(searchKeyPath: Iterable<unknown>): boolean
    ```

    #### Inherited from

    [`Collection#hasIn()`](../collection/index#hasIn())

    ### Persistent changes
- name: Seq.Keyed.includes()
  id: seq.keyed/index#includes()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [includes()](index#includes())

    True if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    includes(value: V): boolean
    ```

    #### Inherited from

    [`Collection#includes()`](../collection/index#includes())

    #### alias

    `contains()`
- name: Seq.Keyed.isEmpty()
  id: seq.keyed/index#isEmpty()
  summary: Returns true if this Collection includes no values
  belongs_to: Seq.Keyed
  description: |-
    #### [isEmpty()](index#isEmpty())

    Returns true if this Collection includes no values.

    ``` ts
    isEmpty(): boolean
    ```

    #### Inherited from

    [`Collection#isEmpty()`](../collection/index#isEmpty())

    #### Discussion

    For some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.
- name: Seq.Keyed.isSubset()
  id: seq.keyed/index#isSubset()
  summary: True if iter includes every value in this Collection
  belongs_to: Seq.Keyed
  description: |-
    #### [isSubset()](index#isSubset())

    True if `iter` includes every value in this Collection.

    ``` ts
    isSubset(iter: Iterable<V>): boolean
    ```

    #### Inherited from

    [`Collection#isSubset()`](../collection/index#isSubset())
- name: Seq.Keyed.isSuperset()
  id: seq.keyed/index#isSuperset()
  summary: True if this Collection includes every value in iter
  belongs_to: Seq.Keyed
  description: "#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<V>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Seq.Keyed/](https://immutable-js.com/docs/v4.2.1/Seq.Keyed/)"
- name: Seq.Keyed.join()
  id: seq.keyed/index#join()
  summary: Joins values together as a string, inserting a separator between each
  belongs_to: Seq.Keyed
  description: |-
    #### [join()](index#join())

    Joins values together as a string, inserting a separator between each. The default separator is `","`.

    ``` ts
    join(separator?: string): string
    ```

    #### Inherited from

    [`Collection#join()`](../collection/index#join())
- name: Seq.Keyed.keyOf()
  id: seq.keyed/index#keyOf()
  summary: Returns the key associated with the search value, or undefined
  belongs_to: Seq.Keyed
  description: |-
    #### [keyOf()](index#keyOf())

    Returns the key associated with the search value, or undefined.

    ``` ts
    keyOf(searchValue: V): K | undefined
    ```

    #### Inherited from

    [`Collection#keyOf()`](../collection/index#keyOf())
- name: Seq.Keyed.keys()
  id: seq.keyed/index#keys()
  summary: An iterator of this Collection's keys
  belongs_to: Seq.Keyed
  description: |-
    #### [keys()](index#keys())

    An iterator of this [`Collection`](../collection/index)'s keys.

    ``` ts
    keys(): IterableIterator<K>
    ```

    #### Inherited from

    [`Collection#keys()`](../collection/index#keys())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.
- name: Seq.Keyed.keySeq()
  id: seq.keyed/index#keySeq()
  summary: Returns a new Seq.Indexed of the keys of this Collection, discarding values
  belongs_to: Seq.Keyed
  description: |-
    #### [keySeq()](index#keySeq())

    Returns a new Seq.Indexed of the keys of this Collection, discarding values.

    ``` ts
    keySeq(): Seq.Indexed<K>
    ```

    #### Inherited from

    [`Collection#keySeq()`](../collection/index#keySeq())
- name: Seq.Keyed.last()
  id: seq.keyed/index#last()
  summary: In case the Collection is not empty returns the last element of the Collection
  belongs_to: Seq.Keyed
  description: |-
    #### [last()](index#last())

    In case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    last<NSV>(notSetValue?: NSV): V | NSV
    ```

    #### Inherited from

    [`Collection#last()`](../collection/index#last())

    ### Reading deep values
- name: Seq.Keyed.lastKeyOf()
  id: seq.keyed/index#lastKeyOf()
  summary: Returns the last key associated with the search value, or undefined
  belongs_to: Seq.Keyed
  description: |-
    #### [lastKeyOf()](index#lastKeyOf())

    Returns the last key associated with the search value, or undefined.

    ``` ts
    lastKeyOf(searchValue: V): K | undefined
    ```

    #### Inherited from

    [`Collection#lastKeyOf()`](../collection/index#lastKeyOf())
- name: Seq.Keyed.map()
  id: seq.keyed/index#map()
  summary: Returns a new Seq.Keyed with values passed through a mapper function
  belongs_to: Seq.Keyed
  description: |-
    #### [map()](index#map())

    Returns a new Seq.Keyed with values passed through a `mapper` function.

    ``` ts
    map<M>(mapper: (value: V, key: K, iter: this) => M,context?: unknown): Seq.Keyed<K, M>
    ```

    #### Overrides

    [`Seq#map()`](../seq/index#map())

    #### Example

    ``` ts
    const { Seq } = require('immutable')
    Seq.Keyed({ a: 1, b: 2 }).map(x => 10 * x)
    // Seq { "a": 10, "b": 20 }
    ```

    Note: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.
- name: Seq.Keyed.mapEntries()
  id: seq.keyed/index#mapEntries()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [mapEntries()](index#mapEntries())

    ``` ts
    mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM] | undefined,context?: unknown): Seq.Keyed<KM, VM>
    ```

    #### Overrides

    [`Collection.Keyed#mapEntries()`](../collection.keyed/index#mapEntries())

    #### see

    Collection.Keyed.mapEntries
- name: Seq.Keyed.mapKeys()
  id: seq.keyed/index#mapKeys()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [mapKeys()](index#mapKeys())

    ``` ts
    mapKeys<M>(mapper: (key: K, value: V, iter: this) => M,context?: unknown): Seq.Keyed<M, V>
    ```

    #### Overrides

    [`Collection.Keyed#mapKeys()`](../collection.keyed/index#mapKeys())

    #### see

    Collection.Keyed.mapKeys
- name: Seq.Keyed.max()
  id: seq.keyed/index#max()
  summary: Returns the maximum value in this collection
  belongs_to: Seq.Keyed
  description: |-
    #### [max()](index#max())

    Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    max(comparator?: (valueA: V, valueB: V) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#max()`](../collection/index#max())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Seq.Keyed.maxBy()
  id: seq.keyed/index#maxBy()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [maxBy()](index#maxBy())

    Like [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    maxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#maxBy()`](../collection/index#maxBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it
    ```
- name: Seq.Keyed.min()
  id: seq.keyed/index#min()
  summary: Returns the minimum value in this collection
  belongs_to: Seq.Keyed
  description: |-
    #### [min()](index#min())

    Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    min(comparator?: (valueA: V, valueB: V) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#min()`](../collection/index#min())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Seq.Keyed.minBy()
  id: seq.keyed/index#minBy()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [minBy()](index#minBy())

    Like [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    minBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#minBy()`](../collection/index#minBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it
    ```

    ### Comparison
- name: Seq.Keyed.partition()
  id: seq.keyed/index#partition()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [partition()](index#partition())

    ``` ts
    partition<F, C>(predicate: (this: C, value: V, key: K, iter: this) => boolean,context?: C): [Seq.Keyed<K, V>, Seq.Keyed<K, F>]
    partition<C>(predicate: (this: C, value: V, key: K, iter: this) => unknown,context?: C): [this, this]
    ```

    #### Overrides

    [`Seq#partition()`](../seq/index#partition())
- name: Seq.Keyed.reduce()
  id: seq.keyed/index#reduce()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [reduce()](index#reduce())

    ``` ts
    reduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R
    reduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduce()`](../collection/index#reduce())
- name: Seq.Keyed.reduceRight()
  id: seq.keyed/index#reduceRight()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [reduceRight()](index#reduceRight())

    ``` ts
    reduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R
    reduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduceRight()`](../collection/index#reduceRight())
- name: Seq.Keyed.rest()
  id: seq.keyed/index#rest()
  summary: Returns a new Collection of the same type containing all entries except the first
  belongs_to: Seq.Keyed
  description: |-
    #### [rest()](index#rest())

    Returns a new Collection of the same type containing all entries except the first.

    ``` ts
    rest(): this
    ```

    #### Inherited from

    [`Collection#rest()`](../collection/index#rest())
- name: Seq.Keyed.reverse()
  id: seq.keyed/index#reverse()
  summary: Returns a new Collection of the same type in reverse order
  belongs_to: Seq.Keyed
  description: |-
    #### [reverse()](index#reverse())

    Returns a new Collection of the same type in reverse order.

    ``` ts
    reverse(): this
    ```

    #### Inherited from

    [`Collection#reverse()`](../collection/index#reverse())
- name: Seq.Keyed.Seq.Keyed()
  id: seq.keyed/index#Seq.Keyed()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [Seq.Keyed()](index#Seq.Keyed())

    ``` ts
    Seq.Keyed<K, V>(collection?: Iterable<[K, V]>): Seq.Keyed<K, V>
    Seq.Keyed<V>(obj: {[key: string]: V}): Seq.Keyed<string, V>
    ```

    ### Conversion to JavaScript types
- name: Seq.Keyed.size
  id: seq.keyed/index#size
  summary: Some Seqs can describe their size lazily
  belongs_to: Seq.Keyed
  description: |-
    #### [size](index#size)

    Some Seqs can describe their size lazily. When this is the case, size will be an integer. Otherwise it will be undefined.

    ``` ts
    size: number | undefined
    ```

    #### Inherited from

    [`Seq#size`](../seq/index#size)

    #### Discussion

    For example, Seqs returned from [`map()`](../seq/index#map()) or [`reverse()`](../seq/index#reverse()) preserve the size of the original [`Seq`](../seq/index) while [`filter()`](../seq/index#filter()) does not.

    Note: [`Range`](../range()/index), [`Repeat`](../repeat()/index) and [`Seq`](../seq/index)s made from [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)s and [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)s will always have a size.

    ### Force evaluation
- name: Seq.Keyed.skip()
  id: seq.keyed/index#skip()
  summary: Returns a new Collection of the same type which excludes the first amount entries from this Collection
  belongs_to: Seq.Keyed
  description: |-
    #### [skip()](index#skip())

    Returns a new Collection of the same type which excludes the first `amount` entries from this Collection.

    ``` ts
    skip(amount: number): this
    ```

    #### Inherited from

    [`Collection#skip()`](../collection/index#skip())
- name: Seq.Keyed.skipLast()
  id: seq.keyed/index#skipLast()
  summary: Returns a new Collection of the same type which excludes the last amount entries from this Collection
  belongs_to: Seq.Keyed
  description: |-
    #### [skipLast()](index#skipLast())

    Returns a new Collection of the same type which excludes the last `amount` entries from this Collection.

    ``` ts
    skipLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#skipLast()`](../collection/index#skipLast())
- name: Seq.Keyed.skipUntil()
  id: seq.keyed/index#skipUntil()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns true
  belongs_to: Seq.Keyed
  description: |-
    #### [skipUntil()](index#skipUntil())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns true.

    ``` ts
    skipUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipUntil()`](../collection/index#skipUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipUntil(x => x.match(/hat/))
    // List [ "hat", "god" ]run it
    ```
- name: Seq.Keyed.skipWhile()
  id: seq.keyed/index#skipWhile()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns false
  belongs_to: Seq.Keyed
  description: |-
    #### [skipWhile()](index#skipWhile())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns false.

    ``` ts
    skipWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipWhile()`](../collection/index#skipWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipWhile(x => x.match(/g/))
    // List [ "cat", "hat", "god" ]run it
    ```
- name: Seq.Keyed.slice()
  id: seq.keyed/index#slice()
  summary: Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end
  belongs_to: Seq.Keyed
  description: |-
    #### [slice()](index#slice())

    Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.

    ``` ts
    slice(begin?: number, end?: number): this
    ```

    #### Inherited from

    [`Collection#slice()`](../collection/index#slice())

    #### Discussion

    If begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.

    If end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.

    If the requested slice is equivalent to the current Collection, then it will return itself.
- name: Seq.Keyed.some()
  id: seq.keyed/index#some()
  summary: True if predicate returns true for any entry in the Collection
  belongs_to: Seq.Keyed
  description: |-
    #### [some()](index#some())

    True if `predicate` returns true for any entry in the Collection.

    ``` ts
    some(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#some()`](../collection/index#some())
- name: Seq.Keyed.sort()
  id: seq.keyed/index#sort()
  summary: Returns a new Collection of the same type which includes the same entries, stably sorted by using a comparator
  belongs_to: Seq.Keyed
  description: |-
    #### [sort()](index#sort())

    Returns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.

    ``` ts
    sort(comparator?: (valueA: V, valueB: V) => number): this
    ```

    #### Inherited from

    [`Collection#sort()`](../collection/index#sort())

    #### Discussion

    If a `comparator` is not provided, a default comparator uses `<` and `>`.

    `comparator(valueA, valueB)`:

    - Returns `0` if the elements should not be swapped.
    - Returns `-1` (or any negative number) if `valueA` comes before `valueB`
    - Returns `1` (or any positive number) if `valueA` comes after `valueB`
    - Is pure, i.e. it must always return the same value for the same pair of values.

    When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.

    ``` ts
    const { Map } = require('immutable')
    Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
      if (a < b) { return -1; }
      if (a > b) { return 1; }
      if (a === b) { return 0; }
    });
    // OrderedMap { "a": 1, "b": 2, "c": 3 }run it
    ```

    Note: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Seq.Keyed.sortBy()
  id: seq.keyed/index#sortBy()
  summary: 'Note: sortBy() Always returns a new instance, even if the original was already sorted'
  belongs_to: Seq.Keyed
  description: |-
    #### [sortBy()](index#sortBy())

    Like [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:

    ``` ts
    sortBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this
    ```

    #### Inherited from

    [`Collection#sortBy()`](../collection/index#sortBy())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const beattles = Map({
      John: { name: "Lennon" },
      Paul: { name: "McCartney" },
      George: { name: "Harrison" },
      Ringo: { name: "Starr" },
    });
    beattles.sortBy(member => member.name);run it
    ```

    Note: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Seq.Keyed.take()
  id: seq.keyed/index#take()
  summary: Returns a new Collection of the same type which includes the first amount entries from this Collection
  belongs_to: Seq.Keyed
  description: |-
    #### [take()](index#take())

    Returns a new Collection of the same type which includes the first `amount` entries from this Collection.

    ``` ts
    take(amount: number): this
    ```

    #### Inherited from

    [`Collection#take()`](../collection/index#take())
- name: Seq.Keyed.takeLast()
  id: seq.keyed/index#takeLast()
  summary: Returns a new Collection of the same type which includes the last amount entries from this Collection
  belongs_to: Seq.Keyed
  description: |-
    #### [takeLast()](index#takeLast())

    Returns a new Collection of the same type which includes the last `amount` entries from this Collection.

    ``` ts
    takeLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#takeLast()`](../collection/index#takeLast())
- name: Seq.Keyed.takeUntil()
  id: seq.keyed/index#takeUntil()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns false
  belongs_to: Seq.Keyed
  description: |-
    #### [takeUntil()](index#takeUntil())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.

    ``` ts
    takeUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeUntil()`](../collection/index#takeUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeUntil(x => x.match(/at/))
    // List [ "dog", "frog" ]run it
    ```

    ### Reducing a value
- name: Seq.Keyed.takeWhile()
  id: seq.keyed/index#takeWhile()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns true
  belongs_to: Seq.Keyed
  description: |-
    #### [takeWhile()](index#takeWhile())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.

    ``` ts
    takeWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeWhile()`](../collection/index#takeWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeWhile(x => x.match(/o/))
    // List [ "dog", "frog" ]run it
    ```
- name: Seq.Keyed.toArray()
  id: seq.keyed/index#toArray()
  summary: Shallowly converts this collection to an Array
  belongs_to: Seq.Keyed
  description: |-
    #### [toArray()](index#toArray())

    Shallowly converts this collection to an Array.

    ``` ts
    toArray(): Array<[K, V]>
    ```

    #### Overrides

    [`Collection#toArray()`](../collection/index#toArray())
- name: Seq.Keyed.toIndexedSeq()
  id: seq.keyed/index#toIndexedSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Seq.Keyed
  description: |-
    #### [toIndexedSeq()](index#toIndexedSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    toIndexedSeq(): Seq.Indexed<V>
    ```

    #### Inherited from

    [`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())
- name: Seq.Keyed.toJS()
  id: seq.keyed/index#toJS()
  summary: Deeply converts this Keyed Seq to equivalent native JavaScript Object
  belongs_to: Seq.Keyed
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Keyed Seq to equivalent native JavaScript Object.

    ``` ts
    toJS(): {[key: string]: DeepCopy<V>}
    ```

    #### Overrides

    [`Collection#toJS()`](../collection/index#toJS())

    #### Discussion

    Converts keys to Strings.
- name: Seq.Keyed.toJSON()
  id: seq.keyed/index#toJSON()
  summary: Shallowly converts this Keyed Seq to equivalent native JavaScript Object
  belongs_to: Seq.Keyed
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Keyed Seq to equivalent native JavaScript Object.

    ``` ts
    toJSON(): {[key: string]: V}
    ```

    #### Overrides

    [`Collection#toJSON()`](../collection/index#toJSON())

    #### Discussion

    Converts keys to Strings.
- name: Seq.Keyed.toKeyedSeq()
  id: seq.keyed/index#toKeyedSeq()
  summary: Returns a Seq.Keyed from this Collection where indices are treated as keys
  belongs_to: Seq.Keyed
  description: |-
    #### [toKeyedSeq()](index#toKeyedSeq())

    Returns a Seq.Keyed from this Collection where indices are treated as keys.

    ``` ts
    toKeyedSeq(): Seq.Keyed<K, V>
    ```

    #### Inherited from

    [`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())

    #### Discussion

    This is useful if you want to operate on an Collection.Indexed and preserve the \[index, value\] pairs.

    The returned Seq will have identical iteration order as this Collection.

    ``` ts
    const { Seq } = require('immutable')
    const indexedSeq = Seq([ 'A', 'B', 'C' ])
    // Seq [ "A", "B", "C" ]
    indexedSeq.filter(v => v === 'B')
    // Seq [ "B" ]
    const keyedSeq = indexedSeq.toKeyedSeq()
    // Seq { 0: "A", 1: "B", 2: "C" }
    keyedSeq.filter(v => v === 'B')
    // Seq { 1: "B" }run it
    ```
- name: Seq.Keyed.toList()
  id: seq.keyed/index#toList()
  summary: Converts this Collection to a List, discarding keys
  belongs_to: Seq.Keyed
  description: |-
    #### [toList()](index#toList())

    Converts this Collection to a List, discarding keys.

    ``` ts
    toList(): List<V>
    ```

    #### Inherited from

    [`Collection#toList()`](../collection/index#toList())

    #### Discussion

    This is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.

    ``` ts
    const { Map, List } = require('immutable')
    var myMap = Map({ a: 'Apple', b: 'Banana' })
    List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
    myMap.toList() // List [ "Apple", "Banana" ]run it
    ```
- name: Seq.Keyed.toMap()
  id: seq.keyed/index#toMap()
  summary: Converts this Collection to a Map, Throws if keys are not hashable
  belongs_to: Seq.Keyed
  description: |-
    #### [toMap()](index#toMap())

    Converts this Collection to a Map, Throws if keys are not hashable.

    ``` ts
    toMap(): Map<K, V>
    ```

    #### Inherited from

    [`Collection#toMap()`](../collection/index#toMap())

    #### Discussion

    Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Seq.Keyed.toObject()
  id: seq.keyed/index#toObject()
  summary: Shallowly converts this Collection to an Object
  belongs_to: Seq.Keyed
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Collection to an Object.

    ``` ts
    toObject(): {[key: string]: V}
    ```

    #### Inherited from

    [`Collection#toObject()`](../collection/index#toObject())

    #### Discussion

    Converts keys to Strings.

    ### Conversion to Seq
- name: Seq.Keyed.toOrderedMap()
  id: seq.keyed/index#toOrderedMap()
  summary: Converts this Collection to a Map, maintaining the order of iteration
  belongs_to: Seq.Keyed
  description: |-
    #### [toOrderedMap()](index#toOrderedMap())

    Converts this Collection to a Map, maintaining the order of iteration.

    ``` ts
    toOrderedMap(): OrderedMap<K, V>
    ```

    #### Inherited from

    [`Collection#toOrderedMap()`](../collection/index#toOrderedMap())

    #### Discussion

    Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Seq.Keyed.toOrderedSet()
  id: seq.keyed/index#toOrderedSet()
  summary: Converts this Collection to a Set, maintaining the order of iteration and discarding keys
  belongs_to: Seq.Keyed
  description: |-
    #### [toOrderedSet()](index#toOrderedSet())

    Converts this Collection to a Set, maintaining the order of iteration and discarding keys.

    ``` ts
    toOrderedSet(): OrderedSet<V>
    ```

    #### Inherited from

    [`Collection#toOrderedSet()`](../collection/index#toOrderedSet())

    #### Discussion

    Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.
- name: Seq.Keyed.toSeq()
  id: seq.keyed/index#toSeq()
  summary: null
  belongs_to: Seq.Keyed
  description: |-
    #### [toSeq()](index#toSeq())

    Returns itself

    ``` ts
    toSeq(): this
    ```

    #### Overrides

    [`Collection#toSeq()`](../collection/index#toSeq())
- name: Seq.Keyed.toSet()
  id: seq.keyed/index#toSet()
  summary: Converts this Collection to a Set, discarding keys
  belongs_to: Seq.Keyed
  description: |-
    #### [toSet()](index#toSet())

    Converts this Collection to a Set, discarding keys. Throws if values are not hashable.

    ``` ts
    toSet(): Set<V>
    ```

    #### Inherited from

    [`Collection#toSet()`](../collection/index#toSet())

    #### Discussion

    Note: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.
- name: Seq.Keyed.toSetSeq()
  id: seq.keyed/index#toSetSeq()
  summary: Returns a Seq.Set of the values of this Collection, discarding keys
  belongs_to: Seq.Keyed
  description: |-
    #### [toSetSeq()](index#toSetSeq())

    Returns a Seq.Set of the values of this Collection, discarding keys.

    ``` ts
    toSetSeq(): Seq.Set<V>
    ```

    #### Inherited from

    [`Collection#toSetSeq()`](../collection/index#toSetSeq())

    ### Combination
- name: Seq.Keyed.toStack()
  id: seq.keyed/index#toStack()
  summary: Converts this Collection to a Stack, discarding keys
  belongs_to: Seq.Keyed
  description: |-
    #### [toStack()](index#toStack())

    Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.

    ``` ts
    toStack(): Stack<V>
    ```

    #### Inherited from

    [`Collection#toStack()`](../collection/index#toStack())

    #### Discussion

    Note: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.

    ### Collections (Seq)
- name: Seq.Keyed.update()
  id: seq.keyed/index#update()
  summary: This can be very useful as a way to "chain" a normal function into a sequence of methods
  belongs_to: Seq.Keyed
  description: |-
    #### [update()](index#update())

    This can be very useful as a way to "chain" a normal function into a sequence of methods. RxJS calls this "let" and lodash calls it "thru".

    ``` ts
    update<R>(updater: (value: this) => R): R
    ```

    #### Inherited from

    [`Collection#update()`](../collection/index#update())

    #### Discussion

    For example, to sum a Seq after mapping and filtering:

    ``` ts
    const { Seq } = require('immutable')

    function sum(collection) {
      return collection.reduce((sum, x) => sum + x, 0)
    }
    Seq([ 1, 2, 3 ])
      .map(x => x + 1)
      .filter(x => x % 2 === 0)
      .update(sum)
    // 6run it
    ```

    ### Conversion to Collections
- name: Seq.Keyed.values()
  id: seq.keyed/index#values()
  summary: An iterator of this Collection's values
  belongs_to: Seq.Keyed
  description: |-
    #### [values()](index#values())

    An iterator of this [`Collection`](../collection/index)'s values.

    ``` ts
    values(): IterableIterator<V>
    ```

    #### Inherited from

    [`Collection#values()`](../collection/index#values())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.
- name: Seq.Keyed.valueSeq()
  id: seq.keyed/index#valueSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Seq.Keyed
  description: |-
    #### [valueSeq()](index#valueSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    valueSeq(): Seq.Indexed<V>
    ```

    #### Inherited from

    [`Collection#valueSeq()`](../collection/index#valueSeq())
- name: Seq.keyOf()
  id: seq/index#keyOf()
  summary: Returns the key associated with the search value, or undefined
  belongs_to: Seq
  description: |-
    #### [keyOf()](index#keyOf())

    Returns the key associated with the search value, or undefined.

    ``` ts
    keyOf(searchValue: V): K | undefined
    ```

    #### Inherited from

    [`Collection#keyOf()`](../collection/index#keyOf())
- name: Seq.keys()
  id: seq/index#keys()
  summary: An iterator of this Collection's keys
  belongs_to: Seq
  description: |-
    #### [keys()](index#keys())

    An iterator of this [`Collection`](../collection/index)'s keys.

    ``` ts
    keys(): IterableIterator<K>
    ```

    #### Inherited from

    [`Collection#keys()`](../collection/index#keys())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.
- name: Seq.keySeq()
  id: seq/index#keySeq()
  summary: Returns a new Seq.Indexed of the keys of this Collection, discarding values
  belongs_to: Seq
  description: |-
    #### [keySeq()](index#keySeq())

    Returns a new Seq.Indexed of the keys of this Collection, discarding values.

    ``` ts
    keySeq(): Seq.Indexed<K>
    ```

    #### Inherited from

    [`Collection#keySeq()`](../collection/index#keySeq())
- name: Seq.last()
  id: seq/index#last()
  summary: In case the Collection is not empty returns the last element of the Collection
  belongs_to: Seq
  description: |-
    #### [last()](index#last())

    In case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    last<NSV>(notSetValue?: NSV): V | NSV
    ```

    #### Inherited from

    [`Collection#last()`](../collection/index#last())

    ### Reading deep values
- name: Seq.lastKeyOf()
  id: seq/index#lastKeyOf()
  summary: Returns the last key associated with the search value, or undefined
  belongs_to: Seq
  description: |-
    #### [lastKeyOf()](index#lastKeyOf())

    Returns the last key associated with the search value, or undefined.

    ``` ts
    lastKeyOf(searchValue: V): K | undefined
    ```

    #### Inherited from

    [`Collection#lastKeyOf()`](../collection/index#lastKeyOf())
- name: Seq.map()
  id: seq/index#map()
  summary: Returns a new Seq with values passed through a mapper function
  belongs_to: Seq
  description: |-
    #### [map()](index#map())

    Returns a new Seq with values passed through a `mapper` function.

    ``` ts
    map<M>(mapper: (value: V, key: K, iter: this) => M,context?: unknown): Seq<K, M>
    map<M>(mapper: (value: V, key: K, iter: this) => M,context?: unknown): Seq<M, M>
    ```

    #### Overrides

    [`Collection#map()`](../collection/index#map())

    #### Example

    ``` ts
    const { Seq } = require('immutable')
    Seq([ 1, 2 ]).map(x => 10 * x)
    // Seq [ 10, 20 ]
    ```

    Note: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step. Note: used only for sets.
- name: Seq.max()
  id: seq/index#max()
  summary: Returns the maximum value in this collection
  belongs_to: Seq
  description: |-
    #### [max()](index#max())

    Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    max(comparator?: (valueA: V, valueB: V) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#max()`](../collection/index#max())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Seq.maxBy()
  id: seq/index#maxBy()
  summary: null
  belongs_to: Seq
  description: |-
    #### [maxBy()](index#maxBy())

    Like [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    maxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#maxBy()`](../collection/index#maxBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it
    ```
- name: Seq.min()
  id: seq/index#min()
  summary: Returns the minimum value in this collection
  belongs_to: Seq
  description: |-
    #### [min()](index#min())

    Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    min(comparator?: (valueA: V, valueB: V) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#min()`](../collection/index#min())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Seq.minBy()
  id: seq/index#minBy()
  summary: null
  belongs_to: Seq
  description: |-
    #### [minBy()](index#minBy())

    Like [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    minBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): V | undefined
    ```

    #### Inherited from

    [`Collection#minBy()`](../collection/index#minBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it
    ```

    ### Comparison
- name: Seq.partition()
  id: seq/index#partition()
  summary: null
  belongs_to: Seq
  description: |-
    #### [partition()](index#partition())

    ``` ts
    partition<F, C>(predicate: (this: C, value: V, key: K, iter: this) => boolean,context?: C): [Seq<K, V>, Seq<K, F>]
    partition<C>(predicate: (this: C, value: V, key: K, iter: this) => unknown,context?: C): [this, this]
    ```

    #### Overrides

    [`Collection#partition()`](../collection/index#partition())
- name: Seq.reduce()
  id: seq/index#reduce()
  summary: null
  belongs_to: Seq
  description: |-
    #### [reduce()](index#reduce())

    ``` ts
    reduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R
    reduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduce()`](../collection/index#reduce())
- name: Seq.reduceRight()
  id: seq/index#reduceRight()
  summary: null
  belongs_to: Seq
  description: |-
    #### [reduceRight()](index#reduceRight())

    ``` ts
    reduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R,initialReduction: R,context?: unknown): R
    reduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduceRight()`](../collection/index#reduceRight())
- name: Seq.rest()
  id: seq/index#rest()
  summary: Returns a new Collection of the same type containing all entries except the first
  belongs_to: Seq
  description: |-
    #### [rest()](index#rest())

    Returns a new Collection of the same type containing all entries except the first.

    ``` ts
    rest(): this
    ```

    #### Inherited from

    [`Collection#rest()`](../collection/index#rest())
- name: Seq.reverse()
  id: seq/index#reverse()
  summary: Returns a new Collection of the same type in reverse order
  belongs_to: Seq
  description: |-
    #### [reverse()](index#reverse())

    Returns a new Collection of the same type in reverse order.

    ``` ts
    reverse(): this
    ```

    #### Inherited from

    [`Collection#reverse()`](../collection/index#reverse())
- name: Seq.Seq()
  id: seq/index#Seq()
  summary: null
  belongs_to: Seq
  description: |-
    #### [Seq()](index#Seq())

    ``` ts
    Seq<S>(seq: S): S
    Seq<K, V>(collection: Collection.Keyed<K, V>): Seq.Keyed<K, V>
    Seq<T>(collection: Collection.Set<T>): Seq.Set<T>
    Seq<T>(collection: Collection.Indexed<T> | Iterable<T> | ArrayLike<T>): Seq.Indexed<T>
    Seq<V>(obj: {[key: string]: V}): Seq.Keyed<string, V>
    Seq<K, V>(): Seq<K, V>
    ```

    ### Static methods
- name: Seq.Seq.isSeq()
  id: seq/index#isSeq()
  summary: null
  belongs_to: Seq
  description: |-
    #### [Seq.isSeq()](index#isSeq())

    ``` ts
    Seq.isSeq(maybeSeq: unknown): boolean
    ```

    ### Members
- name: Seq.Set
  id: seq.set/index
  summary: Seq which represents a set of values
  description: "# Seq.Set\n\n[`Seq`](../seq/index) which represents a set of values.\n\n``` ts\ntype Seq.Set<T> extends Seq<T, T>, Collection.Set<T>\n```\n\n#### Discussion\n\nBecause [`Seq`](../seq/index) are often lazy, [`Seq.Set`](index) does not provide the same guarantee of value uniqueness as the concrete [`Set`](../set/index).\n\n### Construction\n\n#### [Seq.Set()](index#Seq.Set())\n\nAlways returns a Seq.Set, discarding associated indices or keys.\n\n``` ts\nSeq.Set<T>(collection?: Iterable<T> | ArrayLike<T>): Seq.Set<T>\n```\n\n#### Discussion\n\nNote: [`Seq.Set`](index) is a conversion function and not a class, and does not use the `new` keyword during construction.\n\n### Static methods\n\n#### [Seq.Set.of()](index#of())\n\n``` ts\nSeq.Set.of<T>(...values: Array<T>): Seq.Set<T>\n```\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Set Seq to equivalent native JavaScript Array.\n\n``` ts\ntoJS(): Array<DeepCopy<T>>\n```\n\n#### Overrides\n\n[`Collection#toJS()`](../collection/index#toJS())\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Set Seq to equivalent native JavaScript Array.\n\n``` ts\ntoJSON(): Array<T>\n```\n\n#### Overrides\n\n[`Collection#toJSON()`](../collection/index#toJSON())\n\n#### [toArray()](index#toArray())\n\nShallowly converts this collection to an Array.\n\n``` ts\ntoArray(): Array<T>\n```\n\n#### Overrides\n\n[`Collection#toArray()`](../collection/index#toArray())\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Collection to an Object.\n\n``` ts\ntoObject(): {[key: string]: T}\n```\n\n#### Inherited from\n\n[`Collection#toObject()`](../collection/index#toObject())\n\n#### Discussion\n\nConverts keys to Strings.\n\n### Conversion to Seq\n\n#### [toSeq()](index#toSeq())\n\nReturns itself\n\n``` ts\ntoSeq(): this\n```\n\n#### Overrides\n\n[`Collection#toSeq()`](../collection/index#toSeq())\n\n#### [toKeyedSeq()](index#toKeyedSeq())\n\nReturns a Seq.Keyed from this Collection where indices are treated as keys.\n\n``` ts\ntoKeyedSeq(): Seq.Keyed<T, T>\n```\n\n#### Inherited from\n\n[`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())\n\n#### Discussion\n\nThis is useful if you want to operate on an Collection.Indexed and preserve the \\[index, value\\] pairs.\n\nThe returned Seq will have identical iteration order as this Collection.\n\n``` ts\nconst { Seq } = require('immutable')\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\n// Seq [ \"A\", \"B\", \"C\" ]\nindexedSeq.filter(v => v === 'B')\n// Seq [ \"B\" ]\nconst keyedSeq = indexedSeq.toKeyedSeq()\n// Seq { 0: \"A\", 1: \"B\", 2: \"C\" }\nkeyedSeq.filter(v => v === 'B')\n// Seq { 1: \"B\" }run it\n```\n\n#### [toIndexedSeq()](index#toIndexedSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\ntoIndexedSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())\n\n#### [toSetSeq()](index#toSetSeq())\n\nReturns a Seq.Set of the values of this Collection, discarding keys.\n\n``` ts\ntoSetSeq(): Seq.Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSetSeq()`](../collection/index#toSetSeq())\n\n### Combination\n\n#### [concat()](index#concat())\n\nReturns a new Seq with other collections concatenated to this one.\n\n``` ts\nconcat<U>(...collections: Array<Iterable<U>>): Seq.Set<T | U>\n```\n\n#### Overrides\n\n[`Collection#concat()`](../collection/index#concat())\n\n#### Discussion\n\nAll entries will be present in the resulting Seq, even if they are duplicates.\n\n#### [flatten()](index#flatten())\n\n``` ts\nflatten(depth?: number): Collection<unknown, unknown>\nflatten(shallow?: boolean): Collection<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection#flatten()`](../collection/index#flatten())\n\n### Sequence algorithms\n\n#### [map()](index#map())\n\nReturns a new Seq.Set with values passed through a `mapper` function.\n\n``` ts\nmap<M>(mapper: (value: T, key: T, iter: this) => M,context?: unknown): Seq.Set<M>\n```\n\n#### Overrides\n\n[`Seq#map()`](../seq/index#map())\n\n#### Example\n\n``` ts\nSeq.Set([ 1, 2 ]).map(x => 10 * x)\n// Seq { 10, 20 }\n```\n\nNote: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.\n\n#### [flatMap()](index#flatMap())\n\nFlat-maps the Seq, returning a Seq of the same type.\n\n``` ts\nflatMap<M>(mapper: (value: T, key: T, iter: this) => Iterable<M>,context?: unknown): Seq.Set<M>\n```\n\n#### Overrides\n\n[`Seq#flatMap()`](../seq/index#flatMap())\n\n#### Discussion\n\nSimilar to `seq.map(...).flatten(true)`.\n\n#### [filter()](index#filter())\n\n``` ts\nfilter<F>(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): Seq.Set<F>\nfilter(predicate: (value: T, key: T, iter: this) => unknown,context?: unknown): this\n```\n\n#### Overrides\n\n[`Seq#filter()`](../seq/index#filter())\n\n#### [partition()](index#partition())\n\n``` ts\npartition<F, C>(predicate: (this: C, value: T, key: T, iter: this) => boolean,context?: C): [Seq.Set<T>, Seq.Set<F>]\npartition<C>(predicate: (this: C, value: T, key: T, iter: this) => unknown,context?: C): [this, this]\n```\n\n#### Overrides\n\n[`Seq#partition()`](../seq/index#partition())\n\n#### [filterNot()](index#filterNot())\n\nReturns a new Collection of the same type with only the entries for which the `predicate` function returns false.\n\n``` ts\nfilterNot(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#filterNot()`](../collection/index#filterNot())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }run it\n```\n\nNote: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.\n\n#### [reverse()](index#reverse())\n\nReturns a new Collection of the same type in reverse order.\n\n``` ts\nreverse(): this\n```\n\n#### Inherited from\n\n[`Collection#reverse()`](../collection/index#reverse())\n\n#### [sort()](index#sort())\n\nReturns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.\n\n``` ts\nsort(comparator?: (valueA: T, valueB: T) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sort()`](../collection/index#sort())\n\n#### Discussion\n\nIf a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n- Returns `0` if the elements should not be swapped.\n- Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n- Returns `1` (or any positive number) if `valueA` comes after `valueB`\n- Is pure, i.e. it must always return the same value for the same pair of values.\n\nWhen sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n``` ts\nconst { Map } = require('immutable')\nMap({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// OrderedMap { \"a\": 1, \"b\": 2, \"c\": 3 }run it\n```\n\nNote: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [sortBy()](index#sortBy())\n\nLike [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:\n\n``` ts\nsortBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sortBy()`](../collection/index#sortBy())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst beattles = Map({\n  John: { name: \"Lennon\" },\n  Paul: { name: \"McCartney\" },\n  George: { name: \"Harrison\" },\n  Ringo: { name: \"Starr\" },\n});\nbeattles.sortBy(member => member.name);run it\n```\n\nNote: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [groupBy()](index#groupBy())\n\nReturns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.\n\n``` ts\ngroupBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<T, T>>\n```\n\n#### Inherited from\n\n[`Collection#groupBy()`](../collection/index#groupBy())\n\n#### Discussion\n\nNote: This is always an eager operation.\n\n``` ts\nconst { List, Map } = require('immutable')\nconst listOfMaps = List([\n  Map({ v: 0 }),\n  Map({ v: 1 }),\n  Map({ v: 1 }),\n  Map({ v: 0 }),\n  Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ Map{ \"v\": 0 }, Map { \"v\": 0 } ],\n//   1: List [ Map{ \"v\": 1 }, Map { \"v\": 1 } ],\n//   2: List [ Map{ \"v\": 2 } ],\n// }run it\n```\n\n### Iterators\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<T>\n```\n\n#### Overrides\n\n[`Collection#[Symbol.iterator]()`](../collection/index#%5BSymbol.iterator%5D())\n\n#### [keys()](index#keys())\n\nAn iterator of this [`Collection`](../collection/index)'s keys.\n\n``` ts\nkeys(): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection#keys()`](../collection/index#keys())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.\n\n#### [values()](index#values())\n\nAn iterator of this [`Collection`](../collection/index)'s values.\n\n``` ts\nvalues(): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection#values()`](../collection/index#values())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.\n\n#### [entries()](index#entries())\n\nAn iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.\n\n``` ts\nentries(): IterableIterator<[T, T]>\n```\n\n#### Inherited from\n\n[`Collection#entries()`](../collection/index#entries())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.\n\n### Members\n\n#### [size](index#size)\n\nSome Seqs can describe their size lazily. When this is the case, size will be an integer. Otherwise it will be undefined.\n\n``` ts\nsize: number | undefined\n```\n\n#### Inherited from\n\n[`Seq#size`](../seq/index#size)\n\n#### Discussion\n\nFor example, Seqs returned from [`map()`](../seq/index#map()) or [`reverse()`](../seq/index#reverse()) preserve the size of the original [`Seq`](../seq/index) while [`filter()`](../seq/index#filter()) does not.\n\nNote: [`Range`](../range()/index), [`Repeat`](../repeat()/index) and [`Seq`](../seq/index)s made from [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)s and [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)s will always have a size.\n\n### Force evaluation\n\n#### [cacheResult()](index#cacheResult())\n\nBecause Sequences are lazy and designed to be chained together, they do not cache their results. For example, this map function is called a total of 6 times, as each [`join`](../seq/index#join()) iterates the Seq of three values.\n\n``` ts\ncacheResult(): this\n```\n\n#### Inherited from\n\n[`Seq#cacheResult()`](../seq/index#cacheResult())\n\n#### Discussion\n\n``` ts\nvar squares = Seq([ 1, 2, 3 ]).map(x => x  x)\nsquares.join() + squares.join()\n```\n\nIf you know a [`Seq`](../seq/index) will be used multiple times, it may be more efficient to first cache it in memory. Here, the map function is called only 3 times.\n\n``` ts\nvar squares = Seq([ 1, 2, 3 ]).map(x => x  x).cacheResult()\nsquares.join() + squares.join()\n```\n\nUse this method judiciously, as it must fully evaluate a Seq which can be a burden on memory and possibly performance.\n\nNote: after calling [`cacheResult`](../seq/index#cacheResult()), a Seq will always have a [`size`](../seq/index#size).\n\n### Value equality\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#equals()`](../collection/index#equals())\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Inherited from\n\n[`Collection#hashCode()`](../collection/index#hashCode())\n\n#### Discussion\n\nThe [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nIf two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.\n\n### Reading values\n\n#### [get()](index#get())\n\n``` ts\nget<NSV>(key: T, notSetValue: NSV): T | NSV\nget(key: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#get()`](../collection/index#get())\n\n#### [has()](index#has())\n\nTrue if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nhas(key: T): boolean\n```\n\n#### Inherited from\n\n[`Collection#has()`](../collection/index#has())\n\n#### [includes()](index#includes())\n\nTrue if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nincludes(value: T): boolean\n```\n\n#### Inherited from\n\n[`Collection#includes()`](../collection/index#includes())\n\n#### alias\n\n`contains()`\n\n#### [first()](index#first())\n\nIn case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nfirst<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#first()`](../collection/index#first())\n\n#### [last()](index#last())\n\nIn case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nlast<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#last()`](../collection/index#last())\n\n### Reading deep values\n\n#### [getIn()](index#getIn())\n\nReturns the value found by following a path of keys or indices through nested Collections.\n\n``` ts\ngetIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown\n```\n\n#### Inherited from\n\n[`Collection#getIn()`](../collection/index#getIn())\n\n#### Discussion\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: [ { y: 123 } ] });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\n#### [hasIn()](index#hasIn())\n\nTrue if the result of following a path of keys or indices through nested Collections results in a set value.\n\n``` ts\nhasIn(searchKeyPath: Iterable<unknown>): boolean\n```\n\n#### Inherited from\n\n[`Collection#hasIn()`](../collection/index#hasIn())\n\n### Persistent changes\n\n#### [update()](index#update())\n\nThis can be very useful as a way to \"chain\" a normal function into a sequence of methods. RxJS calls this \"let\" and lodash calls it \"thru\".\n\n``` ts\nupdate<R>(updater: (value: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#update()`](../collection/index#update())\n\n#### Discussion\n\nFor example, to sum a Seq after mapping and filtering:\n\n``` ts\nconst { Seq } = require('immutable')\n\nfunction sum(collection) {\n  return collection.reduce((sum, x) => sum + x, 0)\n}\nSeq([ 1, 2, 3 ])\n  .map(x => x + 1)\n  .filter(x => x % 2 === 0)\n  .update(sum)\n// 6run it\n```\n\n### Conversion to Collections\n\n#### [toMap()](index#toMap())\n\nConverts this Collection to a Map, Throws if keys are not hashable.\n\n``` ts\ntoMap(): Map<T, T>\n```\n\n#### Inherited from\n\n[`Collection#toMap()`](../collection/index#toMap())\n\n#### Discussion\n\nNote: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toOrderedMap()](index#toOrderedMap())\n\nConverts this Collection to a Map, maintaining the order of iteration.\n\n``` ts\ntoOrderedMap(): OrderedMap<T, T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedMap()`](../collection/index#toOrderedMap())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toSet()](index#toSet())\n\nConverts this Collection to a Set, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoSet(): Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSet()`](../collection/index#toSet())\n\n#### Discussion\n\nNote: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.\n\n#### [toOrderedSet()](index#toOrderedSet())\n\nConverts this Collection to a Set, maintaining the order of iteration and discarding keys.\n\n``` ts\ntoOrderedSet(): OrderedSet<T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedSet()`](../collection/index#toOrderedSet())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toList()](index#toList())\n\nConverts this Collection to a List, discarding keys.\n\n``` ts\ntoList(): List<T>\n```\n\n#### Inherited from\n\n[`Collection#toList()`](../collection/index#toList())\n\n#### Discussion\n\nThis is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.\n\n``` ts\nconst { Map, List } = require('immutable')\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\nList(myMap) // List [ [ \"a\", \"Apple\" ], [ \"b\", \"Banana\" ] ]\nmyMap.toList() // List [ \"Apple\", \"Banana\" ]run it\n```\n\n#### [toStack()](index#toStack())\n\nConverts this Collection to a Stack, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoStack(): Stack<T>\n```\n\n#### Inherited from\n\n[`Collection#toStack()`](../collection/index#toStack())\n\n#### Discussion\n\nNote: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.\n\n### Collections (Seq)\n\n#### [keySeq()](index#keySeq())\n\nReturns a new Seq.Indexed of the keys of this Collection, discarding values.\n\n``` ts\nkeySeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#keySeq()`](../collection/index#keySeq())\n\n#### [valueSeq()](index#valueSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\nvalueSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#valueSeq()`](../collection/index#valueSeq())\n\n#### [entrySeq()](index#entrySeq())\n\nReturns a new Seq.Indexed of \\[key, value\\] tuples.\n\n``` ts\nentrySeq(): Seq.Indexed<[T, T]>\n```\n\n#### Inherited from\n\n[`Collection#entrySeq()`](../collection/index#entrySeq())\n\n### Side effects\n\n#### [forEach()](index#forEach())\n\nThe `sideEffect` is executed for every entry in the Collection.\n\n``` ts\nforEach(sideEffect: (value: T, key: T, iter: this) => unknown,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#forEach()`](../collection/index#forEach())\n\n#### Discussion\n\nUnlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).\n\n### Creating subsets\n\n#### [slice()](index#slice())\n\nReturns a new Collection of the same type representing a portion of this Collection from start up to but not including end.\n\n``` ts\nslice(begin?: number, end?: number): this\n```\n\n#### Inherited from\n\n[`Collection#slice()`](../collection/index#slice())\n\n#### Discussion\n\nIf begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.\n\nIf the requested slice is equivalent to the current Collection, then it will return itself.\n\n#### [rest()](index#rest())\n\nReturns a new Collection of the same type containing all entries except the first.\n\n``` ts\nrest(): this\n```\n\n#### Inherited from\n\n[`Collection#rest()`](../collection/index#rest())\n\n#### [butLast()](index#butLast())\n\nReturns a new Collection of the same type containing all entries except the last.\n\n``` ts\nbutLast(): this\n```\n\n#### Inherited from\n\n[`Collection#butLast()`](../collection/index#butLast())\n\n#### [skip()](index#skip())\n\nReturns a new Collection of the same type which excludes the first `amount` entries from this Collection.\n\n``` ts\nskip(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skip()`](../collection/index#skip())\n\n#### [skipLast()](index#skipLast())\n\nReturns a new Collection of the same type which excludes the last `amount` entries from this Collection.\n\n``` ts\nskipLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skipLast()`](../collection/index#skipLast())\n\n#### [skipWhile()](index#skipWhile())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns false.\n\n``` ts\nskipWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipWhile()`](../collection/index#skipWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipWhile(x => x.match(/g/))\n// List [ \"cat\", \"hat\", \"god\" ]run it\n```\n\n#### [skipUntil()](index#skipUntil())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns true.\n\n``` ts\nskipUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipUntil()`](../collection/index#skipUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipUntil(x => x.match(/hat/))\n// List [ \"hat\", \"god\" ]run it\n```\n\n#### [take()](index#take())\n\nReturns a new Collection of the same type which includes the first `amount` entries from this Collection.\n\n``` ts\ntake(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#take()`](../collection/index#take())\n\n#### [takeLast()](index#takeLast())\n\nReturns a new Collection of the same type which includes the last `amount` entries from this Collection.\n\n``` ts\ntakeLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#takeLast()`](../collection/index#takeLast())\n\n#### [takeWhile()](index#takeWhile())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.\n\n``` ts\ntakeWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeWhile()`](../collection/index#takeWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeWhile(x => x.match(/o/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n#### [takeUntil()](index#takeUntil())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.\n\n``` ts\ntakeUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeUntil()`](../collection/index#takeUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeUntil(x => x.match(/at/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n### Reducing a value\n\n#### [reduce()](index#reduce())\n\n``` ts\nreduce<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R\nreduce<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduce()`](../collection/index#reduce())\n\n#### [reduceRight()](index#reduceRight())\n\n``` ts\nreduceRight<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R\nreduceRight<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduceRight()`](../collection/index#reduceRight())\n\n#### [every()](index#every())\n\nTrue if `predicate` returns true for all entries in the Collection.\n\n``` ts\nevery(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#every()`](../collection/index#every())\n\n#### [some()](index#some())\n\nTrue if `predicate` returns true for any entry in the Collection.\n\n``` ts\nsome(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#some()`](../collection/index#some())\n\n#### [join()](index#join())\n\nJoins values together as a string, inserting a separator between each. The default separator is `\",\"`.\n\n``` ts\njoin(separator?: string): string\n```\n\n#### Inherited from\n\n[`Collection#join()`](../collection/index#join())\n\n#### [isEmpty()](index#isEmpty())\n\nReturns true if this Collection includes no values.\n\n``` ts\nisEmpty(): boolean\n```\n\n#### Inherited from\n\n[`Collection#isEmpty()`](../collection/index#isEmpty())\n\n#### Discussion\n\nFor some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.\n\n#### [count()](index#count())\n\n``` ts\ncount(): number\ncount(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#count()`](../collection/index#count())\n\n#### [countBy()](index#countBy())\n\nReturns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.\n\n``` ts\ncountBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Map<G, number>\n```\n\n#### Inherited from\n\n[`Collection#countBy()`](../collection/index#countBy())\n\n#### Discussion\n\nNote: This is not a lazy operation.\n\n### Search for value\n\n#### [find()](index#find())\n\nReturns the first value for which the `predicate` returns true.\n\n``` ts\nfind(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#find()`](../collection/index#find())\n\n#### [findLast()](index#findLast())\n\nReturns the last value for which the `predicate` returns true.\n\n``` ts\nfindLast(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLast()`](../collection/index#findLast())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findEntry()](index#findEntry())\n\nReturns the first \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findEntry()`](../collection/index#findEntry())\n\n#### [findLastEntry()](index#findLastEntry())\n\nReturns the last \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindLastEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastEntry()`](../collection/index#findLastEntry())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findKey()](index#findKey())\n\nReturns the key for which the `predicate` returns true.\n\n``` ts\nfindKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findKey()`](../collection/index#findKey())\n\n#### [findLastKey()](index#findLastKey())\n\nReturns the last key for which the `predicate` returns true.\n\n``` ts\nfindLastKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastKey()`](../collection/index#findLastKey())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [keyOf()](index#keyOf())\n\nReturns the key associated with the search value, or undefined.\n\n``` ts\nkeyOf(searchValue: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#keyOf()`](../collection/index#keyOf())\n\n#### [lastKeyOf()](index#lastKeyOf())\n\nReturns the last key associated with the search value, or undefined.\n\n``` ts\nlastKeyOf(searchValue: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#lastKeyOf()`](../collection/index#lastKeyOf())\n\n#### [max()](index#max())\n\nReturns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmax(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#max()`](../collection/index#max())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [maxBy()](index#maxBy())\n\nLike [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nmaxBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#maxBy()`](../collection/index#maxBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it\n```\n\n#### [min()](index#min())\n\nReturns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmin(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#min()`](../collection/index#min())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [minBy()](index#minBy())\n\nLike [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nminBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#minBy()`](../collection/index#minBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it\n```\n\n### Comparison\n\n#### [isSubset()](index#isSubset())\n\nTrue if `iter` includes every value in this Collection.\n\n``` ts\nisSubset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSubset()`](../collection/index#isSubset())\n\n#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Seq.Set/](https://immutable-js.com/docs/v4.2.1/Seq.Set/)"
- name: Seq.Set.[Symbol.iterator]()
  id: seq.set/index#[Symbol.iterator]()
  summary: null
  belongs_to: Seq.Set
  description: |-
    #### [\[Symbol.iterator\]()](index#%5BSymbol.iterator%5D())

    ``` ts
    [Symbol.iterator](): IterableIterator<T>
    ```

    #### Overrides

    [`Collection#[Symbol.iterator]()`](../collection/index#%5BSymbol.iterator%5D())
- name: Seq.Set.butLast()
  id: seq.set/index#butLast()
  summary: Returns a new Collection of the same type containing all entries except the last
  belongs_to: Seq.Set
  description: |-
    #### [butLast()](index#butLast())

    Returns a new Collection of the same type containing all entries except the last.

    ``` ts
    butLast(): this
    ```

    #### Inherited from

    [`Collection#butLast()`](../collection/index#butLast())
- name: Seq.Set.cacheResult()
  id: seq.set/index#cacheResult()
  summary: Because Sequences are lazy and designed to be chained together, they do not cache their results
  belongs_to: Seq.Set
  description: |-
    #### [cacheResult()](index#cacheResult())

    Because Sequences are lazy and designed to be chained together, they do not cache their results. For example, this map function is called a total of 6 times, as each [`join`](../seq/index#join()) iterates the Seq of three values.

    ``` ts
    cacheResult(): this
    ```

    #### Inherited from

    [`Seq#cacheResult()`](../seq/index#cacheResult())

    #### Discussion

    ``` ts
    var squares = Seq([ 1, 2, 3 ]).map(x => x  x)
    squares.join() + squares.join()
    ```

    If you know a [`Seq`](../seq/index) will be used multiple times, it may be more efficient to first cache it in memory. Here, the map function is called only 3 times.

    ``` ts
    var squares = Seq([ 1, 2, 3 ]).map(x => x  x).cacheResult()
    squares.join() + squares.join()
    ```

    Use this method judiciously, as it must fully evaluate a Seq which can be a burden on memory and possibly performance.

    Note: after calling [`cacheResult`](../seq/index#cacheResult()), a Seq will always have a [`size`](../seq/index#size).

    ### Value equality
- name: Seq.Set.concat()
  id: seq.set/index#concat()
  summary: Returns a new Seq with other collections concatenated to this one
  belongs_to: Seq.Set
  description: |-
    #### [concat()](index#concat())

    Returns a new Seq with other collections concatenated to this one.

    ``` ts
    concat<U>(...collections: Array<Iterable<U>>): Seq.Set<T | U>
    ```

    #### Overrides

    [`Collection#concat()`](../collection/index#concat())

    #### Discussion

    All entries will be present in the resulting Seq, even if they are duplicates.
- name: Seq.Set.count()
  id: seq.set/index#count()
  summary: null
  belongs_to: Seq.Set
  description: |-
    #### [count()](index#count())

    ``` ts
    count(): number
    count(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#count()`](../collection/index#count())
- name: Seq.Set.countBy()
  id: seq.set/index#countBy()
  summary: Returns a Seq.Keyed of counts, grouped by the return value of the grouper function
  belongs_to: Seq.Set
  description: |-
    #### [countBy()](index#countBy())

    Returns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.

    ``` ts
    countBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Map<G, number>
    ```

    #### Inherited from

    [`Collection#countBy()`](../collection/index#countBy())

    #### Discussion

    Note: This is not a lazy operation.

    ### Search for value
- name: Seq.Set.entries()
  id: seq.set/index#entries()
  summary: An iterator of this Collection's entries as [ key, value ] tuples
  belongs_to: Seq.Set
  description: |-
    #### [entries()](index#entries())

    An iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.

    ``` ts
    entries(): IterableIterator<[T, T]>
    ```

    #### Inherited from

    [`Collection#entries()`](../collection/index#entries())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.

    ### Members
- name: Seq.Set.entrySeq()
  id: seq.set/index#entrySeq()
  summary: Returns a new Seq.Indexed of [key, value] tuples
  belongs_to: Seq.Set
  description: |-
    #### [entrySeq()](index#entrySeq())

    Returns a new Seq.Indexed of \[key, value\] tuples.

    ``` ts
    entrySeq(): Seq.Indexed<[T, T]>
    ```

    #### Inherited from

    [`Collection#entrySeq()`](../collection/index#entrySeq())

    ### Side effects
- name: Seq.Set.equals()
  id: seq.set/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: Seq.Set
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Inherited from

    [`Collection#equals()`](../collection/index#equals())

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: Seq.Set.every()
  id: seq.set/index#every()
  summary: True if predicate returns true for all entries in the Collection
  belongs_to: Seq.Set
  description: |-
    #### [every()](index#every())

    True if `predicate` returns true for all entries in the Collection.

    ``` ts
    every(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#every()`](../collection/index#every())
- name: Seq.Set.filter()
  id: seq.set/index#filter()
  summary: null
  belongs_to: Seq.Set
  description: |-
    #### [filter()](index#filter())

    ``` ts
    filter<F>(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): Seq.Set<F>
    filter(predicate: (value: T, key: T, iter: this) => unknown,context?: unknown): this
    ```

    #### Overrides

    [`Seq#filter()`](../seq/index#filter())
- name: Seq.Set.filterNot()
  id: seq.set/index#filterNot()
  summary: Returns a new Collection of the same type with only the entries for which the predicate function returns false
  belongs_to: Seq.Set
  description: |-
    #### [filterNot()](index#filterNot())

    Returns a new Collection of the same type with only the entries for which the `predicate` function returns false.

    ``` ts
    filterNot(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#filterNot()`](../collection/index#filterNot())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
    // Map { "a": 1, "c": 3 }run it
    ```

    Note: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.
- name: Seq.Set.find()
  id: seq.set/index#find()
  summary: Returns the first value for which the predicate returns true
  belongs_to: Seq.Set
  description: |-
    #### [find()](index#find())

    Returns the first value for which the `predicate` returns true.

    ``` ts
    find(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#find()`](../collection/index#find())
- name: Seq.Set.findEntry()
  id: seq.set/index#findEntry()
  summary: Returns the first [key, value] entry for which the predicate returns true
  belongs_to: Seq.Set
  description: |-
    #### [findEntry()](index#findEntry())

    Returns the first \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined
    ```

    #### Inherited from

    [`Collection#findEntry()`](../collection/index#findEntry())
- name: Seq.Set.findKey()
  id: seq.set/index#findKey()
  summary: Returns the key for which the predicate returns true
  belongs_to: Seq.Set
  description: |-
    #### [findKey()](index#findKey())

    Returns the key for which the `predicate` returns true.

    ``` ts
    findKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined
    ```

    #### Inherited from

    [`Collection#findKey()`](../collection/index#findKey())
- name: Seq.Set.findLast()
  id: seq.set/index#findLast()
  summary: Returns the last value for which the predicate returns true
  belongs_to: Seq.Set
  description: |-
    #### [findLast()](index#findLast())

    Returns the last value for which the `predicate` returns true.

    ``` ts
    findLast(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#findLast()`](../collection/index#findLast())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Seq.Set.findLastEntry()
  id: seq.set/index#findLastEntry()
  summary: Returns the last [key, value] entry for which the predicate returns true
  belongs_to: Seq.Set
  description: |-
    #### [findLastEntry()](index#findLastEntry())

    Returns the last \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findLastEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined
    ```

    #### Inherited from

    [`Collection#findLastEntry()`](../collection/index#findLastEntry())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Seq.Set.findLastKey()
  id: seq.set/index#findLastKey()
  summary: Returns the last key for which the predicate returns true
  belongs_to: Seq.Set
  description: |-
    #### [findLastKey()](index#findLastKey())

    Returns the last key for which the `predicate` returns true.

    ``` ts
    findLastKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined
    ```

    #### Inherited from

    [`Collection#findLastKey()`](../collection/index#findLastKey())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Seq.Set.first()
  id: seq.set/index#first()
  summary: In case the Collection is not empty returns the first element of the Collection
  belongs_to: Seq.Set
  description: |-
    #### [first()](index#first())

    In case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    first<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#first()`](../collection/index#first())
- name: Seq.Set.flatMap()
  id: seq.set/index#flatMap()
  summary: Flat-maps the Seq, returning a Seq of the same type
  belongs_to: Seq.Set
  description: |-
    #### [flatMap()](index#flatMap())

    Flat-maps the Seq, returning a Seq of the same type.

    ``` ts
    flatMap<M>(mapper: (value: T, key: T, iter: this) => Iterable<M>,context?: unknown): Seq.Set<M>
    ```

    #### Overrides

    [`Seq#flatMap()`](../seq/index#flatMap())

    #### Discussion

    Similar to `seq.map(...).flatten(true)`.
- name: Seq.Set.flatten()
  id: seq.set/index#flatten()
  summary: null
  belongs_to: Seq.Set
  description: |-
    #### [flatten()](index#flatten())

    ``` ts
    flatten(depth?: number): Collection<unknown, unknown>
    flatten(shallow?: boolean): Collection<unknown, unknown>
    ```

    #### Inherited from

    [`Collection#flatten()`](../collection/index#flatten())

    ### Sequence algorithms
- name: Seq.Set.forEach()
  id: seq.set/index#forEach()
  summary: The sideEffect is executed for every entry in the Collection
  belongs_to: Seq.Set
  description: |-
    #### [forEach()](index#forEach())

    The `sideEffect` is executed for every entry in the Collection.

    ``` ts
    forEach(sideEffect: (value: T, key: T, iter: this) => unknown,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#forEach()`](../collection/index#forEach())

    #### Discussion

    Unlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).

    ### Creating subsets
- name: Seq.Set.get()
  id: seq.set/index#get()
  summary: null
  belongs_to: Seq.Set
  description: |-
    #### [get()](index#get())

    ``` ts
    get<NSV>(key: T, notSetValue: NSV): T | NSV
    get(key: T): T | undefined
    ```

    #### Inherited from

    [`Collection#get()`](../collection/index#get())
- name: Seq.Set.getIn()
  id: seq.set/index#getIn()
  summary: Returns the value found by following a path of keys or indices through nested Collections
  belongs_to: Seq.Set
  description: |-
    #### [getIn()](index#getIn())

    Returns the value found by following a path of keys or indices through nested Collections.

    ``` ts
    getIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown
    ```

    #### Inherited from

    [`Collection#getIn()`](../collection/index#getIn())

    #### Discussion

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: [ { y: 123 } ] });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```
- name: Seq.Set.groupBy()
  id: seq.set/index#groupBy()
  summary: Returns a Collection.Keyed of Collection.Keyeds, grouped by the return value of the grouper function
  belongs_to: Seq.Set
  description: |-
    #### [groupBy()](index#groupBy())

    Returns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.

    ``` ts
    groupBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<T, T>>
    ```

    #### Inherited from

    [`Collection#groupBy()`](../collection/index#groupBy())

    #### Discussion

    Note: This is always an eager operation.

    ``` ts
    const { List, Map } = require('immutable')
    const listOfMaps = List([
      Map({ v: 0 }),
      Map({ v: 1 }),
      Map({ v: 1 }),
      Map({ v: 0 }),
      Map({ v: 2 })
    ])
    const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
    // Map {
    //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
    //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
    //   2: List [ Map{ "v": 2 } ],
    // }run it
    ```

    ### Iterators
- name: Seq.Set.has()
  id: seq.set/index#has()
  summary: null
  belongs_to: Seq.Set
  description: |-
    #### [has()](index#has())

    True if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    has(key: T): boolean
    ```

    #### Inherited from

    [`Collection#has()`](../collection/index#has())
- name: Seq.Set.hashCode()
  id: seq.set/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: Seq.Set
  description: |-
    #### [hashCode()](index#hashCode())

    Computes and returns the hashed identity for this Collection.

    ``` ts
    hashCode(): number
    ```

    #### Inherited from

    [`Collection#hashCode()`](../collection/index#hashCode())

    #### Discussion

    The [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.

    ``` ts
    const a = List([ 1, 2, 3 ]);
    const b = List([ 1, 2, 3 ]);
    assert.notStrictEqual(a, b); // different instances
    const set = Set([ a ]);
    assert.equal(set.has(b), true);run it
    ```

    If two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.

    ### Reading values
- name: Seq.Set.hasIn()
  id: seq.set/index#hasIn()
  summary: True if the result of following a path of keys or indices through nested Collections results in a set value
  belongs_to: Seq.Set
  description: |-
    #### [hasIn()](index#hasIn())

    True if the result of following a path of keys or indices through nested Collections results in a set value.

    ``` ts
    hasIn(searchKeyPath: Iterable<unknown>): boolean
    ```

    #### Inherited from

    [`Collection#hasIn()`](../collection/index#hasIn())

    ### Persistent changes
- name: Seq.Set.includes()
  id: seq.set/index#includes()
  summary: null
  belongs_to: Seq.Set
  description: |-
    #### [includes()](index#includes())

    True if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    includes(value: T): boolean
    ```

    #### Inherited from

    [`Collection#includes()`](../collection/index#includes())

    #### alias

    `contains()`
- name: Seq.Set.isEmpty()
  id: seq.set/index#isEmpty()
  summary: Returns true if this Collection includes no values
  belongs_to: Seq.Set
  description: |-
    #### [isEmpty()](index#isEmpty())

    Returns true if this Collection includes no values.

    ``` ts
    isEmpty(): boolean
    ```

    #### Inherited from

    [`Collection#isEmpty()`](../collection/index#isEmpty())

    #### Discussion

    For some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.
- name: Seq.Set.isSubset()
  id: seq.set/index#isSubset()
  summary: True if iter includes every value in this Collection
  belongs_to: Seq.Set
  description: |-
    #### [isSubset()](index#isSubset())

    True if `iter` includes every value in this Collection.

    ``` ts
    isSubset(iter: Iterable<T>): boolean
    ```

    #### Inherited from

    [`Collection#isSubset()`](../collection/index#isSubset())
- name: Seq.Set.isSuperset()
  id: seq.set/index#isSuperset()
  summary: True if this Collection includes every value in iter
  belongs_to: Seq.Set
  description: "#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Seq.Set/](https://immutable-js.com/docs/v4.2.1/Seq.Set/)"
- name: Seq.Set.join()
  id: seq.set/index#join()
  summary: Joins values together as a string, inserting a separator between each
  belongs_to: Seq.Set
  description: |-
    #### [join()](index#join())

    Joins values together as a string, inserting a separator between each. The default separator is `","`.

    ``` ts
    join(separator?: string): string
    ```

    #### Inherited from

    [`Collection#join()`](../collection/index#join())
- name: Seq.Set.keyOf()
  id: seq.set/index#keyOf()
  summary: Returns the key associated with the search value, or undefined
  belongs_to: Seq.Set
  description: |-
    #### [keyOf()](index#keyOf())

    Returns the key associated with the search value, or undefined.

    ``` ts
    keyOf(searchValue: T): T | undefined
    ```

    #### Inherited from

    [`Collection#keyOf()`](../collection/index#keyOf())
- name: Seq.Set.keys()
  id: seq.set/index#keys()
  summary: An iterator of this Collection's keys
  belongs_to: Seq.Set
  description: |-
    #### [keys()](index#keys())

    An iterator of this [`Collection`](../collection/index)'s keys.

    ``` ts
    keys(): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection#keys()`](../collection/index#keys())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.
- name: Seq.Set.keySeq()
  id: seq.set/index#keySeq()
  summary: Returns a new Seq.Indexed of the keys of this Collection, discarding values
  belongs_to: Seq.Set
  description: |-
    #### [keySeq()](index#keySeq())

    Returns a new Seq.Indexed of the keys of this Collection, discarding values.

    ``` ts
    keySeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#keySeq()`](../collection/index#keySeq())
- name: Seq.Set.last()
  id: seq.set/index#last()
  summary: In case the Collection is not empty returns the last element of the Collection
  belongs_to: Seq.Set
  description: |-
    #### [last()](index#last())

    In case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    last<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#last()`](../collection/index#last())

    ### Reading deep values
- name: Seq.Set.lastKeyOf()
  id: seq.set/index#lastKeyOf()
  summary: Returns the last key associated with the search value, or undefined
  belongs_to: Seq.Set
  description: |-
    #### [lastKeyOf()](index#lastKeyOf())

    Returns the last key associated with the search value, or undefined.

    ``` ts
    lastKeyOf(searchValue: T): T | undefined
    ```

    #### Inherited from

    [`Collection#lastKeyOf()`](../collection/index#lastKeyOf())
- name: Seq.Set.map()
  id: seq.set/index#map()
  summary: Returns a new Seq.Set with values passed through a mapper function
  belongs_to: Seq.Set
  description: |-
    #### [map()](index#map())

    Returns a new Seq.Set with values passed through a `mapper` function.

    ``` ts
    map<M>(mapper: (value: T, key: T, iter: this) => M,context?: unknown): Seq.Set<M>
    ```

    #### Overrides

    [`Seq#map()`](../seq/index#map())

    #### Example

    ``` ts
    Seq.Set([ 1, 2 ]).map(x => 10 * x)
    // Seq { 10, 20 }
    ```

    Note: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.
- name: Seq.Set.max()
  id: seq.set/index#max()
  summary: Returns the maximum value in this collection
  belongs_to: Seq.Set
  description: |-
    #### [max()](index#max())

    Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    max(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#max()`](../collection/index#max())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Seq.Set.maxBy()
  id: seq.set/index#maxBy()
  summary: null
  belongs_to: Seq.Set
  description: |-
    #### [maxBy()](index#maxBy())

    Like [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    maxBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#maxBy()`](../collection/index#maxBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it
    ```
- name: Seq.Set.min()
  id: seq.set/index#min()
  summary: Returns the minimum value in this collection
  belongs_to: Seq.Set
  description: |-
    #### [min()](index#min())

    Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    min(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#min()`](../collection/index#min())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Seq.Set.minBy()
  id: seq.set/index#minBy()
  summary: null
  belongs_to: Seq.Set
  description: |-
    #### [minBy()](index#minBy())

    Like [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    minBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#minBy()`](../collection/index#minBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it
    ```

    ### Comparison
- name: Seq.Set.partition()
  id: seq.set/index#partition()
  summary: null
  belongs_to: Seq.Set
  description: |-
    #### [partition()](index#partition())

    ``` ts
    partition<F, C>(predicate: (this: C, value: T, key: T, iter: this) => boolean,context?: C): [Seq.Set<T>, Seq.Set<F>]
    partition<C>(predicate: (this: C, value: T, key: T, iter: this) => unknown,context?: C): [this, this]
    ```

    #### Overrides

    [`Seq#partition()`](../seq/index#partition())
- name: Seq.Set.reduce()
  id: seq.set/index#reduce()
  summary: null
  belongs_to: Seq.Set
  description: |-
    #### [reduce()](index#reduce())

    ``` ts
    reduce<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R
    reduce<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduce()`](../collection/index#reduce())
- name: Seq.Set.reduceRight()
  id: seq.set/index#reduceRight()
  summary: null
  belongs_to: Seq.Set
  description: |-
    #### [reduceRight()](index#reduceRight())

    ``` ts
    reduceRight<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R
    reduceRight<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduceRight()`](../collection/index#reduceRight())
- name: Seq.Set.rest()
  id: seq.set/index#rest()
  summary: Returns a new Collection of the same type containing all entries except the first
  belongs_to: Seq.Set
  description: |-
    #### [rest()](index#rest())

    Returns a new Collection of the same type containing all entries except the first.

    ``` ts
    rest(): this
    ```

    #### Inherited from

    [`Collection#rest()`](../collection/index#rest())
- name: Seq.Set.reverse()
  id: seq.set/index#reverse()
  summary: Returns a new Collection of the same type in reverse order
  belongs_to: Seq.Set
  description: |-
    #### [reverse()](index#reverse())

    Returns a new Collection of the same type in reverse order.

    ``` ts
    reverse(): this
    ```

    #### Inherited from

    [`Collection#reverse()`](../collection/index#reverse())
- name: Seq.Set.Seq.Set()
  id: seq.set/index#Seq.Set()
  summary: Always returns a Seq.Set, discarding associated indices or keys
  belongs_to: Seq.Set
  description: |-
    #### [Seq.Set()](index#Seq.Set())

    Always returns a Seq.Set, discarding associated indices or keys.

    ``` ts
    Seq.Set<T>(collection?: Iterable<T> | ArrayLike<T>): Seq.Set<T>
    ```

    #### Discussion

    Note: [`Seq.Set`](index) is a conversion function and not a class, and does not use the `new` keyword during construction.

    ### Static methods
- name: Seq.Set.Seq.Set.of()
  id: seq.set/index#of()
  summary: null
  belongs_to: Seq.Set
  description: |-
    #### [Seq.Set.of()](index#of())

    ``` ts
    Seq.Set.of<T>(...values: Array<T>): Seq.Set<T>
    ```

    ### Conversion to JavaScript types
- name: Seq.Set.size
  id: seq.set/index#size
  summary: Some Seqs can describe their size lazily
  belongs_to: Seq.Set
  description: |-
    #### [size](index#size)

    Some Seqs can describe their size lazily. When this is the case, size will be an integer. Otherwise it will be undefined.

    ``` ts
    size: number | undefined
    ```

    #### Inherited from

    [`Seq#size`](../seq/index#size)

    #### Discussion

    For example, Seqs returned from [`map()`](../seq/index#map()) or [`reverse()`](../seq/index#reverse()) preserve the size of the original [`Seq`](../seq/index) while [`filter()`](../seq/index#filter()) does not.

    Note: [`Range`](../range()/index), [`Repeat`](../repeat()/index) and [`Seq`](../seq/index)s made from [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)s and [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)s will always have a size.

    ### Force evaluation
- name: Seq.Set.skip()
  id: seq.set/index#skip()
  summary: Returns a new Collection of the same type which excludes the first amount entries from this Collection
  belongs_to: Seq.Set
  description: |-
    #### [skip()](index#skip())

    Returns a new Collection of the same type which excludes the first `amount` entries from this Collection.

    ``` ts
    skip(amount: number): this
    ```

    #### Inherited from

    [`Collection#skip()`](../collection/index#skip())
- name: Seq.Set.skipLast()
  id: seq.set/index#skipLast()
  summary: Returns a new Collection of the same type which excludes the last amount entries from this Collection
  belongs_to: Seq.Set
  description: |-
    #### [skipLast()](index#skipLast())

    Returns a new Collection of the same type which excludes the last `amount` entries from this Collection.

    ``` ts
    skipLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#skipLast()`](../collection/index#skipLast())
- name: Seq.Set.skipUntil()
  id: seq.set/index#skipUntil()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns true
  belongs_to: Seq.Set
  description: |-
    #### [skipUntil()](index#skipUntil())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns true.

    ``` ts
    skipUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipUntil()`](../collection/index#skipUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipUntil(x => x.match(/hat/))
    // List [ "hat", "god" ]run it
    ```
- name: Seq.Set.skipWhile()
  id: seq.set/index#skipWhile()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns false
  belongs_to: Seq.Set
  description: |-
    #### [skipWhile()](index#skipWhile())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns false.

    ``` ts
    skipWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipWhile()`](../collection/index#skipWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipWhile(x => x.match(/g/))
    // List [ "cat", "hat", "god" ]run it
    ```
- name: Seq.Set.slice()
  id: seq.set/index#slice()
  summary: Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end
  belongs_to: Seq.Set
  description: |-
    #### [slice()](index#slice())

    Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.

    ``` ts
    slice(begin?: number, end?: number): this
    ```

    #### Inherited from

    [`Collection#slice()`](../collection/index#slice())

    #### Discussion

    If begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.

    If end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.

    If the requested slice is equivalent to the current Collection, then it will return itself.
- name: Seq.Set.some()
  id: seq.set/index#some()
  summary: True if predicate returns true for any entry in the Collection
  belongs_to: Seq.Set
  description: |-
    #### [some()](index#some())

    True if `predicate` returns true for any entry in the Collection.

    ``` ts
    some(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#some()`](../collection/index#some())
- name: Seq.Set.sort()
  id: seq.set/index#sort()
  summary: Returns a new Collection of the same type which includes the same entries, stably sorted by using a comparator
  belongs_to: Seq.Set
  description: |-
    #### [sort()](index#sort())

    Returns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.

    ``` ts
    sort(comparator?: (valueA: T, valueB: T) => number): this
    ```

    #### Inherited from

    [`Collection#sort()`](../collection/index#sort())

    #### Discussion

    If a `comparator` is not provided, a default comparator uses `<` and `>`.

    `comparator(valueA, valueB)`:

    - Returns `0` if the elements should not be swapped.
    - Returns `-1` (or any negative number) if `valueA` comes before `valueB`
    - Returns `1` (or any positive number) if `valueA` comes after `valueB`
    - Is pure, i.e. it must always return the same value for the same pair of values.

    When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.

    ``` ts
    const { Map } = require('immutable')
    Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
      if (a < b) { return -1; }
      if (a > b) { return 1; }
      if (a === b) { return 0; }
    });
    // OrderedMap { "a": 1, "b": 2, "c": 3 }run it
    ```

    Note: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Seq.Set.sortBy()
  id: seq.set/index#sortBy()
  summary: 'Note: sortBy() Always returns a new instance, even if the original was already sorted'
  belongs_to: Seq.Set
  description: |-
    #### [sortBy()](index#sortBy())

    Like [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:

    ``` ts
    sortBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this
    ```

    #### Inherited from

    [`Collection#sortBy()`](../collection/index#sortBy())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const beattles = Map({
      John: { name: "Lennon" },
      Paul: { name: "McCartney" },
      George: { name: "Harrison" },
      Ringo: { name: "Starr" },
    });
    beattles.sortBy(member => member.name);run it
    ```

    Note: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Seq.Set.take()
  id: seq.set/index#take()
  summary: Returns a new Collection of the same type which includes the first amount entries from this Collection
  belongs_to: Seq.Set
  description: |-
    #### [take()](index#take())

    Returns a new Collection of the same type which includes the first `amount` entries from this Collection.

    ``` ts
    take(amount: number): this
    ```

    #### Inherited from

    [`Collection#take()`](../collection/index#take())
- name: Seq.Set.takeLast()
  id: seq.set/index#takeLast()
  summary: Returns a new Collection of the same type which includes the last amount entries from this Collection
  belongs_to: Seq.Set
  description: |-
    #### [takeLast()](index#takeLast())

    Returns a new Collection of the same type which includes the last `amount` entries from this Collection.

    ``` ts
    takeLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#takeLast()`](../collection/index#takeLast())
- name: Seq.Set.takeUntil()
  id: seq.set/index#takeUntil()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns false
  belongs_to: Seq.Set
  description: |-
    #### [takeUntil()](index#takeUntil())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.

    ``` ts
    takeUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeUntil()`](../collection/index#takeUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeUntil(x => x.match(/at/))
    // List [ "dog", "frog" ]run it
    ```

    ### Reducing a value
- name: Seq.Set.takeWhile()
  id: seq.set/index#takeWhile()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns true
  belongs_to: Seq.Set
  description: |-
    #### [takeWhile()](index#takeWhile())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.

    ``` ts
    takeWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeWhile()`](../collection/index#takeWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeWhile(x => x.match(/o/))
    // List [ "dog", "frog" ]run it
    ```
- name: Seq.Set.toArray()
  id: seq.set/index#toArray()
  summary: Shallowly converts this collection to an Array
  belongs_to: Seq.Set
  description: |-
    #### [toArray()](index#toArray())

    Shallowly converts this collection to an Array.

    ``` ts
    toArray(): Array<T>
    ```

    #### Overrides

    [`Collection#toArray()`](../collection/index#toArray())
- name: Seq.Set.toIndexedSeq()
  id: seq.set/index#toIndexedSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Seq.Set
  description: |-
    #### [toIndexedSeq()](index#toIndexedSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    toIndexedSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())
- name: Seq.Set.toJS()
  id: seq.set/index#toJS()
  summary: Deeply converts this Set Seq to equivalent native JavaScript Array
  belongs_to: Seq.Set
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Set Seq to equivalent native JavaScript Array.

    ``` ts
    toJS(): Array<DeepCopy<T>>
    ```

    #### Overrides

    [`Collection#toJS()`](../collection/index#toJS())
- name: Seq.Set.toJSON()
  id: seq.set/index#toJSON()
  summary: Shallowly converts this Set Seq to equivalent native JavaScript Array
  belongs_to: Seq.Set
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Set Seq to equivalent native JavaScript Array.

    ``` ts
    toJSON(): Array<T>
    ```

    #### Overrides

    [`Collection#toJSON()`](../collection/index#toJSON())
- name: Seq.Set.toKeyedSeq()
  id: seq.set/index#toKeyedSeq()
  summary: Returns a Seq.Keyed from this Collection where indices are treated as keys
  belongs_to: Seq.Set
  description: |-
    #### [toKeyedSeq()](index#toKeyedSeq())

    Returns a Seq.Keyed from this Collection where indices are treated as keys.

    ``` ts
    toKeyedSeq(): Seq.Keyed<T, T>
    ```

    #### Inherited from

    [`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())

    #### Discussion

    This is useful if you want to operate on an Collection.Indexed and preserve the \[index, value\] pairs.

    The returned Seq will have identical iteration order as this Collection.

    ``` ts
    const { Seq } = require('immutable')
    const indexedSeq = Seq([ 'A', 'B', 'C' ])
    // Seq [ "A", "B", "C" ]
    indexedSeq.filter(v => v === 'B')
    // Seq [ "B" ]
    const keyedSeq = indexedSeq.toKeyedSeq()
    // Seq { 0: "A", 1: "B", 2: "C" }
    keyedSeq.filter(v => v === 'B')
    // Seq { 1: "B" }run it
    ```
- name: Seq.Set.toList()
  id: seq.set/index#toList()
  summary: Converts this Collection to a List, discarding keys
  belongs_to: Seq.Set
  description: |-
    #### [toList()](index#toList())

    Converts this Collection to a List, discarding keys.

    ``` ts
    toList(): List<T>
    ```

    #### Inherited from

    [`Collection#toList()`](../collection/index#toList())

    #### Discussion

    This is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.

    ``` ts
    const { Map, List } = require('immutable')
    var myMap = Map({ a: 'Apple', b: 'Banana' })
    List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
    myMap.toList() // List [ "Apple", "Banana" ]run it
    ```
- name: Seq.Set.toMap()
  id: seq.set/index#toMap()
  summary: Converts this Collection to a Map, Throws if keys are not hashable
  belongs_to: Seq.Set
  description: |-
    #### [toMap()](index#toMap())

    Converts this Collection to a Map, Throws if keys are not hashable.

    ``` ts
    toMap(): Map<T, T>
    ```

    #### Inherited from

    [`Collection#toMap()`](../collection/index#toMap())

    #### Discussion

    Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Seq.Set.toObject()
  id: seq.set/index#toObject()
  summary: Shallowly converts this Collection to an Object
  belongs_to: Seq.Set
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Collection to an Object.

    ``` ts
    toObject(): {[key: string]: T}
    ```

    #### Inherited from

    [`Collection#toObject()`](../collection/index#toObject())

    #### Discussion

    Converts keys to Strings.

    ### Conversion to Seq
- name: Seq.Set.toOrderedMap()
  id: seq.set/index#toOrderedMap()
  summary: Converts this Collection to a Map, maintaining the order of iteration
  belongs_to: Seq.Set
  description: |-
    #### [toOrderedMap()](index#toOrderedMap())

    Converts this Collection to a Map, maintaining the order of iteration.

    ``` ts
    toOrderedMap(): OrderedMap<T, T>
    ```

    #### Inherited from

    [`Collection#toOrderedMap()`](../collection/index#toOrderedMap())

    #### Discussion

    Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Seq.Set.toOrderedSet()
  id: seq.set/index#toOrderedSet()
  summary: Converts this Collection to a Set, maintaining the order of iteration and discarding keys
  belongs_to: Seq.Set
  description: |-
    #### [toOrderedSet()](index#toOrderedSet())

    Converts this Collection to a Set, maintaining the order of iteration and discarding keys.

    ``` ts
    toOrderedSet(): OrderedSet<T>
    ```

    #### Inherited from

    [`Collection#toOrderedSet()`](../collection/index#toOrderedSet())

    #### Discussion

    Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.
- name: Seq.Set.toSeq()
  id: seq.set/index#toSeq()
  summary: null
  belongs_to: Seq.Set
  description: |-
    #### [toSeq()](index#toSeq())

    Returns itself

    ``` ts
    toSeq(): this
    ```

    #### Overrides

    [`Collection#toSeq()`](../collection/index#toSeq())
- name: Seq.Set.toSet()
  id: seq.set/index#toSet()
  summary: Converts this Collection to a Set, discarding keys
  belongs_to: Seq.Set
  description: |-
    #### [toSet()](index#toSet())

    Converts this Collection to a Set, discarding keys. Throws if values are not hashable.

    ``` ts
    toSet(): Set<T>
    ```

    #### Inherited from

    [`Collection#toSet()`](../collection/index#toSet())

    #### Discussion

    Note: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.
- name: Seq.Set.toSetSeq()
  id: seq.set/index#toSetSeq()
  summary: Returns a Seq.Set of the values of this Collection, discarding keys
  belongs_to: Seq.Set
  description: |-
    #### [toSetSeq()](index#toSetSeq())

    Returns a Seq.Set of the values of this Collection, discarding keys.

    ``` ts
    toSetSeq(): Seq.Set<T>
    ```

    #### Inherited from

    [`Collection#toSetSeq()`](../collection/index#toSetSeq())

    ### Combination
- name: Seq.Set.toStack()
  id: seq.set/index#toStack()
  summary: Converts this Collection to a Stack, discarding keys
  belongs_to: Seq.Set
  description: |-
    #### [toStack()](index#toStack())

    Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.

    ``` ts
    toStack(): Stack<T>
    ```

    #### Inherited from

    [`Collection#toStack()`](../collection/index#toStack())

    #### Discussion

    Note: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.

    ### Collections (Seq)
- name: Seq.Set.update()
  id: seq.set/index#update()
  summary: This can be very useful as a way to "chain" a normal function into a sequence of methods
  belongs_to: Seq.Set
  description: |-
    #### [update()](index#update())

    This can be very useful as a way to "chain" a normal function into a sequence of methods. RxJS calls this "let" and lodash calls it "thru".

    ``` ts
    update<R>(updater: (value: this) => R): R
    ```

    #### Inherited from

    [`Collection#update()`](../collection/index#update())

    #### Discussion

    For example, to sum a Seq after mapping and filtering:

    ``` ts
    const { Seq } = require('immutable')

    function sum(collection) {
      return collection.reduce((sum, x) => sum + x, 0)
    }
    Seq([ 1, 2, 3 ])
      .map(x => x + 1)
      .filter(x => x % 2 === 0)
      .update(sum)
    // 6run it
    ```

    ### Conversion to Collections
- name: Seq.Set.values()
  id: seq.set/index#values()
  summary: An iterator of this Collection's values
  belongs_to: Seq.Set
  description: |-
    #### [values()](index#values())

    An iterator of this [`Collection`](../collection/index)'s values.

    ``` ts
    values(): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection#values()`](../collection/index#values())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.
- name: Seq.Set.valueSeq()
  id: seq.set/index#valueSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Seq.Set
  description: |-
    #### [valueSeq()](index#valueSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    valueSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#valueSeq()`](../collection/index#valueSeq())
- name: Seq.size
  id: seq/index#size
  summary: Some Seqs can describe their size lazily
  belongs_to: Seq
  description: |-
    #### [size](index#size)

    Some Seqs can describe their size lazily. When this is the case, size will be an integer. Otherwise it will be undefined.

    ``` ts
    size: number | undefined
    ```

    #### Discussion

    For example, Seqs returned from [`map()`](index#map()) or [`reverse()`](index#reverse()) preserve the size of the original [`Seq`](index) while [`filter()`](index#filter()) does not.

    Note: [`Range`](../range()/index), [`Repeat`](../repeat()/index) and [`Seq`](index)s made from [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)s and [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)s will always have a size.

    ### Force evaluation
- name: Seq.skip()
  id: seq/index#skip()
  summary: Returns a new Collection of the same type which excludes the first amount entries from this Collection
  belongs_to: Seq
  description: |-
    #### [skip()](index#skip())

    Returns a new Collection of the same type which excludes the first `amount` entries from this Collection.

    ``` ts
    skip(amount: number): this
    ```

    #### Inherited from

    [`Collection#skip()`](../collection/index#skip())
- name: Seq.skipLast()
  id: seq/index#skipLast()
  summary: Returns a new Collection of the same type which excludes the last amount entries from this Collection
  belongs_to: Seq
  description: |-
    #### [skipLast()](index#skipLast())

    Returns a new Collection of the same type which excludes the last `amount` entries from this Collection.

    ``` ts
    skipLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#skipLast()`](../collection/index#skipLast())
- name: Seq.skipUntil()
  id: seq/index#skipUntil()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns true
  belongs_to: Seq
  description: |-
    #### [skipUntil()](index#skipUntil())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns true.

    ``` ts
    skipUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipUntil()`](../collection/index#skipUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipUntil(x => x.match(/hat/))
    // List [ "hat", "god" ]run it
    ```
- name: Seq.skipWhile()
  id: seq/index#skipWhile()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns false
  belongs_to: Seq
  description: |-
    #### [skipWhile()](index#skipWhile())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns false.

    ``` ts
    skipWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipWhile()`](../collection/index#skipWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipWhile(x => x.match(/g/))
    // List [ "cat", "hat", "god" ]run it
    ```
- name: Seq.slice()
  id: seq/index#slice()
  summary: Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end
  belongs_to: Seq
  description: |-
    #### [slice()](index#slice())

    Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.

    ``` ts
    slice(begin?: number, end?: number): this
    ```

    #### Inherited from

    [`Collection#slice()`](../collection/index#slice())

    #### Discussion

    If begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.

    If end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.

    If the requested slice is equivalent to the current Collection, then it will return itself.
- name: Seq.some()
  id: seq/index#some()
  summary: True if predicate returns true for any entry in the Collection
  belongs_to: Seq
  description: |-
    #### [some()](index#some())

    True if `predicate` returns true for any entry in the Collection.

    ``` ts
    some(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#some()`](../collection/index#some())
- name: Seq.sort()
  id: seq/index#sort()
  summary: Returns a new Collection of the same type which includes the same entries, stably sorted by using a comparator
  belongs_to: Seq
  description: |-
    #### [sort()](index#sort())

    Returns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.

    ``` ts
    sort(comparator?: (valueA: V, valueB: V) => number): this
    ```

    #### Inherited from

    [`Collection#sort()`](../collection/index#sort())

    #### Discussion

    If a `comparator` is not provided, a default comparator uses `<` and `>`.

    `comparator(valueA, valueB)`:

    - Returns `0` if the elements should not be swapped.
    - Returns `-1` (or any negative number) if `valueA` comes before `valueB`
    - Returns `1` (or any positive number) if `valueA` comes after `valueB`
    - Is pure, i.e. it must always return the same value for the same pair of values.

    When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.

    ``` ts
    const { Map } = require('immutable')
    Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
      if (a < b) { return -1; }
      if (a > b) { return 1; }
      if (a === b) { return 0; }
    });
    // OrderedMap { "a": 1, "b": 2, "c": 3 }run it
    ```

    Note: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Seq.sortBy()
  id: seq/index#sortBy()
  summary: 'Note: sortBy() Always returns a new instance, even if the original was already sorted'
  belongs_to: Seq
  description: |-
    #### [sortBy()](index#sortBy())

    Like [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:

    ``` ts
    sortBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this
    ```

    #### Inherited from

    [`Collection#sortBy()`](../collection/index#sortBy())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const beattles = Map({
      John: { name: "Lennon" },
      Paul: { name: "McCartney" },
      George: { name: "Harrison" },
      Ringo: { name: "Starr" },
    });
    beattles.sortBy(member => member.name);run it
    ```

    Note: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Seq.take()
  id: seq/index#take()
  summary: Returns a new Collection of the same type which includes the first amount entries from this Collection
  belongs_to: Seq
  description: |-
    #### [take()](index#take())

    Returns a new Collection of the same type which includes the first `amount` entries from this Collection.

    ``` ts
    take(amount: number): this
    ```

    #### Inherited from

    [`Collection#take()`](../collection/index#take())
- name: Seq.takeLast()
  id: seq/index#takeLast()
  summary: Returns a new Collection of the same type which includes the last amount entries from this Collection
  belongs_to: Seq
  description: |-
    #### [takeLast()](index#takeLast())

    Returns a new Collection of the same type which includes the last `amount` entries from this Collection.

    ``` ts
    takeLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#takeLast()`](../collection/index#takeLast())
- name: Seq.takeUntil()
  id: seq/index#takeUntil()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns false
  belongs_to: Seq
  description: |-
    #### [takeUntil()](index#takeUntil())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.

    ``` ts
    takeUntil(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeUntil()`](../collection/index#takeUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeUntil(x => x.match(/at/))
    // List [ "dog", "frog" ]run it
    ```

    ### Combination
- name: Seq.takeWhile()
  id: seq/index#takeWhile()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns true
  belongs_to: Seq
  description: |-
    #### [takeWhile()](index#takeWhile())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.

    ``` ts
    takeWhile(predicate: (value: V, key: K, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeWhile()`](../collection/index#takeWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeWhile(x => x.match(/o/))
    // List [ "dog", "frog" ]run it
    ```
- name: Seq.toArray()
  id: seq/index#toArray()
  summary: Shallowly converts this collection to an Array
  belongs_to: Seq
  description: |-
    #### [toArray()](index#toArray())

    Shallowly converts this collection to an Array.

    ``` ts
    toArray(): Array<V> | Array<[K, V]>
    ```

    #### Inherited from

    [`Collection#toArray()`](../collection/index#toArray())

    #### Discussion

    [`Collection.Indexed`](../collection.indexed/index), and [`Collection.Set`](../collection.set/index) produce an Array of values. [`Collection.Keyed`](../collection.keyed/index) produce an Array of \[key, value\] tuples.
- name: Seq.toIndexedSeq()
  id: seq/index#toIndexedSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Seq
  description: |-
    #### [toIndexedSeq()](index#toIndexedSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    toIndexedSeq(): Seq.Indexed<V>
    ```

    #### Inherited from

    [`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())
- name: Seq.toJS()
  id: seq/index#toJS()
  summary: Deeply converts this Collection to equivalent native JavaScript Array or Object
  belongs_to: Seq
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Collection to equivalent native JavaScript Array or Object.

    ``` ts
    toJS(): Array<DeepCopy<V>> | {[key: string]: DeepCopy<V>}
    ```

    #### Inherited from

    [`Collection#toJS()`](../collection/index#toJS())

    #### Discussion

    [`Collection.Indexed`](../collection.indexed/index), and [`Collection.Set`](../collection.set/index) become [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array), while [`Collection.Keyed`](../collection.keyed/index) become [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object), converting keys to Strings.
- name: Seq.toJSON()
  id: seq/index#toJSON()
  summary: Shallowly converts this Collection to equivalent native JavaScript Array or Object
  belongs_to: Seq
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Collection to equivalent native JavaScript Array or Object.

    ``` ts
    toJSON(): Array<V> | {[key: string]: V}
    ```

    #### Inherited from

    [`Collection#toJSON()`](../collection/index#toJSON())

    #### Discussion

    [`Collection.Indexed`](../collection.indexed/index), and [`Collection.Set`](../collection.set/index) become [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array), while [`Collection.Keyed`](../collection.keyed/index) become [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object), converting keys to Strings.
- name: Seq.toKeyedSeq()
  id: seq/index#toKeyedSeq()
  summary: Returns a Seq.Keyed from this Collection where indices are treated as keys
  belongs_to: Seq
  description: |-
    #### [toKeyedSeq()](index#toKeyedSeq())

    Returns a Seq.Keyed from this Collection where indices are treated as keys.

    ``` ts
    toKeyedSeq(): Seq.Keyed<K, V>
    ```

    #### Inherited from

    [`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())

    #### Discussion

    This is useful if you want to operate on an Collection.Indexed and preserve the \[index, value\] pairs.

    The returned Seq will have identical iteration order as this Collection.

    ``` ts
    const { Seq } = require('immutable')
    const indexedSeq = Seq([ 'A', 'B', 'C' ])
    // Seq [ "A", "B", "C" ]
    indexedSeq.filter(v => v === 'B')
    // Seq [ "B" ]
    const keyedSeq = indexedSeq.toKeyedSeq()
    // Seq { 0: "A", 1: "B", 2: "C" }
    keyedSeq.filter(v => v === 'B')
    // Seq { 1: "B" }run it
    ```
- name: Seq.toList()
  id: seq/index#toList()
  summary: Converts this Collection to a List, discarding keys
  belongs_to: Seq
  description: |-
    #### [toList()](index#toList())

    Converts this Collection to a List, discarding keys.

    ``` ts
    toList(): List<V>
    ```

    #### Inherited from

    [`Collection#toList()`](../collection/index#toList())

    #### Discussion

    This is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.

    ``` ts
    const { Map, List } = require('immutable')
    var myMap = Map({ a: 'Apple', b: 'Banana' })
    List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
    myMap.toList() // List [ "Apple", "Banana" ]run it
    ```
- name: Seq.toMap()
  id: seq/index#toMap()
  summary: Converts this Collection to a Map, Throws if keys are not hashable
  belongs_to: Seq
  description: |-
    #### [toMap()](index#toMap())

    Converts this Collection to a Map, Throws if keys are not hashable.

    ``` ts
    toMap(): Map<K, V>
    ```

    #### Inherited from

    [`Collection#toMap()`](../collection/index#toMap())

    #### Discussion

    Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Seq.toObject()
  id: seq/index#toObject()
  summary: Shallowly converts this Collection to an Object
  belongs_to: Seq
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Collection to an Object.

    ``` ts
    toObject(): {[key: string]: V}
    ```

    #### Inherited from

    [`Collection#toObject()`](../collection/index#toObject())

    #### Discussion

    Converts keys to Strings.

    ### Conversion to Collections
- name: Seq.toOrderedMap()
  id: seq/index#toOrderedMap()
  summary: Converts this Collection to a Map, maintaining the order of iteration
  belongs_to: Seq
  description: |-
    #### [toOrderedMap()](index#toOrderedMap())

    Converts this Collection to a Map, maintaining the order of iteration.

    ``` ts
    toOrderedMap(): OrderedMap<K, V>
    ```

    #### Inherited from

    [`Collection#toOrderedMap()`](../collection/index#toOrderedMap())

    #### Discussion

    Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Seq.toOrderedSet()
  id: seq/index#toOrderedSet()
  summary: Converts this Collection to a Set, maintaining the order of iteration and discarding keys
  belongs_to: Seq
  description: |-
    #### [toOrderedSet()](index#toOrderedSet())

    Converts this Collection to a Set, maintaining the order of iteration and discarding keys.

    ``` ts
    toOrderedSet(): OrderedSet<V>
    ```

    #### Inherited from

    [`Collection#toOrderedSet()`](../collection/index#toOrderedSet())

    #### Discussion

    Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.
- name: Seq.toSeq()
  id: seq/index#toSeq()
  summary: Converts this Collection to a Seq of the same kind (indexed, keyed, or set)
  belongs_to: Seq
  description: |-
    #### [toSeq()](index#toSeq())

    Converts this Collection to a Seq of the same kind (indexed, keyed, or set).

    ``` ts
    toSeq(): Seq<K, V>
    ```

    #### Inherited from

    [`Collection#toSeq()`](../collection/index#toSeq())
- name: Seq.toSet()
  id: seq/index#toSet()
  summary: Converts this Collection to a Set, discarding keys
  belongs_to: Seq
  description: |-
    #### [toSet()](index#toSet())

    Converts this Collection to a Set, discarding keys. Throws if values are not hashable.

    ``` ts
    toSet(): Set<V>
    ```

    #### Inherited from

    [`Collection#toSet()`](../collection/index#toSet())

    #### Discussion

    Note: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.
- name: Seq.toSetSeq()
  id: seq/index#toSetSeq()
  summary: Returns a Seq.Set of the values of this Collection, discarding keys
  belongs_to: Seq
  description: |-
    #### [toSetSeq()](index#toSetSeq())

    Returns a Seq.Set of the values of this Collection, discarding keys.

    ``` ts
    toSetSeq(): Seq.Set<V>
    ```

    #### Inherited from

    [`Collection#toSetSeq()`](../collection/index#toSetSeq())

    ### Iterators
- name: Seq.toStack()
  id: seq/index#toStack()
  summary: Converts this Collection to a Stack, discarding keys
  belongs_to: Seq
  description: |-
    #### [toStack()](index#toStack())

    Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.

    ``` ts
    toStack(): Stack<V>
    ```

    #### Inherited from

    [`Collection#toStack()`](../collection/index#toStack())

    #### Discussion

    Note: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.

    ### Conversion to Seq
- name: Seq.update()
  id: seq/index#update()
  summary: This can be very useful as a way to "chain" a normal function into a sequence of methods
  belongs_to: Seq
  description: |-
    #### [update()](index#update())

    This can be very useful as a way to "chain" a normal function into a sequence of methods. RxJS calls this "let" and lodash calls it "thru".

    ``` ts
    update<R>(updater: (value: this) => R): R
    ```

    #### Inherited from

    [`Collection#update()`](../collection/index#update())

    #### Discussion

    For example, to sum a Seq after mapping and filtering:

    ``` ts
    const { Seq } = require('immutable')

    function sum(collection) {
      return collection.reduce((sum, x) => sum + x, 0)
    }
    Seq([ 1, 2, 3 ])
      .map(x => x + 1)
      .filter(x => x % 2 === 0)
      .update(sum)
    // 6run it
    ```

    ### Conversion to JavaScript types
- name: Seq.values()
  id: seq/index#values()
  summary: An iterator of this Collection's values
  belongs_to: Seq
  description: |-
    #### [values()](index#values())

    An iterator of this [`Collection`](../collection/index)'s values.

    ``` ts
    values(): IterableIterator<V>
    ```

    #### Inherited from

    [`Collection#values()`](../collection/index#values())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.
- name: Seq.valueSeq()
  id: seq/index#valueSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Seq
  description: |-
    #### [valueSeq()](index#valueSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    valueSeq(): Seq.Indexed<V>
    ```

    #### Inherited from

    [`Collection#valueSeq()`](../collection/index#valueSeq())
- name: Set
  id: set/index
  summary: A Collection of unique values with O(log32 N) adds and has
  description: "# Set\n\nA Collection of unique values with `O(log32 N)` adds and has.\n\n``` ts\ntype Set<T> extends Collection.Set<T>\n```\n\n#### Discussion\n\nWhen iterating a Set, the entries will be (value, value) pairs. Iteration order of a Set is undefined, however is stable. Multiple iterations of the same Set will iterate in the same order.\n\nSet values, like Map keys, may be of any type. Equality is determined using [`Immutable.is`](../is()/index), enabling Sets to uniquely include other Immutable collections, custom value types, and NaN.\n\n### Construction\n\n#### [Set()](index#Set())\n\nCreate a new immutable Set containing the values of the provided collection-like.\n\n``` ts\nSet<T>(collection?: Iterable<T> | ArrayLike<T>): Set<T>\n```\n\n#### Discussion\n\nNote: [`Set`](index) is a factory function and not a class, and does not use the `new` keyword during construction.\n\n### Static methods\n\n#### [Set.isSet()](index#isSet())\n\n``` ts\nSet.isSet(maybeSet: unknown): boolean\n```\n\n#### [Set.of()](index#of())\n\n``` ts\nSet.of<T>(...values: Array<T>): Set<T>\n```\n\n#### [Set.fromKeys()](index#fromKeys())\n\n``` ts\nSet.fromKeys<T>(iter: Collection<T, unknown>): Set<T>\nSet.fromKeys(obj: {[key: string]: unknown}): Set<string>\n```\n\n#### [Set.intersect()](index#intersect())\n\n``` ts\nSet.intersect<T>(sets: Iterable<Iterable<T>>): Set<T>\n```\n\n#### [Set.union()](index#union())\n\n``` ts\nSet.union<T>(sets: Iterable<Iterable<T>>): Set<T>\n```\n\n### Members\n\n#### [size](index#size)\n\nThe number of items in this Set.\n\n``` ts\nsize: number\n```\n\n### Persistent changes\n\n#### [add()](index#add())\n\nReturns a new Set which also includes this value.\n\n``` ts\nadd(value: T): this\n```\n\n#### Discussion\n\nNote: [`add`](index#add()) can be used in [`withMutations`](index#withMutations()).\n\n#### [delete()](index#delete())\n\nReturns a new Set which excludes this value.\n\n``` ts\ndelete(value: T): this\n```\n\n#### alias\n\n`remove()`\n\n#### Discussion\n\nNote: [`delete`](index#delete()) can be used in [`withMutations`](index#withMutations()).\n\nNote: [`delete`](index#delete()) **cannot** be safely used in IE8, use [`remove`](../remove()/index) if supporting old browsers.\n\n#### [clear()](index#clear())\n\nReturns a new Set containing no values.\n\n``` ts\nclear(): this\n```\n\n#### Discussion\n\nNote: [`clear`](index#clear()) can be used in [`withMutations`](index#withMutations()).\n\n#### [union()](index#union())\n\nReturns a Set including any value from `collections` that does not already exist in this Set.\n\n``` ts\nunion<C>(...collections: Array<Iterable<C>>): Set<T | C>\n```\n\n#### alias\n\n`merge()`\n\n#### alias\n\n`concat()`\n\n#### Discussion\n\nNote: [`union`](index#union()) can be used in [`withMutations`](index#withMutations()).\n\n#### [intersect()](index#intersect())\n\nReturns a Set which has removed any values not also contained within `collections`.\n\n``` ts\nintersect(...collections: Array<Iterable<T>>): this\n```\n\n#### Discussion\n\nNote: [`intersect`](index#intersect()) can be used in [`withMutations`](index#withMutations()).\n\n#### [subtract()](index#subtract())\n\nReturns a Set excluding any values contained within `collections`.\n\n``` ts\nsubtract(...collections: Array<Iterable<T>>): this\n```\n\n#### Discussion\n\n``` ts\nconst { OrderedSet } = require('immutable')\nOrderedSet([ 1, 2, 3 ]).subtract([1, 3])\n// OrderedSet [2]run it\n```\n\nNote: [`subtract`](index#subtract()) can be used in [`withMutations`](index#withMutations()).\n\n#### [update()](index#update())\n\nThis can be very useful as a way to \"chain\" a normal function into a sequence of methods. RxJS calls this \"let\" and lodash calls it \"thru\".\n\n``` ts\nupdate<R>(updater: (value: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#update()`](../collection/index#update())\n\n#### Discussion\n\nFor example, to sum a Seq after mapping and filtering:\n\n``` ts\nconst { Seq } = require('immutable')\n\nfunction sum(collection) {\n  return collection.reduce((sum, x) => sum + x, 0)\n}\nSeq([ 1, 2, 3 ])\n  .map(x => x + 1)\n  .filter(x => x % 2 === 0)\n  .update(sum)\n// 6run it\n```\n\n### Transient changes\n\n#### [withMutations()](index#withMutations())\n\nNote: Not all methods can be used on a mutable collection or within [`withMutations`](index#withMutations())! Check the documentation for each method to see if it mentions being safe to use in [`withMutations`](index#withMutations()).\n\n``` ts\nwithMutations(mutator: (mutable: this) => unknown): this\n```\n\n#### see\n\n[`Map#withMutations`](../map/index#withMutations())\n\n#### [asMutable()](index#asMutable())\n\nNote: Not all methods can be used on a mutable collection or within [`withMutations`](index#withMutations())! Check the documentation for each method to see if it mentions being safe to use in [`withMutations`](index#withMutations()).\n\n``` ts\nasMutable(): this\n```\n\n#### see\n\n[`Map#asMutable`](../map/index#asMutable())\n\n#### [wasAltered()](index#wasAltered())\n\n``` ts\nwasAltered(): boolean\n```\n\n#### see\n\n[`Map#wasAltered`](../map/index#wasAltered())\n\n#### [asImmutable()](index#asImmutable())\n\n``` ts\nasImmutable(): this\n```\n\n#### see\n\n[`Map#asImmutable`](../map/index#asImmutable())\n\n### Sequence algorithms\n\n#### [map()](index#map())\n\nReturns a new Set with values passed through a `mapper` function.\n\n``` ts\nmap<M>(mapper: (value: T, key: T, iter: this) => M, context?: unknown): Set<M>\n```\n\n#### Overrides\n\n[`Collection.Set#map()`](../collection.set/index#map())\n\n#### Example\n\n``` ts\nSet([1,2]).map(x => 10 * x)\n// Set [10,20]\n```\n\n#### [flatMap()](index#flatMap())\n\nFlat-maps the Set, returning a new Set.\n\n``` ts\nflatMap<M>(mapper: (value: T, key: T, iter: this) => Iterable<M>,context?: unknown): Set<M>\n```\n\n#### Overrides\n\n[`Collection.Set#flatMap()`](../collection.set/index#flatMap())\n\n#### Discussion\n\nSimilar to `set.map(...).flatten(true)`.\n\n#### [filter()](index#filter())\n\n``` ts\nfilter<F>(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): Set<F>\nfilter(predicate: (value: T, key: T, iter: this) => unknown,context?: unknown): this\n```\n\n#### Overrides\n\n[`Collection.Set#filter()`](../collection.set/index#filter())\n\n#### [partition()](index#partition())\n\n``` ts\npartition<F, C>(predicate: (this: C, value: T, key: T, iter: this) => boolean,context?: C): [Set<T>, Set<F>]\npartition<C>(predicate: (this: C, value: T, key: T, iter: this) => unknown,context?: C): [this, this]\n```\n\n#### Overrides\n\n[`Collection.Set#partition()`](../collection.set/index#partition())\n\n#### [concat()](index#concat())\n\nReturns a new Collection with other collections concatenated to this one.\n\n``` ts\nconcat<U>(...collections: Array<Iterable<U>>): Collection.Set<T | U>\n```\n\n#### Inherited from\n\n[`Collection.Set#concat()`](../collection.set/index#concat())\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection.Set#[Symbol.iterator]()`](../collection.set/index#%5BSymbol.iterator%5D())\n\n#### [filterNot()](index#filterNot())\n\nReturns a new Collection of the same type with only the entries for which the `predicate` function returns false.\n\n``` ts\nfilterNot(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#filterNot()`](../collection/index#filterNot())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }run it\n```\n\nNote: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.\n\n#### [reverse()](index#reverse())\n\nReturns a new Collection of the same type in reverse order.\n\n``` ts\nreverse(): this\n```\n\n#### Inherited from\n\n[`Collection#reverse()`](../collection/index#reverse())\n\n#### [sort()](index#sort())\n\nReturns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.\n\n``` ts\nsort(comparator?: (valueA: T, valueB: T) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sort()`](../collection/index#sort())\n\n#### Discussion\n\nIf a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n- Returns `0` if the elements should not be swapped.\n- Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n- Returns `1` (or any positive number) if `valueA` comes after `valueB`\n- Is pure, i.e. it must always return the same value for the same pair of values.\n\nWhen sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n``` ts\nconst { Map } = require('immutable')\nMap({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// OrderedMap { \"a\": 1, \"b\": 2, \"c\": 3 }run it\n```\n\nNote: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [sortBy()](index#sortBy())\n\nLike [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:\n\n``` ts\nsortBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sortBy()`](../collection/index#sortBy())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst beattles = Map({\n  John: { name: \"Lennon\" },\n  Paul: { name: \"McCartney\" },\n  George: { name: \"Harrison\" },\n  Ringo: { name: \"Starr\" },\n});\nbeattles.sortBy(member => member.name);run it\n```\n\nNote: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [groupBy()](index#groupBy())\n\nReturns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.\n\n``` ts\ngroupBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<T, T>>\n```\n\n#### Inherited from\n\n[`Collection#groupBy()`](../collection/index#groupBy())\n\n#### Discussion\n\nNote: This is always an eager operation.\n\n``` ts\nconst { List, Map } = require('immutable')\nconst listOfMaps = List([\n  Map({ v: 0 }),\n  Map({ v: 1 }),\n  Map({ v: 1 }),\n  Map({ v: 0 }),\n  Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ Map{ \"v\": 0 }, Map { \"v\": 0 } ],\n//   1: List [ Map{ \"v\": 1 }, Map { \"v\": 1 } ],\n//   2: List [ Map{ \"v\": 2 } ],\n// }run it\n```\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Set collection to equivalent native JavaScript Array.\n\n``` ts\ntoJS(): Array<DeepCopy<T>>\n```\n\n#### Inherited from\n\n[`Collection.Set#toJS()`](../collection.set/index#toJS())\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Set collection to equivalent native JavaScript Array.\n\n``` ts\ntoJSON(): Array<T>\n```\n\n#### Inherited from\n\n[`Collection.Set#toJSON()`](../collection.set/index#toJSON())\n\n#### [toArray()](index#toArray())\n\nShallowly converts this collection to an Array.\n\n``` ts\ntoArray(): Array<T>\n```\n\n#### Inherited from\n\n[`Collection.Set#toArray()`](../collection.set/index#toArray())\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Collection to an Object.\n\n``` ts\ntoObject(): {[key: string]: T}\n```\n\n#### Inherited from\n\n[`Collection#toObject()`](../collection/index#toObject())\n\n#### Discussion\n\nConverts keys to Strings.\n\n### Conversion to Seq\n\n#### [toSeq()](index#toSeq())\n\nReturns Seq.Set.\n\n``` ts\ntoSeq(): Seq.Set<T>\n```\n\n#### Inherited from\n\n[`Collection.Set#toSeq()`](../collection.set/index#toSeq())\n\n#### [toKeyedSeq()](index#toKeyedSeq())\n\nReturns a Seq.Keyed from this Collection where indices are treated as keys.\n\n``` ts\ntoKeyedSeq(): Seq.Keyed<T, T>\n```\n\n#### Inherited from\n\n[`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())\n\n#### Discussion\n\nThis is useful if you want to operate on an Collection.Indexed and preserve the \\[index, value\\] pairs.\n\nThe returned Seq will have identical iteration order as this Collection.\n\n``` ts\nconst { Seq } = require('immutable')\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\n// Seq [ \"A\", \"B\", \"C\" ]\nindexedSeq.filter(v => v === 'B')\n// Seq [ \"B\" ]\nconst keyedSeq = indexedSeq.toKeyedSeq()\n// Seq { 0: \"A\", 1: \"B\", 2: \"C\" }\nkeyedSeq.filter(v => v === 'B')\n// Seq { 1: \"B\" }run it\n```\n\n#### [toIndexedSeq()](index#toIndexedSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\ntoIndexedSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())\n\n#### [toSetSeq()](index#toSetSeq())\n\nReturns a Seq.Set of the values of this Collection, discarding keys.\n\n``` ts\ntoSetSeq(): Seq.Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSetSeq()`](../collection/index#toSetSeq())\n\n### Value equality\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#equals()`](../collection/index#equals())\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Inherited from\n\n[`Collection#hashCode()`](../collection/index#hashCode())\n\n#### Discussion\n\nThe [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nIf two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.\n\n### Reading values\n\n#### [get()](index#get())\n\n``` ts\nget<NSV>(key: T, notSetValue: NSV): T | NSV\nget(key: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#get()`](../collection/index#get())\n\n#### [has()](index#has())\n\nTrue if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nhas(key: T): boolean\n```\n\n#### Inherited from\n\n[`Collection#has()`](../collection/index#has())\n\n#### [includes()](index#includes())\n\nTrue if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nincludes(value: T): boolean\n```\n\n#### Inherited from\n\n[`Collection#includes()`](../collection/index#includes())\n\n#### alias\n\n`contains()`\n\n#### [first()](index#first())\n\nIn case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nfirst<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#first()`](../collection/index#first())\n\n#### [last()](index#last())\n\nIn case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nlast<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#last()`](../collection/index#last())\n\n### Reading deep values\n\n#### [getIn()](index#getIn())\n\nReturns the value found by following a path of keys or indices through nested Collections.\n\n``` ts\ngetIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown\n```\n\n#### Inherited from\n\n[`Collection#getIn()`](../collection/index#getIn())\n\n#### Discussion\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: [ { y: 123 } ] });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\n#### [hasIn()](index#hasIn())\n\nTrue if the result of following a path of keys or indices through nested Collections results in a set value.\n\n``` ts\nhasIn(searchKeyPath: Iterable<unknown>): boolean\n```\n\n#### Inherited from\n\n[`Collection#hasIn()`](../collection/index#hasIn())\n\n### Conversion to Collections\n\n#### [toMap()](index#toMap())\n\nConverts this Collection to a Map, Throws if keys are not hashable.\n\n``` ts\ntoMap(): Map<T, T>\n```\n\n#### Inherited from\n\n[`Collection#toMap()`](../collection/index#toMap())\n\n#### Discussion\n\nNote: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toOrderedMap()](index#toOrderedMap())\n\nConverts this Collection to a Map, maintaining the order of iteration.\n\n``` ts\ntoOrderedMap(): OrderedMap<T, T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedMap()`](../collection/index#toOrderedMap())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toSet()](index#toSet())\n\nConverts this Collection to a Set, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoSet(): Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSet()`](../collection/index#toSet())\n\n#### Discussion\n\nNote: This is equivalent to [`Set(this)`](index), but provided to allow for chained expressions.\n\n#### [toOrderedSet()](index#toOrderedSet())\n\nConverts this Collection to a Set, maintaining the order of iteration and discarding keys.\n\n``` ts\ntoOrderedSet(): OrderedSet<T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedSet()`](../collection/index#toOrderedSet())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toList()](index#toList())\n\nConverts this Collection to a List, discarding keys.\n\n``` ts\ntoList(): List<T>\n```\n\n#### Inherited from\n\n[`Collection#toList()`](../collection/index#toList())\n\n#### Discussion\n\nThis is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.\n\n``` ts\nconst { Map, List } = require('immutable')\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\nList(myMap) // List [ [ \"a\", \"Apple\" ], [ \"b\", \"Banana\" ] ]\nmyMap.toList() // List [ \"Apple\", \"Banana\" ]run it\n```\n\n#### [toStack()](index#toStack())\n\nConverts this Collection to a Stack, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoStack(): Stack<T>\n```\n\n#### Inherited from\n\n[`Collection#toStack()`](../collection/index#toStack())\n\n#### Discussion\n\nNote: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.\n\n### Iterators\n\n#### [keys()](index#keys())\n\nAn iterator of this [`Collection`](../collection/index)'s keys.\n\n``` ts\nkeys(): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection#keys()`](../collection/index#keys())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.\n\n#### [values()](index#values())\n\nAn iterator of this [`Collection`](../collection/index)'s values.\n\n``` ts\nvalues(): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection#values()`](../collection/index#values())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.\n\n#### [entries()](index#entries())\n\nAn iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.\n\n``` ts\nentries(): IterableIterator<[T, T]>\n```\n\n#### Inherited from\n\n[`Collection#entries()`](../collection/index#entries())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.\n\n### Collections (Seq)\n\n#### [keySeq()](index#keySeq())\n\nReturns a new Seq.Indexed of the keys of this Collection, discarding values.\n\n``` ts\nkeySeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#keySeq()`](../collection/index#keySeq())\n\n#### [valueSeq()](index#valueSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\nvalueSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#valueSeq()`](../collection/index#valueSeq())\n\n#### [entrySeq()](index#entrySeq())\n\nReturns a new Seq.Indexed of \\[key, value\\] tuples.\n\n``` ts\nentrySeq(): Seq.Indexed<[T, T]>\n```\n\n#### Inherited from\n\n[`Collection#entrySeq()`](../collection/index#entrySeq())\n\n### Side effects\n\n#### [forEach()](index#forEach())\n\nThe `sideEffect` is executed for every entry in the Collection.\n\n``` ts\nforEach(sideEffect: (value: T, key: T, iter: this) => unknown,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#forEach()`](../collection/index#forEach())\n\n#### Discussion\n\nUnlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).\n\n### Creating subsets\n\n#### [slice()](index#slice())\n\nReturns a new Collection of the same type representing a portion of this Collection from start up to but not including end.\n\n``` ts\nslice(begin?: number, end?: number): this\n```\n\n#### Inherited from\n\n[`Collection#slice()`](../collection/index#slice())\n\n#### Discussion\n\nIf begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.\n\nIf the requested slice is equivalent to the current Collection, then it will return itself.\n\n#### [rest()](index#rest())\n\nReturns a new Collection of the same type containing all entries except the first.\n\n``` ts\nrest(): this\n```\n\n#### Inherited from\n\n[`Collection#rest()`](../collection/index#rest())\n\n#### [butLast()](index#butLast())\n\nReturns a new Collection of the same type containing all entries except the last.\n\n``` ts\nbutLast(): this\n```\n\n#### Inherited from\n\n[`Collection#butLast()`](../collection/index#butLast())\n\n#### [skip()](index#skip())\n\nReturns a new Collection of the same type which excludes the first `amount` entries from this Collection.\n\n``` ts\nskip(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skip()`](../collection/index#skip())\n\n#### [skipLast()](index#skipLast())\n\nReturns a new Collection of the same type which excludes the last `amount` entries from this Collection.\n\n``` ts\nskipLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skipLast()`](../collection/index#skipLast())\n\n#### [skipWhile()](index#skipWhile())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns false.\n\n``` ts\nskipWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipWhile()`](../collection/index#skipWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipWhile(x => x.match(/g/))\n// List [ \"cat\", \"hat\", \"god\" ]run it\n```\n\n#### [skipUntil()](index#skipUntil())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns true.\n\n``` ts\nskipUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipUntil()`](../collection/index#skipUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipUntil(x => x.match(/hat/))\n// List [ \"hat\", \"god\" ]run it\n```\n\n#### [take()](index#take())\n\nReturns a new Collection of the same type which includes the first `amount` entries from this Collection.\n\n``` ts\ntake(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#take()`](../collection/index#take())\n\n#### [takeLast()](index#takeLast())\n\nReturns a new Collection of the same type which includes the last `amount` entries from this Collection.\n\n``` ts\ntakeLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#takeLast()`](../collection/index#takeLast())\n\n#### [takeWhile()](index#takeWhile())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.\n\n``` ts\ntakeWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeWhile()`](../collection/index#takeWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeWhile(x => x.match(/o/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n#### [takeUntil()](index#takeUntil())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.\n\n``` ts\ntakeUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeUntil()`](../collection/index#takeUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeUntil(x => x.match(/at/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n### Combination\n\n#### [flatten()](index#flatten())\n\n``` ts\nflatten(depth?: number): Collection<unknown, unknown>\nflatten(shallow?: boolean): Collection<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection#flatten()`](../collection/index#flatten())\n\n### Reducing a value\n\n#### [reduce()](index#reduce())\n\n``` ts\nreduce<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R\nreduce<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduce()`](../collection/index#reduce())\n\n#### [reduceRight()](index#reduceRight())\n\n``` ts\nreduceRight<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R\nreduceRight<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduceRight()`](../collection/index#reduceRight())\n\n#### [every()](index#every())\n\nTrue if `predicate` returns true for all entries in the Collection.\n\n``` ts\nevery(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#every()`](../collection/index#every())\n\n#### [some()](index#some())\n\nTrue if `predicate` returns true for any entry in the Collection.\n\n``` ts\nsome(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#some()`](../collection/index#some())\n\n#### [join()](index#join())\n\nJoins values together as a string, inserting a separator between each. The default separator is `\",\"`.\n\n``` ts\njoin(separator?: string): string\n```\n\n#### Inherited from\n\n[`Collection#join()`](../collection/index#join())\n\n#### [isEmpty()](index#isEmpty())\n\nReturns true if this Collection includes no values.\n\n``` ts\nisEmpty(): boolean\n```\n\n#### Inherited from\n\n[`Collection#isEmpty()`](../collection/index#isEmpty())\n\n#### Discussion\n\nFor some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.\n\n#### [count()](index#count())\n\n``` ts\ncount(): number\ncount(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#count()`](../collection/index#count())\n\n#### [countBy()](index#countBy())\n\nReturns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.\n\n``` ts\ncountBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Map<G, number>\n```\n\n#### Inherited from\n\n[`Collection#countBy()`](../collection/index#countBy())\n\n#### Discussion\n\nNote: This is not a lazy operation.\n\n### Search for value\n\n#### [find()](index#find())\n\nReturns the first value for which the `predicate` returns true.\n\n``` ts\nfind(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#find()`](../collection/index#find())\n\n#### [findLast()](index#findLast())\n\nReturns the last value for which the `predicate` returns true.\n\n``` ts\nfindLast(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLast()`](../collection/index#findLast())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findEntry()](index#findEntry())\n\nReturns the first \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findEntry()`](../collection/index#findEntry())\n\n#### [findLastEntry()](index#findLastEntry())\n\nReturns the last \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindLastEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastEntry()`](../collection/index#findLastEntry())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findKey()](index#findKey())\n\nReturns the key for which the `predicate` returns true.\n\n``` ts\nfindKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findKey()`](../collection/index#findKey())\n\n#### [findLastKey()](index#findLastKey())\n\nReturns the last key for which the `predicate` returns true.\n\n``` ts\nfindLastKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastKey()`](../collection/index#findLastKey())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [keyOf()](index#keyOf())\n\nReturns the key associated with the search value, or undefined.\n\n``` ts\nkeyOf(searchValue: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#keyOf()`](../collection/index#keyOf())\n\n#### [lastKeyOf()](index#lastKeyOf())\n\nReturns the last key associated with the search value, or undefined.\n\n``` ts\nlastKeyOf(searchValue: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#lastKeyOf()`](../collection/index#lastKeyOf())\n\n#### [max()](index#max())\n\nReturns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmax(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#max()`](../collection/index#max())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [maxBy()](index#maxBy())\n\nLike [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nmaxBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#maxBy()`](../collection/index#maxBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it\n```\n\n#### [min()](index#min())\n\nReturns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmin(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#min()`](../collection/index#min())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [minBy()](index#minBy())\n\nLike [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nminBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#minBy()`](../collection/index#minBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it\n```\n\n### Comparison\n\n#### [isSubset()](index#isSubset())\n\nTrue if `iter` includes every value in this Collection.\n\n``` ts\nisSubset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSubset()`](../collection/index#isSubset())\n\n#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Set/](https://immutable-js.com/docs/v4.2.1/Set/)"
- name: set()
  id: set()/index
  summary: This documentation is generated from immutable.d.ts
  description: "# set()\n\n``` ts\nset<K, V, C>(collection: C, key: K, value: V): C\nset<TProps, C, K>(record: C, key: K, value: TProps,[K]): C\nset<V, C>(collection: C, key: number, value: V): C\nset<C, K>(object: C, key: K, value: C,[K]): C\nset<V, C>(collection: C, key: string, value: V): C\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/set()/](https://immutable-js.com/docs/v4.2.1/set()/)"
- name: Set.[Symbol.iterator]()
  id: set/index#[Symbol.iterator]()
  summary: null
  belongs_to: Set
  description: |-
    #### [\[Symbol.iterator\]()](index#%5BSymbol.iterator%5D())

    ``` ts
    [Symbol.iterator](): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection.Set#[Symbol.iterator]()`](../collection.set/index#%5BSymbol.iterator%5D())
- name: Set.add()
  id: set/index#add()
  summary: Returns a new Set which also includes this value
  belongs_to: Set
  description: |-
    #### [add()](index#add())

    Returns a new Set which also includes this value.

    ``` ts
    add(value: T): this
    ```

    #### Discussion

    Note: [`add`](index#add()) can be used in [`withMutations`](index#withMutations()).
- name: Set.asImmutable()
  id: set/index#asImmutable()
  summary: null
  belongs_to: Set
  description: |-
    #### [asImmutable()](index#asImmutable())

    ``` ts
    asImmutable(): this
    ```

    #### see

    [`Map#asImmutable`](../map/index#asImmutable())

    ### Sequence algorithms
- name: Set.asMutable()
  id: set/index#asMutable()
  summary: 'Note: Not all methods can be used on a mutable collection or within withMutations! Check the documentation for each method to see if it mentions being safe to use in withMutations'
  belongs_to: Set
  description: |-
    #### [asMutable()](index#asMutable())

    Note: Not all methods can be used on a mutable collection or within [`withMutations`](index#withMutations())! Check the documentation for each method to see if it mentions being safe to use in [`withMutations`](index#withMutations()).

    ``` ts
    asMutable(): this
    ```

    #### see

    [`Map#asMutable`](../map/index#asMutable())
- name: Set.butLast()
  id: set/index#butLast()
  summary: Returns a new Collection of the same type containing all entries except the last
  belongs_to: Set
  description: |-
    #### [butLast()](index#butLast())

    Returns a new Collection of the same type containing all entries except the last.

    ``` ts
    butLast(): this
    ```

    #### Inherited from

    [`Collection#butLast()`](../collection/index#butLast())
- name: Set.clear()
  id: set/index#clear()
  summary: Returns a new Set containing no values
  belongs_to: Set
  description: |-
    #### [clear()](index#clear())

    Returns a new Set containing no values.

    ``` ts
    clear(): this
    ```

    #### Discussion

    Note: [`clear`](index#clear()) can be used in [`withMutations`](index#withMutations()).

    #### [union()](index#union())

    Returns a Set including any value from `collections` that does not already exist in this Set.

    ``` ts
    union<C>(...collections: Array<Iterable<C>>): Set<T | C>
    ```

    #### alias

    `merge()`

    #### alias

    `concat()`

    #### Discussion

    Note: [`union`](index#union()) can be used in [`withMutations`](index#withMutations()).

    #### [intersect()](index#intersect())

    Returns a Set which has removed any values not also contained within `collections`.

    ``` ts
    intersect(...collections: Array<Iterable<T>>): this
    ```

    #### Discussion

    Note: [`intersect`](index#intersect()) can be used in [`withMutations`](index#withMutations()).
- name: Set.concat()
  id: set/index#concat()
  summary: Returns a new Collection with other collections concatenated to this one
  belongs_to: Set
  description: |-
    #### [concat()](index#concat())

    Returns a new Collection with other collections concatenated to this one.

    ``` ts
    concat<U>(...collections: Array<Iterable<U>>): Collection.Set<T | U>
    ```

    #### Inherited from

    [`Collection.Set#concat()`](../collection.set/index#concat())
- name: Set.count()
  id: set/index#count()
  summary: null
  belongs_to: Set
  description: |-
    #### [count()](index#count())

    ``` ts
    count(): number
    count(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#count()`](../collection/index#count())
- name: Set.countBy()
  id: set/index#countBy()
  summary: Returns a Seq.Keyed of counts, grouped by the return value of the grouper function
  belongs_to: Set
  description: |-
    #### [countBy()](index#countBy())

    Returns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.

    ``` ts
    countBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Map<G, number>
    ```

    #### Inherited from

    [`Collection#countBy()`](../collection/index#countBy())

    #### Discussion

    Note: This is not a lazy operation.

    ### Search for value
- name: Set.delete()
  id: set/index#delete()
  summary: Returns a new Set which excludes this value
  belongs_to: Set
  description: |-
    #### [delete()](index#delete())

    Returns a new Set which excludes this value.

    ``` ts
    delete(value: T): this
    ```

    #### alias

    `remove()`

    #### Discussion

    Note: [`delete`](index#delete()) can be used in [`withMutations`](index#withMutations()).

    Note: [`delete`](index#delete()) **cannot** be safely used in IE8, use [`remove`](../remove()/index) if supporting old browsers.
- name: Set.entries()
  id: set/index#entries()
  summary: An iterator of this Collection's entries as [ key, value ] tuples
  belongs_to: Set
  description: |-
    #### [entries()](index#entries())

    An iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.

    ``` ts
    entries(): IterableIterator<[T, T]>
    ```

    #### Inherited from

    [`Collection#entries()`](../collection/index#entries())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.

    ### Collections (Seq)
- name: Set.entrySeq()
  id: set/index#entrySeq()
  summary: Returns a new Seq.Indexed of [key, value] tuples
  belongs_to: Set
  description: |-
    #### [entrySeq()](index#entrySeq())

    Returns a new Seq.Indexed of \[key, value\] tuples.

    ``` ts
    entrySeq(): Seq.Indexed<[T, T]>
    ```

    #### Inherited from

    [`Collection#entrySeq()`](../collection/index#entrySeq())

    ### Side effects
- name: Set.equals()
  id: set/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: Set
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Inherited from

    [`Collection#equals()`](../collection/index#equals())

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: Set.every()
  id: set/index#every()
  summary: True if predicate returns true for all entries in the Collection
  belongs_to: Set
  description: |-
    #### [every()](index#every())

    True if `predicate` returns true for all entries in the Collection.

    ``` ts
    every(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#every()`](../collection/index#every())
- name: Set.filter()
  id: set/index#filter()
  summary: null
  belongs_to: Set
  description: |-
    #### [filter()](index#filter())

    ``` ts
    filter<F>(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): Set<F>
    filter(predicate: (value: T, key: T, iter: this) => unknown,context?: unknown): this
    ```

    #### Overrides

    [`Collection.Set#filter()`](../collection.set/index#filter())
- name: Set.filterNot()
  id: set/index#filterNot()
  summary: Returns a new Collection of the same type with only the entries for which the predicate function returns false
  belongs_to: Set
  description: |-
    #### [filterNot()](index#filterNot())

    Returns a new Collection of the same type with only the entries for which the `predicate` function returns false.

    ``` ts
    filterNot(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#filterNot()`](../collection/index#filterNot())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
    // Map { "a": 1, "c": 3 }run it
    ```

    Note: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.
- name: Set.find()
  id: set/index#find()
  summary: Returns the first value for which the predicate returns true
  belongs_to: Set
  description: |-
    #### [find()](index#find())

    Returns the first value for which the `predicate` returns true.

    ``` ts
    find(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#find()`](../collection/index#find())
- name: Set.findEntry()
  id: set/index#findEntry()
  summary: Returns the first [key, value] entry for which the predicate returns true
  belongs_to: Set
  description: |-
    #### [findEntry()](index#findEntry())

    Returns the first \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined
    ```

    #### Inherited from

    [`Collection#findEntry()`](../collection/index#findEntry())
- name: Set.findKey()
  id: set/index#findKey()
  summary: Returns the key for which the predicate returns true
  belongs_to: Set
  description: |-
    #### [findKey()](index#findKey())

    Returns the key for which the `predicate` returns true.

    ``` ts
    findKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined
    ```

    #### Inherited from

    [`Collection#findKey()`](../collection/index#findKey())
- name: Set.findLast()
  id: set/index#findLast()
  summary: Returns the last value for which the predicate returns true
  belongs_to: Set
  description: |-
    #### [findLast()](index#findLast())

    Returns the last value for which the `predicate` returns true.

    ``` ts
    findLast(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#findLast()`](../collection/index#findLast())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Set.findLastEntry()
  id: set/index#findLastEntry()
  summary: Returns the last [key, value] entry for which the predicate returns true
  belongs_to: Set
  description: |-
    #### [findLastEntry()](index#findLastEntry())

    Returns the last \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findLastEntry(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown,notSetValue?: T): [T, T] | undefined
    ```

    #### Inherited from

    [`Collection#findLastEntry()`](../collection/index#findLastEntry())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Set.findLastKey()
  id: set/index#findLastKey()
  summary: Returns the last key for which the predicate returns true
  belongs_to: Set
  description: |-
    #### [findLastKey()](index#findLastKey())

    Returns the last key for which the `predicate` returns true.

    ``` ts
    findLastKey(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): T | undefined
    ```

    #### Inherited from

    [`Collection#findLastKey()`](../collection/index#findLastKey())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Set.first()
  id: set/index#first()
  summary: In case the Collection is not empty returns the first element of the Collection
  belongs_to: Set
  description: |-
    #### [first()](index#first())

    In case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    first<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#first()`](../collection/index#first())
- name: Set.flatMap()
  id: set/index#flatMap()
  summary: Flat-maps the Set, returning a new Set
  belongs_to: Set
  description: |-
    #### [flatMap()](index#flatMap())

    Flat-maps the Set, returning a new Set.

    ``` ts
    flatMap<M>(mapper: (value: T, key: T, iter: this) => Iterable<M>,context?: unknown): Set<M>
    ```

    #### Overrides

    [`Collection.Set#flatMap()`](../collection.set/index#flatMap())

    #### Discussion

    Similar to `set.map(...).flatten(true)`.
- name: Set.flatten()
  id: set/index#flatten()
  summary: null
  belongs_to: Set
  description: |-
    #### [flatten()](index#flatten())

    ``` ts
    flatten(depth?: number): Collection<unknown, unknown>
    flatten(shallow?: boolean): Collection<unknown, unknown>
    ```

    #### Inherited from

    [`Collection#flatten()`](../collection/index#flatten())

    ### Reducing a value
- name: Set.forEach()
  id: set/index#forEach()
  summary: The sideEffect is executed for every entry in the Collection
  belongs_to: Set
  description: |-
    #### [forEach()](index#forEach())

    The `sideEffect` is executed for every entry in the Collection.

    ``` ts
    forEach(sideEffect: (value: T, key: T, iter: this) => unknown,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#forEach()`](../collection/index#forEach())

    #### Discussion

    Unlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).

    ### Creating subsets
- name: Set.get()
  id: set/index#get()
  summary: null
  belongs_to: Set
  description: |-
    #### [get()](index#get())

    ``` ts
    get<NSV>(key: T, notSetValue: NSV): T | NSV
    get(key: T): T | undefined
    ```

    #### Inherited from

    [`Collection#get()`](../collection/index#get())
- name: Set.getIn()
  id: set/index#getIn()
  summary: Returns the value found by following a path of keys or indices through nested Collections
  belongs_to: Set
  description: |-
    #### [getIn()](index#getIn())

    Returns the value found by following a path of keys or indices through nested Collections.

    ``` ts
    getIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown
    ```

    #### Inherited from

    [`Collection#getIn()`](../collection/index#getIn())

    #### Discussion

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: [ { y: 123 } ] });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```
- name: Set.groupBy()
  id: set/index#groupBy()
  summary: Returns a Collection.Keyed of Collection.Keyeds, grouped by the return value of the grouper function
  belongs_to: Set
  description: |-
    #### [groupBy()](index#groupBy())

    Returns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.

    ``` ts
    groupBy<G>(grouper: (value: T, key: T, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<T, T>>
    ```

    #### Inherited from

    [`Collection#groupBy()`](../collection/index#groupBy())

    #### Discussion

    Note: This is always an eager operation.

    ``` ts
    const { List, Map } = require('immutable')
    const listOfMaps = List([
      Map({ v: 0 }),
      Map({ v: 1 }),
      Map({ v: 1 }),
      Map({ v: 0 }),
      Map({ v: 2 })
    ])
    const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
    // Map {
    //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
    //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
    //   2: List [ Map{ "v": 2 } ],
    // }run it
    ```

    ### Conversion to JavaScript types
- name: Set.has()
  id: set/index#has()
  summary: null
  belongs_to: Set
  description: |-
    #### [has()](index#has())

    True if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    has(key: T): boolean
    ```

    #### Inherited from

    [`Collection#has()`](../collection/index#has())
- name: Set.hashCode()
  id: set/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: Set
  description: |-
    #### [hashCode()](index#hashCode())

    Computes and returns the hashed identity for this Collection.

    ``` ts
    hashCode(): number
    ```

    #### Inherited from

    [`Collection#hashCode()`](../collection/index#hashCode())

    #### Discussion

    The [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.

    ``` ts
    const a = List([ 1, 2, 3 ]);
    const b = List([ 1, 2, 3 ]);
    assert.notStrictEqual(a, b); // different instances
    const set = Set([ a ]);
    assert.equal(set.has(b), true);run it
    ```

    If two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.

    ### Reading values
- name: Set.hasIn()
  id: set/index#hasIn()
  summary: True if the result of following a path of keys or indices through nested Collections results in a set value
  belongs_to: Set
  description: |-
    #### [hasIn()](index#hasIn())

    True if the result of following a path of keys or indices through nested Collections results in a set value.

    ``` ts
    hasIn(searchKeyPath: Iterable<unknown>): boolean
    ```

    #### Inherited from

    [`Collection#hasIn()`](../collection/index#hasIn())

    ### Conversion to Collections
- name: Set.includes()
  id: set/index#includes()
  summary: null
  belongs_to: Set
  description: |-
    #### [includes()](index#includes())

    True if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    includes(value: T): boolean
    ```

    #### Inherited from

    [`Collection#includes()`](../collection/index#includes())

    #### alias

    `contains()`
- name: Set.isEmpty()
  id: set/index#isEmpty()
  summary: Returns true if this Collection includes no values
  belongs_to: Set
  description: |-
    #### [isEmpty()](index#isEmpty())

    Returns true if this Collection includes no values.

    ``` ts
    isEmpty(): boolean
    ```

    #### Inherited from

    [`Collection#isEmpty()`](../collection/index#isEmpty())

    #### Discussion

    For some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.
- name: Set.isSubset()
  id: set/index#isSubset()
  summary: True if iter includes every value in this Collection
  belongs_to: Set
  description: |-
    #### [isSubset()](index#isSubset())

    True if `iter` includes every value in this Collection.

    ``` ts
    isSubset(iter: Iterable<T>): boolean
    ```

    #### Inherited from

    [`Collection#isSubset()`](../collection/index#isSubset())
- name: Set.isSuperset()
  id: set/index#isSuperset()
  summary: True if this Collection includes every value in iter
  belongs_to: Set
  description: "#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Set/](https://immutable-js.com/docs/v4.2.1/Set/)"
- name: Set.join()
  id: set/index#join()
  summary: Joins values together as a string, inserting a separator between each
  belongs_to: Set
  description: |-
    #### [join()](index#join())

    Joins values together as a string, inserting a separator between each. The default separator is `","`.

    ``` ts
    join(separator?: string): string
    ```

    #### Inherited from

    [`Collection#join()`](../collection/index#join())
- name: Set.keyOf()
  id: set/index#keyOf()
  summary: Returns the key associated with the search value, or undefined
  belongs_to: Set
  description: |-
    #### [keyOf()](index#keyOf())

    Returns the key associated with the search value, or undefined.

    ``` ts
    keyOf(searchValue: T): T | undefined
    ```

    #### Inherited from

    [`Collection#keyOf()`](../collection/index#keyOf())
- name: Set.keys()
  id: set/index#keys()
  summary: An iterator of this Collection's keys
  belongs_to: Set
  description: |-
    #### [keys()](index#keys())

    An iterator of this [`Collection`](../collection/index)'s keys.

    ``` ts
    keys(): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection#keys()`](../collection/index#keys())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.
- name: Set.keySeq()
  id: set/index#keySeq()
  summary: Returns a new Seq.Indexed of the keys of this Collection, discarding values
  belongs_to: Set
  description: |-
    #### [keySeq()](index#keySeq())

    Returns a new Seq.Indexed of the keys of this Collection, discarding values.

    ``` ts
    keySeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#keySeq()`](../collection/index#keySeq())
- name: Set.last()
  id: set/index#last()
  summary: In case the Collection is not empty returns the last element of the Collection
  belongs_to: Set
  description: |-
    #### [last()](index#last())

    In case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    last<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#last()`](../collection/index#last())

    ### Reading deep values
- name: Set.lastKeyOf()
  id: set/index#lastKeyOf()
  summary: Returns the last key associated with the search value, or undefined
  belongs_to: Set
  description: |-
    #### [lastKeyOf()](index#lastKeyOf())

    Returns the last key associated with the search value, or undefined.

    ``` ts
    lastKeyOf(searchValue: T): T | undefined
    ```

    #### Inherited from

    [`Collection#lastKeyOf()`](../collection/index#lastKeyOf())
- name: Set.map()
  id: set/index#map()
  summary: Returns a new Set with values passed through a mapper function
  belongs_to: Set
  description: |-
    #### [map()](index#map())

    Returns a new Set with values passed through a `mapper` function.

    ``` ts
    map<M>(mapper: (value: T, key: T, iter: this) => M, context?: unknown): Set<M>
    ```

    #### Overrides

    [`Collection.Set#map()`](../collection.set/index#map())

    #### Example

    ``` ts
    Set([1,2]).map(x => 10 * x)
    // Set [10,20]
    ```
- name: Set.max()
  id: set/index#max()
  summary: Returns the maximum value in this collection
  belongs_to: Set
  description: |-
    #### [max()](index#max())

    Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    max(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#max()`](../collection/index#max())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Set.maxBy()
  id: set/index#maxBy()
  summary: null
  belongs_to: Set
  description: |-
    #### [maxBy()](index#maxBy())

    Like [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    maxBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#maxBy()`](../collection/index#maxBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it
    ```
- name: Set.min()
  id: set/index#min()
  summary: Returns the minimum value in this collection
  belongs_to: Set
  description: |-
    #### [min()](index#min())

    Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    min(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#min()`](../collection/index#min())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Set.minBy()
  id: set/index#minBy()
  summary: null
  belongs_to: Set
  description: |-
    #### [minBy()](index#minBy())

    Like [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    minBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#minBy()`](../collection/index#minBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it
    ```

    ### Comparison
- name: Set.partition()
  id: set/index#partition()
  summary: null
  belongs_to: Set
  description: |-
    #### [partition()](index#partition())

    ``` ts
    partition<F, C>(predicate: (this: C, value: T, key: T, iter: this) => boolean,context?: C): [Set<T>, Set<F>]
    partition<C>(predicate: (this: C, value: T, key: T, iter: this) => unknown,context?: C): [this, this]
    ```

    #### Overrides

    [`Collection.Set#partition()`](../collection.set/index#partition())
- name: Set.reduce()
  id: set/index#reduce()
  summary: null
  belongs_to: Set
  description: |-
    #### [reduce()](index#reduce())

    ``` ts
    reduce<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R
    reduce<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduce()`](../collection/index#reduce())
- name: Set.reduceRight()
  id: set/index#reduceRight()
  summary: null
  belongs_to: Set
  description: |-
    #### [reduceRight()](index#reduceRight())

    ``` ts
    reduceRight<R>(reducer: (reduction: R, value: T, key: T, iter: this) => R,initialReduction: R,context?: unknown): R
    reduceRight<R>(reducer: (reduction: T | R, value: T, key: T, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduceRight()`](../collection/index#reduceRight())
- name: Set.rest()
  id: set/index#rest()
  summary: Returns a new Collection of the same type containing all entries except the first
  belongs_to: Set
  description: |-
    #### [rest()](index#rest())

    Returns a new Collection of the same type containing all entries except the first.

    ``` ts
    rest(): this
    ```

    #### Inherited from

    [`Collection#rest()`](../collection/index#rest())
- name: Set.reverse()
  id: set/index#reverse()
  summary: Returns a new Collection of the same type in reverse order
  belongs_to: Set
  description: |-
    #### [reverse()](index#reverse())

    Returns a new Collection of the same type in reverse order.

    ``` ts
    reverse(): this
    ```

    #### Inherited from

    [`Collection#reverse()`](../collection/index#reverse())
- name: Set.Set()
  id: set/index#Set()
  summary: Create a new immutable Set containing the values of the provided collection-like
  belongs_to: Set
  description: |-
    #### [Set()](index#Set())

    Create a new immutable Set containing the values of the provided collection-like.

    ``` ts
    Set<T>(collection?: Iterable<T> | ArrayLike<T>): Set<T>
    ```

    #### Discussion

    Note: [`Set`](index) is a factory function and not a class, and does not use the `new` keyword during construction.

    ### Static methods
- name: Set.Set.fromKeys()
  id: set/index#fromKeys()
  summary: null
  belongs_to: Set
  description: |-
    #### [Set.fromKeys()](index#fromKeys())

    ``` ts
    Set.fromKeys<T>(iter: Collection<T, unknown>): Set<T>
    Set.fromKeys(obj: {[key: string]: unknown}): Set<string>
    ```
- name: Set.Set.isSet()
  id: set/index#isSet()
  summary: null
  belongs_to: Set
  description: |-
    #### [Set.isSet()](index#isSet())

    ``` ts
    Set.isSet(maybeSet: unknown): boolean
    ```
- name: Set.Set.of()
  id: set/index#of()
  summary: null
  belongs_to: Set
  description: |-
    #### [Set.of()](index#of())

    ``` ts
    Set.of<T>(...values: Array<T>): Set<T>
    ```
- name: Set.size
  id: set/index#size
  summary: The number of items in this Set
  belongs_to: Set
  description: |-
    #### [size](index#size)

    The number of items in this Set.

    ``` ts
    size: number
    ```

    ### Persistent changes
- name: Set.skip()
  id: set/index#skip()
  summary: Returns a new Collection of the same type which excludes the first amount entries from this Collection
  belongs_to: Set
  description: |-
    #### [skip()](index#skip())

    Returns a new Collection of the same type which excludes the first `amount` entries from this Collection.

    ``` ts
    skip(amount: number): this
    ```

    #### Inherited from

    [`Collection#skip()`](../collection/index#skip())
- name: Set.skipLast()
  id: set/index#skipLast()
  summary: Returns a new Collection of the same type which excludes the last amount entries from this Collection
  belongs_to: Set
  description: |-
    #### [skipLast()](index#skipLast())

    Returns a new Collection of the same type which excludes the last `amount` entries from this Collection.

    ``` ts
    skipLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#skipLast()`](../collection/index#skipLast())
- name: Set.skipUntil()
  id: set/index#skipUntil()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns true
  belongs_to: Set
  description: |-
    #### [skipUntil()](index#skipUntil())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns true.

    ``` ts
    skipUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipUntil()`](../collection/index#skipUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipUntil(x => x.match(/hat/))
    // List [ "hat", "god" ]run it
    ```
- name: Set.skipWhile()
  id: set/index#skipWhile()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns false
  belongs_to: Set
  description: |-
    #### [skipWhile()](index#skipWhile())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns false.

    ``` ts
    skipWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipWhile()`](../collection/index#skipWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipWhile(x => x.match(/g/))
    // List [ "cat", "hat", "god" ]run it
    ```
- name: Set.slice()
  id: set/index#slice()
  summary: Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end
  belongs_to: Set
  description: |-
    #### [slice()](index#slice())

    Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.

    ``` ts
    slice(begin?: number, end?: number): this
    ```

    #### Inherited from

    [`Collection#slice()`](../collection/index#slice())

    #### Discussion

    If begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.

    If end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.

    If the requested slice is equivalent to the current Collection, then it will return itself.
- name: Set.some()
  id: set/index#some()
  summary: True if predicate returns true for any entry in the Collection
  belongs_to: Set
  description: |-
    #### [some()](index#some())

    True if `predicate` returns true for any entry in the Collection.

    ``` ts
    some(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#some()`](../collection/index#some())
- name: Set.sort()
  id: set/index#sort()
  summary: Returns a new Collection of the same type which includes the same entries, stably sorted by using a comparator
  belongs_to: Set
  description: |-
    #### [sort()](index#sort())

    Returns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.

    ``` ts
    sort(comparator?: (valueA: T, valueB: T) => number): this
    ```

    #### Inherited from

    [`Collection#sort()`](../collection/index#sort())

    #### Discussion

    If a `comparator` is not provided, a default comparator uses `<` and `>`.

    `comparator(valueA, valueB)`:

    - Returns `0` if the elements should not be swapped.
    - Returns `-1` (or any negative number) if `valueA` comes before `valueB`
    - Returns `1` (or any positive number) if `valueA` comes after `valueB`
    - Is pure, i.e. it must always return the same value for the same pair of values.

    When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.

    ``` ts
    const { Map } = require('immutable')
    Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
      if (a < b) { return -1; }
      if (a > b) { return 1; }
      if (a === b) { return 0; }
    });
    // OrderedMap { "a": 1, "b": 2, "c": 3 }run it
    ```

    Note: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Set.sortBy()
  id: set/index#sortBy()
  summary: 'Note: sortBy() Always returns a new instance, even if the original was already sorted'
  belongs_to: Set
  description: |-
    #### [sortBy()](index#sortBy())

    Like [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:

    ``` ts
    sortBy<C>(comparatorValueMapper: (value: T, key: T, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this
    ```

    #### Inherited from

    [`Collection#sortBy()`](../collection/index#sortBy())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const beattles = Map({
      John: { name: "Lennon" },
      Paul: { name: "McCartney" },
      George: { name: "Harrison" },
      Ringo: { name: "Starr" },
    });
    beattles.sortBy(member => member.name);run it
    ```

    Note: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Set.subtract()
  id: set/index#subtract()
  summary: Returns a Set excluding any values contained within collections
  belongs_to: Set
  description: |-
    #### [subtract()](index#subtract())

    Returns a Set excluding any values contained within `collections`.

    ``` ts
    subtract(...collections: Array<Iterable<T>>): this
    ```

    #### Discussion

    ``` ts
    const { OrderedSet } = require('immutable')
    OrderedSet([ 1, 2, 3 ]).subtract([1, 3])
    // OrderedSet [2]run it
    ```

    Note: [`subtract`](index#subtract()) can be used in [`withMutations`](index#withMutations()).
- name: Set.take()
  id: set/index#take()
  summary: Returns a new Collection of the same type which includes the first amount entries from this Collection
  belongs_to: Set
  description: |-
    #### [take()](index#take())

    Returns a new Collection of the same type which includes the first `amount` entries from this Collection.

    ``` ts
    take(amount: number): this
    ```

    #### Inherited from

    [`Collection#take()`](../collection/index#take())
- name: Set.takeLast()
  id: set/index#takeLast()
  summary: Returns a new Collection of the same type which includes the last amount entries from this Collection
  belongs_to: Set
  description: |-
    #### [takeLast()](index#takeLast())

    Returns a new Collection of the same type which includes the last `amount` entries from this Collection.

    ``` ts
    takeLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#takeLast()`](../collection/index#takeLast())
- name: Set.takeUntil()
  id: set/index#takeUntil()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns false
  belongs_to: Set
  description: |-
    #### [takeUntil()](index#takeUntil())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.

    ``` ts
    takeUntil(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeUntil()`](../collection/index#takeUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeUntil(x => x.match(/at/))
    // List [ "dog", "frog" ]run it
    ```

    ### Combination
- name: Set.takeWhile()
  id: set/index#takeWhile()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns true
  belongs_to: Set
  description: |-
    #### [takeWhile()](index#takeWhile())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.

    ``` ts
    takeWhile(predicate: (value: T, key: T, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeWhile()`](../collection/index#takeWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeWhile(x => x.match(/o/))
    // List [ "dog", "frog" ]run it
    ```
- name: Set.toArray()
  id: set/index#toArray()
  summary: Shallowly converts this collection to an Array
  belongs_to: Set
  description: |-
    #### [toArray()](index#toArray())

    Shallowly converts this collection to an Array.

    ``` ts
    toArray(): Array<T>
    ```

    #### Inherited from

    [`Collection.Set#toArray()`](../collection.set/index#toArray())
- name: Set.toIndexedSeq()
  id: set/index#toIndexedSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Set
  description: |-
    #### [toIndexedSeq()](index#toIndexedSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    toIndexedSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())
- name: Set.toJS()
  id: set/index#toJS()
  summary: Deeply converts this Set collection to equivalent native JavaScript Array
  belongs_to: Set
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Set collection to equivalent native JavaScript Array.

    ``` ts
    toJS(): Array<DeepCopy<T>>
    ```

    #### Inherited from

    [`Collection.Set#toJS()`](../collection.set/index#toJS())
- name: Set.toJSON()
  id: set/index#toJSON()
  summary: Shallowly converts this Set collection to equivalent native JavaScript Array
  belongs_to: Set
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Set collection to equivalent native JavaScript Array.

    ``` ts
    toJSON(): Array<T>
    ```

    #### Inherited from

    [`Collection.Set#toJSON()`](../collection.set/index#toJSON())
- name: Set.toKeyedSeq()
  id: set/index#toKeyedSeq()
  summary: Returns a Seq.Keyed from this Collection where indices are treated as keys
  belongs_to: Set
  description: |-
    #### [toKeyedSeq()](index#toKeyedSeq())

    Returns a Seq.Keyed from this Collection where indices are treated as keys.

    ``` ts
    toKeyedSeq(): Seq.Keyed<T, T>
    ```

    #### Inherited from

    [`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())

    #### Discussion

    This is useful if you want to operate on an Collection.Indexed and preserve the \[index, value\] pairs.

    The returned Seq will have identical iteration order as this Collection.

    ``` ts
    const { Seq } = require('immutable')
    const indexedSeq = Seq([ 'A', 'B', 'C' ])
    // Seq [ "A", "B", "C" ]
    indexedSeq.filter(v => v === 'B')
    // Seq [ "B" ]
    const keyedSeq = indexedSeq.toKeyedSeq()
    // Seq { 0: "A", 1: "B", 2: "C" }
    keyedSeq.filter(v => v === 'B')
    // Seq { 1: "B" }run it
    ```
- name: Set.toList()
  id: set/index#toList()
  summary: Converts this Collection to a List, discarding keys
  belongs_to: Set
  description: |-
    #### [toList()](index#toList())

    Converts this Collection to a List, discarding keys.

    ``` ts
    toList(): List<T>
    ```

    #### Inherited from

    [`Collection#toList()`](../collection/index#toList())

    #### Discussion

    This is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.

    ``` ts
    const { Map, List } = require('immutable')
    var myMap = Map({ a: 'Apple', b: 'Banana' })
    List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
    myMap.toList() // List [ "Apple", "Banana" ]run it
    ```
- name: Set.toMap()
  id: set/index#toMap()
  summary: Converts this Collection to a Map, Throws if keys are not hashable
  belongs_to: Set
  description: |-
    #### [toMap()](index#toMap())

    Converts this Collection to a Map, Throws if keys are not hashable.

    ``` ts
    toMap(): Map<T, T>
    ```

    #### Inherited from

    [`Collection#toMap()`](../collection/index#toMap())

    #### Discussion

    Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Set.toObject()
  id: set/index#toObject()
  summary: Shallowly converts this Collection to an Object
  belongs_to: Set
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Collection to an Object.

    ``` ts
    toObject(): {[key: string]: T}
    ```

    #### Inherited from

    [`Collection#toObject()`](../collection/index#toObject())

    #### Discussion

    Converts keys to Strings.

    ### Conversion to Seq
- name: Set.toOrderedMap()
  id: set/index#toOrderedMap()
  summary: Converts this Collection to a Map, maintaining the order of iteration
  belongs_to: Set
  description: |-
    #### [toOrderedMap()](index#toOrderedMap())

    Converts this Collection to a Map, maintaining the order of iteration.

    ``` ts
    toOrderedMap(): OrderedMap<T, T>
    ```

    #### Inherited from

    [`Collection#toOrderedMap()`](../collection/index#toOrderedMap())

    #### Discussion

    Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Set.toOrderedSet()
  id: set/index#toOrderedSet()
  summary: Converts this Collection to a Set, maintaining the order of iteration and discarding keys
  belongs_to: Set
  description: |-
    #### [toOrderedSet()](index#toOrderedSet())

    Converts this Collection to a Set, maintaining the order of iteration and discarding keys.

    ``` ts
    toOrderedSet(): OrderedSet<T>
    ```

    #### Inherited from

    [`Collection#toOrderedSet()`](../collection/index#toOrderedSet())

    #### Discussion

    Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.
- name: Set.toSeq()
  id: set/index#toSeq()
  summary: Returns Seq.Set
  belongs_to: Set
  description: |-
    #### [toSeq()](index#toSeq())

    Returns Seq.Set.

    ``` ts
    toSeq(): Seq.Set<T>
    ```

    #### Inherited from

    [`Collection.Set#toSeq()`](../collection.set/index#toSeq())
- name: Set.toSet()
  id: set/index#toSet()
  summary: Converts this Collection to a Set, discarding keys
  belongs_to: Set
  description: |-
    #### [toSet()](index#toSet())

    Converts this Collection to a Set, discarding keys. Throws if values are not hashable.

    ``` ts
    toSet(): Set<T>
    ```

    #### Inherited from

    [`Collection#toSet()`](../collection/index#toSet())

    #### Discussion

    Note: This is equivalent to [`Set(this)`](index), but provided to allow for chained expressions.
- name: Set.toSetSeq()
  id: set/index#toSetSeq()
  summary: Returns a Seq.Set of the values of this Collection, discarding keys
  belongs_to: Set
  description: |-
    #### [toSetSeq()](index#toSetSeq())

    Returns a Seq.Set of the values of this Collection, discarding keys.

    ``` ts
    toSetSeq(): Seq.Set<T>
    ```

    #### Inherited from

    [`Collection#toSetSeq()`](../collection/index#toSetSeq())

    ### Value equality
- name: Set.toStack()
  id: set/index#toStack()
  summary: Converts this Collection to a Stack, discarding keys
  belongs_to: Set
  description: |-
    #### [toStack()](index#toStack())

    Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.

    ``` ts
    toStack(): Stack<T>
    ```

    #### Inherited from

    [`Collection#toStack()`](../collection/index#toStack())

    #### Discussion

    Note: This is equivalent to [`Stack(this)`](../stack/index), but provided to allow for chained expressions.

    ### Iterators
- name: Set.update()
  id: set/index#update()
  summary: This can be very useful as a way to "chain" a normal function into a sequence of methods
  belongs_to: Set
  description: |-
    #### [update()](index#update())

    This can be very useful as a way to "chain" a normal function into a sequence of methods. RxJS calls this "let" and lodash calls it "thru".

    ``` ts
    update<R>(updater: (value: this) => R): R
    ```

    #### Inherited from

    [`Collection#update()`](../collection/index#update())

    #### Discussion

    For example, to sum a Seq after mapping and filtering:

    ``` ts
    const { Seq } = require('immutable')

    function sum(collection) {
      return collection.reduce((sum, x) => sum + x, 0)
    }
    Seq([ 1, 2, 3 ])
      .map(x => x + 1)
      .filter(x => x % 2 === 0)
      .update(sum)
    // 6run it
    ```

    ### Transient changes
- name: Set.values()
  id: set/index#values()
  summary: An iterator of this Collection's values
  belongs_to: Set
  description: |-
    #### [values()](index#values())

    An iterator of this [`Collection`](../collection/index)'s values.

    ``` ts
    values(): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection#values()`](../collection/index#values())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.
- name: Set.valueSeq()
  id: set/index#valueSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Set
  description: |-
    #### [valueSeq()](index#valueSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    valueSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#valueSeq()`](../collection/index#valueSeq())
- name: Set.wasAltered()
  id: set/index#wasAltered()
  summary: null
  belongs_to: Set
  description: |-
    #### [wasAltered()](index#wasAltered())

    ``` ts
    wasAltered(): boolean
    ```

    #### see

    [`Map#wasAltered`](../map/index#wasAltered())
- name: Set.withMutations()
  id: set/index#withMutations()
  summary: 'Note: Not all methods can be used on a mutable collection or within withMutations! Check the documentation for each method to see if it mentions being safe to use in withMutations'
  belongs_to: Set
  description: |-
    #### [withMutations()](index#withMutations())

    Note: Not all methods can be used on a mutable collection or within [`withMutations`](index#withMutations())! Check the documentation for each method to see if it mentions being safe to use in [`withMutations`](index#withMutations()).

    ``` ts
    withMutations(mutator: (mutable: this) => unknown): this
    ```

    #### see

    [`Map#withMutations`](../map/index#withMutations())
- name: setIn()
  id: setin()/index
  summary: Returns a copy of the collection with the value at the key path set to the provided value
  description: "# setIn()\n\nReturns a copy of the collection with the value at the key path set to the provided value.\n\n``` ts\nsetIn<C>(collection: C, keyPath: Iterable<unknown>, value: unknown): C\n```\n\n#### Discussion\n\nA functional alternative to `collection.setIn(keypath)` which will also work with plain Objects and Arrays.\n\n``` ts\nconst { setIn } = require('immutable')\nconst original = { x: { y: { z: 123 }}}\nsetIn(original, ['x', 'y', 'z'], 456) // { x: { y: { z: 456 }}}\nconsole.log(original) // { x: { y: { z: 123 }}}run it\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/setIn()/](https://immutable-js.com/docs/v4.2.1/setIn()/)"
- name: Stack
  id: stack/index
  summary: Stacks are indexed collections which support very efficient O(1) addition and removal from the front using unshift(v) and shift()
  description: "# Stack\n\nStacks are indexed collections which support very efficient O(1) addition and removal from the front using [`unshift(v)`](index#unshift()) and [`shift()`](index#shift()).\n\n``` ts\ntype Stack<T> extends Collection.Indexed<T>\n```\n\n#### Discussion\n\nFor familiarity, Stack also provides [`push(v)`](index#push()), [`pop()`](index#pop()), and [`peek()`](index#peek()), but be aware that they also operate on the front of the list, unlike List or a JavaScript Array.\n\nNote: [`reverse()`](index#reverse()) or any inherent reverse traversal ([`reduceRight`](index#reduceRight()), [`lastIndexOf`](index#lastIndexOf()), etc.) is not efficient with a Stack.\n\nStack is implemented with a Single-Linked List.\n\n### Construction\n\n#### [Stack()](index#Stack())\n\nCreate a new immutable Stack containing the values of the provided collection-like.\n\n``` ts\nStack<T>(collection?: Iterable<T> | ArrayLike<T>): Stack<T>\n```\n\n#### Discussion\n\nThe iteration order of the provided collection is preserved in the resulting [`Stack`](index).\n\nNote: [`Stack`](index) is a factory function and not a class, and does not use the `new` keyword during construction.\n\n### Static methods\n\n#### [Stack.isStack()](index#isStack())\n\n``` ts\nStack.isStack(maybeStack: unknown): boolean\n```\n\n#### [Stack.of()](index#of())\n\n``` ts\nStack.of<T>(...values: Array<T>): Stack<T>\n```\n\n### Members\n\n#### [size](index#size)\n\nThe number of items in this Stack.\n\n``` ts\nsize: number\n```\n\n### Reading values\n\n#### [peek()](index#peek())\n\nAlias for [`Stack.first()`](index#first()).\n\n``` ts\npeek(): T | undefined\n```\n\n#### [get()](index#get())\n\n``` ts\nget<NSV>(index: number, notSetValue: NSV): T | NSV\nget(index: number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection.Indexed#get()`](../collection.indexed/index#get())\n\n#### [has()](index#has())\n\nTrue if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nhas(key: number): boolean\n```\n\n#### Inherited from\n\n[`Collection#has()`](../collection/index#has())\n\n#### [includes()](index#includes())\n\nTrue if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality\n\n``` ts\nincludes(value: T): boolean\n```\n\n#### Inherited from\n\n[`Collection#includes()`](../collection/index#includes())\n\n#### alias\n\n`contains()`\n\n#### [first()](index#first())\n\nIn case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nfirst<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#first()`](../collection/index#first())\n\n#### [last()](index#last())\n\nIn case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.\n\n``` ts\nlast<NSV>(notSetValue?: NSV): T | NSV\n```\n\n#### Inherited from\n\n[`Collection#last()`](../collection/index#last())\n\n### Persistent changes\n\n#### [clear()](index#clear())\n\nReturns a new Stack with 0 size and no values.\n\n``` ts\nclear(): Stack<T>\n```\n\n#### Discussion\n\nNote: [`clear`](index#clear()) can be used in [`withMutations`](index#withMutations()).\n\n#### [unshift()](index#unshift())\n\nReturns a new Stack with the provided `values` prepended, shifting other values ahead to higher indices.\n\n``` ts\nunshift(...values: Array<T>): Stack<T>\n```\n\n#### Discussion\n\nThis is very efficient for Stack.\n\nNote: [`unshift`](index#unshift()) can be used in [`withMutations`](index#withMutations()).\n\n#### [unshiftAll()](index#unshiftAll())\n\nLike [`Stack#unshift`](index#unshift()), but accepts a collection rather than varargs.\n\n``` ts\nunshiftAll(iter: Iterable<T>): Stack<T>\n```\n\n#### Discussion\n\nNote: [`unshiftAll`](index#unshiftAll()) can be used in [`withMutations`](index#withMutations()).\n\n#### [shift()](index#shift())\n\nReturns a new Stack with a size ones less than this Stack, excluding the first item in this Stack, shifting all other values to a lower index.\n\n``` ts\nshift(): Stack<T>\n```\n\n#### Discussion\n\nNote: this differs from [`Array#shift`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift) because it returns a new Stack rather than the removed value. Use [`first()`](index#first()) or [`peek()`](index#peek()) to get the first value in this Stack.\n\nNote: [`shift`](index#shift()) can be used in [`withMutations`](index#withMutations()).\n\n#### [push()](index#push())\n\nAlias for [`Stack#unshift`](index#unshift()) and is not equivalent to [`List#push`](../list/index#push()).\n\n``` ts\npush(...values: Array<T>): Stack<T>\n```\n\n#### [pushAll()](index#pushAll())\n\nAlias for [`Stack#unshiftAll`](index#unshiftAll()).\n\n``` ts\npushAll(iter: Iterable<T>): Stack<T>\n```\n\n#### [pop()](index#pop())\n\nAlias for [`Stack#shift`](index#shift()) and is not equivalent to [`List#pop`](../list/index#pop()).\n\n``` ts\npop(): Stack<T>\n```\n\n#### [update()](index#update())\n\nThis can be very useful as a way to \"chain\" a normal function into a sequence of methods. RxJS calls this \"let\" and lodash calls it \"thru\".\n\n``` ts\nupdate<R>(updater: (value: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#update()`](../collection/index#update())\n\n#### Discussion\n\nFor example, to sum a Seq after mapping and filtering:\n\n``` ts\nconst { Seq } = require('immutable')\n\nfunction sum(collection) {\n  return collection.reduce((sum, x) => sum + x, 0)\n}\nSeq([ 1, 2, 3 ])\n  .map(x => x + 1)\n  .filter(x => x % 2 === 0)\n  .update(sum)\n// 6run it\n```\n\n### Transient changes\n\n#### [withMutations()](index#withMutations())\n\nNote: Not all methods can be used on a mutable collection or within [`withMutations`](index#withMutations())! Check the documentation for each method to see if it mentions being safe to use in [`withMutations`](index#withMutations()).\n\n``` ts\nwithMutations(mutator: (mutable: this) => unknown): this\n```\n\n#### see\n\n[`Map#withMutations`](../map/index#withMutations())\n\n#### [asMutable()](index#asMutable())\n\nNote: Not all methods can be used on a mutable collection or within [`withMutations`](index#withMutations())! Check the documentation for each method to see if it mentions being safe to use in [`withMutations`](index#withMutations()).\n\n``` ts\nasMutable(): this\n```\n\n#### see\n\n[`Map#asMutable`](../map/index#asMutable())\n\n#### [wasAltered()](index#wasAltered())\n\n``` ts\nwasAltered(): boolean\n```\n\n#### see\n\n[`Map#wasAltered`](../map/index#wasAltered())\n\n#### [asImmutable()](index#asImmutable())\n\n``` ts\nasImmutable(): this\n```\n\n#### see\n\n[`Map#asImmutable`](../map/index#asImmutable())\n\n### Sequence algorithms\n\n#### [concat()](index#concat())\n\nReturns a new Stack with other collections concatenated to this one.\n\n``` ts\nconcat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Stack<T | C>\n```\n\n#### Overrides\n\n[`Collection.Indexed#concat()`](../collection.indexed/index#concat())\n\n#### [map()](index#map())\n\nReturns a new Stack with values passed through a `mapper` function.\n\n``` ts\nmap<M>(mapper: (value: T, key: number, iter: this) => M,context?: unknown): Stack<M>\n```\n\n#### Overrides\n\n[`Collection.Indexed#map()`](../collection.indexed/index#map())\n\n#### Example\n\n``` ts\nStack([ 1, 2 ]).map(x => 10 * x)\n// Stack [ 10, 20 ]\n```\n\nNote: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.\n\n#### [flatMap()](index#flatMap())\n\nFlat-maps the Stack, returning a new Stack.\n\n``` ts\nflatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>,context?: unknown): Stack<M>\n```\n\n#### Overrides\n\n[`Collection.Indexed#flatMap()`](../collection.indexed/index#flatMap())\n\n#### Discussion\n\nSimilar to `stack.map(...).flatten(true)`.\n\n#### [filter()](index#filter())\n\n``` ts\nfilter<F>(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): Set<F>\nfilter(predicate: (value: T, index: number, iter: this) => unknown,context?: unknown): this\n```\n\n#### Overrides\n\n[`Collection.Indexed#filter()`](../collection.indexed/index#filter())\n\n#### [zip()](index#zip())\n\n``` ts\nzip<U>(other: Collection<unknown, U>): Stack<[T, U]>\nzip<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): Stack<[T, U, V]>\nzip(...collections: Array<Collection<unknown, unknown>>): Stack<unknown>\n```\n\n#### Overrides\n\n[`Collection.Indexed#zip()`](../collection.indexed/index#zip())\n\n#### [zipAll()](index#zipAll())\n\n``` ts\nzipAll<U>(other: Collection<unknown, U>): Stack<[T, U]>\nzipAll<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): Stack<[T, U, V]>\nzipAll(...collections: Array<Collection<unknown, unknown>>): Stack<unknown>\n```\n\n#### Overrides\n\n[`Collection.Indexed#zipAll()`](../collection.indexed/index#zipAll())\n\n#### [zipWith()](index#zipWith())\n\n``` ts\nzipWith<U, Z>(zipper: (value: T, otherValue: U) => Z,otherCollection: Collection<unknown, U>): Stack<Z>\nzipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z,otherCollection: Collection<unknown, U>,thirdCollection: Collection<unknown, V>): Stack<Z>\nzipWith<Z>(zipper: (...values: Array<unknown>) => Z,...collections: Array<Collection<unknown, unknown>>): Stack<Z>\n```\n\n#### Overrides\n\n[`Collection.Indexed#zipWith()`](../collection.indexed/index#zipWith())\n\n#### [partition()](index#partition())\n\n``` ts\npartition<F, C>(predicate: (this: C, value: T, index: number, iter: this) => boolean,context?: C): [Collection.Indexed<T>, Collection.Indexed<F>]\npartition<C>(predicate: (this: C, value: T, index: number, iter: this) => unknown,context?: C): [this, this]\n```\n\n#### Inherited from\n\n[`Collection.Indexed#partition()`](../collection.indexed/index#partition())\n\n#### [\\[Symbol.iterator\\]()](index#%5BSymbol.iterator%5D())\n\n``` ts\n[Symbol.iterator](): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection.Indexed#[Symbol.iterator]()`](../collection.indexed/index#%5BSymbol.iterator%5D())\n\n#### [filterNot()](index#filterNot())\n\nReturns a new Collection of the same type with only the entries for which the `predicate` function returns false.\n\n``` ts\nfilterNot(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#filterNot()`](../collection/index#filterNot())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }run it\n```\n\nNote: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.\n\n#### [reverse()](index#reverse())\n\nReturns a new Collection of the same type in reverse order.\n\n``` ts\nreverse(): this\n```\n\n#### Inherited from\n\n[`Collection#reverse()`](../collection/index#reverse())\n\n#### [sort()](index#sort())\n\nReturns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.\n\n``` ts\nsort(comparator?: (valueA: T, valueB: T) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sort()`](../collection/index#sort())\n\n#### Discussion\n\nIf a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n- Returns `0` if the elements should not be swapped.\n- Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n- Returns `1` (or any positive number) if `valueA` comes after `valueB`\n- Is pure, i.e. it must always return the same value for the same pair of values.\n\nWhen sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n``` ts\nconst { Map } = require('immutable')\nMap({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// OrderedMap { \"a\": 1, \"b\": 2, \"c\": 3 }run it\n```\n\nNote: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [sortBy()](index#sortBy())\n\nLike [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:\n\n``` ts\nsortBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this\n```\n\n#### Inherited from\n\n[`Collection#sortBy()`](../collection/index#sortBy())\n\n#### Discussion\n\n``` ts\nconst { Map } = require('immutable')\nconst beattles = Map({\n  John: { name: \"Lennon\" },\n  Paul: { name: \"McCartney\" },\n  George: { name: \"Harrison\" },\n  Ringo: { name: \"Starr\" },\n});\nbeattles.sortBy(member => member.name);run it\n```\n\nNote: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.\n\nNote: This is always an eager operation.\n\n#### [groupBy()](index#groupBy())\n\nReturns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.\n\n``` ts\ngroupBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<number, T>>\n```\n\n#### Inherited from\n\n[`Collection#groupBy()`](../collection/index#groupBy())\n\n#### Discussion\n\nNote: This is always an eager operation.\n\n``` ts\nconst { List, Map } = require('immutable')\nconst listOfMaps = List([\n  Map({ v: 0 }),\n  Map({ v: 1 }),\n  Map({ v: 1 }),\n  Map({ v: 0 }),\n  Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ Map{ \"v\": 0 }, Map { \"v\": 0 } ],\n//   1: List [ Map{ \"v\": 1 }, Map { \"v\": 1 } ],\n//   2: List [ Map{ \"v\": 2 } ],\n// }run it\n```\n\n### Conversion to JavaScript types\n\n#### [toJS()](index#toJS())\n\nDeeply converts this Indexed collection to equivalent native JavaScript Array.\n\n``` ts\ntoJS(): Array<DeepCopy<T>>\n```\n\n#### Inherited from\n\n[`Collection.Indexed#toJS()`](../collection.indexed/index#toJS())\n\n#### [toJSON()](index#toJSON())\n\nShallowly converts this Indexed collection to equivalent native JavaScript Array.\n\n``` ts\ntoJSON(): Array<T>\n```\n\n#### Inherited from\n\n[`Collection.Indexed#toJSON()`](../collection.indexed/index#toJSON())\n\n#### [toArray()](index#toArray())\n\nShallowly converts this collection to an Array.\n\n``` ts\ntoArray(): Array<T>\n```\n\n#### Inherited from\n\n[`Collection.Indexed#toArray()`](../collection.indexed/index#toArray())\n\n#### [toObject()](index#toObject())\n\nShallowly converts this Collection to an Object.\n\n``` ts\ntoObject(): {[key: string]: T}\n```\n\n#### Inherited from\n\n[`Collection#toObject()`](../collection/index#toObject())\n\n#### Discussion\n\nConverts keys to Strings.\n\n### Conversion to Seq\n\n#### [toSeq()](index#toSeq())\n\nReturns Seq.Indexed.\n\n``` ts\ntoSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection.Indexed#toSeq()`](../collection.indexed/index#toSeq())\n\n#### [fromEntrySeq()](index#fromEntrySeq())\n\nIf this is a collection of \\[key, value\\] entry tuples, it will return a Seq.Keyed of those entries.\n\n``` ts\nfromEntrySeq(): Seq.Keyed<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection.Indexed#fromEntrySeq()`](../collection.indexed/index#fromEntrySeq())\n\n#### [toKeyedSeq()](index#toKeyedSeq())\n\nReturns a Seq.Keyed from this Collection where indices are treated as keys.\n\n``` ts\ntoKeyedSeq(): Seq.Keyed<number, T>\n```\n\n#### Inherited from\n\n[`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())\n\n#### Discussion\n\nThis is useful if you want to operate on an Collection.Indexed and preserve the \\[index, value\\] pairs.\n\nThe returned Seq will have identical iteration order as this Collection.\n\n``` ts\nconst { Seq } = require('immutable')\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\n// Seq [ \"A\", \"B\", \"C\" ]\nindexedSeq.filter(v => v === 'B')\n// Seq [ \"B\" ]\nconst keyedSeq = indexedSeq.toKeyedSeq()\n// Seq { 0: \"A\", 1: \"B\", 2: \"C\" }\nkeyedSeq.filter(v => v === 'B')\n// Seq { 1: \"B\" }run it\n```\n\n#### [toIndexedSeq()](index#toIndexedSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\ntoIndexedSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())\n\n#### [toSetSeq()](index#toSetSeq())\n\nReturns a Seq.Set of the values of this Collection, discarding keys.\n\n``` ts\ntoSetSeq(): Seq.Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSetSeq()`](../collection/index#toSetSeq())\n\n### Combination\n\n#### [interpose()](index#interpose())\n\nReturns a Collection of the same type with `separator` between each item in this Collection.\n\n``` ts\ninterpose(separator: T): this\n```\n\n#### Inherited from\n\n[`Collection.Indexed#interpose()`](../collection.indexed/index#interpose())\n\n#### [interleave()](index#interleave())\n\nReturns a Collection of the same type with the provided `collections` interleaved into this collection.\n\n``` ts\ninterleave(...collections: Array<Collection<unknown, T>>): this\n```\n\n#### Inherited from\n\n[`Collection.Indexed#interleave()`](../collection.indexed/index#interleave())\n\n#### Discussion\n\nThe resulting Collection includes the first item from each, then the second from each, etc.\n\n``` ts\nconst { List } = require('immutable')\nList([ 1, 2, 3 ]).interleave(List([ 'A', 'B', 'C' ]))\n// List [ 1, \"A\", 2, \"B\", 3, \"C\" ]run it\n```\n\nThe shortest Collection stops interleave.\n\n``` ts\nList([ 1, 2, 3 ]).interleave(\n  List([ 'A', 'B' ]),\n  List([ 'X', 'Y', 'Z' ])\n)\n// List [ 1, \"A\", \"X\", 2, \"B\", \"Y\" ]run it\n```\n\nSince [`interleave()`](../list/index#interleave()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.\n\nNote: [`interleave`](../list/index#interleave()) *cannot* be used in [`withMutations`](../list/index#withMutations()).\n\n#### [splice()](index#splice())\n\nSplice returns a new indexed Collection by replacing a region of this Collection with new values. If values are not provided, it only skips the region to be removed.\n\n``` ts\nsplice(index: number, removeNum: number, ...values: Array<T>): this\n```\n\n#### Inherited from\n\n[`Collection.Indexed#splice()`](../collection.indexed/index#splice())\n\n#### Discussion\n\n`index` may be a negative number, which indexes back from the end of the Collection. `s.splice(-2)` splices after the second to last item.\n\n``` ts\nconst { List } = require('immutable')\nList([ 'a', 'b', 'c', 'd' ]).splice(1, 2, 'q', 'r', 's')\n// List [ \"a\", \"q\", \"r\", \"s\", \"d\" ]run it\n```\n\nSince [`splice()`](../list/index#splice()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.\n\nNote: [`splice`](../list/index#splice()) *cannot* be used in [`withMutations`](../list/index#withMutations()).\n\n#### [flatten()](index#flatten())\n\n``` ts\nflatten(depth?: number): Collection<unknown, unknown>\nflatten(shallow?: boolean): Collection<unknown, unknown>\n```\n\n#### Inherited from\n\n[`Collection#flatten()`](../collection/index#flatten())\n\n### Search for value\n\n#### [indexOf()](index#indexOf())\n\nReturns the first index at which a given value can be found in the Collection, or -1 if it is not present.\n\n``` ts\nindexOf(searchValue: T): number\n```\n\n#### Inherited from\n\n[`Collection.Indexed#indexOf()`](../collection.indexed/index#indexOf())\n\n#### [lastIndexOf()](index#lastIndexOf())\n\nReturns the last index at which a given value can be found in the Collection, or -1 if it is not present.\n\n``` ts\nlastIndexOf(searchValue: T): number\n```\n\n#### Inherited from\n\n[`Collection.Indexed#lastIndexOf()`](../collection.indexed/index#lastIndexOf())\n\n#### [findIndex()](index#findIndex())\n\nReturns the first index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.\n\n``` ts\nfindIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection.Indexed#findIndex()`](../collection.indexed/index#findIndex())\n\n#### [findLastIndex()](index#findLastIndex())\n\nReturns the last index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.\n\n``` ts\nfindLastIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection.Indexed#findLastIndex()`](../collection.indexed/index#findLastIndex())\n\n#### [find()](index#find())\n\nReturns the first value for which the `predicate` returns true.\n\n``` ts\nfind(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#find()`](../collection/index#find())\n\n#### [findLast()](index#findLast())\n\nReturns the last value for which the `predicate` returns true.\n\n``` ts\nfindLast(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLast()`](../collection/index#findLast())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findEntry()](index#findEntry())\n\nReturns the first \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findEntry()`](../collection/index#findEntry())\n\n#### [findLastEntry()](index#findLastEntry())\n\nReturns the last \\[key, value\\] entry for which the `predicate` returns true.\n\n``` ts\nfindLastEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastEntry()`](../collection/index#findLastEntry())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [findKey()](index#findKey())\n\nReturns the key for which the `predicate` returns true.\n\n``` ts\nfindKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#findKey()`](../collection/index#findKey())\n\n#### [findLastKey()](index#findLastKey())\n\nReturns the last key for which the `predicate` returns true.\n\n``` ts\nfindLastKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#findLastKey()`](../collection/index#findLastKey())\n\n#### Discussion\n\nNote: `predicate` will be called for each entry in reverse.\n\n#### [keyOf()](index#keyOf())\n\nReturns the key associated with the search value, or undefined.\n\n``` ts\nkeyOf(searchValue: T): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#keyOf()`](../collection/index#keyOf())\n\n#### [lastKeyOf()](index#lastKeyOf())\n\nReturns the last key associated with the search value, or undefined.\n\n``` ts\nlastKeyOf(searchValue: T): number | undefined\n```\n\n#### Inherited from\n\n[`Collection#lastKeyOf()`](../collection/index#lastKeyOf())\n\n#### [max()](index#max())\n\nReturns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmax(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#max()`](../collection/index#max())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [maxBy()](index#maxBy())\n\nLike [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nmaxBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#maxBy()`](../collection/index#maxBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it\n```\n\n#### [min()](index#min())\n\nReturns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.\n\n``` ts\nmin(comparator?: (valueA: T, valueB: T) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#min()`](../collection/index#min())\n\n#### Discussion\n\nThe `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.\n\nWhen two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.\n\nIf `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.\n\n#### [minBy()](index#minBy())\n\nLike [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:\n\n``` ts\nminBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined\n```\n\n#### Inherited from\n\n[`Collection#minBy()`](../collection/index#minBy())\n\n#### Discussion\n\n``` ts\nconst { List, } = require('immutable');\nconst l = List([\n  { name: 'Bob', avgHit: 1 },\n  { name: 'Max', avgHit: 3 },\n  { name: 'Lili', avgHit: 2 } ,\n]);\nl.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it\n```\n\n### Value equality\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#equals()`](../collection/index#equals())\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Inherited from\n\n[`Collection#hashCode()`](../collection/index#hashCode())\n\n#### Discussion\n\nThe [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nIf two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.\n\n### Reading deep values\n\n#### [getIn()](index#getIn())\n\nReturns the value found by following a path of keys or indices through nested Collections.\n\n``` ts\ngetIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown\n```\n\n#### Inherited from\n\n[`Collection#getIn()`](../collection/index#getIn())\n\n#### Discussion\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\nPlain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:\n\n``` ts\nconst { Map, List } = require('immutable')\nconst deepData = Map({ x: [ { y: 123 } ] });\ndeepData.getIn(['x', 0, 'y']) // 123run it\n```\n\n#### [hasIn()](index#hasIn())\n\nTrue if the result of following a path of keys or indices through nested Collections results in a set value.\n\n``` ts\nhasIn(searchKeyPath: Iterable<unknown>): boolean\n```\n\n#### Inherited from\n\n[`Collection#hasIn()`](../collection/index#hasIn())\n\n### Conversion to Collections\n\n#### [toMap()](index#toMap())\n\nConverts this Collection to a Map, Throws if keys are not hashable.\n\n``` ts\ntoMap(): Map<number, T>\n```\n\n#### Inherited from\n\n[`Collection#toMap()`](../collection/index#toMap())\n\n#### Discussion\n\nNote: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toOrderedMap()](index#toOrderedMap())\n\nConverts this Collection to a Map, maintaining the order of iteration.\n\n``` ts\ntoOrderedMap(): OrderedMap<number, T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedMap()`](../collection/index#toOrderedMap())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toSet()](index#toSet())\n\nConverts this Collection to a Set, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoSet(): Set<T>\n```\n\n#### Inherited from\n\n[`Collection#toSet()`](../collection/index#toSet())\n\n#### Discussion\n\nNote: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.\n\n#### [toOrderedSet()](index#toOrderedSet())\n\nConverts this Collection to a Set, maintaining the order of iteration and discarding keys.\n\n``` ts\ntoOrderedSet(): OrderedSet<T>\n```\n\n#### Inherited from\n\n[`Collection#toOrderedSet()`](../collection/index#toOrderedSet())\n\n#### Discussion\n\nNote: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.\n\n#### [toList()](index#toList())\n\nConverts this Collection to a List, discarding keys.\n\n``` ts\ntoList(): List<T>\n```\n\n#### Inherited from\n\n[`Collection#toList()`](../collection/index#toList())\n\n#### Discussion\n\nThis is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.\n\n``` ts\nconst { Map, List } = require('immutable')\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\nList(myMap) // List [ [ \"a\", \"Apple\" ], [ \"b\", \"Banana\" ] ]\nmyMap.toList() // List [ \"Apple\", \"Banana\" ]run it\n```\n\n#### [toStack()](index#toStack())\n\nConverts this Collection to a Stack, discarding keys. Throws if values are not hashable.\n\n``` ts\ntoStack(): Stack<T>\n```\n\n#### Inherited from\n\n[`Collection#toStack()`](../collection/index#toStack())\n\n#### Discussion\n\nNote: This is equivalent to [`Stack(this)`](index), but provided to allow for chained expressions.\n\n### Iterators\n\n#### [keys()](index#keys())\n\nAn iterator of this [`Collection`](../collection/index)'s keys.\n\n``` ts\nkeys(): IterableIterator<number>\n```\n\n#### Inherited from\n\n[`Collection#keys()`](../collection/index#keys())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.\n\n#### [values()](index#values())\n\nAn iterator of this [`Collection`](../collection/index)'s values.\n\n``` ts\nvalues(): IterableIterator<T>\n```\n\n#### Inherited from\n\n[`Collection#values()`](../collection/index#values())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.\n\n#### [entries()](index#entries())\n\nAn iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.\n\n``` ts\nentries(): IterableIterator<[number, T]>\n```\n\n#### Inherited from\n\n[`Collection#entries()`](../collection/index#entries())\n\n#### Discussion\n\nNote: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.\n\n### Collections (Seq)\n\n#### [keySeq()](index#keySeq())\n\nReturns a new Seq.Indexed of the keys of this Collection, discarding values.\n\n``` ts\nkeySeq(): Seq.Indexed<number>\n```\n\n#### Inherited from\n\n[`Collection#keySeq()`](../collection/index#keySeq())\n\n#### [valueSeq()](index#valueSeq())\n\nReturns an Seq.Indexed of the values of this Collection, discarding keys.\n\n``` ts\nvalueSeq(): Seq.Indexed<T>\n```\n\n#### Inherited from\n\n[`Collection#valueSeq()`](../collection/index#valueSeq())\n\n#### [entrySeq()](index#entrySeq())\n\nReturns a new Seq.Indexed of \\[key, value\\] tuples.\n\n``` ts\nentrySeq(): Seq.Indexed<[number, T]>\n```\n\n#### Inherited from\n\n[`Collection#entrySeq()`](../collection/index#entrySeq())\n\n### Side effects\n\n#### [forEach()](index#forEach())\n\nThe `sideEffect` is executed for every entry in the Collection.\n\n``` ts\nforEach(sideEffect: (value: T, key: number, iter: this) => unknown,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#forEach()`](../collection/index#forEach())\n\n#### Discussion\n\nUnlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).\n\n### Creating subsets\n\n#### [slice()](index#slice())\n\nReturns a new Collection of the same type representing a portion of this Collection from start up to but not including end.\n\n``` ts\nslice(begin?: number, end?: number): this\n```\n\n#### Inherited from\n\n[`Collection#slice()`](../collection/index#slice())\n\n#### Discussion\n\nIf begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.\n\nIf the requested slice is equivalent to the current Collection, then it will return itself.\n\n#### [rest()](index#rest())\n\nReturns a new Collection of the same type containing all entries except the first.\n\n``` ts\nrest(): this\n```\n\n#### Inherited from\n\n[`Collection#rest()`](../collection/index#rest())\n\n#### [butLast()](index#butLast())\n\nReturns a new Collection of the same type containing all entries except the last.\n\n``` ts\nbutLast(): this\n```\n\n#### Inherited from\n\n[`Collection#butLast()`](../collection/index#butLast())\n\n#### [skip()](index#skip())\n\nReturns a new Collection of the same type which excludes the first `amount` entries from this Collection.\n\n``` ts\nskip(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skip()`](../collection/index#skip())\n\n#### [skipLast()](index#skipLast())\n\nReturns a new Collection of the same type which excludes the last `amount` entries from this Collection.\n\n``` ts\nskipLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#skipLast()`](../collection/index#skipLast())\n\n#### [skipWhile()](index#skipWhile())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns false.\n\n``` ts\nskipWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipWhile()`](../collection/index#skipWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipWhile(x => x.match(/g/))\n// List [ \"cat\", \"hat\", \"god\" ]run it\n```\n\n#### [skipUntil()](index#skipUntil())\n\nReturns a new Collection of the same type which includes entries starting from when `predicate` first returns true.\n\n``` ts\nskipUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#skipUntil()`](../collection/index#skipUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .skipUntil(x => x.match(/hat/))\n// List [ \"hat\", \"god\" ]run it\n```\n\n#### [take()](index#take())\n\nReturns a new Collection of the same type which includes the first `amount` entries from this Collection.\n\n``` ts\ntake(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#take()`](../collection/index#take())\n\n#### [takeLast()](index#takeLast())\n\nReturns a new Collection of the same type which includes the last `amount` entries from this Collection.\n\n``` ts\ntakeLast(amount: number): this\n```\n\n#### Inherited from\n\n[`Collection#takeLast()`](../collection/index#takeLast())\n\n#### [takeWhile()](index#takeWhile())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.\n\n``` ts\ntakeWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeWhile()`](../collection/index#takeWhile())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeWhile(x => x.match(/o/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n#### [takeUntil()](index#takeUntil())\n\nReturns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.\n\n``` ts\ntakeUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this\n```\n\n#### Inherited from\n\n[`Collection#takeUntil()`](../collection/index#takeUntil())\n\n#### Discussion\n\n``` ts\nconst { List } = require('immutable')\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\n  .takeUntil(x => x.match(/at/))\n// List [ \"dog\", \"frog\" ]run it\n```\n\n### Reducing a value\n\n#### [reduce()](index#reduce())\n\n``` ts\nreduce<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R\nreduce<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduce()`](../collection/index#reduce())\n\n#### [reduceRight()](index#reduceRight())\n\n``` ts\nreduceRight<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R\nreduceRight<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R\n```\n\n#### Inherited from\n\n[`Collection#reduceRight()`](../collection/index#reduceRight())\n\n#### [every()](index#every())\n\nTrue if `predicate` returns true for all entries in the Collection.\n\n``` ts\nevery(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#every()`](../collection/index#every())\n\n#### [some()](index#some())\n\nTrue if `predicate` returns true for any entry in the Collection.\n\n``` ts\nsome(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean\n```\n\n#### Inherited from\n\n[`Collection#some()`](../collection/index#some())\n\n#### [join()](index#join())\n\nJoins values together as a string, inserting a separator between each. The default separator is `\",\"`.\n\n``` ts\njoin(separator?: string): string\n```\n\n#### Inherited from\n\n[`Collection#join()`](../collection/index#join())\n\n#### [isEmpty()](index#isEmpty())\n\nReturns true if this Collection includes no values.\n\n``` ts\nisEmpty(): boolean\n```\n\n#### Inherited from\n\n[`Collection#isEmpty()`](../collection/index#isEmpty())\n\n#### Discussion\n\nFor some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.\n\n#### [count()](index#count())\n\n``` ts\ncount(): number\ncount(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number\n```\n\n#### Inherited from\n\n[`Collection#count()`](../collection/index#count())\n\n#### [countBy()](index#countBy())\n\nReturns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.\n\n``` ts\ncountBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Map<G, number>\n```\n\n#### Inherited from\n\n[`Collection#countBy()`](../collection/index#countBy())\n\n#### Discussion\n\nNote: This is not a lazy operation.\n\n### Comparison\n\n#### [isSubset()](index#isSubset())\n\nTrue if `iter` includes every value in this Collection.\n\n``` ts\nisSubset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSubset()`](../collection/index#isSubset())\n\n#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Stack/](https://immutable-js.com/docs/v4.2.1/Stack/)"
- name: Stack.[Symbol.iterator]()
  id: stack/index#[Symbol.iterator]()
  summary: null
  belongs_to: Stack
  description: |-
    #### [\[Symbol.iterator\]()](index#%5BSymbol.iterator%5D())

    ``` ts
    [Symbol.iterator](): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection.Indexed#[Symbol.iterator]()`](../collection.indexed/index#%5BSymbol.iterator%5D())
- name: Stack.asImmutable()
  id: stack/index#asImmutable()
  summary: null
  belongs_to: Stack
  description: |-
    #### [asImmutable()](index#asImmutable())

    ``` ts
    asImmutable(): this
    ```

    #### see

    [`Map#asImmutable`](../map/index#asImmutable())

    ### Sequence algorithms
- name: Stack.asMutable()
  id: stack/index#asMutable()
  summary: 'Note: Not all methods can be used on a mutable collection or within withMutations! Check the documentation for each method to see if it mentions being safe to use in withMutations'
  belongs_to: Stack
  description: |-
    #### [asMutable()](index#asMutable())

    Note: Not all methods can be used on a mutable collection or within [`withMutations`](index#withMutations())! Check the documentation for each method to see if it mentions being safe to use in [`withMutations`](index#withMutations()).

    ``` ts
    asMutable(): this
    ```

    #### see

    [`Map#asMutable`](../map/index#asMutable())
- name: Stack.butLast()
  id: stack/index#butLast()
  summary: Returns a new Collection of the same type containing all entries except the last
  belongs_to: Stack
  description: |-
    #### [butLast()](index#butLast())

    Returns a new Collection of the same type containing all entries except the last.

    ``` ts
    butLast(): this
    ```

    #### Inherited from

    [`Collection#butLast()`](../collection/index#butLast())
- name: Stack.clear()
  id: stack/index#clear()
  summary: Returns a new Stack with 0 size and no values
  belongs_to: Stack
  description: |-
    #### [clear()](index#clear())

    Returns a new Stack with 0 size and no values.

    ``` ts
    clear(): Stack<T>
    ```

    #### Discussion

    Note: [`clear`](index#clear()) can be used in [`withMutations`](index#withMutations()).
- name: Stack.concat()
  id: stack/index#concat()
  summary: Returns a new Stack with other collections concatenated to this one
  belongs_to: Stack
  description: |-
    #### [concat()](index#concat())

    Returns a new Stack with other collections concatenated to this one.

    ``` ts
    concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Stack<T | C>
    ```

    #### Overrides

    [`Collection.Indexed#concat()`](../collection.indexed/index#concat())
- name: Stack.count()
  id: stack/index#count()
  summary: null
  belongs_to: Stack
  description: |-
    #### [count()](index#count())

    ``` ts
    count(): number
    count(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#count()`](../collection/index#count())
- name: Stack.countBy()
  id: stack/index#countBy()
  summary: Returns a Seq.Keyed of counts, grouped by the return value of the grouper function
  belongs_to: Stack
  description: |-
    #### [countBy()](index#countBy())

    Returns a [`Seq.Keyed`](../seq.keyed/index) of counts, grouped by the return value of the `grouper` function.

    ``` ts
    countBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Map<G, number>
    ```

    #### Inherited from

    [`Collection#countBy()`](../collection/index#countBy())

    #### Discussion

    Note: This is not a lazy operation.

    ### Comparison
- name: Stack.entries()
  id: stack/index#entries()
  summary: An iterator of this Collection's entries as [ key, value ] tuples
  belongs_to: Stack
  description: |-
    #### [entries()](index#entries())

    An iterator of this [`Collection`](../collection/index)'s entries as `[ key, value ]` tuples.

    ``` ts
    entries(): IterableIterator<[number, T]>
    ```

    #### Inherited from

    [`Collection#entries()`](../collection/index#entries())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`entrySeq`](../list/index#entrySeq()) instead, if this is what you want.

    ### Collections (Seq)
- name: Stack.entrySeq()
  id: stack/index#entrySeq()
  summary: Returns a new Seq.Indexed of [key, value] tuples
  belongs_to: Stack
  description: |-
    #### [entrySeq()](index#entrySeq())

    Returns a new Seq.Indexed of \[key, value\] tuples.

    ``` ts
    entrySeq(): Seq.Indexed<[number, T]>
    ```

    #### Inherited from

    [`Collection#entrySeq()`](../collection/index#entrySeq())

    ### Side effects
- name: Stack.equals()
  id: stack/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: Stack
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Inherited from

    [`Collection#equals()`](../collection/index#equals())

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: Stack.every()
  id: stack/index#every()
  summary: True if predicate returns true for all entries in the Collection
  belongs_to: Stack
  description: |-
    #### [every()](index#every())

    True if `predicate` returns true for all entries in the Collection.

    ``` ts
    every(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#every()`](../collection/index#every())
- name: Stack.filter()
  id: stack/index#filter()
  summary: null
  belongs_to: Stack
  description: |-
    #### [filter()](index#filter())

    ``` ts
    filter<F>(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): Set<F>
    filter(predicate: (value: T, index: number, iter: this) => unknown,context?: unknown): this
    ```

    #### Overrides

    [`Collection.Indexed#filter()`](../collection.indexed/index#filter())
- name: Stack.filterNot()
  id: stack/index#filterNot()
  summary: Returns a new Collection of the same type with only the entries for which the predicate function returns false
  belongs_to: Stack
  description: |-
    #### [filterNot()](index#filterNot())

    Returns a new Collection of the same type with only the entries for which the `predicate` function returns false.

    ``` ts
    filterNot(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#filterNot()`](../collection/index#filterNot())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
    // Map { "a": 1, "c": 3 }run it
    ```

    Note: [`filterNot()`](../list/index#filterNot()) always returns a new instance, even if it results in not filtering out any values.
- name: Stack.find()
  id: stack/index#find()
  summary: Returns the first value for which the predicate returns true
  belongs_to: Stack
  description: |-
    #### [find()](index#find())

    Returns the first value for which the `predicate` returns true.

    ``` ts
    find(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#find()`](../collection/index#find())
- name: Stack.findEntry()
  id: stack/index#findEntry()
  summary: Returns the first [key, value] entry for which the predicate returns true
  belongs_to: Stack
  description: |-
    #### [findEntry()](index#findEntry())

    Returns the first \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined
    ```

    #### Inherited from

    [`Collection#findEntry()`](../collection/index#findEntry())
- name: Stack.findIndex()
  id: stack/index#findIndex()
  summary: Returns the first index in the Collection where a value satisfies the provided predicate function
  belongs_to: Stack
  description: |-
    #### [findIndex()](index#findIndex())

    Returns the first index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.

    ``` ts
    findIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection.Indexed#findIndex()`](../collection.indexed/index#findIndex())
- name: Stack.findKey()
  id: stack/index#findKey()
  summary: Returns the key for which the predicate returns true
  belongs_to: Stack
  description: |-
    #### [findKey()](index#findKey())

    Returns the key for which the `predicate` returns true.

    ``` ts
    findKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined
    ```

    #### Inherited from

    [`Collection#findKey()`](../collection/index#findKey())
- name: Stack.findLast()
  id: stack/index#findLast()
  summary: Returns the last value for which the predicate returns true
  belongs_to: Stack
  description: |-
    #### [findLast()](index#findLast())

    Returns the last value for which the `predicate` returns true.

    ``` ts
    findLast(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): T | undefined
    ```

    #### Inherited from

    [`Collection#findLast()`](../collection/index#findLast())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Stack.findLastEntry()
  id: stack/index#findLastEntry()
  summary: Returns the last [key, value] entry for which the predicate returns true
  belongs_to: Stack
  description: |-
    #### [findLastEntry()](index#findLastEntry())

    Returns the last \[key, value\] entry for which the `predicate` returns true.

    ``` ts
    findLastEntry(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown,notSetValue?: T): [number, T] | undefined
    ```

    #### Inherited from

    [`Collection#findLastEntry()`](../collection/index#findLastEntry())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Stack.findLastIndex()
  id: stack/index#findLastIndex()
  summary: Returns the last index in the Collection where a value satisfies the provided predicate function
  belongs_to: Stack
  description: |-
    #### [findLastIndex()](index#findLastIndex())

    Returns the last index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.

    ``` ts
    findLastIndex(predicate: (value: T, index: number, iter: this) => boolean,context?: unknown): number
    ```

    #### Inherited from

    [`Collection.Indexed#findLastIndex()`](../collection.indexed/index#findLastIndex())
- name: Stack.findLastKey()
  id: stack/index#findLastKey()
  summary: Returns the last key for which the predicate returns true
  belongs_to: Stack
  description: |-
    #### [findLastKey()](index#findLastKey())

    Returns the last key for which the `predicate` returns true.

    ``` ts
    findLastKey(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): number | undefined
    ```

    #### Inherited from

    [`Collection#findLastKey()`](../collection/index#findLastKey())

    #### Discussion

    Note: `predicate` will be called for each entry in reverse.
- name: Stack.first()
  id: stack/index#first()
  summary: In case the Collection is not empty returns the first element of the Collection
  belongs_to: Stack
  description: |-
    #### [first()](index#first())

    In case the [`Collection`](../collection/index) is not empty returns the first element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    first<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#first()`](../collection/index#first())
- name: Stack.flatMap()
  id: stack/index#flatMap()
  summary: Flat-maps the Stack, returning a new Stack
  belongs_to: Stack
  description: |-
    #### [flatMap()](index#flatMap())

    Flat-maps the Stack, returning a new Stack.

    ``` ts
    flatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>,context?: unknown): Stack<M>
    ```

    #### Overrides

    [`Collection.Indexed#flatMap()`](../collection.indexed/index#flatMap())

    #### Discussion

    Similar to `stack.map(...).flatten(true)`.
- name: Stack.flatten()
  id: stack/index#flatten()
  summary: null
  belongs_to: Stack
  description: |-
    #### [flatten()](index#flatten())

    ``` ts
    flatten(depth?: number): Collection<unknown, unknown>
    flatten(shallow?: boolean): Collection<unknown, unknown>
    ```

    #### Inherited from

    [`Collection#flatten()`](../collection/index#flatten())

    ### Search for value
- name: Stack.forEach()
  id: stack/index#forEach()
  summary: The sideEffect is executed for every entry in the Collection
  belongs_to: Stack
  description: |-
    #### [forEach()](index#forEach())

    The `sideEffect` is executed for every entry in the Collection.

    ``` ts
    forEach(sideEffect: (value: T, key: number, iter: this) => unknown,context?: unknown): number
    ```

    #### Inherited from

    [`Collection#forEach()`](../collection/index#forEach())

    #### Discussion

    Unlike [`Array#forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach), if any call of `sideEffect` returns `false`, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).

    ### Creating subsets
- name: Stack.fromEntrySeq()
  id: stack/index#fromEntrySeq()
  summary: If this is a collection of [key, value] entry tuples, it will return a Seq.Keyed of those entries
  belongs_to: Stack
  description: |-
    #### [fromEntrySeq()](index#fromEntrySeq())

    If this is a collection of \[key, value\] entry tuples, it will return a Seq.Keyed of those entries.

    ``` ts
    fromEntrySeq(): Seq.Keyed<unknown, unknown>
    ```

    #### Inherited from

    [`Collection.Indexed#fromEntrySeq()`](../collection.indexed/index#fromEntrySeq())
- name: Stack.get()
  id: stack/index#get()
  summary: null
  belongs_to: Stack
  description: |-
    #### [get()](index#get())

    ``` ts
    get<NSV>(index: number, notSetValue: NSV): T | NSV
    get(index: number): T | undefined
    ```

    #### Inherited from

    [`Collection.Indexed#get()`](../collection.indexed/index#get())
- name: Stack.getIn()
  id: stack/index#getIn()
  summary: Returns the value found by following a path of keys or indices through nested Collections
  belongs_to: Stack
  description: |-
    #### [getIn()](index#getIn())

    Returns the value found by following a path of keys or indices through nested Collections.

    ``` ts
    getIn(searchKeyPath: Iterable<unknown>, notSetValue?: unknown): unknown
    ```

    #### Inherited from

    [`Collection#getIn()`](../collection/index#getIn())

    #### Discussion

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```

    Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:

    ``` ts
    const { Map, List } = require('immutable')
    const deepData = Map({ x: [ { y: 123 } ] });
    deepData.getIn(['x', 0, 'y']) // 123run it
    ```
- name: Stack.groupBy()
  id: stack/index#groupBy()
  summary: Returns a Collection.Keyed of Collection.Keyeds, grouped by the return value of the grouper function
  belongs_to: Stack
  description: |-
    #### [groupBy()](index#groupBy())

    Returns a [`Collection.Keyed`](../collection.keyed/index) of `Collection.Keyeds`, grouped by the return value of the `grouper` function.

    ``` ts
    groupBy<G>(grouper: (value: T, key: number, iter: this) => G,context?: unknown): Seq.Keyed<G, Collection<number, T>>
    ```

    #### Inherited from

    [`Collection#groupBy()`](../collection/index#groupBy())

    #### Discussion

    Note: This is always an eager operation.

    ``` ts
    const { List, Map } = require('immutable')
    const listOfMaps = List([
      Map({ v: 0 }),
      Map({ v: 1 }),
      Map({ v: 1 }),
      Map({ v: 0 }),
      Map({ v: 2 })
    ])
    const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
    // Map {
    //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
    //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
    //   2: List [ Map{ "v": 2 } ],
    // }run it
    ```

    ### Conversion to JavaScript types
- name: Stack.has()
  id: stack/index#has()
  summary: null
  belongs_to: Stack
  description: |-
    #### [has()](index#has())

    True if a key exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    has(key: number): boolean
    ```

    #### Inherited from

    [`Collection#has()`](../collection/index#has())
- name: Stack.hashCode()
  id: stack/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: Stack
  description: |-
    #### [hashCode()](index#hashCode())

    Computes and returns the hashed identity for this Collection.

    ``` ts
    hashCode(): number
    ```

    #### Inherited from

    [`Collection#hashCode()`](../collection/index#hashCode())

    #### Discussion

    The [`hashCode`](../list/index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.

    ``` ts
    const a = List([ 1, 2, 3 ]);
    const b = List([ 1, 2, 3 ]);
    assert.notStrictEqual(a, b); // different instances
    const set = Set([ a ]);
    assert.equal(set.has(b), true);run it
    ```

    If two values have the same [`hashCode`](../list/index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](../list/index#hashCode())s, they must not be equal.

    ### Reading deep values
- name: Stack.hasIn()
  id: stack/index#hasIn()
  summary: True if the result of following a path of keys or indices through nested Collections results in a set value
  belongs_to: Stack
  description: |-
    #### [hasIn()](index#hasIn())

    True if the result of following a path of keys or indices through nested Collections results in a set value.

    ``` ts
    hasIn(searchKeyPath: Iterable<unknown>): boolean
    ```

    #### Inherited from

    [`Collection#hasIn()`](../collection/index#hasIn())

    ### Conversion to Collections
- name: Stack.includes()
  id: stack/index#includes()
  summary: null
  belongs_to: Stack
  description: |-
    #### [includes()](index#includes())

    True if a value exists within this [`Collection`](../collection/index), using [`Immutable.is`](../is()/index) to determine equality

    ``` ts
    includes(value: T): boolean
    ```

    #### Inherited from

    [`Collection#includes()`](../collection/index#includes())

    #### alias

    `contains()`
- name: Stack.indexOf()
  id: stack/index#indexOf()
  summary: Returns the first index at which a given value can be found in the Collection, or -1 if it is not present
  belongs_to: Stack
  description: |-
    #### [indexOf()](index#indexOf())

    Returns the first index at which a given value can be found in the Collection, or -1 if it is not present.

    ``` ts
    indexOf(searchValue: T): number
    ```

    #### Inherited from

    [`Collection.Indexed#indexOf()`](../collection.indexed/index#indexOf())
- name: Stack.interleave()
  id: stack/index#interleave()
  summary: Returns a Collection of the same type with the provided collections interleaved into this collection
  belongs_to: Stack
  description: |-
    #### [interleave()](index#interleave())

    Returns a Collection of the same type with the provided `collections` interleaved into this collection.

    ``` ts
    interleave(...collections: Array<Collection<unknown, T>>): this
    ```

    #### Inherited from

    [`Collection.Indexed#interleave()`](../collection.indexed/index#interleave())

    #### Discussion

    The resulting Collection includes the first item from each, then the second from each, etc.

    ``` ts
    const { List } = require('immutable')
    List([ 1, 2, 3 ]).interleave(List([ 'A', 'B', 'C' ]))
    // List [ 1, "A", 2, "B", 3, "C" ]run it
    ```

    The shortest Collection stops interleave.

    ``` ts
    List([ 1, 2, 3 ]).interleave(
      List([ 'A', 'B' ]),
      List([ 'X', 'Y', 'Z' ])
    )
    // List [ 1, "A", "X", 2, "B", "Y" ]run it
    ```

    Since [`interleave()`](../list/index#interleave()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.

    Note: [`interleave`](../list/index#interleave()) *cannot* be used in [`withMutations`](../list/index#withMutations()).
- name: Stack.interpose()
  id: stack/index#interpose()
  summary: Returns a Collection of the same type with separator between each item in this Collection
  belongs_to: Stack
  description: |-
    #### [interpose()](index#interpose())

    Returns a Collection of the same type with `separator` between each item in this Collection.

    ``` ts
    interpose(separator: T): this
    ```

    #### Inherited from

    [`Collection.Indexed#interpose()`](../collection.indexed/index#interpose())
- name: Stack.isEmpty()
  id: stack/index#isEmpty()
  summary: Returns true if this Collection includes no values
  belongs_to: Stack
  description: |-
    #### [isEmpty()](index#isEmpty())

    Returns true if this Collection includes no values.

    ``` ts
    isEmpty(): boolean
    ```

    #### Inherited from

    [`Collection#isEmpty()`](../collection/index#isEmpty())

    #### Discussion

    For some lazy [`Seq`](../seq/index), [`isEmpty`](../list/index#isEmpty()) might need to iterate to determine emptiness. At most one iteration will occur.
- name: Stack.isSubset()
  id: stack/index#isSubset()
  summary: True if iter includes every value in this Collection
  belongs_to: Stack
  description: |-
    #### [isSubset()](index#isSubset())

    True if `iter` includes every value in this Collection.

    ``` ts
    isSubset(iter: Iterable<T>): boolean
    ```

    #### Inherited from

    [`Collection#isSubset()`](../collection/index#isSubset())
- name: Stack.isSuperset()
  id: stack/index#isSuperset()
  summary: True if this Collection includes every value in iter
  belongs_to: Stack
  description: "#### [isSuperset()](index#isSuperset())\n\nTrue if this Collection includes every value in `iter`.\n\n``` ts\nisSuperset(iter: Iterable<T>): boolean\n```\n\n#### Inherited from\n\n[`Collection#isSuperset()`](../collection/index#isSuperset())\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/Stack/](https://immutable-js.com/docs/v4.2.1/Stack/)"
- name: Stack.join()
  id: stack/index#join()
  summary: Joins values together as a string, inserting a separator between each
  belongs_to: Stack
  description: |-
    #### [join()](index#join())

    Joins values together as a string, inserting a separator between each. The default separator is `","`.

    ``` ts
    join(separator?: string): string
    ```

    #### Inherited from

    [`Collection#join()`](../collection/index#join())
- name: Stack.keyOf()
  id: stack/index#keyOf()
  summary: Returns the key associated with the search value, or undefined
  belongs_to: Stack
  description: |-
    #### [keyOf()](index#keyOf())

    Returns the key associated with the search value, or undefined.

    ``` ts
    keyOf(searchValue: T): number | undefined
    ```

    #### Inherited from

    [`Collection#keyOf()`](../collection/index#keyOf())
- name: Stack.keys()
  id: stack/index#keys()
  summary: An iterator of this Collection's keys
  belongs_to: Stack
  description: |-
    #### [keys()](index#keys())

    An iterator of this [`Collection`](../collection/index)'s keys.

    ``` ts
    keys(): IterableIterator<number>
    ```

    #### Inherited from

    [`Collection#keys()`](../collection/index#keys())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`keySeq`](../list/index#keySeq()) instead, if this is what you want.
- name: Stack.keySeq()
  id: stack/index#keySeq()
  summary: Returns a new Seq.Indexed of the keys of this Collection, discarding values
  belongs_to: Stack
  description: |-
    #### [keySeq()](index#keySeq())

    Returns a new Seq.Indexed of the keys of this Collection, discarding values.

    ``` ts
    keySeq(): Seq.Indexed<number>
    ```

    #### Inherited from

    [`Collection#keySeq()`](../collection/index#keySeq())
- name: Stack.last()
  id: stack/index#last()
  summary: In case the Collection is not empty returns the last element of the Collection
  belongs_to: Stack
  description: |-
    #### [last()](index#last())

    In case the [`Collection`](../collection/index) is not empty returns the last element of the [`Collection`](../collection/index). In case the [`Collection`](../collection/index) is empty returns the optional default value if provided, if no default value is provided returns undefined.

    ``` ts
    last<NSV>(notSetValue?: NSV): T | NSV
    ```

    #### Inherited from

    [`Collection#last()`](../collection/index#last())

    ### Persistent changes
- name: Stack.lastIndexOf()
  id: stack/index#lastIndexOf()
  summary: Returns the last index at which a given value can be found in the Collection, or -1 if it is not present
  belongs_to: Stack
  description: |-
    #### [lastIndexOf()](index#lastIndexOf())

    Returns the last index at which a given value can be found in the Collection, or -1 if it is not present.

    ``` ts
    lastIndexOf(searchValue: T): number
    ```

    #### Inherited from

    [`Collection.Indexed#lastIndexOf()`](../collection.indexed/index#lastIndexOf())
- name: Stack.lastKeyOf()
  id: stack/index#lastKeyOf()
  summary: Returns the last key associated with the search value, or undefined
  belongs_to: Stack
  description: |-
    #### [lastKeyOf()](index#lastKeyOf())

    Returns the last key associated with the search value, or undefined.

    ``` ts
    lastKeyOf(searchValue: T): number | undefined
    ```

    #### Inherited from

    [`Collection#lastKeyOf()`](../collection/index#lastKeyOf())
- name: Stack.map()
  id: stack/index#map()
  summary: Returns a new Stack with values passed through a mapper function
  belongs_to: Stack
  description: |-
    #### [map()](index#map())

    Returns a new Stack with values passed through a `mapper` function.

    ``` ts
    map<M>(mapper: (value: T, key: number, iter: this) => M,context?: unknown): Stack<M>
    ```

    #### Overrides

    [`Collection.Indexed#map()`](../collection.indexed/index#map())

    #### Example

    ``` ts
    Stack([ 1, 2 ]).map(x => 10 * x)
    // Stack [ 10, 20 ]
    ```

    Note: [`map()`](index#map()) always returns a new instance, even if it produced the same value at every step.
- name: Stack.max()
  id: stack/index#max()
  summary: Returns the maximum value in this collection
  belongs_to: Stack
  description: |-
    #### [max()](index#max())

    Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    max(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#max()`](../collection/index#max())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `>`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`max`](../list/index#max()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `>` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Stack.maxBy()
  id: stack/index#maxBy()
  summary: null
  belongs_to: Stack
  description: |-
    #### [maxBy()](index#maxBy())

    Like [`max`](../list/index#max()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    maxBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#maxBy()`](../collection/index#maxBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }run it
    ```
- name: Stack.min()
  id: stack/index#min()
  summary: Returns the minimum value in this collection
  belongs_to: Stack
  description: |-
    #### [min()](index#min())

    Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.

    ``` ts
    min(comparator?: (valueA: T, valueB: T) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#min()`](../collection/index#min())

    #### Discussion

    The `comparator` is used in the same way as [`Collection#sort`](../collection/index#sort()). If it is not provided, the default comparator is `<`.

    When two values are considered equivalent, the first encountered will be returned. Otherwise, [`min`](../list/index#min()) will operate independent of the order of input as long as the comparator is commutative. The default comparator `<` is commutative *only* when types do not differ.

    If `comparator` returns 0 and either value is NaN, undefined, or null, that value will be returned.
- name: Stack.minBy()
  id: stack/index#minBy()
  summary: null
  belongs_to: Stack
  description: |-
    #### [minBy()](index#minBy())

    Like [`min`](../list/index#min()), but also accepts a `comparatorValueMapper` which allows for comparing by more sophisticated means:

    ``` ts
    minBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): T | undefined
    ```

    #### Inherited from

    [`Collection#minBy()`](../collection/index#minBy())

    #### Discussion

    ``` ts
    const { List, } = require('immutable');
    const l = List([
      { name: 'Bob', avgHit: 1 },
      { name: 'Max', avgHit: 3 },
      { name: 'Lili', avgHit: 2 } ,
    ]);
    l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it
    ```

    ### Value equality
- name: Stack.partition()
  id: stack/index#partition()
  summary: null
  belongs_to: Stack
  description: |-
    #### [partition()](index#partition())

    ``` ts
    partition<F, C>(predicate: (this: C, value: T, index: number, iter: this) => boolean,context?: C): [Collection.Indexed<T>, Collection.Indexed<F>]
    partition<C>(predicate: (this: C, value: T, index: number, iter: this) => unknown,context?: C): [this, this]
    ```

    #### Inherited from

    [`Collection.Indexed#partition()`](../collection.indexed/index#partition())
- name: Stack.peek()
  id: stack/index#peek()
  summary: Alias for Stack.first()
  belongs_to: Stack
  description: |-
    #### [peek()](index#peek())

    Alias for [`Stack.first()`](index#first()).

    ``` ts
    peek(): T | undefined
    ```
- name: Stack.pop()
  id: stack/index#pop()
  summary: Alias for Stack#shift and is not equivalent to List#pop
  belongs_to: Stack
  description: |-
    #### [pop()](index#pop())

    Alias for [`Stack#shift`](index#shift()) and is not equivalent to [`List#pop`](../list/index#pop()).

    ``` ts
    pop(): Stack<T>
    ```
- name: Stack.push()
  id: stack/index#push()
  summary: Alias for Stack#unshift and is not equivalent to List#push
  belongs_to: Stack
  description: |-
    #### [push()](index#push())

    Alias for [`Stack#unshift`](index#unshift()) and is not equivalent to [`List#push`](../list/index#push()).

    ``` ts
    push(...values: Array<T>): Stack<T>
    ```
- name: Stack.pushAll()
  id: stack/index#pushAll()
  summary: Alias for Stack#unshiftAll
  belongs_to: Stack
  description: |-
    #### [pushAll()](index#pushAll())

    Alias for [`Stack#unshiftAll`](index#unshiftAll()).

    ``` ts
    pushAll(iter: Iterable<T>): Stack<T>
    ```
- name: Stack.reduce()
  id: stack/index#reduce()
  summary: null
  belongs_to: Stack
  description: |-
    #### [reduce()](index#reduce())

    ``` ts
    reduce<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R
    reduce<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduce()`](../collection/index#reduce())
- name: Stack.reduceRight()
  id: stack/index#reduceRight()
  summary: null
  belongs_to: Stack
  description: |-
    #### [reduceRight()](index#reduceRight())

    ``` ts
    reduceRight<R>(reducer: (reduction: R, value: T, key: number, iter: this) => R,initialReduction: R,context?: unknown): R
    reduceRight<R>(reducer: (reduction: T | R, value: T, key: number, iter: this) => R): R
    ```

    #### Inherited from

    [`Collection#reduceRight()`](../collection/index#reduceRight())
- name: Stack.rest()
  id: stack/index#rest()
  summary: Returns a new Collection of the same type containing all entries except the first
  belongs_to: Stack
  description: |-
    #### [rest()](index#rest())

    Returns a new Collection of the same type containing all entries except the first.

    ``` ts
    rest(): this
    ```

    #### Inherited from

    [`Collection#rest()`](../collection/index#rest())
- name: Stack.reverse()
  id: stack/index#reverse()
  summary: Returns a new Collection of the same type in reverse order
  belongs_to: Stack
  description: |-
    #### [reverse()](index#reverse())

    Returns a new Collection of the same type in reverse order.

    ``` ts
    reverse(): this
    ```

    #### Inherited from

    [`Collection#reverse()`](../collection/index#reverse())
- name: Stack.shift()
  id: stack/index#shift()
  summary: Returns a new Stack with a size ones less than this Stack, excluding the first item in this Stack, shifting all other values to a lower index
  belongs_to: Stack
  description: |-
    #### [shift()](index#shift())

    Returns a new Stack with a size ones less than this Stack, excluding the first item in this Stack, shifting all other values to a lower index.

    ``` ts
    shift(): Stack<T>
    ```

    #### Discussion

    Note: this differs from [`Array#shift`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift) because it returns a new Stack rather than the removed value. Use [`first()`](index#first()) or [`peek()`](index#peek()) to get the first value in this Stack.

    Note: [`shift`](index#shift()) can be used in [`withMutations`](index#withMutations()).
- name: Stack.size
  id: stack/index#size
  summary: The number of items in this Stack
  belongs_to: Stack
  description: |-
    #### [size](index#size)

    The number of items in this Stack.

    ``` ts
    size: number
    ```

    ### Reading values
- name: Stack.skip()
  id: stack/index#skip()
  summary: Returns a new Collection of the same type which excludes the first amount entries from this Collection
  belongs_to: Stack
  description: |-
    #### [skip()](index#skip())

    Returns a new Collection of the same type which excludes the first `amount` entries from this Collection.

    ``` ts
    skip(amount: number): this
    ```

    #### Inherited from

    [`Collection#skip()`](../collection/index#skip())
- name: Stack.skipLast()
  id: stack/index#skipLast()
  summary: Returns a new Collection of the same type which excludes the last amount entries from this Collection
  belongs_to: Stack
  description: |-
    #### [skipLast()](index#skipLast())

    Returns a new Collection of the same type which excludes the last `amount` entries from this Collection.

    ``` ts
    skipLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#skipLast()`](../collection/index#skipLast())
- name: Stack.skipUntil()
  id: stack/index#skipUntil()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns true
  belongs_to: Stack
  description: |-
    #### [skipUntil()](index#skipUntil())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns true.

    ``` ts
    skipUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipUntil()`](../collection/index#skipUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipUntil(x => x.match(/hat/))
    // List [ "hat", "god" ]run it
    ```
- name: Stack.skipWhile()
  id: stack/index#skipWhile()
  summary: Returns a new Collection of the same type which includes entries starting from when predicate first returns false
  belongs_to: Stack
  description: |-
    #### [skipWhile()](index#skipWhile())

    Returns a new Collection of the same type which includes entries starting from when `predicate` first returns false.

    ``` ts
    skipWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#skipWhile()`](../collection/index#skipWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .skipWhile(x => x.match(/g/))
    // List [ "cat", "hat", "god" ]run it
    ```
- name: Stack.slice()
  id: stack/index#slice()
  summary: Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end
  belongs_to: Stack
  description: |-
    #### [slice()](index#slice())

    Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.

    ``` ts
    slice(begin?: number, end?: number): this
    ```

    #### Inherited from

    [`Collection#slice()`](../collection/index#slice())

    #### Discussion

    If begin is negative, it is offset from the end of the Collection. e.g. `slice(-2)` returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.

    If end is negative, it is offset from the end of the Collection. e.g. `slice(0, -1)` returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.

    If the requested slice is equivalent to the current Collection, then it will return itself.
- name: Stack.some()
  id: stack/index#some()
  summary: True if predicate returns true for any entry in the Collection
  belongs_to: Stack
  description: |-
    #### [some()](index#some())

    True if `predicate` returns true for any entry in the Collection.

    ``` ts
    some(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): boolean
    ```

    #### Inherited from

    [`Collection#some()`](../collection/index#some())
- name: Stack.sort()
  id: stack/index#sort()
  summary: Returns a new Collection of the same type which includes the same entries, stably sorted by using a comparator
  belongs_to: Stack
  description: |-
    #### [sort()](index#sort())

    Returns a new Collection of the same type which includes the same entries, stably sorted by using a `comparator`.

    ``` ts
    sort(comparator?: (valueA: T, valueB: T) => number): this
    ```

    #### Inherited from

    [`Collection#sort()`](../collection/index#sort())

    #### Discussion

    If a `comparator` is not provided, a default comparator uses `<` and `>`.

    `comparator(valueA, valueB)`:

    - Returns `0` if the elements should not be swapped.
    - Returns `-1` (or any negative number) if `valueA` comes before `valueB`
    - Returns `1` (or any positive number) if `valueA` comes after `valueB`
    - Is pure, i.e. it must always return the same value for the same pair of values.

    When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. `map.sort()` returns OrderedMap.

    ``` ts
    const { Map } = require('immutable')
    Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
      if (a < b) { return -1; }
      if (a > b) { return 1; }
      if (a === b) { return 0; }
    });
    // OrderedMap { "a": 1, "b": 2, "c": 3 }run it
    ```

    Note: [`sort()`](../list/index#sort()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Stack.sortBy()
  id: stack/index#sortBy()
  summary: 'Note: sortBy() Always returns a new instance, even if the original was already sorted'
  belongs_to: Stack
  description: |-
    #### [sortBy()](index#sortBy())

    Like [`sort`](../list/index#sort()), but also accepts a `comparatorValueMapper` which allows for sorting by more sophisticated means:

    ``` ts
    sortBy<C>(comparatorValueMapper: (value: T, key: number, iter: this) => C,comparator?: (valueA: C, valueB: C) => number): this
    ```

    #### Inherited from

    [`Collection#sortBy()`](../collection/index#sortBy())

    #### Discussion

    ``` ts
    const { Map } = require('immutable')
    const beattles = Map({
      John: { name: "Lennon" },
      Paul: { name: "McCartney" },
      George: { name: "Harrison" },
      Ringo: { name: "Starr" },
    });
    beattles.sortBy(member => member.name);run it
    ```

    Note: [`sortBy()`](../list/index#sortBy()) Always returns a new instance, even if the original was already sorted.

    Note: This is always an eager operation.
- name: Stack.splice()
  id: stack/index#splice()
  summary: Splice returns a new indexed Collection by replacing a region of this Collection with new values
  belongs_to: Stack
  description: |-
    #### [splice()](index#splice())

    Splice returns a new indexed Collection by replacing a region of this Collection with new values. If values are not provided, it only skips the region to be removed.

    ``` ts
    splice(index: number, removeNum: number, ...values: Array<T>): this
    ```

    #### Inherited from

    [`Collection.Indexed#splice()`](../collection.indexed/index#splice())

    #### Discussion

    `index` may be a negative number, which indexes back from the end of the Collection. `s.splice(-2)` splices after the second to last item.

    ``` ts
    const { List } = require('immutable')
    List([ 'a', 'b', 'c', 'd' ]).splice(1, 2, 'q', 'r', 's')
    // List [ "a", "q", "r", "s", "d" ]run it
    ```

    Since [`splice()`](../list/index#splice()) re-indexes values, it produces a complete copy, which has `O(N)` complexity.

    Note: [`splice`](../list/index#splice()) *cannot* be used in [`withMutations`](../list/index#withMutations()).
- name: Stack.Stack()
  id: stack/index#Stack()
  summary: Create a new immutable Stack containing the values of the provided collection-like
  belongs_to: Stack
  description: |-
    #### [Stack()](index#Stack())

    Create a new immutable Stack containing the values of the provided collection-like.

    ``` ts
    Stack<T>(collection?: Iterable<T> | ArrayLike<T>): Stack<T>
    ```

    #### Discussion

    The iteration order of the provided collection is preserved in the resulting [`Stack`](index).

    Note: [`Stack`](index) is a factory function and not a class, and does not use the `new` keyword during construction.

    ### Static methods
- name: Stack.Stack.isStack()
  id: stack/index#isStack()
  summary: null
  belongs_to: Stack
  description: |-
    #### [Stack.isStack()](index#isStack())

    ``` ts
    Stack.isStack(maybeStack: unknown): boolean
    ```
- name: Stack.Stack.of()
  id: stack/index#of()
  summary: null
  belongs_to: Stack
  description: |-
    #### [Stack.of()](index#of())

    ``` ts
    Stack.of<T>(...values: Array<T>): Stack<T>
    ```

    ### Members
- name: Stack.take()
  id: stack/index#take()
  summary: Returns a new Collection of the same type which includes the first amount entries from this Collection
  belongs_to: Stack
  description: |-
    #### [take()](index#take())

    Returns a new Collection of the same type which includes the first `amount` entries from this Collection.

    ``` ts
    take(amount: number): this
    ```

    #### Inherited from

    [`Collection#take()`](../collection/index#take())
- name: Stack.takeLast()
  id: stack/index#takeLast()
  summary: Returns a new Collection of the same type which includes the last amount entries from this Collection
  belongs_to: Stack
  description: |-
    #### [takeLast()](index#takeLast())

    Returns a new Collection of the same type which includes the last `amount` entries from this Collection.

    ``` ts
    takeLast(amount: number): this
    ```

    #### Inherited from

    [`Collection#takeLast()`](../collection/index#takeLast())
- name: Stack.takeUntil()
  id: stack/index#takeUntil()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns false
  belongs_to: Stack
  description: |-
    #### [takeUntil()](index#takeUntil())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns false.

    ``` ts
    takeUntil(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeUntil()`](../collection/index#takeUntil())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeUntil(x => x.match(/at/))
    // List [ "dog", "frog" ]run it
    ```

    ### Reducing a value
- name: Stack.takeWhile()
  id: stack/index#takeWhile()
  summary: Returns a new Collection of the same type which includes entries from this Collection as long as the predicate returns true
  belongs_to: Stack
  description: |-
    #### [takeWhile()](index#takeWhile())

    Returns a new Collection of the same type which includes entries from this Collection as long as the `predicate` returns true.

    ``` ts
    takeWhile(predicate: (value: T, key: number, iter: this) => boolean,context?: unknown): this
    ```

    #### Inherited from

    [`Collection#takeWhile()`](../collection/index#takeWhile())

    #### Discussion

    ``` ts
    const { List } = require('immutable')
    List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
      .takeWhile(x => x.match(/o/))
    // List [ "dog", "frog" ]run it
    ```
- name: Stack.toArray()
  id: stack/index#toArray()
  summary: Shallowly converts this collection to an Array
  belongs_to: Stack
  description: |-
    #### [toArray()](index#toArray())

    Shallowly converts this collection to an Array.

    ``` ts
    toArray(): Array<T>
    ```

    #### Inherited from

    [`Collection.Indexed#toArray()`](../collection.indexed/index#toArray())
- name: Stack.toIndexedSeq()
  id: stack/index#toIndexedSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Stack
  description: |-
    #### [toIndexedSeq()](index#toIndexedSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    toIndexedSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#toIndexedSeq()`](../collection/index#toIndexedSeq())
- name: Stack.toJS()
  id: stack/index#toJS()
  summary: Deeply converts this Indexed collection to equivalent native JavaScript Array
  belongs_to: Stack
  description: |-
    #### [toJS()](index#toJS())

    Deeply converts this Indexed collection to equivalent native JavaScript Array.

    ``` ts
    toJS(): Array<DeepCopy<T>>
    ```

    #### Inherited from

    [`Collection.Indexed#toJS()`](../collection.indexed/index#toJS())
- name: Stack.toJSON()
  id: stack/index#toJSON()
  summary: Shallowly converts this Indexed collection to equivalent native JavaScript Array
  belongs_to: Stack
  description: |-
    #### [toJSON()](index#toJSON())

    Shallowly converts this Indexed collection to equivalent native JavaScript Array.

    ``` ts
    toJSON(): Array<T>
    ```

    #### Inherited from

    [`Collection.Indexed#toJSON()`](../collection.indexed/index#toJSON())
- name: Stack.toKeyedSeq()
  id: stack/index#toKeyedSeq()
  summary: Returns a Seq.Keyed from this Collection where indices are treated as keys
  belongs_to: Stack
  description: |-
    #### [toKeyedSeq()](index#toKeyedSeq())

    Returns a Seq.Keyed from this Collection where indices are treated as keys.

    ``` ts
    toKeyedSeq(): Seq.Keyed<number, T>
    ```

    #### Inherited from

    [`Collection#toKeyedSeq()`](../collection/index#toKeyedSeq())

    #### Discussion

    This is useful if you want to operate on an Collection.Indexed and preserve the \[index, value\] pairs.

    The returned Seq will have identical iteration order as this Collection.

    ``` ts
    const { Seq } = require('immutable')
    const indexedSeq = Seq([ 'A', 'B', 'C' ])
    // Seq [ "A", "B", "C" ]
    indexedSeq.filter(v => v === 'B')
    // Seq [ "B" ]
    const keyedSeq = indexedSeq.toKeyedSeq()
    // Seq { 0: "A", 1: "B", 2: "C" }
    keyedSeq.filter(v => v === 'B')
    // Seq { 1: "B" }run it
    ```
- name: Stack.toList()
  id: stack/index#toList()
  summary: Converts this Collection to a List, discarding keys
  belongs_to: Stack
  description: |-
    #### [toList()](index#toList())

    Converts this Collection to a List, discarding keys.

    ``` ts
    toList(): List<T>
    ```

    #### Inherited from

    [`Collection#toList()`](../collection/index#toList())

    #### Discussion

    This is similar to [`List(collection)`](../list/index), but provided to allow for chained expressions. However, when called on [`Map`](../map/index) or other keyed collections, `collection.toList()` discards the keys and creates a list of only the values, whereas [`List(collection)`](../list/index) creates a list of entry tuples.

    ``` ts
    const { Map, List } = require('immutable')
    var myMap = Map({ a: 'Apple', b: 'Banana' })
    List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
    myMap.toList() // List [ "Apple", "Banana" ]run it
    ```
- name: Stack.toMap()
  id: stack/index#toMap()
  summary: Converts this Collection to a Map, Throws if keys are not hashable
  belongs_to: Stack
  description: |-
    #### [toMap()](index#toMap())

    Converts this Collection to a Map, Throws if keys are not hashable.

    ``` ts
    toMap(): Map<number, T>
    ```

    #### Inherited from

    [`Collection#toMap()`](../collection/index#toMap())

    #### Discussion

    Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Stack.toObject()
  id: stack/index#toObject()
  summary: Shallowly converts this Collection to an Object
  belongs_to: Stack
  description: |-
    #### [toObject()](index#toObject())

    Shallowly converts this Collection to an Object.

    ``` ts
    toObject(): {[key: string]: T}
    ```

    #### Inherited from

    [`Collection#toObject()`](../collection/index#toObject())

    #### Discussion

    Converts keys to Strings.

    ### Conversion to Seq
- name: Stack.toOrderedMap()
  id: stack/index#toOrderedMap()
  summary: Converts this Collection to a Map, maintaining the order of iteration
  belongs_to: Stack
  description: |-
    #### [toOrderedMap()](index#toOrderedMap())

    Converts this Collection to a Map, maintaining the order of iteration.

    ``` ts
    toOrderedMap(): OrderedMap<number, T>
    ```

    #### Inherited from

    [`Collection#toOrderedMap()`](../collection/index#toOrderedMap())

    #### Discussion

    Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but provided for convenience and to allow for chained expressions.
- name: Stack.toOrderedSet()
  id: stack/index#toOrderedSet()
  summary: Converts this Collection to a Set, maintaining the order of iteration and discarding keys
  belongs_to: Stack
  description: |-
    #### [toOrderedSet()](index#toOrderedSet())

    Converts this Collection to a Set, maintaining the order of iteration and discarding keys.

    ``` ts
    toOrderedSet(): OrderedSet<T>
    ```

    #### Inherited from

    [`Collection#toOrderedSet()`](../collection/index#toOrderedSet())

    #### Discussion

    Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided for convenience and to allow for chained expressions.
- name: Stack.toSeq()
  id: stack/index#toSeq()
  summary: Returns Seq.Indexed
  belongs_to: Stack
  description: |-
    #### [toSeq()](index#toSeq())

    Returns Seq.Indexed.

    ``` ts
    toSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection.Indexed#toSeq()`](../collection.indexed/index#toSeq())
- name: Stack.toSet()
  id: stack/index#toSet()
  summary: Converts this Collection to a Set, discarding keys
  belongs_to: Stack
  description: |-
    #### [toSet()](index#toSet())

    Converts this Collection to a Set, discarding keys. Throws if values are not hashable.

    ``` ts
    toSet(): Set<T>
    ```

    #### Inherited from

    [`Collection#toSet()`](../collection/index#toSet())

    #### Discussion

    Note: This is equivalent to [`Set(this)`](../set/index), but provided to allow for chained expressions.
- name: Stack.toSetSeq()
  id: stack/index#toSetSeq()
  summary: Returns a Seq.Set of the values of this Collection, discarding keys
  belongs_to: Stack
  description: |-
    #### [toSetSeq()](index#toSetSeq())

    Returns a Seq.Set of the values of this Collection, discarding keys.

    ``` ts
    toSetSeq(): Seq.Set<T>
    ```

    #### Inherited from

    [`Collection#toSetSeq()`](../collection/index#toSetSeq())

    ### Combination
- name: Stack.toStack()
  id: stack/index#toStack()
  summary: Converts this Collection to a Stack, discarding keys
  belongs_to: Stack
  description: |-
    #### [toStack()](index#toStack())

    Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.

    ``` ts
    toStack(): Stack<T>
    ```

    #### Inherited from

    [`Collection#toStack()`](../collection/index#toStack())

    #### Discussion

    Note: This is equivalent to [`Stack(this)`](index), but provided to allow for chained expressions.

    ### Iterators
- name: Stack.unshift()
  id: stack/index#unshift()
  summary: Returns a new Stack with the provided values prepended, shifting other values ahead to higher indices
  belongs_to: Stack
  description: |-
    #### [unshift()](index#unshift())

    Returns a new Stack with the provided `values` prepended, shifting other values ahead to higher indices.

    ``` ts
    unshift(...values: Array<T>): Stack<T>
    ```

    #### Discussion

    This is very efficient for Stack.

    Note: [`unshift`](index#unshift()) can be used in [`withMutations`](index#withMutations()).
- name: Stack.unshiftAll()
  id: stack/index#unshiftAll()
  summary: Like Stack#unshift, but accepts a collection rather than varargs
  belongs_to: Stack
  description: |-
    #### [unshiftAll()](index#unshiftAll())

    Like [`Stack#unshift`](index#unshift()), but accepts a collection rather than varargs.

    ``` ts
    unshiftAll(iter: Iterable<T>): Stack<T>
    ```

    #### Discussion

    Note: [`unshiftAll`](index#unshiftAll()) can be used in [`withMutations`](index#withMutations()).
- name: Stack.update()
  id: stack/index#update()
  summary: This can be very useful as a way to "chain" a normal function into a sequence of methods
  belongs_to: Stack
  description: |-
    #### [update()](index#update())

    This can be very useful as a way to "chain" a normal function into a sequence of methods. RxJS calls this "let" and lodash calls it "thru".

    ``` ts
    update<R>(updater: (value: this) => R): R
    ```

    #### Inherited from

    [`Collection#update()`](../collection/index#update())

    #### Discussion

    For example, to sum a Seq after mapping and filtering:

    ``` ts
    const { Seq } = require('immutable')

    function sum(collection) {
      return collection.reduce((sum, x) => sum + x, 0)
    }
    Seq([ 1, 2, 3 ])
      .map(x => x + 1)
      .filter(x => x % 2 === 0)
      .update(sum)
    // 6run it
    ```

    ### Transient changes
- name: Stack.values()
  id: stack/index#values()
  summary: An iterator of this Collection's values
  belongs_to: Stack
  description: |-
    #### [values()](index#values())

    An iterator of this [`Collection`](../collection/index)'s values.

    ``` ts
    values(): IterableIterator<T>
    ```

    #### Inherited from

    [`Collection#values()`](../collection/index#values())

    #### Discussion

    Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use [`valueSeq`](../list/index#valueSeq()) instead, if this is what you want.
- name: Stack.valueSeq()
  id: stack/index#valueSeq()
  summary: Returns an Seq.Indexed of the values of this Collection, discarding keys
  belongs_to: Stack
  description: |-
    #### [valueSeq()](index#valueSeq())

    Returns an Seq.Indexed of the values of this Collection, discarding keys.

    ``` ts
    valueSeq(): Seq.Indexed<T>
    ```

    #### Inherited from

    [`Collection#valueSeq()`](../collection/index#valueSeq())
- name: Stack.wasAltered()
  id: stack/index#wasAltered()
  summary: null
  belongs_to: Stack
  description: |-
    #### [wasAltered()](index#wasAltered())

    ``` ts
    wasAltered(): boolean
    ```

    #### see

    [`Map#wasAltered`](../map/index#wasAltered())
- name: Stack.withMutations()
  id: stack/index#withMutations()
  summary: 'Note: Not all methods can be used on a mutable collection or within withMutations! Check the documentation for each method to see if it mentions being safe to use in withMutations'
  belongs_to: Stack
  description: |-
    #### [withMutations()](index#withMutations())

    Note: Not all methods can be used on a mutable collection or within [`withMutations`](index#withMutations())! Check the documentation for each method to see if it mentions being safe to use in [`withMutations`](index#withMutations()).

    ``` ts
    withMutations(mutator: (mutable: this) => unknown): this
    ```

    #### see

    [`Map#withMutations`](../map/index#withMutations())
- name: Stack.zip()
  id: stack/index#zip()
  summary: null
  belongs_to: Stack
  description: |-
    #### [zip()](index#zip())

    ``` ts
    zip<U>(other: Collection<unknown, U>): Stack<[T, U]>
    zip<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): Stack<[T, U, V]>
    zip(...collections: Array<Collection<unknown, unknown>>): Stack<unknown>
    ```

    #### Overrides

    [`Collection.Indexed#zip()`](../collection.indexed/index#zip())
- name: Stack.zipAll()
  id: stack/index#zipAll()
  summary: null
  belongs_to: Stack
  description: |-
    #### [zipAll()](index#zipAll())

    ``` ts
    zipAll<U>(other: Collection<unknown, U>): Stack<[T, U]>
    zipAll<U, V>(other: Collection<unknown, U>,other2: Collection<unknown, V>): Stack<[T, U, V]>
    zipAll(...collections: Array<Collection<unknown, unknown>>): Stack<unknown>
    ```

    #### Overrides

    [`Collection.Indexed#zipAll()`](../collection.indexed/index#zipAll())
- name: Stack.zipWith()
  id: stack/index#zipWith()
  summary: null
  belongs_to: Stack
  description: |-
    #### [zipWith()](index#zipWith())

    ``` ts
    zipWith<U, Z>(zipper: (value: T, otherValue: U) => Z,otherCollection: Collection<unknown, U>): Stack<Z>
    zipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z,otherCollection: Collection<unknown, U>,thirdCollection: Collection<unknown, V>): Stack<Z>
    zipWith<Z>(zipper: (...values: Array<unknown>) => Z,...collections: Array<Collection<unknown, unknown>>): Stack<Z>
    ```

    #### Overrides

    [`Collection.Indexed#zipWith()`](../collection.indexed/index#zipWith())
- name: update()
  id: update()/index
  summary: This documentation is generated from immutable.d.ts
  description: "# update()\n\n``` ts\nupdate<K, V, C>(collection: C, key: K, updater: (value: V | undefined) => V): C\nupdate<K, V, C, NSV>(collection: C,key: K,notSetValue: NSV,updater: (value: V | NSV) => V): C\nupdate<TProps, C, K>(record: C,key: K,updater: (value: TProps,[K]) => TProps,[K]): C\nupdate<TProps, C, K, NSV>(record: C,key: K,notSetValue: NSV,updater: (value: TProps,[K] | NSV) => TProps,[K]): C\nupdate<V>(collection: Array<V>, key: number, updater: (value: V) => V): Array<V>\nupdate<V, NSV>(collection: Array<V>,key: number,notSetValue: NSV,updater: (value: V | NSV) => V): Array<V>\nupdate<C, K>(object: C, key: K, updater: (value: C,[K]) => C,[K]): C\nupdate<C, K, NSV>(object: C,key: K,notSetValue: NSV,updater: (value: C,[K] | NSV) => C,[K]): C\nupdate<V, C, K>(collection: C,key: K,updater: (value: V) => V): {[key: string]: V}\nupdate<V, C, K, NSV>(collection: C,key: K,notSetValue: NSV,updater: (value: V | NSV) => V): {[key: string]: V}\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/update()/](https://immutable-js.com/docs/v4.2.1/update()/)"
- name: updateIn()
  id: updatein()/index
  summary: This documentation is generated from immutable.d.ts
  description: "# updateIn()\n\n``` ts\nupdateIn<C>(collection: C,keyPath: Iterable<unknown>,updater: (value: unknown) => unknown): C\nupdateIn<C>(collection: C,keyPath: Iterable<unknown>,notSetValue: unknown,updater: (value: unknown) => unknown): C\n```\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/updateIn()/](https://immutable-js.com/docs/v4.2.1/updateIn()/)"
- name: ValueObject
  id: valueobject/index
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  description: "# ValueObject\n\n``` ts\ntype ValueObject\n```\n\n### Members\n\n#### [equals()](index#equals())\n\nTrue if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).\n\n``` ts\nequals(other: unknown): boolean\n```\n\n#### Discussion\n\nNote: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.\n\n#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Discussion\n\nThe [`hashCode`](index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst { List, Set } = require('immutable');\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nNote: hashCode() MUST return a Uint32 number. The easiest way to guarantee this is to return `myHash | 0` from a custom implementation.\n\nIf two values have the same [`hashCode`](index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](index#hashCode())s, they must not be equal.\n\nNote: [`hashCode()`](index#hashCode()) is not guaranteed to always be called before [`equals()`](index#equals()). Most but not all Immutable.js collections use hash codes to organize their internal data structures, while all Immutable.js collections use equality during lookups.\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/ValueObject/](https://immutable-js.com/docs/v4.2.1/ValueObject/)"
- name: ValueObject.equals()
  id: valueobject/index#equals()
  summary: True if this and the other Collection have value equality, as defined by Immutable.is()
  belongs_to: ValueObject
  description: |-
    #### [equals()](index#equals())

    True if this and the other Collection have value equality, as defined by [`Immutable.is()`](../is()/index).

    ``` ts
    equals(other: unknown): boolean
    ```

    #### Discussion

    Note: This is equivalent to `Immutable.is(this, other)`, but provided to allow for chained expressions.
- name: ValueObject.hashCode()
  id: valueobject/index#hashCode()
  summary: Computes and returns the hashed identity for this Collection
  belongs_to: ValueObject
  description: "#### [hashCode()](index#hashCode())\n\nComputes and returns the hashed identity for this Collection.\n\n``` ts\nhashCode(): number\n```\n\n#### Discussion\n\nThe [`hashCode`](index#hashCode()) of a Collection is used to determine potential equality, and is used when adding this to a [`Set`](../set/index) or as a key in a [`Map`](../map/index), enabling lookup via a different instance.\n\n``` ts\nconst { List, Set } = require('immutable');\nconst a = List([ 1, 2, 3 ]);\nconst b = List([ 1, 2, 3 ]);\nassert.notStrictEqual(a, b); // different instances\nconst set = Set([ a ]);\nassert.equal(set.has(b), true);run it\n```\n\nNote: hashCode() MUST return a Uint32 number. The easiest way to guarantee this is to return `myHash | 0` from a custom implementation.\n\nIf two values have the same [`hashCode`](index#hashCode()), they are [not guaranteed to be equal](https://en.wikipedia.org/wiki/Collision_(computer_science)). If two values have different [`hashCode`](index#hashCode())s, they must not be equal.\n\nNote: [`hashCode()`](index#hashCode()) is not guaranteed to always be called before [`equals()`](index#equals()). Most but not all Immutable.js collections use hash codes to organize their internal data structures, while all Immutable.js collections use equality during lookups.\n\nThis documentation is generated from [immutable.d.ts](https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts). Pull requests and [Issues](https://github.com/immutable-js/immutable-js/issues) welcome.\n\n© 2014–present, Lee Byron and other contributors  \nLicensed under the 3-clause BSD License.  \n[https://immutable-js.com/docs/v4.2.1/ValueObject/](https://immutable-js.com/docs/v4.2.1/ValueObject/)"
