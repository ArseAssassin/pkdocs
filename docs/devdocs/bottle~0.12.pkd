---
name: Bottle
slug: bottle~0.12
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: '0.12'
copyright: |-
  © 2009–2017 Marcel Hellkamp
  Licensed under the MIT License.
  https://bottlepy.org/docs/0.12/index.html
homepage: https://bottlepy.org/

---
- name: API Reference
  id: api
  summary: This is a mostly auto-generated API
  description: "# API Reference\n\nThis is a mostly auto-generated API. If you are new to bottle, you might find the narrative [Tutorial](tutorial) more helpful.\n\n## Module Contents\n\nThe module defines several functions, constants, and an exception.\n\n`debug(mode=True)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#debug)  \nChange the debug level. There is only one debug level supported at the moment.\n\n`run(app=None, server='wsgiref', host='127.0.0.1', port=8080, interval=1, reloader=False, quiet=False, plugins=None, debug=None, **kargs)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#run)  \nStart a server instance. This method blocks until the server terminates.\n\n[TABLE]\n\n&nbsp;\n\n`load(target, **namespace)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#load)  \nImport a module or fetch an object from a module.\n\n- `package.module` returns `module` as a module object.\n- `pack.mod:name` returns the module variable `name` from `pack.mod`.\n- `pack.mod:func()` calls `pack.mod.func()` and returns the result.\n\nThe last form accepts not only function calls, but any type of expression. Keyword arguments passed to this function are available as local variables. Example: `import_string('re:compile(x)', x='[a-z]')`\n\n&nbsp;\n\n`load_app(target)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#load_app)  \nLoad a bottle application from a module and make sure that the import does not affect the current default application, but returns a separate application object. See [`load()`](#bottle.load \"bottle.load\") for the target parameter.\n\n&nbsp;\n\n`request = `  \nA thread-safe instance of [`LocalRequest`](#bottle.LocalRequest \"bottle.LocalRequest\"). If accessed from within a request callback, this instance always refers to the *current* request (even on a multithreaded server).\n\n&nbsp;\n\n`response = Content-Type: text/html; charset=UTF-8`  \nA thread-safe instance of [`LocalResponse`](#bottle.LocalResponse \"bottle.LocalResponse\"). It is used to change the HTTP response for the *current* request.\n\n&nbsp;\n\n`HTTP_CODES = {300: 'Multiple Choices', 301: 'Moved Permanently', 302: 'Found', 303: 'See Other', 304: 'Not Modified', 305: 'Use Proxy', 306: '(Unused)', 307: 'Temporary Redirect', 100: 'Continue', 101: 'Switching Protocols', 400: 'Bad Request', 401: 'Unauthorized', 402: 'Payment Required', 403: 'Forbidden', 404: 'Not Found', 405: 'Method Not Allowed', 406: 'Not Acceptable', 407: 'Proxy Authentication Required', 408: 'Request Timeout', 409: 'Conflict', 410: 'Gone', 411: 'Length Required', 412: 'Precondition Failed', 413: 'Request Entity Too Large', 414: 'Request-URI Too Long', 415: 'Unsupported Media Type', 416: 'Requested Range Not Satisfiable', 417: 'Expectation Failed', 418: \"I'm a teapot\", 422: 'Unprocessable Entity', 428: 'Precondition Required', 429: 'Too Many Requests', 431: 'Request Header Fields Too Large', 200: 'OK', 201: 'Created', 202: 'Accepted', 203: 'Non-Authoritative Information', 204: 'No Content', 205: 'Reset Content', 206: 'Partial Content', 500: 'Internal Server Error', 501: 'Not Implemented', 502: 'Bad Gateway', 503: 'Service Unavailable', 504: 'Gateway Timeout', 505: 'HTTP Version Not Supported', 511: 'Network Authentication Required'}`  \nA dict to map HTTP status codes (e.g. 404) to phrases (e.g. ‘Not Found’)\n\n&nbsp;\n\n`app()`  \n`default_app()`  \nReturn the current [Default Application](tutorial#default-app). Actually, these are callable instances of [`AppStack`](#bottle.AppStack \"bottle.AppStack\") and implement a stack-like API.\n\n### Routing\n\nBottle maintains a stack of [`Bottle`](#bottle.Bottle \"bottle.Bottle\") instances (see [`app()`](#bottle.app \"bottle.app\") and [`AppStack`](#bottle.AppStack \"bottle.AppStack\")) and uses the top of the stack as a *default application* for some of the module-level functions and decorators.\n\n`route(path, method='GET', callback=None, **options)`  \n`get(...)`  \n`post(...)`  \n`put(...)`  \n`delete(...)`  \nDecorator to install a route to the current default application. See [`Bottle.route()`](#bottle.Bottle.route \"bottle.Bottle.route\") for details.\n\n&nbsp;\n\n`error(...)`  \nDecorator to install an error handler to the current default application. See [`Bottle.error()`](#bottle.Bottle.error \"bottle.Bottle.error\") for details.\n\n### WSGI and HTTP Utilities\n\n`parse_date(ims)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#parse_date)  \nParse rfc1123, rfc850 and asctime timestamps and return UTC epoch.\n\n&nbsp;\n\n`parse_auth(header)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#parse_auth)  \nParse rfc2617 HTTP authentication header string (basic) and return (user,pass) tuple or None\n\n&nbsp;\n\n`cookie_encode(data, key)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#cookie_encode)  \nEncode and sign a pickle-able object. Return a (byte) string\n\n&nbsp;\n\n`cookie_decode(data, key)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#cookie_decode)  \nVerify and decode an encoded string. Return an object or None.\n\n&nbsp;\n\n`cookie_is_encoded(data)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#cookie_is_encoded)  \nReturn True if the argument looks like a encoded cookie.\n\n&nbsp;\n\n`yieldroutes(func)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#yieldroutes)  \nReturn a generator for routes that match the signature (name, args) of the func parameter. This may yield more than one route if the function takes optional keyword arguments. The output is best described by example:\n\n``` python\na()         -> '/a'\nb(x, y)     -> '/b/<x>/<y>'\nc(x, y=5)   -> '/c/<x>' and '/c/<x>/<y>'\nd(x=5, y=6) -> '/d' and '/d/<x>' and '/d/<x>/<y>'\n```\n\n&nbsp;\n\n`path_shift(script_name, path_info, shift=1)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#path_shift)  \nShift path fragments from PATH_INFO to SCRIPT_NAME and vice versa.\n\n[TABLE]\n\n### Data Structures\n\n`class MultiDict(*a, **k)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#MultiDict)  \nThis dict stores multiple values per key, but behaves exactly like a normal dict in that it returns only the newest value for any given key. There are special methods available to access the full list of values.\n\n`get(key, default=None, index=-1, type=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#MultiDict.get)  \nReturn the most recent value for a key.\n\n[TABLE]\n\n`append(key, value)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#MultiDict.append)  \nAdd a new value to the list of values for this key.\n\n`replace(key, value)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#MultiDict.replace)  \nReplace the list of values with a single value.\n\n`getall(key)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#MultiDict.getall)  \nReturn a (possibly empty) list of values for a key.\n\n`getone(key, default=None, index=-1, type=None)`  \nAliases for WTForms to mimic other multi-dict APIs (Django)\n\n`getlist(key)`  \nReturn a (possibly empty) list of values for a key.\n\n&nbsp;\n\n`class HeaderDict(*a, **ka)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#HeaderDict)  \nA case-insensitive version of [`MultiDict`](#bottle.MultiDict \"bottle.MultiDict\") that defaults to replace the old value instead of appending it.\n\n&nbsp;\n\n`class FormsDict(*a, **k)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#FormsDict)  \nThis [`MultiDict`](#bottle.MultiDict \"bottle.MultiDict\") subclass is used to store request form data. Additionally to the normal dict-like item access methods (which return unmodified data as native strings), this container also supports attribute-like access to its values. Attributes are automatically de- or recoded to match [`input_encoding`](#bottle.FormsDict.input_encoding \"bottle.FormsDict.input_encoding\") (default: ‘utf8’). Missing attributes default to an empty string.\n\n`input_encoding = 'utf8'`  \nEncoding used for attribute values.\n\n`recode_unicode = True`  \nIf true (default), unicode strings are first encoded with `latin1` and then decoded to match [`input_encoding`](#bottle.FormsDict.input_encoding \"bottle.FormsDict.input_encoding\").\n\n`decode(encoding=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#FormsDict.decode)  \nReturns a copy with all keys and values de- or recoded to match [`input_encoding`](#bottle.FormsDict.input_encoding \"bottle.FormsDict.input_encoding\"). Some libraries (e.g. WTForms) want a unicode dictionary.\n\n`getunicode(name, default=None, encoding=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#FormsDict.getunicode)  \nReturn the value as a unicode string, or the default.\n\n&nbsp;\n\n`class WSGIHeaderDict(environ)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#WSGIHeaderDict)  \nThis dict-like class wraps a WSGI environ dict and provides convenient access to HTTP\\_\\* fields. Keys and values are native strings (2.x bytes or 3.x unicode) and keys are case-insensitive. If the WSGI environment contains non-native string values, these are de- or encoded using a lossless ‘latin1’ character set.\n\nThe API will remain stable even on changes to the relevant PEPs. Currently PEP 333, 444 and 3333 are supported. (PEP 444 is the only one that uses non-native strings.)\n\n`cgikeys = ('CONTENT_TYPE', 'CONTENT_LENGTH')`  \nList of keys that do not have a `HTTP_` prefix.\n\n`raw(key, default=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#WSGIHeaderDict.raw)  \nReturn the header value as is (may be bytes or unicode).\n\n&nbsp;\n\n`class AppStack` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#AppStack)  \nA stack-like list. Calling it returns the head of the stack.\n\n`pop()`  \nReturn the current default application and remove it from the stack.\n\n`push(value=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#AppStack.push)  \nAdd a new [`Bottle`](#bottle.Bottle \"bottle.Bottle\") instance to the stack\n\n&nbsp;\n\n`class ResourceManager(base='./', opener=, cachemode='all')` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ResourceManager)  \nThis class manages a list of search paths and helps to find and open application-bound resources (files).\n\n[TABLE]\n\n`path = None`  \nA list of search paths. See [`add_path()`](#bottle.ResourceManager.add_path \"bottle.ResourceManager.add_path\") for details.\n\n`cache = None`  \nA cache for resolved paths. `res.cache.clear()` clears the cache.\n\n`add_path(path, base=None, index=None, create=False)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ResourceManager.add_path)  \nAdd a new path to the list of search paths. Return False if the path does not exist.\n\n[TABLE]\n\nThe `base` parameter makes it easy to reference files installed along with a python module or package:\n\n``` python\nres.add_path('./resources/', __file__)\n```\n\n`lookup(name)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ResourceManager.lookup)  \nSearch for a resource and return an absolute file path, or `None`.\n\nThe [`path`](#bottle.ResourceManager.path \"bottle.ResourceManager.path\") list is searched in order. The first match is returend. Symlinks are followed. The result is cached to speed up future lookups.\n\n`open(name, mode='r', *args, **kwargs)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ResourceManager.open)  \nFind a resource and return a file object, or raise IOError.\n\n&nbsp;\n\n`class FileUpload(fileobj, name, filename, headers=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#FileUpload)  \n`file = None`  \nOpen file(-like) object (BytesIO buffer or temporary file)\n\n`name = None`  \nName of the upload form field\n\n`raw_filename = None`  \nRaw filename as sent by the client (may contain unsafe characters)\n\n`headers = None`  \nA [`HeaderDict`](#bottle.HeaderDict \"bottle.HeaderDict\") with additional headers (e.g. content-type)\n\n`content_type`  \nCurrent value of the ‘Content-Type’ header.\n\n`content_length`  \nCurrent value of the ‘Content-Length’ header.\n\n`get_header(name, default=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#FileUpload.get_header)  \nReturn the value of a header within the mulripart part.\n\n`filename` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#FileUpload.filename)  \nName of the file on the client file system, but normalized to ensure file system compatibility. An empty filename is returned as ‘empty’.\n\nOnly ASCII letters, digits, dashes, underscores and dots are allowed in the final filename. Accents are removed, if possible. Whitespace is replaced by a single dash. Leading or tailing dots or dashes are removed. The filename is limited to 255 characters.\n\n`save(destination, overwrite=False, chunk_size=65536)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#FileUpload.save)  \nSave file to disk or copy its content to an open file(-like) object. If *destination* is a directory, [`filename`](#bottle.FileUpload.filename \"bottle.FileUpload.filename\") is added to the path. Existing files are not overwritten by default (IOError).\n\n[TABLE]\n\n### Exceptions\n\n`exception BottleException` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BottleException)  \nA base class for exceptions used by bottle.\n\n## The Bottle Class\n\n`class Bottle(catchall=True, autojson=True)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle)  \nEach Bottle object represents a single, distinct web application and consists of routes, callbacks, plugins, resources and configuration. Instances are callable WSGI applications.\n\n|             |                                                                                                                  |\n|-------------|------------------------------------------------------------------------------------------------------------------|\n| Parameters: | **catchall** – If true (default), handle all exceptions. Turn off to let debugging middleware handle exceptions. |\n\n`config = None`  \nA [`ConfigDict`](configuration#bottle.ConfigDict \"bottle.ConfigDict\") for app specific configuration.\n\n`resources = None`  \nA [`ResourceManager`](#bottle.ResourceManager \"bottle.ResourceManager\") for application files\n\n`catchall`  \nIf true, most exceptions are caught and returned as [`HTTPError`](#bottle.HTTPError \"bottle.HTTPError\")\n\n`add_hook(name, func)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.add_hook)  \nAttach a callback to a hook. Three hooks are currently implemented:\n\nbefore_request  \nExecuted once before each request. The request context is available, but no routing has happened yet.\n\nafter_request  \nExecuted once after each request regardless of its outcome.\n\napp_reset  \nCalled whenever [`Bottle.reset()`](#bottle.Bottle.reset \"bottle.Bottle.reset\") is called.\n\n`remove_hook(name, func)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.remove_hook)  \nRemove a callback from a hook.\n\n`trigger_hook(_Bottle__name, *args, **kwargs)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.trigger_hook)  \nTrigger a hook and return a list of results.\n\n`hook(name)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.hook)  \nReturn a decorator that attaches a callback to a hook. See [`add_hook()`](#bottle.Bottle.add_hook \"bottle.Bottle.add_hook\") for details.\n\n`mount(prefix, app, **options)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.mount)  \nMount an application ([`Bottle`](#bottle.Bottle \"bottle.Bottle\") or plain WSGI) to a specific URL prefix. Example:\n\n``` python\nroot_app.mount('/admin/', admin_app)\n```\n\n[TABLE]\n\nAll other parameters are passed to the underlying [`route()`](#bottle.route \"bottle.route\") call.\n\n`merge(routes)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.merge)  \nMerge the routes of another [`Bottle`](#bottle.Bottle \"bottle.Bottle\") application or a list of [`Route`](#bottle.Route \"bottle.Route\") objects into this application. The routes keep their ‘owner’, meaning that the [`Route.app`](#bottle.Route.app \"bottle.Route.app\") attribute is not changed.\n\n`install(plugin)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.install)  \nAdd a plugin to the list of plugins and prepare it for being applied to all routes of this application. A plugin may be a simple decorator or an object that implements the [`Plugin`](plugindev#bottle.Plugin \"bottle.Plugin\") API.\n\n`uninstall(plugin)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.uninstall)  \nUninstall plugins. Pass an instance to remove a specific plugin, a type object to remove all plugins that match that type, a string to remove all plugins with a matching `name` attribute or `True` to remove all plugins. Return the list of removed plugins.\n\n`reset(route=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.reset)  \nReset all routes (force plugins to be re-applied) and clear all caches. If an ID or route object is given, only that specific route is affected.\n\n`close()` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.close)  \nClose the application and all installed plugins.\n\n`run(**kwargs)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.run)  \nCalls [`run()`](#bottle.run \"bottle.run\") with the same parameters.\n\n`match(environ)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.match)  \nSearch for a matching route and return a ([`Route`](#bottle.Route \"bottle.Route\") , urlargs) tuple. The second value is a dictionary with parameters extracted from the URL. Raise [`HTTPError`](#bottle.HTTPError \"bottle.HTTPError\") (404/405) on a non-match.\n\n`get_url(routename, **kargs)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.get_url)  \nReturn a string that matches a named route\n\n`add_route(route)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.add_route)  \nAdd a route object, but do not change the [`Route.app`](#bottle.Route.app \"bottle.Route.app\") attribute.\n\n`route(path=None, method='GET', callback=None, name=None, apply=None, skip=None, **config)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.route)  \nA decorator to bind a function to a request URL. Example:\n\n``` python\n@app.route('/hello/:name')\ndef hello(name):\n    return 'Hello %s' % name\n```\n\nThe `:name` part is a wildcard. See `Router` for syntax details.\n\n[TABLE]\n\nAny additional keyword arguments are stored as route-specific configuration and passed to plugins (see [`Plugin.apply()`](plugindev#bottle.Plugin.apply \"bottle.Plugin.apply\")).\n\n`get(path=None, method='GET', **options)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.get)  \nEquals [`route()`](#bottle.route \"bottle.route\").\n\n`post(path=None, method='POST', **options)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.post)  \nEquals [`route()`](#bottle.route \"bottle.route\") with a `POST` method parameter.\n\n`put(path=None, method='PUT', **options)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.put)  \nEquals [`route()`](#bottle.route \"bottle.route\") with a `PUT` method parameter.\n\n`delete(path=None, method='DELETE', **options)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.delete)  \nEquals [`route()`](#bottle.route \"bottle.route\") with a `DELETE` method parameter.\n\n`error(code=500)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.error)  \nDecorator: Register an output handler for a HTTP error code\n\n`wsgi(environ, start_response)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.wsgi)  \nThe bottle WSGI-interface.\n\n&nbsp;\n\n`class Route(app, rule, method, callback, name=None, plugins=None, skiplist=None, **config)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Route)  \nThis class wraps a route callback along with route specific metadata and configuration and applies Plugins on demand. It is also responsible for turing an URL path rule into a regular expression usable by the Router.\n\n`app = None`  \nThe application this route is installed to.\n\n`rule = None`  \nThe path-rule string (e.g. `/wiki/:page`).\n\n`method = None`  \nThe HTTP method as a string (e.g. `GET`).\n\n`callback = None`  \nThe original callback with no plugins applied. Useful for introspection.\n\n`name = None`  \nThe name of the route (if specified) or `None`.\n\n`plugins = None`  \nA list of route-specific plugins (see [`Bottle.route()`](#bottle.Bottle.route \"bottle.Bottle.route\")).\n\n`skiplist = None`  \nA list of plugins to not apply to this route (see [`Bottle.route()`](#bottle.Bottle.route \"bottle.Bottle.route\")).\n\n`config = None`  \nAdditional keyword arguments passed to the [`Bottle.route()`](#bottle.Bottle.route \"bottle.Bottle.route\") decorator are stored in this dictionary. Used for route-specific plugin configuration and meta-data.\n\n`call` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Route.call)  \nThe route callback with all plugins applied. This property is created on demand and then cached to speed up subsequent requests.\n\n`reset()` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Route.reset)  \nForget any cached values. The next time [`call`](#bottle.Route.call \"bottle.Route.call\") is accessed, all plugins are re-applied.\n\n`prepare()` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Route.prepare)  \nDo all on-demand work immediately (useful for debugging).\n\n`all_plugins()` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Route.all_plugins)  \nYield all Plugins affecting this route.\n\n`get_undecorated_callback()` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Route.get_undecorated_callback)  \nReturn the callback. If the callback is a decorated function, try to recover the original function.\n\n`get_callback_args()` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Route.get_callback_args)  \nReturn a list of argument names the callback (most likely) accepts as keyword arguments. If the callback is a decorated function, try to recover the original function before inspection.\n\n`get_config(key, default=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Route.get_config)  \nLookup a config field and return its value, first checking the route.config, then route.app.config.\n\n## The Request Object\n\nThe [`Request`](#bottle.Request \"bottle.Request\") class wraps a WSGI environment and provides helpful methods to parse and access form data, cookies, file uploads and other metadata. Most of the attributes are read-only.\n\n`Request`  \nalias of [`BaseRequest`](#bottle.BaseRequest \"bottle.BaseRequest\")\n\n&nbsp;\n\n`class BaseRequest(environ=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest)  \nA wrapper for WSGI environment dictionaries that adds a lot of convenient access methods and properties. Most of them are read-only.\n\nAdding new attributes to a request actually adds them to the environ dictionary (as ‘bottle.request.ext.\\<name\\>’). This is the recommended way to store and access request-specific data.\n\n`MEMFILE_MAX = 102400`  \nMaximum size of memory buffer for [`body`](#bottle.BaseRequest.body \"bottle.BaseRequest.body\") in bytes.\n\n`environ`  \nThe wrapped WSGI environ dictionary. This is the only real attribute. All other attributes actually are read-only properties.\n\n`app` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.app)  \nBottle application handling this request.\n\n`route` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.route)  \nThe bottle [`Route`](#bottle.Route \"bottle.Route\") object that matches this request.\n\n`url_args` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.url_args)  \nThe arguments extracted from the URL.\n\n`path`  \nThe value of `PATH_INFO` with exactly one prefixed slash (to fix broken clients and avoid the “empty path” edge case).\n\n`method`  \nThe `REQUEST_METHOD` value as an uppercase string.\n\n`headers` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.headers)  \nA [`WSGIHeaderDict`](#bottle.WSGIHeaderDict \"bottle.WSGIHeaderDict\") that provides case-insensitive access to HTTP request headers.\n\n`get_header(name, default=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.get_header)  \nReturn the value of a request header, or a given default value.\n\n`cookies` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.cookies)  \nCookies parsed into a [`FormsDict`](#bottle.FormsDict \"bottle.FormsDict\"). Signed cookies are NOT decoded. Use [`get_cookie()`](#bottle.BaseRequest.get_cookie \"bottle.BaseRequest.get_cookie\") if you expect signed cookies.\n\n`get_cookie(key, default=None, secret=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.get_cookie)  \nReturn the content of a cookie. To read a `Signed Cookie`, the `secret` must match the one used to create the cookie (see [`BaseResponse.set_cookie()`](#bottle.BaseResponse.set_cookie \"bottle.BaseResponse.set_cookie\")). If anything goes wrong (missing cookie or wrong signature), return a default value.\n\n`query` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.query)  \nThe [`query_string`](#bottle.BaseRequest.query_string \"bottle.BaseRequest.query_string\") parsed into a [`FormsDict`](#bottle.FormsDict \"bottle.FormsDict\"). These values are sometimes called “URL arguments” or “GET parameters”, but not to be confused with “URL wildcards” as they are provided by the `Router`.\n\n`forms` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.forms)  \nForm values parsed from an `url-encoded` or `multipart/form-data` encoded POST or PUT request body. The result is returned as a [`FormsDict`](#bottle.FormsDict \"bottle.FormsDict\"). All keys and values are strings. File uploads are stored separately in [`files`](#bottle.BaseRequest.files \"bottle.BaseRequest.files\").\n\n`params` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.params)  \nA [`FormsDict`](#bottle.FormsDict \"bottle.FormsDict\") with the combined values of [`query`](#bottle.BaseRequest.query \"bottle.BaseRequest.query\") and [`forms`](#bottle.BaseRequest.forms \"bottle.BaseRequest.forms\"). File uploads are stored in [`files`](#bottle.BaseRequest.files \"bottle.BaseRequest.files\").\n\n`files` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.files)  \nFile uploads parsed from `multipart/form-data` encoded POST or PUT request body. The values are instances of [`FileUpload`](#bottle.FileUpload \"bottle.FileUpload\").\n\n`json` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.json)  \nIf the `Content-Type` header is `application/json`, this property holds the parsed content of the request body. Only requests smaller than [`MEMFILE_MAX`](#bottle.BaseRequest.MEMFILE_MAX \"bottle.BaseRequest.MEMFILE_MAX\") are processed to avoid memory exhaustion.\n\n`body`  \nThe HTTP request body as a seek-able file-like object. Depending on [`MEMFILE_MAX`](#bottle.BaseRequest.MEMFILE_MAX \"bottle.BaseRequest.MEMFILE_MAX\"), this is either a temporary file or a [`io.BytesIO`](http://docs.python.org/library/io.html#io.BytesIO \"(in Python v2.7)\") instance. Accessing this property for the first time reads and replaces the `wsgi.input` environ variable. Subsequent accesses just do a `seek(0)` on the file object.\n\n`chunked`  \nTrue if Chunked transfer encoding was.\n\n`GET`  \nAn alias for [`query`](#bottle.BaseRequest.query \"bottle.BaseRequest.query\").\n\n`POST` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.POST)  \nThe values of [`forms`](#bottle.BaseRequest.forms \"bottle.BaseRequest.forms\") and [`files`](#bottle.BaseRequest.files \"bottle.BaseRequest.files\") combined into a single [`FormsDict`](#bottle.FormsDict \"bottle.FormsDict\"). Values are either strings (form values) or instances of `cgi.FieldStorage` (file uploads).\n\n`url`  \nThe full request URI including hostname and scheme. If your app lives behind a reverse proxy or load balancer and you get confusing results, make sure that the `X-Forwarded-Host` header is set correctly.\n\n`urlparts` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.urlparts)  \nThe [`url`](#bottle.BaseRequest.url \"bottle.BaseRequest.url\") string as an [`urlparse.SplitResult`](http://docs.python.org/library/urlparse.html#urlparse.SplitResult \"(in Python v2.7)\") tuple. The tuple contains (scheme, host, path, query_string and fragment), but the fragment is always empty because it is not visible to the server.\n\n`fullpath`  \nRequest path including [`script_name`](#bottle.BaseRequest.script_name \"bottle.BaseRequest.script_name\") (if present).\n\n`query_string`  \nThe raw [`query`](#bottle.BaseRequest.query \"bottle.BaseRequest.query\") part of the URL (everything in between `?` and `#`) as a string.\n\n`script_name`  \nThe initial portion of the URL’s `path` that was removed by a higher level (server or routing middleware) before the application was called. This script path is returned with leading and tailing slashes.\n\n`path_shift(shift=1)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.path_shift)  \n`Shift path segments from path to script_name and`  \nvice versa.\n\n|             |                                                                                                               |\n|-------------|---------------------------------------------------------------------------------------------------------------|\n| Parameters: | **shift** – The number of path segments to shift. May be negative to change the shift direction. (default: 1) |\n\n`content_length`  \nThe request body length as an integer. The client is responsible to set this header. Otherwise, the real length of the body is unknown and -1 is returned. In this case, [`body`](#bottle.BaseRequest.body \"bottle.BaseRequest.body\") will be empty.\n\n`content_type`  \nThe Content-Type header as a lowercase-string (default: empty).\n\n`is_xhr`  \nTrue if the request was triggered by a XMLHttpRequest. This only works with JavaScript libraries that support the `X-Requested-With` header (most of the popular libraries do).\n\n`is_ajax`  \nAlias for [`is_xhr`](#bottle.BaseRequest.is_xhr \"bottle.BaseRequest.is_xhr\"). “Ajax” is not the right term.\n\n`auth`  \nHTTP authentication data as a (user, password) tuple. This implementation currently supports basic (not digest) authentication only. If the authentication happened at a higher level (e.g. in the front web-server or a middleware), the password field is None, but the user field is looked up from the `REMOTE_USER` environ variable. On any errors, None is returned.\n\n`remote_route`  \nA list of all IPs that were involved in this request, starting with the client IP and followed by zero or more proxies. This does only work if all proxies support the `` `X-Forwarded-For `` header. Note that this information can be forged by malicious clients.\n\n`remote_addr`  \nThe client IP as a string. Note that this information can be forged by malicious clients.\n\n`copy()` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.copy)  \nReturn a new [`Request`](#bottle.Request \"bottle.Request\") with a shallow [`environ`](#bottle.BaseRequest.environ \"bottle.BaseRequest.environ\") copy.\n\nThe module-level [`bottle.request`](#bottle.request \"bottle.request\") is a proxy object (implemented in [`LocalRequest`](#bottle.LocalRequest \"bottle.LocalRequest\")) and always refers to the `current` request, or in other words, the request that is currently processed by the request handler in the current thread. This `thread locality` ensures that you can safely use a global instance in a multi-threaded environment.\n\n`class LocalRequest(environ=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#LocalRequest)  \nA thread-local subclass of [`BaseRequest`](#bottle.BaseRequest \"bottle.BaseRequest\") with a different set of attributes for each thread. There is usually only one global instance of this class ([`request`](#bottle.request \"bottle.request\")). If accessed during a request/response cycle, this instance always refers to the *current* request (even on a multithreaded server).\n\n`bind(environ=None)`  \nWrap a WSGI environ dictionary.\n\n`environ`  \nThread-local property\n\n&nbsp;\n\n`request = `  \nA thread-safe instance of [`LocalRequest`](#bottle.LocalRequest \"bottle.LocalRequest\"). If accessed from within a request callback, this instance always refers to the *current* request (even on a multithreaded server).\n\n## The Response Object\n\nThe [`Response`](#bottle.Response \"bottle.Response\") class stores the HTTP status code as well as headers and cookies that are to be sent to the client. Similar to [`bottle.request`](#bottle.request \"bottle.request\") there is a thread-local [`bottle.response`](#bottle.response \"bottle.response\") instance that can be used to adjust the `current` response. Moreover, you can instantiate [`Response`](#bottle.Response \"bottle.Response\") and return it from your request handler. In this case, the custom instance overrules the headers and cookies defined in the global one.\n\n`Response`  \nalias of [`BaseResponse`](#bottle.BaseResponse \"bottle.BaseResponse\")\n\n&nbsp;\n\n`class BaseResponse(body='', status=None, headers=None, **more_headers)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse)  \nStorage class for a response body as well as headers and cookies.\n\nThis class does support dict-like case-insensitive item-access to headers, but is NOT a dict. Most notably, iterating over a response yields parts of the body and not the headers.\n\n[TABLE]\n\nAdditional keyword arguments are added to the list of headers. Underscores in the header name are replaced with dashes.\n\n`copy(cls=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse.copy)  \nReturns a copy of self.\n\n`status_line`  \nThe HTTP status line as a string (e.g. `404 Not Found`).\n\n`status_code`  \nThe HTTP status code as an integer (e.g. 404).\n\n`status`  \nA writeable property to change the HTTP response status. It accepts either a numeric code (100-999) or a string with a custom reason phrase (e.g. “404 Brain not found”). Both [`status_line`](#bottle.BaseResponse.status_line \"bottle.BaseResponse.status_line\") and [`status_code`](#bottle.BaseResponse.status_code \"bottle.BaseResponse.status_code\") are updated accordingly. The return value is always a status string.\n\n`headers`  \nAn instance of [`HeaderDict`](#bottle.HeaderDict \"bottle.HeaderDict\"), a case-insensitive dict-like view on the response headers.\n\n`get_header(name, default=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse.get_header)  \nReturn the value of a previously defined header. If there is no header with that name, return a default value.\n\n`set_header(name, value)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse.set_header)  \nCreate a new response header, replacing any previously defined headers with the same name.\n\n`add_header(name, value)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse.add_header)  \nAdd an additional response header, not removing duplicates.\n\n`iter_headers()` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse.iter_headers)  \nYield (header, value) tuples, skipping headers that are not allowed with the current response status code.\n\n`headerlist`  \nWSGI conform list of (header, value) tuples.\n\n`content_type`  \nCurrent value of the ‘Content-Type’ header.\n\n`content_length`  \nCurrent value of the ‘Content-Length’ header.\n\n`expires`  \nCurrent value of the ‘Expires’ header.\n\n`charset`  \nReturn the charset specified in the content-type header (default: utf8).\n\n`set_cookie(name, value, secret=None, **options)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse.set_cookie)  \nCreate a new cookie or replace an old one. If the `secret` parameter is set, create a `Signed Cookie` (described below).\n\n[TABLE]\n\nAdditionally, this method accepts all RFC 2109 attributes that are supported by `cookie.Morsel`, including:\n\n[TABLE]\n\nIf neither `expires` nor `max_age` is set (default), the cookie will expire at the end of the browser session (as soon as the browser window is closed).\n\nSigned cookies may store any pickle-able object and are cryptographically signed to prevent manipulation. Keep in mind that cookies are limited to 4kb in most browsers.\n\nWarning: Signed cookies are not encrypted (the client can still see the content) and not copy-protected (the client can restore an old cookie). The main intention is to make pickling and unpickling save, not to store secret information at client side.\n\n`delete_cookie(key, **kwargs)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse.delete_cookie)  \nDelete a cookie. Be sure to use the same `domain` and `path` settings as used to create the cookie.\n\n&nbsp;\n\n`class LocalResponse(body='', status=None, headers=None, **more_headers)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#LocalResponse)  \nA thread-local subclass of [`BaseResponse`](#bottle.BaseResponse \"bottle.BaseResponse\") with a different set of attributes for each thread. There is usually only one global instance of this class ([`response`](#bottle.response \"bottle.response\")). Its attributes are used to build the HTTP response at the end of the request/response cycle.\n\n`body`  \nThread-local property\n\nThe following two classes can be raised as an exception. The most noticeable difference is that bottle invokes error handlers for [`HTTPError`](#bottle.HTTPError \"bottle.HTTPError\"), but not for [`HTTPResponse`](#bottle.HTTPResponse \"bottle.HTTPResponse\") or other response types.\n\n`exception HTTPResponse(body='', status=None, headers=None, **more_headers)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#HTTPResponse)\n\n`exception HTTPError(status=None, body=None, exception=None, traceback=None, **options)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#HTTPError)\n\n## Templates\n\nAll template engines supported by [`bottle`](tutorial#module-bottle \"bottle\") implement the [`BaseTemplate`](#bottle.BaseTemplate \"bottle.BaseTemplate\") API. This way it is possible to switch and mix template engines without changing the application code at all.\n\n`class BaseTemplate(source=None, name=None, lookup=[], encoding='utf8', **settings)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseTemplate)  \nBase class and minimal API for template adapters\n\n`__init__(source=None, name=None, lookup=[], encoding='utf8', **settings)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseTemplate.__init__)  \nCreate a new template. If the source parameter (str or buffer) is missing, the name argument is used to guess a template filename. Subclasses can assume that self.source and/or self.filename are set. Both are strings. The lookup, encoding and settings parameters are stored as instance variables. The lookup parameter stores a list containing directory paths. The encoding parameter should be used to decode byte strings or files. The settings parameter contains a dict for engine-specific settings.\n\n`classmethod search(name, lookup=[])` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseTemplate.search)  \nSearch name in all directories specified in lookup. First without, then with common extensions. Return first hit.\n\n`classmethod global_config(key, *args)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseTemplate.global_config)  \nThis reads or sets the global settings stored in class.settings.\n\n`prepare(**options)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseTemplate.prepare)  \nRun preparations (parsing, caching, ...). It should be possible to call this again to refresh a template or to update settings.\n\n`render(*args, **kwargs)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseTemplate.render)  \nRender the template with the specified local variables and return a single byte or unicode string. If it is a byte string, the encoding must match self.encoding. This method must be thread-safe! Local variables may be provided in dictionaries (args) or directly, as keywords (kwargs).\n\n&nbsp;\n\n`view(tpl_name, **defaults)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#view)  \nDecorator: renders a template for a handler. The handler can control its behavior like that:\n\n- return a dict of template vars to fill out the template\n- return something other than a dict and the view decorator will not process the template, but return the handler result as is. This includes returning a HTTPResponse(dict) to get, for instance, JSON with autojson or other castfilters.\n\n&nbsp;\n\n`template(*args, **kwargs)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#template)  \nGet a rendered template as a string iterator. You can use a name, a filename or a template string as first parameter. Template rendering arguments can be passed as dictionaries or directly (as keyword arguments).\n\nYou can write your own adapter for your favourite template engine or use one of the predefined adapters. Currently there are four fully supported template engines:\n\n| Class                                                                  | URL                                                                | Decorator                              | Render function                                    |\n|------------------------------------------------------------------------|--------------------------------------------------------------------|----------------------------------------|----------------------------------------------------|\n| [`SimpleTemplate`](stpl#bottle.SimpleTemplate \"bottle.SimpleTemplate\") | [SimpleTemplate Engine](stpl)                                      | [`view()`](#bottle.view \"bottle.view\") | [`template()`](#bottle.template \"bottle.template\") |\n| `MakoTemplate`                                                         | [http://www.makotemplates.org](http://www.makotemplates.org)       | `mako_view()`                          | `mako_template()`                                  |\n| `CheetahTemplate`                                                      | [http://www.cheetahtemplate.org/](http://www.cheetahtemplate.org/) | `cheetah_view()`                       | `cheetah_template()`                               |\n| `Jinja2Template`                                                       | [http://jinja.pocoo.org/](http://jinja.pocoo.org/)                 | `jinja2_view()`                        | `jinja2_template()`                                |\n\nTo use `MakoTemplate` as your default template engine, just import its specialised decorator and render function:\n\n``` python\nfrom bottle import mako_view as view, mako_template as template\n```\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/api.html](https://bottlepy.org/docs/0.12/api.html)"
- name: app()
  id: api#bottle.app
  summary: Return the current Default Application
  belongs_to: API Reference
  description: |-
    `app()`

    `default_app()`

    Return the current [Default Application](tutorial#default-app). Actually, these are callable instances of [`AppStack`](#bottle.AppStack "bottle.AppStack") and implement a stack-like API.

    ### Routing

    Bottle maintains a stack of [`Bottle`](#bottle.Bottle "bottle.Bottle") instances (see [`app()`](#bottle.app "bottle.app") and [`AppStack`](#bottle.AppStack "bottle.AppStack")) and uses the top of the stack as a *default application* for some of the module-level functions and decorators.
- name: AppStack
  id: api#bottle.AppStack
  summary: A stack-like list
  belongs_to: API Reference
  description: |-
    `class AppStack` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#AppStack)

    A stack-like list. Calling it returns the head of the stack.
- name: AppStack::pop()
  id: api#bottle.AppStack.pop
  summary: Return the current default application and remove it from the stack
  belongs_to: API Reference
  description: |-
    `pop()`

    Return the current default application and remove it from the stack.
- name: AppStack::push()
  id: api#bottle.AppStack.push
  summary: null
  belongs_to: API Reference
  description: |-
    `push(value=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#AppStack.push)

    Add a new [`Bottle`](#bottle.Bottle "bottle.Bottle") instance to the stack
- name: BaseRequest
  id: api#bottle.BaseRequest
  summary: A wrapper for WSGI environment dictionaries that adds a lot of convenient access methods and properties
  belongs_to: API Reference
  description: |-
    `class BaseRequest(environ=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest)

    A wrapper for WSGI environment dictionaries that adds a lot of convenient access methods and properties. Most of them are read-only.

    Adding new attributes to a request actually adds them to the environ dictionary (as ‘bottle.request.ext.\<name\>’). This is the recommended way to store and access request-specific data.

    `MEMFILE_MAX = 102400`

    Maximum size of memory buffer for [`body`](#bottle.BaseRequest.body "bottle.BaseRequest.body") in bytes.

    `environ`

    The wrapped WSGI environ dictionary. This is the only real attribute. All other attributes actually are read-only properties.

    `app` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.app)

    Bottle application handling this request.

    `route` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.route)

    The bottle [`Route`](#bottle.Route "bottle.Route") object that matches this request.

    `url_args` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.url_args)

    The arguments extracted from the URL.

    `path`

    The value of `PATH_INFO` with exactly one prefixed slash (to fix broken clients and avoid the “empty path” edge case).

    `method`

    The `REQUEST_METHOD` value as an uppercase string.

    `headers` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.headers)

    A [`WSGIHeaderDict`](#bottle.WSGIHeaderDict "bottle.WSGIHeaderDict") that provides case-insensitive access to HTTP request headers.
- name: BaseRequest::copy()
  id: api#bottle.BaseRequest.copy
  summary: Return a new Request with a shallow environ copy
  belongs_to: API Reference
  description: |-
    `copy()` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.copy)

    Return a new [`Request`](#bottle.Request "bottle.Request") with a shallow [`environ`](#bottle.BaseRequest.environ "bottle.BaseRequest.environ") copy.

    The module-level [`bottle.request`](#bottle.request "bottle.request") is a proxy object (implemented in [`LocalRequest`](#bottle.LocalRequest "bottle.LocalRequest")) and always refers to the `current` request, or in other words, the request that is currently processed by the request handler in the current thread. This `thread locality` ensures that you can safely use a global instance in a multi-threaded environment.
- name: BaseRequest::get_cookie()
  id: api#bottle.BaseRequest.get_cookie
  summary: Return the content of a cookie
  belongs_to: API Reference
  description: |-
    `get_cookie(key, default=None, secret=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.get_cookie)

    Return the content of a cookie. To read a `Signed Cookie`, the `secret` must match the one used to create the cookie (see [`BaseResponse.set_cookie()`](#bottle.BaseResponse.set_cookie "bottle.BaseResponse.set_cookie")). If anything goes wrong (missing cookie or wrong signature), return a default value.

    `query` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.query)

    The [`query_string`](#bottle.BaseRequest.query_string "bottle.BaseRequest.query_string") parsed into a [`FormsDict`](#bottle.FormsDict "bottle.FormsDict"). These values are sometimes called “URL arguments” or “GET parameters”, but not to be confused with “URL wildcards” as they are provided by the `Router`.

    `forms` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.forms)

    Form values parsed from an `url-encoded` or `multipart/form-data` encoded POST or PUT request body. The result is returned as a [`FormsDict`](#bottle.FormsDict "bottle.FormsDict"). All keys and values are strings. File uploads are stored separately in [`files`](#bottle.BaseRequest.files "bottle.BaseRequest.files").

    `params` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.params)

    A [`FormsDict`](#bottle.FormsDict "bottle.FormsDict") with the combined values of [`query`](#bottle.BaseRequest.query "bottle.BaseRequest.query") and [`forms`](#bottle.BaseRequest.forms "bottle.BaseRequest.forms"). File uploads are stored in [`files`](#bottle.BaseRequest.files "bottle.BaseRequest.files").

    `files` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.files)

    File uploads parsed from `multipart/form-data` encoded POST or PUT request body. The values are instances of [`FileUpload`](#bottle.FileUpload "bottle.FileUpload").

    `json` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.json)

    If the `Content-Type` header is `application/json`, this property holds the parsed content of the request body. Only requests smaller than [`MEMFILE_MAX`](#bottle.BaseRequest.MEMFILE_MAX "bottle.BaseRequest.MEMFILE_MAX") are processed to avoid memory exhaustion.

    `body`

    The HTTP request body as a seek-able file-like object. Depending on [`MEMFILE_MAX`](#bottle.BaseRequest.MEMFILE_MAX "bottle.BaseRequest.MEMFILE_MAX"), this is either a temporary file or a [`io.BytesIO`](http://docs.python.org/library/io.html#io.BytesIO "(in Python v2.7)") instance. Accessing this property for the first time reads and replaces the `wsgi.input` environ variable. Subsequent accesses just do a `seek(0)` on the file object.

    `chunked`

    True if Chunked transfer encoding was.

    `GET`

    An alias for [`query`](#bottle.BaseRequest.query "bottle.BaseRequest.query").

    `POST` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.POST)

    The values of [`forms`](#bottle.BaseRequest.forms "bottle.BaseRequest.forms") and [`files`](#bottle.BaseRequest.files "bottle.BaseRequest.files") combined into a single [`FormsDict`](#bottle.FormsDict "bottle.FormsDict"). Values are either strings (form values) or instances of `cgi.FieldStorage` (file uploads).

    `url`

    The full request URI including hostname and scheme. If your app lives behind a reverse proxy or load balancer and you get confusing results, make sure that the `X-Forwarded-Host` header is set correctly.

    `urlparts` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.urlparts)

    The [`url`](#bottle.BaseRequest.url "bottle.BaseRequest.url") string as an [`urlparse.SplitResult`](http://docs.python.org/library/urlparse.html#urlparse.SplitResult "(in Python v2.7)") tuple. The tuple contains (scheme, host, path, query_string and fragment), but the fragment is always empty because it is not visible to the server.

    `fullpath`

    Request path including [`script_name`](#bottle.BaseRequest.script_name "bottle.BaseRequest.script_name") (if present).

    `query_string`

    The raw [`query`](#bottle.BaseRequest.query "bottle.BaseRequest.query") part of the URL (everything in between `?` and `#`) as a string.

    `script_name`

    The initial portion of the URL’s `path` that was removed by a higher level (server or routing middleware) before the application was called. This script path is returned with leading and tailing slashes.
- name: BaseRequest::get_header()
  id: api#bottle.BaseRequest.get_header
  summary: Return the value of a request header, or a given default value
  belongs_to: API Reference
  description: |-
    `get_header(name, default=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.get_header)

    Return the value of a request header, or a given default value.

    `cookies` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.cookies)

    Cookies parsed into a [`FormsDict`](#bottle.FormsDict "bottle.FormsDict"). Signed cookies are NOT decoded. Use [`get_cookie()`](#bottle.BaseRequest.get_cookie "bottle.BaseRequest.get_cookie") if you expect signed cookies.
- name: BaseRequest::path_shift()
  id: api#bottle.BaseRequest.path_shift
  summary: vice versa
  belongs_to: API Reference
  description: |-
    `path_shift(shift=1)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseRequest.path_shift)

    `Shift path segments from path to script_name and`

    vice versa.

    |             |                                                                                                               |
    |-------------|---------------------------------------------------------------------------------------------------------------|
    | Parameters: | **shift** – The number of path segments to shift. May be negative to change the shift direction. (default: 1) |

    `content_length`

    The request body length as an integer. The client is responsible to set this header. Otherwise, the real length of the body is unknown and -1 is returned. In this case, [`body`](#bottle.BaseRequest.body "bottle.BaseRequest.body") will be empty.

    `content_type`

    The Content-Type header as a lowercase-string (default: empty).

    `is_xhr`

    True if the request was triggered by a XMLHttpRequest. This only works with JavaScript libraries that support the `X-Requested-With` header (most of the popular libraries do).

    `is_ajax`

    Alias for [`is_xhr`](#bottle.BaseRequest.is_xhr "bottle.BaseRequest.is_xhr"). “Ajax” is not the right term.

    `auth`

    HTTP authentication data as a (user, password) tuple. This implementation currently supports basic (not digest) authentication only. If the authentication happened at a higher level (e.g. in the front web-server or a middleware), the password field is None, but the user field is looked up from the `REMOTE_USER` environ variable. On any errors, None is returned.

    `remote_route`

    A list of all IPs that were involved in this request, starting with the client IP and followed by zero or more proxies. This does only work if all proxies support the `` `X-Forwarded-For `` header. Note that this information can be forged by malicious clients.

    `remote_addr`

    The client IP as a string. Note that this information can be forged by malicious clients.
- name: BaseResponse
  id: api#bottle.BaseResponse
  summary: Storage class for a response body as well as headers and cookies
  belongs_to: API Reference
  description: |-
    `class BaseResponse(body='', status=None, headers=None, **more_headers)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse)

    Storage class for a response body as well as headers and cookies.

    This class does support dict-like case-insensitive item-access to headers, but is NOT a dict. Most notably, iterating over a response yields parts of the body and not the headers.

    [TABLE]

    Additional keyword arguments are added to the list of headers. Underscores in the header name are replaced with dashes.
- name: BaseResponse::add_header()
  id: api#bottle.BaseResponse.add_header
  summary: Add an additional response header, not removing duplicates
  belongs_to: API Reference
  description: |-
    `add_header(name, value)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse.add_header)

    Add an additional response header, not removing duplicates.
- name: BaseResponse::copy()
  id: api#bottle.BaseResponse.copy
  summary: Returns a copy of self
  belongs_to: API Reference
  description: |-
    `copy(cls=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse.copy)

    Returns a copy of self.

    `status_line`

    The HTTP status line as a string (e.g. `404 Not Found`).

    `status_code`

    The HTTP status code as an integer (e.g. 404).

    `status`

    A writeable property to change the HTTP response status. It accepts either a numeric code (100-999) or a string with a custom reason phrase (e.g. “404 Brain not found”). Both [`status_line`](#bottle.BaseResponse.status_line "bottle.BaseResponse.status_line") and [`status_code`](#bottle.BaseResponse.status_code "bottle.BaseResponse.status_code") are updated accordingly. The return value is always a status string.

    `headers`

    An instance of [`HeaderDict`](#bottle.HeaderDict "bottle.HeaderDict"), a case-insensitive dict-like view on the response headers.
- name: BaseResponse::delete_cookie()
  id: api#bottle.BaseResponse.delete_cookie
  summary: Delete a cookie
  belongs_to: API Reference
  description: |-
    `delete_cookie(key, **kwargs)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse.delete_cookie)

    Delete a cookie. Be sure to use the same `domain` and `path` settings as used to create the cookie.
- name: BaseResponse::get_header()
  id: api#bottle.BaseResponse.get_header
  summary: Return the value of a previously defined header
  belongs_to: API Reference
  description: |-
    `get_header(name, default=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse.get_header)

    Return the value of a previously defined header. If there is no header with that name, return a default value.
- name: BaseResponse::iter_headers()
  id: api#bottle.BaseResponse.iter_headers
  summary: Yield (header, value) tuples, skipping headers that are not allowed with the current response status code
  belongs_to: API Reference
  description: |-
    `iter_headers()` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse.iter_headers)

    Yield (header, value) tuples, skipping headers that are not allowed with the current response status code.

    `headerlist`

    WSGI conform list of (header, value) tuples.

    `content_type`

    Current value of the ‘Content-Type’ header.

    `content_length`

    Current value of the ‘Content-Length’ header.

    `expires`

    Current value of the ‘Expires’ header.

    `charset`

    Return the charset specified in the content-type header (default: utf8).
- name: BaseResponse::set_cookie()
  id: api#bottle.BaseResponse.set_cookie
  summary: Create a new cookie or replace an old one
  belongs_to: API Reference
  description: |-
    `set_cookie(name, value, secret=None, **options)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse.set_cookie)

    Create a new cookie or replace an old one. If the `secret` parameter is set, create a `Signed Cookie` (described below).

    [TABLE]

    Additionally, this method accepts all RFC 2109 attributes that are supported by `cookie.Morsel`, including:

    [TABLE]

    If neither `expires` nor `max_age` is set (default), the cookie will expire at the end of the browser session (as soon as the browser window is closed).

    Signed cookies may store any pickle-able object and are cryptographically signed to prevent manipulation. Keep in mind that cookies are limited to 4kb in most browsers.

    Warning: Signed cookies are not encrypted (the client can still see the content) and not copy-protected (the client can restore an old cookie). The main intention is to make pickling and unpickling save, not to store secret information at client side.
- name: BaseResponse::set_header()
  id: api#bottle.BaseResponse.set_header
  summary: Create a new response header, replacing any previously defined headers with the same name
  belongs_to: API Reference
  description: |-
    `set_header(name, value)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseResponse.set_header)

    Create a new response header, replacing any previously defined headers with the same name.
- name: BaseTemplate
  id: api#bottle.BaseTemplate
  summary: null
  belongs_to: API Reference
  description: |-
    `class BaseTemplate(source=None, name=None, lookup=[], encoding='utf8', **settings)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseTemplate)

    Base class and minimal API for template adapters
- name: BaseTemplate::prepare()
  id: api#bottle.BaseTemplate.prepare
  summary: Run preparations (parsing, caching, ...)
  belongs_to: API Reference
  description: |-
    `prepare(**options)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseTemplate.prepare)

    Run preparations (parsing, caching, ...). It should be possible to call this again to refresh a template or to update settings.
- name: BaseTemplate::render()
  id: api#bottle.BaseTemplate.render
  summary: Render the template with the specified local variables and return a single byte or unicode string
  belongs_to: API Reference
  description: |-
    `render(*args, **kwargs)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseTemplate.render)

    Render the template with the specified local variables and return a single byte or unicode string. If it is a byte string, the encoding must match self.encoding. This method must be thread-safe! Local variables may be provided in dictionaries (args) or directly, as keywords (kwargs).
- name: BaseTemplate::__init__()
  id: api#bottle.BaseTemplate.__init__
  summary: Create a new template
  belongs_to: API Reference
  description: |-
    `__init__(source=None, name=None, lookup=[], encoding='utf8', **settings)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseTemplate.__init__)

    Create a new template. If the source parameter (str or buffer) is missing, the name argument is used to guess a template filename. Subclasses can assume that self.source and/or self.filename are set. Both are strings. The lookup, encoding and settings parameters are stored as instance variables. The lookup parameter stores a list containing directory paths. The encoding parameter should be used to decode byte strings or files. The settings parameter contains a dict for engine-specific settings.

    `classmethod search(name, lookup=[])` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseTemplate.search)

    Search name in all directories specified in lookup. First without, then with common extensions. Return first hit.

    `classmethod global_config(key, *args)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BaseTemplate.global_config)

    This reads or sets the global settings stored in class.settings.
- name: Bottle
  id: api#bottle.Bottle
  summary: Each Bottle object represents a single, distinct web application and consists of routes, callbacks, plugins, resources and configuration
  belongs_to: API Reference
  description: |-
    `class Bottle(catchall=True, autojson=True)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle)

    Each Bottle object represents a single, distinct web application and consists of routes, callbacks, plugins, resources and configuration. Instances are callable WSGI applications.

    |             |                                                                                                                  |
    |-------------|------------------------------------------------------------------------------------------------------------------|
    | Parameters: | **catchall** – If true (default), handle all exceptions. Turn off to let debugging middleware handle exceptions. |

    `config = None`

    A [`ConfigDict`](configuration#bottle.ConfigDict "bottle.ConfigDict") for app specific configuration.

    `resources = None`

    A [`ResourceManager`](#bottle.ResourceManager "bottle.ResourceManager") for application files

    `catchall`

    If true, most exceptions are caught and returned as [`HTTPError`](#bottle.HTTPError "bottle.HTTPError")
- name: Bottle::add_hook()
  id: api#bottle.Bottle.add_hook
  summary: Attach a callback to a hook
  belongs_to: API Reference
  description: |-
    `add_hook(name, func)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.add_hook)

    Attach a callback to a hook. Three hooks are currently implemented:

    before_request

    Executed once before each request. The request context is available, but no routing has happened yet.

    after_request

    Executed once after each request regardless of its outcome.

    app_reset

    Called whenever [`Bottle.reset()`](#bottle.Bottle.reset "bottle.Bottle.reset") is called.
- name: Bottle::add_route()
  id: api#bottle.Bottle.add_route
  summary: Add a route object, but do not change the Route.app attribute
  belongs_to: API Reference
  description: |-
    `add_route(route)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.add_route)

    Add a route object, but do not change the [`Route.app`](#bottle.Route.app "bottle.Route.app") attribute.
- name: Bottle::close()
  id: api#bottle.Bottle.close
  summary: Close the application and all installed plugins
  belongs_to: API Reference
  description: |-
    `close()` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.close)

    Close the application and all installed plugins.
- name: Bottle::delete()
  id: api#bottle.Bottle.delete
  summary: Equals route() with a DELETE method parameter
  belongs_to: API Reference
  description: |-
    `delete(path=None, method='DELETE', **options)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.delete)

    Equals [`route()`](#bottle.route "bottle.route") with a `DELETE` method parameter.
- name: Bottle::error()
  id: api#bottle.Bottle.error
  summary: null
  belongs_to: API Reference
  description: |-
    `error(code=500)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.error)

    Decorator: Register an output handler for a HTTP error code
- name: Bottle::get()
  id: api#bottle.Bottle.get
  summary: Equals route()
  belongs_to: API Reference
  description: |-
    `get(path=None, method='GET', **options)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.get)

    Equals [`route()`](#bottle.route "bottle.route").
- name: Bottle::get_url()
  id: api#bottle.Bottle.get_url
  summary: null
  belongs_to: API Reference
  description: |-
    `get_url(routename, **kargs)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.get_url)

    Return a string that matches a named route
- name: Bottle::hook()
  id: api#bottle.Bottle.hook
  summary: Return a decorator that attaches a callback to a hook
  belongs_to: API Reference
  description: |-
    `hook(name)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.hook)

    Return a decorator that attaches a callback to a hook. See [`add_hook()`](#bottle.Bottle.add_hook "bottle.Bottle.add_hook") for details.
- name: Bottle::install()
  id: api#bottle.Bottle.install
  summary: Add a plugin to the list of plugins and prepare it for being applied to all routes of this application
  belongs_to: API Reference
  description: |-
    `install(plugin)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.install)

    Add a plugin to the list of plugins and prepare it for being applied to all routes of this application. A plugin may be a simple decorator or an object that implements the [`Plugin`](plugindev#bottle.Plugin "bottle.Plugin") API.
- name: Bottle::match()
  id: api#bottle.Bottle.match
  summary: Search for a matching route and return a (Route , urlargs) tuple
  belongs_to: API Reference
  description: |-
    `match(environ)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.match)

    Search for a matching route and return a ([`Route`](#bottle.Route "bottle.Route") , urlargs) tuple. The second value is a dictionary with parameters extracted from the URL. Raise [`HTTPError`](#bottle.HTTPError "bottle.HTTPError") (404/405) on a non-match.
- name: Bottle::merge()
  id: api#bottle.Bottle.merge
  summary: Merge the routes of another Bottle application or a list of Route objects into this application
  belongs_to: API Reference
  description: |-
    `merge(routes)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.merge)

    Merge the routes of another [`Bottle`](#bottle.Bottle "bottle.Bottle") application or a list of [`Route`](#bottle.Route "bottle.Route") objects into this application. The routes keep their ‘owner’, meaning that the [`Route.app`](#bottle.Route.app "bottle.Route.app") attribute is not changed.
- name: Bottle::mount()
  id: api#bottle.Bottle.mount
  summary: Mount an application (Bottle or plain WSGI) to a specific URL prefix
  belongs_to: API Reference
  description: |-
    `mount(prefix, app, **options)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.mount)

    Mount an application ([`Bottle`](#bottle.Bottle "bottle.Bottle") or plain WSGI) to a specific URL prefix. Example:

    ``` python
    root_app.mount('/admin/', admin_app)
    ```

    [TABLE]

    All other parameters are passed to the underlying [`route()`](#bottle.route "bottle.route") call.
- name: Bottle::post()
  id: api#bottle.Bottle.post
  summary: Equals route() with a POST method parameter
  belongs_to: API Reference
  description: |-
    `post(path=None, method='POST', **options)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.post)

    Equals [`route()`](#bottle.route "bottle.route") with a `POST` method parameter.
- name: Bottle::put()
  id: api#bottle.Bottle.put
  summary: Equals route() with a PUT method parameter
  belongs_to: API Reference
  description: |-
    `put(path=None, method='PUT', **options)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.put)

    Equals [`route()`](#bottle.route "bottle.route") with a `PUT` method parameter.
- name: Bottle::remove_hook()
  id: api#bottle.Bottle.remove_hook
  summary: Remove a callback from a hook
  belongs_to: API Reference
  description: |-
    `remove_hook(name, func)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.remove_hook)

    Remove a callback from a hook.
- name: Bottle::reset()
  id: api#bottle.Bottle.reset
  summary: Reset all routes (force plugins to be re-applied) and clear all caches
  belongs_to: API Reference
  description: |-
    `reset(route=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.reset)

    Reset all routes (force plugins to be re-applied) and clear all caches. If an ID or route object is given, only that specific route is affected.
- name: Bottle::route()
  id: api#bottle.Bottle.route
  summary: A decorator to bind a function to a request URL
  belongs_to: API Reference
  description: |-
    `route(path=None, method='GET', callback=None, name=None, apply=None, skip=None, **config)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.route)

    A decorator to bind a function to a request URL. Example:

    ``` python
    @app.route('/hello/:name')
    def hello(name):
        return 'Hello %s' % name
    ```

    The `:name` part is a wildcard. See `Router` for syntax details.

    [TABLE]

    Any additional keyword arguments are stored as route-specific configuration and passed to plugins (see [`Plugin.apply()`](plugindev#bottle.Plugin.apply "bottle.Plugin.apply")).
- name: Bottle::run()
  id: api#bottle.Bottle.run
  summary: Calls run() with the same parameters
  belongs_to: API Reference
  description: |-
    `run(**kwargs)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.run)

    Calls [`run()`](#bottle.run "bottle.run") with the same parameters.
- name: Bottle::trigger_hook()
  id: api#bottle.Bottle.trigger_hook
  summary: Trigger a hook and return a list of results
  belongs_to: API Reference
  description: |-
    `trigger_hook(_Bottle__name, *args, **kwargs)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.trigger_hook)

    Trigger a hook and return a list of results.
- name: Bottle::uninstall()
  id: api#bottle.Bottle.uninstall
  summary: Uninstall plugins
  belongs_to: API Reference
  description: |-
    `uninstall(plugin)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.uninstall)

    Uninstall plugins. Pass an instance to remove a specific plugin, a type object to remove all plugins that match that type, a string to remove all plugins with a matching `name` attribute or `True` to remove all plugins. Return the list of removed plugins.
- name: Bottle::wsgi()
  id: api#bottle.Bottle.wsgi
  summary: The bottle WSGI-interface
  belongs_to: API Reference
  description: |-
    `wsgi(environ, start_response)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Bottle.wsgi)

    The bottle WSGI-interface.
- name: ConfigDict
  id: configuration#bottle.ConfigDict
  summary: A dict-like configuration storage with additional support for namespaces, validators, meta-data, on_change listeners and more
  belongs_to: Configuration (DRAFT)
  description: |-
    `class ConfigDict(*a, **ka)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ConfigDict)

    A dict-like configuration storage with additional support for namespaces, validators, meta-data, on_change listeners and more.

    This storage is optimized for fast read access. Retrieving a key or using non-altering dict methods (e.g. `dict.get()`) has no overhead compared to a native dict.
- name: ConfigDict::load_config()
  id: configuration#bottle.ConfigDict.load_config
  summary: Load values from an *.ini style config file
  belongs_to: Configuration (DRAFT)
  description: |-
    `load_config(filename)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ConfigDict.load_config)

    Load values from an [\*](#id1).ini style config file.

    If the config file contains sections, their names are used as namespaces for the values within. The two special sections `DEFAULT` and `bottle` refer to the root namespace (no prefix).
- name: ConfigDict::load_dict()
  id: configuration#bottle.ConfigDict.load_dict
  summary: Import values from a dictionary structure
  belongs_to: Configuration (DRAFT)
  description: |-
    `load_dict(source, namespace='', make_namespaces=False)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ConfigDict.load_dict)

    Import values from a dictionary structure. Nesting can be used to represent namespaces.

    ``` python
    >>> ConfigDict().load_dict({'name': {'space': {'key': 'value'}}})
    {'name.space.key': 'value'}
    ```
- name: ConfigDict::meta_get()
  id: configuration#bottle.ConfigDict.meta_get
  summary: Return the value of a meta field for a key
  belongs_to: Configuration (DRAFT)
  description: |-
    `meta_get(key, metafield, default=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ConfigDict.meta_get)

    Return the value of a meta field for a key.
- name: ConfigDict::meta_list()
  id: configuration#bottle.ConfigDict.meta_list
  summary: Return an iterable of meta field names defined for a key
  belongs_to: Configuration (DRAFT)
  description: "`meta_list(key)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ConfigDict.meta_list)\n\nReturn an iterable of meta field names defined for a key.\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/configuration.html](https://bottlepy.org/docs/0.12/configuration.html)"
- name: ConfigDict::meta_set()
  id: configuration#bottle.ConfigDict.meta_set
  summary: Set the meta field for a key to a new value
  belongs_to: Configuration (DRAFT)
  description: |-
    `meta_set(key, metafield, value)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ConfigDict.meta_set)

    Set the meta field for a key to a new value. This triggers the on-change handler for existing keys.
- name: ConfigDict::update()
  id: configuration#bottle.ConfigDict.update
  summary: If the first parameter is a string, all keys are prefixed with this namespace
  belongs_to: Configuration (DRAFT)
  description: |-
    `update(*a, **ka)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ConfigDict.update)

    If the first parameter is a string, all keys are prefixed with this namespace. Apart from that it works just as the usual dict.update(). Example: `update('some.namespace', key='value')`
- name: Configuration (DRAFT)
  id: configuration
  summary: Bottle applications can store their configuration in Bottle.config, a dict-like object and central place for application specific settings
  description: "# Configuration (DRAFT)\n\nBottle applications can store their configuration in [`Bottle.config`](api#bottle.Bottle.config \"bottle.Bottle.config\"), a dict-like object and central place for application specific settings. This dictionary controls many aspects of the framework, tells (newer) plugins what to do, and can be used to store your own configuration as well.\n\n## Configuration Basics\n\nThe [`Bottle.config`](api#bottle.Bottle.config \"bottle.Bottle.config\") object behaves a lot like an ordinary dictionary. All the common dict methods work as expected. Let us start with some examples:\n\n``` python\nimport bottle\napp = bottle.default_app()             # or bottle.Bottle() if you prefer\n\napp.config['autojson']    = False      # Turns off the \"autojson\" feature\napp.config['sqlite.db']   = ':memory:' # Tells the sqlite plugin which db to use\napp.config['myapp.param'] = 'value'    # Example for a custom config value.\n\n# Change many values at once\napp.config.update({\n    'autojson': False,\n    'sqlite.db': ':memory:',\n    'myapp.param': 'value'\n})\n\n# Add default values\napp.config.setdefault('myapp.param2', 'some default')\n\n# Receive values\nparam  = app.config['myapp.param']\nparam2 = app.config.get('myapp.param2', 'fallback value')\n\n# An example route using configuration values\n@app.route('/about', view='about.rst')\ndef about():\n    email = app.config.get('my.email', 'nomail@example.com')\n    return {'email': email}\n```\n\nThe app object is not always available, but as long as you are within a request context, you can use the `request` object to get the current application and its configuration:\n\n``` python\nfrom bottle import request\ndef is_admin(user):\n    return user == request.app.config['myapp.admin_user']\n```\n\n## Naming Convention\n\nTo make life easier, plugins and applications should follow some simple rules when it comes to config parameter names:\n\n- All keys should be lowercase strings and follow the rules for python identifiers (no special characters but the underscore).\n- Namespaces are separated by dots (e.g. `namespace.field` or `namespace.subnamespace.field`).\n- Bottle uses the root namespace for its own configuration. Plugins should store all their variables in their own namespace (e.g. `sqlite.db` or `werkzeug.use_debugger`).\n- Your own application should use a separate namespace (e.g. `myapp.*`).\n\n## Loading Configuration from a File\n\nConfiguration files are useful if you want to enable non-programmers to configure your application, or just don’t want to hack python module files just to change the database port. A very common syntax for configuration files is shown here:\n\n``` ini\n[bottle]\ndebug = True\n\n[sqlite]\ndb = /tmp/test.db\ncommit = auto\n\n[myapp]\nadmin_user = defnull\n```\n\nWith [`ConfigDict.load_config()`](#bottle.ConfigDict.load_config \"bottle.ConfigDict.load_config\") you can load these `*.ini` style configuration files from disk and import their values into your existing configuration:\n\n``` python\napp.config.load_config('/etc/myapp.conf')\n```\n\n## Loading Configuration from a nested dict\n\nAnother useful method is [`ConfigDict.load_dict()`](#bottle.ConfigDict.load_dict \"bottle.ConfigDict.load_dict\"). This method takes an entire structure of nested dictionaries and turns it into a flat list of keys and values with namespaced keys:\n\n``` python\n# Load an entire dict structure\napp.config.load_dict({\n    'autojson': False,\n    'sqlite': { 'db': ':memory:' },\n    'myapp': {\n        'param': 'value',\n        'param2': 'value2'\n    }\n})\n\nassert app.config['myapp.param'] == 'value'\n\n# Load configuration from a json file\nwith open('/etc/myapp.json') as fp:\n    app.config.load_dict(json.load(fp))\n```\n\n## Listening to configuration changes\n\nThe `config` hook on the application object is triggered each time a value in [`Bottle.config`](api#bottle.Bottle.config \"bottle.Bottle.config\") is changed. This hook can be used to react on configuration changes at runtime, for example reconnect to a new database, change the debug settings on a background service or resize worker thread pools. The hook callback receives two arguments (key, new_value) and is called before the value is actually changed in the dictionary. Raising an exception from a hook callback cancels the change and the old value is preserved.\n\n``` python\n@app.hook('config')\ndef on_config_change(key, value):\n  if key == 'debug':\n      switch_own_debug_mode_to(value)\n```\n\nThe hook callbacks cannot *change* the value that is to be stored to the dictionary. That is what filters are for.\n\n## Filters and other Meta Data\n\n[`ConfigDict`](#bottle.ConfigDict \"bottle.ConfigDict\") allows you to store meta data along with configuration keys. Two meta fields are currently defined:\n\nhelp  \nA help or description string. May be used by debugging, introspection or admin tools to help the site maintainer configuring their application.\n\nfilter  \nA callable that accepts and returns a single value. If a filter is defined for a key, any new value stored to that key is first passed through the filter callback. The filter can be used to cast the value to a different type, check for invalid values (throw a ValueError) or trigger side effects.\n\nThis feature is most useful for plugins. They can validate their config parameters or trigger side effects using filters and document their configuration via `help` fields:\n\n``` python\nclass SomePlugin(object):\n    def setup(app):\n        app.config.meta_set('some.int', 'filter', int)\n        app.config.meta_set('some.list', 'filter',\n            lambda val: str(val).split(';'))\n        app.config.meta_set('some.list', 'help',\n            'A semicolon separated list.')\n\n    def apply(self, callback, route):\n        ...\n\nimport bottle\napp = bottle.default_app()\napp.install(SomePlugin())\n\napp.config['some.list'] = 'a;b;c'     # Actually stores ['a', 'b', 'c']\napp.config['some.int'] = 'not an int' # raises ValueError\n```\n\n## API Documentation\n\n`class ConfigDict(*a, **ka)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ConfigDict)  \nA dict-like configuration storage with additional support for namespaces, validators, meta-data, on_change listeners and more.\n\nThis storage is optimized for fast read access. Retrieving a key or using non-altering dict methods (e.g. `dict.get()`) has no overhead compared to a native dict.\n\n`load_config(filename)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ConfigDict.load_config)  \nLoad values from an [\\*](#id1).ini style config file.\n\nIf the config file contains sections, their names are used as namespaces for the values within. The two special sections `DEFAULT` and `bottle` refer to the root namespace (no prefix).\n\n`load_dict(source, namespace='', make_namespaces=False)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ConfigDict.load_dict)  \nImport values from a dictionary structure. Nesting can be used to represent namespaces.\n\n``` python\n>>> ConfigDict().load_dict({'name': {'space': {'key': 'value'}}})\n{'name.space.key': 'value'}\n```\n\n`update(*a, **ka)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ConfigDict.update)  \nIf the first parameter is a string, all keys are prefixed with this namespace. Apart from that it works just as the usual dict.update(). Example: `update('some.namespace', key='value')`\n\n`meta_get(key, metafield, default=None)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ConfigDict.meta_get)  \nReturn the value of a meta field for a key.\n\n`meta_set(key, metafield, value)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ConfigDict.meta_set)  \nSet the meta field for a key to a new value. This triggers the on-change handler for existing keys.\n\n`meta_list(key)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ConfigDict.meta_list)  \nReturn an iterable of meta field names defined for a key.\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/configuration.html](https://bottlepy.org/docs/0.12/configuration.html)"
- name: cookie_decode()
  id: api#bottle.cookie_decode
  summary: Verify and decode an encoded string
  belongs_to: API Reference
  description: |-
    `cookie_decode(data, key)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#cookie_decode)

    Verify and decode an encoded string. Return an object or None.
- name: cookie_encode()
  id: api#bottle.cookie_encode
  summary: Encode and sign a pickle-able object
  belongs_to: API Reference
  description: |-
    `cookie_encode(data, key)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#cookie_encode)

    Encode and sign a pickle-able object. Return a (byte) string
- name: cookie_is_encoded()
  id: api#bottle.cookie_is_encoded
  summary: Return True if the argument looks like a encoded cookie
  belongs_to: API Reference
  description: |-
    `cookie_is_encoded(data)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#cookie_is_encoded)

    Return True if the argument looks like a encoded cookie.
- name: debug()
  id: api#bottle.debug
  summary: Change the debug level
  belongs_to: API Reference
  description: |-
    `debug(mode=True)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#debug)

    Change the debug level. There is only one debug level supported at the moment.
- name: defined()
  id: stpl#stpl.defined
  summary: Return True if the variable is defined in the current template namespace, False otherwise
  belongs_to: SimpleTemplate Engine
  description: |-
    `defined(name)`

    Return True if the variable is defined in the current template namespace, False otherwise.
- name: Deployment
  id: deployment
  summary: The bottle run() function, when called without any parameters, starts a local development server on port 8080
  description: "# Deployment\n\nThe bottle `run()` function, when called without any parameters, starts a local development server on port 8080. You can access and test your application via [http://localhost:8080/](http://localhost:8080/) if you are on the same host.\n\nTo get your application available to the outside world, specify the IP of the interface the server should listen to (e.g. `run(host='192.168.0.1')`) or let the server listen to all interfaces at once (e.g. `run(host='0.0.0.0')`). The listening port can be changed in a similar way, but you need root or admin rights to choose a port below 1024. Port 80 is the standard for HTTP servers:\n\n``` python\nrun(host='0.0.0.0', port=80) # Listen to HTTP requests on all interfaces\n```\n\n## Server Options\n\nThe built-in default server is based on [wsgiref WSGIServer](http://docs.python.org/library/wsgiref.html#module-wsgiref.simple_server). This non-threading HTTP server is perfectly fine for development and early production, but may become a performance bottleneck when server load increases. There are three ways to eliminate this bottleneck:\n\n- Use a different server that is either multi-threaded or asynchronous.\n- Start multiple server processes and spread the load with a load-balancer.\n- Do both.\n\n**Multi-threaded** servers are the ‘classic’ way to do it. They are very robust, reasonably fast and easy to manage. As a drawback, they can only handle a limited number of connections at the same time and utilize only one CPU core due to the “Global Interpreter Lock” (GIL). This does not hurt most applications, they are waiting for network IO most of the time anyway, but may slow down CPU intensive tasks (e.g. image processing).\n\n**Asynchronous** servers are very fast, can handle a virtually unlimited number of concurrent connections and are easy to manage, but can get a bit tricky. To take full advantage of their potential, you need to design your application accordingly and understand the concepts of the specific server.\n\n**Multi-processing** (forking) servers are not limited by the GIL and utilize more than one CPU core, but make communication between server instances more expensive. You need a database or external message query to share state between processes, or design your application so that it does not need any shared state. The setup is also a bit more complicated, but there are good tutorials available.\n\n## Switching the Server Backend\n\nThe easiest way to increase performance is to install a multi-threaded server library like [paste](http://pythonpaste.org/) or [cherrypy](http://www.cherrypy.org/) and tell Bottle to use that instead of the single-threaded server:\n\n``` python\nbottle.run(server='paste')\n```\n\nBottle ships with a lot of ready-to-use adapters for the most common WSGI servers and automates the setup process. Here is an incomplete list:\n\n| Name     | Homepage                                                          | Description                                       |\n|----------|-------------------------------------------------------------------|---------------------------------------------------|\n| cgi      |                                                                   | Run as CGI script                                 |\n| flup     | [flup](http://trac.saddi.com/flup)                                | Run as FastCGI process                            |\n| gae      | [gae](http://code.google.com/appengine/docs/python/overview.html) | Helper for Google App Engine deployments          |\n| wsgiref  | [wsgiref](http://docs.python.org/library/wsgiref.html)            | Single-threaded default server                    |\n| cherrypy | [cherrypy](http://www.cherrypy.org/)                              | Multi-threaded and very stable                    |\n| paste    | [paste](http://pythonpaste.org/)                                  | Multi-threaded, stable, tried and tested          |\n| rocket   | [rocket](http://pypi.python.org/pypi/rocket)                      | Multi-threaded                                    |\n| waitress | [waitress](http://readthedocs.org/docs/waitress/en/latest/)       | Multi-threaded, poweres Pyramid                   |\n| gunicorn | [gunicorn](http://pypi.python.org/pypi/gunicorn)                  | Pre-forked, partly written in C                   |\n| eventlet | [eventlet](http://eventlet.net/)                                  | Asynchronous framework with WSGI support.         |\n| gevent   | [gevent](http://www.gevent.org/)                                  | Asynchronous (greenlets)                          |\n| diesel   | [diesel](http://dieselweb.org/)                                   | Asynchronous (greenlets)                          |\n| fapws3   | [fapws3](http://www.fapws.org/)                                   | Asynchronous (network side only), written in C    |\n| tornado  | [tornado](http://www.tornadoweb.org/)                             | Asynchronous, powers some parts of Facebook       |\n| twisted  | [twisted](http://twistedmatrix.com/)                              | Asynchronous, well tested but... twisted          |\n| meinheld | [meinheld](http://pypi.python.org/pypi/meinheld)                  | Asynchronous, partly written in C                 |\n| bjoern   | [bjoern](http://pypi.python.org/pypi/bjoern)                      | Asynchronous, very fast and written in C          |\n| auto     |                                                                   | Automatically selects an available server adapter |\n\nThe full list is available through `server_names`.\n\nIf there is no adapter for your favorite server or if you need more control over the server setup, you may want to start the server manually. Refer to the server documentation on how to run WSGI applications. Here is an example for [paste](http://pythonpaste.org/):\n\n``` python\napplication = bottle.default_app()\nfrom paste import httpserver\nhttpserver.serve(application, host='0.0.0.0', port=80)\n```\n\n### Apache mod_wsgi\n\nInstead of running your own HTTP server from within Bottle, you can attach Bottle applications to an [Apache server](apache) using [mod_wsgi](http://code.google.com/p/modwsgi/).\n\nAll you need is an `app.wsgi` file that provides an `application` object. This object is used by mod_wsgi to start your application and should be a WSGI-compatible Python callable.\n\nFile `/var/www/yourapp/app.wsgi`:\n\n``` python\n# Change working directory so relative paths (and template lookup) work again\nos.chdir(os.path.dirname(__file__))\n\nimport bottle\n# ... build or import your bottle application here ...\n# Do NOT use bottle.run() with mod_wsgi\napplication = bottle.default_app()\n```\n\nThe Apache configuration may look like this:\n\n``` python\n<VirtualHost *>\n    ServerName example.com\n\n    WSGIDaemonProcess yourapp user=www-data group=www-data processes=1 threads=5\n    WSGIScriptAlias / /var/www/yourapp/app.wsgi\n\n    <Directory /var/www/yourapp>\n        WSGIProcessGroup yourapp\n        WSGIApplicationGroup %{GLOBAL}\n        Order deny,allow\n        Allow from all\n    </Directory>\n</VirtualHost>\n```\n\n### Google AppEngine\n\nNew in version 0.9.\n\nThe `gae` server adapter is used to run applications on Google App Engine. It works similar to the `cgi` adapter in that it does not start a new HTTP server, but prepares and optimizes your application for Google App Engine and makes sure it conforms to their API:\n\n``` python\nbottle.run(server='gae') # No need for a host or port setting.\n```\n\nIt is always a good idea to let GAE serve static files directly. Here is example for a working `app.yaml`:\n\n``` python\napplication: myapp\nversion: 1\nruntime: python\napi_version: 1\n\nhandlers:\n- url: /static\n  static_dir: static\n\n- url: /.*\n  script: myapp.py\n```\n\n### Load Balancer (Manual Setup)\n\nA single Python process can utilize only one CPU at a time, even if there are more CPU cores available. The trick is to balance the load between multiple independent Python processes to utilize all of your CPU cores.\n\nInstead of a single Bottle application server, you start one instance for each CPU core available using different local port (localhost:8080, 8081, 8082, ...). You can choose any server adapter you want, even asynchronous ones. Then a high performance load balancer acts as a reverse proxy and forwards each new requests to a random port, spreading the load between all available back-ends. This way you can use all of your CPU cores and even spread out the load between different physical servers.\n\nOne of the fastest load balancers available is [Pound](http://www.apsis.ch/pound) but most common web servers have a proxy-module that can do the work just fine.\n\nPound example:\n\n``` python\nListenHTTP\n    Address 0.0.0.0\n    Port    80\n\n    Service\n        BackEnd\n            Address 127.0.0.1\n            Port    8080\n        End\n        BackEnd\n            Address 127.0.0.1\n            Port    8081\n        End\n    End\nEnd\n```\n\nApache example:\n\n``` python\n<Proxy balancer://mycluster>\nBalancerMember http://192.168.1.50:80\nBalancerMember http://192.168.1.51:80\n</Proxy>\nProxyPass / balancer://mycluster\n```\n\nLighttpd example:\n\n``` python\nserver.modules += ( \"mod_proxy\" )\nproxy.server = (\n    \"\" => (\n        \"wsgi1\" => ( \"host\" => \"127.0.0.1\", \"port\" => 8080 ),\n        \"wsgi2\" => ( \"host\" => \"127.0.0.1\", \"port\" => 8081 )\n    )\n)\n```\n\n## Good old CGI\n\nA CGI server starts a new process for each request. This adds a lot of overhead but is sometimes the only option, especially on cheap hosting packages. The `cgi` server adapter does not actually start a CGI server, but transforms your bottle application into a valid CGI application:\n\n``` python\nbottle.run(server='cgi')\n```\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/deployment.html](https://bottlepy.org/docs/0.12/deployment.html)"
- name: error()
  id: api#bottle.error
  summary: Decorator to install an error handler to the current default application
  belongs_to: API Reference
  description: |-
    `error(...)`

    Decorator to install an error handler to the current default application. See [`Bottle.error()`](#bottle.Bottle.error "bottle.Bottle.error") for details.

    ### WSGI and HTTP Utilities
- name: FileUpload
  id: api#bottle.FileUpload
  summary: A HeaderDict with additional headers (e.g
  belongs_to: API Reference
  description: |-
    `class FileUpload(fileobj, name, filename, headers=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#FileUpload)

    `file = None`

    Open file(-like) object (BytesIO buffer or temporary file)

    `name = None`

    Name of the upload form field

    `raw_filename = None`

    Raw filename as sent by the client (may contain unsafe characters)

    `headers = None`

    A [`HeaderDict`](#bottle.HeaderDict "bottle.HeaderDict") with additional headers (e.g. content-type)

    `content_type`

    Current value of the ‘Content-Type’ header.

    `content_length`

    Current value of the ‘Content-Length’ header.
- name: FileUpload::get_header()
  id: api#bottle.FileUpload.get_header
  summary: Return the value of a header within the mulripart part
  belongs_to: API Reference
  description: |-
    `get_header(name, default=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#FileUpload.get_header)

    Return the value of a header within the mulripart part.

    `filename` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#FileUpload.filename)

    Name of the file on the client file system, but normalized to ensure file system compatibility. An empty filename is returned as ‘empty’.

    Only ASCII letters, digits, dashes, underscores and dots are allowed in the final filename. Accents are removed, if possible. Whitespace is replaced by a single dash. Leading or tailing dots or dashes are removed. The filename is limited to 255 characters.
- name: FileUpload::save()
  id: api#bottle.FileUpload.save
  summary: Save file to disk or copy its content to an open file(-like) object
  belongs_to: API Reference
  description: |-
    `save(destination, overwrite=False, chunk_size=65536)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#FileUpload.save)

    Save file to disk or copy its content to an open file(-like) object. If *destination* is a directory, [`filename`](#bottle.FileUpload.filename "bottle.FileUpload.filename") is added to the path. Existing files are not overwritten by default (IOError).

    [TABLE]

    ### Exceptions

    `exception BottleException` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#BottleException)

    A base class for exceptions used by bottle.

    ## The Bottle Class
- name: FormsDict
  id: api#bottle.FormsDict
  summary: This MultiDict subclass is used to store request form data
  belongs_to: API Reference
  description: |-
    `class FormsDict(*a, **k)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#FormsDict)

    This [`MultiDict`](#bottle.MultiDict "bottle.MultiDict") subclass is used to store request form data. Additionally to the normal dict-like item access methods (which return unmodified data as native strings), this container also supports attribute-like access to its values. Attributes are automatically de- or recoded to match [`input_encoding`](#bottle.FormsDict.input_encoding "bottle.FormsDict.input_encoding") (default: ‘utf8’). Missing attributes default to an empty string.

    `input_encoding = 'utf8'`

    Encoding used for attribute values.

    `recode_unicode = True`

    If true (default), unicode strings are first encoded with `latin1` and then decoded to match [`input_encoding`](#bottle.FormsDict.input_encoding "bottle.FormsDict.input_encoding").
- name: FormsDict::decode()
  id: api#bottle.FormsDict.decode
  summary: Returns a copy with all keys and values de- or recoded to match input_encoding
  belongs_to: API Reference
  description: |-
    `decode(encoding=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#FormsDict.decode)

    Returns a copy with all keys and values de- or recoded to match [`input_encoding`](#bottle.FormsDict.input_encoding "bottle.FormsDict.input_encoding"). Some libraries (e.g. WTForms) want a unicode dictionary.
- name: FormsDict::getunicode()
  id: api#bottle.FormsDict.getunicode
  summary: Return the value as a unicode string, or the default
  belongs_to: API Reference
  description: |-
    `getunicode(name, default=None, encoding=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#FormsDict.getunicode)

    Return the value as a unicode string, or the default.
- name: Frequently Asked Questions
  id: faq
  summary: Bottle is a micro framework designed for prototyping and building small web applications and services
  description: "# Frequently Asked Questions\n\n## About Bottle\n\n### Is bottle suitable for complex applications?\n\nBottle is a *micro* framework designed for prototyping and building small web applications and services. It stays out of your way and allows you to get things done fast, but misses some advanced features and ready-to-use solutions found in other frameworks (MVC, ORM, form validation, scaffolding, XML-RPC). Although it *is* possible to add these features and build complex applications with Bottle, you should consider using a full-stack Web framework like [pylons](http://pylonshq.com/) or [paste](http://pythonpaste.org/modules/evalexception.html) instead.\n\n## Common Problems and Pitfalls\n\n### “Template Not Found” in mod_wsgi/mod_python\n\nBottle searches in `./` and `./views/` for templates. In a [mod_python](http://www.modpython.org/) or [mod_wsgi](http://code.google.com/p/modwsgi/) environment, the working directory (`./`) depends on your Apache settings. You should add an absolute path to the template search path:\n\n``` python\nbottle.TEMPLATE_PATH.insert(0,'/absolut/path/to/templates/')\n```\n\nso bottle searches the right paths.\n\n### Dynamic Routes and Slashes\n\nIn [dynamic route syntax](tutorial#tutorial-dynamic-routes), a placeholder token (`:name`) matches everything up to the next slash. This equals to `[^/]+` in regular expression syntax. To accept slashes too, you have to add a custom regular pattern to the placeholder. An example: `/images/:filepath#.*#` would match `/images/icons/error.png` but `/images/:filename` won’t.\n\n### Problems with reverse proxies\n\nRedirects and url-building only works if bottle knows the public address and location of your application. If you run bottle locally behind a reverse proxy or load balancer, some information might get lost along the way. For example, the `wsgi.url_scheme` value or the `Host` header might reflect the local request by your proxy, not the real request by the client. Here is a small WSGI middleware snippet that helps to fix these values:\n\n``` python\ndef fix_environ_middleware(app):\n  def fixed_app(environ, start_response):\n    environ['wsgi.url_scheme'] = 'https'\n    environ['HTTP_X_FORWARDED_HOST'] = 'example.com'\n    return app(environ, start_response)\n  return https_app\n\napp = bottle.default_app()\napp.wsgi = fix_environ_middleware(app.wsgi)\n```\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/faq.html](https://bottlepy.org/docs/0.12/faq.html)"
- name: get()
  id: stpl#stpl.get
  summary: Return the variable, or a default value
  belongs_to: SimpleTemplate Engine
  description: |-
    `get(name, default=None)`

    Return the variable, or a default value.
- name: HeaderDict
  id: api#bottle.HeaderDict
  summary: A case-insensitive version of MultiDict that defaults to replace the old value instead of appending it
  belongs_to: API Reference
  description: |-
    `class HeaderDict(*a, **ka)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#HeaderDict)

    A case-insensitive version of [`MultiDict`](#bottle.MultiDict "bottle.MultiDict") that defaults to replace the old value instead of appending it.
- name: include()
  id: stpl#stpl.include
  summary: Render a sub-template with the specified variables and insert the resulting text into the current template
  belongs_to: SimpleTemplate Engine
  description: |-
    `include(sub_template, **variables)`

    Render a sub-template with the specified variables and insert the resulting text into the current template. The function returns a dictionary containing the local variables passed to or defined within the sub-template:

    ``` html
    % include('header.tpl', title='Page Title')
    Page Content
    % include('foother.tpl')
    ```
- name: List of available Plugins
  id: plugins/index
  summary: This is a list of third-party plugins that add extend Bottles core functionality or integrate other libraries with the Bottle framework
  description: "# List of available Plugins\n\nThis is a list of third-party plugins that add extend Bottles core functionality or integrate other libraries with the Bottle framework.\n\nHave a look at [Plugins](../tutorial#plugins) for general questions about plugins (installation, usage). If you plan to develop a new plugin, the [Plugin Development Guide](../plugindev) may help you.\n\n[Bottle-Cork](http://cork.firelet.net/)  \nCork provides a simple set of methods to implement Authentication and Authorization in web applications based on Bottle.\n\n[Bottle-Extras](http://pypi.python.org/pypi/bottle-extras/)  \nMeta package to install the bottle plugin collection.\n\n[Bottle-Flash](http://pypi.python.org/pypi/bottle-flash/)  \nflash plugin for bottle\n\n[Bottle-Hotqueue](http://pypi.python.org/pypi/bottle-hotqueue/)  \nFIFO Queue for Bottle built upon redis\n\n[Macaron](http://nobrin.github.com/macaron/webapp.html)  \nMacaron is an object-relational mapper (ORM) for SQLite.\n\n[Bottle-Memcache](http://pypi.python.org/pypi/bottle-memcache/)  \nMemcache integration for Bottle.\n\n[Bottle-MongoDB](http://pypi.python.org/pypi/bottle-mongodb/)  \nMongoDB integration for Bottle\n\n[Bottle-Redis](http://pypi.python.org/pypi/bottle-redis/)  \nRedis integration for Bottle.\n\n[Bottle-Renderer](http://pypi.python.org/pypi/bottle-renderer/)  \nRenderer plugin for bottle\n\n[Bottle-Servefiles](http://pypi.python.org/pypi/bottle-servefiles/)  \nA reusable app that serves static files for bottle apps\n\n[Bottle-Sqlalchemy](http://pypi.python.org/pypi/bottle-sqlalchemy/)  \nSQLAlchemy integration for Bottle.\n\n[Bottle-Sqlite](http://pypi.python.org/pypi/bottle-sqlite/)  \nSQLite3 database integration for Bottle.\n\n[Bottle-Web2pydal](http://pypi.python.org/pypi/bottle-web2pydal/)  \nWeb2py Dal integration for Bottle.\n\n[Bottle-Werkzeug](http://pypi.python.org/pypi/bottle-werkzeug/)  \nIntegrates the `werkzeug` library (alternative request and response objects, advanced debugging middleware and more).\n\nPlugins listed here are not part of Bottle or the Bottle project, but developed and maintained by third parties.\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/plugins/index.html](https://bottlepy.org/docs/0.12/plugins/index.html)"
- name: load()
  id: api#bottle.load
  summary: Import a module or fetch an object from a module
  belongs_to: API Reference
  description: |-
    `load(target, **namespace)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#load)

    Import a module or fetch an object from a module.

    - `package.module` returns `module` as a module object.
    - `pack.mod:name` returns the module variable `name` from `pack.mod`.
    - `pack.mod:func()` calls `pack.mod.func()` and returns the result.

    The last form accepts not only function calls, but any type of expression. Keyword arguments passed to this function are available as local variables. Example: `import_string('re:compile(x)', x='[a-z]')`
- name: load_app()
  id: api#bottle.load_app
  summary: Load a bottle application from a module and make sure that the import does not affect the current default application, but returns a separate application object
  belongs_to: API Reference
  description: |-
    `load_app(target)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#load_app)

    Load a bottle application from a module and make sure that the import does not affect the current default application, but returns a separate application object. See [`load()`](#bottle.load "bottle.load") for the target parameter.

    `request = `

    A thread-safe instance of [`LocalRequest`](#bottle.LocalRequest "bottle.LocalRequest"). If accessed from within a request callback, this instance always refers to the *current* request (even on a multithreaded server).

    `response = Content-Type: text/html; charset=UTF-8`

    A thread-safe instance of [`LocalResponse`](#bottle.LocalResponse "bottle.LocalResponse"). It is used to change the HTTP response for the *current* request.

    `HTTP_CODES = {300: 'Multiple Choices', 301: 'Moved Permanently', 302: 'Found', 303: 'See Other', 304: 'Not Modified', 305: 'Use Proxy', 306: '(Unused)', 307: 'Temporary Redirect', 100: 'Continue', 101: 'Switching Protocols', 400: 'Bad Request', 401: 'Unauthorized', 402: 'Payment Required', 403: 'Forbidden', 404: 'Not Found', 405: 'Method Not Allowed', 406: 'Not Acceptable', 407: 'Proxy Authentication Required', 408: 'Request Timeout', 409: 'Conflict', 410: 'Gone', 411: 'Length Required', 412: 'Precondition Failed', 413: 'Request Entity Too Large', 414: 'Request-URI Too Long', 415: 'Unsupported Media Type', 416: 'Requested Range Not Satisfiable', 417: 'Expectation Failed', 418: "I'm a teapot", 422: 'Unprocessable Entity', 428: 'Precondition Required', 429: 'Too Many Requests', 431: 'Request Header Fields Too Large', 200: 'OK', 201: 'Created', 202: 'Accepted', 203: 'Non-Authoritative Information', 204: 'No Content', 205: 'Reset Content', 206: 'Partial Content', 500: 'Internal Server Error', 501: 'Not Implemented', 502: 'Bad Gateway', 503: 'Service Unavailable', 504: 'Gateway Timeout', 505: 'HTTP Version Not Supported', 511: 'Network Authentication Required'}`

    A dict to map HTTP status codes (e.g. 404) to phrases (e.g. ‘Not Found’)
- name: LocalRequest
  id: api#bottle.LocalRequest
  summary: A thread-local subclass of BaseRequest with a different set of attributes for each thread
  belongs_to: API Reference
  description: |-
    `class LocalRequest(environ=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#LocalRequest)

    A thread-local subclass of [`BaseRequest`](#bottle.BaseRequest "bottle.BaseRequest") with a different set of attributes for each thread. There is usually only one global instance of this class ([`request`](#bottle.request "bottle.request")). If accessed during a request/response cycle, this instance always refers to the *current* request (even on a multithreaded server).
- name: LocalRequest::bind()
  id: api#bottle.LocalRequest.bind
  summary: Wrap a WSGI environ dictionary
  belongs_to: API Reference
  description: |-
    `bind(environ=None)`

    Wrap a WSGI environ dictionary.

    `environ`

    Thread-local property

    `request = `

    A thread-safe instance of [`LocalRequest`](#bottle.LocalRequest "bottle.LocalRequest"). If accessed from within a request callback, this instance always refers to the *current* request (even on a multithreaded server).

    ## The Response Object

    The [`Response`](#bottle.Response "bottle.Response") class stores the HTTP status code as well as headers and cookies that are to be sent to the client. Similar to [`bottle.request`](#bottle.request "bottle.request") there is a thread-local [`bottle.response`](#bottle.response "bottle.response") instance that can be used to adjust the `current` response. Moreover, you can instantiate [`Response`](#bottle.Response "bottle.Response") and return it from your request handler. In this case, the custom instance overrules the headers and cookies defined in the global one.

    `Response`

    alias of [`BaseResponse`](#bottle.BaseResponse "bottle.BaseResponse")
- name: LocalResponse
  id: api#bottle.LocalResponse
  summary: A thread-local subclass of BaseResponse with a different set of attributes for each thread
  belongs_to: API Reference
  description: |-
    `class LocalResponse(body='', status=None, headers=None, **more_headers)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#LocalResponse)

    A thread-local subclass of [`BaseResponse`](#bottle.BaseResponse "bottle.BaseResponse") with a different set of attributes for each thread. There is usually only one global instance of this class ([`response`](#bottle.response "bottle.response")). Its attributes are used to build the HTTP response at the end of the request/response cycle.

    `body`

    Thread-local property

    The following two classes can be raised as an exception. The most noticeable difference is that bottle invokes error handlers for [`HTTPError`](#bottle.HTTPError "bottle.HTTPError"), but not for [`HTTPResponse`](#bottle.HTTPResponse "bottle.HTTPResponse") or other response types.

    `exception HTTPResponse(body='', status=None, headers=None, **more_headers)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#HTTPResponse)

    `exception HTTPError(status=None, body=None, exception=None, traceback=None, **options)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#HTTPError)

    ## Templates

    All template engines supported by [`bottle`](tutorial#module-bottle "bottle") implement the [`BaseTemplate`](#bottle.BaseTemplate "bottle.BaseTemplate") API. This way it is possible to switch and mix template engines without changing the application code at all.
- name: MultiDict
  id: api#bottle.MultiDict
  summary: This dict stores multiple values per key, but behaves exactly like a normal dict in that it returns only the newest value for any given key
  belongs_to: API Reference
  description: |-
    `class MultiDict(*a, **k)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#MultiDict)

    This dict stores multiple values per key, but behaves exactly like a normal dict in that it returns only the newest value for any given key. There are special methods available to access the full list of values.
- name: MultiDict::append()
  id: api#bottle.MultiDict.append
  summary: Add a new value to the list of values for this key
  belongs_to: API Reference
  description: |-
    `append(key, value)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#MultiDict.append)

    Add a new value to the list of values for this key.
- name: MultiDict::get()
  id: api#bottle.MultiDict.get
  summary: Return the most recent value for a key
  belongs_to: API Reference
  description: |-
    `get(key, default=None, index=-1, type=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#MultiDict.get)

    Return the most recent value for a key.

    [TABLE]
- name: MultiDict::getall()
  id: api#bottle.MultiDict.getall
  summary: Return a (possibly empty) list of values for a key
  belongs_to: API Reference
  description: |-
    `getall(key)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#MultiDict.getall)

    Return a (possibly empty) list of values for a key.
- name: MultiDict::getlist()
  id: api#bottle.MultiDict.getlist
  summary: Return a (possibly empty) list of values for a key
  belongs_to: API Reference
  description: |-
    `getlist(key)`

    Return a (possibly empty) list of values for a key.
- name: MultiDict::getone()
  id: api#bottle.MultiDict.getone
  summary: null
  belongs_to: API Reference
  description: |-
    `getone(key, default=None, index=-1, type=None)`

    Aliases for WTForms to mimic other multi-dict APIs (Django)
- name: MultiDict::replace()
  id: api#bottle.MultiDict.replace
  summary: Replace the list of values with a single value
  belongs_to: API Reference
  description: |-
    `replace(key, value)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#MultiDict.replace)

    Replace the list of values with a single value.
- name: parse_auth()
  id: api#bottle.parse_auth
  summary: null
  belongs_to: API Reference
  description: |-
    `parse_auth(header)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#parse_auth)

    Parse rfc2617 HTTP authentication header string (basic) and return (user,pass) tuple or None
- name: parse_date()
  id: api#bottle.parse_date
  summary: Parse rfc1123, rfc850 and asctime timestamps and return UTC epoch
  belongs_to: API Reference
  description: |-
    `parse_date(ims)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#parse_date)

    Parse rfc1123, rfc850 and asctime timestamps and return UTC epoch.
- name: path_shift()
  id: api#bottle.path_shift
  summary: Shift path fragments from PATH_INFO to SCRIPT_NAME and vice versa
  belongs_to: API Reference
  description: |-
    `path_shift(script_name, path_info, shift=1)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#path_shift)

    Shift path fragments from PATH_INFO to SCRIPT_NAME and vice versa.

    [TABLE]

    ### Data Structures
- name: Plugin
  id: plugindev#bottle.Plugin
  summary: Plugins must be callable or implement apply()
  belongs_to: Plugin Development Guide
  description: |-
    `class Plugin(object)`

    Plugins must be callable or implement [`apply()`](#bottle.Plugin.apply "bottle.Plugin.apply"). If [`apply()`](#bottle.Plugin.apply "bottle.Plugin.apply") is defined, it is always preferred over calling the plugin directly. All other methods and attributes are optional.

    `name`

    Both [`Bottle.uninstall()`](api#bottle.Bottle.uninstall "bottle.Bottle.uninstall") and the `skip` parameter of [`Bottle.route()`](api#bottle.Bottle.route "bottle.Bottle.route") accept a name string to refer to a plugin or plugin type. This works only for plugins that have a name attribute.

    `api`

    The Plugin API is still evolving. This integer attribute tells bottle which version to use. If it is missing, bottle defaults to the first version. The current version is `2`. See [Plugin API changes](#plugin-changelog) for details.
- name: Plugin Development Guide
  id: plugindev
  summary: This guide explains the plugin API and how to write custom plugins
  description: "# Plugin Development Guide\n\nThis guide explains the plugin API and how to write custom plugins. I suggest reading [Plugins](tutorial#plugins) first if you have not done that already. You might also want to have a look at the [List of available Plugins](plugins/index) for some practical examples.\n\nNote\n\nThis is a draft. If you see any errors or find that a specific part is not explained clear enough, please tell the [mailing-list](mailto:bottlepy%40googlegroups.com) or file a [bug report](https://github.com/defnull/bottle/issues).\n\n## How Plugins Work: The Basics\n\nThe plugin API builds on the concept of [decorators](http://docs.python.org/glossary.html#term-decorator). To put it briefly, a plugin is a decorator applied to every single route callback of an application.\n\nOf course, this is just a simplification. Plugins can do a lot more than just decorating route callbacks, but it is a good starting point. Lets have a look at some code:\n\n``` python\nfrom bottle import response, install\nimport time\n\ndef stopwatch(callback):\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        body = callback(*args, **kwargs)\n        end = time.time()\n        response.headers['X-Exec-Time'] = str(end - start)\n        return body\n    return wrapper\n\ninstall(stopwatch)\n```\n\nThis plugin measures the execution time for each request and adds an appropriate `X-Exec-Time` header to the response. As you can see, the plugin returns a wrapper and the wrapper calls the original callback recursively. This is how decorators usually work.\n\nThe last line tells Bottle to install the plugin to the default application. This causes the plugin to be automatically applied to all routes of that application. In other words, `stopwatch()` is called once for each route callback and the return value is used as a replacement for the original callback.\n\nPlugins are applied on demand, that is, as soon as a route is requested for the first time. For this to work properly in multi-threaded environments, the plugin should be thread-safe. This is not a problem most of the time, but keep it in mind.\n\nOnce all plugins are applied to a route, the wrapped callback is cached and subsequent requests are handled by the cached version directly. This means that a plugin is usually applied only once to a specific route. That cache, however, is cleared every time the list of installed plugins changes. Your plugin should be able to decorate the same route more than once.\n\nThe decorator API is quite limited, though. You don’t know anything about the route being decorated or the associated application object and have no way to efficiently store data that is shared among all routes. But fear not! Plugins are not limited to just decorator functions. Bottle accepts anything as a plugin as long as it is callable or implements an extended API. This API is described below and gives you a lot of control over the whole process.\n\n## Plugin API\n\n[`Plugin`](#bottle.Plugin \"bottle.Plugin\") is not a real class (you cannot import it from [`bottle`](tutorial#module-bottle \"bottle\")) but an interface that plugins are expected to implement. Bottle accepts any object of any type as a plugin, as long as it conforms to the following API.\n\n`class Plugin(object)`  \nPlugins must be callable or implement [`apply()`](#bottle.Plugin.apply \"bottle.Plugin.apply\"). If [`apply()`](#bottle.Plugin.apply \"bottle.Plugin.apply\") is defined, it is always preferred over calling the plugin directly. All other methods and attributes are optional.\n\n`name`  \nBoth [`Bottle.uninstall()`](api#bottle.Bottle.uninstall \"bottle.Bottle.uninstall\") and the `skip` parameter of [`Bottle.route()`](api#bottle.Bottle.route \"bottle.Bottle.route\") accept a name string to refer to a plugin or plugin type. This works only for plugins that have a name attribute.\n\n`api`  \nThe Plugin API is still evolving. This integer attribute tells bottle which version to use. If it is missing, bottle defaults to the first version. The current version is `2`. See [Plugin API changes](#plugin-changelog) for details.\n\n`setup(self, app)`  \nCalled as soon as the plugin is installed to an application (see [`Bottle.install()`](api#bottle.Bottle.install \"bottle.Bottle.install\")). The only parameter is the associated application object.\n\n`__call__(self, callback)`  \nAs long as [`apply()`](#bottle.Plugin.apply \"bottle.Plugin.apply\") is not defined, the plugin itself is used as a decorator and applied directly to each route callback. The only parameter is the callback to decorate. Whatever is returned by this method replaces the original callback. If there is no need to wrap or replace a given callback, just return the unmodified callback parameter.\n\n`apply(self, callback, route)`  \nIf defined, this method is used in favor of [`__call__()`](#bottle.Plugin.__call__ \"bottle.Plugin.__call__\") to decorate route callbacks. The additional `route` parameter is an instance of [`Route`](api#bottle.Route \"bottle.Route\") and provides a lot of meta-information and context for that route. See [The Route Context](#route-context) for details.\n\n`close(self)`  \nCalled immediately before the plugin is uninstalled or the application is closed (see [`Bottle.uninstall()`](api#bottle.Bottle.uninstall \"bottle.Bottle.uninstall\") or [`Bottle.close()`](api#bottle.Bottle.close \"bottle.Bottle.close\")).\n\nBoth [`Plugin.setup()`](#bottle.Plugin.setup \"bottle.Plugin.setup\") and [`Plugin.close()`](#bottle.Plugin.close \"bottle.Plugin.close\") are *not* called for plugins that are applied directly to a route via the [`Bottle.route()`](api#bottle.Bottle.route \"bottle.Bottle.route\") decorator, but only for plugins installed to an application.\n\n### Plugin API changes\n\nThe Plugin API is still evolving and changed with Bottle 0.10 to address certain issues with the route context dictionary. To ensure backwards compatibility with 0.9 Plugins, we added an optional [`Plugin.api`](#bottle.Plugin.api \"bottle.Plugin.api\") attribute to tell bottle which API to use. The API differences are summarized here.\n\n- **Bottle 0.9 API 1** ([`Plugin.api`](#bottle.Plugin.api \"bottle.Plugin.api\") not present)\n  - Original Plugin API as described in the 0.9 docs.\n- **Bottle 0.10 API 2** ([`Plugin.api`](#bottle.Plugin.api \"bottle.Plugin.api\") equals 2)\n  - The `context` parameter of the [`Plugin.apply()`](#bottle.Plugin.apply \"bottle.Plugin.apply\") method is now an instance of [`Route`](api#bottle.Route \"bottle.Route\") instead of a context dictionary.\n\n## The Route Context\n\nThe [`Route`](api#bottle.Route \"bottle.Route\") instance passed to [`Plugin.apply()`](#bottle.Plugin.apply \"bottle.Plugin.apply\") provides detailed informations about the associated route. The most important attributes are summarized here:\n\n| Attribute | Description                                                                                                                                                                                                |\n|-----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| app       | The application object this route is installed to.                                                                                                                                                         |\n| rule      | The rule string (e.g. `/wiki/:page`).                                                                                                                                                                      |\n| method    | The HTTP method as a string (e.g. `GET`).                                                                                                                                                                  |\n| callback  | The original callback with no plugins applied. Useful for introspection.                                                                                                                                   |\n| name      | The name of the route (if specified) or `None`.                                                                                                                                                            |\n| plugins   | A list of route-specific plugins. These are applied in addition to application-wide plugins. (see [`Bottle.route()`](api#bottle.Bottle.route \"bottle.Bottle.route\")).                                      |\n| skiplist  | A list of plugins to not apply to this route (again, see [`Bottle.route()`](api#bottle.Bottle.route \"bottle.Bottle.route\")).                                                                               |\n| config    | Additional keyword arguments passed to the [`Bottle.route()`](api#bottle.Bottle.route \"bottle.Bottle.route\") decorator are stored in this dictionary. Used for route-specific configuration and meta-data. |\n\nFor your plugin, [`Route.config`](api#bottle.Route.config \"bottle.Route.config\") is probably the most important attribute. Keep in mind that this dictionary is local to the route, but shared between all plugins. It is always a good idea to add a unique prefix or, if your plugin needs a lot of configuration, store it in a separate namespace within the `config` dictionary. This helps to avoid naming collisions between plugins.\n\n### Changing the [`Route`](api#bottle.Route \"bottle.Route\") object\n\nWhile some [`Route`](api#bottle.Route \"bottle.Route\") attributes are mutable, changes may have unwanted effects on other plugins. It is most likely a bad idea to monkey-patch a broken route instead of providing a helpful error message and let the user fix the problem.\n\nIn some rare cases, however, it might be justifiable to break this rule. After you made your changes to the [`Route`](api#bottle.Route \"bottle.Route\") instance, raise `RouteReset` as an exception. This removes the current route from the cache and causes all plugins to be re-applied. The router is not updated, however. Changes to `rule` or `method` values have no effect on the router, but only on plugins. This may change in the future, though.\n\n## Runtime optimizations\n\nOnce all plugins are applied to a route, the wrapped route callback is cached to speed up subsequent requests. If the behavior of your plugin depends on configuration, and you want to be able to change that configuration at runtime, you need to read the configuration on each request. Easy enough.\n\nFor performance reasons, however, it might be worthwhile to choose a different wrapper based on current needs, work with closures, or enable or disable a plugin at runtime. Let’s take the built-in HooksPlugin as an example: If no hooks are installed, the plugin removes itself from all affected routes and has virtaully no overhead. As soon as you install the first hook, the plugin activates itself and takes effect again.\n\nTo achieve this, you need control over the callback cache: [`Route.reset()`](api#bottle.Route.reset \"bottle.Route.reset\") clears the cache for a single route and [`Bottle.reset()`](api#bottle.Bottle.reset \"bottle.Bottle.reset\") clears all caches for all routes of an application at once. On the next request, all plugins are re-applied to the route as if it were requested for the first time.\n\nBoth methods won’t affect the current request if called from within a route callback, of cause. To force a restart of the current request, raise `RouteReset` as an exception.\n\n## Plugin Example: SQLitePlugin\n\nThis plugin provides an sqlite3 database connection handle as an additional keyword argument to wrapped callbacks, but only if the callback expects it. If not, the route is ignored and no overhead is added. The wrapper does not affect the return value, but handles plugin-related exceptions properly. [`Plugin.setup()`](#bottle.Plugin.setup \"bottle.Plugin.setup\") is used to inspect the application and search for conflicting plugins.\n\n``` python\nimport sqlite3\nimport inspect\n\nclass SQLitePlugin(object):\n    ''' This plugin passes an sqlite3 database handle to route callbacks\n    that accept a `db` keyword argument. If a callback does not expect\n    such a parameter, no connection is made. You can override the database\n    settings on a per-route basis. '''\n\n    name = 'sqlite'\n    api = 2\n\n    def __init__(self, dbfile=':memory:', autocommit=True, dictrows=True,\n                 keyword='db'):\n         self.dbfile = dbfile\n         self.autocommit = autocommit\n         self.dictrows = dictrows\n         self.keyword = keyword\n\n    def setup(self, app):\n        ''' Make sure that other installed plugins don't affect the same\n            keyword argument.'''\n        for other in app.plugins:\n            if not isinstance(other, SQLitePlugin): continue\n            if other.keyword == self.keyword:\n                raise PluginError(\"Found another sqlite plugin with \"\\\n                \"conflicting settings (non-unique keyword).\")\n\n    def apply(self, callback, context):\n        # Override global configuration with route-specific values.\n        conf = context.config.get('sqlite') or {}\n        dbfile = conf.get('dbfile', self.dbfile)\n        autocommit = conf.get('autocommit', self.autocommit)\n        dictrows = conf.get('dictrows', self.dictrows)\n        keyword = conf.get('keyword', self.keyword)\n\n        # Test if the original callback accepts a 'db' keyword.\n        # Ignore it if it does not need a database handle.\n        args = inspect.getargspec(context.callback)[0]\n        if keyword not in args:\n            return callback\n\n        def wrapper(*args, **kwargs):\n            # Connect to the database\n            db = sqlite3.connect(dbfile)\n            # This enables column access by name: row['column_name']\n            if dictrows: db.row_factory = sqlite3.Row\n            # Add the connection handle as a keyword argument.\n            kwargs[keyword] = db\n\n            try:\n                rv = callback(*args, **kwargs)\n                if autocommit: db.commit()\n            except sqlite3.IntegrityError, e:\n                db.rollback()\n                raise HTTPError(500, \"Database Error\", e)\n            finally:\n                db.close()\n            return rv\n\n        # Replace the route callback with the wrapped one.\n        return wrapper\n```\n\nThis plugin is actually useful and very similar to the version bundled with Bottle. Not bad for less than 60 lines of code, don’t you think? Here is a usage example:\n\n``` python\nsqlite = SQLitePlugin(dbfile='/tmp/test.db')\nbottle.install(sqlite)\n\n@route('/show/:page')\ndef show(page, db):\n    row = db.execute('SELECT * from pages where name=?', page).fetchone()\n    if row:\n        return template('showpage', page=row)\n    return HTTPError(404, \"Page not found\")\n\n@route('/static/:fname#.*#')\ndef static(fname):\n    return static_file(fname, root='/some/path')\n\n@route('/admin/set/:db#[a-zA-Z]+#', skip=[sqlite])\ndef change_dbfile(db):\n    sqlite.dbfile = '/tmp/%s.db' % db\n    return \"Switched DB to %s.db\" % db\n```\n\nThe first route needs a database connection and tells the plugin to create a handle by requesting a `db` keyword argument. The second route does not need a database and is therefore ignored by the plugin. The third route does expect a ‘db’ keyword argument, but explicitly skips the sqlite plugin. This way the argument is not overruled by the plugin and still contains the value of the same-named url argument.\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/plugindev.html](https://bottlepy.org/docs/0.12/plugindev.html)"
- name: Plugin::apply()
  id: plugindev#bottle.Plugin.apply
  summary: If defined, this method is used in favor of __call__() to decorate route callbacks
  belongs_to: Plugin Development Guide
  description: |-
    `apply(self, callback, route)`

    If defined, this method is used in favor of [`__call__()`](#bottle.Plugin.__call__ "bottle.Plugin.__call__") to decorate route callbacks. The additional `route` parameter is an instance of [`Route`](api#bottle.Route "bottle.Route") and provides a lot of meta-information and context for that route. See [The Route Context](#route-context) for details.
- name: Plugin::close()
  id: plugindev#bottle.Plugin.close
  summary: Called immediately before the plugin is uninstalled or the application is closed (see Bottle.uninstall() or Bottle.close())
  belongs_to: Plugin Development Guide
  description: "`close(self)`\n\nCalled immediately before the plugin is uninstalled or the application is closed (see [`Bottle.uninstall()`](api#bottle.Bottle.uninstall \"bottle.Bottle.uninstall\") or [`Bottle.close()`](api#bottle.Bottle.close \"bottle.Bottle.close\")).\n\nBoth [`Plugin.setup()`](#bottle.Plugin.setup \"bottle.Plugin.setup\") and [`Plugin.close()`](#bottle.Plugin.close \"bottle.Plugin.close\") are *not* called for plugins that are applied directly to a route via the [`Bottle.route()`](api#bottle.Bottle.route \"bottle.Bottle.route\") decorator, but only for plugins installed to an application.\n\n### Plugin API changes\n\nThe Plugin API is still evolving and changed with Bottle 0.10 to address certain issues with the route context dictionary. To ensure backwards compatibility with 0.9 Plugins, we added an optional [`Plugin.api`](#bottle.Plugin.api \"bottle.Plugin.api\") attribute to tell bottle which API to use. The API differences are summarized here.\n\n- **Bottle 0.9 API 1** ([`Plugin.api`](#bottle.Plugin.api \"bottle.Plugin.api\") not present)\n  - Original Plugin API as described in the 0.9 docs.\n- **Bottle 0.10 API 2** ([`Plugin.api`](#bottle.Plugin.api \"bottle.Plugin.api\") equals 2)\n  - The `context` parameter of the [`Plugin.apply()`](#bottle.Plugin.apply \"bottle.Plugin.apply\") method is now an instance of [`Route`](api#bottle.Route \"bottle.Route\") instead of a context dictionary.\n\n## The Route Context\n\nThe [`Route`](api#bottle.Route \"bottle.Route\") instance passed to [`Plugin.apply()`](#bottle.Plugin.apply \"bottle.Plugin.apply\") provides detailed informations about the associated route. The most important attributes are summarized here:\n\n| Attribute | Description                                                                                                                                                                                                |\n|-----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| app       | The application object this route is installed to.                                                                                                                                                         |\n| rule      | The rule string (e.g. `/wiki/:page`).                                                                                                                                                                      |\n| method    | The HTTP method as a string (e.g. `GET`).                                                                                                                                                                  |\n| callback  | The original callback with no plugins applied. Useful for introspection.                                                                                                                                   |\n| name      | The name of the route (if specified) or `None`.                                                                                                                                                            |\n| plugins   | A list of route-specific plugins. These are applied in addition to application-wide plugins. (see [`Bottle.route()`](api#bottle.Bottle.route \"bottle.Bottle.route\")).                                      |\n| skiplist  | A list of plugins to not apply to this route (again, see [`Bottle.route()`](api#bottle.Bottle.route \"bottle.Bottle.route\")).                                                                               |\n| config    | Additional keyword arguments passed to the [`Bottle.route()`](api#bottle.Bottle.route \"bottle.Bottle.route\") decorator are stored in this dictionary. Used for route-specific configuration and meta-data. |\n\nFor your plugin, [`Route.config`](api#bottle.Route.config \"bottle.Route.config\") is probably the most important attribute. Keep in mind that this dictionary is local to the route, but shared between all plugins. It is always a good idea to add a unique prefix or, if your plugin needs a lot of configuration, store it in a separate namespace within the `config` dictionary. This helps to avoid naming collisions between plugins.\n\n### Changing the [`Route`](api#bottle.Route \"bottle.Route\") object\n\nWhile some [`Route`](api#bottle.Route \"bottle.Route\") attributes are mutable, changes may have unwanted effects on other plugins. It is most likely a bad idea to monkey-patch a broken route instead of providing a helpful error message and let the user fix the problem.\n\nIn some rare cases, however, it might be justifiable to break this rule. After you made your changes to the [`Route`](api#bottle.Route \"bottle.Route\") instance, raise `RouteReset` as an exception. This removes the current route from the cache and causes all plugins to be re-applied. The router is not updated, however. Changes to `rule` or `method` values have no effect on the router, but only on plugins. This may change in the future, though.\n\n## Runtime optimizations\n\nOnce all plugins are applied to a route, the wrapped route callback is cached to speed up subsequent requests. If the behavior of your plugin depends on configuration, and you want to be able to change that configuration at runtime, you need to read the configuration on each request. Easy enough.\n\nFor performance reasons, however, it might be worthwhile to choose a different wrapper based on current needs, work with closures, or enable or disable a plugin at runtime. Let’s take the built-in HooksPlugin as an example: If no hooks are installed, the plugin removes itself from all affected routes and has virtaully no overhead. As soon as you install the first hook, the plugin activates itself and takes effect again.\n\nTo achieve this, you need control over the callback cache: [`Route.reset()`](api#bottle.Route.reset \"bottle.Route.reset\") clears the cache for a single route and [`Bottle.reset()`](api#bottle.Bottle.reset \"bottle.Bottle.reset\") clears all caches for all routes of an application at once. On the next request, all plugins are re-applied to the route as if it were requested for the first time.\n\nBoth methods won’t affect the current request if called from within a route callback, of cause. To force a restart of the current request, raise `RouteReset` as an exception.\n\n## Plugin Example: SQLitePlugin\n\nThis plugin provides an sqlite3 database connection handle as an additional keyword argument to wrapped callbacks, but only if the callback expects it. If not, the route is ignored and no overhead is added. The wrapper does not affect the return value, but handles plugin-related exceptions properly. [`Plugin.setup()`](#bottle.Plugin.setup \"bottle.Plugin.setup\") is used to inspect the application and search for conflicting plugins.\n\n``` python\nimport sqlite3\nimport inspect\n\nclass SQLitePlugin(object):\n    ''' This plugin passes an sqlite3 database handle to route callbacks\n    that accept a `db` keyword argument. If a callback does not expect\n    such a parameter, no connection is made. You can override the database\n    settings on a per-route basis. '''\n\n    name = 'sqlite'\n    api = 2\n\n    def __init__(self, dbfile=':memory:', autocommit=True, dictrows=True,\n                 keyword='db'):\n         self.dbfile = dbfile\n         self.autocommit = autocommit\n         self.dictrows = dictrows\n         self.keyword = keyword\n\n    def setup(self, app):\n        ''' Make sure that other installed plugins don't affect the same\n            keyword argument.'''\n        for other in app.plugins:\n            if not isinstance(other, SQLitePlugin): continue\n            if other.keyword == self.keyword:\n                raise PluginError(\"Found another sqlite plugin with \"\\\n                \"conflicting settings (non-unique keyword).\")\n\n    def apply(self, callback, context):\n        # Override global configuration with route-specific values.\n        conf = context.config.get('sqlite') or {}\n        dbfile = conf.get('dbfile', self.dbfile)\n        autocommit = conf.get('autocommit', self.autocommit)\n        dictrows = conf.get('dictrows', self.dictrows)\n        keyword = conf.get('keyword', self.keyword)\n\n        # Test if the original callback accepts a 'db' keyword.\n        # Ignore it if it does not need a database handle.\n        args = inspect.getargspec(context.callback)[0]\n        if keyword not in args:\n            return callback\n\n        def wrapper(*args, **kwargs):\n            # Connect to the database\n            db = sqlite3.connect(dbfile)\n            # This enables column access by name: row['column_name']\n            if dictrows: db.row_factory = sqlite3.Row\n            # Add the connection handle as a keyword argument.\n            kwargs[keyword] = db\n\n            try:\n                rv = callback(*args, **kwargs)\n                if autocommit: db.commit()\n            except sqlite3.IntegrityError, e:\n                db.rollback()\n                raise HTTPError(500, \"Database Error\", e)\n            finally:\n                db.close()\n            return rv\n\n        # Replace the route callback with the wrapped one.\n        return wrapper\n```\n\nThis plugin is actually useful and very similar to the version bundled with Bottle. Not bad for less than 60 lines of code, don’t you think? Here is a usage example:\n\n``` python\nsqlite = SQLitePlugin(dbfile='/tmp/test.db')\nbottle.install(sqlite)\n\n@route('/show/:page')\ndef show(page, db):\n    row = db.execute('SELECT * from pages where name=?', page).fetchone()\n    if row:\n        return template('showpage', page=row)\n    return HTTPError(404, \"Page not found\")\n\n@route('/static/:fname#.*#')\ndef static(fname):\n    return static_file(fname, root='/some/path')\n\n@route('/admin/set/:db#[a-zA-Z]+#', skip=[sqlite])\ndef change_dbfile(db):\n    sqlite.dbfile = '/tmp/%s.db' % db\n    return \"Switched DB to %s.db\" % db\n```\n\nThe first route needs a database connection and tells the plugin to create a handle by requesting a `db` keyword argument. The second route does not need a database and is therefore ignored by the plugin. The third route does expect a ‘db’ keyword argument, but explicitly skips the sqlite plugin. This way the argument is not overruled by the plugin and still contains the value of the same-named url argument.\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/plugindev.html](https://bottlepy.org/docs/0.12/plugindev.html)"
- name: Plugin::setup()
  id: plugindev#bottle.Plugin.setup
  summary: Called as soon as the plugin is installed to an application (see Bottle.install())
  belongs_to: Plugin Development Guide
  description: |-
    `setup(self, app)`

    Called as soon as the plugin is installed to an application (see [`Bottle.install()`](api#bottle.Bottle.install "bottle.Bottle.install")). The only parameter is the associated application object.
- name: Plugin::__call__()
  id: plugindev#bottle.Plugin.__call__
  summary: As long as apply() is not defined, the plugin itself is used as a decorator and applied directly to each route callback
  belongs_to: Plugin Development Guide
  description: |-
    `__call__(self, callback)`

    As long as [`apply()`](#bottle.Plugin.apply "bottle.Plugin.apply") is not defined, the plugin itself is used as a decorator and applied directly to each route callback. The only parameter is the callback to decorate. Whatever is returned by this method replaces the original callback. If there is no need to wrap or replace a given callback, just return the unmodified callback parameter.
- name: Primer to Asynchronous Applications
  id: async
  summary: Asynchronous design patterns don’t mix well with the synchronous nature of WSGI
  description: "# Primer to Asynchronous Applications\n\nAsynchronous design patterns don’t mix well with the synchronous nature of [WSGI](http://www.python.org/dev/peps/pep-3333/). This is why most asynchronous frameworks (tornado, twisted, ...) implement a specialized API to expose their asynchronous features. Bottle is a WSGI framework and shares the synchronous nature of WSGI, but thanks to the awesome [gevent project](http://www.gevent.org/), it is still possible to write asynchronous applications with bottle. This article documents the usage of Bottle with Asynchronous WSGI.\n\n## The Limits of Synchronous WSGI\n\nBriefly worded, the [WSGI specification (pep 3333)](http://www.python.org/dev/peps/pep-3333/) defines a request/response circle as follows: The application callable is invoked once for each request and must return a body iterator. The server then iterates over the body and writes each chunk to the socket. As soon as the body iterator is exhausted, the client connection is closed.\n\nSimple enough, but there is a snag: All this happens synchronously. If your application needs to wait for data (IO, sockets, databases, ...), it must either yield empty strings (busy wait) or block the current thread. Both solutions occupy the handling thread and prevent it from answering new requests. There is consequently only one ongoing request per thread.\n\nMost servers limit the number of threads to avoid their relatively high overhead. Pools of 20 or less threads are common. As soon as all threads are occupied, any new connection is stalled. The server is effectively dead for everyone else. If you want to implement a chat that uses long-polling ajax requests to get real-time updates, you’d reach the limited at 20 concurrent connections. That’s a pretty small chat.\n\n## Greenlets to the rescue\n\nMost servers limit the size of their worker pools to a relatively low number of concurrent threads, due to the high overhead involved in switching between and creating new threads. While threads are cheap compared to processes (forks), they are still expensive to create for each new connection.\n\nThe [gevent](http://www.gevent.org/) module adds *greenlets* to the mix. Greenlets behave similar to traditional threads, but are very cheap to create. A gevent-based server can spawn thousands of greenlets (one for each connection) with almost no overhead. Blocking individual greenlets has no impact on the servers ability to accept new requests. The number of concurrent connections is virtually unlimited.\n\nThis makes creating asynchronous applications incredibly easy, because they look and feel like synchronous applications. A gevent-based server is actually not asynchronous, but massively multi-threaded. Here is an example:\n\n``` python\nfrom gevent import monkey; monkey.patch_all()\n\nfrom time import sleep\nfrom bottle import route, run\n\n@route('/stream')\ndef stream():\n    yield 'START'\n    sleep(3)\n    yield 'MIDDLE'\n    sleep(5)\n    yield 'END'\n\nrun(host='0.0.0.0', port=8080, server='gevent')\n```\n\nThe first line is important. It causes gevent to monkey-patch most of Python’s blocking APIs to not block the current thread, but pass the CPU to the next greenlet instead. It actually replaces Python’s threading with gevent-based pseudo-threads. This is why you can still use `time.sleep()` which would normally block the whole thread. If you don’t feel comfortable with monkey-patching python built-ins, you can use the corresponding gevent functions (`gevent.sleep()` in this case).\n\nIf you run this script and point your browser to `http://localhost:8080/stream`, you should see `START`, `MIDDLE`, and `END` show up one by one (rather than waiting 8 seconds to see them all at once). It works exactly as with normal threads, but now your server can handle thousands of concurrent requests without any problems.\n\nNote\n\nSome browsers buffer a certain amount of data before they start rendering a page. You might need to yield more than a few bytes to see an effect in these browsers. Additionally, many browsers have a limit of one concurrent connection per URL. If this is the case, you can use a second browser or a benchmark tool (e.g. `ab` or `httperf`) to measure performance.\n\n## Event Callbacks\n\nA very common design pattern in asynchronous frameworks (including tornado, twisted, node.js and friends) is to use non-blocking APIs and bind callbacks to asynchronous events. The socket object is kept open until it is closed explicitly to allow callbacks to write to the socket at a later point. Here is an example based on the [tornado library](http://www.tornadoweb.org/documentation#non-blocking-asynchronous-requests):\n\n``` python\nclass MainHandler(tornado.web.RequestHandler):\n    @tornado.web.asynchronous\n    def get(self):\n        worker = SomeAsyncWorker()\n        worker.on_data(lambda chunk: self.write(chunk))\n        worker.on_finish(lambda: self.finish())\n```\n\nThe main benefit is that the request handler terminates early. The handling thread can move on and accept new requests while the callbacks continue to write to sockets of previous requests. This is how these frameworks manage to process a lot of concurrent requests with only a small number of OS threads.\n\nWith Gevent+WSGI, things are different: First, terminating early has no benefit because we have an unlimited pool of (pseudo)threads to accept new connections. Second, we cannot terminate early because that would close the socket (as required by WSGI). Third, we must return an iterable to conform to WSGI.\n\nIn order to conform to the WSGI standard, all we have to do is to return a body iterable that we can write to asynchronously. With the help of [gevent.queue](http://www.gevent.org/gevent.queue.html), we can *simulate* a detached socket and rewrite the previous example as follows:\n\n``` python\n@route('/fetch')\ndef fetch():\n    body = gevent.queue.Queue()\n    worker = SomeAsyncWorker()\n    worker.on_data(body.put)\n    worker.on_finish(lambda: body.put(StopIteration))\n    worker.start()\n    return body\n```\n\nFrom the server perspective, the queue object is iterable. It blocks if empty and stops as soon as it reaches `StopIteration`. This conforms to WSGI. On the application side, the queue object behaves like a non-blocking socket. You can write to it at any time, pass it around and even start a new (pseudo)thread that writes to it asynchronously. This is how long-polling is implemented most of the time.\n\n## Finally: WebSockets\n\nLets forget about the low-level details for a while and speak about WebSockets. Since you are reading this article, you probably know what WebSockets are: A bidirectional communication channel between a browser (client) and a web application (server).\n\nThankfully the [gevent-websocket](http://pypi.python.org/pypi/gevent-websocket/) package does all the hard work for us. Here is a simple WebSocket endpoint that receives messages and just sends them back to the client:\n\n``` python\nfrom bottle import request, Bottle, abort\napp = Bottle()\n\n@app.route('/websocket')\ndef handle_websocket():\n    wsock = request.environ.get('wsgi.websocket')\n    if not wsock:\n        abort(400, 'Expected WebSocket request.')\n\n    while True:\n        try:\n            message = wsock.receive()\n            wsock.send(\"Your message was: %r\" % message)\n        except WebSocketError:\n            break\n\nfrom gevent.pywsgi import WSGIServer\nfrom geventwebsocket import WebSocketHandler, WebSocketError\nserver = WSGIServer((\"0.0.0.0\", 8080), app,\n                    handler_class=WebSocketHandler)\nserver.serve_forever()\n```\n\nThe while-loop runs until the client closes the connection. You get the idea :)\n\nThe client-site JavaScript API is really straight forward, too:\n\n``` python\n<!DOCTYPE html>\n<html>\n<head>\n  <script type=\"text/javascript\">\n    var ws = new WebSocket(\"ws://example.com:8080/websocket\");\n    ws.onopen = function() {\n        ws.send(\"Hello, world\");\n    };\n    ws.onmessage = function (evt) {\n        alert(evt.data);\n    };\n  </script>\n</head>\n</html>\n```\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/async.html](https://bottlepy.org/docs/0.12/async.html)"
- name: rebase()
  id: stpl#stpl.rebase
  summary: Mark the current template to be later included into a different template
  belongs_to: SimpleTemplate Engine
  description: |-
    `rebase(name, **variables)`

    Mark the current template to be later included into a different template. After the current template is rendered, its resulting text is stored in a variable named `base` and passed to the base-template, which is then rendered. This can be used to `wrap` a template with surrounding text, or simulate the inheritance feature found in other template engines:

    ``` html
    % rebase('base.tpl', title='Page Title')
    <p>Page Content ...</p>
    ```

    This can be combined with the following `base.tpl`:

    ``` html
    <html>
    <head>
      <title>{{title or 'No title'}}</title>
    </head>
    <body>
      {{base}}
    </body>
    </html>
    ```

    Accessing undefined variables in a template raises `NameError` and stops rendering immediately. This is standard python behavior and nothing new, but vanilla python lacks an easy way to check the availability of a variable. This quickly gets annoying if you want to support flexible inputs or use the same template in different situations. These functions may help:
- name: Recipes
  id: recipes
  summary: This is a collection of code snippets and examples for common use cases
  description: "# Recipes\n\nThis is a collection of code snippets and examples for common use cases.\n\n## Keeping track of Sessions\n\nThere is no built-in support for sessions because there is no *right* way to do it (in a micro framework). Depending on requirements and environment you could use [beaker](http://beaker.groovie.org/) middleware with a fitting backend or implement it yourself. Here is an example for beaker sessions with a file-based backend:\n\n``` python\nimport bottle\nfrom beaker.middleware import SessionMiddleware\n\nsession_opts = {\n    'session.type': 'file',\n    'session.cookie_expires': 300,\n    'session.data_dir': './data',\n    'session.auto': True\n}\napp = SessionMiddleware(bottle.app(), session_opts)\n\n@bottle.route('/test')\ndef test():\n  s = bottle.request.environ.get('beaker.session')\n  s['test'] = s.get('test',0) + 1\n  s.save()\n  return 'Test counter: %d' % s['test']\n\nbottle.run(app=app)\n```\n\n## Debugging with Style: Debugging Middleware\n\nBottle catches all Exceptions raised in your app code to prevent your WSGI server from crashing. If the built-in [`debug()`](api#bottle.debug \"bottle.debug\") mode is not enough and you need exceptions to propagate to a debugging middleware, you can turn off this behaviour:\n\n``` python\nimport bottle\napp = bottle.app()\napp.catchall = False #Now most exceptions are re-raised within bottle.\nmyapp = DebuggingMiddleware(app) #Replace this with a middleware of your choice (see below)\nbottle.run(app=myapp)\n```\n\nNow, bottle only catches its own exceptions ([`HTTPError`](api#bottle.HTTPError \"bottle.HTTPError\"), [`HTTPResponse`](api#bottle.HTTPResponse \"bottle.HTTPResponse\") and [`BottleException`](api#bottle.BottleException \"bottle.BottleException\")) and your middleware can handle the rest.\n\nThe [werkzeug](http://werkzeug.pocoo.org/documentation/dev/debug.html) and [paste](http://pythonpaste.org/modules/evalexception.html) libraries both ship with very powerful debugging WSGI middleware. Look at [`werkzeug.debug.DebuggedApplication`](http://werkzeug.pocoo.org/docs/debug/#werkzeug.debug.DebuggedApplication \"(in Werkzeug v0.12-dev)\") for [werkzeug](http://werkzeug.pocoo.org/documentation/dev/debug.html) and `paste.evalexception.middleware.EvalException` for [paste](http://pythonpaste.org/modules/evalexception.html). They both allow you do inspect the stack and even execute python code within the stack context, so **do not use them in production**.\n\n## Unit-Testing Bottle Applications\n\nUnit-testing is usually performed against methods defined in your web application without running a WSGI environment.\n\nA simple example using [Nose](http://readthedocs.org/docs/nose):\n\n``` python\nimport bottle\n\n@bottle.route('/')\ndef index():\n    return 'Hi!'\n\nif __name__ == '__main__':\n    bottle.run()\n```\n\nTest script:\n\n``` python\nimport mywebapp\n\ndef test_webapp_index():\n    assert mywebapp.index() == 'Hi!'\n```\n\nIn the example the Bottle route() method is never executed - only index() is tested.\n\n## Functional Testing Bottle Applications\n\nAny HTTP-based testing system can be used with a running WSGI server, but some testing frameworks work more intimately with WSGI, and provide the ability the call WSGI applications in a controlled environment, with tracebacks and full use of debugging tools. [Testing tools for WSGI](http://www.wsgi.org/en/latest/testing.html) is a good starting point.\n\nExample using [WebTest](http://webtest.pythonpaste.org/) and [Nose](http://readthedocs.org/docs/nose):\n\n``` python\nfrom webtest import TestApp\nimport mywebapp\n\ndef test_functional_login_logout():\n    app = TestApp(mywebapp.app)\n\n    app.post('/login', {'user': 'foo', 'pass': 'bar'}) # log in and get a cookie\n\n    assert app.get('/admin').status == '200 OK'        # fetch a page successfully\n\n    app.get('/logout')                                 # log out\n    app.reset()                                        # drop the cookie\n\n    # fetch the same page, unsuccessfully\n    assert app.get('/admin').status == '401 Unauthorized'\n```\n\n## Embedding other WSGI Apps\n\nThis is not the recommend way (you should use a middleware in front of bottle to do this) but you can call other WSGI applications from within your bottle app and let bottle act as a pseudo-middleware. Here is an example:\n\n``` python\nfrom bottle import request, response, route\nsubproject = SomeWSGIApplication()\n\n@route('/subproject/:subpath#.*#', method='ANY')\ndef call_wsgi(subpath):\n    new_environ = request.environ.copy()\n    new_environ['SCRIPT_NAME'] = new_environ.get('SCRIPT_NAME','') + '/subproject'\n    new_environ['PATH_INFO'] = '/' + subpath\n    def start_response(status, headerlist):\n        response.status = int(status.split()[0])\n        for key, value in headerlist:\n            response.add_header(key, value)\n    return app(new_environ, start_response)\n```\n\nAgain, this is not the recommend way to implement subprojects. It is only here because many people asked for this and to show how bottle maps to WSGI.\n\n## Ignore trailing slashes\n\nFor Bottle, `/example` and `/example/` are two different routes [\\[1\\]](#id3). To treat both URLs the same you can add two `@route` decorators:\n\n``` python\n@route('/test')\n@route('/test/')\ndef test(): return 'Slash? no?'\n```\n\nor add a WSGI middleware that strips trailing slashes from all URLs:\n\n``` python\nclass StripPathMiddleware(object):\n  def __init__(self, app):\n    self.app = app\n  def __call__(self, e, h):\n    e['PATH_INFO'] = e['PATH_INFO'].rstrip('/')\n    return self.app(e,h)\n\napp = bottle.app()\nmyapp = StripPathMiddleware(app)\nbottle.run(app=myapp)\n```\n\n#### Footnotes\n\n|               |                                                                                                      |\n|---------------|------------------------------------------------------------------------------------------------------|\n| [\\[1\\]](#id2) | Because they are. See \\<[http://www.ietf.org/rfc/rfc3986.txt](http://www.ietf.org/rfc/rfc3986.txt)\\> |\n\n## Keep-alive requests\n\nNote\n\nFor a more detailed explanation, see [Primer to Asynchronous Applications](async).\n\nSeveral “push” mechanisms like XHR multipart need the ability to write response data without closing the connection in conjunction with the response header “Connection: keep-alive”. WSGI does not easily lend itself to this behavior, but it is still possible to do so in Bottle by using the [gevent](http://www.gevent.org/) async framework. Here is a sample that works with either the [gevent](http://www.gevent.org/) HTTP server or the [paste](http://pythonpaste.org/modules/evalexception.html) HTTP server (it may work with others, but I have not tried). Just change `server='gevent'` to `server='paste'` to use the [paste](http://pythonpaste.org/modules/evalexception.html) server:\n\n``` python\nfrom gevent import monkey; monkey.patch_all()\n\nimport time\nfrom bottle import route, run\n\n@route('/stream')\ndef stream():\n    yield 'START'\n    time.sleep(3)\n    yield 'MIDDLE'\n    time.sleep(5)\n    yield 'END'\n\nrun(host='0.0.0.0', port=8080, server='gevent')\n```\n\nIf you browse to `http://localhost:8080/stream`, you should see ‘START’, ‘MIDDLE’, and ‘END’ show up one at a time (rather than waiting 8 seconds to see them all at once).\n\n## Gzip Compression in Bottle\n\nNote\n\nFor a detailed discussion, see [compression](https://github.com/defnull/bottle/issues/92)\n\nA common feature request is for Bottle to support Gzip compression, which speeds up sites by compressing static resources (like CSS and JS files) during a request.\n\nSupporting Gzip compression is not a straightforward proposition, due to a number of corner cases that crop up frequently. A proper Gzip implementation must:\n\n- Compress on the fly and be fast doing so.\n- Do not compress for browsers that don’t support it.\n- Do not compress files that are compressed already (images, videos).\n- Do not compress dynamic files.\n- Support two differed compression algorithms (gzip and deflate).\n- Cache compressed files that don’t change often.\n- De-validate the cache if one of the files changed anyway.\n- Make sure the cache does not get to big.\n- Do not cache small files because a disk seek would take longer than on-the-fly compression.\n\nBecause of these requirements, it is the recommendation of the Bottle project that Gzip compression is best handled by the WSGI server Bottle runs on top of. WSGI servers such as [cherrypy](http://www.cherrypy.org) provide a [GzipFilter](http://www.cherrypy.org/wiki/GzipFilter) middleware that can be used to accomplish this.\n\n## Using the hooks plugin\n\nFor example, if you want to allow Cross-Origin Resource Sharing for the content returned by all of your URL, you can use the hook decorator and setup a callback function:\n\n``` python\nfrom bottle import hook, response, route\n\n@hook('after_request')\ndef enable_cors():\n    response.headers['Access-Control-Allow-Origin'] = '*'\n\n@route('/foo')\ndef say_foo():\n    return 'foo!'\n\n@route('/bar')\ndef say_bar():\n    return {'type': 'friendly', 'content': 'Hi!'}\n```\n\nYou can also use the `before_request` to take an action before every function gets called.\n\n## Using Bottle with Heroku\n\n[Heroku](http://heroku.com), a popular cloud application platform now provides support for running Python applications on their infastructure.\n\nThis recipe is based upon the [Heroku Quickstart](http://devcenter.heroku.com/articles/quickstart), with Bottle specific code replacing the [Write Your App](http://devcenter.heroku.com/articles/python#write_your_app) section of the [Getting Started with Python on Heroku/Cedar](http://devcenter.heroku.com/articles/python) guide:\n\n``` python\nimport os\nfrom bottle import route, run\n\n@route(\"/\")\ndef hello_world():\n        return \"Hello World!\"\n\nrun(host=\"0.0.0.0\", port=int(os.environ.get(\"PORT\", 5000)))\n```\n\nHeroku’s app stack passes the port that the application needs to listen on for requests, using the `os.environ` dictionary.\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/recipes.html](https://bottlepy.org/docs/0.12/recipes.html)"
- name: Request Routing
  id: routing
  summary: Bottle uses a powerful routing engine to find the right callback for each request
  description: "# Request Routing\n\nBottle uses a powerful routing engine to find the right callback for each request. The [tutorial](tutorial#tutorial-routing) shows you the basics. This document covers advanced techniques and rule mechanics in detail.\n\n## Rule Syntax\n\nThe `Router` distinguishes between two basic types of routes: **static routes** (e.g. `/contact`) and **dynamic routes** (e.g. `/hello/<name>`). A route that contains one or more *wildcards* it is considered dynamic. All other routes are static.\n\nChanged in version 0.10.\n\nThe simplest form of a wildcard consists of a name enclosed in angle brackets (e.g. `<name>`). The name should be unique for a given route and form a valid python identifier (alphanumeric, starting with a letter). This is because wildcards are used as keyword arguments for the request callback later.\n\nEach wildcard matches one or more characters, but stops at the first slash (`/`). This equals a regular expression of `[^/]+` and ensures that only one path segment is matched and routes with more than one wildcard stay unambiguous.\n\nThe rule `/<action>/<item>` matches as follows:\n\n| Path       | Result                              |\n|------------|-------------------------------------|\n| /save/123  | `{'action': 'save', 'item': '123'}` |\n| /save/123/ | `No Match`                          |\n| /save/     | `No Match`                          |\n| //123      | `No Match`                          |\n\nYou can change the exact behaviour in many ways using filters. This is described in the next section.\n\n## Wildcard Filters\n\nNew in version 0.10.\n\nFilters are used to define more specific wildcards, and/or transform the matched part of the URL before it is passed to the callback. A filtered wildcard is declared as `<name:filter>` or `<name:filter:config>`. The syntax for the optional config part depends on the filter used.\n\nThe following standard filters are implemented:\n\n- **:int** matches (signed) digits and converts the value to integer.\n- **:float** similar to :int but for decimal numbers.\n- **:path** matches all characters including the slash character in a non-greedy way and may be used to match more than one path segment.\n- **:re\\[:exp\\]** allows you to specify a custom regular expression in the config field. The matched value is not modified.\n\nYou can add your own filters to the router. All you need is a function that returns three elements: A regular expression string, a callable to convert the URL fragment to a python value, and a callable that does the opposite. The filter function is called with the configuration string as the only parameter and may parse it as needed:\n\n``` python\napp = Bottle()\n\ndef list_filter(config):\n    ''' Matches a comma separated list of numbers. '''\n    delimiter = config or ','\n    regexp = r'\\d+(%s\\d)*' % re.escape(delimiter)\n\n    def to_python(match):\n        return map(int, match.split(delimiter))\n\n    def to_url(numbers):\n        return delimiter.join(map(str, numbers))\n\n    return regexp, to_python, to_url\n\napp.router.add_filter('list', list_filter)\n\n@app.route('/follow/<ids:list>')\ndef follow_users(ids):\n    for id in ids:\n        ...\n```\n\n## Legacy Syntax\n\nChanged in version 0.10.\n\nThe new rule syntax was introduce in **Bottle 0.10** to simplify some common use cases, but the old syntax still works and you can find lot code examples still using it. The differences are best described by example:\n\n| Old Syntax      | New Syntax         |\n|-----------------|--------------------|\n| `:name`         | `<name>`           |\n| `:name#regexp#` | `<name:re:regexp>` |\n| `:#regexp#`     | `<:re:regexp>`     |\n| `:##`           | `<:re>`            |\n\nTry to avoid the old syntax in future projects if you can. It is not currently deprecated, but will be eventually.\n\n## Explicit routing configuration\n\nRoute decorator can also be directly called as method. This way provides flexibility in complex setups, allowing you to directly control, when and how routing configuration done.\n\nHere is a basic example of explicit routing configuration for default bottle application:\n\n``` python\ndef setup_routing():\n    bottle.route('/', 'GET', index)\n    bottle.route('/edit', ['GET', 'POST'], edit)\n```\n\nIn fact, any `Bottle` instance routing can be configured same way:\n\n``` python\ndef setup_routing(app):\n    app.route('/new', ['GET', 'POST'], form_new)\n    app.route('/edit', ['GET', 'POST'], form_edit)\n\napp = Bottle()\nsetup_routing(app)\n```\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/routing.html](https://bottlepy.org/docs/0.12/routing.html)"
- name: ResourceManager
  id: api#bottle.ResourceManager
  summary: This class manages a list of search paths and helps to find and open application-bound resources (files)
  belongs_to: API Reference
  description: |-
    `class ResourceManager(base='./', opener=, cachemode='all')` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ResourceManager)

    This class manages a list of search paths and helps to find and open application-bound resources (files).

    [TABLE]

    `path = None`

    A list of search paths. See [`add_path()`](#bottle.ResourceManager.add_path "bottle.ResourceManager.add_path") for details.

    `cache = None`

    A cache for resolved paths. `res.cache.clear()` clears the cache.
- name: ResourceManager::add_path()
  id: api#bottle.ResourceManager.add_path
  summary: Add a new path to the list of search paths
  belongs_to: API Reference
  description: |-
    `add_path(path, base=None, index=None, create=False)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ResourceManager.add_path)

    Add a new path to the list of search paths. Return False if the path does not exist.

    [TABLE]

    The `base` parameter makes it easy to reference files installed along with a python module or package:

    ``` python
    res.add_path('./resources/', __file__)
    ```
- name: ResourceManager::lookup()
  id: api#bottle.ResourceManager.lookup
  summary: Search for a resource and return an absolute file path, or None
  belongs_to: API Reference
  description: |-
    `lookup(name)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ResourceManager.lookup)

    Search for a resource and return an absolute file path, or `None`.

    The [`path`](#bottle.ResourceManager.path "bottle.ResourceManager.path") list is searched in order. The first match is returend. Symlinks are followed. The result is cached to speed up future lookups.
- name: ResourceManager::open()
  id: api#bottle.ResourceManager.open
  summary: Find a resource and return a file object, or raise IOError
  belongs_to: API Reference
  description: |-
    `open(name, mode='r', *args, **kwargs)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#ResourceManager.open)

    Find a resource and return a file object, or raise IOError.
- name: Route
  id: api#bottle.Route
  summary: Decorator to install a route to the current default application
  belongs_to: API Reference
  description: |-
    `route(path, method='GET', callback=None, **options)`

    `get(...)`

    `post(...)`

    `put(...)`

    `delete(...)`

    Decorator to install a route to the current default application. See [`Bottle.route()`](#bottle.Bottle.route "bottle.Bottle.route") for details.
- name: route()
  id: api#bottle.route
  summary: Decorator to install a route to the current default application
  belongs_to: API Reference
  description: |-
    `route(path, method='GET', callback=None, **options)`

    `get(...)`

    `post(...)`

    `put(...)`

    `delete(...)`

    Decorator to install a route to the current default application. See [`Bottle.route()`](#bottle.Bottle.route "bottle.Bottle.route") for details.
- name: Route::all_plugins()
  id: api#bottle.Route.all_plugins
  summary: Yield all Plugins affecting this route
  belongs_to: API Reference
  description: |-
    `all_plugins()` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Route.all_plugins)

    Yield all Plugins affecting this route.
- name: Route::get_callback_args()
  id: api#bottle.Route.get_callback_args
  summary: Return a list of argument names the callback (most likely) accepts as keyword arguments
  belongs_to: API Reference
  description: |-
    `get_callback_args()` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Route.get_callback_args)

    Return a list of argument names the callback (most likely) accepts as keyword arguments. If the callback is a decorated function, try to recover the original function before inspection.
- name: Route::get_config()
  id: api#bottle.Route.get_config
  summary: Lookup a config field and return its value, first checking the route.config, then route.app.config
  belongs_to: API Reference
  description: |-
    `get_config(key, default=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Route.get_config)

    Lookup a config field and return its value, first checking the route.config, then route.app.config.

    ## The Request Object

    The [`Request`](#bottle.Request "bottle.Request") class wraps a WSGI environment and provides helpful methods to parse and access form data, cookies, file uploads and other metadata. Most of the attributes are read-only.

    `Request`

    alias of [`BaseRequest`](#bottle.BaseRequest "bottle.BaseRequest")
- name: Route::get_undecorated_callback()
  id: api#bottle.Route.get_undecorated_callback
  summary: Return the callback
  belongs_to: API Reference
  description: |-
    `get_undecorated_callback()` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Route.get_undecorated_callback)

    Return the callback. If the callback is a decorated function, try to recover the original function.
- name: Route::prepare()
  id: api#bottle.Route.prepare
  summary: Do all on-demand work immediately (useful for debugging)
  belongs_to: API Reference
  description: |-
    `prepare()` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Route.prepare)

    Do all on-demand work immediately (useful for debugging).
- name: Route::reset()
  id: api#bottle.Route.reset
  summary: Forget any cached values
  belongs_to: API Reference
  description: |-
    `reset()` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#Route.reset)

    Forget any cached values. The next time [`call`](#bottle.Route.call "bottle.Route.call") is accessed, all plugins are re-applied.
- name: run()
  id: api#bottle.run
  summary: Start a server instance
  belongs_to: API Reference
  description: |-
    `run(app=None, server='wsgiref', host='127.0.0.1', port=8080, interval=1, reloader=False, quiet=False, plugins=None, debug=None, **kargs)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#run)

    Start a server instance. This method blocks until the server terminates.

    [TABLE]
- name: setdefault()
  id: stpl#stpl.setdefault
  summary: If the variable is not defined, create it with the given default value
  belongs_to: SimpleTemplate Engine
  description: |-
    `setdefault(name, default)`

    If the variable is not defined, create it with the given default value. Return the variable.

    Here is an example that uses all three functions to implement optional template variables in different ways:

    ``` html
    % setdefault('text', 'No Text')
    <h1>{{get('title', 'No Title')}}</h1>
    <p> {{ text }} </p>
    % if defined('author'):
      <p>By {{ author }}</p>
    % end
    ```

    ## SimpleTemplate API
- name: SimpleTemplate
  id: stpl#bottle.SimpleTemplate
  summary: null
  belongs_to: SimpleTemplate Engine
  description: '`class SimpleTemplate(source=None, name=None, lookup=[], encoding=''utf8'', **settings)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#SimpleTemplate)'
- name: SimpleTemplate Engine
  id: stpl
  summary: Bottle comes with a fast, powerful and easy to learn built-in template engine called SimpleTemplate or stpl for short
  description: "# SimpleTemplate Engine\n\nBottle comes with a fast, powerful and easy to learn built-in template engine called *SimpleTemplate* or *stpl* for short. It is the default engine used by the [`view()`](api#bottle.view \"bottle.view\") and [`template()`](api#bottle.template \"bottle.template\") helpers but can be used as a stand-alone general purpose template engine too. This document explains the template syntax and shows examples for common use cases.\n\n#### Basic API Usage:\n\n[`SimpleTemplate`](#bottle.SimpleTemplate \"bottle.SimpleTemplate\") implements the [`BaseTemplate`](api#bottle.BaseTemplate \"bottle.BaseTemplate\") API:\n\n``` python\n>>> from bottle import SimpleTemplate\n>>> tpl = SimpleTemplate('Hello {{name}}!')\n>>> tpl.render(name='World')\nu'Hello World!'\n```\n\nIn this document we use the [`template()`](api#bottle.template \"bottle.template\") helper in examples for the sake of simplicity:\n\n``` python\n>>> from bottle import template\n>>> template('Hello {{name}}!', name='World')\nu'Hello World!'\n```\n\nJust keep in mind that compiling and rendering templates are two different actions, even if the [`template()`](api#bottle.template \"bottle.template\") helper hides this fact. Templates are usually compiled only once and cached internally, but rendered many times with different keyword arguments.\n\n## SimpleTemplate Syntax\n\nPython is a very powerful language but its whitespace-aware syntax makes it difficult to use as a template language. SimpleTemplate removes some of these restrictions and allows you to write clean, readable and maintainable templates while preserving full access to the features, libraries and speed of the Python language.\n\nWarning\n\nThe [`SimpleTemplate`](#bottle.SimpleTemplate \"bottle.SimpleTemplate\") syntax compiles directly to python bytecode and is executed on each [`SimpleTemplate.render()`](#bottle.SimpleTemplate.render \"bottle.SimpleTemplate.render\") call. Do not render untrusted templates! They may contain and execute harmful python code.\n\n### Inline Expressions\n\nYou already learned the use of the `{{...}}` syntax from the “Hello World!” example above, but there is more: any python expression is allowed within the curly brackets as long as it evaluates to a string or something that has a string representation:\n\n``` python\n>>> template('Hello {{name}}!', name='World')\nu'Hello World!'\n>>> template('Hello {{name.title() if name else \"stranger\"}}!', name=None)\nu'Hello stranger!'\n>>> template('Hello {{name.title() if name else \"stranger\"}}!', name='mArC')\nu'Hello Marc!'\n```\n\nThe contained python expression is executed at render-time and has access to all keyword arguments passed to the [`SimpleTemplate.render()`](#bottle.SimpleTemplate.render \"bottle.SimpleTemplate.render\") method. HTML special characters are escaped automatically to prevent [XSS](http://en.wikipedia.org/wiki/Cross-Site_Scripting) attacks. You can start the expression with an exclamation mark to disable escaping for that expression:\n\n``` python\n>>> template('Hello {{name}}!', name='<b>World</b>')\nu'Hello &lt;b&gt;World&lt;/b&gt;!'\n>>> template('Hello {{!name}}!', name='<b>World</b>')\nu'Hello <b>World</b>!'\n```\n\n### Embedded python code\n\nThe template engine allows you to embed lines or blocks of python code within your template. Code lines start with `%` and code blocks are surrounded by `<%` and `%>` tokens:\n\n``` html\n% name = \"Bob\"  # a line of python code\n<p>Some plain text in between</p>\n<%\n  # A block of python code\n  name = name.title().strip()\n%>\n<p>More plain text</p>\n```\n\nEmbedded python code follows regular python syntax, but with two additional syntax rules:\n\n- **Indentation is ignored.** You can put as much whitespace in front of statements as you want. This allows you to align your code with the surrounding markup and can greatly improve readability.\n- Blocks that are normally indented now have to be closed explicitly with an `end` keyword.\n\n``` html\n<ul>\n  % for item in basket:\n    <li>{{item}}</li>\n  % end\n</ul>\n```\n\nBoth the `%` and the `<%` tokens are only recognized if they are the first non-whitespace characters in a line. You don’t have to escape them if they appear mid-text in your template markup. Only if a line of text starts with one of these tokens, you have to escape it with a backslash. In the rare case where the backslash + token combination appears in your markup at the beginning of a line, you can always help yourself with a string literal in an inline expression:\n\n``` html\nThis line contains % and <% but no python code.\n\\% This text-line starts with the '%' token.\n\\<% Another line that starts with a token but is rendered as text.\n{{'\\\\%'}} this line starts with an escaped token.\n```\n\nIf you find yourself to escape a lot, consider using custom tokens.\n\n### Whitespace Control\n\nCode blocks and code lines always span the whole line. Whitespace in front of after a code segment is stripped away. You won’t see empty lines or dangling whitespace in your template because of embedded code:\n\n``` html\n<div>\n % if True:\n  <span>content</span>\n % end\n</div>\n```\n\nThis snippet renders to clean and compact html:\n\n``` html\n<div>\n  <span>content</span>\n</div>\n```\n\nBut embedding code still requires you to start a new line, which may not what you want to see in your rendered template. To skip the newline in front of a code segment, end the text line with a double-backslash:\n\n``` html\n<div>\\\\\n %if True:\n<span>content</span>\\\\\n %end\n</div>\n```\n\nTHis time the rendered template looks like this:\n\n``` html\n<div><span>content</span></div>\n```\n\nThis only works directly in front of code segments. In all other places you can control the whitespace yourself and don’t need any special syntax.\n\n## Template Functions\n\nEach template is preloaded with a bunch of functions that help with the most common use cases. These functions are always available. You don’t have to import or provide them yourself. For everything not covered here there are probably good python libraries available. Remember that you can `import` anything you want within your templates. They are python programs after all.\n\nChanged in version 0.12: Prior to this release, [`include()`](#stpl.include \"stpl.include\") and [`rebase()`](#stpl.rebase \"stpl.rebase\") were sytnax keywords, not functions.\n\n`include(sub_template, **variables)`  \nRender a sub-template with the specified variables and insert the resulting text into the current template. The function returns a dictionary containing the local variables passed to or defined within the sub-template:\n\n``` html\n% include('header.tpl', title='Page Title')\nPage Content\n% include('foother.tpl')\n```\n\n`rebase(name, **variables)`  \nMark the current template to be later included into a different template. After the current template is rendered, its resulting text is stored in a variable named `base` and passed to the base-template, which is then rendered. This can be used to `wrap` a template with surrounding text, or simulate the inheritance feature found in other template engines:\n\n``` html\n% rebase('base.tpl', title='Page Title')\n<p>Page Content ...</p>\n```\n\nThis can be combined with the following `base.tpl`:\n\n``` html\n<html>\n<head>\n  <title>{{title or 'No title'}}</title>\n</head>\n<body>\n  {{base}}\n</body>\n</html>\n```\n\nAccessing undefined variables in a template raises `NameError` and stops rendering immediately. This is standard python behavior and nothing new, but vanilla python lacks an easy way to check the availability of a variable. This quickly gets annoying if you want to support flexible inputs or use the same template in different situations. These functions may help:\n\n`defined(name)`  \nReturn True if the variable is defined in the current template namespace, False otherwise.\n\n&nbsp;\n\n`get(name, default=None)`  \nReturn the variable, or a default value.\n\n&nbsp;\n\n`setdefault(name, default)`  \nIf the variable is not defined, create it with the given default value. Return the variable.\n\nHere is an example that uses all three functions to implement optional template variables in different ways:\n\n``` html\n% setdefault('text', 'No Text')\n<h1>{{get('title', 'No Title')}}</h1>\n<p> {{ text }} </p>\n% if defined('author'):\n  <p>By {{ author }}</p>\n% end\n```\n\n## SimpleTemplate API\n\n`class SimpleTemplate(source=None, name=None, lookup=[], encoding='utf8', **settings)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#SimpleTemplate)  \n`render(*args, **kwargs)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#SimpleTemplate.render)  \nRender the template using keyword arguments as local variables.\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/stpl.html](https://bottlepy.org/docs/0.12/stpl.html)"
- name: SimpleTemplate::render()
  id: stpl#bottle.SimpleTemplate.render
  summary: Render the template using keyword arguments as local variables
  belongs_to: SimpleTemplate Engine
  description: "`render(*args, **kwargs)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#SimpleTemplate.render)\n\nRender the template using keyword arguments as local variables.\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/stpl.html](https://bottlepy.org/docs/0.12/stpl.html)"
- name: template()
  id: api#bottle.template
  summary: Get a rendered template as a string iterator
  belongs_to: API Reference
  description: "`template(*args, **kwargs)` [\\[source\\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#template)\n\nGet a rendered template as a string iterator. You can use a name, a filename or a template string as first parameter. Template rendering arguments can be passed as dictionaries or directly (as keyword arguments).\n\nYou can write your own adapter for your favourite template engine or use one of the predefined adapters. Currently there are four fully supported template engines:\n\n| Class                                                                  | URL                                                                | Decorator                              | Render function                                    |\n|------------------------------------------------------------------------|--------------------------------------------------------------------|----------------------------------------|----------------------------------------------------|\n| [`SimpleTemplate`](stpl#bottle.SimpleTemplate \"bottle.SimpleTemplate\") | [SimpleTemplate Engine](stpl)                                      | [`view()`](#bottle.view \"bottle.view\") | [`template()`](#bottle.template \"bottle.template\") |\n| `MakoTemplate`                                                         | [http://www.makotemplates.org](http://www.makotemplates.org)       | `mako_view()`                          | `mako_template()`                                  |\n| `CheetahTemplate`                                                      | [http://www.cheetahtemplate.org/](http://www.cheetahtemplate.org/) | `cheetah_view()`                       | `cheetah_template()`                               |\n| `Jinja2Template`                                                       | [http://jinja.pocoo.org/](http://jinja.pocoo.org/)                 | `jinja2_view()`                        | `jinja2_template()`                                |\n\nTo use `MakoTemplate` as your default template engine, just import its specialised decorator and render function:\n\n``` python\nfrom bottle import mako_view as view, mako_template as template\n```\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/api.html](https://bottlepy.org/docs/0.12/api.html)"
- name: Tutorial
  id: tutorial
  summary: This tutorial introduces you to the concepts and features of the Bottle web framework and covers basic and advanced topics alike
  description: "# Tutorial\n\nThis tutorial introduces you to the concepts and features of the Bottle web framework and covers basic and advanced topics alike. You can read it from start to end, or use it as a reference later on. The automatically generated [API Reference](api) may be interesting for you, too. It covers more details, but explains less than this tutorial. Solutions for the most common questions can be found in our [Recipes](recipes) collection or on the [Frequently Asked Questions](faq) page. If you need any help, join our [mailing list](mailto:bottlepy%40googlegroups.com) or visit us in our [IRC channel](http://webchat.freenode.net/?channels=bottlepy).\n\n## Installation\n\nBottle does not depend on any external libraries. You can just download [bottle.py](https://bottlepy.org/bottle.py) into your project directory and start coding:\n\n``` bash\n$ wget http://bottlepy.org/bottle.py\n```\n\nThis will get you the latest development snapshot that includes all the new features. If you prefer a more stable environment, you should stick with the stable releases. These are available on [PyPI](http://pypi.python.org/pypi/bottle) and can be installed via **pip** (recommended), **easy_install** or your package manager:\n\n``` bash\n$ sudo pip install bottle              # recommended\n$ sudo easy_install bottle             # alternative without pip\n$ sudo apt-get install python-bottle   # works for debian, ubuntu, ...\n```\n\nEither way, you’ll need Python 2.5 or newer (including 3.x) to run bottle applications. If you do not have permissions to install packages system-wide or simply don’t want to, create a [virtualenv](http://pypi.python.org/pypi/virtualenv) first:\n\n``` bash\n$ virtualenv develop              # Create virtual environment\n$ source develop/bin/activate     # Change default python to virtual one\n(develop)$ pip install -U bottle  # Install bottle to virtual environment\n```\n\nOr, if virtualenv is not installed on your system:\n\n``` bash\n$ wget https://raw.github.com/pypa/virtualenv/master/virtualenv.py\n$ python virtualenv.py develop    # Create virtual environment\n$ source develop/bin/activate     # Change default python to virtual one\n(develop)$ pip install -U bottle  # Install bottle to virtual environment\n```\n\n## Quickstart: “Hello World”\n\nThis tutorial assumes you have Bottle either [installed](#installation) or copied into your project directory. Let’s start with a very basic “Hello World” example:\n\n``` python\nfrom bottle import route, run\n\n@route('/hello')\ndef hello():\n    return \"Hello World!\"\n\nrun(host='localhost', port=8080, debug=True)\n```\n\nThis is it. Run this script, visit [http://localhost:8080/hello](http://localhost:8080/hello) and you will see “Hello World!” in your browser. Here is how it works:\n\nThe [`route()`](api#bottle.route \"bottle.route\") decorator binds a piece of code to an URL path. In this case, we link the `/hello` path to the `hello()` function. This is called a `route` (hence the decorator name) and is the most important concept of this framework. You can define as many routes as you want. Whenever a browser requests an URL, the associated function is called and the return value is sent back to the browser. Its as simple as that.\n\nThe [`run()`](api#bottle.run \"bottle.run\") call in the last line starts a built-in development server. It runs on `localhost` port `8080` and serves requests until you hit `Control-c`. You can switch the server backend later, but for now a development server is all we need. It requires no setup at all and is an incredibly painless way to get your application up and running for local tests.\n\nThe [Debug Mode](#tutorial-debugging) is very helpful during early development, but should be switched off for public applications. Keep that in mind.\n\nOf course this is a very simple example, but it shows the basic concept of how applications are built with Bottle. Continue reading and you’ll see what else is possible.\n\n### The Default Application\n\nFor the sake of simplicity, most examples in this tutorial use a module-level [`route()`](api#bottle.route \"bottle.route\") decorator to define routes. This adds routes to a global “default application”, an instance of [`Bottle`](api#bottle.Bottle \"bottle.Bottle\") that is automatically created the first time you call [`route()`](api#bottle.route \"bottle.route\"). Several other module-level decorators and functions relate to this default application, but if you prefer a more object oriented approach and don’t mind the extra typing, you can create a separate application object and use that instead of the global one:\n\n``` python\nfrom bottle import Bottle, run\n\napp = Bottle()\n\n@app.route('/hello')\ndef hello():\n    return \"Hello World!\"\n\nrun(app, host='localhost', port=8080)\n```\n\nThe object-oriented approach is further described in the [Default Application](#default-app) section. Just keep in mind that you have a choice.\n\n## Request Routing\n\nIn the last chapter we built a very simple web application with only a single route. Here is the routing part of the “Hello World” example again:\n\n``` python\n@route('/hello')\ndef hello():\n    return \"Hello World!\"\n```\n\nThe [`route()`](api#bottle.route \"bottle.route\") decorator links an URL path to a callback function, and adds a new route to the [default application](#tutorial-default). An application with just one route is kind of boring, though. Let’s add some more:\n\n``` python\n@route('/')\n@route('/hello/<name>')\ndef greet(name='Stranger'):\n    return template('Hello {{name}}, how are you?', name=name)\n```\n\nThis example demonstrates two things: You can bind more than one route to a single callback, and you can add wildcards to URLs and access them via keyword arguments.\n\n### Dynamic Routes\n\nRoutes that contain wildcards are called `dynamic routes` (as opposed to `static routes`) and match more than one URL at the same time. A simple wildcard consists of a name enclosed in angle brackets (e.g. `<name>`) and accepts one or more characters up to the next slash (`/`). For example, the route `/hello/<name>` accepts requests for `/hello/alice` as well as `/hello/bob`, but not for `/hello`, `/hello/` or `/hello/mr/smith`.\n\nEach wildcard passes the covered part of the URL as a keyword argument to the request callback. You can use them right away and implement RESTful, nice-looking and meaningful URLs with ease. Here are some other examples along with the URLs they’d match:\n\n``` python\n@route('/wiki/<pagename>')            # matches /wiki/Learning_Python\ndef show_wiki_page(pagename):\n    ...\n\n@route('/<action>/<user>')            # matches /follow/defnull\ndef user_api(action, user):\n    ...\n```\n\nNew in version 0.10.\n\nFilters are used to define more specific wildcards, and/or transform the covered part of the URL before it is passed to the callback. A filtered wildcard is declared as `<name:filter>` or `<name:filter:config>`. The syntax for the optional config part depends on the filter used.\n\nThe following filters are implemented by default and more may be added:\n\n- **:int** matches (signed) digits only and converts the value to integer.\n- **:float** similar to :int but for decimal numbers.\n- **:path** matches all characters including the slash character in a non-greedy way and can be used to match more than one path segment.\n- **:re** allows you to specify a custom regular expression in the config field. The matched value is not modified.\n\nLet’s have a look at some practical examples:\n\n``` python\n@route('/object/<id:int>')\ndef callback(id):\n    assert isinstance(id, int)\n\n@route('/show/<name:re:[a-z]+>')\ndef callback(name):\n    assert name.isalpha()\n\n@route('/static/<path:path>')\ndef callback(path):\n    return static_file(path, ...)\n```\n\nYou can add your own filters as well. See `Routing` for details.\n\nChanged in version 0.10.\n\nThe new rule syntax was introduced in **Bottle 0.10** to simplify some common use cases, but the old syntax still works and you can find a lot of code examples still using it. The differences are best described by example:\n\n| Old Syntax      | New Syntax         |\n|-----------------|--------------------|\n| `:name`         | `<name>`           |\n| `:name#regexp#` | `<name:re:regexp>` |\n| `:#regexp#`     | `<:re:regexp>`     |\n| `:##`           | `<:re>`            |\n\nTry to avoid the old syntax in future projects if you can. It is not currently deprecated, but will be eventually.\n\n### HTTP Request Methods\n\nThe HTTP protocol defines several [request methods](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html) (sometimes referred to as “verbs”) for different tasks. GET is the default for all routes with no other method specified. These routes will match GET requests only. To handle other methods such as POST, PUT or DELETE, add a `method` keyword argument to the [`route()`](api#bottle.route \"bottle.route\") decorator or use one of the four alternative decorators: [`get()`](api#bottle.get \"bottle.get\"), [`post()`](api#bottle.post \"bottle.post\"), [`put()`](api#bottle.put \"bottle.put\") or [`delete()`](api#bottle.delete \"bottle.delete\").\n\nThe POST method is commonly used for HTML form submission. This example shows how to handle a login form using POST:\n\n``` python\nfrom bottle import get, post, request # or route\n\n@get('/login') # or @route('/login')\ndef login():\n    return '''\n        <form action=\"/login\" method=\"post\">\n            Username: <input name=\"username\" type=\"text\" />\n            Password: <input name=\"password\" type=\"password\" />\n            <input value=\"Login\" type=\"submit\" />\n        </form>\n    '''\n\n@post('/login') # or @route('/login', method='POST')\ndef do_login():\n    username = request.forms.get('username')\n    password = request.forms.get('password')\n    if check_login(username, password):\n        return \"<p>Your login information was correct.</p>\"\n    else:\n        return \"<p>Login failed.</p>\"\n```\n\nIn this example the `/login` URL is linked to two distinct callbacks, one for GET requests and another for POST requests. The first one displays a HTML form to the user. The second callback is invoked on a form submission and checks the login credentials the user entered into the form. The use of `Request.forms` is further described in the [Request Data](#tutorial-request) section.\n\n#### Special Methods: HEAD and ANY\n\nThe HEAD method is used to ask for the response identical to the one that would correspond to a GET request, but without the response body. This is useful for retrieving meta-information about a resource without having to download the entire document. Bottle handles these requests automatically by falling back to the corresponding GET route and cutting off the request body, if present. You don’t have to specify any HEAD routes yourself.\n\nAdditionally, the non-standard ANY method works as a low priority fallback: Routes that listen to ANY will match requests regardless of their HTTP method but only if no other more specific route is defined. This is helpful for *proxy-routes* that redirect requests to more specific sub-applications.\n\nTo sum it up: HEAD requests fall back to GET routes and all requests fall back to ANY routes, but only if there is no matching route for the original request method. It’s as simple as that.\n\n### Routing Static Files\n\nStatic files such as images or CSS files are not served automatically. You have to add a route and a callback to control which files get served and where to find them:\n\n``` python\nfrom bottle import static_file\n@route('/static/<filename>')\ndef server_static(filename):\n    return static_file(filename, root='/path/to/your/static/files')\n```\n\nThe `static_file()` function is a helper to serve files in a safe and convenient way (see [Static Files](#tutorial-static-files)). This example is limited to files directly within the `/path/to/your/static/files` directory because the `<filename>` wildcard won’t match a path with a slash in it. To serve files in subdirectories, change the wildcard to use the `path` filter:\n\n``` python\n@route('/static/<filepath:path>')\ndef server_static(filepath):\n    return static_file(filepath, root='/path/to/your/static/files')\n```\n\nBe careful when specifying a relative root-path such as `root='./static/files'`. The working directory (`./`) and the project directory are not always the same.\n\n### Error Pages\n\nIf anything goes wrong, Bottle displays an informative but fairly plain error page. You can override the default for a specific HTTP status code with the [`error()`](api#bottle.error \"bottle.error\") decorator:\n\n``` python\nfrom bottle import error\n@error(404)\ndef error404(error):\n    return 'Nothing here, sorry'\n```\n\nFrom now on, `404 File not Found` errors will display a custom error page to the user. The only parameter passed to the error-handler is an instance of [`HTTPError`](api#bottle.HTTPError \"bottle.HTTPError\"). Apart from that, an error-handler is quite similar to a regular request callback. You can read from [`request`](api#bottle.request \"bottle.request\"), write to [`response`](api#bottle.response \"bottle.response\") and return any supported data-type except for [`HTTPError`](api#bottle.HTTPError \"bottle.HTTPError\") instances.\n\nError handlers are used only if your application returns or raises an [`HTTPError`](api#bottle.HTTPError \"bottle.HTTPError\") exception (`abort()` does just that). Changing `Request.status` or returning [`HTTPResponse`](api#bottle.HTTPResponse \"bottle.HTTPResponse\") won’t trigger the error handler.\n\n## Generating content\n\nIn pure WSGI, the range of types you may return from your application is very limited. Applications must return an iterable yielding byte strings. You may return a string (because strings are iterable) but this causes most servers to transmit your content char by char. Unicode strings are not allowed at all. This is not very practical.\n\nBottle is much more flexible and supports a wide range of types. It even adds a `Content-Length` header if possible and encodes unicode automatically, so you don’t have to. What follows is a list of data types you may return from your application callbacks and a short description of how these are handled by the framework:\n\nDictionaries  \nAs mentioned above, Python dictionaries (or subclasses thereof) are automatically transformed into JSON strings and returned to the browser with the `Content-Type` header set to `application/json`. This makes it easy to implement json-based APIs. Data formats other than json are supported too. See the tutorial-output-filter to learn more.\n\n`Empty Strings, False, None or other non-true values:`  \nThese produce an empty output with the `Content-Length` header set to 0.\n\nUnicode strings  \nUnicode strings (or iterables yielding unicode strings) are automatically encoded with the codec specified in the `Content-Type` header (utf8 by default) and then treated as normal byte strings (see below).\n\nByte strings  \nBottle returns strings as a whole (instead of iterating over each char) and adds a `Content-Length` header based on the string length. Lists of byte strings are joined first. Other iterables yielding byte strings are not joined because they may grow too big to fit into memory. The `Content-Length` header is not set in this case.\n\n`Instances of HTTPError or` [`HTTPResponse`](api#bottle.HTTPResponse \"bottle.HTTPResponse\")  \nReturning these has the same effect as when raising them as an exception. In case of an [`HTTPError`](api#bottle.HTTPError \"bottle.HTTPError\"), the error handler is applied. See [Error Pages](#tutorial-errorhandling) for details.\n\nFile objects  \nEverything that has a `.read()` method is treated as a file or file-like object and passed to the `wsgi.file_wrapper` callable defined by the WSGI server framework. Some WSGI server implementations can make use of optimized system calls (sendfile) to transmit files more efficiently. In other cases this just iterates over chunks that fit into memory. Optional headers such as `Content-Length` or `Content-Type` are *not* set automatically. Use `send_file()` if possible. See [Static Files](#tutorial-static-files) for details.\n\nIterables and generators  \nYou are allowed to use `yield` within your callbacks or return an iterable, as long as the iterable yields byte strings, unicode strings, [`HTTPError`](api#bottle.HTTPError \"bottle.HTTPError\") or [`HTTPResponse`](api#bottle.HTTPResponse \"bottle.HTTPResponse\") instances. Nested iterables are not supported, sorry. Please note that the HTTP status code and the headers are sent to the browser as soon as the iterable yields its first non-empty value. Changing these later has no effect.\n\nThe ordering of this list is significant. You may for example return a subclass of [`str`](http://docs.python.org/library/functions.html#str \"(in Python v2.7)\") with a `read()` method. It is still treated as a string instead of a file, because strings are handled first.\n\n#### Changing the Default Encoding\n\nBottle uses the `charset` parameter of the `Content-Type` header to decide how to encode unicode strings. This header defaults to `text/html; charset=UTF8` and can be changed using the `Response.content_type` attribute or by setting the `Response.charset` attribute directly. (The [`Response`](api#bottle.Response \"bottle.Response\") object is described in the section [The Response Object](#tutorial-response).)\n\n``` python\nfrom bottle import response\n@route('/iso')\ndef get_iso():\n    response.charset = 'ISO-8859-15'\n    return u'This will be sent with ISO-8859-15 encoding.'\n\n@route('/latin9')\ndef get_latin():\n    response.content_type = 'text/html; charset=latin9'\n    return u'ISO-8859-15 is also known as latin9.'\n```\n\nIn some rare cases the Python encoding names differ from the names supported by the HTTP specification. Then, you have to do both: first set the `Response.content_type` header (which is sent to the client unchanged) and then set the `Response.charset` attribute (which is used to encode unicode).\n\n### Static Files\n\nYou can directly return file objects, but `static_file()` is the recommended way to serve static files. It automatically guesses a mime-type, adds a `Last-Modified` header, restricts paths to a `root` directory for security reasons and generates appropriate error responses (403 on permission errors, 404 on missing files). It even supports the `If-Modified-Since` header and eventually generates a `304 Not Modified` response. You can pass a custom MIME type to disable guessing.\n\n``` python\nfrom bottle import static_file\n@route('/images/<filename:re:.*\\.png>')\ndef send_image(filename):\n    return static_file(filename, root='/path/to/image/files', mimetype='image/png')\n\n@route('/static/<filename:path>')\ndef send_static(filename):\n    return static_file(filename, root='/path/to/static/files')\n```\n\nYou can raise the return value of `static_file()` as an exception if you really need to.\n\n#### Forced Download\n\nMost browsers try to open downloaded files if the MIME type is known and assigned to an application (e.g. PDF files). If this is not what you want, you can force a download dialog and even suggest a filename to the user:\n\n``` python\n@route('/download/<filename:path>')\ndef download(filename):\n    return static_file(filename, root='/path/to/static/files', download=filename)\n```\n\nIf the `download` parameter is just `True`, the original filename is used.\n\n### HTTP Errors and Redirects\n\nThe `abort()` function is a shortcut for generating HTTP error pages.\n\n``` python\nfrom bottle import route, abort\n@route('/restricted')\ndef restricted():\n    abort(401, \"Sorry, access denied.\")\n```\n\nTo redirect a client to a different URL, you can send a `303 See Other` response with the `Location` header set to the new URL. `redirect()` does that for you:\n\n``` python\nfrom bottle import redirect\n@route('/wrong/url')\ndef wrong():\n    redirect(\"/right/url\")\n```\n\nYou may provide a different HTTP status code as a second parameter.\n\nNote\n\nBoth functions will interrupt your callback code by raising an [`HTTPError`](api#bottle.HTTPError \"bottle.HTTPError\") exception.\n\n#### Other Exceptions\n\nAll exceptions other than [`HTTPResponse`](api#bottle.HTTPResponse \"bottle.HTTPResponse\") or [`HTTPError`](api#bottle.HTTPError \"bottle.HTTPError\") will result in a `500 Internal Server Error` response, so they won’t crash your WSGI server. You can turn off this behavior to handle exceptions in your middleware by setting `bottle.app().catchall` to `False`.\n\n### The [`Response`](api#bottle.Response \"bottle.Response\") Object\n\nResponse metadata such as the HTTP status code, response headers and cookies are stored in an object called [`response`](api#bottle.response \"bottle.response\") up to the point where they are transmitted to the browser. You can manipulate these metadata directly or use the predefined helper methods to do so. The full API and feature list is described in the API section (see [`Response`](api#bottle.Response \"bottle.Response\")), but the most common use cases and features are covered here, too.\n\n#### Status Code\n\nThe [HTTP status code](http_code) controls the behavior of the browser and defaults to `200 OK`. In most scenarios you won’t need to set the `Response.status` attribute manually, but use the `abort()` helper or return an [`HTTPResponse`](api#bottle.HTTPResponse \"bottle.HTTPResponse\") instance with the appropriate status code. Any integer is allowed, but codes other than the ones defined by the [HTTP specification](http_code) will only confuse the browser and break standards.\n\n#### Response Header\n\nResponse headers such as `Cache-Control` or `Location` are defined via `Response.set_header()`. This method takes two parameters, a header name and a value. The name part is case-insensitive:\n\n``` python\n@route('/wiki/<page>')\ndef wiki(page):\n    response.set_header('Content-Language', 'en')\n    ...\n```\n\nMost headers are unique, meaning that only one header per name is send to the client. Some special headers however are allowed to appear more than once in a response. To add an additional header, use `Response.add_header()` instead of `Response.set_header()`:\n\n``` python\nresponse.set_header('Set-Cookie', 'name=value')\nresponse.add_header('Set-Cookie', 'name2=value2')\n```\n\nPlease note that this is just an example. If you want to work with cookies, read [ahead](#tutorial-cookies).\n\n### Cookies\n\nA cookie is a named piece of text stored in the user’s browser profile. You can access previously defined cookies via `Request.get_cookie()` and set new cookies with `Response.set_cookie()`:\n\n``` python\n@route('/hello')\ndef hello_again():\n    if request.get_cookie(\"visited\"):\n        return \"Welcome back! Nice to see you again\"\n    else:\n        response.set_cookie(\"visited\", \"yes\")\n        return \"Hello there! Nice to meet you\"\n```\n\nThe `Response.set_cookie()` method accepts a number of additional keyword arguments that control the cookies lifetime and behavior. Some of the most common settings are described here:\n\n- **max_age:** Maximum age in seconds. (default: `None`)\n- **expires:** A datetime object or UNIX timestamp. (default: `None`)\n- **domain:** The domain that is allowed to read the cookie. (default: current domain)\n- **path:** Limit the cookie to a given path (default: `/`)\n- **secure:** Limit the cookie to HTTPS connections (default: off).\n- **httponly:** Prevent client-side javascript to read this cookie (default: off, requires Python 2.6 or newer).\n\nIf neither `expires` nor `max_age` is set, the cookie expires at the end of the browser session or as soon as the browser window is closed. There are some other gotchas you should consider when using cookies:\n\n- Cookies are limited to 4 KB of text in most browsers.\n- Some users configure their browsers to not accept cookies at all. Most search engines ignore cookies too. Make sure that your application still works without cookies.\n- Cookies are stored at client side and are not encrypted in any way. Whatever you store in a cookie, the user can read it. Worse than that, an attacker might be able to steal a user’s cookies through [XSS](http://en.wikipedia.org/wiki/HTTP_cookie#Cookie_theft_and_session_hijacking) vulnerabilities on your side. Some viruses are known to read the browser cookies, too. Thus, never store confidential information in cookies.\n- Cookies are easily forged by malicious clients. Do not trust cookies.\n\n#### Signed Cookies\n\nAs mentioned above, cookies are easily forged by malicious clients. Bottle can cryptographically sign your cookies to prevent this kind of manipulation. All you have to do is to provide a signature key via the `secret` keyword argument whenever you read or set a cookie and keep that key a secret. As a result, `Request.get_cookie()` will return `None` if the cookie is not signed or the signature keys don’t match:\n\n``` python\n@route('/login')\ndef do_login():\n    username = request.forms.get('username')\n    password = request.forms.get('password')\n    if check_login(username, password):\n        response.set_cookie(\"account\", username, secret='some-secret-key')\n        return template(\"<p>Welcome {{name}}! You are now logged in.</p>\", name=username)\n    else:\n        return \"<p>Login failed.</p>\"\n\n@route('/restricted')\ndef restricted_area():\n    username = request.get_cookie(\"account\", secret='some-secret-key')\n    if username:\n        return template(\"Hello {{name}}. Welcome back.\", name=username)\n    else:\n        return \"You are not logged in. Access denied.\"\n```\n\nIn addition, Bottle automatically pickles and unpickles any data stored to signed cookies. This allows you to store any pickle-able object (not only strings) to cookies, as long as the pickled data does not exceed the 4 KB limit.\n\nWarning\n\nSigned cookies are not encrypted (the client can still see the content) and not copy-protected (the client can restore an old cookie). The main intention is to make pickling and unpickling safe and prevent manipulation, not to store secret information at client side.\n\n## Request Data\n\nCookies, HTTP header, HTML `<form>` fields and other request data is available through the global [`request`](api#bottle.request \"bottle.request\") object. This special object always refers to the *current* request, even in multi-threaded environments where multiple client connections are handled at the same time:\n\n``` python\nfrom bottle import request, route, template\n\n@route('/hello')\ndef hello():\n    name = request.cookies.username or 'Guest'\n    return template('Hello {{name}}', name=name)\n```\n\nThe [`request`](api#bottle.request \"bottle.request\") object is a subclass of [`BaseRequest`](api#bottle.BaseRequest \"bottle.BaseRequest\") and has a very rich API to access data. We only cover the most commonly used features here, but it should be enough to get started.\n\n### Introducing [`FormsDict`](api#bottle.FormsDict \"bottle.FormsDict\")\n\nBottle uses a special type of dictionary to store form data and cookies. [`FormsDict`](api#bottle.FormsDict \"bottle.FormsDict\") behaves like a normal dictionary, but has some additional features to make your life easier.\n\n**Attribute access**: All values in the dictionary are also accessible as attributes. These virtual attributes return unicode strings, even if the value is missing or unicode decoding fails. In that case, the string is empty, but still present:\n\n``` python\nname = request.cookies.name\n\n# is a shortcut for:\n\nname = request.cookies.getunicode('name') # encoding='utf-8' (default)\n\n# which basically does this:\n\ntry:\n    name = request.cookies.get('name', '').decode('utf-8')\nexcept UnicodeError:\n    name = u''\n```\n\n**Multiple values per key:** [`FormsDict`](api#bottle.FormsDict \"bottle.FormsDict\") is a subclass of [`MultiDict`](api#bottle.MultiDict \"bottle.MultiDict\") and can store more than one value per key. The standard dictionary access methods will only return a single value, but the [`getall()`](api#bottle.MultiDict.getall \"bottle.MultiDict.getall\") method returns a (possibly empty) list of all values for a specific key:\n\n``` python\nfor choice in request.forms.getall('multiple_choice'):\n    do_something(choice)\n```\n\n**WTForms support:** Some libraries (e.g. [WTForms](http://wtforms.simplecodes.com/)) want all-unicode dictionaries as input. [`FormsDict.decode()`](api#bottle.FormsDict.decode \"bottle.FormsDict.decode\") does that for you. It decodes all values and returns a copy of itself, while preserving multiple values per key and all the other features.\n\nNote\n\nIn **Python 2** all keys and values are byte-strings. If you need unicode, you can call [`FormsDict.getunicode()`](api#bottle.FormsDict.getunicode \"bottle.FormsDict.getunicode\") or fetch values via attribute access. Both methods try to decode the string (default: utf8) and return an empty string if that fails. No need to catch `UnicodeError`:\n\n``` python\n>>> request.query['city']\n'G\\xc3\\xb6ttingen'  # A utf8 byte string\n>>> request.query.city\nu'Göttingen'        # The same string as unicode\n```\n\nIn **Python 3** all strings are unicode, but HTTP is a byte-based wire protocol. The server has to decode the byte strings somehow before they are passed to the application. To be on the safe side, WSGI suggests ISO-8859-1 (aka latin1), a reversible single-byte codec that can be re-encoded with a different encoding later. Bottle does that for [`FormsDict.getunicode()`](api#bottle.FormsDict.getunicode \"bottle.FormsDict.getunicode\") and attribute access, but not for the dict-access methods. These return the unchanged values as provided by the server implementation, which is probably not what you want.\n\n``` python\n>>> request.query['city']\n'GÃ¶ttingen' # An utf8 string provisionally decoded as ISO-8859-1 by the server\n>>> request.query.city\n'Göttingen'  # The same string correctly re-encoded as utf8 by bottle\n```\n\nIf you need the whole dictionary with correctly decoded values (e.g. for WTForms), you can call [`FormsDict.decode()`](api#bottle.FormsDict.decode \"bottle.FormsDict.decode\") to get a re-encoded copy.\n\n### Cookies\n\nCookies are small pieces of text stored in the clients browser and sent back to the server with each request. They are useful to keep some state around for more than one request (HTTP itself is stateless), but should not be used for security related stuff. They can be easily forged by the client.\n\nAll cookies sent by the client are available through [`BaseRequest.cookies`](api#bottle.BaseRequest.cookies \"bottle.BaseRequest.cookies\") (a [`FormsDict`](api#bottle.FormsDict \"bottle.FormsDict\")). This example shows a simple cookie-based view counter:\n\n``` python\nfrom bottle import route, request, response\n@route('/counter')\ndef counter():\n    count = int( request.cookies.get('counter', '0') )\n    count += 1\n    response.set_cookie('counter', str(count))\n    return 'You visited this page %d times' % count\n```\n\nThe [`BaseRequest.get_cookie()`](api#bottle.BaseRequest.get_cookie \"bottle.BaseRequest.get_cookie\") method is a different way do access cookies. It supports decoding [signed cookies](#tutorial-signed-cookies) as described in a separate section.\n\n### HTTP Headers\n\nAll HTTP headers sent by the client (e.g. `Referer`, `Agent` or `Accept-Language`) are stored in a [`WSGIHeaderDict`](api#bottle.WSGIHeaderDict \"bottle.WSGIHeaderDict\") and accessible through the [`BaseRequest.headers`](api#bottle.BaseRequest.headers \"bottle.BaseRequest.headers\") attribute. A [`WSGIHeaderDict`](api#bottle.WSGIHeaderDict \"bottle.WSGIHeaderDict\") is basically a dictionary with case-insensitive keys:\n\n``` python\nfrom bottle import route, request\n@route('/is_ajax')\ndef is_ajax():\n    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':\n        return 'This is an AJAX request'\n    else:\n        return 'This is a normal request'\n```\n\n### Query Variables\n\nThe query string (as in `/forum?id=1&page=5`) is commonly used to transmit a small number of key/value pairs to the server. You can use the [`BaseRequest.query`](api#bottle.BaseRequest.query \"bottle.BaseRequest.query\") attribute (a [`FormsDict`](api#bottle.FormsDict \"bottle.FormsDict\")) to access these values and the [`BaseRequest.query_string`](api#bottle.BaseRequest.query_string \"bottle.BaseRequest.query_string\") attribute to get the whole string.\n\n``` python\nfrom bottle import route, request, response, template\n@route('/forum')\ndef display_forum():\n    forum_id = request.query.id\n    page = request.query.page or '1'\n    return template('Forum ID: {{id}} (page {{page}})', id=forum_id, page=page)\n```\n\n### HTML `<form>` Handling\n\nLet us start from the beginning. In HTML, a typical `<form>` looks something like this:\n\n``` html\n<form action=\"/login\" method=\"post\">\n    Username: <input name=\"username\" type=\"text\" />\n    Password: <input name=\"password\" type=\"password\" />\n    <input value=\"Login\" type=\"submit\" />\n</form>\n```\n\nThe `action` attribute specifies the URL that will receive the form data. `method` defines the HTTP method to use (`GET` or `POST`). With `method=\"get\"` the form values are appended to the URL and available through [`BaseRequest.query`](api#bottle.BaseRequest.query \"bottle.BaseRequest.query\") as described above. This is considered insecure and has other limitations, so we use `method=\"post\"` here. If in doubt, use `POST` forms.\n\nForm fields transmitted via `POST` are stored in [`BaseRequest.forms`](api#bottle.BaseRequest.forms \"bottle.BaseRequest.forms\") as a [`FormsDict`](api#bottle.FormsDict \"bottle.FormsDict\"). The server side code may look like this:\n\n``` python\nfrom bottle import route, request\n\n@route('/login')\ndef login():\n    return '''\n        <form action=\"/login\" method=\"post\">\n            Username: <input name=\"username\" type=\"text\" />\n            Password: <input name=\"password\" type=\"password\" />\n            <input value=\"Login\" type=\"submit\" />\n        </form>\n    '''\n\n@route('/login', method='POST')\ndef do_login():\n    username = request.forms.get('username')\n    password = request.forms.get('password')\n    if check_login(username, password):\n        return \"<p>Your login information was correct.</p>\"\n    else:\n        return \"<p>Login failed.</p>\"\n```\n\nThere are several other attributes used to access form data. Some of them combine values from different sources for easier access. The following table should give you a decent overview.\n\n| Attribute                                                                         | GET Form fields | POST Form fields | File Uploads |\n|-----------------------------------------------------------------------------------|-----------------|------------------|--------------|\n| [`BaseRequest.query`](api#bottle.BaseRequest.query \"bottle.BaseRequest.query\")    | yes             | no               | no           |\n| [`BaseRequest.forms`](api#bottle.BaseRequest.forms \"bottle.BaseRequest.forms\")    | no              | yes              | no           |\n| [`BaseRequest.files`](api#bottle.BaseRequest.files \"bottle.BaseRequest.files\")    | no              | no               | yes          |\n| [`BaseRequest.params`](api#bottle.BaseRequest.params \"bottle.BaseRequest.params\") | yes             | yes              | no           |\n| [`BaseRequest.GET`](api#bottle.BaseRequest.GET \"bottle.BaseRequest.GET\")          | yes             | no               | no           |\n| [`BaseRequest.POST`](api#bottle.BaseRequest.POST \"bottle.BaseRequest.POST\")       | no              | yes              | yes          |\n\n### File uploads\n\nTo support file uploads, we have to change the `<form>` tag a bit. First, we tell the browser to encode the form data in a different way by adding an `enctype=\"multipart/form-data\"` attribute to the `<form>` tag. Then, we add `<input type=\"file\" />` tags to allow the user to select a file. Here is an example:\n\n``` html\n<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\n  Category:      <input type=\"text\" name=\"category\" />\n  Select a file: <input type=\"file\" name=\"upload\" />\n  <input type=\"submit\" value=\"Start upload\" />\n</form>\n```\n\nBottle stores file uploads in [`BaseRequest.files`](api#bottle.BaseRequest.files \"bottle.BaseRequest.files\") as [`FileUpload`](api#bottle.FileUpload \"bottle.FileUpload\") instances, along with some metadata about the upload. Let us assume you just want to save the file to disk:\n\n``` python\n@route('/upload', method='POST')\ndef do_upload():\n    category   = request.forms.get('category')\n    upload     = request.files.get('upload')\n    name, ext = os.path.splitext(upload.filename)\n    if ext not in ('.png','.jpg','.jpeg'):\n        return 'File extension not allowed.'\n\n    save_path = get_save_path_for_category(category)\n    upload.save(save_path) # appends upload.filename automatically\n    return 'OK'\n```\n\n[`FileUpload.filename`](api#bottle.FileUpload.filename \"bottle.FileUpload.filename\") contains the name of the file on the clients file system, but is cleaned up and normalized to prevent bugs caused by unsupported characters or path segments in the filename. If you need the unmodified name as sent by the client, have a look at [`FileUpload.raw_filename`](api#bottle.FileUpload.raw_filename \"bottle.FileUpload.raw_filename\").\n\nThe [`FileUpload.save`](api#bottle.FileUpload.save \"bottle.FileUpload.save\") method is highly recommended if you want to store the file to disk. It prevents some common errors (e.g. it does not overwrite existing files unless you tell it to) and stores the file in a memory efficient way. You can access the file object directly via [`FileUpload.file`](api#bottle.FileUpload.file \"bottle.FileUpload.file\"). Just be careful.\n\n### JSON Content\n\nSome JavaScript or REST clients send `application/json` content to the server. The [`BaseRequest.json`](api#bottle.BaseRequest.json \"bottle.BaseRequest.json\") attribute contains the parsed data structure, if available.\n\n### The raw request body\n\nYou can access the raw body data as a file-like object via [`BaseRequest.body`](api#bottle.BaseRequest.body \"bottle.BaseRequest.body\"). This is a `BytesIO` buffer or a temporary file depending on the content length and [`BaseRequest.MEMFILE_MAX`](api#bottle.BaseRequest.MEMFILE_MAX \"bottle.BaseRequest.MEMFILE_MAX\") setting. In both cases the body is completely buffered before you can access the attribute. If you expect huge amounts of data and want to get direct unbuffered access to the stream, have a look at `request['wsgi.input']`.\n\n### WSGI Environment\n\nEach [`BaseRequest`](api#bottle.BaseRequest \"bottle.BaseRequest\") instance wraps a WSGI environment dictionary. The original is stored in [`BaseRequest.environ`](api#bottle.BaseRequest.environ \"bottle.BaseRequest.environ\"), but the request object itself behaves like a dictionary, too. Most of the interesting data is exposed through special methods or attributes, but if you want to access [WSGI environ variables](wsgispecification) directly, you can do so:\n\n``` python\n@route('/my_ip')\ndef show_ip():\n    ip = request.environ.get('REMOTE_ADDR')\n    # or ip = request.get('REMOTE_ADDR')\n    # or ip = request['REMOTE_ADDR']\n    return template(\"Your IP is: {{ip}}\", ip=ip)\n```\n\n## Templates\n\nBottle comes with a fast and powerful built-in template engine called [SimpleTemplate Engine](stpl). To render a template you can use the [`template()`](api#bottle.template \"bottle.template\") function or the [`view()`](api#bottle.view \"bottle.view\") decorator. All you have to do is to provide the name of the template and the variables you want to pass to the template as keyword arguments. Here’s a simple example of how to render a template:\n\n``` python\n@route('/hello')\n@route('/hello/<name>')\ndef hello(name='World'):\n    return template('hello_template', name=name)\n```\n\nThis will load the template file `hello_template.tpl` and render it with the `name` variable set. Bottle will look for templates in the `./views/` folder or any folder specified in the `bottle.TEMPLATE_PATH` list.\n\nThe [`view()`](api#bottle.view \"bottle.view\") decorator allows you to return a dictionary with the template variables instead of calling [`template()`](api#bottle.template \"bottle.template\"):\n\n``` python\n@route('/hello')\n@route('/hello/<name>')\n@view('hello_template')\ndef hello(name='World'):\n    return dict(name=name)\n```\n\n#### Syntax\n\nThe template syntax is a very thin layer around the Python language. Its main purpose is to ensure correct indentation of blocks, so you can format your template without worrying about indentation. Follow the link for a full syntax description: [SimpleTemplate Engine](stpl)\n\nHere is an example template:\n\n``` html\n%if name == 'World':\n    <h1>Hello {{name}}!</h1>\n    <p>This is a test.</p>\n%else:\n    <h1>Hello {{name.title()}}!</h1>\n    <p>How are you?</p>\n%end\n```\n\n#### Caching\n\nTemplates are cached in memory after compilation. Modifications made to the template files will have no affect until you clear the template cache. Call `bottle.TEMPLATES.clear()` to do so. Caching is disabled in debug mode.\n\n## Plugins\n\nNew in version 0.9.\n\nBottle’s core features cover most common use-cases, but as a micro-framework it has its limits. This is where “Plugins” come into play. Plugins add missing functionality to the framework, integrate third party libraries, or just automate some repetitive work.\n\nWe have a growing [List of available Plugins](plugins/index) and most plugins are designed to be portable and re-usable across applications. The chances are high that your problem has already been solved and a ready-to-use plugin exists. If not, the [Plugin Development Guide](plugindev) may help you.\n\nThe effects and APIs of plugins are manifold and depend on the specific plugin. The `SQLitePlugin` plugin for example detects callbacks that require a `db` keyword argument and creates a fresh database connection object every time the callback is called. This makes it very convenient to use a database:\n\n``` python\nfrom bottle import route, install, template\nfrom bottle_sqlite import SQLitePlugin\n\ninstall(SQLitePlugin(dbfile='/tmp/test.db'))\n\n@route('/show/<post_id:int>')\ndef show(db, post_id):\n    c = db.execute('SELECT title, content FROM posts WHERE id = ?', (post_id,))\n    row = c.fetchone()\n    return template('show_post', title=row['title'], text=row['content'])\n\n@route('/contact')\ndef contact_page():\n    ''' This callback does not need a db connection. Because the 'db'\n        keyword argument is missing, the sqlite plugin ignores this callback\n        completely. '''\n    return template('contact')\n```\n\nOther plugin may populate the thread-safe `local` object, change details of the [`request`](api#bottle.request \"bottle.request\") object, filter the data returned by the callback or bypass the callback completely. An “auth” plugin for example could check for a valid session and return a login page instead of calling the original callback. What happens exactly depends on the plugin.\n\n### Application-wide Installation\n\nPlugins can be installed application-wide or just to some specific routes that need additional functionality. Most plugins can safely be installed to all routes and are smart enough to not add overhead to callbacks that do not need their functionality.\n\nLet us take the `SQLitePlugin` plugin for example. It only affects route callbacks that need a database connection. Other routes are left alone. Because of this, we can install the plugin application-wide with no additional overhead.\n\nTo install a plugin, just call `install()` with the plugin as first argument:\n\n``` python\nfrom bottle_sqlite import SQLitePlugin\ninstall(SQLitePlugin(dbfile='/tmp/test.db'))\n```\n\nThe plugin is not applied to the route callbacks yet. This is delayed to make sure no routes are missed. You can install plugins first and add routes later, if you want to. The order of installed plugins is significant, though. If a plugin requires a database connection, you need to install the database plugin first.\n\n#### Uninstall Plugins\n\nYou can use a name, class or instance to `uninstall()` a previously installed plugin:\n\n``` python\nsqlite_plugin = SQLitePlugin(dbfile='/tmp/test.db')\ninstall(sqlite_plugin)\n\nuninstall(sqlite_plugin) # uninstall a specific plugin\nuninstall(SQLitePlugin)  # uninstall all plugins of that type\nuninstall('sqlite')      # uninstall all plugins with that name\nuninstall(True)          # uninstall all plugins at once\n```\n\nPlugins can be installed and removed at any time, even at runtime while serving requests. This enables some neat tricks (installing slow debugging or profiling plugins only when needed) but should not be overused. Each time the list of plugins changes, the route cache is flushed and all plugins are re-applied.\n\nNote\n\nThe module-level `install()` and `uninstall()` functions affect the [Default Application](#default-app). To manage plugins for a specific application, use the corresponding methods on the [`Bottle`](api#bottle.Bottle \"bottle.Bottle\") application object.\n\n### Route-specific Installation\n\nThe `apply` parameter of the [`route()`](api#bottle.route \"bottle.route\") decorator comes in handy if you want to install plugins to only a small number of routes:\n\n``` python\nsqlite_plugin = SQLitePlugin(dbfile='/tmp/test.db')\n\n@route('/create', apply=[sqlite_plugin])\ndef create(db):\n    db.execute('INSERT INTO ...')\n```\n\n### Blacklisting Plugins\n\nYou may want to explicitly disable a plugin for a number of routes. The [`route()`](api#bottle.route \"bottle.route\") decorator has a `skip` parameter for this purpose:\n\n``` python\nsqlite_plugin = SQLitePlugin(dbfile='/tmp/test1.db')\ninstall(sqlite_plugin)\n\ndbfile1 = '/tmp/test1.db'\ndbfile2 = '/tmp/test2.db'\n\n@route('/open/<db>', skip=[sqlite_plugin])\ndef open_db(db):\n    # The 'db' keyword argument is not touched by the plugin this time.\n\n    # The plugin handle can be used for runtime configuration, too.\n    if db == 'test1':\n        sqlite_plugin.dbfile = dbfile1\n    elif db == 'test2':\n        sqlite_plugin.dbfile = dbfile2\n    else:\n        abort(404, \"No such database.\")\n\n    return \"Database File switched to: \" + sqlite_plugin.dbfile\n```\n\nThe `skip` parameter accepts a single value or a list of values. You can use a name, class or instance to identify the plugin that is to be skipped. Set `skip=True` to skip all plugins at once.\n\n### Plugins and Sub-Applications\n\nMost plugins are specific to the application they were installed to. Consequently, they should not affect sub-applications mounted with [`Bottle.mount()`](api#bottle.Bottle.mount \"bottle.Bottle.mount\"). Here is an example:\n\n``` python\nroot = Bottle()\nroot.mount('/blog', apps.blog)\n\n@root.route('/contact', template='contact')\ndef contact():\n    return {'email': 'contact@example.com'}\n\nroot.install(plugins.WTForms())\n```\n\nWhenever you mount an application, Bottle creates a proxy-route on the main-application that forwards all requests to the sub-application. Plugins are disabled for this kind of proxy-route by default. As a result, our (fictional) `WTForms` plugin affects the `/contact` route, but does not affect the routes of the `/blog` sub-application.\n\nThis behavior is intended as a sane default, but can be overridden. The following example re-activates all plugins for a specific proxy-route:\n\n``` python\nroot.mount('/blog', apps.blog, skip=None)\n```\n\nBut there is a snag: The plugin sees the whole sub-application as a single route, namely the proxy-route mentioned above. In order to affect each individual route of the sub-application, you have to install the plugin to the mounted application explicitly.\n\n## Development\n\nSo you have learned the basics and want to write your own application? Here are some tips that might help you to be more productive.\n\n### Default Application\n\nBottle maintains a global stack of [`Bottle`](api#bottle.Bottle \"bottle.Bottle\") instances and uses the top of the stack as a default for some of the module-level functions and decorators. The [`route()`](api#bottle.route \"bottle.route\") decorator, for example, is a shortcut for calling [`Bottle.route()`](api#bottle.Bottle.route \"bottle.Bottle.route\") on the default application:\n\n``` python\n@route('/')\ndef hello():\n    return 'Hello World'\n```\n\nThis is very convenient for small applications and saves you some typing, but also means that, as soon as your module is imported, routes are installed to the global application. To avoid this kind of import side-effects, Bottle offers a second, more explicit way to build applications:\n\n``` python\napp = Bottle()\n\n@app.route('/')\ndef hello():\n    return 'Hello World'\n```\n\nSeparating the application object improves re-usability a lot, too. Other developers can safely import the `app` object from your module and use [`Bottle.mount()`](api#bottle.Bottle.mount \"bottle.Bottle.mount\") to merge applications together.\n\nAs an alternative, you can make use of the application stack to isolate your routes while still using the convenient shortcuts:\n\n``` python\ndefault_app.push()\n\n@route('/')\ndef hello():\n    return 'Hello World'\n\napp = default_app.pop()\n```\n\nBoth [`app()`](api#bottle.app \"bottle.app\") and [`default_app()`](api#bottle.default_app \"bottle.default_app\") are instance of [`AppStack`](api#bottle.AppStack \"bottle.AppStack\") and implement a stack-like API. You can push and pop applications from and to the stack as needed. This also helps if you want to import a third party module that does not offer a separate application object:\n\n``` python\ndefault_app.push()\n\nimport some.module\n\napp = default_app.pop()\n```\n\n### Debug Mode\n\nDuring early development, the debug mode can be very helpful.\n\n``` python\nbottle.debug(True)\n```\n\nIn this mode, Bottle is much more verbose and provides helpful debugging information whenever an error occurs. It also disables some optimisations that might get in your way and adds some checks that warn you about possible misconfiguration.\n\nHere is an incomplete list of things that change in debug mode:\n\n- The default error page shows a traceback.\n- Templates are not cached.\n- Plugins are applied immediately.\n\nJust make sure not to use the debug mode on a production server.\n\n### Auto Reloading\n\nDuring development, you have to restart the server a lot to test your recent changes. The auto reloader can do this for you. Every time you edit a module file, the reloader restarts the server process and loads the newest version of your code.\n\n``` python\nfrom bottle import run\nrun(reloader=True)\n```\n\nHow it works: the main process will not start a server, but spawn a new child process using the same command line arguments used to start the main process. All module-level code is executed at least twice! Be careful.\n\nThe child process will have `os.environ['BOTTLE_CHILD']` set to `True` and start as a normal non-reloading app server. As soon as any of the loaded modules changes, the child process is terminated and re-spawned by the main process. Changes in template files will not trigger a reload. Please use debug mode to deactivate template caching.\n\nThe reloading depends on the ability to stop the child process. If you are running on Windows or any other operating system not supporting `signal.SIGINT` (which raises `KeyboardInterrupt` in Python), `signal.SIGTERM` is used to kill the child. Note that exit handlers and finally clauses, etc., are not executed after a `SIGTERM`.\n\n### Command Line Interface\n\nStarting with version 0.10 you can use bottle as a command-line tool:\n\n``` console\n$ python -m bottle\n\nUsage: bottle.py [options] package.module:app\n\nOptions:\n  -h, --help            show this help message and exit\n  --version             show version number.\n  -b ADDRESS, --bind=ADDRESS\n                        bind socket to ADDRESS.\n  -s SERVER, --server=SERVER\n                        use SERVER as backend.\n  -p PLUGIN, --plugin=PLUGIN\n                        install additional plugin/s.\n  --debug               start server in debug mode.\n  --reload              auto-reload on file changes.\n```\n\nThe `ADDRESS` field takes an IP address or an IP:PORT pair and defaults to `localhost:8080`. The other parameters should be self-explanatory.\n\nBoth plugins and applications are specified via import expressions. These consist of an import path (e.g. `package.module`) and an expression to be evaluated in the namespace of that module, separated by a colon. See [`load()`](api#bottle.load \"bottle.load\") for details. Here are some examples:\n\n``` console\n# Grab the 'app' object from the 'myapp.controller' module and\n# start a paste server on port 80 on all interfaces.\npython -m bottle -server paste -bind 0.0.0.0:80 myapp.controller:app\n\n# Start a self-reloading development server and serve the global\n# default application. The routes are defined in 'test.py'\npython -m bottle --debug --reload test\n\n# Install a custom debug plugin with some parameters\npython -m bottle --debug --reload --plugin 'utils:DebugPlugin(exc=True)'' test\n\n# Serve an application that is created with 'myapp.controller.make_app()'\n# on demand.\npython -m bottle 'myapp.controller:make_app()''\n```\n\n## Deployment\n\nBottle runs on the built-in [wsgiref WSGIServer](http://docs.python.org/library/wsgiref.html#module-wsgiref.simple_server) by default. This non-threading HTTP server is perfectly fine for development and early production, but may become a performance bottleneck when server load increases.\n\nThe easiest way to increase performance is to install a multi-threaded server library like [paste](http://pythonpaste.org/) or [cherrypy](http://www.cherrypy.org/) and tell Bottle to use that instead of the single-threaded server:\n\n``` python\nbottle.run(server='paste')\n```\n\nThis, and many other deployment options are described in a separate article: [Deployment](deployment)\n\n## Glossary\n\n`callback`  \nProgrammer code that is to be called when some external action happens. In the context of web frameworks, the mapping between URL paths and application code is often achieved by specifying a callback function for each URL.\n\n`decorator`  \nA function returning another function, usually applied as a function transformation using the `@decorator` syntax. See [python documentation for function definition](http://docs.python.org/reference/compound_stmts.html#function) for more about decorators.\n\n`environ`  \nA structure where information about all documents under the root is saved, and used for cross-referencing. The environment is pickled after the parsing stage, so that successive runs only need to read and parse new and changed documents.\n\n`handler function`  \nA function to handle some specific event or situation. In a web framework, the application is developed by attaching a handler function as callback for each specific URL comprising the application.\n\n`source directory`  \nThe directory which, including its subdirectories, contains all source files for one Sphinx project.\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/tutorial.html](https://bottlepy.org/docs/0.12/tutorial.html)"
- name: 'Tutorial: Todo-List Application'
  id: tutorial_app
  summary: This tutorial is a work in progess and written by noisefloor
  description: "# Tutorial: Todo-List Application\n\nNote\n\nThis tutorial is a work in progess and written by [noisefloor](http://github.com/noisefloor).\n\nThis tutorial should give a brief introduction to the [Bottle](http://bottle.paws.org) WSGI Framework. The main goal is to be able, after reading through this tutorial, to create a project using Bottle. Within this document, not all abilities will be shown, but at least the main and important ones like routing, utilizing the Bottle template abilities to format output and handling GET / POST parameters.\n\nTo understand the content here, it is not necessary to have a basic knowledge of WSGI, as Bottle tries to keep WSGI away from the user anyway. You should have a fair understanding of the [Python](http://www.python.org) programming language. Furthermore, the example used in the tutorial retrieves and stores data in a SQL databse, so a basic idea about SQL helps, but is not a must to understand the concepts of Bottle. Right here, [SQLite](http://www.sqlite.org) is used. The output of Bottle sent to the browser is formatted in some examples by the help of HTML. Thus, a basic idea about the common HTML tags does help as well.\n\nFor the sake of introducing Bottle, the Python code “in between” is kept short, in order to keep the focus. Also all code within the tutorial is working fine, but you may not necessarily use it “in the wild”, e.g. on a public web server. In order to do so, you may add e.g. more error handling, protect the database with a password, test and escape the input etc.\n\nTable of Contents\n\n- [Tutorial: Todo-List Application](#tutorial-todo-list-application)\n  - [Goals](#goals)\n  - [Before We Start...](#before-we-start)\n  - [Using Bottle for a Web-Based ToDo List](#using-bottle-for-a-web-based-todo-list)\n  - [Server Setup](#server-setup)\n  - [Final Words](#final-words)\n  - [Complete Example Listing](#complete-example-listing)\n\n## Goals\n\nAt the end of this tutorial, we will have a simple, web-based ToDo list. The list contains a text (with max 100 characters) and a status (0 for closed, 1 for open) for each item. Through the web-based user interface, open items can be view and edited and new items can be added.\n\nDuring development, all pages will be available on `localhost` only, but later on it will be shown how to adapt the application for a “real” server, including how to use with Apache’s mod_wsgi.\n\nBottle will do the routing and format the output, with the help of templates. The items of the list will be stored inside a SQLite database. Reading and writing the database will be done by Python code.\n\nWe will end up with an application with the following pages and functionality:\n\n- start page `http://localhost:8080/todo`\n- adding new items to the list: `http://localhost:8080/new`\n- page for editing items: `http://localhost:8080/edit/:no`\n- validating data assigned by dynamic routes with the @validate decorator\n- catching errors\n\n## Before We Start...\n\n#### Install Bottle\n\nAssuming that you have a fairly new installation of Python (version 2.5 or higher), you only need to install Bottle in addition to that. Bottle has no other dependencies than Python itself.\n\nYou can either manually install Bottle or use Python’s easy_install: `easy_install bottle`\n\n#### Further Software Necessities\n\nAs we use SQLite3 as a database, make sure it is installed. On Linux systems, most distributions have SQLite3 installed by default. SQLite is available for Windows and MacOS X as well and the `sqlite3` module is part of the python standard library.\n\n#### Create An SQL Database\n\nFirst, we need to create the database we use later on. To do so, save the following script in your project directory and run it with python. You can use the interactive interpreter too:\n\n``` python\nimport sqlite3\ncon = sqlite3.connect('todo.db') # Warning: This file is created in the current directory\ncon.execute(\"CREATE TABLE todo (id INTEGER PRIMARY KEY, task char(100) NOT NULL, status bool NOT NULL)\")\ncon.execute(\"INSERT INTO todo (task,status) VALUES ('Read A-byte-of-python to get a good introduction into Python',0)\")\ncon.execute(\"INSERT INTO todo (task,status) VALUES ('Visit the Python website',1)\")\ncon.execute(\"INSERT INTO todo (task,status) VALUES ('Test various editors for and check the syntax highlighting',1)\")\ncon.execute(\"INSERT INTO todo (task,status) VALUES ('Choose your favorite WSGI-Framework',0)\")\ncon.commit()\n```\n\nThis generates a database-file `todo.db` with tables called `todo` and three columns `id`, `task`, and `status`. `id` is a unique id for each row, which is used later on to reference the rows. The column `task` holds the text which describes the task, it can be max 100 characters long. Finally, the column `status` is used to mark a task as open (value 1) or closed (value 0).\n\n## Using Bottle for a Web-Based ToDo List\n\nNow it is time to introduce Bottle in order to create a web-based application. But first, we need to look into a basic concept of Bottle: routes.\n\n#### Understanding routes\n\nBasically, each page visible in the browser is dynamically generated when the page address is called. Thus, there is no static content. That is exactly what is called a “route” within Bottle: a certain address on the server. So, for example, when the page `http://localhost:8080/todo` is called from the browser, Bottle “grabs” the call and checks if there is any (Python) function defined for the route “todo”. If so, Bottle will execute the corresponding Python code and return its result.\n\n#### First Step - Showing All Open Items\n\nSo, after understanding the concept of routes, let’s create the first one. The goal is to see all open items from the ToDo list:\n\n``` python\nimport sqlite3\nfrom bottle import route, run\n\n@route('/todo')\ndef todo_list():\n    conn = sqlite3.connect('todo.db')\n    c = conn.cursor()\n    c.execute(\"SELECT id, task FROM todo WHERE status LIKE '1'\")\n    result = c.fetchall()\n    return str(result)\n\nrun()\n```\n\nSave the code a `todo.py`, preferably in the same directory as the file `todo.db`. Otherwise, you need to add the path to `todo.db` in the `sqlite3.connect()` statement.\n\nLet’s have a look what we just did: We imported the necessary module `sqlite3` to access to SQLite database and from Bottle we imported `route` and `run`. The `run()` statement simply starts the web server included in Bottle. By default, the web server serves the pages on localhost and port 8080. Furthermore, we imported `route`, which is the function responsible for Bottle’s routing. As you can see, we defined one function, `todo_list()`, with a few lines of code reading from the database. The important point is the [decorator statement](http://docs.python.org/glossary.html#term-decorator) `@route('/todo')` right before the `def todo_list()` statement. By doing this, we bind this function to the route `/todo`, so every time the browsers calls `http://localhost:8080/todo`, Bottle returns the result of the function `todo_list()`. That is how routing within bottle works.\n\nActually you can bind more than one route to a function. So the following code:\n\n``` python\n@route('/todo')\n@route('/my_todo_list')\ndef todo_list():\n    ...\n```\n\nwill work fine, too. What will not work is to bind one route to more than one function.\n\nWhat you will see in the browser is what is returned, thus the value given by the `return` statement. In this example, we need to convert `result` in to a string by `str()`, as Bottle expects a string or a list of strings from the return statement. But here, the result of the database query is a list of tuples, which is the standard defined by the [Python DB API](http://www.python.org/dev/peps/pep-0249/).\n\nNow, after understanding the little script above, it is time to execute it and watch the result yourself. Remember that on Linux- / Unix-based systems the file `todo.py` needs to be executable first. Then, just run `python todo.py` and call the page `http://localhost:8080/todo` in your browser. In case you made no mistake writing the script, the output should look like this:\n\n``` python\n[(2, u'Visit the Python website'), (3, u'Test various editors for and check the syntax highlighting')]\n```\n\nIf so - congratulations! You are now a successful user of Bottle. In case it did not work and you need to make some changes to the script, remember to stop Bottle serving the page, otherwise the revised version will not be loaded.\n\nActually, the output is not really exciting nor nice to read. It is the raw result returned from the SQL query.\n\nSo, in the next step we format the output in a nicer way. But before we do that, we make our life easier.\n\n#### Debugging and Auto-Reload\n\nMaybe you already noticed that Bottle sends a short error message to the browser in case something within the script is wrong, e.g. the connection to the database is not working. For debugging purposes it is quite helpful to get more details. This can be easily achieved by adding the following statement to the script:\n\n``` python\nfrom bottle import run, route, debug\n...\n#add this at the very end:\ndebug(True)\nrun()\n```\n\nBy enabling “debug”, you will get a full stacktrace of the Python interpreter, which usually contains useful information for finding bugs. Furthermore, templates (see below) are not cached, thus changes to templates will take effect without stopping the server.\n\nWarning\n\nThat `debug(True)` is supposed to be used for development only, it should *not* be used in production environments.\n\nAnother quite nice feature is auto-reloading, which is enabled by modifying the `run()` statement to\n\n``` python\nrun(reloader=True)\n```\n\nThis will automatically detect changes to the script and reload the new version once it is called again, without the need to stop and start the server.\n\nAgain, the feature is mainly supposed to be used while developing, not on production systems.\n\n#### Bottle Template To Format The Output\n\nNow let’s have a look at casting the output of the script into a proper format.\n\nActually Bottle expects to receive a string or a list of strings from a function and returns them by the help of the built-in server to the browser. Bottle does not bother about the content of the string itself, so it can be text formatted with HTML markup, too.\n\nBottle brings its own easy-to-use template engine with it. Templates are stored as separate files having a `.tpl` extension. The template can be called then from within a function. Templates can contain any type of text (which will be most likely HTML-markup mixed with Python statements). Furthermore, templates can take arguments, e.g. the result set of a database query, which will be then formatted nicely within the template.\n\nRight here, we are going to cast the result of our query showing the open ToDo items into a simple table with two columns: the first column will contain the ID of the item, the second column the text. The result set is, as seen above, a list of tuples, each tuple contains one set of results.\n\nTo include the template in our example, just add the following lines:\n\n``` python\nfrom bottle import route, run, debug, template\n...\nresult = c.fetchall()\nc.close()\noutput = template('make_table', rows=result)\nreturn output\n...\n```\n\nSo we do here two things: first, we import `template` from Bottle in order to be able to use templates. Second, we assign the output of the template `make_table` to the variable `output`, which is then returned. In addition to calling the template, we assign `result`, which we received from the database query, to the variable `rows`, which is later on used within the template. If necessary, you can assign more than one variable / value to a template.\n\nTemplates always return a list of strings, thus there is no need to convert anything. Of course, we can save one line of code by writing `return template('make_table', rows=result)`, which gives exactly the same result as above.\n\nNow it is time to write the corresponding template, which looks like this:\n\n``` python\n%#template to generate a HTML table from a list of tuples (or list of lists, or tuple of tuples or ...)\n<p>The open items are as follows:</p>\n<table border=\"1\">\n%for row in rows:\n  <tr>\n  %for col in row:\n    <td>{{col}}</td>\n  %end\n  </tr>\n%end\n</table>\n```\n\nSave the code as `make_table.tpl` in the same directory where `todo.py` is stored.\n\nLet’s have a look at the code: every line starting with % is interpreted as Python code. Please note that, of course, only valid Python statements are allowed, otherwise the template will raise an exception, just as any other Python code. The other lines are plain HTML markup.\n\nAs you can see, we use Python’s `for` statement two times, in order to go through `rows`. As seen above, `rows` is a variable which holds the result of the database query, so it is a list of tuples. The first `for` statement accesses the tuples within the list, the second one the items within the tuple, which are put each into a cell of the table. It is important that you close all `for`, `if`, `while` etc. statements with `%end`, otherwise the output may not be what you expect.\n\nIf you need to access a variable within a non-Python code line inside the template, you need to put it into double curly braces. This tells the template to insert the actual value of the variable right in place.\n\nRun the script again and look at the output. Still not really nice, but at least more readable than the list of tuples. Of course, you can spice-up the very simple HTML markup above, e.g. by using in-line styles to get a better looking output.\n\n#### Using GET and POST Values\n\nAs we can review all open items properly, we move to the next step, which is adding new items to the ToDo list. The new item should be received from a regular HTML-based form, which sends its data by the GET method.\n\nTo do so, we first add a new route to our script and tell the route that it should get GET data:\n\n``` python\nfrom bottle import route, run, debug, template, request\n...\nreturn template('make_table', rows=result)\n...\n\n@route('/new', method='GET')\ndef new_item():\n\n    new = request.GET.get('task', '').strip()\n\n    conn = sqlite3.connect('todo.db')\n    c = conn.cursor()\n\n    c.execute(\"INSERT INTO todo (task,status) VALUES (?,?)\", (new,1))\n    new_id = c.lastrowid\n\n    conn.commit()\n    c.close()\n\n    return '<p>The new task was inserted into the database, the ID is %s</p>' % new_id\n```\n\nTo access GET (or POST) data, we need to import `request` from Bottle. To assign the actual data to a variable, we use the statement `request.GET.get('task','').strip()` statement, where `task` is the name of the GET data we want to access. That’s all. If your GET data has more than one variable, multiple `request.GET.get()` statements can be used and assigned to other variables.\n\nThe rest of this piece of code is just processing of the gained data: writing to the database, retrieve the corresponding id from the database and generate the output.\n\nBut where do we get the GET data from? Well, we can use a static HTML page holding the form. Or, what we do right now, is to use a template which is output when the route `/new` is called without GET data.\n\nThe code needs to be extended to:\n\n``` python\n...\n@route('/new', method='GET')\ndef new_item():\n\n    if request.GET.get('save','').strip():\n\n        new = request.GET.get('task', '').strip()\n        conn = sqlite3.connect('todo.db')\n        c = conn.cursor()\n\n        c.execute(\"INSERT INTO todo (task,status) VALUES (?,?)\", (new,1))\n        new_id = c.lastrowid\n\n        conn.commit()\n        c.close()\n\n        return '<p>The new task was inserted into the database, the ID is %s</p>' % new_id\n    else:\n        return template('new_task.tpl')\n```\n\n`new_task.tpl` looks like this:\n\n``` python\n<p>Add a new task to the ToDo list:</p>\n<form action=\"/new\" method=\"GET\">\n<input type=\"text\" size=\"100\" maxlength=\"100\" name=\"task\">\n<input type=\"submit\" name=\"save\" value=\"save\">\n</form>\n```\n\nThat’s all. As you can see, the template is plain HTML this time.\n\nNow we are able to extend our to do list.\n\nBy the way, if you prefer to use POST data: this works exactly the same way, just use `request.POST.get()` instead.\n\n#### Editing Existing Items\n\nThe last point to do is to enable editing of existing items.\n\nBy using only the routes we know so far it is possible, but may be quite tricky. But Bottle knows something called “dynamic routes”, which makes this task quite easy.\n\nThe basic statement for a dynamic route looks like this:\n\n``` python\n@route('/myroute/:something')\n```\n\nThe key point here is the colon. This tells Bottle to accept for `:something` any string up to the next slash. Furthermore, the value of `something` will be passed to the function assigned to that route, so the data can be processed within the function.\n\nFor our ToDo list, we will create a route `@route('/edit/:no)`, where `no` is the id of the item to edit.\n\nThe code looks like this:\n\n``` python\n@route('/edit/:no', method='GET')\ndef edit_item(no):\n\n    if request.GET.get('save','').strip():\n        edit = request.GET.get('task','').strip()\n        status = request.GET.get('status','').strip()\n\n        if status == 'open':\n            status = 1\n        else:\n            status = 0\n\n        conn = sqlite3.connect('todo.db')\n        c = conn.cursor()\n        c.execute(\"UPDATE todo SET task = ?, status = ? WHERE id LIKE ?\", (edit, status, no))\n        conn.commit()\n\n        return '<p>The item number %s was successfully updated</p>' % no\n    else:\n        conn = sqlite3.connect('todo.db')\n        c = conn.cursor()\n        c.execute(\"SELECT task FROM todo WHERE id LIKE ?\", (str(no)))\n        cur_data = c.fetchone()\n\n        return template('edit_task', old=cur_data, no=no)\n```\n\nIt is basically pretty much the same what we already did above when adding new items, like using `GET` data etc. The main addition here is using the dynamic route `:no`, which here passes the number to the corresponding function. As you can see, `no` is used within the function to access the right row of data within the database.\n\nThe template `edit_task.tpl` called within the function looks like this:\n\n``` python\n%#template for editing a task\n%#the template expects to receive a value for \"no\" as well a \"old\", the text of the selected ToDo item\n<p>Edit the task with ID = {{no}}</p>\n<form action=\"/edit/{{no}}\" method=\"get\">\n<input type=\"text\" name=\"task\" value=\"{{old[0]}}\" size=\"100\" maxlength=\"100\">\n<select name=\"status\">\n<option>open</option>\n<option>closed</option>\n</select>\n<br/>\n<input type=\"submit\" name=\"save\" value=\"save\">\n</form>\n```\n\nAgain, this template is a mix of Python statements and HTML, as already explained above.\n\nA last word on dynamic routes: you can even use a regular expression for a dynamic route, as demonstrated later.\n\n#### Validating Dynamic Routes\n\nUsing dynamic routes is fine, but for many cases it makes sense to validate the dynamic part of the route. For example, we expect an integer number in our route for editing above. But if a float, characters or so are received, the Python interpreter throws an exception, which is not what we want.\n\nFor those cases, Bottle offers the `@validate` decorator, which validates the “input” prior to passing it to the function. In order to apply the validator, extend the code as follows:\n\n``` python\nfrom bottle import route, run, debug, template, request, validate\n...\n@route('/edit/:no', method='GET')\n@validate(no=int)\ndef edit_item(no):\n...\n```\n\nAt first, we imported `validate` from the Bottle framework, than we apply the @validate-decorator. Right here, we validate if `no` is an integer. Basically, the validation works with all types of data like floats, lists etc.\n\nSave the code and call the page again using a “403 forbidden” value for `:no`, e.g. a float. You will receive not an exception, but a “403 - Forbidden” error, saying that an integer was expected.\n\n#### Dynamic Routes Using Regular Expressions\n\nBottle can also handle dynamic routes, where the “dynamic part” of the route can be a regular expression.\n\nSo, just to demonstrate that, let’s assume that all single items in our ToDo list should be accessible by their plain number, by a term like e.g. “item1”. For obvious reasons, you do not want to create a route for every item. Furthermore, the simple dynamic routes do not work either, as part of the route, the term “item” is static.\n\nAs said above, the solution is a regular expression:\n\n``` python\n@route('/item:item#[0-9]+#')\ndef show_item(item):\n    conn = sqlite3.connect('todo.db')\n    c = conn.cursor()\n    c.execute(\"SELECT task FROM todo WHERE id LIKE ?\", (item))\n    result = c.fetchall()\n    c.close()\n    if not result:\n        return 'This item number does not exist!'\n    else:\n        return 'Task: %s' %result[0]\n```\n\nOf course, this example is somehow artificially constructed - it would be easier to use a plain dynamic route only combined with a validation. Nevertheless, we want to see how regular expression routes work: the line `@route(/item:item_#[0-9]+#)` starts like a normal route, but the part surrounded by \\# is interpreted as a regular expression, which is the dynamic part of the route. So in this case, we want to match any digit between 0 and 9. The following function “show_item” just checks whether the given item is present in the database or not. In case it is present, the corresponding text of the task is returned. As you can see, only the regular expression part of the route is passed forward. Furthermore, it is always forwarded as a string, even if it is a plain integer number, like in this case.\n\n#### Returning Static Files\n\nSometimes it may become necessary to associate a route not to a Python function, but just return a static file. So if you have for example a help page for your application, you may want to return this page as plain HTML. This works as follows:\n\n``` python\nfrom bottle import route, run, debug, template, request, validate, static_file\n\n@route('/help')\ndef help():\n    return static_file('help.html', root='/path/to/file')\n```\n\nAt first, we need to import the `static_file` function from Bottle. As you can see, the `return static_file` statement replaces the `return` statement. It takes at least two arguments: the name of the file to be returned and the path to the file. Even if the file is in the same directory as your application, the path needs to be stated. But in this case, you can use `'.'` as a path, too. Bottle guesses the MIME-type of the file automatically, but in case you like to state it explicitly, add a third argument to `static_file`, which would be here `mimetype='text/html'`. `static_file` works with any type of route, including the dynamic ones.\n\n#### Returning JSON Data\n\nThere may be cases where you do not want your application to generate the output directly, but return data to be processed further on, e.g. by JavaScript. For those cases, Bottle offers the possibility to return JSON objects, which is sort of standard for exchanging data between web applications. Furthermore, JSON can be processed by many programming languages, including Python\n\nSo, let’s assume we want to return the data generated in the regular expression route example as a JSON object. The code looks like this:\n\n``` python\n@route('/json:json#[0-9]+#')\ndef show_json(json):\n    conn = sqlite3.connect('todo.db')\n    c = conn.cursor()\n    c.execute(\"SELECT task FROM todo WHERE id LIKE ?\", (json))\n    result = c.fetchall()\n    c.close()\n\n    if not result:\n        return {'task':'This item number does not exist!'}\n    else:\n        return {'Task': result[0]}\n```\n\nAs you can, that is fairly simple: just return a regular Python dictionary and Bottle will convert it automatically into a JSON object prior to sending. So if you e.g. call “[http://localhost/json1](http://localhost/json1)” Bottle should in this case return the JSON object `{\"Task\": [\"Read A-byte-of-python to get a good introduction into Python\"]}`.\n\n#### Catching Errors\n\nThe next step may is to catch the error with Bottle itself, to keep away any type of error message from the user of your application. To do that, Bottle has an “error-route”, which can be a assigned to a HTML-error.\n\nIn our case, we want to catch a 403 error. The code is as follows:\n\n``` python\nfrom bottle import error\n\n@error(403)\ndef mistake(code):\n    return 'The parameter you passed has the wrong format!'\n```\n\nSo, at first we need to import `error` from Bottle and define a route by `error(403)`, which catches all “403 forbidden” errors. The function “mistake” is assigned to that. Please note that `error()` always passes the error-code to the function - even if you do not need it. Thus, the function always needs to accept one argument, otherwise it will not work.\n\nAgain, you can assign more than one error-route to a function, or catch various errors with one function each. So this code:\n\n``` python\n@error(404)\n@error(403)\ndef mistake(code):\n    return 'There is something wrong!'\n```\n\nworks fine, the following one as well:\n\n``` python\n@error(403)\ndef mistake403(code):\n    return 'The parameter you passed has the wrong format!'\n\n@error(404)\ndef mistake404(code):\n    return 'Sorry, this page does not exist!'\n```\n\n#### Summary\n\nAfter going through all the sections above, you should have a brief understanding how the Bottle WSGI framework works. Furthermore you have all the knowledge necessary to use Bottle for your applications.\n\nThe following chapter give a short introduction how to adapt Bottle for larger projects. Furthermore, we will show how to operate Bottle with web servers which perform better on a higher load / more web traffic than the one we used so far.\n\n## Server Setup\n\nSo far, we used the standard server used by Bottle, which is the [WSGI reference Server](http://docs.python.org/library/wsgiref.html#module-wsgiref.simple_server) shipped along with Python. Although this server is perfectly suitable for development purposes, it is not really suitable for larger applications. But before we have a look at the alternatives, let’s have a look how to tweak the settings of the standard server first.\n\n#### Running Bottle on a different port and IP\n\nAs standard, Bottle serves the pages on the IP adress 127.0.0.1, also known as `localhost`, and on port `8080`. To modify the setting is pretty simple, as additional parameters can be passed to Bottle’s `run()` function to change the port and the address.\n\nTo change the port, just add `port=portnumber` to the run command. So, for example:\n\n``` python\nrun(port=80)\n```\n\nwould make Bottle listen to port 80.\n\nTo change the IP address where Bottle is listening:\n\n``` python\nrun(host='123.45.67.89')\n```\n\nOf course, both parameters can be combined, like:\n\n``` python\nrun(port=80, host='123.45.67.89')\n```\n\nThe `port` and `host` parameter can also be applied when Bottle is running with a different server, as shown in the following section.\n\n#### Running Bottle with a different server\n\nAs said above, the standard server is perfectly suitable for development, personal use or a small group of people only using your application based on Bottle. For larger tasks, the standard server may become a bottleneck, as it is single-threaded, thus it can only serve one request at a time.\n\nBut Bottle has already various adapters to multi-threaded servers on board, which perform better on higher load. Bottle supports [Cherrypy](http://www.cherrypy.org/), [Fapws3](http://github.com/william-os4y/fapws3), [Flup](http://trac.saddi.com/flup) and [Paste](http://pythonpaste.org/).\n\nIf you want to run for example Bottle with the Paste server, use the following code:\n\n``` python\nfrom bottle import PasteServer\n...\nrun(server=PasteServer)\n```\n\nThis works exactly the same way with `FlupServer`, `CherryPyServer` and `FapwsServer`.\n\n#### Running Bottle on Apache with mod_wsgi\n\nMaybe you already have an [Apache](http://www.apache.org) or you want to run a Bottle-based application large scale - then it is time to think about Apache with [mod_wsgi](http://code.google.com/p/modwsgi/).\n\nWe assume that your Apache server is up and running and mod_wsgi is working fine as well. On a lot of Linux distributions, mod_wsgi can be easily installed via whatever package management system is in use.\n\nBottle brings an adapter for mod_wsgi with it, so serving your application is an easy task.\n\nIn the following example, we assume that you want to make your application “ToDo list” accessible through `http://www.mypage.com/todo` and your code, templates and SQLite database are stored in the path `/var/www/todo`.\n\nWhen you run your application via mod_wsgi, it is imperative to remove the `run()` statement from your code, otherwise it won’t work here.\n\nAfter that, create a file called `adapter.wsgi` with the following content:\n\n``` python\nimport sys, os, bottle\n\nsys.path = ['/var/www/todo/'] + sys.path\nos.chdir(os.path.dirname(__file__))\n\nimport todo # This loads your application\n\napplication = bottle.default_app()\n```\n\nand save it in the same path, `/var/www/todo`. Actually the name of the file can be anything, as long as the extension is `.wsgi`. The name is only used to reference the file from your virtual host.\n\nFinally, we need to add a virtual host to the Apache configuration, which looks like this:\n\n``` python\n<VirtualHost *>\n    ServerName mypage.com\n\n    WSGIDaemonProcess todo user=www-data group=www-data processes=1 threads=5\n    WSGIScriptAlias / /var/www/todo/adapter.wsgi\n\n    <Directory /var/www/todo>\n        WSGIProcessGroup todo\n        WSGIApplicationGroup %{GLOBAL}\n        Order deny,allow\n        Allow from all\n    </Directory>\n</VirtualHost>\n```\n\nAfter restarting the server, your ToDo list should be accessible at `http://www.mypage.com/todo`\n\n## Final Words\n\nNow we are at the end of this introduction and tutorial to Bottle. We learned about the basic concepts of Bottle and wrote a first application using the Bottle framework. In addition to that, we saw how to adapt Bottle for large tasks and serve Bottle through an Apache web server with mod_wsgi.\n\nAs said in the introduction, this tutorial is not showing all shades and possibilities of Bottle. What we skipped here is e.g. receiving file objects and streams and how to handle authentication data. Furthermore, we did not show how templates can be called from within another template. For an introduction into those points, please refer to the full [Bottle documentation](http://bottlepy.org/docs/dev/tutorial.html) .\n\n## Complete Example Listing\n\nAs the ToDo list example was developed piece by piece, here is the complete listing:\n\nMain code for the application `todo.py`:\n\n``` python\nimport sqlite3\nfrom bottle import route, run, debug, template, request, validate, static_file, error\n\n# only needed when you run Bottle on mod_wsgi\nfrom bottle import default_app\n\n@route('/todo')\ndef todo_list():\n\n    conn = sqlite3.connect('todo.db')\n    c = conn.cursor()\n    c.execute(\"SELECT id, task FROM todo WHERE status LIKE '1';\")\n    result = c.fetchall()\n    c.close()\n\n    output = template('make_table', rows=result)\n    return output\n\n@route('/new', method='GET')\ndef new_item():\n\n    if request.GET.get('save','').strip():\n\n        new = request.GET.get('task', '').strip()\n        conn = sqlite3.connect('todo.db')\n        c = conn.cursor()\n\n        c.execute(\"INSERT INTO todo (task,status) VALUES (?,?)\", (new,1))\n        new_id = c.lastrowid\n\n        conn.commit()\n        c.close()\n\n        return '<p>The new task was inserted into the database, the ID is %s</p>' % new_id\n\n    else:\n        return template('new_task.tpl')\n\n@route('/edit/:no', method='GET')\n@validate(no=int)\ndef edit_item(no):\n\n    if request.GET.get('save','').strip():\n        edit = request.GET.get('task','').strip()\n        status = request.GET.get('status','').strip()\n\n        if status == 'open':\n            status = 1\n        else:\n            status = 0\n\n        conn = sqlite3.connect('todo.db')\n        c = conn.cursor()\n        c.execute(\"UPDATE todo SET task = ?, status = ? WHERE id LIKE ?\", (edit,status,no))\n        conn.commit()\n\n        return '<p>The item number %s was successfully updated</p>' %no\n\n    else:\n        conn = sqlite3.connect('todo.db')\n        c = conn.cursor()\n        c.execute(\"SELECT task FROM todo WHERE id LIKE ?\", (str(no)))\n        cur_data = c.fetchone()\n\n        return template('edit_task', old = cur_data, no = no)\n\n@route('/item:item#[0-9]+#')\ndef show_item(item):\n\n        conn = sqlite3.connect('todo.db')\n        c = conn.cursor()\n        c.execute(\"SELECT task FROM todo WHERE id LIKE ?\", (item))\n        result = c.fetchall()\n        c.close()\n\n        if not result:\n            return 'This item number does not exist!'\n        else:\n            return 'Task: %s' %result[0]\n\n@route('/help')\ndef help():\n\n    static_file('help.html', root='.')\n\n@route('/json:json#[0-9]+#')\ndef show_json(json):\n\n    conn = sqlite3.connect('todo.db')\n    c = conn.cursor()\n    c.execute(\"SELECT task FROM todo WHERE id LIKE ?\", (json))\n    result = c.fetchall()\n    c.close()\n\n    if not result:\n        return {'task':'This item number does not exist!'}\n    else:\n        return {'Task': result[0]}\n\n\n@error(403)\ndef mistake403(code):\n    return 'There is a mistake in your url!'\n\n@error(404)\ndef mistake404(code):\n    return 'Sorry, this page does not exist!'\n\n\ndebug(True)\nrun(reloader=True)\n#remember to remove reloader=True and debug(True) when you move your application from development to a productive environment\n```\n\nTemplate `make_table.tpl`:\n\n``` python\n%#template to generate a HTML table from a list of tuples (or list of lists, or tuple of tuples or ...)\n<p>The open items are as follows:</p>\n<table border=\"1\">\n%for row in rows:\n  <tr>\n  %for col in row:\n    <td>{{col}}</td>\n  %end\n  </tr>\n%end\n</table>\n```\n\nTemplate `edit_task.tpl`:\n\n``` python\n%#template for editing a task\n%#the template expects to receive a value for \"no\" as well a \"old\", the text of the selected ToDo item\n<p>Edit the task with ID = {{no}}</p>\n<form action=\"/edit/{{no}}\" method=\"get\">\n<input type=\"text\" name=\"task\" value=\"{{old[0]}}\" size=\"100\" maxlength=\"100\">\n<select name=\"status\">\n<option>open</option>\n<option>closed</option>\n</select>\n<br/>\n<input type=\"submit\" name=\"save\" value=\"save\">\n</form>\n```\n\nTemplate `new_task.tpl`:\n\n``` python\n%#template for the form for a new task\n<p>Add a new task to the ToDo list:</p>\n<form action=\"/new\" method=\"GET\">\n<input type=\"text\" size=\"100\" maxlength=\"100\" name=\"task\">\n<input type=\"submit\" name=\"save\" value=\"save\">\n</form>\n```\n\n© 2009–2017 Marcel Hellkamp  \nLicensed under the MIT License.  \n[https://bottlepy.org/docs/0.12/tutorial_app.html](https://bottlepy.org/docs/0.12/tutorial_app.html)"
- name: view()
  id: api#bottle.view
  summary: 'Decorator: renders a template for a handler'
  belongs_to: API Reference
  description: |-
    `view(tpl_name, **defaults)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#view)

    Decorator: renders a template for a handler. The handler can control its behavior like that:

    - return a dict of template vars to fill out the template
    - return something other than a dict and the view decorator will not process the template, but return the handler result as is. This includes returning a HTTPResponse(dict) to get, for instance, JSON with autojson or other castfilters.
- name: WSGIHeaderDict
  id: api#bottle.WSGIHeaderDict
  summary: This dict-like class wraps a WSGI environ dict and provides convenient access to HTTP_* fields
  belongs_to: API Reference
  description: |-
    `class WSGIHeaderDict(environ)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#WSGIHeaderDict)

    This dict-like class wraps a WSGI environ dict and provides convenient access to HTTP\_\* fields. Keys and values are native strings (2.x bytes or 3.x unicode) and keys are case-insensitive. If the WSGI environment contains non-native string values, these are de- or encoded using a lossless ‘latin1’ character set.

    The API will remain stable even on changes to the relevant PEPs. Currently PEP 333, 444 and 3333 are supported. (PEP 444 is the only one that uses non-native strings.)

    `cgikeys = ('CONTENT_TYPE', 'CONTENT_LENGTH')`

    List of keys that do not have a `HTTP_` prefix.
- name: WSGIHeaderDict::raw()
  id: api#bottle.WSGIHeaderDict.raw
  summary: Return the header value as is (may be bytes or unicode)
  belongs_to: API Reference
  description: |-
    `raw(key, default=None)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#WSGIHeaderDict.raw)

    Return the header value as is (may be bytes or unicode).
- name: yieldroutes()
  id: api#bottle.yieldroutes
  summary: Return a generator for routes that match the signature (name, args) of the func parameter
  belongs_to: API Reference
  description: |-
    `yieldroutes(func)` [\[source\]](https://bottlepy.org/docs/0.12/_modules/bottle.html#yieldroutes)

    Return a generator for routes that match the signature (name, args) of the func parameter. This may yield more than one route if the function takes optional keyword arguments. The output is best described by example:

    ``` python
    a()         -> '/a'
    b(x, y)     -> '/b/<x>/<y>'
    c(x, y=5)   -> '/c/<x>' and '/c/<x>/<y>'
    d(x=5, y=6) -> '/d' and '/d/<x>' and '/d/<x>/<y>'
    ```
