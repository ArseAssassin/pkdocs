---
name: Marionette.js
slug: marionette~4
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: '4'
copyright: |-
  © 2017 Muted Solutions, LLC
  Licensed under the MIT License.
  https://marionettejs.com/docs/v4.0.0/index
homepage: https://marionettejs.com/

---
- name: Application
  id: marionette.application
  summary: The Application provides hooks for organizing and initiating other elements and a view tree
  description: "# Marionette.Application\n\nThe `Application` provides hooks for organizing and initiating other elements and a view tree.\n\n`Application` includes:\n\n- [Common Marionette Functionality](common)\n- [Class Events](events.class#application-events)\n- [Radio API](backbone.radio#marionette-integration)\n- [MnObject's API](marionette.mnobject)\n\nIn addition to `MnObject`'s API, Application provides two significant additions. A simple lifecycle hook with [`start`](#starting-an-application) and a [single region](#application-region) for attaching a view tree.\n\nOne additional difference is the `Application` [`cidPrefix`](marionette.mnobject#unique-client-id) is `mna`.\n\n## Documentation Index\n\n- [Instantiating An Application](#instantiating-an-application)\n- [Starting An Application](#starting-an-application)\n- [Application Region](#application-region)\n- [Application Region Methods](#application-region-methods)\n\n## Instantiating an Application\n\nWhen instantiating a `Application` there are several properties, if passed, that will be attached directly to the instance: `channelName`, `radioEvents`, `radioRequests`, `region`, `regionClass`\n\n``` javascript\nimport { Application } from 'backbone.marionette';\n\nconst myApplication = new Application({ ... });\n```\n\n## Starting An Application\n\nOnce you have your application configured, you can kick everything off by calling: `myApp.start(options)`.\n\nThis function takes a single optional argument to pass along to the events.\n\n``` javascript\nimport Bb from 'backbone';\nimport { Application } from 'backbone.marionette';\n\nconst MyApp = Application.extend({\n  region: '#root-element',\n\n  initialize(options) {\n    console.log('Initialize');\n  },\n\n  onBeforeStart(app, options) {\n    this.model = new MyModel(options.data);\n  },\n\n  onStart(app, options) {\n    this.showView(new MyView({model: this.model}));\n    Bb.history.start();\n  }\n});\n\nconst myApp = new MyApp();\n\nmyApp.start({\n  data: {\n    id: 1,\n    text: 'value'\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/k05dctyt/)\n\n## Application Region\n\nAn `Application` provides a single [region](marionette.region) for attaching a view tree. The `region` property can be [defined in multiple ways](marionette.region#defining-regions)\n\n``` javascript\nimport { Application } from 'backbone.marionette';\nimport RootView from './views/root';\n\nconst MyApp = Application.extend({\n  region: '#root-element',\n\n  onStart() {\n    this.showView(new RootView());\n  }\n});\n\nconst myApp = new MyApp();\nmyApp.start();\n```\n\n[Live example](https://jsfiddle.net/marionettejs/uzc8or6u/)\n\nThis will immediately render `RootView` and fire the usual triggers such as `before:attach` and `attach` in addition to the `before:render` and `render` triggers.\n\n`region` can also be passed as an option during instantiation.\n\n### `regionClass`\n\nBy default the [`Region`](marionette.region) is used to instantiate the `Application`'s region. An extended Region can be provided to the `Application` definition to override the default.\n\n``` javascript\nimport { Application, Region } from 'backbone.marionette';\n\nconst MyRegion = Region.extend({\n  isSpecial: true\n});\n\nconst MyApp = Application.extend({\n  regionClass: MyRegion\n});\n\nconst myApp = new Application({ region: '#foo' });\n\nmyApp.getRegion().isSpecial; // true\n```\n\n`regionClass` can also be passed as an option during instantiation.\n\n## Application Region Methods\n\nThe Marionette Application provides helper methods for managing its attached region.\n\n### `getRegion()`\n\nReturn the attached [region object](marionette.region) for the Application.\n\n### `showView(view)`\n\nDisplay a `View` instance in the region attached to the Application. This runs the [`View lifecycle`](view.lifecycle).\n\n### `getView()`\n\nReturn the view currently being displayed in the Application's attached `region`. If the Application is not currently displaying a view, this method returns `undefined`.\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/marionette.application.html](https://marionettejs.com/docs/v4.0.0/marionette.application.html)"
- name: Application Region
  id: marionette.application#application-region
  summary: An Application provides a single region for attaching a view tree
  belongs_to: Application
  description: |-
    ## Application Region

    An `Application` provides a single [region](marionette.region) for attaching a view tree. The `region` property can be [defined in multiple ways](marionette.region#defining-regions)

    ``` javascript
    import { Application } from 'backbone.marionette';
    import RootView from './views/root';

    const MyApp = Application.extend({
      region: '#root-element',

      onStart() {
        this.showView(new RootView());
      }
    });

    const myApp = new MyApp();
    myApp.start();
    ```

    [Live example](https://jsfiddle.net/marionettejs/uzc8or6u/)

    This will immediately render `RootView` and fire the usual triggers such as `before:attach` and `attach` in addition to the `before:render` and `render` triggers.

    `region` can also be passed as an option during instantiation.

    ### `regionClass`

    By default the [`Region`](marionette.region) is used to instantiate the `Application`'s region. An extended Region can be provided to the `Application` definition to override the default.

    ``` javascript
    import { Application, Region } from 'backbone.marionette';

    const MyRegion = Region.extend({
      isSpecial: true
    });

    const MyApp = Application.extend({
      regionClass: MyRegion
    });

    const myApp = new Application({ region: '#foo' });

    myApp.getRegion().isSpecial; // true
    ```

    `regionClass` can also be passed as an option during instantiation.
- name: Application Region Methods
  id: marionette.application#application-region-methods
  summary: The Marionette Application provides helper methods for managing its attached region
  belongs_to: Application
  description: "## Application Region Methods\n\nThe Marionette Application provides helper methods for managing its attached region.\n\n### `getRegion()`\n\nReturn the attached [region object](marionette.region) for the Application.\n\n### `showView(view)`\n\nDisplay a `View` instance in the region attached to the Application. This runs the [`View lifecycle`](view.lifecycle).\n\n### `getView()`\n\nReturn the view currently being displayed in the Application's attached `region`. If the Application is not currently displaying a view, this method returns `undefined`.\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/marionette.application.html](https://marionettejs.com/docs/v4.0.0/marionette.application.html)"
- name: Backbone Radio
  id: backbone.radio
  summary: The Backbone Radio provides easy support for a number of messaging patterns for Backbone and Marionette
  description: "# Backbone Radio\n\nThe Backbone Radio provides easy support for a number of messaging patterns for Backbone and Marionette. This is provided through two basic constructs:\n\n- Events - trigger events on a global object\n- Requests - a global request/reply implementation\n\nRadio takes these two constructs and adds the channel implementation - providing namespaces for events and requests. In short, Radio is a global, namespaced, message bus system designed to allow two otherwise unrelated objects to communicate and share information.\n\n## Documentation Index\n\n- [Radio Concepts](#radio-concepts)\n  - [Channel](#channel)\n  - [Event](#event)\n    - [When to use Events](#when-to-use-events)\n  - [Request](#request)\n    - [Returning Values from Reply](#returning-values-from-reply)\n    - [When to use Requests](#when-to-use-requests)\n- [Marionette Integration](#marionette-integration)\n  - [API](#api)\n  - [Examples](#examples)\n    - [Listening to Events](#listening-to-events)\n    - [Replying to Requests](#replying-to-requests)\n    - [Events and Requests](#events-and-requests)\n\n## Radio Concepts\n\nThe `Radio` message bus exposes some core concepts:\n\n- `Channel` - a namespace mechanism.\n- `Event` - alert other parts of your application that something happened.\n- `Request` - execute single functions in a different part of your application.\n\n### Channel\n\nThe `channel` is the biggest reason to use `Radio` as our event aggregator - it provides a clean point for dividing global events. To retrieve a channel, use `Radio.channel(channelName)`:\n\n``` javascript\nimport Radio from 'backbone.radio';\n\nconst myChannel = Radio.channel('basic');\n\nmyChannel.on('some:event', function() {\n  // ...\n});\n```\n\nThe channel is accessible everywhere in your application. Simply import Radio and call `channel()` to add listeners, fire callbacks, or send requests.\n\n``` javascript\nimport Radio from 'backbone.radio';\n\nconst someChannel = Radio.channel('basic');  // Exactly the same channel as above\n\nsomeChannel.trigger('some:event');  // Will fire the function call above\n```\n\n[Live example](https://jsfiddle.net/marionettejs/0bejfju0/)\n\n### Event\n\nThe `Radio Event` works exactly the same way as regular `Backbone Events` like model/collection events. In fact, it uses the `Backbone.Events` mixin internally, exposing its API:\n\n- `channel.on('event', callback, [context])` - when `event` fires, call `callback`\n- `channel.once('event', callback, [context])` - same as `on`, but triggered only once\n- `channel.off('event')` - stop listening to event\n- `channel.trigger('event', ..args)` - fires `event` and passes args into the resulting `callback`\n\nEvents are typically used to alert other parts of the system that something happened. For example, a user login expired or the user performed a specific action.\n\nAs the Radio can be imported anywhere, we can use it as a global event aggregator as such:\n\n``` javascript\nimport Radio from 'backbone.radio';\n\nconst myChannel = Radio.channel('star');\n\nmyChannel.on('left:building', function(person) {\n  console.log(person.get('name') + ' has left the building!');\n});\n\nconst elvis = new Bb.Model({name: 'Elvis'});\nmyChannel.trigger('left:building', elvis);\n\nmyChannel.off('left:building');\n```\n\nJust like Backbone Events, the Radio respects the `listenTo` handler as well:\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\nimport Radio from 'backbone.radio';\n\nconst starChannel = Radio.channel('star');\n\nconst Star = MnObject.extend({\n\n  initialize() {\n    this.listenTo(starChannel, 'left:building', this.leftBuilding);\n    this.listenTo(starChannel, 'enter:building', function(person) {\n       console.log(person.get('name') + ' has entered the building!');\n    });\n  },\n\n  leftBuilding(person) {\n    console.log(person.get('name') + ' has left the building!');\n  }\n});\n```\n\nNote that the event handler can be defined as a method like used for `'left:building'` event or inline like used in `'enter:building'`.\n\n[Live example](https://jsfiddle.net/marionettejs/s8nff8vz/)\n\nAs in Backbone, the event handler is called with `this` bound to the `Star` instance. See the [Backbone documentation](http://backbonejs.org/#Events) for the full list of Event handling methods.\n\n#### When to use Events\n\nThe Event is a simple notification that *something happened* and you may or may not want other objects in your application to react to that. A few key principles to bear in mind are:\n\n- If you don't know what could act on the event, or don't care, use an `Event`\n- If you find yourself calling it an action that occurred, use an `Event`\n- If it's fine for many objects to perform an action, use an `Event`\n- If you don't mind that no objects react, use an `Event`\n\nIf your use case isn't covered here, consider whether you want to [use a request](#when-to-use-requests) instead.\n\n### Request\n\nThe Request API provides a uniform way for unrelated parts of the system to communicate with each other. For example, displaying notifications in response to system activity. To attach a listener to a request channel, use `reply` or `replyOnce` to attach a listener that immediately detaches after one call.\n\nAs with request, any arguments passed in `channel.request` will be passed into the callback.\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\nimport Radio from 'backbone.radio';\n\nconst channel = Radio.channel('notify');\n\nconst Notification = MnObject.extend({\n\n  initialize() {\n    channel.reply('show:success', this.showSuccessMessage);\n    channel.reply('show:error', function(msg) {\n       // ...\n    });\n  },\n\n  showSuccessMessage(msg) {\n    // ...\n  }\n});\n```\n\nSo, for example, when a model sync fails:\n\n``` javascript\nimport { View } from 'backbone.marionette';\nimport Radio from 'backbone.radio';\n\nconst channel = Radio.channel('notify');\n\nconst ModelView = View.extend({\n  modelEvents: {\n    error: 'showErrorMessage'\n  },\n\n  showErrorMessage() {\n    channel.request('show:error', 'An error occurred contacting the server');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/4uuyLe1q/)\n\nNow, whenever the model attached to this View is unable to sync with the server, we can display an error message to the user.\n\n### Returning Values from Reply\n\nThe Request API is also able to return values, making it extremely useful for accessing objects that would be otherwise difficult to access. As an example, let's assume we attach the currently logged-in user to the `Application` object and we want to know if they're still logged-in.\n\n``` javascript\nimport { Application } from 'backbone.marionette';\nimport Radio from 'backbone.radio';\n\nconst channel = Radio.channel('user');\n\nconst App = Application.extend({\n  initialize() {\n    channel.reply('user:loggedIn', this.isLoggedIn);\n  },\n\n  isLoggedIn() {\n    return this.model.getLoggedIn();\n  }\n});\n```\n\nThen, from another view, instead of trying to find the User model. we simply `request` it:\n\n``` javascript\nconst Radio = require('backbone.radio');\n\nconst channel = Radio.channel('user');\n\nconst loggedIn = channel.request('user:loggedIn');  // App.model.getLoggedIn()\n```\n\n[Live example](https://jsfiddle.net/marionettejs/zaje1rLj/)\n\n### When to use Requests\n\nA Request is, as you might guess, a request for information or for something to happen. You will probably want to use requests when:\n\n- You call the request an action to perform e.g. `show:notification`\n- You want to get the return value of the request\n- You want to call *exactly one* function\n\nIn addition to this documentation, the Radio documentation can be found on [Github](https://github.com/marionettejs/backbone.radio).\n\n## Marionette Integration\n\nThe [`Application`](marionette.application) and [`MnObject`](marionette.mnobject) classes provide bindings to provide automatic event listeners and / or request handlers on your object instances. This works with a bound `channelName` to let us provide listeners using the `radioEvents` and `radioRequests` properties.\n\n**Errors** An error will be thrown if using the radio integration unless `backbone.radio` is setup as a dependency.\n\n### API\n\n- `channelName` - defines the Radio channel that will be used for the requests and/or events\n- `getChannel()` - returns a Radio.Channel instance using `channelName`\n- `radioEvents` - defines an events hash with the events to be listened and its respective handlers\n- `radioRequests` - defines an events hash with the requests to be replied and its respective handlers\n\n### Examples\n\n#### Listening to events\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\n\nconst Star = MnObject.extend({\n  channelName: 'star',\n\n  radioEvents: {\n    'left:building': 'leftBuilding'\n  },\n\n  leftBuilding(person) {\n    console.log(person.get('name') + ' has left the building!');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/tf9467x4/)\n\nThis gives us a clear definition of how this object interacts with the `star` radio channel.\n\n#### Replying to requests\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\n\nconst Notification = MnObject.extend({\n  channelName: 'notify',\n\n  radioRequests: {\n    'show:success': 'showSuccessMessage',\n    'show:error': 'showErrorMessage'\n  },\n\n  showSuccessMessage(msg) {\n    // ...\n  },\n\n  showErrorMessage(msg) {\n    // ...\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/j2qgfk3s/)\n\nWe now have a clear API for communicating with the `Notification` across the application. Don't forget to define the `channelName` on your `MnObject` definition.\n\nAs with a normal request/reply, we can return values from these bound handlers:\n\n``` javascript\nimport { Application } from 'backbone.marionette';\n\nconst App = Application.extend({\n  channelName: 'user',\n\n  radioRequests: {\n    'user:loggedIn': 'isLoggedIn'\n  },\n\n  isLoggedIn() {\n    return this.model.getLoggedIn();\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/52rpd3zg/)\n\n#### Events and requests\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\n\nconst NotificationHandler = MnObject.extend({\n  channelName: 'notify',\n\n  radioRequests: {\n    'show:success': 'showSuccessMessage',\n    'show:error': 'showErrorMessage'\n  },\n\n  radioEvents: {\n    'login:user': 'showProfileButton',\n    'logout:user': 'hideProfileButton'\n  },\n\n  showSuccessMessage(message) {\n    // ...\n  },\n\n  showErrorMessage(message) {\n    // ...\n  },\n\n  showProfileButton(user) {\n    // ...\n  },\n\n  hideProfileButton(user) {\n    // ...\n  }\n});\n```\n\nIn an unrelated module:\n\n``` javascript\nimport Radio from 'backbone.radio';\nimport User from './models/user';\n\nconst notifyChannel = Radio.channel('notify');\nconst userModel = new User();\n\n// The following will call Notification.showErrorMessage(message)\nnotifyChannel.request('show:error', 'A generic error occurred!');\n\n// The following will call Notification.showProfileButton(user)\nnotifyChannel.trigger('login:user', userModel);\n```\n\n[Live example](https://jsfiddle.net/marionettejs/dv40a0t2/)\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/backbone.radio.html](https://marionettejs.com/docs/v4.0.0/backbone.radio.html)"
- name: Behavior
  id: marionette.behavior
  summary: A Behavior provides a clean separation of concerns to your view logic, allowing you to share common user-facing operations between your views
  description: "# Marionette.Behavior\n\nA `Behavior` provides a clean separation of concerns to your view logic, allowing you to share common user-facing operations between your views.\n\n`Behavior` includes:\n\n- [Common Marionette Functionality](common)\n- [Class Events](events.class#behavior-events)\n- [DOM Interactions](dom.interactions)\n- [Entity Events](events.entity)\n\n`Behavior`s are particularly good at factoring out the common user, model and collection interactions to be utilized across your application. Unlike the other Marionette classes, `Behavior`s are not meant to be instantiated directly. Instead a `Behavior` should be instantiated by the view it is related to by [attaching the a behavior class definition to the view](#using-behaviors).\n\n## Documentation Index\n\n- [Instantiating a Behavior](#instantiating-a-behavior)\n- [Using Behaviors](#using-behaviors)\n  - [Defining and Attaching Behaviors](#defining-and-attaching-behaviors)\n  - [Behavior Options](#behavior-options)\n- [Nesting Behaviors](#nesting-behaviors)\n- [The Behavior's `view`](#the-behaviors-view)\n- [View Proxy](#view-proxy)\n  - [Listening to View Events](#listening-to-view-events)\n  - [Proxy Handlers](#proxy-handlers)\n  - [Events / Initialize Order](#events--initialize-order)\n  - [Using `ui`](#using-ui)\n  - [View DOM proxies](#view-dom-proxies)\n- [Destroying a Behavior](#destroying-a-behavior)\n\n## Instantiating a Behavior\n\nUnlike other [Marionette classes](classes), `Behavior`s are not meant to be instantiated except by a view.\n\n## Using Behaviors\n\nThe easiest way to see how to use the `Behavior` class is to take an example view and factor out common behavior to be shared across other views.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  ui: {\n    destroy: '.destroy-btn'\n  },\n\n  events: {\n    'click @ui.destroy': 'warnBeforeDestroy'\n  },\n\n  warnBeforeDestroy() {\n    alert('You are about to destroy all your data!');\n    this.destroy();\n  },\n\n  onRender() {\n    this.ui.destroy.tooltip({\n      text: 'What a nice mouse you have.'\n    });\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/pa8ryv03/)\n\nInteraction points, such as tooltips and warning messages, are generic concepts. There is no need to recode them within your Views so they are prime candidates to be extracted into `Behavior` classes.\n\n### Defining and Attaching Behaviors\n\n``` javascript\nimport { Behavior, View } from 'backbone.marionette';\n\nconst DestroyWarn = Behavior.extend({\n  // You can set default options\n  // They will be overridden if you pass in an option with the same key.\n  options: {\n    message: 'You are destroying!'\n  },\n\n  ui: {\n    destroy: '.destroy-btn'\n  },\n\n  // Behaviors have events that are bound to the views DOM.\n  events: {\n    'click @ui.destroy': 'warnBeforeDestroy'\n  },\n\n  warnBeforeDestroy() {\n    const message = this.getOption('message');\n    window.alert(message);\n    // Every Behavior has a hook into the\n    // view that it is attached to.\n    this.view.destroy();\n  }\n});\n\nconst ToolTip = Behavior.extend({\n  options: {\n    text: 'Tooltip text'\n  },\n\n  ui: {\n    tooltip: '.tooltip'\n  },\n\n  onRender() {\n    this.ui.tooltip.tooltip({\n      text: this.getOption('text')\n    });\n  }\n});\n\nconst MyView = View.extend({\n  behaviors: [DestroyWarn, ToolTip]\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/b1awta6u/)\n\nEach behavior will now be able to respond to user interactions as though the event handlers were attached to the view directly. In addition to using array notation, Behaviors can be attached using an object:\n\n``` javascript\nconst MyView = View.extend({\n  behaviors: {\n    destroy: DestroyWarn,\n    tooltip: ToolTip\n  }\n});\n```\n\n#### Behavior Options\n\nWhen we attach behaviors to views, we can also pass in options to add to the behavior. This tends to be static information relating to what the behavior should do. In our above example, we want to override the message to our `DestroyWarn` and `Tooltip` behaviors to match the original message on the View:\n\n``` javascript\nconst MyView = View.extend({\n  behaviors: [\n    {\n      behaviorClass: DestroyWarn,\n      message: 'You are about to destroy all your data!'\n    },\n    {\n      behaviorClass: ToolTip,\n      text: 'What a nice mouse you have.'\n    }\n  ]\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/vq9k3c69/)\n\nThere are several properties, if passed, that will be attached directly to the instance: `collectionEvents`, `events`, `modelEvents`, `triggers`, `ui`\n\nUsing an object, we must define the `behaviorClass` attribute to refer to our behaviors and then add any extra options with keys matching the option we want to override. Any passed options will override the values from `options` property.\n\n**Errors** An error will be thrown if the `Behavior` class is not passed.\n\n## Nesting Behaviors\n\nIn addition to extending a `View` with `Behavior`, a `Behavior` can itself use other Behaviors. The syntax is identical to that used for a `View`:\n\n``` javascript\nimport { Behavior } from 'backbone.marionette';\n\nconst Modal = Behavior.extend({\n  behaviors: [\n    {\n      behaviorClass: DestroyWarn,\n      message: 'Whoa! You sure about this?'\n    }\n  ]\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/7ffnqff3/)\n\nNested Behaviors act as if they were direct Behaviors of the parent `Behavior`'s view instance.\n\n## The Behavior's `view`\n\nThe `view` is a reference to the `View` instance that the `Behavior` is attached to.\n\n``` javascript\nimport { Behavior } from 'backbone.marionette';\n\nBehavior.extend({\n  handleDestroyClick() {\n    this.view.destroy();\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/p8vymo4j/)\n\n## View Proxy\n\nThe `Behavior` class provides proxies for a selection of `View` functionality. This includes [listening to events on the view](marionette.behavior), being able to [handle events on models and collections](marionette.behavior), and being able to directly [interact with the attached template](marionette.behavior).\n\n### Listening to View Events\n\nBehaviors are powered by an event proxy. This means that any events that are triggered on a `View` are passed to all attached `behaviors`. This includes:\n\n- Events fired by `triggerMethod`\n- Events fired from `triggers`\n- Events fired by `childViewTriggers`\n- Events fired from `childView`\n\nThese handlers work exactly as they do on `View` - [see the `View` documentation](marionette.view#events)\n\n> Be default all events triggered on the behavior come from the view or the view's entities. Events triggered in the behavior instance are not executed in the view. To notify the view, the behavior must trigger an event in its view property, e.g, `this.view.trigger('my:event')`\n\n### Proxy Handlers\n\nBehaviors provide proxies to a number of the view event handling attributes including:\n\n- [`events`](dom.interactions#view-events)\n- [`triggers`](dom.interactions#view-triggers)\n- [`modelEvents`](events.entity#model-events)\n- [`collectionEvents`](events.entity#collection-events)\n\n``` javascript\nimport { Behavior } from 'backbone.marionette';\n\nBehavior.extend({\n  events: {\n    'click .foo-button': 'onClickFooButton'\n  },\n  triggers: {\n    'click .bar-button': 'click:barButton'\n  },\n  modelEvents: {\n    'change': 'onChangeModel'\n  },\n  collectionEvents: {\n    'change': 'onChangeCollection'\n  },\n  onClickFooButton(evt) {\n    // ..\n  },\n  onClickBarButton(view, evt) {\n    // ..\n  },\n  onChangeModel(model, opts) {\n    // ..\n  },\n  onChangeCollection(model, opts) {\n    // ..\n  }\n});\n```\n\n### Events / Initialize Order\n\nIf both view and behavior are listening for the same event, this will be executed first in the view then in the behavior as below.\n\nThe View + Behavior initialize process is as follows:\n\n1.  View is constructed\n2.  Behavior is constructed\n3.  Behavior is initialized with view property set\n4.  View is initialized\n5.  View triggers an `initialize` event on the behavior.\n\nThis means that the behavior can access the view during its own `initialize` method. The view `initialize` is called later with the information eventually injected by the behavior. The `initialize` event is triggered on the behavior indicating that the view is fully initialized.\n\n[Live example](https://jsfiddle.net/marionettejs/qb9go1y3/)\n\n#### Using `ui`\n\nAs in views, `events` and `triggers` can use the `ui` references in their listeners. For more details, see the [`ui` documentation](dom.interactions#organizing-your-view). These can be defined on either the Behavior or the View:\n\n``` javascript\nimport { Behavior } from 'backbone.marionette';\n\nconst MyBehavior = Behavior.extend({\n  ui: {\n    saveForm: '.btn-save'\n  },\n\n  events: {\n    'click @ui.saveForm': 'saveForm'\n  },\n\n  modelEvents: {\n    invalid: 'showError'\n  },\n\n  saveForm() {\n    this.view.model.save();\n  },\n\n  showError() {\n    alert('You have errors');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/6b8o3pmz/)\n\nIf your `ui` keys clash with keys on the attached view, the view's `ui` declarations will take precidence over the behavior's `ui`. This allows for behaviors to be more easily reused without dictating necessary structures within the view itself.\n\n``` javascript\nimport { Behavior, View } from 'backbone.marionette';\n\nconst MyBehavior = Behavior.extend({\n  ui: {\n    saveForm: '.btn-save'\n  },\n\n  events: {\n    'click @ui.saveForm': 'saveForm'  // .btn-primary when used with `FirstView`\n  },\n\n  saveForm() {\n    this.view.model.save();\n  }\n});\n\nconst FirstView = View.extend({\n  behaviors: [MyBehavior],\n\n  ui: {\n    saveForm: '.btn-primary'\n  },\n\n  events: {\n    'click @ui.saveForm': 'checkForm'  // .btn-primary\n  },\n\n  checkForm() {\n    // ...\n  }\n});\n```\n\n### View DOM proxies\n\nThe `Behavior` has a number of proxies attributes that directly refer to the related attribute on a view:\n\n- `$`\n- `el`\n- `$el`\n\nIn addition, each behavior is able to reference the view they are attached to through the `view` attribute:\n\n``` javascript\nimport { Behavior } from 'backbone.marionette';\n\nconst ViewBehavior = Behavior.extend({\n  onRender() {\n    const shouldHighlight = this.view.model.get('selected');\n    this.$el.toggleClass('highlight', shouldHighlight);\n    this.$('.view-class').addClass('highlighted-icon');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/8dmk30Lq/)\n\n**Note** in rare cases when a view's `el` is modified via `setElement` if utilizing these proxies they will need to be manually updated by calling `myBehavior.proxyViewProperties();`\n\n## Destroying a Behavior\n\n`myBehavior.destroy()` will call `stopListening` on the behavior instance, and it will remove the behavior from the view.\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/marionette.behavior.html](https://marionettejs.com/docs/v4.0.0/marionette.behavior.html)"
- name: Class Events
  id: events.class
  summary: Marionette uses triggerMethod internally to trigger various events used within the classes
  description: "# Class Events\n\nMarionette uses [`triggerMethod`](events#triggermethod) internally to trigger various events used within the [classes](classes). This provides ['onEvent' binding](events#onevent-binding) providing convenient hooks for handling class events. Notably all internally triggered events will pass the triggering class instance as the first argument of the event.\n\n## Documentation Index\n\n- [Application Events](#application-events)\n  - [`before:start` event](#before-start-event)\n  - [`start` event](#start-event)\n- [Behavior Events](#behavior-events)\n  - [`initialize` event](#initialize-event)\n  - [Proxied Events](#proxied-events)\n- [Region Events](#region-events)\n  - [`show` and `before:show` events](#show-and-beforeshow-events)\n  - [`empty` and `before:empty` events](#empty-and-beforeempty-events)\n- [MnObject Events](#mnobject-events)\n- [View Events](#view-events)\n  - [`add:region` and `before:add:region` events](#addregion-and-beforeaddregion-events)\n  - [`remove:region` and `before:remove:region` events](#removeregion-and-beforeremoveregion-events)\n- [CollectionView Events](#collectionview-events)\n  - [`add:child` and `before:add:child` events](#addchild-and-beforeaddchild-events)\n  - [`remove:child` and `before:remove:child` events](#removechild-and-beforeremovechild-events)\n  - [`sort` and `before:sort` events](#sort-and-beforesort-events)\n  - [`filter` and `before:filter` events](#filter-and-beforefilter-events)\n  - [`render:children` and `before:render:children` events](#renderchildren-and-beforerenderchildren-events)\n  - [`destroy:children` and `before:destroy:children` events](#destroychildren-and-beforedestroychildren-events)\n  - [CollectionView EmptyView Region Events](#collectionview-emptyview-region-events)\n- [DOM Change Events](#dom-change-events)\n  - [`render` and `before:render` events](#render-and-beforerender-events)\n  - [`attach` and `before:attach` events](#attach-and-beforeattach-events)\n  - [`detach` and `before:detach` events](#detach-and-beforedetach-events)\n  - [`dom:refresh` event](#domrefresh-event)\n  - [`dom:remove` event](#domremove-event)\n  - [Advanced Event Settings](#advanced-event-settings)\n- [Destroy Events](#destroy-events)\n  - [`destroy` and `before:destroy` events](#destroy-and-beforedestroy-events)\n- [Supporting Backbone Views](#supporting-backbone-views)\n  - [`Marionette.Events` and `triggerMethod`](#marionetteevents-and-triggermethod)\n  - [Lifecycle Events](#lifecycle-events)\n\n## Application Events\n\nThe `Application` object will fire two events:\n\n### `before:start` event\n\nFired just before the application is started. Use this to prepare the application with anything it will need to start, for example instantiating routers, models, and collections.\n\n### `start` event\n\nFired as part of the application startup. This is where you should be showing your views and starting `Backbone.history`.\n\n``` javascript\nimport Bb from 'backbone';\nimport { Application } from 'backbone.marionette';\n\nimport MyModel from './mymodel';\nimport MyView from './myview';\n\nconst MyApp = Application.extend({\n  region: '#root-element',\n\n  initialize(options) {\n    console.log('Initialize' + options.foo);\n  },\n\n  onBeforeStart(app, options) {\n    this.model = new MyModel(options.data);\n  },\n\n  onStart(app, options) {\n    this.showView(new MyView({model: this.model}));\n    Bb.history.start();\n  }\n});\n\nconst myApp = new MyApp({ foo: 'My App' });\nmyApp.start({ data: { bar: true } });\n```\n\n[Live example](https://jsfiddle.net/marionettejs/ny59rs7b/)\n\nAs shown the `options` object is passed into the `Application` as the second argument to `start`.\n\n#### Application `destroy` events\n\nThe `Application` class also triggers [Destroy Events](#destroy-and-beforedestroy-events).\n\n## Behavior Events\n\n### `initialize` event\n\nAfter the view and behavior are [constructed and initialized](marionette.behavior#events--initialize-order), the last event to occur is an `initialize` event on the behavior which is passed the view instance and any options passed to the view at instantiation.\n\n``` javascript\nimport { Behavior, View } from 'backbone.marionette';\n\nconst MyBehavior = Behavior.extend({\n  onInitialize(view, options) {\n    console.log(options.msg);\n  }\n});\n\nconst MyView = View.extend({\n  behaviors: [MyBehavior]\n});\n\nconst myView = new MyView({ msg: 'view initialized' });\n```\n\n**Note** This event is unique in that the triggering class instance (the view) is not the same instance as the handler (the behavior). In most cases internally triggered events are triggered and handled by the same instance, but this is an exception.\n\n### Proxied Events\n\nA `Behavior`'s view events [are proxied directly on the behavior](marionette.behavior#proxy-handlers).\n\n**Note** In order to prevent conflict `Behavior` does not trigger [destroy events](#destroy-and-beforedestroy-events) with its own destruction. A `destroy` event occurring on the `Behavior` will have originated from the related view.\n\n## Region Events\n\nWhen you show a view inside a region - either using [`region.show(view)`](marionette.region#showing-a-view) or [`showChildView('region', view)`](marionette.view#showing-a-view) - the `Region` will emit events around the view events that you can hook into.\n\nThe `Region` class also triggers [Destroy Events](#destroy-and-beforedestroy-events).\n\n### `show` and `before:show` events\n\nThese events fire before (`before:show`) and after (`show`) showing anything in a region. A view may or may not be rendered during `before:show`, but a view will be rendered by `show`.\n\nThe `show` events will receive the region instance, the view being shown, and any options passed to `region.show`.\n\n``` javascript\nimport { Region, View } from 'backbone.marionette';\n\nconst MyRegion = Region.extend({\n  onBeforeShow(myRegion, view, options) {\n    console.log(myRegion.hasView()); //false\n    console.log(view.isRendered()); // false\n    console.log(options.foo === 'bar'); // true\n  },\n  onShow(myRegion, view, options) {\n    console.log(myRegion.hasView()); //true\n    console.log(view.isRendered()); // true\n    console.log(options.foo === 'bar'); // true\n  }\n});\n\nconst MyView = View.extend({\n  template: _.template('hello')\n});\n\nconst myRegion = new MyRegion({ el: '#dom-hook' });\n\nmyRegion.show(new MyView(), { foo: 'bar' });\n```\n\n### `empty` and `before:empty` events\n\nThese events fire before (`before:empty`) and after (`empty`) emptying a region's view. These events will not fire if there is no view in the region, even if the region detaches DOM from within the region's `el`. The view will not be detached or destroyed during `before:empty`, but will be detached or destroyed during the `empty`.\n\nThe empty events will receive the region instance, the view leaving the region.\n\n``` javascript\nimport { Region, View } from 'backbone.marionette';\n\nconst MyRegion = Region.extend({\n  onBeforeEmpty(myRegion, view) {\n    console.log(myRegion.hasView()); //true\n    console.log(view.isDestroyed()); // false\n  },\n  onEmpty(myRegion, view) {\n    console.log(myRegion.hasView()); //false\n    console.log(view.isDestroyed()); // true\n  }\n});\n\nconst MyView = View.extend({\n  template: _.template('hello')\n});\n\nconst myRegion = new MyRegion({ el: '#dom-hook' });\n\nmyRegion.empty(); // no events, no view emptied\n\nmyRegion.show(new MyView());\n\nmyRegion.empty();\n```\n\n## MnObject Events\n\nThe `MnObject` class triggers [Destroy Events](#destroy-and-beforedestroy-events).\n\n## View Events\n\n### `add:region` and `before:add:region` events\n\nThese events fire before (`before:add:region`) and after (`add:region`) a region is added to a view. This event handler will receive the view instance, the region name string, and the region instance as event arguments. The region is fully instantated for both events.\n\n### `remove:region` and `before:remove:region` events\n\nThese events fire before (`before:remove:region`) and after (`remove:region`) a region is removed from a view. This event handler will receive the view instance, the region name string, and the region instance as event arguments. The region will be not be destroyed in the before event, but is destroyed by `remove:region`.\n\n**Note** Currently these events are only triggered using the `view.removeRegion` API and not when the region is destroyed directly. <https://github.com/marionettejs/backbone.marionette/issues/3602>\n\n## CollectionView Events\n\nThe `CollectionView` triggers unique events specifically related to child management.\n\n### `add:child` and `before:add:child` events\n\nThese events fire before (`before:add:child`) and after (`add:child`) each child view is instantiated and added to the [`children`](collectionview#collectionviews-children). These will fire once for each item in the attached collection or for any view added using [`addChildView`](collectionview#adding-a-child-view).\n\n### `remove:child` and `before:remove:child` events\n\nThese events fire before (`before:remove:child`) and after (`remove:child`) each child view is removed to the [`children`](collectionview#collectionviews-children). A view may be removed from the `children` if it is destroyed, if it is removed from the `collection` or if it is removed with [`removeChildView`](collectionview#removing-a-child-view).\n\n**NOTE** A childview may or may not be destroyed by this point.\n\n**NOTE** When a `CollectionView` is destroyed it will not individually remove its `children`. Each childview will be destroyed, but any needed clean up during the `CollectionView`'s destruction should happen in [`before:destroy:children`](#destroychildren-and-beforedestroychildren-events).\n\n### `sort` and `before:sort` events\n\nThese events fire before (`before:sort`) and after (`sort`) sorting the children in the `CollectionView`. These events will only fire if there are [`children`](collectionview#collectionviews-children) and a [`viewComparator`](collectionview#defining-the-viewcomparator)\n\n### `filter` and `before:filter` events\n\nThese events fire before (`before:filter`) and after (`filter`) filtering the children in the `CollectionView`. This event will only fire if there are [`children`](collectionview#collectionviews-children) and a [`viewFilter`](collectionview#defining-the-viewfilter).\n\nWhen the `filter` event is fired the children filtered out will have already been detached from the view's `el`, but new children will not yet have been rendered. The `filter` event not only receives the view instance, but also arrays of attached views, and detached views.\n\n``` javascript\nconst MyCollectionView = CollectionView.extend({\n  onBeforeFilter(myCollectionView) {\n   console.log('Nothing has changed yet!');\n  },\n  onFilter(myCollectionView, attachViews, detachedView) {\n    console.log('Array of attached views', attachedView);\n    console.log('Array of detached views', attachedView);\n  }\n});\n```\n\n### `render:children` and `before:render:children` events\n\nSimilar to [`Region` `show` and `before:show` events](#show-and-beforeshow-events) these events fire before (`before:render:children`) and after (`render:children`) the `children` of the `CollectionView` are attached to the `CollectionView`'s `el` or `childViewContainer`.\n\nThese events will be passed the `CollectionView` instance and the array of views being attached. The views in the array may or may not be rendered or attached for `before:render:children`, but will be rendered and attached by `render:children`.\n\nIf the `CollectionView` can determine that added views will only be appended to the end, only the appended views will be passed to the event. Otherwise all of the `children` views will be passed.\n\n**Note** if you consistently need all of the views within this event use [`children`](marionette.collectionview#collectionviews-children)\n\n### `destroy:children` and `before:destroy:children` events\n\nThese events fire before (`before:destroy:children`) and after (`destroy:children`) destroying the children in the `CollectionView`. These events will only fire if there are [`children`](collectionview#collectionviews-children).\n\n### CollectionView EmptyView Region Events\n\nThe `CollectionView` uses a region internally that can be used to know when the empty view is show or destroyed. See [Region Events](#region-events).\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyView = CollectionView.extend({\n  emptyView: MyEmptyView\n});\n\nconst myView = new MyView();\n\nmyView.getEmptyRegion().on({\n  'show'() {\n    console.log('CollectionView is empty!');\n  },\n  'before:empty'() {\n    if (this.hasView()) {\n      console.log('CollectionView is removing the emptyView');\n    }\n  }\n});\n\nmyView.render();\n```\n\n## DOM Change Events\n\n### `render` and `before:render` events\n\nReflects when a view's template is being rendered into its `el`.\n\n`before:render` will occur prior to removing any current child views. `render` is an ideal event for attaching child views to the view's template as the first render *generally* occurs prior to the view attaching to the DOM.\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\nimport MyChildView from './MyChildView';\n\nconst MyView = View.extend({\n  template: _.template('<div class=\"foo-region\"></div>'),\n  regions: {\n    'foo': '.foo-region'\n  },\n  onRender() {\n    this.showChildView('foo', new MyChildView());\n  }\n});\n\nconst MyCollectionView = CollectionView.extend({\n  childView: MyChildView,\n  onRender() {\n    // Add a child not from the `collection`\n    this.addChildView(new MyChildView());\n  }\n})\n```\n\n**Note** This event is only triggered when rendering a template into a view. A view that is pre-rendered will not have this event triggered unless re-rendered. [Pre-rendered views](dom.prerendered) should use `initialize` for attaching child views and the `render` event if the view is re-rendered.\n\n**Note** If a view's `template` is set to `false` this event will not trigger.\n\n### `attach` and `before:attach` events\n\nRelects when the `el` of a view is attached to the DOM. These events will not trigger when a view is re-rendered as the `el` itself does not change.\n\n`attach` is the ideal event to setup any external DOM listeners such as `jQuery` plugins that use the view's `el`, but *not* its contents.\n\n### `detach` and `before:detach` events\n\nRelects when the `el` of a view is detached from the DOM. These events will not trigger when a view is re-rendered as the `el` itself does not change.\n\n`before:detach` is the ideal event to clean up any external DOM listeners such as `jQuery` plugins that use the view's `el`, but *not* its contents.\n\n### `dom:refresh` event\n\nRelects when the *contents* of a view's `el` change in the DOM. This event will fire when the view is first [`attach`ed](#attach-and-beforeattach-events). It will also fire if an attached view is re-rendered.\n\nThis is the ideal event to setup any external DOM listeners such as `jQuery` plugins that use DOM *within* the `el` of the view and not the view's `el` itself.\n\n**NOTE** This event will not fire if the view has no template to render unless it contains prerendered html.\n\n### `dom:remove` event\n\nRelects when the *contents* of a view's `el` are about to change in the DOM. This event will fire when the view is about to be [`detach`ed](#detach-and-beforedetach-events). It will also fire before an attached view is re-rendered.\n\nThis is the ideal event to clean up any external DOM listeners such as `jQuery` plugins that use DOM *within* the `el` of the view and not the view's `el` itself.\n\n**NOTE** This event will not fire if the view has no template to render unless it contains prerendered html.\n\n### Advanced Event Settings\n\nMarionette is able to trigger `attach`/`detach` events down the view tree along with triggering the `dom:refresh`/`dom:remove` events because of the view event monitor. This monitor starts when a view is created or shown in a region (to handle non-Marionette views).\n\nIn some cases it may be a useful performance improvement to disable this functionality. Doing so is as easy as setting `monitorViewEvents: false` on the view class.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst NonMonitoredView = View.extend({\n  monitorViewEvents: false\n});\n```\n\n**Note**: Disabling the view monitor will break the monitor generated events for this view *and all child views* of this view. Disabling should be done carefully.\n\n## Destroy Events\n\n### `destroy` and `before:destroy` events\n\nEvery class has a `destroy` method which can be used to clean up the instance. With the exception of `Behavior`'s each of these methods triggers a `before:destroy` and a `destroy` event.\n\nAs a general rule, `onBeforeDestroy` is the best handler for cleanup as the instance and any internally created children are already destroyed by the time `onDestroy` is called.\n\n**Note** For views this is not the ideal location for clean up of anything touching the DOM. See [`dom:remove`](#domremove-event) or \\[`before:detach`\\] for DOM related clean up.\n\n``` javascript\nimport { Application, View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  onBeforeDestroy(options) {\n    console.log(options.foo);\n  }\n});\n\nconst myView = new MyView();\n\nmvView.destroy({ foo: 'destroy view' });\n\nconst MyApp = Application.extend({\n  onBeforeDestroy(options) {\n    console.log(options.foo);\n  }\n});\n\nconst myApp = new MyApp();\n\nmyApp.destroy({ foo: 'destroy app' });\n```\n\n#### `CollectionView` `destroy:children` and `before:destroy:children` events\n\nSimilar to `destroy`, `CollectionView` has events for when all of its children are destroyed. See [the CollectionView's events](#destroychildren-and-beforedestroychildren-events) for more information.\n\n## Supporting Backbone Views\n\n### `Marionette.Events` and `triggerMethod`\n\nInternally Marionette uses [`triggerMethod`](common#triggermethod) for event triggering. This API is not available to `Backbone.View`s so in order to support `Backbone.View`s in Marionette v4+, `Marionette.Events` must be mixed into the non-Marionette view.\n\nThis can be done for an individual view definition:\n\n``` javascript\nimport { Events } from 'backbone.marionette';\n\nconst MyBbView = Backbone.View.extend(Events);\n```\n\nor for all `Backbone.View`s\n\n``` javascript\n_.extend(Backbone.View.prototype, Events);\n```\n\n### Lifecycle Events\n\n#### `render` and `destroy`\n\nTo support non-Marionette Views, Marionette uses two flags to determine if it should trigger `render` and `destroy` events on the view. If a custom view throws it's own `render` or `destroy` events, the related flag should be set to `true` to avoid Marionette duplicating these events.\n\n``` javascript\n// Add support for triggerMethod\nimport { Events } from 'backbone.marionette';\n\n_.extend(Backbone.View.prototype, Events);\n\nconst MyCustomView = Backbone.View.extend({\n  supportsRenderLifecycle: true,\n  supportsDestroyLifecycle: true,\n  render() {\n    this.triggerMethod('before:render');\n\n    this.$el.html('render html');\n\n    // Since render is being triggered here set the\n    // supportsRenderLifecycle flag to true to avoid duplication\n    this.triggerMethod('render');\n  },\n  destroy() {\n    this.triggerMethod('before:destroy');\n\n    this.remove();\n\n    // Since destroy is being triggered here set the\n    // supportsDestroyLifecycle flag to true to avoid duplication\n    this.triggerMethod('destroy');\n  }\n});\n```\n\n#### DOM Change Lifecycle Events\n\nAs mentioned in [Advanced Event Settings](#advanced-event-settings) some DOM events are triggers from the view event monitor that will handle DOM attachment related events down the view tree. Backbone View's won't have the functionality unless the monitor is added. This will include all [DOM Change Events](#dom-change-events) other than render.\n\nYou can add the view events monitor to any non-Marionette view:\n\n``` javascript\nimport { monitorViewEvents, Events } from 'backbone.marionette';\n\n// Add support for triggerMethod\n_.extend(Backbone.View.prototype, Events);\n\nconst MyCustomView = Backbone.View.extend({\n  initialize() {\n    monitorViewEvents(this);\n    // Ideally this happens first prior to any rendering\n    // or attaching that might occur in the initialize\n  }\n});\n```\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/events.class.html](https://marionettejs.com/docs/v4.0.0/events.class.html)"
- name: Class Events add:child and before:add:child events
  id: events.class#addchild-and-beforeaddchild-events
  summary: These events fire before (before:add:child) and after (add:child) each child view is instantiated and added to the children
  belongs_to: Class Events
  description: |-
    ### `add:child` and `before:add:child` events

    These events fire before (`before:add:child`) and after (`add:child`) each child view is instantiated and added to the [`children`](collectionview#collectionviews-children). These will fire once for each item in the attached collection or for any view added using [`addChildView`](collectionview#adding-a-child-view).
- name: Class Events add:region and before:add:region events
  id: events.class#addregion-and-beforeaddregion-events
  summary: These events fire before (before:add:region) and after (add:region) a region is added to a view
  belongs_to: Class Events
  description: |-
    ### `add:region` and `before:add:region` events

    These events fire before (`before:add:region`) and after (`add:region`) a region is added to a view. This event handler will receive the view instance, the region name string, and the region instance as event arguments. The region is fully instantated for both events.
- name: Class Events attach and before:attach events
  id: events.class#attach-and-beforeattach-events
  summary: Relects when the el of a view is attached to the DOM
  belongs_to: Class Events
  description: |-
    ### `attach` and `before:attach` events

    Relects when the `el` of a view is attached to the DOM. These events will not trigger when a view is re-rendered as the `el` itself does not change.

    `attach` is the ideal event to setup any external DOM listeners such as `jQuery` plugins that use the view's `el`, but *not* its contents.
- name: Class Events before:start event
  id: events.class#before-start-event
  summary: Marionette uses triggerMethod internally to trigger various events used within the classes
  belongs_to: Class Events
  description: "# Class Events\n\nMarionette uses [`triggerMethod`](events#triggermethod) internally to trigger various events used within the [classes](classes). This provides ['onEvent' binding](events#onevent-binding) providing convenient hooks for handling class events. Notably all internally triggered events will pass the triggering class instance as the first argument of the event.\n\n## Documentation Index\n\n- [Application Events](#application-events)\n  - [`before:start` event](#before-start-event)\n  - [`start` event](#start-event)\n- [Behavior Events](#behavior-events)\n  - [`initialize` event](#initialize-event)\n  - [Proxied Events](#proxied-events)\n- [Region Events](#region-events)\n  - [`show` and `before:show` events](#show-and-beforeshow-events)\n  - [`empty` and `before:empty` events](#empty-and-beforeempty-events)\n- [MnObject Events](#mnobject-events)\n- [View Events](#view-events)\n  - [`add:region` and `before:add:region` events](#addregion-and-beforeaddregion-events)\n  - [`remove:region` and `before:remove:region` events](#removeregion-and-beforeremoveregion-events)\n- [CollectionView Events](#collectionview-events)\n  - [`add:child` and `before:add:child` events](#addchild-and-beforeaddchild-events)\n  - [`remove:child` and `before:remove:child` events](#removechild-and-beforeremovechild-events)\n  - [`sort` and `before:sort` events](#sort-and-beforesort-events)\n  - [`filter` and `before:filter` events](#filter-and-beforefilter-events)\n  - [`render:children` and `before:render:children` events](#renderchildren-and-beforerenderchildren-events)\n  - [`destroy:children` and `before:destroy:children` events](#destroychildren-and-beforedestroychildren-events)\n  - [CollectionView EmptyView Region Events](#collectionview-emptyview-region-events)\n- [DOM Change Events](#dom-change-events)\n  - [`render` and `before:render` events](#render-and-beforerender-events)\n  - [`attach` and `before:attach` events](#attach-and-beforeattach-events)\n  - [`detach` and `before:detach` events](#detach-and-beforedetach-events)\n  - [`dom:refresh` event](#domrefresh-event)\n  - [`dom:remove` event](#domremove-event)\n  - [Advanced Event Settings](#advanced-event-settings)\n- [Destroy Events](#destroy-events)\n  - [`destroy` and `before:destroy` events](#destroy-and-beforedestroy-events)\n- [Supporting Backbone Views](#supporting-backbone-views)\n  - [`Marionette.Events` and `triggerMethod`](#marionetteevents-and-triggermethod)\n  - [Lifecycle Events](#lifecycle-events)\n\n## Application Events\n\nThe `Application` object will fire two events:\n\n### `before:start` event\n\nFired just before the application is started. Use this to prepare the application with anything it will need to start, for example instantiating routers, models, and collections.\n\n### `start` event\n\nFired as part of the application startup. This is where you should be showing your views and starting `Backbone.history`.\n\n``` javascript\nimport Bb from 'backbone';\nimport { Application } from 'backbone.marionette';\n\nimport MyModel from './mymodel';\nimport MyView from './myview';\n\nconst MyApp = Application.extend({\n  region: '#root-element',\n\n  initialize(options) {\n    console.log('Initialize' + options.foo);\n  },\n\n  onBeforeStart(app, options) {\n    this.model = new MyModel(options.data);\n  },\n\n  onStart(app, options) {\n    this.showView(new MyView({model: this.model}));\n    Bb.history.start();\n  }\n});\n\nconst myApp = new MyApp({ foo: 'My App' });\nmyApp.start({ data: { bar: true } });\n```\n\n[Live example](https://jsfiddle.net/marionettejs/ny59rs7b/)\n\nAs shown the `options` object is passed into the `Application` as the second argument to `start`.\n\n#### Application `destroy` events\n\nThe `Application` class also triggers [Destroy Events](#destroy-and-beforedestroy-events).\n\n## Behavior Events\n\n### `initialize` event\n\nAfter the view and behavior are [constructed and initialized](marionette.behavior#events--initialize-order), the last event to occur is an `initialize` event on the behavior which is passed the view instance and any options passed to the view at instantiation.\n\n``` javascript\nimport { Behavior, View } from 'backbone.marionette';\n\nconst MyBehavior = Behavior.extend({\n  onInitialize(view, options) {\n    console.log(options.msg);\n  }\n});\n\nconst MyView = View.extend({\n  behaviors: [MyBehavior]\n});\n\nconst myView = new MyView({ msg: 'view initialized' });\n```\n\n**Note** This event is unique in that the triggering class instance (the view) is not the same instance as the handler (the behavior). In most cases internally triggered events are triggered and handled by the same instance, but this is an exception.\n\n### Proxied Events\n\nA `Behavior`'s view events [are proxied directly on the behavior](marionette.behavior#proxy-handlers).\n\n**Note** In order to prevent conflict `Behavior` does not trigger [destroy events](#destroy-and-beforedestroy-events) with its own destruction. A `destroy` event occurring on the `Behavior` will have originated from the related view.\n\n## Region Events\n\nWhen you show a view inside a region - either using [`region.show(view)`](marionette.region#showing-a-view) or [`showChildView('region', view)`](marionette.view#showing-a-view) - the `Region` will emit events around the view events that you can hook into.\n\nThe `Region` class also triggers [Destroy Events](#destroy-and-beforedestroy-events).\n\n### `show` and `before:show` events\n\nThese events fire before (`before:show`) and after (`show`) showing anything in a region. A view may or may not be rendered during `before:show`, but a view will be rendered by `show`.\n\nThe `show` events will receive the region instance, the view being shown, and any options passed to `region.show`.\n\n``` javascript\nimport { Region, View } from 'backbone.marionette';\n\nconst MyRegion = Region.extend({\n  onBeforeShow(myRegion, view, options) {\n    console.log(myRegion.hasView()); //false\n    console.log(view.isRendered()); // false\n    console.log(options.foo === 'bar'); // true\n  },\n  onShow(myRegion, view, options) {\n    console.log(myRegion.hasView()); //true\n    console.log(view.isRendered()); // true\n    console.log(options.foo === 'bar'); // true\n  }\n});\n\nconst MyView = View.extend({\n  template: _.template('hello')\n});\n\nconst myRegion = new MyRegion({ el: '#dom-hook' });\n\nmyRegion.show(new MyView(), { foo: 'bar' });\n```\n\n### `empty` and `before:empty` events\n\nThese events fire before (`before:empty`) and after (`empty`) emptying a region's view. These events will not fire if there is no view in the region, even if the region detaches DOM from within the region's `el`. The view will not be detached or destroyed during `before:empty`, but will be detached or destroyed during the `empty`.\n\nThe empty events will receive the region instance, the view leaving the region.\n\n``` javascript\nimport { Region, View } from 'backbone.marionette';\n\nconst MyRegion = Region.extend({\n  onBeforeEmpty(myRegion, view) {\n    console.log(myRegion.hasView()); //true\n    console.log(view.isDestroyed()); // false\n  },\n  onEmpty(myRegion, view) {\n    console.log(myRegion.hasView()); //false\n    console.log(view.isDestroyed()); // true\n  }\n});\n\nconst MyView = View.extend({\n  template: _.template('hello')\n});\n\nconst myRegion = new MyRegion({ el: '#dom-hook' });\n\nmyRegion.empty(); // no events, no view emptied\n\nmyRegion.show(new MyView());\n\nmyRegion.empty();\n```\n\n## MnObject Events\n\nThe `MnObject` class triggers [Destroy Events](#destroy-and-beforedestroy-events).\n\n## View Events\n\n### `add:region` and `before:add:region` events\n\nThese events fire before (`before:add:region`) and after (`add:region`) a region is added to a view. This event handler will receive the view instance, the region name string, and the region instance as event arguments. The region is fully instantated for both events.\n\n### `remove:region` and `before:remove:region` events\n\nThese events fire before (`before:remove:region`) and after (`remove:region`) a region is removed from a view. This event handler will receive the view instance, the region name string, and the region instance as event arguments. The region will be not be destroyed in the before event, but is destroyed by `remove:region`.\n\n**Note** Currently these events are only triggered using the `view.removeRegion` API and not when the region is destroyed directly. <https://github.com/marionettejs/backbone.marionette/issues/3602>\n\n## CollectionView Events\n\nThe `CollectionView` triggers unique events specifically related to child management.\n\n### `add:child` and `before:add:child` events\n\nThese events fire before (`before:add:child`) and after (`add:child`) each child view is instantiated and added to the [`children`](collectionview#collectionviews-children). These will fire once for each item in the attached collection or for any view added using [`addChildView`](collectionview#adding-a-child-view).\n\n### `remove:child` and `before:remove:child` events\n\nThese events fire before (`before:remove:child`) and after (`remove:child`) each child view is removed to the [`children`](collectionview#collectionviews-children). A view may be removed from the `children` if it is destroyed, if it is removed from the `collection` or if it is removed with [`removeChildView`](collectionview#removing-a-child-view).\n\n**NOTE** A childview may or may not be destroyed by this point.\n\n**NOTE** When a `CollectionView` is destroyed it will not individually remove its `children`. Each childview will be destroyed, but any needed clean up during the `CollectionView`'s destruction should happen in [`before:destroy:children`](#destroychildren-and-beforedestroychildren-events).\n\n### `sort` and `before:sort` events\n\nThese events fire before (`before:sort`) and after (`sort`) sorting the children in the `CollectionView`. These events will only fire if there are [`children`](collectionview#collectionviews-children) and a [`viewComparator`](collectionview#defining-the-viewcomparator)\n\n### `filter` and `before:filter` events\n\nThese events fire before (`before:filter`) and after (`filter`) filtering the children in the `CollectionView`. This event will only fire if there are [`children`](collectionview#collectionviews-children) and a [`viewFilter`](collectionview#defining-the-viewfilter).\n\nWhen the `filter` event is fired the children filtered out will have already been detached from the view's `el`, but new children will not yet have been rendered. The `filter` event not only receives the view instance, but also arrays of attached views, and detached views.\n\n``` javascript\nconst MyCollectionView = CollectionView.extend({\n  onBeforeFilter(myCollectionView) {\n   console.log('Nothing has changed yet!');\n  },\n  onFilter(myCollectionView, attachViews, detachedView) {\n    console.log('Array of attached views', attachedView);\n    console.log('Array of detached views', attachedView);\n  }\n});\n```\n\n### `render:children` and `before:render:children` events\n\nSimilar to [`Region` `show` and `before:show` events](#show-and-beforeshow-events) these events fire before (`before:render:children`) and after (`render:children`) the `children` of the `CollectionView` are attached to the `CollectionView`'s `el` or `childViewContainer`.\n\nThese events will be passed the `CollectionView` instance and the array of views being attached. The views in the array may or may not be rendered or attached for `before:render:children`, but will be rendered and attached by `render:children`.\n\nIf the `CollectionView` can determine that added views will only be appended to the end, only the appended views will be passed to the event. Otherwise all of the `children` views will be passed.\n\n**Note** if you consistently need all of the views within this event use [`children`](marionette.collectionview#collectionviews-children)\n\n### `destroy:children` and `before:destroy:children` events\n\nThese events fire before (`before:destroy:children`) and after (`destroy:children`) destroying the children in the `CollectionView`. These events will only fire if there are [`children`](collectionview#collectionviews-children).\n\n### CollectionView EmptyView Region Events\n\nThe `CollectionView` uses a region internally that can be used to know when the empty view is show or destroyed. See [Region Events](#region-events).\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyView = CollectionView.extend({\n  emptyView: MyEmptyView\n});\n\nconst myView = new MyView();\n\nmyView.getEmptyRegion().on({\n  'show'() {\n    console.log('CollectionView is empty!');\n  },\n  'before:empty'() {\n    if (this.hasView()) {\n      console.log('CollectionView is removing the emptyView');\n    }\n  }\n});\n\nmyView.render();\n```\n\n## DOM Change Events\n\n### `render` and `before:render` events\n\nReflects when a view's template is being rendered into its `el`.\n\n`before:render` will occur prior to removing any current child views. `render` is an ideal event for attaching child views to the view's template as the first render *generally* occurs prior to the view attaching to the DOM.\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\nimport MyChildView from './MyChildView';\n\nconst MyView = View.extend({\n  template: _.template('<div class=\"foo-region\"></div>'),\n  regions: {\n    'foo': '.foo-region'\n  },\n  onRender() {\n    this.showChildView('foo', new MyChildView());\n  }\n});\n\nconst MyCollectionView = CollectionView.extend({\n  childView: MyChildView,\n  onRender() {\n    // Add a child not from the `collection`\n    this.addChildView(new MyChildView());\n  }\n})\n```\n\n**Note** This event is only triggered when rendering a template into a view. A view that is pre-rendered will not have this event triggered unless re-rendered. [Pre-rendered views](dom.prerendered) should use `initialize` for attaching child views and the `render` event if the view is re-rendered.\n\n**Note** If a view's `template` is set to `false` this event will not trigger.\n\n### `attach` and `before:attach` events\n\nRelects when the `el` of a view is attached to the DOM. These events will not trigger when a view is re-rendered as the `el` itself does not change.\n\n`attach` is the ideal event to setup any external DOM listeners such as `jQuery` plugins that use the view's `el`, but *not* its contents.\n\n### `detach` and `before:detach` events\n\nRelects when the `el` of a view is detached from the DOM. These events will not trigger when a view is re-rendered as the `el` itself does not change.\n\n`before:detach` is the ideal event to clean up any external DOM listeners such as `jQuery` plugins that use the view's `el`, but *not* its contents.\n\n### `dom:refresh` event\n\nRelects when the *contents* of a view's `el` change in the DOM. This event will fire when the view is first [`attach`ed](#attach-and-beforeattach-events). It will also fire if an attached view is re-rendered.\n\nThis is the ideal event to setup any external DOM listeners such as `jQuery` plugins that use DOM *within* the `el` of the view and not the view's `el` itself.\n\n**NOTE** This event will not fire if the view has no template to render unless it contains prerendered html.\n\n### `dom:remove` event\n\nRelects when the *contents* of a view's `el` are about to change in the DOM. This event will fire when the view is about to be [`detach`ed](#detach-and-beforedetach-events). It will also fire before an attached view is re-rendered.\n\nThis is the ideal event to clean up any external DOM listeners such as `jQuery` plugins that use DOM *within* the `el` of the view and not the view's `el` itself.\n\n**NOTE** This event will not fire if the view has no template to render unless it contains prerendered html.\n\n### Advanced Event Settings\n\nMarionette is able to trigger `attach`/`detach` events down the view tree along with triggering the `dom:refresh`/`dom:remove` events because of the view event monitor. This monitor starts when a view is created or shown in a region (to handle non-Marionette views).\n\nIn some cases it may be a useful performance improvement to disable this functionality. Doing so is as easy as setting `monitorViewEvents: false` on the view class.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst NonMonitoredView = View.extend({\n  monitorViewEvents: false\n});\n```\n\n**Note**: Disabling the view monitor will break the monitor generated events for this view *and all child views* of this view. Disabling should be done carefully.\n\n## Destroy Events\n\n### `destroy` and `before:destroy` events\n\nEvery class has a `destroy` method which can be used to clean up the instance. With the exception of `Behavior`'s each of these methods triggers a `before:destroy` and a `destroy` event.\n\nAs a general rule, `onBeforeDestroy` is the best handler for cleanup as the instance and any internally created children are already destroyed by the time `onDestroy` is called.\n\n**Note** For views this is not the ideal location for clean up of anything touching the DOM. See [`dom:remove`](#domremove-event) or \\[`before:detach`\\] for DOM related clean up.\n\n``` javascript\nimport { Application, View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  onBeforeDestroy(options) {\n    console.log(options.foo);\n  }\n});\n\nconst myView = new MyView();\n\nmvView.destroy({ foo: 'destroy view' });\n\nconst MyApp = Application.extend({\n  onBeforeDestroy(options) {\n    console.log(options.foo);\n  }\n});\n\nconst myApp = new MyApp();\n\nmyApp.destroy({ foo: 'destroy app' });\n```\n\n#### `CollectionView` `destroy:children` and `before:destroy:children` events\n\nSimilar to `destroy`, `CollectionView` has events for when all of its children are destroyed. See [the CollectionView's events](#destroychildren-and-beforedestroychildren-events) for more information.\n\n## Supporting Backbone Views\n\n### `Marionette.Events` and `triggerMethod`\n\nInternally Marionette uses [`triggerMethod`](common#triggermethod) for event triggering. This API is not available to `Backbone.View`s so in order to support `Backbone.View`s in Marionette v4+, `Marionette.Events` must be mixed into the non-Marionette view.\n\nThis can be done for an individual view definition:\n\n``` javascript\nimport { Events } from 'backbone.marionette';\n\nconst MyBbView = Backbone.View.extend(Events);\n```\n\nor for all `Backbone.View`s\n\n``` javascript\n_.extend(Backbone.View.prototype, Events);\n```\n\n### Lifecycle Events\n\n#### `render` and `destroy`\n\nTo support non-Marionette Views, Marionette uses two flags to determine if it should trigger `render` and `destroy` events on the view. If a custom view throws it's own `render` or `destroy` events, the related flag should be set to `true` to avoid Marionette duplicating these events.\n\n``` javascript\n// Add support for triggerMethod\nimport { Events } from 'backbone.marionette';\n\n_.extend(Backbone.View.prototype, Events);\n\nconst MyCustomView = Backbone.View.extend({\n  supportsRenderLifecycle: true,\n  supportsDestroyLifecycle: true,\n  render() {\n    this.triggerMethod('before:render');\n\n    this.$el.html('render html');\n\n    // Since render is being triggered here set the\n    // supportsRenderLifecycle flag to true to avoid duplication\n    this.triggerMethod('render');\n  },\n  destroy() {\n    this.triggerMethod('before:destroy');\n\n    this.remove();\n\n    // Since destroy is being triggered here set the\n    // supportsDestroyLifecycle flag to true to avoid duplication\n    this.triggerMethod('destroy');\n  }\n});\n```\n\n#### DOM Change Lifecycle Events\n\nAs mentioned in [Advanced Event Settings](#advanced-event-settings) some DOM events are triggers from the view event monitor that will handle DOM attachment related events down the view tree. Backbone View's won't have the functionality unless the monitor is added. This will include all [DOM Change Events](#dom-change-events) other than render.\n\nYou can add the view events monitor to any non-Marionette view:\n\n``` javascript\nimport { monitorViewEvents, Events } from 'backbone.marionette';\n\n// Add support for triggerMethod\n_.extend(Backbone.View.prototype, Events);\n\nconst MyCustomView = Backbone.View.extend({\n  initialize() {\n    monitorViewEvents(this);\n    // Ideally this happens first prior to any rendering\n    // or attaching that might occur in the initialize\n  }\n});\n```\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/events.class.html](https://marionettejs.com/docs/v4.0.0/events.class.html)"
- name: Class Events destroy and before:destroy events
  id: events.class#destroy-and-beforedestroy-events
  summary: Every class has a destroy method which can be used to clean up the instance
  belongs_to: Class Events
  description: |-
    ### `destroy` and `before:destroy` events

    Every class has a `destroy` method which can be used to clean up the instance. With the exception of `Behavior`'s each of these methods triggers a `before:destroy` and a `destroy` event.

    As a general rule, `onBeforeDestroy` is the best handler for cleanup as the instance and any internally created children are already destroyed by the time `onDestroy` is called.

    **Note** For views this is not the ideal location for clean up of anything touching the DOM. See [`dom:remove`](#domremove-event) or \[`before:detach`\] for DOM related clean up.

    ``` javascript
    import { Application, View } from 'backbone.marionette';

    const MyView = View.extend({
      onBeforeDestroy(options) {
        console.log(options.foo);
      }
    });

    const myView = new MyView();

    mvView.destroy({ foo: 'destroy view' });

    const MyApp = Application.extend({
      onBeforeDestroy(options) {
        console.log(options.foo);
      }
    });

    const myApp = new MyApp();

    myApp.destroy({ foo: 'destroy app' });
    ```

    #### `CollectionView``destroy:children` and `before:destroy:children` events

    Similar to `destroy`, `CollectionView` has events for when all of its children are destroyed. See [the CollectionView's events](#destroychildren-and-beforedestroychildren-events) for more information.

    ## Supporting Backbone Views
- name: Class Events destroy:children and before:destroy:children events
  id: events.class#destroychildren-and-beforedestroychildren-events
  summary: These events fire before (before:destroy:children) and after (destroy:children) destroying the children in the CollectionView
  belongs_to: Class Events
  description: |-
    ### `destroy:children` and `before:destroy:children` events

    These events fire before (`before:destroy:children`) and after (`destroy:children`) destroying the children in the `CollectionView`. These events will only fire if there are [`children`](collectionview#collectionviews-children).

    ### CollectionView EmptyView Region Events

    The `CollectionView` uses a region internally that can be used to know when the empty view is show or destroyed. See [Region Events](#region-events).

    ``` javascript
    import { CollectionView } from 'backbone.marionette';

    const MyView = CollectionView.extend({
      emptyView: MyEmptyView
    });

    const myView = new MyView();

    myView.getEmptyRegion().on({
      'show'() {
        console.log('CollectionView is empty!');
      },
      'before:empty'() {
        if (this.hasView()) {
          console.log('CollectionView is removing the emptyView');
        }
      }
    });

    myView.render();
    ```

    ## DOM Change Events
- name: Class Events detach and before:detach events
  id: events.class#detach-and-beforedetach-events
  summary: Relects when the el of a view is detached from the DOM
  belongs_to: Class Events
  description: |-
    ### `detach` and `before:detach` events

    Relects when the `el` of a view is detached from the DOM. These events will not trigger when a view is re-rendered as the `el` itself does not change.

    `before:detach` is the ideal event to clean up any external DOM listeners such as `jQuery` plugins that use the view's `el`, but *not* its contents.
- name: Class Events dom:refresh event
  id: events.class#domrefresh-event
  summary: Relects when the contents of a view's el change in the DOM
  belongs_to: Class Events
  description: |-
    ### `dom:refresh` event

    Relects when the *contents* of a view's `el` change in the DOM. This event will fire when the view is first [`attach`ed](#attach-and-beforeattach-events). It will also fire if an attached view is re-rendered.

    This is the ideal event to setup any external DOM listeners such as `jQuery` plugins that use DOM *within* the `el` of the view and not the view's `el` itself.

    **NOTE** This event will not fire if the view has no template to render unless it contains prerendered html.
- name: Class Events dom:remove event
  id: events.class#domremove-event
  summary: Relects when the contents of a view's el are about to change in the DOM
  belongs_to: Class Events
  description: |-
    ### `dom:remove` event

    Relects when the *contents* of a view's `el` are about to change in the DOM. This event will fire when the view is about to be [`detach`ed](#detach-and-beforedetach-events). It will also fire before an attached view is re-rendered.

    This is the ideal event to clean up any external DOM listeners such as `jQuery` plugins that use DOM *within* the `el` of the view and not the view's `el` itself.

    **NOTE** This event will not fire if the view has no template to render unless it contains prerendered html.

    ### Advanced Event Settings

    Marionette is able to trigger `attach`/`detach` events down the view tree along with triggering the `dom:refresh`/`dom:remove` events because of the view event monitor. This monitor starts when a view is created or shown in a region (to handle non-Marionette views).

    In some cases it may be a useful performance improvement to disable this functionality. Doing so is as easy as setting `monitorViewEvents: false` on the view class.

    ``` javascript
    import { View } from 'backbone.marionette';

    const NonMonitoredView = View.extend({
      monitorViewEvents: false
    });
    ```

    **Note**: Disabling the view monitor will break the monitor generated events for this view *and all child views* of this view. Disabling should be done carefully.

    ## Destroy Events
- name: Class Events empty and before:empty events
  id: events.class#empty-and-beforeempty-events
  summary: These events fire before (before:empty) and after (empty) emptying a region's view
  belongs_to: Class Events
  description: |-
    ### `empty` and `before:empty` events

    These events fire before (`before:empty`) and after (`empty`) emptying a region's view. These events will not fire if there is no view in the region, even if the region detaches DOM from within the region's `el`. The view will not be detached or destroyed during `before:empty`, but will be detached or destroyed during the `empty`.

    The empty events will receive the region instance, the view leaving the region.

    ``` javascript
    import { Region, View } from 'backbone.marionette';

    const MyRegion = Region.extend({
      onBeforeEmpty(myRegion, view) {
        console.log(myRegion.hasView()); //true
        console.log(view.isDestroyed()); // false
      },
      onEmpty(myRegion, view) {
        console.log(myRegion.hasView()); //false
        console.log(view.isDestroyed()); // true
      }
    });

    const MyView = View.extend({
      template: _.template('hello')
    });

    const myRegion = new MyRegion({ el: '#dom-hook' });

    myRegion.empty(); // no events, no view emptied

    myRegion.show(new MyView());

    myRegion.empty();
    ```

    ## MnObject Events

    The `MnObject` class triggers [Destroy Events](#destroy-and-beforedestroy-events).

    ## View Events
- name: Class Events filter and before:filter events
  id: events.class#filter-and-beforefilter-events
  summary: These events fire before (before:filter) and after (filter) filtering the children in the CollectionView
  belongs_to: Class Events
  description: |-
    ### `filter` and `before:filter` events

    These events fire before (`before:filter`) and after (`filter`) filtering the children in the `CollectionView`. This event will only fire if there are [`children`](collectionview#collectionviews-children) and a [`viewFilter`](collectionview#defining-the-viewfilter).

    When the `filter` event is fired the children filtered out will have already been detached from the view's `el`, but new children will not yet have been rendered. The `filter` event not only receives the view instance, but also arrays of attached views, and detached views.

    ``` javascript
    const MyCollectionView = CollectionView.extend({
      onBeforeFilter(myCollectionView) {
       console.log('Nothing has changed yet!');
      },
      onFilter(myCollectionView, attachViews, detachedView) {
        console.log('Array of attached views', attachedView);
        console.log('Array of detached views', attachedView);
      }
    });
    ```
- name: Class Events initialize event
  id: events.class#initialize-event
  summary: After the view and behavior are constructed and initialized, the last event to occur is an initialize event on the behavior which is passed the view instance and any options passed to the view at instantiation
  belongs_to: Class Events
  description: |-
    ### `initialize` event

    After the view and behavior are [constructed and initialized](marionette.behavior#events--initialize-order), the last event to occur is an `initialize` event on the behavior which is passed the view instance and any options passed to the view at instantiation.

    ``` javascript
    import { Behavior, View } from 'backbone.marionette';

    const MyBehavior = Behavior.extend({
      onInitialize(view, options) {
        console.log(options.msg);
      }
    });

    const MyView = View.extend({
      behaviors: [MyBehavior]
    });

    const myView = new MyView({ msg: 'view initialized' });
    ```

    **Note** This event is unique in that the triggering class instance (the view) is not the same instance as the handler (the behavior). In most cases internally triggered events are triggered and handled by the same instance, but this is an exception.

    ### Proxied Events

    A `Behavior`'s view events [are proxied directly on the behavior](marionette.behavior#proxy-handlers).

    **Note** In order to prevent conflict `Behavior` does not trigger [destroy events](#destroy-and-beforedestroy-events) with its own destruction. A `destroy` event occurring on the `Behavior` will have originated from the related view.

    ## Region Events

    When you show a view inside a region - either using [`region.show(view)`](marionette.region#showing-a-view) or [`showChildView('region', view)`](marionette.view#showing-a-view) - the `Region` will emit events around the view events that you can hook into.

    The `Region` class also triggers [Destroy Events](#destroy-and-beforedestroy-events).
- name: Class Events remove:child and before:remove:child events
  id: events.class#removechild-and-beforeremovechild-events
  summary: These events fire before (before:remove:child) and after (remove:child) each child view is removed to the children
  belongs_to: Class Events
  description: |-
    ### `remove:child` and `before:remove:child` events

    These events fire before (`before:remove:child`) and after (`remove:child`) each child view is removed to the [`children`](collectionview#collectionviews-children). A view may be removed from the `children` if it is destroyed, if it is removed from the `collection` or if it is removed with [`removeChildView`](collectionview#removing-a-child-view).

    **NOTE** A childview may or may not be destroyed by this point.

    **NOTE** When a `CollectionView` is destroyed it will not individually remove its `children`. Each childview will be destroyed, but any needed clean up during the `CollectionView`'s destruction should happen in [`before:destroy:children`](#destroychildren-and-beforedestroychildren-events).
- name: Class Events remove:region and before:remove:region events
  id: events.class#removeregion-and-beforeremoveregion-events
  summary: These events fire before (before:remove:region) and after (remove:region) a region is removed from a view
  belongs_to: Class Events
  description: |-
    ### `remove:region` and `before:remove:region` events

    These events fire before (`before:remove:region`) and after (`remove:region`) a region is removed from a view. This event handler will receive the view instance, the region name string, and the region instance as event arguments. The region will be not be destroyed in the before event, but is destroyed by `remove:region`.

    **Note** Currently these events are only triggered using the `view.removeRegion` API and not when the region is destroyed directly. <https://github.com/marionettejs/backbone.marionette/issues/3602>

    ## CollectionView Events

    The `CollectionView` triggers unique events specifically related to child management.
- name: Class Events render and before:render events
  id: events.class#render-and-beforerender-events
  summary: Reflects when a view's template is being rendered into its el
  belongs_to: Class Events
  description: |-
    ### `render` and `before:render` events

    Reflects when a view's template is being rendered into its `el`.

    `before:render` will occur prior to removing any current child views. `render` is an ideal event for attaching child views to the view's template as the first render *generally* occurs prior to the view attaching to the DOM.

    ``` javascript
    import { View, CollectionView } from 'backbone.marionette';
    import MyChildView from './MyChildView';

    const MyView = View.extend({
      template: _.template('<div class="foo-region"></div>'),
      regions: {
        'foo': '.foo-region'
      },
      onRender() {
        this.showChildView('foo', new MyChildView());
      }
    });

    const MyCollectionView = CollectionView.extend({
      childView: MyChildView,
      onRender() {
        // Add a child not from the `collection`
        this.addChildView(new MyChildView());
      }
    })
    ```

    **Note** This event is only triggered when rendering a template into a view. A view that is pre-rendered will not have this event triggered unless re-rendered. [Pre-rendered views](dom.prerendered) should use `initialize` for attaching child views and the `render` event if the view is re-rendered.

    **Note** If a view's `template` is set to `false` this event will not trigger.
- name: Class Events render:children and before:render:children events
  id: events.class#renderchildren-and-beforerenderchildren-events
  summary: Similar to Region``show and before:show events these events fire before (before:render:children) and after (render:children) the children of the CollectionView are attached to the CollectionView's el or childViewContainer
  belongs_to: Class Events
  description: |-
    ### `render:children` and `before:render:children` events

    Similar to [`Region``show` and `before:show` events](#show-and-beforeshow-events) these events fire before (`before:render:children`) and after (`render:children`) the `children` of the `CollectionView` are attached to the `CollectionView`'s `el` or `childViewContainer`.

    These events will be passed the `CollectionView` instance and the array of views being attached. The views in the array may or may not be rendered or attached for `before:render:children`, but will be rendered and attached by `render:children`.

    If the `CollectionView` can determine that added views will only be appended to the end, only the appended views will be passed to the event. Otherwise all of the `children` views will be passed.

    **Note** if you consistently need all of the views within this event use [`children`](marionette.collectionview#collectionviews-children)
- name: Class Events show and before:show events
  id: events.class#show-and-beforeshow-events
  summary: These events fire before (before:show) and after (show) showing anything in a region
  belongs_to: Class Events
  description: |-
    ### `show` and `before:show` events

    These events fire before (`before:show`) and after (`show`) showing anything in a region. A view may or may not be rendered during `before:show`, but a view will be rendered by `show`.

    The `show` events will receive the region instance, the view being shown, and any options passed to `region.show`.

    ``` javascript
    import { Region, View } from 'backbone.marionette';

    const MyRegion = Region.extend({
      onBeforeShow(myRegion, view, options) {
        console.log(myRegion.hasView()); //false
        console.log(view.isRendered()); // false
        console.log(options.foo === 'bar'); // true
      },
      onShow(myRegion, view, options) {
        console.log(myRegion.hasView()); //true
        console.log(view.isRendered()); // true
        console.log(options.foo === 'bar'); // true
      }
    });

    const MyView = View.extend({
      template: _.template('hello')
    });

    const myRegion = new MyRegion({ el: '#dom-hook' });

    myRegion.show(new MyView(), { foo: 'bar' });
    ```
- name: Class Events sort and before:sort events
  id: events.class#sort-and-beforesort-events
  summary: These events fire before (before:sort) and after (sort) sorting the children in the CollectionView
  belongs_to: Class Events
  description: |-
    ### `sort` and `before:sort` events

    These events fire before (`before:sort`) and after (`sort`) sorting the children in the `CollectionView`. These events will only fire if there are [`children`](collectionview#collectionviews-children) and a [`viewComparator`](collectionview#defining-the-viewcomparator)
- name: Class Events start event
  id: events.class#start-event
  summary: Fired as part of the application startup
  belongs_to: Class Events
  description: |-
    ### `start` event

    Fired as part of the application startup. This is where you should be showing your views and starting `Backbone.history`.

    ``` javascript
    import Bb from 'backbone';
    import { Application } from 'backbone.marionette';

    import MyModel from './mymodel';
    import MyView from './myview';

    const MyApp = Application.extend({
      region: '#root-element',

      initialize(options) {
        console.log('Initialize' + options.foo);
      },

      onBeforeStart(app, options) {
        this.model = new MyModel(options.data);
      },

      onStart(app, options) {
        this.showView(new MyView({model: this.model}));
        Bb.history.start();
      }
    });

    const myApp = new MyApp({ foo: 'My App' });
    myApp.start({ data: { bar: true } });
    ```

    [Live example](https://jsfiddle.net/marionettejs/ny59rs7b/)

    As shown the `options` object is passed into the `Application` as the second argument to `start`.

    #### Application `destroy` events

    The `Application` class also triggers [Destroy Events](#destroy-and-beforedestroy-events).

    ## Behavior Events
- name: Classes
  id: classes
  summary: Marionette follows Backbone's pseudo-class architecture
  description: "# Marionette Classes\n\nMarionette follows Backbone's [pseudo-class architecture](basics#class-based-inheritance). This documentation is meant to provide a comprehensive listing of those classes so that the reader can have a high-level view and understand functional similarities between the classes. All of these classes share a [common set of functionality](common).\n\n### [Marionette.View](marionette.view)\n\nA `View` is used for managing portions of the DOM via a single parent DOM element or `el`. It provides a consistent interface for managing the content of the `el` which is typically administered by serializing a `Backbone.Model` or `Backbone.Collection` and rendering a template with the serialized data into the `View`s `el`.\n\nThe `View` provides event delegation for capturing and handling DOM interactions as well as the ability to separate concerns into smaller, managed child views.\n\n`View` includes:\n\n- [The DOM API](dom.api)\n- [Class Events](events.class#view-events)\n- [DOM Interactions](dom.interactions)\n- [Child Event Bubbling](events#event-bubbling)\n- [Entity Events](events.entity)\n- [View Rendering](view.rendering)\n- [Prerendered Content](dom.prerendered)\n- [View Lifecycle](view.lifecycle)\n\nA `View` can have [`Region`s](#marionetteregion) and [`Behavior`s](#marionettebehavior)\n\n### [Marionette.CollectionView](marionette.collectionview)\n\nA `CollectionView` like `View` manages a portion of the DOM via a single parent DOM element or `el`. This view manages an ordered set of child views that are shown within the view's `el`. These children are most often created to match the models of a `Backbone.Collection` though a `CollectionView` does not require a `collection` and can manage any set of views.\n\n`CollectionView` includes:\n\n- [The DOM API](dom.api)\n- [Class Events](events.class#collectionview-events)\n- [DOM Interactions](dom.interactions)\n- [Child Event Bubbling](events#event-bubbling)\n- [Entity Events](events.entity)\n- [View Rendering](view.rendering)\n- [Prerendered Content](dom.prerendered)\n- [View Lifecycle](view.lifecycle)\n\nA `CollectionView` can have [`Behavior`s](#marionettebehavior).\n\n### [Marionette.Region](marionette.region)\n\nRegions provide consistent methods to manage, show and destroy views in your applications and views.\n\n`Region` includes:\n\n- [Class Events](events.class#region-events)\n- [The DOM API](dom.api)\n\n### [Marionette.Behavior](marionette.behavior)\n\nA `Behavior` provides a clean separation of concerns to your view logic, allowing you to share common user-facing operations between your views.\n\n`Behavior` includes:\n\n- [Class Events](events.class#behavior-events)\n- [DOM Interactions](dom.interactions)\n- [Entity Events](events.entity)\n\n### [Marionette.Application](marionette.application)\n\nAn `Application` provides hooks for organizing and initiating other elements and a view tree.\n\n`Application` includes:\n\n- [Class Events](events.class#application-events)\n- [Radio API](backbone.radio#marionette-integration)\n- [MnObject's API](marionette.mnobject)\n\nAn `Application` can have a single [region](marionette.application#application-region).\n\n### [Marionette.MnObject](marionette.mnobject)\n\n`MnObject` incorporates backbone conventions `initialize`, `cid` and `extend`.\n\n`MnObject` includes:\n\n- [Class Events](events.class#mnobject-events)\n- [Radio API](backbone.radio#marionette-integration).\n\n## Routing in Marionette\n\nUsers of versions of Marionette prior to v4 will notice that a router is no longer bundled. The [Marionette.AppRouter](https://github.com/marionettejs/marionette.approuter) was extracted and the core library will no longer hold an opinion on routing.\n\n[Continue Reading](routing) about routing in Marionette.\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/classes.html](https://marionettejs.com/docs/v4.0.0/classes.html)"
- name: CollectionView
  id: marionette.collectionview
  summary: A CollectionView like View manages a portion of the DOM via a single parent DOM element or el
  description: "# Marionette.CollectionView\n\nA `CollectionView` like `View` manages a portion of the DOM via a single parent DOM element or `el`. This view manages an ordered set of child views that are shown within the view's `el`. These children are most often created to match the models of a `Backbone.Collection` though a `CollectionView` does not require a `collection` and can manage any set of views.\n\n`CollectionView` includes:\n\n- [The DOM API](dom.api)\n- [Class Events](events.class#collectionview-events)\n- [DOM Interactions](dom.interactions)\n- [Child Event Bubbling](events#event-bubbling)\n- [Entity Events](events.entity)\n- [View Rendering](view.rendering)\n- [Prerendered Content](dom.prerendered)\n- [View Lifecycle](view.lifecycle)\n\nA `CollectionView` can have [`Behavior`s](marionette.behavior).\n\n## Documentation Index\n\n- [Instantiating a CollectionView](#instantiating-a-collectionview)\n- [Rendering a CollectionView](#rendering-a-collectionview)\n  - [Rendering a Template](#rendering-a-template)\n  - [Defining the `childViewContainer`](#defining-the-childviewcontainer)\n  - [Re-rendering the CollectionView](#re-rendering-the-collectionview)\n- [View Lifecycle and Events](#view-lifecycle-and-events)\n- [Entity Events](#entity-events)\n- [DOM Interactions](#dom-interactions)\n- [Behaviors](#behaviors)\n- [Managing Children](#managing-children)\n  - [Attaching `children` within the `el`](#attaching-children-within-the-el)\n  - [Destroying All `children`](#destroying-all-children)\n- [CollectionView's `childView`](#collectionviews-childview)\n  - [Building the `children`](#building-the-children)\n  - [Passing Data to the `childView`](#passing-data-to-the-childview)\n- [CollectionView's `emptyView`](#collectionviews-emptyview)\n  - [CollectionView's `getEmptyRegion`](#collectionviews-getemptyregion)\n  - [Passing Data to the `emptyView`](#passing-data-to-the-emptyview)\n  - [Defining When an `emptyView` shows](#defining-when-an-emptyview-shows)\n- [Accessing a Child View](#accessing-a-child-view)\n  - [CollectionView `children` Iterators And Collection Functions](collectionview-children-iterators-and-collection-functions)\n- [Listening to Events on the `children`](#listening-to-events-on-the-children)\n- [Self Managed `children`](#self-managed-children)\n  - [Adding a Child View](#adding-a-child-view)\n  - [Removing a Child View](#removing-a-child-view)\n  - [Detaching a Child View](#detaching-a-child-view)\n  - [Swapping Child Views](#swapping-child-views)\n- [Sorting the `children`](#sorting-the-children)\n  - [Defining the `viewComparator`](#defining-the-viewcomparator)\n  - [Maintaining the `collection`'s sort](#maintaining-the-collections-sort)\n- [Filtering the `children`](#filtering-the-children)\n  - [Defining the `viewFilter`](#defining-the-viewfilter)\n\n## Instantiating a CollectionView\n\nWhen instantiating a `CollectionView` there are several properties, if passed, that will be attached directly to the instance: `attributes`, `behaviors`, `childView`, `childViewContainer`, `childViewEventPrefix`, `childViewEvents`, `childViewOptions`, `childViewTriggers`, `className`, `collection`, `collectionEvents`, `el`, `emptyView`, `emptyViewOptions`, `events`, `id`, `model`, `modelEvents`, `sortWithCollection`, `tagName`, `template`, `templateContext`, `triggers`, `ui`, `viewComparator`, `viewFilter`\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst myCollectionView = new CollectionView({ ... });\n```\n\nSome of these properties come from Marionette, but many are inherited from [`Backbone.View`](http://backbonejs.org/#View-constructor).\n\n## Rendering a CollectionView\n\nThe `render` method of the `CollectionView` is primarily responsible for rendering the entire collection. It loops through each of the children in the collection and renders them individually as a `childView`.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyCollectionView = CollectionView.extend({...});\n\n// all of the children views will now be rendered.\nnew MyCollectionView().render();\n```\n\n### Rendering a Template\n\nIn addition to rendering children, the `CollectionView` may have a `template`. The child views can be rendered within a DOM element of this template. The `CollectionView` will serialize either the `model` or `collection` along with context for the `template` to render.\n\nFor more detail on how to render templates, see [View Template Rendering](view.rendering).\n\n### Defining the `childViewContainer`\n\nBy default the `CollectionView` will render the children into the `el` of the `CollectionView`. If you are rendering a template you will want to set the `childViewContainer` to be a selector for an element within the template for child view attachment.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyCollectionView = CollectionView.extend({\n  childViewContainer: '.js-widgets',\n  template: _.template('<h1>Widgets</h1><ul class=\"js-widgets\"></ul>')\n});\n```\n\n**Errors** An error will throw if the childViewContainer can not be found.\n\n### Re-rendering the CollectionView\n\nIf you need to re-render the entire collection or the template, you can call the `collectionView.render` method. This method will destroying all of the child views that may have previously been added.\n\n## View Lifecycle and Events\n\nAn instantiated `CollectionView` is aware of its lifecycle state and will throw events related to when that state changes. The view states indicate whether the view is rendered, attached to the DOM, or destroyed.\n\nRead More:\n\n- [View Lifecycle](view.lifecycle)\n- [View DOM Change Events](events.class#dom-change-events)\n- [View Destroy Events](events.class#destroy-events)\n\n## Entity Events\n\nThe `CollectionView` can bind to events that occur on the attached `model` and `collection` - this includes both [standard backbone-events](http://backbonejs.org/#Events-catalog) and custom events.\n\nRead More:\n\n- [Entity Events](events.entity)\n\n## DOM Interactions\n\nIn addition to what Backbone provides the views, Marionette has additional API for DOM interactions: `events`, `triggers`, and `ui`.\n\nBy default `ui` is only bound to the elements within the [template](#rendering-a-template). However as `events` and `triggers` are delegated to the view's `el` they will apply to any children. There may be instances where binding `ui` is helpful when you want to access elements inside `CollectionView`s children with [`getUI()`](dom.interactions#accessing-ui-elements). For these cases you will need to bind `ui` yourself. To do so run `bindUIElements` on the `CollectionView`:\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyCollectionView = CollectionView.extend({\n  // ...\n\n  ui: {\n    checkbox: 'input[type=\"checkbox\"]'\n  }\n});\n\nconst collectionView = new MyCollectionView();\n\ncollectionView.bindUIElements();\n\nconsole.log(collectionView.getUI('checkbox')); // Output all checkboxes.\n```\n\nRead More:\n\n- [DOM Interactions](dom.interactions)\n\n## Behaviors\n\nA `Behavior` provides a clean separation of concerns to your view logic, allowing you to share common user-facing operations between your views.\n\nRead More:\n\n- [Using `Behavior`s](marionette.behavior#using-behaviors)\n\n## Managing Children\n\nChildren are automatically managed once the `CollectionView` is [rendered](#rendering-a-collectionview). For each model within the `collection` the `CollectionView` will build and store a `childView` within its `children` object. This allows you to easily access the views within the collection view, iterate them, find them by a given indexer such as the view's model or id and more.\n\nAfter the initial `render` the `CollectionView` binds to the `update` and `reset` events of the `collection`.\n\nWhen the `collection` for the view is `reset`, the view will destroy all children and re-render the entire collection.\n\nWhen a model is added to the `collection`, the `CollectionView` will render that one model into the `children`.\n\nWhen a model is removed from the `collection` (or destroyed / deleted), the `CollectionView` will destroy and remove that model's child view.\n\nWhen the `collection` for the view is sorted, the view by default automatically re-sort its child views unless the `sortWithCollection` attribute on the `CollectionView` is set to `false`, or the `viewComparator` is `false`.\n\n``` javascript\nimport Backbone from 'backbone';\nimport { View, CollectionView } from 'backbone.marionette';\n\nconst collection = new Backbone.Collection();\n\nconst MyChildView = View.extend({:\n  template: false\n});\n\nconst MyCollectionView = CollectionView.extend({\n  childView: MyChildView,\n  collection,\n});\n\nconst myCollectionView = new MyCollectionView();\n\n// Collection view will not re-render as it has not been rendered\ncollection.reset([{foo: 'foo'}]);\n\nmyCollectionView.render();\n\n// Collection view will effectively re-render displaying the new model\ncollection.reset([{foo: 'bar'}]);\n```\n\nWhen the children are rendered the [`render:children` and `before:render:children` events](events.class#renderchildren-and-beforerenderchildren-events) will trigger.\n\nWhen a childview is added to the children [`add:child` and `before:add:child` events](events.class#addchild-and-beforeaddchild-events) will trigger\n\nWhen a childview is removed from the children [`remove:child` and `before:remove:child` events](events.class#removechild-and-beforeremovechild-events) will trigger.\n\n### Attaching `children` within the `el`\n\nBy default the `CollectionView` will add the HTML of each ChildView into an element buffer array, and then call the DOM API's [appendContents](dom.api#appendcontentsel-contents) once at the end to move all of the HTML within the collection view's `el`.\n\nYou can override this by specifying an `attachHtml` method in your view definition. This method takes two parameters and has no return value.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nCollectionView.extend({\n\n  // The default implementation:\n  attachHtml(els, $container){\n    // Unless childViewContainer, $container === this.$el\n    this.Dom.appendContents(this.el, els);\n  }\n});\n```\n\nThe first parameter is the HTML buffer, and the second parameter is the expected container for the children which by default equates to the view's `el` unless a [`childViewContainer`](#defining-the-childViewContainer) is set.\n\n### Destroying All `children`\n\n`CollectionView` implements a `destroy` method which automatically destroys its children and cleans up listeners.\n\nWhen the children are destroyed the [`destroy:children` and `before:destroy:children` events](events.class#destroychildren-and-beforedestroychildren-events) will trigger.\n\nRead More:\n\n- [View Destroy Events](events.class#destroy-events)\n\n## CollectionView's `childView`\n\nWhen using a `collection` to manage the children of `CollectionView`, specify a `childView` for your `CollectionView`. This must be a Backbone view class definition, not an instance. It can be any `Backbone.View` related class including both Marionette's `View` and `CollectionView`.\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\nconst MyChildView = View.extend({});\n\nconst MyCollectionView = CollectionView.extend({\n  childView: MyChildView\n});\n```\n\n**Errors** If you do not specify a `childView`, an exception will be thrown stating that you must specify a `childView`.\n\nYou can also define `childView` as a function. In this form, the value returned by this method is the `ChildView` class that will be instantiated when a `Model` needs to be initially rendered. This method also gives you the ability to customize per `Model` `ChildViews`.\n\n``` javascript\nimport _ from 'underscore';\nimport Backbone from 'backbone';\nimport { View, CollectionView } from 'backbone.marionette';\n\nconst FooView =View.extend({\n  template: _.template('foo')\n});\n\nconst BarView = View.extend({\n  bar\n});\n\nconst MyCollectionView = CollectionView.extend({\n  collection: new Backbone.Collection(),\n  childView(item) {\n    // Choose which view class to render,\n    // depending on the properties of the item model\n    if  (item.get('isFoo')) {\n      return FooView;\n    }\n    else {\n      return BarView;\n    }\n  }\n});\n\nconst collectionView = new MyCollectionView();\n\nconst foo = new Backbone.Model({\n  isFoo: true\n});\n\nconst bar = new Backbone.Model({\n  isFoo: false\n});\n\n// Renders a FooView\ncollectionView.collection.add(foo);\n\n// Renders a BarView\ncollectionView.collection.add(bar);\n```\n\n**Errors** If `childView` is a function that does not return a view class an error will be thrown.\n\n### Building the `children`\n\nThe `buildChildView` method is responsible for taking the ChildView class and instantiating it with the appropriate data. This method takes three parameters and returns a view instance to be used as the child view.\n\n``` javascript\nbuildChildView(child, ChildViewClass, childViewOptions){\n  // build the final list of options for the childView class\n  const options = _.extend({model: child}, childViewOptions);\n  // create the child view instance\n  const view = new ChildViewClass(options);\n  // return it\n  return view;\n},\n```\n\nOverride this method when you need a more complicated build, but use [`childView`](#collectionviews-childview) if you need to determine *which* View class to instantiate.\n\n``` javascript\nimport _ from 'underscore';\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\nimport MyListView from './my-list-view';\nimport MyView from './my-view';\n\nconst MyCollectionView = CollectionView.extend({\n  childView(child) {\n    if (child.get('type') === 'list') {\n      return MyListView;\n    }\n\n    return MyView;\n  },\n  buildChildView(child, ChildViewClass, childViewOptions) {\n    const options = {};\n\n    if (child.get('type') === 'list') {\n      const childList = new Backbone.Collection(child.get('list'));\n      options = _.extend({collection: childList}, childViewOptions);\n    } else {\n      options = _.extend({model: child}, childViewOptions);\n    }\n\n    // create the child view instance\n    const view = new ChildViewClass(options);\n    // return it\n    return view;\n  }\n});\n```\n\n### Passing Data to the `childView`\n\nThere may be scenarios where you need to pass data from your parent collection view in to each of the childView instances. To do this, provide a `childViewOptions` definition on your collection view as an object literal. This will be passed to the constructor of your childView as part of the `options`.\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\nconst ChildView = View.extend({\n  initialize(options) {\n    console.log(options.foo); // => \"bar\"\n  }\n});\n\nconst MyCollectionView = CollectionView.extend({\n  childView: ChildView,\n\n  childViewOptions: {\n    foo: 'bar'\n  }\n});\n```\n\nYou can also specify the `childViewOptions` as a function, if you need to calculate the values to return at runtime. The model will be passed into the function should you need access to it when calculating `childViewOptions`. The function must return an object, and the attributes of the object will be copied to the `childView` instance's options.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyCollectionView = CollectionView.extend({\n  childViewOptions(model) {\n    // do some calculations based on the model\n    return {\n      foo: 'bar'\n    };\n  }\n});\n```\n\n## CollectionView's `emptyView`\n\nWhen a collection has no children, and you need to render a view other than the list of childViews, you can specify an `emptyView` attribute on your collection view. The `emptyView` just like the [`childView`](#collectionviews-childview) can also be passed as an option on instantiation or can be a function that returns the `emptyView`.\n\n``` javascript\nimport _ from 'underscore';\nimport { View, CollectionView } from 'backbone.marionette';\n\nconst MyEmptyView = View.extend({\n  template: _.template('Nothing to display.')\n});\n\nconst MyCollectionView = CollectionView.extend({\n  // ...\n\n  emptyView: MyEmptyView\n});\n```\n\n### CollectionView's `getEmptyRegion`\n\nWhen a `CollectionView` is instantiated it creates a region for showing the [`emptyView`](#collectionviews-emptyview). This region can be requested using the `getEmptyRegion` method. The region will share the `el` with the `CollectionView` and is shown with [`replaceElement: false`](marionette.region#additional-options).\n\n**Note** The `CollectionView` expects to be the only entity managing the region. Showing things in this region directly is not advised.\n\n``` javascript\nconst isEmptyShowing = myCollectionView.getEmptyRegion().hasView();\n```\n\nThis region can be useful for handling the [EmptyView Region Events](events.class#collectionview-emptyview-region-events).\n\n### Passing Data to the `emptyView`\n\nSimilar to [`childView`](#collectionviews-childview) and [`childViewOptions`](#padding-data-to-the-childview), there is an `emptyViewOptions` property that will be passed to the `emptyView` constructor. It can be provided as an object literal or as a function.\n\nIf `emptyViewOptions` aren't provided the `CollectionView` will default to passing the `childViewOptions` to the `emptyView`.\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\nconst EmptyView = View.extend({\n  initialize(options){\n    console.log(options.foo); // => \"bar\"\n  }\n});\n\nconst MyCollectionView = CollectionView.extend({\n  emptyView: EmptyView,\n\n  emptyViewOptions: {\n    foo: 'bar'\n  }\n});\n```\n\n### Defining When an `emptyView` shows\n\nIf you want to control when the empty view is rendered, you can override `isEmpty`:\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyCollectionView = CollectionView.extend({\n  isEmpty() {\n    // some logic to calculate if the view should be rendered as empty\n    return this.collection.length < 2;\n  }\n});\n```\n\nThe default implementation of `isEmpty` returns `!this.children.length`.\n\nYou can also use this method to determine when the empty view was shown:\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyCollectionView = CollectionView.extend({\n  // ...\n  onRenderChildren() {\n    if (this.isEmpty()) { console.log('Empty View Shown'); }\n  }\n});\n```\n\n## Accessing a Child View\n\nYou can retrieve a view by a number of methods. If the findBy\\* method cannot find the view, it will return `undefined`.\n\n**Note** That children represents the views rendered that are or will be attached within the view's `el`.\n\n#### CollectionView `children`'s: `findByCid`\n\nFind a view by it's cid.\n\n``` javascript\nconst bView = myCollectionView.children.findByCid(buttonView.cid);\n```\n\n#### CollectionView `children`'s: `findByModel`\n\nFind a view by model.\n\n``` javascript\nconst bView = myCollectionView.children.findByModel(buttonView.model);\n```\n\n#### CollectionView `children`'s: `findByModelCid`\n\nFind a view by model cid.\n\n``` javascript\nconst bView = myCollectionView.children.findByModelCid(buttonView.model.cid);\n```\n\n#### CollectionView `children`'s: `findByIndex`\n\nFind by numeric index (unstable)\n\n``` javascript\nconst bView = myCollectionView.children.findByIndex(0);\n```\n\n#### CollectionView `children`'s: `findIndexByView`\n\nFind the index of the view inside the children\n\n``` javascript\nconst index = myCollectionView.children.findIndexByView(bView);\n```\n\n### CollectionView `children` Iterators And Collection Functions\n\nThe container object borrows several functions from [Underscore.js](http://underscorejs.org/), to provide iterators and other collection functions, including:\n\n- [each](http://underscorejs.org/#each)\n- [map](http://underscorejs.org/#map)\n- [reduce](http://underscorejs.org/#reduce)\n- [find](http://underscorejs.org/#find)\n- [filter](http://underscorejs.org/#filter)\n- [reject](http://underscorejs.org/#reject)\n- [every](http://underscorejs.org/#every)\n- [some](http://underscorejs.org/#some)\n- [contains](http://underscorejs.org/#contains)\n- [invoke](http://underscorejs.org/#invoke)\n- [toArray](http://underscorejs.org/#toArray)\n- [first](http://underscorejs.org/#first)\n- [initial](http://underscorejs.org/#initial)\n- [rest](http://underscorejs.org/#rest)\n- [last](http://underscorejs.org/#last)\n- [without](http://underscorejs.org/#without)\n- [isEmpty](http://underscorejs.org/#isEmpty)\n- [pluck](http://underscorejs.org/#pluck)\n- [partition](http://underscorejs.org/#partition)\n\nThese methods can be called directly on the container, to iterate and process the views held by the container.\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\n\nconst collectionView = new CollectionView({\n  collection: new Backbone.Collection()\n});\n\ncollectionView.render();\n\n// iterate over all of the views and process them\ncollectionView.children.each(function(childView) {\n  // process the `childView` here\n});\n```\n\n## Listening to Events on the `children`\n\nThe `CollectionView` can take action depending on what events are triggered in its `children`.\n\nRead More:\n\n- [Child Event Bubbling](events#event-bubbling)\n\n## Self Managed `children`\n\nIn addition to children added by Marionette matching the model of a `collection`, the `children` of the `CollectionView` can be manually managed.\n\n### Adding a Child View\n\nThe `addChildView` method can be used to add a view that is independent of your `Backbone.Collection`. This method takes two parameters, the child view instance and optionally the index for where it should be placed within the [CollectionView's `children`](#managing-children). It returns the added view.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\nimport ButtonView from './button-view';\n\nconst MyCollectionView = CollectionView.extend({\n  onRender() {\n    View = new ButtonView();\n    this.addChildView(buttonView, this.children.length);\n  }\n});\n\nconst myCollectionView = new MyCollectionView();\n\nmyCollectionView.render();\n```\n\n**Note** Unless an index is specified, this added view will be subject to filtering and sorting and may be difficult to manage in complex situations. Use with care.\n\n### Removing a Child View\n\nThe `removeChildView` method is useful if you need to remove and destroy a view from the `CollectionView` without affecting the view's collection. In most cases it is better to use the data to determine what the `CollectionView` should display.\n\nThis method accepts the child view instance to remove as its parameter. It returns the removed view;\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyCollectionView = CollectionView.extend({\n  onChildViewFooEvent(childView, model) {\n    // NOTE: we must wait for the server to confirm\n    // the destroy PRIOR to removing it from the collection\n    model.destroy({wait: true});\n\n    // but go ahead and remove it visually\n    this.removeChildView(childView);\n  }\n});\n```\n\n### Detaching a Child View\n\nThis method is the same as [`removeChildView`](#removing-a-child-view) with the exception that the removed view is not destroyed.\n\n### Swapping Child Views\n\nSwap the location of two views in the `CollectionView` `children` and in the `el`. This can be useful when sorting is arbitrary or is not performant.\n\n**Errors** If either of the two views aren't part of the `CollectionView` an error will be thrown.\n\nIf one child is in the `el` but the other is not, [filter](#filtering-the-children) will be called.\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\nimport MyChildView from './my-child-view';\n\nconst collection = new Backbone.Collection([\n  { name: 'first' },\n  { name: 'middle' },\n  { name: 'last' }\n]);\n\nconst myColView = new CollectionView({\n  collection: collection,\n  childView: MyChildView\n});\n\nmyColView.swapChildViews(myColView.children.first(), myColView.children.last());\n\nmyColView.children.first().model.get('name'); // \"last\"\nmyColView.children.last().model.get('name'); // \"first\"\n```\n\n## Sorting the `children`\n\nThe `sort` method will loop through the `CollectionView` `children` prior to filtering and sort them with the [`viewComparator`](#defining-the-viewcomparator). By default, if a `viewComparator` is not set, the `CollectionView` will sort the views by the order of the models in the `collection`. If set to `false` view sorting will be disabled.\n\nThis method is called internally when rendering and [`sort` and `before:sort` events](events.class#sort-and-beforesort-events) will trigger.\n\nBy default the `CollectionView` will maintain a sorted collection's order in the DOM. This behavior can be disabled by specifying `{sortWithCollection: false}` on initialize.\n\n### Defining the `viewComparator`\n\n`CollectionView` allows for a custom `viewComparator` option if you want your `CollectionView`'s children to be rendered with a different sort order than the underlying Backbone collection uses.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst myCollectionView = new CollectionView({\n  collection: someCollection,\n  viewComparator: 'otherFieldToSortOn'\n});\n```\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\n\nconst myCollection = new Backbone.Collection([\n  { id: 1 },\n  { id: 4 },\n  { id: 3 },\n  { id: 2 }\n]);\n\nmyCollection.comparator = 'id';\n\nconst mySortedColView = new CollectionView({\n  //...\n  collection: myCollection\n});\n\nconst myUnsortedColView = new CollectionView({\n  //...\n  collection: myCollection,\n  viewComparator: false\n});\n\nmySortedColView.render(); // 1 4 3 2\nmyUnsortedColView.render(); // 1 4 3 2\n\nmyCollection.sort();\n// mySortedColView auto-renders 1 2 3 4\n// myUnsortedColView has no change\n```\n\nThe `viewComparator` can take any of the acceptable `Backbone.Collection` [comparator formats](http://backbonejs.org/#Collection-comparator) -- a sortBy (pass a function that takes a single argument), as a sort (pass a comparator function that expects two arguments), or as a string indicating the attribute to sort by.\n\n#### `getComparator`\n\nOverride this method to determine which `viewComparator` to use.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyCollectionView = CollectionView.extend({\n  sortAsc(model) {\n    return -model.get('order');\n  },\n  sortDesc(model) {\n    return model.get('order');\n  },\n  getComparator() {\n    // The collectionView's model\n    if (this.model.get('sorted') === 'ASC') {\n      return this.sortAsc;\n    }\n\n    return this.sortDesc;\n  }\n});\n```\n\n#### `setComparator`\n\nThe `setComparator` method modifies the `CollectionView`'s `viewComparator` attribute and re-sorts. Passing `{ preventRender: true }` in the options argument will prevent the view being rendered.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst cv = new CollectionView({\n  collection: someCollection\n});\n\ncv.render();\n\n// Note: the setComparator is preventing the automatic re-render\ncv.setComparator('orderBy', { preventRender: true });\n\n// Render the children ordered by the orderBy attribute\ncv.render();\n```\n\n#### `removeComparator`\n\nThis function is actually an alias of `setComparator(null, options)`. It is useful for removing the comparator. `removeComparator` also accepts `preventRender` as a option.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst cv = new CollectionView({\n  collection: someCollection\n});\n\ncv.render();\n\ncv.setComparator('orderBy');\n\n//Remove the current comparator without rendering again.\ncv.removeComparator({ preventRender: true });\n```\n\n### Maintaining the `collection`'s sort\n\nBy default the `CollectionView` will maintain a sorted collection's order in the DOM. This behavior can be disabled by specifying `{sortWithCollection: false}` on initialize or on the view definiton.\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\n\nconst myCollection = new Backbone.Collection([\n  { id: 1 },\n  { id: 4 },\n  { id: 3 },\n  { id: 2 }\n]);\n\nmyCollection.comparator = 'id';\n\nconst mySortedColView = new CollectionView({\n  //...\n  collection: myCollection\n});\n\nconst myUnsortedColView = new CollectionView({\n  //...\n  collection: myCollection,\n  sortWithCollection: false\n});\n\nmySortedColView.render(); // 1 4 3 2\nmyUnsortedColView.render(); // 1 4 3 2\n\nmyCollection.sort();\n// mySortedColView auto-renders 1 2 3 4\n// myUnsortedColView has no change\n```\n\n## Filtering the `children`\n\nThe `filter` method will loop through the `CollectionView`'s sorted `children` and test them against the [`viewFilter`](#defining-the-viewfilter). The views that pass the `viewFilter`are rendered if necessary and attached to the CollectionView and the views that are filtered out will be detached. After filtering the `children` will only contain the views to be attached.\n\nIf a `viewFilter` exists the [`filter` and `before:filter` events](events.class#filter-and-beforefilter-events) will trigger.\n\nBy default the CollectionView will refilter when views change or when the CollectionView is sorted.\n\n**Note** This is a presentation functionality used to easily filter in and out constructed children. All children of a `collection` will be instantiated once regardless of their filtered status. If you would prefer to manage child view instantiation, you should filter the `collection` itself.\n\n### Defining the `viewFilter`\n\n`CollectionView` allows for a custom `viewFilter` option if you want to prevent some of the underlying `children` from being attached to the DOM. A `viewFilter` can be a function, predicate object. or string.\n\n**Errors** An error will be thrown if the `ViewFilter` is not one of these options.\n\n#### `viewFilter` as a function\n\nThe `viewFilter` function takes a view from the `children` and returns a truthy value if the child should be attached, and a falsey value if it should not.\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\n\nconst cv = new CollectionView({\n  childView: SomeChildView,\n  emptyView: SomeEmptyView,\n  collection: new Bb.Collection([\n    { value: 1 },\n    { value: 2 },\n    { value: 3 },\n    { value: 4 }\n  ]),\n\n  // Only show views with even values\n  viewFilter(view, index, children) {\n    return view.model.get('value') % 2 === 0;\n  }\n});\n\n// renders the views with values '2' and '4'\ncv.render();\n```\n\n#### `viewFilter` as a predicate object\n\nThe `viewFilter` predicate object will filter against the view's model attributes.\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\n\nconst cv = new CollectionView({\n  childView: SomeChildView,\n  emptyView: SomeEmptyView,\n  collection: new Bb.Collection([\n    { value: 1 },\n    { value: 2 },\n    { value: 3 },\n    { value: 4 }\n  ]),\n\n  // Only show views with value 2\n  viewFilter: { value: 2 }\n});\n\n// renders the view with values '2'\ncv.render();\n```\n\n#### `viewFilter` as a string\n\nThe `viewFilter` string represents the view's model attribute and will filter truthy values.\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\n\nconst cv = new CollectionView({\n  childView: SomeChildView,\n  emptyView: SomeEmptyView,\n  collection: new Bb.Collection([\n    { value: 0 },\n    { value: 1 },\n    { value: 2 },\n    { value: null },\n    { value: 4 }\n  ]),\n\n  // Only show views 1,2, and 4\n  viewFilter: 'value'\n});\n\n// renders the view with values '1', '2', and '4'\ncv.render();\n```\n\n#### `getFilter`\n\nOverride this function to programatically decide which `viewFilter` to use when `filter` is called.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyCollectionView = CollectionView.extend({\n  summaryFilter(view) {\n    return view.model.get('type') === 'summary';\n  },\n  getFilter() {\n    if (this.collection.length > 100) {\n      return this.summaryFilter;\n    }\n    return this.viewFilter;\n  }\n});\n```\n\n#### `setFilter`\n\nThe `setFilter` method modifies the `CollectionView`'s `viewFilter` attribute and filters. Passing `{ preventRender: true }` in the options argument will prevent the view being rendered.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst cv = new CollectionView({\n  collection: someCollection\n});\n\ncv.render();\n\nconst newFilter = function(view, index, children) {\n  return view.model.get('value') % 2 === 0;\n};\n\n// Note: the setFilter is preventing the automatic re-render\ncv.setFilter(newFilter, { preventRender: true });\n\n//Render the new state of the ChildViews instead of the whole DOM.\ncv.render();\n```\n\n#### `removeFilter`\n\nThis function is actually an alias of `setFilter(null, options)`. It is useful for removing filters. `removeFilter` also accepts `preventRender` as a option.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst cv = new CollectionView({\n  collection: someCollection\n});\n\ncv.render();\n\ncv.setFilter(function(view, index, children) {\n  return view.model.get('value') % 2 === 0;\n});\n\n//Remove the current filter without rendering again.\ncv.removeFilter({ preventRender: true });\n```\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/marionette.collectionview.html](https://marionettejs.com/docs/v4.0.0/marionette.collectionview.html)"
- name: CollectionView children Iterators And Collection Functions
  id: marionette.collectionview#collectionview-children-iterators-and-collection-functions
  summary: These methods can be called directly on the container, to iterate and process the views held by the container
  belongs_to: CollectionView
  description: "### CollectionView `children` Iterators And Collection Functions\n\nThe container object borrows several functions from [Underscore.js](http://underscorejs.org/), to provide iterators and other collection functions, including:\n\n- [each](http://underscorejs.org/#each)\n- [map](http://underscorejs.org/#map)\n- [reduce](http://underscorejs.org/#reduce)\n- [find](http://underscorejs.org/#find)\n- [filter](http://underscorejs.org/#filter)\n- [reject](http://underscorejs.org/#reject)\n- [every](http://underscorejs.org/#every)\n- [some](http://underscorejs.org/#some)\n- [contains](http://underscorejs.org/#contains)\n- [invoke](http://underscorejs.org/#invoke)\n- [toArray](http://underscorejs.org/#toArray)\n- [first](http://underscorejs.org/#first)\n- [initial](http://underscorejs.org/#initial)\n- [rest](http://underscorejs.org/#rest)\n- [last](http://underscorejs.org/#last)\n- [without](http://underscorejs.org/#without)\n- [isEmpty](http://underscorejs.org/#isEmpty)\n- [pluck](http://underscorejs.org/#pluck)\n- [partition](http://underscorejs.org/#partition)\n\nThese methods can be called directly on the container, to iterate and process the views held by the container.\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\n\nconst collectionView = new CollectionView({\n  collection: new Backbone.Collection()\n});\n\ncollectionView.render();\n\n// iterate over all of the views and process them\ncollectionView.children.each(function(childView) {\n  // process the `childView` here\n});\n```\n\n## Listening to Events on the `children`\n\nThe `CollectionView` can take action depending on what events are triggered in its `children`.\n\nRead More:\n\n- [Child Event Bubbling](events#event-bubbling)\n\n## Self Managed `children`\n\nIn addition to children added by Marionette matching the model of a `collection`, the `children` of the `CollectionView` can be manually managed.\n\n### Adding a Child View\n\nThe `addChildView` method can be used to add a view that is independent of your `Backbone.Collection`. This method takes two parameters, the child view instance and optionally the index for where it should be placed within the [CollectionView's `children`](#managing-children). It returns the added view.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\nimport ButtonView from './button-view';\n\nconst MyCollectionView = CollectionView.extend({\n  onRender() {\n    View = new ButtonView();\n    this.addChildView(buttonView, this.children.length);\n  }\n});\n\nconst myCollectionView = new MyCollectionView();\n\nmyCollectionView.render();\n```\n\n**Note** Unless an index is specified, this added view will be subject to filtering and sorting and may be difficult to manage in complex situations. Use with care.\n\n### Removing a Child View\n\nThe `removeChildView` method is useful if you need to remove and destroy a view from the `CollectionView` without affecting the view's collection. In most cases it is better to use the data to determine what the `CollectionView` should display.\n\nThis method accepts the child view instance to remove as its parameter. It returns the removed view;\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyCollectionView = CollectionView.extend({\n  onChildViewFooEvent(childView, model) {\n    // NOTE: we must wait for the server to confirm\n    // the destroy PRIOR to removing it from the collection\n    model.destroy({wait: true});\n\n    // but go ahead and remove it visually\n    this.removeChildView(childView);\n  }\n});\n```\n\n### Detaching a Child View\n\nThis method is the same as [`removeChildView`](#removing-a-child-view) with the exception that the removed view is not destroyed.\n\n### Swapping Child Views\n\nSwap the location of two views in the `CollectionView` `children` and in the `el`. This can be useful when sorting is arbitrary or is not performant.\n\n**Errors** If either of the two views aren't part of the `CollectionView` an error will be thrown.\n\nIf one child is in the `el` but the other is not, [filter](#filtering-the-children) will be called.\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\nimport MyChildView from './my-child-view';\n\nconst collection = new Backbone.Collection([\n  { name: 'first' },\n  { name: 'middle' },\n  { name: 'last' }\n]);\n\nconst myColView = new CollectionView({\n  collection: collection,\n  childView: MyChildView\n});\n\nmyColView.swapChildViews(myColView.children.first(), myColView.children.last());\n\nmyColView.children.first().model.get('name'); // \"last\"\nmyColView.children.last().model.get('name'); // \"first\"\n```\n\n## Sorting the `children`\n\nThe `sort` method will loop through the `CollectionView` `children` prior to filtering and sort them with the [`viewComparator`](#defining-the-viewcomparator). By default, if a `viewComparator` is not set, the `CollectionView` will sort the views by the order of the models in the `collection`. If set to `false` view sorting will be disabled.\n\nThis method is called internally when rendering and [`sort` and `before:sort` events](events.class#sort-and-beforesort-events) will trigger.\n\nBy default the `CollectionView` will maintain a sorted collection's order in the DOM. This behavior can be disabled by specifying `{sortWithCollection: false}` on initialize.\n\n### Defining the `viewComparator`\n\n`CollectionView` allows for a custom `viewComparator` option if you want your `CollectionView`'s children to be rendered with a different sort order than the underlying Backbone collection uses.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst myCollectionView = new CollectionView({\n  collection: someCollection,\n  viewComparator: 'otherFieldToSortOn'\n});\n```\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\n\nconst myCollection = new Backbone.Collection([\n  { id: 1 },\n  { id: 4 },\n  { id: 3 },\n  { id: 2 }\n]);\n\nmyCollection.comparator = 'id';\n\nconst mySortedColView = new CollectionView({\n  //...\n  collection: myCollection\n});\n\nconst myUnsortedColView = new CollectionView({\n  //...\n  collection: myCollection,\n  viewComparator: false\n});\n\nmySortedColView.render(); // 1 4 3 2\nmyUnsortedColView.render(); // 1 4 3 2\n\nmyCollection.sort();\n// mySortedColView auto-renders 1 2 3 4\n// myUnsortedColView has no change\n```\n\nThe `viewComparator` can take any of the acceptable `Backbone.Collection` [comparator formats](http://backbonejs.org/#Collection-comparator) -- a sortBy (pass a function that takes a single argument), as a sort (pass a comparator function that expects two arguments), or as a string indicating the attribute to sort by.\n\n#### `getComparator`\n\nOverride this method to determine which `viewComparator` to use.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyCollectionView = CollectionView.extend({\n  sortAsc(model) {\n    return -model.get('order');\n  },\n  sortDesc(model) {\n    return model.get('order');\n  },\n  getComparator() {\n    // The collectionView's model\n    if (this.model.get('sorted') === 'ASC') {\n      return this.sortAsc;\n    }\n\n    return this.sortDesc;\n  }\n});\n```\n\n#### `setComparator`\n\nThe `setComparator` method modifies the `CollectionView`'s `viewComparator` attribute and re-sorts. Passing `{ preventRender: true }` in the options argument will prevent the view being rendered.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst cv = new CollectionView({\n  collection: someCollection\n});\n\ncv.render();\n\n// Note: the setComparator is preventing the automatic re-render\ncv.setComparator('orderBy', { preventRender: true });\n\n// Render the children ordered by the orderBy attribute\ncv.render();\n```\n\n#### `removeComparator`\n\nThis function is actually an alias of `setComparator(null, options)`. It is useful for removing the comparator. `removeComparator` also accepts `preventRender` as a option.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst cv = new CollectionView({\n  collection: someCollection\n});\n\ncv.render();\n\ncv.setComparator('orderBy');\n\n//Remove the current comparator without rendering again.\ncv.removeComparator({ preventRender: true });\n```\n\n### Maintaining the `collection`'s sort\n\nBy default the `CollectionView` will maintain a sorted collection's order in the DOM. This behavior can be disabled by specifying `{sortWithCollection: false}` on initialize or on the view definiton.\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\n\nconst myCollection = new Backbone.Collection([\n  { id: 1 },\n  { id: 4 },\n  { id: 3 },\n  { id: 2 }\n]);\n\nmyCollection.comparator = 'id';\n\nconst mySortedColView = new CollectionView({\n  //...\n  collection: myCollection\n});\n\nconst myUnsortedColView = new CollectionView({\n  //...\n  collection: myCollection,\n  sortWithCollection: false\n});\n\nmySortedColView.render(); // 1 4 3 2\nmyUnsortedColView.render(); // 1 4 3 2\n\nmyCollection.sort();\n// mySortedColView auto-renders 1 2 3 4\n// myUnsortedColView has no change\n```\n\n## Filtering the `children`\n\nThe `filter` method will loop through the `CollectionView`'s sorted `children` and test them against the [`viewFilter`](#defining-the-viewfilter). The views that pass the `viewFilter`are rendered if necessary and attached to the CollectionView and the views that are filtered out will be detached. After filtering the `children` will only contain the views to be attached.\n\nIf a `viewFilter` exists the [`filter` and `before:filter` events](events.class#filter-and-beforefilter-events) will trigger.\n\nBy default the CollectionView will refilter when views change or when the CollectionView is sorted.\n\n**Note** This is a presentation functionality used to easily filter in and out constructed children. All children of a `collection` will be instantiated once regardless of their filtered status. If you would prefer to manage child view instantiation, you should filter the `collection` itself.\n\n### Defining the `viewFilter`\n\n`CollectionView` allows for a custom `viewFilter` option if you want to prevent some of the underlying `children` from being attached to the DOM. A `viewFilter` can be a function, predicate object. or string.\n\n**Errors** An error will be thrown if the `ViewFilter` is not one of these options.\n\n#### `viewFilter` as a function\n\nThe `viewFilter` function takes a view from the `children` and returns a truthy value if the child should be attached, and a falsey value if it should not.\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\n\nconst cv = new CollectionView({\n  childView: SomeChildView,\n  emptyView: SomeEmptyView,\n  collection: new Bb.Collection([\n    { value: 1 },\n    { value: 2 },\n    { value: 3 },\n    { value: 4 }\n  ]),\n\n  // Only show views with even values\n  viewFilter(view, index, children) {\n    return view.model.get('value') % 2 === 0;\n  }\n});\n\n// renders the views with values '2' and '4'\ncv.render();\n```\n\n#### `viewFilter` as a predicate object\n\nThe `viewFilter` predicate object will filter against the view's model attributes.\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\n\nconst cv = new CollectionView({\n  childView: SomeChildView,\n  emptyView: SomeEmptyView,\n  collection: new Bb.Collection([\n    { value: 1 },\n    { value: 2 },\n    { value: 3 },\n    { value: 4 }\n  ]),\n\n  // Only show views with value 2\n  viewFilter: { value: 2 }\n});\n\n// renders the view with values '2'\ncv.render();\n```\n\n#### `viewFilter` as a string\n\nThe `viewFilter` string represents the view's model attribute and will filter truthy values.\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\n\nconst cv = new CollectionView({\n  childView: SomeChildView,\n  emptyView: SomeEmptyView,\n  collection: new Bb.Collection([\n    { value: 0 },\n    { value: 1 },\n    { value: 2 },\n    { value: null },\n    { value: 4 }\n  ]),\n\n  // Only show views 1,2, and 4\n  viewFilter: 'value'\n});\n\n// renders the view with values '1', '2', and '4'\ncv.render();\n```\n\n#### `getFilter`\n\nOverride this function to programatically decide which `viewFilter` to use when `filter` is called.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyCollectionView = CollectionView.extend({\n  summaryFilter(view) {\n    return view.model.get('type') === 'summary';\n  },\n  getFilter() {\n    if (this.collection.length > 100) {\n      return this.summaryFilter;\n    }\n    return this.viewFilter;\n  }\n});\n```\n\n#### `setFilter`\n\nThe `setFilter` method modifies the `CollectionView`'s `viewFilter` attribute and filters. Passing `{ preventRender: true }` in the options argument will prevent the view being rendered.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst cv = new CollectionView({\n  collection: someCollection\n});\n\ncv.render();\n\nconst newFilter = function(view, index, children) {\n  return view.model.get('value') % 2 === 0;\n};\n\n// Note: the setFilter is preventing the automatic re-render\ncv.setFilter(newFilter, { preventRender: true });\n\n//Render the new state of the ChildViews instead of the whole DOM.\ncv.render();\n```\n\n#### `removeFilter`\n\nThis function is actually an alias of `setFilter(null, options)`. It is useful for removing filters. `removeFilter` also accepts `preventRender` as a option.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst cv = new CollectionView({\n  collection: someCollection\n});\n\ncv.render();\n\ncv.setFilter(function(view, index, children) {\n  return view.model.get('value') % 2 === 0;\n});\n\n//Remove the current filter without rendering again.\ncv.removeFilter({ preventRender: true });\n```\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/marionette.collectionview.html](https://marionettejs.com/docs/v4.0.0/marionette.collectionview.html)"
- name: CollectionView childView
  id: marionette.collectionview#collectionviews-childview
  summary: When using a collection to manage the children of CollectionView, specify a childView for your CollectionView
  belongs_to: CollectionView
  description: |-
    ## CollectionView's `childView`

    When using a `collection` to manage the children of `CollectionView`, specify a `childView` for your `CollectionView`. This must be a Backbone view class definition, not an instance. It can be any `Backbone.View` related class including both Marionette's `View` and `CollectionView`.

    ``` javascript
    import { View, CollectionView } from 'backbone.marionette';

    const MyChildView = View.extend({});

    const MyCollectionView = CollectionView.extend({
      childView: MyChildView
    });
    ```

    **Errors** If you do not specify a `childView`, an exception will be thrown stating that you must specify a `childView`.

    You can also define `childView` as a function. In this form, the value returned by this method is the `ChildView` class that will be instantiated when a `Model` needs to be initially rendered. This method also gives you the ability to customize per `Model` `ChildViews`.

    ``` javascript
    import _ from 'underscore';
    import Backbone from 'backbone';
    import { View, CollectionView } from 'backbone.marionette';

    const FooView =View.extend({
      template: _.template('foo')
    });

    const BarView = View.extend({
      bar
    });

    const MyCollectionView = CollectionView.extend({
      collection: new Backbone.Collection(),
      childView(item) {
        // Choose which view class to render,
        // depending on the properties of the item model
        if  (item.get('isFoo')) {
          return FooView;
        }
        else {
          return BarView;
        }
      }
    });

    const collectionView = new MyCollectionView();

    const foo = new Backbone.Model({
      isFoo: true
    });

    const bar = new Backbone.Model({
      isFoo: false
    });

    // Renders a FooView
    collectionView.collection.add(foo);

    // Renders a BarView
    collectionView.collection.add(bar);
    ```

    **Errors** If `childView` is a function that does not return a view class an error will be thrown.

    ### Building the `children`

    The `buildChildView` method is responsible for taking the ChildView class and instantiating it with the appropriate data. This method takes three parameters and returns a view instance to be used as the child view.

    ``` javascript
    buildChildView(child, ChildViewClass, childViewOptions){
      // build the final list of options for the childView class
      const options = _.extend({model: child}, childViewOptions);
      // create the child view instance
      const view = new ChildViewClass(options);
      // return it
      return view;
    },
    ```

    Override this method when you need a more complicated build, but use [`childView`](#collectionviews-childview) if you need to determine *which* View class to instantiate.

    ``` javascript
    import _ from 'underscore';
    import Backbone from 'backbone';
    import { CollectionView } from 'backbone.marionette';
    import MyListView from './my-list-view';
    import MyView from './my-view';

    const MyCollectionView = CollectionView.extend({
      childView(child) {
        if (child.get('type') === 'list') {
          return MyListView;
        }

        return MyView;
      },
      buildChildView(child, ChildViewClass, childViewOptions) {
        const options = {};

        if (child.get('type') === 'list') {
          const childList = new Backbone.Collection(child.get('list'));
          options = _.extend({collection: childList}, childViewOptions);
        } else {
          options = _.extend({model: child}, childViewOptions);
        }

        // create the child view instance
        const view = new ChildViewClass(options);
        // return it
        return view;
      }
    });
    ```

    ### Passing Data to the `childView`

    There may be scenarios where you need to pass data from your parent collection view in to each of the childView instances. To do this, provide a `childViewOptions` definition on your collection view as an object literal. This will be passed to the constructor of your childView as part of the `options`.

    ``` javascript
    import { View, CollectionView } from 'backbone.marionette';

    const ChildView = View.extend({
      initialize(options) {
        console.log(options.foo); // => "bar"
      }
    });

    const MyCollectionView = CollectionView.extend({
      childView: ChildView,

      childViewOptions: {
        foo: 'bar'
      }
    });
    ```

    You can also specify the `childViewOptions` as a function, if you need to calculate the values to return at runtime. The model will be passed into the function should you need access to it when calculating `childViewOptions`. The function must return an object, and the attributes of the object will be copied to the `childView` instance's options.

    ``` javascript
    import { CollectionView } from 'backbone.marionette';

    const MyCollectionView = CollectionView.extend({
      childViewOptions(model) {
        // do some calculations based on the model
        return {
          foo: 'bar'
        };
      }
    });
    ```
- name: CollectionView emptyView
  id: marionette.collectionview#collectionviews-emptyview
  summary: When a collection has no children, and you need to render a view other than the list of childViews, you can specify an emptyView attribute on your collection view
  belongs_to: CollectionView
  description: |-
    ## CollectionView's `emptyView`

    When a collection has no children, and you need to render a view other than the list of childViews, you can specify an `emptyView` attribute on your collection view. The `emptyView` just like the [`childView`](#collectionviews-childview) can also be passed as an option on instantiation or can be a function that returns the `emptyView`.

    ``` javascript
    import _ from 'underscore';
    import { View, CollectionView } from 'backbone.marionette';

    const MyEmptyView = View.extend({
      template: _.template('Nothing to display.')
    });

    const MyCollectionView = CollectionView.extend({
      // ...

      emptyView: MyEmptyView
    });
    ```
- name: CollectionView getEmptyRegion
  id: marionette.collectionview#collectionviews-getemptyregion
  summary: When a CollectionView is instantiated it creates a region for showing the emptyView
  belongs_to: CollectionView
  description: |-
    ### CollectionView's `getEmptyRegion`

    When a `CollectionView` is instantiated it creates a region for showing the [`emptyView`](#collectionviews-emptyview). This region can be requested using the `getEmptyRegion` method. The region will share the `el` with the `CollectionView` and is shown with [`replaceElement: false`](marionette.region#additional-options).

    **Note** The `CollectionView` expects to be the only entity managing the region. Showing things in this region directly is not advised.

    ``` javascript
    const isEmptyShowing = myCollectionView.getEmptyRegion().hasView();
    ```

    This region can be useful for handling the [EmptyView Region Events](events.class#collectionview-emptyview-region-events).

    ### Passing Data to the `emptyView`

    Similar to [`childView`](#collectionviews-childview) and [`childViewOptions`](#padding-data-to-the-childview), there is an `emptyViewOptions` property that will be passed to the `emptyView` constructor. It can be provided as an object literal or as a function.

    If `emptyViewOptions` aren't provided the `CollectionView` will default to passing the `childViewOptions` to the `emptyView`.

    ``` javascript
    import { View, CollectionView } from 'backbone.marionette';

    const EmptyView = View.extend({
      initialize(options){
        console.log(options.foo); // => "bar"
      }
    });

    const MyCollectionView = CollectionView.extend({
      emptyView: EmptyView,

      emptyViewOptions: {
        foo: 'bar'
      }
    });
    ```

    ### Defining When an `emptyView` shows

    If you want to control when the empty view is rendered, you can override `isEmpty`:

    ``` javascript
    import { CollectionView } from 'backbone.marionette';

    const MyCollectionView = CollectionView.extend({
      isEmpty() {
        // some logic to calculate if the view should be rendered as empty
        return this.collection.length < 2;
      }
    });
    ```

    The default implementation of `isEmpty` returns `!this.children.length`.

    You can also use this method to determine when the empty view was shown:

    ``` javascript
    import { CollectionView } from 'backbone.marionette';

    const MyCollectionView = CollectionView.extend({
      // ...
      onRenderChildren() {
        if (this.isEmpty()) { console.log('Empty View Shown'); }
      }
    });
    ```

    ## Accessing a Child View

    You can retrieve a view by a number of methods. If the findBy\* method cannot find the view, it will return `undefined`.

    **Note** That children represents the views rendered that are or will be attached within the view's `el`.

    #### CollectionView `children`'s: `findByCid`

    Find a view by it's cid.

    ``` javascript
    const bView = myCollectionView.children.findByCid(buttonView.cid);
    ```

    #### CollectionView `children`'s: `findByModel`

    Find a view by model.

    ``` javascript
    const bView = myCollectionView.children.findByModel(buttonView.model);
    ```

    #### CollectionView `children`'s: `findByModelCid`

    Find a view by model cid.

    ``` javascript
    const bView = myCollectionView.children.findByModelCid(buttonView.model.cid);
    ```

    #### CollectionView `children`'s: `findByIndex`

    Find by numeric index (unstable)

    ``` javascript
    const bView = myCollectionView.children.findByIndex(0);
    ```

    #### CollectionView `children`'s: `findIndexByView`

    Find the index of the view inside the children

    ``` javascript
    const index = myCollectionView.children.findIndexByView(bView);
    ```
- name: Common Concepts
  id: basics
  summary: This document covers the basic usage patterns and concepts across Marionette
  description: "# Common Marionette Concepts\n\nThis document covers the basic usage patterns and concepts across Marionette. This includes things like calling conventions, setting attributes, common option patterns etc.\n\n## Documentation Index\n\n- [Using ES6 Modules](#using-es6-modules)\n- [Class-based Inheritance](#class-based-inheritance)\n  - [Value Attributes](#value-attributes)\n  - [Functions Returning Values](#functions-returning-values)\n  - [Binding Attributes on Instantiation](#binding-attributes-on-instantiation)\n- [Common Marionette Functionality](common)\n\n## Using ES6 Modules\n\nMarionette still supports using the library via an inline script.\n\n``` html\n<script src=\"./backbone.marionette.js\"></script>\n<script>new Marionette.View({ el: 'body' });</script>\n```\n\nThe recommended solution is to choose a solution like a [package manager](installation) to allow for ES6 module importing of the library. The best way to import is using name imports.\n\n``` javascript\nimport { View } from 'backbone.marionette';\nimport * as Mn from 'backbone.marionette';\n\nnew View({ el: 'body' });\nnew Mn.Application();\n```\n\nHowever to support backwards compatibility Marionette exports all of its classes and functions on a default object. This default export may be removed in a future version of Marionette and it is recommend to migrate to a named imports.\n\n``` javascript\nimport Marionette from 'backbone.marionette';\n\nnew Marionette.Application();\n```\n\n## Class-based Inheritance\n\nLike [Backbone](http://backbonejs.org/#Model-extend), Marionette utilizes the [`_.extend`](http://underscorejs.org/#extend) function to simulate class-based inheritance. [All built-in classes](classes), such as `Marionette.View`, `Marionette.MnObject` and everything that extend these provide an `extend` method for just this purpose.\n\nIn the example below, we create a new pseudo-class called `MyView`:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({});\n```\n\nYou can now create instances of `MyView` with JavaScript's `new` keyword:\n\n``` javascript\nconst view = new MyView();\n```\n\n### Value Attributes\n\nWhen we extend classes, we can provide class attributes with specific values by defining them in the object we pass as the `extend` parameter:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  className: 'bg-success',\n\n  template: '#template-identifier',\n\n  regions: {\n    myRegion: '.my-region'\n  },\n\n  modelEvents: {\n    change: 'removeBackground'\n  },\n\n  removeBackground() {\n    this.$el.removeClass('bg-success');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/k93pejyb/)\n\nWhen we instantiate `MyView`, each instance will be given a `.bg-success` class with a `myRegion` region created on the `.my-region` element.\n\n### Functions Returning Values\n\nIn almost every instance where we can set a value, we can also assign a function to figure out the value at runtime. In this case, Marionette will run the function on instantiation and use the returned value:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  className() {\n    return this.model.successful() ? 'bg-success' : 'bg-error';\n  },\n\n  template: '#template-identifier',\n\n  regions() {\n    return {\n      myRegion: '.my-region'\n    };\n  },\n\n  modelEvents() {\n    const wasSuccessful = this.model.successful();\n    return {\n      change: wasSuccessful ? 'removeBackground' : 'alert'\n    };\n  },\n\n  removeBackground() {\n    this.$el.removeClass('bg-success');\n  },\n\n  alert() {\n    console.log('model changed');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/nn1754fc/)\n\nAs we can see, almost all of the attributes here can be worked out dynamically. In most cases, Marionette will call the function once at instantiation, or first render, and preserve the value throughout the lifetime of the View. There are some exceptions to this rule - these will be referred to with their respective documentation.\n\n### Function Context\n\nWhen using functions to set attributes, Marionette will assign the instance of your new class as `this`. You can use this feature to ensure you're able to access your object in cases where `this` isn't what you might expect it to be.\n\n### Binding Attributes on Instantiation\n\nIn Marionette, most attributes can be bound on class instantiation in addition to being set when the [class is defined](#class-based-inheritance). You can use this to bind events, triggers, models, and collections at runtime:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: '#template-identifier'\n});\n\nconst myView = new MyView({\n  triggers: {\n    'click a': 'show:link'\n  }\n});\n```\n\nThis will set a trigger called `show:link` that will be fired whenever the user clicks an `<a>` inside the view.\n\nOptions set here will override options set on class definition. So, for example:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: '#template-identifier',\n\n  triggers: {\n    'click @ui.save': 'save:form'\n  }\n});\n\nconst myView = new MyView({\n  triggers: {\n    'click a': 'show:link'\n  }\n});\n```\n\nIn this example, the trigger for `save:form` will no longer be fired, as the trigger for `show:link` completely overrides it.\n\n## Setting Options\n\nMarionette can set options when you instantiate a class. This lets you override many class-based attributes when you need to. You can also pass new information specific to the object in question that it can access through special helper methods.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  checkOption() {\n    console.log(this.getOption('foo'));\n  }\n});\n\nconst view = new MyView({\n  foo: 'some text'\n});\n\nview.checkOption();  // prints 'some text'\n```\n\n[Live example](https://jsfiddle.net/marionettejs/6n02ex1m/)\n\n## Common Marionette Functionality\n\nMarionette has a few methods and core functionality that are common to [all classes](classes).\n\n[Continue Reading...](common).\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/basics.html](https://marionettejs.com/docs/v4.0.0/basics.html)"
- name: Common Functionality
  id: common
  summary: Marionette has a few methods that are common to all classes
  description: "# Common Marionette Functionality\n\nMarionette has a few methods that are common to [all classes](classes).\n\n## Documentation Index\n\n- [initialize](#initialize)\n- [extend](#extend)\n- [Events API](#events-api)\n- [triggerMethod](#triggermethod)\n- [bindEvents](#bindevents)\n- [unbindEvents](#unbindevents)\n- [bindRequests](#bindrequests)\n- [unbindRequests](#unbindrequests)\n- [normalizeMethods](#normalizemethods)\n- [getOption](#getoption)\n- [mergeOptions](#mergeoptions)\n- [The `options` Property](#the-options-property)\n\n### `initialize`\n\nLike the backbone classes, `initialize` is a method you can define on any Marionette class that will be called when the class is instantiated and will be passed any arguments passed at instantiation. The first argument may contain [options](#getoption) the class attaches to the instance.\n\n``` js\nimport { MnObject } from 'backbone.marionette';\n\nconst MyObject = MnObject.extend({\n  initialize(options, arg2) {\n    console.log(options.foo, this.getOption('foo'), arg2);\n  }\n});\n\nconst myObject = new MyObject({ foo: 'bar' }, 'baz'); // logs \"bar\" \"bar\" \"baz\"\n```\n\n[Live example](https://jsfiddle.net/marionettejs/1ytrwyog/)\n\n### `extend`\n\nBorrowed from backbone, `extend` is available on all class definitions for [class based inheritance](basics#class-based-inheritance)\n\n### Events API\n\nThe [Backbone.Events API](http://backbonejs.org/#Events) is available to all classes. Each Marionette class can both `listenTo` any object with this API and have events triggered on the instance.\n\n**Note** The events API should not be confused with [view `events`](https://marionettejs.com/.dom.interactions.html#view-events) which capture DOM events.\n\n### `triggerMethod`\n\nTrigger an event and [a corresponding method](events#onevent-binding) on the object. It is the same as `Backbone`'s [`trigger`](http://backbonejs.org/#Events-trigger) but with the additional method handler.\n\nWhen an event is triggered, the first letter of each section of the event name is capitalized, and the word \"on\" is prepended to the front of it. Examples:\n\n- `triggerMethod('foo')` fires the \"onFoo\" function\n- `triggerMethod('before:foo')` fires the \"onBeforeFoo\" function\n\nAll arguments that are passed to the `triggerMethod` call are passed along to both the event and the method, with the exception of the event name not being passed to the corresponding method.\n\n`triggerMethod('foo', bar)` will call `onFoo(bar){...})`\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\n\nconst MyObject = MnObject.extend({\n  initialize(){\n    this.triggerMethod('foo', 'baz');\n  },\n  onFoo(bar){\n    console.log(bar);\n  }\n});\n\nconst myObj = new MyObject(); // console.log \"baz\"\n\nmyObj.triggerMethod('foo', 'qux'); // console.log \"qux\"\n```\n\nMore information on `triggerMethod` can be found in the [Marionette events documentation](events#triggermethod).\n\n### `bindEvents`\n\nThis method is used to bind any object that works with the [`Backbone.Events` API](#events-api). This includes all Backbone classes, Marionette classes and [Radio](backbone.radio) channels.\n\n``` javascript\nimport Radio from 'backbone.radio';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  fooEvents: {\n    'change:foo': 'doSomething'\n  },\n  initialize(){\n    this.fooChannel = Radio.channel('foo');\n    this.bindEvents(this.fooChannel, this.fooEvents);\n  },\n  doSomething(){\n    // the \"change:foo\" event was fired from the radio channel\n    // respond to it appropriately, here.\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/L640ecac/)\n\nThe first parameter is the `entity` (Backbone.Model, Backbone.Collection or any object that has Backbone.Events mixed in) to bind the events from.\n\nThe second parameter is a hash of `{ 'event:name': 'eventHandler' }` configuration. A function can be supplied instead of a string handler name.\n\n**Errors** An error will be thrown if the second parameter is not an object.\n\n### `unbindEvents`\n\nThis method is used to unbind any object that works with the [`Backbone.Events` API](#events-api). This includes all Backbone classes, Marionette classes and [Radio](backbone.radio) channels.\n\nCalling this method without a events hash will unbind all events from the channel.\n\n``` javascript\nimport Radio from 'backbone.radio';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  fooEvents: {\n    'change:foo': 'onChangeFoo',\n    'stop': 'onStop'\n  },\n  initialize(){\n    this.fooChannel = Radio.channel('foo');\n    this.bindEvents(this.fooChannel, this.fooEvents);\n  },\n  onChangeFoo(){\n    // the \"change:foo\" event was fired from the radio channel\n    // respond to it appropriately, here.\n\n    // Doing something\n    this.listenTo(this.fooChannel, 'adhoc', this.render);\n  },\n  onStop() {\n    // Removes all fooEvents\n    this.unbindEvents(this.fooChannel, this.fooEvents);\n\n    // Removes all bound fooChannel events including `adhoc`\n    this.unbindEvents(this.fooChannel);\n  }\n});\n```\n\nThe first parameter is the `entity` (Backbone.Model, Backbone.Collection or any object that has Backbone.Events mixed in) to bind the events from.\n\nThe second parameter is a hash of `{ 'event:name': 'eventHandler' }` configuration. A function can be supplied instead of a string handler name. If the second paramater is not supplied, all listeners are removed.\n\n[Live example](https://jsfiddle.net/marionettejs/yvsfm65c/)\n\n### `bindRequests`\n\nThis method is used to bind any object that works with the [`Backbone.Radio` Request API](https://github.com/marionettejs/backbone.radio#backboneradiorequests). This includes [Radio](backbone.radio) channels.\n\n``` javascript\nimport Radio from 'backbone.radio';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  channelName: 'myChannelName',\n  radioRequests: {\n    'foo:bar': 'doFooBar'\n  },\n  initialize() {\n    const channel = Radio.channel(this.channelName);\n    this.bindRequests(channel, this.radioRequests);\n  },\n  doFooBar() {\n    console.log('foo:bar');\n    return 'bar';\n  }\n });\n\nconst myView = new MyView();\nconst channel = Radio.channel('myChannelName');\nchannel.request('foo:bar'); // Logs 'foo:bar' and returns 'bar'\n```\n\n[Live example](https://jsfiddle.net/marionettejs/hmjgkg7w/)\n\nThe first parameter, `channel`, is an instance from `Radio`.\n\nThe second parameter is a hash of `{ 'request:name': 'replyHandler' }` configuration. A function can be supplied instead of a string handler name.\n\n**Errors** An error will be thrown if the second parameter is not an object.\n\n### `unbindRequests`\n\nThis method is used to unbind any object that works with the [`Backbone.Radio` Request API](https://github.com/marionettejs/backbone.radio#backboneradiorequests).\n\nCalling this method without a radio requests hash will unbind all requests from the channel.\n\n**NOTE: To avoid memory leaks, `unbindRequests` should be called in or before `onBeforeDestroy`.**\n\n``` javascript\nimport Radio from 'backbone.radio';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  channelName: 'myChannelName',\n  radioRequests: {\n    'foo:bar': 'doFooBar'\n  },\n  onAttach() {\n    const channel = Radio.channel(this.channelName);\n    this.bindRequests(channel, this.radioRequests);\n  },\n  onBeforeDetach() {\n    const channel = Radio.channel(this.channelName);\n    this.unbindRequests(channel, this.radioRequests);\n  }\n });\n```\n\n[Live examples](https://jsfiddle.net/marionettejs/r5kmwwke/)\n\nThe first parameter, `channel`, is an instance from `Radio`.\n\nThe second parameter is a hash of `{ 'request:name': 'replyHandler' }` configuration. A function can be supplied instead of a string handler name. If the second paramater is not supplied, all handlers are removed.\n\n### `normalizeMethods`\n\nReceives a hash of event names and functions and/or function names, and returns the same hash with the function names replaced with the function references themselves.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  initialize() {\n    const hash = {\n      'action:one': 'handleActionOne', // This will become a reference to `this.handleActionOne`\n      'action:two': this.handleActionTwo\n    };\n\n    this.normalizedHash = this.normalizeMethods(hash);\n  },\n\n  do(action) {\n    this.normalizedHash[action]();\n  },\n\n  handleActionOne() {\n    console.log('action:one was fired');\n  },\n\n  handleActionTwo() {\n    console.log('action:two was fired');\n  }\n\n});\n\nconst myView = new MyView();\nmyView.do('action:one');\nmyView.do('action:two');\n```\n\n[Live example](https://jsfiddle.net/marionettejs/zzjhm4p1/)\n\n### `getOption`\n\nTo access an option, we use the `getOption` method. `getOption` will fall back to the value of the same name defined on the instance if not defined in the options.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst View = View.extend({\n  classVal: 'class value',\n  initialize(){\n    this.instanceVal = 'instance value'\n  }\n});\n\nconst view = new View({ optVal: 'option value' });\n\nview.getOption('instanceVal'); // instance value\nview.getOption('classVal'); // class value\nview.getOption('optVal'); // option value\n\nconst view2 = new View({ instanceVal: 'foo', classVal: 'bar', optVal: 'baz' });\n\nview.getOption('instanceVal'); // foo\nview.getOption('classVal'); // bar\nview.getOption('optVal'); // baz\n```\n\n[Live example](https://jsfiddle.net/marionettejs/ekvb8wwa/)\n\n#### Falsey values\n\nThe `getOption` function will return any falsey value from the `options`, other than `undefined`. If an object's options has an undefined value, it will attempt to read the value from the object directly.\n\nFor example:\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\n\nconst MyObject = MnObject.extend({\n  foo: 'bar',\n\n  initialize() {\n    console.log(this.getOption('foo'));\n  }\n});\n\nconst model1 = new MyObject(); // => \"bar\"\n\nconst myObj = {};\nconsole.log(myObj.foo); // undefined\nconst model2 = new MyObject({ foo: myObj.foo }); // => \"bar\"\n```\n\n[Live example](https://jsfiddle.net/marionettejs/2ddk28ap/)\n\nIn this example, \"bar\" is returned both times because the second example has an undefined value for `f`.\n\n### `mergeOptions`\n\nThe `mergeOptions` method takes two arguments: an `options` object and `keys` to pull from the options object. Any matching `keys` will be merged onto the class instance. For example:\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\n\nconst MyObject = MnObject.extend({\n  initialize(options) {\n    this.mergeOptions(options, ['model', 'something']);\n    // this.model and this.something will now be available\n  }\n});\n\nconst myObject = new MyObject({\n  model: new Backbone.Model(),\n  something: 'test',\n  another: 'value'\n});\n\nconsole.log(myObject.model);\nconsole.log(myObject.something);\nconsole.log(myObject.getOption('another'));\n```\n\n[Live example](https://jsfiddle.net/marionettejs/ub510cbx/)\n\nIn this example, `model` and `something` are directly available on the `MyObject` instance, while `another` must be accessed via `getOption`. This is handy when you want to add extra keys that will be used heavily throughout the defined class.\n\n### The `options` Property\n\nThe Marionette classes accept an `options` property in the class definition which is merged with the `options` argument passed at instantiation. The values from the passed in `options` overrides the property values.\n\n> The `options` argument passed in `initialize` method is equal to the passed at class instantiation. To get the option inside initialize considering the `options` property is necessary to use `getOption`\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\n\nconst MyObject = MnObject.extend({\n  options: {\n    foo: 'bar',\n    another: 'thing'\n  },\n\n  initialize(options) {\n    console.log(options.foo) // undefined\n    console.log(this.getOption('foo')) // 'bar'\n    console.log(this.getOption('another')) // 'value'\n  }\n});\n\nconst myObject = new MyObject({\n  another: 'value'\n});\n```\n\n## Marionette Classes\n\nMarionette provides a few classes for building your view tree and application structure.\n\n[Continue Reading...](classes).\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/common.html](https://marionettejs.com/docs/v4.0.0/common.html)"
- name: Common Functionality bindEvents
  id: common#bindevents
  summary: This method is used to bind any object that works with the Backbone.Events API
  belongs_to: Common Functionality
  description: |-
    ### `bindEvents`

    This method is used to bind any object that works with the [`Backbone.Events` API](#events-api). This includes all Backbone classes, Marionette classes and [Radio](backbone.radio) channels.

    ``` javascript
    import Radio from 'backbone.radio';
    import { View } from 'backbone.marionette';

    const MyView = View.extend({
      fooEvents: {
        'change:foo': 'doSomething'
      },
      initialize(){
        this.fooChannel = Radio.channel('foo');
        this.bindEvents(this.fooChannel, this.fooEvents);
      },
      doSomething(){
        // the "change:foo" event was fired from the radio channel
        // respond to it appropriately, here.
      }
    });
    ```

    [Live example](https://jsfiddle.net/marionettejs/L640ecac/)

    The first parameter is the `entity` (Backbone.Model, Backbone.Collection or any object that has Backbone.Events mixed in) to bind the events from.

    The second parameter is a hash of `{ 'event:name': 'eventHandler' }` configuration. A function can be supplied instead of a string handler name.

    **Errors** An error will be thrown if the second parameter is not an object.
- name: Common Functionality bindRequests
  id: common#bindrequests
  summary: This method is used to bind any object that works with the Backbone.Radio Request API
  belongs_to: Common Functionality
  description: |-
    ### `bindRequests`

    This method is used to bind any object that works with the [`Backbone.Radio` Request API](https://github.com/marionettejs/backbone.radio#backboneradiorequests). This includes [Radio](backbone.radio) channels.

    ``` javascript
    import Radio from 'backbone.radio';
    import { View } from 'backbone.marionette';

    const MyView = View.extend({
      channelName: 'myChannelName',
      radioRequests: {
        'foo:bar': 'doFooBar'
      },
      initialize() {
        const channel = Radio.channel(this.channelName);
        this.bindRequests(channel, this.radioRequests);
      },
      doFooBar() {
        console.log('foo:bar');
        return 'bar';
      }
     });

    const myView = new MyView();
    const channel = Radio.channel('myChannelName');
    channel.request('foo:bar'); // Logs 'foo:bar' and returns 'bar'
    ```

    [Live example](https://jsfiddle.net/marionettejs/hmjgkg7w/)

    The first parameter, `channel`, is an instance from `Radio`.

    The second parameter is a hash of `{ 'request:name': 'replyHandler' }` configuration. A function can be supplied instead of a string handler name.

    **Errors** An error will be thrown if the second parameter is not an object.
- name: Common Functionality extend
  id: common#extend
  summary: The Backbone.Events API is available to all classes
  belongs_to: Common Functionality
  description: |-
    ### `extend`

    Borrowed from backbone, `extend` is available on all class definitions for [class based inheritance](basics#class-based-inheritance)

    ### Events API

    The [Backbone.Events API](http://backbonejs.org/#Events) is available to all classes. Each Marionette class can both `listenTo` any object with this API and have events triggered on the instance.

    **Note** The events API should not be confused with [view `events`](https://marionettejs.com/.dom.interactions.html#view-events) which capture DOM events.
- name: Common Functionality getOption
  id: common#getoption
  summary: To access an option, we use the getOption method
  belongs_to: Common Functionality
  description: |-
    ### `getOption`

    To access an option, we use the `getOption` method. `getOption` will fall back to the value of the same name defined on the instance if not defined in the options.

    ``` javascript
    import { View } from 'backbone.marionette';

    const View = View.extend({
      classVal: 'class value',
      initialize(){
        this.instanceVal = 'instance value'
      }
    });

    const view = new View({ optVal: 'option value' });

    view.getOption('instanceVal'); // instance value
    view.getOption('classVal'); // class value
    view.getOption('optVal'); // option value

    const view2 = new View({ instanceVal: 'foo', classVal: 'bar', optVal: 'baz' });

    view.getOption('instanceVal'); // foo
    view.getOption('classVal'); // bar
    view.getOption('optVal'); // baz
    ```

    [Live example](https://jsfiddle.net/marionettejs/ekvb8wwa/)

    #### Falsey values

    The `getOption` function will return any falsey value from the `options`, other than `undefined`. If an object's options has an undefined value, it will attempt to read the value from the object directly.

    For example:

    ``` javascript
    import { MnObject } from 'backbone.marionette';

    const MyObject = MnObject.extend({
      foo: 'bar',

      initialize() {
        console.log(this.getOption('foo'));
      }
    });

    const model1 = new MyObject(); // => "bar"

    const myObj = {};
    console.log(myObj.foo); // undefined
    const model2 = new MyObject({ foo: myObj.foo }); // => "bar"
    ```

    [Live example](https://jsfiddle.net/marionettejs/2ddk28ap/)

    In this example, "bar" is returned both times because the second example has an undefined value for `f`.
- name: Common Functionality initialize
  id: common#initialize
  summary: Like the backbone classes, initialize is a method you can define on any Marionette class that will be called when the class is instantiated and will be passed any arguments passed at instantiation
  belongs_to: Common Functionality
  description: |-
    ### `initialize`

    Like the backbone classes, `initialize` is a method you can define on any Marionette class that will be called when the class is instantiated and will be passed any arguments passed at instantiation. The first argument may contain [options](#getoption) the class attaches to the instance.

    ``` js
    import { MnObject } from 'backbone.marionette';

    const MyObject = MnObject.extend({
      initialize(options, arg2) {
        console.log(options.foo, this.getOption('foo'), arg2);
      }
    });

    const myObject = new MyObject({ foo: 'bar' }, 'baz'); // logs "bar" "bar" "baz"
    ```

    [Live example](https://jsfiddle.net/marionettejs/1ytrwyog/)
- name: Common Functionality mergeOptions
  id: common#mergeoptions
  summary: 'The mergeOptions method takes two arguments: an options object and keys to pull from the options object'
  belongs_to: Common Functionality
  description: "### `mergeOptions`\n\nThe `mergeOptions` method takes two arguments: an `options` object and `keys` to pull from the options object. Any matching `keys` will be merged onto the class instance. For example:\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\n\nconst MyObject = MnObject.extend({\n  initialize(options) {\n    this.mergeOptions(options, ['model', 'something']);\n    // this.model and this.something will now be available\n  }\n});\n\nconst myObject = new MyObject({\n  model: new Backbone.Model(),\n  something: 'test',\n  another: 'value'\n});\n\nconsole.log(myObject.model);\nconsole.log(myObject.something);\nconsole.log(myObject.getOption('another'));\n```\n\n[Live example](https://jsfiddle.net/marionettejs/ub510cbx/)\n\nIn this example, `model` and `something` are directly available on the `MyObject` instance, while `another` must be accessed via `getOption`. This is handy when you want to add extra keys that will be used heavily throughout the defined class.\n\n### The `options` Property\n\nThe Marionette classes accept an `options` property in the class definition which is merged with the `options` argument passed at instantiation. The values from the passed in `options` overrides the property values.\n\n> The `options` argument passed in `initialize` method is equal to the passed at class instantiation. To get the option inside initialize considering the `options` property is necessary to use `getOption`\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\n\nconst MyObject = MnObject.extend({\n  options: {\n    foo: 'bar',\n    another: 'thing'\n  },\n\n  initialize(options) {\n    console.log(options.foo) // undefined\n    console.log(this.getOption('foo')) // 'bar'\n    console.log(this.getOption('another')) // 'value'\n  }\n});\n\nconst myObject = new MyObject({\n  another: 'value'\n});\n```\n\n## Marionette Classes\n\nMarionette provides a few classes for building your view tree and application structure.\n\n[Continue Reading...](classes).\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/common.html](https://marionettejs.com/docs/v4.0.0/common.html)"
- name: Common Functionality normalizeMethods
  id: common#normalizemethods
  summary: Receives a hash of event names and functions and/or function names, and returns the same hash with the function names replaced with the function references themselves
  belongs_to: Common Functionality
  description: |-
    ### `normalizeMethods`

    Receives a hash of event names and functions and/or function names, and returns the same hash with the function names replaced with the function references themselves.

    ``` javascript
    import { View } from 'backbone.marionette';

    const MyView = View.extend({
      initialize() {
        const hash = {
          'action:one': 'handleActionOne', // This will become a reference to `this.handleActionOne`
          'action:two': this.handleActionTwo
        };

        this.normalizedHash = this.normalizeMethods(hash);
      },

      do(action) {
        this.normalizedHash[action]();
      },

      handleActionOne() {
        console.log('action:one was fired');
      },

      handleActionTwo() {
        console.log('action:two was fired');
      }

    });

    const myView = new MyView();
    myView.do('action:one');
    myView.do('action:two');
    ```

    [Live example](https://jsfiddle.net/marionettejs/zzjhm4p1/)
- name: Common Functionality triggerMethod
  id: common#triggermethod
  summary: Trigger an event and a corresponding method on the object
  belongs_to: Common Functionality
  description: |-
    ### `triggerMethod`

    Trigger an event and [a corresponding method](events#onevent-binding) on the object. It is the same as `Backbone`'s [`trigger`](http://backbonejs.org/#Events-trigger) but with the additional method handler.

    When an event is triggered, the first letter of each section of the event name is capitalized, and the word "on" is prepended to the front of it. Examples:

    - `triggerMethod('foo')` fires the "onFoo" function
    - `triggerMethod('before:foo')` fires the "onBeforeFoo" function

    All arguments that are passed to the `triggerMethod` call are passed along to both the event and the method, with the exception of the event name not being passed to the corresponding method.

    `triggerMethod('foo', bar)` will call `onFoo(bar){...})`

    ``` javascript
    import { MnObject } from 'backbone.marionette';

    const MyObject = MnObject.extend({
      initialize(){
        this.triggerMethod('foo', 'baz');
      },
      onFoo(bar){
        console.log(bar);
      }
    });

    const myObj = new MyObject(); // console.log "baz"

    myObj.triggerMethod('foo', 'qux'); // console.log "qux"
    ```

    More information on `triggerMethod` can be found in the [Marionette events documentation](events#triggermethod).
- name: Common Functionality unbindEvents
  id: common#unbindevents
  summary: This method is used to unbind any object that works with the Backbone.Events API
  belongs_to: Common Functionality
  description: |-
    ### `unbindEvents`

    This method is used to unbind any object that works with the [`Backbone.Events` API](#events-api). This includes all Backbone classes, Marionette classes and [Radio](backbone.radio) channels.

    Calling this method without a events hash will unbind all events from the channel.

    ``` javascript
    import Radio from 'backbone.radio';
    import { View } from 'backbone.marionette';

    const MyView = View.extend({
      fooEvents: {
        'change:foo': 'onChangeFoo',
        'stop': 'onStop'
      },
      initialize(){
        this.fooChannel = Radio.channel('foo');
        this.bindEvents(this.fooChannel, this.fooEvents);
      },
      onChangeFoo(){
        // the "change:foo" event was fired from the radio channel
        // respond to it appropriately, here.

        // Doing something
        this.listenTo(this.fooChannel, 'adhoc', this.render);
      },
      onStop() {
        // Removes all fooEvents
        this.unbindEvents(this.fooChannel, this.fooEvents);

        // Removes all bound fooChannel events including `adhoc`
        this.unbindEvents(this.fooChannel);
      }
    });
    ```

    The first parameter is the `entity` (Backbone.Model, Backbone.Collection or any object that has Backbone.Events mixed in) to bind the events from.

    The second parameter is a hash of `{ 'event:name': 'eventHandler' }` configuration. A function can be supplied instead of a string handler name. If the second paramater is not supplied, all listeners are removed.

    [Live example](https://jsfiddle.net/marionettejs/yvsfm65c/)
- name: Common Functionality unbindRequests
  id: common#unbindrequests
  summary: This method is used to unbind any object that works with the Backbone.Radio Request API
  belongs_to: Common Functionality
  description: |-
    ### `unbindRequests`

    This method is used to unbind any object that works with the [`Backbone.Radio` Request API](https://github.com/marionettejs/backbone.radio#backboneradiorequests).

    Calling this method without a radio requests hash will unbind all requests from the channel.

    **NOTE: To avoid memory leaks, `unbindRequests` should be called in or before `onBeforeDestroy`.**

    ``` javascript
    import Radio from 'backbone.radio';
    import { View } from 'backbone.marionette';

    const MyView = View.extend({
      channelName: 'myChannelName',
      radioRequests: {
        'foo:bar': 'doFooBar'
      },
      onAttach() {
        const channel = Radio.channel(this.channelName);
        this.bindRequests(channel, this.radioRequests);
      },
      onBeforeDetach() {
        const channel = Radio.channel(this.channelName);
        this.unbindRequests(channel, this.radioRequests);
      }
     });
    ```

    [Live examples](https://jsfiddle.net/marionettejs/r5kmwwke/)

    The first parameter, `channel`, is an instance from `Radio`.

    The second parameter is a hash of `{ 'request:name': 'replyHandler' }` configuration. A function can be supplied instead of a string handler name. If the second paramater is not supplied, all handlers are removed.
- name: DOM Interactions
  id: dom.interactions
  summary: In addition to what Backbone provides the views, Marionette has additional API for DOM interactions available to all Marionette view classes
  description: "# DOM Interactions\n\nIn addition to what Backbone provides the views, Marionette has additional API for DOM interactions available to all Marionette [view classes](classes).\n\n### DOM Interactions in a Backbone.View\n\nMarionette's Views extend [`Backbone.View`](http://backbonejs.org/#View) and so have references to the view's `el`, `$el`, and `this.$()` as well as defining an `events` hash.\n\nThese methods provide ways for interacting with the view scoped to it's `el` *and* all of the view's children. To restate `events` and `this.$()` will query the view's template and all of the children. Marionette's added interfaces attempt to scope interactions with only the view's template, leaving the children to handle themselves.\n\n### Binding To User Input\n\nViews can bind custom events whenever users perform some interaction with the DOM. Using the view [`events`](#view-events) and [`triggers`](#view-triggers) handlers lets us either bind user input directly to an action or fire a generic trigger that may or may not be handled.\n\n#### Event and Trigger Mapping\n\nThe `events` and `triggers` attributes bind DOM events to actions to perform on the view. They each take a DOM event key and a mapping to the handler.\n\nWe'll cover a simple example:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  events: {\n    'drop': 'onDrop',\n    'click .btn-show-modal': 'onShowModal',\n    'click @ui.save': 'onSave'\n  },\n\n  triggers: {\n    'click @ui.close': 'close'\n  },\n\n  ui: {\n    save: '.btn-save',\n    close: '.btn-cancel'\n  },\n\n  onShowModal() {\n    console.log('Show the modal');\n  },\n\n  onSave() {\n    console.log('Save the form');\n  },\n\n  onDrop() {\n    console.log('Handle a drop event anywhere in the element');\n  }\n});\n```\n\nEvent listeners are constructed by:\n\n``` javascript\n'<dom event> [dom node]': 'listener'\n```\n\nThe `dom event` can be a jQuery DOM event - such as `click` - or another custom event, such as Bootstrap's `show.bs.modal`.\n\nThe `dom node` represents a jQuery selector or a `ui` key prefixed by `@.`. The `dom node` is optional, and if omitted, the view's `$el` will be used as the selector. For more information about the `ui` object, and how it works, see [the documentation on ui](#organizing-your-view).\n\n#### View `events`\n\nThe view `events` attribute binds DOM events to functions or methods on the view. The simplest form is to reference a method on the view:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  events: {\n    'click a': 'onShowModal'\n  },\n\n  onShowModal(event) {\n    console.log('Show the modal');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/jfxwtmxj/)\n\nThe DOM event gets passed in as the first argument, allowing you to see any information passed as part of the event.\n\n**When passing a method reference, the method must exist on the View.**\n\nThe `events` attribute can also directly bind functions:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  events: {\n    'click a'(event) {\n      console.log('Show the modal');\n    }\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/obt5vt09/)\n\nAs when passing a string reference to a view method, the `events` attribute passes in the `event` as the argument to the function called.\n\n**Note** Backbone `events` are delegated to the view's `el`. This means that events with a dom node selector will be handled for the view and any decendants. So if you attach a child with the same selector as the parent event handler, the parent will handle the event for both views.\n\n#### View `triggers`\n\nThe view `triggers` attribute binds DOM events to Marionette events that can be responded to at the view or parent level. For more information on events, see the [events documentation](events). This section will just cover how to bind these events to views.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  triggers: {\n    'click a': 'click:link'\n  },\n\n  onClickLink(view, event) {\n    console.log('Show the modal');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/exu2s3tL/)\n\nWhen the `a` tag is clicked here, the `link:click` event is fired. This event can be listened to using the [`onEvent` Binding](events#onevent-binding) technique discussed in the [events documentation](events).\n\nThe major benefit of the `triggers` attribute over `events` is that triggered events can bubble up to any parent views. For a full explanation of bubbling events and listening to child events, see the [event bubbling documentation](events#event-bubbling)..\n\n#### View `triggers` Event Object\n\nEvent handlers will receive the triggering view as the first argument and the DOM Event object as the second followed by any extra parameters triggered by the event.\n\n**NOTE** It is *strongly recommended* that View's handle their own DOM event objects. It should be considered a best practice to not utilize the DOM event in external listeners.\n\nBy default all trigger events are stopped with [`preventDefault`](features#triggerspreventdefault) and [`stopPropagation`](features#triggersstoppropagating) methods. This by nature artificially scopes event handling to the view's template preventing event handling of the same selectors in child views. However you can manually configurethe triggers using a hash instead of an event name. The example below triggers an event and prevents default browser behaviour using `preventDefault`.\n\n``` js\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  triggers: {\n    'click a': {\n      event: 'link:clicked',\n      preventDefault: true, // this param is optional and will default to true\n      stopPropagation: false\n    }\n  }\n});\n```\n\nThe default behavior for calling `preventDefault` can be changed with the feature flag [`triggersPreventDefault`](features#triggerspreventdefault), and `stopPropagation` can be changed with the feature flag [`triggersStopPropagation`](features#triggersstoppropagating).\n\n## Organizing Your View\n\nThe `View` provides a mechanism to name parts of your template to be used throughout the view with the `ui` attribute. This provides a number of benefits:\n\n1.  Provide a single defined reference to commonly used UI elements\n2.  Cache the jQuery selector\n3.  Query from only the view's template and not the children\n\n### Defining `ui`\n\nTo define your `ui` hash, just set an object of named jQuery selectors to the `ui` attribute of your View:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: MyTemplate,\n  ui: {\n    save: '#save-button',\n    close: '.close-button'\n  }\n});\n```\n\nInside your view, the `save` and `close` references will point to the jQuery selectors `#save-button` and `.close-button`respectively found only in the rendered `MyTemplate`.\n\n### Accessing UI Elements\n\nTo get the handles to your UI elements, use the `getUI(ui)` method:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: MyTemplate,\n  ui: {\n    save: '#save-button',\n    close: '.close-button'\n  },\n\n  onFooEvent() {\n    const $saveButton = this.getUI('save');\n    $saveButton.addClass('disabled');\n    $saveButton.attr('disabled', 'disabled');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/rpa58v0g/)\n\nAs `$saveButton` here is a jQuery selector, you can call any jQuery methods on it, according to the jQuery documentation.\n\n#### Referencing UI in `events` and `triggers`\n\nThe UI attribute is especially useful when setting handlers in the [`events`](#view-events) and [`triggers`](#view-triggers) objects - simply use the `@ui.` prefix:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: MyTemplate,\n  ui: {\n    save: '#save-button',\n    close: '.close-button'\n  },\n\n  events: {\n    'click @ui.save': 'onSave'\n  },\n\n  triggers: {\n    'click @ui.close': 'close'\n  },\n\n  onSave() {\n    this.model.save();\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/f2k0wu05/)\n\nIn this example, when the user clicks on `#save-button`, `onSave` will be called. If the user clicks on `.close-button`, then the event `close:view` will be fired on `MyView`.\n\nBy prefixing with `@ui`, we can change the underlying template without having to hunt through our view for every place where that selector is referenced - just update the `ui` object.\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/dom.interactions.html](https://marionettejs.com/docs/v4.0.0/dom.interactions.html)"
- name: Entity events
  id: events.entity
  summary: The View, CollectionView and Behavior can bind to events that occur on attached models and collections - this includes both standard backbone-events and custom events
  description: "# Entity events\n\nThe [`View`, `CollectionView` and `Behavior`](classes) can bind to events that occur on attached models and collections - this includes both [standard backbone-events](http://backbonejs.org/#Events-catalog) and custom events.\n\nEvent handlers are called with the same arguments as if listening to the entity directly and called with the context of the view instance.\n\n### Model Events\n\nFor example, to listen to a model's events:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  modelEvents: {\n    'change:attribute': 'onChangeAttribute'\n  },\n\n  onChangeAttribute(model, value) {\n    console.log('New value: ' + value);\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/auvk4hps/)\n\nThe `modelEvents` attribute passes through all the arguments that are passed to `model.trigger('event', arguments)`.\n\nThe `modelEvents` attribute can also take a [function returning an object](basics#functions-returning-values).\n\n#### Function Callback\n\nYou can also bind a function callback directly in the `modelEvents` attribute:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  modelEvents: {\n    'change:attribute': () {\n      console.log('attribute was changed');\n    }\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/zaxLe6au/)\n\n### Collection Events\n\nCollection events work exactly the same way as [`modelEvents`](#model-events) with their own `collectionEvents` key:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  collectionEvents: {\n    sync: 'onSync'\n  },\n\n  onSync(collection) {\n    console.log('Collection was synchronised with the server');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/7qyfeh9r/)\n\nThe `collectionEvents` attribute can also take a [function returning an object](basics#functions-returning-values).\n\nJust as in `modelEvents`, you can bind function callbacks directly inside the `collectionEvents` object:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  collectionEvents: {\n    'update'() {\n      console.log('the collection was updated');\n    }\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/ze8po0x5/)\n\n### Listening to Both\n\nIf your view has a `model` and `collection` attached, it will listen for events on both:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n\n  modelEvents: {\n    'change:someattribute': 'onChangeSomeattribute'\n  },\n\n  collectionEvents: {\n    'update': 'onCollectionUpdate'\n  },\n\n  onChangeSomeattribute() {\n    console.log('someattribute was changed');\n  },\n\n  onCollectionUpdate() {\n    console.log('models were added or removed in the collection');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/h9ub5hp3/)\n\nIn this case, Marionette will bind event handlers to both.\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/events.entity.html](https://marionettejs.com/docs/v4.0.0/events.entity.html)"
- name: Events
  id: events
  summary: The Marionette Event system provides a system for objects to communicate with each other in a uniform way
  description: "# Marionette Events\n\nThe Marionette Event system provides a system for objects to communicate with each other in a uniform way. In Marionette, this involves one object triggering an event that another listens to. This is an extended from of the [event handling system in Backbone](http://backbonejs.org/#Events), and is different than [DOM related events](dom.interactions#binding-to-user-input). It is mixed in to every [Marionette class](classes).\n\n## Documentation Index\n\n- [Triggering and Listening to Events](#triggering-and-listening-to-events)\n  - [`triggerMethod`](#triggermethod)\n  - [Listening to Events](#listening-to-events)\n    - [`onEvent` Binding](#onevent-binding)\n  - [View events and triggers](#view-events-and-triggers)\n  - [View entity events](#view-entity-events)\n- [Child View Events](#child-view-events)\n  - [Event Bubbling](#event-bubbling)\n    - [Using CollectionView](#using-collectionview)\n  - [A Child View's Event Prefix](#a-child-views-event-prefix)\n  - [Explicit Event Listeners](#explicit-event-listeners)\n    - [Attaching Functions](#attaching-functions)\n    - [Using `CollectionView`'s `childViewEvents`](#using-collectionviews-childviewevents)\n  - [Triggering Events on Child Events](#triggering-events-on-child-events)\n    - [Using `CollectionView`'s `childViewTriggers`](#using-collectionviews-childviewtriggers)\n- [Lifecycle Events](#lifecycle-events)\n\n## Triggering and Listening to Events\n\nThe traditional [event handling system in Backbone](http://backbonejs.org/#Events) is fully supported in Marionette. Marionette, however, provides an additional event API using the `triggerMethod` method - the key difference between the two is that `triggerMethod` automatically calls specially named event handlers.\n\n### `triggerMethod`\n\nJust like `Backbone`'s [`trigger`](http://backbonejs.org/#Events-trigger) the `triggerMethod` method fires the named event on the instance - any listeners will then be triggered on the event. If there are no listeners, this call will still succeed. All arguments after the first event name string will be passed to all event handlers.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  callMethod(myString) {\n    console.log(myString + ' was passed');\n  }\n});\n\nconst myView = new MyView();\n/* See Backbone.listenTo */\nmyView.on('something:happened', myView.callMethod);\n\n/* Calls callMethod('foo'); */\nmyView.triggerMethod('something:happened', 'foo');\n```\n\n[Live example](https://jsfiddle.net/marionettejs/whvgao7o/)\n\n**The `triggerMethod` method is available to [all Marionette classes](common#triggermethod).**\n\n### Listening to Events\n\nMarionette's event triggers work just like regular Backbone events - you can use `myView.on` and `myObject.listenTo` to act on events:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  initialize() {\n    this.on('event:happened', this.logCall);\n  },\n\n  logCall(myVal) {\n    console.log(myVal);\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/90Larbty/)\n\nYou can also use `listenTo` as in Backbone:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst OtherView = View.extend({\n  initialize(someView) {\n    this.listenTo(someView, 'event:happened', this.logCall);\n  },\n\n  logCall(myVal) {\n    console.log(myVal);\n  }\n});\n\nconst MyView = View.extend();\n\nconst myView = new MyView();\n\nconst otherView = new OtherView(myView);\n\nmyView.triggerMethod('event:happened', 'someValue'); // Logs 'someValue'\n```\n\n[Live examples](https://jsfiddle.net/marionettejs/cm2rczqz/)\n\nAs in [Backbone](http://backbonejs.org/#Events), `listenTo` will pass the object it is called on in as the context variable. These behave exactly as in Backbone, so using `object.on` will require you to unhook any event handlers yourself to prevent memory leaks. Marionette, however, does provide extra helpers as part of the view lifecycle that bind and unbind event handlers for you. this is the core of `onEvent` Binding.\n\n#### `onEvent` Binding\n\nThe major difference between `Backbone.trigger` and `triggerMethod` is that `triggerMethod` can fire specially named events on the instance. For example, a view that has been rendered will iternally fire `view.triggerMethod('render')` and call `onRender` - providing a handy way to add behavior to your views.\n\nDetermining what method an event will call is easy, we will outline this with an example using `before:dom:refresh` though this also works with any custom events you want to fire:\n\n1.  Split the words around the `:` characters - so `before`, `dom`, `refresh`\n2.  Capitalize the first letter of each word - `Before`, `Dom`, `Refresh`\n3.  Add a leading `on` - `on`, `Before`, `Dom`, `Refresh`\n4.  Mash it into a single call - `onBeforeDomRefresh`\n\nUsing this process, `before:dom:refresh` will call the `onBeforeDomRefresh` method. Let's see it in action with a custom event:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  onMyEvent(myVal) {\n    console.log(myVal);\n  }\n});\n\nconst myView = new MyView();\n\nmyView.triggerMethod('my:event', 'someValue'); // Logs 'someValue'\n```\n\n[Live example](https://jsfiddle.net/marionettejs/oc8wwcnx/)\n\nAs before, all arguments passed into `triggerMethod` after the event name will make their way into the event handler. Using this method ensures there will be no unexpected memory leaks.\n\n### View `events` and `triggers`\n\nViews can automatically bind DOM events to methods and View events with [`events`](dom.interactions#view-events) and [`triggers`](dom.interactions#view-triggers) respectively:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  events: {\n    'click a': 'showModal'\n  },\n\n  triggers: {\n    'keyup input': 'data:entered'\n  },\n\n  showModal(event) {\n    console.log('Show the modal');\n  },\n\n  onDataEntered(view, event) {\n    console.log('Data was entered');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/pq4xfchk/)\n\nFor more information, see the [DOM interactions documentation](dom.interactions#binding-to-user-input).\n\n### View entity events\n\nViews can automatically bind to its model or collection with [`modelEvents`](events.entity#model-events) and [`collectionEvents`](events.entity#collection-events) respectively.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  modelEvents: {\n    'change:someattribute': 'onChangeSomeattribute'\n  },\n\n  collectionEvents: {\n    'update': 'onCollectionUpdate'\n  },\n\n  onChangeSomeattribute() {\n    console.log('someattribute was changed');\n  },\n\n  onCollectionUpdate() {\n    console.log('models were added or removed in the collection');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/h9ub5hp3/)\n\nFor more information, see the [Entity events documentation](events.entity).\n\n## Child View Events\n\nThe [`View`](marionette.view) and [`CollectionView`](marionette.collectionview) are able to monitor and act on events on any of their direct children. Any events fired on a view are automatically propagated to their direct parents as well. Let's see a quick example:\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\nconst Item = View.extend({\n  tagName: 'li',\n\n  triggers: {\n    'click a': 'select:item'\n  }\n});\n\nconst Collection = CollectionView.extend({\n  tagName: 'ul',\n\n  childViewEvents: {\n    'select:item': 'itemSelected'\n  },\n\n  itemSelected(childView) {\n    console.log('item selected: ' + childView.model.id);\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/opyfvsfx/)\n\n### Event Bubbling\n\nEvents fired on a view bubble up to their direct parent views, calling any event methods using the `childview:` prefix (more on that shortly) and any methods bound to the `childViewEvents` attribute. This works for built-in events, custom events fired with `triggerMethod` and bound events using `triggers`.\n\n**NOTE** Automatic event bubbling can be disabled by setting [`childViewEventPrefix`](#a-child-views-event-prefix) to `false`.\n\nWhen using implicit listeners, the [`childview:*` event prefix](#a-child-views-event-prefix) is used which needs to be included as part of the handler:\n\n``` javascript\nimport { View, } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  triggers: {\n    click: 'click:view'\n  },\n\n  doSomething() {\n    this.triggerMethod('did:something', this);\n  }\n});\n\nconst ParentView = View.extend({\n  regions: {\n    foo: '.foo-hook'\n  },\n\n  onRender() {\n    this.showChildView('foo', new MyView());\n  },\n\n  onChildviewClickView(childView) {\n    console.log('View clicked ' + childView);\n  },\n\n  onChildviewDidSomething(childView) {\n    console.log('Something was done to ' + childView);\n  }\n})\n```\n\n**NOTE** `triggers` will automatically pass the child view as an argument to the parent view, however `triggerMethod` will not, and so notice that in the above example, the `triggerMethod` explicitly passes the child view.\n\n[Live example](https://jsfiddle.net/marionettejs/oquea4uy/)\n\n#### Using `CollectionView`\n\nThis works exactly the same way for the `CollectionView` and its `childView`:\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\nconst MyChild = View.extend({\n  triggers: {\n    click: 'click:child'\n  }\n});\n\nconst MyList = CollectionView.extend({\n  onChildviewClickChild(childView) {\n    console.log('Childview ' + childView + ' was clicked');\n  }\n});\n```\n\n[Live examples](https://jsfiddle.net/marionettejs/za27jys1/)\n\n### A Child View's Event Prefix\n\nYou can customize the event prefix for events that are forwarded through the view. To do this, set the `childViewEventPrefix` on the view or collectionview. For more information on the `childViewEventPrefix` see [Event bubbling](#event-bubbling).\n\nThe default value for `childViewEventPrefix` is `childview`. Setting this property to `false` will disable [automatic event bubbling](#event-bubbling).\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\nimport MyChildView from './my-child-view';\n\nconst myCollection = new Backbone.Collection([{}]);\n\nconst CollectionView = CollectionView.extend({\n  childViewEventPrefix: 'some:prefix',\n  childView: MyChildView\n});\n\nconst collectionView = new CollectionView({\n  collection: myCollection\n});\n\ncollectionView.on('some:prefix:render', function(){\n  // child view was rendered\n});\n\ncollectionView.render();\n```\n\n[Live example](https://jsfiddle.net/marionettejs/as33hnk1/)\n\nThe `childViewEventPrefix` can be provided in the view definition or in the constructor function call, to get a view instance.\n\n### Explicit Event Listeners\n\nTo call specific functions on event triggers, use the `childViewEvents` attribute to map child events to methods on the parent view. This takes events fired on child views - *without the `childview:` prefix* - and calls the method referenced or attached function.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  triggers: {\n    click: 'view:clicked'\n  }\n});\n\nconst ParentView = View.extend({\n  regions: {\n    foo: '.foo-hook'\n  },\n\n  childViewEvents: {\n    'view:clicked': 'displayMessage'\n  },\n\n  onRender() {\n    this.showChildView('foo', new MyView());\n  },\n\n  displayMessage(childView) {\n    console.log('Displaying message for ' + childView);\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/y92r99p2/)\n\n#### Attaching Functions\n\nThe `childViewEvents` attribute can also attach functions directly to be event handlers:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  triggers: {\n    click: 'view:clicked'\n  }\n});\n\nconst ParentView = View.extend({\n  regions: {\n    foo: '.foo-hook'\n  },\n\n  childViewEvents: {\n    'view:clicked'(childView) {\n      console.log('Function called for ' + childView);\n    }\n  },\n\n  onRender() {\n    this.showChildView('foo', new MyView());\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/pnp1dd8j/)\n\n#### Using `CollectionView`'s `childViewEvents`\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\n// childViewEvents can be specified as a hash...\nconst MyCollectionView = CollectionView.extend({\n  childViewEvents: {\n    // This callback will be called whenever a child is rendered or emits a `render` event\n    render() {\n      console.log('A child view has been rendered.');\n    }\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/a2uvcfrp/)\n\n### Triggering Events on Child Events\n\nA `childViewTriggers` hash or method permits proxying of child view events without manually setting bindings. The values of the hash should be a string of the event to trigger on the parent.\n\n`childViewTriggers` is sugar on top of [`childViewEvents`](#explicit-event-listeners) much in the same way that [view `triggers`](dom.interaction#view-triggers) are sugar for [view `events`](dom.interactions#view-events).\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\n// The child view fires a custom event, `show:message`\nconst ChildView = View.extend({\n\n  // Events hash defines local event handlers that in turn may call `triggerMethod`.\n  events: {\n    'click .button': 'onClickButton'\n  },\n\n  triggers: {\n    'submit form': 'submit:form'\n  },\n\n  onClickButton () {\n    // Both `trigger` and `triggerMethod` events will be caught by parent.\n    this.trigger('show:message', 'foo');\n    this.triggerMethod('show:message', 'bar');\n  }\n});\n\n// The parent uses childViewEvents to catch the child view's custom event\nconst ParentView = CollectionView.extend({\n  childView: ChildView,\n\n  childViewTriggers: {\n    'show:message': 'child:show:message',\n    'submit:form': 'child:submit:form'\n  },\n\n  onChildShowMessage (message) {\n    console.log('A child view fired show:message with ' + message);\n  },\n\n  onChildSubmitForm (childView) {\n    console.log('A child view fired submit:form');\n  }\n});\n\nconst GrandParentView = View.extend({\n  regions: {\n    list: '.list'\n  },\n\n  onRender() {\n    this.showChildView('list', new ParentView({\n      collection: this.collection\n    }));\n  },\n\n  childViewEvents: {\n    'child:show:message': 'showMessage'\n  },\n\n  showMessage(childView) {\n    console.log('A child (' + childView + ') fired an event');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/8eq7vca5/)\n\n#### Using `CollectionView`'s `childViewTriggers`\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\n// The child view fires a custom event, `show:message`\nconst ChildView = View.extend({\n\n  // Events hash defines local event handlers that in turn may call `triggerMethod`.\n  events: {\n    'click .button': 'onClickButton'\n  },\n\n  // Triggers hash converts DOM events directly to view events catchable on the parent.\n  // Note that `triggers` automatically pass the first argument as the child view.\n  triggers: {\n    'submit form': 'submit:form'\n  },\n\n  onClickButton () {\n    // Both `trigger` and `triggerMethod` events will be caught by parent.\n    this.trigger('show:message', 'foo');\n    this.triggerMethod('show:message', 'bar');\n  }\n});\n\n// The parent uses childViewEvents to catch the child view's custom event\nconst ParentView = CollectionView.extend({\n\n  childView: ChildView,\n\n  childViewTriggers: {\n    'show:message': 'child:show:message',\n    'submit:form': 'child:submit:form'\n  },\n\n  onChildShowMessage (message) {\n    console.log('A child view fired show:message with ' + message);\n  },\n\n  onChildSubmitForm (childView) {\n    console.log('A child view fired submit:form');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/edhqd2h8/)\n\n## Lifecycle Events\n\nMarionette Views fire events during their creation and destruction lifecycle. For more information see the documentation covering the [`View` Lifecycle](view.lifecycle).\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/events.html](https://marionettejs.com/docs/v4.0.0/events.html)"
- name: Events onEvent Binding
  id: events#onevent-binding
  summary: The Marionette Event system provides a system for objects to communicate with each other in a uniform way
  belongs_to: Events
  description: "# Marionette Events\n\nThe Marionette Event system provides a system for objects to communicate with each other in a uniform way. In Marionette, this involves one object triggering an event that another listens to. This is an extended from of the [event handling system in Backbone](http://backbonejs.org/#Events), and is different than [DOM related events](dom.interactions#binding-to-user-input). It is mixed in to every [Marionette class](classes).\n\n## Documentation Index\n\n- [Triggering and Listening to Events](#triggering-and-listening-to-events)\n  - [`triggerMethod`](#triggermethod)\n  - [Listening to Events](#listening-to-events)\n    - [`onEvent` Binding](#onevent-binding)\n  - [View events and triggers](#view-events-and-triggers)\n  - [View entity events](#view-entity-events)\n- [Child View Events](#child-view-events)\n  - [Event Bubbling](#event-bubbling)\n    - [Using CollectionView](#using-collectionview)\n  - [A Child View's Event Prefix](#a-child-views-event-prefix)\n  - [Explicit Event Listeners](#explicit-event-listeners)\n    - [Attaching Functions](#attaching-functions)\n    - [Using `CollectionView`'s `childViewEvents`](#using-collectionviews-childviewevents)\n  - [Triggering Events on Child Events](#triggering-events-on-child-events)\n    - [Using `CollectionView`'s `childViewTriggers`](#using-collectionviews-childviewtriggers)\n- [Lifecycle Events](#lifecycle-events)\n\n## Triggering and Listening to Events\n\nThe traditional [event handling system in Backbone](http://backbonejs.org/#Events) is fully supported in Marionette. Marionette, however, provides an additional event API using the `triggerMethod` method - the key difference between the two is that `triggerMethod` automatically calls specially named event handlers.\n\n### `triggerMethod`\n\nJust like `Backbone`'s [`trigger`](http://backbonejs.org/#Events-trigger) the `triggerMethod` method fires the named event on the instance - any listeners will then be triggered on the event. If there are no listeners, this call will still succeed. All arguments after the first event name string will be passed to all event handlers.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  callMethod(myString) {\n    console.log(myString + ' was passed');\n  }\n});\n\nconst myView = new MyView();\n/* See Backbone.listenTo */\nmyView.on('something:happened', myView.callMethod);\n\n/* Calls callMethod('foo'); */\nmyView.triggerMethod('something:happened', 'foo');\n```\n\n[Live example](https://jsfiddle.net/marionettejs/whvgao7o/)\n\n**The `triggerMethod` method is available to [all Marionette classes](common#triggermethod).**\n\n### Listening to Events\n\nMarionette's event triggers work just like regular Backbone events - you can use `myView.on` and `myObject.listenTo` to act on events:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  initialize() {\n    this.on('event:happened', this.logCall);\n  },\n\n  logCall(myVal) {\n    console.log(myVal);\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/90Larbty/)\n\nYou can also use `listenTo` as in Backbone:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst OtherView = View.extend({\n  initialize(someView) {\n    this.listenTo(someView, 'event:happened', this.logCall);\n  },\n\n  logCall(myVal) {\n    console.log(myVal);\n  }\n});\n\nconst MyView = View.extend();\n\nconst myView = new MyView();\n\nconst otherView = new OtherView(myView);\n\nmyView.triggerMethod('event:happened', 'someValue'); // Logs 'someValue'\n```\n\n[Live examples](https://jsfiddle.net/marionettejs/cm2rczqz/)\n\nAs in [Backbone](http://backbonejs.org/#Events), `listenTo` will pass the object it is called on in as the context variable. These behave exactly as in Backbone, so using `object.on` will require you to unhook any event handlers yourself to prevent memory leaks. Marionette, however, does provide extra helpers as part of the view lifecycle that bind and unbind event handlers for you. this is the core of `onEvent` Binding.\n\n#### `onEvent` Binding\n\nThe major difference between `Backbone.trigger` and `triggerMethod` is that `triggerMethod` can fire specially named events on the instance. For example, a view that has been rendered will iternally fire `view.triggerMethod('render')` and call `onRender` - providing a handy way to add behavior to your views.\n\nDetermining what method an event will call is easy, we will outline this with an example using `before:dom:refresh` though this also works with any custom events you want to fire:\n\n1.  Split the words around the `:` characters - so `before`, `dom`, `refresh`\n2.  Capitalize the first letter of each word - `Before`, `Dom`, `Refresh`\n3.  Add a leading `on` - `on`, `Before`, `Dom`, `Refresh`\n4.  Mash it into a single call - `onBeforeDomRefresh`\n\nUsing this process, `before:dom:refresh` will call the `onBeforeDomRefresh` method. Let's see it in action with a custom event:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  onMyEvent(myVal) {\n    console.log(myVal);\n  }\n});\n\nconst myView = new MyView();\n\nmyView.triggerMethod('my:event', 'someValue'); // Logs 'someValue'\n```\n\n[Live example](https://jsfiddle.net/marionettejs/oc8wwcnx/)\n\nAs before, all arguments passed into `triggerMethod` after the event name will make their way into the event handler. Using this method ensures there will be no unexpected memory leaks.\n\n### View `events` and `triggers`\n\nViews can automatically bind DOM events to methods and View events with [`events`](dom.interactions#view-events) and [`triggers`](dom.interactions#view-triggers) respectively:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  events: {\n    'click a': 'showModal'\n  },\n\n  triggers: {\n    'keyup input': 'data:entered'\n  },\n\n  showModal(event) {\n    console.log('Show the modal');\n  },\n\n  onDataEntered(view, event) {\n    console.log('Data was entered');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/pq4xfchk/)\n\nFor more information, see the [DOM interactions documentation](dom.interactions#binding-to-user-input).\n\n### View entity events\n\nViews can automatically bind to its model or collection with [`modelEvents`](events.entity#model-events) and [`collectionEvents`](events.entity#collection-events) respectively.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  modelEvents: {\n    'change:someattribute': 'onChangeSomeattribute'\n  },\n\n  collectionEvents: {\n    'update': 'onCollectionUpdate'\n  },\n\n  onChangeSomeattribute() {\n    console.log('someattribute was changed');\n  },\n\n  onCollectionUpdate() {\n    console.log('models were added or removed in the collection');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/h9ub5hp3/)\n\nFor more information, see the [Entity events documentation](events.entity).\n\n## Child View Events\n\nThe [`View`](marionette.view) and [`CollectionView`](marionette.collectionview) are able to monitor and act on events on any of their direct children. Any events fired on a view are automatically propagated to their direct parents as well. Let's see a quick example:\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\nconst Item = View.extend({\n  tagName: 'li',\n\n  triggers: {\n    'click a': 'select:item'\n  }\n});\n\nconst Collection = CollectionView.extend({\n  tagName: 'ul',\n\n  childViewEvents: {\n    'select:item': 'itemSelected'\n  },\n\n  itemSelected(childView) {\n    console.log('item selected: ' + childView.model.id);\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/opyfvsfx/)\n\n### Event Bubbling\n\nEvents fired on a view bubble up to their direct parent views, calling any event methods using the `childview:` prefix (more on that shortly) and any methods bound to the `childViewEvents` attribute. This works for built-in events, custom events fired with `triggerMethod` and bound events using `triggers`.\n\n**NOTE** Automatic event bubbling can be disabled by setting [`childViewEventPrefix`](#a-child-views-event-prefix) to `false`.\n\nWhen using implicit listeners, the [`childview:*` event prefix](#a-child-views-event-prefix) is used which needs to be included as part of the handler:\n\n``` javascript\nimport { View, } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  triggers: {\n    click: 'click:view'\n  },\n\n  doSomething() {\n    this.triggerMethod('did:something', this);\n  }\n});\n\nconst ParentView = View.extend({\n  regions: {\n    foo: '.foo-hook'\n  },\n\n  onRender() {\n    this.showChildView('foo', new MyView());\n  },\n\n  onChildviewClickView(childView) {\n    console.log('View clicked ' + childView);\n  },\n\n  onChildviewDidSomething(childView) {\n    console.log('Something was done to ' + childView);\n  }\n})\n```\n\n**NOTE** `triggers` will automatically pass the child view as an argument to the parent view, however `triggerMethod` will not, and so notice that in the above example, the `triggerMethod` explicitly passes the child view.\n\n[Live example](https://jsfiddle.net/marionettejs/oquea4uy/)\n\n#### Using `CollectionView`\n\nThis works exactly the same way for the `CollectionView` and its `childView`:\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\nconst MyChild = View.extend({\n  triggers: {\n    click: 'click:child'\n  }\n});\n\nconst MyList = CollectionView.extend({\n  onChildviewClickChild(childView) {\n    console.log('Childview ' + childView + ' was clicked');\n  }\n});\n```\n\n[Live examples](https://jsfiddle.net/marionettejs/za27jys1/)\n\n### A Child View's Event Prefix\n\nYou can customize the event prefix for events that are forwarded through the view. To do this, set the `childViewEventPrefix` on the view or collectionview. For more information on the `childViewEventPrefix` see [Event bubbling](#event-bubbling).\n\nThe default value for `childViewEventPrefix` is `childview`. Setting this property to `false` will disable [automatic event bubbling](#event-bubbling).\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\nimport MyChildView from './my-child-view';\n\nconst myCollection = new Backbone.Collection([{}]);\n\nconst CollectionView = CollectionView.extend({\n  childViewEventPrefix: 'some:prefix',\n  childView: MyChildView\n});\n\nconst collectionView = new CollectionView({\n  collection: myCollection\n});\n\ncollectionView.on('some:prefix:render', function(){\n  // child view was rendered\n});\n\ncollectionView.render();\n```\n\n[Live example](https://jsfiddle.net/marionettejs/as33hnk1/)\n\nThe `childViewEventPrefix` can be provided in the view definition or in the constructor function call, to get a view instance.\n\n### Explicit Event Listeners\n\nTo call specific functions on event triggers, use the `childViewEvents` attribute to map child events to methods on the parent view. This takes events fired on child views - *without the `childview:` prefix* - and calls the method referenced or attached function.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  triggers: {\n    click: 'view:clicked'\n  }\n});\n\nconst ParentView = View.extend({\n  regions: {\n    foo: '.foo-hook'\n  },\n\n  childViewEvents: {\n    'view:clicked': 'displayMessage'\n  },\n\n  onRender() {\n    this.showChildView('foo', new MyView());\n  },\n\n  displayMessage(childView) {\n    console.log('Displaying message for ' + childView);\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/y92r99p2/)\n\n#### Attaching Functions\n\nThe `childViewEvents` attribute can also attach functions directly to be event handlers:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  triggers: {\n    click: 'view:clicked'\n  }\n});\n\nconst ParentView = View.extend({\n  regions: {\n    foo: '.foo-hook'\n  },\n\n  childViewEvents: {\n    'view:clicked'(childView) {\n      console.log('Function called for ' + childView);\n    }\n  },\n\n  onRender() {\n    this.showChildView('foo', new MyView());\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/pnp1dd8j/)\n\n#### Using `CollectionView`'s `childViewEvents`\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\n// childViewEvents can be specified as a hash...\nconst MyCollectionView = CollectionView.extend({\n  childViewEvents: {\n    // This callback will be called whenever a child is rendered or emits a `render` event\n    render() {\n      console.log('A child view has been rendered.');\n    }\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/a2uvcfrp/)\n\n### Triggering Events on Child Events\n\nA `childViewTriggers` hash or method permits proxying of child view events without manually setting bindings. The values of the hash should be a string of the event to trigger on the parent.\n\n`childViewTriggers` is sugar on top of [`childViewEvents`](#explicit-event-listeners) much in the same way that [view `triggers`](dom.interaction#view-triggers) are sugar for [view `events`](dom.interactions#view-events).\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\n// The child view fires a custom event, `show:message`\nconst ChildView = View.extend({\n\n  // Events hash defines local event handlers that in turn may call `triggerMethod`.\n  events: {\n    'click .button': 'onClickButton'\n  },\n\n  triggers: {\n    'submit form': 'submit:form'\n  },\n\n  onClickButton () {\n    // Both `trigger` and `triggerMethod` events will be caught by parent.\n    this.trigger('show:message', 'foo');\n    this.triggerMethod('show:message', 'bar');\n  }\n});\n\n// The parent uses childViewEvents to catch the child view's custom event\nconst ParentView = CollectionView.extend({\n  childView: ChildView,\n\n  childViewTriggers: {\n    'show:message': 'child:show:message',\n    'submit:form': 'child:submit:form'\n  },\n\n  onChildShowMessage (message) {\n    console.log('A child view fired show:message with ' + message);\n  },\n\n  onChildSubmitForm (childView) {\n    console.log('A child view fired submit:form');\n  }\n});\n\nconst GrandParentView = View.extend({\n  regions: {\n    list: '.list'\n  },\n\n  onRender() {\n    this.showChildView('list', new ParentView({\n      collection: this.collection\n    }));\n  },\n\n  childViewEvents: {\n    'child:show:message': 'showMessage'\n  },\n\n  showMessage(childView) {\n    console.log('A child (' + childView + ') fired an event');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/8eq7vca5/)\n\n#### Using `CollectionView`'s `childViewTriggers`\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\n// The child view fires a custom event, `show:message`\nconst ChildView = View.extend({\n\n  // Events hash defines local event handlers that in turn may call `triggerMethod`.\n  events: {\n    'click .button': 'onClickButton'\n  },\n\n  // Triggers hash converts DOM events directly to view events catchable on the parent.\n  // Note that `triggers` automatically pass the first argument as the child view.\n  triggers: {\n    'submit form': 'submit:form'\n  },\n\n  onClickButton () {\n    // Both `trigger` and `triggerMethod` events will be caught by parent.\n    this.trigger('show:message', 'foo');\n    this.triggerMethod('show:message', 'bar');\n  }\n});\n\n// The parent uses childViewEvents to catch the child view's custom event\nconst ParentView = CollectionView.extend({\n\n  childView: ChildView,\n\n  childViewTriggers: {\n    'show:message': 'child:show:message',\n    'submit:form': 'child:submit:form'\n  },\n\n  onChildShowMessage (message) {\n    console.log('A child view fired show:message with ' + message);\n  },\n\n  onChildSubmitForm (childView) {\n    console.log('A child view fired submit:form');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/edhqd2h8/)\n\n## Lifecycle Events\n\nMarionette Views fire events during their creation and destruction lifecycle. For more information see the documentation covering the [`View` Lifecycle](view.lifecycle).\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/events.html](https://marionettejs.com/docs/v4.0.0/events.html)"
- name: Events triggerMethod
  id: events#triggermethod
  summary: Just like Backbone's trigger the triggerMethod method fires the named event on the instance - any listeners will then be triggered on the event
  belongs_to: Events
  description: "### `triggerMethod`\n\nJust like `Backbone`'s [`trigger`](http://backbonejs.org/#Events-trigger) the `triggerMethod` method fires the named event on the instance - any listeners will then be triggered on the event. If there are no listeners, this call will still succeed. All arguments after the first event name string will be passed to all event handlers.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  callMethod(myString) {\n    console.log(myString + ' was passed');\n  }\n});\n\nconst myView = new MyView();\n/* See Backbone.listenTo */\nmyView.on('something:happened', myView.callMethod);\n\n/* Calls callMethod('foo'); */\nmyView.triggerMethod('something:happened', 'foo');\n```\n\n[Live example](https://jsfiddle.net/marionettejs/whvgao7o/)\n\n**The `triggerMethod` method is available to [all Marionette classes](common#triggermethod).**\n\n### Listening to Events\n\nMarionette's event triggers work just like regular Backbone events - you can use `myView.on` and `myObject.listenTo` to act on events:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  initialize() {\n    this.on('event:happened', this.logCall);\n  },\n\n  logCall(myVal) {\n    console.log(myVal);\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/90Larbty/)\n\nYou can also use `listenTo` as in Backbone:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst OtherView = View.extend({\n  initialize(someView) {\n    this.listenTo(someView, 'event:happened', this.logCall);\n  },\n\n  logCall(myVal) {\n    console.log(myVal);\n  }\n});\n\nconst MyView = View.extend();\n\nconst myView = new MyView();\n\nconst otherView = new OtherView(myView);\n\nmyView.triggerMethod('event:happened', 'someValue'); // Logs 'someValue'\n```\n\n[Live examples](https://jsfiddle.net/marionettejs/cm2rczqz/)\n\nAs in [Backbone](http://backbonejs.org/#Events), `listenTo` will pass the object it is called on in as the context variable. These behave exactly as in Backbone, so using `object.on` will require you to unhook any event handlers yourself to prevent memory leaks. Marionette, however, does provide extra helpers as part of the view lifecycle that bind and unbind event handlers for you. this is the core of `onEvent` Binding.\n\n#### `onEvent` Binding\n\nThe major difference between `Backbone.trigger` and `triggerMethod` is that `triggerMethod` can fire specially named events on the instance. For example, a view that has been rendered will iternally fire `view.triggerMethod('render')` and call `onRender` - providing a handy way to add behavior to your views.\n\nDetermining what method an event will call is easy, we will outline this with an example using `before:dom:refresh` though this also works with any custom events you want to fire:\n\n1.  Split the words around the `:` characters - so `before`, `dom`, `refresh`\n2.  Capitalize the first letter of each word - `Before`, `Dom`, `Refresh`\n3.  Add a leading `on` - `on`, `Before`, `Dom`, `Refresh`\n4.  Mash it into a single call - `onBeforeDomRefresh`\n\nUsing this process, `before:dom:refresh` will call the `onBeforeDomRefresh` method. Let's see it in action with a custom event:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  onMyEvent(myVal) {\n    console.log(myVal);\n  }\n});\n\nconst myView = new MyView();\n\nmyView.triggerMethod('my:event', 'someValue'); // Logs 'someValue'\n```\n\n[Live example](https://jsfiddle.net/marionettejs/oc8wwcnx/)\n\nAs before, all arguments passed into `triggerMethod` after the event name will make their way into the event handler. Using this method ensures there will be no unexpected memory leaks.\n\n### View `events` and `triggers`\n\nViews can automatically bind DOM events to methods and View events with [`events`](dom.interactions#view-events) and [`triggers`](dom.interactions#view-triggers) respectively:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  events: {\n    'click a': 'showModal'\n  },\n\n  triggers: {\n    'keyup input': 'data:entered'\n  },\n\n  showModal(event) {\n    console.log('Show the modal');\n  },\n\n  onDataEntered(view, event) {\n    console.log('Data was entered');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/pq4xfchk/)\n\nFor more information, see the [DOM interactions documentation](dom.interactions#binding-to-user-input).\n\n### View entity events\n\nViews can automatically bind to its model or collection with [`modelEvents`](events.entity#model-events) and [`collectionEvents`](events.entity#collection-events) respectively.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  modelEvents: {\n    'change:someattribute': 'onChangeSomeattribute'\n  },\n\n  collectionEvents: {\n    'update': 'onCollectionUpdate'\n  },\n\n  onChangeSomeattribute() {\n    console.log('someattribute was changed');\n  },\n\n  onCollectionUpdate() {\n    console.log('models were added or removed in the collection');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/h9ub5hp3/)\n\nFor more information, see the [Entity events documentation](events.entity).\n\n## Child View Events\n\nThe [`View`](marionette.view) and [`CollectionView`](marionette.collectionview) are able to monitor and act on events on any of their direct children. Any events fired on a view are automatically propagated to their direct parents as well. Let's see a quick example:\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\nconst Item = View.extend({\n  tagName: 'li',\n\n  triggers: {\n    'click a': 'select:item'\n  }\n});\n\nconst Collection = CollectionView.extend({\n  tagName: 'ul',\n\n  childViewEvents: {\n    'select:item': 'itemSelected'\n  },\n\n  itemSelected(childView) {\n    console.log('item selected: ' + childView.model.id);\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/opyfvsfx/)\n\n### Event Bubbling\n\nEvents fired on a view bubble up to their direct parent views, calling any event methods using the `childview:` prefix (more on that shortly) and any methods bound to the `childViewEvents` attribute. This works for built-in events, custom events fired with `triggerMethod` and bound events using `triggers`.\n\n**NOTE** Automatic event bubbling can be disabled by setting [`childViewEventPrefix`](#a-child-views-event-prefix) to `false`.\n\nWhen using implicit listeners, the [`childview:*` event prefix](#a-child-views-event-prefix) is used which needs to be included as part of the handler:\n\n``` javascript\nimport { View, } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  triggers: {\n    click: 'click:view'\n  },\n\n  doSomething() {\n    this.triggerMethod('did:something', this);\n  }\n});\n\nconst ParentView = View.extend({\n  regions: {\n    foo: '.foo-hook'\n  },\n\n  onRender() {\n    this.showChildView('foo', new MyView());\n  },\n\n  onChildviewClickView(childView) {\n    console.log('View clicked ' + childView);\n  },\n\n  onChildviewDidSomething(childView) {\n    console.log('Something was done to ' + childView);\n  }\n})\n```\n\n**NOTE**`triggers` will automatically pass the child view as an argument to the parent view, however `triggerMethod` will not, and so notice that in the above example, the `triggerMethod` explicitly passes the child view.\n\n[Live example](https://jsfiddle.net/marionettejs/oquea4uy/)\n\n#### Using `CollectionView`\n\nThis works exactly the same way for the `CollectionView` and its `childView`:\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\nconst MyChild = View.extend({\n  triggers: {\n    click: 'click:child'\n  }\n});\n\nconst MyList = CollectionView.extend({\n  onChildviewClickChild(childView) {\n    console.log('Childview ' + childView + ' was clicked');\n  }\n});\n```\n\n[Live examples](https://jsfiddle.net/marionettejs/za27jys1/)\n\n### A Child View's Event Prefix\n\nYou can customize the event prefix for events that are forwarded through the view. To do this, set the `childViewEventPrefix` on the view or collectionview. For more information on the `childViewEventPrefix` see [Event bubbling](#event-bubbling).\n\nThe default value for `childViewEventPrefix` is `childview`. Setting this property to `false` will disable [automatic event bubbling](#event-bubbling).\n\n``` javascript\nimport Backbone from 'backbone';\nimport { CollectionView } from 'backbone.marionette';\nimport MyChildView from './my-child-view';\n\nconst myCollection = new Backbone.Collection([{}]);\n\nconst CollectionView = CollectionView.extend({\n  childViewEventPrefix: 'some:prefix',\n  childView: MyChildView\n});\n\nconst collectionView = new CollectionView({\n  collection: myCollection\n});\n\ncollectionView.on('some:prefix:render', function(){\n  // child view was rendered\n});\n\ncollectionView.render();\n```\n\n[Live example](https://jsfiddle.net/marionettejs/as33hnk1/)\n\nThe `childViewEventPrefix` can be provided in the view definition or in the constructor function call, to get a view instance.\n\n### Explicit Event Listeners\n\nTo call specific functions on event triggers, use the `childViewEvents` attribute to map child events to methods on the parent view. This takes events fired on child views - *without the `childview:` prefix* - and calls the method referenced or attached function.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  triggers: {\n    click: 'view:clicked'\n  }\n});\n\nconst ParentView = View.extend({\n  regions: {\n    foo: '.foo-hook'\n  },\n\n  childViewEvents: {\n    'view:clicked': 'displayMessage'\n  },\n\n  onRender() {\n    this.showChildView('foo', new MyView());\n  },\n\n  displayMessage(childView) {\n    console.log('Displaying message for ' + childView);\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/y92r99p2/)\n\n#### Attaching Functions\n\nThe `childViewEvents` attribute can also attach functions directly to be event handlers:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  triggers: {\n    click: 'view:clicked'\n  }\n});\n\nconst ParentView = View.extend({\n  regions: {\n    foo: '.foo-hook'\n  },\n\n  childViewEvents: {\n    'view:clicked'(childView) {\n      console.log('Function called for ' + childView);\n    }\n  },\n\n  onRender() {\n    this.showChildView('foo', new MyView());\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/pnp1dd8j/)\n\n#### Using `CollectionView`'s `childViewEvents`\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\n// childViewEvents can be specified as a hash...\nconst MyCollectionView = CollectionView.extend({\n  childViewEvents: {\n    // This callback will be called whenever a child is rendered or emits a `render` event\n    render() {\n      console.log('A child view has been rendered.');\n    }\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/a2uvcfrp/)\n\n### Triggering Events on Child Events\n\nA `childViewTriggers` hash or method permits proxying of child view events without manually setting bindings. The values of the hash should be a string of the event to trigger on the parent.\n\n`childViewTriggers` is sugar on top of [`childViewEvents`](#explicit-event-listeners) much in the same way that [view `triggers`](dom.interaction#view-triggers) are sugar for [view `events`](dom.interactions#view-events).\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\n// The child view fires a custom event, `show:message`\nconst ChildView = View.extend({\n\n  // Events hash defines local event handlers that in turn may call `triggerMethod`.\n  events: {\n    'click .button': 'onClickButton'\n  },\n\n  triggers: {\n    'submit form': 'submit:form'\n  },\n\n  onClickButton () {\n    // Both `trigger` and `triggerMethod` events will be caught by parent.\n    this.trigger('show:message', 'foo');\n    this.triggerMethod('show:message', 'bar');\n  }\n});\n\n// The parent uses childViewEvents to catch the child view's custom event\nconst ParentView = CollectionView.extend({\n  childView: ChildView,\n\n  childViewTriggers: {\n    'show:message': 'child:show:message',\n    'submit:form': 'child:submit:form'\n  },\n\n  onChildShowMessage (message) {\n    console.log('A child view fired show:message with ' + message);\n  },\n\n  onChildSubmitForm (childView) {\n    console.log('A child view fired submit:form');\n  }\n});\n\nconst GrandParentView = View.extend({\n  regions: {\n    list: '.list'\n  },\n\n  onRender() {\n    this.showChildView('list', new ParentView({\n      collection: this.collection\n    }));\n  },\n\n  childViewEvents: {\n    'child:show:message': 'showMessage'\n  },\n\n  showMessage(childView) {\n    console.log('A child (' + childView + ') fired an event');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/8eq7vca5/)\n\n#### Using `CollectionView`'s `childViewTriggers`\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\n// The child view fires a custom event, `show:message`\nconst ChildView = View.extend({\n\n  // Events hash defines local event handlers that in turn may call `triggerMethod`.\n  events: {\n    'click .button': 'onClickButton'\n  },\n\n  // Triggers hash converts DOM events directly to view events catchable on the parent.\n  // Note that `triggers` automatically pass the first argument as the child view.\n  triggers: {\n    'submit form': 'submit:form'\n  },\n\n  onClickButton () {\n    // Both `trigger` and `triggerMethod` events will be caught by parent.\n    this.trigger('show:message', 'foo');\n    this.triggerMethod('show:message', 'bar');\n  }\n});\n\n// The parent uses childViewEvents to catch the child view's custom event\nconst ParentView = CollectionView.extend({\n\n  childView: ChildView,\n\n  childViewTriggers: {\n    'show:message': 'child:show:message',\n    'submit:form': 'child:submit:form'\n  },\n\n  onChildShowMessage (message) {\n    console.log('A child view fired show:message with ' + message);\n  },\n\n  onChildSubmitForm (childView) {\n    console.log('A child view fired submit:form');\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/edhqd2h8/)\n\n## Lifecycle Events\n\nMarionette Views fire events during their creation and destruction lifecycle. For more information see the documentation covering the [`View` Lifecycle](view.lifecycle).\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/events.html](https://marionettejs.com/docs/v4.0.0/events.html)"
- name: Features
  id: features
  summary: Marionette Features are opt-in functionality that you can enable by utilizing setEnabled in your app
  description: "# Features\n\nMarionette Features are opt-in functionality that you can enable by utilizing [`setEnabled`](#setting-a-feature-flag) in your app. It is a good practice to set these flags only once prior to instantiating any Marionette class.\n\n## Documentation Index\n\n- [Goals](#goals)\n- [Checking a Feature Flag state](#checking-a-feature-flag-state)\n- [Setting a Feature Flag](#setting-a-feature-flag)\n- [Current Features](#current-features)\n\n## Goals:\n\n- make it possible to add breaking changes in a minor release\n- give community members a chance to provide feedback for new functionality\n\n## Checking a Feature Flag State\n\nUse `isEnabled` if you need to know the state of a feature flag programmatically.\n\n``` javascript\nimport { isEnabled } from 'backbone.marionette';\n\nisEnabled('fooFlag'); // false\n```\n\n## Setting a Feature Flag\n\nUse `setEnabled` to change the value of a flag. While setting a flag at any point may work, these flags are designed to be set before any functionality of Marionette is used. Change flags after at your own risk.\n\n``` javascript\nimport { setEnabled } from 'backbone.marionette';\n\nsetEnabled('fooFlag', true);\n\nconst myApp = new MyApp({\n  region: '#app-hook'\n});\n\nmyApp.start();\n```\n\n## Current Features\n\n### `childViewEventPrefix`\n\n*Default:* `false`\n\nThis flag indicates whether [`childViewEventPrefix`](events#a-child-views-event-prefix) for all views will return the default value of `'childview'` or if it will return `false` disabling [automatic event bubbling](events#event-bubbling).\n\n### `triggersPreventDefault`\n\n*Default:* `true`\n\nIt indicates the whether or not [`View.triggers` will call `event.preventDefault()`](dom.interactions#view-triggers-event-object) if not explicitly defined by the trigger. The default has been true, but for a future version [`false` is being considered](https://github.com/marionettejs/backbone.marionette/issues/2926).\n\n### `triggersStopPropagating`\n\n*Default:* `true`\n\nIt indicates the whether or not [`View.triggers` will call `event.stopPropagating()`](dom.interactions#view-triggers-event-object) if not explicitly defined by the trigger. The default has been true, but for a future version [`false` is being considered](https://github.com/marionettejs/backbone.marionette/issues/2926).\n\n### DEV_MODE\n\n*Default:* `false`\n\nIf `true`, deprecation console warnings are issued at runtime.\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/features.html](https://marionettejs.com/docs/v4.0.0/features.html)"
- name: Installing Marionette
  id: installation
  summary: As with all JavaScript libraries, there are a number of ways to get started with a Marionette application
  description: "# Installing Marionette\n\nAs with all JavaScript libraries, there are a number of ways to get started with a Marionette application. In this section we'll cover the most common ways. While some integrations are listed here, more resources are available in the integrations repo: [marionette-integrations](https://github.com/marionettejs/marionette-integrations)\n\n## Documentation Index\n\n- [NPM and Webpack](#quick-start-using-npm-and-webpack)\n- [NPM and Brunch](#quick-start-using-npm-and-brunch)\n- [NPM and Browserify](#quick-start-using-npm-and-browserify)\n- [Browserify and Grunt](#browserify-and-grunt)\n- [Browserify and Gulp](#browserify-and-gulp)\n- [Getting Started](basics)\n\n## Quick start using NPM and Webpack\n\n[NPM](https://www.npmjs.com/) is the package manager for JavaScript.\n\nInstalling with NPM through command-line interface\n\n    npm install backbone.marionette\n\n[Webpack](https://webpack.github.io/) is a build tool that makes it easy to pull your dependencies together into a single bundle to be delivered to your browser's `<script>` tag. It works particularly well with Marionette and jQuery.\n\n[Here](https://github.com/marionettejs/marionette-integrations/tree/master/webpack) we prepared simple marionettejs skeleton with Webpack.\n\n## Quick start using NPM and Brunch\n\n[Brunch](http://brunch.io/) is fast front-end web app build tool with simple declarative config, seamless incremental compilation for rapid development, an opinionated pipeline and workflow, and core support for source maps.\n\n[Here](https://github.com/marionettejs/marionette-integrations/tree/master/brunch) we prepared simple marionettejs skeleton with Brunch.\n\n## Quick start using NPM and Browserify\n\n[Browserify](http://browserify.org/) is a build tool that makes it easy to bundle NPM modules into your application, so you can `require` them as you would import dependencies in any other language.\n\n[Here](https://github.com/marionettejs/marionette-integrations/tree/master/browserify) we prepared simple marionettejs skeleton with Browserify.\n\n### Browserify and Grunt\n\n[Grunt](http://gruntjs.com/) is task runner. [Here](https://github.com/marionettejs/marionette-integrations/tree/master/browserify-grunt) is simple Browserify + Grunt skeleton.\n\n### Browserify and Gulp\n\n[Gulp](http://gulpjs.com/) is streaming build system. [Here](https://github.com/marionettejs/marionette-integrations/tree/master/browserify-gulp) is simple Browserify + Gulp skeleton.\n\n## Getting Started\n\nAfter installing Marionette you might want to check out the basics.\n\n[Continue Reading...](basics).\n\nAdditionally check out [features](features) for some configurable options.\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/installation.html](https://marionettejs.com/docs/v4.0.0/installation.html)"
- name: Marionette.Events and triggerMethod
  id: events.class#marionetteevents-and-triggermethod
  summary: Internally Marionette uses triggerMethod for event triggering
  belongs_to: Class Events
  description: "### `Marionette.Events` and `triggerMethod`\n\nInternally Marionette uses [`triggerMethod`](common#triggermethod) for event triggering. This API is not available to `Backbone.View`s so in order to support `Backbone.View`s in Marionette v4+, `Marionette.Events` must be mixed into the non-Marionette view.\n\nThis can be done for an individual view definition:\n\n``` javascript\nimport { Events } from 'backbone.marionette';\n\nconst MyBbView = Backbone.View.extend(Events);\n```\n\nor for all `Backbone.View`s\n\n``` javascript\n_.extend(Backbone.View.prototype, Events);\n```\n\n### Lifecycle Events\n\n#### `render` and `destroy`\n\nTo support non-Marionette Views, Marionette uses two flags to determine if it should trigger `render` and `destroy` events on the view. If a custom view throws it's own `render` or `destroy` events, the related flag should be set to `true` to avoid Marionette duplicating these events.\n\n``` javascript\n// Add support for triggerMethodimport { Events } from 'backbone.marionette';\n\n_.extend(Backbone.View.prototype, Events);\n\nconst MyCustomView = Backbone.View.extend({\n  supportsRenderLifecycle: true,\n  supportsDestroyLifecycle: true,\n  render() {\n    this.triggerMethod('before:render');\n\n    this.$el.html('render html');\n\n    // Since render is being triggered here set the\n    // supportsRenderLifecycle flag to true to avoid duplication\n    this.triggerMethod('render');\n  },\n  destroy() {\n    this.triggerMethod('before:destroy');\n\n    this.remove();\n\n    // Since destroy is being triggered here set the\n    // supportsDestroyLifecycle flag to true to avoid duplication\n    this.triggerMethod('destroy');\n  }\n});\n```\n\n#### DOM Change Lifecycle Events\n\nAs mentioned in [Advanced Event Settings](#advanced-event-settings) some DOM events are triggers from the view event monitor that will handle DOM attachment related events down the view tree. Backbone View's won't have the functionality unless the monitor is added. This will include all [DOM Change Events](#dom-change-events) other than render.\n\nYou can add the view events monitor to any non-Marionette view:\n\n``` javascript\nimport { monitorViewEvents, Events } from 'backbone.marionette';\n\n// Add support for triggerMethod\n_.extend(Backbone.View.prototype, Events);\n\nconst MyCustomView = Backbone.View.extend({\n  initialize() {\n    monitorViewEvents(this);\n    // Ideally this happens first prior to any rendering\n    // or attaching that might occur in the initialize\n  }\n});\n```\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/events.class.html](https://marionettejs.com/docs/v4.0.0/events.class.html)"
- name: MnObject
  id: marionette.mnobject
  summary: MnObject incorporates backbone conventions initialize, cid and extend
  description: "# Marionette.MnObject\n\n`MnObject` incorporates backbone conventions `initialize`, `cid` and `extend`. `MnObject` includes:\n\n- [Common Marionette Functionality](common)\n- [Class Events](events.class#mnobject-events)\n- [Radio API](backbone.radio#marionette-integration)\n\n## Documentation Index\n\n- [Instantiating a MnObject](#instantiating-a-mnobject)\n- [Unique Client ID](#unique-client-id)\n- [Destroying a MnObject](#destroying-a-mnobject)\n- [Basic Use](#basic-use)\n- [Backwards Compatibility](#backwards-compatibility)\n\n## Instantiating a MnObject\n\nWhen instantiating a `MnObject` there are several properties, if passed, that will be attached directly to the instance: `channelName`, `radioEvents`, `radioRequests`\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\n\nconst myObject = new MnObject({ ... });\n```\n\n## Unique Client ID\n\nThe `cid` or client id is a unique identifier automatically assigned to MnObjects when they're first created and by default is prefixed with `mno`. You can modify the prefix for `MnObject`s you `extend` by setting the `cidPrefix`.\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\n\nconst MyFoo = MnObject.extend({\n  cidPrefix: 'foo'\n});\n\nconst foo = new MyFoo();\n\nconsole.log(foo.cid); // foo1234\n```\n\n## Destroying a MnObject\n\n### `destroy`\n\nMnObjects have a `destroy` method that unbind the events that are directly attached to the instance. `destroy` returns the MnObject.\n\nInvoking the `destroy` method will trigger `before:destroy` and `destroy` events and their [corresponding methods](marionette.functions#marionettetriggermethod).\n\n**Note** The event handlers will pass the `options` argument `destroy` was invoked with.\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\n\n// define a mnobject with an onBeforeDestroy method\nconst MyObject = MnObject.extend({\n\n  onBeforeDestroy(options){\n    // put other custom clean-up code here\n  }\n});\n\n// create a new mnobject instance\nconst obj = new MyObject();\n\n// add some event handlers\nobj.on('before:destroy', function(options){ ... });\nobj.listenTo(something, 'bar', function(){...});\n\n// destroy the mnobject: unbind all of the\n// event handlers, trigger the \"destroy\" event and\n// call the onBeforeDestroy method\nobj.destroy({ foo: 'bar' });\n```\n\n### `isDestroyed`\n\nThis method will return a boolean indicating if the mnobject has been destroyed.\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\n\nconst obj = new MnObject();\nobj.isDestroyed(); // false\nobj.destroy();\nobj.isDestroyed(); // true\n```\n\n## Basic Use\n\nSelections is a simple MnObject that manages a selection of things. Because Selections extends from MnObject, it gets `initialize` and `Events` for free.\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\n\nconst Selections = MnObject.extend({\n\n  initialize(options){\n    this.selections = {};\n  },\n\n  select(key, item){\n    this.selections[key] = item;\n    this.triggerMethod('select', key, item);\n  },\n\n  deselect(key, item) {\n    delete this.selections[key];\n    this.triggerMethod('deselect', key, item);\n  }\n\n});\n\nconst selections = new Selections({\n  filters: Filters\n});\n\n// use the built in EventBinder\nselections.listenTo(selections, 'select', function(key, item){\n  console.log(item);\n});\n\nselections.select('toy', Truck);\n```\n\n## Backwards Compatibility\n\nIn versions previous to v4, `MnObject` was simply named `Object`. This naming is still supported via the default export of the library, but should be considered **deprecated** and is scheduled for removal in an upcoming version.\n\n``` javascript\nimport { MnObject } from 'backbone.marionette';\nimport Marionette from 'backbone.marionette';\n\nconsole.log(MnObject === Marionette.Object === Marionette.MnObject); // true\n```\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/marionette.mnobject.html](https://marionettejs.com/docs/v4.0.0/marionette.mnobject.html)"
- name: Prerendered Content
  id: dom.prerendered
  summary: View classes can be initialized with pre-rendered DOM
  description: "# Prerendered Content\n\n[View classes](classes) can be initialized with pre-rendered DOM.\n\nThis can be HTML that's currently in the DOM:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst myView = new View({ el: $('#foo-selector') });\n\nmyView.isRendered(); // true if '#foo-selector` exists and has content\nmyView.isAttached(); // true if '#foo-selector` is in the DOM\n```\n\nOr it can be DOM created in memory:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst $inMemoryHtml = $('<div>Hello World!</div>');\n\nconst myView = new View({ el: $inMemoryHtml });\n```\n\n[Live example](https://jsfiddle.net/marionettejs/b2yz38gj/)\n\nIn both of the cases at instantiation the view will determine [its state](view.lifecycle) as to whether the el is rendered or attached.\n\n**Note** `render` and `attach` events will not fire for the initial state as the state is set already at instantiation and is not changing.\n\n## Managing `View` children\n\nWith [`View`](marionette.view) in most cases the [`render` event](events.class#render-and-beforerender-events) is the best place to show child views [for best performance](marionette.view#efficient-nested-view-structures).\n\nHowever with pre-rendered DOM you may need to show child views in `initialize` as the view will already be rendered.\n\n``` javascript\nimport { View } from 'backbone.marionette';\nimport HeaderView from './header-view';\n\nconst MyBaseLayout = View.extend({\n  regions: {\n    header: '#header-region',\n    content: '#content-region'\n  },\n  el: $('#base-layout'),\n  initialize() {\n   this.showChildView('header', new HeaderView());\n  }\n});\n```\n\n### Managing a Pre-existing View Tree.\n\nIt may be the case that you need child views of already existing DOM as well. To set this up you'll need to query for `el`s down the tree:\n\n``` javascript\nimport { View } from 'backbone.marionette';\nimport HeaderView from './header-view';\n\nconst MyBaseLayout = View.extend({\n  regions: {\n    header: '#header-region',\n    content: '#content-region'\n  },\n  el: $('#base-layout'),\n  initialize() {\n    this.showChildView('header', new HeaderView({\n      el: this.getRegion('header').$el.contents()\n    }));\n  }\n});\n```\n\nThe same can be done with [`CollectionView`](marionette.collectionview):\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\nimport ItemView from './item-view';\n\nconst MyList = CollectionView.extend({\n  el: $('#base-table'),\n  childView: ItemView,\n  childViewContainer: 'tbody',\n  buildChildView(model, ChildView) {\n    const index = this.collection.indexOf(model);\n    const childEl = this.$('tbody').contents()[index];\n\n    return new ChildView({\n      model,\n      el: childEl\n    });\n  }\n});\n\nconst myList = new MyList({ collection: someCollection });\n\n// Unlike `View`, `CollectionView` should be rendered to build the `children`\nmyList.render();\n```\n\n<https://github.com/marionettejs/backbone.marionette/issues/3128>\n\n## Re-rendering children of a view with preexisting DOM.\n\nYou may be instantiating a `View` with existing HTML, but if you re-render the view, like any other view, your view will render the `template` into the view's `el` and any children will need to be re-shown.\n\nSo your view will need to be prepared to handle both scenarios.\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\nimport HeaderView from './header-view';\n\nconst MyBaseLayout = View.extend({\n  regions: {\n    header: '#header-region',\n    content: '#content-region'\n  },\n  el: $('#base-layout'),\n  initialize() {\n    this.showChildView('header', new HeaderView({\n      el: this.getRegion('header').$el.contents()\n    }));\n  },\n  template: _.template('<div id=\"header-region\"></div><div id=\"content-region\"></div>'),\n  onRender() {\n    this.showChildView('header', new HeaderView());\n  }\n});\n```\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/dom.prerendered.html](https://marionettejs.com/docs/v4.0.0/dom.prerendered.html)"
- name: Regions
  id: marionette.region
  summary: Regions provide consistent methods to manage, show and destroy views in your applications and views
  description: "# Regions\n\nRegions provide consistent methods to manage, show and destroy views in your applications and views.\n\n`Region` includes:\n\n- [Common Marionette Functionality](common)\n- [Class Events](events.class#region-events)\n- [The DOM API](dom.api)\n\nSee the documentation for [laying out views](marionette.view#laying-out-views---regions) for an introduction in managing regions throughout your application.\n\nRegions maintain the [View's lifecycle](view.lifecycle) while showing or emptying a view.\n\n## Documentation Index\n\n- [Instantiating a Region](#instantiating-a-region)\n- [Defining the Application Region](#defining-the-application-region)\n- [Defining Regions](#defining-regions)\n  - [String Selector](#string-selector)\n  - [Additional Options](#additional-options)\n  - [Specifying `regions` as a Function](#specifying-regions-as-a-function)\n  - [Using a RegionClass](#using-a-regionclass)\n  - [Referencing UI in `regions`](#referencing-ui-in-regions)\n- [Adding Regions](#adding-regions)\n- [Removing Regions](#removing-regions)\n- [Using Regions on a view](#using-regions-on-a-view)\n- [Showing a View](#showing-a-view)\n  - [Checking whether a region is showing a view](#checking-whether-a-region-is-showing-a-view)\n  - [Non-Marionette Views](#non-marionette-views)\n    - [Partially-rendered Views](#partially-rendered-views)\n- [Showing a Template](#showing-a-template)\n- [Emptying a Region](#emptying-a-region)\n  - [Preserving Existing Views](#preserving-existing-views)\n  - [Detaching Existing Views](#detaching-existing-views)\n- [`reset` A Region](#reset-a-region)\n- [`destroy` A Region](#destroy-a-region)\n- [Check If View Is Being Swapped By Another](#check-if-view-is-being-swapped-by-another)\n- [Set How View's `el` Is Attached](#set-how-views-el-is-attached)\n- [Configure How To Remove View](#configure-how-to-remove-view)\n\n## Instantiating a Region\n\nWhen instantiating a `Region` there are two properties, if passed, that will be attached directly to the instance: `el`, and `replaceElement`.\n\n``` javascript\nimport { Region } from 'backbone.marionette';\n\nconst myRegion = new Region({ ... });\n```\n\nWhile regions may be instantiated and useful on their own, their primary use case is through the [`Application`](#defining-the-application-region) and [`View`](#defining-regions) classes.\n\n## Defining the Application Region\n\nThe Application defines a single region `el` using the `region` attribute. This can be accessed through `getRegion()` or have a view displayed directly with `showView()`. Below is a short example:\n\n``` javascript\nimport { Application } from 'backbone.marionette';\nimport SomeView from './view';\n\nconst MyApp = Application.extend({\n  region: '#main-content',\n\n  onStart() {\n    const mainRegion = this.getRegion();  // Has all the properties of a `Region`\n    mainRegion.show(new SomeView());\n  }\n});\n```\n\n[Live example](http://jsfiddle.net/marionettejs/9fburmb8/)\n\nFor more information, see the [Application docs](marionette.application#application-region).\n\n## Defining Regions\n\nIn Marionette you can define a region with a string selector or an object literal on your `Application` or `View`. This section will document the two types as applied to `View`, although they will work for `Application` as well - just replace `regions` with `region` in your definition.\n\n**Errors** An error will be thrown for an incorrect region configuration.\n\n### String Selector\n\nYou can use a jQuery string selector to define regions.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  regions: {\n    mainRegion: '#main'\n  }\n});\n```\n\n### Additional Options\n\nYou can define regions with an object literal. Object literal definitions expect an `el` property - the selector string to hook the region into. With this format is possible to define whether showing the region overwrites the `el` or just overwrites the content (the default behavior).\n\nTo overwrite the parent `el` of the region with the rendered contents of the inner View, use `replaceElement` as so:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst OverWriteView = View.extend({\n  className: '.new-class'\n});\n\nconst MyView = View.extend({\n  regions: {\n    main: {\n      el: '.overwrite-me',\n      replaceElement: true\n    }\n  }\n});\nconst view = new MyView();\nview.render();\n\nconsole.log(view.$('.overwrite-me').length); // 1\nconsole.log(view.$('.new-class').length); // 0\n\nview.showChildView('main', new OverWriteView());\n\nconsole.log(view.$('.overwrite-me').length); // 0\nconsole.log(view.$('.new-class').length); // 1\n```\n\nWhen the instance of `MyView` is rendered, the `.overwrite-me` element will be removed from the DOM and replaced with an element of `.new-class` - this lets us do things like rendering views inside `table` or `select` more easily - these elements are usually very strict on what content they will allow.\n\n``` js\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  regions: {\n    regionDefinition: {\n      el: '.bar',\n      replaceElement: true\n    }\n  }\n});\n```\n\n**Errors** An error will be thrown in the regions `el` is not specified, or if the `el` does not exist in the html.\n\n### Specifying `regions` as a Function\n\nOn a `View` the `regions` attribute can also be a [function returning an object](basics#functions-returning-values):\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  regions(){\n    return {\n      firstRegion: '#first-region'\n    };\n  }\n});\n```\n\n### Using a RegionClass\n\nIf you've created a custom region class, you can use it to define your region.\n\n``` javascript\nimport { Application, Region, View } from 'backbone.marionette';\n\nconst MyRegion = Region.extend({\n  onShow(){\n    // Scroll to the middle\n    this.$el.scrollTop(this.currentView.$el.height() / 2 - this.$el.height() / 2);\n  }\n});\n\nconst MyApp = Application.extend({\n  regionClass: MyRegion,\n  region: '#first-region'\n})\n\nconst MyView = View.extend({\n  regionClass: MyRegion,\n  regions: {\n    firstRegion: {\n      el: '#first-region',\n      regionClass: Region // Don't scroll this to the top\n    },\n    secondRegion: '#second-region'\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/oLLrzx8g/)\n\n### Referencing UI in `regions`\n\nThe UI attribute can be useful when setting region selectors - simply use the `@ui.` prefix:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  ui: {\n    region: '#first-region'\n  },\n  regions: {\n    firstRegion: '@ui.region'\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/ey1od1g8/)\n\n## Adding Regions\n\nTo add regions to a view after it has been instantiated, simply use the `addRegion` method:\n\n``` javascript\nimport MyView from './myview';\n\nconst myView = new MyView();\nmyView.addRegion('thirdRegion', '#third-region');\n```\n\nNow we can access `thirdRegion` as we would the others.\n\nYou can also add multiple regions using `addRegions`.\n\n``` javascript\nimport MyView from './myview';\n\nconst myView = new MyView();\nmyView.addRegions({\n  main: {\n    el: '.overwrite-me',\n    replaceElement: true\n  },\n  sidebar: '.sidebar'\n});\n```\n\n[Live example](http://jsfiddle.net/marionettejs/kjvzdyd6/)\n\n## Removing Regions\n\nYou can remove all of the regions from a view by calling `removeRegions` or you can remove a region by name using `removeRegion`. When a region is removed the region will be destroyed.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  regions: {\n    main: '.main',\n    sidebar: '.sidebar',\n    header: '.header'\n  }\n});\n\nconst myView = new MyView();\n\n// remove only the main region\nconst mainRegion = myView.removeRegion('main');\n\nmainRegion.isDestroyed(); // -> true\n\n// remove all regions\nmyView.removeRegions();\n```\n\n## Using Regions on a view\n\nIn addition to adding and removing regions there are a few methods to help utilize regions. All of these methods will first render an unrendered view so that regions are properly initialized.\n\n- `getRegion(name)` - Request a region from a view by name.\n- `getRegions()` - Returns an object literal of all regions on the view organized by name.\n- `hasRegion(name)` - Check if a view has a region.\n- `emptyRegions()` - Empty all of the regions on a view.\n\n## Showing a View\n\nOnce a region is defined, you can call its `show` method to display the view:\n\n``` javascript\nconst myView = new MyView();\nconst childView = new MyChildView();\nconst mainRegion = myView.getRegion('main');\n\n// render and display the view\nmainRegion.show(childView, { fooOption: 'bar' });\n```\n\nThis is equivalent to a view's `showChildView` which can be used as:\n\n``` javascript\nconst myView = new MyView();\nconst childView = new MyChildView();\n\n// render and display the view\nmyView.showChildView('main', childView, { fooOption: 'bar' });\n```\n\nBoth forms take an `options` object that will be passed to the [events fired during `show`](events.class#show-and-beforeshow-events).\n\nFor more information on `showChildView` and `getChildView`, see the [Documentation for Views](marionette.view#managing-children)\n\n**Errors** An error will be thrown if the view is falsy or destroyed.\n\n### Checking whether a region is showing a view\n\nIf you wish to check whether a region has a view, you can use the `hasView` function. This will return a boolean value depending whether or not the region is showing a view.\n\n``` javascript\nconst myView = new MyView();\nconst mainRegion = myView.getRegion('main');\n\nmainRegion.hasView() // false\nmainRegion.show(new OtherView());\nmainRegion.hasView() // true\n```\n\nIf you show a view in a region with an existing view, Marionette will [remove the existing View](#emptying-a-region) before showing the new one.\n\n### Non-Marionette Views\n\nMarionette Regions aren't just for showing Marionette Views - they can also display instances of a [`Backbone.View`](http://backbonejs.org/#View). To do this, ensure your view defines a `render()` method and just treat it like a regular Marionette View:\n\n``` javascript\nimport _ from 'underscore';\nimport Bb from 'backbone';\nimport { View } from 'backbone.marionette';\n\nconst MyChildView = Bb.View.extend({\n  render() {\n    this.$el.append('<p>Some text</p>');\n  },\n\n  onRender() {\n    console.log('Regions also fire Lifecycle events on Backbone.View!');\n  }\n});\n\nconst MyParentView = View.extend({\n  regions: {\n    child: '.child-view'\n  },\n\n  template: _.template('<div class=\"child-view\"></div>'),\n\n  onRender() {\n    this.showChildView('child', new MyChildView());\n  }\n});\n```\n\nAs you can see above, you can listen to [Lifecycle Events](view.lifecycle) on `Backbone.View` and Marionette will fire the events for you.\n\n## Showing a Template\n\nYou can show a template or a string directly into a region. Additionally you can pass an object literal containing a template and any other view options. Under the hood a `Marionette.View` is instantiated using the template.\n\n``` javascript\nconst myView = new MyView();\n\nmyView.showChildView('main', {\n  template: _.template('This is the <%- section %> page'),\n  templateContext: { section: 'main' }\n});\n\nmyView.showChildView('header', _.template('Welcome to the site'));\n\nmyView.getRegion('other').show('This text is in another region');\n```\n\n## Emptying a Region\n\nYou can remove a view from a region (effectively \"unshowing\" it) with `region.empty()` on a region:\n\n``` javascript\nconst myView = new MyView();\n\nmyView.showChildView('main', new OtherView());\nconst mainRegion = myView.getRegion('main');\nmainRegion.empty();\n```\n\nThis will destroy the view, clean up any event handlers and remove it from the DOM. When a region is emptied [empty events are triggered](events.class#empty-and-beforeempty-events).\n\n**NOTE** If the region does *not* currently contain a View it will detach any HTML inside the region when emptying. If the region *does* contain a View [any HTML that doesn't belong to the View will remain](upgrade#changes-to-regionshow).\n\n### Preserving Existing Views\n\nIf you replace the current view with a new view by calling `show`, it will automatically destroy the previous view. You can prevent this behavior by [detaching the view](#detaching-existing-views) before showing another one.\n\n### Detaching Existing Views\n\nIf you want to detach an existing view from a region, use `detachView`.\n\n``` javascript\nconst myView = new MyView();\n\nconst myOtherView = new MyView();\n\nconst childView = new MyChildView();\n\n// render and display the view\nmyView.showChildView('main', childView);\n\n// ... somewhere down the line\nmyOtherView.showChildView('main', myView.getRegion('main').detachView());\n```\n\n**Note** When detaching a view you must pass it to a new region so Marionette can handle its life cycle automatically or `destroy` it manually to prevent memory leaks.\n\n## `reset` A Region\n\nA region can be `reset` at any time. This destroys any existing view being displayed, and deletes the cached `el`. The next time the region shows a view, the region's `el` is queried from the DOM.\n\n``` javascript\nconst myView = new MyView();\nmyView.showChildView('main', new OtherView());\nconst myRegion = myView.getRegion('main');\nmyRegion.reset();\n```\n\nThis can be useful in unit testing your views.\n\n## `destroy` A Region\n\nA region can be destroyed which will `reset` the region, remove it from any parent view, and stop any internal region listeners. A destroyed region should not be reused.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  regions: {\n    mainRegion: '#main'\n  }\n});\n\nconst myView = new MyView();\n\nconst myRegion = myView.getRegion('mainRegion');\n\nmyRegion.show(new ChildView());\n\nmyRegion.destroy();\n\nmyRegion.isDestroyed(); // true\nmyRegion.hasView(); // false\nmyView.hasRegion('mainRegion'); // false\n```\n\n## Check If View Is Being Swapped By Another\n\nThe `isSwappingView` method returns if a view is being swapped by another one. It's useful inside region lifecycle events / methods.\n\nThe example will show an message when the region is empty:\n\n``` javascript\nimport { Region } from 'backbone.marionette';\n\nconst EmptyMsgRegion = Region.extend({\n  onEmpty() {\n    if (!this.isSwappingView()) {\n      this.$el.append('Empty Region');\n    }\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/c1nacq0c/)\n\n## Set How View's `el` Is Attached and Detached\n\nOverride the region's `attachHtml` method to change how the view is attached to the DOM (when not using `replaceElement: true`. This method receives one parameter - the view to show.\n\nThe default implementation of `attachHtml` is essentially:\n\n``` javascript\nimport { Region } from 'backbone.marionette';\n\nRegion.prototype.attachHtml = function(view){\n  this.el.appendChild(view.el);\n}\n```\n\nSimilar to `attachHtml`, override `detachHtml` to determine how the region detaches the contents from its `el`. This method receives no parameters.\n\nFor most cases you will want to use the [DOM API](dom.api) to determine how a region html is attached, but in some cases you may want to override a single Region class for situations like animation where you want to control both attaching and [view removal](#configure-how-to-remove-view).\n\nThis example will make a view slide down from the top of the screen instead of just appearing in place:\n\n``` javascript\nimport { Region, View } from 'backbone.marionette';\n\nconst ModalRegion = Region.extend({\n  attachHtml(view){\n    // Some effect to show the view:\n    this.$el.empty().append(view.el);\n    this.$el.hide().slideDown('fast');\n  }\n});\n\nconst MyView = View.extend({\n  regions: {\n    mainRegion: '#main-region',\n    modalRegion: {\n      regionClass: ModalRegion,\n      el: '#modal-region'\n    }\n  }\n});\n```\n\n## Configure How To Remove View\n\nOverride the region's `removeView` method to change how and when the view is destroyed / removed from the DOM. This method receives one parameter - the view to remove.\n\nThe default implementation of `removeView` is:\n\n``` javascript\nimport { Region } from 'backbone.marionette';\n\nRegion.prototype.removeView = function(view){\n  this.destroyView(view);\n}\n```\n\n> `destroyView` method destroys the view taking into consideration if is a Marionette.View descendant or vanilla Backbone view. It can be replaced by a `view.destroy()` call if is ensured that view descends from Marionette.View\n\nThis example will animate with a fade effect showing and hiding the view:\n\n``` javascript\nimport { Region, View } from 'backbone.marionette';\n\nconst AnimatedRegion = Region.extend({\n  attachHtml(view) {\n    view.$el\n      .css({display: 'none'})\n      .appendTo(this.$el);\n    if (!this.isSwappingView()) view.$el.fadeIn('slow');\n  },\n\n  removeView(view) {\n    view.$el.fadeOut('slow', () => {\n      this.destroyView(view);\n      if (this.currentView) this.currentView.$el.fadeIn('slow');\n    });\n  }\n});\n\nconst MyView = View.extend({\n  regions: {\n    animatedRegion: {\n      regionClass: AnimatedRegion,\n      el: '#animated-region'\n    }\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/qtvjLu70/)\n\nUsing a similar approach is possible to create a region animated with CSS:\n\n[Live example](https://jsfiddle.net/marionettejs/8uoabg7c/)\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/marionette.region.html](https://marionettejs.com/docs/v4.0.0/marionette.region.html)"
- name: Regions destroy A Region
  id: marionette.region#destroy-a-region
  summary: A region can be destroyed which will reset the region, remove it from any parent view, and stop any internal region listeners
  belongs_to: Regions
  description: "## `destroy` A Region\n\nA region can be destroyed which will `reset` the region, remove it from any parent view, and stop any internal region listeners. A destroyed region should not be reused.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  regions: {\n    mainRegion: '#main'\n  }\n});\n\nconst myView = new MyView();\n\nconst myRegion = myView.getRegion('mainRegion');\n\nmyRegion.show(new ChildView());\n\nmyRegion.destroy();\n\nmyRegion.isDestroyed(); // true\nmyRegion.hasView(); // false\nmyView.hasRegion('mainRegion'); // false\n```\n\n## Check If View Is Being Swapped By Another\n\nThe `isSwappingView` method returns if a view is being swapped by another one. It's useful inside region lifecycle events / methods.\n\nThe example will show an message when the region is empty:\n\n``` javascript\nimport { Region } from 'backbone.marionette';\n\nconst EmptyMsgRegion = Region.extend({\n  onEmpty() {\n    if (!this.isSwappingView()) {\n      this.$el.append('Empty Region');\n    }\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/c1nacq0c/)\n\n## Set How View's `el` Is Attached and Detached\n\nOverride the region's `attachHtml` method to change how the view is attached to the DOM (when not using `replaceElement: true`. This method receives one parameter - the view to show.\n\nThe default implementation of `attachHtml` is essentially:\n\n``` javascript\nimport { Region } from 'backbone.marionette';\n\nRegion.prototype.attachHtml = function(view){\n  this.el.appendChild(view.el);\n}\n```\n\nSimilar to `attachHtml`, override `detachHtml` to determine how the region detaches the contents from its `el`. This method receives no parameters.\n\nFor most cases you will want to use the [DOM API](dom.api) to determine how a region html is attached, but in some cases you may want to override a single Region class for situations like animation where you want to control both attaching and [view removal](#configure-how-to-remove-view).\n\nThis example will make a view slide down from the top of the screen instead of just appearing in place:\n\n``` javascript\nimport { Region, View } from 'backbone.marionette';\n\nconst ModalRegion = Region.extend({\n  attachHtml(view){\n    // Some effect to show the view:\n    this.$el.empty().append(view.el);\n    this.$el.hide().slideDown('fast');\n  }\n});\n\nconst MyView = View.extend({\n  regions: {\n    mainRegion: '#main-region',\n    modalRegion: {\n      regionClass: ModalRegion,\n      el: '#modal-region'\n    }\n  }\n});\n```\n\n## Configure How To Remove View\n\nOverride the region's `removeView` method to change how and when the view is destroyed / removed from the DOM. This method receives one parameter - the view to remove.\n\nThe default implementation of `removeView` is:\n\n``` javascript\nimport { Region } from 'backbone.marionette';\n\nRegion.prototype.removeView = function(view){\n  this.destroyView(view);\n}\n```\n\n> `destroyView` method destroys the view taking into consideration if is a Marionette.View descendant or vanilla Backbone view. It can be replaced by a `view.destroy()` call if is ensured that view descends from Marionette.View\n\nThis example will animate with a fade effect showing and hiding the view:\n\n``` javascript\nimport { Region, View } from 'backbone.marionette';\n\nconst AnimatedRegion = Region.extend({\n  attachHtml(view) {\n    view.$el\n      .css({display: 'none'})\n      .appendTo(this.$el);\n    if (!this.isSwappingView()) view.$el.fadeIn('slow');\n  },\n\n  removeView(view) {\n    view.$el.fadeOut('slow', () => {\n      this.destroyView(view);\n      if (this.currentView) this.currentView.$el.fadeIn('slow');\n    });\n  }\n});\n\nconst MyView = View.extend({\n  regions: {\n    animatedRegion: {\n      regionClass: AnimatedRegion,\n      el: '#animated-region'\n    }\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/qtvjLu70/)\n\nUsing a similar approach is possible to create a region animated with CSS:\n\n[Live example](https://jsfiddle.net/marionettejs/8uoabg7c/)\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/marionette.region.html](https://marionettejs.com/docs/v4.0.0/marionette.region.html)"
- name: Regions reset A Region
  id: marionette.region#reset-a-region
  summary: A region can be reset at any time
  belongs_to: Regions
  description: |-
    ## `reset` A Region

    A region can be `reset` at any time. This destroys any existing view being displayed, and deletes the cached `el`. The next time the region shows a view, the region's `el` is queried from the DOM.

    ``` javascript
    const myView = new MyView();
    myView.showChildView('main', new OtherView());
    const myRegion = myView.getRegion('main');
    myRegion.reset();
    ```

    This can be useful in unit testing your views.
- name: Routing in Marionette
  id: routing
  summary: Users of versions of Marionette prior to v4 will notice that a router is no longer a bundled class
  description: "# Routing in Marionette\n\nUsers of versions of Marionette prior to v4 will notice that a router is no longer a [bundled class](classes). The [Marionette.AppRouter](https://github.com/marionettejs/marionette.approuter) was extracted and the core library will no longer hold an opinion on routing.\n\n## Some Routing Solutions\n\nBesides the router [bundled with Backbone](http://backbonejs.org/#Router) there are many viable routing solutions available. Some specifically designed for Backbone or Marionette and some that are generic solutions for any framework. Here are a few of those options.\n\n## Marionette Community Routers\n\n### [Marionette.AppRouter](https://github.com/marionettejs/marionette.approuter)\n\nPreviously bundled router. Extends [backbone.router](http://backbonejs.org/#Router) and is helpful for breaking a large amount of routes on a single backbone.router instance into smaller more managable approuters.\n\n### [Marionette.Routing](https://github.com/blikblum/marionette.routing)\n\nAn advanced router for MarionetteJS applications. Includes nested routes, states, rendering, async operations, lazy loading routes, Radio channel eventing, and inherits most of CherryTree features while maintaining a similar to Marionette API.\n\n### [Backbone.Eventrouter](https://github.com/RoundingWellOS/backbone.eventrouter)\n\nA highly opinionated, simplistic Backbone.Router coupled with a Backbone.Radio.Channel. When an event is triggered on the channel, it will set the route URL, or when a URL matches a route it will throw an event on the channel.\n\n## Generic Routers\n\n[Stateman](https://github.com/leeluolee/stateman) Angular-UI style routing, without the Angular\n\n[Cherrytree](https://github.com/QubitProducts/cherrytree) Nested routes, like Ember, but without the transition lifecycle.\n\n[router.js](https://github.com/tildeio/router.js) This is what Ember's router is built on top of. It has all of the features needed for good routing\n\n## Know of other routers that should be listed here?\n\n[Add them!](https://github.com/marionettejs/backbone.marionette/edit/next/docs/routing.html)\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/routing.html](https://marionettejs.com/docs/v4.0.0/routing.html)"
- name: The DOM API
  id: dom.api
  summary: With the release of Marionette 3.2, developers can remove the dependency on jQuery and integrate with the DOM using a custom api
  description: "# The DOM API\n\nWith the release of Marionette 3.2, developers can remove the dependency on jQuery and integrate with the DOM using a custom api.\n\n## API Methods\n\nThe DOM API manages the DOM on behalf of [each view class and `Region`](classes). It defines the methods that actually attach and remove views and children.\n\n[The default API](#the-default-api) depends on Backbone's jQuery `$` object however it does not rely on jQuery-specific behavior. This should make it easier to develop your own API. You will, however, [need to also handle Backbone's jQuery integration](#backbone-jquery-integration).\n\n### `createBuffer()`\n\nReturns a new HTML DOM node instance. The resulting node can be passed into the other DOM functions.\n\n### `getEl(selector)`\n\nLookup the `selector` string withing the DOM. The `selector` may also be a DOM element. It should return an array-like object of the node.\n\n### `findEl(el, selector)`\n\nLookup the `selector` string within the DOM node `el`. It should return an array-like object of nodes.\n\n### `hasEl(el, childEl)`\n\nReturns true if the el contains the node childEl\n\n### `detachEl(el)`\n\nDetach `el` from the DOM without removing listeners.\n\n### `replaceEl(newEl, oldEl)`\n\nRemove `oldEl` from the DOM and put `newEl` in its place.\n\n### `swapEl(el1, el2)`\n\nSwaps the location of `el1` and `el2` in the DOM. Both els must have a parentNode to be able to swap.\n\n### `setContents(el, html)`\n\nReplace the contents of `el` with the HTML string of `html`. Unlike other DOM functions, this only takes a literal string for its second argument.\n\n### `appendContents(el, contents)`\n\nTakes the DOM node `el` and appends the DOM node `contents` to the end of the element's contents.\n\n### `hasContents(el)`\n\nReturns a boolean indicating if the `el` has child nodes.\n\n### `detachContents(el)`\n\nRemove the inner contents of `el` from the DOM while leaving `el` itself in the DOM.\n\n## The default API\n\nThe API used by Marionette by default is attached as `Marionette.DomApi`. This is useful if you [change the API](#providing-your-own-dom-api) globally, but want to reuse the default in certain cases.\n\n``` javascript\nimport { setDomApi, DomApi } from 'backbone.marionette';\n\nimport MyDOMApi from './mydom';\n\nsetDomApi(MyDOMApi);\n\n// Use MyDOMApi everywhere but `Marionette.View`\nView.setDomApi(DomApi);\n```\n\n## Providing Your Own DOM API\n\nTo implement your own DOM API use `setDomApi`:\n\n``` javascript\nimport { setDomApi } from 'backbone.marionette';\nimport MyDOMApi from './mydom';\n\nsetDomApi(MyDOMApi);\n```\n\nYou can also implement a different DOM API for a particular class:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nView.setDomApi(MyDOMApi);\n```\n\n`CollectionView`, `Region`, and `View` all have `setDomApi`. Each extended class may have their own DOM API.\n\nAdditionally a DOM API can be partially set:\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend();\n\nMyView.setDomApi({\n  setContents(el, html) {\n    el.innerHTML = html;\n  }\n});\n```\n\n### Backbone jQuery Integration\n\nBackbone.js is tied to jQuery's API for managing DOM manipulation. If you want to completely remove jQuery from your Marionette app, you'll also have to provide your own versions of the following methods:\n\n- [`_setAttributes`](http://backbonejs.org/docs/backbone.html#section-170)\n- [`delegate`](http://backbonejs.org/docs/backbone.html#section-165)\n- [`undelegate`](http://backbonejs.org/docs/backbone.html#section-167)\n\n#### See Also\n\nThe DOM API takes care of the other DOM manipulation methods for you. The [Backbone Wiki](https://github.com/jashkenas/backbone/wiki/using-backbone-without-jquery) has a good reference for removing jQuery from the app, including Browserify and Webpack configuration hooks.\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/dom.api.html](https://marionettejs.com/docs/v4.0.0/dom.api.html)"
- name: Upgrade Guide
  id: upgrade-v2-v3
  summary: Marionette 3 introduces a number of breaking changes
  description: "# Upgrade Guide\n\nMarionette 3 introduces a number of breaking changes. This upgrade guide will go through the major changes and describe how to change your application to accommodate them.\n\nAn [upgrade tool](https://github.com/marionettejs/marionette-v3-compat) is available and covers the breaking changes in detail.\n\nWhere possible, we will document how to make the changes in Marionette 2.x so that your applications can continue to work and to ease the burden of upgrading to Marionette 3.\n\nYou can run Marionette 3 alongside Marionette 2 with the Marionette.noConflict() function.\n\n## Views\n\nThe most noticeable change to Marionette 3 is the consolidation of `ItemView` and `LayoutView` into `View`. In addition, `CompositeView` has been removed and its functionality merged into `CollectionView` and `View`.\n\n### Removing `LayoutView` and `ItemView`\n\nUsing separate `View` `LayoutView` and `ItemView` was complicating the API for Marionette needlessly. The new `View` replaces all of this and sets a clear recommendation for building layout trees.\n\n#### Upgrading for Marionette 2.x\n\nFor updating in Marionette 2.x, it is recommended you change all instances of `ItemView` to `LayoutView`.\n\n#### Upgrading to Marionette 3\n\nChange all instances of `LayoutView` and `ItemView` to `View`. Any views that previously extended `View` with a custom `render` should work relatively unchanged.\n\n### Removing `CompositeView`\n\nThe `CompositeView` was deprecated in favor of using `View` and `CollectionView`. The `CompositeView` will be completely removed in Marionette 4.\n\nSee [`CollectionView`](marionette.collectionview#rendering-collectionviews) for detail on upgrading to Marionette 3. This technique works in both Marionette 2.x and Marionette 3.\n\n### Removing `CollectionView.getChildView()`\n\nThe `getChildView` method has been removed in favor of the `childView` property, [which now accepts a function](basics#functions-returning-values).\n\n#### Upgrading to Marionette 3\n\nSimply replace all instances of `getChildView` with `childView`.\n\n### Removing `CollectionView.getEmptyView()`\n\nThe `getEmptyView` method has been removed in favor of the `emptyView` property, [which now accepts a function](basics#functions-returning-values).\n\n#### Upgrading to Marionette 3\n\nSimply replace all instances of `getEmptyView` with `emptyView`.\n\n### Child event handlers\n\nThe `childEvents` attribute was renamed to `childViewEvents`.\n\nChild event bubbling above one level is now removed in most instances and deprecated pending removal everywhere else. This can no longer be relied upon. To pass events further up the chain, you must explicitly using `childViewTriggers` to convert the event from the child into an event on the parent. These can be chained all the way up to the level you require them to be.\n\nBubbled child events no longer pass the `childView` implicitly and only pass the arguments passed as part of `triggerMethod`. This means that the arguments passed to `onEvent` and `onChildviewEvent` are now identical. See the [documentation on event lifecycles](view.lifecycle) for more information.\n\nIn Marionette 2, `childEvents` were bound on every event. In Marionette 3, `childViewEvents` are bound once and cached. This means that you cannot add new events after the view has been created.\n\n### View `triggers`\n\nThe view `triggers` attribute no longer passes an `options` attribute to event handlers, instead passing the view instance that triggered the event.\n\n## Events\n\nA number of lifecycle events were changed or removed from Marionette 3. Information on which ones were removed, changed, or added will be found here with recommendations on how to update your code.\n\n### `show` and `before:show`\n\nThe `show` events were removed completely as they were redundant and were being used incorrectly to show child regions. The `show` event was fired after the view had been attached, meaning the DOM was being constantly updated, leading to deteriorated performance.\n\n#### Upgrading for Marionette 2.x\n\nReplace all instances of `onShow`, `on('show')`, `onBeforeShow` and `on('before:show')` to use the `render` and `before:render` events. This is the recommendation for Marionette 3 and ensures the DOM tree is built in-memory before modifying the DOM.\n\n#### Upgrading to Marionette 3\n\nReplace all instances of `show` and `before:show` with `render` and `before:render`. If you want the view to be visible in the DOM, then listen to the `dom:refresh` event.\n\n### Changes to `region.show()`\n\nThe `region.show()` method (that also backs `showChildView()`) was changed to not remove HTML outside the `$el` of the displayed view. In Marionette 2, the `region.show()` method would call `region.$el.empty()` before showing the new HTML.\n\nIn Marionette 3, this was changed to unhook `region.currentView` from the DOM, remove all event handlers, then delete it. Any HTML added to the region that isn't contained in the DOM of the View won't be removed.\n\nFor example:\n\n``` javascript\nvar _ = require('underscore');\nvar Mn = require('backbone.marionette');\n\nvar app = require('./app');\n\nvar MyView = Mn.View.extend({\n  template: _.template('View contents')\n});\n\nvar ParentView = Mn.View.extend({\n  template: _.template('<div class=\"view-hook\"></div>'),\n  regions: {\n    child: '.view-hook'\n  }\n});\n\nvar parent = new ParentView();\napp.showView(parent);\n\nvar child = new MyView();\n\nparent.showChildView('child', child);\nparent.getRegion('child').$el.append('<p>Not removed</p>');\nparent.showChildView('child', new MyView());\n```\n\nIn Marionette 2, the HTML output will be:\n\n``` html\n<div class=\"view-hook\">\n  <div>View contents</div>\n</div>\n```\n\nIn Marionette 3, the HTML will be:\n\n``` html\n<div class=\"view-hook\">\n  <p>Not Removed</p>\n  <div>View contents</div>\n</div>\n```\n\n### Arguments for Lifecycle Events\n\nThe arguments for a number of lifecycle events were changed. For consistency, all events will now receive the view that is emitting the event as the first argument. See the [documentation for view lifecycles](view.lifecycle) for more complete information.\n\n#### Upgrading to Marionette 3\n\nThe following events, with their accompanying `before:` event were changed and may need to be updated:\n\n| Class            | Event                            |\n|------------------|----------------------------------|\n| `Object`         | `destroy`                        |\n| `Region`         | `show`                           |\n| `View`           | `add:region` and `remove:region` |\n| `CollectionView` | `add:child` and `remove:child`   |\n| `Application`    | `start`                          |\n\n## Templates\n\nThe biggest change to templates is renaming `templateHelpers` to `templateContext` - the aim is to be more in-line with terminology from other frameworks.\n\n### Upgrading to Marionette 3\n\nSimply replace all instances of `templateHelpers` with `templateContext`\n\n## Regions\n\nThere are a number of changes to how regions behave - the biggest change being the removal of the ability to access regions as attributes\n\n### Removing `view.region`\n\nThe `view.<region_name>` syntax has been removed in favor of `view.getRegion()`, `view.getChildView()` and `view.showChildView()`.\n\n#### Upgrading for Marionette 2.x\n\nChange all references to `view.region` to `view.getRegion('region')`. For example, in Mn 2.x and below:\n\n``` javascript\nvar AnotherView = require('./anotherview');\n\nvar MyView = Mn.LayoutView.extend({\n  regions: {\n    myregion: '.regionname'\n  },\n\n  onRender: function() {\n    this.myregion.show(new AnotherView());\n  }\n});\n```\n\nThis does not work in Mn 3 - instead do:\n\n``` javascript\nvar AnotherView = require('./anotherview');\n\n/* In Mn 2.x we can just use LayoutView */\nvar MyView = Mn.View.extend({\n  regions: {\n    myregion: '.regionname'\n  },\n\n  onRender: function() {\n    this.showChildView('myregion', new AnotherView());\n  }\n});\n```\n\nSee the documentation for [views](marionette.view#laying-out-views---regions) to learn more about how to manage regions in Marionette 3.\n\n## Modules\n\nMarionette Modules have been completely removed in favor of using the more standard JavaScript module loaders e.g. [Webpack](installation#quick-start-using-npm-and-webpack) or [Browserify](installation#quick-start-using-npm-and-browserify). See the [installation](installation) documentation for a list of potential options.\n\n## Backbone.Babysitter\n\nThe dependency on `Backbone.Babysitter` has been removed in favour of an in-built implementation that is maintained within the main Marionette codebase.\n\nBabySitter provides a simple way to manage child views in Backbone/Marionette or any object that manages lists of views. The external Babysitter library was used in Marionette to manage the `CollectionView` children.\n\n### Main Differences\n\nThe main difference between Babysitter and the Marionette implementation is the removal of `.call` and `.apply` on `CollectionView.children`. Instead you should use `.invoke` or [any of the methods provided](marionette.collectionview#collectionview-childview-iterators-and-collection-functions).\n\nFor example:\n\n``` javascript\nvar MyCollectionView = require('./views');\nvar MyCollection = require('./collections');\n\nvar collection = new MyCollection();\ncollection.fetch();\n\nvar myView = new MyCollectionView({collection: collection});\nmyView.children.invoke('render');\nmyView.children.map(function(view) {\n  view.doMethod();\n});\n```\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/upgrade-v2-v3.html](https://marionettejs.com/docs/v4.0.0/upgrade-v2-v3.html)"
- name: Upgrade Guide from v3 to v4
  id: upgrade-v3-v4
  summary: Marionette 4 introduces a number of breaking changes
  description: "# Upgrade Guide from v3 to v4\n\nMarionette 4 introduces a number of breaking changes. This upgrade guide will go through the major changes and describe how to change your application to accommodate them.\n\n## Required changes\n\nThese are breaking changes that need to be handled when migrating from Marionette v3 to v4\n\n#### CompositeView was removed\n\n- **Old behavior:** `CompositeView` class was provided\n- **New behavior:** `CompositeView` does not exists\n- **Reason:** API simplification\n- **Remedy:** Use `CollectionView` instead. Most features of `CompositeView` were added to `CollectionView` and in common cases a class rename is enough. The old `CompositeView` was abstracted to a [separate library](https://github.com/marionettejs/marionette.oldcollectionview).\n\nOne of the required changes is to explicitly define the `childView` when implementing a recursive (tree) view\n\n``` javascript\n   // with compositeview\n   const TreeView = CompositeView.extend({\n     template: 'node-template'\n   })\n\n   // with collectionview\n   const TreeView = CollectionView.extend({\n     template: 'node-template',\n     childView () {\n       return TreeView\n     }\n   })\n```\n\n#### NextCollectionView was renamed to CollectionView\n\n- **Old behavior:** Both `NextCollectionView` and `CollectionView` were provided\n- **New behavior:** Only `CollectionView`, based on `NextCollectionView` is provided. The old `CollectionView` implementation was removed\n- **Reason:** API simplification\n- **Remedy:** Use `CollectionView` instead. The old `CollectionView` was abstracted to a [separate library](https://github.com/marionettejs/marionette.oldcollectionview).\n\n#### `childViewEventPrefix` flag is set to false by default\n\n- **Old behavior:** `childViewEventPrefix` flag was set to true\n- **New behavior:** `childViewEventPrefix` flag was set to false\n- **Reason:** Performance Improvement\n- **Remedy:** It is recommended that child view events are proxied only when necessary. Rather than turning it on globally, set the `childViewEventPrefix` per view that needs it. Even better explictly define the proxies via `childViewEvents` and `childViewTriggers`.\n\n#### Marionette global instance is not attached to Backbone global instance\n\n- **Old behavior:** Marionette could be acessed using `Backbone.Marionette`\n- **New behavior:** Marionette is not attached to `Backbone` global instance\n- **Reason:** Support named exports\n- **Remedy:** Import Marionette classes directly or use global Marionette instance (when using as a standalone script)\n\n#### `noConflict` was removed\n\n- **Old behavior:** `noConflict` allowed for multiple installs of Marionette to be installed\n- **New behavior:** Marionette no longer handles conflicts internally.\n- **Reason:** Isn't useful with ES6\n- **Remedy:** Use package managers if multiple versions are needed.\n\n#### AppRouter was removed\n\n- **Old behavior:** Marionette included a router\n- **New behavior:** Marionette no longer includes a router\n- **Reason:** AppRouter was used by a minority of cases\n- **Remedy:** Use any router including the extract AppRouter <https://github.com/marionettejs/marionette.approuter>\n\n#### Renderer class was removed\n\n- **Old behavior:** The default renderer could be changed by setting `Renderer.render`\n- **New behavior:** `Renderer` does not exists\n- **Reason:** API simplification\n- **Remedy:** Use `Marionette.setRenderer` which accepts a function with same signature as expected by `Renderer.render`\n\n#### `TemplateCache` render removed\n\n- **Old behavior:** Rendered templates using the `TemplateCache`\n- **New behavior:** Renders templates directly `template(data);`\n- **Reason:** TemplateCache is only used by a minority of users.\n- **Remedy:** If needed use <https://github.com/marionettejs/marionette.templatecache>\n\n#### Behavior Lookup was removed\n\n- **Old behavior:** View behaviors could optionally be looked up via the global lookup naming scheme.\n\n- **New behavior:** Behavior definitions must be defined on the view.\n\n- **Reason:** Simplify API and no global Marionette instance\n\n- **Remedy:** Attach behaviors to view definitions. In v3\n\n  ``` javascript\n  const MyBehavior = Marionette.Behavior.extend({...});\n\n  Marionette.Behaviors.behaviorsLookup = function() {\n    return {\n      FooBehavior: MyBehavior\n    };\n  };\n\n  const V3View = Marionette.View.extend({\n    behaviors: {\n      FooBehavior: {}\n    }\n  });\n  ```\n\n  In v4\n\n  ``` javascript\n  const MyBehavior = Behavior.extend({...});\n\n  const V3View = View.extend({\n    behaviors: {\n      FooBehavior: MyBehavior\n    }\n  });\n  ```\n\n#### `attachElContent` not called unless the View renderer returns a value\n\n- **Old behavior:** `attachElContent` was always called\n- **New behavior:** `attachElContent` not called if the render doesn't return a value.\n- **Reason:** Useful for renderers that modify the content directly.\n- **Remedy:** Return at least an empty string if you need to have `attachElContent` called\n\n#### Support for vanilla Backbone.View has changed\n\n- **Old behavior:** `Backbone.View` instances were supported as is\n\n- **New behavior:** To support `Backbone.View` is necessary to apply `Marionette.Events` mixin\n\n- **Reason:** Improve performance\n\n- **Remedy:** If vanilla `Backbone.View` is not used there's no required change, otherwise, apply the `Marionette.Events` mixin`to the prototype of the view class intended to be used with`Marionette\\`. Example:\n\n  ``` javascript\n  // once, in the application start\n  import _ from 'underscore';\n  import {Events} from 'backbone.marionette';\n  _.extend(Backbone.View.prototype, Events);\n  ```\n\n#### `triggerMethodOn` was removed\n\n- **Old behavior:** This method was use to `triggerMethod` on an object that did not have the method\n- **New behavior:** Objects that need this functionality should mixin `Marionette.Events`\n- **Reason:** Improve performance\n- **Remedy:** Same as supporting a vanilla Backbone.View mentioned above\n\n#### Function isNodeAttached was removed\n\n- **Old behavior:** Utility function `isNodeAttached` was provided\n- **New behavior:** `isNodeAttached` does not exists\n- **Reason:** API simplification\n- **Remedy:** Use native code: `document.documentElement.contains(el)`\n\n#### View's `template: false` now no-ops the render\n\n- **Old behavior:** Template was not rendered, but render events were triggered\n- **New behavior:** No render events will occur\n- **Reason:** Prevents incorrect usage of `render`\n- **Remedy:** `template: false` was often used to generate render events when no render was performed. Use other hooks or methods when no template will be rendered.\n\n#### View.showChildView and Application.showView now return the shown view\n\n- **Old behavior:** These methods returned the region\n- **New behavior:** These methods now return the shown view\n- **Reason:** More useful return\n- **Remedy:** Use `getRegion` if the region is needed after this method\n\n#### View data serialization no longer clones the data\n\n- **Old behavior:** model attributes were always cloned prior to template rendering\n- **New behavior:** model attributes are no longer cloned\n- **Reason:** Improve performance\n- **Remedy:** Unlikely to be an issue but if no `templateContext` is defined templates can modify the actual model data if not careful. Clone if necessary.\n\n#### View `render` is no longer bound to the view\n\n- **Old behavior:** view.render was bound to the view\n- **New behavior:** view.render is no longer bound to the view\n- **Reason:** Improve performance\n- **Remedy:** In most all cases this won't matter but if you need to call the render function out of the context, use `call` or `apply`.\n\n#### Region no longer supports the `selector` property\n\n- **Old behavior:** The `selector` or `el` property could be used to set the region `el`.\n- **New behavior:** The `el` property can be used to set the `el`.\n- **Reason:** Simplify API\n- **Remedy:** Rename any `selector` used with Region to `el`.\n\n#### Region `preventDestroy` option was removed from `show` and `empty`\n\n- **Old behavior:** Option could be used to prevent destroying a leaving view\n- **New behavior:** Option is no longer available\n- **Reason:** Simplify API\n- **Remedy:** Use `detachView` first if you need to remove a shown view without destroying.\n\n#### Internally `_.bind` was replaced with `Function.prototype.bind`\n\n- **Old behavior:** `_.bind` was used\n- **New behavior:** `Function.prototype.bind` is used\n- **Reason:** Preparing for lodash 5\n- **Remedy:** This may affect anyone hoping to squeeze \\< IE9 support out of Marionette.\n\n#### `Application`, `Behavior`, and `Region` no longer extend `MnObject`\n\n- **Old behavior:** These classes extended `Mn.Object`.\n- **New behavior:** These classes no longer extend anything.\n- **Reason:** Shallow inheritance\n- **Remedy:** If modifying the `Object` prototype you may need to modify the others too.\n\n#### `destroy` functions only proxy a single argument\n\n- **Old behavior:** Any number of arguments passed to a `destroy` functions were passed along to events.\n- **New behavior:** Only one argument is passed\n- **Reason:** Performance Improvement\n- **Remedy:** If you need to pass multiple pieces of data through `destroy` use an object.\n\n#### `defaults` was removed from Behavior\n\n- **Old behavior:** Both `options` and `defaults` defined on Behavior are default options.\n- **New behavior:** Only `options` define the Behavior's default options\n- **Reason:** Simplify API\n- **Remedy:** Rename any use of `defaults` to `options`.\n\n#### View definition options will not be passed to the view `initialize`.\n\n- **Old behavior:** `options` defined on the view definition were merged into `options` and passed to the Backbone.View constructor\n- **New behavior:** Only `options` passed in at construction will be passed to the Backbone.View constructor.\n- **Reason:** Performance Improvement\n- **Remedy:** Define any default Backbone.View options on the view instance directly instead of in a nested `options` on the definition.\n\n#### `Error` utility was made private\n\n- **Old behavior:** The Marionette.Error class was publicly available.\n- **New behavior:** There is no accessible Error class.\n- **Reason:** Simplify API and maintenance\n\n#### `DEV_MODE` which shows deprecation warnings was made a feature flag.\n\n- **Old behavior:** `DEV_MODE` was set on the global `Marionette` object.\n- **New behavior:** Use `setEnabled` to set the `DEV_MODE` feature flag.\n- **Reason:** There is no longer a global `Marionette` object.\n\n## Recommended changes (deprecations)\n\nThese changes are optional, although recommended to make future upgrades easy\n\n#### The default export has been deprecated\n\n- **Old behavior:** The package was exported as an UMD module with all classes / functions as a property of the default export\n\n- **New behavior:** Package is exported as a ECMAScript module using named exports. The default export with all classes still\n\n- **Reason:** Align with current JS standard practice, allow tree shaking\n\n- **Remedy:** Import each Marionette classses / functions separatedly or with \\* keyword Examples: \\`\\`\\`javascript // using ES module syntax // old behavior import Mn from 'backbone.marionette'; const MyView = Mn.View.extend({});\n\n  // new behaviors // import only needed class/function import {View} from 'backbone.marionette'; const MyView = View.extend({});\n\n  // or import all (kills any chance of tree shaking) import \\* as Mn from 'backbone.marionette'; const MyView = Mn.View.extend({});\n\n  // or create a module that default exports all functions/classes // mymarionette.js -\\> can be configured as an alias for marionette or any other module name with webpack import \\* as Mn from 'backbone.marionette'; export default Mn;\n\n  // myview.js import Mn from './mymarionette'; const MyView = Mn.View.extend({});\n\n// using CommonJS syntax\n\n// old behavior const Mn = require('backbone.marionette'); const MyView = Mn.View.extend({});\n\n// new behavior const {View} = require('backbone.marionette'); const MyView = View.extend({});\n\n    #### `Marionette.Object` was renamed to `Marionette.MnObject`\n\n     * **Old behavior:** The Marionette Object class was exported as `Marionette.Object`\n     * **New behavior:** The Marionette Object class is exported as `MnObject`\n     * **Reason:** Avoid collision with native `Object` class when using with ES imports\n     * **Remedy:** Rename `Marionette.Object` to `MnObject`. To easy transition the Object will still be available on default Marionette export\n\n    ```javascript\n       // using ES module syntax\n       // old behavior\n       import Mn from 'backbone.marionette';\n       const MyObj = Mn.Object.extend({});\n\n       // new behaviors\n       // import only needed class/function\n       import {MnObject} from 'backbone.marionette';\n       const MyView = MnObject.extend({});\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/upgrade-v3-v4.html](https://marionettejs.com/docs/v4.0.0/upgrade-v3-v4.html)"
- name: Utility Functions
  id: utils
  summary: Marionette provides a set of utility / helper functions that are used to facilitate common behaviors throughout the framework
  description: "# Marionette Utility Functions\n\nMarionette provides a set of utility / helper functions that are used to facilitate common behaviors throughout the framework. These functions may be useful to those that are building on top of Marionette, as they provide a way to get the same behaviors and conventions from your own code.\n\n## Documentation Index\n\n- [extend](#extend)\n- [Common Method Utilities](#common-method-utilities)\n- [VERSION](#version)\n\n## extend\n\nBackbone's `extend` function is a useful utility to have, and is used in various places in Marionette. To make the use of this method more consistent, Backbone's `extend` has been exported `extend`. This allows you to get the extend functionality for your object without having to decide if you want to use Backbone.View or Backbone.Model or another Backbone object to grab the method from.\n\n``` javascript\nimport { extend } from 'backbone.marionette';\n\nconst Foo = function(){};\n\n// use Marionette.extend to make Foo extendable, just like other\n// Backbone and Marionette objects\nFoo.extend = extend;\n\n// Now Foo can be extended to create a new class, with methods\nconst Bar = Foo.extend({\n\n  someMethod(){ ... }\n\n  // ...\n});\n\n// Create an instance of Bar\nconst b = new Bar();\n```\n\n[Live example](https://jsfiddle.net/marionettejs/w5avq89r/)\n\n## Common Method Utilities\n\nThese [common utilities](common) are available to all Marionette classes and exported so that the functionality can be used elsewhere. Each method has the same arguments as documented in [common utilities](common) except that the target of the method is added as the first argument.\n\nFor instance:\n\n``` javascript\nimport { View, triggerMethod, getOption } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  initialize() {\n    this.triggerMethod('foo', this.getOption('foo'));\n  },\n  onFoo() {\n    console.log('bar');\n  }\n});\n\n// logs \"bar\"\nconst myView = new MyView({ foo: 'bar' });\n\n// Same as initialize, logs \"bar\"\ntriggerMethod(myView, 'foo', getOption(myView, 'foo'));\n```\n\n- [triggerMethod](common#triggermethod)\n  - Trigger an event and a corresponding method on the target object.\n- [bindEvents](common#bindevents)\n  - This method is used to bind a backbone \"entity\" to methods on a target object.\n- [unbindEvents](common#unbindevents)\n  - This method can be used to unbind callbacks from entities' events.\n- [bindRequests](common#bindrequests)\n  - This method is used to bind backbone radio replies to methods on a target object.\n- [unbindRequests](common#unbindrequests)\n  - This method can be used to unbind radio reply handler from entities' events.\n- [normalizeMethods](common#normalizemethods)\n  - Receives a hash of event names and functions and/or function names, and returns the same hash with the function names replaced with the function references themselves.\n- [getOption](common#getoption)\n  - Retrieve an object's attribute either directly from the object, or from the object's `this.options`.\n- [mergeOptions](common#mergeoptions)\n  - A handy function to pluck certain `options` and attach them directly to an instance.\n\n## VERSION\n\nMaintains a reference to the version of a Marionette instance. `VERSION` is used to direct users to the correctly versioned documentation when errors are thrown.\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/utils.html](https://marionettejs.com/docs/v4.0.0/utils.html)"
- name: Utility Functions extend
  id: utils#extend
  summary: Backbone's extend function is a useful utility to have, and is used in various places in Marionette
  belongs_to: Utility Functions
  description: "## extend\n\nBackbone's `extend` function is a useful utility to have, and is used in various places in Marionette. To make the use of this method more consistent, Backbone's `extend` has been exported `extend`. This allows you to get the extend functionality for your object without having to decide if you want to use Backbone.View or Backbone.Model or another Backbone object to grab the method from.\n\n``` javascript\nimport { extend } from 'backbone.marionette';\n\nconst Foo = function(){};\n\n// use Marionette.extend to make Foo extendable, just like other\n// Backbone and Marionette objects\nFoo.extend = extend;\n\n// Now Foo can be extended to create a new class, with methods\nconst Bar = Foo.extend({\n\n  someMethod(){ ... }\n\n  // ...\n});\n\n// Create an instance of Bar\nconst b = new Bar();\n```\n\n[Live example](https://jsfiddle.net/marionettejs/w5avq89r/)\n\n## Common Method Utilities\n\nThese [common utilities](common) are available to all Marionette classes and exported so that the functionality can be used elsewhere. Each method has the same arguments as documented in [common utilities](common) except that the target of the method is added as the first argument.\n\nFor instance:\n\n``` javascript\nimport { View, triggerMethod, getOption } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  initialize() {\n    this.triggerMethod('foo', this.getOption('foo'));\n  },\n  onFoo() {\n    console.log('bar');\n  }\n});\n\n// logs \"bar\"\nconst myView = new MyView({ foo: 'bar' });\n\n// Same as initialize, logs \"bar\"\ntriggerMethod(myView, 'foo', getOption(myView, 'foo'));\n```\n\n- [triggerMethod](common#triggermethod)\n  - Trigger an event and a corresponding method on the target object.\n- [bindEvents](common#bindevents)\n  - This method is used to bind a backbone \"entity\" to methods on a target object.\n- [unbindEvents](common#unbindevents)\n  - This method can be used to unbind callbacks from entities' events.\n- [bindRequests](common#bindrequests)\n  - This method is used to bind backbone radio replies to methods on a target object.\n- [unbindRequests](common#unbindrequests)\n  - This method can be used to unbind radio reply handler from entities' events.\n- [normalizeMethods](common#normalizemethods)\n  - Receives a hash of event names and functions and/or function names, and returns the same hash with the function names replaced with the function references themselves.\n- [getOption](common#getoption)\n  - Retrieve an object's attribute either directly from the object, or from the object's `this.options`.\n- [mergeOptions](common#mergeoptions)\n  - A handy function to pluck certain `options` and attach them directly to an instance.\n\n## VERSION\n\nMaintains a reference to the version of a Marionette instance. `VERSION` is used to direct users to the correctly versioned documentation when errors are thrown.\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/utils.html](https://marionettejs.com/docs/v4.0.0/utils.html)"
- name: View
  id: marionette.view
  summary: A View is used for managing portions of the DOM via a single parent DOM element or el
  description: "# Marionette.View\n\nA `View` is used for managing portions of the DOM via a single parent DOM element or `el`. It provides a consistent interface for managing the content of the `el` which is typically administered by serializing a `Backbone.Model` or `Backbone.Collection` and rendering a template with the serialized data into the `View`s `el`.\n\nThe `View` provides event delegation for capturing and handling DOM interactions as well as the ability to separate concerns into smaller, managed child views.\n\n`View` includes:\n\n- [The DOM API](dom.api)\n- [Class Events](events.class#view-events)\n- [DOM Interactions](dom.interactions)\n- [Child Event Bubbling](events#event-bubbling)\n- [Entity Events](events.entity)\n- [View Rendering](view.rendering)\n- [Prerendered Content](dom.prerendered)\n- [View Lifecycle](view.lifecycle)\n\nA `View` can have [`Region`s](marionette.region) and [`Behavior`s](marionette.behavior)\n\n## Documentation Index\n\n- [Instantiating a View](#instantiating-a-view)\n- [Rendering a View](#rendering-a-view)\n  - [Using a View Without a Template](#using-a-view-without-a-template)\n- [View Lifecycle and Events](#view-lifecycle-and-events)\n- [Entity Events](#entity-events)\n- [DOM Interactions](#dom-interactions)\n- [Behaviors](#behaviors)\n- [Managing Children](#managing-children)\n  - [Laying Out Views - Regions](#laying-out-views---regions)\n  - [Showing a Child View](#showing-a-child-view)\n  - [Attaching a Child View](#attaching-a-child-view)\n  - [Detaching a Child View](#detaching-a-child-view)\n  - [Destroying a Child View](#destroying-a-child-view)\n  - [Region Availability](#region-availability)\n- [Efficient Nested View Structures](#efficient-nested-view-structures)\n- [Listening to Events on Children](#listening-to-events-on-children)\n\n## Instantiating a View\n\nWhen instantiating a `View` there are several properties, if passed, that will be attached directly to the instance: `attributes`, `behaviors`, `childViewEventPrefix`, `childViewEvents`, `childViewTriggers`, `className`, `collection`, `collectionEvents`, `el`, `events`, `id`, `model`, `modelEvents`, `regionClass`, `regions`, `tagName`, `template`, `templateContext`, `triggers`, `ui`\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst myView = new View({ ... });\n```\n\nSome of these properties come from Marionette, but many are inherited from [`Backbone.View`](http://backbonejs.org/#View-constructor).\n\n## Rendering a View\n\nThe Marionette View implements a powerful render method which, given a [`template`](view.rendering#setting-a-view-template), will build your HTML from that template, mixing in `model` or `collection` data and any extra [template context](view.rendering#adding-context-data).\n\nUnlike `Backbone.View` Marionette defines `render` and this method should not be overridden. To add functionality to the render use the [`render` and `before:render` events](events.class#render-and-beforerender-events).\n\n[Live example](https://jsfiddle.net/marionettejs/dhsjcka4/)\n\nFor more detail on how to render templates, see [View Template Rendering](view.rendering).\n\n### Using a View Without a Template\n\nBy setting [`template` to `false`](view.rendering#using-a-view-without-a-template) you can entirely disable the view rendering and events. This may be useful for cases where you only need the `el` or have [`prerendered content`](dom.prerendered) that you do not intend to re-render.\n\n## View Lifecycle and Events\n\nAn instantiated `View` is aware of its lifecycle state and will throw events related to when that state changes.\n\nThe view states indicate whether the view is rendered, attached to the DOM, or destroyed.\n\nRead More:\n\n- [View Lifecycle](view.lifecycle)\n- [View DOM Change Events](events.class#dom-change-events)\n- [View Destroy Events](events.class#destroy-events)\n\n## Entity Events\n\nThe `View` can bind to events that occur on the attached `model` and `collection` - this includes both [standard backbone-events](http://backbonejs.org/#Events-catalog) and custom events.\n\nRead More:\n\n- [Entity Events](events.entity)\n\n## DOM Interactions\n\nIn addition to what Backbone provides the views, Marionette has additional API for DOM interactions: `events`, `triggers`, and `ui`.\n\nRead More:\n\n- [DOM Interactions](dom.interactions)\n\n## Behaviors\n\nA `Behavior` provides a clean separation of concerns to your view logic, allowing you to share common user-facing operations between your views.\n\nRead More:\n\n- [Using `Behavior`s](marionette.behavior#using-behaviors)\n\n## Managing Children\n\n`View` provides a simple interface for managing child-views with [`showChildView`](#showing-a-child-view), [`getChildView`](#accessing-a-child-view), and [`detachChildView`](#detaching-a-child-view). These methods all access `regions` within the view. We will cover this here but for more advanced information, see the [documentation for regions](marionette.region).\n\n### Laying Out Views - Regions\n\nThe `Marionette.View` class lets us manage a hierarchy of views using `regions`. Regions are a hook point that lets us show views inside views, manage the show/hide lifecycles, and act on events inside the children.\n\n**This Section only covers the basics. For more information on regions, see the [Regions Documentation.](marionette.region)**\n\nRegions are ideal for rendering application layouts by isolating concerns inside another view. This is especially useful for independently re-rendering chunks of your application without having to completely re-draw the entire screen every time some data is updated.\n\nRegions can be added to a View at class definition, with [`regions`](marionette.region#defining-regions), or at runtime using [`addRegion`](marionette.region#adding-regions).\n\nWhen you extend `View`, we use the `regions` attribute to point to the selector where the new view will be displayed:\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: _.template(`\n    <div id=\"first-region\"></div>\n    <div id=\"second-region\"></div>\n    <div id=\"third-region\"></div>\n  `),\n  regions: {\n    firstRegion: '#first-region',\n    secondRegion: '#second-region'\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/4e3qdgwr/)\n\nWhen we show views in the region, the contents of `#first-region` and `#second-region` will be replaced with the contents of the view we show. The value in the `regions` hash is just a jQuery selector, and any valid jQuery syntax will suffice.\n\n### Showing a Child View\n\nTo show a view inside a region, simply call `showChildView(regionName, view)`. This will handle rendering the view's HTML and attaching it to the DOM for you:\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\nimport SubView from './subview';\n\nconst MyView = View.extend({\n  template: _.template('<h1>Title</h1><div id=\"first-region\"></div>'),\n\n  regions: {\n    firstRegion: '#first-region'\n  },\n\n  onRender() {\n    this.showChildView('firstRegion', new SubView());\n  }\n});\n```\n\nNote: If `view.showChildView(region, subView)` is invoked before the `view` has been rendered, it will automatically render the `view` so the region's `el` exists in the DOM.\n\n[Live example](https://jsfiddle.net/marionettejs/98u073m0/)\n\n### Accessing a Child View\n\nTo access the child view of a `View` - use the `getChildView(regionName)` method. This will return the view instance that is currently being displayed at that region, or `null`:\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette'\nimport SubView from './subview';\n\nconst MyView = View.extend({\n  _.template('<h1>Title</h1><div id=\"first-region\"></div>'),\n\n  regions: {\n    firstRegion: '#first-region'\n  },\n\n  onRender() {\n    this.showChildView('firstRegion', new SubView());\n  },\n\n  onSomeEvent() {\n    const first = this.getChildView('firstRegion');\n    first.doSomething();\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/b12kgq3t/)\n\nIf no view is available, `getChildView` returns `null`.\n\n### Detaching a Child View\n\nYou can detach a child view from a region through `detachChildView(region)`\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette'\nimport SubView from './subview';\n\nconst MyView = View.extend({\n  template: _.template(`\n    <h1>Title</h1>\n    <div id=\"first-region\"></div>\n    <div id=\"second-region\"></div>\n  `),\n  regions: {\n    firstRegion: '#first-region',\n    secondRegion: '#second-region'\n  },\n\n  onRender() {\n    this.showChildView('firstRegion', new SubView());\n  },\n\n  onMoveView() {\n    const view = this.detachChildView('firstRegion');\n    this.showChildView('secondRegion', view);\n  }\n});\n```\n\nThis is a proxy for [region.detachView()](marionette.region#detaching-existing-views)\n\n### Destroying a Child View\n\nThere are two ways to easily destroy a child view.\n\n``` javascript\n// Directly\nmyChildView.getChildView('regionName').destroy();\n\n// Indirectly\nmyChildView.getRegion('regionName').empty();\n```\n\n### Region Availability\n\nAny defined regions within a `View` will be available to the `View` or any calling code immediately after rendering the `View`. Using `getRegion` or any of the child view methods above will first render the view so that the region is available.\n\n## Efficient Nested View Structures\n\nWhen your views get some more regions, you may want to think of the most efficient way to render your views. Since manipulating the DOM is performance heavy, it's best practice to render most of your views at once.\n\nMarionette provides a simple mechanism to infinitely nest views in a single paint: just render all of the children in the `onRender` callback for the [`render` event](events.class#render-and-beforerender-events).\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst ParentView = View.extend({\n  // ...\n  onRender() {\n    this.showChildView('header', new HeaderView());\n    this.showChildView('footer', new FooterView());\n  }\n});\n\nmyRegion.show(new ParentView());\n```\n\nIn this example, the doubly-nested view structure will be rendered in a single paint.\n\nThis system is recursive, so it works for any deeply nested structure. The child views you show can render their own child views within their onRender callbacks!\n\n## Listening to Events on Children\n\nUsing regions lets you listen to the events that fire on child views - views attached inside a region. This lets a parent view take action depending on what events are triggered in views it directly owns.\n\nRead More:\n\n- [Child Event Bubbling](events#event-bubbling)\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/marionette.view.html](https://marionettejs.com/docs/v4.0.0/marionette.view.html)"
- name: View isAttached()
  id: view.lifecycle#isattached
  summary: Returns a boolean value reflecting if the view is considered attached to the DOM
  belongs_to: View Lifecycle
  description: |-
    ### `isAttached()`

    Returns a boolean value reflecting if the view is considered attached to the DOM.
- name: View isDestroyed()
  id: view.lifecycle#isdestroyed
  summary: Returns a boolean value reflecting if the view has been destroyed
  belongs_to: View Lifecycle
  description: "### `isDestroyed()`\n\nReturns a boolean value reflecting if the view has been destroyed.\n\n## Instantiating a View\n\nMarionette Views are Backbone Views and so when they are instantiated the view has an `el`. That `el` will be the root node for the view and other than its contents it will not change for the life of the view unless directly manipulated (ie: `view.$el.addClass`)\n\nThe view can be passed an existing `el` either in the DOM (ie: `el: $('.foo-selector')`) or in memory (ie: `el: $('<div></div>')`) or most commonly, the view constructs its own `el` at instantiation as [documented on backbonejs.org](http://backbonejs.org/#View-el).\n\nMarionette will determine the initial state of the view as to whether the view is considered already [rendered](#rendering-a-view) or [attached](#attaching-a-view). If a view is already rendered or attached its [state](#lifecycle-state-methods) will reflect that status, but the [related events](events.class#dom-change-events) will not have fired.\n\nFor more information on instanting a view with pre-rendered DOM see: [Prerendered Content](dom.prerendered).\n\n### Using `setElement`\n\n`Backbone.View` allows the user to change the view's `el` after instantiaton using [`setElement`](http://backbonejs.org/#View-setElement). This method can be used in Marionette as well, but should be done with caution. `setElement` will redelegate view events, but it will essentially ignore children of the view, whether through `regions` or through `children` and the view's `behaviors` will also be unaware of the change. It is likely better to reconstuct a new view with the new `el` than to try to change the `el` of an existing view.\n\n## Rendering a View\n\nIn Marionette [rendering a view](view.rendering) is changing a view's `el`'s contents.\n\nWhat rendering indicates varies slightly between the two Marionette views.\n\n**Note** Once a view is considered \"rendered\" it cannot be unrendered until it is [destroyed](#destroying-a-view).\n\n### `View` Rendering\n\nFor [`View`](marionette.view), rendering entails serializing the view's data, passing it to a template, and taking the results of that template and replacing the contents of the view's `el`. So when a `View` is instantiated it is considered rendered if the `el` node contains any content. However after instantiation a template may render empty in which case the `View` will still be considered \"rendered\" even though it contains no content.\n\n### `CollectionView` Rendering\n\nFor [`CollectionView`](marionette.collectionview), rendering signifies that the view's [`children`](marionette.collectionview#collectionviews-children) were created and attached to the view's `el`. So unlike `View` a `CollectionView` can be instantiated with content in its `el`, but until the `children` are \"rendered\" the entire view is not considered rendered.\n\nNotably if there are no `children` when rendering, the view will still be considered rendered. This is true whether or not an [`emptyView`](marionette.collectionview#collectionviews-emptyview) is rendered. So it is possible for a `CollectionView` to be \"rendered\" but the `el` to only be an empty tag. Also note that just like `View` a `CollectionView` may have a `template` which is rendered and attached to the `el` during the `render`, but the template rendering itself has no bearing on the status of the `CollectionView`.\n\n## Rendering Children\n\nRendering child views is often best accomplish after the view render as typically the first render happens prior to the view entering the DOM. This helps to prevent unnecessary repaints and reflows by making the DOM insert at the highest possible view in the view tree.\n\nThe exception is views with [prerendered content](dom.prerendered). In the case that the view is instantiated rendered, child views are best managed in the view's [`initialize`](common#initialize).\n\n### `View` Children\n\nIn general the best method for adding a child view to a `View` is to use [`showChildView`](marionette.view#showing-a-view) in the [`render` event](events.class#render-and-beforerender-events).\n\nView regions will be emptied on each render so views shown outside of the `render` event will still need be reshown on subsequent renders.\n\n### `CollectionView` Children\n\nThe primary use case for a `CollectionView` is maintaining child views to match the state of a Backbone Collection. By default children will be added or removed to match the models within the collection. However a `CollectionView` can have children in addition to, or instead of, views matching the `collection`.\n\n#### Adding managed children\n\nIf you add a view to a `CollectionView`s children by default it will treat it as any other view added from the `collection`. This means it is subject to the [`viewComparator`](marionette.collectionview#defining-the-viewcomparator) and [`viewFilter`](marionette.collectionview#defining-the-viewfilter).\n\nSo if you are accounting for added views in your `viewFilter` and `viewComparator` the best place to add these children is likely in the [`render` event](events.class#render-and-beforerender-events) as the views will only be added once (or re-added if the children are rebuilt in a subsequent `render`) and managed in the sort or filter as the `collection` is updated.\n\n#### Adding unmanaged children\n\nUnlike managed children there may be cases where you want to insert views to the results of the `CollectionView` after the `collection` changes, or after sorting and/or filtering. In these cases the solution might depend slightly on the features used on the `CollectionView`.\n\nThe goal will be to add the unmanaged views after other views are added and to remove any unmanaged views prior to any managed `children` changes. To do so you must understand which [`CollectionView` event](events.class#collectionview-events) will occur prior to changes to the `children` for your particular use case. By default a `CollectionView` sorts according to the `collection` sort, so unless `viewComparator` is disabled, the best event for removing unmanaged views is the [`before:sort` event](events.class#sort-and-beforesort-events), but if `viewComparator` is false the next event to consider is the [`before:filter` event](events.class#filter-and-beforefilter-events) if your `CollectionView` has a `viewFilter`, otherwise the [`before:render:children` event](events.class#renderchildren-and-beforerenderchildren-events) is ideal.\n\nOnce you have determined the best strategy for removing your unmanaged child views, adding them is best handled in the [`render:children` event](events.class#renderchildren-and-beforerenderchildren-events). Additionally adding a child with `addChildView` will itself cause these events to occur, so to prevent stack overflows, it is best to use a flag to guard the adds and to insert a new view at a specified index.\n\nThe following simplistic example will add an unmanaged view at the 5th index and remove it prior to any changes to the `children`. In a real world scenario it will likely be more complicated to keep track of which view to remove in the `onBeforeSort`.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyCollectionView = CollectionView.extend({\n  childView: MyChildView,\n  onBeforeSort() {\n    this.removeChildView(this.children.findByIndex(5));\n  },\n  onRenderChildren() {\n    this.addFooView();\n  },\n  addFooView() {\n    if (this.addingFooView) {\n      return;\n    }\n\n    this.addingFooView = true;\n    this.addChildView(new FooView(), 5);\n    this.addingFooView = false;\n  }\n});\n```\n\n## Attaching a View\n\nIn Marionette a view is attached if the view's `el` can be found in the DOM. The best time to add listeners to the view's `el` is likely in the [`attach` event](events.class#attach-and-beforeattach-events).\n\nWhile the `el` of the view can be attached the contents of the view can be removed and added to during the lifetime of the view. If you are adding listeners to the contents of the view rather than `attach` the [`dom:refresh` event](events.class#domrefresh-event) would be best.\n\nThe attached state is maintained when attaching a view with a `Region` or as a child of a `CollectionView` or during [view instantiation](#instantiating-a-view). If a view is attached by other means like `$.append` \\[`isAttached`\\] may not reflect the actual state of attachment.\n\n## Detaching a View\n\nA view is detached when its `el` is removed from the DOM. The best time to clean up any listeners added to the `el` is in the [`before:detach` event](events.class#detach-and-beforedetach-events).\n\nWhile the `el` of the view may remain attached, its contents will be removed on render. If you have added listeners to the contents of the view rather than `before:detach` the [`dom:remove` event](events.class#domremove-event) would be best.\n\n## Destroying a View\n\nDestroying a view (ie: `myView.destroy()`) cleans up anything constucted within Marionette so that if a view's instance is no longer referenced the view can be cleaned up by the browser's garbage collector.\n\nThe [`before:destroy` event](events.class#destroy-and-beforedestroy-events) is the best place to clean up any added listeners not related to the view's DOM.\n\nThe state of the view after the destroy is not attached and not rendered although the `el` is not emptied.\n\n## Destroying Children\n\nChildren added to a `View`'s region or through a `CollectionView` will be automatically destroyed if the view is re-rendered, if the view is destroyed, or for `CollectionView` if the `collection` is reset.\n\n**Note** Children are removed after the DOM detach of the parent to prevent multiple reflows or repaints.\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/view.lifecycle.html](https://marionettejs.com/docs/v4.0.0/view.lifecycle.html)"
- name: View isRendered()
  id: view.lifecycle#isrendered
  summary: Returns a boolean value reflecting if the view is considered rendered
  belongs_to: View Lifecycle
  description: |-
    ### `isRendered()`

    Returns a boolean value reflecting if the view is considered rendered.
- name: View Lifecycle
  id: view.lifecycle
  summary: Both View and CollectionView are aware of their lifecycle state which indicates if the view is rendered, attached to the DOM or destroyed
  description: "# View Lifecycle\n\nBoth [`View` and `CollectionView`](classes) are aware of their lifecycle state which indicates if the view is rendered, attached to the DOM or destroyed.\n\n## Documentation Index\n\n- [View Lifecycle](#view-lifecycle)\n- [Lifecycle State Methods](#lifecycle-state-methods)\n  - [`isRendered()`](#isrendered)\n  - [`isAttached()`](#isattached)\n  - [`isDestroyed()`](#isdestroyed)\n- [Instantiating a View](#instantiating-a-view)\n  - [Using `setElement`](#using-setelement)\n- [Rendering a View](#rendering-a-view)\n  - [`View` Rendering](#view-rendering)\n  - [`CollectionView` Rendering](#collectionview-rendering)\n- [Rendering Children](#rendering-children)\n- [Attaching a View](#attaching-a-view)\n- [Detaching a View](#detaching-a-view)\n- [Destroying a View](#destroying-a-view)\n- [Destroying Children](#rendering-children)\n\n## Lifecycle State Methods\n\nBoth `View` and `CollectionView` share methods for checking lifecycle state.\n\n### `isRendered()`\n\nReturns a boolean value reflecting if the view is considered rendered.\n\n### `isAttached()`\n\nReturns a boolean value reflecting if the view is considered attached to the DOM.\n\n### `isDestroyed()`\n\nReturns a boolean value reflecting if the view has been destroyed.\n\n## Instantiating a View\n\nMarionette Views are Backbone Views and so when they are instantiated the view has an `el`. That `el` will be the root node for the view and other than its contents it will not change for the life of the view unless directly manipulated (ie: `view.$el.addClass`)\n\nThe view can be passed an existing `el` either in the DOM (ie: `el: $('.foo-selector')`) or in memory (ie: `el: $('<div></div>')`) or most commonly, the view constructs its own `el` at instantiation as [documented on backbonejs.org](http://backbonejs.org/#View-el).\n\nMarionette will determine the initial state of the view as to whether the view is considered already [rendered](#rendering-a-view) or [attached](#attaching-a-view). If a view is already rendered or attached its [state](#lifecycle-state-methods) will reflect that status, but the [related events](events.class#dom-change-events) will not have fired.\n\nFor more information on instanting a view with pre-rendered DOM see: [Prerendered Content](dom.prerendered).\n\n### Using `setElement`\n\n`Backbone.View` allows the user to change the view's `el` after instantiaton using [`setElement`](http://backbonejs.org/#View-setElement). This method can be used in Marionette as well, but should be done with caution. `setElement` will redelegate view events, but it will essentially ignore children of the view, whether through `regions` or through `children` and the view's `behaviors` will also be unaware of the change. It is likely better to reconstuct a new view with the new `el` than to try to change the `el` of an existing view.\n\n## Rendering a View\n\nIn Marionette [rendering a view](view.rendering) is changing a view's `el`'s contents.\n\nWhat rendering indicates varies slightly between the two Marionette views.\n\n**Note** Once a view is considered \"rendered\" it cannot be unrendered until it is [destroyed](#destroying-a-view).\n\n### `View` Rendering\n\nFor [`View`](marionette.view), rendering entails serializing the view's data, passing it to a template, and taking the results of that template and replacing the contents of the view's `el`. So when a `View` is instantiated it is considered rendered if the `el` node contains any content. However after instantiation a template may render empty in which case the `View` will still be considered \"rendered\" even though it contains no content.\n\n### `CollectionView` Rendering\n\nFor [`CollectionView`](marionette.collectionview), rendering signifies that the view's [`children`](marionette.collectionview#collectionviews-children) were created and attached to the view's `el`. So unlike `View` a `CollectionView` can be instantiated with content in its `el`, but until the `children` are \"rendered\" the entire view is not considered rendered.\n\nNotably if there are no `children` when rendering, the view will still be considered rendered. This is true whether or not an [`emptyView`](marionette.collectionview#collectionviews-emptyview) is rendered. So it is possible for a `CollectionView` to be \"rendered\" but the `el` to only be an empty tag. Also note that just like `View` a `CollectionView` may have a `template` which is rendered and attached to the `el` during the `render`, but the template rendering itself has no bearing on the status of the `CollectionView`.\n\n## Rendering Children\n\nRendering child views is often best accomplish after the view render as typically the first render happens prior to the view entering the DOM. This helps to prevent unnecessary repaints and reflows by making the DOM insert at the highest possible view in the view tree.\n\nThe exception is views with [prerendered content](dom.prerendered). In the case that the view is instantiated rendered, child views are best managed in the view's [`initialize`](common#initialize).\n\n### `View` Children\n\nIn general the best method for adding a child view to a `View` is to use [`showChildView`](marionette.view#showing-a-view) in the [`render` event](events.class#render-and-beforerender-events).\n\nView regions will be emptied on each render so views shown outside of the `render` event will still need be reshown on subsequent renders.\n\n### `CollectionView` Children\n\nThe primary use case for a `CollectionView` is maintaining child views to match the state of a Backbone Collection. By default children will be added or removed to match the models within the collection. However a `CollectionView` can have children in addition to, or instead of, views matching the `collection`.\n\n#### Adding managed children\n\nIf you add a view to a `CollectionView`s children by default it will treat it as any other view added from the `collection`. This means it is subject to the [`viewComparator`](marionette.collectionview#defining-the-viewcomparator) and [`viewFilter`](marionette.collectionview#defining-the-viewfilter).\n\nSo if you are accounting for added views in your `viewFilter` and `viewComparator` the best place to add these children is likely in the [`render` event](events.class#render-and-beforerender-events) as the views will only be added once (or re-added if the children are rebuilt in a subsequent `render`) and managed in the sort or filter as the `collection` is updated.\n\n#### Adding unmanaged children\n\nUnlike managed children there may be cases where you want to insert views to the results of the `CollectionView` after the `collection` changes, or after sorting and/or filtering. In these cases the solution might depend slightly on the features used on the `CollectionView`.\n\nThe goal will be to add the unmanaged views after other views are added and to remove any unmanaged views prior to any managed `children` changes. To do so you must understand which [`CollectionView` event](events.class#collectionview-events) will occur prior to changes to the `children` for your particular use case. By default a `CollectionView` sorts according to the `collection` sort, so unless `viewComparator` is disabled, the best event for removing unmanaged views is the [`before:sort` event](events.class#sort-and-beforesort-events), but if `viewComparator` is false the next event to consider is the [`before:filter` event](events.class#filter-and-beforefilter-events) if your `CollectionView` has a `viewFilter`, otherwise the [`before:render:children` event](events.class#renderchildren-and-beforerenderchildren-events) is ideal.\n\nOnce you have determined the best strategy for removing your unmanaged child views, adding them is best handled in the [`render:children` event](events.class#renderchildren-and-beforerenderchildren-events). Additionally adding a child with `addChildView` will itself cause these events to occur, so to prevent stack overflows, it is best to use a flag to guard the adds and to insert a new view at a specified index.\n\nThe following simplistic example will add an unmanaged view at the 5th index and remove it prior to any changes to the `children`. In a real world scenario it will likely be more complicated to keep track of which view to remove in the `onBeforeSort`.\n\n``` javascript\nimport { CollectionView } from 'backbone.marionette';\n\nconst MyCollectionView = CollectionView.extend({\n  childView: MyChildView,\n  onBeforeSort() {\n    this.removeChildView(this.children.findByIndex(5));\n  },\n  onRenderChildren() {\n    this.addFooView();\n  },\n  addFooView() {\n    if (this.addingFooView) {\n      return;\n    }\n\n    this.addingFooView = true;\n    this.addChildView(new FooView(), 5);\n    this.addingFooView = false;\n  }\n});\n```\n\n## Attaching a View\n\nIn Marionette a view is attached if the view's `el` can be found in the DOM. The best time to add listeners to the view's `el` is likely in the [`attach` event](events.class#attach-and-beforeattach-events).\n\nWhile the `el` of the view can be attached the contents of the view can be removed and added to during the lifetime of the view. If you are adding listeners to the contents of the view rather than `attach` the [`dom:refresh` event](events.class#domrefresh-event) would be best.\n\nThe attached state is maintained when attaching a view with a `Region` or as a child of a `CollectionView` or during [view instantiation](#instantiating-a-view). If a view is attached by other means like `$.append` \\[`isAttached`\\] may not reflect the actual state of attachment.\n\n## Detaching a View\n\nA view is detached when its `el` is removed from the DOM. The best time to clean up any listeners added to the `el` is in the [`before:detach` event](events.class#detach-and-beforedetach-events).\n\nWhile the `el` of the view may remain attached, its contents will be removed on render. If you have added listeners to the contents of the view rather than `before:detach` the [`dom:remove` event](events.class#domremove-event) would be best.\n\n## Destroying a View\n\nDestroying a view (ie: `myView.destroy()`) cleans up anything constucted within Marionette so that if a view's instance is no longer referenced the view can be cleaned up by the browser's garbage collector.\n\nThe [`before:destroy` event](events.class#destroy-and-beforedestroy-events) is the best place to clean up any added listeners not related to the view's DOM.\n\nThe state of the view after the destroy is not attached and not rendered although the `el` is not emptied.\n\n## Destroying Children\n\nChildren added to a `View`'s region or through a `CollectionView` will be automatically destroyed if the view is re-rendered, if the view is destroyed, or for `CollectionView` if the `collection` is reset.\n\n**Note** Children are removed after the DOM detach of the parent to prevent multiple reflows or repaints.\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/view.lifecycle.html](https://marionettejs.com/docs/v4.0.0/view.lifecycle.html)"
- name: View Lifecycle and Events
  id: marionette.view#view-lifecycle-and-events
  summary: An instantiated View is aware of its lifecycle state and will throw events related to when that state changes
  belongs_to: View
  description: "## View Lifecycle and Events\n\nAn instantiated `View` is aware of its lifecycle state and will throw events related to when that state changes.\n\nThe view states indicate whether the view is rendered, attached to the DOM, or destroyed.\n\nRead More:\n\n- [View Lifecycle](view.lifecycle)\n- [View DOM Change Events](events.class#dom-change-events)\n- [View Destroy Events](events.class#destroy-events)\n\n## Entity Events\n\nThe `View` can bind to events that occur on the attached `model` and `collection` - this includes both [standard backbone-events](http://backbonejs.org/#Events-catalog) and custom events.\n\nRead More:\n\n- [Entity Events](events.entity)\n\n## DOM Interactions\n\nIn addition to what Backbone provides the views, Marionette has additional API for DOM interactions: `events`, `triggers`, and `ui`.\n\nRead More:\n\n- [DOM Interactions](dom.interactions)\n\n## Behaviors\n\nA `Behavior` provides a clean separation of concerns to your view logic, allowing you to share common user-facing operations between your views.\n\nRead More:\n\n- [Using `Behavior`s](marionette.behavior#using-behaviors)\n\n## Managing Children\n\n`View` provides a simple interface for managing child-views with [`showChildView`](#showing-a-child-view), [`getChildView`](#accessing-a-child-view), and [`detachChildView`](#detaching-a-child-view). These methods all access `regions` within the view. We will cover this here but for more advanced information, see the [documentation for regions](marionette.region).\n\n### Laying Out Views - Regions\n\nThe `Marionette.View` class lets us manage a hierarchy of views using `regions`. Regions are a hook point that lets us show views inside views, manage the show/hide lifecycles, and act on events inside the children.\n\n**This Section only covers the basics. For more information on regions, see the [Regions Documentation.](marionette.region)**\n\nRegions are ideal for rendering application layouts by isolating concerns inside another view. This is especially useful for independently re-rendering chunks of your application without having to completely re-draw the entire screen every time some data is updated.\n\nRegions can be added to a View at class definition, with [`regions`](marionette.region#defining-regions), or at runtime using [`addRegion`](marionette.region#adding-regions).\n\nWhen you extend `View`, we use the `regions` attribute to point to the selector where the new view will be displayed:\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: _.template(`\n    <div id=\"first-region\"></div>\n    <div id=\"second-region\"></div>\n    <div id=\"third-region\"></div>\n  `),\n  regions: {\n    firstRegion: '#first-region',\n    secondRegion: '#second-region'\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/4e3qdgwr/)\n\nWhen we show views in the region, the contents of `#first-region` and `#second-region` will be replaced with the contents of the view we show. The value in the `regions` hash is just a jQuery selector, and any valid jQuery syntax will suffice.\n\n### Showing a Child View\n\nTo show a view inside a region, simply call `showChildView(regionName, view)`. This will handle rendering the view's HTML and attaching it to the DOM for you:\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\nimport SubView from './subview';\n\nconst MyView = View.extend({\n  template: _.template('<h1>Title</h1><div id=\"first-region\"></div>'),\n\n  regions: {\n    firstRegion: '#first-region'\n  },\n\n  onRender() {\n    this.showChildView('firstRegion', new SubView());\n  }\n});\n```\n\nNote: If `view.showChildView(region, subView)` is invoked before the `view` has been rendered, it will automatically render the `view` so the region's `el` exists in the DOM.\n\n[Live example](https://jsfiddle.net/marionettejs/98u073m0/)\n\n### Accessing a Child View\n\nTo access the child view of a `View` - use the `getChildView(regionName)` method. This will return the view instance that is currently being displayed at that region, or `null`:\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette'\nimport SubView from './subview';\n\nconst MyView = View.extend({\n  _.template('<h1>Title</h1><div id=\"first-region\"></div>'),\n\n  regions: {\n    firstRegion: '#first-region'\n  },\n\n  onRender() {\n    this.showChildView('firstRegion', new SubView());\n  },\n\n  onSomeEvent() {\n    const first = this.getChildView('firstRegion');\n    first.doSomething();\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/b12kgq3t/)\n\nIf no view is available, `getChildView` returns `null`.\n\n### Detaching a Child View\n\nYou can detach a child view from a region through `detachChildView(region)`\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette'\nimport SubView from './subview';\n\nconst MyView = View.extend({\n  template: _.template(`\n    <h1>Title</h1>\n    <div id=\"first-region\"></div>\n    <div id=\"second-region\"></div>\n  `),\n  regions: {\n    firstRegion: '#first-region',\n    secondRegion: '#second-region'\n  },\n\n  onRender() {\n    this.showChildView('firstRegion', new SubView());\n  },\n\n  onMoveView() {\n    const view = this.detachChildView('firstRegion');\n    this.showChildView('secondRegion', view);\n  }\n});\n```\n\nThis is a proxy for [region.detachView()](marionette.region#detaching-existing-views)\n\n### Destroying a Child View\n\nThere are two ways to easily destroy a child view.\n\n``` javascript\n// Directly\nmyChildView.getChildView('regionName').destroy();\n\n// Indirectly\nmyChildView.getRegion('regionName').empty();\n```\n\n### Region Availability\n\nAny defined regions within a `View` will be available to the `View` or any calling code immediately after rendering the `View`. Using `getRegion` or any of the child view methods above will first render the view so that the region is available.\n\n## Efficient Nested View Structures\n\nWhen your views get some more regions, you may want to think of the most efficient way to render your views. Since manipulating the DOM is performance heavy, it's best practice to render most of your views at once.\n\nMarionette provides a simple mechanism to infinitely nest views in a single paint: just render all of the children in the `onRender` callback for the [`render` event](events.class#render-and-beforerender-events).\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst ParentView = View.extend({\n  // ...\n  onRender() {\n    this.showChildView('header', new HeaderView());\n    this.showChildView('footer', new FooterView());\n  }\n});\n\nmyRegion.show(new ParentView());\n```\n\nIn this example, the doubly-nested view structure will be rendered in a single paint.\n\nThis system is recursive, so it works for any deeply nested structure. The child views you show can render their own child views within their onRender callbacks!\n\n## Listening to Events on Children\n\nUsing regions lets you listen to the events that fire on child views - views attached inside a region. This lets a parent view take action depending on what events are triggered in views it directly owns.\n\nRead More:\n\n- [Child Event Bubbling](events#event-bubbling)\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/marionette.view.html](https://marionettejs.com/docs/v4.0.0/marionette.view.html)"
- name: View Template Rendering
  id: view.rendering
  summary: Unlike Backbone.View, Marionette views provide a customizable solution for rendering a template with data and placing the results in the DOM
  description: "# View Template Rendering\n\nUnlike [`Backbone.View`](http://backbonejs.org/#View-template), [Marionette views](classes) provide a customizable solution for rendering a template with data and placing the results in the DOM.\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  tagName: 'h1',\n  template: _.template('Contents')\n});\n\nconst myView = new MyView();\nmyView.render();\n```\n\nIn the above example the contents of the `template` attribute will be rendered inside a `<h1>` tag available at `myView.el`.\n\n[Live example](https://jsfiddle.net/marionettejs/h762zjua/)\n\n## Documentation Index\n\n- [What is a template](#what-is-a-template)\n- [Setting a View Template](#setting-a-view-template)\n  - [Using a View Without a Template](#using-a-view-without-a-template)\n- [Rendering the Template](#rendering-the-template)\n  - [Using a Custom Renderer](#using-a-custom-renderer)\n  - [Rendering to HTML](#rendering-to-html)\n  - [Rendering to DOM](#rendering-to-dom)\n- [Serializing Data](#serializing-data)\n  - [Serializing a Model](#serializing-a-model)\n  - [Serializing a Collection](#serializing-a-collection)\n  - [Serializing with a `CollectionView`](#serializing-with-a-collectionview)\n- [Adding Context Data](#adding-context-data)\n  - [What is Context Data?](#what-is-context-data)\n\n## What is a template?\n\nA template is a function that given data returns either an HTML string or DOM. [The default renderer](#rendering-the-template) in Marionette expects the template to return an HTML string. Marionette's dependency Underscore comes with an HTML string [template compiler](http://underscorejs.org/#template).\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: _.template('<h1>Hello, world</h1>')\n});\n```\n\nThis doesn't have to be an underscore template, you can pass your own rendering function:\n\n``` javascript\nimport Handlebars from 'handlebars';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: Handlebars.compile('<h1>Hello, {{ name }}')\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/ep0e4qkt/)\n\n## Setting a View Template\n\nMarionette views use the `getTemplate` method to determine which template to use for rendering into its `el`. By default `getTemplate` is predefined on the view as simply:\n\n``` javascript\ngetTemplate() {\n  return this.template\n}\n```\n\nIn most cases by using the default `getTemplate` you can simply set the `template` on the view to define the view's template, but in some circumstances you may want to set the template conditionally.\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: _.template('Hello World!'),\n  getTemplate() {\n    if (this.model.has('user')) {\n      return _.template('Hello User!');\n    }\n\n    return this.template;\n  }\n});\n```\n\n[Live example](https://jsfiddle.net/marionettejs/9k5v4p92/)\n\n### Using a View Without a Template\n\nBy default `CollectionView` has no defined `template` and will only attempt to render the `template` if one is defined. For `View` there may be some situations where you do not intend to use a `template`. Perhaps you only need the view's `el` or you are using [prerendered content](dom.prerendered).\n\nIn this case setting `template` to `false` will prevent the template render. In the case of `View` it will also prevent the [`render` events](events.class#render-and-beforerender-events).\n\n``` javascript\nimport { View } from 'backbone.marionette';\n\nconst MyIconButtonView = View.extend({\n  template: false,\n  tagName: 'button',\n  className: '.icon-button',\n  triggers: {\n    'click': 'click'\n  },\n  onRender() {\n    console.log('You will never see me!');\n  }\n});\n```\n\n## Rendering the Template\n\nEach view class has a renderer which by default passes the [view data](#serializing-data) to the template function and returns the html string it generates.\n\nThe current default renderer is essentially the following:\n\n``` javascript\nimport { View, CollectionView } from 'backbone.marionette';\n\nfunction renderer(template, data) {\n  return template(data);\n}\n\nView.setRenderer(renderer);\nCollectionView.setRenderer(renderer);\n```\n\nPrevious to Marionette v4 the default renderer was the `TemplateCache`. This renderer has been extracted to a separate library: <https://github.com/marionettejs/marionette.templatecache> and can be used with v4.\n\n### Using a Custom Renderer\n\nYou can set the renderer for a view class by using the class method `setRenderer`. The renderer accepts two arguments. The first is the template passed to the view, and the second argument is the data to be rendered into the template.\n\nHere's an example that allows for the `template` of a view to be an underscore template string.\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\n\nView.setRenderer(function(template, data) {\n  return _.template(template)(data);\n});\n\nconst myView = new View({\n  template: 'Hello <%- name %>!',\n  model: new Backbone.Model({ name: 'World' })\n});\n\nmyView.render();\n\n// myView.el is <div>Hello World!</div>\n```\n\nThe renderer can also be customized separately on any extended View.\n\n``` javascript\nconst MyHBSView = View.extend();\n\n// Similar example as above but for handlebars\nMyHBSView.setRenderer(function(template, data) {\n  return Handlebars.compile(template)(data);\n});\n\nconst myHBSView = new MyHBSView({\n  template: 'Hello {{ name }}!',\n  model: new Backbone.Model({ name: 'World' })\n});\n\nmyHBSView.render();\n\n// myView.el is <div>Hello World!</div>\n```\n\n**Note** These examples while functional may not be ideal. If possible it is recommend to precompile your templates which can be done for a number of templating using various plugins for bundling tools such as [Browserify or Webpack](installation).\n\n### Rendering to HTML\n\nThe default Marionette renders return the HTML as a string. This string is passed to the view's `attachElContents` method which in turn uses the DOM API's [`setContents`](dom.api#setcontentsel-html). to set the contents of the view's `el` with DOM from the string.\n\n#### Customizing `attachElContents`\n\nYou can modify the way any particular view attaches a compiled template to the `el` by overriding `attachElContents`. This method receives only the results of the view's renderer and is only called if the renderer returned a value.\n\nFor instance, perhaps for one particular view you need to bypass the [DOM API](dom.api) and set the html directly:\n\n``` javascript\nattachElContent(html) {\n  this.el.innerHTML = html;\n}\n```\n\n### Rendering to DOM\n\nMarionette also supports templates that render to DOM instead of html strings by using a custom render.\n\nIn the following example the `template` method passed to the renderer will return a DOM element, and then if the view is already rendered utilize [morphdom](https://github.com/patrick-steele-idem/morphdom) to patch the DOM or otherwise it will set the view's `el` to the result of the template. (Note in this case the view's `el` created at instantiation would be overridden).\n\n``` javascript\nimport morphdom from 'morphdom';\nimport { View } from 'backbone.marionette';\n\nconst VDomView = View.extend();\n\nVDomView.setRenderer(function(template, data) {\n  const el = template(data);\n\n  if (this.isRendered()) {\n    // Patch the view's el contents in the DOM\n    morphdom(this.el, el, { childrenOnly: true });\n    return;\n  }\n\n  this.setElement(el.cloneNode(true));\n});\n```\n\nIn this case because the renderer is modifying the `el` directly, there is no need to return the result of the template rendering for the view to handle in [`attachElContents`](#customizing-attachelcontents). It is certainly an option to return the compiled DOM and modify [`attachElContents`](#customizing-attachelcontents) to handle a DOM object instead of a string literal, but in many cases it may be overcomplicated to do so.\n\nThere are a variety of possibilities for rendering with Marionette. If you are looking into alternatives from the default this may be a useful resource: <https://github.com/blikblum/marionette.renderers#renderers>\n\n## Serializing Data\n\nMarionette will automatically serialize the data from its `model` or `collection` for the template to use at [rendering](#rendering-the-template). You can override this logic and provide serialization of other data with the `serializeData` method. The method is called with no arguments, but has the context of the view and should return a javascript object for the template to consume. If `serializeData` does not return data the template may still receive [added context](#adding-context-data) or an empty object for rendering.\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: _.template(`\n    <div><% user.name %></div>\n    <ul>\n    <% _.each(groups, function(group) { %>\n      <li><%- group.name %></li>\n    <% }) %>\n    </ul>\n  `),\n  serializeData() {\n    // For this view I need both the\n    // model and collection serialized\n    return {\n      user: this.serializeModel(),\n      groups: this.serializeCollection(),\n    };\n  }\n});\n```\n\n**Note** You should not use this method to add arbitrary extra data to your template. Instead use `templateContext` to [add context data to your template](#adding-context-data).\n\n### Serializing a Model\n\nIf the view has a `model` it will pass that model's attributes to the template.\n\n``` javascript\nimport _ from 'underscore';\nimport Backbone from 'backbone';\nimport { View } from 'backbone.marionette';\n\nconst MyModel = Backbone.Model.extend({\n  defaults: {\n    name: 'world'\n  }\n});\n\nconst MyView = View.extend({\n  template: _.template('<h1>Hello, <%- name %></h1>')\n});\n\nconst myView = new MyView({ model: new MyModel() });\n```\n\n[Live example](https://jsfiddle.net/marionettejs/warfa6rL/)\n\nHow the `model` is serialized can also be customized per view.\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  serializeModel() {\n    const data = _.clone(this.model.attributes);\n\n    // serialize nested model data\n    data.sub_model = data.sub_model.attributes;\n\n    return data;\n  }\n});\n```\n\n### Serializing a Collection\n\nIf the view does not have a `model` but has a `collection` the collection's models will be serialized to an array provided as an `items` attribute to the template.\n\n``` javascript\nimport _ from 'underscore';\nimport Backbone from 'backbone';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: _.template(`\n    <ul>\n    <% _.each(items, function(item) { %>\n      <li><%- item.name %></li>\n    <% }) %>\n    </ul>\n  `)\n});\n\nconst collection = new Backbone.Collection([\n  {name: 'Steve'}, {name: 'Helen'}\n]);\n\nconst myView = new MyView({ collection });\n```\n\n[Live example](https://jsfiddle.net/marionettejs/qyodkakf/)\n\nHow the `collection` is serialized can also be customized per view.\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  serializeCollection() {\n    return _.map(this.collection.models, model => {\n      const data = _.clone(model.attributes);\n\n      // serialize nested model data\n      data.sub_model = data.sub_model.attributes;\n\n      return data;\n    });\n  }\n});\n```\n\n### Serializing with a `CollectionView`\n\nif you are using a `template` with a `CollectionView` that is not also given a `model`, your `CollectionView` will [serialize the collection](serializing-a-collection) for the template. This could be costly and unnecessary. If your `CollectionView` has a `template` it is advised to either use an empty `model` or override the [`serializeData`](#serializing-data) method.\n\n## Adding Context Data\n\nMarionette views provide a `templateContext` attribute that is used to add extra information to your templates. This can be either an object, or a function returning an object. The keys on the returned object will be mixed into the model or collection keys and made available to the template.\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: _.template('<h1>Hello, <%- name %></h1>'),\n  templateContext: {\n    name: 'World'\n  }\n});\n```\n\nAdditionally context data overwrites the serialized data\n\n``` javascript\nimport _ from 'underscore';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: _.template('<h1>Hello, <%- name %></h1>'),\n  templateContext() {\n    return {\n      name: this.model.get('name').toUpperCase()\n    };\n  }\n});\n```\n\nYou can also define a template context value as a method. How this method is called is determined by your templating solution. For instance with handlebars a method is called with the context of the data passed to the template.\n\n``` javascript\nimport Handlebars from 'handlebars';\nimport Backbone from 'backbone';\nimport { View } from 'backbone.marionette';\n\nconst MyView = View.extend({\n  template: Handlebars.compile(`\n    <h1{{#if isDr}} class=\"dr\"{{/if}}>Hello {{ fullName }}</h1>,\n  `),\n  templateContext: {\n    isDr() {\n      return (this.degree) === 'phd';\n    },\n    fullName() {\n      // Because of Handlebars `this` here is the data object\n      // passed to the template which is the result of the\n      // templateContext mixed with the serialized data of the view\n      return this.isDr() ? `Dr. { this.name }` : this.name;\n    }\n  }\n});\n\nconst myView = new MyView({\n  model: new Backbone.Model({ degree: 'masters', name: 'Joe' });\n});\n```\n\n**Note** the data object passed to the template is not deeply cloned and in some cases is not cloned at all. Take caution when modifying the data passed to the template, that you are not also modifying your model's data indirectly.\n\n### What is Context Data?\n\nWhile [serializing data](#serializing-data) deals more with getting the data belonging to the view into the template, template context mixes in other needed data, or in some cases, might do extra computations that go beyond simply \"serializing\" the view's `model` or `collection`\n\n``` javascript\nimport _ from 'underscore'\nimport { CollectionView } from 'backbone.marionette';\nimport GroupView from './group-view';\n\nconst MyCollectionView = CollectionView.extend({\n  tagName: 'div',\n  childViewContainer: 'ul',\n  childView: GroupView,\n  template: _.template(`\n    <h1>Hello <% name %> of <% orgName %></h1>\n    <div>You have <% stats.public %> group(s).</div>\n    <div>You have <% stats.private %> group(s).</div>\n    <h3>Groups:</h3>\n    <ul></ul>\n  `),\n  templateContext() {\n    const user = this.model;\n    const organization = user.getOrganization();\n    const groups = this.collection;\n\n    return {\n      orgName: organization.get('name'),\n      name: user.getFullName(),\n      stats: groups.countBy('type')\n    };\n  }\n})\n```\n\n© 2017 Muted Solutions, LLC  \nLicensed under the MIT License.  \n[https://marionettejs.com/docs/v4.0.0/view.rendering.html](https://marionettejs.com/docs/v4.0.0/view.rendering.html)"
