---
name: Chai
slug: chai
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © 2017 Chai.js Assertion Library
  Licensed under the MIT License.
  https://www.chaijs.com/api/
homepage: https://www.chaijs.com/

---
- name: a
  id: api/bdd/index#method_a
  summary: Asserts that the target’s type is equal to the given string type
  belongs_to: BDD
  description: |-
    ### .a(type\[, msg\])

    - @param { String } type
    - @param { String } msg \_optional\_

    Asserts that the target’s type is equal to the given string `type`. Types are case insensitive. See the `type``-``detect` project page for info on the type detection algorithm: https://github.com/chaijs/type-detect.

    ``` javascript
    expect('foo').to.be.a('string');
    expect({a: 1}).to.be.an('object');
    expect(null).to.be.a('null');
    expect(undefined).to.be.an('undefined');
    expect(new Error).to.be.an('error');
    expect(Promise.resolve()).to.be.a('promise');
    expect(new Float32Array).to.be.a('float32array');
    expect(Symbol()).to.be.a('symbol');
    ```

    `.``a` supports objects that have a custom type set via `Symbol``.``toStringTag`.

    ``` javascript
    var myObj = {
      [Symbol.toStringTag]: 'myCustomType'
    };

    expect(myObj).to.be.a('myCustomType').but.not.an('object');
    ```

    It’s often best to use `.``a` to check a target’s type before making more assertions on the same target. That way, you avoid unexpected behavior from any assertion that does different things based on the target’s type.

    ``` javascript
    expect([1, 2, 3]).to.be.an('array').that.includes(2);
    expect([]).to.be.an('array').that.is.empty;
    ```

    Add `.``not` earlier in the chain to negate `.``a`. However, it’s often best to assert that the target is the expected type, rather than asserting that it isn’t one of many unexpected types.

    ``` javascript
    expect('foo').to.be.a('string'); // Recommended
    expect('foo').to.not.be.an('array'); // Not recommended
    ```

    `.``a` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect(1).to.be.a('string', 'nooo why fail??');
    expect(1, 'nooo why fail??').to.be.a('string');
    ```

    `.``a` can also be used as a language chain to improve the readability of your assertions.

    ``` javascript
    expect({b: 2}).to.have.a.property('b');
    ```

    The alias `.``an` can be used interchangeably with `.``a`.
- name: above
  id: api/bdd/index#method_above
  summary: Asserts that the target is a number or a date greater than the given number or date n respectively
  belongs_to: BDD
  description: |-
    ### .above(n\[, msg\])

    - @param { Number } n
    - @param { String } msg \_optional\_

    Asserts that the target is a number or a date greater than the given number or date `n` respectively. However, it’s often best to assert that the target is equal to its expected value.

    ``` javascript
    expect(2).to.equal(2); // Recommended
    expect(2).to.be.above(1); // Not recommended
    ```

    Add `.``lengthOf` earlier in the chain to assert that the target’s `length` or `size` is greater than the given number `n`.

    ``` javascript
    expect('foo').to.have.lengthOf(3); // Recommended
    expect('foo').to.have.lengthOf.above(2); // Not recommended

    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
    ```

    Add `.``not` earlier in the chain to negate `.``above`.

    ``` javascript
    expect(2).to.equal(2); // Recommended
    expect(1).to.not.be.above(2); // Not recommended
    ```

    `.``above` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect(1).to.be.above(2, 'nooo why fail??');
    expect(1, 'nooo why fail??').to.be.above(2);
    ```

    The aliases `.``gt` and `.``greaterThan` can be used interchangeably with `.``above`.
- name: addChainableMethod
  id: api/plugins/index#method_addchainablemethod
  summary: Adds a method to an object, such that the method can also be chained
  belongs_to: Plugin Utilities
  description: |-
    ### .addChainableMethod(ctx, name, method, chainingBehavior)

    - @param { Object } ctx object to which the method is added
    - @param { String } name of method to add
    - @param { Function } method function to be used for \`name\`, when called
    - @param { Function } chainingBehavior function to be called every time the property is accessed

    Adds a method to an object, such that the method can also be chained.

    ``` javascript
    utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
      var obj = utils.flag(this, 'object');
      new chai.Assertion(obj).to.be.equal(str);
    });
    ```

    Can also be accessed directly from `chai.Assertion`.

    ``` javascript
    chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
    ```

    The result can then be used as both a method assertion, executing both `method` and `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.

    ``` javascript
    expect(fooStr).to.be.foo('bar');
    expect(fooStr).to.be.foo.equal('foo');
    ```
- name: addLengthGuard
  id: api/plugins/index#method_addlengthguard
  summary: Define length as a getter on the given uninvoked method assertion
  belongs_to: Plugin Utilities
  description: |-
    ### .addLengthGuard(fn, assertionName, isChainable)

    - @param { Function } fn
    - @param { String } assertionName
    - @param { Boolean } isChainable

    Define `length` as a getter on the given uninvoked method assertion. The getter acts as a guard against chaining `length` directly off of an uninvoked method assertion, which is a problem because it references `function`’s built-in `length` property instead of Chai’s `length` assertion. When the getter catches the user making this mistake, it throws an error with a helpful message.

    There are two ways in which this mistake can be made. The first way is by chaining the `length` assertion directly off of an uninvoked chainable method. In this case, Chai suggests that the user use `lengthOf` instead. The second way is by chaining the `length` assertion directly off of an uninvoked non-chainable method. Non-chainable methods must be invoked prior to chaining. In this case, Chai suggests that the user consult the docs for the given assertion.

    If the `length` property of functions is unconfigurable, then return `fn` without modification.

    Note that in ES6, the function’s `length` property is configurable, so once support for legacy environments is dropped, Chai’s `length` property can replace the built-in function’s `length` property, and this length guard will no longer be necessary. In the mean time, maintaining consistency across all environments is the priority.
- name: addMethod
  id: api/plugins/index#method_addmethod
  summary: Adds a method to the prototype of an object
  belongs_to: Plugin Utilities
  description: |-
    ### .addMethod(ctx, name, method)

    - @param { Object } ctx object to which the method is added
    - @param { String } name of method to add
    - @param { Function } method function to be used for name

    Adds a method to the prototype of an object.

    ``` javascript
    utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
      var obj = utils.flag(this, 'object');
      new chai.Assertion(obj).to.be.equal(str);
    });
    ```

    Can also be accessed directly from `chai.Assertion`.

    ``` javascript
    chai.Assertion.addMethod('foo', fn);
    ```

    Then can be used as any other assertion.

    ``` javascript
    expect(fooStr).to.be.foo('bar');
    ```
- name: addProperty
  id: api/plugins/index#method_addproperty
  summary: Adds a property to the prototype of an object
  belongs_to: Plugin Utilities
  description: |-
    ### .addProperty(ctx, name, getter)

    - @param { Object } ctx object to which the property is added
    - @param { String } name of property to add
    - @param { Function } getter function to be used for name

    Adds a property to the prototype of an object.

    ``` javascript
    utils.addProperty(chai.Assertion.prototype, 'foo', function () {
      var obj = utils.flag(this, 'object');
      new chai.Assertion(obj).to.be.instanceof(Foo);
    });
    ```

    Can also be accessed directly from `chai.Assertion`.

    ``` javascript
    chai.Assertion.addProperty('foo', fn);
    ```

    Then can be used as any other assertion.

    ``` javascript
    expect(myFoo).to.be.foo;
    ```
- name: all
  id: api/bdd/index#method_all
  summary: Causes all .``keys assertions that follow in the chain to require that the target have all of the given keys
  belongs_to: BDD
  description: |-
    ### .all

    Causes all `.``keys` assertions that follow in the chain to require that the target have all of the given keys. This is the opposite of `.``any`, which only requires that the target have at least one of the given keys.

    ``` javascript
    expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
    ```

    Note that `.``all` is used by default when neither `.``all` nor `.``any` are added earlier in the chain. However, it’s often best to add `.``all` anyway because it improves readability.

    See the `.``keys` doc for guidance on when to use `.``any` or `.``all`.
- name: any
  id: api/bdd/index#method_any
  summary: Causes all .``keys assertions that follow in the chain to only require that the target have at least one of the given keys
  belongs_to: BDD
  description: |-
    ### .any

    Causes all `.``keys` assertions that follow in the chain to only require that the target have at least one of the given keys. This is the opposite of `.``all`, which requires that the target have all of the given keys.

    ``` javascript
    expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
    ```

    See the `.``keys` doc for guidance on when to use `.``any` or `.``all`.
- name: approximately
  id: api/assert/index#method_approximately
  summary: Asserts that the target is equal expected, to within a +/- delta range
  belongs_to: Assert
  description: |-
    ### .approximately(actual, expected, delta, \[message\])

    - @param { Number } actual
    - @param { Number } expected
    - @param { Number } delta
    - @param { String } message

    Asserts that the target is equal `expected`, to within a +/- `delta` range.

    ``` javascript
    assert.approximately(1.5, 1, 0.5, 'numbers are close');
    ```
- name: arguments
  id: api/bdd/index#method_arguments
  summary: Asserts that the target is an arguments object
  belongs_to: BDD
  description: |-
    ### .arguments

    Asserts that the target is an `arguments` object.

    ``` javascript
    function test () {
      expect(arguments).to.be.arguments;
    }

    test();
    ```

    Add `.``not` earlier in the chain to negate `.``arguments`. However, it’s often best to assert which type the target is expected to be, rather than asserting that it’s not an `arguments` object.

    ``` javascript
    expect('foo').to.be.a('string'); // Recommended
    expect('foo').to.not.be.arguments; // Not recommended
    ```

    A custom error message can be given as the second argument to `expect`.

    ``` javascript
    expect({}, 'nooo why fail??').to.be.arguments;
    ```

    The alias `.``Arguments` can be used interchangeably with `.``arguments`.
- name: Assert
  id: api/assert/index
  summary: The assert style is very similar to node.js’ included assert module, with a bit of extra sugar
  description: "# Assert\n\nThe `assert` style is very similar to node.js’ included assert module, with a bit of extra sugar. Of the three style options, `assert` is the only one that is not chainable. Check out the [Style Guide](../../guide/styles/index) for a comparison.\n\n## API Reference\n\n### assert(expression, message)\n\n- @param { Mixed } expression to test for truthiness\n- @param { String } message to display on error\n\nWrite your own test expressions.\n\n``` javascript\nassert('foo' !== 'bar', 'foo is not bar');\nassert(Array.isArray([]), 'empty arrays are arrays');\n```\n\n### .fail(\\[message\\])\n\n### .fail(actual, expected, \\[message\\], \\[operator\\])\n\n- @param { Mixed } actual\n- @param { Mixed } expected\n- @param { String } message\n- @param { String } operator\n\nThrow a failure. Node.js `assert` module-compatible.\n\n``` javascript\nassert.fail();\nassert.fail(\"custom error message\");\nassert.fail(1, 2);\nassert.fail(1, 2, \"custom error message\");\nassert.fail(1, 2, \"custom error message\", \">\");\nassert.fail(1, 2, undefined, \">\");\n```\n\n### .isOk(object, \\[message\\])\n\n- @param { Mixed } object to test\n- @param { String } message\n\nAsserts that `object` is truthy.\n\n``` javascript\nassert.isOk('everything', 'everything is ok');\nassert.isOk(false, 'this will fail');\n```\n\n### .isNotOk(object, \\[message\\])\n\n- @param { Mixed } object to test\n- @param { String } message\n\nAsserts that `object` is falsy.\n\n``` javascript\nassert.isNotOk('everything', 'this will fail');\nassert.isNotOk(false, 'this will pass');\n```\n\n### .equal(actual, expected, \\[message\\])\n\n- @param { Mixed } actual\n- @param { Mixed } expected\n- @param { String } message\n\nAsserts non-strict equality (`==`) of `actual` and `expected`.\n\n``` javascript\nassert.equal(3, '3', '== coerces values to strings');\n```\n\n### .notEqual(actual, expected, \\[message\\])\n\n- @param { Mixed } actual\n- @param { Mixed } expected\n- @param { String } message\n\nAsserts non-strict inequality (`!=`) of `actual` and `expected`.\n\n``` javascript\nassert.notEqual(3, 4, 'these numbers are not equal');\n```\n\n### .strictEqual(actual, expected, \\[message\\])\n\n- @param { Mixed } actual\n- @param { Mixed } expected\n- @param { String } message\n\nAsserts strict equality (`===`) of `actual` and `expected`.\n\n``` javascript\nassert.strictEqual(true, true, 'these booleans are strictly equal');\n```\n\n### .notStrictEqual(actual, expected, \\[message\\])\n\n- @param { Mixed } actual\n- @param { Mixed } expected\n- @param { String } message\n\nAsserts strict inequality (`!==`) of `actual` and `expected`.\n\n``` javascript\nassert.notStrictEqual(3, '3', 'no coercion for strict equality');\n```\n\n### .deepEqual(actual, expected, \\[message\\])\n\n- @param { Mixed } actual\n- @param { Mixed } expected\n- @param { String } message\n\nAsserts that `actual` is deeply equal to `expected`.\n\n``` javascript\nassert.deepEqual({ tea: 'green' }, { tea: 'green' });\n```\n\n### .notDeepEqual(actual, expected, \\[message\\])\n\n- @param { Mixed } actual\n- @param { Mixed } expected\n- @param { String } message\n\nAssert that `actual` is not deeply equal to `expected`.\n\n``` javascript\nassert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\n```\n\n### .isAbove(valueToCheck, valueToBeAbove, \\[message\\])\n\n- @param { Mixed } valueToCheck\n- @param { Mixed } valueToBeAbove\n- @param { String } message\n\nAsserts `valueToCheck` is strictly greater than (\\>) `valueToBeAbove`.\n\n``` javascript\nassert.isAbove(5, 2, '5 is strictly greater than 2');\n```\n\n### .isAtLeast(valueToCheck, valueToBeAtLeast, \\[message\\])\n\n- @param { Mixed } valueToCheck\n- @param { Mixed } valueToBeAtLeast\n- @param { String } message\n\nAsserts `valueToCheck` is greater than or equal to (\\>=) `valueToBeAtLeast`.\n\n``` javascript\nassert.isAtLeast(5, 2, '5 is greater or equal to 2');\nassert.isAtLeast(3, 3, '3 is greater or equal to 3');\n```\n\n### .isBelow(valueToCheck, valueToBeBelow, \\[message\\])\n\n- @param { Mixed } valueToCheck\n- @param { Mixed } valueToBeBelow\n- @param { String } message\n\nAsserts `valueToCheck` is strictly less than (\\<) `valueToBeBelow`.\n\n``` javascript\nassert.isBelow(3, 6, '3 is strictly less than 6');\n```\n\n### .isAtMost(valueToCheck, valueToBeAtMost, \\[message\\])\n\n- @param { Mixed } valueToCheck\n- @param { Mixed } valueToBeAtMost\n- @param { String } message\n\nAsserts `valueToCheck` is less than or equal to (\\<=) `valueToBeAtMost`.\n\n``` javascript\nassert.isAtMost(3, 6, '3 is less than or equal to 6');\nassert.isAtMost(4, 4, '4 is less than or equal to 4');\n```\n\n### .isTrue(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is true.\n\n``` javascript\nvar teaServed = true;\nassert.isTrue(teaServed, 'the tea has been served');\n```\n\n### .isNotTrue(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is not true.\n\n``` javascript\nvar tea = 'tasty chai';\nassert.isNotTrue(tea, 'great, time for tea!');\n```\n\n### .isFalse(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is false.\n\n``` javascript\nvar teaServed = false;\nassert.isFalse(teaServed, 'no tea yet? hmm...');\n```\n\n### .isNotFalse(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is not false.\n\n``` javascript\nvar tea = 'tasty chai';\nassert.isNotFalse(tea, 'great, time for tea!');\n```\n\n### .isNull(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is null.\n\n``` javascript\nassert.isNull(err, 'there was no error');\n```\n\n### .isNotNull(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is not null.\n\n``` javascript\nvar tea = 'tasty chai';\nassert.isNotNull(tea, 'great, time for tea!');\n```\n\n### .isNaN\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that value is NaN.\n\n``` javascript\nassert.isNaN(NaN, 'NaN is NaN');\n```\n\n### .isNotNaN\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that value is not NaN.\n\n``` javascript\nassert.isNotNaN(4, '4 is not NaN');\n```\n\n### .exists\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that the target is neither `null` nor `undefined`.\n\n``` javascript\nvar foo = 'hi';\n\nassert.exists(foo, 'foo is neither `null` nor `undefined`');\n```\n\n### .notExists\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that the target is either `null` or `undefined`.\n\n``` javascript\nvar bar = null\n  , baz;\n\nassert.notExists(bar);\nassert.notExists(baz, 'baz is either null or undefined');\n```\n\n### .isUndefined(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is `undefined`.\n\n``` javascript\nvar tea;\nassert.isUndefined(tea, 'no tea defined');\n```\n\n### .isDefined(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is not `undefined`.\n\n``` javascript\nvar tea = 'cup of chai';\nassert.isDefined(tea, 'tea has been defined');\n```\n\n### .isFunction(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is a function.\n\n``` javascript\nfunction serveTea() { return 'cup of tea'; };\nassert.isFunction(serveTea, 'great, we can have tea now');\n```\n\n### .isNotFunction(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is *not* a function.\n\n``` javascript\nvar serveTea = [ 'heat', 'pour', 'sip' ];\nassert.isNotFunction(serveTea, 'great, we have listed the steps');\n```\n\n### .isObject(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is an object of type ‘Object’ (as revealed by `Object``.``prototype``.``toString`). *The assertion does not match subclassed objects.*\n\n``` javascript\nvar selection = { name: 'Chai', serve: 'with spices' };\nassert.isObject(selection, 'tea selection is an object');\n```\n\n### .isNotObject(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is *not* an object of type ‘Object’ (as revealed by `Object``.``prototype``.``toString`).\n\n``` javascript\nvar selection = 'chai'\nassert.isNotObject(selection, 'tea selection is not an object');\nassert.isNotObject(null, 'null is not an object');\n```\n\n### .isArray(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is an array.\n\n``` javascript\nvar menu = [ 'green', 'chai', 'oolong' ];\nassert.isArray(menu, 'what kind of tea do we want?');\n```\n\n### .isNotArray(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is *not* an array.\n\n``` javascript\nvar menu = 'green|chai|oolong';\nassert.isNotArray(menu, 'what kind of tea do we want?');\n```\n\n### .isString(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is a string.\n\n``` javascript\nvar teaOrder = 'chai';\nassert.isString(teaOrder, 'order placed');\n```\n\n### .isNotString(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is *not* a string.\n\n``` javascript\nvar teaOrder = 4;\nassert.isNotString(teaOrder, 'order placed');\n```\n\n### .isNumber(value, \\[message\\])\n\n- @param { Number } value\n- @param { String } message\n\nAsserts that `value` is a number.\n\n``` javascript\nvar cups = 2;\nassert.isNumber(cups, 'how many cups');\n```\n\n### .isNotNumber(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is *not* a number.\n\n``` javascript\nvar cups = '2 cups please';\nassert.isNotNumber(cups, 'how many cups');\n```\n\n### .isFinite(value, \\[message\\])\n\n- @param { Number } value\n- @param { String } message\n\nAsserts that `value` is a finite number. Unlike `.``isNumber`, this will fail for `NaN` and `Infinity`.\n\n``` javascript\nvar cups = 2;\nassert.isFinite(cups, 'how many cups');\n\nassert.isFinite(NaN); // throws\n```\n\n### .isBoolean(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is a boolean.\n\n``` javascript\nvar teaReady = true\n  , teaServed = false;\n\nassert.isBoolean(teaReady, 'is the tea ready');\nassert.isBoolean(teaServed, 'has tea been served');\n```\n\n### .isNotBoolean(value, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `value` is *not* a boolean.\n\n``` javascript\nvar teaReady = 'yep'\n  , teaServed = 'nope';\n\nassert.isNotBoolean(teaReady, 'is the tea ready');\nassert.isNotBoolean(teaServed, 'has tea been served');\n```\n\n### .typeOf(value, name, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } name\n- @param { String } message\n\nAsserts that `value`’s type is `name`, as determined by `Object``.``prototype``.``toString`.\n\n``` javascript\nassert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\nassert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\nassert.typeOf('tea', 'string', 'we have a string');\nassert.typeOf(/tea/, 'regexp', 'we have a regular expression');\nassert.typeOf(null, 'null', 'we have a null');\nassert.typeOf(undefined, 'undefined', 'we have an undefined');\n```\n\n### .notTypeOf(value, name, \\[message\\])\n\n- @param { Mixed } value\n- @param { String } typeof name\n- @param { String } message\n\nAsserts that `value`’s type is *not* `name`, as determined by `Object``.``prototype``.``toString`.\n\n``` javascript\nassert.notTypeOf('tea', 'number', 'strings are not numbers');\n```\n\n### .instanceOf(object, constructor, \\[message\\])\n\n- @param { Object } object\n- @param { Constructor } constructor\n- @param { String } message\n\nAsserts that `value` is an instance of `constructor`.\n\n``` javascript\nvar Tea = function (name) { this.name = name; }\n  , chai = new Tea('chai');\n\nassert.instanceOf(chai, Tea, 'chai is an instance of tea');\n```\n\n### .notInstanceOf(object, constructor, \\[message\\])\n\n- @param { Object } object\n- @param { Constructor } constructor\n- @param { String } message\n\nAsserts `value` is not an instance of `constructor`.\n\n``` javascript\nvar Tea = function (name) { this.name = name; }\n  , chai = new String('chai');\n\nassert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\n```\n\n### .include(haystack, needle, \\[message\\])\n\n- @param { Array \\| String } haystack\n- @param { Mixed } needle\n- @param { String } message\n\nAsserts that `haystack` includes `needle`. Can be used to assert the inclusion of a value in an array, a substring in a string, or a subset of properties in an object.\n\n``` javascript\nassert.include([1,2,3], 2, 'array contains value');\nassert.include('foobar', 'foo', 'string contains substring');\nassert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');\n```\n\nStrict equality (===) is used. When asserting the inclusion of a value in an array, the array is searched for an element that’s strictly equal to the given value. When asserting a subset of properties in an object, the object is searched for the given property keys, checking that each one is present and strictly equal to the given property value. For instance:\n\n``` javascript\nvar obj1 = {a: 1}\n  , obj2 = {b: 2};\nassert.include([obj1, obj2], obj1);\nassert.include({foo: obj1, bar: obj2}, {foo: obj1});\nassert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});\n```\n\n### .notInclude(haystack, needle, \\[message\\])\n\n- @param { Array \\| String } haystack\n- @param { Mixed } needle\n- @param { String } message\n\nAsserts that `haystack` does not include `needle`. Can be used to assert the absence of a value in an array, a substring in a string, or a subset of properties in an object.\n\n``` javascript\nassert.notInclude([1,2,3], 4, \"array doesn't contain value\");\nassert.notInclude('foobar', 'baz', \"string doesn't contain substring\");\nassert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');\n```\n\nStrict equality (===) is used. When asserting the absence of a value in an array, the array is searched to confirm the absence of an element that’s strictly equal to the given value. When asserting a subset of properties in an object, the object is searched to confirm that at least one of the given property keys is either not present or not strictly equal to the given property value. For instance:\n\n``` javascript\nvar obj1 = {a: 1}\n  , obj2 = {b: 2};\nassert.notInclude([obj1, obj2], {a: 1});\nassert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});\nassert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});\n```\n\n### .deepInclude(haystack, needle, \\[message\\])\n\n- @param { Array \\| String } haystack\n- @param { Mixed } needle\n- @param { String } message\n\nAsserts that `haystack` includes `needle`. Can be used to assert the inclusion of a value in an array or a subset of properties in an object. Deep equality is used.\n\n``` javascript\nvar obj1 = {a: 1}\n  , obj2 = {b: 2};\nassert.deepInclude([obj1, obj2], {a: 1});\nassert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});\nassert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});\n```\n\n### .notDeepInclude(haystack, needle, \\[message\\])\n\n- @param { Array \\| String } haystack\n- @param { Mixed } needle\n- @param { String } message\n\nAsserts that `haystack` does not include `needle`. Can be used to assert the absence of a value in an array or a subset of properties in an object. Deep equality is used.\n\n``` javascript\nvar obj1 = {a: 1}\n  , obj2 = {b: 2};\nassert.notDeepInclude([obj1, obj2], {a: 9});\nassert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});\nassert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});\n```\n\n### .nestedInclude(haystack, needle, \\[message\\])\n\n- @param { Object } haystack\n- @param { Object } needle\n- @param { String } message\n\nAsserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\\[\\]’ and ‘.’ in property names can be escaped using double backslashes.\n\n``` javascript\nassert.nestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.[b]': 'x'});\nassert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'x'});\n```\n\n### .notNestedInclude(haystack, needle, \\[message\\])\n\n- @param { Object } haystack\n- @param { Object } needle\n- @param { String } message\n\nAsserts that ‘haystack’ does not include ‘needle’. Can be used to assert the absence of a subset of properties in an object. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\\[\\]’ and ‘.’ in property names can be escaped using double backslashes.\n\n``` javascript\nassert.notNestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.b': 'y'});\nassert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'y'});\n```\n\n### .deepNestedInclude(haystack, needle, \\[message\\])\n\n- @param { Object } haystack\n- @param { Object } needle\n- @param { String } message\n\nAsserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while checking for deep equality. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\\[\\]’ and ‘.’ in property names can be escaped using double backslashes.\n\n``` javascript\nassert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});\nassert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {x: 1}});\n```\n\n### .notDeepNestedInclude(haystack, needle, \\[message\\])\n\n- @param { Object } haystack\n- @param { Object } needle\n- @param { String } message\n\nAsserts that ‘haystack’ does not include ‘needle’. Can be used to assert the absence of a subset of properties in an object while checking for deep equality. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\\[\\]’ and ‘.’ in property names can be escaped using double backslashes.\n\n``` javascript\nassert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})\nassert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {y: 2}});\n```\n\n### .ownInclude(haystack, needle, \\[message\\])\n\n- @param { Object } haystack\n- @param { Object } needle\n- @param { String } message\n\nAsserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties.\n\n``` javascript\nassert.ownInclude({ a: 1 }, { a: 1 });\n```\n\n### .notOwnInclude(haystack, needle, \\[message\\])\n\n- @param { Object } haystack\n- @param { Object } needle\n- @param { String } message\n\nAsserts that ‘haystack’ includes ‘needle’. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties.\n\n``` javascript\nObject.prototype.b = 2;\n\nassert.notOwnInclude({ a: 1 }, { b: 2 });\n```\n\n### .deepOwnInclude(haystack, needle, \\[message\\])\n\n- @param { Object } haystack\n- @param { Object } needle\n- @param { String } message\n\nAsserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties and checking for deep equality.\n\n``` javascript\n assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});\n```\n\n### .notDeepOwnInclude(haystack, needle, \\[message\\])\n\n- @param { Object } haystack\n- @param { Object } needle\n- @param { String } message\n\nAsserts that ‘haystack’ includes ‘needle’. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties and checking for deep equality.\n\n``` javascript\n assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});\n```\n\n### .match(value, regexp, \\[message\\])\n\n- @param { Mixed } value\n- @param { RegExp } regexp\n- @param { String } message\n\nAsserts that `value` matches the regular expression `regexp`.\n\n``` javascript\nassert.match('foobar', /^foo/, 'regexp matches');\n```\n\n### .notMatch(value, regexp, \\[message\\])\n\n- @param { Mixed } value\n- @param { RegExp } regexp\n- @param { String } message\n\nAsserts that `value` does not match the regular expression `regexp`.\n\n``` javascript\nassert.notMatch('foobar', /^foo/, 'regexp does not match');\n```\n\n### .property(object, property, \\[message\\])\n\n- @param { Object } object\n- @param { String } property\n- @param { String } message\n\nAsserts that `object` has a direct or inherited property named by `property`.\n\n``` javascript\nassert.property({ tea: { green: 'matcha' }}, 'tea');\nassert.property({ tea: { green: 'matcha' }}, 'toString');\n```\n\n### .notProperty(object, property, \\[message\\])\n\n- @param { Object } object\n- @param { String } property\n- @param { String } message\n\nAsserts that `object` does *not* have a direct or inherited property named by `property`.\n\n``` javascript\nassert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\n```\n\n### .propertyVal(object, property, value, \\[message\\])\n\n- @param { Object } object\n- @param { String } property\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `object` has a direct or inherited property named by `property` with a value given by `value`. Uses a strict equality check (===).\n\n``` javascript\nassert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\n```\n\n### .notPropertyVal(object, property, value, \\[message\\])\n\n- @param { Object } object\n- @param { String } property\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `object` does *not* have a direct or inherited property named by `property` with value given by `value`. Uses a strict equality check (===).\n\n``` javascript\nassert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');\nassert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');\n```\n\n### .deepPropertyVal(object, property, value, \\[message\\])\n\n- @param { Object } object\n- @param { String } property\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `object` has a direct or inherited property named by `property` with a value given by `value`. Uses a deep equality check.\n\n``` javascript\nassert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });\n```\n\n### .notDeepPropertyVal(object, property, value, \\[message\\])\n\n- @param { Object } object\n- @param { String } property\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `object` does *not* have a direct or inherited property named by `property` with value given by `value`. Uses a deep equality check.\n\n``` javascript\nassert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });\nassert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });\nassert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });\n```\n\n### .nestedProperty(object, property, \\[message\\])\n\n- @param { Object } object\n- @param { String } property\n- @param { String } message\n\nAsserts that `object` has a direct or inherited property named by `property`, which can be a string using dot- and bracket-notation for nested reference.\n\n``` javascript\nassert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');\n```\n\n### .notNestedProperty(object, property, \\[message\\])\n\n- @param { Object } object\n- @param { String } property\n- @param { String } message\n\nAsserts that `object` does *not* have a property named by `property`, which can be a string using dot- and bracket-notation for nested reference. The property cannot exist on the object nor anywhere in its prototype chain.\n\n``` javascript\nassert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\n```\n\n### .nestedPropertyVal(object, property, value, \\[message\\])\n\n- @param { Object } object\n- @param { String } property\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `object` has a property named by `property` with value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a strict equality check (===).\n\n``` javascript\nassert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\n```\n\n### .notNestedPropertyVal(object, property, value, \\[message\\])\n\n- @param { Object } object\n- @param { String } property\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `object` does *not* have a property named by `property` with value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a strict equality check (===).\n\n``` javascript\nassert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\nassert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');\n```\n\n### .deepNestedPropertyVal(object, property, value, \\[message\\])\n\n- @param { Object } object\n- @param { String } property\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `object` has a property named by `property` with a value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a deep equality check.\n\n``` javascript\nassert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });\n```\n\n### .notDeepNestedPropertyVal(object, property, value, \\[message\\])\n\n- @param { Object } object\n- @param { String } property\n- @param { Mixed } value\n- @param { String } message\n\nAsserts that `object` does *not* have a property named by `property` with value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a deep equality check.\n\n``` javascript\nassert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });\nassert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });\nassert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });\n```\n\n### .lengthOf(object, length, \\[message\\])\n\n- @param { Mixed } object\n- @param { Number } length\n- @param { String } message\n\nAsserts that `object` has a `length` or `size` with the expected value.\n\n``` javascript\nassert.lengthOf([1,2,3], 3, 'array has length of 3');\nassert.lengthOf('foobar', 6, 'string has length of 6');\nassert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');\nassert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');\n```\n\n### .hasAnyKeys(object, \\[keys\\], \\[message\\])\n\n- @param { Mixed } object\n- @param { Array \\| Object } keys\n- @param { String } message\n\nAsserts that `object` has at least one of the `keys` provided. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.\n\n``` javascript\nassert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);\nassert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});\nassert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\nassert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);\n```\n\n### .hasAllKeys(object, \\[keys\\], \\[message\\])\n\n- @param { Mixed } object\n- @param { Array. } keys\n- @param { String } message\n\nAsserts that `object` has all and only all of the `keys` provided. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.\n\n``` javascript\nassert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);\nassert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);\nassert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\nassert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);\n```\n\n### .containsAllKeys(object, \\[keys\\], \\[message\\])\n\n- @param { Mixed } object\n- @param { Array. } keys\n- @param { String } message\n\nAsserts that `object` has all of the `keys` provided but may have more keys not listed. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.\n\n``` javascript\nassert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);\nassert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);\nassert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});\nassert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});\nassert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);\nassert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\nassert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);\nassert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);\n```\n\n### .doesNotHaveAnyKeys(object, \\[keys\\], \\[message\\])\n\n- @param { Mixed } object\n- @param { Array. } keys\n- @param { String } message\n\nAsserts that `object` has none of the `keys` provided. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.\n\n``` javascript\nassert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);\nassert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});\nassert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);\nassert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);\n```\n\n### .doesNotHaveAllKeys(object, \\[keys\\], \\[message\\])\n\n- @param { Mixed } object\n- @param { Array. } keys\n- @param { String } message\n\nAsserts that `object` does not have at least one of the `keys` provided. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.\n\n``` javascript\nassert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);\nassert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});\nassert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);\nassert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);\n```\n\n### .hasAnyDeepKeys(object, \\[keys\\], \\[message\\])\n\n- @param { Mixed } object\n- @param { Array \\| Object } keys\n- @param { String } message\n\nAsserts that `object` has at least one of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.\n\n``` javascript\nassert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});\nassert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);\nassert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\nassert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});\nassert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);\nassert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\n```\n\n### .hasAllDeepKeys(object, \\[keys\\], \\[message\\])\n\n- @param { Mixed } object\n- @param { Array \\| Object } keys\n- @param { String } message\n\nAsserts that `object` has all and only all of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.\n\n``` javascript\nassert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});\nassert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\nassert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});\nassert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\n```\n\n### .containsAllDeepKeys(object, \\[keys\\], \\[message\\])\n\n- @param { Mixed } object\n- @param { Array \\| Object } keys\n- @param { String } message\n\nAsserts that `object` contains all of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.\n\n``` javascript\nassert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});\nassert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\nassert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});\nassert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\n```\n\n### .doesNotHaveAnyDeepKeys(object, \\[keys\\], \\[message\\])\n\n- @param { Mixed } object\n- @param { Array \\| Object } keys\n- @param { String } message\n\nAsserts that `object` has none of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.\n\n``` javascript\nassert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});\nassert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);\nassert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});\nassert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);\n```\n\n### .doesNotHaveAllDeepKeys(object, \\[keys\\], \\[message\\])\n\n- @param { Mixed } object\n- @param { Array \\| Object } keys\n- @param { String } message\n\nAsserts that `object` does not have at least one of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.\n\n``` javascript\nassert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});\nassert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);\nassert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});\nassert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);\n```\n\n### .throws(fn, \\[errorLike/string/regexp\\], \\[string/regexp\\], \\[message\\])\n\n- @param { Function } fn\n- @param { ErrorConstructor \\| Error } errorLike\n- @param { RegExp \\| String } errMsgMatcher\n- @param { String } message\n- @see [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types)\n\nIf `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an instance of `errorLike`. If `errorLike` is an `Error` instance, asserts that the error thrown is the same instance as `errorLike`. If `errMsgMatcher` is provided, it also asserts that the error thrown will have a message matching `errMsgMatcher`.\n\n``` javascript\nassert.throws(fn, 'Error thrown must have this msg');\nassert.throws(fn, /Error thrown must have a msg that matches this/);\nassert.throws(fn, ReferenceError);\nassert.throws(fn, errorInstance);\nassert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');\nassert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');\nassert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);\nassert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);\n```\n\n### .doesNotThrow(fn, \\[errorLike/string/regexp\\], \\[string/regexp\\], \\[message\\])\n\n- @param { Function } fn\n- @param { ErrorConstructor } errorLike\n- @param { RegExp \\| String } errMsgMatcher\n- @param { String } message\n- @see [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types)\n\nIf `errorLike` is an `Error` constructor, asserts that `fn` will *not* throw an error that is an instance of `errorLike`. If `errorLike` is an `Error` instance, asserts that the error thrown is *not* the same instance as `errorLike`. If `errMsgMatcher` is provided, it also asserts that the error thrown will *not* have a message matching `errMsgMatcher`.\n\n``` javascript\nassert.doesNotThrow(fn, 'Any Error thrown must not have this message');\nassert.doesNotThrow(fn, /Any Error thrown must not match this/);\nassert.doesNotThrow(fn, Error);\nassert.doesNotThrow(fn, errorInstance);\nassert.doesNotThrow(fn, Error, 'Error must not have this message');\nassert.doesNotThrow(fn, errorInstance, 'Error must not have this message');\nassert.doesNotThrow(fn, Error, /Error must not match this/);\nassert.doesNotThrow(fn, errorInstance, /Error must not match this/);\n```\n\n### .operator(val1, operator, val2, \\[message\\])\n\n- @param { Mixed } val1\n- @param { String } operator\n- @param { Mixed } val2\n- @param { String } message\n\nCompares two values using `operator`.\n\n``` javascript\nassert.operator(1, '<', 2, 'everything is ok');\nassert.operator(1, '>', 2, 'this will fail');\n```\n\n### .closeTo(actual, expected, delta, \\[message\\])\n\n- @param { Number } actual\n- @param { Number } expected\n- @param { Number } delta\n- @param { String } message\n\nAsserts that the target is equal `expected`, to within a +/- `delta` range.\n\n``` javascript\nassert.closeTo(1.5, 1, 0.5, 'numbers are close');\n```\n\n### .approximately(actual, expected, delta, \\[message\\])\n\n- @param { Number } actual\n- @param { Number } expected\n- @param { Number } delta\n- @param { String } message\n\nAsserts that the target is equal `expected`, to within a +/- `delta` range.\n\n``` javascript\nassert.approximately(1.5, 1, 0.5, 'numbers are close');\n```\n\n### .sameMembers(set1, set2, \\[message\\])\n\n- @param { Array } set1\n- @param { Array } set2\n- @param { String } message\n\nAsserts that `set1` and `set2` have the same members in any order. Uses a strict equality check (===).\n\n``` javascript\nassert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');\n```\n\n### .notSameMembers(set1, set2, \\[message\\])\n\n- @param { Array } set1\n- @param { Array } set2\n- @param { String } message\n\nAsserts that `set1` and `set2` don’t have the same members in any order. Uses a strict equality check (===).\n\n``` javascript\nassert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');\n```\n\n### .sameDeepMembers(set1, set2, \\[message\\])\n\n- @param { Array } set1\n- @param { Array } set2\n- @param { String } message\n\nAsserts that `set1` and `set2` have the same members in any order. Uses a deep equality check.\n\n``` javascript\nassert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');\n```\n\n### .notSameDeepMembers(set1, set2, \\[message\\])\n\n- @param { Array } set1\n- @param { Array } set2\n- @param { String } message\n\nAsserts that `set1` and `set2` don’t have the same members in any order. Uses a deep equality check.\n\n``` javascript\nassert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');\n```\n\n### .sameOrderedMembers(set1, set2, \\[message\\])\n\n- @param { Array } set1\n- @param { Array } set2\n- @param { String } message\n\nAsserts that `set1` and `set2` have the same members in the same order. Uses a strict equality check (===).\n\n``` javascript\nassert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');\n```\n\n### .notSameOrderedMembers(set1, set2, \\[message\\])\n\n- @param { Array } set1\n- @param { Array } set2\n- @param { String } message\n\nAsserts that `set1` and `set2` don’t have the same members in the same order. Uses a strict equality check (===).\n\n``` javascript\nassert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');\n```\n\n### .sameDeepOrderedMembers(set1, set2, \\[message\\])\n\n- @param { Array } set1\n- @param { Array } set2\n- @param { String } message\n\nAsserts that `set1` and `set2` have the same members in the same order. Uses a deep equality check.\n\n``` javascript\nassert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');\n```\n\n### .notSameDeepOrderedMembers(set1, set2, \\[message\\])\n\n- @param { Array } set1\n- @param { Array } set2\n- @param { String } message\n\nAsserts that `set1` and `set2` don’t have the same members in the same order. Uses a deep equality check.\n\n``` javascript\nassert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');\nassert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');\n```\n\n### .includeMembers(superset, subset, \\[message\\])\n\n- @param { Array } superset\n- @param { Array } subset\n- @param { String } message\n\nAsserts that `subset` is included in `superset` in any order. Uses a strict equality check (===). Duplicates are ignored.\n\n``` javascript\nassert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');\n```\n\n### .notIncludeMembers(superset, subset, \\[message\\])\n\n- @param { Array } superset\n- @param { Array } subset\n- @param { String } message\n\nAsserts that `subset` isn’t included in `superset` in any order. Uses a strict equality check (===). Duplicates are ignored.\n\n``` javascript\nassert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');\n```\n\n### .includeDeepMembers(superset, subset, \\[message\\])\n\n- @param { Array } superset\n- @param { Array } subset\n- @param { String } message\n\nAsserts that `subset` is included in `superset` in any order. Uses a deep equality check. Duplicates are ignored.\n\n``` javascript\nassert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');\n```\n\n### .notIncludeDeepMembers(superset, subset, \\[message\\])\n\n- @param { Array } superset\n- @param { Array } subset\n- @param { String } message\n\nAsserts that `subset` isn’t included in `superset` in any order. Uses a deep equality check. Duplicates are ignored.\n\n``` javascript\nassert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');\n```\n\n### .includeOrderedMembers(superset, subset, \\[message\\])\n\n- @param { Array } superset\n- @param { Array } subset\n- @param { String } message\n\nAsserts that `subset` is included in `superset` in the same order beginning with the first element in `superset`. Uses a strict equality check (===).\n\n``` javascript\nassert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');\n```\n\n### .notIncludeOrderedMembers(superset, subset, \\[message\\])\n\n- @param { Array } superset\n- @param { Array } subset\n- @param { String } message\n\nAsserts that `subset` isn’t included in `superset` in the same order beginning with the first element in `superset`. Uses a strict equality check (===).\n\n``` javascript\nassert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');\nassert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');\n```\n\n### .includeDeepOrderedMembers(superset, subset, \\[message\\])\n\n- @param { Array } superset\n- @param { Array } subset\n- @param { String } message\n\nAsserts that `subset` is included in `superset` in the same order beginning with the first element in `superset`. Uses a deep equality check.\n\n``` javascript\nassert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');\n```\n\n### .notIncludeDeepOrderedMembers(superset, subset, \\[message\\])\n\n- @param { Array } superset\n- @param { Array } subset\n- @param { String } message\n\nAsserts that `subset` isn’t included in `superset` in the same order beginning with the first element in `superset`. Uses a deep equality check.\n\n``` javascript\nassert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');\nassert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');\nassert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');\n```\n\n### .oneOf(inList, list, \\[message\\])\n\n- @param { } inList\n- @param { Array. } list\n- @param { String } message\n\nAsserts that non-object, non-array value `inList` appears in the flat array `list`.\n\n``` javascript\nassert.oneOf(1, [ 2, 1 ], 'Not found in list');\n```\n\n### .changes(function, object, property, \\[message\\])\n\n- @param { Function } modifier function\n- @param { Object } object or getter function\n- @param { String } property name \\_optional\\_\n- @param { String } message \\_optional\\_\n\nAsserts that a function changes the value of a property.\n\n``` javascript\nvar obj = { val: 10 };\nvar fn = function() { obj.val = 22 };\nassert.changes(fn, obj, 'val');\n```\n\n### .changesBy(function, object, property, delta, \\[message\\])\n\n- @param { Function } modifier function\n- @param { Object } object or getter function\n- @param { String } property name \\_optional\\_\n- @param { Number } change amount (delta)\n- @param { String } message \\_optional\\_\n\nAsserts that a function changes the value of a property by an amount (delta).\n\n``` javascript\nvar obj = { val: 10 };\nvar fn = function() { obj.val += 2 };\nassert.changesBy(fn, obj, 'val', 2);\n```\n\n### .doesNotChange(function, object, property, \\[message\\])\n\n- @param { Function } modifier function\n- @param { Object } object or getter function\n- @param { String } property name \\_optional\\_\n- @param { String } message \\_optional\\_\n\nAsserts that a function does not change the value of a property.\n\n``` javascript\nvar obj = { val: 10 };\nvar fn = function() { console.log('foo'); };\nassert.doesNotChange(fn, obj, 'val');\n```\n\n### .changesButNotBy(function, object, property, delta, \\[message\\])\n\n- @param { Function } modifier function\n- @param { Object } object or getter function\n- @param { String } property name \\_optional\\_\n- @param { Number } change amount (delta)\n- @param { String } message \\_optional\\_\n\nAsserts that a function does not change the value of a property or of a function’s return value by an amount (delta)\n\n``` javascript\nvar obj = { val: 10 };\nvar fn = function() { obj.val += 10 };\nassert.changesButNotBy(fn, obj, 'val', 5);\n```\n\n### .increases(function, object, property, \\[message\\])\n\n- @param { Function } modifier function\n- @param { Object } object or getter function\n- @param { String } property name \\_optional\\_\n- @param { String } message \\_optional\\_\n\nAsserts that a function increases a numeric object property.\n\n``` javascript\nvar obj = { val: 10 };\nvar fn = function() { obj.val = 13 };\nassert.increases(fn, obj, 'val');\n```\n\n### .increasesBy(function, object, property, delta, \\[message\\])\n\n- @param { Function } modifier function\n- @param { Object } object or getter function\n- @param { String } property name \\_optional\\_\n- @param { Number } change amount (delta)\n- @param { String } message \\_optional\\_\n\nAsserts that a function increases a numeric object property or a function’s return value by an amount (delta).\n\n``` javascript\nvar obj = { val: 10 };\nvar fn = function() { obj.val += 10 };\nassert.increasesBy(fn, obj, 'val', 10);\n```\n\n### .doesNotIncrease(function, object, property, \\[message\\])\n\n- @param { Function } modifier function\n- @param { Object } object or getter function\n- @param { String } property name \\_optional\\_\n- @param { String } message \\_optional\\_\n\nAsserts that a function does not increase a numeric object property.\n\n``` javascript\nvar obj = { val: 10 };\nvar fn = function() { obj.val = 8 };\nassert.doesNotIncrease(fn, obj, 'val');\n```\n\n### .increasesButNotBy(function, object, property, delta, \\[message\\])\n\n- @param { Function } modifier function\n- @param { Object } object or getter function\n- @param { String } property name \\_optional\\_\n- @param { Number } change amount (delta)\n- @param { String } message \\_optional\\_\n\nAsserts that a function does not increase a numeric object property or function’s return value by an amount (delta).\n\n``` javascript\nvar obj = { val: 10 };\nvar fn = function() { obj.val = 15 };\nassert.increasesButNotBy(fn, obj, 'val', 10);\n```\n\n### .decreases(function, object, property, \\[message\\])\n\n- @param { Function } modifier function\n- @param { Object } object or getter function\n- @param { String } property name \\_optional\\_\n- @param { String } message \\_optional\\_\n\nAsserts that a function decreases a numeric object property.\n\n``` javascript\nvar obj = { val: 10 };\nvar fn = function() { obj.val = 5 };\nassert.decreases(fn, obj, 'val');\n```\n\n### .decreasesBy(function, object, property, delta, \\[message\\])\n\n- @param { Function } modifier function\n- @param { Object } object or getter function\n- @param { String } property name \\_optional\\_\n- @param { Number } change amount (delta)\n- @param { String } message \\_optional\\_\n\nAsserts that a function decreases a numeric object property or a function’s return value by an amount (delta)\n\n``` javascript\nvar obj = { val: 10 };\nvar fn = function() { obj.val -= 5 };\nassert.decreasesBy(fn, obj, 'val', 5);\n```\n\n### .doesNotDecrease(function, object, property, \\[message\\])\n\n- @param { Function } modifier function\n- @param { Object } object or getter function\n- @param { String } property name \\_optional\\_\n- @param { String } message \\_optional\\_\n\nAsserts that a function does not decreases a numeric object property.\n\n``` javascript\nvar obj = { val: 10 };\nvar fn = function() { obj.val = 15 };\nassert.doesNotDecrease(fn, obj, 'val');\n```\n\n### .doesNotDecreaseBy(function, object, property, delta, \\[message\\])\n\n- @param { Function } modifier function\n- @param { Object } object or getter function\n- @param { String } property name \\_optional\\_\n- @param { Number } change amount (delta)\n- @param { String } message \\_optional\\_\n\nAsserts that a function does not decreases a numeric object property or a function’s return value by an amount (delta)\n\n``` javascript\nvar obj = { val: 10 };\nvar fn = function() { obj.val = 5 };\nassert.doesNotDecreaseBy(fn, obj, 'val', 1);\n```\n\n### .decreasesButNotBy(function, object, property, delta, \\[message\\])\n\n- @param { Function } modifier function\n- @param { Object } object or getter function\n- @param { String } property name \\_optional\\_\n- @param { Number } change amount (delta)\n- @param { String } message \\_optional\\_\n\nAsserts that a function does not decreases a numeric object property or a function’s return value by an amount (delta)\n\n``` javascript\nvar obj = { val: 10 };\nvar fn = function() { obj.val = 5 };\nassert.decreasesButNotBy(fn, obj, 'val', 1);\n```\n\n### .ifError(object)\n\n- @param { Object } object\n\nAsserts if value is not a false value, and throws if it is a true value. This is added to allow for chai to be a drop-in replacement for Node’s assert class.\n\n``` javascript\nvar err = new Error('I am a custom error');\nassert.ifError(err); // Rethrows err!\n```\n\n### .isExtensible(object)\n\n- @param { Object } object\n- @param { String } message \\_optional\\_\n\nAsserts that `object` is extensible (can have new properties added to it).\n\n``` javascript\nassert.isExtensible({});\n```\n\n### .isNotExtensible(object)\n\n- @param { Object } object\n- @param { String } message \\_optional\\_\n\nAsserts that `object` is *not* extensible.\n\n``` javascript\nvar nonExtensibleObject = Object.preventExtensions({});\nvar sealedObject = Object.seal({});\nvar frozenObject = Object.freeze({});\n\nassert.isNotExtensible(nonExtensibleObject);\nassert.isNotExtensible(sealedObject);\nassert.isNotExtensible(frozenObject);\n```\n\n### .isSealed(object)\n\n- @param { Object } object\n- @param { String } message \\_optional\\_\n\nAsserts that `object` is sealed (cannot have new properties added to it and its existing properties cannot be removed).\n\n``` javascript\nvar sealedObject = Object.seal({});\nvar frozenObject = Object.seal({});\n\nassert.isSealed(sealedObject);\nassert.isSealed(frozenObject);\n```\n\n### .isNotSealed(object)\n\n- @param { Object } object\n- @param { String } message \\_optional\\_\n\nAsserts that `object` is *not* sealed.\n\n``` javascript\nassert.isNotSealed({});\n```\n\n### .isFrozen(object)\n\n- @param { Object } object\n- @param { String } message \\_optional\\_\n\nAsserts that `object` is frozen (cannot have new properties added to it and its existing properties cannot be modified).\n\n``` javascript\nvar frozenObject = Object.freeze({});\nassert.frozen(frozenObject);\n```\n\n### .isNotFrozen(object)\n\n- @param { Object } object\n- @param { String } message \\_optional\\_\n\nAsserts that `object` is *not* frozen.\n\n``` javascript\nassert.isNotFrozen({});\n```\n\n### .isEmpty(target)\n\n- @param { Object \\| Array \\| String \\| Map \\| Set } target\n- @param { String } message \\_optional\\_\n\nAsserts that the target does not contain any values. For arrays and strings, it checks the `length` property. For `Map` and `Set` instances, it checks the `size` property. For non-function objects, it gets the count of own enumerable string keys.\n\n``` javascript\nassert.isEmpty([]);\nassert.isEmpty('');\nassert.isEmpty(new Map);\nassert.isEmpty({});\n```\n\n### .isNotEmpty(target)\n\n- @param { Object \\| Array \\| String \\| Map \\| Set } target\n- @param { String } message \\_optional\\_\n\nAsserts that the target contains values. For arrays and strings, it checks the `length` property. For `Map` and `Set` instances, it checks the `size` property. For non-function objects, it gets the count of own enumerable string keys.\n\n``` javascript\nassert.isNotEmpty([1, 2]);\nassert.isNotEmpty('34');\nassert.isNotEmpty(new Set([5, 6]));\nassert.isNotEmpty({ key: 7 });\n```\n\n© 2017 Chai.js Assertion Library  \nLicensed under the MIT License.  \n[https://www.chaijs.com/api/assert/](https://www.chaijs.com/api/assert/)"
- name: assert
  id: api/assert/index#method_assert
  summary: Write your own test expressions
  belongs_to: Assert
  description: |-
    ### assert(expression, message)

    - @param { Mixed } expression to test for truthiness
    - @param { String } message to display on error

    Write your own test expressions.

    ``` javascript
    assert('foo' !== 'bar', 'foo is not bar');
    assert(Array.isArray([]), 'empty arrays are arrays');
    ```
- name: Assertion Styles
  id: guide/styles/index
  summary: This section of the guide introduces you to the three different assertion styles that you may use in your testing environment
  description: "# Assertion Styles\n\nThis section of the guide introduces you to the three different assertion styles that you may use in your testing environment. Once you have made your selection, it is recommended that you look at the API Documentation for your selected style.\n\n## Assert\n\n[View full Assert API](../../api/assert/index)\n\nThe assert style is exposed through `assert` interface. This provides the classic assert-dot notation, similar to that packaged with node.js. This assert module, however, provides several additional tests and is browser compatible.\n\n``` javascript\nvar assert = require('chai').assert\n  , foo = 'bar'\n  , beverages = { tea: [ 'chai', 'matcha', 'oolong' ] };\n\nassert.typeOf(foo, 'string'); // without optional message\nassert.typeOf(foo, 'string', 'foo is a string'); // with optional message\nassert.equal(foo, 'bar', 'foo equal `bar`');\nassert.lengthOf(foo, 3, 'foo`s value has a length of 3');\nassert.lengthOf(beverages.tea, 3, 'beverages has 3 types of tea');\n```\n\nIn all cases, the assert style allows you to include an optional message as the last parameter in the `assert` statement. These will be included in the error messages should your assertion not pass.\n\n## BDD\n\n[View full BDD API](../../api/bdd/index)\n\nThe BDD style comes in two flavors: `expect` and `should`. Both use the same chainable language to construct assertions, but they differ in the way an assertion is initially constructed. In the case of `should`, there are also some caveats and additional tools to overcome the caveats.\n\n### Expect\n\nThe BDD style is exposed through `expect` or `should` interfaces. In both scenarios, you chain together natural language assertions.\n\n``` javascript\nvar expect = require('chai').expect\n  , foo = 'bar'\n  , beverages = { tea: [ 'chai', 'matcha', 'oolong' ] };\n\nexpect(foo).to.be.a('string');\nexpect(foo).to.equal('bar');\nexpect(foo).to.have.lengthOf(3);\nexpect(beverages).to.have.property('tea').with.lengthOf(3);\n```\n\nExpect also allows you to include arbitrary messages to prepend to any failed assertions that might occur.\n\n``` javascript\nvar answer = 43;\n\n// AssertionError: expected 43 to equal 42.\nexpect(answer).to.equal(42);\n\n// AssertionError: topic [answer]: expected 43 to equal 42.\nexpect(answer, 'topic [answer]').to.equal(42);\n```\n\nThis comes in handy when being used with non-descript topics such as booleans or numbers.\n\n### Should\n\nThe `should` style allows for the same chainable assertions as the `expect` interface, however it extends each object with a `should` property to start your chain. This style has some issues when used with Internet Explorer, so be aware of browser compatibility.\n\n``` javascript\nvar should = require('chai').should() //actually call the function\n  , foo = 'bar'\n  , beverages = { tea: [ 'chai', 'matcha', 'oolong' ] };\n\nfoo.should.be.a('string');\nfoo.should.equal('bar');\nfoo.should.have.lengthOf(3);\nbeverages.should.have.property('tea').with.lengthOf(3);\n```\n\n### Differences\n\nFirst of all, notice that the `expect` require is just a reference to the `expect` function, whereas with the `should` require, the function is being executed.\n\n``` javascript\nvar chai = require('chai')\n  , expect = chai.expect\n  , should = chai.should();\n```\n\nThe `expect` interface provides a function as a starting point for chaining your language assertions. It works on node.js and in all browsers.\n\nThe `should` interface extends `Object``.``prototype` to provide a single getter as the starting point for your language assertions. It works on node.js and in all modern browsers except Internet Explorer.\n\n### Should Extras\n\nGiven that `should` works by extending `Object``.``prototype`, there are some scenarios where `should` will not work. Mainly, if you are trying to check the existence of an object. Take the following pseudocode:\n\n``` javascript\ndb.get(1234, function (err, doc) {\n  // we expect error to not exist\n  // we expect doc to exist and be an object\n});\n```\n\nGiven that `err` should be null or undefined, `err``.``should``.``not``.``exist` is not a valid statement as `undefined` and `null` haven’t been extended with a `should` chain starter. As such, the appropriate few assertions for this scenario are as follows:\n\n``` javascript\nvar should = require('chai').should();\ndb.get(1234, function (err, doc) {\n  should.not.exist(err);\n  should.exist(doc);\n  doc.should.be.an('object');\n});\n```\n\nProvided you assigned `should` to a var, you have access to several quick helpers to keep you out of trouble when using `should`.\n\n- `should``.``exist`\n- `should``.``not``.``exist`\n- `should``.``equal`\n- `should``.``not``.``equal`\n- `should``.``Throw`\n- `should``.``not``.``Throw`\n\n### Using Should in ES2015\n\nIt isn’t possible to chain a function call from an ES2015 `import` statement – it has to go on its own line, which looks a little verbose:\n\n``` javascript\nimport chai from 'chai';\nchai.should();\n```\n\nFor a cleaner look, you can do this instead:\n\n``` javascript\nimport 'chai/register-should';\n```\n\n## Configuration\n\n### config.includeStack\n\n- **@param** *{Boolean}*\n- **@default** `false`\n\nUser configurable property, influences whether stack trace is included in Assertion error message. Default of `false` suppresses stack trace in the error message.\n\n``` javascript\nchai.config.includeStack = true; // turn on stack trace\n```\n\n### config.showDiff\n\n- **@param** *{Boolean}*\n- **@default** `true`\n\nUser configurable property, influences whether or not the `showDiff` flag should be included in the thrown AssertionErrors. `false` will always be `false`; `true` will be true when the assertion has requested a diff be shown.\n\n``` javascript\nchai.config.showDiff = false; // turn off reporter diff display\n```\n\n### config.truncateThreshold\n\n- **@param** *{Number}*\n- **@default** `40`\n\nUser configurable property, sets length threshold for actual and expected values in assertion errors. If this threshold is exceeded, the value is truncated.\n\nSet it to zero if you want to disable truncating altogether.\n\n``` javascript\nchai.config.truncateThreshold = 0; // disable truncating\n```\n\n© 2017 Chai.js Assertion Library  \nLicensed under the MIT License.  \n[https://www.chaijs.com/guide/styles/](https://www.chaijs.com/guide/styles/)"
- name: BDD
  id: api/bdd/index
  summary: The BDD styles are expect and should
  description: "# BDD\n\nThe BDD styles are `expect` and `should`. Both use the same chainable language to construct assertions, but they differ in the way an assertion is initially constructed. Check out the [Style Guide](../../guide/styles/index) for a comparison.\n\n## API Reference\n\n### Language Chains\n\nThe following are provided as chainable getters to improve the readability of your assertions.\n\n**Chains**\n\n- to\n- be\n- been\n- is\n- that\n- which\n- and\n- has\n- have\n- with\n- at\n- of\n- same\n- but\n- does\n- still\n- also\n\n### .not\n\nNegates all assertions that follow in the chain.\n\n``` javascript\nexpect(function () {}).to.not.throw();\nexpect({a: 1}).to.not.have.property('b');\nexpect([1, 2]).to.be.an('array').that.does.not.include(3);\n```\n\nJust because you can negate any assertion with `.``not` doesn’t mean you should. With great power comes great responsibility. It’s often best to assert that the one expected output was produced, rather than asserting that one of countless unexpected outputs wasn’t produced. See individual assertions for specific guidance.\n\n``` javascript\nexpect(2).to.equal(2); // Recommended\nexpect(2).to.not.equal(1); // Not recommended\n```\n\n### .deep\n\nCauses all `.``equal`, `.``include`, `.``members`, `.``keys`, and `.``property` assertions that follow in the chain to use deep equality instead of strict (`===`) equality. See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n\n``` javascript\n// Target object deeply (but not strictly) equals `{a: 1}`\nexpect({a: 1}).to.deep.equal({a: 1});\nexpect({a: 1}).to.not.equal({a: 1});\n\n// Target array deeply (but not strictly) includes `{a: 1}`\nexpect([{a: 1}]).to.deep.include({a: 1});\nexpect([{a: 1}]).to.not.include({a: 1});\n\n// Target object deeply (but not strictly) includes `x: {a: 1}`\nexpect({x: {a: 1}}).to.deep.include({x: {a: 1}});\nexpect({x: {a: 1}}).to.not.include({x: {a: 1}});\n\n// Target array deeply (but not strictly) has member `{a: 1}`\nexpect([{a: 1}]).to.have.deep.members([{a: 1}]);\nexpect([{a: 1}]).to.not.have.members([{a: 1}]);\n\n// Target set deeply (but not strictly) has key `{a: 1}`\nexpect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);\nexpect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);\n\n// Target object deeply (but not strictly) has property `x: {a: 1}`\nexpect({x: {a: 1}}).to.have.deep.property('x', {a: 1});\nexpect({x: {a: 1}}).to.not.have.property('x', {a: 1});\n```\n\n### .nested\n\nEnables dot- and bracket-notation in all `.``property` and `.``include` assertions that follow in the chain.\n\n``` javascript\nexpect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');\nexpect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});\n```\n\nIf `.` or `[]` are part of an actual property name, they can be escaped by adding two backslashes before them.\n\n``` javascript\nexpect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');\nexpect({'.a': {'[b]': 'x'}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 'x'});\n```\n\n`.``nested` cannot be combined with `.``own`.\n\n### .own\n\nCauses all `.``property` and `.``include` assertions that follow in the chain to ignore inherited properties.\n\n``` javascript\nObject.prototype.b = 2;\n\nexpect({a: 1}).to.have.own.property('a');\nexpect({a: 1}).to.have.property('b');\nexpect({a: 1}).to.not.have.own.property('b');\n\nexpect({a: 1}).to.own.include({a: 1});\nexpect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});\n```\n\n`.``own` cannot be combined with `.``nested`.\n\n### .ordered\n\nCauses all `.``members` assertions that follow in the chain to require that members be in the same order.\n\n``` javascript\nexpect([1, 2]).to.have.ordered.members([1, 2])\n  .but.not.have.ordered.members([2, 1]);\n```\n\nWhen `.``include` and `.``ordered` are combined, the ordering begins at the start of both arrays.\n\n``` javascript\nexpect([1, 2, 3]).to.include.ordered.members([1, 2])\n  .but.not.include.ordered.members([2, 3]);\n```\n\n### .any\n\nCauses all `.``keys` assertions that follow in the chain to only require that the target have at least one of the given keys. This is the opposite of `.``all`, which requires that the target have all of the given keys.\n\n``` javascript\nexpect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');\n```\n\nSee the `.``keys` doc for guidance on when to use `.``any` or `.``all`.\n\n### .all\n\nCauses all `.``keys` assertions that follow in the chain to require that the target have all of the given keys. This is the opposite of `.``any`, which only requires that the target have at least one of the given keys.\n\n``` javascript\nexpect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n```\n\nNote that `.``all` is used by default when neither `.``all` nor `.``any` are added earlier in the chain. However, it’s often best to add `.``all` anyway because it improves readability.\n\nSee the `.``keys` doc for guidance on when to use `.``any` or `.``all`.\n\n### .a(type\\[, msg\\])\n\n- @param { String } type\n- @param { String } msg \\_optional\\_\n\nAsserts that the target’s type is equal to the given string `type`. Types are case insensitive. See the `type``-``detect` project page for info on the type detection algorithm: https://github.com/chaijs/type-detect.\n\n``` javascript\nexpect('foo').to.be.a('string');\nexpect({a: 1}).to.be.an('object');\nexpect(null).to.be.a('null');\nexpect(undefined).to.be.an('undefined');\nexpect(new Error).to.be.an('error');\nexpect(Promise.resolve()).to.be.a('promise');\nexpect(new Float32Array).to.be.a('float32array');\nexpect(Symbol()).to.be.a('symbol');\n```\n\n`.``a` supports objects that have a custom type set via `Symbol``.``toStringTag`.\n\n``` javascript\nvar myObj = {\n  [Symbol.toStringTag]: 'myCustomType'\n};\n\nexpect(myObj).to.be.a('myCustomType').but.not.an('object');\n```\n\nIt’s often best to use `.``a` to check a target’s type before making more assertions on the same target. That way, you avoid unexpected behavior from any assertion that does different things based on the target’s type.\n\n``` javascript\nexpect([1, 2, 3]).to.be.an('array').that.includes(2);\nexpect([]).to.be.an('array').that.is.empty;\n```\n\nAdd `.``not` earlier in the chain to negate `.``a`. However, it’s often best to assert that the target is the expected type, rather than asserting that it isn’t one of many unexpected types.\n\n``` javascript\nexpect('foo').to.be.a('string'); // Recommended\nexpect('foo').to.not.be.an('array'); // Not recommended\n```\n\n`.``a` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect(1).to.be.a('string', 'nooo why fail??');\nexpect(1, 'nooo why fail??').to.be.a('string');\n```\n\n`.``a` can also be used as a language chain to improve the readability of your assertions.\n\n``` javascript\nexpect({b: 2}).to.have.a.property('b');\n```\n\nThe alias `.``an` can be used interchangeably with `.``a`.\n\n### .include(val\\[, msg\\])\n\n- @param { Mixed } val\n- @param { String } msg \\_optional\\_\n\nWhen the target is a string, `.``include` asserts that the given string `val` is a substring of the target.\n\n``` javascript\nexpect('foobar').to.include('foo');\n```\n\nWhen the target is an array, `.``include` asserts that the given `val` is a member of the target.\n\n``` javascript\nexpect([1, 2, 3]).to.include(2);\n```\n\nWhen the target is an object, `.``include` asserts that the given object `val`’s properties are a subset of the target’s properties.\n\n``` javascript\nexpect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});\n```\n\nWhen the target is a Set or WeakSet, `.``include` asserts that the given `val` is a member of the target. SameValueZero equality algorithm is used.\n\n``` javascript\nexpect(new Set([1, 2])).to.include(2);\n```\n\nWhen the target is a Map, `.``include` asserts that the given `val` is one of the values of the target. SameValueZero equality algorithm is used.\n\n``` javascript\nexpect(new Map([['a', 1], ['b', 2]])).to.include(2);\n```\n\nBecause `.``include` does different things based on the target’s type, it’s important to check the target’s type before using `.``include`. See the `.``a` doc for info on testing a target’s type.\n\n``` javascript\nexpect([1, 2, 3]).to.be.an('array').that.includes(2);\n```\n\nBy default, strict (`===`) equality is used to compare array members and object properties. Add `.``deep` earlier in the chain to use deep equality instead (WeakSet targets are not supported). See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n\n``` javascript\n// Target array deeply (but not strictly) includes `{a: 1}`\nexpect([{a: 1}]).to.deep.include({a: 1});\nexpect([{a: 1}]).to.not.include({a: 1});\n\n// Target object deeply (but not strictly) includes `x: {a: 1}`\nexpect({x: {a: 1}}).to.deep.include({x: {a: 1}});\nexpect({x: {a: 1}}).to.not.include({x: {a: 1}});\n```\n\nBy default, all of the target’s properties are searched when working with objects. This includes properties that are inherited and/or non-enumerable. Add `.``own` earlier in the chain to exclude the target’s inherited properties from the search.\n\n``` javascript\nObject.prototype.b = 2;\n\nexpect({a: 1}).to.own.include({a: 1});\nexpect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});\n```\n\nNote that a target object is always only searched for `val`’s own enumerable properties.\n\n`.``deep` and `.``own` can be combined.\n\n``` javascript\nexpect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});\n```\n\nAdd `.``nested` earlier in the chain to enable dot- and bracket-notation when referencing nested properties.\n\n``` javascript\nexpect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});\n```\n\nIf `.` or `[]` are part of an actual property name, they can be escaped by adding two backslashes before them.\n\n``` javascript\nexpect({'.a': {'[b]': 2}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 2});\n```\n\n`.``deep` and `.``nested` can be combined.\n\n``` javascript\nexpect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});\n```\n\n`.``own` and `.``nested` cannot be combined.\n\nAdd `.``not` earlier in the chain to negate `.``include`.\n\n``` javascript\nexpect('foobar').to.not.include('taco');\nexpect([1, 2, 3]).to.not.include(4);\n```\n\nHowever, it’s dangerous to negate `.``include` when the target is an object. The problem is that it creates uncertain expectations by asserting that the target object doesn’t have all of `val`’s key/value pairs but may or may not have some of them. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.\n\nWhen the target object isn’t even expected to have `val`’s keys, it’s often best to assert exactly that.\n\n``` javascript\nexpect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended\nexpect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended\n```\n\nWhen the target object is expected to have `val`’s keys, it’s often best to assert that each of the properties has its expected value, rather than asserting that each property doesn’t have one of many unexpected values.\n\n``` javascript\nexpect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended\nexpect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended\n```\n\n`.``include` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect([1, 2, 3]).to.include(4, 'nooo why fail??');\nexpect([1, 2, 3], 'nooo why fail??').to.include(4);\n```\n\n`.``include` can also be used as a language chain, causing all `.``members` and `.``keys` assertions that follow in the chain to require the target to be a superset of the expected set, rather than an identical set. Note that `.``members` ignores duplicates in the subset when `.``include` is added.\n\n``` javascript\n// Target object's keys are a superset of ['a', 'b'] but not identical\nexpect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');\nexpect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');\n\n// Target array is a superset of [1, 2] but not identical\nexpect([1, 2, 3]).to.include.members([1, 2]);\nexpect([1, 2, 3]).to.not.have.members([1, 2]);\n\n// Duplicates in the subset are ignored\nexpect([1, 2, 3]).to.include.members([1, 2, 2, 2]);\n```\n\nNote that adding `.``any` earlier in the chain causes the `.``keys` assertion to ignore `.``include`.\n\n``` javascript\n// Both assertions are identical\nexpect({a: 1}).to.include.any.keys('a', 'b');\nexpect({a: 1}).to.have.any.keys('a', 'b');\n```\n\nThe aliases `.``includes`, `.``contain`, and `.``contains` can be used interchangeably with `.``include`.\n\n### .ok\n\nAsserts that the target is a truthy value (considered `true` in boolean context). However, it’s often best to assert that the target is strictly (`===`) or deeply equal to its expected value.\n\n``` javascript\nexpect(1).to.equal(1); // Recommended\nexpect(1).to.be.ok; // Not recommended\n\nexpect(true).to.be.true; // Recommended\nexpect(true).to.be.ok; // Not recommended\n```\n\nAdd `.``not` earlier in the chain to negate `.``ok`.\n\n``` javascript\nexpect(0).to.equal(0); // Recommended\nexpect(0).to.not.be.ok; // Not recommended\n\nexpect(false).to.be.false; // Recommended\nexpect(false).to.not.be.ok; // Not recommended\n\nexpect(null).to.be.null; // Recommended\nexpect(null).to.not.be.ok; // Not recommended\n\nexpect(undefined).to.be.undefined; // Recommended\nexpect(undefined).to.not.be.ok; // Not recommended\n```\n\nA custom error message can be given as the second argument to `expect`.\n\n``` javascript\nexpect(false, 'nooo why fail??').to.be.ok;\n```\n\n### .true\n\nAsserts that the target is strictly (`===`) equal to `true`.\n\n``` javascript\nexpect(true).to.be.true;\n```\n\nAdd `.``not` earlier in the chain to negate `.``true`. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to `true`.\n\n``` javascript\nexpect(false).to.be.false; // Recommended\nexpect(false).to.not.be.true; // Not recommended\n\nexpect(1).to.equal(1); // Recommended\nexpect(1).to.not.be.true; // Not recommended\n```\n\nA custom error message can be given as the second argument to `expect`.\n\n``` javascript\nexpect(false, 'nooo why fail??').to.be.true;\n```\n\n### .false\n\nAsserts that the target is strictly (`===`) equal to `false`.\n\n``` javascript\nexpect(false).to.be.false;\n```\n\nAdd `.``not` earlier in the chain to negate `.``false`. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to `false`.\n\n``` javascript\nexpect(true).to.be.true; // Recommended\nexpect(true).to.not.be.false; // Not recommended\n\nexpect(1).to.equal(1); // Recommended\nexpect(1).to.not.be.false; // Not recommended\n```\n\nA custom error message can be given as the second argument to `expect`.\n\n``` javascript\nexpect(true, 'nooo why fail??').to.be.false;\n```\n\n### .null\n\nAsserts that the target is strictly (`===`) equal to `null`.\n\n``` javascript\nexpect(null).to.be.null;\n```\n\nAdd `.``not` earlier in the chain to negate `.``null`. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to `null`.\n\n``` javascript\nexpect(1).to.equal(1); // Recommended\nexpect(1).to.not.be.null; // Not recommended\n```\n\nA custom error message can be given as the second argument to `expect`.\n\n``` javascript\nexpect(42, 'nooo why fail??').to.be.null;\n```\n\n### .undefined\n\nAsserts that the target is strictly (`===`) equal to `undefined`.\n\n``` javascript\nexpect(undefined).to.be.undefined;\n```\n\nAdd `.``not` earlier in the chain to negate `.``undefined`. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to `undefined`.\n\n``` javascript\nexpect(1).to.equal(1); // Recommended\nexpect(1).to.not.be.undefined; // Not recommended\n```\n\nA custom error message can be given as the second argument to `expect`.\n\n``` javascript\nexpect(42, 'nooo why fail??').to.be.undefined;\n```\n\n### .NaN\n\nAsserts that the target is exactly `NaN`.\n\n``` javascript\nexpect(NaN).to.be.NaN;\n```\n\nAdd `.``not` earlier in the chain to negate `.``NaN`. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to `NaN`.\n\n``` javascript\nexpect('foo').to.equal('foo'); // Recommended\nexpect('foo').to.not.be.NaN; // Not recommended\n```\n\nA custom error message can be given as the second argument to `expect`.\n\n``` javascript\nexpect(42, 'nooo why fail??').to.be.NaN;\n```\n\n### .exist\n\nAsserts that the target is not strictly (`===`) equal to either `null` or `undefined`. However, it’s often best to assert that the target is equal to its expected value.\n\n``` javascript\nexpect(1).to.equal(1); // Recommended\nexpect(1).to.exist; // Not recommended\n\nexpect(0).to.equal(0); // Recommended\nexpect(0).to.exist; // Not recommended\n```\n\nAdd `.``not` earlier in the chain to negate `.``exist`.\n\n``` javascript\nexpect(null).to.be.null; // Recommended\nexpect(null).to.not.exist; // Not recommended\n\nexpect(undefined).to.be.undefined; // Recommended\nexpect(undefined).to.not.exist; // Not recommended\n```\n\nA custom error message can be given as the second argument to `expect`.\n\n``` javascript\nexpect(null, 'nooo why fail??').to.exist;\n```\n\nThe alias `.``exists` can be used interchangeably with `.``exist`.\n\n### .empty\n\nWhen the target is a string or array, `.``empty` asserts that the target’s `length` property is strictly (`===`) equal to `0`.\n\n``` javascript\nexpect([]).to.be.empty;\nexpect('').to.be.empty;\n```\n\nWhen the target is a map or set, `.``empty` asserts that the target’s `size` property is strictly equal to `0`.\n\n``` javascript\nexpect(new Set()).to.be.empty;\nexpect(new Map()).to.be.empty;\n```\n\nWhen the target is a non-function object, `.``empty` asserts that the target doesn’t have any own enumerable properties. Properties with Symbol-based keys are excluded from the count.\n\n``` javascript\nexpect({}).to.be.empty;\n```\n\nBecause `.``empty` does different things based on the target’s type, it’s important to check the target’s type before using `.``empty`. See the `.``a` doc for info on testing a target’s type.\n\n``` javascript\nexpect([]).to.be.an('array').that.is.empty;\n```\n\nAdd `.``not` earlier in the chain to negate `.``empty`. However, it’s often best to assert that the target contains its expected number of values, rather than asserting that it’s not empty.\n\n``` javascript\nexpect([1, 2, 3]).to.have.lengthOf(3); // Recommended\nexpect([1, 2, 3]).to.not.be.empty; // Not recommended\n\nexpect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended\nexpect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended\n\nexpect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended\nexpect({a: 1}).to.not.be.empty; // Not recommended\n```\n\nA custom error message can be given as the second argument to `expect`.\n\n``` javascript\nexpect([1, 2, 3], 'nooo why fail??').to.be.empty;\n```\n\n### .arguments\n\nAsserts that the target is an `arguments` object.\n\n``` javascript\nfunction test () {\n  expect(arguments).to.be.arguments;\n}\n\ntest();\n```\n\nAdd `.``not` earlier in the chain to negate `.``arguments`. However, it’s often best to assert which type the target is expected to be, rather than asserting that it’s not an `arguments` object.\n\n``` javascript\nexpect('foo').to.be.a('string'); // Recommended\nexpect('foo').to.not.be.arguments; // Not recommended\n```\n\nA custom error message can be given as the second argument to `expect`.\n\n``` javascript\nexpect({}, 'nooo why fail??').to.be.arguments;\n```\n\nThe alias `.``Arguments` can be used interchangeably with `.``arguments`.\n\n### .equal(val\\[, msg\\])\n\n- @param { Mixed } val\n- @param { String } msg \\_optional\\_\n\nAsserts that the target is strictly (`===`) equal to the given `val`.\n\n``` javascript\nexpect(1).to.equal(1);\nexpect('foo').to.equal('foo');\n```\n\nAdd `.``deep` earlier in the chain to use deep equality instead. See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n\n``` javascript\n// Target object deeply (but not strictly) equals `{a: 1}`\nexpect({a: 1}).to.deep.equal({a: 1});\nexpect({a: 1}).to.not.equal({a: 1});\n\n// Target array deeply (but not strictly) equals `[1, 2]`\nexpect([1, 2]).to.deep.equal([1, 2]);\nexpect([1, 2]).to.not.equal([1, 2]);\n```\n\nAdd `.``not` earlier in the chain to negate `.``equal`. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to one of countless unexpected values.\n\n``` javascript\nexpect(1).to.equal(1); // Recommended\nexpect(1).to.not.equal(2); // Not recommended\n```\n\n`.``equal` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect(1).to.equal(2, 'nooo why fail??');\nexpect(1, 'nooo why fail??').to.equal(2);\n```\n\nThe aliases `.``equals` and `eq` can be used interchangeably with `.``equal`.\n\n### .eql(obj\\[, msg\\])\n\n- @param { Mixed } obj\n- @param { String } msg \\_optional\\_\n\nAsserts that the target is deeply equal to the given `obj`. See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n\n``` javascript\n// Target object is deeply (but not strictly) equal to {a: 1}\nexpect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});\n\n// Target array is deeply (but not strictly) equal to [1, 2]\nexpect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);\n```\n\nAdd `.``not` earlier in the chain to negate `.``eql`. However, it’s often best to assert that the target is deeply equal to its expected value, rather than not deeply equal to one of countless unexpected values.\n\n``` javascript\nexpect({a: 1}).to.eql({a: 1}); // Recommended\nexpect({a: 1}).to.not.eql({b: 2}); // Not recommended\n```\n\n`.``eql` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect({a: 1}).to.eql({b: 2}, 'nooo why fail??');\nexpect({a: 1}, 'nooo why fail??').to.eql({b: 2});\n```\n\nThe alias `.``eqls` can be used interchangeably with `.``eql`.\n\nThe `.``deep``.``equal` assertion is almost identical to `.``eql` but with one difference: `.``deep``.``equal` causes deep equality comparisons to also be used for any other assertions that follow in the chain.\n\n### .above(n\\[, msg\\])\n\n- @param { Number } n\n- @param { String } msg \\_optional\\_\n\nAsserts that the target is a number or a date greater than the given number or date `n` respectively. However, it’s often best to assert that the target is equal to its expected value.\n\n``` javascript\nexpect(2).to.equal(2); // Recommended\nexpect(2).to.be.above(1); // Not recommended\n```\n\nAdd `.``lengthOf` earlier in the chain to assert that the target’s `length` or `size` is greater than the given number `n`.\n\n``` javascript\nexpect('foo').to.have.lengthOf(3); // Recommended\nexpect('foo').to.have.lengthOf.above(2); // Not recommended\n\nexpect([1, 2, 3]).to.have.lengthOf(3); // Recommended\nexpect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended\n```\n\nAdd `.``not` earlier in the chain to negate `.``above`.\n\n``` javascript\nexpect(2).to.equal(2); // Recommended\nexpect(1).to.not.be.above(2); // Not recommended\n```\n\n`.``above` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect(1).to.be.above(2, 'nooo why fail??');\nexpect(1, 'nooo why fail??').to.be.above(2);\n```\n\nThe aliases `.``gt` and `.``greaterThan` can be used interchangeably with `.``above`.\n\n### .least(n\\[, msg\\])\n\n- @param { Number } n\n- @param { String } msg \\_optional\\_\n\nAsserts that the target is a number or a date greater than or equal to the given number or date `n` respectively. However, it’s often best to assert that the target is equal to its expected value.\n\n``` javascript\nexpect(2).to.equal(2); // Recommended\nexpect(2).to.be.at.least(1); // Not recommended\nexpect(2).to.be.at.least(2); // Not recommended\n```\n\nAdd `.``lengthOf` earlier in the chain to assert that the target’s `length` or `size` is greater than or equal to the given number `n`.\n\n``` javascript\nexpect('foo').to.have.lengthOf(3); // Recommended\nexpect('foo').to.have.lengthOf.at.least(2); // Not recommended\n\nexpect([1, 2, 3]).to.have.lengthOf(3); // Recommended\nexpect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended\n```\n\nAdd `.``not` earlier in the chain to negate `.``least`.\n\n``` javascript\nexpect(1).to.equal(1); // Recommended\nexpect(1).to.not.be.at.least(2); // Not recommended\n```\n\n`.``least` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect(1).to.be.at.least(2, 'nooo why fail??');\nexpect(1, 'nooo why fail??').to.be.at.least(2);\n```\n\nThe aliases `.``gte` and `.``greaterThanOrEqual` can be used interchangeably with `.``least`.\n\n### .below(n\\[, msg\\])\n\n- @param { Number } n\n- @param { String } msg \\_optional\\_\n\nAsserts that the target is a number or a date less than the given number or date `n` respectively. However, it’s often best to assert that the target is equal to its expected value.\n\n``` javascript\nexpect(1).to.equal(1); // Recommended\nexpect(1).to.be.below(2); // Not recommended\n```\n\nAdd `.``lengthOf` earlier in the chain to assert that the target’s `length` or `size` is less than the given number `n`.\n\n``` javascript\nexpect('foo').to.have.lengthOf(3); // Recommended\nexpect('foo').to.have.lengthOf.below(4); // Not recommended\n\nexpect([1, 2, 3]).to.have.length(3); // Recommended\nexpect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended\n```\n\nAdd `.``not` earlier in the chain to negate `.``below`.\n\n``` javascript\nexpect(2).to.equal(2); // Recommended\nexpect(2).to.not.be.below(1); // Not recommended\n```\n\n`.``below` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect(2).to.be.below(1, 'nooo why fail??');\nexpect(2, 'nooo why fail??').to.be.below(1);\n```\n\nThe aliases `.``lt` and `.``lessThan` can be used interchangeably with `.``below`.\n\n### .most(n\\[, msg\\])\n\n- @param { Number } n\n- @param { String } msg \\_optional\\_\n\nAsserts that the target is a number or a date less than or equal to the given number or date `n` respectively. However, it’s often best to assert that the target is equal to its expected value.\n\n``` javascript\nexpect(1).to.equal(1); // Recommended\nexpect(1).to.be.at.most(2); // Not recommended\nexpect(1).to.be.at.most(1); // Not recommended\n```\n\nAdd `.``lengthOf` earlier in the chain to assert that the target’s `length` or `size` is less than or equal to the given number `n`.\n\n``` javascript\nexpect('foo').to.have.lengthOf(3); // Recommended\nexpect('foo').to.have.lengthOf.at.most(4); // Not recommended\n\nexpect([1, 2, 3]).to.have.lengthOf(3); // Recommended\nexpect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended\n```\n\nAdd `.``not` earlier in the chain to negate `.``most`.\n\n``` javascript\nexpect(2).to.equal(2); // Recommended\nexpect(2).to.not.be.at.most(1); // Not recommended\n```\n\n`.``most` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect(2).to.be.at.most(1, 'nooo why fail??');\nexpect(2, 'nooo why fail??').to.be.at.most(1);\n```\n\nThe aliases `.``lte` and `.``lessThanOrEqual` can be used interchangeably with `.``most`.\n\n### .within(start, finish\\[, msg\\])\n\n- @param { Number } start lower bound inclusive\n- @param { Number } finish upper bound inclusive\n- @param { String } msg \\_optional\\_\n\nAsserts that the target is a number or a date greater than or equal to the given number or date `start`, and less than or equal to the given number or date `finish` respectively. However, it’s often best to assert that the target is equal to its expected value.\n\n``` javascript\nexpect(2).to.equal(2); // Recommended\nexpect(2).to.be.within(1, 3); // Not recommended\nexpect(2).to.be.within(2, 3); // Not recommended\nexpect(2).to.be.within(1, 2); // Not recommended\n```\n\nAdd `.``lengthOf` earlier in the chain to assert that the target’s `length` or `size` is greater than or equal to the given number `start`, and less than or equal to the given number `finish`.\n\n``` javascript\nexpect('foo').to.have.lengthOf(3); // Recommended\nexpect('foo').to.have.lengthOf.within(2, 4); // Not recommended\n\nexpect([1, 2, 3]).to.have.lengthOf(3); // Recommended\nexpect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended\n```\n\nAdd `.``not` earlier in the chain to negate `.``within`.\n\n``` javascript\nexpect(1).to.equal(1); // Recommended\nexpect(1).to.not.be.within(2, 4); // Not recommended\n```\n\n`.``within` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect(4).to.be.within(1, 3, 'nooo why fail??');\nexpect(4, 'nooo why fail??').to.be.within(1, 3);\n```\n\n### .instanceof(constructor\\[, msg\\])\n\n- @param { Constructor } constructor\n- @param { String } msg \\_optional\\_\n\nAsserts that the target is an instance of the given `constructor`.\n\n``` javascript\nfunction Cat () { }\n\nexpect(new Cat()).to.be.an.instanceof(Cat);\nexpect([1, 2]).to.be.an.instanceof(Array);\n```\n\nAdd `.``not` earlier in the chain to negate `.``instanceof`.\n\n``` javascript\nexpect({a: 1}).to.not.be.an.instanceof(Array);\n```\n\n`.``instanceof` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect(1).to.be.an.instanceof(Array, 'nooo why fail??');\nexpect(1, 'nooo why fail??').to.be.an.instanceof(Array);\n```\n\nDue to limitations in ES5, `.``instanceof` may not always work as expected when using a transpiler such as Babel or TypeScript. In particular, it may produce unexpected results when subclassing built-in object such as `Array`, `Error`, and `Map`. See your transpiler’s docs for details:\n\n- ([Babel](https://babeljs.io/docs/usage/caveats/#classes))\n- ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))\n\nThe alias `.``instanceOf` can be used interchangeably with `.``instanceof`.\n\n### .property(name\\[, val\\[, msg\\]\\])\n\n- @param { String } name\n- @param { Mixed } val (optional)\n- @param { String } msg \\_optional\\_\n\nAsserts that the target has a property with the given key `name`.\n\n``` javascript\nexpect({a: 1}).to.have.property('a');\n```\n\nWhen `val` is provided, `.``property` also asserts that the property’s value is equal to the given `val`.\n\n``` javascript\nexpect({a: 1}).to.have.property('a', 1);\n```\n\nBy default, strict (`===`) equality is used. Add `.``deep` earlier in the chain to use deep equality instead. See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n\n``` javascript\n// Target object deeply (but not strictly) has property `x: {a: 1}`\nexpect({x: {a: 1}}).to.have.deep.property('x', {a: 1});\nexpect({x: {a: 1}}).to.not.have.property('x', {a: 1});\n```\n\nThe target’s enumerable and non-enumerable properties are always included in the search. By default, both own and inherited properties are included. Add `.``own` earlier in the chain to exclude inherited properties from the search.\n\n``` javascript\nObject.prototype.b = 2;\n\nexpect({a: 1}).to.have.own.property('a');\nexpect({a: 1}).to.have.own.property('a', 1);\nexpect({a: 1}).to.have.property('b');\nexpect({a: 1}).to.not.have.own.property('b');\n```\n\n`.``deep` and `.``own` can be combined.\n\n``` javascript\nexpect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});\n```\n\nAdd `.``nested` earlier in the chain to enable dot- and bracket-notation when referencing nested properties.\n\n``` javascript\nexpect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');\nexpect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');\n```\n\nIf `.` or `[]` are part of an actual property name, they can be escaped by adding two backslashes before them.\n\n``` javascript\nexpect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');\n```\n\n`.``deep` and `.``nested` can be combined.\n\n``` javascript\nexpect({a: {b: [{c: 3}]}})\n  .to.have.deep.nested.property('a.b[0]', {c: 3});\n```\n\n`.``own` and `.``nested` cannot be combined.\n\nAdd `.``not` earlier in the chain to negate `.``property`.\n\n``` javascript\nexpect({a: 1}).to.not.have.property('b');\n```\n\nHowever, it’s dangerous to negate `.``property` when providing `val`. The problem is that it creates uncertain expectations by asserting that the target either doesn’t have a property with the given key `name`, or that it does have a property with the given key `name` but its value isn’t equal to the given `val`. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.\n\nWhen the target isn’t expected to have a property with the given key `name`, it’s often best to assert exactly that.\n\n``` javascript\nexpect({b: 2}).to.not.have.property('a'); // Recommended\nexpect({b: 2}).to.not.have.property('a', 1); // Not recommended\n```\n\nWhen the target is expected to have a property with the given key `name`, it’s often best to assert that the property has its expected value, rather than asserting that it doesn’t have one of many unexpected values.\n\n``` javascript\nexpect({a: 3}).to.have.property('a', 3); // Recommended\nexpect({a: 3}).to.not.have.property('a', 1); // Not recommended\n```\n\n`.``property` changes the target of any assertions that follow in the chain to be the value of the property from the original target object.\n\n``` javascript\nexpect({a: 1}).to.have.property('a').that.is.a('number');\n```\n\n`.``property` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`. When not providing `val`, only use the second form.\n\n``` javascript\n// Recommended\nexpect({a: 1}).to.have.property('a', 2, 'nooo why fail??');\nexpect({a: 1}, 'nooo why fail??').to.have.property('a', 2);\nexpect({a: 1}, 'nooo why fail??').to.have.property('b');\n\n// Not recommended\nexpect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');\n```\n\nThe above assertion isn’t the same thing as not providing `val`. Instead, it’s asserting that the target object has a `b` property that’s equal to `undefined`.\n\nThe assertions `.``ownProperty` and `.``haveOwnProperty` can be used interchangeably with `.``own``.``property`.\n\n### .ownPropertyDescriptor(name\\[, descriptor\\[, msg\\]\\])\n\n- @param { String } name\n- @param { Object } descriptor \\_optional\\_\n- @param { String } msg \\_optional\\_\n\nAsserts that the target has its own property descriptor with the given key `name`. Enumerable and non-enumerable properties are included in the search.\n\n``` javascript\nexpect({a: 1}).to.have.ownPropertyDescriptor('a');\n```\n\nWhen `descriptor` is provided, `.``ownPropertyDescriptor` also asserts that the property’s descriptor is deeply equal to the given `descriptor`. See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n\n``` javascript\nexpect({a: 1}).to.have.ownPropertyDescriptor('a', {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  value: 1,\n});\n```\n\nAdd `.``not` earlier in the chain to negate `.``ownPropertyDescriptor`.\n\n``` javascript\nexpect({a: 1}).to.not.have.ownPropertyDescriptor('b');\n```\n\nHowever, it’s dangerous to negate `.``ownPropertyDescriptor` when providing a `descriptor`. The problem is that it creates uncertain expectations by asserting that the target either doesn’t have a property descriptor with the given key `name`, or that it does have a property descriptor with the given key `name` but it’s not deeply equal to the given `descriptor`. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.\n\nWhen the target isn’t expected to have a property descriptor with the given key `name`, it’s often best to assert exactly that.\n\n``` javascript\n// Recommended\nexpect({b: 2}).to.not.have.ownPropertyDescriptor('a');\n\n// Not recommended\nexpect({b: 2}).to.not.have.ownPropertyDescriptor('a', {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  value: 1,\n});\n```\n\nWhen the target is expected to have a property descriptor with the given key `name`, it’s often best to assert that the property has its expected descriptor, rather than asserting that it doesn’t have one of many unexpected descriptors.\n\n``` javascript\n// Recommended\nexpect({a: 3}).to.have.ownPropertyDescriptor('a', {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  value: 3,\n});\n\n// Not recommended\nexpect({a: 3}).to.not.have.ownPropertyDescriptor('a', {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  value: 1,\n});\n```\n\n`.``ownPropertyDescriptor` changes the target of any assertions that follow in the chain to be the value of the property descriptor from the original target object.\n\n``` javascript\nexpect({a: 1}).to.have.ownPropertyDescriptor('a')\n  .that.has.property('enumerable', true);\n```\n\n`.``ownPropertyDescriptor` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`. When not providing `descriptor`, only use the second form.\n\n``` javascript\n// Recommended\nexpect({a: 1}).to.have.ownPropertyDescriptor('a', {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  value: 2,\n}, 'nooo why fail??');\n\n// Recommended\nexpect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  value: 2,\n});\n\n// Recommended\nexpect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');\n\n// Not recommended\nexpect({a: 1})\n  .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');\n```\n\nThe above assertion isn’t the same thing as not providing `descriptor`. Instead, it’s asserting that the target object has a `b` property descriptor that’s deeply equal to `undefined`.\n\nThe alias `.``haveOwnPropertyDescriptor` can be used interchangeably with `.``ownPropertyDescriptor`.\n\n### .lengthOf(n\\[, msg\\])\n\n- @param { Number } n\n- @param { String } msg \\_optional\\_\n\nAsserts that the target’s `length` or `size` is equal to the given number `n`.\n\n``` javascript\nexpect([1, 2, 3]).to.have.lengthOf(3);\nexpect('foo').to.have.lengthOf(3);\nexpect(new Set([1, 2, 3])).to.have.lengthOf(3);\nexpect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);\n```\n\nAdd `.``not` earlier in the chain to negate `.``lengthOf`. However, it’s often best to assert that the target’s `length` property is equal to its expected value, rather than not equal to one of many unexpected values.\n\n``` javascript\nexpect('foo').to.have.lengthOf(3); // Recommended\nexpect('foo').to.not.have.lengthOf(4); // Not recommended\n```\n\n`.``lengthOf` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');\nexpect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);\n```\n\n`.``lengthOf` can also be used as a language chain, causing all `.``above`, `.``below`, `.``least`, `.``most`, and `.``within` assertions that follow in the chain to use the target’s `length` property as the target. However, it’s often best to assert that the target’s `length` property is equal to its expected length, rather than asserting that its `length` property falls within some range of values.\n\n``` javascript\n// Recommended\nexpect([1, 2, 3]).to.have.lengthOf(3);\n\n// Not recommended\nexpect([1, 2, 3]).to.have.lengthOf.above(2);\nexpect([1, 2, 3]).to.have.lengthOf.below(4);\nexpect([1, 2, 3]).to.have.lengthOf.at.least(3);\nexpect([1, 2, 3]).to.have.lengthOf.at.most(3);\nexpect([1, 2, 3]).to.have.lengthOf.within(2,4);\n```\n\nDue to a compatibility issue, the alias `.``length` can’t be chained directly off of an uninvoked method such as `.``a`. Therefore, `.``length` can’t be used interchangeably with `.``lengthOf` in every situation. It’s recommended to always use `.``lengthOf` instead of `.``length`.\n\n``` javascript\nexpect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error\nexpect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected\n```\n\n### .match(re\\[, msg\\])\n\n- @param { RegExp } re\n- @param { String } msg \\_optional\\_\n\nAsserts that the target matches the given regular expression `re`.\n\n``` javascript\nexpect('foobar').to.match(/^foo/);\n```\n\nAdd `.``not` earlier in the chain to negate `.``match`.\n\n``` javascript\nexpect('foobar').to.not.match(/taco/);\n```\n\n`.``match` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect('foobar').to.match(/taco/, 'nooo why fail??');\nexpect('foobar', 'nooo why fail??').to.match(/taco/);\n```\n\nThe alias `.``matches` can be used interchangeably with `.``match`.\n\n### .string(str\\[, msg\\])\n\n- @param { String } str\n- @param { String } msg \\_optional\\_\n\nAsserts that the target string contains the given substring `str`.\n\n``` javascript\nexpect('foobar').to.have.string('bar');\n```\n\nAdd `.``not` earlier in the chain to negate `.``string`.\n\n``` javascript\nexpect('foobar').to.not.have.string('taco');\n```\n\n`.``string` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect('foobar').to.have.string('taco', 'nooo why fail??');\nexpect('foobar', 'nooo why fail??').to.have.string('taco');\n```\n\n### .keys(key1\\[, key2\\[, …\\]\\])\n\n- @param { String \\| Array \\| Object } keys\n\nAsserts that the target object, array, map, or set has the given keys. Only the target’s own inherited properties are included in the search.\n\nWhen the target is an object or array, keys can be provided as one or more string arguments, a single array argument, or a single object argument. In the latter case, only the keys in the given object matter; the values are ignored.\n\n``` javascript\nexpect({a: 1, b: 2}).to.have.all.keys('a', 'b');\nexpect(['x', 'y']).to.have.all.keys(0, 1);\n\nexpect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);\nexpect(['x', 'y']).to.have.all.keys([0, 1]);\n\nexpect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5\nexpect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5\n```\n\nWhen the target is a map or set, each key must be provided as a separate argument.\n\n``` javascript\nexpect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');\nexpect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');\n```\n\nBecause `.``keys` does different things based on the target’s type, it’s important to check the target’s type before using `.``keys`. See the `.``a` doc for info on testing a target’s type.\n\n``` javascript\nexpect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');\n```\n\nBy default, strict (`===`) equality is used to compare keys of maps and sets. Add `.``deep` earlier in the chain to use deep equality instead. See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n\n``` javascript\n// Target set deeply (but not strictly) has key `{a: 1}`\nexpect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);\nexpect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);\n```\n\nBy default, the target must have all of the given keys and no more. Add `.``any` earlier in the chain to only require that the target have at least one of the given keys. Also, add `.``not` earlier in the chain to negate `.``keys`. It’s often best to add `.``any` when negating `.``keys`, and to use `.``all` when asserting `.``keys` without negation.\n\nWhen negating `.``keys`, `.``any` is preferred because `.``not``.``any``.``keys` asserts exactly what’s expected of the output, whereas `.``not``.``all``.``keys` creates uncertain expectations.\n\n``` javascript\n// Recommended; asserts that target doesn't have any of the given keys\nexpect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');\n\n// Not recommended; asserts that target doesn't have all of the given\n// keys but may or may not have some of them\nexpect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');\n```\n\nWhen asserting `.``keys` without negation, `.``all` is preferred because `.``all``.``keys` asserts exactly what’s expected of the output, whereas `.``any``.``keys` creates uncertain expectations.\n\n``` javascript\n// Recommended; asserts that target has all the given keys\nexpect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n\n// Not recommended; asserts that target has at least one of the given\n// keys but may or may not have more of them\nexpect({a: 1, b: 2}).to.have.any.keys('a', 'b');\n```\n\nNote that `.``all` is used by default when neither `.``all` nor `.``any` appear earlier in the chain. However, it’s often best to add `.``all` anyway because it improves readability.\n\n``` javascript\n// Both assertions are identical\nexpect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended\nexpect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended\n```\n\nAdd `.``include` earlier in the chain to require that the target’s keys be a superset of the expected keys, rather than identical sets.\n\n``` javascript\n// Target object's keys are a superset of ['a', 'b'] but not identical\nexpect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');\nexpect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');\n```\n\nHowever, if `.``any` and `.``include` are combined, only the `.``any` takes effect. The `.``include` is ignored in this case.\n\n``` javascript\n// Both assertions are identical\nexpect({a: 1}).to.have.any.keys('a', 'b');\nexpect({a: 1}).to.include.any.keys('a', 'b');\n```\n\nA custom error message can be given as the second argument to `expect`.\n\n``` javascript\nexpect({a: 1}, 'nooo why fail??').to.have.key('b');\n```\n\nThe alias `.``key` can be used interchangeably with `.``keys`.\n\n### .throw(\\[errorLike\\], \\[errMsgMatcher\\], \\[msg\\])\n\n- @param { Error \\| ErrorConstructor } errorLike\n- @param { String \\| RegExp } errMsgMatcher error message\n- @param { String } msg \\_optional\\_\n- @see [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types)\n\nWhen no arguments are provided, `.``throw` invokes the target function and asserts that an error is thrown.\n\n``` javascript\nvar badFn = function () { throw new TypeError('Illegal salmon!'); };\n\nexpect(badFn).to.throw();\n```\n\nWhen one argument is provided, and it’s an error constructor, `.``throw` invokes the target function and asserts that an error is thrown that’s an instance of that error constructor.\n\n``` javascript\nvar badFn = function () { throw new TypeError('Illegal salmon!'); };\n\nexpect(badFn).to.throw(TypeError);\n```\n\nWhen one argument is provided, and it’s an error instance, `.``throw` invokes the target function and asserts that an error is thrown that’s strictly (`===`) equal to that error instance.\n\n``` javascript\nvar err = new TypeError('Illegal salmon!');\nvar badFn = function () { throw err; };\n\nexpect(badFn).to.throw(err);\n```\n\nWhen one argument is provided, and it’s a string, `.``throw` invokes the target function and asserts that an error is thrown with a message that contains that string.\n\n``` javascript\nvar badFn = function () { throw new TypeError('Illegal salmon!'); };\n\nexpect(badFn).to.throw('salmon');\n```\n\nWhen one argument is provided, and it’s a regular expression, `.``throw` invokes the target function and asserts that an error is thrown with a message that matches that regular expression.\n\n``` javascript\nvar badFn = function () { throw new TypeError('Illegal salmon!'); };\n\nexpect(badFn).to.throw(/salmon/);\n```\n\nWhen two arguments are provided, and the first is an error instance or constructor, and the second is a string or regular expression, `.``throw` invokes the function and asserts that an error is thrown that fulfills both conditions as described above.\n\n``` javascript\nvar err = new TypeError('Illegal salmon!');\nvar badFn = function () { throw err; };\n\nexpect(badFn).to.throw(TypeError, 'salmon');\nexpect(badFn).to.throw(TypeError, /salmon/);\nexpect(badFn).to.throw(err, 'salmon');\nexpect(badFn).to.throw(err, /salmon/);\n```\n\nAdd `.``not` earlier in the chain to negate `.``throw`.\n\n``` javascript\nvar goodFn = function () {};\n\nexpect(goodFn).to.not.throw();\n```\n\nHowever, it’s dangerous to negate `.``throw` when providing any arguments. The problem is that it creates uncertain expectations by asserting that the target either doesn’t throw an error, or that it throws an error but of a different type than the given type, or that it throws an error of the given type but with a message that doesn’t include the given string. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.\n\nWhen the target isn’t expected to throw an error, it’s often best to assert exactly that.\n\n``` javascript\nvar goodFn = function () {};\n\nexpect(goodFn).to.not.throw(); // Recommended\nexpect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended\n```\n\nWhen the target is expected to throw an error, it’s often best to assert that the error is of its expected type, and has a message that includes an expected string, rather than asserting that it doesn’t have one of many unexpected types, and doesn’t have a message that includes some string.\n\n``` javascript\nvar badFn = function () { throw new TypeError('Illegal salmon!'); };\n\nexpect(badFn).to.throw(TypeError, 'salmon'); // Recommended\nexpect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended\n```\n\n`.``throw` changes the target of any assertions that follow in the chain to be the error object that’s thrown.\n\n``` javascript\nvar err = new TypeError('Illegal salmon!');\nerr.code = 42;\nvar badFn = function () { throw err; };\n\nexpect(badFn).to.throw(TypeError).with.property('code', 42);\n```\n\n`.``throw` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`. When not providing two arguments, always use the second form.\n\n``` javascript\nvar goodFn = function () {};\n\nexpect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');\nexpect(goodFn, 'nooo why fail??').to.throw();\n```\n\nDue to limitations in ES5, `.``throw` may not always work as expected when using a transpiler such as Babel or TypeScript. In particular, it may produce unexpected results when subclassing the built-in `Error` object and then passing the subclassed constructor to `.``throw`. See your transpiler’s docs for details:\n\n- ([Babel](https://babeljs.io/docs/usage/caveats/#classes))\n- ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))\n\nBeware of some common mistakes when using the `throw` assertion. One common mistake is to accidentally invoke the function yourself instead of letting the `throw` assertion invoke the function for you. For example, when testing if a function named `fn` throws, provide `fn` instead of `fn``()` as the target for the assertion.\n\n``` javascript\nexpect(fn).to.throw();     // Good! Tests `fn` as desired\nexpect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`\n```\n\nIf you need to assert that your function `fn` throws when passed certain arguments, then wrap a call to `fn` inside of another function.\n\n``` javascript\nexpect(function () { fn(42); }).to.throw();  // Function expression\nexpect(() => fn(42)).to.throw();             // ES6 arrow function\n```\n\nAnother common mistake is to provide an object method (or any stand-alone function that relies on `this`) as the target of the assertion. Doing so is problematic because the `this` context will be lost when the function is invoked by `.``throw`; there’s no way for it to know what `this` is supposed to be. There are two ways around this problem. One solution is to wrap the method or function call inside of another function. Another solution is to use `bind`.\n\n``` javascript\nexpect(function () { cat.meow(); }).to.throw();  // Function expression\nexpect(() => cat.meow()).to.throw();             // ES6 arrow function\nexpect(cat.meow.bind(cat)).to.throw();           // Bind\n```\n\nFinally, it’s worth mentioning that it’s a best practice in JavaScript to only throw `Error` and derivatives of `Error` such as `ReferenceError`, `TypeError`, and user-defined objects that extend `Error`. No other type of value will generate a stack trace when initialized. With that said, the `throw` assertion does technically support any type of value being thrown, not just `Error` and its derivatives.\n\nThe aliases `.``throws` and `.``Throw` can be used interchangeably with `.``throw`.\n\n### .respondTo(method\\[, msg\\])\n\n- @param { String } method\n- @param { String } msg \\_optional\\_\n\nWhen the target is a non-function object, `.``respondTo` asserts that the target has a method with the given name `method`. The method can be own or inherited, and it can be enumerable or non-enumerable.\n\n``` javascript\nfunction Cat () {}\nCat.prototype.meow = function () {};\n\nexpect(new Cat()).to.respondTo('meow');\n```\n\nWhen the target is a function, `.``respondTo` asserts that the target’s `prototype` property has a method with the given name `method`. Again, the method can be own or inherited, and it can be enumerable or non-enumerable.\n\n``` javascript\nfunction Cat () {}\nCat.prototype.meow = function () {};\n\nexpect(Cat).to.respondTo('meow');\n```\n\nAdd `.``itself` earlier in the chain to force `.``respondTo` to treat the target as a non-function object, even if it’s a function. Thus, it asserts that the target has a method with the given name `method`, rather than asserting that the target’s `prototype` property has a method with the given name `method`.\n\n``` javascript\nfunction Cat () {}\nCat.prototype.meow = function () {};\nCat.hiss = function () {};\n\nexpect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');\n```\n\nWhen not adding `.``itself`, it’s important to check the target’s type before using `.``respondTo`. See the `.``a` doc for info on checking a target’s type.\n\n``` javascript\nfunction Cat () {}\nCat.prototype.meow = function () {};\n\nexpect(new Cat()).to.be.an('object').that.respondsTo('meow');\n```\n\nAdd `.``not` earlier in the chain to negate `.``respondTo`.\n\n``` javascript\nfunction Dog () {}\nDog.prototype.bark = function () {};\n\nexpect(new Dog()).to.not.respondTo('meow');\n```\n\n`.``respondTo` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect({}).to.respondTo('meow', 'nooo why fail??');\nexpect({}, 'nooo why fail??').to.respondTo('meow');\n```\n\nThe alias `.``respondsTo` can be used interchangeably with `.``respondTo`.\n\n### .itself\n\nForces all `.``respondTo` assertions that follow in the chain to behave as if the target is a non-function object, even if it’s a function. Thus, it causes `.``respondTo` to assert that the target has a method with the given name, rather than asserting that the target’s `prototype` property has a method with the given name.\n\n``` javascript\nfunction Cat () {}\nCat.prototype.meow = function () {};\nCat.hiss = function () {};\n\nexpect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');\n```\n\n### .satisfy(matcher\\[, msg\\])\n\n- @param { Function } matcher\n- @param { String } msg \\_optional\\_\n\nInvokes the given `matcher` function with the target being passed as the first argument, and asserts that the value returned is truthy.\n\n``` javascript\nexpect(1).to.satisfy(function(num) {\n  return num > 0;\n});\n```\n\nAdd `.``not` earlier in the chain to negate `.``satisfy`.\n\n``` javascript\nexpect(1).to.not.satisfy(function(num) {\n  return num > 2;\n});\n```\n\n`.``satisfy` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect(1).to.satisfy(function(num) {\n  return num > 2;\n}, 'nooo why fail??');\n\nexpect(1, 'nooo why fail??').to.satisfy(function(num) {\n  return num > 2;\n});\n```\n\nThe alias `.``satisfies` can be used interchangeably with `.``satisfy`.\n\n### .closeTo(expected, delta\\[, msg\\])\n\n- @param { Number } expected\n- @param { Number } delta\n- @param { String } msg \\_optional\\_\n\nAsserts that the target is a number that’s within a given +/- `delta` range of the given number `expected`. However, it’s often best to assert that the target is equal to its expected value.\n\n``` javascript\n// Recommended\nexpect(1.5).to.equal(1.5);\n\n// Not recommended\nexpect(1.5).to.be.closeTo(1, 0.5);\nexpect(1.5).to.be.closeTo(2, 0.5);\nexpect(1.5).to.be.closeTo(1, 1);\n```\n\nAdd `.``not` earlier in the chain to negate `.``closeTo`.\n\n``` javascript\nexpect(1.5).to.equal(1.5); // Recommended\nexpect(1.5).to.not.be.closeTo(3, 1); // Not recommended\n```\n\n`.``closeTo` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');\nexpect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);\n```\n\nThe alias `.``approximately` can be used interchangeably with `.``closeTo`.\n\n### .members(set\\[, msg\\])\n\n- @param { Array } set\n- @param { String } msg \\_optional\\_\n\nAsserts that the target array has the same members as the given array `set`.\n\n``` javascript\nexpect([1, 2, 3]).to.have.members([2, 1, 3]);\nexpect([1, 2, 2]).to.have.members([2, 1, 2]);\n```\n\nBy default, members are compared using strict (`===`) equality. Add `.``deep` earlier in the chain to use deep equality instead. See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n\n``` javascript\n// Target array deeply (but not strictly) has member `{a: 1}`\nexpect([{a: 1}]).to.have.deep.members([{a: 1}]);\nexpect([{a: 1}]).to.not.have.members([{a: 1}]);\n```\n\nBy default, order doesn’t matter. Add `.``ordered` earlier in the chain to require that members appear in the same order.\n\n``` javascript\nexpect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);\nexpect([1, 2, 3]).to.have.members([2, 1, 3])\n  .but.not.ordered.members([2, 1, 3]);\n```\n\nBy default, both arrays must be the same size. Add `.``include` earlier in the chain to require that the target’s members be a superset of the expected members. Note that duplicates are ignored in the subset when `.``include` is added.\n\n``` javascript\n// Target array is a superset of [1, 2] but not identical\nexpect([1, 2, 3]).to.include.members([1, 2]);\nexpect([1, 2, 3]).to.not.have.members([1, 2]);\n\n// Duplicates in the subset are ignored\nexpect([1, 2, 3]).to.include.members([1, 2, 2, 2]);\n```\n\n`.``deep`, `.``ordered`, and `.``include` can all be combined. However, if `.``include` and `.``ordered` are combined, the ordering begins at the start of both arrays.\n\n``` javascript\nexpect([{a: 1}, {b: 2}, {c: 3}])\n  .to.include.deep.ordered.members([{a: 1}, {b: 2}])\n  .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);\n```\n\nAdd `.``not` earlier in the chain to negate `.``members`. However, it’s dangerous to do so. The problem is that it creates uncertain expectations by asserting that the target array doesn’t have all of the same members as the given array `set` but may or may not have some of them. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.\n\n``` javascript\nexpect([1, 2]).to.not.include(3).and.not.include(4); // Recommended\nexpect([1, 2]).to.not.have.members([3, 4]); // Not recommended\n```\n\n`.``members` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');\nexpect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);\n```\n\n### .oneOf(list\\[, msg\\])\n\n- @param { Array. } list\n- @param { String } msg \\_optional\\_\n\nAsserts that the target is a member of the given array `list`. However, it’s often best to assert that the target is equal to its expected value.\n\n``` javascript\nexpect(1).to.equal(1); // Recommended\nexpect(1).to.be.oneOf([1, 2, 3]); // Not recommended\n```\n\nComparisons are performed using strict (`===`) equality.\n\nAdd `.``not` earlier in the chain to negate `.``oneOf`.\n\n``` javascript\nexpect(1).to.equal(1); // Recommended\nexpect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended\n```\n\nIt can also be chained with `.``contain` or `.``include`, which will work with both arrays and strings:\n\n``` javascript\nexpect('Today is sunny').to.contain.oneOf(['sunny', 'cloudy'])\nexpect('Today is rainy').to.not.contain.oneOf(['sunny', 'cloudy'])\nexpect([1,2,3]).to.contain.oneOf([3,4,5])\nexpect([1,2,3]).to.not.contain.oneOf([4,5,6])\n```\n\n`.``oneOf` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nexpect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');\nexpect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);\n```\n\n### .change(subject\\[, prop\\[, msg\\]\\])\n\n- @param { String } subject\n- @param { String } prop name \\_optional\\_\n- @param { String } msg \\_optional\\_\n\nWhen one argument is provided, `.``change` asserts that the given function `subject` returns a different value when it’s invoked before the target function compared to when it’s invoked afterward. However, it’s often best to assert that `subject` is equal to its expected value.\n\n``` javascript\nvar dots = ''\n  , addDot = function () { dots += '.'; }\n  , getDots = function () { return dots; };\n\n// Recommended\nexpect(getDots()).to.equal('');\naddDot();\nexpect(getDots()).to.equal('.');\n\n// Not recommended\nexpect(addDot).to.change(getDots);\n```\n\nWhen two arguments are provided, `.``change` asserts that the value of the given object `subject`’s `prop` property is different before invoking the target function compared to afterward.\n\n``` javascript\nvar myObj = {dots: ''}\n  , addDot = function () { myObj.dots += '.'; };\n\n// Recommended\nexpect(myObj).to.have.property('dots', '');\naddDot();\nexpect(myObj).to.have.property('dots', '.');\n\n// Not recommended\nexpect(addDot).to.change(myObj, 'dots');\n```\n\nStrict (`===`) equality is used to compare before and after values.\n\nAdd `.``not` earlier in the chain to negate `.``change`.\n\n``` javascript\nvar dots = ''\n  , noop = function () {}\n  , getDots = function () { return dots; };\n\nexpect(noop).to.not.change(getDots);\n\nvar myObj = {dots: ''}\n  , noop = function () {};\n\nexpect(noop).to.not.change(myObj, 'dots');\n```\n\n`.``change` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`. When not providing two arguments, always use the second form.\n\n``` javascript\nvar myObj = {dots: ''}\n  , addDot = function () { myObj.dots += '.'; };\n\nexpect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');\n\nvar dots = ''\n  , addDot = function () { dots += '.'; }\n  , getDots = function () { return dots; };\n\nexpect(addDot, 'nooo why fail??').to.not.change(getDots);\n```\n\n`.``change` also causes all `.``by` assertions that follow in the chain to assert how much a numeric subject was increased or decreased by. However, it’s dangerous to use `.``change``.``by`. The problem is that it creates uncertain expectations by asserting that the subject either increases by the given delta, or that it decreases by the given delta. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.\n\n``` javascript\nvar myObj = {val: 1}\n  , addTwo = function () { myObj.val += 2; }\n  , subtractTwo = function () { myObj.val -= 2; };\n\nexpect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\nexpect(addTwo).to.change(myObj, 'val').by(2); // Not recommended\n\nexpect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\nexpect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended\n```\n\nThe alias `.``changes` can be used interchangeably with `.``change`.\n\n### .increase(subject\\[, prop\\[, msg\\]\\])\n\n- @param { String \\| Function } subject\n- @param { String } prop name \\_optional\\_\n- @param { String } msg \\_optional\\_\n\nWhen one argument is provided, `.``increase` asserts that the given function `subject` returns a greater number when it’s invoked after invoking the target function compared to when it’s invoked beforehand. `.``increase` also causes all `.``by` assertions that follow in the chain to assert how much greater of a number is returned. It’s often best to assert that the return value increased by the expected amount, rather than asserting it increased by any amount.\n\n``` javascript\nvar val = 1\n  , addTwo = function () { val += 2; }\n  , getVal = function () { return val; };\n\nexpect(addTwo).to.increase(getVal).by(2); // Recommended\nexpect(addTwo).to.increase(getVal); // Not recommended\n```\n\nWhen two arguments are provided, `.``increase` asserts that the value of the given object `subject`’s `prop` property is greater after invoking the target function compared to beforehand.\n\n``` javascript\nvar myObj = {val: 1}\n  , addTwo = function () { myObj.val += 2; };\n\nexpect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\nexpect(addTwo).to.increase(myObj, 'val'); // Not recommended\n```\n\nAdd `.``not` earlier in the chain to negate `.``increase`. However, it’s dangerous to do so. The problem is that it creates uncertain expectations by asserting that the subject either decreases, or that it stays the same. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.\n\nWhen the subject is expected to decrease, it’s often best to assert that it decreased by the expected amount.\n\n``` javascript\nvar myObj = {val: 1}\n  , subtractTwo = function () { myObj.val -= 2; };\n\nexpect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\nexpect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended\n```\n\nWhen the subject is expected to stay the same, it’s often best to assert exactly that.\n\n``` javascript\nvar myObj = {val: 1}\n  , noop = function () {};\n\nexpect(noop).to.not.change(myObj, 'val'); // Recommended\nexpect(noop).to.not.increase(myObj, 'val'); // Not recommended\n```\n\n`.``increase` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`. When not providing two arguments, always use the second form.\n\n``` javascript\nvar myObj = {val: 1}\n  , noop = function () {};\n\nexpect(noop).to.increase(myObj, 'val', 'nooo why fail??');\n\nvar val = 1\n  , noop = function () {}\n  , getVal = function () { return val; };\n\nexpect(noop, 'nooo why fail??').to.increase(getVal);\n```\n\nThe alias `.``increases` can be used interchangeably with `.``increase`.\n\n### .decrease(subject\\[, prop\\[, msg\\]\\])\n\n- @param { String \\| Function } subject\n- @param { String } prop name \\_optional\\_\n- @param { String } msg \\_optional\\_\n\nWhen one argument is provided, `.``decrease` asserts that the given function `subject` returns a lesser number when it’s invoked after invoking the target function compared to when it’s invoked beforehand. `.``decrease` also causes all `.``by` assertions that follow in the chain to assert how much lesser of a number is returned. It’s often best to assert that the return value decreased by the expected amount, rather than asserting it decreased by any amount.\n\n``` javascript\nvar val = 1\n  , subtractTwo = function () { val -= 2; }\n  , getVal = function () { return val; };\n\nexpect(subtractTwo).to.decrease(getVal).by(2); // Recommended\nexpect(subtractTwo).to.decrease(getVal); // Not recommended\n```\n\nWhen two arguments are provided, `.``decrease` asserts that the value of the given object `subject`’s `prop` property is lesser after invoking the target function compared to beforehand.\n\n``` javascript\nvar myObj = {val: 1}\n  , subtractTwo = function () { myObj.val -= 2; };\n\nexpect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\nexpect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended\n```\n\nAdd `.``not` earlier in the chain to negate `.``decrease`. However, it’s dangerous to do so. The problem is that it creates uncertain expectations by asserting that the subject either increases, or that it stays the same. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.\n\nWhen the subject is expected to increase, it’s often best to assert that it increased by the expected amount.\n\n``` javascript\nvar myObj = {val: 1}\n  , addTwo = function () { myObj.val += 2; };\n\nexpect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\nexpect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended\n```\n\nWhen the subject is expected to stay the same, it’s often best to assert exactly that.\n\n``` javascript\nvar myObj = {val: 1}\n  , noop = function () {};\n\nexpect(noop).to.not.change(myObj, 'val'); // Recommended\nexpect(noop).to.not.decrease(myObj, 'val'); // Not recommended\n```\n\n`.``decrease` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`. When not providing two arguments, always use the second form.\n\n``` javascript\nvar myObj = {val: 1}\n  , noop = function () {};\n\nexpect(noop).to.decrease(myObj, 'val', 'nooo why fail??');\n\nvar val = 1\n  , noop = function () {}\n  , getVal = function () { return val; };\n\nexpect(noop, 'nooo why fail??').to.decrease(getVal);\n```\n\nThe alias `.``decreases` can be used interchangeably with `.``decrease`.\n\n### .by(delta\\[, msg\\])\n\n- @param { Number } delta\n- @param { String } msg \\_optional\\_\n\nWhen following an `.``increase` assertion in the chain, `.``by` asserts that the subject of the `.``increase` assertion increased by the given `delta`.\n\n``` javascript\nvar myObj = {val: 1}\n  , addTwo = function () { myObj.val += 2; };\n\nexpect(addTwo).to.increase(myObj, 'val').by(2);\n```\n\nWhen following a `.``decrease` assertion in the chain, `.``by` asserts that the subject of the `.``decrease` assertion decreased by the given `delta`.\n\n``` javascript\nvar myObj = {val: 1}\n  , subtractTwo = function () { myObj.val -= 2; };\n\nexpect(subtractTwo).to.decrease(myObj, 'val').by(2);\n```\n\nWhen following a `.``change` assertion in the chain, `.``by` asserts that the subject of the `.``change` assertion either increased or decreased by the given `delta`. However, it’s dangerous to use `.``change``.``by`. The problem is that it creates uncertain expectations. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.\n\n``` javascript\nvar myObj = {val: 1}\n  , addTwo = function () { myObj.val += 2; }\n  , subtractTwo = function () { myObj.val -= 2; };\n\nexpect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\nexpect(addTwo).to.change(myObj, 'val').by(2); // Not recommended\n\nexpect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\nexpect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended\n```\n\nAdd `.``not` earlier in the chain to negate `.``by`. However, it’s often best to assert that the subject changed by its expected delta, rather than asserting that it didn’t change by one of countless unexpected deltas.\n\n``` javascript\nvar myObj = {val: 1}\n  , addTwo = function () { myObj.val += 2; };\n\n// Recommended\nexpect(addTwo).to.increase(myObj, 'val').by(2);\n\n// Not recommended\nexpect(addTwo).to.increase(myObj, 'val').but.not.by(3);\n```\n\n`.``by` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.\n\n``` javascript\nvar myObj = {val: 1}\n  , addTwo = function () { myObj.val += 2; };\n\nexpect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');\nexpect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);\n```\n\n### .extensible\n\nAsserts that the target is extensible, which means that new properties can be added to it. Primitives are never extensible.\n\n``` javascript\nexpect({a: 1}).to.be.extensible;\n```\n\nAdd `.``not` earlier in the chain to negate `.``extensible`.\n\n``` javascript\nvar nonExtensibleObject = Object.preventExtensions({})\n  , sealedObject = Object.seal({})\n  , frozenObject = Object.freeze({});\n\nexpect(nonExtensibleObject).to.not.be.extensible;\nexpect(sealedObject).to.not.be.extensible;\nexpect(frozenObject).to.not.be.extensible;\nexpect(1).to.not.be.extensible;\n```\n\nA custom error message can be given as the second argument to `expect`.\n\n``` javascript\nexpect(1, 'nooo why fail??').to.be.extensible;\n```\n\n### .sealed\n\nAsserts that the target is sealed, which means that new properties can’t be added to it, and its existing properties can’t be reconfigured or deleted. However, it’s possible that its existing properties can still be reassigned to different values. Primitives are always sealed.\n\n``` javascript\nvar sealedObject = Object.seal({});\nvar frozenObject = Object.freeze({});\n\nexpect(sealedObject).to.be.sealed;\nexpect(frozenObject).to.be.sealed;\nexpect(1).to.be.sealed;\n```\n\nAdd `.``not` earlier in the chain to negate `.``sealed`.\n\n``` javascript\nexpect({a: 1}).to.not.be.sealed;\n```\n\nA custom error message can be given as the second argument to `expect`.\n\n``` javascript\nexpect({a: 1}, 'nooo why fail??').to.be.sealed;\n```\n\n### .frozen\n\nAsserts that the target is frozen, which means that new properties can’t be added to it, and its existing properties can’t be reassigned to different values, reconfigured, or deleted. Primitives are always frozen.\n\n``` javascript\nvar frozenObject = Object.freeze({});\n\nexpect(frozenObject).to.be.frozen;\nexpect(1).to.be.frozen;\n```\n\nAdd `.``not` earlier in the chain to negate `.``frozen`.\n\n``` javascript\nexpect({a: 1}).to.not.be.frozen;\n```\n\nA custom error message can be given as the second argument to `expect`.\n\n``` javascript\nexpect({a: 1}, 'nooo why fail??').to.be.frozen;\n```\n\n### .finite\n\nAsserts that the target is a number, and isn’t `NaN` or positive/negative `Infinity`.\n\n``` javascript\nexpect(1).to.be.finite;\n```\n\nAdd `.``not` earlier in the chain to negate `.``finite`. However, it’s dangerous to do so. The problem is that it creates uncertain expectations by asserting that the subject either isn’t a number, or that it’s `NaN`, or that it’s positive `Infinity`, or that it’s negative `Infinity`. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.\n\nWhen the target isn’t expected to be a number, it’s often best to assert that it’s the expected type, rather than asserting that it isn’t one of many unexpected types.\n\n``` javascript\nexpect('foo').to.be.a('string'); // Recommended\nexpect('foo').to.not.be.finite; // Not recommended\n```\n\nWhen the target is expected to be `NaN`, it’s often best to assert exactly that.\n\n``` javascript\nexpect(NaN).to.be.NaN; // Recommended\nexpect(NaN).to.not.be.finite; // Not recommended\n```\n\nWhen the target is expected to be positive infinity, it’s often best to assert exactly that.\n\n``` javascript\nexpect(Infinity).to.equal(Infinity); // Recommended\nexpect(Infinity).to.not.be.finite; // Not recommended\n```\n\nWhen the target is expected to be negative infinity, it’s often best to assert exactly that.\n\n``` javascript\nexpect(-Infinity).to.equal(-Infinity); // Recommended\nexpect(-Infinity).to.not.be.finite; // Not recommended\n```\n\nA custom error message can be given as the second argument to `expect`.\n\n``` javascript\nexpect('foo', 'nooo why fail??').to.be.finite;\n```\n\n### .fail(\\[message\\])\n\n### .fail(actual, expected, \\[message\\], \\[operator\\])\n\n- @param { Mixed } actual\n- @param { Mixed } expected\n- @param { String } message\n- @param { String } operator\n\nThrow a failure.\n\n``` javascript\nexpect.fail();\nexpect.fail(\"custom error message\");\nexpect.fail(1, 2);\nexpect.fail(1, 2, \"custom error message\");\nexpect.fail(1, 2, \"custom error message\", \">\");\nexpect.fail(1, 2, undefined, \">\");\n```\n\n### .fail(\\[message\\])\n\n### .fail(actual, expected, \\[message\\], \\[operator\\])\n\n- @param { Mixed } actual\n- @param { Mixed } expected\n- @param { String } message\n- @param { String } operator\n\nThrow a failure.\n\n``` javascript\nshould.fail();\nshould.fail(\"custom error message\");\nshould.fail(1, 2);\nshould.fail(1, 2, \"custom error message\");\nshould.fail(1, 2, \"custom error message\", \">\");\nshould.fail(1, 2, undefined, \">\");\n```\n\n© 2017 Chai.js Assertion Library  \nLicensed under the MIT License.  \n[https://www.chaijs.com/api/bdd/](https://www.chaijs.com/api/bdd/)"
- name: below
  id: api/bdd/index#method_below
  summary: Asserts that the target is a number or a date less than the given number or date n respectively
  belongs_to: BDD
  description: |-
    ### .below(n\[, msg\])

    - @param { Number } n
    - @param { String } msg \_optional\_

    Asserts that the target is a number or a date less than the given number or date `n` respectively. However, it’s often best to assert that the target is equal to its expected value.

    ``` javascript
    expect(1).to.equal(1); // Recommended
    expect(1).to.be.below(2); // Not recommended
    ```

    Add `.``lengthOf` earlier in the chain to assert that the target’s `length` or `size` is less than the given number `n`.

    ``` javascript
    expect('foo').to.have.lengthOf(3); // Recommended
    expect('foo').to.have.lengthOf.below(4); // Not recommended

    expect([1, 2, 3]).to.have.length(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
    ```

    Add `.``not` earlier in the chain to negate `.``below`.

    ``` javascript
    expect(2).to.equal(2); // Recommended
    expect(2).to.not.be.below(1); // Not recommended
    ```

    `.``below` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect(2).to.be.below(1, 'nooo why fail??');
    expect(2, 'nooo why fail??').to.be.below(1);
    ```

    The aliases `.``lt` and `.``lessThan` can be used interchangeably with `.``below`.
- name: Building a Helper
  id: guide/helpers/index
  summary: This tutorial assumes that you are familiar with the plugin core concepts
  description: "# Building a Helper\n\n> This tutorial assumes that you are familiar with the plugin [core concepts](../plugins/index). If you have not yet read that article, it is recommended that you do so before continuing.\n\nProviding chainable helper assertions is the most common use of the plugin utilities that Chai exposes. Before we get into the basics, we are going to need a topic for which we will extend Chai’s assertions to comprehend. For this, we will be using a very minimal data model object.\n\n``` javascript\n/**\n * # Model\n *\n * A constructor for a simple data model\n * object. Has a `type` and contains arbitrary\n * attributes.\n *\n * @param {String} type\n */\n\nfunction Model (type) {\n  this._type = type;\n  this._attrs = {};\n}\n\n/**\n * .set (key, value)\n *\n * Set an attribute to be stored in this model.\n *\n * @param {String} key\n * @param {Mixted} value\n */\n\nModel.prototype.set = function (key, value) {\n  this._attrs[key] = value;\n};\n\n/**\n * .get (key)\n *\n * Get an attribute that is stored in this model.\n *\n * @param {String} key\n */\n\nModel.prototype.get = function (key) {\n  return this._attrs[key];\n};\n```\n\nPractically speaking, this could be any data model object returned from an ORM database in node or constructed from your MVC framework of choice in the browser.\n\nHopefully our `Model` class is self explanatory, but as an example, here we construct a person object.\n\n``` javascript\nvar arthur = new Model('person');\narthur.set('name', 'Arthur Dent');\narthur.set('occupation', 'traveller');\nconsole.log(arthur.get('name')); // Arthur Dent\n```\n\nNow that we have our subject, we can move on to the basics of plugins.\n\n## Adding Language Chains\n\nNow we are getting to the fun part! Adding properties and methods are what Chai’s plugin API is really for.\n\n### Adding Properties\n\nIn essence, defining a property can be done using `Object``.``defineProperty`, but we encourage you to use Chai’s utility helpers to ensure a standard implementation throughout.\n\nFor this example, we want the following test case to pass:\n\n``` javascript\nvar arthur = new Model('person');\nexpect(arthur).to.be.a.model;\n```\n\nFor this, we will use the `addProperty` utility.\n\n``` javascript\nutils.addProperty(Assertion.prototype, 'model', function () {\n  this.assert(\n      this._obj instanceof Model\n    , 'expected #{this} to be a Model'\n    , 'expected #{this} to not be a Model'\n  );\n});\n```\n\n[View addProperty API](../../api/plugins/index#method_addproperty)\n\nSimple and concise. Chai can take it from here. It is also worth mentioning that because this extension pattern is used so often, Chai makes it just a bit easier. The following can be used in place of the first line above:\n\n``` javascript\nAssertion.addProperty('model', function () { // ...\n```\n\nAll chain extension utilities are provided both as part of the `utils` object and directly on the Assertion constructor. For the rest of this document, however, we will be calling the methods directly from `Assertion`.\n\n### Adding Methods\n\n> Note: Multiple plugins defining the same method name using `addMethod` will conflict, with the last-registered plugin winning. The plugin API is pending a major overhaul in future versions of Chai that will, among other things, deal with this conflict. In the mean time, please prefer using `overwriteMethod`.\n\nThough a property is an elegant solution, it is likely not specific enough for the helper we are constructing. As our models have types, it would be beneficial to assert that our model is of a specific type. For this, we need a method.\n\n``` javascript\n// goal\nexpect(arthur).to.be.a.model('person');\n\n// language chain method\nAssertion.addMethod('model', function (type) {\n  var obj = this._obj;\n\n  // first, our instanceof check, shortcut\n  new Assertion(this._obj).to.be.instanceof(Model);\n\n  // second, our type check\n  this.assert(\n      obj._type === type\n    , \"expected #{this} to be of type #{exp} but got #{act}\"\n    , \"expected #{this} to not be of type #{act}\"\n    , type        // expected\n    , obj._type   // actual\n  );\n});\n```\n\n[View addMethod API](../../api/plugins/index#method_addmethod)\n\nAll calls to `assert` are synchronous, so if the first one fails the `AssertionError` is thrown and the second one will not be reached. It is up to the test runner to interpret the message and handle display of any failed assertions.\n\n### Methods as Properties\n\nChai includes a unique utility that allows you to construct a language chain that can function as either a property or a method. We call these “chainable methods”. Despite the fact that we demonstrated the “is model of model” as both a property and a method, these assertions are NOT a good use case for chainable methods.\n\n##### When to Use\n\nTo understand when to best use chainable methods we will examine a chainable method from Chai’s core.\n\n``` javascript\nvar arr = [ 1, 2, 3 ]\n  , obj = { a: 1, b: 2 };\n\nexpect(arr).to.contain(2);\nexpect(obj).to.contain.key('a');\n```\n\nFor this to work, two separate functions are needed. One that will be invoked when the chain is used as either a property or a method, and one that will be invoked when only used as a method.\n\nIn these examples, and with all of the other chainable methods in core, the only function of `contain` as a property is to set a `contains` flag to true. This indicates to `keys` to behave differently. In this case, when `key` is used in conjunction with `contain`, it will check for the inclusion of a key, instead of checking the exact match to all keys.\n\n##### When NOT to Use\n\nLet’s say we set up a chainable method for `model` to behave as we indicated above: do an `instanceof` check if used as a property, and a `_type` check if used as a method. The following conflict would occur…\n\nThe following would work…\n\n``` javascript\nexpect(arthur).to.be.a.model;\nexpect(arthur).to.be.a.model('person');\nexpect(arr).to.not.be.a.model;\n```\n\nBut the following would not…\n\n``` javascript\nexpect(arthur).to.not.be.a.model('person');\n```\n\nRemember, since the function used as the property assertion is invoked when also used as a method, and negation impacts ALL assertions after it is set, we would receive an error message resembling `expected`` ``[``object`` ``Model``]`` ``not`` ``to`` ``be`` ``instance`` ``of`` ``[``object`` ``Model``]`. As such, please obey this general guideline when constructing chainable methods.\n\n> When constructing chainable methods, the property function should only serve to set a flag for later modifying the behavior of an existing assertion.\n\n##### An Appropriate Example\n\nFor use with our model example, we are going to construct an example that allows us to test Arthur’s age exactly, or chain into Chai’s numerical comparators, such as `above`, `below`, and `within`. You will need to learn how to overwrite methods without destroying core functionality, but we get to that a bit later.\n\nOur goal will allow for all of the following to pass.\n\n``` javascript\nexpect(arthur).to.have.age(27);\nexpect(arthur).to.have.age.above(17);\nexpect(arthur).to.not.have.age.below(18);\n```\n\nLet’s start first by composing the two functions needed for a chainable method. First up is the function to use when invoking the `age` method.\n\n``` javascript\nfunction assertModelAge (n) {\n  // make sure we are working with a model\n  new Assertion(this._obj).to.be.instanceof(Model);\n\n  // make sure we have an age and its a number\n  var age = this._obj.get('age');\n  new Assertion(age).to.be.a('number');\n\n  // do our comparison\n  this.assert(\n      age === n\n    , \"expected #{this} to have have #{exp} but got #{act}\"\n    , \"expected #{this} to not have age #{act}\"\n    , n\n    , age\n  );\n}\n```\n\nBy now, that should be self-explanatory. Now for our property function.\n\n``` javascript\nfunction chainModelAge () {\n  utils.flag(this, 'model.age', true);\n}\n```\n\nWe will later teach our numerical comparators to look for that flag and change its behavior. Since we don’t want to break the core methods, we will need to safely override that method, but we’ll get to that in a minute. Let’s finish up here first…\n\n``` javascript\nAssertion.addChainableMethod('age', assertModelAge, chainModelAge);\n```\n\n[View addChainableMethod API](../../api/plugins/index#method_addchainablemethod)\n\nDone. Now we can assert Arthur’s exact age. We will pick up again with this example when learning how to overwrite methods.\n\n## Overwriting Language Chains\n\nNow that we can successfully add assertions to the language chain, we should work on being able to safely overwrite existing assertions, such as those from Chai’s core or other plugins.\n\nChai provides a number of utilities that allow you to overwrite existing behavior of an already existing assertion, but revert to the already defined assertion behavior if the subject of the assertion does not meet your criteria.\n\nLet’s start with a simple example of overwriting a property.\n\n### Overwriting Properties\n\nFor this example, we are going to overwrite the `ok` property provided by Chai’s core. The default behavior is that `ok` will pass if an object is truthy. We want to change that behavior so then when `ok` is used with an instance of a model, it validates that the model is well formed. In our example, we will consider a model `ok` if it has an `id` attribute.\n\nLet’s start out with the basic overwrite utility and a basic assertion.\n\n``` javascript\nchai.overwriteProperty('ok', function (_super) {\n  return function checkModel () {\n    var obj = this._obj;\n    if (obj && obj instanceof Model) {\n      new Assertion(obj).to.have.deep.property('_attrs.id').a('number');\n    } else {\n      _super.call(this);\n    }\n  };\n});\n```\n\n[View overwriteProperty API](../../api/plugins/index#method_overwriteproperty)\n\n##### Overwrite Structure\n\nAs you can see, the main difference in overwriting is that the first function passes just one argument of `_super`. This is the function that originally existed, and you should be sure to call that if your criteria doesn’t match. Secondly, you will notice that we immediately return a new function that will serve as the actual assertion.\n\nWith this in place, we can write positive assertions.\n\n``` javascript\nvar arthur = new Model('person');\narthur.set('id', 42);\nexpect(arthur).to.be.ok;\nexpect(true).to.be.ok;\n```\n\nThe above expectations will pass. When working with a model it will run our custom assertion, and when working with non-models it will revert to the original behavior. We will, however, run into a bit of trouble if we try to negate an `ok` assertion on a model.\n\n``` javascript\nvar arthur = new Model('person');\narthur.set('id', 'dont panic');\nexpect(arthur).to.not.be.ok;\n```\n\nWe would expect this expectation to pass as well, as our statement is negated and the id is not a number. Unfortunately, the negation flag was not passed to our number assertion, so it still expects the value to be a number.\n\n##### Transferring Flags\n\nFor this we will expand on this assertion by transferring all of the flags from the original assertion to our new assertion. The final property overwrite would look like this.\n\n``` javascript\nchai.overwriteProperty('ok', function (_super) {\n  return function checkModel () {\n    var obj = this._obj;\n    if (obj && obj instanceof Model) {\n      new Assertion(obj).to.have.deep.property('_attrs.id'); // we always want this\n      var assertId = new Assertion(obj._attrs.id);\n      utils.transferFlags(this, assertId, false); // false means don't transfer `object` flag\n      assertId.is.a('number');\n    } else {\n      _super.call(this);\n    }\n  };\n});\n```\n\nNow, the negation flag is included in your new assertion and we can successfully handle both positive and negative assertions on the type of id. We left the property assertion as it was as we always want it to fail if the id is not present.\n\n##### Enhancing Error Messages\n\nThough, we have one more small modification to make. Should our assertion fail for the wrong type of id attribute, we would get an error message that states `expected`` ``'``dont panic``'`` ``to`` ``[``not``]`` ``be`` ``a`` ``number`. Not entirely useful when running a large test suite, so we will provide it with a bit more information.\n\n``` javascript\nvar assertId = new Assertion(obj._attrs.id, 'model assert ok id type');\n```\n\nThis will change our error message to be a more informative `model`` ``assert`` ``ok`` ``id`` ``type``:`` ``expected`` ``'``dont panic``'`` ``to`` ``[``not``]`` ``be`` ``a`` ``number`. Much more informative!\n\n### Overwriting Methods\n\nOverwriting methods follow the same structure of overwriting properties. For this example we will be returning to our example of asserting Arthur’s age to be above a minimum threshold.\n\n``` javascript\nvar arthur = new Model('person');\narthur.set('age', 27);\nexpect(arthur).to.have.age.above(17);\n```\n\nWe already have our `age` chain in place to flag the assertion with `model``.``age` so all we have to do is check if that exists.\n\n``` javascript\nAssertion.overwriteMethod('above', function (_super) {\n  return function assertAge (n) {\n    if (utils.flag(this, 'model.age')) {\n      var obj = this._obj;\n\n      // first we assert we are actually working with a model\n      new Assertion(obj).instanceof(Model);\n\n      // next, make sure we have an age\n      new Assertion(obj).to.have.deep.property('_attrs.age').a('number');\n\n      // now we compare\n      var age = obj.get('age');\n      this.assert(\n          age > n\n        , \"expected #{this} to have an age above #{exp} but got #{act}\"\n        , \"expected #{this} to not have an age above #{exp} but got #{act}\"\n        , n\n        , age\n      );\n    } else {\n      _super.apply(this, arguments);\n    }\n  };\n});\n```\n\n[View overwriteMethod API](../../api/plugins/index#method_overwritemethod)\n\nThis covers both positive and negative scenarios. No need to transfer flags in this case as `this``.``assert` handles that automatically. The same pattern can also be used for `below` and `within`.\n\n© 2017 Chai.js Assertion Library  \nLicensed under the MIT License.  \n[https://www.chaijs.com/guide/helpers/](https://www.chaijs.com/guide/helpers/)"
- name: by
  id: api/bdd/index#method_by
  summary: When following an .``increase assertion in the chain, .``by asserts that the subject of the .``increase assertion increased by the given delta
  belongs_to: BDD
  description: |-
    ### .by(delta\[, msg\])

    - @param { Number } delta
    - @param { String } msg \_optional\_

    When following an `.``increase` assertion in the chain, `.``by` asserts that the subject of the `.``increase` assertion increased by the given `delta`.

    ``` javascript
    var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };

    expect(addTwo).to.increase(myObj, 'val').by(2);
    ```

    When following a `.``decrease` assertion in the chain, `.``by` asserts that the subject of the `.``decrease` assertion decreased by the given `delta`.

    ``` javascript
    var myObj = {val: 1}
      , subtractTwo = function () { myObj.val -= 2; };

    expect(subtractTwo).to.decrease(myObj, 'val').by(2);
    ```

    When following a `.``change` assertion in the chain, `.``by` asserts that the subject of the `.``change` assertion either increased or decreased by the given `delta`. However, it’s dangerous to use `.``change``.``by`. The problem is that it creates uncertain expectations. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.

    ``` javascript
    var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; }
      , subtractTwo = function () { myObj.val -= 2; };

    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
    expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended

    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
    expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
    ```

    Add `.``not` earlier in the chain to negate `.``by`. However, it’s often best to assert that the subject changed by its expected delta, rather than asserting that it didn’t change by one of countless unexpected deltas.

    ``` javascript
    var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };

    // Recommended
    expect(addTwo).to.increase(myObj, 'val').by(2);

    // Not recommended
    expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
    ```

    `.``by` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };

    expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
    expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
    ```
- name: change
  id: api/bdd/index#method_change
  summary: When one argument is provided, .``change asserts that the given function subject returns a different value when it’s invoked before the target function compared to when it’s invoked afterward
  belongs_to: BDD
  description: |-
    ### .change(subject\[, prop\[, msg\]\])

    - @param { String } subject
    - @param { String } prop name \_optional\_
    - @param { String } msg \_optional\_

    When one argument is provided, `.``change` asserts that the given function `subject` returns a different value when it’s invoked before the target function compared to when it’s invoked afterward. However, it’s often best to assert that `subject` is equal to its expected value.

    ``` javascript
    var dots = ''
      , addDot = function () { dots += '.'; }
      , getDots = function () { return dots; };

    // Recommended
    expect(getDots()).to.equal('');
    addDot();
    expect(getDots()).to.equal('.');

    // Not recommended
    expect(addDot).to.change(getDots);
    ```

    When two arguments are provided, `.``change` asserts that the value of the given object `subject`’s `prop` property is different before invoking the target function compared to afterward.

    ``` javascript
    var myObj = {dots: ''}
      , addDot = function () { myObj.dots += '.'; };

    // Recommended
    expect(myObj).to.have.property('dots', '');
    addDot();
    expect(myObj).to.have.property('dots', '.');

    // Not recommended
    expect(addDot).to.change(myObj, 'dots');
    ```

    Strict (`===`) equality is used to compare before and after values.

    Add `.``not` earlier in the chain to negate `.``change`.

    ``` javascript
    var dots = ''
      , noop = function () {}
      , getDots = function () { return dots; };

    expect(noop).to.not.change(getDots);

    var myObj = {dots: ''}
      , noop = function () {};

    expect(noop).to.not.change(myObj, 'dots');
    ```

    `.``change` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`. When not providing two arguments, always use the second form.

    ``` javascript
    var myObj = {dots: ''}
      , addDot = function () { myObj.dots += '.'; };

    expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');

    var dots = ''
      , addDot = function () { dots += '.'; }
      , getDots = function () { return dots; };

    expect(addDot, 'nooo why fail??').to.not.change(getDots);
    ```

    `.``change` also causes all `.``by` assertions that follow in the chain to assert how much a numeric subject was increased or decreased by. However, it’s dangerous to use `.``change``.``by`. The problem is that it creates uncertain expectations by asserting that the subject either increases by the given delta, or that it decreases by the given delta. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.

    ``` javascript
    var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; }
      , subtractTwo = function () { myObj.val -= 2; };

    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
    expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended

    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
    expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
    ```

    The alias `.``changes` can be used interchangeably with `.``change`.
- name: changes
  id: api/assert/index#method_changes
  summary: Asserts that a function changes the value of a property
  belongs_to: Assert
  description: |-
    ### .changes(function, object, property, \[message\])

    - @param { Function } modifier function
    - @param { Object } object or getter function
    - @param { String } property name \_optional\_
    - @param { String } message \_optional\_

    Asserts that a function changes the value of a property.

    ``` javascript
    var obj = { val: 10 };
    var fn = function() { obj.val = 22 };
    assert.changes(fn, obj, 'val');
    ```
- name: changesButNotBy
  id: api/assert/index#method_changesbutnotby
  summary: null
  belongs_to: Assert
  description: |-
    ### .changesButNotBy(function, object, property, delta, \[message\])

    - @param { Function } modifier function
    - @param { Object } object or getter function
    - @param { String } property name \_optional\_
    - @param { Number } change amount (delta)
    - @param { String } message \_optional\_

    Asserts that a function does not change the value of a property or of a function’s return value by an amount (delta)

    ``` javascript
    var obj = { val: 10 };
    var fn = function() { obj.val += 10 };
    assert.changesButNotBy(fn, obj, 'val', 5);
    ```
- name: changesBy
  id: api/assert/index#method_changesby
  summary: Asserts that a function changes the value of a property by an amount (delta)
  belongs_to: Assert
  description: |-
    ### .changesBy(function, object, property, delta, \[message\])

    - @param { Function } modifier function
    - @param { Object } object or getter function
    - @param { String } property name \_optional\_
    - @param { Number } change amount (delta)
    - @param { String } message \_optional\_

    Asserts that a function changes the value of a property by an amount (delta).

    ``` javascript
    var obj = { val: 10 };
    var fn = function() { obj.val += 2 };
    assert.changesBy(fn, obj, 'val', 2);
    ```
- name: closeTo
  id: api/bdd/index#method_closeto
  summary: Asserts that the target is a number that’s within a given +/- delta range of the given number expected
  belongs_to: BDD
  description: |-
    ### .closeTo(expected, delta\[, msg\])

    - @param { Number } expected
    - @param { Number } delta
    - @param { String } msg \_optional\_

    Asserts that the target is a number that’s within a given +/- `delta` range of the given number `expected`. However, it’s often best to assert that the target is equal to its expected value.

    ``` javascript
    // Recommended
    expect(1.5).to.equal(1.5);

    // Not recommended
    expect(1.5).to.be.closeTo(1, 0.5);
    expect(1.5).to.be.closeTo(2, 0.5);
    expect(1.5).to.be.closeTo(1, 1);
    ```

    Add `.``not` earlier in the chain to negate `.``closeTo`.

    ``` javascript
    expect(1.5).to.equal(1.5); // Recommended
    expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
    ```

    `.``closeTo` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
    expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
    ```

    The alias `.``approximately` can be used interchangeably with `.``closeTo`.
- name: closeTo
  id: api/assert/index#method_closeto
  summary: Asserts that the target is equal expected, to within a +/- delta range
  belongs_to: Assert
  description: |-
    ### .closeTo(actual, expected, delta, \[message\])

    - @param { Number } actual
    - @param { Number } expected
    - @param { Number } delta
    - @param { String } message

    Asserts that the target is equal `expected`, to within a +/- `delta` range.

    ``` javascript
    assert.closeTo(1.5, 1, 0.5, 'numbers are close');
    ```
- name: compareByInspect
  id: api/plugins/index#method_comparebyinspect
  summary: To be used as a compareFunction with Array.prototype.sort
  belongs_to: Plugin Utilities
  description: |-
    ### .compareByInspect(mixed, mixed)

    - @param { Mixed } first element to compare
    - @param { Mixed } second element to compare

    To be used as a compareFunction with Array.prototype.sort. Compares elements using inspect instead of default behavior of using toString so that Symbols and objects with irregular/missing toString can still be sorted without a TypeError.
- name: compatibleConstructor
  id: api/plugins/index#method_compatibleconstructor
  summary: Checks if two constructors are compatible
  belongs_to: Plugin Utilities
  description: |-
    ### .compatibleConstructor(thrown, errorLike)

    - @param { Error } thrown error
    - @param { Error \| ErrorConstructor } errorLike object to compare against

    Checks if two constructors are compatible. This function can receive either an error constructor or an error instance as the `errorLike` argument. Constructors are compatible if they’re the same or if one is an instance of another.
- name: compatibleInstance
  id: api/plugins/index#method_compatibleinstance
  summary: Checks if two instances are compatible (strict equal)
  belongs_to: Plugin Utilities
  description: |-
    ### .compatibleInstance(thrown, errorLike)

    - @param { Error } thrown error
    - @param { Error \| ErrorConstructor } errorLike object to compare against

    Checks if two instances are compatible (strict equal). Returns false if errorLike is not an instance of Error, because instances can only be compatible if they’re both error instances.
- name: compatibleMessage
  id: api/plugins/index#method_compatiblemessage
  summary: Checks if an error’s message is compatible with a matcher (String or RegExp)
  belongs_to: Plugin Utilities
  description: |-
    ### .compatibleMessage(thrown, errMatcher)

    - @param { Error } thrown error
    - @param { String \| RegExp } errMatcher to look for into the message

    Checks if an error’s message is compatible with a matcher (String or RegExp). If the message contains the String or passes the RegExp test, it is considered compatible.
- name: containsAllDeepKeys
  id: api/assert/index#method_containsalldeepkeys
  summary: Asserts that object contains all of the keys provided
  belongs_to: Assert
  description: |-
    ### .containsAllDeepKeys(object, \[keys\], \[message\])

    - @param { Mixed } object
    - @param { Array \| Object } keys
    - @param { String } message

    Asserts that `object` contains all of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.

    ``` javascript
    assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
    assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
    assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    ```
- name: containsAllKeys
  id: api/assert/index#method_containsallkeys
  summary: Asserts that object has all of the keys provided but may have more keys not listed
  belongs_to: Assert
  description: |-
    ### .containsAllKeys(object, \[keys\], \[message\])

    - @param { Mixed } object
    - @param { Array. } keys
    - @param { String } message

    Asserts that `object` has all of the `keys` provided but may have more keys not listed. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.

    ``` javascript
    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);
    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
    assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
    assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);
    assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
    assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);
    assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
    ```
- name: Core Plugin Concepts
  id: guide/plugins/index
  summary: Plugins are for more than just writing vendor integrations
  description: "# Core Plugin Concepts\n\nPlugins are for more than just writing vendor integrations. As a tester, one can write a plugin to validate input data, assert schema validation on an object, or ensure proper behavior on a DOM element. The API is flexible enough that any synchronous tasks can easily be encapsulated within a single assertion and reused throughout your tests.\n\nThis tutorial will show you how to access Chai’s plugin API, use flags to transfer data through the language chain, and write your first assertion (and thorough error messages). Once you have finished here, [Building a Helper](../helpers/index) will show you how to compose properties and methods for use on the Chai language chain.\n\n## Accessing Utilities\n\nChai comes with a number of utilities to assist in the construction of assertions, but it does not provide these directly on the `chai` export. These can be accessed by using the `use` method of the chai export, which accepts a single function as an argument.\n\n``` javascript\nchai.use(function (_chai, utils) {\n  // ...\n});\n```\n\nThe function which will be used gets passed two parameters to its scope. The first is the `chai` export, the second is an object containing a number of utility methods (we’ll get to those in a minute).\n\nThe `chai` export is included so that you can build helpers that can be used in multiple test files, or package your helpers as a plugin to share with the community. A more appropriate pattern for creating helpers is as follows…\n\nFor our helper file: `test``/``helpers``/``model``.``js`\n\n``` javascript\nmodule.exports = function (chai, utils) {\n  var Assertion = chai.Assertion;\n\n  // your helpers here\n};\n```\n\nAnd, for our actual test: `test``/``person``.``js`\n\n``` javascript\nvar chai = require('chai')\n  , chaiModel = require('./helpers/model')\n  , expect = chai.expect;\n\nchai.use(chaiModel);\n```\n\nFor the rest of this document, we will assume this structure…\n\n- helper in external file\n- `chai``.``Assertion` assigned to the `Assertion` variable\n- all of our helpers will be inside exported function, located where indicated\n\nThe `Assertion` variable is now a constructor for an assertion chain; `new`` ``Assertion``(``obj``)` is now equivalent to `expect``(``obj``)`.\n\n## Using Flags\n\nThe upper-most core concept of how assertions work internally is the concept of flags. Each assertion has a set of mostly arbitrary flags - key:value pairs - associated with it. Chai uses a small number of these internally, but the store is also available for developers to expand on.\n\n### flag usage\n\nThe flag utility is exposed as `utils``.``flag` from within our `use` function. It can function as either a getter or a setter, depending on the number of arguments passed to it.\n\n``` javascript\nvar myAssert = new Assertion(obj);\nutils.flag(myAssert, 'owner', 'me'); // sets key `owner` to `me`\nvar owner = utils.flag(myAssert, 'owner'); // get key `owner', returns value\n```\n\n### object flag\n\nThe most important of Chai’s reserved flags is the `object` flag. This is the subject of an assertion.\n\n``` javascript\nvar myAssert = new Assertion('Arthur Dent');\nvar obj = flag(myAssert, 'object'); // obj === 'Arthur Dent';\n```\n\nThis flag is so often used that a shortcut was provided as the `_obj` property of a constructed assertion.\n\n``` javascript\nvar obj = myAssert._obj; // obj === `Arthur Dent`\n```\n\nThe following flags are used by Chai’s core assertions. Side effects may occur should you interfere with these.\n\n- `object`: (see above)\n- `ssfi`: start stack function - used to prevent callback stacks from being shown in errors.\n- `message`: additional information to include with an error when using `assert` interface.\n- `negate`: set when `.``not` is included in the chain.\n- `deep`: set when `.``deep` is included in the chain. used by `equal` and `property`\n- `contains`: set when `include` or `contain` is used as a property. changes the behavior of `keys`.\n- `lengthOf`: set when `length` is used as a property. changes the behavior of `above`, `below`, and `within`.\n\n## Composing an Assertion\n\nBefore we begin adding methods and properties to the language chain, we should first examine how to invoke an assertion, and the expected behavior should it fail.\n\nFor this, each constructed `Assertion` has a method called simply `assert`. It accepts many parameters and its behavior can change depending on whether an assertion was negated or not.\n\n### Basic Assertion\n\nTo begin, we will construct Arthur again, then we can assert that he is who he says he is.\n\n``` javascript\nvar arthur = new Assertion('Arthur Dent');\n\narthur.assert(\n    arthur._obj === 'Arthur Dent'\n  , \"expected #{this} to be 'Arthur Dent'\"\n  , \"expected #{this} to not be 'Arthur Dent'\"\n);\n```\n\nChai will check the first argument; if it is `true` then the assertion passed, but if it is `false` the assertion failed and the first error message will be thrown as part of a `chai``.``AssertionError`. Conversely, if the language chain was negated, it will consider `false` a pass and `true` a failure. The second error message will be included in the thrown error instead.\n\nIn all, the `assert` method accepts six arguments:\n\n1.  a boolean (result of a truth test)\n2.  a string error message to be used if the first argument is `false`\n3.  a string error message to be used if the assertion is negated and the first argument is `true`\n4.  (optional) the expected value\n5.  (optional) the actual value, which will default to `_obj`\n6.  (optional) a boolean which indicates whether to display a diff in addition to the message if the first argument is `false`\n\n### Composing Error Messages\n\nAs you can see from the above example, Chai can accept template tags to dynamically compose the error message. When used, these template tags will be replaced with a stringified replacement of the object in question. There are three template tags available.\n\n- `#``{``this``}`: the `_obj` of the assertion\n- `#``{``exp``}`: the expected value, if it was provided in `assert`\n- `#``{``act``}`: the actual value, defaults to `_obj` but can be overwritten by value provided in `assert`\n\n© 2017 Chai.js Assertion Library  \nLicensed under the MIT License.  \n[https://www.chaijs.com/guide/plugins/](https://www.chaijs.com/guide/plugins/)"
- name: decrease
  id: api/bdd/index#method_decrease
  summary: When one argument is provided, .``decrease asserts that the given function subject returns a lesser number when it’s invoked after invoking the target function compared to when it’s invoked beforehand
  belongs_to: BDD
  description: |-
    ### .decrease(subject\[, prop\[, msg\]\])

    - @param { String \| Function } subject
    - @param { String } prop name \_optional\_
    - @param { String } msg \_optional\_

    When one argument is provided, `.``decrease` asserts that the given function `subject` returns a lesser number when it’s invoked after invoking the target function compared to when it’s invoked beforehand. `.``decrease` also causes all `.``by` assertions that follow in the chain to assert how much lesser of a number is returned. It’s often best to assert that the return value decreased by the expected amount, rather than asserting it decreased by any amount.

    ``` javascript
    var val = 1
      , subtractTwo = function () { val -= 2; }
      , getVal = function () { return val; };

    expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
    expect(subtractTwo).to.decrease(getVal); // Not recommended
    ```

    When two arguments are provided, `.``decrease` asserts that the value of the given object `subject`’s `prop` property is lesser after invoking the target function compared to beforehand.

    ``` javascript
    var myObj = {val: 1}
      , subtractTwo = function () { myObj.val -= 2; };

    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
    expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
    ```

    Add `.``not` earlier in the chain to negate `.``decrease`. However, it’s dangerous to do so. The problem is that it creates uncertain expectations by asserting that the subject either increases, or that it stays the same. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.

    When the subject is expected to increase, it’s often best to assert that it increased by the expected amount.

    ``` javascript
    var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };

    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
    expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
    ```

    When the subject is expected to stay the same, it’s often best to assert exactly that.

    ``` javascript
    var myObj = {val: 1}
      , noop = function () {};

    expect(noop).to.not.change(myObj, 'val'); // Recommended
    expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
    ```

    `.``decrease` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`. When not providing two arguments, always use the second form.

    ``` javascript
    var myObj = {val: 1}
      , noop = function () {};

    expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');

    var val = 1
      , noop = function () {}
      , getVal = function () { return val; };

    expect(noop, 'nooo why fail??').to.decrease(getVal);
    ```

    The alias `.``decreases` can be used interchangeably with `.``decrease`.
- name: decreases
  id: api/assert/index#method_decreases
  summary: Asserts that a function decreases a numeric object property
  belongs_to: Assert
  description: |-
    ### .decreases(function, object, property, \[message\])

    - @param { Function } modifier function
    - @param { Object } object or getter function
    - @param { String } property name \_optional\_
    - @param { String } message \_optional\_

    Asserts that a function decreases a numeric object property.

    ``` javascript
    var obj = { val: 10 };
    var fn = function() { obj.val = 5 };
    assert.decreases(fn, obj, 'val');
    ```
- name: decreasesButNotBy
  id: api/assert/index#method_decreasesbutnotby
  summary: null
  belongs_to: Assert
  description: |-
    ### .decreasesButNotBy(function, object, property, delta, \[message\])

    - @param { Function } modifier function
    - @param { Object } object or getter function
    - @param { String } property name \_optional\_
    - @param { Number } change amount (delta)
    - @param { String } message \_optional\_

    Asserts that a function does not decreases a numeric object property or a function’s return value by an amount (delta)

    ``` javascript
    var obj = { val: 10 };
    var fn = function() { obj.val = 5 };
    assert.decreasesButNotBy(fn, obj, 'val', 1);
    ```
- name: decreasesBy
  id: api/assert/index#method_decreasesby
  summary: null
  belongs_to: Assert
  description: |-
    ### .decreasesBy(function, object, property, delta, \[message\])

    - @param { Function } modifier function
    - @param { Object } object or getter function
    - @param { String } property name \_optional\_
    - @param { Number } change amount (delta)
    - @param { String } message \_optional\_

    Asserts that a function decreases a numeric object property or a function’s return value by an amount (delta)

    ``` javascript
    var obj = { val: 10 };
    var fn = function() { obj.val -= 5 };
    assert.decreasesBy(fn, obj, 'val', 5);
    ```
- name: deep
  id: api/bdd/index#method_deep
  summary: Causes all .``equal, .``include, .``members, .``keys, and .``property assertions that follow in the chain to use deep equality instead of strict (===) equality
  belongs_to: BDD
  description: |-
    ### .deep

    Causes all `.``equal`, `.``include`, `.``members`, `.``keys`, and `.``property` assertions that follow in the chain to use deep equality instead of strict (`===`) equality. See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.

    ``` javascript
    // Target object deeply (but not strictly) equals `{a: 1}`
    expect({a: 1}).to.deep.equal({a: 1});
    expect({a: 1}).to.not.equal({a: 1});

    // Target array deeply (but not strictly) includes `{a: 1}`
    expect([{a: 1}]).to.deep.include({a: 1});
    expect([{a: 1}]).to.not.include({a: 1});

    // Target object deeply (but not strictly) includes `x: {a: 1}`
    expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
    expect({x: {a: 1}}).to.not.include({x: {a: 1}});

    // Target array deeply (but not strictly) has member `{a: 1}`
    expect([{a: 1}]).to.have.deep.members([{a: 1}]);
    expect([{a: 1}]).to.not.have.members([{a: 1}]);

    // Target set deeply (but not strictly) has key `{a: 1}`
    expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
    expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);

    // Target object deeply (but not strictly) has property `x: {a: 1}`
    expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
    expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
    ```
- name: deepEqual
  id: api/assert/index#method_deepequal
  summary: Asserts that actual is deeply equal to expected
  belongs_to: Assert
  description: |-
    ### .deepEqual(actual, expected, \[message\])

    - @param { Mixed } actual
    - @param { Mixed } expected
    - @param { String } message

    Asserts that `actual` is deeply equal to `expected`.

    ``` javascript
    assert.deepEqual({ tea: 'green' }, { tea: 'green' });
    ```
- name: deepInclude
  id: api/assert/index#method_deepinclude
  summary: Asserts that haystack includes needle
  belongs_to: Assert
  description: |-
    ### .deepInclude(haystack, needle, \[message\])

    - @param { Array \| String } haystack
    - @param { Mixed } needle
    - @param { String } message

    Asserts that `haystack` includes `needle`. Can be used to assert the inclusion of a value in an array or a subset of properties in an object. Deep equality is used.

    ``` javascript
    var obj1 = {a: 1}
      , obj2 = {b: 2};
    assert.deepInclude([obj1, obj2], {a: 1});
    assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
    assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});
    ```
- name: deepNestedInclude
  id: api/assert/index#method_deepnestedinclude
  summary: Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while checking for deep equality
  belongs_to: Assert
  description: |-
    ### .deepNestedInclude(haystack, needle, \[message\])

    - @param { Object } haystack
    - @param { Object } needle
    - @param { String } message

    Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while checking for deep equality. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\[\]’ and ‘.’ in property names can be escaped using double backslashes.

    ``` javascript
    assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});
    assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {x: 1}});
    ```
- name: deepNestedPropertyVal
  id: api/assert/index#method_deepnestedpropertyval
  summary: Asserts that object has a property named by property with a value given by value
  belongs_to: Assert
  description: |-
    ### .deepNestedPropertyVal(object, property, value, \[message\])

    - @param { Object } object
    - @param { String } property
    - @param { Mixed } value
    - @param { String } message

    Asserts that `object` has a property named by `property` with a value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a deep equality check.

    ``` javascript
    assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });
    ```
- name: deepOwnInclude
  id: api/assert/index#method_deepowninclude
  summary: Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties and checking for deep equality
  belongs_to: Assert
  description: |-
    ### .deepOwnInclude(haystack, needle, \[message\])

    - @param { Object } haystack
    - @param { Object } needle
    - @param { String } message

    Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties and checking for deep equality.

    ``` javascript
     assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});
    ```
- name: deepPropertyVal
  id: api/assert/index#method_deeppropertyval
  summary: Asserts that object has a direct or inherited property named by property with a value given by value
  belongs_to: Assert
  description: |-
    ### .deepPropertyVal(object, property, value, \[message\])

    - @param { Object } object
    - @param { String } property
    - @param { Mixed } value
    - @param { String } message

    Asserts that `object` has a direct or inherited property named by `property` with a value given by `value`. Uses a deep equality check.

    ``` javascript
    assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
    ```
- name: doesNotChange
  id: api/assert/index#method_doesnotchange
  summary: Asserts that a function does not change the value of a property
  belongs_to: Assert
  description: |-
    ### .doesNotChange(function, object, property, \[message\])

    - @param { Function } modifier function
    - @param { Object } object or getter function
    - @param { String } property name \_optional\_
    - @param { String } message \_optional\_

    Asserts that a function does not change the value of a property.

    ``` javascript
    var obj = { val: 10 };
    var fn = function() { console.log('foo'); };
    assert.doesNotChange(fn, obj, 'val');
    ```
- name: doesNotDecrease
  id: api/assert/index#method_doesnotdecrease
  summary: Asserts that a function does not decreases a numeric object property
  belongs_to: Assert
  description: |-
    ### .doesNotDecrease(function, object, property, \[message\])

    - @param { Function } modifier function
    - @param { Object } object or getter function
    - @param { String } property name \_optional\_
    - @param { String } message \_optional\_

    Asserts that a function does not decreases a numeric object property.

    ``` javascript
    var obj = { val: 10 };
    var fn = function() { obj.val = 15 };
    assert.doesNotDecrease(fn, obj, 'val');
    ```
- name: doesNotDecreaseBy
  id: api/assert/index#method_doesnotdecreaseby
  summary: null
  belongs_to: Assert
  description: |-
    ### .doesNotDecreaseBy(function, object, property, delta, \[message\])

    - @param { Function } modifier function
    - @param { Object } object or getter function
    - @param { String } property name \_optional\_
    - @param { Number } change amount (delta)
    - @param { String } message \_optional\_

    Asserts that a function does not decreases a numeric object property or a function’s return value by an amount (delta)

    ``` javascript
    var obj = { val: 10 };
    var fn = function() { obj.val = 5 };
    assert.doesNotDecreaseBy(fn, obj, 'val', 1);
    ```
- name: doesNotHaveAllDeepKeys
  id: api/assert/index#method_doesnothavealldeepkeys
  summary: Asserts that object does not have at least one of the keys provided
  belongs_to: Assert
  description: |-
    ### .doesNotHaveAllDeepKeys(object, \[keys\], \[message\])

    - @param { Mixed } object
    - @param { Array \| Object } keys
    - @param { String } message

    Asserts that `object` does not have at least one of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.

    ``` javascript
    assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);
    assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);
    ```
- name: doesNotHaveAllKeys
  id: api/assert/index#method_doesnothaveallkeys
  summary: Asserts that object does not have at least one of the keys provided
  belongs_to: Assert
  description: |-
    ### .doesNotHaveAllKeys(object, \[keys\], \[message\])

    - @param { Mixed } object
    - @param { Array. } keys
    - @param { String } message

    Asserts that `object` does not have at least one of the `keys` provided. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.

    ``` javascript
    assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
    assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
    assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
    assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
    ```
- name: doesNotHaveAnyDeepKeys
  id: api/assert/index#method_doesnothaveanydeepkeys
  summary: Asserts that object has none of the keys provided
  belongs_to: Assert
  description: |-
    ### .doesNotHaveAnyDeepKeys(object, \[keys\], \[message\])

    - @param { Mixed } object
    - @param { Array \| Object } keys
    - @param { String } message

    Asserts that `object` has none of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.

    ``` javascript
    assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    ```
- name: doesNotHaveAnyKeys
  id: api/assert/index#method_doesnothaveanykeys
  summary: Asserts that object has none of the keys provided
  belongs_to: Assert
  description: |-
    ### .doesNotHaveAnyKeys(object, \[keys\], \[message\])

    - @param { Mixed } object
    - @param { Array. } keys
    - @param { String } message

    Asserts that `object` has none of the `keys` provided. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.

    ``` javascript
    assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
    assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
    assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
    assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
    ```
- name: doesNotIncrease
  id: api/assert/index#method_doesnotincrease
  summary: Asserts that a function does not increase a numeric object property
  belongs_to: Assert
  description: |-
    ### .doesNotIncrease(function, object, property, \[message\])

    - @param { Function } modifier function
    - @param { Object } object or getter function
    - @param { String } property name \_optional\_
    - @param { String } message \_optional\_

    Asserts that a function does not increase a numeric object property.

    ``` javascript
    var obj = { val: 10 };
    var fn = function() { obj.val = 8 };
    assert.doesNotIncrease(fn, obj, 'val');
    ```
- name: doesNotThrow
  id: api/assert/index#method_doesnotthrow
  summary: If errorLike is an Error constructor, asserts that fn will not throw an error that is an instance of errorLike
  belongs_to: Assert
  description: |-
    ### .doesNotThrow(fn, \[errorLike/string/regexp\], \[string/regexp\], \[message\])

    - @param { Function } fn
    - @param { ErrorConstructor } errorLike
    - @param { RegExp \| String } errMsgMatcher
    - @param { String } message
    - @see [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types)

    If `errorLike` is an `Error` constructor, asserts that `fn` will *not* throw an error that is an instance of `errorLike`. If `errorLike` is an `Error` instance, asserts that the error thrown is *not* the same instance as `errorLike`. If `errMsgMatcher` is provided, it also asserts that the error thrown will *not* have a message matching `errMsgMatcher`.

    ``` javascript
    assert.doesNotThrow(fn, 'Any Error thrown must not have this message');
    assert.doesNotThrow(fn, /Any Error thrown must not match this/);
    assert.doesNotThrow(fn, Error);
    assert.doesNotThrow(fn, errorInstance);
    assert.doesNotThrow(fn, Error, 'Error must not have this message');
    assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');
    assert.doesNotThrow(fn, Error, /Error must not match this/);
    assert.doesNotThrow(fn, errorInstance, /Error must not match this/);
    ```
- name: empty
  id: api/bdd/index#method_empty
  summary: When the target is a string or array, .``empty asserts that the target’s length property is strictly (===) equal to 0
  belongs_to: BDD
  description: |-
    ### .empty

    When the target is a string or array, `.``empty` asserts that the target’s `length` property is strictly (`===`) equal to `0`.

    ``` javascript
    expect([]).to.be.empty;
    expect('').to.be.empty;
    ```

    When the target is a map or set, `.``empty` asserts that the target’s `size` property is strictly equal to `0`.

    ``` javascript
    expect(new Set()).to.be.empty;
    expect(new Map()).to.be.empty;
    ```

    When the target is a non-function object, `.``empty` asserts that the target doesn’t have any own enumerable properties. Properties with Symbol-based keys are excluded from the count.

    ``` javascript
    expect({}).to.be.empty;
    ```

    Because `.``empty` does different things based on the target’s type, it’s important to check the target’s type before using `.``empty`. See the `.``a` doc for info on testing a target’s type.

    ``` javascript
    expect([]).to.be.an('array').that.is.empty;
    ```

    Add `.``not` earlier in the chain to negate `.``empty`. However, it’s often best to assert that the target contains its expected number of values, rather than asserting that it’s not empty.

    ``` javascript
    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.not.be.empty; // Not recommended

    expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
    expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended

    expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
    expect({a: 1}).to.not.be.empty; // Not recommended
    ```

    A custom error message can be given as the second argument to `expect`.

    ``` javascript
    expect([1, 2, 3], 'nooo why fail??').to.be.empty;
    ```
- name: eql
  id: api/bdd/index#method_eql
  summary: Asserts that the target is deeply equal to the given obj
  belongs_to: BDD
  description: |-
    ### .eql(obj\[, msg\])

    - @param { Mixed } obj
    - @param { String } msg \_optional\_

    Asserts that the target is deeply equal to the given `obj`. See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.

    ``` javascript
    // Target object is deeply (but not strictly) equal to {a: 1}
    expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});

    // Target array is deeply (but not strictly) equal to [1, 2]
    expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
    ```

    Add `.``not` earlier in the chain to negate `.``eql`. However, it’s often best to assert that the target is deeply equal to its expected value, rather than not deeply equal to one of countless unexpected values.

    ``` javascript
    expect({a: 1}).to.eql({a: 1}); // Recommended
    expect({a: 1}).to.not.eql({b: 2}); // Not recommended
    ```

    `.``eql` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
    expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
    ```

    The alias `.``eqls` can be used interchangeably with `.``eql`.

    The `.``deep``.``equal` assertion is almost identical to `.``eql` but with one difference: `.``deep``.``equal` causes deep equality comparisons to also be used for any other assertions that follow in the chain.
- name: equal
  id: api/bdd/index#method_equal
  summary: Asserts that the target is strictly (===) equal to the given val
  belongs_to: BDD
  description: |-
    ### .equal(val\[, msg\])

    - @param { Mixed } val
    - @param { String } msg \_optional\_

    Asserts that the target is strictly (`===`) equal to the given `val`.

    ``` javascript
    expect(1).to.equal(1);
    expect('foo').to.equal('foo');
    ```

    Add `.``deep` earlier in the chain to use deep equality instead. See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.

    ``` javascript
    // Target object deeply (but not strictly) equals `{a: 1}`
    expect({a: 1}).to.deep.equal({a: 1});
    expect({a: 1}).to.not.equal({a: 1});

    // Target array deeply (but not strictly) equals `[1, 2]`
    expect([1, 2]).to.deep.equal([1, 2]);
    expect([1, 2]).to.not.equal([1, 2]);
    ```

    Add `.``not` earlier in the chain to negate `.``equal`. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to one of countless unexpected values.

    ``` javascript
    expect(1).to.equal(1); // Recommended
    expect(1).to.not.equal(2); // Not recommended
    ```

    `.``equal` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect(1).to.equal(2, 'nooo why fail??');
    expect(1, 'nooo why fail??').to.equal(2);
    ```

    The aliases `.``equals` and `eq` can be used interchangeably with `.``equal`.
- name: equal
  id: api/assert/index#method_equal
  summary: Asserts non-strict equality (==) of actual and expected
  belongs_to: Assert
  description: |-
    ### .equal(actual, expected, \[message\])

    - @param { Mixed } actual
    - @param { Mixed } expected
    - @param { String } message

    Asserts non-strict equality (`==`) of `actual` and `expected`.

    ``` javascript
    assert.equal(3, '3', '== coerces values to strings');
    ```
- name: exist
  id: api/bdd/index#method_exist
  summary: Asserts that the target is not strictly (===) equal to either null or undefined
  belongs_to: BDD
  description: |-
    ### .exist

    Asserts that the target is not strictly (`===`) equal to either `null` or `undefined`. However, it’s often best to assert that the target is equal to its expected value.

    ``` javascript
    expect(1).to.equal(1); // Recommended
    expect(1).to.exist; // Not recommended

    expect(0).to.equal(0); // Recommended
    expect(0).to.exist; // Not recommended
    ```

    Add `.``not` earlier in the chain to negate `.``exist`.

    ``` javascript
    expect(null).to.be.null; // Recommended
    expect(null).to.not.exist; // Not recommended

    expect(undefined).to.be.undefined; // Recommended
    expect(undefined).to.not.exist; // Not recommended
    ```

    A custom error message can be given as the second argument to `expect`.

    ``` javascript
    expect(null, 'nooo why fail??').to.exist;
    ```

    The alias `.``exists` can be used interchangeably with `.``exist`.
- name: exists
  id: api/assert/index#method_exists
  summary: Asserts that the target is neither null nor undefined
  belongs_to: Assert
  description: |-
    ### .exists

    - @param { Mixed } value
    - @param { String } message

    Asserts that the target is neither `null` nor `undefined`.

    ``` javascript
    var foo = 'hi';

    assert.exists(foo, 'foo is neither `null` nor `undefined`');
    ```
- name: expectTypes
  id: api/plugins/index#method_expecttypes
  summary: Ensures that the object being tested against is of a valid type
  belongs_to: Plugin Utilities
  description: |-
    ### .expectTypes(obj, types)

    - @param { Mixed } obj constructed Assertion
    - @param { Array } type A list of allowed types for this assertion

    Ensures that the object being tested against is of a valid type.

    ``` javascript
    utils.expectTypes(this, ['array', 'object', 'string']);
    ```
- name: extensible
  id: api/bdd/index#method_extensible
  summary: Asserts that the target is extensible, which means that new properties can be added to it
  belongs_to: BDD
  description: |-
    ### .extensible

    Asserts that the target is extensible, which means that new properties can be added to it. Primitives are never extensible.

    ``` javascript
    expect({a: 1}).to.be.extensible;
    ```

    Add `.``not` earlier in the chain to negate `.``extensible`.

    ``` javascript
    var nonExtensibleObject = Object.preventExtensions({})
      , sealedObject = Object.seal({})
      , frozenObject = Object.freeze({});

    expect(nonExtensibleObject).to.not.be.extensible;
    expect(sealedObject).to.not.be.extensible;
    expect(frozenObject).to.not.be.extensible;
    expect(1).to.not.be.extensible;
    ```

    A custom error message can be given as the second argument to `expect`.

    ``` javascript
    expect(1, 'nooo why fail??').to.be.extensible;
    ```
- name: fail
  id: api/bdd/index#method_fail
  summary: Throw a failure
  belongs_to: BDD
  description: "### .fail(\\[message\\])\n\n### .fail(actual, expected, \\[message\\], \\[operator\\])\n\n- @param { Mixed } actual\n- @param { Mixed } expected\n- @param { String } message\n- @param { String } operator\n\nThrow a failure.\n\n``` javascript\nexpect.fail();\nexpect.fail(\"custom error message\");\nexpect.fail(1, 2);\nexpect.fail(1, 2, \"custom error message\");\nexpect.fail(1, 2, \"custom error message\", \">\");\nexpect.fail(1, 2, undefined, \">\");\n```\n\n### .fail(\\[message\\])\n\n### .fail(actual, expected, \\[message\\], \\[operator\\])\n\n- @param { Mixed } actual\n- @param { Mixed } expected\n- @param { String } message\n- @param { String } operator\n\nThrow a failure.\n\n``` javascript\nshould.fail();\nshould.fail(\"custom error message\");\nshould.fail(1, 2);\nshould.fail(1, 2, \"custom error message\");\nshould.fail(1, 2, \"custom error message\", \">\");\nshould.fail(1, 2, undefined, \">\");\n```\n\n© 2017 Chai.js Assertion Library  \nLicensed under the MIT License.  \n[https://www.chaijs.com/api/bdd/](https://www.chaijs.com/api/bdd/)"
- name: fail
  id: api/assert/index#method_fail
  summary: Throw a failure
  belongs_to: Assert
  description: |-
    ### .fail(\[message\])

    ### .fail(actual, expected, \[message\], \[operator\])

    - @param { Mixed } actual
    - @param { Mixed } expected
    - @param { String } message
    - @param { String } operator

    Throw a failure. Node.js `assert` module-compatible.

    ``` javascript
    assert.fail();
    assert.fail("custom error message");
    assert.fail(1, 2);
    assert.fail(1, 2, "custom error message");
    assert.fail(1, 2, "custom error message", ">");
    assert.fail(1, 2, undefined, ">");
    ```
- name: 'false'
  id: api/bdd/index#method_false
  summary: Asserts that the target is strictly (===) equal to false
  belongs_to: BDD
  description: |-
    ### .false

    Asserts that the target is strictly (`===`) equal to `false`.

    ``` javascript
    expect(false).to.be.false;
    ```

    Add `.``not` earlier in the chain to negate `.``false`. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to `false`.

    ``` javascript
    expect(true).to.be.true; // Recommended
    expect(true).to.not.be.false; // Not recommended

    expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.false; // Not recommended
    ```

    A custom error message can be given as the second argument to `expect`.

    ``` javascript
    expect(true, 'nooo why fail??').to.be.false;
    ```
- name: finite
  id: api/bdd/index#method_finite
  summary: Asserts that the target is a number, and isn’t NaN or positive/negative Infinity
  belongs_to: BDD
  description: |-
    ### .finite

    Asserts that the target is a number, and isn’t `NaN` or positive/negative `Infinity`.

    ``` javascript
    expect(1).to.be.finite;
    ```

    Add `.``not` earlier in the chain to negate `.``finite`. However, it’s dangerous to do so. The problem is that it creates uncertain expectations by asserting that the subject either isn’t a number, or that it’s `NaN`, or that it’s positive `Infinity`, or that it’s negative `Infinity`. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.

    When the target isn’t expected to be a number, it’s often best to assert that it’s the expected type, rather than asserting that it isn’t one of many unexpected types.

    ``` javascript
    expect('foo').to.be.a('string'); // Recommended
    expect('foo').to.not.be.finite; // Not recommended
    ```

    When the target is expected to be `NaN`, it’s often best to assert exactly that.

    ``` javascript
    expect(NaN).to.be.NaN; // Recommended
    expect(NaN).to.not.be.finite; // Not recommended
    ```

    When the target is expected to be positive infinity, it’s often best to assert exactly that.

    ``` javascript
    expect(Infinity).to.equal(Infinity); // Recommended
    expect(Infinity).to.not.be.finite; // Not recommended
    ```

    When the target is expected to be negative infinity, it’s often best to assert exactly that.

    ``` javascript
    expect(-Infinity).to.equal(-Infinity); // Recommended
    expect(-Infinity).to.not.be.finite; // Not recommended
    ```

    A custom error message can be given as the second argument to `expect`.

    ``` javascript
    expect('foo', 'nooo why fail??').to.be.finite;
    ```
- name: flag
  id: api/plugins/index#method_flag
  summary: Get or set a flag value on an object
  belongs_to: Plugin Utilities
  description: |-
    ### .flag(object, key, \[value\])

    - @param { Object } object constructed Assertion
    - @param { String } key
    - @param { Mixed } value (optional)

    Get or set a flag value on an object. If a value is provided it will be set, else it will return the currently set value or `undefined` if the value is not set.

    ``` javascript
    utils.flag(this, 'foo', 'bar'); // setter
    utils.flag(this, 'foo'); // getter, returns `bar`
    ```
- name: frozen
  id: api/bdd/index#method_frozen
  summary: Asserts that the target is frozen, which means that new properties can’t be added to it, and its existing properties can’t be reassigned to different values, reconfigured, or deleted
  belongs_to: BDD
  description: |-
    ### .frozen

    Asserts that the target is frozen, which means that new properties can’t be added to it, and its existing properties can’t be reassigned to different values, reconfigured, or deleted. Primitives are always frozen.

    ``` javascript
    var frozenObject = Object.freeze({});

    expect(frozenObject).to.be.frozen;
    expect(1).to.be.frozen;
    ```

    Add `.``not` earlier in the chain to negate `.``frozen`.

    ``` javascript
    expect({a: 1}).to.not.be.frozen;
    ```

    A custom error message can be given as the second argument to `expect`.

    ``` javascript
    expect({a: 1}, 'nooo why fail??').to.be.frozen;
    ```
- name: getActual
  id: api/plugins/index#method_getactual
  summary: Returns the actual value for an Assertion
  belongs_to: Plugin Utilities
  description: |-
    ### .getActual(object, \[actual\])

    - @param { Object } object (constructed Assertion)
    - @param { Arguments } chai.Assertion.prototype.assert arguments

    Returns the `actual` value for an Assertion.
- name: getConstructorName
  id: api/plugins/index#method_getconstructorname
  summary: Gets the constructor name for an Error instance or constructor itself
  belongs_to: Plugin Utilities
  description: |-
    ### .getConstructorName(errorLike)

    - @param { Error \| ErrorConstructor } errorLike

    Gets the constructor name for an Error instance or constructor itself.

    ### .getMessage(errorLike)

    - @param { Error \| String } errorLike

    Gets the error message from an error. If `err` is a String itself, we return it. If the error has no message, we return an empty string.
- name: getEnumerableProperties
  id: api/plugins/index#method_getenumerableproperties
  summary: This allows the retrieval of enumerable property names of an object, inherited or not
  belongs_to: Plugin Utilities
  description: |-
    ### .getEnumerableProperties(object)

    - @param { Object } object

    This allows the retrieval of enumerable property names of an object, inherited or not.
- name: getFuncName
  id: api/plugins/index#method_getfuncname
  summary: Returns the name of a function
  belongs_to: Plugin Utilities
  description: |-
    ### .getFuncName(constructorFn)

    - @param { Function } funct

    Returns the name of a function. When a non-function instance is passed, returns `null`. This also includes a polyfill function if `aFunc.name` is not defined.
- name: getFunctionName
  id: api/plugins/index#method_getfunctionname
  summary: Returns the name of a function
  belongs_to: Plugin Utilities
  description: |-
    ### .getFunctionName(constructorFn)

    - @param { Function } constructorFn

    Returns the name of a function. This also includes a polyfill function if `constructorFn.name` is not defined.
- name: getMessage
  id: api/plugins/index#method_getmessage
  summary: Construct the error message based on flags and template tags
  belongs_to: Plugin Utilities
  description: |-
    ### .getMessage(object, message, negateMessage)

    - @param { Object } object (constructed Assertion)
    - @param { Arguments } chai.Assertion.prototype.assert arguments

    Construct the error message based on flags and template tags. Template tags will return a stringified inspection of the object referenced.

    Message template tags:

    - `#{this}` current asserted object
    - `#{act}` actual value
    - `#{exp}` expected value
- name: getOperator
  id: api/plugins/index#method_getoperator
  summary: Extract the operator from error message
  belongs_to: Plugin Utilities
  description: |-
    ### .getOperator(message)

    - @param { Object } object (constructed Assertion)
    - @param { Arguments } chai.Assertion.prototype.assert arguments

    Extract the operator from error message. Operator defined is based on below link https://nodejs.org/api/assert.html#assert_assert.

    Returns the `operator` or `undefined` value for an Assertion.
- name: getOwnEnumerableProperties
  id: api/plugins/index#method_getownenumerableproperties
  summary: This allows the retrieval of directly-owned enumerable property names and symbols of an object
  belongs_to: Plugin Utilities
  description: |-
    ### .getOwnEnumerableProperties(object)

    - @param { Object } object

    This allows the retrieval of directly-owned enumerable property names and symbols of an object. This function is necessary because Object.keys only returns enumerable property names, not enumerable property symbols.
- name: getOwnEnumerablePropertySymbols
  id: api/plugins/index#method_getownenumerablepropertysymbols
  summary: This allows the retrieval of directly-owned enumerable property symbols of an object
  belongs_to: Plugin Utilities
  description: |-
    ### .getOwnEnumerablePropertySymbols(object)

    - @param { Object } object

    This allows the retrieval of directly-owned enumerable property symbols of an object. This function is necessary because Object.getOwnPropertySymbols returns both enumerable and non-enumerable property symbols.
- name: getPathInfo
  id: api/plugins/index#method_getpathinfo
  summary: This allows the retrieval of property info in an object given a string path
  belongs_to: Plugin Utilities
  description: |-
    ### .getPathInfo(object, path)

    - @param { Object } object
    - @param { String } path

    This allows the retrieval of property info in an object given a string path.

    The path info consists of an object with the following properties:

    - parent - The parent object of the property referenced by `path`
    - name - The name of the final property, a number if it was an array indexer
    - value - The value of the property, if it exists, otherwise `undefined`
    - exists - Whether the property exists or not
- name: getPathValue
  id: api/plugins/index#method_getpathvalue
  summary: This allows the retrieval of values in an object given a string path
  belongs_to: Plugin Utilities
  description: "### .getPathValue(object, path)\n\n- @param { Object } object\n- @param { String } path\n\nThis allows the retrieval of values in an object given a string path.\n\n``` javascript\nvar obj = {\n    prop1: {\n        arr: ['a', 'b', 'c']\n      , str: 'Hello'\n    }\n  , prop2: {\n        arr: [ { nested: 'Universe' } ]\n      , str: 'Hello again!'\n    }\n}\n```\n\nThe following would be the results.\n\n``` javascript\ngetPathValue(obj, 'prop1.str'); // Hello\ngetPathValue(obj, 'prop1.att[2]'); // b\ngetPathValue(obj, 'prop2.arr[0].nested'); // Universe\n```\n\n© 2017 Chai.js Assertion Library  \nLicensed under the MIT License.  \n[https://www.chaijs.com/api/plugins/](https://www.chaijs.com/api/plugins/)"
- name: getProperties
  id: api/plugins/index#method_getproperties
  summary: This allows the retrieval of property names of an object, enumerable or not, inherited or not
  belongs_to: Plugin Utilities
  description: |-
    ### .getProperties(object)

    - @param { Object } object

    This allows the retrieval of property names of an object, enumerable or not, inherited or not.
- name: hasAllDeepKeys
  id: api/assert/index#method_hasalldeepkeys
  summary: Asserts that object has all and only all of the keys provided
  belongs_to: Assert
  description: |-
    ### .hasAllDeepKeys(object, \[keys\], \[message\])

    - @param { Mixed } object
    - @param { Array \| Object } keys
    - @param { String } message

    Asserts that `object` has all and only all of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.

    ``` javascript
    assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});
    assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});
    assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    ```
- name: hasAllKeys
  id: api/assert/index#method_hasallkeys
  summary: Asserts that object has all and only all of the keys provided
  belongs_to: Assert
  description: |-
    ### .hasAllKeys(object, \[keys\], \[message\])

    - @param { Mixed } object
    - @param { Array. } keys
    - @param { String } message

    Asserts that `object` has all and only all of the `keys` provided. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.

    ``` javascript
    assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
    assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
    assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
    assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
    ```
- name: hasAnyDeepKeys
  id: api/assert/index#method_hasanydeepkeys
  summary: Asserts that object has at least one of the keys provided
  belongs_to: Assert
  description: |-
    ### .hasAnyDeepKeys(object, \[keys\], \[message\])

    - @param { Mixed } object
    - @param { Array \| Object } keys
    - @param { String } message

    Asserts that `object` has at least one of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.

    ``` javascript
    assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
    assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);
    assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
    assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);
    assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    ```
- name: hasAnyKeys
  id: api/assert/index#method_hasanykeys
  summary: Asserts that object has at least one of the keys provided
  belongs_to: Assert
  description: |-
    ### .hasAnyKeys(object, \[keys\], \[message\])

    - @param { Mixed } object
    - @param { Array \| Object } keys
    - @param { String } message

    Asserts that `object` has at least one of the `keys` provided. You can also provide a single object instead of a `keys` array and its keys will be used as the expected set of keys.

    ``` javascript
    assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);
    assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});
    assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
    assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);
    ```
- name: hasProperty
  id: api/plugins/index#method_hasproperty
  summary: This allows checking whether an object has own or inherited from prototype chain named property
  belongs_to: Plugin Utilities
  description: |-
    ### .hasProperty(object, name)

    - @param { Object } object
    - @param { String \| Symbol } name

    This allows checking whether an object has own or inherited from prototype chain named property.

    Basically does the same thing as the `in` operator but works properly with null/undefined values and other primitives.

    ``` javascript
    var obj = {
        arr: ['a', 'b', 'c']
      , str: 'Hello'
    }
    ```

    The following would be the results.

    ``` javascript
    hasProperty(obj, 'str');  // true
    hasProperty(obj, 'constructor');  // true
    hasProperty(obj, 'bar');  // false

    hasProperty(obj.str, 'length'); // true
    hasProperty(obj.str, 1);  // true
    hasProperty(obj.str, 5);  // false

    hasProperty(obj.arr, 'length');  // true
    hasProperty(obj.arr, 2);  // true
    hasProperty(obj.arr, 3);  // false
    ```
- name: ifError
  id: api/assert/index#method_iferror
  summary: Asserts if value is not a false value, and throws if it is a true value
  belongs_to: Assert
  description: |-
    ### .ifError(object)

    - @param { Object } object

    Asserts if value is not a false value, and throws if it is a true value. This is added to allow for chai to be a drop-in replacement for Node’s assert class.

    ``` javascript
    var err = new Error('I am a custom error');
    assert.ifError(err); // Rethrows err!
    ```
- name: include
  id: api/bdd/index#method_include
  summary: When the target is a string, .``include asserts that the given string val is a substring of the target
  belongs_to: BDD
  description: |-
    ### .include(val\[, msg\])

    - @param { Mixed } val
    - @param { String } msg \_optional\_

    When the target is a string, `.``include` asserts that the given string `val` is a substring of the target.

    ``` javascript
    expect('foobar').to.include('foo');
    ```

    When the target is an array, `.``include` asserts that the given `val` is a member of the target.

    ``` javascript
    expect([1, 2, 3]).to.include(2);
    ```

    When the target is an object, `.``include` asserts that the given object `val`’s properties are a subset of the target’s properties.

    ``` javascript
    expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
    ```

    When the target is a Set or WeakSet, `.``include` asserts that the given `val` is a member of the target. SameValueZero equality algorithm is used.

    ``` javascript
    expect(new Set([1, 2])).to.include(2);
    ```

    When the target is a Map, `.``include` asserts that the given `val` is one of the values of the target. SameValueZero equality algorithm is used.

    ``` javascript
    expect(new Map([['a', 1], ['b', 2]])).to.include(2);
    ```

    Because `.``include` does different things based on the target’s type, it’s important to check the target’s type before using `.``include`. See the `.``a` doc for info on testing a target’s type.

    ``` javascript
    expect([1, 2, 3]).to.be.an('array').that.includes(2);
    ```

    By default, strict (`===`) equality is used to compare array members and object properties. Add `.``deep` earlier in the chain to use deep equality instead (WeakSet targets are not supported). See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.

    ``` javascript
    // Target array deeply (but not strictly) includes `{a: 1}`
    expect([{a: 1}]).to.deep.include({a: 1});
    expect([{a: 1}]).to.not.include({a: 1});

    // Target object deeply (but not strictly) includes `x: {a: 1}`
    expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
    expect({x: {a: 1}}).to.not.include({x: {a: 1}});
    ```

    By default, all of the target’s properties are searched when working with objects. This includes properties that are inherited and/or non-enumerable. Add `.``own` earlier in the chain to exclude the target’s inherited properties from the search.

    ``` javascript
    Object.prototype.b = 2;

    expect({a: 1}).to.own.include({a: 1});
    expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
    ```

    Note that a target object is always only searched for `val`’s own enumerable properties.

    `.``deep` and `.``own` can be combined.

    ``` javascript
    expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
    ```

    Add `.``nested` earlier in the chain to enable dot- and bracket-notation when referencing nested properties.

    ``` javascript
    expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
    ```

    If `.` or `[]` are part of an actual property name, they can be escaped by adding two backslashes before them.

    ``` javascript
    expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});
    ```

    `.``deep` and `.``nested` can be combined.

    ``` javascript
    expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
    ```

    `.``own` and `.``nested` cannot be combined.

    Add `.``not` earlier in the chain to negate `.``include`.

    ``` javascript
    expect('foobar').to.not.include('taco');
    expect([1, 2, 3]).to.not.include(4);
    ```

    However, it’s dangerous to negate `.``include` when the target is an object. The problem is that it creates uncertain expectations by asserting that the target object doesn’t have all of `val`’s key/value pairs but may or may not have some of them. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.

    When the target object isn’t even expected to have `val`’s keys, it’s often best to assert exactly that.

    ``` javascript
    expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
    expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
    ```

    When the target object is expected to have `val`’s keys, it’s often best to assert that each of the properties has its expected value, rather than asserting that each property doesn’t have one of many unexpected values.

    ``` javascript
    expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
    expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
    ```

    `.``include` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect([1, 2, 3]).to.include(4, 'nooo why fail??');
    expect([1, 2, 3], 'nooo why fail??').to.include(4);
    ```

    `.``include` can also be used as a language chain, causing all `.``members` and `.``keys` assertions that follow in the chain to require the target to be a superset of the expected set, rather than an identical set. Note that `.``members` ignores duplicates in the subset when `.``include` is added.

    ``` javascript
    // Target object's keys are a superset of ['a', 'b'] but not identical
    expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
    expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');

    // Target array is a superset of [1, 2] but not identical
    expect([1, 2, 3]).to.include.members([1, 2]);
    expect([1, 2, 3]).to.not.have.members([1, 2]);

    // Duplicates in the subset are ignored
    expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
    ```

    Note that adding `.``any` earlier in the chain causes the `.``keys` assertion to ignore `.``include`.

    ``` javascript
    // Both assertions are identical
    expect({a: 1}).to.include.any.keys('a', 'b');
    expect({a: 1}).to.have.any.keys('a', 'b');
    ```

    The aliases `.``includes`, `.``contain`, and `.``contains` can be used interchangeably with `.``include`.
- name: include
  id: api/assert/index#method_include
  summary: Asserts that haystack includes needle
  belongs_to: Assert
  description: |-
    ### .include(haystack, needle, \[message\])

    - @param { Array \| String } haystack
    - @param { Mixed } needle
    - @param { String } message

    Asserts that `haystack` includes `needle`. Can be used to assert the inclusion of a value in an array, a substring in a string, or a subset of properties in an object.

    ``` javascript
    assert.include([1,2,3], 2, 'array contains value');
    assert.include('foobar', 'foo', 'string contains substring');
    assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');
    ```

    Strict equality (===) is used. When asserting the inclusion of a value in an array, the array is searched for an element that’s strictly equal to the given value. When asserting a subset of properties in an object, the object is searched for the given property keys, checking that each one is present and strictly equal to the given property value. For instance:

    ``` javascript
    var obj1 = {a: 1}
      , obj2 = {b: 2};
    assert.include([obj1, obj2], obj1);
    assert.include({foo: obj1, bar: obj2}, {foo: obj1});
    assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});
    ```
- name: includeDeepMembers
  id: api/assert/index#method_includedeepmembers
  summary: Asserts that subset is included in superset in any order
  belongs_to: Assert
  description: |-
    ### .includeDeepMembers(superset, subset, \[message\])

    - @param { Array } superset
    - @param { Array } subset
    - @param { String } message

    Asserts that `subset` is included in `superset` in any order. Uses a deep equality check. Duplicates are ignored.

    ``` javascript
    assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');
    ```
- name: includeDeepOrderedMembers
  id: api/assert/index#method_includedeeporderedmembers
  summary: Asserts that subset is included in superset in the same order beginning with the first element in superset
  belongs_to: Assert
  description: |-
    ### .includeDeepOrderedMembers(superset, subset, \[message\])

    - @param { Array } superset
    - @param { Array } subset
    - @param { String } message

    Asserts that `subset` is included in `superset` in the same order beginning with the first element in `superset`. Uses a deep equality check.

    ``` javascript
    assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');
    ```
- name: includeMembers
  id: api/assert/index#method_includemembers
  summary: Asserts that subset is included in superset in any order
  belongs_to: Assert
  description: |-
    ### .includeMembers(superset, subset, \[message\])

    - @param { Array } superset
    - @param { Array } subset
    - @param { String } message

    Asserts that `subset` is included in `superset` in any order. Uses a strict equality check (===). Duplicates are ignored.

    ``` javascript
    assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');
    ```
- name: includeOrderedMembers
  id: api/assert/index#method_includeorderedmembers
  summary: Asserts that subset is included in superset in the same order beginning with the first element in superset
  belongs_to: Assert
  description: |-
    ### .includeOrderedMembers(superset, subset, \[message\])

    - @param { Array } superset
    - @param { Array } subset
    - @param { String } message

    Asserts that `subset` is included in `superset` in the same order beginning with the first element in `superset`. Uses a strict equality check (===).

    ``` javascript
    assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');
    ```
- name: increase
  id: api/bdd/index#method_increase
  summary: When one argument is provided, .``increase asserts that the given function subject returns a greater number when it’s invoked after invoking the target function compared to when it’s invoked beforehand
  belongs_to: BDD
  description: |-
    ### .increase(subject\[, prop\[, msg\]\])

    - @param { String \| Function } subject
    - @param { String } prop name \_optional\_
    - @param { String } msg \_optional\_

    When one argument is provided, `.``increase` asserts that the given function `subject` returns a greater number when it’s invoked after invoking the target function compared to when it’s invoked beforehand. `.``increase` also causes all `.``by` assertions that follow in the chain to assert how much greater of a number is returned. It’s often best to assert that the return value increased by the expected amount, rather than asserting it increased by any amount.

    ``` javascript
    var val = 1
      , addTwo = function () { val += 2; }
      , getVal = function () { return val; };

    expect(addTwo).to.increase(getVal).by(2); // Recommended
    expect(addTwo).to.increase(getVal); // Not recommended
    ```

    When two arguments are provided, `.``increase` asserts that the value of the given object `subject`’s `prop` property is greater after invoking the target function compared to beforehand.

    ``` javascript
    var myObj = {val: 1}
      , addTwo = function () { myObj.val += 2; };

    expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
    expect(addTwo).to.increase(myObj, 'val'); // Not recommended
    ```

    Add `.``not` earlier in the chain to negate `.``increase`. However, it’s dangerous to do so. The problem is that it creates uncertain expectations by asserting that the subject either decreases, or that it stays the same. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.

    When the subject is expected to decrease, it’s often best to assert that it decreased by the expected amount.

    ``` javascript
    var myObj = {val: 1}
      , subtractTwo = function () { myObj.val -= 2; };

    expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
    expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
    ```

    When the subject is expected to stay the same, it’s often best to assert exactly that.

    ``` javascript
    var myObj = {val: 1}
      , noop = function () {};

    expect(noop).to.not.change(myObj, 'val'); // Recommended
    expect(noop).to.not.increase(myObj, 'val'); // Not recommended
    ```

    `.``increase` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`. When not providing two arguments, always use the second form.

    ``` javascript
    var myObj = {val: 1}
      , noop = function () {};

    expect(noop).to.increase(myObj, 'val', 'nooo why fail??');

    var val = 1
      , noop = function () {}
      , getVal = function () { return val; };

    expect(noop, 'nooo why fail??').to.increase(getVal);
    ```

    The alias `.``increases` can be used interchangeably with `.``increase`.
- name: increases
  id: api/assert/index#method_increases
  summary: Asserts that a function increases a numeric object property
  belongs_to: Assert
  description: |-
    ### .increases(function, object, property, \[message\])

    - @param { Function } modifier function
    - @param { Object } object or getter function
    - @param { String } property name \_optional\_
    - @param { String } message \_optional\_

    Asserts that a function increases a numeric object property.

    ``` javascript
    var obj = { val: 10 };
    var fn = function() { obj.val = 13 };
    assert.increases(fn, obj, 'val');
    ```
- name: increasesButNotBy
  id: api/assert/index#method_increasesbutnotby
  summary: Asserts that a function does not increase a numeric object property or function’s return value by an amount (delta)
  belongs_to: Assert
  description: |-
    ### .increasesButNotBy(function, object, property, delta, \[message\])

    - @param { Function } modifier function
    - @param { Object } object or getter function
    - @param { String } property name \_optional\_
    - @param { Number } change amount (delta)
    - @param { String } message \_optional\_

    Asserts that a function does not increase a numeric object property or function’s return value by an amount (delta).

    ``` javascript
    var obj = { val: 10 };
    var fn = function() { obj.val = 15 };
    assert.increasesButNotBy(fn, obj, 'val', 10);
    ```
- name: increasesBy
  id: api/assert/index#method_increasesby
  summary: Asserts that a function increases a numeric object property or a function’s return value by an amount (delta)
  belongs_to: Assert
  description: |-
    ### .increasesBy(function, object, property, delta, \[message\])

    - @param { Function } modifier function
    - @param { Object } object or getter function
    - @param { String } property name \_optional\_
    - @param { Number } change amount (delta)
    - @param { String } message \_optional\_

    Asserts that a function increases a numeric object property or a function’s return value by an amount (delta).

    ``` javascript
    var obj = { val: 10 };
    var fn = function() { obj.val += 10 };
    assert.increasesBy(fn, obj, 'val', 10);
    ```
- name: inspect
  id: api/plugins/index#method_inspect
  summary: Echoes the value of a value
  belongs_to: Plugin Utilities
  description: |-
    ### .inspect(obj, \[showHidden\], \[depth\], \[colors\])

    - @param { Object } obj The object to print out.
    - @param { Boolean } showHidden Flag that shows hidden (not enumerable) properties of objects. Default is false.
    - @param { Number } depth Depth in which to descend in object. Default is 2.
    - @param { Boolean } colors Flag to turn on ANSI escape codes to color the output. Default is false (no coloring).

    Echoes the value of a value. Tries to print the value out in the best way possible given the different types.
- name: Installation
  id: guide/installation/index
  summary: Chai is available for both node.js and the browser using any test framework you like
  description: "# Installation\n\nChai is available for both node.js and the browser using any test framework you like. There are also a number of other tools that include Chai.\n\n### Node.js\n\nPackage is available through [npm](http://npmjs.org):\n\n``` javascript\nnpm install chai\n```\n\nRecommend adding it to `package``.``json` devDependencies using a `*` as the version tag. This will ensure that you always have the most recent version after running `npm`` ``install`, which can be especially powerful when paired with a continuous integration tool.\n\n``` javascript\n\"devDependencies\": {\n  \"chai\": \"*\",\n  \"mocha\": \"*\"\n}, \"//\": \"mocha is our preference, but you can use any test runner you like\"\n```\n\n### Browser\n\nInclude the chai browser build in your testing suite.\n\n``` javascript\n<script src=\"chai.js\" type=\"text/javascript\"></script>\n```\n\nThis will provide `chai` as a global object, or `define` it if you are using AMD.\n\nThe latest tagged version will be available for hot-linking at [http://chaijs.com/chai.js](https://www.chaijs.com/chai.js). If you prefer to host yourself, use the `chai``.``js` file from the root of the github project. We recommend that you always use a version tag as your starting point, so the [tag download list](https://github.com/chaijs/chai/tags) is the best place to start.\n\nCurrently supports all modern browsers: IE 9+, Chrome 7+, FireFox 4+, Safari 5+. Please note that the `should` style is currently not compatible with IE9.\n\nIf you want to know if your browser is compatible, run the [online test suite](https://www.chaijs.com/api/test/).\n\n### Other Platforms\n\n#### Ruby\n\n##### [Konacha](https://github.com/jfirebaugh/konacha)\n\nFor testing your Ruby on Rails application using Chai assertions and the Mocha test framework, check out Konacha – a modern test harness that takes full advantage of Rails 3 features such as the asset pipeline and engines.\n\n© 2017 Chai.js Assertion Library  \nLicensed under the MIT License.  \n[https://www.chaijs.com/guide/installation/](https://www.chaijs.com/guide/installation/)"
- name: instanceof
  id: api/bdd/index#method_instanceof
  summary: Asserts that the target is an instance of the given constructor
  belongs_to: BDD
  description: |-
    ### .instanceof(constructor\[, msg\])

    - @param { Constructor } constructor
    - @param { String } msg \_optional\_

    Asserts that the target is an instance of the given `constructor`.

    ``` javascript
    function Cat () { }

    expect(new Cat()).to.be.an.instanceof(Cat);
    expect([1, 2]).to.be.an.instanceof(Array);
    ```

    Add `.``not` earlier in the chain to negate `.``instanceof`.

    ``` javascript
    expect({a: 1}).to.not.be.an.instanceof(Array);
    ```

    `.``instanceof` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
    expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
    ```

    Due to limitations in ES5, `.``instanceof` may not always work as expected when using a transpiler such as Babel or TypeScript. In particular, it may produce unexpected results when subclassing built-in object such as `Array`, `Error`, and `Map`. See your transpiler’s docs for details:

    - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
    - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))

    The alias `.``instanceOf` can be used interchangeably with `.``instanceof`.
- name: instanceOf
  id: api/assert/index#method_instanceof
  summary: Asserts that value is an instance of constructor
  belongs_to: Assert
  description: |-
    ### .instanceOf(object, constructor, \[message\])

    - @param { Object } object
    - @param { Constructor } constructor
    - @param { String } message

    Asserts that `value` is an instance of `constructor`.

    ``` javascript
    var Tea = function (name) { this.name = name; }
      , chai = new Tea('chai');

    assert.instanceOf(chai, Tea, 'chai is an instance of tea');
    ```
- name: isAbove
  id: api/assert/index#method_isabove
  summary: Asserts valueToCheck is strictly greater than (>) valueToBeAbove
  belongs_to: Assert
  description: |-
    ### .isAbove(valueToCheck, valueToBeAbove, \[message\])

    - @param { Mixed } valueToCheck
    - @param { Mixed } valueToBeAbove
    - @param { String } message

    Asserts `valueToCheck` is strictly greater than (\>) `valueToBeAbove`.

    ``` javascript
    assert.isAbove(5, 2, '5 is strictly greater than 2');
    ```
- name: isArray
  id: api/assert/index#method_isarray
  summary: Asserts that value is an array
  belongs_to: Assert
  description: |-
    ### .isArray(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is an array.

    ``` javascript
    var menu = [ 'green', 'chai', 'oolong' ];
    assert.isArray(menu, 'what kind of tea do we want?');
    ```
- name: isAtLeast
  id: api/assert/index#method_isatleast
  summary: Asserts valueToCheck is greater than or equal to (>=) valueToBeAtLeast
  belongs_to: Assert
  description: |-
    ### .isAtLeast(valueToCheck, valueToBeAtLeast, \[message\])

    - @param { Mixed } valueToCheck
    - @param { Mixed } valueToBeAtLeast
    - @param { String } message

    Asserts `valueToCheck` is greater than or equal to (\>=) `valueToBeAtLeast`.

    ``` javascript
    assert.isAtLeast(5, 2, '5 is greater or equal to 2');
    assert.isAtLeast(3, 3, '3 is greater or equal to 3');
    ```
- name: isAtMost
  id: api/assert/index#method_isatmost
  summary: Asserts valueToCheck is less than or equal to (<=) valueToBeAtMost
  belongs_to: Assert
  description: |-
    ### .isAtMost(valueToCheck, valueToBeAtMost, \[message\])

    - @param { Mixed } valueToCheck
    - @param { Mixed } valueToBeAtMost
    - @param { String } message

    Asserts `valueToCheck` is less than or equal to (\<=) `valueToBeAtMost`.

    ``` javascript
    assert.isAtMost(3, 6, '3 is less than or equal to 6');
    assert.isAtMost(4, 4, '4 is less than or equal to 4');
    ```
- name: isBelow
  id: api/assert/index#method_isbelow
  summary: Asserts valueToCheck is strictly less than (<) valueToBeBelow
  belongs_to: Assert
  description: |-
    ### .isBelow(valueToCheck, valueToBeBelow, \[message\])

    - @param { Mixed } valueToCheck
    - @param { Mixed } valueToBeBelow
    - @param { String } message

    Asserts `valueToCheck` is strictly less than (\<) `valueToBeBelow`.

    ``` javascript
    assert.isBelow(3, 6, '3 is strictly less than 6');
    ```
- name: isBoolean
  id: api/assert/index#method_isboolean
  summary: Asserts that value is a boolean
  belongs_to: Assert
  description: |-
    ### .isBoolean(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is a boolean.

    ``` javascript
    var teaReady = true
      , teaServed = false;

    assert.isBoolean(teaReady, 'is the tea ready');
    assert.isBoolean(teaServed, 'has tea been served');
    ```
- name: isDefined
  id: api/assert/index#method_isdefined
  summary: Asserts that value is not undefined
  belongs_to: Assert
  description: |-
    ### .isDefined(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is not `undefined`.

    ``` javascript
    var tea = 'cup of chai';
    assert.isDefined(tea, 'tea has been defined');
    ```
- name: isEmpty
  id: api/assert/index#method_isempty
  summary: Asserts that the target does not contain any values
  belongs_to: Assert
  description: |-
    ### .isEmpty(target)

    - @param { Object \| Array \| String \| Map \| Set } target
    - @param { String } message \_optional\_

    Asserts that the target does not contain any values. For arrays and strings, it checks the `length` property. For `Map` and `Set` instances, it checks the `size` property. For non-function objects, it gets the count of own enumerable string keys.

    ``` javascript
    assert.isEmpty([]);
    assert.isEmpty('');
    assert.isEmpty(new Map);
    assert.isEmpty({});
    ```
- name: isExtensible
  id: api/assert/index#method_isextensible
  summary: Asserts that object is extensible (can have new properties added to it)
  belongs_to: Assert
  description: |-
    ### .isExtensible(object)

    - @param { Object } object
    - @param { String } message \_optional\_

    Asserts that `object` is extensible (can have new properties added to it).

    ``` javascript
    assert.isExtensible({});
    ```
- name: isFalse
  id: api/assert/index#method_isfalse
  summary: Asserts that value is false
  belongs_to: Assert
  description: |-
    ### .isFalse(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is false.

    ``` javascript
    var teaServed = false;
    assert.isFalse(teaServed, 'no tea yet? hmm...');
    ```
- name: isFinite
  id: api/assert/index#method_isfinite
  summary: Asserts that value is a finite number
  belongs_to: Assert
  description: |-
    ### .isFinite(value, \[message\])

    - @param { Number } value
    - @param { String } message

    Asserts that `value` is a finite number. Unlike `.``isNumber`, this will fail for `NaN` and `Infinity`.

    ``` javascript
    var cups = 2;
    assert.isFinite(cups, 'how many cups');

    assert.isFinite(NaN); // throws
    ```
- name: isFrozen
  id: api/assert/index#method_isfrozen
  summary: Asserts that object is frozen (cannot have new properties added to it and its existing properties cannot be modified)
  belongs_to: Assert
  description: |-
    ### .isFrozen(object)

    - @param { Object } object
    - @param { String } message \_optional\_

    Asserts that `object` is frozen (cannot have new properties added to it and its existing properties cannot be modified).

    ``` javascript
    var frozenObject = Object.freeze({});
    assert.frozen(frozenObject);
    ```
- name: isFunction
  id: api/assert/index#method_isfunction
  summary: Asserts that value is a function
  belongs_to: Assert
  description: |-
    ### .isFunction(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is a function.

    ``` javascript
    function serveTea() { return 'cup of tea'; };
    assert.isFunction(serveTea, 'great, we can have tea now');
    ```
- name: isNaN
  id: api/assert/index#method_isnan
  summary: Asserts that value is NaN
  belongs_to: Assert
  description: |-
    ### .isNaN

    - @param { Mixed } value
    - @param { String } message

    Asserts that value is NaN.

    ``` javascript
    assert.isNaN(NaN, 'NaN is NaN');
    ```
- name: isNotArray
  id: api/assert/index#method_isnotarray
  summary: Asserts that value is not an array
  belongs_to: Assert
  description: |-
    ### .isNotArray(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is *not* an array.

    ``` javascript
    var menu = 'green|chai|oolong';
    assert.isNotArray(menu, 'what kind of tea do we want?');
    ```
- name: isNotBoolean
  id: api/assert/index#method_isnotboolean
  summary: Asserts that value is not a boolean
  belongs_to: Assert
  description: |-
    ### .isNotBoolean(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is *not* a boolean.

    ``` javascript
    var teaReady = 'yep'
      , teaServed = 'nope';

    assert.isNotBoolean(teaReady, 'is the tea ready');
    assert.isNotBoolean(teaServed, 'has tea been served');
    ```
- name: isNotEmpty
  id: api/assert/index#method_isnotempty
  summary: Asserts that the target contains values
  belongs_to: Assert
  description: "### .isNotEmpty(target)\n\n- @param { Object \\| Array \\| String \\| Map \\| Set } target\n- @param { String } message \\_optional\\_\n\nAsserts that the target contains values. For arrays and strings, it checks the `length` property. For `Map` and `Set` instances, it checks the `size` property. For non-function objects, it gets the count of own enumerable string keys.\n\n``` javascript\nassert.isNotEmpty([1, 2]);\nassert.isNotEmpty('34');\nassert.isNotEmpty(new Set([5, 6]));\nassert.isNotEmpty({ key: 7 });\n```\n\n© 2017 Chai.js Assertion Library  \nLicensed under the MIT License.  \n[https://www.chaijs.com/api/assert/](https://www.chaijs.com/api/assert/)"
- name: isNotExtensible
  id: api/assert/index#method_isnotextensible
  summary: Asserts that object is not extensible
  belongs_to: Assert
  description: |-
    ### .isNotExtensible(object)

    - @param { Object } object
    - @param { String } message \_optional\_

    Asserts that `object` is *not* extensible.

    ``` javascript
    var nonExtensibleObject = Object.preventExtensions({});
    var sealedObject = Object.seal({});
    var frozenObject = Object.freeze({});

    assert.isNotExtensible(nonExtensibleObject);
    assert.isNotExtensible(sealedObject);
    assert.isNotExtensible(frozenObject);
    ```
- name: isNotFalse
  id: api/assert/index#method_isnotfalse
  summary: Asserts that value is not false
  belongs_to: Assert
  description: |-
    ### .isNotFalse(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is not false.

    ``` javascript
    var tea = 'tasty chai';
    assert.isNotFalse(tea, 'great, time for tea!');
    ```
- name: isNotFrozen
  id: api/assert/index#method_isnotfrozen
  summary: Asserts that object is not frozen
  belongs_to: Assert
  description: |-
    ### .isNotFrozen(object)

    - @param { Object } object
    - @param { String } message \_optional\_

    Asserts that `object` is *not* frozen.

    ``` javascript
    assert.isNotFrozen({});
    ```
- name: isNotFunction
  id: api/assert/index#method_isnotfunction
  summary: Asserts that value is not a function
  belongs_to: Assert
  description: |-
    ### .isNotFunction(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is *not* a function.

    ``` javascript
    var serveTea = [ 'heat', 'pour', 'sip' ];
    assert.isNotFunction(serveTea, 'great, we have listed the steps');
    ```
- name: isNotNaN
  id: api/assert/index#method_isnotnan
  summary: Asserts that value is not NaN
  belongs_to: Assert
  description: |-
    ### .isNotNaN

    - @param { Mixed } value
    - @param { String } message

    Asserts that value is not NaN.

    ``` javascript
    assert.isNotNaN(4, '4 is not NaN');
    ```
- name: isNotNull
  id: api/assert/index#method_isnotnull
  summary: Asserts that value is not null
  belongs_to: Assert
  description: |-
    ### .isNotNull(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is not null.

    ``` javascript
    var tea = 'tasty chai';
    assert.isNotNull(tea, 'great, time for tea!');
    ```
- name: isNotNumber
  id: api/assert/index#method_isnotnumber
  summary: Asserts that value is not a number
  belongs_to: Assert
  description: |-
    ### .isNotNumber(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is *not* a number.

    ``` javascript
    var cups = '2 cups please';
    assert.isNotNumber(cups, 'how many cups');
    ```
- name: isNotObject
  id: api/assert/index#method_isnotobject
  summary: Asserts that value is not an object of type ‘Object’ (as revealed by Object``.``prototype``.``toString)
  belongs_to: Assert
  description: |-
    ### .isNotObject(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is *not* an object of type ‘Object’ (as revealed by `Object``.``prototype``.``toString`).

    ``` javascript
    var selection = 'chai'
    assert.isNotObject(selection, 'tea selection is not an object');
    assert.isNotObject(null, 'null is not an object');
    ```
- name: isNotOk
  id: api/assert/index#method_isnotok
  summary: Asserts that object is falsy
  belongs_to: Assert
  description: |-
    ### .isNotOk(object, \[message\])

    - @param { Mixed } object to test
    - @param { String } message

    Asserts that `object` is falsy.

    ``` javascript
    assert.isNotOk('everything', 'this will fail');
    assert.isNotOk(false, 'this will pass');
    ```
- name: isNotSealed
  id: api/assert/index#method_isnotsealed
  summary: Asserts that object is not sealed
  belongs_to: Assert
  description: |-
    ### .isNotSealed(object)

    - @param { Object } object
    - @param { String } message \_optional\_

    Asserts that `object` is *not* sealed.

    ``` javascript
    assert.isNotSealed({});
    ```
- name: isNotString
  id: api/assert/index#method_isnotstring
  summary: Asserts that value is not a string
  belongs_to: Assert
  description: |-
    ### .isNotString(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is *not* a string.

    ``` javascript
    var teaOrder = 4;
    assert.isNotString(teaOrder, 'order placed');
    ```
- name: isNotTrue
  id: api/assert/index#method_isnottrue
  summary: Asserts that value is not true
  belongs_to: Assert
  description: |-
    ### .isNotTrue(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is not true.

    ``` javascript
    var tea = 'tasty chai';
    assert.isNotTrue(tea, 'great, time for tea!');
    ```
- name: isNull
  id: api/assert/index#method_isnull
  summary: Asserts that value is null
  belongs_to: Assert
  description: |-
    ### .isNull(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is null.

    ``` javascript
    assert.isNull(err, 'there was no error');
    ```
- name: isNumber
  id: api/assert/index#method_isnumber
  summary: Asserts that value is a number
  belongs_to: Assert
  description: |-
    ### .isNumber(value, \[message\])

    - @param { Number } value
    - @param { String } message

    Asserts that `value` is a number.

    ``` javascript
    var cups = 2;
    assert.isNumber(cups, 'how many cups');
    ```
- name: isObject
  id: api/assert/index#method_isobject
  summary: Asserts that value is an object of type ‘Object’ (as revealed by Object``.``prototype``.``toString)
  belongs_to: Assert
  description: |-
    ### .isObject(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is an object of type ‘Object’ (as revealed by `Object``.``prototype``.``toString`). *The assertion does not match subclassed objects.*

    ``` javascript
    var selection = { name: 'Chai', serve: 'with spices' };
    assert.isObject(selection, 'tea selection is an object');
    ```
- name: isOk
  id: api/assert/index#method_isok
  summary: Asserts that object is truthy
  belongs_to: Assert
  description: |-
    ### .isOk(object, \[message\])

    - @param { Mixed } object to test
    - @param { String } message

    Asserts that `object` is truthy.

    ``` javascript
    assert.isOk('everything', 'everything is ok');
    assert.isOk(false, 'this will fail');
    ```
- name: isProxyEnabled
  id: api/plugins/index#method_isproxyenabled
  summary: Helper function to check if Chai’s proxy protection feature is enabled
  belongs_to: Plugin Utilities
  description: |-
    ### .isProxyEnabled()

    Helper function to check if Chai’s proxy protection feature is enabled. If proxies are unsupported or disabled via the user’s Chai config, then return false. Otherwise, return true.
- name: isSealed
  id: api/assert/index#method_issealed
  summary: Asserts that object is sealed (cannot have new properties added to it and its existing properties cannot be removed)
  belongs_to: Assert
  description: |-
    ### .isSealed(object)

    - @param { Object } object
    - @param { String } message \_optional\_

    Asserts that `object` is sealed (cannot have new properties added to it and its existing properties cannot be removed).

    ``` javascript
    var sealedObject = Object.seal({});
    var frozenObject = Object.seal({});

    assert.isSealed(sealedObject);
    assert.isSealed(frozenObject);
    ```
- name: isString
  id: api/assert/index#method_isstring
  summary: Asserts that value is a string
  belongs_to: Assert
  description: |-
    ### .isString(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is a string.

    ``` javascript
    var teaOrder = 'chai';
    assert.isString(teaOrder, 'order placed');
    ```
- name: isTrue
  id: api/assert/index#method_istrue
  summary: Asserts that value is true
  belongs_to: Assert
  description: |-
    ### .isTrue(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is true.

    ``` javascript
    var teaServed = true;
    assert.isTrue(teaServed, 'the tea has been served');
    ```
- name: isUndefined
  id: api/assert/index#method_isundefined
  summary: Asserts that value is undefined
  belongs_to: Assert
  description: |-
    ### .isUndefined(value, \[message\])

    - @param { Mixed } value
    - @param { String } message

    Asserts that `value` is `undefined`.

    ``` javascript
    var tea;
    assert.isUndefined(tea, 'no tea defined');
    ```
- name: itself
  id: api/bdd/index#method_itself
  summary: Forces all .``respondTo assertions that follow in the chain to behave as if the target is a non-function object, even if it’s a function
  belongs_to: BDD
  description: |-
    ### .itself

    Forces all `.``respondTo` assertions that follow in the chain to behave as if the target is a non-function object, even if it’s a function. Thus, it causes `.``respondTo` to assert that the target has a method with the given name, rather than asserting that the target’s `prototype` property has a method with the given name.

    ``` javascript
    function Cat () {}
    Cat.prototype.meow = function () {};
    Cat.hiss = function () {};

    expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
    ```
- name: keys
  id: api/bdd/index#method_keys
  summary: Asserts that the target object, array, map, or set has the given keys
  belongs_to: BDD
  description: |-
    ### .keys(key1\[, key2\[, …\]\])

    - @param { String \| Array \| Object } keys

    Asserts that the target object, array, map, or set has the given keys. Only the target’s own inherited properties are included in the search.

    When the target is an object or array, keys can be provided as one or more string arguments, a single array argument, or a single object argument. In the latter case, only the keys in the given object matter; the values are ignored.

    ``` javascript
    expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
    expect(['x', 'y']).to.have.all.keys(0, 1);

    expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
    expect(['x', 'y']).to.have.all.keys([0, 1]);

    expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
    expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
    ```

    When the target is a map or set, each key must be provided as a separate argument.

    ``` javascript
    expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
    expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
    ```

    Because `.``keys` does different things based on the target’s type, it’s important to check the target’s type before using `.``keys`. See the `.``a` doc for info on testing a target’s type.

    ``` javascript
    expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
    ```

    By default, strict (`===`) equality is used to compare keys of maps and sets. Add `.``deep` earlier in the chain to use deep equality instead. See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.

    ``` javascript
    // Target set deeply (but not strictly) has key `{a: 1}`
    expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
    expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
    ```

    By default, the target must have all of the given keys and no more. Add `.``any` earlier in the chain to only require that the target have at least one of the given keys. Also, add `.``not` earlier in the chain to negate `.``keys`. It’s often best to add `.``any` when negating `.``keys`, and to use `.``all` when asserting `.``keys` without negation.

    When negating `.``keys`, `.``any` is preferred because `.``not``.``any``.``keys` asserts exactly what’s expected of the output, whereas `.``not``.``all``.``keys` creates uncertain expectations.

    ``` javascript
    // Recommended; asserts that target doesn't have any of the given keys
    expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');

    // Not recommended; asserts that target doesn't have all of the given
    // keys but may or may not have some of them
    expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
    ```

    When asserting `.``keys` without negation, `.``all` is preferred because `.``all``.``keys` asserts exactly what’s expected of the output, whereas `.``any``.``keys` creates uncertain expectations.

    ``` javascript
    // Recommended; asserts that target has all the given keys
    expect({a: 1, b: 2}).to.have.all.keys('a', 'b');

    // Not recommended; asserts that target has at least one of the given
    // keys but may or may not have more of them
    expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
    ```

    Note that `.``all` is used by default when neither `.``all` nor `.``any` appear earlier in the chain. However, it’s often best to add `.``all` anyway because it improves readability.

    ``` javascript
    // Both assertions are identical
    expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
    expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
    ```

    Add `.``include` earlier in the chain to require that the target’s keys be a superset of the expected keys, rather than identical sets.

    ``` javascript
    // Target object's keys are a superset of ['a', 'b'] but not identical
    expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
    expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
    ```

    However, if `.``any` and `.``include` are combined, only the `.``any` takes effect. The `.``include` is ignored in this case.

    ``` javascript
    // Both assertions are identical
    expect({a: 1}).to.have.any.keys('a', 'b');
    expect({a: 1}).to.include.any.keys('a', 'b');
    ```

    A custom error message can be given as the second argument to `expect`.

    ``` javascript
    expect({a: 1}, 'nooo why fail??').to.have.key('b');
    ```

    The alias `.``key` can be used interchangeably with `.``keys`.
- name: language chains
  id: api/bdd/index#method_language-chains
  summary: The following are provided as chainable getters to improve the readability of your assertions
  belongs_to: BDD
  description: |-
    ### Language Chains

    The following are provided as chainable getters to improve the readability of your assertions.

    **Chains**

    - to
    - be
    - been
    - is
    - that
    - which
    - and
    - has
    - have
    - with
    - at
    - of
    - same
    - but
    - does
    - still
    - also
- name: least
  id: api/bdd/index#method_least
  summary: Asserts that the target is a number or a date greater than or equal to the given number or date n respectively
  belongs_to: BDD
  description: |-
    ### .least(n\[, msg\])

    - @param { Number } n
    - @param { String } msg \_optional\_

    Asserts that the target is a number or a date greater than or equal to the given number or date `n` respectively. However, it’s often best to assert that the target is equal to its expected value.

    ``` javascript
    expect(2).to.equal(2); // Recommended
    expect(2).to.be.at.least(1); // Not recommended
    expect(2).to.be.at.least(2); // Not recommended
    ```

    Add `.``lengthOf` earlier in the chain to assert that the target’s `length` or `size` is greater than or equal to the given number `n`.

    ``` javascript
    expect('foo').to.have.lengthOf(3); // Recommended
    expect('foo').to.have.lengthOf.at.least(2); // Not recommended

    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
    ```

    Add `.``not` earlier in the chain to negate `.``least`.

    ``` javascript
    expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.at.least(2); // Not recommended
    ```

    `.``least` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect(1).to.be.at.least(2, 'nooo why fail??');
    expect(1, 'nooo why fail??').to.be.at.least(2);
    ```

    The aliases `.``gte` and `.``greaterThanOrEqual` can be used interchangeably with `.``least`.
- name: lengthOf
  id: api/bdd/index#method_lengthof
  summary: Asserts that the target’s length or size is equal to the given number n
  belongs_to: BDD
  description: |-
    ### .lengthOf(n\[, msg\])

    - @param { Number } n
    - @param { String } msg \_optional\_

    Asserts that the target’s `length` or `size` is equal to the given number `n`.

    ``` javascript
    expect([1, 2, 3]).to.have.lengthOf(3);
    expect('foo').to.have.lengthOf(3);
    expect(new Set([1, 2, 3])).to.have.lengthOf(3);
    expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);
    ```

    Add `.``not` earlier in the chain to negate `.``lengthOf`. However, it’s often best to assert that the target’s `length` property is equal to its expected value, rather than not equal to one of many unexpected values.

    ``` javascript
    expect('foo').to.have.lengthOf(3); // Recommended
    expect('foo').to.not.have.lengthOf(4); // Not recommended
    ```

    `.``lengthOf` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
    expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
    ```

    `.``lengthOf` can also be used as a language chain, causing all `.``above`, `.``below`, `.``least`, `.``most`, and `.``within` assertions that follow in the chain to use the target’s `length` property as the target. However, it’s often best to assert that the target’s `length` property is equal to its expected length, rather than asserting that its `length` property falls within some range of values.

    ``` javascript
    // Recommended
    expect([1, 2, 3]).to.have.lengthOf(3);

    // Not recommended
    expect([1, 2, 3]).to.have.lengthOf.above(2);
    expect([1, 2, 3]).to.have.lengthOf.below(4);
    expect([1, 2, 3]).to.have.lengthOf.at.least(3);
    expect([1, 2, 3]).to.have.lengthOf.at.most(3);
    expect([1, 2, 3]).to.have.lengthOf.within(2,4);
    ```

    Due to a compatibility issue, the alias `.``length` can’t be chained directly off of an uninvoked method such as `.``a`. Therefore, `.``length` can’t be used interchangeably with `.``lengthOf` in every situation. It’s recommended to always use `.``lengthOf` instead of `.``length`.

    ``` javascript
    expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
    expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
    ```
- name: lengthOf
  id: api/assert/index#method_lengthof
  summary: Asserts that object has a length or size with the expected value
  belongs_to: Assert
  description: |-
    ### .lengthOf(object, length, \[message\])

    - @param { Mixed } object
    - @param { Number } length
    - @param { String } message

    Asserts that `object` has a `length` or `size` with the expected value.

    ``` javascript
    assert.lengthOf([1,2,3], 3, 'array has length of 3');
    assert.lengthOf('foobar', 6, 'string has length of 6');
    assert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');
    assert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');
    ```
- name: match
  id: api/bdd/index#method_match
  summary: Asserts that the target matches the given regular expression re
  belongs_to: BDD
  description: |-
    ### .match(re\[, msg\])

    - @param { RegExp } re
    - @param { String } msg \_optional\_

    Asserts that the target matches the given regular expression `re`.

    ``` javascript
    expect('foobar').to.match(/^foo/);
    ```

    Add `.``not` earlier in the chain to negate `.``match`.

    ``` javascript
    expect('foobar').to.not.match(/taco/);
    ```

    `.``match` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect('foobar').to.match(/taco/, 'nooo why fail??');
    expect('foobar', 'nooo why fail??').to.match(/taco/);
    ```

    The alias `.``matches` can be used interchangeably with `.``match`.
- name: match
  id: api/assert/index#method_match
  summary: Asserts that value matches the regular expression regexp
  belongs_to: Assert
  description: |-
    ### .match(value, regexp, \[message\])

    - @param { Mixed } value
    - @param { RegExp } regexp
    - @param { String } message

    Asserts that `value` matches the regular expression `regexp`.

    ``` javascript
    assert.match('foobar', /^foo/, 'regexp matches');
    ```
- name: members
  id: api/bdd/index#method_members
  summary: Asserts that the target array has the same members as the given array set
  belongs_to: BDD
  description: |-
    ### .members(set\[, msg\])

    - @param { Array } set
    - @param { String } msg \_optional\_

    Asserts that the target array has the same members as the given array `set`.

    ``` javascript
    expect([1, 2, 3]).to.have.members([2, 1, 3]);
    expect([1, 2, 2]).to.have.members([2, 1, 2]);
    ```

    By default, members are compared using strict (`===`) equality. Add `.``deep` earlier in the chain to use deep equality instead. See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.

    ``` javascript
    // Target array deeply (but not strictly) has member `{a: 1}`
    expect([{a: 1}]).to.have.deep.members([{a: 1}]);
    expect([{a: 1}]).to.not.have.members([{a: 1}]);
    ```

    By default, order doesn’t matter. Add `.``ordered` earlier in the chain to require that members appear in the same order.

    ``` javascript
    expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
    expect([1, 2, 3]).to.have.members([2, 1, 3])
      .but.not.ordered.members([2, 1, 3]);
    ```

    By default, both arrays must be the same size. Add `.``include` earlier in the chain to require that the target’s members be a superset of the expected members. Note that duplicates are ignored in the subset when `.``include` is added.

    ``` javascript
    // Target array is a superset of [1, 2] but not identical
    expect([1, 2, 3]).to.include.members([1, 2]);
    expect([1, 2, 3]).to.not.have.members([1, 2]);

    // Duplicates in the subset are ignored
    expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
    ```

    `.``deep`, `.``ordered`, and `.``include` can all be combined. However, if `.``include` and `.``ordered` are combined, the ordering begins at the start of both arrays.

    ``` javascript
    expect([{a: 1}, {b: 2}, {c: 3}])
      .to.include.deep.ordered.members([{a: 1}, {b: 2}])
      .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
    ```

    Add `.``not` earlier in the chain to negate `.``members`. However, it’s dangerous to do so. The problem is that it creates uncertain expectations by asserting that the target array doesn’t have all of the same members as the given array `set` but may or may not have some of them. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.

    ``` javascript
    expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
    expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
    ```

    `.``members` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
    expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
    ```
- name: most
  id: api/bdd/index#method_most
  summary: Asserts that the target is a number or a date less than or equal to the given number or date n respectively
  belongs_to: BDD
  description: |-
    ### .most(n\[, msg\])

    - @param { Number } n
    - @param { String } msg \_optional\_

    Asserts that the target is a number or a date less than or equal to the given number or date `n` respectively. However, it’s often best to assert that the target is equal to its expected value.

    ``` javascript
    expect(1).to.equal(1); // Recommended
    expect(1).to.be.at.most(2); // Not recommended
    expect(1).to.be.at.most(1); // Not recommended
    ```

    Add `.``lengthOf` earlier in the chain to assert that the target’s `length` or `size` is less than or equal to the given number `n`.

    ``` javascript
    expect('foo').to.have.lengthOf(3); // Recommended
    expect('foo').to.have.lengthOf.at.most(4); // Not recommended

    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
    ```

    Add `.``not` earlier in the chain to negate `.``most`.

    ``` javascript
    expect(2).to.equal(2); // Recommended
    expect(2).to.not.be.at.most(1); // Not recommended
    ```

    `.``most` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect(2).to.be.at.most(1, 'nooo why fail??');
    expect(2, 'nooo why fail??').to.be.at.most(1);
    ```

    The aliases `.``lte` and `.``lessThanOrEqual` can be used interchangeably with `.``most`.
- name: NaN
  id: api/bdd/index#method_nan
  summary: Asserts that the target is exactly NaN
  belongs_to: BDD
  description: |-
    ### .NaN

    Asserts that the target is exactly `NaN`.

    ``` javascript
    expect(NaN).to.be.NaN;
    ```

    Add `.``not` earlier in the chain to negate `.``NaN`. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to `NaN`.

    ``` javascript
    expect('foo').to.equal('foo'); // Recommended
    expect('foo').to.not.be.NaN; // Not recommended
    ```

    A custom error message can be given as the second argument to `expect`.

    ``` javascript
    expect(42, 'nooo why fail??').to.be.NaN;
    ```
- name: nested
  id: api/bdd/index#method_nested
  summary: Enables dot- and bracket-notation in all .``property and .``include assertions that follow in the chain
  belongs_to: BDD
  description: |-
    ### .nested

    Enables dot- and bracket-notation in all `.``property` and `.``include` assertions that follow in the chain.

    ``` javascript
    expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
    expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
    ```

    If `.` or `[]` are part of an actual property name, they can be escaped by adding two backslashes before them.

    ``` javascript
    expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
    expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
    ```

    `.``nested` cannot be combined with `.``own`.
- name: nestedInclude
  id: api/assert/index#method_nestedinclude
  summary: Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object
  belongs_to: Assert
  description: |-
    ### .nestedInclude(haystack, needle, \[message\])

    - @param { Object } haystack
    - @param { Object } needle
    - @param { String } message

    Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\[\]’ and ‘.’ in property names can be escaped using double backslashes.

    ``` javascript
    assert.nestedInclude({'.a': {'b': 'x'}}, {'\\.a.[b]': 'x'});
    assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'x'});
    ```
- name: nestedProperty
  id: api/assert/index#method_nestedproperty
  summary: Asserts that object has a direct or inherited property named by property, which can be a string using dot- and bracket-notation for nested reference
  belongs_to: Assert
  description: |-
    ### .nestedProperty(object, property, \[message\])

    - @param { Object } object
    - @param { String } property
    - @param { String } message

    Asserts that `object` has a direct or inherited property named by `property`, which can be a string using dot- and bracket-notation for nested reference.

    ``` javascript
    assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');
    ```
- name: nestedPropertyVal
  id: api/assert/index#method_nestedpropertyval
  summary: Asserts that object has a property named by property with value given by value
  belongs_to: Assert
  description: |-
    ### .nestedPropertyVal(object, property, value, \[message\])

    - @param { Object } object
    - @param { String } property
    - @param { Mixed } value
    - @param { String } message

    Asserts that `object` has a property named by `property` with value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a strict equality check (===).

    ``` javascript
    assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
    ```
- name: not
  id: api/bdd/index#method_not
  summary: Negates all assertions that follow in the chain
  belongs_to: BDD
  description: |-
    ### .not

    Negates all assertions that follow in the chain.

    ``` javascript
    expect(function () {}).to.not.throw();
    expect({a: 1}).to.not.have.property('b');
    expect([1, 2]).to.be.an('array').that.does.not.include(3);
    ```

    Just because you can negate any assertion with `.``not` doesn’t mean you should. With great power comes great responsibility. It’s often best to assert that the one expected output was produced, rather than asserting that one of countless unexpected outputs wasn’t produced. See individual assertions for specific guidance.

    ``` javascript
    expect(2).to.equal(2); // Recommended
    expect(2).to.not.equal(1); // Not recommended
    ```
- name: notDeepEqual
  id: api/assert/index#method_notdeepequal
  summary: Assert that actual is not deeply equal to expected
  belongs_to: Assert
  description: |-
    ### .notDeepEqual(actual, expected, \[message\])

    - @param { Mixed } actual
    - @param { Mixed } expected
    - @param { String } message

    Assert that `actual` is not deeply equal to `expected`.

    ``` javascript
    assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
    ```
- name: notDeepInclude
  id: api/assert/index#method_notdeepinclude
  summary: Asserts that haystack does not include needle
  belongs_to: Assert
  description: |-
    ### .notDeepInclude(haystack, needle, \[message\])

    - @param { Array \| String } haystack
    - @param { Mixed } needle
    - @param { String } message

    Asserts that `haystack` does not include `needle`. Can be used to assert the absence of a value in an array or a subset of properties in an object. Deep equality is used.

    ``` javascript
    var obj1 = {a: 1}
      , obj2 = {b: 2};
    assert.notDeepInclude([obj1, obj2], {a: 9});
    assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
    assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});
    ```
- name: notDeepNestedInclude
  id: api/assert/index#method_notdeepnestedinclude
  summary: Asserts that ‘haystack’ does not include ‘needle’. Can be used to assert the absence of a subset of properties in an object while checking for deep equality
  belongs_to: Assert
  description: |-
    ### .notDeepNestedInclude(haystack, needle, \[message\])

    - @param { Object } haystack
    - @param { Object } needle
    - @param { String } message

    Asserts that ‘haystack’ does not include ‘needle’. Can be used to assert the absence of a subset of properties in an object while checking for deep equality. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\[\]’ and ‘.’ in property names can be escaped using double backslashes.

    ``` javascript
    assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})
    assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {y: 2}});
    ```
- name: notDeepNestedPropertyVal
  id: api/assert/index#method_notdeepnestedpropertyval
  summary: Asserts that object does not have a property named by property with value given by value
  belongs_to: Assert
  description: |-
    ### .notDeepNestedPropertyVal(object, property, value, \[message\])

    - @param { Object } object
    - @param { String } property
    - @param { Mixed } value
    - @param { String } message

    Asserts that `object` does *not* have a property named by `property` with value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a deep equality check.

    ``` javascript
    assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });
    assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });
    assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });
    ```
- name: notDeepOwnInclude
  id: api/assert/index#method_notdeepowninclude
  summary: Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties and checking for deep equality
  belongs_to: Assert
  description: |-
    ### .notDeepOwnInclude(haystack, needle, \[message\])

    - @param { Object } haystack
    - @param { Object } needle
    - @param { String } message

    Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties and checking for deep equality.

    ``` javascript
     assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});
    ```
- name: notDeepPropertyVal
  id: api/assert/index#method_notdeeppropertyval
  summary: Asserts that object does not have a direct or inherited property named by property with value given by value
  belongs_to: Assert
  description: |-
    ### .notDeepPropertyVal(object, property, value, \[message\])

    - @param { Object } object
    - @param { String } property
    - @param { Mixed } value
    - @param { String } message

    Asserts that `object` does *not* have a direct or inherited property named by `property` with value given by `value`. Uses a deep equality check.

    ``` javascript
    assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
    assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
    assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
    ```
- name: notEqual
  id: api/assert/index#method_notequal
  summary: Asserts non-strict inequality (!=) of actual and expected
  belongs_to: Assert
  description: |-
    ### .notEqual(actual, expected, \[message\])

    - @param { Mixed } actual
    - @param { Mixed } expected
    - @param { String } message

    Asserts non-strict inequality (`!=`) of `actual` and `expected`.

    ``` javascript
    assert.notEqual(3, 4, 'these numbers are not equal');
    ```
- name: notExists
  id: api/assert/index#method_notexists
  summary: Asserts that the target is either null or undefined
  belongs_to: Assert
  description: |-
    ### .notExists

    - @param { Mixed } value
    - @param { String } message

    Asserts that the target is either `null` or `undefined`.

    ``` javascript
    var bar = null
      , baz;

    assert.notExists(bar);
    assert.notExists(baz, 'baz is either null or undefined');
    ```
- name: notInclude
  id: api/assert/index#method_notinclude
  summary: Asserts that haystack does not include needle
  belongs_to: Assert
  description: |-
    ### .notInclude(haystack, needle, \[message\])

    - @param { Array \| String } haystack
    - @param { Mixed } needle
    - @param { String } message

    Asserts that `haystack` does not include `needle`. Can be used to assert the absence of a value in an array, a substring in a string, or a subset of properties in an object.

    ``` javascript
    assert.notInclude([1,2,3], 4, "array doesn't contain value");
    assert.notInclude('foobar', 'baz', "string doesn't contain substring");
    assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');
    ```

    Strict equality (===) is used. When asserting the absence of a value in an array, the array is searched to confirm the absence of an element that’s strictly equal to the given value. When asserting a subset of properties in an object, the object is searched to confirm that at least one of the given property keys is either not present or not strictly equal to the given property value. For instance:

    ``` javascript
    var obj1 = {a: 1}
      , obj2 = {b: 2};
    assert.notInclude([obj1, obj2], {a: 1});
    assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
    assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});
    ```
- name: notIncludeDeepMembers
  id: api/assert/index#method_notincludedeepmembers
  summary: Asserts that subset isn’t included in superset in any order
  belongs_to: Assert
  description: |-
    ### .notIncludeDeepMembers(superset, subset, \[message\])

    - @param { Array } superset
    - @param { Array } subset
    - @param { String } message

    Asserts that `subset` isn’t included in `superset` in any order. Uses a deep equality check. Duplicates are ignored.

    ``` javascript
    assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
    ```
- name: notIncludeDeepOrderedMembers
  id: api/assert/index#method_notincludedeeporderedmembers
  summary: Asserts that subset isn’t included in superset in the same order beginning with the first element in superset
  belongs_to: Assert
  description: |-
    ### .notIncludeDeepOrderedMembers(superset, subset, \[message\])

    - @param { Array } superset
    - @param { Array } subset
    - @param { String } message

    Asserts that `subset` isn’t included in `superset` in the same order beginning with the first element in `superset`. Uses a deep equality check.

    ``` javascript
    assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');
    assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');
    assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');
    ```
- name: notIncludeMembers
  id: api/assert/index#method_notincludemembers
  summary: Asserts that subset isn’t included in superset in any order
  belongs_to: Assert
  description: |-
    ### .notIncludeMembers(superset, subset, \[message\])

    - @param { Array } superset
    - @param { Array } subset
    - @param { String } message

    Asserts that `subset` isn’t included in `superset` in any order. Uses a strict equality check (===). Duplicates are ignored.

    ``` javascript
    assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');
    ```
- name: notIncludeOrderedMembers
  id: api/assert/index#method_notincludeorderedmembers
  summary: Asserts that subset isn’t included in superset in the same order beginning with the first element in superset
  belongs_to: Assert
  description: |-
    ### .notIncludeOrderedMembers(superset, subset, \[message\])

    - @param { Array } superset
    - @param { Array } subset
    - @param { String } message

    Asserts that `subset` isn’t included in `superset` in the same order beginning with the first element in `superset`. Uses a strict equality check (===).

    ``` javascript
    assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');
    assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');
    ```
- name: notInstanceOf
  id: api/assert/index#method_notinstanceof
  summary: Asserts value is not an instance of constructor
  belongs_to: Assert
  description: |-
    ### .notInstanceOf(object, constructor, \[message\])

    - @param { Object } object
    - @param { Constructor } constructor
    - @param { String } message

    Asserts `value` is not an instance of `constructor`.

    ``` javascript
    var Tea = function (name) { this.name = name; }
      , chai = new String('chai');

    assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
    ```
- name: notMatch
  id: api/assert/index#method_notmatch
  summary: Asserts that value does not match the regular expression regexp
  belongs_to: Assert
  description: |-
    ### .notMatch(value, regexp, \[message\])

    - @param { Mixed } value
    - @param { RegExp } regexp
    - @param { String } message

    Asserts that `value` does not match the regular expression `regexp`.

    ``` javascript
    assert.notMatch('foobar', /^foo/, 'regexp does not match');
    ```
- name: notNestedInclude
  id: api/assert/index#method_notnestedinclude
  summary: Asserts that ‘haystack’ does not include ‘needle’. Can be used to assert the absence of a subset of properties in an object
  belongs_to: Assert
  description: |-
    ### .notNestedInclude(haystack, needle, \[message\])

    - @param { Object } haystack
    - @param { Object } needle
    - @param { String } message

    Asserts that ‘haystack’ does not include ‘needle’. Can be used to assert the absence of a subset of properties in an object. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\[\]’ and ‘.’ in property names can be escaped using double backslashes.

    ``` javascript
    assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\.a.b': 'y'});
    assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'y'});
    ```
- name: notNestedProperty
  id: api/assert/index#method_notnestedproperty
  summary: Asserts that object does not have a property named by property, which can be a string using dot- and bracket-notation for nested reference
  belongs_to: Assert
  description: |-
    ### .notNestedProperty(object, property, \[message\])

    - @param { Object } object
    - @param { String } property
    - @param { String } message

    Asserts that `object` does *not* have a property named by `property`, which can be a string using dot- and bracket-notation for nested reference. The property cannot exist on the object nor anywhere in its prototype chain.

    ``` javascript
    assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
    ```
- name: notNestedPropertyVal
  id: api/assert/index#method_notnestedpropertyval
  summary: Asserts that object does not have a property named by property with value given by value
  belongs_to: Assert
  description: |-
    ### .notNestedPropertyVal(object, property, value, \[message\])

    - @param { Object } object
    - @param { String } property
    - @param { Mixed } value
    - @param { String } message

    Asserts that `object` does *not* have a property named by `property` with value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a strict equality check (===).

    ``` javascript
    assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
    assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');
    ```
- name: notOwnInclude
  id: api/assert/index#method_notowninclude
  summary: Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties
  belongs_to: Assert
  description: |-
    ### .notOwnInclude(haystack, needle, \[message\])

    - @param { Object } haystack
    - @param { Object } needle
    - @param { String } message

    Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties.

    ``` javascript
    Object.prototype.b = 2;

    assert.notOwnInclude({ a: 1 }, { b: 2 });
    ```
- name: notProperty
  id: api/assert/index#method_notproperty
  summary: Asserts that object does not have a direct or inherited property named by property
  belongs_to: Assert
  description: |-
    ### .notProperty(object, property, \[message\])

    - @param { Object } object
    - @param { String } property
    - @param { String } message

    Asserts that `object` does *not* have a direct or inherited property named by `property`.

    ``` javascript
    assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
    ```
- name: notPropertyVal
  id: api/assert/index#method_notpropertyval
  summary: Asserts that object does not have a direct or inherited property named by property with value given by value
  belongs_to: Assert
  description: |-
    ### .notPropertyVal(object, property, value, \[message\])

    - @param { Object } object
    - @param { String } property
    - @param { Mixed } value
    - @param { String } message

    Asserts that `object` does *not* have a direct or inherited property named by `property` with value given by `value`. Uses a strict equality check (===).

    ``` javascript
    assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');
    assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');
    ```
- name: notSameDeepMembers
  id: api/assert/index#method_notsamedeepmembers
  summary: Asserts that set1 and set2 don’t have the same members in any order
  belongs_to: Assert
  description: |-
    ### .notSameDeepMembers(set1, set2, \[message\])

    - @param { Array } set1
    - @param { Array } set2
    - @param { String } message

    Asserts that `set1` and `set2` don’t have the same members in any order. Uses a deep equality check.

    ``` javascript
    assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');
    ```
- name: notSameDeepOrderedMembers
  id: api/assert/index#method_notsamedeeporderedmembers
  summary: Asserts that set1 and set2 don’t have the same members in the same order
  belongs_to: Assert
  description: |-
    ### .notSameDeepOrderedMembers(set1, set2, \[message\])

    - @param { Array } set1
    - @param { Array } set2
    - @param { String } message

    Asserts that `set1` and `set2` don’t have the same members in the same order. Uses a deep equality check.

    ``` javascript
    assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');
    assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');
    ```
- name: notSameMembers
  id: api/assert/index#method_notsamemembers
  summary: Asserts that set1 and set2 don’t have the same members in any order
  belongs_to: Assert
  description: |-
    ### .notSameMembers(set1, set2, \[message\])

    - @param { Array } set1
    - @param { Array } set2
    - @param { String } message

    Asserts that `set1` and `set2` don’t have the same members in any order. Uses a strict equality check (===).

    ``` javascript
    assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');
    ```
- name: notSameOrderedMembers
  id: api/assert/index#method_notsameorderedmembers
  summary: Asserts that set1 and set2 don’t have the same members in the same order
  belongs_to: Assert
  description: |-
    ### .notSameOrderedMembers(set1, set2, \[message\])

    - @param { Array } set1
    - @param { Array } set2
    - @param { String } message

    Asserts that `set1` and `set2` don’t have the same members in the same order. Uses a strict equality check (===).

    ``` javascript
    assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');
    ```
- name: notStrictEqual
  id: api/assert/index#method_notstrictequal
  summary: Asserts strict inequality (!==) of actual and expected
  belongs_to: Assert
  description: |-
    ### .notStrictEqual(actual, expected, \[message\])

    - @param { Mixed } actual
    - @param { Mixed } expected
    - @param { String } message

    Asserts strict inequality (`!==`) of `actual` and `expected`.

    ``` javascript
    assert.notStrictEqual(3, '3', 'no coercion for strict equality');
    ```
- name: notTypeOf
  id: api/assert/index#method_nottypeof
  summary: Asserts that value’s type is not name, as determined by Object``.``prototype``.``toString
  belongs_to: Assert
  description: |-
    ### .notTypeOf(value, name, \[message\])

    - @param { Mixed } value
    - @param { String } typeof name
    - @param { String } message

    Asserts that `value`’s type is *not* `name`, as determined by `Object``.``prototype``.``toString`.

    ``` javascript
    assert.notTypeOf('tea', 'number', 'strings are not numbers');
    ```
- name: 'null'
  id: api/bdd/index#method_null
  summary: Asserts that the target is strictly (===) equal to null
  belongs_to: BDD
  description: |-
    ### .null

    Asserts that the target is strictly (`===`) equal to `null`.

    ``` javascript
    expect(null).to.be.null;
    ```

    Add `.``not` earlier in the chain to negate `.``null`. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to `null`.

    ``` javascript
    expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.null; // Not recommended
    ```

    A custom error message can be given as the second argument to `expect`.

    ``` javascript
    expect(42, 'nooo why fail??').to.be.null;
    ```
- name: objDisplay
  id: api/plugins/index#method_objdisplay
  summary: Determines if an object or an array matches criteria to be inspected in-line for error messages or should be truncated
  belongs_to: Plugin Utilities
  description: |-
    ### .objDisplay(object)

    - @param { Mixed } javascript object to inspect

    Determines if an object or an array matches criteria to be inspected in-line for error messages or should be truncated.
- name: ok
  id: api/bdd/index#method_ok
  summary: Asserts that the target is a truthy value (considered true in boolean context)
  belongs_to: BDD
  description: |-
    ### .ok

    Asserts that the target is a truthy value (considered `true` in boolean context). However, it’s often best to assert that the target is strictly (`===`) or deeply equal to its expected value.

    ``` javascript
    expect(1).to.equal(1); // Recommended
    expect(1).to.be.ok; // Not recommended

    expect(true).to.be.true; // Recommended
    expect(true).to.be.ok; // Not recommended
    ```

    Add `.``not` earlier in the chain to negate `.``ok`.

    ``` javascript
    expect(0).to.equal(0); // Recommended
    expect(0).to.not.be.ok; // Not recommended

    expect(false).to.be.false; // Recommended
    expect(false).to.not.be.ok; // Not recommended

    expect(null).to.be.null; // Recommended
    expect(null).to.not.be.ok; // Not recommended

    expect(undefined).to.be.undefined; // Recommended
    expect(undefined).to.not.be.ok; // Not recommended
    ```

    A custom error message can be given as the second argument to `expect`.

    ``` javascript
    expect(false, 'nooo why fail??').to.be.ok;
    ```
- name: oneOf
  id: api/bdd/index#method_oneof
  summary: Asserts that the target is a member of the given array list
  belongs_to: BDD
  description: |-
    ### .oneOf(list\[, msg\])

    - @param { Array. } list
    - @param { String } msg \_optional\_

    Asserts that the target is a member of the given array `list`. However, it’s often best to assert that the target is equal to its expected value.

    ``` javascript
    expect(1).to.equal(1); // Recommended
    expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
    ```

    Comparisons are performed using strict (`===`) equality.

    Add `.``not` earlier in the chain to negate `.``oneOf`.

    ``` javascript
    expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
    ```

    It can also be chained with `.``contain` or `.``include`, which will work with both arrays and strings:

    ``` javascript
    expect('Today is sunny').to.contain.oneOf(['sunny', 'cloudy'])
    expect('Today is rainy').to.not.contain.oneOf(['sunny', 'cloudy'])
    expect([1,2,3]).to.contain.oneOf([3,4,5])
    expect([1,2,3]).to.not.contain.oneOf([4,5,6])
    ```

    `.``oneOf` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
    expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
    ```
- name: oneOf
  id: api/assert/index#method_oneof
  summary: Asserts that non-object, non-array value inList appears in the flat array list
  belongs_to: Assert
  description: |-
    ### .oneOf(inList, list, \[message\])

    - @param { } inList
    - @param { Array. } list
    - @param { String } message

    Asserts that non-object, non-array value `inList` appears in the flat array `list`.

    ``` javascript
    assert.oneOf(1, [ 2, 1 ], 'Not found in list');
    ```
- name: operator
  id: api/assert/index#method_operator
  summary: Compares two values using operator
  belongs_to: Assert
  description: |-
    ### .operator(val1, operator, val2, \[message\])

    - @param { Mixed } val1
    - @param { String } operator
    - @param { Mixed } val2
    - @param { String } message

    Compares two values using `operator`.

    ``` javascript
    assert.operator(1, '<', 2, 'everything is ok');
    assert.operator(1, '>', 2, 'this will fail');
    ```
- name: ordered
  id: api/bdd/index#method_ordered
  summary: Causes all .``members assertions that follow in the chain to require that members be in the same order
  belongs_to: BDD
  description: |-
    ### .ordered

    Causes all `.``members` assertions that follow in the chain to require that members be in the same order.

    ``` javascript
    expect([1, 2]).to.have.ordered.members([1, 2])
      .but.not.have.ordered.members([2, 1]);
    ```

    When `.``include` and `.``ordered` are combined, the ordering begins at the start of both arrays.

    ``` javascript
    expect([1, 2, 3]).to.include.ordered.members([1, 2])
      .but.not.include.ordered.members([2, 3]);
    ```
- name: overwriteChainableMethod
  id: api/plugins/index#method_overwritechainablemethod
  summary: Overwrites an already existing chainable method and provides access to the previous function or property
  belongs_to: Plugin Utilities
  description: |-
    ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)

    - @param { Object } ctx object whose method / property is to be overwritten
    - @param { String } name of method / property to overwrite
    - @param { Function } method function that returns a function to be used for name
    - @param { Function } chainingBehavior function that returns a function to be used for property

    Overwrites an already existing chainable method and provides access to the previous function or property. Must return functions to be used for name.

    ``` javascript
    utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',
      function (_super) {
      }
    , function (_super) {
      }
    );
    ```

    Can also be accessed directly from `chai.Assertion`.

    ``` javascript
    chai.Assertion.overwriteChainableMethod('foo', fn, fn);
    ```

    Then can be used as any other assertion.

    ``` javascript
    expect(myFoo).to.have.lengthOf(3);
    expect(myFoo).to.have.lengthOf.above(3);
    ```
- name: overwriteMethod
  id: api/plugins/index#method_overwritemethod
  summary: Overwrites an already existing method and provides access to previous function
  belongs_to: Plugin Utilities
  description: |-
    ### .overwriteMethod(ctx, name, fn)

    - @param { Object } ctx object whose method is to be overwritten
    - @param { String } name of method to overwrite
    - @param { Function } method function that returns a function to be used for name

    Overwrites an already existing method and provides access to previous function. Must return function to be used for name.

    ``` javascript
    utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
      return function (str) {
        var obj = utils.flag(this, 'object');
        if (obj instanceof Foo) {
          new chai.Assertion(obj.value).to.equal(str);
        } else {
          _super.apply(this, arguments);
        }
      }
    });
    ```

    Can also be accessed directly from `chai.Assertion`.

    ``` javascript
    chai.Assertion.overwriteMethod('foo', fn);
    ```

    Then can be used as any other assertion.

    ``` javascript
    expect(myFoo).to.equal('bar');
    ```
- name: overwriteProperty
  id: api/plugins/index#method_overwriteproperty
  summary: Overwrites an already existing property getter and provides access to previous value
  belongs_to: Plugin Utilities
  description: |-
    ### .overwriteProperty(ctx, name, fn)

    - @param { Object } ctx object whose property is to be overwritten
    - @param { String } name of property to overwrite
    - @param { Function } getter function that returns a getter function to be used for name

    Overwrites an already existing property getter and provides access to previous value. Must return function to use as getter.

    ``` javascript
    utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
      return function () {
        var obj = utils.flag(this, 'object');
        if (obj instanceof Foo) {
          new chai.Assertion(obj.name).to.equal('bar');
        } else {
          _super.call(this);
        }
      }
    });
    ```

    Can also be accessed directly from `chai.Assertion`.

    ``` javascript
    chai.Assertion.overwriteProperty('foo', fn);
    ```

    Then can be used as any other assertion.

    ``` javascript
    expect(myFoo).to.be.ok;
    ```
- name: own
  id: api/bdd/index#method_own
  summary: Causes all .``property and .``include assertions that follow in the chain to ignore inherited properties
  belongs_to: BDD
  description: |-
    ### .own

    Causes all `.``property` and `.``include` assertions that follow in the chain to ignore inherited properties.

    ``` javascript
    Object.prototype.b = 2;

    expect({a: 1}).to.have.own.property('a');
    expect({a: 1}).to.have.property('b');
    expect({a: 1}).to.not.have.own.property('b');

    expect({a: 1}).to.own.include({a: 1});
    expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
    ```

    `.``own` cannot be combined with `.``nested`.
- name: ownInclude
  id: api/assert/index#method_owninclude
  summary: Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties
  belongs_to: Assert
  description: |-
    ### .ownInclude(haystack, needle, \[message\])

    - @param { Object } haystack
    - @param { Object } needle
    - @param { String } message

    Asserts that ‘haystack’ includes ‘needle’. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties.

    ``` javascript
    assert.ownInclude({ a: 1 }, { a: 1 });
    ```
- name: ownPropertyDescriptor
  id: api/bdd/index#method_ownpropertydescriptor
  summary: Asserts that the target has its own property descriptor with the given key name
  belongs_to: BDD
  description: |-
    ### .ownPropertyDescriptor(name\[, descriptor\[, msg\]\])

    - @param { String } name
    - @param { Object } descriptor \_optional\_
    - @param { String } msg \_optional\_

    Asserts that the target has its own property descriptor with the given key `name`. Enumerable and non-enumerable properties are included in the search.

    ``` javascript
    expect({a: 1}).to.have.ownPropertyDescriptor('a');
    ```

    When `descriptor` is provided, `.``ownPropertyDescriptor` also asserts that the property’s descriptor is deeply equal to the given `descriptor`. See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.

    ``` javascript
    expect({a: 1}).to.have.ownPropertyDescriptor('a', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 1,
    });
    ```

    Add `.``not` earlier in the chain to negate `.``ownPropertyDescriptor`.

    ``` javascript
    expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
    ```

    However, it’s dangerous to negate `.``ownPropertyDescriptor` when providing a `descriptor`. The problem is that it creates uncertain expectations by asserting that the target either doesn’t have a property descriptor with the given key `name`, or that it does have a property descriptor with the given key `name` but it’s not deeply equal to the given `descriptor`. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.

    When the target isn’t expected to have a property descriptor with the given key `name`, it’s often best to assert exactly that.

    ``` javascript
    // Recommended
    expect({b: 2}).to.not.have.ownPropertyDescriptor('a');

    // Not recommended
    expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 1,
    });
    ```

    When the target is expected to have a property descriptor with the given key `name`, it’s often best to assert that the property has its expected descriptor, rather than asserting that it doesn’t have one of many unexpected descriptors.

    ``` javascript
    // Recommended
    expect({a: 3}).to.have.ownPropertyDescriptor('a', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 3,
    });

    // Not recommended
    expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 1,
    });
    ```

    `.``ownPropertyDescriptor` changes the target of any assertions that follow in the chain to be the value of the property descriptor from the original target object.

    ``` javascript
    expect({a: 1}).to.have.ownPropertyDescriptor('a')
      .that.has.property('enumerable', true);
    ```

    `.``ownPropertyDescriptor` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`. When not providing `descriptor`, only use the second form.

    ``` javascript
    // Recommended
    expect({a: 1}).to.have.ownPropertyDescriptor('a', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 2,
    }, 'nooo why fail??');

    // Recommended
    expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 2,
    });

    // Recommended
    expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');

    // Not recommended
    expect({a: 1})
      .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
    ```

    The above assertion isn’t the same thing as not providing `descriptor`. Instead, it’s asserting that the target object has a `b` property descriptor that’s deeply equal to `undefined`.

    The alias `.``haveOwnPropertyDescriptor` can be used interchangeably with `.``ownPropertyDescriptor`.
- name: Plugin Utilities
  id: api/plugins/index
  summary: The plugin utilities are for those who want to extend Chai with their own set of assertions
  description: "# Plugin Utilities\n\nThe plugin utilities are for those who want to extend Chai with their own set of assertions. The [Code Plugin Concepts](../../guide/plugins/index) and [Building a Helper](../../guide/helpers/index) guide tutorials are a great reference on how to get started with your own assertions.\n\n## API Reference\n\n### .addChainableMethod(ctx, name, method, chainingBehavior)\n\n- @param { Object } ctx object to which the method is added\n- @param { String } name of method to add\n- @param { Function } method function to be used for \\`name\\`, when called\n- @param { Function } chainingBehavior function to be called every time the property is accessed\n\nAdds a method to an object, such that the method can also be chained.\n\n``` javascript\nutils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n  var obj = utils.flag(this, 'object');\n  new chai.Assertion(obj).to.be.equal(str);\n});\n```\n\nCan also be accessed directly from `chai.Assertion`.\n\n``` javascript\nchai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n```\n\nThe result can then be used as both a method assertion, executing both `method` and `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n\n``` javascript\nexpect(fooStr).to.be.foo('bar');\nexpect(fooStr).to.be.foo.equal('foo');\n```\n\n### .addLengthGuard(fn, assertionName, isChainable)\n\n- @param { Function } fn\n- @param { String } assertionName\n- @param { Boolean } isChainable\n\nDefine `length` as a getter on the given uninvoked method assertion. The getter acts as a guard against chaining `length` directly off of an uninvoked method assertion, which is a problem because it references `function`’s built-in `length` property instead of Chai’s `length` assertion. When the getter catches the user making this mistake, it throws an error with a helpful message.\n\nThere are two ways in which this mistake can be made. The first way is by chaining the `length` assertion directly off of an uninvoked chainable method. In this case, Chai suggests that the user use `lengthOf` instead. The second way is by chaining the `length` assertion directly off of an uninvoked non-chainable method. Non-chainable methods must be invoked prior to chaining. In this case, Chai suggests that the user consult the docs for the given assertion.\n\nIf the `length` property of functions is unconfigurable, then return `fn` without modification.\n\nNote that in ES6, the function’s `length` property is configurable, so once support for legacy environments is dropped, Chai’s `length` property can replace the built-in function’s `length` property, and this length guard will no longer be necessary. In the mean time, maintaining consistency across all environments is the priority.\n\n### .addMethod(ctx, name, method)\n\n- @param { Object } ctx object to which the method is added\n- @param { String } name of method to add\n- @param { Function } method function to be used for name\n\nAdds a method to the prototype of an object.\n\n``` javascript\nutils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n  var obj = utils.flag(this, 'object');\n  new chai.Assertion(obj).to.be.equal(str);\n});\n```\n\nCan also be accessed directly from `chai.Assertion`.\n\n``` javascript\nchai.Assertion.addMethod('foo', fn);\n```\n\nThen can be used as any other assertion.\n\n``` javascript\nexpect(fooStr).to.be.foo('bar');\n```\n\n### .addProperty(ctx, name, getter)\n\n- @param { Object } ctx object to which the property is added\n- @param { String } name of property to add\n- @param { Function } getter function to be used for name\n\nAdds a property to the prototype of an object.\n\n``` javascript\nutils.addProperty(chai.Assertion.prototype, 'foo', function () {\n  var obj = utils.flag(this, 'object');\n  new chai.Assertion(obj).to.be.instanceof(Foo);\n});\n```\n\nCan also be accessed directly from `chai.Assertion`.\n\n``` javascript\nchai.Assertion.addProperty('foo', fn);\n```\n\nThen can be used as any other assertion.\n\n``` javascript\nexpect(myFoo).to.be.foo;\n```\n\n### .compareByInspect(mixed, mixed)\n\n- @param { Mixed } first element to compare\n- @param { Mixed } second element to compare\n\nTo be used as a compareFunction with Array.prototype.sort. Compares elements using inspect instead of default behavior of using toString so that Symbols and objects with irregular/missing toString can still be sorted without a TypeError.\n\n### .expectTypes(obj, types)\n\n- @param { Mixed } obj constructed Assertion\n- @param { Array } type A list of allowed types for this assertion\n\nEnsures that the object being tested against is of a valid type.\n\n``` javascript\nutils.expectTypes(this, ['array', 'object', 'string']);\n```\n\n### .flag(object, key, \\[value\\])\n\n- @param { Object } object constructed Assertion\n- @param { String } key\n- @param { Mixed } value (optional)\n\nGet or set a flag value on an object. If a value is provided it will be set, else it will return the currently set value or `undefined` if the value is not set.\n\n``` javascript\nutils.flag(this, 'foo', 'bar'); // setter\nutils.flag(this, 'foo'); // getter, returns `bar`\n```\n\n### .getActual(object, \\[actual\\])\n\n- @param { Object } object (constructed Assertion)\n- @param { Arguments } chai.Assertion.prototype.assert arguments\n\nReturns the `actual` value for an Assertion.\n\n### .getEnumerableProperties(object)\n\n- @param { Object } object\n\nThis allows the retrieval of enumerable property names of an object, inherited or not.\n\n### .getMessage(object, message, negateMessage)\n\n- @param { Object } object (constructed Assertion)\n- @param { Arguments } chai.Assertion.prototype.assert arguments\n\nConstruct the error message based on flags and template tags. Template tags will return a stringified inspection of the object referenced.\n\nMessage template tags:\n\n- `#{this}` current asserted object\n- `#{act}` actual value\n- `#{exp}` expected value\n\n### .getOperator(message)\n\n- @param { Object } object (constructed Assertion)\n- @param { Arguments } chai.Assertion.prototype.assert arguments\n\nExtract the operator from error message. Operator defined is based on below link https://nodejs.org/api/assert.html#assert_assert.\n\nReturns the `operator` or `undefined` value for an Assertion.\n\n### .getOwnEnumerableProperties(object)\n\n- @param { Object } object\n\nThis allows the retrieval of directly-owned enumerable property names and symbols of an object. This function is necessary because Object.keys only returns enumerable property names, not enumerable property symbols.\n\n### .getOwnEnumerablePropertySymbols(object)\n\n- @param { Object } object\n\nThis allows the retrieval of directly-owned enumerable property symbols of an object. This function is necessary because Object.getOwnPropertySymbols returns both enumerable and non-enumerable property symbols.\n\n### .getProperties(object)\n\n- @param { Object } object\n\nThis allows the retrieval of property names of an object, enumerable or not, inherited or not.\n\n### .inspect(obj, \\[showHidden\\], \\[depth\\], \\[colors\\])\n\n- @param { Object } obj The object to print out.\n- @param { Boolean } showHidden Flag that shows hidden (not enumerable) properties of objects. Default is false.\n- @param { Number } depth Depth in which to descend in object. Default is 2.\n- @param { Boolean } colors Flag to turn on ANSI escape codes to color the output. Default is false (no coloring).\n\nEchoes the value of a value. Tries to print the value out in the best way possible given the different types.\n\n### .isProxyEnabled()\n\nHelper function to check if Chai’s proxy protection feature is enabled. If proxies are unsupported or disabled via the user’s Chai config, then return false. Otherwise, return true.\n\n### .objDisplay(object)\n\n- @param { Mixed } javascript object to inspect\n\nDetermines if an object or an array matches criteria to be inspected in-line for error messages or should be truncated.\n\n### .overwriteChainableMethod(ctx, name, method, chainingBehavior)\n\n- @param { Object } ctx object whose method / property is to be overwritten\n- @param { String } name of method / property to overwrite\n- @param { Function } method function that returns a function to be used for name\n- @param { Function } chainingBehavior function that returns a function to be used for property\n\nOverwrites an already existing chainable method and provides access to the previous function or property. Must return functions to be used for name.\n\n``` javascript\nutils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',\n  function (_super) {\n  }\n, function (_super) {\n  }\n);\n```\n\nCan also be accessed directly from `chai.Assertion`.\n\n``` javascript\nchai.Assertion.overwriteChainableMethod('foo', fn, fn);\n```\n\nThen can be used as any other assertion.\n\n``` javascript\nexpect(myFoo).to.have.lengthOf(3);\nexpect(myFoo).to.have.lengthOf.above(3);\n```\n\n### .overwriteMethod(ctx, name, fn)\n\n- @param { Object } ctx object whose method is to be overwritten\n- @param { String } name of method to overwrite\n- @param { Function } method function that returns a function to be used for name\n\nOverwrites an already existing method and provides access to previous function. Must return function to be used for name.\n\n``` javascript\nutils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n  return function (str) {\n    var obj = utils.flag(this, 'object');\n    if (obj instanceof Foo) {\n      new chai.Assertion(obj.value).to.equal(str);\n    } else {\n      _super.apply(this, arguments);\n    }\n  }\n});\n```\n\nCan also be accessed directly from `chai.Assertion`.\n\n``` javascript\nchai.Assertion.overwriteMethod('foo', fn);\n```\n\nThen can be used as any other assertion.\n\n``` javascript\nexpect(myFoo).to.equal('bar');\n```\n\n### .overwriteProperty(ctx, name, fn)\n\n- @param { Object } ctx object whose property is to be overwritten\n- @param { String } name of property to overwrite\n- @param { Function } getter function that returns a getter function to be used for name\n\nOverwrites an already existing property getter and provides access to previous value. Must return function to use as getter.\n\n``` javascript\nutils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n  return function () {\n    var obj = utils.flag(this, 'object');\n    if (obj instanceof Foo) {\n      new chai.Assertion(obj.name).to.equal('bar');\n    } else {\n      _super.call(this);\n    }\n  }\n});\n```\n\nCan also be accessed directly from `chai.Assertion`.\n\n``` javascript\nchai.Assertion.overwriteProperty('foo', fn);\n```\n\nThen can be used as any other assertion.\n\n``` javascript\nexpect(myFoo).to.be.ok;\n```\n\n### .proxify(object)\n\n- @param { Object } obj\n- @param { String } nonChainableMethodName\n\nReturn a proxy of given object that throws an error when a non-existent property is read. By default, the root cause is assumed to be a misspelled property, and thus an attempt is made to offer a reasonable suggestion from the list of existing properties. However, if a nonChainableMethodName is provided, then the root cause is instead a failure to invoke a non-chainable method prior to reading the non-existent property.\n\nIf proxies are unsupported or disabled via the user’s Chai config, then return object without modification.\n\n### .test(object, expression)\n\n- @param { Object } object (constructed Assertion)\n- @param { Arguments } chai.Assertion.prototype.assert arguments\n\nTest and object for expression.\n\n### .transferFlags(assertion, object, includeAll = true)\n\n- @param { Assertion } assertion the assertion to transfer the flags from\n- @param { Object } object the object to transfer the flags to; usually a new assertion\n- @param { Boolean } includeAll\n\nTransfer all the flags for `assertion` to `object`. If `includeAll` is set to `false`, then the base Chai assertion flags (namely `object`, `ssfi`, `lockSsfi`, and `message`) will not be transferred.\n\n``` javascript\nvar newAssertion = new Assertion();\nutils.transferFlags(assertion, newAssertion);\n\nvar anotherAssertion = new Assertion(myObj);\nutils.transferFlags(assertion, anotherAssertion, false);\n```\n\n### .compatibleInstance(thrown, errorLike)\n\n- @param { Error } thrown error\n- @param { Error \\| ErrorConstructor } errorLike object to compare against\n\nChecks if two instances are compatible (strict equal). Returns false if errorLike is not an instance of Error, because instances can only be compatible if they’re both error instances.\n\n### .compatibleConstructor(thrown, errorLike)\n\n- @param { Error } thrown error\n- @param { Error \\| ErrorConstructor } errorLike object to compare against\n\nChecks if two constructors are compatible. This function can receive either an error constructor or an error instance as the `errorLike` argument. Constructors are compatible if they’re the same or if one is an instance of another.\n\n### .compatibleMessage(thrown, errMatcher)\n\n- @param { Error } thrown error\n- @param { String \\| RegExp } errMatcher to look for into the message\n\nChecks if an error’s message is compatible with a matcher (String or RegExp). If the message contains the String or passes the RegExp test, it is considered compatible.\n\n### .getFunctionName(constructorFn)\n\n- @param { Function } constructorFn\n\nReturns the name of a function. This also includes a polyfill function if `constructorFn.name` is not defined.\n\n### .getConstructorName(errorLike)\n\n- @param { Error \\| ErrorConstructor } errorLike\n\nGets the constructor name for an Error instance or constructor itself.\n\n### .getMessage(errorLike)\n\n- @param { Error \\| String } errorLike\n\nGets the error message from an error. If `err` is a String itself, we return it. If the error has no message, we return an empty string.\n\n### .getFuncName(constructorFn)\n\n- @param { Function } funct\n\nReturns the name of a function. When a non-function instance is passed, returns `null`. This also includes a polyfill function if `aFunc.name` is not defined.\n\n### .hasProperty(object, name)\n\n- @param { Object } object\n- @param { String \\| Symbol } name\n\nThis allows checking whether an object has own or inherited from prototype chain named property.\n\nBasically does the same thing as the `in` operator but works properly with null/undefined values and other primitives.\n\n``` javascript\nvar obj = {\n    arr: ['a', 'b', 'c']\n  , str: 'Hello'\n}\n```\n\nThe following would be the results.\n\n``` javascript\nhasProperty(obj, 'str');  // true\nhasProperty(obj, 'constructor');  // true\nhasProperty(obj, 'bar');  // false\n\nhasProperty(obj.str, 'length'); // true\nhasProperty(obj.str, 1);  // true\nhasProperty(obj.str, 5);  // false\n\nhasProperty(obj.arr, 'length');  // true\nhasProperty(obj.arr, 2);  // true\nhasProperty(obj.arr, 3);  // false\n```\n\n### .getPathInfo(object, path)\n\n- @param { Object } object\n- @param { String } path\n\nThis allows the retrieval of property info in an object given a string path.\n\nThe path info consists of an object with the following properties:\n\n- parent - The parent object of the property referenced by `path`\n- name - The name of the final property, a number if it was an array indexer\n- value - The value of the property, if it exists, otherwise `undefined`\n- exists - Whether the property exists or not\n\n### .getPathValue(object, path)\n\n- @param { Object } object\n- @param { String } path\n\nThis allows the retrieval of values in an object given a string path.\n\n``` javascript\nvar obj = {\n    prop1: {\n        arr: ['a', 'b', 'c']\n      , str: 'Hello'\n    }\n  , prop2: {\n        arr: [ { nested: 'Universe' } ]\n      , str: 'Hello again!'\n    }\n}\n```\n\nThe following would be the results.\n\n``` javascript\ngetPathValue(obj, 'prop1.str'); // Hello\ngetPathValue(obj, 'prop1.att[2]'); // b\ngetPathValue(obj, 'prop2.arr[0].nested'); // Universe\n```\n\n© 2017 Chai.js Assertion Library  \nLicensed under the MIT License.  \n[https://www.chaijs.com/api/plugins/](https://www.chaijs.com/api/plugins/)"
- name: property
  id: api/bdd/index#method_property
  summary: Asserts that the target has a property with the given key name
  belongs_to: BDD
  description: |-
    ### .property(name\[, val\[, msg\]\])

    - @param { String } name
    - @param { Mixed } val (optional)
    - @param { String } msg \_optional\_

    Asserts that the target has a property with the given key `name`.

    ``` javascript
    expect({a: 1}).to.have.property('a');
    ```

    When `val` is provided, `.``property` also asserts that the property’s value is equal to the given `val`.

    ``` javascript
    expect({a: 1}).to.have.property('a', 1);
    ```

    By default, strict (`===`) equality is used. Add `.``deep` earlier in the chain to use deep equality instead. See the `deep``-``eql` project page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.

    ``` javascript
    // Target object deeply (but not strictly) has property `x: {a: 1}`
    expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
    expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
    ```

    The target’s enumerable and non-enumerable properties are always included in the search. By default, both own and inherited properties are included. Add `.``own` earlier in the chain to exclude inherited properties from the search.

    ``` javascript
    Object.prototype.b = 2;

    expect({a: 1}).to.have.own.property('a');
    expect({a: 1}).to.have.own.property('a', 1);
    expect({a: 1}).to.have.property('b');
    expect({a: 1}).to.not.have.own.property('b');
    ```

    `.``deep` and `.``own` can be combined.

    ``` javascript
    expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
    ```

    Add `.``nested` earlier in the chain to enable dot- and bracket-notation when referencing nested properties.

    ``` javascript
    expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
    expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
    ```

    If `.` or `[]` are part of an actual property name, they can be escaped by adding two backslashes before them.

    ``` javascript
    expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
    ```

    `.``deep` and `.``nested` can be combined.

    ``` javascript
    expect({a: {b: [{c: 3}]}})
      .to.have.deep.nested.property('a.b[0]', {c: 3});
    ```

    `.``own` and `.``nested` cannot be combined.

    Add `.``not` earlier in the chain to negate `.``property`.

    ``` javascript
    expect({a: 1}).to.not.have.property('b');
    ```

    However, it’s dangerous to negate `.``property` when providing `val`. The problem is that it creates uncertain expectations by asserting that the target either doesn’t have a property with the given key `name`, or that it does have a property with the given key `name` but its value isn’t equal to the given `val`. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.

    When the target isn’t expected to have a property with the given key `name`, it’s often best to assert exactly that.

    ``` javascript
    expect({b: 2}).to.not.have.property('a'); // Recommended
    expect({b: 2}).to.not.have.property('a', 1); // Not recommended
    ```

    When the target is expected to have a property with the given key `name`, it’s often best to assert that the property has its expected value, rather than asserting that it doesn’t have one of many unexpected values.

    ``` javascript
    expect({a: 3}).to.have.property('a', 3); // Recommended
    expect({a: 3}).to.not.have.property('a', 1); // Not recommended
    ```

    `.``property` changes the target of any assertions that follow in the chain to be the value of the property from the original target object.

    ``` javascript
    expect({a: 1}).to.have.property('a').that.is.a('number');
    ```

    `.``property` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`. When not providing `val`, only use the second form.

    ``` javascript
    // Recommended
    expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
    expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
    expect({a: 1}, 'nooo why fail??').to.have.property('b');

    // Not recommended
    expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
    ```

    The above assertion isn’t the same thing as not providing `val`. Instead, it’s asserting that the target object has a `b` property that’s equal to `undefined`.

    The assertions `.``ownProperty` and `.``haveOwnProperty` can be used interchangeably with `.``own``.``property`.
- name: property
  id: api/assert/index#method_property
  summary: Asserts that object has a direct or inherited property named by property
  belongs_to: Assert
  description: |-
    ### .property(object, property, \[message\])

    - @param { Object } object
    - @param { String } property
    - @param { String } message

    Asserts that `object` has a direct or inherited property named by `property`.

    ``` javascript
    assert.property({ tea: { green: 'matcha' }}, 'tea');
    assert.property({ tea: { green: 'matcha' }}, 'toString');
    ```
- name: propertyVal
  id: api/assert/index#method_propertyval
  summary: Asserts that object has a direct or inherited property named by property with a value given by value
  belongs_to: Assert
  description: |-
    ### .propertyVal(object, property, value, \[message\])

    - @param { Object } object
    - @param { String } property
    - @param { Mixed } value
    - @param { String } message

    Asserts that `object` has a direct or inherited property named by `property` with a value given by `value`. Uses a strict equality check (===).

    ``` javascript
    assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
    ```
- name: proxify
  id: api/plugins/index#method_proxify
  summary: Return a proxy of given object that throws an error when a non-existent property is read
  belongs_to: Plugin Utilities
  description: |-
    ### .proxify(object)

    - @param { Object } obj
    - @param { String } nonChainableMethodName

    Return a proxy of given object that throws an error when a non-existent property is read. By default, the root cause is assumed to be a misspelled property, and thus an attempt is made to offer a reasonable suggestion from the list of existing properties. However, if a nonChainableMethodName is provided, then the root cause is instead a failure to invoke a non-chainable method prior to reading the non-existent property.

    If proxies are unsupported or disabled via the user’s Chai config, then return object without modification.
- name: respondTo
  id: api/bdd/index#method_respondto
  summary: When the target is a non-function object, .``respondTo asserts that the target has a method with the given name method
  belongs_to: BDD
  description: |-
    ### .respondTo(method\[, msg\])

    - @param { String } method
    - @param { String } msg \_optional\_

    When the target is a non-function object, `.``respondTo` asserts that the target has a method with the given name `method`. The method can be own or inherited, and it can be enumerable or non-enumerable.

    ``` javascript
    function Cat () {}
    Cat.prototype.meow = function () {};

    expect(new Cat()).to.respondTo('meow');
    ```

    When the target is a function, `.``respondTo` asserts that the target’s `prototype` property has a method with the given name `method`. Again, the method can be own or inherited, and it can be enumerable or non-enumerable.

    ``` javascript
    function Cat () {}
    Cat.prototype.meow = function () {};

    expect(Cat).to.respondTo('meow');
    ```

    Add `.``itself` earlier in the chain to force `.``respondTo` to treat the target as a non-function object, even if it’s a function. Thus, it asserts that the target has a method with the given name `method`, rather than asserting that the target’s `prototype` property has a method with the given name `method`.

    ``` javascript
    function Cat () {}
    Cat.prototype.meow = function () {};
    Cat.hiss = function () {};

    expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
    ```

    When not adding `.``itself`, it’s important to check the target’s type before using `.``respondTo`. See the `.``a` doc for info on checking a target’s type.

    ``` javascript
    function Cat () {}
    Cat.prototype.meow = function () {};

    expect(new Cat()).to.be.an('object').that.respondsTo('meow');
    ```

    Add `.``not` earlier in the chain to negate `.``respondTo`.

    ``` javascript
    function Dog () {}
    Dog.prototype.bark = function () {};

    expect(new Dog()).to.not.respondTo('meow');
    ```

    `.``respondTo` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect({}).to.respondTo('meow', 'nooo why fail??');
    expect({}, 'nooo why fail??').to.respondTo('meow');
    ```

    The alias `.``respondsTo` can be used interchangeably with `.``respondTo`.
- name: sameDeepMembers
  id: api/assert/index#method_samedeepmembers
  summary: Asserts that set1 and set2 have the same members in any order
  belongs_to: Assert
  description: |-
    ### .sameDeepMembers(set1, set2, \[message\])

    - @param { Array } set1
    - @param { Array } set2
    - @param { String } message

    Asserts that `set1` and `set2` have the same members in any order. Uses a deep equality check.

    ``` javascript
    assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');
    ```
- name: sameDeepOrderedMembers
  id: api/assert/index#method_samedeeporderedmembers
  summary: Asserts that set1 and set2 have the same members in the same order
  belongs_to: Assert
  description: |-
    ### .sameDeepOrderedMembers(set1, set2, \[message\])

    - @param { Array } set1
    - @param { Array } set2
    - @param { String } message

    Asserts that `set1` and `set2` have the same members in the same order. Uses a deep equality check.

    ``` javascript
    assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');
    ```
- name: sameMembers
  id: api/assert/index#method_samemembers
  summary: Asserts that set1 and set2 have the same members in any order
  belongs_to: Assert
  description: |-
    ### .sameMembers(set1, set2, \[message\])

    - @param { Array } set1
    - @param { Array } set2
    - @param { String } message

    Asserts that `set1` and `set2` have the same members in any order. Uses a strict equality check (===).

    ``` javascript
    assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
    ```
- name: sameOrderedMembers
  id: api/assert/index#method_sameorderedmembers
  summary: Asserts that set1 and set2 have the same members in the same order
  belongs_to: Assert
  description: |-
    ### .sameOrderedMembers(set1, set2, \[message\])

    - @param { Array } set1
    - @param { Array } set2
    - @param { String } message

    Asserts that `set1` and `set2` have the same members in the same order. Uses a strict equality check (===).

    ``` javascript
    assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');
    ```
- name: satisfy
  id: api/bdd/index#method_satisfy
  summary: Invokes the given matcher function with the target being passed as the first argument, and asserts that the value returned is truthy
  belongs_to: BDD
  description: |-
    ### .satisfy(matcher\[, msg\])

    - @param { Function } matcher
    - @param { String } msg \_optional\_

    Invokes the given `matcher` function with the target being passed as the first argument, and asserts that the value returned is truthy.

    ``` javascript
    expect(1).to.satisfy(function(num) {
      return num > 0;
    });
    ```

    Add `.``not` earlier in the chain to negate `.``satisfy`.

    ``` javascript
    expect(1).to.not.satisfy(function(num) {
      return num > 2;
    });
    ```

    `.``satisfy` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect(1).to.satisfy(function(num) {
      return num > 2;
    }, 'nooo why fail??');

    expect(1, 'nooo why fail??').to.satisfy(function(num) {
      return num > 2;
    });
    ```

    The alias `.``satisfies` can be used interchangeably with `.``satisfy`.
- name: sealed
  id: api/bdd/index#method_sealed
  summary: Asserts that the target is sealed, which means that new properties can’t be added to it, and its existing properties can’t be reconfigured or deleted
  belongs_to: BDD
  description: |-
    ### .sealed

    Asserts that the target is sealed, which means that new properties can’t be added to it, and its existing properties can’t be reconfigured or deleted. However, it’s possible that its existing properties can still be reassigned to different values. Primitives are always sealed.

    ``` javascript
    var sealedObject = Object.seal({});
    var frozenObject = Object.freeze({});

    expect(sealedObject).to.be.sealed;
    expect(frozenObject).to.be.sealed;
    expect(1).to.be.sealed;
    ```

    Add `.``not` earlier in the chain to negate `.``sealed`.

    ``` javascript
    expect({a: 1}).to.not.be.sealed;
    ```

    A custom error message can be given as the second argument to `expect`.

    ``` javascript
    expect({a: 1}, 'nooo why fail??').to.be.sealed;
    ```
- name: strictEqual
  id: api/assert/index#method_strictequal
  summary: Asserts strict equality (===) of actual and expected
  belongs_to: Assert
  description: |-
    ### .strictEqual(actual, expected, \[message\])

    - @param { Mixed } actual
    - @param { Mixed } expected
    - @param { String } message

    Asserts strict equality (`===`) of `actual` and `expected`.

    ``` javascript
    assert.strictEqual(true, true, 'these booleans are strictly equal');
    ```
- name: string
  id: api/bdd/index#method_string
  summary: Asserts that the target string contains the given substring str
  belongs_to: BDD
  description: |-
    ### .string(str\[, msg\])

    - @param { String } str
    - @param { String } msg \_optional\_

    Asserts that the target string contains the given substring `str`.

    ``` javascript
    expect('foobar').to.have.string('bar');
    ```

    Add `.``not` earlier in the chain to negate `.``string`.

    ``` javascript
    expect('foobar').to.not.have.string('taco');
    ```

    `.``string` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect('foobar').to.have.string('taco', 'nooo why fail??');
    expect('foobar', 'nooo why fail??').to.have.string('taco');
    ```
- name: test
  id: api/plugins/index#method_test
  summary: Test and object for expression
  belongs_to: Plugin Utilities
  description: |-
    ### .test(object, expression)

    - @param { Object } object (constructed Assertion)
    - @param { Arguments } chai.Assertion.prototype.assert arguments

    Test and object for expression.
- name: throw
  id: api/bdd/index#method_throw
  summary: When no arguments are provided, .``throw invokes the target function and asserts that an error is thrown
  belongs_to: BDD
  description: |-
    ### .throw(\[errorLike\], \[errMsgMatcher\], \[msg\])

    - @param { Error \| ErrorConstructor } errorLike
    - @param { String \| RegExp } errMsgMatcher error message
    - @param { String } msg \_optional\_
    - @see [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types)

    When no arguments are provided, `.``throw` invokes the target function and asserts that an error is thrown.

    ``` javascript
    var badFn = function () { throw new TypeError('Illegal salmon!'); };

    expect(badFn).to.throw();
    ```

    When one argument is provided, and it’s an error constructor, `.``throw` invokes the target function and asserts that an error is thrown that’s an instance of that error constructor.

    ``` javascript
    var badFn = function () { throw new TypeError('Illegal salmon!'); };

    expect(badFn).to.throw(TypeError);
    ```

    When one argument is provided, and it’s an error instance, `.``throw` invokes the target function and asserts that an error is thrown that’s strictly (`===`) equal to that error instance.

    ``` javascript
    var err = new TypeError('Illegal salmon!');
    var badFn = function () { throw err; };

    expect(badFn).to.throw(err);
    ```

    When one argument is provided, and it’s a string, `.``throw` invokes the target function and asserts that an error is thrown with a message that contains that string.

    ``` javascript
    var badFn = function () { throw new TypeError('Illegal salmon!'); };

    expect(badFn).to.throw('salmon');
    ```

    When one argument is provided, and it’s a regular expression, `.``throw` invokes the target function and asserts that an error is thrown with a message that matches that regular expression.

    ``` javascript
    var badFn = function () { throw new TypeError('Illegal salmon!'); };

    expect(badFn).to.throw(/salmon/);
    ```

    When two arguments are provided, and the first is an error instance or constructor, and the second is a string or regular expression, `.``throw` invokes the function and asserts that an error is thrown that fulfills both conditions as described above.

    ``` javascript
    var err = new TypeError('Illegal salmon!');
    var badFn = function () { throw err; };

    expect(badFn).to.throw(TypeError, 'salmon');
    expect(badFn).to.throw(TypeError, /salmon/);
    expect(badFn).to.throw(err, 'salmon');
    expect(badFn).to.throw(err, /salmon/);
    ```

    Add `.``not` earlier in the chain to negate `.``throw`.

    ``` javascript
    var goodFn = function () {};

    expect(goodFn).to.not.throw();
    ```

    However, it’s dangerous to negate `.``throw` when providing any arguments. The problem is that it creates uncertain expectations by asserting that the target either doesn’t throw an error, or that it throws an error but of a different type than the given type, or that it throws an error of the given type but with a message that doesn’t include the given string. It’s often best to identify the exact output that’s expected, and then write an assertion that only accepts that exact output.

    When the target isn’t expected to throw an error, it’s often best to assert exactly that.

    ``` javascript
    var goodFn = function () {};

    expect(goodFn).to.not.throw(); // Recommended
    expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
    ```

    When the target is expected to throw an error, it’s often best to assert that the error is of its expected type, and has a message that includes an expected string, rather than asserting that it doesn’t have one of many unexpected types, and doesn’t have a message that includes some string.

    ``` javascript
    var badFn = function () { throw new TypeError('Illegal salmon!'); };

    expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
    expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
    ```

    `.``throw` changes the target of any assertions that follow in the chain to be the error object that’s thrown.

    ``` javascript
    var err = new TypeError('Illegal salmon!');
    err.code = 42;
    var badFn = function () { throw err; };

    expect(badFn).to.throw(TypeError).with.property('code', 42);
    ```

    `.``throw` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`. When not providing two arguments, always use the second form.

    ``` javascript
    var goodFn = function () {};

    expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
    expect(goodFn, 'nooo why fail??').to.throw();
    ```

    Due to limitations in ES5, `.``throw` may not always work as expected when using a transpiler such as Babel or TypeScript. In particular, it may produce unexpected results when subclassing the built-in `Error` object and then passing the subclassed constructor to `.``throw`. See your transpiler’s docs for details:

    - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
    - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))

    Beware of some common mistakes when using the `throw` assertion. One common mistake is to accidentally invoke the function yourself instead of letting the `throw` assertion invoke the function for you. For example, when testing if a function named `fn` throws, provide `fn` instead of `fn``()` as the target for the assertion.

    ``` javascript
    expect(fn).to.throw();     // Good! Tests `fn` as desired
    expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`
    ```

    If you need to assert that your function `fn` throws when passed certain arguments, then wrap a call to `fn` inside of another function.

    ``` javascript
    expect(function () { fn(42); }).to.throw();  // Function expression
    expect(() => fn(42)).to.throw();             // ES6 arrow function
    ```

    Another common mistake is to provide an object method (or any stand-alone function that relies on `this`) as the target of the assertion. Doing so is problematic because the `this` context will be lost when the function is invoked by `.``throw`; there’s no way for it to know what `this` is supposed to be. There are two ways around this problem. One solution is to wrap the method or function call inside of another function. Another solution is to use `bind`.

    ``` javascript
    expect(function () { cat.meow(); }).to.throw();  // Function expression
    expect(() => cat.meow()).to.throw();             // ES6 arrow function
    expect(cat.meow.bind(cat)).to.throw();           // Bind
    ```

    Finally, it’s worth mentioning that it’s a best practice in JavaScript to only throw `Error` and derivatives of `Error` such as `ReferenceError`, `TypeError`, and user-defined objects that extend `Error`. No other type of value will generate a stack trace when initialized. With that said, the `throw` assertion does technically support any type of value being thrown, not just `Error` and its derivatives.

    The aliases `.``throws` and `.``Throw` can be used interchangeably with `.``throw`.
- name: throws
  id: api/assert/index#method_throws
  summary: If errorLike is an Error constructor, asserts that fn will throw an error that is an instance of errorLike
  belongs_to: Assert
  description: |-
    ### .throws(fn, \[errorLike/string/regexp\], \[string/regexp\], \[message\])

    - @param { Function } fn
    - @param { ErrorConstructor \| Error } errorLike
    - @param { RegExp \| String } errMsgMatcher
    - @param { String } message
    - @see [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types)

    If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an instance of `errorLike`. If `errorLike` is an `Error` instance, asserts that the error thrown is the same instance as `errorLike`. If `errMsgMatcher` is provided, it also asserts that the error thrown will have a message matching `errMsgMatcher`.

    ``` javascript
    assert.throws(fn, 'Error thrown must have this msg');
    assert.throws(fn, /Error thrown must have a msg that matches this/);
    assert.throws(fn, ReferenceError);
    assert.throws(fn, errorInstance);
    assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');
    assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');
    assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
    assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);
    ```
- name: transferFlags
  id: api/plugins/index#method_transferflags
  summary: Transfer all the flags for assertion to object
  belongs_to: Plugin Utilities
  description: |-
    ### .transferFlags(assertion, object, includeAll = true)

    - @param { Assertion } assertion the assertion to transfer the flags from
    - @param { Object } object the object to transfer the flags to; usually a new assertion
    - @param { Boolean } includeAll

    Transfer all the flags for `assertion` to `object`. If `includeAll` is set to `false`, then the base Chai assertion flags (namely `object`, `ssfi`, `lockSsfi`, and `message`) will not be transferred.

    ``` javascript
    var newAssertion = new Assertion();
    utils.transferFlags(assertion, newAssertion);

    var anotherAssertion = new Assertion(myObj);
    utils.transferFlags(assertion, anotherAssertion, false);
    ```
- name: 'true'
  id: api/bdd/index#method_true
  summary: Asserts that the target is strictly (===) equal to true
  belongs_to: BDD
  description: |-
    ### .true

    Asserts that the target is strictly (`===`) equal to `true`.

    ``` javascript
    expect(true).to.be.true;
    ```

    Add `.``not` earlier in the chain to negate `.``true`. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to `true`.

    ``` javascript
    expect(false).to.be.false; // Recommended
    expect(false).to.not.be.true; // Not recommended

    expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.true; // Not recommended
    ```

    A custom error message can be given as the second argument to `expect`.

    ``` javascript
    expect(false, 'nooo why fail??').to.be.true;
    ```
- name: typeOf
  id: api/assert/index#method_typeof
  summary: Asserts that value’s type is name, as determined by Object``.``prototype``.``toString
  belongs_to: Assert
  description: |-
    ### .typeOf(value, name, \[message\])

    - @param { Mixed } value
    - @param { String } name
    - @param { String } message

    Asserts that `value`’s type is `name`, as determined by `Object``.``prototype``.``toString`.

    ``` javascript
    assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
    assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
    assert.typeOf('tea', 'string', 'we have a string');
    assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
    assert.typeOf(null, 'null', 'we have a null');
    assert.typeOf(undefined, 'undefined', 'we have an undefined');
    ```
- name: undefined
  id: api/bdd/index#method_undefined
  summary: Asserts that the target is strictly (===) equal to undefined
  belongs_to: BDD
  description: |-
    ### .undefined

    Asserts that the target is strictly (`===`) equal to `undefined`.

    ``` javascript
    expect(undefined).to.be.undefined;
    ```

    Add `.``not` earlier in the chain to negate `.``undefined`. However, it’s often best to assert that the target is equal to its expected value, rather than not equal to `undefined`.

    ``` javascript
    expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.undefined; // Not recommended
    ```

    A custom error message can be given as the second argument to `expect`.

    ``` javascript
    expect(42, 'nooo why fail??').to.be.undefined;
    ```
- name: within
  id: api/bdd/index#method_within
  summary: Asserts that the target is a number or a date greater than or equal to the given number or date start, and less than or equal to the given number or date finish respectively
  belongs_to: BDD
  description: |-
    ### .within(start, finish\[, msg\])

    - @param { Number } start lower bound inclusive
    - @param { Number } finish upper bound inclusive
    - @param { String } msg \_optional\_

    Asserts that the target is a number or a date greater than or equal to the given number or date `start`, and less than or equal to the given number or date `finish` respectively. However, it’s often best to assert that the target is equal to its expected value.

    ``` javascript
    expect(2).to.equal(2); // Recommended
    expect(2).to.be.within(1, 3); // Not recommended
    expect(2).to.be.within(2, 3); // Not recommended
    expect(2).to.be.within(1, 2); // Not recommended
    ```

    Add `.``lengthOf` earlier in the chain to assert that the target’s `length` or `size` is greater than or equal to the given number `start`, and less than or equal to the given number `finish`.

    ``` javascript
    expect('foo').to.have.lengthOf(3); // Recommended
    expect('foo').to.have.lengthOf.within(2, 4); // Not recommended

    expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
    expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
    ```

    Add `.``not` earlier in the chain to negate `.``within`.

    ``` javascript
    expect(1).to.equal(1); // Recommended
    expect(1).to.not.be.within(2, 4); // Not recommended
    ```

    `.``within` accepts an optional `msg` argument which is a custom error message to show when the assertion fails. The message can also be given as the second argument to `expect`.

    ``` javascript
    expect(4).to.be.within(1, 3, 'nooo why fail??');
    expect(4, 'nooo why fail??').to.be.within(1, 3);
    ```
