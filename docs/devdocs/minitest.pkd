---
name: Ruby / Minitest
slug: minitest
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © Ryan Davis, seattle.rb
  Licensed under the MIT License.
  https://docs.seattlerb.org/minitest/table_of_contents.html
homepage: null

---
- name: Kernel
  id: kernel
  summary: Describe a series of expectations for a given target desc
  description: "# module Kernel\n\n[`Kernel`](kernel) extensions for minitest\n\n### Private Instance Methods\n\ndescribe(desc, \\*additional_desc, &block) Show source\n\n``` ruby\n# File lib/minitest/spec.rb, line 82\ndef describe desc, *additional_desc, &block # :doc:\n  stack = Minitest::Spec.describe_stack\n  name  = [stack.last, desc, *additional_desc].compact.join(\"::\")\n  sclas = stack.last || if Class === self && kind_of?(Minitest::Spec::DSL) then\n                          self\n                        else\n                          Minitest::Spec.spec_type desc, *additional_desc\n                        end\n\n  cls = sclas.create name, desc\n\n  stack.push cls\n  cls.class_eval(&block)\n  stack.pop\n  cls\nend\n```\n\nDescribe a series of expectations for a given target `desc`.\n\nDefines a test class subclassing from either [`Minitest::Spec`](minitest/spec) or from the surrounding describe’s class. The surrounding class may subclass [`Minitest::Spec`](minitest/spec) manually in order to easily share code:\n\n``` ruby\nclass MySpec < Minitest::Spec\n  # ... shared code ...\nend\n\nclass TestStuff < MySpec\n  it \"does stuff\" do\n    # shared code available here\n  end\n  describe \"inner stuff\" do\n    it \"still does stuff\" do\n      # ...and here\n    end\n  end\nend\n```\n\nFor more information on getting started with writing specs, see:\n\n[www.rubyinside.com/a-minitestspec-tutorial-elegant-spec-style-testing-that-comes-with-ruby-5354.html](http://www.rubyinside.com/a-minitestspec-tutorial-elegant-spec-style-testing-that-comes-with-ruby-5354.html)\n\nFor some suggestions on how to improve your specs, try:\n\n[betterspecs.org](https://betterspecs.org)\n\nbut do note that several items there are debatable or specific to rspec.\n\nFor more information about expectations, see [`Minitest::Expectations`](minitest/expectations).\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Kernel.html](https://docs.seattlerb.org/minitest/Kernel.html)"
- name: Kernel#describe
  id: kernel#method-i-describe
  summary: Describe a series of expectations for a given target desc
  belongs_to: Kernel
  description: "describe (desc, \\*additional_desc, &block) Show source\n\n``` ruby\n# File lib/minitest/spec.rb, line 82\ndef describe desc, *additional_desc, &block # :doc:\n  stack = Minitest::Spec.describe_stack\n  name  = [stack.last, desc, *additional_desc].compact.join(\"::\")\n  sclas = stack.last || if Class === self && kind_of?(Minitest::Spec::DSL) then\n                          self\n                        else\n                          Minitest::Spec.spec_type desc, *additional_desc\n                        end\n\n  cls = sclas.create name, desc\n\n  stack.push cls\n  cls.class_eval(&block)\n  stack.pop\n  cls\nend\n```\n\nDescribe a series of expectations for a given target `desc`.\n\nDefines a test class subclassing from either [`Minitest::Spec`](minitest/spec) or from the surrounding describe’s class. The surrounding class may subclass [`Minitest::Spec`](minitest/spec) manually in order to easily share code:\n\n``` ruby\nclass MySpec < Minitest::Spec\n  # ... shared code ...\nend\n\nclass TestStuff < MySpec\n  it \"does stuff\" do\n    # shared code available here\n  end\n  describe \"inner stuff\" do\n    it \"still does stuff\" do\n      # ...and here\n    end\n  end\nend\n```\n\nFor more information on getting started with writing specs, see:\n\n[www.rubyinside.com/a-minitestspec-tutorial-elegant-spec-style-testing-that-comes-with-ruby-5354.html](http://www.rubyinside.com/a-minitestspec-tutorial-elegant-spec-style-testing-that-comes-with-ruby-5354.html)\n\nFor some suggestions on how to improve your specs, try:\n\n[betterspecs.org](https://betterspecs.org)\n\nbut do note that several items there are debatable or specific to rspec.\n\nFor more information about expectations, see [`Minitest::Expectations`](minitest/expectations).\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Kernel.html](https://docs.seattlerb.org/minitest/Kernel.html)"
- name: Minitest
  id: minitest
  summary: minitest provides a complete suite of testing facilities supporting TDD, BDD, mocking, and benchmarking
  description: "# module Minitest\n\n# minitest/{test,spec,mock,benchmark}\n\nhome  \n[github.com/minitest/minitest](https://github.com/minitest/minitest)\n\nbugs  \n[github.com/minitest/minitest/issues](https://github.com/minitest/minitest/issues)\n\nrdoc  \n[docs.seattlerb.org/minitest](https://docs.seattlerb.org/minitest)\n\nvim  \n[github.com/sunaku/vim-ruby-minitest](https://github.com/sunaku/vim-ruby-minitest)\n\nemacs  \n[github.com/arthurnn/minitest-emacs](https://github.com/arthurnn/minitest-emacs)\n\n## DESCRIPTION:\n\nminitest provides a complete suite of testing facilities supporting TDD, BDD, mocking, and benchmarking.\n\n    \"I had a class with Jim Weirich on testing last week and we were\n     allowed to choose our testing frameworks. Kirk Haines and I were\n     paired up and we cracked open the code for a few test\n     frameworks...\n\n     I MUST say that minitest is *very* readable / understandable\n     compared to the 'other two' options we looked at. Nicely done and\n     thank you for helping us keep our mental sanity.\"\n\n    -- Wayne E. Seguin\n\nminitest/test is a small and incredibly fast unit testing framework. It provides a rich set of assertions to make your tests clean and readable.\n\nminitest/spec is a functionally complete spec engine. It hooks onto minitest/test and seamlessly bridges test assertions over to spec expectations.\n\nminitest/benchmark is an awesome way to assert the performance of your algorithms in a repeatable manner. Now you can assert that your newb co-worker doesn’t replace your linear algorithm with an exponential one!\n\nminitest/mock by Steven Baker, is a beautifully tiny mock (and stub) object framework.\n\nminitest/pride shows pride in testing and adds coloring to your test output. I guess it is an example of how to write IO pipes too. :P\n\nminitest/test is meant to have a clean implementation for language implementors that need a minimal set of methods to bootstrap a working test suite. For example, there is no magic involved for test-case discovery.\n\n    \"Again, I can't praise enough the idea of a testing/specing\n     framework that I can actually read in full in one sitting!\"\n\n    -- Piotr Szotkowski\n\nComparing to rspec:\n\n    rspec is a testing DSL. minitest is ruby.\n\n    -- Adam Hawkins, \"Bow Before MiniTest\"\n\nminitest doesn’t reinvent anything that ruby already provides, like: classes, modules, inheritance, methods. This means you only have to learn ruby to use minitest and all of your regular OO practices like extract-method refactorings still apply.\n\n## FEATURES/PROBLEMS:\n\n- minitest/autorun - the easy and explicit way to run all your tests.\n\n- minitest/test - a very fast, simple, and clean test system.\n\n- minitest/spec - a very fast, simple, and clean spec system.\n\n- minitest/mock - a simple and clean mock/stub system.\n\n- minitest/benchmark - an awesome way to assert your algorithm’s performance.\n\n- minitest/pride - show your pride in testing!\n\n- minitest/test_task - a full-featured and clean rake task generator.\n\n- Incredibly small and fast runner, but no bells and whistles.\n\n- Written by squishy human beings. Software can never be perfect. We will all eventually die.\n\n## RATIONALE:\n\nSee design_rationale.rb to see how specs and tests work in minitest.\n\n## SYNOPSIS:\n\nGiven that you’d like to test the following class:\n\n``` ruby\nclass Meme\n  def i_can_has_cheezburger?\n    \"OHAI!\"\n  end\n\n  def will_it_blend?\n    \"YES!\"\n  end\nend\n```\n\n### Unit tests\n\nDefine your tests as methods beginning with `test_`.\n\n``` ruby\nrequire \"minitest/autorun\"\n\nclass TestMeme < Minitest::Test\n  def setup\n    @meme = Meme.new\n  end\n\n  def test_that_kitty_can_eat\n    assert_equal \"OHAI!\", @meme.i_can_has_cheezburger?\n  end\n\n  def test_that_it_will_not_blend\n    refute_match /^no/i, @meme.will_it_blend?\n  end\n\n  def test_that_will_be_skipped\n    skip \"test this later\"\n  end\nend\n```\n\n### Specs\n\n``` ruby\nrequire \"minitest/autorun\"\n\ndescribe Meme do\n  before do\n    @meme = Meme.new\n  end\n\n  describe \"when asked about cheeseburgers\" do\n    it \"must respond positively\" do\n      _(@meme.i_can_has_cheezburger?).must_equal \"OHAI!\"\n    end\n  end\n\n  describe \"when asked about blending possibilities\" do\n    it \"won't say no\" do\n      _(@meme.will_it_blend?).wont_match /^no/i\n    end\n  end\nend\n```\n\nFor matchers support check out:\n\n- [github.com/wojtekmach/minitest-matchers](https://github.com/wojtekmach/minitest-matchers)\n\n- [github.com/rmm5t/minitest-matchers_vaccine](https://github.com/rmm5t/minitest-matchers_vaccine)\n\n### Benchmarks\n\nAdd benchmarks to your tests.\n\n``` ruby\n# optionally run benchmarks, good for CI-only work!\nrequire \"minitest/benchmark\" if ENV[\"BENCH\"]\n\nclass TestMeme < Minitest::Benchmark\n  # Override self.bench_range or default range is [1, 10, 100, 1_000, 10_000]\n  def bench_my_algorithm\n    assert_performance_linear 0.9999 do |n| # n is a range value\n      @obj.my_algorithm(n)\n    end\n  end\nend\n```\n\nOr add them to your specs. If you make benchmarks optional, you’ll need to wrap your benchmarks in a conditional since the methods won’t be defined. In minitest 5, the describe name needs to match `/Bench(mark)?$/`.\n\n``` ruby\ndescribe \"Meme Benchmark\" do\n  if ENV[\"BENCH\"] then\n    bench_performance_linear \"my_algorithm\", 0.9999 do |n|\n      100.times do\n        @obj.my_algorithm(n)\n      end\n    end\n  end\nend\n```\n\noutputs something like:\n\n    # Running benchmarks:\n\n    TestBlah    100     1000    10000\n    bench_my_algorithm   0.006167        0.079279        0.786993\n    bench_other_algorithm        0.061679        0.792797        7.869932\n\nOutput is tab-delimited to make it easy to paste into a spreadsheet.\n\n### Mocks\n\nMocks and stubs defined using terminology by Fowler & Meszaros at [www.martinfowler.com/bliki/TestDouble.html](https://www.martinfowler.com/bliki/TestDouble.html):\n\n“Mocks are pre-programmed with expectations which form a specification of the calls they are expected to receive. They can throw an exception if they receive a call they don’t expect and are checked during verification to ensure they got all the calls they were expecting.”\n\n``` ruby\nclass MemeAsker\n  def initialize(meme)\n    @meme = meme\n  end\n\n  def ask(question)\n    method = question.tr(\" \", \"_\") + \"?\"\n    @meme.__send__(method)\n  end\nend\n\nrequire \"minitest/autorun\"\n\ndescribe MemeAsker, :ask do\n  describe \"when passed an unpunctuated question\" do\n    it \"should invoke the appropriate predicate method on the meme\" do\n      @meme = Minitest::Mock.new\n      @meme_asker = MemeAsker.new @meme\n      @meme.expect :will_it_blend?, :return_value\n\n      @meme_asker.ask \"will it blend\"\n\n      @meme.verify\n    end\n  end\nend\n```\n\n#### Multi-threading and Mocks\n\n[`Minitest`](minitest) mocks do not support multi-threading. If it works, fine, if it doesn’t you can use regular ruby patterns and facilities like local variables. Here’s an example of asserting that code inside a thread is run:\n\n``` ruby\ndef test_called_inside_thread\n  called = false\n  pr = Proc.new { called = true }\n  thread = Thread.new(&pr)\n  thread.join\n  assert called, \"proc not called\"\nend\n```\n\n### Stubs\n\nMocks and stubs are defined using terminology by Fowler & Meszaros at [www.martinfowler.com/bliki/TestDouble.html](https://www.martinfowler.com/bliki/TestDouble.html):\n\n“Stubs provide canned answers to calls made during the test”.\n\nMinitest’s stub method overrides a single method for the duration of the block.\n\n``` ruby\ndef test_stale_eh\n  obj_under_test = Something.new\n\n  refute obj_under_test.stale?\n\n  Time.stub :now, Time.at(0) do   # stub goes away once the block is done\n    assert obj_under_test.stale?\n  end\nend\n```\n\nA note on stubbing: In order to stub a method, the method must actually exist prior to stubbing. Use a singleton method to create a new non-existing method:\n\n    def obj_under_test.fake_method\n      ...\n    end\n\n### Running Your Tests\n\nIdeally, you’ll use a rake task to run your tests (see below), either piecemeal or all at once. BUT! You don’t have to:\n\n    % ruby -Ilib:test test/minitest/test_minitest_test.rb\n    Run options: --seed 37685\n\n    # Running:\n\n    ...................................................................... (etc)\n\n    Finished in 0.107130s, 1446.8403 runs/s, 2959.0217 assertions/s.\n\n    155 runs, 317 assertions, 0 failures, 0 errors, 0 skips\n\nThere are runtime options available, both from minitest itself, and also provided via plugins. To see them, simply run with `--help`:\n\n    % ruby -Ilib:test test/minitest/test_minitest_test.rb --help\n    minitest options:\n        -h, --help                       Display this help.\n        -s, --seed SEED                  Sets random seed. Also via env. Eg: SEED=n rake\n        -v, --verbose                    Verbose. Show progress processing files.\n        -n, --name PATTERN               Filter run on /regexp/ or string.\n        -e, --exclude PATTERN            Exclude /regexp/ or string from run.\n\n    Known extensions: pride, autotest\n        -p, --pride                      Pride. Show your testing pride!\n        -a, --autotest                   Connect to autotest server.\n\n### Rake Tasks\n\nYou can set up a rake task to run all your tests by adding this to your Rakefile:\n\n``` ruby\nrequire \"minitest/test_task\"\n\nMinitest::TestTask.create # named test, sensible defaults\n\n# or more explicitly:\n\nMinitest::TestTask.create(:test) do |t|\n  t.libs << \"test\"\n  t.libs << \"lib\"\n  t.warning = false\n  t.test_globs = [\"test/**/*_test.rb\"]\nend\n\ntask :default => :test\n```\n\nEach of these will generate 4 tasks:\n\n    rake test          :: Run the test suite.\n    rake test:cmd      :: Print out the test command.\n    rake test:isolated :: Show which test files fail when run separately.\n    rake test:slow     :: Show bottom 25 tests sorted by time.\n\n### Rake Task Variables\n\nThere are a bunch of variables you can supply to rake to modify the run.\n\n    MT_LIB_EXTRAS :: Extra libs to dynamically override/inject for custom runs.\n    N             :: -n: Tests to run (string or /regexp/).\n    X             :: -x: Tests to exclude (string or /regexp/).\n    A             :: Any extra arguments. Honors shell quoting.\n    MT_CPU        :: How many threads to use for parallel test runs\n    SEED          :: -s --seed Sets random seed.\n    TESTOPTS      :: Deprecated, same as A\n    FILTER        :: Deprecated, same as A\n\n## Writing Extensions\n\nTo define a plugin, add a file named minitest/XXX_plugin.rb to your project/gem. That file must be discoverable via ruby’s LOAD_PATH (via rubygems or otherwise). [`Minitest`](minitest) will find and require that file using Gem.find_files. It will then try to call `plugin_XXX_init` during startup. The option processor will also try to call `plugin_XXX_options` passing the OptionParser instance and the current options hash. This lets you register your own command-line options. Here’s a totally bogus example:\n\n``` ruby\n# minitest/bogus_plugin.rb:\n\nmodule Minitest\n  def self.plugin_bogus_options(opts, options)\n    opts.on \"--myci\", \"Report results to my CI\" do\n      options[:myci] = true\n      options[:myci_addr] = get_myci_addr\n      options[:myci_port] = get_myci_port\n    end\n  end\n\n  def self.plugin_bogus_init(options)\n    self.reporter << MyCI.new(options) if options[:myci]\n  end\nend\n```\n\n### Adding custom reporters\n\n[`Minitest`](minitest) uses composite reporter to output test results using multiple reporter instances. You can add new reporters to the composite during the init_plugins phase. As we saw in `plugin_bogus_init` above, you simply add your reporter instance to the composite via `<<`.\n\n`AbstractReporter` defines the API for reporters. You may subclass it and override any method you want to achieve your desired behavior.\n\nstart  \nCalled when the run has started.\n\nrecord  \nCalled for each result, passed or otherwise.\n\nreport  \nCalled at the end of the run.\n\npassed?  \nCalled to see if you detected any problems.\n\nUsing our example above, here is how we might implement MyCI:\n\n``` ruby\n# minitest/bogus_plugin.rb\n\nmodule Minitest\n  class MyCI < AbstractReporter\n    attr_accessor :results, :addr, :port\n\n    def initialize options\n      self.results = []\n      self.addr = options[:myci_addr]\n      self.port = options[:myci_port]\n    end\n\n    def record result\n      self.results << result\n    end\n\n    def report\n      CI.connect(addr, port).send_results self.results\n    end\n  end\n\n  # code from above...\nend\n```\n\n## FAQ\n\n### What versions are compatible with what? Or what versions are supported?\n\n[`Minitest`](minitest) is a dependency of rails, which until fairly recently had an overzealous backwards compatibility policy. As such, I’m stuck supporting versions of ruby that are long past EOL. Hopefully I’ll be able to support only current versions of ruby sometime in the near future.\n\n(As of 2023-03-05)\n\nCurrent versions of rails: ([endoflife.date/rails](https://endoflife.date/rails))\n\n    | rails | min ruby | rec ruby | minitest | status   |  EOL Date  |\n    |-------+----------+----------+----------+----------+------------|\n    |   7.0 | >= 2.7   |      3.1 | >= 5.1   | Current  | 2025-06-01?|\n    |   6.1 | >= 2.5   |      3.0 | >= 5.1   | Maint    | 2024-06-01?|\n    |   6.0 | >= 2.5   |      2.6 | >= 5.1   | Security | 2023-06-01 |\n    |   5.2 | >= 2.2.2 |      2.5 | ~> 5.1   | EOL      | 2022-06-01 |\n\nIf you want to look at the requirements for a specific version, run:\n\n    gem spec -r --ruby rails -v 7.0.0\n\nCurrent versions of ruby: ([endoflife.date/ruby](https://endoflife.date/ruby))\n\n    | ruby | Status  |   EOL Date |\n    |------+---------+------------|\n    |  3.2 | Current | 2026-03-31 |\n    |  3.1 | Maint   | 2025-03-31 |\n    |  3.0 | Maint   | 2024-03-31 |\n    |  2.7 | Security| 2023-03-31 |\n    |  2.6 | EOL     | 2022-03-31 |\n    |  2.5 | EOL     | 2021-03-31 |\n\n### How to test SimpleDelegates?\n\nThe following implementation and test:\n\n``` ruby\nclass Worker < SimpleDelegator\n  def work\n  end\nend\n\ndescribe Worker do\n  before do\n    @worker = Worker.new(Object.new)\n  end\n\n  it \"must respond to work\" do\n    _(@worker).must_respond_to :work\n  end\nend\n```\n\noutputs a failure:\n\n      1) Failure:\n    Worker#test_0001_must respond to work [bug11.rb:16]:\n    Expected #<Object:0x007f9e7184f0a0> (Object) to respond to #work.\n\nWorker is a SimpleDelegate which in 1.9+ is a subclass of BasicObject. [`Expectations`](minitest/expectations) are put on [`Object`](object) (one level down) so the Worker (SimpleDelegate) hits `method_missing` and delegates down to the `Object.new` instance. That object doesn’t respond to work so the test fails.\n\nYou can bypass `SimpleDelegate#method_missing` by extending the worker with `Minitest::Expectations`. You can either do that in your setup at the instance level, like:\n\n``` ruby\nbefore do\n  @worker = Worker.new(Object.new)\n  @worker.extend Minitest::Expectations\nend\n```\n\nor you can extend the Worker class (within the test file!), like:\n\n``` ruby\nclass Worker\n  include ::Minitest::Expectations\nend\n```\n\n### How to share code across test classes?\n\nUse a module. That’s exactly what they’re for:\n\n``` ruby\nmodule UsefulStuff\n  def useful_method\n    # ...\n  end\nend\n\ndescribe Blah do\n  include UsefulStuff\n\n  def test_whatever\n    # useful_method available here\n  end\nend\n```\n\nRemember, `describe` simply creates test classes. It’s just ruby at the end of the day and all your normal Good Ruby Rules (tm) apply. If you want to extend your test using setup/teardown via a module, just make sure you ALWAYS call super. before/after automatically call super for you, so make sure you don’t do it twice.\n\n### How to run code before a group of tests?\n\nUse a constant with begin…end like this:\n\n``` ruby\ndescribe Blah do\n  SETUP = begin\n     # ... this runs once when describe Blah starts\n  end\n  # ...\nend\n```\n\nThis can be useful for expensive initializations or sharing state. Remember, this is just ruby code, so you need to make sure this technique and sharing state doesn’t interfere with your tests.\n\n### Why am I seeing `uninitialized constant MiniTest::Test (NameError)`?\n\nAre you running the test with Bundler (e.g. via `bundle exec` )? If so, in order to require minitest, you must first add the `gem 'minitest'` to your Gemfile and run `bundle`. Once it’s installed, you should be able to require minitest and run your tests.\n\n## Prominent Projects using Minitest:\n\n- arel\n\n- journey\n\n- mime-types\n\n- nokogiri\n\n- rails (active_support et al)\n\n- rake\n\n- rdoc\n\n- …and of course, everything from seattle.rb…\n\n## Developing Minitest:\n\n[`Minitest`](minitest) requires [Hoe](https://rubygems.org/gems/hoe).\n\n### Minitest’s own tests require UTF-8 external encoding.\n\nThis is a common problem in Windows, where the default external Encoding is often CP850, but can affect any platform. [`Minitest`](minitest) can run test suites using any Encoding, but to run Minitest’s own tests you must have a default external Encoding of UTF-8.\n\nIf your encoding is wrong, you’ll see errors like:\n\n    --- expected\n    +++ actual\n    @@ -1,2 +1,3 @@\n     # encoding: UTF-8\n     -\"Expected /\\\\w+/ to not match \\\"blah blah blah\\\".\"\n     +\"Expected /\\\\w+/ to not match # encoding: UTF-8\n     +\\\"blah blah blah\\\".\"\n\nTo check your current encoding, run:\n\n    ruby -e 'puts Encoding.default_external'\n\nIf your output is something other than UTF-8, you can set the RUBYOPTS env variable to a value of ‘-Eutf-8’. Something like:\n\n    RUBYOPT='-Eutf-8' ruby -e 'puts Encoding.default_external'\n\nCheck your OS/shell documentation for the precise syntax (the above will not work on a basic Windows CMD prompt, look for the SET command). Once you’ve got it successfully outputing UTF-8, use the same setting when running rake in [`Minitest`](minitest).\n\n### Minitest’s own tests require GNU (or similar) diff.\n\nThis is also a problem primarily affecting Windows developers. PowerShell has a command called diff, but it is not suitable for use with [`Minitest`](minitest).\n\nIf you see failures like either of these, you are probably missing diff tool:\n\n      4) Failure:\n    TestMinitestUnitTestCase#test_assert_equal_different_long [D:/ruby/seattlerb/minitest/test/minitest/test_minitest_test.rb:936]:\n    Expected: \"--- expected\\n+++ actual\\n@@ -1 +1 @@\\n-\\\"hahahahahahahahahahahahahahahahahahahaha\\\"\\n+\\\"blahblahblahblahblahblahblahblahblahblah\\\"\\n\"\n      Actual: \"Expected: \\\"hahahahahahahahahahahahahahahahahahahaha\\\"\\n  Actual: \\\"blahblahblahblahblahblahblahblahblahblah\\\"\"\n\n      5) Failure:\n    TestMinitestUnitTestCase#test_assert_equal_different_collection_hash_hex_invisible [D:/ruby/seattlerb/minitest/test/minitest/test_minitest_test.rb:845]:\n    Expected: \"No visible difference in the Hash#inspect output.\\nYou should look at the implementation of #== on Hash or its members.\\n\n    {1=>#<Object:0xXXXXXX>}\"\n      Actual: \"Expected: {1=>#<Object:0x00000003ba0470>}\\n  Actual: {1=>#<Object:0x00000003ba0448>}\"\n\nIf you use Cygwin or MSYS2 or similar there are packages that include a GNU diff for Windows. If you don’t, you can download GNU diffutils from [gnuwin32.sourceforge.net/packages/diffutils.htm](http://gnuwin32.sourceforge.net/packages/diffutils.htm) (make sure to add it to your PATH).\n\nYou can make sure it’s installed and path is configured properly with:\n\n``` ruby\ndiff.exe -v\n```\n\nThere are multiple lines of output, the first should be something like:\n\n    diff (GNU diffutils) 2.8.1\n\nIf you are using PowerShell make sure you run diff.exe, not just diff, which will invoke the PowerShell built in function.\n\n## Known Extensions:\n\ncapybara_minitest_spec  \nBridge between Capybara RSpec matchers and [`Minitest::Spec`](minitest/spec) expectations (e.g. `page.must_have_content(\"Title\")`).\n\ncolor_pound_spec_reporter  \n[`Test`](minitest/test) names print Ruby [`Object`](object) types in color with your [`Minitest`](minitest) [`Spec`](minitest/spec) style tests.\n\nminispec-metadata  \nMetadata for describe/it blocks & CLI tag filter. E.g. `it \"requires JS driver\", js: true do` & `ruby test.rb --tag js` runs tests tagged :js.\n\nminispec-rails  \nMinimal support to use [`Spec`](minitest/spec) style in Rails 5+.\n\nmini-apivore  \nfor swagger based automated API testing.\n\nminitest-around  \nAround block for minitest. An alternative to setup/teardown dance.\n\nminitest-assert_errors  \nAdds [`Minitest`](minitest) assertions to test for errors raised or not raised by [`Minitest`](minitest) itself.\n\nminitest-autotest  \nautotest is a continuous testing facility meant to be used during development.\n\nminitest-bacon  \nminitest-bacon extends minitest with bacon-like functionality.\n\nminitest-bang  \nAdds support for RSpec-style let! to immediately invoke let statements before each test.\n\nminitest-bisect  \nHelps you isolate and debug random test failures.\n\nminitest-blink1_reporter  \nDisplay test results with a Blink1.\n\nminitest-capistrano  \n[`Assertions`](minitest/assertions) and expectations for testing Capistrano recipes.\n\nminitest-capybara  \nCapybara matchers support for minitest unit and spec.\n\nminitest-cc  \nIt provides minimal information about code coverage.\n\nminitest-chef-handler  \nRun [`Minitest`](minitest) suites as Chef report handlers\n\nminitest-ci  \nCI reporter plugin for [`Minitest`](minitest).\n\nminitest-context  \nDefines contexts for code reuse in [`Minitest`](minitest) specs that share common expectations.\n\nminitest-debugger  \nWraps assert so failed assertions drop into the ruby debugger.\n\nminitest-display  \nPatches [`Minitest`](minitest) to allow for an easily configurable output.\n\nminitest-documentation  \nMinimal documentation format inspired by rspec’s.\n\nminitest-doc_reporter  \nDetailed output inspired by rspec’s documentation format.\n\nminitest-emoji  \nPrint out emoji for your test passes, fails, and skips.\n\nminitest-english  \nSemantically symmetric aliases for assertions and expectations.\n\nminitest-excludes  \nClean API for excluding certain tests you don’t want to run under certain conditions.\n\nminitest-fail-fast  \nReimplements RSpec’s “fail fast” feature\n\nminitest-filecontent  \nSupport unit tests with expectation results in files. Differing results will be stored again in files.\n\nminitest-filesystem  \nAdds assertion and expectation to help testing filesystem contents.\n\nminitest-firemock  \nMakes your [`Minitest`](minitest) mocks more resilient.\n\nminitest-focus  \nFocus on one test at a time.\n\nminitest-gcstats  \nA minitest plugin that adds a report of the top tests by number of objects allocated.\n\nminitest-global_expectations  \nSupport minitest expectation methods for all objects\n\nminitest-great_expectations  \nGenerally useful additions to minitest’s assertions and expectations.\n\nminitest-growl  \n[`Test`](minitest/test) notifier for minitest via growl.\n\nminitest-happy  \nGLOBALLY ACTIVATE MINITEST PRIDE! RAWR!\n\nminitest-have_tag  \nAdds [`Minitest`](minitest) assertions to test for the existence of HTML tags, including contents, within a provided string.\n\nminitest-heat  \nReporting that builds a heat map of failure locations\n\nminitest-hooks  \nAround and before_all/after_all/around_all hooks\n\nminitest-hyper  \nPretty, single-page HTML reports for your [`Minitest`](minitest) runs\n\nminitest-implicit-subject  \nImplicit declaration of the test subject.\n\nminitest-instrument  \nInstrument ActiveSupport::Notifications when test method is executed.\n\nminitest-instrument-db  \nStore information about speed of test execution provided by minitest-instrument in database.\n\nminitest-junit  \nJUnit-style XML reporter for minitest.\n\nminitest-keyword  \nUse [`Minitest`](minitest) assertions with keyword arguments.\n\nminitest-libnotify  \n[`Test`](minitest/test) notifier for minitest via libnotify.\n\nminitest-line  \nRun test at line number.\n\nminitest-logger  \nDefine assert_log and enable minitest to test log messages. Supports Logger and Log4r::Logger.\n\nminitest-macruby  \nProvides extensions to minitest for macruby UI testing.\n\nminitest-matchers  \nAdds support for RSpec-style matchers to minitest.\n\nminitest-matchers_vaccine  \nAdds assertions that adhere to the matcher spec, but without any expectation infections.\n\nminitest-metadata  \nAnnotate tests with metadata (key-value).\n\nminitest-mock_expectations  \nProvides method call assertions for minitest.\n\nminitest-mongoid  \nMongoid assertion matchers for [`Minitest`](minitest).\n\nminitest-must_not  \nProvides must_not as an alias for wont in [`Minitest`](minitest).\n\nminitest-optional_retry  \nAutomatically retry failed test to help with flakiness.\n\nminitest-osx  \nReporter for the Mac OS X notification center.\n\nminitest-parallel_fork  \nFork-based parallelization\n\nminitest-parallel-db  \nRun tests in parallel with a single database.\n\nminitest-power_assert  \nPowerAssert for [`Minitest`](minitest).\n\nminitest-predicates  \nAdds support for .predicate? methods.\n\nminitest-profile  \nList the 10 slowest tests in your suite.\n\nminitest-rails  \n[`Minitest`](minitest) integration for Rails 3.x.\n\nminitest-rails-capybara  \nCapybara integration for Minitest::Rails.\n\nminitest-reporters  \nCreate customizable [`Minitest`](minitest) output formats.\n\nminitest-rg  \nColored red/green output for [`Minitest`](minitest).\n\nminitest-rspec_mocks  \nUse RSpec Mocks with [`Minitest`](minitest).\n\nminitest-server  \nminitest-server provides a client/server setup with your minitest process, allowing your test run to send its results directly to a handler.\n\nminitest-sequel  \n[`Minitest`](minitest) assertions to speed-up development and testing of Ruby Sequel database setups.\n\nminitest-shared_description  \nSupport for shared specs and shared spec subclasses\n\nminitest-should_syntax  \nRSpec-style `x.should == y` assertions for [`Minitest`](minitest).\n\nminitest-shouldify  \nAdding all manner of shoulds to [`Minitest`](minitest) (bad idea)\n\nminitest-snail  \nPrint a list of tests that take too long\n\nminitest-spec-context  \nProvides rspec-ish context method to [`Minitest::Spec`](minitest/spec).\n\nminitest-spec-expect  \nExpect syntax for [`Minitest::Spec`](minitest/spec) (e.g. expect(sequences).to_include :celery_man).\n\nminitest-spec-magic  \n[`Minitest::Spec`](minitest/spec) extensions for Rails and beyond.\n\nminitest-spec-rails  \nDrop in [`Minitest::Spec`](minitest/spec) superclass for ActiveSupport::TestCase.\n\nminitest-sprint  \nRuns (Get it? It’s fast!) your tests and makes it easier to rerun individual failures.\n\nminitest-stately  \nFind leaking state between tests\n\nminitest-stub_any_instance  \nStub any instance of a method on the given class for the duration of a block.\n\nminitest-stub-const  \nStub constants for the duration of a block.\n\nminitest-tags  \nAdd tags for minitest.\n\nminitest-unordered  \nAdds a new assertion to minitest for checking the contents of a collection, ignoring element order.\n\nminitest-vcr  \nAutomatic cassette management with [`Minitest::Spec`](minitest/spec) and VCR.\n\nminitest_log  \nAdds structured logging, data explication, and verdicts.\n\nminitest_owrapper  \nGet tests results as a TestResult object.\n\nminitest_should  \nShoulda style syntax for minitest test::unit.\n\nminitest_tu_shim  \nBridges between test/unit and minitest.\n\nmongoid-minitest  \n[`Minitest`](minitest) matchers for Mongoid.\n\nmutant-minitest  \n[`Minitest`](minitest) integration for mutant.\n\npry-rescue  \nA pry plugin w/ minitest support. See pry-rescue/minitest.rb.\n\nrematch  \nDeclutter your test files from large hardcoded data and update them automatically when your code changes.\n\nrspec2minitest  \nEasily translate any RSpec matchers to [`Minitest`](minitest) assertions and expectations.\n\nstubberry  \nMultiple stubbing ‘berries’, sweet and useful stub helpers and assertions. ( stub_must, assert_method_called, stubbing ORM objects by id )\n\n## Unknown Extensions:\n\nAuthors… Please send me a pull request with a description of your minitest extension.\n\n- assay-minitest\n\n- detroit-minitest\n\n- em-minitest-spec\n\n- flexmock-minitest\n\n- guard-minitest\n\n- guard-minitest-decisiv\n\n- minitest-activemodel\n\n- minitest-ar-assertions\n\n- minitest-capybara-unit\n\n- minitest-colorer\n\n- minitest-deluxe\n\n- minitest-extra-assertions\n\n- minitest-rails-shoulda\n\n- minitest-spec\n\n- minitest-spec-should\n\n- minitest-sugar\n\n- spork-minitest\n\n## [`Minitest`](minitest) related goods\n\n- minitest/pride fabric: [www.spoonflower.com/fabric/3928730-again-by-katie_allen](https://www.spoonflower.com/fabric/3928730-again-by-katie_allen)\n\n## REQUIREMENTS:\n\n- Ruby 2.3+. No magic is involved. I hope.\n\n## INSTALL:\n\n``` ruby\nsudo gem install minitest\n```\n\nOn 1.9, you already have it. To get newer candy you can still install the gem, and then requiring “minitest/autorun” should automatically pull it in. If not, you’ll need to do it yourself:\n\n``` ruby\ngem \"minitest\"     # ensures you\"re using the gem, and not the built-in MT\nrequire \"minitest/autorun\"\n\n# ... usual testing stuffs ...\n```\n\nDO NOTE: There is a serious problem with the way that ruby 1.9/2.0 packages their own gems. They install a gem specification file, but don’t install the gem contents in the gem path. This messes up Gem.find_files and many other things (gem which, gem contents, etc).\n\nJust install minitest as a gem for real and you’ll be happier.\n\n## LICENSE:\n\n(The MIT License)\n\nCopyright © Ryan Davis, seattle.rb\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ‘Software’), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED ‘AS IS’, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n### Public Class Methods\n\n\\_\\_run(reporter, options) Show source\n\n``` ruby\n# File lib/minitest.rb, line 176\ndef self.__run reporter, options\n  suites = Runnable.runnables.shuffle\n  parallel, serial = suites.partition { |s| s.test_order == :parallel }\n\n  # If we run the parallel tests before the serial tests, the parallel tests\n  # could run in parallel with the serial tests. This would be bad because\n  # the serial tests won't lock around Reporter#record. Run the serial tests\n  # first, so that after they complete, the parallel tests will lock when\n  # recording results.\n  serial.map { |suite| suite.run reporter, options } +\n    parallel.map { |suite| suite.run reporter, options }\nend\n```\n\nInternal run method. Responsible for telling all Runnable sub-classes to run.\n\nafter_run(&block) Show source\n\n``` ruby\n# File lib/minitest.rb, line 97\ndef self.after_run &block\n  @@after_run << block\nend\n```\n\nA simple hook allowing you to run a block of code after everything is done running. Eg:\n\n``` ruby\nMinitest.after_run { p $debugging_info }\n```\n\nautorun() Show source\n\n``` ruby\n# File lib/minitest.rb, line 69\ndef self.autorun\n  if Object.const_defined?(:Warning) && Warning.respond_to?(:[]=)\n    Warning[:deprecated] = true\n  end\n\n  at_exit {\n    next if $! and not ($!.kind_of? SystemExit and $!.success?)\n\n    exit_code = nil\n\n    pid = Process.pid\n    at_exit {\n      next if !Minitest.allow_fork && Process.pid != pid\n      @@after_run.reverse_each(&:call)\n      exit exit_code || false\n    }\n\n    exit_code = Minitest.run ARGV\n  } unless @@installed_at_exit\n  @@installed_at_exit = true\nend\n```\n\nRegisters [`Minitest`](minitest) to run at process exit\n\nrun(args = \\[\\]) Show source\n\n``` ruby\n# File lib/minitest.rb, line 143\ndef self.run args = []\n  self.load_plugins unless args.delete(\"--no-plugins\") || ENV[\"MT_NO_PLUGINS\"]\n\n  options = process_args args\n\n  Minitest.seed = options[:seed]\n  srand Minitest.seed\n\n  reporter = CompositeReporter.new\n  reporter << SummaryReporter.new(options[:io], options)\n  reporter << ProgressReporter.new(options[:io], options)\n\n  self.reporter = reporter # this makes it available to plugins\n  self.init_plugins options\n  self.reporter = nil # runnables shouldn't depend on the reporter, ever\n\n  self.parallel_executor.start if parallel_executor.respond_to?(:start)\n  reporter.start\n  begin\n    __run reporter, options\n  rescue Interrupt\n    warn \"Interrupted. Exiting...\"\n  end\n  self.parallel_executor.shutdown\n  reporter.report\n\n  reporter.passed?\nend\n```\n\nThis is the top-level run method. Everything starts from here. It tells each Runnable sub-class to run, and each of those are responsible for doing whatever they do.\n\nThe overall structure of a run looks like this:\n\n``` ruby\nMinitest.autorun\n  Minitest.run(args)\n    Minitest.__run(reporter, options)\n      Runnable.runnables.each\n        runnable.run(reporter, options)\n          self.runnable_methods.each\n            self.run_one_method(self, runnable_method, reporter)\n              Minitest.run_one_method(klass, runnable_method)\n                klass.new(runnable_method).run\n```\n\n### Public Instance Methods\n\nbacktrace_filter() Show source\n\n``` c\n# File lib/minitest.rb, line 43\ncattr_accessor :backtrace_filter\n```\n\nFilter object for backtraces.\n\nextensions() Show source\n\n``` c\n# File lib/minitest.rb, line 55\ncattr_accessor :extensions\n```\n\nNames of known extension plugins.\n\ninfo_signal() Show source\n\n``` c\n# File lib/minitest.rb, line 60\ncattr_accessor :info_signal\n```\n\nThe signal to use for dumping information to STDERR. Defaults to “INFO”.\n\nparallel_executor() Show source\n\n``` c\n# File lib/minitest.rb, line 33\ncattr_accessor :parallel_executor\n```\n\n[`Parallel`](minitest/parallel) test executor\n\nreporter() Show source\n\n``` c\n# File lib/minitest.rb, line 50\ncattr_accessor :reporter\n```\n\nReporter object to be used for all runs.\n\nNOTE: This accessor is only available during setup, not during runs.\n\nseed() Show source\n\n``` c\n# File lib/minitest.rb, line 28\ncattr_accessor :seed\n```\n\nThe random seed used for this run. This is used to srand at the start of the run and between each `Runnable.run`.\n\nSet via [`Minitest.run`](minitest#method-c-run) after processing args.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest.html](https://docs.seattlerb.org/minitest/Minitest.html)"
- name: Minitest#backtrace_filter
  id: minitest#method-i-backtrace_filter
  summary: Filter object for backtraces
  belongs_to: Minitest
  description: |-
    backtrace_filter () Show source

    ``` c
    # File lib/minitest.rb, line 43
    cattr_accessor :backtrace_filter
    ```

    Filter object for backtraces.
- name: Minitest#extensions
  id: minitest#method-i-extensions
  summary: Names of known extension plugins
  belongs_to: Minitest
  description: |-
    extensions () Show source

    ``` c
    # File lib/minitest.rb, line 55
    cattr_accessor :extensions
    ```

    Names of known extension plugins.
- name: Minitest#info_signal
  id: minitest#method-i-info_signal
  summary: The signal to use for dumping information to STDERR
  belongs_to: Minitest
  description: |-
    info_signal () Show source

    ``` c
    # File lib/minitest.rb, line 60
    cattr_accessor :info_signal
    ```

    The signal to use for dumping information to STDERR. Defaults to “INFO”.
- name: Minitest#parallel_executor
  id: minitest#method-i-parallel_executor
  summary: null
  belongs_to: Minitest
  description: |-
    parallel_executor () Show source

    ``` c
    # File lib/minitest.rb, line 33
    cattr_accessor :parallel_executor
    ```

    [`Parallel`](minitest/parallel) test executor
- name: Minitest#reporter
  id: minitest#method-i-reporter
  summary: Reporter object to be used for all runs
  belongs_to: Minitest
  description: |-
    reporter () Show source

    ``` c
    # File lib/minitest.rb, line 50
    cattr_accessor :reporter
    ```

    Reporter object to be used for all runs.

    NOTE: This accessor is only available during setup, not during runs.
- name: Minitest#seed
  id: minitest#method-i-seed
  summary: The random seed used for this run
  belongs_to: Minitest
  description: "seed () Show source\n\n``` c\n# File lib/minitest.rb, line 28\ncattr_accessor :seed\n```\n\nThe random seed used for this run. This is used to srand at the start of the run and between each `Runnable.run`.\n\nSet via [`Minitest.run`](minitest#method-c-run) after processing args.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest.html](https://docs.seattlerb.org/minitest/Minitest.html)"
- name: Minitest::AbstractReporter
  id: minitest/abstractreporter
  summary: Defines the API for Reporters
  description: "# class Minitest::AbstractReporter\n\nParent:\n\n[Object](../object)\n\nIncluded modules:\n\nDefines the API for Reporters. Subclass this and override whatever you want. Go nuts.\n\n### Public Instance Methods\n\npassed?() Show source\n\n``` ruby\n# File lib/minitest.rb, line 655\ndef passed?\n  true\nend\n```\n\nDid this run pass?\n\nprerecord(klass, name) Show source\n\n``` ruby\n# File lib/minitest.rb, line 634\ndef prerecord klass, name\nend\n```\n\nAbout to start running a test. This allows a reporter to show that it is starting or that we are in the middle of a test run.\n\nrecord(result) Show source\n\n``` ruby\n# File lib/minitest.rb, line 643\ndef record result\nend\n```\n\nOutput and record the result of the test. Call [result#result_code](runnable#method-i-result_code) to get the result character string. Stores the result of the run if the run did not pass.\n\nreport() Show source\n\n``` ruby\n# File lib/minitest.rb, line 649\ndef report\nend\n```\n\nOutputs the summary of the run.\n\nstart() Show source\n\n``` ruby\n# File lib/minitest.rb, line 627\ndef start\nend\n```\n\nStarts reporting on the run.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/AbstractReporter.html](https://docs.seattlerb.org/minitest/Minitest/AbstractReporter.html)"
- name: Minitest::AbstractReporter#passed?
  id: minitest/abstractreporter#method-i-passed-3F
  summary: null
  belongs_to: Minitest::AbstractReporter
  description: |-
    passed? () Show source

    ``` ruby
    # File lib/minitest.rb, line 655
    def passed?
      true
    end
    ```

    Did this run pass?
- name: Minitest::AbstractReporter#prerecord
  id: minitest/abstractreporter#method-i-prerecord
  summary: About to start running a test
  belongs_to: Minitest::AbstractReporter
  description: |-
    prerecord (klass, name) Show source

    ``` ruby
    # File lib/minitest.rb, line 634
    def prerecord klass, name
    end
    ```

    About to start running a test. This allows a reporter to show that it is starting or that we are in the middle of a test run.
- name: Minitest::AbstractReporter#record
  id: minitest/abstractreporter#method-i-record
  summary: Output and record the result of the test
  belongs_to: Minitest::AbstractReporter
  description: |-
    record (result) Show source

    ``` ruby
    # File lib/minitest.rb, line 643
    def record result
    end
    ```

    Output and record the result of the test. Call [result#result_code](runnable#method-i-result_code) to get the result character string. Stores the result of the run if the run did not pass.
- name: Minitest::AbstractReporter#report
  id: minitest/abstractreporter#method-i-report
  summary: Outputs the summary of the run
  belongs_to: Minitest::AbstractReporter
  description: |-
    report () Show source

    ``` ruby
    # File lib/minitest.rb, line 649
    def report
    end
    ```

    Outputs the summary of the run.
- name: Minitest::AbstractReporter#start
  id: minitest/abstractreporter#method-i-start
  summary: Starts reporting on the run
  belongs_to: Minitest::AbstractReporter
  description: "start () Show source\n\n``` ruby\n# File lib/minitest.rb, line 627\ndef start\nend\n```\n\nStarts reporting on the run.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/AbstractReporter.html](https://docs.seattlerb.org/minitest/Minitest/AbstractReporter.html)"
- name: Minitest::after_run
  id: minitest#method-c-after_run
  summary: A simple hook allowing you to run a block of code after everything is done running
  belongs_to: Minitest
  description: |-
    after_run (&block) Show source

    ``` ruby
    # File lib/minitest.rb, line 97
    def self.after_run &block
      @@after_run << block
    end
    ```

    A simple hook allowing you to run a block of code after everything is done running. Eg:

    ``` ruby
    Minitest.after_run { p $debugging_info }
    ```
- name: Minitest::Assertion
  id: minitest/assertion
  summary: Represents run failures
  description: "# class Minitest::Assertion\n\nParent:  \nException\n\nRepresents run failures.\n\n### Public Instance Methods\n\nlocation() Show source\n\n``` ruby\n# File lib/minitest.rb, line 946\ndef location\n  last_before_assertion = \"\"\n  self.backtrace.reverse_each do |s|\n    break if s =~ /in .(assert|refute|flunk|pass|fail|raise|must|wont)/\n    last_before_assertion = s\n  end\n  last_before_assertion.sub(/:in .*$/, \"\")\nend\n```\n\nWhere was this run before an assertion was raised?\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Assertion.html](https://docs.seattlerb.org/minitest/Minitest/Assertion.html)"
- name: Minitest::Assertion#location
  id: minitest/assertion#method-i-location
  summary: © Ryan Davis, seattle.rb Licensed under the MIT License
  belongs_to: Minitest::Assertion
  description: "location () Show source\n\n``` ruby\n# File lib/minitest.rb, line 946\ndef location\n  last_before_assertion = \"\"\n  self.backtrace.reverse_each do |s|\n    break if s =~ /in .(assert|refute|flunk|pass|fail|raise|must|wont)/\n    last_before_assertion = s\n  end\n  last_before_assertion.sub(/:in .*$/, \"\")\nend\n```\n\nWhere was this run before an assertion was raised?\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Assertion.html](https://docs.seattlerb.org/minitest/Minitest/Assertion.html)"
- name: Minitest::Assertions
  id: minitest/assertions
  summary: Minitest Assertions
  description: "# module Minitest::Assertions\n\n[`Minitest`](../minitest) [`Assertions`](assertions). All assertion methods accept a `msg` which is printed if the assertion fails.\n\nProtocol: Nearly everything here boils up to `assert`, which expects to be able to increment an instance accessor named `assertions`. This is not provided by [`Assertions`](assertions) and must be provided by the thing including [`Assertions`](assertions). See Minitest::Runnable for an example.\n\n### Public Class Methods\n\ndiff() Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 29\ndef self.diff\n  return @diff if defined? @diff\n\n  @diff = if (RbConfig::CONFIG[\"host_os\"] =~ /mswin|mingw/ &&\n              system(\"diff.exe\", __FILE__, __FILE__)) then\n            \"diff.exe -u\"\n          elsif system(\"gdiff\", __FILE__, __FILE__)\n            \"gdiff -u\" # solaris and kin suck\n          elsif system(\"diff\", __FILE__, __FILE__)\n            \"diff -u\"\n          else\n            nil\n          end\nend\n```\n\nReturns the diff command to use in [`diff`](assertions#method-i-diff). Tries to intelligently figure out what diff to use.\n\ndiff=(o) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 47\ndef self.diff= o\n  @diff = o\nend\n```\n\nSet the diff command to use in [`diff`](assertions#method-i-diff).\n\n### Public Instance Methods\n\nassert(test, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 178\ndef assert test, msg = nil\n  self.assertions += 1\n  unless test then\n    msg ||= \"Expected #{mu_pp test} to be truthy.\"\n    msg = msg.call if Proc === msg\n    raise Minitest::Assertion, msg\n  end\n  true\nend\n```\n\nFails unless `test` is truthy.\n\nassert_empty(obj, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 195\ndef assert_empty obj, msg = nil\n  msg = message(msg) { \"Expected #{mu_pp(obj)} to be empty\" }\n  assert_respond_to obj, :empty?\n  assert obj.empty?, msg\nend\n```\n\nFails unless `obj` is empty.\n\nassert_equal(exp, act, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 216\ndef assert_equal exp, act, msg = nil\n  msg = message(msg, E) { diff exp, act }\n  result = assert exp == act, msg\n\n  if nil == exp then\n    if Minitest::VERSION =~ /^6/ then\n      refute_nil exp, \"Use assert_nil if expecting nil.\"\n    else\n      where = Minitest.filter_backtrace(caller).first\n      where = where.split(/:in /, 2).first # clean up noise\n\n      warn \"DEPRECATED: Use assert_nil if expecting nil from #{where}. This will fail in Minitest 6.\"\n    end\n  end\n\n  result\nend\n```\n\nFails unless `exp == act` printing the difference between the two, if possible.\n\nIf there is no visible difference but the assertion fails, you should suspect that your == is buggy, or your inspect output is missing crucial details. For nicer structural diffing, set [`Minitest::Test.make_my_diffs_pretty!`](test#method-c-make_my_diffs_pretty-21)\n\nFor floats use assert_in_delta.\n\nSee also: [`Minitest::Assertions.diff`](assertions#method-c-diff)\n\nassert_in_delta(exp, act, delta = 0.001, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 240\ndef assert_in_delta exp, act, delta = 0.001, msg = nil\n  n = (exp - act).abs\n  msg = message(msg) {\n    \"Expected |#{exp} - #{act}| (#{n}) to be <= #{delta}\"\n  }\n  assert delta >= n, msg\nend\n```\n\nFor comparing Floats. Fails unless `exp` and `act` are within `delta` of each other.\n\n``` ruby\nassert_in_delta Math::PI, (22.0 / 7.0), 0.01\n```\n\nassert_in_epsilon(exp, act, epsilon = 0.001, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 252\ndef assert_in_epsilon exp, act, epsilon = 0.001, msg = nil\n  assert_in_delta exp, act, [exp.abs, act.abs].min * epsilon, msg\nend\n```\n\nFor comparing Floats. Fails unless `exp` and `act` have a relative error less than `epsilon`.\n\nassert_includes(collection, obj, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 259\ndef assert_includes collection, obj, msg = nil\n  msg = message(msg) {\n    \"Expected #{mu_pp(collection)} to include #{mu_pp(obj)}\"\n  }\n  assert_respond_to collection, :include?\n  assert collection.include?(obj), msg\nend\n```\n\nFails unless `collection` includes `obj`.\n\nassert_instance_of(cls, obj, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 270\ndef assert_instance_of cls, obj, msg = nil\n  msg = message(msg) {\n    \"Expected #{mu_pp(obj)} to be an instance of #{cls}, not #{obj.class}\"\n  }\n\n  assert obj.instance_of?(cls), msg\nend\n```\n\nFails unless `obj` is an instance of `cls`.\n\nassert_kind_of(cls, obj, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 281\ndef assert_kind_of cls, obj, msg = nil\n  msg = message(msg) {\n    \"Expected #{mu_pp(obj)} to be a kind of #{cls}, not #{obj.class}\" }\n\n  assert obj.kind_of?(cls), msg\nend\n```\n\nFails unless `obj` is a kind of `cls`.\n\nassert_match(matcher, obj, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 291\ndef assert_match matcher, obj, msg = nil\n  msg = message(msg) { \"Expected #{mu_pp matcher} to match #{mu_pp obj}\" }\n  assert_respond_to matcher, :\"=~\"\n  matcher = Regexp.new Regexp.escape matcher if String === matcher\n  assert matcher =~ obj, msg\n\n  Regexp.last_match\nend\n```\n\nFails unless `matcher` `=~` `obj`.\n\nassert_mock(mock) Show source\n\n``` ruby\n# File lib/minitest/mock.rb, line 248\ndef assert_mock mock\n  assert mock.verify\nend\n```\n\nAssert that the mock verifies correctly.\n\nassert_nil(obj, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 303\ndef assert_nil obj, msg = nil\n  msg = message(msg) { \"Expected #{mu_pp(obj)} to be nil\" }\n  assert obj.nil?, msg\nend\n```\n\nFails unless `obj` is nil\n\nassert_operator(o1, op, o2 = UNDEFINED, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 313\ndef assert_operator o1, op, o2 = UNDEFINED, msg = nil\n  return assert_predicate o1, op, msg if UNDEFINED == o2\n  msg = message(msg) { \"Expected #{mu_pp(o1)} to be #{op} #{mu_pp(o2)}\" }\n  assert o1.__send__(op, o2), msg\nend\n```\n\nFor testing with binary operators. Eg:\n\n``` ruby\nassert_operator 5, :<=, 4\n```\n\nassert_output(stdout = nil, stderr = nil) { \\|\\| ... } Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 331\ndef assert_output stdout = nil, stderr = nil\n  flunk \"assert_output requires a block to capture output.\" unless\n    block_given?\n\n  out, err = capture_io do\n    yield\n  end\n\n  err_msg = Regexp === stderr ? :assert_match : :assert_equal if stderr\n  out_msg = Regexp === stdout ? :assert_match : :assert_equal if stdout\n\n  y = send err_msg, stderr, err, \"In stderr\" if err_msg\n  x = send out_msg, stdout, out, \"In stdout\" if out_msg\n\n  (!stdout || x) && (!stderr || y)\nrescue Assertion\n  raise\nrescue => e\n  raise UnexpectedError, e\nend\n```\n\nFails if stdout or stderr do not output the expected results. Pass in nil if you don’t care about that streams output. Pass in “” if you require it to be silent. Pass in a regexp if you want to pattern match.\n\n``` ruby\nassert_output(/hey/) { method_with_output }\n```\n\nNOTE: this uses [`capture_io`](assertions#method-i-capture_io), not [`capture_subprocess_io`](assertions#method-i-capture_subprocess_io).\n\nSee also: [`assert_silent`](assertions#method-i-assert_silent)\n\nassert_path_exists(path, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 355\ndef assert_path_exists path, msg = nil\n  msg = message(msg) { \"Expected path '#{path}' to exist\" }\n  assert File.exist?(path), msg\nend\n```\n\nFails unless `path` exists.\n\nassert_pattern() { \\|\\| ... } Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 374\ndef assert_pattern\n  raise NotImplementedError, \"only available in Ruby 3.0+\" unless RUBY_VERSION >= \"3.0\"\n  flunk \"assert_pattern requires a block to capture errors.\" unless block_given?\n\n  begin # TODO: remove after ruby 2.6 dropped\n    yield\n    pass\n  rescue NoMatchingPatternError => e\n    flunk e.message\n  end\nend\n```\n\nFor testing with pattern matching (only supported with Ruby 3.0 and later)\n\n``` ruby\n# pass\nassert_pattern { [1,2,3] => [Integer, Integer, Integer] }\n\n# fail \"length mismatch (given 3, expected 1)\"\nassert_pattern { [1,2,3] => [Integer] }\n```\n\nThe bare `=>` pattern will raise a NoMatchingPatternError on failure, which would normally be counted as a test error. This assertion rescues NoMatchingPatternError and generates a test failure. Any other exception will be raised as normal and generate a test error.\n\nassert_predicate(o1, op, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 395\ndef assert_predicate o1, op, msg = nil\n  msg = message(msg) { \"Expected #{mu_pp(o1)} to be #{op}\" }\n  assert o1.__send__(op), msg\nend\n```\n\nFor testing with predicates. Eg:\n\n``` ruby\nassert_predicate str, :empty?\n```\n\nThis is really meant for specs and is front-ended by [`assert_operator`](assertions#method-i-assert_operator):\n\n``` ruby\nstr.must_be :empty?\n```\n\nassert_raises(\\*exp) { \\|\\| ... } Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 422\ndef assert_raises *exp\n  flunk \"assert_raises requires a block to capture errors.\" unless\n    block_given?\n\n  msg = \"#{exp.pop}.\\n\" if String === exp.last\n  exp << StandardError if exp.empty?\n\n  begin\n    yield\n  rescue *exp => e\n    pass # count assertion\n    return e\n  rescue Minitest::Assertion # incl Skip & UnexpectedError\n    # don't count assertion\n    raise\n  rescue SignalException, SystemExit\n    raise\n  rescue Exception => e\n    flunk proc {\n      exception_details(e, \"#{msg}#{mu_pp(exp)} exception expected, not\")\n    }\n  end\n\n  exp = exp.first if exp.size == 1\n\n  flunk \"#{msg}#{mu_pp(exp)} expected but nothing was raised.\"\nend\n```\n\nFails unless the block raises one of `exp`. Returns the exception matched so you can check the message, attributes, etc.\n\n`exp` takes an optional message on the end to help explain failures and defaults to StandardError if no exception class is passed. Eg:\n\n``` ruby\nassert_raises(CustomError) { method_with_custom_error }\n```\n\nWith custom error message:\n\n``` ruby\nassert_raises(CustomError, 'This should have raised CustomError') { method_with_custom_error }\n```\n\nUsing the returned object:\n\n``` ruby\nerror = assert_raises(CustomError) do\n  raise CustomError, 'This is really bad'\nend\n\nassert_equal 'This is really bad', error.message\n```\n\nassert_respond_to(obj, meth, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 453\ndef assert_respond_to obj, meth, msg = nil\n  msg = message(msg) {\n    \"Expected #{mu_pp(obj)} (#{obj.class}) to respond to ##{meth}\"\n  }\n  assert obj.respond_to?(meth), msg\nend\n```\n\nFails unless `obj` responds to `meth`.\n\nassert_same(exp, act, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 463\ndef assert_same exp, act, msg = nil\n  msg = message(msg) {\n    data = [mu_pp(act), act.object_id, mu_pp(exp), exp.object_id]\n    \"Expected %s (oid=%d) to be the same as %s (oid=%d)\" % data\n  }\n  assert exp.equal?(act), msg\nend\n```\n\nFails unless `exp` and `act` are equal?\n\nassert_send(send_ary, m = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 476\ndef assert_send send_ary, m = nil\n  where = Minitest.filter_backtrace(caller).first\n  where = where.split(/:in /, 2).first # clean up noise\n  warn \"DEPRECATED: assert_send. From #{where}\"\n\n  recv, msg, *args = send_ary\n  m = message(m) {\n    \"Expected #{mu_pp(recv)}.#{msg}(*#{mu_pp(args)}) to return true\" }\n  assert recv.__send__(msg, *args), m\nend\n```\n\n`send_ary` is a receiver, message and arguments.\n\nFails unless the call returns a true value\n\nassert_silent() { \\|\\| ... } Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 492\ndef assert_silent\n  assert_output \"\", \"\" do\n    yield\n  end\nend\n```\n\nFails if the block outputs anything to stderr or stdout.\n\nSee also: [`assert_output`](assertions#method-i-assert_output)\n\nassert_throws(sym, msg = nil) { \\|\\| ... } Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 501\ndef assert_throws sym, msg = nil\n  default = \"Expected #{mu_pp(sym)} to have been thrown\"\n  caught = true\n  value = catch(sym) do\n    begin\n      yield\n    rescue ThreadError => e       # wtf?!? 1.8 + threads == suck\n      default += \", not \\:#{e.message[/uncaught throw \\`(\\w+?)\\'/, 1]}\"\n    rescue ArgumentError => e     # 1.9 exception\n      raise e unless e.message.include?(\"uncaught throw\")\n      default += \", not #{e.message.split(/ /).last}\"\n    rescue NameError => e         # 1.8 exception\n      raise e unless e.name == sym\n      default += \", not #{e.name.inspect}\"\n    end\n    caught = false\n  end\n\n  assert caught, message(msg) { default }\n  value\nrescue Assertion\n  raise\nrescue => e\n  raise UnexpectedError, e\nend\n```\n\nFails unless the block throws `sym`\n\ncapture_io() { \\|\\| ... } Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 542\ndef capture_io\n  _synchronize do\n    begin\n      captured_stdout, captured_stderr = StringIO.new, StringIO.new\n\n      orig_stdout, orig_stderr = $stdout, $stderr\n      $stdout, $stderr         = captured_stdout, captured_stderr\n\n      yield\n\n      return captured_stdout.string, captured_stderr.string\n    ensure\n      $stdout = orig_stdout\n      $stderr = orig_stderr\n    end\n  end\nend\n```\n\nCaptures $stdout and $stderr into strings:\n\n``` ruby\nout, err = capture_io do\n  puts \"Some info\"\n  warn \"You did a bad thing\"\nend\n\nassert_match %r%info%, out\nassert_match %r%bad%, err\n```\n\nNOTE: For efficiency, this method uses StringIO and does not capture IO for subprocesses. Use [`capture_subprocess_io`](assertions#method-i-capture_subprocess_io) for that.\n\ncapture_subprocess_io() { \\|\\| ... } Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 575\ndef capture_subprocess_io\n  _synchronize do\n    begin\n      require \"tempfile\"\n\n      captured_stdout, captured_stderr = Tempfile.new(\"out\"), Tempfile.new(\"err\")\n\n      orig_stdout, orig_stderr = $stdout.dup, $stderr.dup\n      $stdout.reopen captured_stdout\n      $stderr.reopen captured_stderr\n\n      yield\n\n      $stdout.rewind\n      $stderr.rewind\n\n      return captured_stdout.read, captured_stderr.read\n    ensure\n      $stdout.reopen orig_stdout\n      $stderr.reopen orig_stderr\n\n      orig_stdout.close\n      orig_stderr.close\n      captured_stdout.close!\n      captured_stderr.close!\n    end\n  end\nend\n```\n\nCaptures $stdout and $stderr into strings, using Tempfile to ensure that subprocess IO is captured as well.\n\n``` ruby\nout, err = capture_subprocess_io do\n  system \"echo Some info\"\n  system \"echo You did a bad thing 1>&2\"\nend\n\nassert_match %r%info%, out\nassert_match %r%bad%, err\n```\n\nNOTE: This method is approximately 10x slower than [`capture_io`](assertions#method-i-capture_io) so only use it when you need to test the output of a subprocess.\n\ndiff(exp, act) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 59\ndef diff exp, act\n  result = nil\n\n  expect, butwas = things_to_diff(exp, act)\n\n  return \"Expected: #{mu_pp exp}\\n  Actual: #{mu_pp act}\" unless\n    expect\n\n  Tempfile.open(\"expect\") do |a|\n    a.puts expect\n    a.flush\n\n    Tempfile.open(\"butwas\") do |b|\n      b.puts butwas\n      b.flush\n\n      result = `#{Minitest::Assertions.diff} #{a.path} #{b.path}`\n      result.sub!(/^\\-\\-\\- .+/, \"--- expected\")\n      result.sub!(/^\\+\\+\\+ .+/, \"+++ actual\")\n\n      if result.empty? then\n        klass = exp.class\n        result = [\n                  \"No visible difference in the #{klass}#inspect output.\\n\",\n                  \"You should look at the implementation of #== on \",\n                  \"#{klass} or its members.\\n\",\n                  expect,\n                 ].join\n      end\n    end\n  end\n\n  result\nend\n```\n\nReturns a diff between `exp` and `act`. If there is no known diff command or if it doesn’t make sense to diff the output (single line, short output), then it simply returns a basic comparison between the two.\n\nSee `things_to_diff` for more info.\n\nexception_details(e, msg) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 607\ndef exception_details e, msg\n  [\n   \"#{msg}\",\n   \"Class: <#{e.class}>\",\n   \"Message: <#{e.message.inspect}>\",\n   \"---Backtrace---\",\n   \"#{Minitest.filter_backtrace(e.backtrace).join(\"\\n\")}\",\n   \"---------------\",\n  ].join \"\\n\"\nend\n```\n\nReturns details for exception `e`\n\nfail_after(y,m,d,msg) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 623\ndef fail_after y,m,d,msg\n  flunk msg if Time.now > Time.local(y, m, d)\nend\n```\n\nFails after a given date (in the local time zone). This allows you to put time-bombs in your tests if you need to keep something around until a later date lest you forget about it.\n\nflunk(msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 630\ndef flunk msg = nil\n  msg ||= \"Epic Fail!\"\n  assert false, msg\nend\n```\n\nFails with `msg`.\n\nmessage(msg = nil, ending = nil, &default) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 638\ndef message msg = nil, ending = nil, &default\n  proc {\n    msg = msg.call.chomp(\".\") if Proc === msg\n    custom_message = \"#{msg}.\\n\" unless msg.nil? or msg.to_s.empty?\n    \"#{custom_message}#{default.call}#{ending || \".\"}\"\n  }\nend\n```\n\nReturns a proc that will output `msg` along with the default message.\n\nmu_pp(obj) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 129\ndef mu_pp obj\n  s = obj.inspect\n\n  if defined? Encoding then\n    s = s.encode Encoding.default_external\n\n    if String === obj && (obj.encoding != Encoding.default_external ||\n                          !obj.valid_encoding?) then\n      enc = \"# encoding: #{obj.encoding}\"\n      val = \"#    valid: #{obj.valid_encoding?}\"\n      s = \"#{enc}\\n#{val}\\n#{s}\"\n    end\n  end\n\n  s\nend\n```\n\nThis returns a human-readable version of `obj`. By default inspect is called. You can override this to use pretty_inspect if you want.\n\nSee [`Minitest::Test.make_my_diffs_pretty!`](test#method-c-make_my_diffs_pretty-21)\n\nmu_pp_for_diff(obj) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 152\ndef mu_pp_for_diff obj\n  str = mu_pp obj\n\n  # both '\\n' & '\\\\n' (_after_ mu_pp (aka inspect))\n  single = !!str.match(/(?<!\\\\|^)\\\\n/)\n  double = !!str.match(/(?<=\\\\|^)\\\\n/)\n\n  process =\n    if single ^ double then\n      if single then\n        lambda { |s| s == \"\\\\n\"   ? \"\\n\"    : s } # unescape\n      else\n        lambda { |s| s == \"\\\\\\\\n\" ? \"\\\\n\\n\" : s } # unescape a bit, add nls\n      end\n    else\n      :itself                                     # leave it alone\n    end\n\n  str.\n    gsub(/\\\\?\\\\n/, &process).\n    gsub(/:0x[a-fA-F0-9]{4,}/m, \":0xXXXXXX\") # anonymize hex values\nend\n```\n\nThis returns a diff-able more human-readable version of `obj`. This differs from the regular [`mu_pp`](assertions#method-i-mu_pp) because it expands escaped newlines and makes hex-values (like object_ids) generic. This uses [`mu_pp`](assertions#method-i-mu_pp) to do the first pass and then cleans it up.\n\npass(\\_msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 649\ndef pass _msg = nil\n  assert true\nend\n```\n\nused for counting assertions\n\nrefute(test, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 656\ndef refute test, msg = nil\n  msg ||= message { \"Expected #{mu_pp(test)} to not be truthy\" }\n  assert !test, msg\nend\n```\n\nFails if `test` is truthy.\n\nrefute_empty(obj, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 664\ndef refute_empty obj, msg = nil\n  msg = message(msg) { \"Expected #{mu_pp(obj)} to not be empty\" }\n  assert_respond_to obj, :empty?\n  refute obj.empty?, msg\nend\n```\n\nFails if `obj` is empty.\n\nrefute_equal(exp, act, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 675\ndef refute_equal exp, act, msg = nil\n  msg = message(msg) {\n    \"Expected #{mu_pp(act)} to not be equal to #{mu_pp(exp)}\"\n  }\n  refute exp == act, msg\nend\n```\n\nFails if `exp == act`.\n\nFor floats use refute_in_delta.\n\nrefute_in_delta(exp, act, delta = 0.001, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 687\ndef refute_in_delta exp, act, delta = 0.001, msg = nil\n  n = (exp - act).abs\n  msg = message(msg) {\n    \"Expected |#{exp} - #{act}| (#{n}) to not be <= #{delta}\"\n  }\n  refute delta >= n, msg\nend\n```\n\nFor comparing Floats. Fails if `exp` is within `delta` of `act`.\n\n``` ruby\nrefute_in_delta Math::PI, (22.0 / 7.0)\n```\n\nrefute_in_epsilon(a, b, epsilon = 0.001, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 699\ndef refute_in_epsilon a, b, epsilon = 0.001, msg = nil\n  refute_in_delta a, b, a * epsilon, msg\nend\n```\n\nFor comparing Floats. Fails if `exp` and `act` have a relative error less than `epsilon`.\n\nrefute_includes(collection, obj, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 706\ndef refute_includes collection, obj, msg = nil\n  msg = message(msg) {\n    \"Expected #{mu_pp(collection)} to not include #{mu_pp(obj)}\"\n  }\n  assert_respond_to collection, :include?\n  refute collection.include?(obj), msg\nend\n```\n\nFails if `collection` includes `obj`.\n\nrefute_instance_of(cls, obj, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 717\ndef refute_instance_of cls, obj, msg = nil\n  msg = message(msg) {\n    \"Expected #{mu_pp(obj)} to not be an instance of #{cls}\"\n  }\n  refute obj.instance_of?(cls), msg\nend\n```\n\nFails if `obj` is an instance of `cls`.\n\nrefute_kind_of(cls, obj, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 727\ndef refute_kind_of cls, obj, msg = nil\n  msg = message(msg) { \"Expected #{mu_pp(obj)} to not be a kind of #{cls}\" }\n  refute obj.kind_of?(cls), msg\nend\n```\n\nFails if `obj` is a kind of `cls`.\n\nrefute_match(matcher, obj, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 735\ndef refute_match matcher, obj, msg = nil\n  msg = message(msg) { \"Expected #{mu_pp matcher} to not match #{mu_pp obj}\" }\n  assert_respond_to matcher, :\"=~\"\n  matcher = Regexp.new Regexp.escape matcher if String === matcher\n  refute matcher =~ obj, msg\nend\n```\n\nFails if `matcher` `=~` `obj`.\n\nrefute_nil(obj, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 745\ndef refute_nil obj, msg = nil\n  msg = message(msg) { \"Expected #{mu_pp(obj)} to not be nil\" }\n  refute obj.nil?, msg\nend\n```\n\nFails if `obj` is nil.\n\nrefute_operator(o1, op, o2 = UNDEFINED, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 780\ndef refute_operator o1, op, o2 = UNDEFINED, msg = nil\n  return refute_predicate o1, op, msg if UNDEFINED == o2\n  msg = message(msg) { \"Expected #{mu_pp(o1)} to not be #{op} #{mu_pp(o2)}\" }\n  refute o1.__send__(op, o2), msg\nend\n```\n\nFails if `o1` is not `op` `o2`. Eg:\n\n``` ruby\nrefute_operator 1, :>, 2 #=> pass\nrefute_operator 1, :<, 2 #=> fail\n```\n\nrefute_path_exists(path, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 789\ndef refute_path_exists path, msg = nil\n  msg = message(msg) { \"Expected path '#{path}' to not exist\" }\n  refute File.exist?(path), msg\nend\n```\n\nFails if `path` exists.\n\nrefute_pattern() { \\|\\| ... } Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 762\ndef refute_pattern\n  raise NotImplementedError, \"only available in Ruby 3.0+\" unless RUBY_VERSION >= \"3.0\"\n  flunk \"refute_pattern requires a block to capture errors.\" unless block_given?\n\n  begin\n    yield\n    flunk(\"NoMatchingPatternError expected, but nothing was raised.\")\n  rescue NoMatchingPatternError\n    pass\n  end\nend\n```\n\nFor testing with pattern matching (only supported with Ruby 3.0 and later)\n\n``` ruby\n# pass\nrefute_pattern { [1,2,3] => [String] }\n\n# fail \"NoMatchingPatternError expected, but nothing was raised.\"\nrefute_pattern { [1,2,3] => [Integer, Integer, Integer] }\n```\n\nThis assertion expects a NoMatchingPatternError exception, and will fail if none is raised. Any other exceptions will be raised as normal and generate a test error.\n\nrefute_predicate(o1, op, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 803\ndef refute_predicate o1, op, msg = nil\n  msg = message(msg) { \"Expected #{mu_pp(o1)} to not be #{op}\" }\n  refute o1.__send__(op), msg\nend\n```\n\nFor testing with predicates.\n\n``` ruby\nrefute_predicate str, :empty?\n```\n\nThis is really meant for specs and is front-ended by [`refute_operator`](assertions#method-i-refute_operator):\n\n``` ruby\nstr.wont_be :empty?\n```\n\nrefute_respond_to(obj, meth, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 811\ndef refute_respond_to obj, meth, msg = nil\n  msg = message(msg) { \"Expected #{mu_pp(obj)} to not respond to #{meth}\" }\n\n  refute obj.respond_to?(meth), msg\nend\n```\n\nFails if `obj` responds to the message `meth`.\n\nrefute_same(exp, act, msg = nil) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 820\ndef refute_same exp, act, msg = nil\n  msg = message(msg) {\n    data = [mu_pp(act), act.object_id, mu_pp(exp), exp.object_id]\n    \"Expected %s (oid=%d) to not be the same as %s (oid=%d)\" % data\n  }\n  refute exp.equal?(act), msg\nend\n```\n\nFails if `exp` is the same (by object identity) as `act`.\n\nskip(msg = nil, bt = caller) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 833\ndef skip msg = nil, bt = caller\n  msg ||= \"Skipped, no message given\"\n  @skip = true\n  raise Minitest::Skip, msg, bt\nend\n```\n\nSkips the current run. If run in verbose-mode, the skipped run gets listed at the end of the run but doesn’t cause a failure exit code.\n\nskip_until(y,m,d,msg) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 845\ndef skip_until y,m,d,msg\n  skip msg if Time.now < Time.local(y, m, d)\n  where = caller.first.rpartition(':in').reject(&:empty?).first\n  warn \"Stale skip_until %p at %s\" % [msg, where]\nend\n```\n\nSkips the current run until a given date (in the local time zone). This allows you to put some fixes on hold until a later date, but still holds you accountable and prevents you from forgetting it.\n\nskipped?() Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 854\ndef skipped?\n  defined?(@skip) and @skip\nend\n```\n\nWas this testcase skipped? Meant for teardown.\n\nthings_to_diff(exp, act) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 104\ndef things_to_diff exp, act\n  expect = mu_pp_for_diff exp\n  butwas = mu_pp_for_diff act\n\n  e1, e2 = expect.include?(\"\\n\"), expect.include?(\"\\\\n\")\n  b1, b2 = butwas.include?(\"\\n\"), butwas.include?(\"\\\\n\")\n\n  need_to_diff =\n    (e1 ^ e2                  ||\n     b1 ^ b2                  ||\n     expect.size > 30         ||\n     butwas.size > 30         ||\n     expect == butwas)        &&\n    Minitest::Assertions.diff\n\n  need_to_diff && [expect, butwas]\nend\n```\n\nReturns things to diff \\[expect, butwas\\], or \\[nil, nil\\] if nothing to diff.\n\nCriterion:\n\n1.  Strings include newlines or escaped newlines, but not both.\n\n2.  or: String lengths are \\> 30 characters.\n\n3.  or: Strings are equal to each other (but maybe different encodings?).\n\n4.  and: we found a diff executable.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Assertions.html](https://docs.seattlerb.org/minitest/Minitest/Assertions.html)"
- name: Minitest::Assertions#assert
  id: minitest/assertions#method-i-assert
  summary: Fails unless test is truthy
  belongs_to: Minitest::Assertions
  description: |-
    assert (test, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 178
    def assert test, msg = nil
      self.assertions += 1
      unless test then
        msg ||= "Expected #{mu_pp test} to be truthy."
        msg = msg.call if Proc === msg
        raise Minitest::Assertion, msg
      end
      true
    end
    ```

    Fails unless `test` is truthy.
- name: Minitest::Assertions#assert_empty
  id: minitest/assertions#method-i-assert_empty
  summary: Fails unless obj is empty
  belongs_to: Minitest::Assertions
  description: |-
    assert_empty (obj, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 195
    def assert_empty obj, msg = nil
      msg = message(msg) { "Expected #{mu_pp(obj)} to be empty" }
      assert_respond_to obj, :empty?
      assert obj.empty?, msg
    end
    ```

    Fails unless `obj` is empty.
- name: Minitest::Assertions#assert_equal
  id: minitest/assertions#method-i-assert_equal
  summary: Fails unless exp == act printing the difference between the two, if possible
  belongs_to: Minitest::Assertions
  description: |-
    assert_equal (exp, act, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 216
    def assert_equal exp, act, msg = nil
      msg = message(msg, E) { diff exp, act }
      result = assert exp == act, msg

      if nil == exp then
        if Minitest::VERSION =~ /^6/ then
          refute_nil exp, "Use assert_nil if expecting nil."
        else
          where = Minitest.filter_backtrace(caller).first
          where = where.split(/:in /, 2).first # clean up noise

          warn "DEPRECATED: Use assert_nil if expecting nil from #{where}. This will fail in Minitest 6."
        end
      end

      result
    end
    ```

    Fails unless `exp == act` printing the difference between the two, if possible.

    If there is no visible difference but the assertion fails, you should suspect that your == is buggy, or your inspect output is missing crucial details. For nicer structural diffing, set [`Minitest::Test.make_my_diffs_pretty!`](test#method-c-make_my_diffs_pretty-21)

    For floats use assert_in_delta.

    See also: [`Minitest::Assertions.diff`](assertions#method-c-diff)
- name: Minitest::Assertions#assert_in_delta
  id: minitest/assertions#method-i-assert_in_delta
  summary: For comparing Floats
  belongs_to: Minitest::Assertions
  description: |-
    assert_in_delta (exp, act, delta = 0.001, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 240
    def assert_in_delta exp, act, delta = 0.001, msg = nil
      n = (exp - act).abs
      msg = message(msg) {
        "Expected |#{exp} - #{act}| (#{n}) to be <= #{delta}"
      }
      assert delta >= n, msg
    end
    ```

    For comparing Floats. Fails unless `exp` and `act` are within `delta` of each other.

    ``` ruby
    assert_in_delta Math::PI, (22.0 / 7.0), 0.01
    ```
- name: Minitest::Assertions#assert_in_epsilon
  id: minitest/assertions#method-i-assert_in_epsilon
  summary: For comparing Floats
  belongs_to: Minitest::Assertions
  description: |-
    assert_in_epsilon (exp, act, epsilon = 0.001, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 252
    def assert_in_epsilon exp, act, epsilon = 0.001, msg = nil
      assert_in_delta exp, act, [exp.abs, act.abs].min * epsilon, msg
    end
    ```

    For comparing Floats. Fails unless `exp` and `act` have a relative error less than `epsilon`.
- name: Minitest::Assertions#assert_includes
  id: minitest/assertions#method-i-assert_includes
  summary: Fails unless collection includes obj
  belongs_to: Minitest::Assertions
  description: |-
    assert_includes (collection, obj, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 259
    def assert_includes collection, obj, msg = nil
      msg = message(msg) {
        "Expected #{mu_pp(collection)} to include #{mu_pp(obj)}"
      }
      assert_respond_to collection, :include?
      assert collection.include?(obj), msg
    end
    ```

    Fails unless `collection` includes `obj`.
- name: Minitest::Assertions#assert_instance_of
  id: minitest/assertions#method-i-assert_instance_of
  summary: Fails unless obj is an instance of cls
  belongs_to: Minitest::Assertions
  description: |-
    assert_instance_of (cls, obj, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 270
    def assert_instance_of cls, obj, msg = nil
      msg = message(msg) {
        "Expected #{mu_pp(obj)} to be an instance of #{cls}, not #{obj.class}"
      }

      assert obj.instance_of?(cls), msg
    end
    ```

    Fails unless `obj` is an instance of `cls`.
- name: Minitest::Assertions#assert_kind_of
  id: minitest/assertions#method-i-assert_kind_of
  summary: Fails unless obj is a kind of cls
  belongs_to: Minitest::Assertions
  description: |-
    assert_kind_of (cls, obj, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 281
    def assert_kind_of cls, obj, msg = nil
      msg = message(msg) {
        "Expected #{mu_pp(obj)} to be a kind of #{cls}, not #{obj.class}" }

      assert obj.kind_of?(cls), msg
    end
    ```

    Fails unless `obj` is a kind of `cls`.
- name: Minitest::Assertions#assert_match
  id: minitest/assertions#method-i-assert_match
  summary: Fails unless matcher =~ obj
  belongs_to: Minitest::Assertions
  description: |-
    assert_match (matcher, obj, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 291
    def assert_match matcher, obj, msg = nil
      msg = message(msg) { "Expected #{mu_pp matcher} to match #{mu_pp obj}" }
      assert_respond_to matcher, :"=~"
      matcher = Regexp.new Regexp.escape matcher if String === matcher
      assert matcher =~ obj, msg

      Regexp.last_match
    end
    ```

    Fails unless `matcher` `=~` `obj`.
- name: Minitest::Assertions#assert_mock
  id: minitest/assertions#method-i-assert_mock
  summary: Assert that the mock verifies correctly
  belongs_to: Minitest::Assertions
  description: |-
    assert_mock (mock) Show source

    ``` ruby
    # File lib/minitest/mock.rb, line 248
    def assert_mock mock
      assert mock.verify
    end
    ```

    Assert that the mock verifies correctly.
- name: Minitest::Assertions#assert_nil
  id: minitest/assertions#method-i-assert_nil
  summary: null
  belongs_to: Minitest::Assertions
  description: |-
    assert_nil (obj, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 303
    def assert_nil obj, msg = nil
      msg = message(msg) { "Expected #{mu_pp(obj)} to be nil" }
      assert obj.nil?, msg
    end
    ```

    Fails unless `obj` is nil
- name: Minitest::Assertions#assert_operator
  id: minitest/assertions#method-i-assert_operator
  summary: For testing with binary operators
  belongs_to: Minitest::Assertions
  description: |-
    assert_operator (o1, op, o2 = UNDEFINED, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 313
    def assert_operator o1, op, o2 = UNDEFINED, msg = nil
      return assert_predicate o1, op, msg if UNDEFINED == o2
      msg = message(msg) { "Expected #{mu_pp(o1)} to be #{op} #{mu_pp(o2)}" }
      assert o1.__send__(op, o2), msg
    end
    ```

    For testing with binary operators. Eg:

    ``` ruby
    assert_operator 5, :<=, 4
    ```
- name: Minitest::Assertions#assert_output
  id: minitest/assertions#method-i-assert_output
  summary: Fails if stdout or stderr do not output the expected results
  belongs_to: Minitest::Assertions
  description: |-
    assert_output (stdout = nil, stderr = nil) { \|\| ... } Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 331
    def assert_output stdout = nil, stderr = nil
      flunk "assert_output requires a block to capture output." unless
        block_given?

      out, err = capture_io do
        yield
      end

      err_msg = Regexp === stderr ? :assert_match : :assert_equal if stderr
      out_msg = Regexp === stdout ? :assert_match : :assert_equal if stdout

      y = send err_msg, stderr, err, "In stderr" if err_msg
      x = send out_msg, stdout, out, "In stdout" if out_msg

      (!stdout || x) && (!stderr || y)
    rescue Assertion
      raise
    rescue => e
      raise UnexpectedError, e
    end
    ```

    Fails if stdout or stderr do not output the expected results. Pass in nil if you don’t care about that streams output. Pass in “” if you require it to be silent. Pass in a regexp if you want to pattern match.

    ``` ruby
    assert_output(/hey/) { method_with_output }
    ```

    NOTE: this uses [`capture_io`](assertions#method-i-capture_io), not [`capture_subprocess_io`](assertions#method-i-capture_subprocess_io).

    See also: [`assert_silent`](assertions#method-i-assert_silent)
- name: Minitest::Assertions#assert_path_exists
  id: minitest/assertions#method-i-assert_path_exists
  summary: Fails unless path exists
  belongs_to: Minitest::Assertions
  description: |-
    assert_path_exists (path, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 355
    def assert_path_exists path, msg = nil
      msg = message(msg) { "Expected path '#{path}' to exist" }
      assert File.exist?(path), msg
    end
    ```

    Fails unless `path` exists.
- name: Minitest::Assertions#assert_pattern
  id: minitest/assertions#method-i-assert_pattern
  summary: The bare => pattern will raise a NoMatchingPatternError on failure, which would normally be counted as a test error
  belongs_to: Minitest::Assertions
  description: |-
    assert_pattern () { \|\| ... } Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 374
    def assert_pattern
      raise NotImplementedError, "only available in Ruby 3.0+" unless RUBY_VERSION >= "3.0"
      flunk "assert_pattern requires a block to capture errors." unless block_given?

      begin # TODO: remove after ruby 2.6 dropped
        yield
        pass
      rescue NoMatchingPatternError => e
        flunk e.message
      end
    end
    ```

    For testing with pattern matching (only supported with Ruby 3.0 and later)

    ``` ruby
    # pass
    assert_pattern { [1,2,3] => [Integer, Integer, Integer] }

    # fail "length mismatch (given 3, expected 1)"
    assert_pattern { [1,2,3] => [Integer] }
    ```

    The bare `=>` pattern will raise a NoMatchingPatternError on failure, which would normally be counted as a test error. This assertion rescues NoMatchingPatternError and generates a test failure. Any other exception will be raised as normal and generate a test error.
- name: Minitest::Assertions#assert_predicate
  id: minitest/assertions#method-i-assert_predicate
  summary: For testing with predicates
  belongs_to: Minitest::Assertions
  description: |-
    assert_predicate (o1, op, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 395
    def assert_predicate o1, op, msg = nil
      msg = message(msg) { "Expected #{mu_pp(o1)} to be #{op}" }
      assert o1.__send__(op), msg
    end
    ```

    For testing with predicates. Eg:

    ``` ruby
    assert_predicate str, :empty?
    ```

    This is really meant for specs and is front-ended by [`assert_operator`](assertions#method-i-assert_operator):

    ``` ruby
    str.must_be :empty?
    ```
- name: Minitest::Assertions#assert_raises
  id: minitest/assertions#method-i-assert_raises
  summary: Fails unless the block raises one of exp
  belongs_to: Minitest::Assertions
  description: |-
    assert_raises (\*exp) { \|\| ... } Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 422
    def assert_raises *exp
      flunk "assert_raises requires a block to capture errors." unless
        block_given?

      msg = "#{exp.pop}.\n" if String === exp.last
      exp << StandardError if exp.empty?

      begin
        yield
      rescue *exp => e
        pass # count assertion
        return e
      rescue Minitest::Assertion # incl Skip & UnexpectedError
        # don't count assertion
        raise
      rescue SignalException, SystemExit
        raise
      rescue Exception => e
        flunk proc {
          exception_details(e, "#{msg}#{mu_pp(exp)} exception expected, not")
        }
      end

      exp = exp.first if exp.size == 1

      flunk "#{msg}#{mu_pp(exp)} expected but nothing was raised."
    end
    ```

    Fails unless the block raises one of `exp`. Returns the exception matched so you can check the message, attributes, etc.

    `exp` takes an optional message on the end to help explain failures and defaults to StandardError if no exception class is passed. Eg:

    ``` ruby
    assert_raises(CustomError) { method_with_custom_error }
    ```

    With custom error message:

    ``` ruby
    assert_raises(CustomError, 'This should have raised CustomError') { method_with_custom_error }
    ```

    Using the returned object:

    ``` ruby
    error = assert_raises(CustomError) do
      raise CustomError, 'This is really bad'
    end

    assert_equal 'This is really bad', error.message
    ```
- name: Minitest::Assertions#assert_respond_to
  id: minitest/assertions#method-i-assert_respond_to
  summary: Fails unless obj responds to meth
  belongs_to: Minitest::Assertions
  description: |-
    assert_respond_to (obj, meth, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 453
    def assert_respond_to obj, meth, msg = nil
      msg = message(msg) {
        "Expected #{mu_pp(obj)} (#{obj.class}) to respond to ##{meth}"
      }
      assert obj.respond_to?(meth), msg
    end
    ```

    Fails unless `obj` responds to `meth`.
- name: Minitest::Assertions#assert_same
  id: minitest/assertions#method-i-assert_same
  summary: null
  belongs_to: Minitest::Assertions
  description: |-
    assert_same (exp, act, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 463
    def assert_same exp, act, msg = nil
      msg = message(msg) {
        data = [mu_pp(act), act.object_id, mu_pp(exp), exp.object_id]
        "Expected %s (oid=%d) to be the same as %s (oid=%d)" % data
      }
      assert exp.equal?(act), msg
    end
    ```

    Fails unless `exp` and `act` are equal?
- name: Minitest::Assertions#assert_send
  id: minitest/assertions#method-i-assert_send
  summary: send_ary is a receiver, message and arguments
  belongs_to: Minitest::Assertions
  description: |-
    assert_send (send_ary, m = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 476
    def assert_send send_ary, m = nil
      where = Minitest.filter_backtrace(caller).first
      where = where.split(/:in /, 2).first # clean up noise
      warn "DEPRECATED: assert_send. From #{where}"

      recv, msg, *args = send_ary
      m = message(m) {
        "Expected #{mu_pp(recv)}.#{msg}(*#{mu_pp(args)}) to return true" }
      assert recv.__send__(msg, *args), m
    end
    ```

    `send_ary` is a receiver, message and arguments.

    Fails unless the call returns a true value
- name: Minitest::Assertions#assert_silent
  id: minitest/assertions#method-i-assert_silent
  summary: Fails if the block outputs anything to stderr or stdout
  belongs_to: Minitest::Assertions
  description: |-
    assert_silent () { \|\| ... } Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 492
    def assert_silent
      assert_output "", "" do
        yield
      end
    end
    ```

    Fails if the block outputs anything to stderr or stdout.

    See also: [`assert_output`](assertions#method-i-assert_output)
- name: Minitest::Assertions#assert_throws
  id: minitest/assertions#method-i-assert_throws
  summary: null
  belongs_to: Minitest::Assertions
  description: |-
    assert_throws (sym, msg = nil) { \|\| ... } Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 501
    def assert_throws sym, msg = nil
      default = "Expected #{mu_pp(sym)} to have been thrown"
      caught = true
      value = catch(sym) do
        begin
          yield
        rescue ThreadError => e       # wtf?!? 1.8 + threads == suck
          default += ", not \:#{e.message[/uncaught throw \`(\w+?)\'/, 1]}"
        rescue ArgumentError => e     # 1.9 exception
          raise e unless e.message.include?("uncaught throw")
          default += ", not #{e.message.split(/ /).last}"
        rescue NameError => e         # 1.8 exception
          raise e unless e.name == sym
          default += ", not #{e.name.inspect}"
        end
        caught = false
      end

      assert caught, message(msg) { default }
      value
    rescue Assertion
      raise
    rescue => e
      raise UnexpectedError, e
    end
    ```

    Fails unless the block throws `sym`
- name: Minitest::Assertions#capture_io
  id: minitest/assertions#method-i-capture_io
  summary: 'NOTE: For efficiency, this method uses StringIO and does not capture IO for subprocesses'
  belongs_to: Minitest::Assertions
  description: |-
    capture_io () { \|\| ... } Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 542
    def capture_io
      _synchronize do
        begin
          captured_stdout, captured_stderr = StringIO.new, StringIO.new

          orig_stdout, orig_stderr = $stdout, $stderr
          $stdout, $stderr         = captured_stdout, captured_stderr

          yield

          return captured_stdout.string, captured_stderr.string
        ensure
          $stdout = orig_stdout
          $stderr = orig_stderr
        end
      end
    end
    ```

    Captures $stdout and $stderr into strings:

    ``` ruby
    out, err = capture_io do
      puts "Some info"
      warn "You did a bad thing"
    end

    assert_match %r%info%, out
    assert_match %r%bad%, err
    ```

    NOTE: For efficiency, this method uses StringIO and does not capture IO for subprocesses. Use [`capture_subprocess_io`](assertions#method-i-capture_subprocess_io) for that.
- name: Minitest::Assertions#capture_subprocess_io
  id: minitest/assertions#method-i-capture_subprocess_io
  summary: Captures $stdout and $stderr into strings, using Tempfile to ensure that subprocess IO is captured as well
  belongs_to: Minitest::Assertions
  description: |-
    capture_subprocess_io () { \|\| ... } Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 575
    def capture_subprocess_io
      _synchronize do
        begin
          require "tempfile"

          captured_stdout, captured_stderr = Tempfile.new("out"), Tempfile.new("err")

          orig_stdout, orig_stderr = $stdout.dup, $stderr.dup
          $stdout.reopen captured_stdout
          $stderr.reopen captured_stderr

          yield

          $stdout.rewind
          $stderr.rewind

          return captured_stdout.read, captured_stderr.read
        ensure
          $stdout.reopen orig_stdout
          $stderr.reopen orig_stderr

          orig_stdout.close
          orig_stderr.close
          captured_stdout.close!
          captured_stderr.close!
        end
      end
    end
    ```

    Captures $stdout and $stderr into strings, using Tempfile to ensure that subprocess IO is captured as well.

    ``` ruby
    out, err = capture_subprocess_io do
      system "echo Some info"
      system "echo You did a bad thing 1>&2"
    end

    assert_match %r%info%, out
    assert_match %r%bad%, err
    ```

    NOTE: This method is approximately 10x slower than [`capture_io`](assertions#method-i-capture_io) so only use it when you need to test the output of a subprocess.
- name: Minitest::Assertions#diff
  id: minitest/assertions#method-i-diff
  summary: Returns a diff between exp and act
  belongs_to: Minitest::Assertions
  description: |-
    diff (exp, act) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 59
    def diff exp, act
      result = nil

      expect, butwas = things_to_diff(exp, act)

      return "Expected: #{mu_pp exp}\n  Actual: #{mu_pp act}" unless
        expect

      Tempfile.open("expect") do |a|
        a.puts expect
        a.flush

        Tempfile.open("butwas") do |b|
          b.puts butwas
          b.flush

          result = `#{Minitest::Assertions.diff} #{a.path} #{b.path}`
          result.sub!(/^\-\-\- .+/, "--- expected")
          result.sub!(/^\+\+\+ .+/, "+++ actual")

          if result.empty? then
            klass = exp.class
            result = [
                      "No visible difference in the #{klass}#inspect output.\n",
                      "You should look at the implementation of #== on ",
                      "#{klass} or its members.\n",
                      expect,
                     ].join
          end
        end
      end

      result
    end
    ```

    Returns a diff between `exp` and `act`. If there is no known diff command or if it doesn’t make sense to diff the output (single line, short output), then it simply returns a basic comparison between the two.

    See `things_to_diff` for more info.
- name: Minitest::Assertions#exception_details
  id: minitest/assertions#method-i-exception_details
  summary: null
  belongs_to: Minitest::Assertions
  description: |-
    exception_details (e, msg) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 607
    def exception_details e, msg
      [
       "#{msg}",
       "Class: <#{e.class}>",
       "Message: <#{e.message.inspect}>",
       "---Backtrace---",
       "#{Minitest.filter_backtrace(e.backtrace).join("\n")}",
       "---------------",
      ].join "\n"
    end
    ```

    Returns details for exception `e`
- name: Minitest::Assertions#fail_after
  id: minitest/assertions#method-i-fail_after
  summary: Fails after a given date (in the local time zone)
  belongs_to: Minitest::Assertions
  description: |-
    fail_after (y,m,d,msg) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 623
    def fail_after y,m,d,msg
      flunk msg if Time.now > Time.local(y, m, d)
    end
    ```

    Fails after a given date (in the local time zone). This allows you to put time-bombs in your tests if you need to keep something around until a later date lest you forget about it.
- name: Minitest::Assertions#flunk
  id: minitest/assertions#method-i-flunk
  summary: Fails with msg
  belongs_to: Minitest::Assertions
  description: |-
    flunk (msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 630
    def flunk msg = nil
      msg ||= "Epic Fail!"
      assert false, msg
    end
    ```

    Fails with `msg`.
- name: Minitest::Assertions#message
  id: minitest/assertions#method-i-message
  summary: Returns a proc that will output msg along with the default message
  belongs_to: Minitest::Assertions
  description: |-
    message (msg = nil, ending = nil, &default) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 638
    def message msg = nil, ending = nil, &default
      proc {
        msg = msg.call.chomp(".") if Proc === msg
        custom_message = "#{msg}.\n" unless msg.nil? or msg.to_s.empty?
        "#{custom_message}#{default.call}#{ending || "."}"
      }
    end
    ```

    Returns a proc that will output `msg` along with the default message.
- name: Minitest::Assertions#mu_pp
  id: minitest/assertions#method-i-mu_pp
  summary: This returns a human-readable version of obj
  belongs_to: Minitest::Assertions
  description: |-
    mu_pp (obj) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 129
    def mu_pp obj
      s = obj.inspect

      if defined? Encoding then
        s = s.encode Encoding.default_external

        if String === obj && (obj.encoding != Encoding.default_external ||
                              !obj.valid_encoding?) then
          enc = "# encoding: #{obj.encoding}"
          val = "#    valid: #{obj.valid_encoding?}"
          s = "#{enc}\n#{val}\n#{s}"
        end
      end

      s
    end
    ```

    This returns a human-readable version of `obj`. By default inspect is called. You can override this to use pretty_inspect if you want.

    See [`Minitest::Test.make_my_diffs_pretty!`](test#method-c-make_my_diffs_pretty-21)
- name: Minitest::Assertions#mu_pp_for_diff
  id: minitest/assertions#method-i-mu_pp_for_diff
  summary: This returns a diff-able more human-readable version of obj
  belongs_to: Minitest::Assertions
  description: |-
    mu_pp_for_diff (obj) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 152
    def mu_pp_for_diff obj
      str = mu_pp obj

      # both '\n' & '\\n' (_after_ mu_pp (aka inspect))
      single = !!str.match(/(?<!\\|^)\\n/)
      double = !!str.match(/(?<=\\|^)\\n/)

      process =
        if single ^ double then
          if single then
            lambda { |s| s == "\\n"   ? "\n"    : s } # unescape
          else
            lambda { |s| s == "\\\\n" ? "\\n\n" : s } # unescape a bit, add nls
          end
        else
          :itself                                     # leave it alone
        end

      str.
        gsub(/\\?\\n/, &process).
        gsub(/:0x[a-fA-F0-9]{4,}/m, ":0xXXXXXX") # anonymize hex values
    end
    ```

    This returns a diff-able more human-readable version of `obj`. This differs from the regular [`mu_pp`](assertions#method-i-mu_pp) because it expands escaped newlines and makes hex-values (like object_ids) generic. This uses [`mu_pp`](assertions#method-i-mu_pp) to do the first pass and then cleans it up.
- name: Minitest::Assertions#pass
  id: minitest/assertions#method-i-pass
  summary: null
  belongs_to: Minitest::Assertions
  description: |-
    pass (\_msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 649
    def pass _msg = nil
      assert true
    end
    ```

    used for counting assertions
- name: Minitest::Assertions#refute
  id: minitest/assertions#method-i-refute
  summary: Fails if test is truthy
  belongs_to: Minitest::Assertions
  description: |-
    refute (test, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 656
    def refute test, msg = nil
      msg ||= message { "Expected #{mu_pp(test)} to not be truthy" }
      assert !test, msg
    end
    ```

    Fails if `test` is truthy.
- name: Minitest::Assertions#refute_empty
  id: minitest/assertions#method-i-refute_empty
  summary: Fails if obj is empty
  belongs_to: Minitest::Assertions
  description: |-
    refute_empty (obj, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 664
    def refute_empty obj, msg = nil
      msg = message(msg) { "Expected #{mu_pp(obj)} to not be empty" }
      assert_respond_to obj, :empty?
      refute obj.empty?, msg
    end
    ```

    Fails if `obj` is empty.
- name: Minitest::Assertions#refute_equal
  id: minitest/assertions#method-i-refute_equal
  summary: Fails if exp == act
  belongs_to: Minitest::Assertions
  description: |-
    refute_equal (exp, act, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 675
    def refute_equal exp, act, msg = nil
      msg = message(msg) {
        "Expected #{mu_pp(act)} to not be equal to #{mu_pp(exp)}"
      }
      refute exp == act, msg
    end
    ```

    Fails if `exp == act`.

    For floats use refute_in_delta.
- name: Minitest::Assertions#refute_in_delta
  id: minitest/assertions#method-i-refute_in_delta
  summary: For comparing Floats
  belongs_to: Minitest::Assertions
  description: |-
    refute_in_delta (exp, act, delta = 0.001, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 687
    def refute_in_delta exp, act, delta = 0.001, msg = nil
      n = (exp - act).abs
      msg = message(msg) {
        "Expected |#{exp} - #{act}| (#{n}) to not be <= #{delta}"
      }
      refute delta >= n, msg
    end
    ```

    For comparing Floats. Fails if `exp` is within `delta` of `act`.

    ``` ruby
    refute_in_delta Math::PI, (22.0 / 7.0)
    ```
- name: Minitest::Assertions#refute_in_epsilon
  id: minitest/assertions#method-i-refute_in_epsilon
  summary: For comparing Floats
  belongs_to: Minitest::Assertions
  description: |-
    refute_in_epsilon (a, b, epsilon = 0.001, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 699
    def refute_in_epsilon a, b, epsilon = 0.001, msg = nil
      refute_in_delta a, b, a * epsilon, msg
    end
    ```

    For comparing Floats. Fails if `exp` and `act` have a relative error less than `epsilon`.
- name: Minitest::Assertions#refute_includes
  id: minitest/assertions#method-i-refute_includes
  summary: Fails if collection includes obj
  belongs_to: Minitest::Assertions
  description: |-
    refute_includes (collection, obj, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 706
    def refute_includes collection, obj, msg = nil
      msg = message(msg) {
        "Expected #{mu_pp(collection)} to not include #{mu_pp(obj)}"
      }
      assert_respond_to collection, :include?
      refute collection.include?(obj), msg
    end
    ```

    Fails if `collection` includes `obj`.
- name: Minitest::Assertions#refute_instance_of
  id: minitest/assertions#method-i-refute_instance_of
  summary: Fails if obj is an instance of cls
  belongs_to: Minitest::Assertions
  description: |-
    refute_instance_of (cls, obj, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 717
    def refute_instance_of cls, obj, msg = nil
      msg = message(msg) {
        "Expected #{mu_pp(obj)} to not be an instance of #{cls}"
      }
      refute obj.instance_of?(cls), msg
    end
    ```

    Fails if `obj` is an instance of `cls`.
- name: Minitest::Assertions#refute_kind_of
  id: minitest/assertions#method-i-refute_kind_of
  summary: Fails if obj is a kind of cls
  belongs_to: Minitest::Assertions
  description: |-
    refute_kind_of (cls, obj, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 727
    def refute_kind_of cls, obj, msg = nil
      msg = message(msg) { "Expected #{mu_pp(obj)} to not be a kind of #{cls}" }
      refute obj.kind_of?(cls), msg
    end
    ```

    Fails if `obj` is a kind of `cls`.
- name: Minitest::Assertions#refute_match
  id: minitest/assertions#method-i-refute_match
  summary: Fails if matcher =~ obj
  belongs_to: Minitest::Assertions
  description: |-
    refute_match (matcher, obj, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 735
    def refute_match matcher, obj, msg = nil
      msg = message(msg) { "Expected #{mu_pp matcher} to not match #{mu_pp obj}" }
      assert_respond_to matcher, :"=~"
      matcher = Regexp.new Regexp.escape matcher if String === matcher
      refute matcher =~ obj, msg
    end
    ```

    Fails if `matcher` `=~` `obj`.
- name: Minitest::Assertions#refute_nil
  id: minitest/assertions#method-i-refute_nil
  summary: Fails if obj is nil
  belongs_to: Minitest::Assertions
  description: |-
    refute_nil (obj, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 745
    def refute_nil obj, msg = nil
      msg = message(msg) { "Expected #{mu_pp(obj)} to not be nil" }
      refute obj.nil?, msg
    end
    ```

    Fails if `obj` is nil.
- name: Minitest::Assertions#refute_operator
  id: minitest/assertions#method-i-refute_operator
  summary: Fails if o1 is not op o2
  belongs_to: Minitest::Assertions
  description: |-
    refute_operator (o1, op, o2 = UNDEFINED, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 780
    def refute_operator o1, op, o2 = UNDEFINED, msg = nil
      return refute_predicate o1, op, msg if UNDEFINED == o2
      msg = message(msg) { "Expected #{mu_pp(o1)} to not be #{op} #{mu_pp(o2)}" }
      refute o1.__send__(op, o2), msg
    end
    ```

    Fails if `o1` is not `op` `o2`. Eg:

    ``` ruby
    refute_operator 1, :>, 2 #=> pass
    refute_operator 1, :<, 2 #=> fail
    ```
- name: Minitest::Assertions#refute_path_exists
  id: minitest/assertions#method-i-refute_path_exists
  summary: Fails if path exists
  belongs_to: Minitest::Assertions
  description: |-
    refute_path_exists (path, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 789
    def refute_path_exists path, msg = nil
      msg = message(msg) { "Expected path '#{path}' to not exist" }
      refute File.exist?(path), msg
    end
    ```

    Fails if `path` exists.
- name: Minitest::Assertions#refute_pattern
  id: minitest/assertions#method-i-refute_pattern
  summary: This assertion expects a NoMatchingPatternError exception, and will fail if none is raised
  belongs_to: Minitest::Assertions
  description: |-
    refute_pattern () { \|\| ... } Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 762
    def refute_pattern
      raise NotImplementedError, "only available in Ruby 3.0+" unless RUBY_VERSION >= "3.0"
      flunk "refute_pattern requires a block to capture errors." unless block_given?

      begin
        yield
        flunk("NoMatchingPatternError expected, but nothing was raised.")
      rescue NoMatchingPatternError
        pass
      end
    end
    ```

    For testing with pattern matching (only supported with Ruby 3.0 and later)

    ``` ruby
    # pass
    refute_pattern { [1,2,3] => [String] }

    # fail "NoMatchingPatternError expected, but nothing was raised."
    refute_pattern { [1,2,3] => [Integer, Integer, Integer] }
    ```

    This assertion expects a NoMatchingPatternError exception, and will fail if none is raised. Any other exceptions will be raised as normal and generate a test error.
- name: Minitest::Assertions#refute_predicate
  id: minitest/assertions#method-i-refute_predicate
  summary: For testing with predicates
  belongs_to: Minitest::Assertions
  description: |-
    refute_predicate (o1, op, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 803
    def refute_predicate o1, op, msg = nil
      msg = message(msg) { "Expected #{mu_pp(o1)} to not be #{op}" }
      refute o1.__send__(op), msg
    end
    ```

    For testing with predicates.

    ``` ruby
    refute_predicate str, :empty?
    ```

    This is really meant for specs and is front-ended by [`refute_operator`](assertions#method-i-refute_operator):

    ``` ruby
    str.wont_be :empty?
    ```
- name: Minitest::Assertions#refute_respond_to
  id: minitest/assertions#method-i-refute_respond_to
  summary: Fails if obj responds to the message meth
  belongs_to: Minitest::Assertions
  description: |-
    refute_respond_to (obj, meth, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 811
    def refute_respond_to obj, meth, msg = nil
      msg = message(msg) { "Expected #{mu_pp(obj)} to not respond to #{meth}" }

      refute obj.respond_to?(meth), msg
    end
    ```

    Fails if `obj` responds to the message `meth`.
- name: Minitest::Assertions#refute_same
  id: minitest/assertions#method-i-refute_same
  summary: Fails if exp is the same (by object identity) as act
  belongs_to: Minitest::Assertions
  description: |-
    refute_same (exp, act, msg = nil) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 820
    def refute_same exp, act, msg = nil
      msg = message(msg) {
        data = [mu_pp(act), act.object_id, mu_pp(exp), exp.object_id]
        "Expected %s (oid=%d) to not be the same as %s (oid=%d)" % data
      }
      refute exp.equal?(act), msg
    end
    ```

    Fails if `exp` is the same (by object identity) as `act`.
- name: Minitest::Assertions#skip
  id: minitest/assertions#method-i-skip
  summary: Skips the current run
  belongs_to: Minitest::Assertions
  description: |-
    skip (msg = nil, bt = caller) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 833
    def skip msg = nil, bt = caller
      msg ||= "Skipped, no message given"
      @skip = true
      raise Minitest::Skip, msg, bt
    end
    ```

    Skips the current run. If run in verbose-mode, the skipped run gets listed at the end of the run but doesn’t cause a failure exit code.
- name: Minitest::Assertions#skip_until
  id: minitest/assertions#method-i-skip_until
  summary: Skips the current run until a given date (in the local time zone)
  belongs_to: Minitest::Assertions
  description: |-
    skip_until (y,m,d,msg) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 845
    def skip_until y,m,d,msg
      skip msg if Time.now < Time.local(y, m, d)
      where = caller.first.rpartition(':in').reject(&:empty?).first
      warn "Stale skip_until %p at %s" % [msg, where]
    end
    ```

    Skips the current run until a given date (in the local time zone). This allows you to put some fixes on hold until a later date, but still holds you accountable and prevents you from forgetting it.
- name: Minitest::Assertions#skipped?
  id: minitest/assertions#method-i-skipped-3F
  summary: Was this testcase skipped? Meant for teardown
  belongs_to: Minitest::Assertions
  description: |-
    skipped? () Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 854
    def skipped?
      defined?(@skip) and @skip
    end
    ```

    Was this testcase skipped? Meant for teardown.
- name: Minitest::Assertions#things_to_diff
  id: minitest/assertions#method-i-things_to_diff
  summary: Returns things to diff [expect, butwas], or [nil, nil] if nothing to diff
  belongs_to: Minitest::Assertions
  description: "things_to_diff (exp, act) Show source\n\n``` ruby\n# File lib/minitest/assertions.rb, line 104\ndef things_to_diff exp, act\n  expect = mu_pp_for_diff exp\n  butwas = mu_pp_for_diff act\n\n  e1, e2 = expect.include?(\"\\n\"), expect.include?(\"\\\\n\")\n  b1, b2 = butwas.include?(\"\\n\"), butwas.include?(\"\\\\n\")\n\n  need_to_diff =\n    (e1 ^ e2                  ||\n     b1 ^ b2                  ||\n     expect.size > 30         ||\n     butwas.size > 30         ||\n     expect == butwas)        &&\n    Minitest::Assertions.diff\n\n  need_to_diff && [expect, butwas]\nend\n```\n\nReturns things to diff \\[expect, butwas\\], or \\[nil, nil\\] if nothing to diff.\n\nCriterion:\n\n1.  Strings include newlines or escaped newlines, but not both.\n\n2.  or: String lengths are \\> 30 characters.\n\n3.  or: Strings are equal to each other (but maybe different encodings?).\n\n4.  and: we found a diff executable.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Assertions.html](https://docs.seattlerb.org/minitest/Minitest/Assertions.html)"
- name: Minitest::Assertions::diff
  id: minitest/assertions#method-c-diff
  summary: Returns the diff command to use in diff
  belongs_to: Minitest::Assertions
  description: |-
    diff () Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 29
    def self.diff
      return @diff if defined? @diff

      @diff = if (RbConfig::CONFIG["host_os"] =~ /mswin|mingw/ &&
                  system("diff.exe", __FILE__, __FILE__)) then
                "diff.exe -u"
              elsif system("gdiff", __FILE__, __FILE__)
                "gdiff -u" # solaris and kin suck
              elsif system("diff", __FILE__, __FILE__)
                "diff -u"
              else
                nil
              end
    end
    ```

    Returns the diff command to use in [`diff`](assertions#method-i-diff). Tries to intelligently figure out what diff to use.
- name: Minitest::Assertions::diff=
  id: minitest/assertions#method-c-diff-3D
  summary: Set the diff command to use in diff
  belongs_to: Minitest::Assertions
  description: |-
    diff= (o) Show source

    ``` ruby
    # File lib/minitest/assertions.rb, line 47
    def self.diff= o
      @diff = o
    end
    ```

    Set the diff command to use in [`diff`](assertions#method-i-diff).

    ### Public Instance Methods
- name: Minitest::autorun
  id: minitest#method-c-autorun
  summary: null
  belongs_to: Minitest
  description: |-
    autorun () Show source

    ``` ruby
    # File lib/minitest.rb, line 69
    def self.autorun
      if Object.const_defined?(:Warning) && Warning.respond_to?(:[]=)
        Warning[:deprecated] = true
      end

      at_exit {
        next if $! and not ($!.kind_of? SystemExit and $!.success?)

        exit_code = nil

        pid = Process.pid
        at_exit {
          next if !Minitest.allow_fork && Process.pid != pid
          @@after_run.reverse_each(&:call)
          exit exit_code || false
        }

        exit_code = Minitest.run ARGV
      } unless @@installed_at_exit
      @@installed_at_exit = true
    end
    ```

    Registers [`Minitest`](minitest) to run at process exit
- name: Minitest::BacktraceFilter
  id: minitest/backtracefilter
  summary: The standard backtrace filter for minitest
  description: "# class Minitest::BacktraceFilter\n\nParent:  \n[Object](../object)\n\nThe standard backtrace filter for minitest.\n\nSee Minitest.backtrace_filter=.\n\n### Public Instance Methods\n\nfilter(bt) Show source\n\n``` ruby\n# File lib/minitest.rb, line 1078\ndef filter bt\n  return [\"No backtrace\"] unless bt\n\n  return bt.dup if $DEBUG || ENV[\"MT_DEBUG\"]\n\n  new_bt = bt.take_while { |line| line !~ MT_RE }\n  new_bt = bt.select     { |line| line !~ MT_RE } if new_bt.empty?\n  new_bt = bt.dup                                 if new_bt.empty?\n\n  new_bt\nend\n```\n\nFilter `bt` to something useful. Returns the whole thing if $DEBUG (ruby) or $MT_DEBUG (env).\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/BacktraceFilter.html](https://docs.seattlerb.org/minitest/Minitest/BacktraceFilter.html)"
- name: Minitest::BacktraceFilter#filter
  id: minitest/backtracefilter#method-i-filter
  summary: Filter bt to something useful
  belongs_to: Minitest::BacktraceFilter
  description: "filter (bt) Show source\n\n``` ruby\n# File lib/minitest.rb, line 1078\ndef filter bt\n  return [\"No backtrace\"] unless bt\n\n  return bt.dup if $DEBUG || ENV[\"MT_DEBUG\"]\n\n  new_bt = bt.take_while { |line| line !~ MT_RE }\n  new_bt = bt.select     { |line| line !~ MT_RE } if new_bt.empty?\n  new_bt = bt.dup                                 if new_bt.empty?\n\n  new_bt\nend\n```\n\nFilter `bt` to something useful. Returns the whole thing if $DEBUG (ruby) or $MT_DEBUG (env).\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/BacktraceFilter.html](https://docs.seattlerb.org/minitest/Minitest/BacktraceFilter.html)"
- name: Minitest::Benchmark
  id: minitest/benchmark
  summary: Subclass Benchmark to create your own benchmark runs
  description: "# class Minitest::Benchmark\n\nParent:  \nTest\n\nSubclass [`Benchmark`](benchmark) to create your own benchmark runs. Methods starting with “bench\\_” get executed on a per-class.\n\nSee [`Minitest::Assertions`](assertions)\n\n### Public Class Methods\n\nbench_exp(min, max, base = 10) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 35\ndef self.bench_exp min, max, base = 10\n  min = (Math.log10(min) / Math.log10(base)).to_i\n  max = (Math.log10(max) / Math.log10(base)).to_i\n\n  (min..max).map { |m| base ** m }.to_a\nend\n```\n\nReturns a set of ranges stepped exponentially from `min` to `max` by powers of `base`. Eg:\n\n``` ruby\nbench_exp(2, 16, 2) # => [2, 4, 8, 16]\n```\n\nbench_linear(min, max, step = 10) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 48\ndef self.bench_linear min, max, step = 10\n  (min..max).step(step).to_a\nrescue LocalJumpError # 1.8.6\n  r = []; (min..max).step(step) { |n| r << n }; r\nend\n```\n\nReturns a set of ranges stepped linearly from `min` to `max` by `step`. Eg:\n\n``` ruby\nbench_linear(20, 40, 10) # => [20, 30, 40]\n```\n\nbench_range() Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 61\ndef self.bench_range\n  bench_exp 1, 10_000\nend\n```\n\nSpecifies the ranges used for benchmarking for that class. Defaults to exponential growth from 1 to 10k by powers of 10. Override if you need different ranges for your benchmarks.\n\nSee also: [`::bench_exp`](benchmark#method-c-bench_exp) and [`::bench_linear`](benchmark#method-c-bench_linear).\n\n### Public Instance Methods\n\nassert_performance(validation, &work) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 83\ndef assert_performance validation, &work\n  range = self.class.bench_range\n\n  io.print \"#{self.name}\"\n\n  times = []\n\n  range.each do |x|\n    GC.start\n    t0 = Minitest.clock_time\n    instance_exec(x, &work)\n    t = Minitest.clock_time - t0\n\n    io.print \"\\t%9.6f\" % t\n    times << t\n  end\n  io.puts\n\n  validation[range, times]\nend\n```\n\nRuns the given `work`, gathering the times of each run. Range and times are then passed to a given `validation` proc. Outputs the benchmark name and times in tab-separated format, making it easy to paste into a spreadsheet for graphing or further analysis.\n\nRanges are specified by [`::bench_range`](benchmark#method-c-bench_range).\n\nEg:\n\n    def bench_algorithm\n      validation = proc { |x, y| ... }\n      assert_performance validation do |n|\n        @obj.algorithm(n)\n      end\n    end\n\nassert_performance_constant(threshold = 0.99, &work) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 127\ndef assert_performance_constant threshold = 0.99, &work\n  validation = proc do |range, times|\n    a, b, rr = fit_linear range, times\n    assert_in_delta 0, b, 1 - threshold\n    [a, b, rr]\n  end\n\n  assert_performance validation, &work\nend\n```\n\nRuns the given `work` and asserts that the times gathered fit to match a constant rate (eg, linear slope == 0) within a given `threshold`. Note: because we’re testing for a slope of 0, R^2 is not a good determining factor for the fit, so the threshold is applied against the slope itself. As such, you probably want to tighten it from the default.\n\nSee [www.graphpad.com/guides/prism/8/curve-fitting/reg_intepretingnonlinr2.htm](https://www.graphpad.com/guides/prism/8/curve-fitting/reg_intepretingnonlinr2.htm) for more details.\n\nFit is calculated by [`fit_linear`](benchmark#method-i-fit_linear).\n\nRanges are specified by [`::bench_range`](benchmark#method-c-bench_range).\n\nEg:\n\n``` ruby\ndef bench_algorithm\n  assert_performance_constant 0.9999 do |n|\n    @obj.algorithm(n)\n  end\nend\n```\n\nassert_performance_exponential(threshold = 0.99, &work) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 153\ndef assert_performance_exponential threshold = 0.99, &work\n  assert_performance validation_for_fit(:exponential, threshold), &work\nend\n```\n\nRuns the given `work` and asserts that the times gathered fit to match a exponential curve within a given error `threshold`.\n\nFit is calculated by [`fit_exponential`](benchmark#method-i-fit_exponential).\n\nRanges are specified by [`::bench_range`](benchmark#method-c-bench_range).\n\nEg:\n\n``` ruby\ndef bench_algorithm\n  assert_performance_exponential 0.9999 do |n|\n    @obj.algorithm(n)\n  end\nend\n```\n\nassert_performance_linear(threshold = 0.99, &work) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 193\ndef assert_performance_linear threshold = 0.99, &work\n  assert_performance validation_for_fit(:linear, threshold), &work\nend\n```\n\nRuns the given `work` and asserts that the times gathered fit to match a straight line within a given error `threshold`.\n\nFit is calculated by [`fit_linear`](benchmark#method-i-fit_linear).\n\nRanges are specified by [`::bench_range`](benchmark#method-c-bench_range).\n\nEg:\n\n``` ruby\ndef bench_algorithm\n  assert_performance_linear 0.9999 do |n|\n    @obj.algorithm(n)\n  end\nend\n```\n\nassert_performance_logarithmic(threshold = 0.99, &work) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 173\ndef assert_performance_logarithmic threshold = 0.99, &work\n  assert_performance validation_for_fit(:logarithmic, threshold), &work\nend\n```\n\nRuns the given `work` and asserts that the times gathered fit to match a logarithmic curve within a given error `threshold`.\n\nFit is calculated by [`fit_logarithmic`](benchmark#method-i-fit_logarithmic).\n\nRanges are specified by [`::bench_range`](benchmark#method-c-bench_range).\n\nEg:\n\n``` ruby\ndef bench_algorithm\n  assert_performance_logarithmic 0.9999 do |n|\n    @obj.algorithm(n)\n  end\nend\n```\n\nassert_performance_power(threshold = 0.99, &work) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 213\ndef assert_performance_power threshold = 0.99, &work\n  assert_performance validation_for_fit(:power, threshold), &work\nend\n```\n\nRuns the given `work` and asserts that the times gathered curve fit to match a power curve within a given error `threshold`.\n\nFit is calculated by [`fit_power`](benchmark#method-i-fit_power).\n\nRanges are specified by [`::bench_range`](benchmark#method-c-bench_range).\n\nEg:\n\n``` ruby\ndef bench_algorithm\n  assert_performance_power 0.9999 do |x|\n    @obj.algorithm\n  end\nend\n```\n\nfit_error(xys) { \\|x\\| ... } Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 222\ndef fit_error xys\n  y_bar  = sigma(xys) { |_, y| y } / xys.size.to_f\n  ss_tot = sigma(xys) { |_, y| (y    - y_bar) ** 2 }\n  ss_err = sigma(xys) { |x, y| (yield(x) - y) ** 2 }\n\n  1 - (ss_err / ss_tot)\nend\n```\n\nTakes an array of x/y pairs and calculates the general R^2 value.\n\nSee: [en.wikipedia.org/wiki/Coefficient_of_determination](https://en.wikipedia.org/wiki/Coefficient_of_determination)\n\nfit_exponential(xs, ys) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 237\ndef fit_exponential xs, ys\n  n     = xs.size\n  xys   = xs.zip(ys)\n  sxlny = sigma(xys) { |x, y| x * Math.log(y) }\n  slny  = sigma(xys) { |_, y| Math.log(y)     }\n  sx2   = sigma(xys) { |x, _| x * x           }\n  sx    = sigma xs\n\n  c = n * sx2 - sx ** 2\n  a = (slny * sx2 - sx * sxlny) / c\n  b = ( n * sxlny - sx * slny ) / c\n\n  return Math.exp(a), b, fit_error(xys) { |x| Math.exp(a + b * x) }\nend\n```\n\nTo fit a functional form: y = ae^(bx).\n\nTakes x and y values and returns \\[a, b, r^2\\].\n\nSee: [mathworld.wolfram.com/LeastSquaresFittingExponential.html](https://mathworld.wolfram.com/LeastSquaresFittingExponential.html)\n\nfit_linear(xs, ys) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 281\ndef fit_linear xs, ys\n  n   = xs.size\n  xys = xs.zip(ys)\n  sx  = sigma xs\n  sy  = sigma ys\n  sx2 = sigma(xs)  { |x|   x ** 2 }\n  sxy = sigma(xys) { |x, y| x * y  }\n\n  c = n * sx2 - sx**2\n  a = (sy * sx2 - sx * sxy) / c\n  b = ( n * sxy - sx * sy ) / c\n\n  return a, b, fit_error(xys) { |x| a + b * x }\nend\n```\n\nFits the functional form: a + bx.\n\nTakes x and y values and returns \\[a, b, r^2\\].\n\nSee: [mathworld.wolfram.com/LeastSquaresFitting.html](https://mathworld.wolfram.com/LeastSquaresFitting.html)\n\nfit_logarithmic(xs, ys) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 259\ndef fit_logarithmic xs, ys\n  n     = xs.size\n  xys   = xs.zip(ys)\n  slnx2 = sigma(xys) { |x, _| Math.log(x) ** 2 }\n  slnx  = sigma(xys) { |x, _| Math.log(x)      }\n  sylnx = sigma(xys) { |x, y| y * Math.log(x)  }\n  sy    = sigma(xys) { |_, y| y                }\n\n  c = n * slnx2 - slnx ** 2\n  b = ( n * sylnx - sy * slnx ) / c\n  a = (sy - b * slnx) / n\n\n  return a, b, fit_error(xys) { |x| a + b * Math.log(x) }\nend\n```\n\nTo fit a functional form: y = a + b\\*ln(x).\n\nTakes x and y values and returns \\[a, b, r^2\\].\n\nSee: [mathworld.wolfram.com/LeastSquaresFittingLogarithmic.html](https://mathworld.wolfram.com/LeastSquaresFittingLogarithmic.html)\n\nfit_power(xs, ys) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 303\ndef fit_power xs, ys\n  n       = xs.size\n  xys     = xs.zip(ys)\n  slnxlny = sigma(xys) { |x, y| Math.log(x) * Math.log(y) }\n  slnx    = sigma(xs)  { |x   | Math.log(x)               }\n  slny    = sigma(ys)  { |   y| Math.log(y)               }\n  slnx2   = sigma(xs)  { |x   | Math.log(x) ** 2          }\n\n  b = (n * slnxlny - slnx * slny) / (n * slnx2 - slnx ** 2)\n  a = (slny - b * slnx) / n\n\n  return Math.exp(a), b, fit_error(xys) { |x| (Math.exp(a) * (x ** b)) }\nend\n```\n\nTo fit a functional form: y = ax^b.\n\nTakes x and y values and returns \\[a, b, r^2\\].\n\nSee: [mathworld.wolfram.com/LeastSquaresFittingPowerLaw.html](https://mathworld.wolfram.com/LeastSquaresFittingPowerLaw.html)\n\nsigma(enum, &block) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 324\ndef sigma enum, &block\n  enum = enum.map(&block) if block\n  enum.inject { |sum, n| sum + n }\nend\n```\n\nEnumerates over `enum` mapping `block` if given, returning the sum of the result. Eg:\n\n``` ruby\nsigma([1, 2, 3])                # => 1 + 2 + 3 => 6\nsigma([1, 2, 3]) { |n| n ** 2 } # => 1 + 4 + 9 => 14\n```\n\nvalidation_for_fit(msg, threshold) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 333\ndef validation_for_fit msg, threshold\n  proc do |range, times|\n    a, b, rr = send \"fit_#{msg}\", range, times\n    assert_operator rr, :>=, threshold\n    [a, b, rr]\n  end\nend\n```\n\nReturns a proc that calls the specified fit method and asserts that the error is within a tolerable threshold.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Benchmark.html](https://docs.seattlerb.org/minitest/Minitest/Benchmark.html)"
- name: Minitest::Benchmark#assert_performance
  id: minitest/benchmark#method-i-assert_performance
  summary: Runs the given work, gathering the times of each run
  belongs_to: Minitest::Benchmark
  description: |-
    assert_performance (validation, &work) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 83
    def assert_performance validation, &work
      range = self.class.bench_range

      io.print "#{self.name}"

      times = []

      range.each do |x|
        GC.start
        t0 = Minitest.clock_time
        instance_exec(x, &work)
        t = Minitest.clock_time - t0

        io.print "\t%9.6f" % t
        times << t
      end
      io.puts

      validation[range, times]
    end
    ```

    Runs the given `work`, gathering the times of each run. Range and times are then passed to a given `validation` proc. Outputs the benchmark name and times in tab-separated format, making it easy to paste into a spreadsheet for graphing or further analysis.

    Ranges are specified by [`::bench_range`](benchmark#method-c-bench_range).

    Eg:

        def bench_algorithm
          validation = proc { |x, y| ... }
          assert_performance validation do |n|
            @obj.algorithm(n)
          end
        end
- name: Minitest::Benchmark#assert_performance_constant
  id: minitest/benchmark#method-i-assert_performance_constant
  summary: Runs the given work and asserts that the times gathered fit to match a constant rate (eg, linear slope == 0) within a given threshold
  belongs_to: Minitest::Benchmark
  description: |-
    assert_performance_constant (threshold = 0.99, &work) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 127
    def assert_performance_constant threshold = 0.99, &work
      validation = proc do |range, times|
        a, b, rr = fit_linear range, times
        assert_in_delta 0, b, 1 - threshold
        [a, b, rr]
      end

      assert_performance validation, &work
    end
    ```

    Runs the given `work` and asserts that the times gathered fit to match a constant rate (eg, linear slope == 0) within a given `threshold`. Note: because we’re testing for a slope of 0, R^2 is not a good determining factor for the fit, so the threshold is applied against the slope itself. As such, you probably want to tighten it from the default.

    See [www.graphpad.com/guides/prism/8/curve-fitting/reg_intepretingnonlinr2.htm](https://www.graphpad.com/guides/prism/8/curve-fitting/reg_intepretingnonlinr2.htm) for more details.

    Fit is calculated by [`fit_linear`](benchmark#method-i-fit_linear).

    Ranges are specified by [`::bench_range`](benchmark#method-c-bench_range).

    Eg:

    ``` ruby
    def bench_algorithm
      assert_performance_constant 0.9999 do |n|
        @obj.algorithm(n)
      end
    end
    ```
- name: Minitest::Benchmark#assert_performance_exponential
  id: minitest/benchmark#method-i-assert_performance_exponential
  summary: Runs the given work and asserts that the times gathered fit to match a exponential curve within a given error threshold
  belongs_to: Minitest::Benchmark
  description: |-
    assert_performance_exponential (threshold = 0.99, &work) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 153
    def assert_performance_exponential threshold = 0.99, &work
      assert_performance validation_for_fit(:exponential, threshold), &work
    end
    ```

    Runs the given `work` and asserts that the times gathered fit to match a exponential curve within a given error `threshold`.

    Fit is calculated by [`fit_exponential`](benchmark#method-i-fit_exponential).

    Ranges are specified by [`::bench_range`](benchmark#method-c-bench_range).

    Eg:

    ``` ruby
    def bench_algorithm
      assert_performance_exponential 0.9999 do |n|
        @obj.algorithm(n)
      end
    end
    ```
- name: Minitest::Benchmark#assert_performance_linear
  id: minitest/benchmark#method-i-assert_performance_linear
  summary: Runs the given work and asserts that the times gathered fit to match a straight line within a given error threshold
  belongs_to: Minitest::Benchmark
  description: |-
    assert_performance_linear (threshold = 0.99, &work) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 193
    def assert_performance_linear threshold = 0.99, &work
      assert_performance validation_for_fit(:linear, threshold), &work
    end
    ```

    Runs the given `work` and asserts that the times gathered fit to match a straight line within a given error `threshold`.

    Fit is calculated by [`fit_linear`](benchmark#method-i-fit_linear).

    Ranges are specified by [`::bench_range`](benchmark#method-c-bench_range).

    Eg:

    ``` ruby
    def bench_algorithm
      assert_performance_linear 0.9999 do |n|
        @obj.algorithm(n)
      end
    end
    ```
- name: Minitest::Benchmark#assert_performance_logarithmic
  id: minitest/benchmark#method-i-assert_performance_logarithmic
  summary: Runs the given work and asserts that the times gathered fit to match a logarithmic curve within a given error threshold
  belongs_to: Minitest::Benchmark
  description: |-
    assert_performance_logarithmic (threshold = 0.99, &work) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 173
    def assert_performance_logarithmic threshold = 0.99, &work
      assert_performance validation_for_fit(:logarithmic, threshold), &work
    end
    ```

    Runs the given `work` and asserts that the times gathered fit to match a logarithmic curve within a given error `threshold`.

    Fit is calculated by [`fit_logarithmic`](benchmark#method-i-fit_logarithmic).

    Ranges are specified by [`::bench_range`](benchmark#method-c-bench_range).

    Eg:

    ``` ruby
    def bench_algorithm
      assert_performance_logarithmic 0.9999 do |n|
        @obj.algorithm(n)
      end
    end
    ```
- name: Minitest::Benchmark#assert_performance_power
  id: minitest/benchmark#method-i-assert_performance_power
  summary: Runs the given work and asserts that the times gathered curve fit to match a power curve within a given error threshold
  belongs_to: Minitest::Benchmark
  description: |-
    assert_performance_power (threshold = 0.99, &work) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 213
    def assert_performance_power threshold = 0.99, &work
      assert_performance validation_for_fit(:power, threshold), &work
    end
    ```

    Runs the given `work` and asserts that the times gathered curve fit to match a power curve within a given error `threshold`.

    Fit is calculated by [`fit_power`](benchmark#method-i-fit_power).

    Ranges are specified by [`::bench_range`](benchmark#method-c-bench_range).

    Eg:

    ``` ruby
    def bench_algorithm
      assert_performance_power 0.9999 do |x|
        @obj.algorithm
      end
    end
    ```
- name: Minitest::Benchmark#fit_error
  id: minitest/benchmark#method-i-fit_error
  summary: Takes an array of x/y pairs and calculates the general R^2 value
  belongs_to: Minitest::Benchmark
  description: |-
    fit_error (xys) { \|x\| ... } Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 222
    def fit_error xys
      y_bar  = sigma(xys) { |_, y| y } / xys.size.to_f
      ss_tot = sigma(xys) { |_, y| (y    - y_bar) ** 2 }
      ss_err = sigma(xys) { |x, y| (yield(x) - y) ** 2 }

      1 - (ss_err / ss_tot)
    end
    ```

    Takes an array of x/y pairs and calculates the general R^2 value.

    See: [en.wikipedia.org/wiki/Coefficient_of_determination](https://en.wikipedia.org/wiki/Coefficient_of_determination)
- name: Minitest::Benchmark#fit_exponential
  id: minitest/benchmark#method-i-fit_exponential
  summary: 'To fit a functional form: y = ae^(bx)'
  belongs_to: Minitest::Benchmark
  description: |-
    fit_exponential (xs, ys) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 237
    def fit_exponential xs, ys
      n     = xs.size
      xys   = xs.zip(ys)
      sxlny = sigma(xys) { |x, y| x * Math.log(y) }
      slny  = sigma(xys) { |_, y| Math.log(y)     }
      sx2   = sigma(xys) { |x, _| x * x           }
      sx    = sigma xs

      c = n * sx2 - sx ** 2
      a = (slny * sx2 - sx * sxlny) / c
      b = ( n * sxlny - sx * slny ) / c

      return Math.exp(a), b, fit_error(xys) { |x| Math.exp(a + b * x) }
    end
    ```

    To fit a functional form: y = ae^(bx).

    Takes x and y values and returns \[a, b, r^2\].

    See: [mathworld.wolfram.com/LeastSquaresFittingExponential.html](https://mathworld.wolfram.com/LeastSquaresFittingExponential.html)
- name: Minitest::Benchmark#fit_linear
  id: minitest/benchmark#method-i-fit_linear
  summary: 'Fits the functional form: a + bx'
  belongs_to: Minitest::Benchmark
  description: |-
    fit_linear (xs, ys) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 281
    def fit_linear xs, ys
      n   = xs.size
      xys = xs.zip(ys)
      sx  = sigma xs
      sy  = sigma ys
      sx2 = sigma(xs)  { |x|   x ** 2 }
      sxy = sigma(xys) { |x, y| x * y  }

      c = n * sx2 - sx**2
      a = (sy * sx2 - sx * sxy) / c
      b = ( n * sxy - sx * sy ) / c

      return a, b, fit_error(xys) { |x| a + b * x }
    end
    ```

    Fits the functional form: a + bx.

    Takes x and y values and returns \[a, b, r^2\].

    See: [mathworld.wolfram.com/LeastSquaresFitting.html](https://mathworld.wolfram.com/LeastSquaresFitting.html)
- name: Minitest::Benchmark#fit_logarithmic
  id: minitest/benchmark#method-i-fit_logarithmic
  summary: 'To fit a functional form: y = a + b*ln(x)'
  belongs_to: Minitest::Benchmark
  description: |-
    fit_logarithmic (xs, ys) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 259
    def fit_logarithmic xs, ys
      n     = xs.size
      xys   = xs.zip(ys)
      slnx2 = sigma(xys) { |x, _| Math.log(x) ** 2 }
      slnx  = sigma(xys) { |x, _| Math.log(x)      }
      sylnx = sigma(xys) { |x, y| y * Math.log(x)  }
      sy    = sigma(xys) { |_, y| y                }

      c = n * slnx2 - slnx ** 2
      b = ( n * sylnx - sy * slnx ) / c
      a = (sy - b * slnx) / n

      return a, b, fit_error(xys) { |x| a + b * Math.log(x) }
    end
    ```

    To fit a functional form: y = a + b\*ln(x).

    Takes x and y values and returns \[a, b, r^2\].

    See: [mathworld.wolfram.com/LeastSquaresFittingLogarithmic.html](https://mathworld.wolfram.com/LeastSquaresFittingLogarithmic.html)
- name: Minitest::Benchmark#fit_power
  id: minitest/benchmark#method-i-fit_power
  summary: 'To fit a functional form: y = ax^b'
  belongs_to: Minitest::Benchmark
  description: |-
    fit_power (xs, ys) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 303
    def fit_power xs, ys
      n       = xs.size
      xys     = xs.zip(ys)
      slnxlny = sigma(xys) { |x, y| Math.log(x) * Math.log(y) }
      slnx    = sigma(xs)  { |x   | Math.log(x)               }
      slny    = sigma(ys)  { |   y| Math.log(y)               }
      slnx2   = sigma(xs)  { |x   | Math.log(x) ** 2          }

      b = (n * slnxlny - slnx * slny) / (n * slnx2 - slnx ** 2)
      a = (slny - b * slnx) / n

      return Math.exp(a), b, fit_error(xys) { |x| (Math.exp(a) * (x ** b)) }
    end
    ```

    To fit a functional form: y = ax^b.

    Takes x and y values and returns \[a, b, r^2\].

    See: [mathworld.wolfram.com/LeastSquaresFittingPowerLaw.html](https://mathworld.wolfram.com/LeastSquaresFittingPowerLaw.html)
- name: Minitest::Benchmark#sigma
  id: minitest/benchmark#method-i-sigma
  summary: Enumerates over enum mapping block if given, returning the sum of the result
  belongs_to: Minitest::Benchmark
  description: |-
    sigma (enum, &block) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 324
    def sigma enum, &block
      enum = enum.map(&block) if block
      enum.inject { |sum, n| sum + n }
    end
    ```

    Enumerates over `enum` mapping `block` if given, returning the sum of the result. Eg:

    ``` ruby
    sigma([1, 2, 3])                # => 1 + 2 + 3 => 6
    sigma([1, 2, 3]) { |n| n ** 2 } # => 1 + 4 + 9 => 14
    ```
- name: Minitest::Benchmark#validation_for_fit
  id: minitest/benchmark#method-i-validation_for_fit
  summary: Returns a proc that calls the specified fit method and asserts that the error is within a tolerable threshold
  belongs_to: Minitest::Benchmark
  description: "validation_for_fit (msg, threshold) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 333\ndef validation_for_fit msg, threshold\n  proc do |range, times|\n    a, b, rr = send \"fit_#{msg}\", range, times\n    assert_operator rr, :>=, threshold\n    [a, b, rr]\n  end\nend\n```\n\nReturns a proc that calls the specified fit method and asserts that the error is within a tolerable threshold.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Benchmark.html](https://docs.seattlerb.org/minitest/Minitest/Benchmark.html)"
- name: Minitest::Benchmark::bench_exp
  id: minitest/benchmark#method-c-bench_exp
  summary: Returns a set of ranges stepped exponentially from min to max by powers of base
  belongs_to: Minitest::Benchmark
  description: |-
    bench_exp (min, max, base = 10) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 35
    def self.bench_exp min, max, base = 10
      min = (Math.log10(min) / Math.log10(base)).to_i
      max = (Math.log10(max) / Math.log10(base)).to_i

      (min..max).map { |m| base ** m }.to_a
    end
    ```

    Returns a set of ranges stepped exponentially from `min` to `max` by powers of `base`. Eg:

    ``` ruby
    bench_exp(2, 16, 2) # => [2, 4, 8, 16]
    ```
- name: Minitest::Benchmark::bench_linear
  id: minitest/benchmark#method-c-bench_linear
  summary: Returns a set of ranges stepped linearly from min to max by step
  belongs_to: Minitest::Benchmark
  description: |-
    bench_linear (min, max, step = 10) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 48
    def self.bench_linear min, max, step = 10
      (min..max).step(step).to_a
    rescue LocalJumpError # 1.8.6
      r = []; (min..max).step(step) { |n| r << n }; r
    end
    ```

    Returns a set of ranges stepped linearly from `min` to `max` by `step`. Eg:

    ``` ruby
    bench_linear(20, 40, 10) # => [20, 30, 40]
    ```
- name: Minitest::Benchmark::bench_range
  id: minitest/benchmark#method-c-bench_range
  summary: Specifies the ranges used for benchmarking for that class
  belongs_to: Minitest::Benchmark
  description: |-
    bench_range () Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 61
    def self.bench_range
      bench_exp 1, 10_000
    end
    ```

    Specifies the ranges used for benchmarking for that class. Defaults to exponential growth from 1 to 10k by powers of 10. Override if you need different ranges for your benchmarks.

    See also: [`::bench_exp`](benchmark#method-c-bench_exp) and [`::bench_linear`](benchmark#method-c-bench_linear).

    ### Public Instance Methods
- name: Minitest::BenchSpec
  id: minitest/benchspec
  summary: The spec version of Minitest::Benchmark
  description: "# class Minitest::BenchSpec\n\nParent:  \n[Minitest::Benchmark](benchmark)\n\nThe spec version of [`Minitest::Benchmark`](benchmark).\n\n### Public Class Methods\n\nbench(name, &block) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 357\ndef self.bench name, &block\n  define_method \"bench_#{name.gsub(/\\W+/, \"_\")}\", &block\nend\n```\n\nThis is used to define a new benchmark method. You usually don’t use this directly and is intended for those needing to write new performance curve fits (eg: you need a specific polynomial fit).\n\nSee [`::bench_performance_linear`](benchspec#method-c-bench_performance_linear) for an example of how to use this.\n\nbench_performance_constant(name, threshold = 0.99, &work) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 401\ndef self.bench_performance_constant name, threshold = 0.99, &work\n  bench name do\n    assert_performance_constant threshold, &work\n  end\nend\n```\n\nCreate a benchmark that verifies that the performance is constant.\n\n``` ruby\ndescribe \"my class Bench\" do\n  bench_performance_constant \"zoom_algorithm!\" do |n|\n    @obj.zoom_algorithm!(n)\n  end\nend\n```\n\nbench_performance_exponential(name, threshold = 0.99, &work) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 416\ndef self.bench_performance_exponential name, threshold = 0.99, &work\n  bench name do\n    assert_performance_exponential threshold, &work\n  end\nend\n```\n\nCreate a benchmark that verifies that the performance is exponential.\n\n``` ruby\ndescribe \"my class Bench\" do\n  bench_performance_exponential \"algorithm\" do |n|\n    @obj.algorithm(n)\n  end\nend\n```\n\nbench_performance_linear(name, threshold = 0.99, &work) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 386\ndef self.bench_performance_linear name, threshold = 0.99, &work\n  bench name do\n    assert_performance_linear threshold, &work\n  end\nend\n```\n\nCreate a benchmark that verifies that the performance is linear.\n\n``` ruby\ndescribe \"my class Bench\" do\n  bench_performance_linear \"fast_algorithm\", 0.9999 do |n|\n    @obj.fast_algorithm(n)\n  end\nend\n```\n\nbench_performance_logarithmic(name, threshold = 0.99, &work) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 432\ndef self.bench_performance_logarithmic name, threshold = 0.99, &work\n  bench name do\n    assert_performance_logarithmic threshold, &work\n  end\nend\n```\n\nCreate a benchmark that verifies that the performance is logarithmic.\n\n``` ruby\ndescribe \"my class Bench\" do\n  bench_performance_logarithmic \"algorithm\" do |n|\n    @obj.algorithm(n)\n  end\nend\n```\n\nbench_performance_power(name, threshold = 0.99, &work) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 447\ndef self.bench_performance_power name, threshold = 0.99, &work\n  bench name do\n    assert_performance_power threshold, &work\n  end\nend\n```\n\nCreate a benchmark that verifies that the performance is power.\n\n``` ruby\ndescribe \"my class Bench\" do\n  bench_performance_power \"algorithm\" do |n|\n    @obj.algorithm(n)\n  end\nend\n```\n\nbench_range(&block) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 370\ndef self.bench_range &block\n  return super unless block\n\n  meta = (class << self; self; end)\n  meta.send :define_method, \"bench_range\", &block\nend\n```\n\nSpecifies the ranges used for benchmarking for that class.\n\n``` ruby\nbench_range do\n  bench_exp(2, 16, 2)\nend\n```\n\nSee Minitest::Benchmark#bench_range for more details.\n\nCalls superclass method [`Minitest::Benchmark::bench_range`](benchmark#method-c-bench_range)\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/BenchSpec.html](https://docs.seattlerb.org/minitest/Minitest/BenchSpec.html)"
- name: Minitest::BenchSpec::bench
  id: minitest/benchspec#method-c-bench
  summary: This is used to define a new benchmark method
  belongs_to: Minitest::BenchSpec
  description: |-
    bench (name, &block) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 357
    def self.bench name, &block
      define_method "bench_#{name.gsub(/\W+/, "_")}", &block
    end
    ```

    This is used to define a new benchmark method. You usually don’t use this directly and is intended for those needing to write new performance curve fits (eg: you need a specific polynomial fit).

    See [`::bench_performance_linear`](benchspec#method-c-bench_performance_linear) for an example of how to use this.
- name: Minitest::BenchSpec::bench_performance_constant
  id: minitest/benchspec#method-c-bench_performance_constant
  summary: Create a benchmark that verifies that the performance is constant
  belongs_to: Minitest::BenchSpec
  description: |-
    bench_performance_constant (name, threshold = 0.99, &work) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 401
    def self.bench_performance_constant name, threshold = 0.99, &work
      bench name do
        assert_performance_constant threshold, &work
      end
    end
    ```

    Create a benchmark that verifies that the performance is constant.

    ``` ruby
    describe "my class Bench" do
      bench_performance_constant "zoom_algorithm!" do |n|
        @obj.zoom_algorithm!(n)
      end
    end
    ```
- name: Minitest::BenchSpec::bench_performance_exponential
  id: minitest/benchspec#method-c-bench_performance_exponential
  summary: Create a benchmark that verifies that the performance is exponential
  belongs_to: Minitest::BenchSpec
  description: |-
    bench_performance_exponential (name, threshold = 0.99, &work) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 416
    def self.bench_performance_exponential name, threshold = 0.99, &work
      bench name do
        assert_performance_exponential threshold, &work
      end
    end
    ```

    Create a benchmark that verifies that the performance is exponential.

    ``` ruby
    describe "my class Bench" do
      bench_performance_exponential "algorithm" do |n|
        @obj.algorithm(n)
      end
    end
    ```
- name: Minitest::BenchSpec::bench_performance_linear
  id: minitest/benchspec#method-c-bench_performance_linear
  summary: Create a benchmark that verifies that the performance is linear
  belongs_to: Minitest::BenchSpec
  description: |-
    bench_performance_linear (name, threshold = 0.99, &work) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 386
    def self.bench_performance_linear name, threshold = 0.99, &work
      bench name do
        assert_performance_linear threshold, &work
      end
    end
    ```

    Create a benchmark that verifies that the performance is linear.

    ``` ruby
    describe "my class Bench" do
      bench_performance_linear "fast_algorithm", 0.9999 do |n|
        @obj.fast_algorithm(n)
      end
    end
    ```
- name: Minitest::BenchSpec::bench_performance_logarithmic
  id: minitest/benchspec#method-c-bench_performance_logarithmic
  summary: Create a benchmark that verifies that the performance is logarithmic
  belongs_to: Minitest::BenchSpec
  description: |-
    bench_performance_logarithmic (name, threshold = 0.99, &work) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 432
    def self.bench_performance_logarithmic name, threshold = 0.99, &work
      bench name do
        assert_performance_logarithmic threshold, &work
      end
    end
    ```

    Create a benchmark that verifies that the performance is logarithmic.

    ``` ruby
    describe "my class Bench" do
      bench_performance_logarithmic "algorithm" do |n|
        @obj.algorithm(n)
      end
    end
    ```
- name: Minitest::BenchSpec::bench_performance_power
  id: minitest/benchspec#method-c-bench_performance_power
  summary: Create a benchmark that verifies that the performance is power
  belongs_to: Minitest::BenchSpec
  description: |-
    bench_performance_power (name, threshold = 0.99, &work) Show source

    ``` ruby
    # File lib/minitest/benchmark.rb, line 447
    def self.bench_performance_power name, threshold = 0.99, &work
      bench name do
        assert_performance_power threshold, &work
      end
    end
    ```

    Create a benchmark that verifies that the performance is power.

    ``` ruby
    describe "my class Bench" do
      bench_performance_power "algorithm" do |n|
        @obj.algorithm(n)
      end
    end
    ```
- name: Minitest::BenchSpec::bench_range
  id: minitest/benchspec#method-c-bench_range
  summary: Specifies the ranges used for benchmarking for that class
  belongs_to: Minitest::BenchSpec
  description: "bench_range (&block) Show source\n\n``` ruby\n# File lib/minitest/benchmark.rb, line 370\ndef self.bench_range &block\n  return super unless block\n\n  meta = (class << self; self; end)\n  meta.send :define_method, \"bench_range\", &block\nend\n```\n\nSpecifies the ranges used for benchmarking for that class.\n\n``` ruby\nbench_range do\n  bench_exp(2, 16, 2)\nend\n```\n\nSee Minitest::Benchmark#bench_range for more details.\n\nCalls superclass method [`Minitest::Benchmark::bench_range`](benchmark#method-c-bench_range)\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/BenchSpec.html](https://docs.seattlerb.org/minitest/Minitest/BenchSpec.html)"
- name: Minitest::CompositeReporter
  id: minitest/compositereporter
  summary: Dispatch to multiple reporters as one
  description: "# class Minitest::CompositeReporter\n\nParent:  \n[Minitest::AbstractReporter](abstractreporter)\n\nDispatch to multiple reporters as one.\n\n### Attributes\n\nreporters\\[RW\\]\n\nThe list of reporters to dispatch to.\n\n### Public Instance Methods\n\n\\<\\<(reporter) Show source\n\n``` ruby\n# File lib/minitest.rb, line 905\ndef << reporter\n  self.reporters << reporter\nend\n```\n\nAdd another reporter to the mix.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/CompositeReporter.html](https://docs.seattlerb.org/minitest/Minitest/CompositeReporter.html)"
- name: Minitest::CompositeReporter#<<
  id: minitest/compositereporter#method-i-3C-3C
  summary: Add another reporter to the mix
  belongs_to: Minitest::CompositeReporter
  description: "\\<\\< (reporter) Show source\n\n``` ruby\n# File lib/minitest.rb, line 905\ndef << reporter\n  self.reporters << reporter\nend\n```\n\nAdd another reporter to the mix.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/CompositeReporter.html](https://docs.seattlerb.org/minitest/Minitest/CompositeReporter.html)"
- name: Minitest::CompositeReporter#reporters
  id: minitest/compositereporter#attribute-i-reporters
  summary: The list of reporters to dispatch to
  belongs_to: Minitest::CompositeReporter
  description: |-
    reporters \[RW\]

    The list of reporters to dispatch to.

    ### Public Instance Methods
- name: Minitest::Expectations
  id: minitest/expectations
  summary: Please note, because of the way that expectations are implemented, all expectations (eg must_equal) are dependent upon a thread local variable :current_spec
  description: "# module Minitest::Expectations\n\nIt’s where you hide your “assertions”.\n\nPlease note, because of the way that expectations are implemented, all expectations (eg [`must_equal`](expectations#method-i-must_equal)) are dependent upon a thread local variable `:current_spec`. If your specs rely on mixing threads into the specs themselves, you’re better off using assertions or the new \\_(value) wrapper. For example:\n\n``` ruby\nit \"should still work in threads\" do\n  my_threaded_thingy do\n    (1+1).must_equal 2                  # bad\n    assert_equal 2, 1+1                 # good\n    _(1 + 1).must_equal 2               # good\n    value(1 + 1).must_equal 2           # good, also #expect\n    _ { 1 + \"1\" }.must_raise TypeError  # good\n  end\nend\n```\n\n### Public Instance Methods\n\nmust_be() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 116\ninfect_an_assertion :assert_operator, :must_be, :reverse\n```\n\nSee [`Minitest::Assertions#assert_operator`](assertions#method-i-assert_operator)\n\n``` ruby\n_(n).must_be :<=, 42\n```\n\nThis can also do predicates:\n\n``` ruby\n_(str).must_be :empty?\n```\n\nmust_be_close_to() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 47\ninfect_an_assertion :assert_in_delta, :must_be_close_to\n```\n\nSee [`Minitest::Assertions#assert_in_delta`](assertions#method-i-assert_in_delta)\n\n    _(n).must_be_close_to m [, delta]\n\nmust_be_empty() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 29\ninfect_an_assertion :assert_empty, :must_be_empty, :unary\n```\n\nSee [`Minitest::Assertions#assert_empty`](assertions#method-i-assert_empty).\n\n``` ruby\n_(collection).must_be_empty\n```\n\nmust_be_instance_of() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 76\ninfect_an_assertion :assert_instance_of, :must_be_instance_of\n```\n\nSee [`Minitest::Assertions#assert_instance_of`](assertions#method-i-assert_instance_of)\n\n``` ruby\n_(obj).must_be_instance_of klass\n```\n\nmust_be_kind_of() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 85\ninfect_an_assertion :assert_kind_of, :must_be_kind_of\n```\n\nSee [`Minitest::Assertions#assert_kind_of`](assertions#method-i-assert_kind_of)\n\n``` ruby\n_(obj).must_be_kind_of mod\n```\n\nmust_be_nil() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 103\ninfect_an_assertion :assert_nil, :must_be_nil, :unary\n```\n\nSee [`Minitest::Assertions#assert_nil`](assertions#method-i-assert_nil)\n\n``` ruby\n_(obj).must_be_nil\n```\n\nmust_be_same_as() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 161\ninfect_an_assertion :assert_same, :must_be_same_as\n```\n\nSee [`Minitest::Assertions#assert_same`](assertions#method-i-assert_same)\n\n``` ruby\n_(a).must_be_same_as b\n```\n\nmust_be_silent() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 170\ninfect_an_assertion :assert_silent, :must_be_silent, :block\n```\n\nSee [`Minitest::Assertions#assert_silent`](assertions#method-i-assert_silent)\n\n    _ { ... }.must_be_silent\n\nmust_be_within_epsilon() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 58\ninfect_an_assertion :assert_in_epsilon, :must_be_within_epsilon\n```\n\nSee [`Minitest::Assertions#assert_in_epsilon`](assertions#method-i-assert_in_epsilon)\n\n    _(n).must_be_within_epsilon m [, epsilon]\n\nmust_equal() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 38\ninfect_an_assertion :assert_equal, :must_equal\n```\n\nSee [`Minitest::Assertions#assert_equal`](assertions#method-i-assert_equal)\n\n``` ruby\n_(a).must_equal b\n```\n\nmust_include() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 67\ninfect_an_assertion :assert_includes, :must_include, :reverse\n```\n\nSee [`Minitest::Assertions#assert_includes`](assertions#method-i-assert_includes)\n\n``` ruby\n_(collection).must_include obj\n```\n\nmust_match() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 94\ninfect_an_assertion :assert_match, :must_match\n```\n\nSee [`Minitest::Assertions#assert_match`](assertions#method-i-assert_match)\n\n``` ruby\n_(a).must_match b\n```\n\nmust_output() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 125\ninfect_an_assertion :assert_output, :must_output, :block\n```\n\nSee [`Minitest::Assertions#assert_output`](assertions#method-i-assert_output)\n\n    _ { ... }.must_output out_or_nil [, err]\n\nmust_pattern_match() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 134\ninfect_an_assertion :assert_pattern, :must_pattern_match, :block\n```\n\nSee Minitest::Assertions#assert_pattern_match\n\n    _ { ... }.must_pattern_match [...]\n\nmust_raise() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 143\ninfect_an_assertion :assert_raises, :must_raise, :block\n```\n\nSee [`Minitest::Assertions#assert_raises`](assertions#method-i-assert_raises)\n\n    _ { ... }.must_raise exception\n\nmust_respond_to() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 152\ninfect_an_assertion :assert_respond_to, :must_respond_to, :reverse\n```\n\nSee [`Minitest::Assertions#assert_respond_to`](assertions#method-i-assert_respond_to)\n\n``` ruby\n_(obj).must_respond_to msg\n```\n\nmust_throw() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 179\ninfect_an_assertion :assert_throws, :must_throw, :block\n```\n\nSee [`Minitest::Assertions#assert_throws`](assertions#method-i-assert_throws)\n\n    _ { ... }.must_throw sym\n\npath_must_exist() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 188\ninfect_an_assertion :assert_path_exists, :path_must_exist, :unary\n```\n\nSee [`Minitest::Assertions#assert_path_exists`](assertions#method-i-assert_path_exists)\n\n``` ruby\n_(some_path).path_must_exist\n```\n\npath_wont_exist() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 197\ninfect_an_assertion :refute_path_exists, :path_wont_exist, :unary\n```\n\nSee [`Minitest::Assertions#refute_path_exists`](assertions#method-i-refute_path_exists)\n\n``` ruby\n_(some_path).path_wont_exist\n```\n\nwont_be() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 293\ninfect_an_assertion :refute_operator, :wont_be, :reverse\n```\n\nSee [`Minitest::Assertions#refute_operator`](assertions#method-i-refute_operator)\n\n``` ruby\n_(n).wont_be :<=, 42\n```\n\nThis can also do predicates:\n\n``` ruby\nstr.wont_be :empty?\n```\n\nwont_be_close_to() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 224\ninfect_an_assertion :refute_in_delta, :wont_be_close_to\n```\n\nSee [`Minitest::Assertions#refute_in_delta`](assertions#method-i-refute_in_delta)\n\n    _(n).wont_be_close_to m [, delta]\n\nwont_be_empty() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 206\ninfect_an_assertion :refute_empty, :wont_be_empty, :unary\n```\n\nSee [`Minitest::Assertions#refute_empty`](assertions#method-i-refute_empty)\n\n``` ruby\n_(collection).wont_be_empty\n```\n\nwont_be_instance_of() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 253\ninfect_an_assertion :refute_instance_of, :wont_be_instance_of\n```\n\nSee [`Minitest::Assertions#refute_instance_of`](assertions#method-i-refute_instance_of)\n\n``` ruby\n_(obj).wont_be_instance_of klass\n```\n\nwont_be_kind_of() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 262\ninfect_an_assertion :refute_kind_of, :wont_be_kind_of\n```\n\nSee [`Minitest::Assertions#refute_kind_of`](assertions#method-i-refute_kind_of)\n\n``` ruby\n_(obj).wont_be_kind_of mod\n```\n\nwont_be_nil() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 280\ninfect_an_assertion :refute_nil, :wont_be_nil, :unary\n```\n\nSee [`Minitest::Assertions#refute_nil`](assertions#method-i-refute_nil)\n\n``` ruby\n_(obj).wont_be_nil\n```\n\nwont_be_same_as() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 320\ninfect_an_assertion :refute_same, :wont_be_same_as\n```\n\nSee [`Minitest::Assertions#refute_same`](assertions#method-i-refute_same)\n\n``` ruby\n_(a).wont_be_same_as b\n```\n\nwont_be_within_epsilon() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 235\ninfect_an_assertion :refute_in_epsilon, :wont_be_within_epsilon\n```\n\nSee [`Minitest::Assertions#refute_in_epsilon`](assertions#method-i-refute_in_epsilon)\n\n    _(n).wont_be_within_epsilon m [, epsilon]\n\nwont_equal() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 215\ninfect_an_assertion :refute_equal, :wont_equal\n```\n\nSee [`Minitest::Assertions#refute_equal`](assertions#method-i-refute_equal)\n\n``` ruby\n_(a).wont_equal b\n```\n\nwont_include() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 244\ninfect_an_assertion :refute_includes, :wont_include, :reverse\n```\n\nSee [`Minitest::Assertions#refute_includes`](assertions#method-i-refute_includes)\n\n``` ruby\n_(collection).wont_include obj\n```\n\nwont_match() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 271\ninfect_an_assertion :refute_match, :wont_match\n```\n\nSee [`Minitest::Assertions#refute_match`](assertions#method-i-refute_match)\n\n``` ruby\n_(a).wont_match b\n```\n\nwont_pattern_match() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 302\ninfect_an_assertion :refute_pattern, :wont_pattern_match, :block\n```\n\nSee Minitest::Assertions#refute_pattern_match\n\n    _ { ... }.wont_pattern_match [...]\n\nwont_respond_to() Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 311\ninfect_an_assertion :refute_respond_to, :wont_respond_to, :reverse\n```\n\nSee [`Minitest::Assertions#refute_respond_to`](assertions#method-i-refute_respond_to)\n\n``` ruby\n_(obj).wont_respond_to msg\n```\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Expectations.html](https://docs.seattlerb.org/minitest/Minitest/Expectations.html)"
- name: Minitest::Expectations#must_be
  id: minitest/expectations#method-i-must_be
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_be () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 116
    infect_an_assertion :assert_operator, :must_be, :reverse
    ```

    See [`Minitest::Assertions#assert_operator`](assertions#method-i-assert_operator)

    ``` ruby
    _(n).must_be :<=, 42
    ```

    This can also do predicates:

    ``` ruby
    _(str).must_be :empty?
    ```
- name: Minitest::Expectations#must_be_close_to
  id: minitest/expectations#method-i-must_be_close_to
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_be_close_to () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 47
    infect_an_assertion :assert_in_delta, :must_be_close_to
    ```

    See [`Minitest::Assertions#assert_in_delta`](assertions#method-i-assert_in_delta)

        _(n).must_be_close_to m [, delta]
- name: Minitest::Expectations#must_be_empty
  id: minitest/expectations#method-i-must_be_empty
  summary: See Minitest::Assertions#assert_empty
  belongs_to: Minitest::Expectations
  description: |-
    must_be_empty () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 29
    infect_an_assertion :assert_empty, :must_be_empty, :unary
    ```

    See [`Minitest::Assertions#assert_empty`](assertions#method-i-assert_empty).

    ``` ruby
    _(collection).must_be_empty
    ```
- name: Minitest::Expectations#must_be_instance_of
  id: minitest/expectations#method-i-must_be_instance_of
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_be_instance_of () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 76
    infect_an_assertion :assert_instance_of, :must_be_instance_of
    ```

    See [`Minitest::Assertions#assert_instance_of`](assertions#method-i-assert_instance_of)

    ``` ruby
    _(obj).must_be_instance_of klass
    ```
- name: Minitest::Expectations#must_be_kind_of
  id: minitest/expectations#method-i-must_be_kind_of
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_be_kind_of () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 85
    infect_an_assertion :assert_kind_of, :must_be_kind_of
    ```

    See [`Minitest::Assertions#assert_kind_of`](assertions#method-i-assert_kind_of)

    ``` ruby
    _(obj).must_be_kind_of mod
    ```
- name: Minitest::Expectations#must_be_nil
  id: minitest/expectations#method-i-must_be_nil
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_be_nil () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 103
    infect_an_assertion :assert_nil, :must_be_nil, :unary
    ```

    See [`Minitest::Assertions#assert_nil`](assertions#method-i-assert_nil)

    ``` ruby
    _(obj).must_be_nil
    ```
- name: Minitest::Expectations#must_be_same_as
  id: minitest/expectations#method-i-must_be_same_as
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_be_same_as () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 161
    infect_an_assertion :assert_same, :must_be_same_as
    ```

    See [`Minitest::Assertions#assert_same`](assertions#method-i-assert_same)

    ``` ruby
    _(a).must_be_same_as b
    ```
- name: Minitest::Expectations#must_be_silent
  id: minitest/expectations#method-i-must_be_silent
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_be_silent () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 170
    infect_an_assertion :assert_silent, :must_be_silent, :block
    ```

    See [`Minitest::Assertions#assert_silent`](assertions#method-i-assert_silent)

        _ { ... }.must_be_silent
- name: Minitest::Expectations#must_be_within_epsilon
  id: minitest/expectations#method-i-must_be_within_epsilon
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_be_within_epsilon () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 58
    infect_an_assertion :assert_in_epsilon, :must_be_within_epsilon
    ```

    See [`Minitest::Assertions#assert_in_epsilon`](assertions#method-i-assert_in_epsilon)

        _(n).must_be_within_epsilon m [, epsilon]
- name: Minitest::Expectations#must_equal
  id: minitest/expectations#method-i-must_equal
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_equal () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 38
    infect_an_assertion :assert_equal, :must_equal
    ```

    See [`Minitest::Assertions#assert_equal`](assertions#method-i-assert_equal)

    ``` ruby
    _(a).must_equal b
    ```
- name: Minitest::Expectations#must_include
  id: minitest/expectations#method-i-must_include
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_include () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 67
    infect_an_assertion :assert_includes, :must_include, :reverse
    ```

    See [`Minitest::Assertions#assert_includes`](assertions#method-i-assert_includes)

    ``` ruby
    _(collection).must_include obj
    ```
- name: Minitest::Expectations#must_match
  id: minitest/expectations#method-i-must_match
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_match () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 94
    infect_an_assertion :assert_match, :must_match
    ```

    See [`Minitest::Assertions#assert_match`](assertions#method-i-assert_match)

    ``` ruby
    _(a).must_match b
    ```
- name: Minitest::Expectations#must_output
  id: minitest/expectations#method-i-must_output
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_output () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 125
    infect_an_assertion :assert_output, :must_output, :block
    ```

    See [`Minitest::Assertions#assert_output`](assertions#method-i-assert_output)

        _ { ... }.must_output out_or_nil [, err]
- name: Minitest::Expectations#must_pattern_match
  id: minitest/expectations#method-i-must_pattern_match
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_pattern_match () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 134
    infect_an_assertion :assert_pattern, :must_pattern_match, :block
    ```

    See Minitest::Assertions#assert_pattern_match

        _ { ... }.must_pattern_match [...]
- name: Minitest::Expectations#must_raise
  id: minitest/expectations#method-i-must_raise
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_raise () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 143
    infect_an_assertion :assert_raises, :must_raise, :block
    ```

    See [`Minitest::Assertions#assert_raises`](assertions#method-i-assert_raises)

        _ { ... }.must_raise exception
- name: Minitest::Expectations#must_respond_to
  id: minitest/expectations#method-i-must_respond_to
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_respond_to () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 152
    infect_an_assertion :assert_respond_to, :must_respond_to, :reverse
    ```

    See [`Minitest::Assertions#assert_respond_to`](assertions#method-i-assert_respond_to)

    ``` ruby
    _(obj).must_respond_to msg
    ```
- name: Minitest::Expectations#must_throw
  id: minitest/expectations#method-i-must_throw
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    must_throw () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 179
    infect_an_assertion :assert_throws, :must_throw, :block
    ```

    See [`Minitest::Assertions#assert_throws`](assertions#method-i-assert_throws)

        _ { ... }.must_throw sym
- name: Minitest::Expectations#path_must_exist
  id: minitest/expectations#method-i-path_must_exist
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    path_must_exist () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 188
    infect_an_assertion :assert_path_exists, :path_must_exist, :unary
    ```

    See [`Minitest::Assertions#assert_path_exists`](assertions#method-i-assert_path_exists)

    ``` ruby
    _(some_path).path_must_exist
    ```
- name: Minitest::Expectations#path_wont_exist
  id: minitest/expectations#method-i-path_wont_exist
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    path_wont_exist () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 197
    infect_an_assertion :refute_path_exists, :path_wont_exist, :unary
    ```

    See [`Minitest::Assertions#refute_path_exists`](assertions#method-i-refute_path_exists)

    ``` ruby
    _(some_path).path_wont_exist
    ```
- name: Minitest::Expectations#wont_be
  id: minitest/expectations#method-i-wont_be
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    wont_be () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 293
    infect_an_assertion :refute_operator, :wont_be, :reverse
    ```

    See [`Minitest::Assertions#refute_operator`](assertions#method-i-refute_operator)

    ``` ruby
    _(n).wont_be :<=, 42
    ```

    This can also do predicates:

    ``` ruby
    str.wont_be :empty?
    ```
- name: Minitest::Expectations#wont_be_close_to
  id: minitest/expectations#method-i-wont_be_close_to
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    wont_be_close_to () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 224
    infect_an_assertion :refute_in_delta, :wont_be_close_to
    ```

    See [`Minitest::Assertions#refute_in_delta`](assertions#method-i-refute_in_delta)

        _(n).wont_be_close_to m [, delta]
- name: Minitest::Expectations#wont_be_empty
  id: minitest/expectations#method-i-wont_be_empty
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    wont_be_empty () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 206
    infect_an_assertion :refute_empty, :wont_be_empty, :unary
    ```

    See [`Minitest::Assertions#refute_empty`](assertions#method-i-refute_empty)

    ``` ruby
    _(collection).wont_be_empty
    ```
- name: Minitest::Expectations#wont_be_instance_of
  id: minitest/expectations#method-i-wont_be_instance_of
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    wont_be_instance_of () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 253
    infect_an_assertion :refute_instance_of, :wont_be_instance_of
    ```

    See [`Minitest::Assertions#refute_instance_of`](assertions#method-i-refute_instance_of)

    ``` ruby
    _(obj).wont_be_instance_of klass
    ```
- name: Minitest::Expectations#wont_be_kind_of
  id: minitest/expectations#method-i-wont_be_kind_of
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    wont_be_kind_of () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 262
    infect_an_assertion :refute_kind_of, :wont_be_kind_of
    ```

    See [`Minitest::Assertions#refute_kind_of`](assertions#method-i-refute_kind_of)

    ``` ruby
    _(obj).wont_be_kind_of mod
    ```
- name: Minitest::Expectations#wont_be_nil
  id: minitest/expectations#method-i-wont_be_nil
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    wont_be_nil () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 280
    infect_an_assertion :refute_nil, :wont_be_nil, :unary
    ```

    See [`Minitest::Assertions#refute_nil`](assertions#method-i-refute_nil)

    ``` ruby
    _(obj).wont_be_nil
    ```
- name: Minitest::Expectations#wont_be_same_as
  id: minitest/expectations#method-i-wont_be_same_as
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    wont_be_same_as () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 320
    infect_an_assertion :refute_same, :wont_be_same_as
    ```

    See [`Minitest::Assertions#refute_same`](assertions#method-i-refute_same)

    ``` ruby
    _(a).wont_be_same_as b
    ```
- name: Minitest::Expectations#wont_be_within_epsilon
  id: minitest/expectations#method-i-wont_be_within_epsilon
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    wont_be_within_epsilon () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 235
    infect_an_assertion :refute_in_epsilon, :wont_be_within_epsilon
    ```

    See [`Minitest::Assertions#refute_in_epsilon`](assertions#method-i-refute_in_epsilon)

        _(n).wont_be_within_epsilon m [, epsilon]
- name: Minitest::Expectations#wont_equal
  id: minitest/expectations#method-i-wont_equal
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    wont_equal () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 215
    infect_an_assertion :refute_equal, :wont_equal
    ```

    See [`Minitest::Assertions#refute_equal`](assertions#method-i-refute_equal)

    ``` ruby
    _(a).wont_equal b
    ```
- name: Minitest::Expectations#wont_include
  id: minitest/expectations#method-i-wont_include
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    wont_include () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 244
    infect_an_assertion :refute_includes, :wont_include, :reverse
    ```

    See [`Minitest::Assertions#refute_includes`](assertions#method-i-refute_includes)

    ``` ruby
    _(collection).wont_include obj
    ```
- name: Minitest::Expectations#wont_match
  id: minitest/expectations#method-i-wont_match
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    wont_match () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 271
    infect_an_assertion :refute_match, :wont_match
    ```

    See [`Minitest::Assertions#refute_match`](assertions#method-i-refute_match)

    ``` ruby
    _(a).wont_match b
    ```
- name: Minitest::Expectations#wont_pattern_match
  id: minitest/expectations#method-i-wont_pattern_match
  summary: null
  belongs_to: Minitest::Expectations
  description: |-
    wont_pattern_match () Show source

    ``` c
    # File lib/minitest/expectations.rb, line 302
    infect_an_assertion :refute_pattern, :wont_pattern_match, :block
    ```

    See Minitest::Assertions#refute_pattern_match

        _ { ... }.wont_pattern_match [...]
- name: Minitest::Expectations#wont_respond_to
  id: minitest/expectations#method-i-wont_respond_to
  summary: © Ryan Davis, seattle.rb Licensed under the MIT License
  belongs_to: Minitest::Expectations
  description: "wont_respond_to () Show source\n\n``` c\n# File lib/minitest/expectations.rb, line 311\ninfect_an_assertion :refute_respond_to, :wont_respond_to, :reverse\n```\n\nSee [`Minitest::Assertions#refute_respond_to`](assertions#method-i-refute_respond_to)\n\n``` ruby\n_(obj).wont_respond_to msg\n```\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Expectations.html](https://docs.seattlerb.org/minitest/Minitest/Expectations.html)"
- name: Minitest::Guard
  id: minitest/guard
  summary: Provides a simple set of guards that you can use in your tests to skip execution if it is not applicable
  description: "# module Minitest::Guard\n\nProvides a simple set of guards that you can use in your tests to skip execution if it is not applicable. These methods are mixed into [`Test`](test) as both instance and class methods so you can use them inside or outside of the test methods.\n\n``` ruby\ndef test_something_for_mri\n  skip \"bug 1234\"  if jruby?\n  # ...\nend\n\nif windows? then\n  # ... lots of test methods ...\nend\n```\n\n### Public Instance Methods\n\njruby?(platform = RUBY_PLATFORM) Show source\n\n``` ruby\n# File lib/minitest.rb, line 1019\ndef jruby? platform = RUBY_PLATFORM\n  \"java\" == platform\nend\n```\n\nIs this running on jruby?\n\nmaglev?(platform = defined?(RUBY_ENGINE) && RUBY_ENGINE) Show source\n\n``` ruby\n# File lib/minitest.rb, line 1026\ndef maglev? platform = defined?(RUBY_ENGINE) && RUBY_ENGINE\n  where = Minitest.filter_backtrace(caller).first\n  where = where.split(/:in /, 2).first # clean up noise\n  warn \"DEPRECATED: `maglev?` called from #{where}. This will fail in Minitest 6.\"\n  \"maglev\" == platform\nend\n```\n\nIs this running on maglev?\n\nmri?(platform = RUBY_DESCRIPTION) Show source\n\n``` ruby\n# File lib/minitest.rb, line 1036\ndef mri? platform = RUBY_DESCRIPTION\n  /^ruby/ =~ platform\nend\n```\n\nIs this running on mri?\n\nosx?(platform = RUBY_PLATFORM) Show source\n\n``` ruby\n# File lib/minitest.rb, line 1043\ndef osx? platform = RUBY_PLATFORM\n  /darwin/ =~ platform\nend\n```\n\nIs this running on macOS?\n\nrubinius?(platform = defined?(RUBY_ENGINE) && RUBY_ENGINE) Show source\n\n``` ruby\n# File lib/minitest.rb, line 1050\ndef rubinius? platform = defined?(RUBY_ENGINE) && RUBY_ENGINE\n  where = Minitest.filter_backtrace(caller).first\n  where = where.split(/:in /, 2).first # clean up noise\n  warn \"DEPRECATED: `rubinius?` called from #{where}. This will fail in Minitest 6.\"\n  \"rbx\" == platform\nend\n```\n\nIs this running on rubinius?\n\nwindows?(platform = RUBY_PLATFORM) Show source\n\n``` ruby\n# File lib/minitest.rb, line 1060\ndef windows? platform = RUBY_PLATFORM\n  /mswin|mingw/ =~ platform\nend\n```\n\nIs this running on windows?\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Guard.html](https://docs.seattlerb.org/minitest/Minitest/Guard.html)"
- name: Minitest::Guard#jruby?
  id: minitest/guard#method-i-jruby-3F
  summary: null
  belongs_to: Minitest::Guard
  description: |-
    jruby? (platform = RUBY_PLATFORM) Show source

    ``` ruby
    # File lib/minitest.rb, line 1019
    def jruby? platform = RUBY_PLATFORM
      "java" == platform
    end
    ```

    Is this running on jruby?
- name: Minitest::Guard#maglev?
  id: minitest/guard#method-i-maglev-3F
  summary: null
  belongs_to: Minitest::Guard
  description: |-
    maglev? (platform = defined?(RUBY_ENGINE) && RUBY_ENGINE) Show source

    ``` ruby
    # File lib/minitest.rb, line 1026
    def maglev? platform = defined?(RUBY_ENGINE) && RUBY_ENGINE
      where = Minitest.filter_backtrace(caller).first
      where = where.split(/:in /, 2).first # clean up noise
      warn "DEPRECATED: `maglev?` called from #{where}. This will fail in Minitest 6."
      "maglev" == platform
    end
    ```

    Is this running on maglev?
- name: Minitest::Guard#mri?
  id: minitest/guard#method-i-mri-3F
  summary: null
  belongs_to: Minitest::Guard
  description: |-
    mri? (platform = RUBY_DESCRIPTION) Show source

    ``` ruby
    # File lib/minitest.rb, line 1036
    def mri? platform = RUBY_DESCRIPTION
      /^ruby/ =~ platform
    end
    ```

    Is this running on mri?
- name: Minitest::Guard#osx?
  id: minitest/guard#method-i-osx-3F
  summary: null
  belongs_to: Minitest::Guard
  description: |-
    osx? (platform = RUBY_PLATFORM) Show source

    ``` ruby
    # File lib/minitest.rb, line 1043
    def osx? platform = RUBY_PLATFORM
      /darwin/ =~ platform
    end
    ```

    Is this running on macOS?
- name: Minitest::Guard#rubinius?
  id: minitest/guard#method-i-rubinius-3F
  summary: null
  belongs_to: Minitest::Guard
  description: |-
    rubinius? (platform = defined?(RUBY_ENGINE) && RUBY_ENGINE) Show source

    ``` ruby
    # File lib/minitest.rb, line 1050
    def rubinius? platform = defined?(RUBY_ENGINE) && RUBY_ENGINE
      where = Minitest.filter_backtrace(caller).first
      where = where.split(/:in /, 2).first # clean up noise
      warn "DEPRECATED: `rubinius?` called from #{where}. This will fail in Minitest 6."
      "rbx" == platform
    end
    ```

    Is this running on rubinius?
- name: Minitest::Guard#windows?
  id: minitest/guard#method-i-windows-3F
  summary: © Ryan Davis, seattle.rb Licensed under the MIT License
  belongs_to: Minitest::Guard
  description: "windows? (platform = RUBY_PLATFORM) Show source\n\n``` ruby\n# File lib/minitest.rb, line 1060\ndef windows? platform = RUBY_PLATFORM\n  /mswin|mingw/ =~ platform\nend\n```\n\nIs this running on windows?\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Guard.html](https://docs.seattlerb.org/minitest/Minitest/Guard.html)"
- name: Minitest::Mock
  id: minitest/mock
  summary: A simple and clean mock object framework
  description: "# class Minitest::Mock\n\nParent:  \n[Object](../object)\n\nA simple and clean mock object framework.\n\nAll mock objects are an instance of [`Mock`](mock)\n\n### Public Instance Methods\n\nexpect(name, retval, args = \\[\\], \\*\\*kwargs, &blk) Show source\n\n``` ruby\n# File lib/minitest/mock.rb, line 91\ndef expect name, retval, args = [], **kwargs, &blk\n  name = name.to_sym\n\n  if block_given?\n    raise ArgumentError, \"args ignored when block given\" unless args.empty?\n    raise ArgumentError, \"kwargs ignored when block given\" unless kwargs.empty?\n    @expected_calls[name] << { :retval => retval, :block => blk }\n  else\n    raise ArgumentError, \"args must be an array\" unless Array === args\n\n    if ENV[\"MT_KWARGS_HAC\\K\"] && (Hash === args.last ||\n                                  Hash ==  args.last) then\n      if kwargs.empty? then\n        kwargs = args.pop\n      else\n        unless @@KW_WARNED then\n          from = caller.first\n          warn \"Using MT_KWARGS_HAC\\K yet passing kwargs. From #{from}\"\n          @@KW_WARNED = true\n        end\n      end\n    end\n\n    @expected_calls[name] <<\n      { :retval => retval, :args => args, :kwargs => kwargs }\n  end\n  self\nend\n```\n\nExpect that method `name` is called, optionally with `args` (and `kwargs` or a `blk`), and returns `retval`.\n\n``` ruby\n@mock.expect(:meaning_of_life, 42)\n@mock.meaning_of_life # => 42\n\n@mock.expect(:do_something_with, true, [some_obj, true])\n@mock.do_something_with(some_obj, true) # => true\n\n@mock.expect(:do_something_else, true) do |a1, a2|\n  a1 == \"buggs\" && a2 == :bunny\nend\n```\n\n`args` is compared to the expected args using case equality (ie, the ‘===’ operator), allowing for less specific expectations.\n\n``` ruby\n@mock.expect(:uses_any_string, true, [String])\n@mock.uses_any_string(\"foo\") # => true\n@mock.verify  # => true\n\n@mock.expect(:uses_one_string, true, [\"foo\"])\n@mock.uses_one_string(\"bar\") # => raises MockExpectationError\n```\n\nIf a method will be called multiple times, specify a new expect for each one. They will be used in the order you define them.\n\n``` ruby\n@mock.expect(:ordinal_increment, 'first')\n@mock.expect(:ordinal_increment, 'second')\n\n@mock.ordinal_increment # => 'first'\n@mock.ordinal_increment # => 'second'\n@mock.ordinal_increment # => raises MockExpectationError \"No more expects available for :ordinal_increment\"\n```\n\nverify() Show source\n\n``` ruby\n# File lib/minitest/mock.rb, line 140\ndef verify\n  @expected_calls.each do |name, expected|\n    actual = @actual_calls.fetch(name, nil)\n    raise MockExpectationError, \"expected #{__call name, expected[0]}\" unless actual\n    raise MockExpectationError, \"expected #{__call name, expected[actual.size]}, got [#{__call name, actual}]\" if\n      actual.size < expected.size\n  end\n  true\nend\n```\n\nVerify that all methods were called as expected. Raises `MockExpectationError` if the mock object was not called as expected.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Mock.html](https://docs.seattlerb.org/minitest/Minitest/Mock.html)"
- name: Minitest::Mock#expect
  id: minitest/mock#method-i-expect
  summary: Expect that method name is called, optionally with args (and kwargs or a blk), and returns retval
  belongs_to: Minitest::Mock
  description: |-
    expect (name, retval, args = \[\], \*\*kwargs, &blk) Show source

    ``` ruby
    # File lib/minitest/mock.rb, line 91
    def expect name, retval, args = [], **kwargs, &blk
      name = name.to_sym

      if block_given?
        raise ArgumentError, "args ignored when block given" unless args.empty?
        raise ArgumentError, "kwargs ignored when block given" unless kwargs.empty?
        @expected_calls[name] << { :retval => retval, :block => blk }
      else
        raise ArgumentError, "args must be an array" unless Array === args

        if ENV["MT_KWARGS_HAC\K"] && (Hash === args.last ||
                                      Hash ==  args.last) then
          if kwargs.empty? then
            kwargs = args.pop
          else
            unless @@KW_WARNED then
              from = caller.first
              warn "Using MT_KWARGS_HAC\K yet passing kwargs. From #{from}"
              @@KW_WARNED = true
            end
          end
        end

        @expected_calls[name] <<
          { :retval => retval, :args => args, :kwargs => kwargs }
      end
      self
    end
    ```

    Expect that method `name` is called, optionally with `args` (and `kwargs` or a `blk`), and returns `retval`.

    ``` ruby
    @mock.expect(:meaning_of_life, 42)
    @mock.meaning_of_life # => 42

    @mock.expect(:do_something_with, true, [some_obj, true])
    @mock.do_something_with(some_obj, true) # => true

    @mock.expect(:do_something_else, true) do |a1, a2|
      a1 == "buggs" && a2 == :bunny
    end
    ```

    `args` is compared to the expected args using case equality (ie, the ‘===’ operator), allowing for less specific expectations.

    ``` ruby
    @mock.expect(:uses_any_string, true, [String])
    @mock.uses_any_string("foo") # => true
    @mock.verify  # => true

    @mock.expect(:uses_one_string, true, ["foo"])
    @mock.uses_one_string("bar") # => raises MockExpectationError
    ```

    If a method will be called multiple times, specify a new expect for each one. They will be used in the order you define them.

    ``` ruby
    @mock.expect(:ordinal_increment, 'first')
    @mock.expect(:ordinal_increment, 'second')

    @mock.ordinal_increment # => 'first'
    @mock.ordinal_increment # => 'second'
    @mock.ordinal_increment # => raises MockExpectationError "No more expects available for :ordinal_increment"
    ```
- name: Minitest::Mock#verify
  id: minitest/mock#method-i-verify
  summary: Verify that all methods were called as expected
  belongs_to: Minitest::Mock
  description: "verify () Show source\n\n``` ruby\n# File lib/minitest/mock.rb, line 140\ndef verify\n  @expected_calls.each do |name, expected|\n    actual = @actual_calls.fetch(name, nil)\n    raise MockExpectationError, \"expected #{__call name, expected[0]}\" unless actual\n    raise MockExpectationError, \"expected #{__call name, expected[actual.size]}, got [#{__call name, actual}]\" if\n      actual.size < expected.size\n  end\n  true\nend\n```\n\nVerify that all methods were called as expected. Raises `MockExpectationError` if the mock object was not called as expected.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Mock.html](https://docs.seattlerb.org/minitest/Minitest/Mock.html)"
- name: Minitest::Parallel::Executor
  id: minitest/parallel/executor
  summary: The engine used to run multiple tests in parallel
  description: "# class Minitest::Parallel::Executor\n\nParent:  \n[Object](../../object)\n\nThe engine used to run multiple tests in parallel.\n\n### Attributes\n\nsize\\[R\\]\n\nThe size of the pool of workers.\n\n### Public Class Methods\n\nnew(size) Show source\n\n``` ruby\n# File lib/minitest/parallel.rb, line 17\ndef initialize size\n  @size  = size\n  @queue = Queue.new\n  @pool  = nil\nend\n```\n\nCreate a parallel test executor of with `size` workers.\n\n### Public Instance Methods\n\n\\<\\<(work;) Show source\n\n``` ruby\n# File lib/minitest/parallel.rb, line 43\ndef << work; @queue << work; end\n```\n\nAdd a job to the queue\n\nshutdown() Show source\n\n``` ruby\n# File lib/minitest/parallel.rb, line 50\ndef shutdown\n  size.times { @queue << nil }\n  @pool.each(&:join)\nend\n```\n\nShuts down the pool of workers by signalling them to quit and waiting for them all to finish what they’re currently working on.\n\nstart() Show source\n\n``` ruby\n# File lib/minitest/parallel.rb, line 26\ndef start\n  @pool  = size.times.map {\n    Thread.new(@queue) do |queue|\n      Thread.current.abort_on_exception = true\n      while (job = queue.pop)\n        klass, method, reporter = job\n        reporter.synchronize { reporter.prerecord klass, method }\n        result = Minitest.run_one_method klass, method\n        reporter.synchronize { reporter.record result }\n      end\n    end\n  }\nend\n```\n\nStart the executor\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Parallel/Executor.html](https://docs.seattlerb.org/minitest/Minitest/Parallel/Executor.html)"
- name: Minitest::Parallel::Executor#<<
  id: minitest/parallel/executor#method-i-3C-3C
  summary: null
  belongs_to: Minitest::Parallel::Executor
  description: |-
    \<\< (work;) Show source

    ``` ruby
    # File lib/minitest/parallel.rb, line 43
    def << work; @queue << work; end
    ```

    Add a job to the queue
- name: Minitest::Parallel::Executor#shutdown
  id: minitest/parallel/executor#method-i-shutdown
  summary: Shuts down the pool of workers by signalling them to quit and waiting for them all to finish what they’re currently working on
  belongs_to: Minitest::Parallel::Executor
  description: |-
    shutdown () Show source

    ``` ruby
    # File lib/minitest/parallel.rb, line 50
    def shutdown
      size.times { @queue << nil }
      @pool.each(&:join)
    end
    ```

    Shuts down the pool of workers by signalling them to quit and waiting for them all to finish what they’re currently working on.
- name: Minitest::Parallel::Executor#size
  id: minitest/parallel/executor#attribute-i-size
  summary: The size of the pool of workers
  belongs_to: Minitest::Parallel::Executor
  description: |-
    size \[R\]

    The size of the pool of workers.

    ### Public Class Methods
- name: Minitest::Parallel::Executor#start
  id: minitest/parallel/executor#method-i-start
  summary: © Ryan Davis, seattle.rb Licensed under the MIT License
  belongs_to: Minitest::Parallel::Executor
  description: "start () Show source\n\n``` ruby\n# File lib/minitest/parallel.rb, line 26\ndef start\n  @pool  = size.times.map {\n    Thread.new(@queue) do |queue|\n      Thread.current.abort_on_exception = true\n      while (job = queue.pop)\n        klass, method, reporter = job\n        reporter.synchronize { reporter.prerecord klass, method }\n        result = Minitest.run_one_method klass, method\n        reporter.synchronize { reporter.record result }\n      end\n    end\n  }\nend\n```\n\nStart the executor\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Parallel/Executor.html](https://docs.seattlerb.org/minitest/Minitest/Parallel/Executor.html)"
- name: Minitest::Parallel::Executor::new
  id: minitest/parallel/executor#method-c-new
  summary: Create a parallel test executor of with size workers
  belongs_to: Minitest::Parallel::Executor
  description: |-
    new (size) Show source

    ``` ruby
    # File lib/minitest/parallel.rb, line 17
    def initialize size
      @size  = size
      @queue = Queue.new
      @pool  = nil
    end
    ```

    Create a parallel test executor of with `size` workers.

    ### Public Instance Methods
- name: Minitest::PrideIO
  id: minitest/prideio
  summary: The IO we’re going to pipe through
  description: "# class Minitest::PrideIO\n\nParent:  \n[Object](../object)\n\nShow your testing pride!\n\n### Constants\n\nESC  \nStart an escape sequence\n\nNND  \nEnd the escape sequence\n\n### Attributes\n\nio\\[R\\]\n\nThe IO we’re going to pipe through.\n\n### Public Class Methods\n\npride!() Show source\n\n``` ruby\n# File lib/minitest/pride_plugin.rb, line 28\ndef self.pride!\n  @pride = true\nend\n```\n\nActivate the pride plugin. Called from both -p option and minitest/pride\n\npride?() Show source\n\n``` ruby\n# File lib/minitest/pride_plugin.rb, line 35\ndef self.pride?\n  @pride ||= false\nend\n```\n\nAre we showing our testing pride?\n\n### Public Instance Methods\n\npride(string) Show source\n\n``` ruby\n# File lib/minitest/pride_plugin.rb, line 89\ndef pride string\n  string = \"*\" if string == \".\"\n  c = @colors[@index % @size]\n  @index += 1\n  \"#{ESC}#{c}m#{string}#{NND}\"\nend\n```\n\nColor a string.\n\nprint(o) Show source\n\n``` ruby\n# File lib/minitest/pride_plugin.rb, line 60\ndef print o\n  case o\n  when \".\" then\n    io.print pride o\n  when \"E\", \"F\" then\n    io.print \"#{ESC}41m#{ESC}37m#{o}#{NND}\"\n  when \"S\" then\n    io.print pride o\n  else\n    io.print o\n  end\nend\n```\n\nWrap print to colorize the output.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/PrideIO.html](https://docs.seattlerb.org/minitest/Minitest/PrideIO.html)"
- name: Minitest::PrideIO#io
  id: minitest/prideio#attribute-i-io
  summary: The IO we’re going to pipe through
  belongs_to: Minitest::PrideIO
  description: |-
    io \[R\]

    The IO we’re going to pipe through.

    ### Public Class Methods
- name: Minitest::PrideIO#pride
  id: minitest/prideio#method-i-pride
  summary: Color a string
  belongs_to: Minitest::PrideIO
  description: |-
    pride (string) Show source

    ``` ruby
    # File lib/minitest/pride_plugin.rb, line 89
    def pride string
      string = "*" if string == "."
      c = @colors[@index % @size]
      @index += 1
      "#{ESC}#{c}m#{string}#{NND}"
    end
    ```

    Color a string.
- name: Minitest::PrideIO#print
  id: minitest/prideio#method-i-print
  summary: Wrap print to colorize the output
  belongs_to: Minitest::PrideIO
  description: "print (o) Show source\n\n``` ruby\n# File lib/minitest/pride_plugin.rb, line 60\ndef print o\n  case o\n  when \".\" then\n    io.print pride o\n  when \"E\", \"F\" then\n    io.print \"#{ESC}41m#{ESC}37m#{o}#{NND}\"\n  when \"S\" then\n    io.print pride o\n  else\n    io.print o\n  end\nend\n```\n\nWrap print to colorize the output.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/PrideIO.html](https://docs.seattlerb.org/minitest/Minitest/PrideIO.html)"
- name: Minitest::PrideIO::pride!
  id: minitest/prideio#method-c-pride-21
  summary: Activate the pride plugin
  belongs_to: Minitest::PrideIO
  description: |-
    pride! () Show source

    ``` ruby
    # File lib/minitest/pride_plugin.rb, line 28
    def self.pride!
      @pride = true
    end
    ```

    Activate the pride plugin. Called from both -p option and minitest/pride
- name: Minitest::PrideIO::pride?
  id: minitest/prideio#method-c-pride-3F
  summary: null
  belongs_to: Minitest::PrideIO
  description: |-
    pride? () Show source

    ``` ruby
    # File lib/minitest/pride_plugin.rb, line 35
    def self.pride?
      @pride ||= false
    end
    ```

    Are we showing our testing pride?

    ### Public Instance Methods
- name: Minitest::PrideLOL
  id: minitest/pridelol
  summary: Make the string even more colorful
  description: "# class Minitest::PrideLOL\n\nParent:  \n[Minitest::PrideIO](prideio)\n\nIf you thought the [`PrideIO`](prideio) was colorful…\n\n(Inspired by lolcat, but with clean math)\n\n### Public Instance Methods\n\npride(string) Show source\n\n``` ruby\n# File lib/minitest/pride_plugin.rb, line 136\ndef pride string\n  c = @colors[@index % @size]\n  @index += 1\n  \"#{ESC}38;5;#{c}m#{string}#{NND}\"\nend\n```\n\nMake the string even more colorful. Damnit.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/PrideLOL.html](https://docs.seattlerb.org/minitest/Minitest/PrideLOL.html)"
- name: Minitest::PrideLOL#pride
  id: minitest/pridelol#method-i-pride
  summary: Make the string even more colorful
  belongs_to: Minitest::PrideLOL
  description: "pride (string) Show source\n\n``` ruby\n# File lib/minitest/pride_plugin.rb, line 136\ndef pride string\n  c = @colors[@index % @size]\n  @index += 1\n  \"#{ESC}38;5;#{c}m#{string}#{NND}\"\nend\n```\n\nMake the string even more colorful. Damnit.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/PrideLOL.html](https://docs.seattlerb.org/minitest/Minitest/PrideLOL.html)"
- name: Minitest::ProgressReporter
  id: minitest/progressreporter
  summary: A very simple reporter that prints the “dots” during the run
  description: "# class Minitest::ProgressReporter\n\nParent:  \nMinitest::Reporter\n\nA very simple reporter that prints the “dots” during the run.\n\nThis is added to the top-level [`CompositeReporter`](compositereporter) at the start of the run. If you want to change the output of minitest via a plugin, pull this out of the composite and replace it with your own.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/ProgressReporter.html](https://docs.seattlerb.org/minitest/Minitest/ProgressReporter.html)"
- name: Minitest::Reportable
  id: minitest/reportable
  summary: Shared code for anything that can get passed to a Reporter
  description: "# module Minitest::Reportable\n\nShared code for anything that can get passed to a Reporter. See [`Minitest::Test`](test) & [`Minitest::Result`](result).\n\n### Public Instance Methods\n\nerror?() Show source\n\n``` ruby\n# File lib/minitest.rb, line 558\ndef error?\n  self.failures.any? { |f| UnexpectedError === f }\nend\n```\n\nDid this run error?\n\nlocation() Show source\n\n``` ruby\n# File lib/minitest.rb, line 532\ndef location\n  loc = \" [#{self.failure.location}]\" unless passed? or error?\n  \"#{self.class_name}##{self.name}#{loc}\"\nend\n```\n\nThe location identifier of this test. Depends on a method existing called class_name.\n\npassed?() Show source\n\n``` ruby\n# File lib/minitest.rb, line 524\ndef passed?\n  not self.failure\nend\n```\n\nDid this run pass?\n\nNote: skipped runs are not considered passing, but they don’t cause the process to exit non-zero.\n\nresult_code() Show source\n\n``` ruby\n# File lib/minitest.rb, line 544\ndef result_code\n  self.failure and self.failure.result_code or \".\"\nend\n```\n\nReturns “.”, “F”, or “E” based on the result of the run.\n\nskipped?() Show source\n\n``` ruby\n# File lib/minitest.rb, line 551\ndef skipped?\n  self.failure and Skip === self.failure\nend\n```\n\nWas this run skipped?\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Reportable.html](https://docs.seattlerb.org/minitest/Minitest/Reportable.html)"
- name: Minitest::Reportable#error?
  id: minitest/reportable#method-i-error-3F
  summary: null
  belongs_to: Minitest::Reportable
  description: |-
    error? () Show source

    ``` ruby
    # File lib/minitest.rb, line 558
    def error?
      self.failures.any? { |f| UnexpectedError === f }
    end
    ```

    Did this run error?
- name: Minitest::Reportable#location
  id: minitest/reportable#method-i-location
  summary: The location identifier of this test
  belongs_to: Minitest::Reportable
  description: |-
    location () Show source

    ``` ruby
    # File lib/minitest.rb, line 532
    def location
      loc = " [#{self.failure.location}]" unless passed? or error?
      "#{self.class_name}##{self.name}#{loc}"
    end
    ```

    The location identifier of this test. Depends on a method existing called class_name.
- name: Minitest::Reportable#passed?
  id: minitest/reportable#method-i-passed-3F
  summary: 'Note: skipped runs are not considered passing, but they don’t cause the process to exit non-zero'
  belongs_to: Minitest::Reportable
  description: |-
    passed? () Show source

    ``` ruby
    # File lib/minitest.rb, line 524
    def passed?
      not self.failure
    end
    ```

    Did this run pass?

    Note: skipped runs are not considered passing, but they don’t cause the process to exit non-zero.
- name: Minitest::Reportable#result_code
  id: minitest/reportable#method-i-result_code
  summary: Returns “.”, “F”, or “E” based on the result of the run
  belongs_to: Minitest::Reportable
  description: |-
    result_code () Show source

    ``` ruby
    # File lib/minitest.rb, line 544
    def result_code
      self.failure and self.failure.result_code or "."
    end
    ```

    Returns “.”, “F”, or “E” based on the result of the run.
- name: Minitest::Reportable#skipped?
  id: minitest/reportable#method-i-skipped-3F
  summary: © Ryan Davis, seattle.rb Licensed under the MIT License
  belongs_to: Minitest::Reportable
  description: "skipped? () Show source\n\n``` ruby\n# File lib/minitest.rb, line 551\ndef skipped?\n  self.failure and Skip === self.failure\nend\n```\n\nWas this run skipped?\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Reportable.html](https://docs.seattlerb.org/minitest/Minitest/Reportable.html)"
- name: Minitest::Result
  id: minitest/result
  summary: This represents a test result in a clean way that can be marshalled over a wire
  description: "# class Minitest::Result\n\nParent:  \n[Minitest::Runnable](runnable)\n\nIncluded modules:  \n[Minitest::Reportable](reportable)\n\nThis represents a test result in a clean way that can be marshalled over a wire. Tests can do anything they want to the test instance and can create conditions that cause Marshal.dump to blow up. By using [`Result.from(a_test)`](result#method-c-from) you can be reasonably sure that the test result can be marshalled.\n\n### Attributes\n\nklass\\[RW\\]\n\nThe class name of the test result.\n\nsource_location\\[RW\\]\n\nThe location of the test method.\n\n### Public Class Methods\n\nfrom(runnable) Show source\n\n``` ruby\n# File lib/minitest.rb, line 589\ndef self.from runnable\n  o = runnable\n\n  r = self.new o.name\n  r.klass      = o.class.name\n  r.assertions = o.assertions\n  r.failures   = o.failures.dup\n  r.time       = o.time\n  r.metadata   = o.metadata if o.metadata?\n\n  r.source_location = o.method(o.name).source_location rescue [\"unknown\", -1]\n\n  r\nend\n```\n\nCreate a new test result from a Runnable instance.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Result.html](https://docs.seattlerb.org/minitest/Minitest/Result.html)"
- name: Minitest::Result#klass
  id: minitest/result#attribute-i-klass
  summary: The class name of the test result
  belongs_to: Minitest::Result
  description: |-
    klass \[RW\]

    The class name of the test result.
- name: Minitest::Result#source_location
  id: minitest/result#attribute-i-source_location
  summary: The location of the test method
  belongs_to: Minitest::Result
  description: |-
    source_location \[RW\]

    The location of the test method.

    ### Public Class Methods
- name: Minitest::Result::from
  id: minitest/result#method-c-from
  summary: Create a new test result from a Runnable instance
  belongs_to: Minitest::Result
  description: "from (runnable) Show source\n\n``` ruby\n# File lib/minitest.rb, line 589\ndef self.from runnable\n  o = runnable\n\n  r = self.new o.name\n  r.klass      = o.class.name\n  r.assertions = o.assertions\n  r.failures   = o.failures.dup\n  r.time       = o.time\n  r.metadata   = o.metadata if o.metadata?\n\n  r.source_location = o.method(o.name).source_location rescue [\"unknown\", -1]\n\n  r\nend\n```\n\nCreate a new test result from a Runnable instance.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Result.html](https://docs.seattlerb.org/minitest/Minitest/Result.html)"
- name: Minitest::run
  id: minitest#method-c-run
  summary: This is the top-level run method
  belongs_to: Minitest
  description: |-
    run (args = \[\]) Show source

    ``` ruby
    # File lib/minitest.rb, line 143
    def self.run args = []
      self.load_plugins unless args.delete("--no-plugins") || ENV["MT_NO_PLUGINS"]

      options = process_args args

      Minitest.seed = options[:seed]
      srand Minitest.seed

      reporter = CompositeReporter.new
      reporter << SummaryReporter.new(options[:io], options)
      reporter << ProgressReporter.new(options[:io], options)

      self.reporter = reporter # this makes it available to plugins
      self.init_plugins options
      self.reporter = nil # runnables shouldn't depend on the reporter, ever

      self.parallel_executor.start if parallel_executor.respond_to?(:start)
      reporter.start
      begin
        __run reporter, options
      rescue Interrupt
        warn "Interrupted. Exiting..."
      end
      self.parallel_executor.shutdown
      reporter.report

      reporter.passed?
    end
    ```

    This is the top-level run method. Everything starts from here. It tells each Runnable sub-class to run, and each of those are responsible for doing whatever they do.

    The overall structure of a run looks like this:

    ``` ruby
    Minitest.autorun
      Minitest.run(args)
        Minitest.__run(reporter, options)
          Runnable.runnables.each
            runnable.run(reporter, options)
              self.runnable_methods.each
                self.run_one_method(self, runnable_method, reporter)
                  Minitest.run_one_method(klass, runnable_method)
                    klass.new(runnable_method).run
    ```

    ### Public Instance Methods
- name: Minitest::Runnable
  id: minitest/runnable
  summary: Represents anything “runnable”, like Test, Spec, Benchmark, or whatever you can dream up
  description: "# class Minitest::Runnable\n\nParent:  \n[Object](../object)\n\nRepresents anything “runnable”, like [`Test`](test), [`Spec`](spec), [`Benchmark`](benchmark), or whatever you can dream up.\n\nSubclasses of this are automatically registered and available in [`Runnable.runnables`](runnable#method-c-runnables).\n\n### Attributes\n\nassertions\\[RW\\]\n\nNumber of assertions executed in this run.\n\nfailures\\[RW\\]\n\nAn assertion raised during the run, if any.\n\nmetadata\\[W\\]\n\nSets metadata, mainly used for `Result.from`.\n\ntime\\[RW\\]\n\nThe time it took to run.\n\n### Public Class Methods\n\nmethods_matching(re) Show source\n\n``` ruby\n# File lib/minitest.rb, line 321\ndef self.methods_matching re\n  public_instance_methods(true).grep(re).map(&:to_s)\nend\n```\n\nReturns all instance methods matching the pattern `re`.\n\nrun(reporter, options = {}) Show source\n\n``` ruby\n# File lib/minitest.rb, line 336\ndef self.run reporter, options = {}\n  filtered_methods = if options[:filter]\n    filter = options[:filter]\n    filter = Regexp.new $1 if filter.is_a?(String) && filter =~ %r%/(.*)/%\n\n    self.runnable_methods.find_all { |m|\n      filter === m || filter === \"#{self}##{m}\"\n    }\n  else\n    self.runnable_methods\n  end\n\n  if options[:exclude]\n    exclude = options[:exclude]\n    exclude = Regexp.new $1 if exclude =~ %r%/(.*)/%\n\n    filtered_methods.delete_if { |m|\n      exclude === m || exclude === \"#{self}##{m}\"\n    }\n  end\n\n  return if filtered_methods.empty?\n\n  with_info_handler reporter do\n    filtered_methods.each do |method_name|\n      run_one_method self, method_name, reporter\n    end\n  end\nend\n```\n\nResponsible for running all runnable methods in a given class, each in its own instance. Each instance is passed to the reporter to record.\n\nrun_one_method(klass, method_name, reporter) Show source\n\n``` ruby\n# File lib/minitest.rb, line 372\ndef self.run_one_method klass, method_name, reporter\n  reporter.prerecord klass, method_name\n  reporter.record Minitest.run_one_method(klass, method_name)\nend\n```\n\nRuns a single method and has the reporter record the result. This was considered internal API but is factored out of run so that subclasses can specialize the running of an individual test. See Minitest::ParallelTest::ClassMethods for an example.\n\nrunnable_methods() Show source\n\n``` ruby\n# File lib/minitest.rb, line 417\ndef self.runnable_methods\n  raise NotImplementedError, \"subclass responsibility\"\nend\n```\n\nEach subclass of Runnable is responsible for overriding this method to return all runnable methods. See methods_matching.\n\nrunnables() Show source\n\n``` ruby\n# File lib/minitest.rb, line 424\ndef self.runnables\n  @@runnables\nend\n```\n\nReturns all subclasses of Runnable.\n\ntest_order() Show source\n\n``` ruby\n# File lib/minitest.rb, line 381\ndef self.test_order\n  :random\nend\n```\n\nDefines the order to run tests (:random by default). Override this or use a convenience method to change it for your tests.\n\n### Public Instance Methods\n\nmetadata() Show source\n\n``` ruby\n# File lib/minitest.rb, line 463\ndef metadata\n  @metadata ||= {}\nend\n```\n\nMetadata you attach to the test results that get sent to the reporter.\n\nLazily initializes to a hash, to keep memory down.\n\nNOTE: this data **must** be plain (read: marshal-able) data! Hashes! Arrays! Strings!\n\nmetadata?() Show source\n\n``` ruby\n# File lib/minitest.rb, line 475\ndef metadata?\n  defined? @metadata\nend\n```\n\nReturns true if metadata exists.\n\nname() Show source\n\n``` ruby\n# File lib/minitest.rb, line 307\ndef name\n  @NAME\nend\n```\n\nName of the run.\n\nname=(o) Show source\n\n``` ruby\n# File lib/minitest.rb, line 314\ndef name= o\n  @NAME = o\nend\n```\n\nSet the name of the run.\n\npassed?() Show source\n\n``` ruby\n# File lib/minitest.rb, line 492\ndef passed?\n  raise NotImplementedError, \"subclass responsibility\"\nend\n```\n\nDid this run pass?\n\nNote: skipped runs are not considered passing, but they don’t cause the process to exit non-zero.\n\nresult_code() Show source\n\n``` ruby\n# File lib/minitest.rb, line 501\ndef result_code\n  raise NotImplementedError, \"subclass responsibility\"\nend\n```\n\nReturns a single character string to print based on the result of the run. One of `\".\"`, `\"F\"`, `\"E\"` or `\"S\"`.\n\nrun() Show source\n\n``` ruby\n# File lib/minitest.rb, line 482\ndef run\n  raise NotImplementedError, \"subclass responsibility\"\nend\n```\n\nRuns a single method. Needs to return self.\n\nskipped?() Show source\n\n``` ruby\n# File lib/minitest.rb, line 508\ndef skipped?\n  raise NotImplementedError, \"subclass responsibility\"\nend\n```\n\nWas this run skipped? See [`passed?`](runnable#method-i-passed-3F) for more information.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Runnable.html](https://docs.seattlerb.org/minitest/Minitest/Runnable.html)"
- name: Minitest::Runnable#assertions
  id: minitest/runnable#attribute-i-assertions
  summary: Number of assertions executed in this run
  belongs_to: Minitest::Runnable
  description: |-
    assertions \[RW\]

    Number of assertions executed in this run.
- name: Minitest::Runnable#failures
  id: minitest/runnable#attribute-i-failures
  summary: An assertion raised during the run, if any
  belongs_to: Minitest::Runnable
  description: |-
    failures \[RW\]

    An assertion raised during the run, if any.
- name: Minitest::Runnable#metadata
  id: minitest/runnable#attribute-i-metadata
  summary: Sets metadata, mainly used for Result.from
  belongs_to: Minitest::Runnable
  description: |-
    metadata \[W\]

    Sets metadata, mainly used for `Result.from`.
- name: Minitest::Runnable#metadata?
  id: minitest/runnable#method-i-metadata-3F
  summary: Returns true if metadata exists
  belongs_to: Minitest::Runnable
  description: |-
    metadata? () Show source

    ``` ruby
    # File lib/minitest.rb, line 475
    def metadata?
      defined? @metadata
    end
    ```

    Returns true if metadata exists.
- name: Minitest::Runnable#name
  id: minitest/runnable#method-i-name
  summary: Name of the run
  belongs_to: Minitest::Runnable
  description: |-
    name () Show source

    ``` ruby
    # File lib/minitest.rb, line 307
    def name
      @NAME
    end
    ```

    Name of the run.
- name: Minitest::Runnable#name=
  id: minitest/runnable#method-i-name-3D
  summary: Set the name of the run
  belongs_to: Minitest::Runnable
  description: |-
    name= (o) Show source

    ``` ruby
    # File lib/minitest.rb, line 314
    def name= o
      @NAME = o
    end
    ```

    Set the name of the run.
- name: Minitest::Runnable#passed?
  id: minitest/runnable#method-i-passed-3F
  summary: 'Note: skipped runs are not considered passing, but they don’t cause the process to exit non-zero'
  belongs_to: Minitest::Runnable
  description: |-
    passed? () Show source

    ``` ruby
    # File lib/minitest.rb, line 492
    def passed?
      raise NotImplementedError, "subclass responsibility"
    end
    ```

    Did this run pass?

    Note: skipped runs are not considered passing, but they don’t cause the process to exit non-zero.
- name: Minitest::Runnable#result_code
  id: minitest/runnable#method-i-result_code
  summary: Returns a single character string to print based on the result of the run
  belongs_to: Minitest::Runnable
  description: |-
    result_code () Show source

    ``` ruby
    # File lib/minitest.rb, line 501
    def result_code
      raise NotImplementedError, "subclass responsibility"
    end
    ```

    Returns a single character string to print based on the result of the run. One of `"."`, `"F"`, `"E"` or `"S"`.
- name: Minitest::Runnable#run
  id: minitest/runnable#method-i-run
  summary: Runs a single method
  belongs_to: Minitest::Runnable
  description: |-
    run () Show source

    ``` ruby
    # File lib/minitest.rb, line 482
    def run
      raise NotImplementedError, "subclass responsibility"
    end
    ```

    Runs a single method. Needs to return self.
- name: Minitest::Runnable#skipped?
  id: minitest/runnable#method-i-skipped-3F
  summary: Was this run skipped? See passed? for more information
  belongs_to: Minitest::Runnable
  description: "skipped? () Show source\n\n``` ruby\n# File lib/minitest.rb, line 508\ndef skipped?\n  raise NotImplementedError, \"subclass responsibility\"\nend\n```\n\nWas this run skipped? See [`passed?`](runnable#method-i-passed-3F) for more information.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Runnable.html](https://docs.seattlerb.org/minitest/Minitest/Runnable.html)"
- name: Minitest::Runnable#time
  id: minitest/runnable#attribute-i-time
  summary: The time it took to run
  belongs_to: Minitest::Runnable
  description: |-
    time \[RW\]

    The time it took to run.

    ### Public Class Methods
- name: Minitest::Runnable::methods_matching
  id: minitest/runnable#method-c-methods_matching
  summary: Returns all instance methods matching the pattern re
  belongs_to: Minitest::Runnable
  description: |-
    methods_matching (re) Show source

    ``` ruby
    # File lib/minitest.rb, line 321
    def self.methods_matching re
      public_instance_methods(true).grep(re).map(&:to_s)
    end
    ```

    Returns all instance methods matching the pattern `re`.
- name: Minitest::Runnable::run
  id: minitest/runnable#method-c-run
  summary: Responsible for running all runnable methods in a given class, each in its own instance
  belongs_to: Minitest::Runnable
  description: |-
    run (reporter, options = {}) Show source

    ``` ruby
    # File lib/minitest.rb, line 336
    def self.run reporter, options = {}
      filtered_methods = if options[:filter]
        filter = options[:filter]
        filter = Regexp.new $1 if filter.is_a?(String) && filter =~ %r%/(.*)/%

        self.runnable_methods.find_all { |m|
          filter === m || filter === "#{self}##{m}"
        }
      else
        self.runnable_methods
      end

      if options[:exclude]
        exclude = options[:exclude]
        exclude = Regexp.new $1 if exclude =~ %r%/(.*)/%

        filtered_methods.delete_if { |m|
          exclude === m || exclude === "#{self}##{m}"
        }
      end

      return if filtered_methods.empty?

      with_info_handler reporter do
        filtered_methods.each do |method_name|
          run_one_method self, method_name, reporter
        end
      end
    end
    ```

    Responsible for running all runnable methods in a given class, each in its own instance. Each instance is passed to the reporter to record.
- name: Minitest::Runnable::run_one_method
  id: minitest/runnable#method-c-run_one_method
  summary: Runs a single method and has the reporter record the result
  belongs_to: Minitest::Runnable
  description: |-
    run_one_method (klass, method_name, reporter) Show source

    ``` ruby
    # File lib/minitest.rb, line 372
    def self.run_one_method klass, method_name, reporter
      reporter.prerecord klass, method_name
      reporter.record Minitest.run_one_method(klass, method_name)
    end
    ```

    Runs a single method and has the reporter record the result. This was considered internal API but is factored out of run so that subclasses can specialize the running of an individual test. See Minitest::ParallelTest::ClassMethods for an example.
- name: Minitest::Runnable::runnable_methods
  id: minitest/runnable#method-c-runnable_methods
  summary: Each subclass of Runnable is responsible for overriding this method to return all runnable methods
  belongs_to: Minitest::Runnable
  description: |-
    runnable_methods () Show source

    ``` ruby
    # File lib/minitest.rb, line 417
    def self.runnable_methods
      raise NotImplementedError, "subclass responsibility"
    end
    ```

    Each subclass of Runnable is responsible for overriding this method to return all runnable methods. See methods_matching.
- name: Minitest::Runnable::runnables
  id: minitest/runnable#method-c-runnables
  summary: Returns all subclasses of Runnable
  belongs_to: Minitest::Runnable
  description: |-
    runnables () Show source

    ``` ruby
    # File lib/minitest.rb, line 424
    def self.runnables
      @@runnables
    end
    ```

    Returns all subclasses of Runnable.
- name: Minitest::Runnable::test_order
  id: minitest/runnable#method-c-test_order
  summary: Defines the order to run tests (:random by default)
  belongs_to: Minitest::Runnable
  description: |-
    test_order () Show source

    ``` ruby
    # File lib/minitest.rb, line 381
    def self.test_order
      :random
    end
    ```

    Defines the order to run tests (:random by default). Override this or use a convenience method to change it for your tests.

    ### Public Instance Methods

    metadata () Show source

    ``` ruby
    # File lib/minitest.rb, line 463
    def metadata
      @metadata ||= {}
    end
    ```

    Metadata you attach to the test results that get sent to the reporter.

    Lazily initializes to a hash, to keep memory down.

    NOTE: this data **must** be plain (read: marshal-able) data! Hashes! Arrays! Strings!
- name: Minitest::Skip
  id: minitest/skip
  summary: Assertion raised when skipping a run
  description: "# class Minitest::Skip\n\nParent:  \n[Minitest::Assertion](assertion)\n\n[`Assertion`](assertion) raised when skipping a run.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Skip.html](https://docs.seattlerb.org/minitest/Minitest/Skip.html)"
- name: Minitest::Spec
  id: minitest/spec
  summary: For a list of expectations, see Minitest::Expectations
  description: "# class Minitest::Spec\n\nParent:  \n[Minitest::Test](test)\n\n[`Minitest::Spec`](spec) – The faster, better, less-magical spec framework!\n\nFor a list of expectations, see [`Minitest::Expectations`](expectations).\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Spec.html](https://docs.seattlerb.org/minitest/Minitest/Spec.html)"
- name: Minitest::Spec::DSL
  id: minitest/spec/dsl
  summary: Oh look! A Minitest::Spec::DSL module! Eat your heart out DHH
  description: "# module Minitest::Spec::DSL\n\nOh look! A [`Minitest::Spec::DSL`](dsl) module! Eat your heart out DHH.\n\n### Constants\n\nTYPES  \nContains pairs of matchers and [`Spec`](../spec) classes to be used to calculate the superclass of a top-level describe. This allows for automatically customizable spec types.\n\nSee: [`register_spec_type`](dsl#method-i-register_spec_type) and [`spec_type`](dsl#method-i-spec_type)\n\n### Public Instance Methods\n\nafter(\\_type = nil, &block) Show source\n\n``` ruby\n# File lib/minitest/spec.rb, line 205\ndef after _type = nil, &block\n  define_method :teardown do\n    self.instance_eval(&block)\n    super()\n  end\nend\n```\n\nDefine an ‘after’ action. Inherits the way normal methods should.\n\nNOTE: `type` is ignored and is only there to make porting easier.\n\nEquivalent to [`Minitest::Test#teardown`](../test/lifecyclehooks#method-i-teardown).\n\nCalls superclass method\n\nbefore(\\_type = nil, &block) Show source\n\n``` ruby\n# File lib/minitest/spec.rb, line 191\ndef before _type = nil, &block\n  define_method :setup do\n    super()\n    self.instance_eval(&block)\n  end\nend\n```\n\nDefine a ‘before’ action. Inherits the way normal methods should.\n\nNOTE: `type` is ignored and is only there to make porting easier.\n\nEquivalent to [`Minitest::Test#setup`](../test/lifecyclehooks#method-i-setup).\n\nCalls superclass method\n\nit(desc = \"anonymous\", &block) Show source\n\n``` ruby\n# File lib/minitest/spec.rb, line 223\ndef it desc = \"anonymous\", &block\n  block ||= proc { skip \"(no tests defined)\" }\n\n  @specs ||= 0\n  @specs += 1\n\n  name = \"test_%04d_%s\" % [ @specs, desc ]\n\n  undef_klasses = self.children.reject { |c| c.public_method_defined? name }\n\n  define_method name, &block\n\n  undef_klasses.each do |undef_klass|\n    undef_klass.send :undef_method, name\n  end\n\n  name\nend\n```\n\nDefine an expectation with name `desc`. Name gets morphed to a proper test method name. For some freakish reason, people who write specs don’t like class inheritance, so this goes way out of its way to make sure that expectations aren’t inherited.\n\nThis is also aliased to [`specify`](dsl#method-i-specify) and doesn’t require a `desc` arg.\n\nHint: If you *do* want inheritance, use minitest/test. You can mix and match between assertions and expectations as much as you want.\n\nAlso aliased as: [specify](dsl#method-i-specify)\n\nlet(name, &block) Show source\n\n``` ruby\n# File lib/minitest/spec.rb, line 247\ndef let name, &block\n  name = name.to_s\n  pre, post = \"let '#{name}' cannot \", \". Please use another name.\"\n  methods = Minitest::Spec.instance_methods.map(&:to_s) - %w[subject]\n  raise ArgumentError, \"#{pre}begin with 'test'#{post}\" if\n    name =~ /\\Atest/\n  raise ArgumentError, \"#{pre}override a method in Minitest::Spec#{post}\" if\n    methods.include? name\n\n  define_method name do\n    @_memoized ||= {}\n    @_memoized.fetch(name) { |k| @_memoized[k] = instance_eval(&block) }\n  end\nend\n```\n\nEssentially, define an accessor for `name` with `block`.\n\nWhy use let instead of def? I honestly don’t know.\n\nregister_spec_type(\\*args, &block) Show source\n\n``` ruby\n# File lib/minitest/spec.rb, line 146\ndef register_spec_type *args, &block\n  if block then\n    matcher, klass = block, args.first\n  else\n    matcher, klass = *args\n  end\n  TYPES.unshift [matcher, klass]\nend\n```\n\nRegister a new type of spec that matches the spec’s description. This method can take either a Regexp and a spec class or a spec class and a block that takes the description and returns true if it matches.\n\nEg:\n\n``` ruby\nregister_spec_type(/Controller$/, Minitest::Spec::Rails)\n```\n\nor:\n\n``` ruby\nregister_spec_type(Minitest::Spec::RailsModel) do |desc|\n  desc.superclass == ActiveRecord::Base\nend\n```\n\nspec_type(desc, \\*additional) Show source\n\n``` ruby\n# File lib/minitest/spec.rb, line 160\ndef spec_type desc, *additional\n  TYPES.find { |matcher, _klass|\n    if matcher.respond_to? :call then\n      matcher.call desc, *additional\n    else\n      matcher === desc.to_s\n    end\n  }.last\nend\n```\n\nFigure out the spec class to use based on a spec’s description. Eg:\n\n``` ruby\nspec_type(\"BlahController\") # => Minitest::Spec::Rails\n```\n\nspecify(desc = \"anonymous\", &block)\n\nAlias for: [it](dsl#method-i-it)\n\nsubject(&block) Show source\n\n``` ruby\n# File lib/minitest/spec.rb, line 266\ndef subject &block\n  let :subject, &block\nend\n```\n\nAnother lazy man’s accessor generator. Made even more lazy by setting the name for you to `subject`.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Spec/DSL.html](https://docs.seattlerb.org/minitest/Minitest/Spec/DSL.html)"
- name: Minitest::Spec::DSL#after
  id: minitest/spec/dsl#method-i-after
  summary: Define an ‘after’ action
  belongs_to: Minitest::Spec::DSL
  description: |-
    after (\_type = nil, &block) Show source

    ``` ruby
    # File lib/minitest/spec.rb, line 205
    def after _type = nil, &block
      define_method :teardown do
        self.instance_eval(&block)
        super()
      end
    end
    ```

    Define an ‘after’ action. Inherits the way normal methods should.

    NOTE: `type` is ignored and is only there to make porting easier.

    Equivalent to [`Minitest::Test#teardown`](../test/lifecyclehooks#method-i-teardown).

    Calls superclass method
- name: Minitest::Spec::DSL#before
  id: minitest/spec/dsl#method-i-before
  summary: Define a ‘before’ action
  belongs_to: Minitest::Spec::DSL
  description: |-
    before (\_type = nil, &block) Show source

    ``` ruby
    # File lib/minitest/spec.rb, line 191
    def before _type = nil, &block
      define_method :setup do
        super()
        self.instance_eval(&block)
      end
    end
    ```

    Define a ‘before’ action. Inherits the way normal methods should.

    NOTE: `type` is ignored and is only there to make porting easier.

    Equivalent to [`Minitest::Test#setup`](../test/lifecyclehooks#method-i-setup).

    Calls superclass method
- name: Minitest::Spec::DSL#it
  id: minitest/spec/dsl#method-i-it
  summary: Define an expectation with name desc
  belongs_to: Minitest::Spec::DSL
  description: |-
    it (desc = "anonymous", &block) Show source

    ``` ruby
    # File lib/minitest/spec.rb, line 223
    def it desc = "anonymous", &block
      block ||= proc { skip "(no tests defined)" }

      @specs ||= 0
      @specs += 1

      name = "test_%04d_%s" % [ @specs, desc ]

      undef_klasses = self.children.reject { |c| c.public_method_defined? name }

      define_method name, &block

      undef_klasses.each do |undef_klass|
        undef_klass.send :undef_method, name
      end

      name
    end
    ```

    Define an expectation with name `desc`. Name gets morphed to a proper test method name. For some freakish reason, people who write specs don’t like class inheritance, so this goes way out of its way to make sure that expectations aren’t inherited.

    This is also aliased to [`specify`](dsl#method-i-specify) and doesn’t require a `desc` arg.

    Hint: If you *do* want inheritance, use minitest/test. You can mix and match between assertions and expectations as much as you want.

    Also aliased as: [specify](dsl#method-i-specify)
- name: Minitest::Spec::DSL#let
  id: minitest/spec/dsl#method-i-let
  summary: Essentially, define an accessor for name with block
  belongs_to: Minitest::Spec::DSL
  description: |-
    let (name, &block) Show source

    ``` ruby
    # File lib/minitest/spec.rb, line 247
    def let name, &block
      name = name.to_s
      pre, post = "let '#{name}' cannot ", ". Please use another name."
      methods = Minitest::Spec.instance_methods.map(&:to_s) - %w[subject]
      raise ArgumentError, "#{pre}begin with 'test'#{post}" if
        name =~ /\Atest/
      raise ArgumentError, "#{pre}override a method in Minitest::Spec#{post}" if
        methods.include? name

      define_method name do
        @_memoized ||= {}
        @_memoized.fetch(name) { |k| @_memoized[k] = instance_eval(&block) }
      end
    end
    ```

    Essentially, define an accessor for `name` with `block`.

    Why use let instead of def? I honestly don’t know.
- name: Minitest::Spec::DSL#register_spec_type
  id: minitest/spec/dsl#method-i-register_spec_type
  summary: Register a new type of spec that matches the spec’s description
  belongs_to: Minitest::Spec::DSL
  description: |-
    register_spec_type (\*args, &block) Show source

    ``` ruby
    # File lib/minitest/spec.rb, line 146
    def register_spec_type *args, &block
      if block then
        matcher, klass = block, args.first
      else
        matcher, klass = *args
      end
      TYPES.unshift [matcher, klass]
    end
    ```

    Register a new type of spec that matches the spec’s description. This method can take either a Regexp and a spec class or a spec class and a block that takes the description and returns true if it matches.

    Eg:

    ``` ruby
    register_spec_type(/Controller$/, Minitest::Spec::Rails)
    ```

    or:

    ``` ruby
    register_spec_type(Minitest::Spec::RailsModel) do |desc|
      desc.superclass == ActiveRecord::Base
    end
    ```
- name: Minitest::Spec::DSL#spec_type
  id: minitest/spec/dsl#method-i-spec_type
  summary: Figure out the spec class to use based on a spec’s description
  belongs_to: Minitest::Spec::DSL
  description: |-
    spec_type (desc, \*additional) Show source

    ``` ruby
    # File lib/minitest/spec.rb, line 160
    def spec_type desc, *additional
      TYPES.find { |matcher, _klass|
        if matcher.respond_to? :call then
          matcher.call desc, *additional
        else
          matcher === desc.to_s
        end
      }.last
    end
    ```

    Figure out the spec class to use based on a spec’s description. Eg:

    ``` ruby
    spec_type("BlahController") # => Minitest::Spec::Rails
    ```
- name: Minitest::Spec::DSL#specify
  id: minitest/spec/dsl#method-i-specify
  summary: null
  belongs_to: Minitest::Spec::DSL
  description: |-
    specify (desc = "anonymous", &block)

    Alias for: [it](dsl#method-i-it)
- name: Minitest::Spec::DSL#subject
  id: minitest/spec/dsl#method-i-subject
  summary: Another lazy man’s accessor generator
  belongs_to: Minitest::Spec::DSL
  description: "subject (&block) Show source\n\n``` ruby\n# File lib/minitest/spec.rb, line 266\ndef subject &block\n  let :subject, &block\nend\n```\n\nAnother lazy man’s accessor generator. Made even more lazy by setting the name for you to `subject`.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Spec/DSL.html](https://docs.seattlerb.org/minitest/Minitest/Spec/DSL.html)"
- name: Minitest::Spec::DSL::InstanceMethods
  id: minitest/spec/dsl/instancemethods
  summary: Takes a value or a block and returns a value monad that has all of Expectations methods available to it
  description: "# module Minitest::Spec::DSL::InstanceMethods\n\nRdoc… why are you so dumb?\n\n### Public Instance Methods\n\n\\_(value = nil, &block) Show source\n\n``` ruby\n# File lib/minitest/spec.rb, line 322\ndef _ value = nil, &block\n  Minitest::Expectation.new block || value, self\nend\n```\n\nTakes a value or a block and returns a value monad that has all of Expectations methods available to it.\n\n``` ruby\n_(1 + 1).must_equal 2\n```\n\nAnd for blocks:\n\n``` ruby\n_ { 1 + \"1\" }.must_raise TypeError\n```\n\nThis method of expectation-based testing is preferable to straight-expectation methods (on [`Object`](../../../object)) because it stores its test context, bypassing our hacky use of thread-local variables.\n\nNOTE: At some point, the methods on [`Object`](../../../object) will be deprecated and then removed.\n\nIt is also aliased to [`value`](instancemethods#method-i-value) and [`expect`](instancemethods#method-i-expect) for your aesthetic pleasure:\n\n``` ruby\n     _(1 + 1).must_equal 2\n value(1 + 1).must_equal 2\nexpect(1 + 1).must_equal 2\n```\n\nAlso aliased as: [value](instancemethods#method-i-value), [expect](instancemethods#method-i-expect)\n\nexpect(value = nil, &block)\n\nAlias for: [\\_](instancemethods#method-i-_)\n\nvalue(value = nil, &block)\n\nAlias for: [\\_](instancemethods#method-i-_)\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Spec/DSL/InstanceMethods.html](https://docs.seattlerb.org/minitest/Minitest/Spec/DSL/InstanceMethods.html)"
- name: Minitest::Spec::DSL::InstanceMethods#expect
  id: minitest/spec/dsl/instancemethods#method-i-expect
  summary: null
  belongs_to: Minitest::Spec::DSL::InstanceMethods
  description: |-
    expect (value = nil, &block)

    Alias for: [\_](instancemethods#method-i-_)
- name: Minitest::Spec::DSL::InstanceMethods#value
  id: minitest/spec/dsl/instancemethods#method-i-value
  summary: © Ryan Davis, seattle.rb Licensed under the MIT License
  belongs_to: Minitest::Spec::DSL::InstanceMethods
  description: "value (value = nil, &block)\n\nAlias for: [\\_](instancemethods#method-i-_)\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Spec/DSL/InstanceMethods.html](https://docs.seattlerb.org/minitest/Minitest/Spec/DSL/InstanceMethods.html)"
- name: Minitest::StatisticsReporter
  id: minitest/statisticsreporter
  summary: A reporter that gathers statistics about a test run
  description: "# class Minitest::StatisticsReporter\n\nParent:  \nMinitest::Reporter\n\nA reporter that gathers statistics about a test run. Does not do any IO because meant to be used as a parent class for a reporter that does.\n\nIf you want to create an entirely different type of output (eg, CI, HTML, etc), this is the place to start.\n\nExample:\n\n``` ruby\nclass JenkinsCIReporter < StatisticsReporter\n  def report\n    super  # Needed to calculate some statistics\n\n    print \"<testsuite \"\n    print \"tests='#{count}' \"\n    print \"failures='#{failures}' \"\n    # Remaining XML...\n  end\nend\n```\n\n### Attributes\n\nassertions\\[RW\\]\n\nTotal number of assertions.\n\ncount\\[RW\\]\n\nTotal number of test cases.\n\nerrors\\[RW\\]\n\nTotal number of tests that erred.\n\nfailures\\[RW\\]\n\nTotal number of tests that failed.\n\nresults\\[RW\\]\n\nAn `Array` of test cases that failed or were skipped.\n\nskips\\[RW\\]\n\nTotal number of tests that where skipped.\n\nstart_time\\[RW\\]\n\nTime the test run started. If available, the monotonic clock is used and this is a `Float`, otherwise it’s an instance of `Time`.\n\ntotal_time\\[RW\\]\n\n[`Test`](test) run time. If available, the monotonic clock is used and this is a `Float`, otherwise it’s an instance of `Time`.\n\n### Public Instance Methods\n\nreport() Show source\n\n``` ruby\n# File lib/minitest.rb, line 797\ndef report\n  aggregate = results.group_by { |r| r.failure.class }\n  aggregate.default = [] # dumb. group_by should provide this\n\n  self.total_time = Minitest.clock_time - start_time\n  self.failures   = aggregate[Assertion].size\n  self.errors     = aggregate[UnexpectedError].size\n  self.skips      = aggregate[Skip].size\nend\n```\n\nReport on the tracked statistics.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/StatisticsReporter.html](https://docs.seattlerb.org/minitest/Minitest/StatisticsReporter.html)"
- name: Minitest::StatisticsReporter#assertions
  id: minitest/statisticsreporter#attribute-i-assertions
  summary: Total number of assertions
  belongs_to: Minitest::StatisticsReporter
  description: |-
    assertions \[RW\]

    Total number of assertions.
- name: Minitest::StatisticsReporter#count
  id: minitest/statisticsreporter#attribute-i-count
  summary: Total number of test cases
  belongs_to: Minitest::StatisticsReporter
  description: |-
    count \[RW\]

    Total number of test cases.
- name: Minitest::StatisticsReporter#errors
  id: minitest/statisticsreporter#attribute-i-errors
  summary: Total number of tests that erred
  belongs_to: Minitest::StatisticsReporter
  description: |-
    errors \[RW\]

    Total number of tests that erred.
- name: Minitest::StatisticsReporter#failures
  id: minitest/statisticsreporter#attribute-i-failures
  summary: Total number of tests that failed
  belongs_to: Minitest::StatisticsReporter
  description: |-
    failures \[RW\]

    Total number of tests that failed.
- name: Minitest::StatisticsReporter#report
  id: minitest/statisticsreporter#method-i-report
  summary: Report on the tracked statistics
  belongs_to: Minitest::StatisticsReporter
  description: "report () Show source\n\n``` ruby\n# File lib/minitest.rb, line 797\ndef report\n  aggregate = results.group_by { |r| r.failure.class }\n  aggregate.default = [] # dumb. group_by should provide this\n\n  self.total_time = Minitest.clock_time - start_time\n  self.failures   = aggregate[Assertion].size\n  self.errors     = aggregate[UnexpectedError].size\n  self.skips      = aggregate[Skip].size\nend\n```\n\nReport on the tracked statistics.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/StatisticsReporter.html](https://docs.seattlerb.org/minitest/Minitest/StatisticsReporter.html)"
- name: Minitest::StatisticsReporter#results
  id: minitest/statisticsreporter#attribute-i-results
  summary: An Array of test cases that failed or were skipped
  belongs_to: Minitest::StatisticsReporter
  description: |-
    results \[RW\]

    An `Array` of test cases that failed or were skipped.
- name: Minitest::StatisticsReporter#skips
  id: minitest/statisticsreporter#attribute-i-skips
  summary: Total number of tests that where skipped
  belongs_to: Minitest::StatisticsReporter
  description: |-
    skips \[RW\]

    Total number of tests that where skipped.
- name: Minitest::StatisticsReporter#start_time
  id: minitest/statisticsreporter#attribute-i-start_time
  summary: Time the test run started
  belongs_to: Minitest::StatisticsReporter
  description: |-
    start_time \[RW\]

    Time the test run started. If available, the monotonic clock is used and this is a `Float`, otherwise it’s an instance of `Time`.
- name: Minitest::StatisticsReporter#total_time
  id: minitest/statisticsreporter#attribute-i-total_time
  summary: Test run time
  belongs_to: Minitest::StatisticsReporter
  description: |-
    total_time \[RW\]

    [`Test`](test) run time. If available, the monotonic clock is used and this is a `Float`, otherwise it’s an instance of `Time`.

    ### Public Instance Methods
- name: Minitest::SummaryReporter
  id: minitest/summaryreporter
  summary: A reporter that prints the header, summary, and failure details at the end of the run
  description: "# class Minitest::SummaryReporter\n\nParent:  \n[Minitest::StatisticsReporter](statisticsreporter)\n\nA reporter that prints the header, summary, and failure details at the end of the run.\n\nThis is added to the top-level [`CompositeReporter`](compositereporter) at the start of the run. If you want to change the output of minitest via a plugin, pull this out of the composite and replace it with your own.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/SummaryReporter.html](https://docs.seattlerb.org/minitest/Minitest/SummaryReporter.html)"
- name: Minitest::Test
  id: minitest/test
  summary: Subclass Test to create your own tests
  description: "# class Minitest::Test\n\nParent:  \n[Minitest::Runnable](runnable)\n\nIncluded modules:  \n[Minitest::Assertions](assertions), [Minitest::Reportable](reportable), [Minitest::Test::LifecycleHooks](test/lifecyclehooks), [Minitest::Guard](guard)\n\nSubclass [`Test`](test) to create your own tests. Typically you’ll want a [`Test`](test) subclass per implementation class.\n\nSee [`Minitest::Assertions`](assertions)\n\n### Public Class Methods\n\ni_suck_and_my_tests_are_order_dependent!() Show source\n\n``` ruby\n# File lib/minitest/test.rb, line 35\ndef self.i_suck_and_my_tests_are_order_dependent!\n  class << self\n    undef_method :test_order if method_defined? :test_order\n    define_method :test_order do :alpha end\n  end\nend\n```\n\nCall this at the top of your tests when you absolutely positively need to have ordered tests. In doing so, you’re admitting that you suck and your tests are weak.\n\nmake_my_diffs_pretty!() Show source\n\n``` ruby\n# File lib/minitest/test.rb, line 48\ndef self.make_my_diffs_pretty!\n  require \"pp\"\n\n  define_method :mu_pp, &:pretty_inspect\nend\n```\n\nMake diffs for this [`Test`](test) use pretty_inspect so that diff in assert_equal can have more details. NOTE: this is much slower than the regular inspect but much more usable for complex objects.\n\nparallelize_me!() Show source\n\n``` ruby\n# File lib/minitest/test.rb, line 59\ndef self.parallelize_me!\n  include Minitest::Parallel::Test\n  extend Minitest::Parallel::Test::ClassMethods\nend\n```\n\nCall this at the top of your tests when you want to run your tests in parallel. In doing so, you’re admitting that you rule and your tests are awesome.\n\nrunnable_methods() Show source\n\n``` ruby\n# File lib/minitest/test.rb, line 69\ndef self.runnable_methods\n  methods = methods_matching(/^test_/)\n\n  case self.test_order\n  when :random, :parallel then\n    srand Minitest.seed\n    methods.sort.shuffle\n  when :alpha, :sorted then\n    methods.sort\n  else\n    raise \"Unknown test_order: #{self.test_order.inspect}\"\n  end\nend\n```\n\nReturns all instance methods starting with “test\\_”. Based on test_order, the methods are either sorted, randomized (default), or run in parallel.\n\n### Public Instance Methods\n\nrun() Show source\n\n``` ruby\n# File lib/minitest/test.rb, line 86\ndef run\n  with_info_handler do\n    time_it do\n      capture_exceptions do\n        SETUP_METHODS.each do |hook|\n          self.send hook\n        end\n\n        self.send self.name\n      end\n\n      TEARDOWN_METHODS.each do |hook|\n        capture_exceptions do\n          self.send hook\n        end\n      end\n    end\n  end\n\n  Result.from self # per contract\nend\n```\n\nRuns a single test with setup/teardown hooks.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Test.html](https://docs.seattlerb.org/minitest/Minitest/Test.html)"
- name: Minitest::Test#run
  id: minitest/test#method-i-run
  summary: Runs a single test with setup/teardown hooks
  belongs_to: Minitest::Test
  description: "run () Show source\n\n``` ruby\n# File lib/minitest/test.rb, line 86\ndef run\n  with_info_handler do\n    time_it do\n      capture_exceptions do\n        SETUP_METHODS.each do |hook|\n          self.send hook\n        end\n\n        self.send self.name\n      end\n\n      TEARDOWN_METHODS.each do |hook|\n        capture_exceptions do\n          self.send hook\n        end\n      end\n    end\n  end\n\n  Result.from self # per contract\nend\n```\n\nRuns a single test with setup/teardown hooks.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Test.html](https://docs.seattlerb.org/minitest/Minitest/Test.html)"
- name: Minitest::Test::i_suck_and_my_tests_are_order_dependent!
  id: minitest/test#method-c-i_suck_and_my_tests_are_order_dependent-21
  summary: Call this at the top of your tests when you absolutely positively need to have ordered tests
  belongs_to: Minitest::Test
  description: |-
    i_suck_and_my_tests_are_order_dependent! () Show source

    ``` ruby
    # File lib/minitest/test.rb, line 35
    def self.i_suck_and_my_tests_are_order_dependent!
      class << self
        undef_method :test_order if method_defined? :test_order
        define_method :test_order do :alpha end
      end
    end
    ```

    Call this at the top of your tests when you absolutely positively need to have ordered tests. In doing so, you’re admitting that you suck and your tests are weak.
- name: Minitest::Test::LifecycleHooks
  id: minitest/test/lifecyclehooks
  summary: Provides before/after hooks for setup and teardown
  description: "# module Minitest::Test::LifecycleHooks\n\nProvides before/after hooks for setup and teardown. These are meant for library writers, NOT for regular test authors. See [`before_setup`](lifecyclehooks#method-i-before_setup) for an example.\n\n### Public Instance Methods\n\nafter_setup() Show source\n\n``` ruby\n# File lib/minitest/test.rb, line 163\ndef after_setup; end\n```\n\nRuns before every test, after setup. This hook is meant for libraries to extend minitest. It is not meant to be used by test developers.\n\nSee [`before_setup`](lifecyclehooks#method-i-before_setup) for an example.\n\nafter_teardown() Show source\n\n``` ruby\n# File lib/minitest/test.rb, line 187\ndef after_teardown; end\n```\n\nRuns after every test, after teardown. This hook is meant for libraries to extend minitest. It is not meant to be used by test developers.\n\nSee [`before_setup`](lifecyclehooks#method-i-before_setup) for an example.\n\nbefore_setup() Show source\n\n``` ruby\n# File lib/minitest/test.rb, line 148\ndef before_setup; end\n```\n\nRuns before every test, before setup. This hook is meant for libraries to extend minitest. It is not meant to be used by test developers.\n\nAs a simplistic example:\n\n``` ruby\nmodule MyMinitestPlugin\n  def before_setup\n    super\n    # ... stuff to do before setup is run\n  end\n\n  def after_setup\n    # ... stuff to do after setup is run\n    super\n  end\n\n  def before_teardown\n    super\n    # ... stuff to do before teardown is run\n  end\n\n  def after_teardown\n    # ... stuff to do after teardown is run\n    super\n  end\nend\n\nclass Minitest::Test\n  include MyMinitestPlugin\nend\n```\n\nbefore_teardown() Show source\n\n``` ruby\n# File lib/minitest/test.rb, line 172\ndef before_teardown; end\n```\n\nRuns after every test, before teardown. This hook is meant for libraries to extend minitest. It is not meant to be used by test developers.\n\nSee [`before_setup`](lifecyclehooks#method-i-before_setup) for an example.\n\nsetup() Show source\n\n``` ruby\n# File lib/minitest/test.rb, line 154\ndef setup; end\n```\n\nRuns before every test. Use this to set up before each test run.\n\nteardown() Show source\n\n``` ruby\n# File lib/minitest/test.rb, line 178\ndef teardown; end\n```\n\nRuns after every test. Use this to clean up after each test run.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Test/LifecycleHooks.html](https://docs.seattlerb.org/minitest/Minitest/Test/LifecycleHooks.html)"
- name: Minitest::Test::LifecycleHooks#after_setup
  id: minitest/test/lifecyclehooks#method-i-after_setup
  summary: Runs before every test, after setup
  belongs_to: Minitest::Test::LifecycleHooks
  description: |-
    after_setup () Show source

    ``` ruby
    # File lib/minitest/test.rb, line 163
    def after_setup; end
    ```

    Runs before every test, after setup. This hook is meant for libraries to extend minitest. It is not meant to be used by test developers.

    See [`before_setup`](lifecyclehooks#method-i-before_setup) for an example.
- name: Minitest::Test::LifecycleHooks#after_teardown
  id: minitest/test/lifecyclehooks#method-i-after_teardown
  summary: Runs after every test, after teardown
  belongs_to: Minitest::Test::LifecycleHooks
  description: |-
    after_teardown () Show source

    ``` ruby
    # File lib/minitest/test.rb, line 187
    def after_teardown; end
    ```

    Runs after every test, after teardown. This hook is meant for libraries to extend minitest. It is not meant to be used by test developers.

    See [`before_setup`](lifecyclehooks#method-i-before_setup) for an example.
- name: Minitest::Test::LifecycleHooks#before_setup
  id: minitest/test/lifecyclehooks#method-i-before_setup
  summary: Runs before every test, before setup
  belongs_to: Minitest::Test::LifecycleHooks
  description: |-
    before_setup () Show source

    ``` ruby
    # File lib/minitest/test.rb, line 148
    def before_setup; end
    ```

    Runs before every test, before setup. This hook is meant for libraries to extend minitest. It is not meant to be used by test developers.

    As a simplistic example:

    ``` ruby
    module MyMinitestPlugin
      def before_setup
        super
        # ... stuff to do before setup is run
      end

      def after_setup
        # ... stuff to do after setup is run
        super
      end

      def before_teardown
        super
        # ... stuff to do before teardown is run
      end

      def after_teardown
        # ... stuff to do after teardown is run
        super
      end
    end

    class Minitest::Test
      include MyMinitestPlugin
    end
    ```
- name: Minitest::Test::LifecycleHooks#before_teardown
  id: minitest/test/lifecyclehooks#method-i-before_teardown
  summary: Runs after every test, before teardown
  belongs_to: Minitest::Test::LifecycleHooks
  description: |-
    before_teardown () Show source

    ``` ruby
    # File lib/minitest/test.rb, line 172
    def before_teardown; end
    ```

    Runs after every test, before teardown. This hook is meant for libraries to extend minitest. It is not meant to be used by test developers.

    See [`before_setup`](lifecyclehooks#method-i-before_setup) for an example.
- name: Minitest::Test::LifecycleHooks#setup
  id: minitest/test/lifecyclehooks#method-i-setup
  summary: Runs before every test
  belongs_to: Minitest::Test::LifecycleHooks
  description: |-
    setup () Show source

    ``` ruby
    # File lib/minitest/test.rb, line 154
    def setup; end
    ```

    Runs before every test. Use this to set up before each test run.
- name: Minitest::Test::LifecycleHooks#teardown
  id: minitest/test/lifecyclehooks#method-i-teardown
  summary: Runs after every test
  belongs_to: Minitest::Test::LifecycleHooks
  description: "teardown () Show source\n\n``` ruby\n# File lib/minitest/test.rb, line 178\ndef teardown; end\n```\n\nRuns after every test. Use this to clean up after each test run.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/Test/LifecycleHooks.html](https://docs.seattlerb.org/minitest/Minitest/Test/LifecycleHooks.html)"
- name: Minitest::Test::make_my_diffs_pretty!
  id: minitest/test#method-c-make_my_diffs_pretty-21
  summary: Make diffs for this Test use pretty_inspect so that diff in assert_equal can have more details
  belongs_to: Minitest::Test
  description: |-
    make_my_diffs_pretty! () Show source

    ``` ruby
    # File lib/minitest/test.rb, line 48
    def self.make_my_diffs_pretty!
      require "pp"

      define_method :mu_pp, &:pretty_inspect
    end
    ```

    Make diffs for this [`Test`](test) use pretty_inspect so that diff in assert_equal can have more details. NOTE: this is much slower than the regular inspect but much more usable for complex objects.
- name: Minitest::Test::parallelize_me!
  id: minitest/test#method-c-parallelize_me-21
  summary: Call this at the top of your tests when you want to run your tests in parallel
  belongs_to: Minitest::Test
  description: |-
    parallelize_me! () Show source

    ``` ruby
    # File lib/minitest/test.rb, line 59
    def self.parallelize_me!
      include Minitest::Parallel::Test
      extend Minitest::Parallel::Test::ClassMethods
    end
    ```

    Call this at the top of your tests when you want to run your tests in parallel. In doing so, you’re admitting that you rule and your tests are awesome.
- name: Minitest::Test::runnable_methods
  id: minitest/test#method-c-runnable_methods
  summary: Returns all instance methods starting with “test_”. Based on test_order, the methods are either sorted, randomized (default), or run in parallel
  belongs_to: Minitest::Test
  description: |-
    runnable_methods () Show source

    ``` ruby
    # File lib/minitest/test.rb, line 69
    def self.runnable_methods
      methods = methods_matching(/^test_/)

      case self.test_order
      when :random, :parallel then
        srand Minitest.seed
        methods.sort.shuffle
      when :alpha, :sorted then
        methods.sort
      else
        raise "Unknown test_order: #{self.test_order.inspect}"
      end
    end
    ```

    Returns all instance methods starting with “test\_”. Based on test_order, the methods are either sorted, randomized (default), or run in parallel.

    ### Public Instance Methods
- name: Minitest::TestTask
  id: minitest/testtask
  summary: Minitest::TestTask is a rake helper that generates several rake tasks under the main test task’s name-space
  description: "# class Minitest::TestTask\n\nParent:  \nRake::TaskLib\n\n[`Minitest::TestTask`](testtask) is a rake helper that generates several rake tasks under the main test task’s name-space.\n\n    task <name>      :: the main test task\n    task <name>:cmd  :: prints the command to use\n    task <name>:deps :: runs each test file by itself to find dependency errors\n    task <name>:slow :: runs the tests and reports the slowest 25 tests.\n\nExamples:\n\n``` ruby\nMinitest::TestTask.create\n```\n\nThe most basic and default setup.\n\n``` ruby\nMinitest::TestTask.create :my_tests\n```\n\nThe most basic/default setup, but with a custom name\n\n``` ruby\nMinitest::TestTask.create :unit do |t|\n  t.test_globs = [\"test/unit/**/*_test.rb\"]\n  t.warning = false\nend\n```\n\nCustomize the name and only run unit tests.\n\nNOTE: To hook this task up to the default, make it a dependency:\n\n``` ruby\ntask default: :unit\n```\n\n### Attributes\n\nextra_args\\[RW\\]\n\nExtra arguments to pass to the tests. Defaults empty but gets populated by a number of enviroment variables:\n\nN (-n flag)  \na string or regexp of tests to run.\n\nX (-e flag)  \na string or regexp of tests to exclude.\n\nA (arg)  \nquick way to inject an arbitrary argument (eg A=–help).\n\nSee [`process_env`](testtask#method-i-process_env)\n\nframework\\[RW\\]\n\nThe code to load the framework. Defaults to requiring minitest/autorun…\n\nWhy do I have this as an option?\n\nlibs\\[RW\\]\n\nExtra library directories to include. Defaults to %w\\[lib test .\\]. Also uses $MT_LIB_EXTRAS allowing you to dynamically override/inject directories for custom runs.\n\nname\\[RW\\]\n\nThe name of the task and base name for the other tasks generated.\n\ntest_globs\\[RW\\]\n\nFile globs to find test files. Defaults to something sensible to find test files under the test directory.\n\ntest_prelude\\[RW\\]\n\nOptional: Additional ruby to run before the test framework is loaded.\n\nverbose\\[RW\\]\n\nPrint out commands as they run. Defaults to Rake’s `trace` (-t flag) option.\n\nwarning\\[RW\\]\n\nTurn on ruby warnings (-w flag). Defaults to true.\n\n### Public Class Methods\n\ncreate(name = :test, &block) Show source\n\n``` ruby\n# File lib/minitest/test_task.rb, line 44\ndef self.create name = :test, &block\n  task = new name\n  task.instance_eval(&block) if block\n  task.process_env\n  task.define\n  task\nend\n```\n\nCreate several test-oriented tasks under `name`. Takes an optional block to customize variables.\n\n### Public Instance Methods\n\nmake_test_cmd(globs = test_globs) Show source\n\n``` ruby\n# File lib/minitest/test_task.rb, line 253\ndef make_test_cmd globs = test_globs\n  tests = []\n  tests.concat Dir[*globs].sort.shuffle # TODO: SEED -> srand first?\n  tests.map! { |f| %(require \"#{f}\") }\n\n  runner = []\n  runner << test_prelude if test_prelude\n  runner << framework\n  runner.concat tests\n  runner = runner.join \"; \"\n\n  args  = []\n  args << \"-I#{libs.join(File::PATH_SEPARATOR)}\" unless libs.empty?\n  args << \"-w\" if warning\n  args << '-e'\n  args << \"'#{runner}'\"\n  args << '--'\n  args << extra_args.map(&:shellescape)\n\n  args.join \" \"\nend\n```\n\nGenerate the test command-line.\n\nprocess_env() Show source\n\n``` ruby\n# File lib/minitest/test_task.rb, line 138\ndef process_env\n  warn \"TESTOPTS is deprecated in Minitest::TestTask. Use A instead\" if\n    ENV[\"TESTOPTS\"]\n  warn \"FILTER is deprecated in Minitest::TestTask. Use A instead\" if\n    ENV[\"FILTER\"]\n  warn \"N is deprecated in Minitest::TestTask. Use MT_CPU instead\" if\n    ENV[\"N\"] && ENV[\"N\"].to_i > 0\n\n  lib_extras = (ENV[\"MT_LIB_EXTRAS\"] || \"\").split File::PATH_SEPARATOR\n  self.libs[0,0] = lib_extras\n\n  extra_args << \"-n\" << ENV[\"N\"]                      if ENV[\"N\"]\n  extra_args << \"-e\" << ENV[\"X\"]                      if ENV[\"X\"]\n  extra_args.concat Shellwords.split(ENV[\"TESTOPTS\"]) if ENV[\"TESTOPTS\"]\n  extra_args.concat Shellwords.split(ENV[\"FILTER\"])   if ENV[\"FILTER\"]\n  extra_args.concat Shellwords.split(ENV[\"A\"])        if ENV[\"A\"]\n\n  ENV.delete \"N\" if ENV[\"N\"]\n\n  # TODO? RUBY_DEBUG = ENV[\"RUBY_DEBUG\"]\n  # TODO? ENV[\"RUBY_FLAGS\"]\n\n  extra_args.compact!\nend\n```\n\nExtract variables from the environment and convert them to command line arguments. See [`extra_args`](testtask#attribute-i-extra_args).\n\nEnvironment Variables:\n\nMT_LIB_EXTRAS  \nExtra libs to dynamically override/inject for custom runs.\n\nN  \nTests to run (string or /regexp/).\n\nX  \nTests to exclude (string or /regexp/).\n\nA  \nAny extra arguments. Honors shell quoting.\n\nDeprecated:\n\nTESTOPTS  \nFor argument passing, use `A`.\n\nN  \nFor parallel testing, use `MT_CPU`.\n\nFILTER  \nSame as `TESTOPTS`.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/TestTask.html](https://docs.seattlerb.org/minitest/Minitest/TestTask.html)"
- name: Minitest::TestTask#extra_args
  id: minitest/testtask#attribute-i-extra_args
  summary: Extra arguments to pass to the tests
  belongs_to: Minitest::TestTask
  description: |-
    extra_args \[RW\]

    Extra arguments to pass to the tests. Defaults empty but gets populated by a number of enviroment variables:

    N (-n flag)

    a string or regexp of tests to run.

    X (-e flag)

    a string or regexp of tests to exclude.

    A (arg)

    quick way to inject an arbitrary argument (eg A=–help).

    See [`process_env`](testtask#method-i-process_env)
- name: Minitest::TestTask#framework
  id: minitest/testtask#attribute-i-framework
  summary: The code to load the framework
  belongs_to: Minitest::TestTask
  description: |-
    framework \[RW\]

    The code to load the framework. Defaults to requiring minitest/autorun…

    Why do I have this as an option?
- name: Minitest::TestTask#libs
  id: minitest/testtask#attribute-i-libs
  summary: Extra library directories to include
  belongs_to: Minitest::TestTask
  description: |-
    libs \[RW\]

    Extra library directories to include. Defaults to %w\[lib test .\]. Also uses $MT_LIB_EXTRAS allowing you to dynamically override/inject directories for custom runs.
- name: Minitest::TestTask#make_test_cmd
  id: minitest/testtask#method-i-make_test_cmd
  summary: Generate the test command-line
  belongs_to: Minitest::TestTask
  description: |-
    make_test_cmd (globs = test_globs) Show source

    ``` ruby
    # File lib/minitest/test_task.rb, line 253
    def make_test_cmd globs = test_globs
      tests = []
      tests.concat Dir[*globs].sort.shuffle # TODO: SEED -> srand first?
      tests.map! { |f| %(require "#{f}") }

      runner = []
      runner << test_prelude if test_prelude
      runner << framework
      runner.concat tests
      runner = runner.join "; "

      args  = []
      args << "-I#{libs.join(File::PATH_SEPARATOR)}" unless libs.empty?
      args << "-w" if warning
      args << '-e'
      args << "'#{runner}'"
      args << '--'
      args << extra_args.map(&:shellescape)

      args.join " "
    end
    ```

    Generate the test command-line.
- name: Minitest::TestTask#name
  id: minitest/testtask#attribute-i-name
  summary: The name of the task and base name for the other tasks generated
  belongs_to: Minitest::TestTask
  description: |-
    name \[RW\]

    The name of the task and base name for the other tasks generated.
- name: Minitest::TestTask#process_env
  id: minitest/testtask#method-i-process_env
  summary: Extract variables from the environment and convert them to command line arguments
  belongs_to: Minitest::TestTask
  description: "process_env () Show source\n\n``` ruby\n# File lib/minitest/test_task.rb, line 138\ndef process_env\n  warn \"TESTOPTS is deprecated in Minitest::TestTask. Use A instead\" if\n    ENV[\"TESTOPTS\"]\n  warn \"FILTER is deprecated in Minitest::TestTask. Use A instead\" if\n    ENV[\"FILTER\"]\n  warn \"N is deprecated in Minitest::TestTask. Use MT_CPU instead\" if\n    ENV[\"N\"] && ENV[\"N\"].to_i > 0\n\n  lib_extras = (ENV[\"MT_LIB_EXTRAS\"] || \"\").split File::PATH_SEPARATOR\n  self.libs[0,0] = lib_extras\n\n  extra_args << \"-n\" << ENV[\"N\"]                      if ENV[\"N\"]\n  extra_args << \"-e\" << ENV[\"X\"]                      if ENV[\"X\"]\n  extra_args.concat Shellwords.split(ENV[\"TESTOPTS\"]) if ENV[\"TESTOPTS\"]\n  extra_args.concat Shellwords.split(ENV[\"FILTER\"])   if ENV[\"FILTER\"]\n  extra_args.concat Shellwords.split(ENV[\"A\"])        if ENV[\"A\"]\n\n  ENV.delete \"N\" if ENV[\"N\"]\n\n  # TODO? RUBY_DEBUG = ENV[\"RUBY_DEBUG\"]\n  # TODO? ENV[\"RUBY_FLAGS\"]\n\n  extra_args.compact!\nend\n```\n\nExtract variables from the environment and convert them to command line arguments. See [`extra_args`](testtask#attribute-i-extra_args).\n\nEnvironment Variables:\n\nMT_LIB_EXTRAS\n\nExtra libs to dynamically override/inject for custom runs.\n\nN\n\nTests to run (string or /regexp/).\n\nX\n\nTests to exclude (string or /regexp/).\n\nA\n\nAny extra arguments. Honors shell quoting.\n\nDeprecated:\n\nTESTOPTS\n\nFor argument passing, use `A`.\n\nN\n\nFor parallel testing, use `MT_CPU`.\n\nFILTER\n\nSame as `TESTOPTS`.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/TestTask.html](https://docs.seattlerb.org/minitest/Minitest/TestTask.html)"
- name: Minitest::TestTask#test_globs
  id: minitest/testtask#attribute-i-test_globs
  summary: File globs to find test files
  belongs_to: Minitest::TestTask
  description: |-
    test_globs \[RW\]

    File globs to find test files. Defaults to something sensible to find test files under the test directory.
- name: Minitest::TestTask#test_prelude
  id: minitest/testtask#attribute-i-test_prelude
  summary: 'Optional: Additional ruby to run before the test framework is loaded'
  belongs_to: Minitest::TestTask
  description: |-
    test_prelude \[RW\]

    Optional: Additional ruby to run before the test framework is loaded.
- name: Minitest::TestTask#verbose
  id: minitest/testtask#attribute-i-verbose
  summary: Print out commands as they run
  belongs_to: Minitest::TestTask
  description: |-
    verbose \[RW\]

    Print out commands as they run. Defaults to Rake’s `trace` (-t flag) option.
- name: Minitest::TestTask#warning
  id: minitest/testtask#attribute-i-warning
  summary: Turn on ruby warnings (-w flag)
  belongs_to: Minitest::TestTask
  description: |-
    warning \[RW\]

    Turn on ruby warnings (-w flag). Defaults to true.

    ### Public Class Methods
- name: Minitest::TestTask::create
  id: minitest/testtask#method-c-create
  summary: Create several test-oriented tasks under name
  belongs_to: Minitest::TestTask
  description: |-
    create (name = :test, &block) Show source

    ``` ruby
    # File lib/minitest/test_task.rb, line 44
    def self.create name = :test, &block
      task = new name
      task.instance_eval(&block) if block
      task.process_env
      task.define
      task
    end
    ```

    Create several test-oriented tasks under `name`. Takes an optional block to customize variables.

    ### Public Instance Methods
- name: Minitest::UnexpectedError
  id: minitest/unexpectederror
  summary: Assertion wrapping an unexpected error that was raised during a run
  description: "# class Minitest::UnexpectedError\n\nParent:  \n[Minitest::Assertion](assertion)\n\n[`Assertion`](assertion) wrapping an unexpected error that was raised during a run.\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Minitest/UnexpectedError.html](https://docs.seattlerb.org/minitest/Minitest/UnexpectedError.html)"
- name: Object
  id: object
  summary: Object extensions for Minitest::Mock
  description: "# class Object\n\nParent:  \nBasicObject\n\n[`Object`](object) extensions for [`Minitest::Mock`](minitest/mock).\n\n### Public Instance Methods\n\nstub(name, val_or_callable, \\*block_args, \\*\\*block_kwargs, &block) Show source\n\n``` ruby\n# File lib/minitest/mock.rb, line 278\ndef stub name, val_or_callable, *block_args, **block_kwargs, &block\n  new_name = \"__minitest_stub__#{name}\"\n\n  metaclass = class << self; self; end\n\n  if respond_to? name and not methods.map(&:to_s).include? name.to_s then\n    metaclass.send :define_method, name do |*args, **kwargs|\n      super(*args, **kwargs)\n    end\n  end\n\n  metaclass.send :alias_method, new_name, name\n\n  if ENV[\"MT_KWARGS_HAC\\K\"] then\n    metaclass.send :define_method, name do |*args, &blk|\n      if val_or_callable.respond_to? :call then\n        val_or_callable.call(*args, &blk)\n      else\n        blk.call(*block_args, **block_kwargs) if blk\n        val_or_callable\n      end\n    end\n  else\n    metaclass.send :define_method, name do |*args, **kwargs, &blk|\n      if val_or_callable.respond_to? :call then\n        if kwargs.empty? then # FIX: drop this after 2.7 dead\n          val_or_callable.call(*args, &blk)\n        else\n          val_or_callable.call(*args, **kwargs, &blk)\n        end\n      else\n        if blk then\n          if block_kwargs.empty? then # FIX: drop this after 2.7 dead\n            blk.call(*block_args)\n          else\n            blk.call(*block_args, **block_kwargs)\n          end\n        end\n        val_or_callable\n      end\n    end\n  end\n\n  block[self]\nensure\n  metaclass.send :undef_method, name\n  metaclass.send :alias_method, name, new_name\n  metaclass.send :undef_method, new_name\nend\n```\n\nAdd a temporary stubbed method replacing `name` for the duration of the `block`. If `val_or_callable` responds to call, then it returns the result of calling it, otherwise returns the value as-is. If stubbed method yields a block, `block_args` will be passed along. Cleans up the stub at the end of the `block`. The method `name` must exist before stubbing.\n\n``` ruby\ndef test_stale_eh\n  obj_under_test = Something.new\n  refute obj_under_test.stale?\n\n  Time.stub :now, Time.at(0) do\n    assert obj_under_test.stale?\n  end\nend\n```\n\nCalls superclass method\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Object.html](https://docs.seattlerb.org/minitest/Object.html)"
- name: Object#stub
  id: object#method-i-stub
  summary: Add a temporary stubbed method replacing name for the duration of the block
  belongs_to: Object
  description: "stub (name, val_or_callable, \\*block_args, \\*\\*block_kwargs, &block) Show source\n\n``` ruby\n# File lib/minitest/mock.rb, line 278\ndef stub name, val_or_callable, *block_args, **block_kwargs, &block\n  new_name = \"__minitest_stub__#{name}\"\n\n  metaclass = class << self; self; end\n\n  if respond_to? name and not methods.map(&:to_s).include? name.to_s then\n    metaclass.send :define_method, name do |*args, **kwargs|\n      super(*args, **kwargs)\n    end\n  end\n\n  metaclass.send :alias_method, new_name, name\n\n  if ENV[\"MT_KWARGS_HAC\\K\"] then\n    metaclass.send :define_method, name do |*args, &blk|\n      if val_or_callable.respond_to? :call then\n        val_or_callable.call(*args, &blk)\n      else\n        blk.call(*block_args, **block_kwargs) if blk\n        val_or_callable\n      end\n    end\n  else\n    metaclass.send :define_method, name do |*args, **kwargs, &blk|\n      if val_or_callable.respond_to? :call then\n        if kwargs.empty? then # FIX: drop this after 2.7 dead\n          val_or_callable.call(*args, &blk)\n        else\n          val_or_callable.call(*args, **kwargs, &blk)\n        end\n      else\n        if blk then\n          if block_kwargs.empty? then # FIX: drop this after 2.7 dead\n            blk.call(*block_args)\n          else\n            blk.call(*block_args, **block_kwargs)\n          end\n        end\n        val_or_callable\n      end\n    end\n  end\n\n  block[self]\nensure\n  metaclass.send :undef_method, name\n  metaclass.send :alias_method, name, new_name\n  metaclass.send :undef_method, new_name\nend\n```\n\nAdd a temporary stubbed method replacing `name` for the duration of the `block`. If `val_or_callable` responds to call, then it returns the result of calling it, otherwise returns the value as-is. If stubbed method yields a block, `block_args` will be passed along. Cleans up the stub at the end of the `block`. The method `name` must exist before stubbing.\n\n``` ruby\ndef test_stale_eh\n  obj_under_test = Something.new\n  refute obj_under_test.stale?\n\n  Time.stub :now, Time.at(0) do\n    assert obj_under_test.stale?\n  end\nend\n```\n\nCalls superclass method\n\n© Ryan Davis, seattle.rb  \nLicensed under the MIT License.  \n[https://docs.seattlerb.org/minitest/Object.html](https://docs.seattlerb.org/minitest/Object.html)"
