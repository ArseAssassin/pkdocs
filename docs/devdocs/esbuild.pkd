---
name: esbuild
slug: esbuild
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © 2020 Evan Wallace
  Licensed under the MIT License.
  https://esbuild.github.io/
homepage: https://esbuild.github.io/

---
- name: Accessing build options
  id: plugins/index#build-options
  summary: Plugins can access the initial build options from within the setup method
  belongs_to: Plugins
  description: |-
    ## Accessing build options

    Plugins can access the initial build options from within the `setup` method. This lets you inspect how the build is configured as well as modify the build options before the build starts. Here is an example:

    ``` javascript
    let examplePlugin = {
      name: 'auto-node-env',
      setup(build) {
        const options = build.initialOptions
        options.define = options.define || {}
        options.define['process.env.NODE_ENV'] =
          options.minify ? '"production"' : '"development"'
      },
    }
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"

    var examplePlugin = api.Plugin{
      Name: "auto-node-env",
      Setup: func(build api.PluginBuild) {
        options := build.InitialOptions
        if options.Define == nil {
          options.Define = map[string]string{}
        }
        if options.MinifyWhitespace && options.MinifyIdentifiers && options.MinifySyntax {
          options.Define[`process.env.NODE_ENV`] = `"production"`
        } else {
          options.Define[`process.env.NODE_ENV`] = `"development"`
        }
      },
    }

    func main() {
    }
    ```

    Note that modifications to the build options after the build starts do not affect the build. In particular, [rebuilds](../api/index#rebuild), [watch mode](../api/index#watch), and [serve mode](../api/index#serve) do not update their build options if plugins mutate the build options object after the first build has started.
- name: Alias
  id: api/index#alias
  summary: This feature lets you substitute one package for another when bundling
  belongs_to: API
  description: |-
    ### Alias

    *Supported by: [Build](#build)*

    This feature lets you substitute one package for another when bundling. The example below substitutes the package `oldpkg` with the package `newpkg`:

    ``` sh
    esbuild app.js --bundle --alias:oldpkg=newpkg
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      write: true,
      alias: {
        'oldpkg': 'newpkg',
      },
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Write:       true,
        Alias: map[string]string{
          "oldpkg": "newpkg",
        },
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    These new substitutions happen first before all of esbuild's other path resolution logic. One use case for this feature is replacing a node-only package with a browser-friendly package in third-party code that you don't control.

    Note that when an import path is substituted using an alias, the resulting import path is resolved in the working directory instead of in the directory containing the source file with the import path. If needed, the working directory that esbuild uses can be set with the [working directory](#working-directory) feature.
- name: Allow overwrite
  id: api/index#allow-overwrite
  summary: Enabling this setting allows output files to overwrite input files
  belongs_to: API
  description: |-
    ### Allow overwrite

    *Supported by: [Build](#build)*

    Enabling this setting allows output files to overwrite input files. It's not enabled by default because doing so means overwriting your source code, which can lead to data loss if your code is not checked in. But supporting this makes certain workflows easier by avoiding the need for a temporary directory. So you can enable this when you want to deliberately overwrite your source code:

    ``` sh
    esbuild app.js --outdir=. --allow-overwrite
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      outdir: '.',
      allowOverwrite: true,
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints:    []string{"app.js"},
        Outdir:         ".",
        AllowOverwrite: true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Analyze
  id: api/index#analyze
  summary: If you're looking for an interactive visualization, try esbuild's Bundle Size Analyzer instead
  belongs_to: API
  description: |-
    ### Analyze

    *Supported by: [Build](#build)*

    If you're looking for an interactive visualization, try esbuild's [Bundle Size Analyzer](../analyze/index) instead. You can upload your esbuild [metafile](#metafile) to see a bundle size breakdown.

    Using the analyze feature generates an easy-to-read report about the contents of your bundle:

    ``` sh
    esbuild --bundle example.jsx --outfile=out.js --minify --analyze

      out.js                                                                    27.6kb  100.0%
       ├ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js  19.2kb   69.8%
       ├ node_modules/react/cjs/react.production.min.js                          5.9kb   21.4%
       ├ node_modules/object-assign/index.js                                     962b     3.4%
       ├ example.jsx                                                             137b     0.5%
       ├ node_modules/react-dom/server.browser.js                                 50b     0.2%
       └ node_modules/react/index.js                                              50b     0.2%

    ...
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let result = await esbuild.build({
      entryPoints: ['example.jsx'],
      outfile: 'out.js',
      minify: true,
      metafile: true,
    })

    console.log(await esbuild.analyzeMetafile(result.metafile))
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "fmt"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints:       []string{"example.jsx"},
        Outfile:           "out.js",
        MinifyWhitespace:  true,
        MinifyIdentifiers: true,
        MinifySyntax:      true,
        Metafile:          true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }

      fmt.Printf("%s", api.AnalyzeMetafile(result.Metafile, api.AnalyzeMetafileOptions{}))
    }
    ```

    The information shows which input files ended up in each output file as well as the percentage of the output file they ended up taking up. If you would like additional information, you can enable the "verbose" mode. This currently shows the import path from the entry point to each input file which tells you why a given input file is being included in the bundle:

    ``` sh
    esbuild --bundle example.jsx --outfile=out.js --minify --analyze=verbose

      out.js ─────────────────────────────────────────────────────────────────── 27.6kb ─ 100.0%
       ├ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js ─ 19.2kb ── 69.8%
       │  └ node_modules/react-dom/server.browser.js
       │     └ example.jsx
       ├ node_modules/react/cjs/react.production.min.js ───────────────────────── 5.9kb ── 21.4%
       │  └ node_modules/react/index.js
       │     └ example.jsx
       ├ node_modules/object-assign/index.js ──────────────────────────────────── 962b ──── 3.4%
       │  └ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js
       │     └ node_modules/react-dom/server.browser.js
       │        └ example.jsx
       ├ example.jsx ──────────────────────────────────────────────────────────── 137b ──── 0.5%
       ├ node_modules/react-dom/server.browser.js ──────────────────────────────── 50b ──── 0.2%
       │  └ example.jsx
       └ node_modules/react/index.js ───────────────────────────────────────────── 50b ──── 0.2%
          └ example.jsx

    ...
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let result = await esbuild.build({
      entryPoints: ['example.jsx'],
      outfile: 'out.js',
      minify: true,
      metafile: true,
    })

    console.log(await esbuild.analyzeMetafile(result.metafile, {
      verbose: true,
    }))
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "fmt"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints:       []string{"example.jsx"},
        Outfile:           "out.js",
        MinifyWhitespace:  true,
        MinifyIdentifiers: true,
        MinifySyntax:      true,
        Metafile:          true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }

      fmt.Printf("%s", api.AnalyzeMetafile(result.Metafile, api.AnalyzeMetafileOptions{
        Verbose: true,
      }))
    }
    ```

    This analysis is just a visualization of the information that can be found in the [metafile](#metafile). If this analysis doesn't exactly suit your needs, you are welcome to build your own visualization using the information in the metafile.

    Note that this formatted analysis summary is intended for humans, not machines. The specific formatting may change over time which will likely break any tools that try to parse it. You should not write a tool to parse this data. You should be using the information in the [JSON metadata file](#metafile) instead. Everything in this visualization is derived from the JSON metadata so you are not losing out on any information by not parsing esbuild's formatted analysis summary.
- name: Anti-virus software
  id: faq/index#anti-virus-software
  summary: Since esbuild is written in native code, anti-virus software can sometimes incorrectly flag it as a virus
  belongs_to: FAQ
  description: |-
    ## Anti-virus software

    Since esbuild is written in native code, anti-virus software can sometimes incorrectly flag it as a virus. *This does not mean esbuild is a virus.* I do not publish malicious code and I take supply chain security very seriously.

    Virtually all of esbuild's code is first-party code except for [one dependency](https://github.com/evanw/esbuild/blob/main/go.mod) on Google's set of supplemental Go packages. My development work is done on different machine that is isolated from the one I use to publish builds. I have done additional work to ensure that esbuild's published builds are completely reproducible and after every release, published builds are [automatically compared](https://github.com/evanw/esbuild/blob/main/.github/workflows/validate.yml) to ones locally-built in an unrelated environment to ensure that they are bitwise identical (i.e. that the Go compiler itself has not been compromised). You can also build esbuild from source yourself and compare your build artifacts to the published ones to independently verify this.

    Having to deal with false-positives is an unfortunate reality of using anti-virus software. Here are some possible workarounds if your anti-virus won't let you use esbuild:

    - Ignore your anti-virus software and remove esbuild from quarantine
    - Report the specific esbuild native executable as a false-positive to your anti-virus software vendor
    - Use [`esbuild-wasm`](../getting-started/index#wasm) instead of `esbuild` to bypass your anti-virus software (which likely won't flag WebAssembly files the same way it flags native executables)
    - Use another build tool instead of esbuild

    &nbsp;
- name: API
  id: api/index
  summary: 'The API can be accessed in one of three languages: on the command line, in JavaScript, and in Go'
  description: "# API\n\nThe API can be accessed in one of three languages: on the command line, in JavaScript, and in Go. The concepts and parameters are largely identical between the three languages so they will be presented together here instead of having separate documentation for each language. You can switch between languages using the `CLI`, `JS`, and `Go` tabs in the top-right corner of each code example. Some specifics for each language:\n\n- **CLI:** If you are using the command-line API, it may be helpful to know that the flags come in one of three forms: `--foo`, `--foo=bar`, or `--foo:bar`. The form `--foo` is used for enabling boolean flags such as [`--minify`](#minify), the form `--foo=bar` is used for flags that have a single value and are only specified once such as [`--platform=`](#platform), and the form `--foo:bar` is used for flags that have multiple values and can be re-specified multiple times such as [`--external:`](#external).\n\n  Also keep in mind that using a CLI (in general, not specific to esbuild) means that your current shell interprets the command's arguments before the command you are running sees them. For example, even though the `echo` command just writes out what it reads in, `echo \"foo\"` can print `foo` instead of `\"foo\"`, and `echo *.json` can print `package.json` instead of `*.json` (the specific behavior depends on which shell you use). If you want to avoid the problems that shell-specific behavior can cause, then you should use esbuild's JavaScript or Go APIs instead of esbuild's CLI.\n\n- **JavaScript:** If you are using JavaScript be sure to check out the [JS-specific details](#js-details) and [browser](#browser) sections below. You may also find the [TypeScript type definitions](https://github.com/evanw/esbuild/blob/main/lib/shared/types.ts) for esbuild helpful as a reference.\n\n- **Go:** If you are using Go, you may find the automatically generated Go documentation for esbuild helpful as a reference. There is separate documentation for both of the public Go packages: [`pkg/api`](https://pkg.go.dev/github.com/evanw/esbuild/pkg/api) and [`pkg/cli`](https://pkg.go.dev/github.com/evanw/esbuild/pkg/cli).\n\n## Overview\n\nThe two most commonly-used esbuild APIs are [build](#build) and [transform](#transform). Each is described below at a high level, followed by documentation for each individual API option.\n\n### Build\n\nThis is the primary interface to esbuild. You typically pass one or more [entry point](#entry-points) files to process along with various options, and then esbuild writes the results back out to the file system. Here's a simple example that enables [bundling](#bundle) with an [output directory](#outdir):\n\n``` sh\nesbuild app.ts --bundle --outdir=dist\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet result = await esbuild.build({\n  entryPoints: ['app.ts'],\n  bundle: true,\n  outdir: 'dist',\n})\nconsole.log(result)\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.ts\"},\n    Bundle:      true,\n    Outdir:      \"dist\",\n  })\n  if len(result.Errors) != 0 {\n    os.Exit(1)\n  }\n}\n```\n\nAdvanced use of the build API involves setting up a long-running build context. This context is an explicit object in JS and Go but is implicit with the CLI. All builds done with a given context share the same build options, and subsequent builds are done incrementally (i.e. they reuse some work from previous builds to improve performance). This is useful for development because esbuild can rebuild your app in the background for you while you work.\n\nThere are three different incremental build APIs:\n\n- [**Watch mode**](#watch) tells esbuild to watch the file system and automatically rebuild for you whenever you edit and save a file that could invalidate the build. Here's an example:\n\n``` sh\nesbuild app.ts --bundle --outdir=dist --watch\n[watch] build finished, watching for changes...\n```\n\n``` javascript\nlet ctx = await esbuild.context({\n  entryPoints: ['app.ts'],\n  bundle: true,\n  outdir: 'dist',\n})\n\nawait ctx.watch()\n```\n\n``` go\nctx, err := api.Context(api.BuildOptions{\n  EntryPoints: []string{\"app.ts\"},\n  Bundle:      true,\n  Outdir:      \"dist\",\n})\n\nerr2 := ctx.Watch(api.WatchOptions{})\n```\n\n- [**Serve mode**](#serve) starts a local development server that serves the results of the latest build. Incoming requests automatically start new builds so your web app is always up to date when you reload the page in the browser. Here's an example:\n\n``` sh\nesbuild app.ts --bundle --outdir=dist --serve\n\n > Local:   http://127.0.0.1:8000/\n > Network: http://192.168.0.1:8000/\n\n127.0.0.1:61302 - \"GET /\" 200 [1ms]\n```\n\n``` javascript\nlet ctx = await esbuild.context({\n  entryPoints: ['app.ts'],\n  bundle: true,\n  outdir: 'dist',\n})\n\nlet { host, port } = await ctx.serve()\n```\n\n``` go\nctx, err := api.Context(api.BuildOptions{\n  EntryPoints: []string{\"app.ts\"},\n  Bundle:      true,\n  Outdir:      \"dist\",\n})\n\nserver, err2 := ctx.Serve(api.ServeOptions{})\n```\n\n- [**Rebuild mode**](#rebuild) lets you manually invoke a build. This is useful when integrating esbuild with other tools (e.g. using a custom file watcher or development server instead of esbuild's built-in ones). Here's an example:\n\n``` sh\n# The CLI does not have an API for \"rebuild\"\n```\n\n``` javascript\nlet ctx = await esbuild.context({\n  entryPoints: ['app.ts'],\n  bundle: true,\n  outdir: 'dist',\n})\n\nfor (let i = 0; i < 5; i++) {\n  let result = await ctx.rebuild()\n}\n```\n\n``` go\nctx, err := api.Context(api.BuildOptions{\n  EntryPoints: []string{\"app.ts\"},\n  Bundle:      true,\n  Outdir:      \"dist\",\n})\n\nfor i := 0; i < 5; i++ {\n  result := ctx.Rebuild()\n}\n```\n\nThese three incremental build APIs can be combined. To enable [live reloading](#live-reload) (automatically reloading the page when you edit and save a file) you'll need to enable [watch](#watch) and [serve](#serve) together on the same context.\n\nWhen you are done with a context object, you can call `dispose()` on the context to wait for existing builds to finish, stop watch and/or serve mode, and free up resources.\n\nThe build and context APIs both take the following options:\n\n**General options:**\n\n- [Bundle](#bundle)\n- [Cancel](#cancel)\n- [Live reload](#live-reload)\n- [Platform](#platform)\n- [Rebuild](#rebuild)\n- [Serve](#serve)\n- [Tsconfig](#tsconfig)\n- [Tsconfig raw](#tsconfig-raw)\n- [Watch](#watch)\n\n  \n**Input:**\n\n- [Entry points](#entry-points)\n- [Loader](#loader)\n- [Stdin](#stdin)\n\n  \n**Output contents:**\n\n- [Banner](#banner)\n- [Charset](#charset)\n- [Footer](#footer)\n- [Format](#format)\n- [Global name](#global-name)\n- [Legal comments](#legal-comments)\n- [Line limit](#line-limit)\n- [Splitting](#splitting)\n\n  \n\n**Output location:**\n\n- [Allow overwrite](#allow-overwrite)\n- [Asset names](#asset-names)\n- [Chunk names](#chunk-names)\n- [Entry names](#entry-names)\n- [Out extension](#out-extension)\n- [Outbase](#outbase)\n- [Outdir](#outdir)\n- [Outfile](#outfile)\n- [Public path](#public-path)\n- [Write](#write)\n\n  \n**Path resolution:**\n\n- [Alias](#alias)\n- [Conditions](#conditions)\n- [External](#external)\n- [Main fields](#main-fields)\n- [Node paths](#node-paths)\n- [Packages](#packages)\n- [Preserve symlinks](#preserve-symlinks)\n- [Resolve extensions](#resolve-extensions)\n- [Working directory](#working-directory)\n\n  \n\n**Transformation:**\n\n- [JSX](#jsx)\n- [JSX dev](#jsx-dev)\n- [JSX factory](#jsx-factory)\n- [JSX fragment](#jsx-fragment)\n- [JSX import source](#jsx-import-source)\n- [JSX side effects](#jsx-side-effects)\n- [Supported](#supported)\n- [Target](#target)\n\n  \n**Optimization:**\n\n- [Define](#define)\n- [Drop](#drop)\n- [Drop labels](#drop-labels)\n- [Ignore annotations](#ignore-annotations)\n- [Inject](#inject)\n- [Keep names](#keep-names)\n- [Mangle props](#mangle-props)\n- [Minify](#minify)\n- [Pure](#pure)\n- [Tree shaking](#tree-shaking)\n\n  \n\n**Source maps:**\n\n- [Source root](#source-root)\n- [Sourcefile](#sourcefile)\n- [Sourcemap](#sourcemap)\n- [Sources content](#sources-content)\n\n  \n**Build metadata:**\n\n- [Analyze](#analyze)\n- [Metafile](#metafile)\n\n  \n**Logging:**\n\n- [Color](#color)\n- [Format messages](#format-messages)\n- [Log level](#log-level)\n- [Log limit](#log-limit)\n- [Log override](#log-override)\n\n  \n\n### Transform\n\nThis is a limited special-case of [build](#build) that transforms a string of code representing an in-memory file in an isolated environment that's completely disconnected from any other files. Common uses include minifying code and transforming TypeScript into JavaScript. Here's an example:\n\n``` sh\necho 'let x: number = 1' | esbuild --loader=ts\nlet x = 1;\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet ts = 'let x: number = 1'\nlet result = await esbuild.transform(ts, {\n  loader: 'ts',\n})\nconsole.log(result)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  ts := \"let x: number = 1\"\n  result := api.Transform(ts, api.TransformOptions{\n    Loader: api.LoaderTS,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\nTaking a string instead of a file as input is more ergonomic for certain use cases. File system isolation has certain advantages (e.g. works in the browser, not affected by nearby `package.json` files) and certain disadvantages (e.g. can't be used with [bundling](#bundle) or [plugins](../plugins/index)). If your use case doesn't fit the transform API then you should use the more general [build](#build) API instead.\n\nThe transform API takes the following options:\n\n**General options:**\n\n- [Platform](#platform)\n- [Tsconfig raw](#tsconfig-raw)\n\n  \n**Input:**\n\n- [Loader](#loader)\n\n  \n\n**Output contents:**\n\n- [Banner](#banner)\n- [Charset](#charset)\n- [Footer](#footer)\n- [Format](#format)\n- [Global name](#global-name)\n- [Legal comments](#legal-comments)\n- [Line limit](#line-limit)\n\n  \n\n**Transformation:**\n\n- [JSX](#jsx)\n- [JSX dev](#jsx-dev)\n- [JSX factory](#jsx-factory)\n- [JSX fragment](#jsx-fragment)\n- [JSX import source](#jsx-import-source)\n- [JSX side effects](#jsx-side-effects)\n- [Supported](#supported)\n- [Target](#target)\n\n  \n\n**Optimization:**\n\n- [Define](#define)\n- [Drop](#drop)\n- [Drop labels](#drop-labels)\n- [Ignore annotations](#ignore-annotations)\n- [Keep names](#keep-names)\n- [Mangle props](#mangle-props)\n- [Minify](#minify)\n- [Pure](#pure)\n- [Tree shaking](#tree-shaking)\n\n  \n\n**Source maps:**\n\n- [Source root](#source-root)\n- [Sourcefile](#sourcefile)\n- [Sourcemap](#sourcemap)\n- [Sources content](#sources-content)\n\n  \n**Logging:**\n\n- [Color](#color)\n- [Format messages](#format-messages)\n- [Log level](#log-level)\n- [Log limit](#log-limit)\n- [Log override](#log-override)\n\n  \n\n### JS-specific details\n\nThe JS API for esbuild comes in both asynchronous and synchronous flavors. The [asynchronous API](#js-async) is recommended because it works in all environments and it's faster and more powerful. The [synchronous API](#js-sync) only works in node and can only do certain things, but it's sometimes necessary in certain node-specific situations. In detail:\n\n#### Async API\n\nAsynchronous API calls return their results using a promise. Note that you'll likely have to use the `.mjs` file extension in node due to the use of the `import` and top-level `await` keywords:\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet result1 = await esbuild.transform(code, options)\nlet result2 = await esbuild.build(options)\n```\n\nPros:\n\n- You can use [plugins](../plugins/index) with the asynchronous API\n- The current thread is not blocked so you can perform other work in the meantime\n- You can run many simultaneous esbuild API calls concurrently which are then spread across all available CPUs for maximum performance\n\nCons:\n\n- Using promises can result in messier code, especially in CommonJS where [top-level await](https://v8.dev/features/top-level-await) is not available\n- Doesn't work in situations that must be synchronous such as within [`require.extensions`](https://nodejs.org/api/modules.html#requireextensions)\n\n#### Sync API\n\nSynchronous API calls return their results inline:\n\n``` javascript\nlet esbuild = require('esbuild')\n\nlet result1 = esbuild.transformSync(code, options)\nlet result2 = esbuild.buildSync(options)\n```\n\nPros:\n\n- Avoiding promises can result in cleaner code, especially when [top-level await](https://v8.dev/features/top-level-await) is not available\n- Works in situations that must be synchronous such as within [`require.extensions`](https://nodejs.org/api/modules.html#requireextensions)\n\nCons:\n\n- You can't use [plugins](../plugins/index) with the synchronous API since plugins are asynchronous\n- It blocks the current thread so you can't perform other work in the meantime\n- Using the synchronous API prevents esbuild from parallelizing esbuild API calls\n\n### In the browser\n\nThe esbuild API can also run in the browser using WebAssembly in a Web Worker. To take advantage of this you will need to install the `esbuild-wasm` package instead of the `esbuild` package:\n\n``` javascript\nnpm install esbuild-wasm\n```\n\nThe API for the browser is similar to the API for node except that you need to call `initialize()` first, and you need to pass the URL of the WebAssembly binary. The synchronous versions of the API are also not available. Assuming you are using a bundler, that would look something like this:\n\n``` javascript\nimport * as esbuild from 'esbuild-wasm'\n\nawait esbuild.initialize({\n  wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',\n})\n\nlet result1 = await esbuild.transform(code, options)\nlet result2 = esbuild.build(options)\n```\n\nIf you're already running this code from a worker and don't want `initialize` to create another worker, you can pass `worker: false` to it. Then it will create a WebAssembly module in the same thread as the thread that calls `initialize`.\n\nYou can also use esbuild's API as a script tag in a HTML file without needing to use a bundler by loading the `lib/browser.min.js` file with a `<script>` tag. In this case the API creates a global called `esbuild` that holds the API object:\n\n``` javascript\n<script src=\"./node_modules/esbuild-wasm/lib/browser.min.js\"></script>\n<script>\n  esbuild.initialize({\n    wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',\n  }).then(() => {\n    ...\n  })\n</script>\n```\n\nIf you want to use this API with ECMAScript modules, you should import the `esm/browser.min.js` file instead:\n\n``` javascript\n<script type=\"module\">\n  import * as esbuild from './node_modules/esbuild-wasm/esm/browser.min.js'\n\n  await esbuild.initialize({\n    wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',\n  })\n\n  ...\n</script>\n```\n\n## General options\n\n### Bundle\n\n*Supported by: [Build](#build)*\n\nTo bundle a file means to inline any imported dependencies into the file itself. This process is recursive so dependencies of dependencies (and so on) will also be inlined. By default esbuild will *not* bundle the input files. Bundling must be explicitly enabled like this:\n\n``` sh\nesbuild in.js --bundle\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nconsole.log(await esbuild.build({\n  entryPoints: ['in.js'],\n  bundle: true,\n  outfile: 'out.js',\n}))\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"in.js\"},\n    Bundle:      true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nRefer to the [getting started guide](../getting-started/index#your-first-bundle) for an example of bundling with real-world code.\n\nNote that bundling is different than file concatenation. Passing esbuild multiple input files with bundling enabled will create multiple separate bundles instead of joining the input files together. To join a set of files together with esbuild, import them all into a single entry point file and bundle just that one file with esbuild.\n\n#### Non-analyzable imports\n\nImport paths are currently only bundled if they are a string literal or a [glob pattern](#glob). Other forms of import paths are not bundled, and are instead preserved verbatim in the generated output. This is because bundling is a compile-time operation and esbuild doesn't support all forms of run-time path resolution. Here are some examples:\n\n``` javascript\n// Analyzable imports (will be bundled by esbuild)\nimport 'pkg';\nimport('pkg');\nrequire('pkg');\nimport(`./locale-${foo}.json`);\nrequire(`./locale-${foo}.json`);\n\n// Non-analyzable imports (will not be bundled by esbuild)\nimport(`pkg/${foo}`);\nrequire(`pkg/${foo}`);\n['pkg'].map(require);\n```\n\nThe way to work around non-analyzable imports is to mark the package containing this problematic code as [external](#external) so that it's not included in the bundle. You will then need to ensure that a copy of the external package is available to your bundled code at run-time.\n\nSome bundlers such as [Webpack](https://webpack.js.org/) try to support all forms of run-time path resolution by including all potentially-reachable files in the bundle and then emulating a file system at run-time. However, run-time file system emulation is out of scope and will not be implemented in esbuild. If you really need to bundle code that does this, you will likely need to use another bundler instead of esbuild.\n\n#### Glob-style imports\n\nImport paths that are evaluated at run-time can now be bundled in certain limited situations. The import path expression must be a form of string concatenation and must start with either `./` or `../`. Each non-string expression in the string concatenation chain becomes a wildcard in a [glob](https://en.wikipedia.org/wiki/Glob_(programming)) pattern. Some examples:\n\n``` javascript\n// These two forms are equivalent\nconst json1 = require('./data/' + kind + '.json')\nconst json2 = require(`./data/${kind}.json`)\n```\n\nWhen you do this, esbuild will search the file system for all files that match the pattern and include all of them in the bundle along with a map that maps the matching import path to the bundled module. The import expression will be replaced with a lookup into that map. An error will be thrown at run-time if the import path is not present in the map. The generated code will look something like this (unimportant parts were omitted for brevity):\n\n``` javascript\n// data/bar.json\nvar require_bar = ...;\n\n// data/foo.json\nvar require_foo = ...;\n\n// require(\"./data/**/*.json\") in example.js\nvar globRequire_data_json = __glob({\n  \"./data/bar.json\": () => require_bar(),\n  \"./data/foo.json\": () => require_foo()\n});\n\n// example.js\nvar json1 = globRequire_data_json(\"./data/\" + kind + \".json\");\nvar json2 = globRequire_data_json(`./data/${kind}.json`);\n```\n\nThis feature works with `require(...)` and `import(...)` because these can all accept run-time expressions. It does not work with `import` and `export` statements because these cannot accept run-time expressions. If you want to prevent esbuild from trying to bundle these imports, you should move the string concatenation expression outside of the `require(...)` or `import(...)`. For example:\n\n``` javascript\n// This will be bundled\nconst json1 = require('./data/' + kind + '.json')\n\n// This will not be bundled\nconst path = './data/' + kind + '.json'\nconst json2 = require(path)\n```\n\nNote that using this feature means esbuild will potentially do a lot of file system I/O to find all possible files that might match the pattern. This is by design, and is not a bug. If this is a concern, there are two ways to reduce the amount of file system I/O that esbuild does:\n\n1.  The simplest approach is to put all files that you want to import for a given run-time import expression in a subdirectory and then include the subdirectory in the pattern. This limits esbuild to searching inside that subdirectory since esbuild doesn't consider `..` path elements during pattern-matching.\n\n2.  Another approach is to prevent esbuild from searching into any subdirectory at all. The pattern matching algorithm that esbuild uses only allows a wildcard to match something containing a `/` path separator if that wildcard has a `/` before it in the pattern. So for example `'./data/' + x + '.json'` will match `x` with anything in any subdirectory while `'./data-' + x + '.json'` will only match `x` with anything in the top-level directory (but not in any subdirectory).\n\n### Cancel\n\n*Supported by: [Build](#build)*\n\nIf you are using [rebuild](#rebuild) to manually invoke incremental builds, you may want to use this cancel API to end the current build early so that you can start a new one. You can do that like this:\n\n``` sh\n# The CLI does not have an API for \"cancel\"\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\nimport process from 'node:process'\n\nlet ctx = await esbuild.context({\n  entryPoints: ['app.ts'],\n  bundle: true,\n  outdir: 'www',\n  logLevel: 'info',\n})\n\n// Whenever we get some data over stdin\nprocess.stdin.on('data', async () => {\n  try {\n    // Cancel the already-running build\n    await ctx.cancel()\n\n    // Then start a new build\n    console.log('build:', await ctx.rebuild())\n  } catch (err) {\n    console.error(err)\n  }\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  ctx, err := api.Context(api.BuildOptions{\n    EntryPoints: []string{\"app.ts\"},\n    Bundle:      true,\n    Outdir:      \"www\",\n    LogLevel:    api.LogLevelInfo,\n  })\n  if err != nil {\n    os.Exit(1)\n  }\n\n  // Whenever we get some data over stdin\n  buf := make([]byte, 100)\n  for {\n    if n, err := os.Stdin.Read(buf); err != nil || n == 0 {\n      break\n    }\n    go func() {\n      // Cancel the already-running build\n      ctx.Cancel()\n\n      // Then start a new build\n      result := ctx.Rebuild()\n      fmt.Fprintf(os.Stderr, \"build: %v\\n\", result)\n    }()\n  }\n}\n```\n\nMake sure to wait until the cancel operation is done before starting a new build (i.e. `await` the returned promise when using JavaScript), otherwise the next [rebuild](#rebuild) will give you the just-canceled build that still hasn't ended yet. Note that plugin [on-end callbacks](../plugins/index#on-end) will still be run regardless of whether or not the build was canceled.\n\n### Live reload\n\n*Supported by: [Build](#build)*\n\nLive reload is an approach to development where you have your browser open and visible at the same time as your code editor. When you edit and save your source code, the browser automatically reloads and the reloaded version of the app contains your changes. This means you can iterate faster because you don't have to manually switch to your browser, reload, and then switch back to your code editor after every change. It's very helpful when changing CSS, for example.\n\nThere is no esbuild API for live reloading directly. Instead, you can construct live reloading by combining [watch mode](#watch) (to automatically start a build when you edit and save a file) and [serve mode](#serve) (to serve the latest build, but block until it's done) plus a small bit of client-side JavaScript code that you add to your app only during development.\n\nThe first step is to enable [watch](#watch) and [serve](#serve) together:\n\n``` sh\nesbuild app.ts --bundle --outdir=www --watch --servedir=www\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet ctx = await esbuild.context({\n  entryPoints: ['app.ts'],\n  bundle: true,\n  outdir: 'www',\n})\n\nawait ctx.watch()\n\nlet { host, port } = await ctx.serve({\n  servedir: 'www',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  ctx, err := api.Context(api.BuildOptions{\n    EntryPoints: []string{\"app.ts\"},\n    Bundle:      true,\n    Outdir:      \"www\",\n  })\n  if err != nil {\n    os.Exit(1)\n  }\n\n  err2 := ctx.Watch(api.WatchOptions{})\n  if err2 != nil {\n    os.Exit(1)\n  }\n\n  result, err3 := ctx.Serve(api.ServeOptions{\n    Servedir: \"www\",\n  })\n  if err3 != nil {\n    os.Exit(1)\n  }\n}\n```\n\nThe second step is to add some code to your JavaScript that subscribes to the `/esbuild` [server-sent event](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events) source. When you get the `change` event, you can reload the page to get the latest version of the app. You can do this in a single line of code:\n\n``` javascript\nnew EventSource('/esbuild').addEventListener('change', () => location.reload())\n```\n\nThat's it! If you load your app in the browser, the page should now automatically reload when you edit and save a file (assuming there are no build errors).\n\nThis should only be included during development, and should not be included in production. One way to remove this code in production is to guard it with an if statement such as `if (!window.IS_PRODUCTION)` and then use [define](#define) to set `window.IS_PRODUCTION` to `true` in production.\n\n#### Live reload caveats\n\nImplementing live reloading like this has a few known caveats:\n\n- These events only trigger when esbuild's output changes. They do not trigger when files unrelated to the build being watched are changed. If your HTML file references other files that esbuild doesn't know about and those files are changed, you can either manually reload the page or you can implement your own live reloading infrastructure instead of using esbuild's built-in behavior.\n\n- The `EventSource` API is supposed to automatically reconnect for you. However, there's [a bug in Firefox](https://bugzilla.mozilla.org/show_bug.cgi?id=1809332) that breaks this if the server is ever temporarily unreachable. Workarounds are to use any other browser, to manually reload the page if this happens, or to write more complicated code that manually closes and re-creates the `EventSource` object if there is a connection error.\n\n- Browser vendors have decided to not implement HTTP/2 without TLS. This means that when using the `http://` protocol, each `/esbuild` event source will take up one of your precious 6 simultaneous per-domain HTTP/1.1 connections. So if you open more than six HTTP tabs that use this live-reloading technique, you will be unable to use live reloading in some of those tabs (and other things will likely also break). The workaround is to [enable the `https://` protocol](#https).\n\n#### Hot-reloading for CSS\n\nThe `change` event also contains additional information to enable more advanced use cases. It currently contains the `added`, `removed`, and `updated` arrays with the paths of the files that have changed since the previous build, which can be described by the following TypeScript interface:\n\n``` javascript\ninterface ChangeEvent {\n  added: string[]\n  removed: string[]\n  updated: string[]\n}\n```\n\nThe code sample below enables \"hot reloading\" for CSS, which is when the CSS is automatically updated in place without reloading the page. If an event arrives that isn't CSS-related, then the whole page will be reloaded as a fallback:\n\n``` javascript\nnew EventSource('/esbuild').addEventListener('change', e => {\n  const { added, removed, updated } = JSON.parse(e.data)\n\n  if (!added.length && !removed.length && updated.length === 1) {\n    for (const link of document.getElementsByTagName(\"link\")) {\n      const url = new URL(link.href)\n\n      if (url.host === location.host && url.pathname === updated[0]) {\n        const next = link.cloneNode()\n        next.href = updated[0] + '?' + Math.random().toString(36).slice(2)\n        next.onload = () => link.remove()\n        link.parentNode.insertBefore(next, link.nextSibling)\n        return\n      }\n    }\n  }\n\n  location.reload()\n})\n```\n\n#### Hot-reloading for JavaScript\n\nHot-reloading for JavaScript is not currently implemented by esbuild. It's possible to transparently implement hot-reloading for CSS because CSS is stateless, but JavaScript is stateful so you cannot transparently implement hot-reloading for JavaScript like you can for CSS.\n\nSome other development servers implement hot-reloading for JavaScript anyway, but it requires additional APIs, sometimes requires framework-specific hacks, and sometimes introduces transient state-related bugs during an editing session. Doing this is outside of esbuild's scope. You are welcome to use other tools instead of esbuild if hot-reloading for JavaScript is one of your requirements.\n\nHowever, with esbuild's live-reloading you can persist your app's current JavaScript state in [`sessionStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage) to more easily restore your app's JavaScript state after a page reload. If your app loads quickly (which it already should for your users' sake), live-reloading with JavaScript can be almost as fast as hot-reloading with JavaScript would be.\n\n### Platform\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nBy default, esbuild's bundler is configured to generate code intended for the browser. If your bundled code is intended to run in node instead, you should set the platform to `node`:\n\n``` sh\nesbuild app.js --bundle --platform=node\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  platform: 'node',\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Platform:    api.PlatformNode,\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nWhen the platform is set to `browser` (the default value):\n\n- When [bundling](#bundle) is enabled the default output [format](#format) is set to `iife`, which wraps the generated JavaScript code in an immediately-invoked function expression to prevent variables from leaking into the global scope.\n\n- If a package specifies a map for the [`browser`](https://gist.github.com/defunctzombie/4339901/49493836fb873ddaa4b8a7aa0ef2352119f69211) field in its `package.json` file, esbuild will use that map to replace specific files or modules with their browser-friendly versions. For example, a package might contain a substitution of [`path`](https://nodejs.org/api/path.html) with [`path-browserify`](https://www.npmjs.com/package/path-browserify).\n\n- The [main fields](#main-fields) setting is set to `browser,module,main` but with some additional special behavior: if a package provides `module` and `main` entry points but not a `browser` entry point then `main` is used instead of `module` if that package is ever imported using `require()`. This behavior improves compatibility with CommonJS modules that export a function by assigning it to `module.exports`. If you want to disable this additional special behavior, you can explicitly set the [main fields](#main-fields) setting to `browser,module,main`.\n\n- The [conditions](#conditions) setting automatically includes the `browser` condition. This changes how the `exports` field in `package.json` files is interpreted to prefer browser-specific code.\n\n- If no custom [conditions](#conditions) are configured, the Webpack-specific `module` condition is also included. The `module` condition is used by package authors to provide a tree-shakable ESM alternative to a CommonJS file without creating a [dual package hazard](https://nodejs.org/api/packages.html#dual-package-hazard). You can prevent the `module` condition from being included by explicitly configuring some custom conditions (even an empty list).\n\n- When using the [build](#build) API, all `process.env.NODE_ENV` expressions are automatically [defined](#define) to `\"production\"` if all [minification](#minify) options are enabled and `\"development\"` otherwise. This only happens if `process`, `process.env`, and `process.env.NODE_ENV` are not already defined. This substitution is necessary to avoid React-based code crashing instantly (since `process` is a node API, not a web API).\n\n- The character sequence `</script>` will be escaped in JavaScript code and the character sequence `</style>` will be escaped in CSS code. This is done in case you inline esbuild's output directly into an HTML file. This can be disabled with esbuild's [supported](#supported) feature by setting `inline-script` (for JavaScript) and/or `inline-style` (for CSS) to `false`.\n\nWhen the platform is set to `node`:\n\n- When [bundling](#bundle) is enabled the default output [format](#format) is set to `cjs`, which stands for CommonJS (the module format used by node). ES6-style exports using `export` statements will be converted into getters on the CommonJS `exports` object.\n\n- All [built-in node modules](https://nodejs.org/docs/latest/api/) such as `fs` are automatically marked as [external](#external) so they don't cause errors when the bundler tries to bundle them.\n\n- The [main fields](#main-fields) setting is set to `main,module`. This means tree shaking will likely not happen for packages that provide both `module` and `main` since tree shaking works with ECMAScript modules but not with CommonJS modules.\n\n  Unfortunately some packages incorrectly treat `module` as meaning \"browser code\" instead of \"ECMAScript module code\" so this default behavior is required for compatibility. You can manually configure the [main fields](#main-fields) setting to `module,main` if you want to enable tree shaking and know it is safe to do so.\n\n- The [conditions](#conditions) setting automatically includes the `node` condition. This changes how the `exports` field in `package.json` files is interpreted to prefer node-specific code.\n\n- If no custom [conditions](#conditions) are configured, the Webpack-specific `module` condition is also included. The `module` condition is used by package authors to provide a tree-shakable ESM alternative to a CommonJS file without creating a [dual package hazard](https://nodejs.org/api/packages.html#dual-package-hazard). You can prevent the `module` condition from being included by explicitly configuring some custom conditions (even an empty list).\n\n- When the [format](#format) is set to `cjs` but the entry point is ESM, esbuild will add special annotations for any named exports to enable importing those named exports using ESM syntax from the resulting CommonJS file. Node's documentation has more information about [node's detection of CommonJS named exports](https://nodejs.org/api/esm.html#commonjs-namespaces).\n\n- The [`binary`](../content-types/index#binary) loader will make use of node's built-in [`Buffer.from`](https://nodejs.org/api/buffer.html#static-method-bufferfromstring-encoding) API to decode the base64 data embedded in the bundle into a `Uint8Array`. This is faster than what esbuild can do otherwise since it's implemented by node in native code.\n\nWhen the platform is set to `neutral`:\n\n- When [bundling](#bundle) is enabled the default output [format](#format) is set to `esm`, which uses the `export` syntax introduced with ECMAScript 2015 (i.e. ES6). You can change the output format if this default is not appropriate.\n\n- The [main fields](#main-fields) setting is empty by default. If you want to use npm-style packages, you will likely have to configure this to be something else such as `main` for the standard main field used by node.\n\n- The [conditions](#conditions) setting does not automatically include any platform-specific values.\n\nSee also [bundling for the browser](../getting-started/index#bundling-for-the-browser) and [bundling for node](../getting-started/index#bundling-for-node).\n\n### Rebuild\n\n*Supported by: [Build](#build)*\n\nYou may want to use this API if your use case involves calling esbuild's [build](#build) API repeatedly with the same options. For example, this is useful if you are implementing your own file watcher service. Rebuilding is more efficient than building again because some of the data from the previous build is cached and can be reused if the original files haven't changed since the previous build. There are currently two forms of caching used by the rebuild API:\n\n- Files are stored in memory and are not re-read from the file system if the file metadata hasn't changed since the last build. This optimization only applies to file system paths. It does not apply to virtual modules created by [plugins](../plugins/index).\n\n- Parsed [ASTs](https://en.wikipedia.org/wiki/Abstract_syntax_tree) are stored in memory and re-parsing the AST is avoided if the file contents haven't changed since the last build. This optimization applies to virtual modules created by plugins in addition to file system modules, as long as the virtual module path remains the same.\n\nHere's how to do a rebuild:\n\n``` sh\n# The CLI does not have an API for \"rebuild\"\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet ctx = await esbuild.context({\n  entryPoints: ['app.js'],\n  bundle: true,\n  outfile: 'out.js',\n})\n\n// Call \"rebuild\" as many times as you want\nfor (let i = 0; i < 5; i++) {\n  let result = await ctx.rebuild()\n}\n\n// Call \"dispose\" when you're done to free up resources\nctx.dispose()\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  ctx, err := api.Context(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Outfile:     \"out.js\",\n  })\n  if err != nil {\n    os.Exit(1)\n  }\n\n  // Call \"Rebuild\" as many times as you want\n  for i := 0; i < 5; i++ {\n    result := ctx.Rebuild()\n    if len(result.Errors) > 0 {\n      os.Exit(1)\n    }\n  }\n\n  // Call \"Dispose\" when you're done to free up resources\n  ctx.Dispose()\n}\n```\n\n### Serve\n\n*Supported by: [Build](#build)*\n\nIf you want your app to automatically reload as you edit, you should read about [live reloading](#live-reload). It combines serve mode with [watch mode](#watch) to listen for changes to the file system.\n\nServe mode starts a web server that serves your code to your browser on your device. Here's an example that bundles `src/app.ts` into `www/js/app.js` and then also serves the `www` directory over `http://localhost:8000/`:\n\n``` sh\nesbuild src/app.ts --outdir=www/js --bundle --servedir=www\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet ctx = await esbuild.context({\n  entryPoints: ['src/app.ts'],\n  outdir: 'www/js',\n  bundle: true,\n})\n\nlet { host, port } = await ctx.serve({\n  servedir: 'www',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  ctx, err := api.Context(api.BuildOptions{\n    EntryPoints: []string{\"src/app.ts\"},\n    Outdir:     \"www/js\",\n    Bundle:      true,\n  })\n  if err != nil {\n    os.Exit(1)\n  }\n\n  server, err2 := ctx.Serve(api.ServeOptions{\n    Servedir: \"www\",\n  })\n  if err2 != nil {\n    os.Exit(1)\n  }\n\n  // Returning from main() exits immediately in Go.\n  // Block forever so we keep serving and don't exit.\n  <-make(chan struct{})\n}\n```\n\nIf you create the file `www/index.html` with the following contents, the code contained in `src/app.ts` will load when you navigate to `http://localhost:8000/`:\n\n``` javascript\n<script src=\"js/app.js\"></script>\n```\n\nOne benefit of using esbuild's built-in web server instead of another web server is that whenever you reload, the files that esbuild serves are always up to date. That's not necessarily the case with other development setups. One common setup is to run a local file watcher that rebuilds output files whenever their input files change, and then separately to run a local file server to serve those output files. But that means reloading after an edit may reload the old output files if the rebuild hasn't finished yet. With esbuild's web server, each incoming request starts a rebuild if one is not already in progress, and then waits for the current rebuild to complete before serving the file. This means esbuild never serves stale build results.\n\nNote that this web server is intended to only be used in development. *Do not use this in production.*\n\n#### Arguments\n\nThe arguments to the serve API are as follows:\n\n``` sh\n# Enable serve mode\n--serve\n\n# Set the port\n--serve=9000\n\n# Set the host and port (IPv4)\n--serve=127.0.0.1:9000\n\n# Set the host and port (IPv6)\n--serve=[::1]:9000\n\n# Set the directory to serve\n--servedir=www\n\n# Enable HTTPS\n--keyfile=your.key --certfile=your.cert\n\n# Specify a fallback HTML file\n--serve-fallback=some-file.html\n```\n\n``` javascript\ninterface ServeOptions {\n  port?: number\n  host?: string\n  servedir?: string\n  keyfile?: string\n  certfile?: string\n  fallback?: string\n  onRequest?: (args: ServeOnRequestArgs) => void\n}\n\ninterface ServeOnRequestArgs {\n  remoteAddress: string\n  method: string\n  path: string\n  status: number\n  timeInMS: number\n}\n```\n\n``` go\ntype ServeOptions struct {\n  Port      uint16\n  Host      string\n  Servedir  string\n  Keyfile   string\n  Certfile  string\n  Fallback  string\n  OnRequest func(ServeOnRequestArgs)\n}\n\ntype ServeOnRequestArgs struct {\n  RemoteAddress string\n  Method        string\n  Path          string\n  Status        int\n  TimeInMS      int\n}\n```\n\n- `host`\n\n  By default, esbuild makes the web server available on all IPv4 network interfaces. This corresponds to a host address of `0.0.0.0`. If you would like to configure a different host (for example, to only serve on the `127.0.0.1` loopback interface without exposing anything to the network), you can specify the host using this argument.\n\n  If you need to use IPv6 instead of IPv4, you just need to specify an IPv6 host address. The equivalent to the `127.0.0.1` loopback interface in IPv6 is `::1` and the equivalent to the `0.0.0.0` universal interface in IPv6 is `::`.\n\n- `port`\n\n  The HTTP port can optionally be configured here. If omitted, it will default to an open port with a preference for ports in the range 8000 to 8009.\n\n- `servedir`\n\n  This is a directory of extra content for esbuild's HTTP server to serve instead of a 404 when incoming requests don't match any of the generated output file paths. This lets you use esbuild as a general-purpose local web server.\n\n  For example, you might want to create an `index.html` file and then set `servedir` to `\".\"` to serve the current directory (which includes the `index.html` file). If you don't set `servedir` then esbuild will only serve the build results, but not any other files.\n\n- `keyfile` and `certfile`\n\n  If you pass a private key and certificate to esbuild using `keyfile` and `certfile`, then esbuild's web server will use the `https://` protocol instead of the `http://` protocol. See [enabling HTTPS](#https) for more information.\n\n- `fallback`\n\n  This is a HTML file for esbuild's HTTP server to serve instead of a 404 when incoming requests don't match any of the generated output file paths. You can use this for a custom \"not found\" page. You can also use this as the entry point of a [single-page application](https://en.wikipedia.org/wiki/Single-page_application) that mutates the current URL and therefore needs to be served from many different URLs simultaneously.\n\n- `onRequest`\n\n  This is called once for each incoming request with some information about the request. This callback is used by the CLI to print out a log message for each request. The time field is the time to generate the data for the request, but it does not include the time to stream the request to the client.\n\n  Note that this is called after the request has completed. It's not possible to use this callback to modify the request in any way. If you want to do this, you should [put a proxy in front of esbuild](#serve-proxy) instead.\n\n#### Return values\n\n``` sh\n# The CLI will print the host and port like this:\n\n > Local: http://127.0.0.1:8000/\n```\n\n``` javascript\ninterface ServeResult {\n  host: string\n  port: number\n}\n```\n\n``` go\ntype ServeResult struct {\n  Host string\n  Port uint16\n}\n```\n\n- `host`\n\n  This is the host that ended up being used by the web server. It will be `0.0.0.0` (i.e. serving on all available network interfaces) unless a custom host was configured. If you are using the CLI and the host is `0.0.0.0`, all available network interfaces will be printed as hosts instead.\n\n- `port`\n\n  This is the port that ended up being used by the web server. You'll want to use this if you don't specify a port since esbuild will end up picking an arbitrary open port, and you need to know which port it picked to be able to connect to it.\n\n#### Enabling HTTPS\n\nBy default, esbuild's web server uses the `http://` protocol. However, certain modern web features are unavailable to HTTP websites. If you want to use these features, then you'll need to tell esbuild to use the `https://` protocol instead.\n\nTo enable HTTPS with esbuild:\n\n1.  Generate a self-signed certificate. There are many ways to do this. Here's one way, assuming you have the `openssl` command installed:\n\n    ``` javascript\n     openssl req -x509 -newkey rsa:4096 -keyout your.key -out your.cert -days 9999 -nodes -subj /CN=127.0.0.1 \n    ```\n\n2.  Pass `your.key` and `your.cert` to esbuild using the `keyfile` and `certfile` [serve arguments](#serve-arguments).\n\n3.  Click past the scary warning in your browser when you load your page (self-signed certificates aren't secure, but that doesn't matter since we're just doing local development).\n\nIf you have more complex needs than this, you can still [put a proxy in front of esbuild](#serve-proxy) and use that for HTTPS instead. Note that if you see the message `Client sent an HTTP request to an HTTPS server` when you load your page, then you are using the incorrect protocol. Replace `http://` with `https://` in your browser's URL bar.\n\nKeep in mind that esbuild's HTTPS support has nothing to do with security. The only reason to enable HTTPS in esbuild is because browsers have made it impossible to do local development with certain modern web features without jumping through these extra hoops. *Please do not use esbuild's development server for anything that needs to be secure.* It's only intended for local development and no considerations have been made for production environments whatsoever.\n\n#### Customizing server behavior\n\nIt's not possible to hook into esbuild's local server to customize the behavior of the server itself. Instead, behavior should be customized by putting a proxy in front of esbuild.\n\nHere's a simple example of a proxy server to get you started, using node's built-in [`http`](https://nodejs.org/api/http.html) module. It adds a custom 404 page instead of esbuild's default 404 page:\n\n``` javascript\nimport * as esbuild from 'esbuild'\nimport http from 'node:http'\n\n// Start esbuild's server on a random local port\nlet ctx = await esbuild.context({\n  // ... your build options go here ...\n})\n\n// The return value tells us where esbuild's local server is\nlet { host, port } = await ctx.serve({ servedir: '.' })\n\n// Then start a proxy server on port 3000\nhttp.createServer((req, res) => {\n  const options = {\n    hostname: host,\n    port: port,\n    path: req.url,\n    method: req.method,\n    headers: req.headers,\n  }\n\n  // Forward each incoming request to esbuild\n  const proxyReq = http.request(options, proxyRes => {\n    // If esbuild returns \"not found\", send a custom 404 page\n    if (proxyRes.statusCode === 404) {\n      res.writeHead(404, { 'Content-Type': 'text/html' })\n      res.end('<h1>A custom 404 page</h1>')\n      return\n    }\n\n    // Otherwise, forward the response from esbuild to the client\n    res.writeHead(proxyRes.statusCode, proxyRes.headers)\n    proxyRes.pipe(res, { end: true })\n  })\n\n  // Forward the body of the request to esbuild\n  req.pipe(proxyReq, { end: true })\n}).listen(3000)\n```\n\nThis code starts esbuild's server on random local port and then starts a proxy server on port 3000. During development you would load <http://localhost:3000> in your browser, which talks to the proxy. This example demonstrates modifying a response after esbuild has handled the request, but you can also modify or replace the request before esbuild has handled it.\n\nYou can do many things with a proxy like this including:\n\n- Injecting your own 404 page (the example above)\n- Customizing the mapping of routes to files on the file system\n- Redirecting some routes to an API server instead of to esbuild\n\nYou can also use a real proxy such as [nginx](https://nginx.org/en/docs/beginners_guide.html#proxy) if you have more advanced needs.\n\n### Tsconfig\n\n*Supported by: [Build](#build)*\n\nNormally the [build](#build) API automatically discovers `tsconfig.json` files and reads their contents during a build. However, you can also configure a custom `tsconfig.json` file to use instead. This can be useful if you need to do multiple builds of the same code with different settings:\n\n``` sh\nesbuild app.ts --bundle --tsconfig=custom-tsconfig.json\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.ts'],\n  bundle: true,\n  tsconfig: 'custom-tsconfig.json',\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.ts\"},\n    Bundle:      true,\n    Tsconfig:    \"custom-tsconfig.json\",\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n### Tsconfig raw\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis option can be used to pass your `tsconfig.json` file to the [transform](#transform) API, which doesn't access the file system. It can also be used to pass the contents of your `tsconfig.json` file to the [build](#build) API inline without writing it to a file. Using it looks like this:\n\n``` sh\necho 'class Foo { foo }' | esbuild --loader=ts --tsconfig-raw='{\"compilerOptions\":{\"useDefineForClassFields\":false}}'\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet ts = 'class Foo { foo }'\nlet result = await esbuild.transform(ts, {\n  loader: 'ts',\n  tsconfigRaw: `{\n    \"compilerOptions\": {\n      \"useDefineForClassFields\": false,\n    },\n  }`,\n})\nconsole.log(result.code)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  ts := \"class Foo { foo }\"\n\n  result := api.Transform(ts, api.TransformOptions{\n    Loader: api.LoaderTS,\n    TsconfigRaw: `{\n      \"compilerOptions\": {\n        \"useDefineForClassFields\": false,\n      },\n    }`,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\n### Watch\n\n*Supported by: [Build](#build)*\n\nEnabling watch mode tells esbuild to listen for changes on the file system and to automatically rebuild whenever a file changes that could invalidate the build. Using it looks like this:\n\n``` sh\nesbuild app.js --outfile=out.js --bundle --watch\n[watch] build finished, watching for changes...\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet ctx = await esbuild.context({\n  entryPoints: ['app.js'],\n  outfile: 'out.js',\n  bundle: true,\n})\n\nawait ctx.watch()\nconsole.log('watching...')\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  ctx, err := api.Context(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Outfile:     \"out.js\",\n    Bundle:      true,\n    Write:       true,\n  })\n  if err != nil {\n    os.Exit(1)\n  }\n\n  err2 := ctx.Watch(api.WatchOptions{})\n  if err2 != nil {\n    os.Exit(1)\n  }\n  fmt.Printf(\"watching...\\n\")\n\n  // Returning from main() exits immediately in Go.\n  // Block forever so we keep watching and don't exit.\n  <-make(chan struct{})\n}\n```\n\nIf you want to stop watch mode at some point in the future, you can call `dispose` on the context object to terminate the file watcher:\n\n``` sh\n# Use Ctrl+C to stop the CLI in watch mode\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet ctx = await esbuild.context({\n  entryPoints: ['app.js'],\n  outfile: 'out.js',\n  bundle: true,\n})\n\nawait ctx.watch()\nconsole.log('watching...')\n\nawait new Promise(r => setTimeout(r, 10 * 1000))\nawait ctx.dispose()\nconsole.log('stopped watching')\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\nimport \"time\"\n\nfunc main() {\n  ctx, err := api.Context(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Outfile:     \"out.js\",\n    Bundle:      true,\n    Write:       true,\n  })\n  if err != nil {\n    os.Exit(1)\n  }\n\n  err2 := ctx.Watch(api.WatchOptions{})\n  if err2 != nil {\n    os.Exit(1)\n  }\n  fmt.Printf(\"watching...\\n\")\n\n  time.Sleep(10 * time.Second)\n  ctx.Dispose()\n  fmt.Printf(\"stopped watching\\n\")\n}\n```\n\nWatch mode in esbuild is implemented using polling instead of OS-specific file system APIs for portability. The polling system is designed to use relatively little CPU vs. a more traditional polling system that scans the whole directory tree at once. The file system is still scanned regularly but each scan only checks a random subset of your files, which means a change to a file will be picked up soon after the change is made but not necessarily instantly.\n\nWith the current heuristics, large projects should be completely scanned around every 2 seconds so in the worst case it could take up to 2 seconds for a change to be noticed. However, after a change has been noticed the change's path goes on a short list of recently changed paths which are checked on every scan, so further changes to recently changed files should be noticed almost instantly.\n\nNote that it is still possible to implement watch mode yourself using esbuild's [rebuild](#rebuild) API and a file watcher library of your choice if you don't want to use a polling-based approach.\n\nIf you are using the CLI, keep in mind that watch mode will be terminated when esbuild's stdin is closed. This prevents esbuild from accidentally outliving the parent process and unexpectedly continuing to consume resources on the system. If you have a use case that requires esbuild to continue to watch forever even when the parent process has finished, you may use `--watch=forever` instead of `--watch`.\n\n## Input\n\n### Entry points\n\n*Supported by: [Build](#build)*\n\nThis is an array of files that each serve as an input to the bundling algorithm. They are called \"entry points\" because each one is meant to be the initial script that is evaluated which then loads all other aspects of the code that it represents. Instead of loading many libraries in your page with `<script>` tags, you would instead use `import` statements to import them into your entry point (or into another file that is then imported into your entry point).\n\nSimple apps only need one entry point but additional entry points can be useful if there are multiple logically-independent groups of code such as a main thread and a worker thread, or an app with separate relatively unrelated areas such as a landing page, an editor page, and a settings page. Separate entry points helps introduce separation of concerns and helps reduce the amount of unnecessary code that the browser needs to download. If applicable, enabling [code splitting](#splitting) can further reduce download sizes when browsing to a second page whose entry point shares some already-downloaded code with a first page that has already been visited.\n\nThe simple way to specify entry points is to just pass an array of file paths:\n\n``` sh\nesbuild home.ts settings.ts --bundle --outdir=out\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['home.ts', 'settings.ts'],\n  bundle: true,\n  write: true,\n  outdir: 'out',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"home.ts\", \"settings.ts\"},\n    Bundle:      true,\n    Write:       true,\n    Outdir:      \"out\",\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThis will generate two output files, `out/home.js` and `out/settings.js` corresponding to the two entry points `home.ts` and `settings.ts`.\n\nFor further control over how the paths of the output files are derived from the corresponding input entry points, you should look into these options:\n\n- [Entry names](#entry-names)\n- [Out extension](#out-extension)\n- [Outbase](#outbase)\n- [Outdir](#outdir)\n- [Outfile](#outfile)\n\nIn addition, you can also specify a fully custom output path for each individual entry point using an alternative entry point syntax:\n\n``` sh\nesbuild out1=home.ts out2=settings.ts --bundle --outdir=out\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: [\n    { out: 'out1', in: 'home.ts'},\n    { out: 'out2', in: 'settings.ts'},\n  ],\n  bundle: true,\n  write: true,\n  outdir: 'out',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPointsAdvanced: []api.EntryPoint{{\n      OutputPath: \"out1\",\n      InputPath:  \"home.ts\",\n    }, {\n      OutputPath: \"out2\",\n      InputPath:  \"settings.ts\",\n    }},\n    Bundle: true,\n    Write:  true,\n    Outdir: \"out\",\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThis will generate two output files, `out/out1.js` and `out/out2.js` corresponding to the two entry points `home.ts` and `settings.ts`.\n\n#### Glob-style entry points\n\nIf an entry point contains the `*` character, then it's considered to be a [glob](https://en.wikipedia.org/wiki/Glob_(programming)) pattern. This means esbuild will use that entry point as a pattern to search for files on the file system and will then replace that entry point with any matching files that were found. So for example, an entry point of `*.js` will cause esbuild to consider all files in the current directory that end in `.js` to be entry points.\n\nThe glob matcher that esbuild implements is intentionally simple, and does not support more advanced features found in certain other glob libraries. Only two kinds of wildcards are supported:\n\n- `*`\n\n  This wildcard matches any number of characters (including none) except that it does not match a slash character (i.e. a `/`), which means it does not cause esbuild to traverse into subdirectories. For example, `*.js` will match `foo.js` but not `bar/foo.js`.\n\n- `/**/`\n\n  This wildcard matches zero or more path segments, which means it can be used to tell esbuild to match against a whole directory tree. For example, `./**/*.js` will match `./foo.js` and `./bar/foo.js` and `./a/b/c/foo.js`.\n\nIf you are using esbuild via the CLI, keep in mind that if you do not quote arguments that contain shell metacharacters before you pass them to esbuild, your shell will likely expand them before esbuild sees them. So if you run `esbuild \"*.js\"` (with quotes) then esbuild will see an entry point of `*.js` and the glob-style entry point rules described above will apply. But if you run `esbuild *.js` (without quotes) then esbuild will see whatever your current shell decided to expand `*.js` into (which may include seeing nothing at all if your shell expanded it into nothing). Using esbuild's built-in glob pattern support can be a convenient way to ensure cross-platform consistency by avoiding shell-specific behavior, but it requires you to quote your arguments correctly so that your shell doesn't interpret them.\n\n### Loader\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis option changes how a given input file is interpreted. For example, the [`js`](../content-types/index#javascript) loader interprets the file as JavaScript and the [`css`](../content-types/index#css) loader interprets the file as CSS. See the [content types](../content-types/index) page for a complete list of all built-in loaders.\n\nConfiguring a loader for a given file type lets you load that file type with an `import` statement or a `require` call. For example, configuring the `.png` file extension to use the [data URL](../content-types/index#data-url) loader means importing a `.png` file gives you a data URL containing the contents of that image:\n\n``` javascript\nimport url from './example.png'\nlet image = new Image\nimage.src = url\ndocument.body.appendChild(image)\n\nimport svg from './example.svg'\nlet doc = new DOMParser().parseFromString(svg, 'application/xml')\nlet node = document.importNode(doc.documentElement, true)\ndocument.body.appendChild(node)\n```\n\nThe above code can be bundled using the [build](#build) API call like this:\n\n``` sh\nesbuild app.js --bundle --loader:.png=dataurl --loader:.svg=text\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  loader: {\n    '.png': 'dataurl',\n    '.svg': 'text',\n  },\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Loader: map[string]api.Loader{\n      \".png\": api.LoaderDataURL,\n      \".svg\": api.LoaderText,\n    },\n    Write: true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThis option is specified differently if you are using the build API with input from [stdin](#stdin), since stdin does not have a file extension. Configuring a loader for stdin with the build API looks like this:\n\n``` sh\necho 'import pkg = require(\"./pkg\")' | esbuild --loader=ts --bundle\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  stdin: {\n    contents: 'import pkg = require(\"./pkg\")',\n    loader: 'ts',\n    resolveDir: '.',\n  },\n  bundle: true,\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    Stdin: &api.StdinOptions{\n      Contents:   \"import pkg = require('./pkg')\",\n      Loader:     api.LoaderTS,\n      ResolveDir: \".\",\n    },\n    Bundle: true,\n  })\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThe [transform](#transform) API call just takes a single loader since it doesn't involve interacting with the file system, and therefore doesn't deal with file extensions. Configuring a loader (in this case the [`ts`](../content-types/index#typescript) loader) for the transform API looks like this:\n\n``` sh\necho 'let x: number = 1' | esbuild --loader=ts\nlet x = 1;\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet ts = 'let x: number = 1'\nlet result = await esbuild.transform(ts, {\n  loader: 'ts',\n})\nconsole.log(result.code)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  ts := \"let x: number = 1\"\n  result := api.Transform(ts, api.TransformOptions{\n    Loader: api.LoaderTS,\n  })\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\n### Stdin\n\n*Supported by: [Build](#build)*\n\nNormally the build API call takes one or more file names as input. However, this option can be used to run a build without a module existing on the file system at all. It's called \"stdin\" because it corresponds to piping a file to stdin on the command line.\n\nIn addition to specifying the contents of the stdin file, you can optionally also specify the resolve directory (used to determine where relative imports are located), the [sourcefile](#sourcefile) (the file name to use in error messages and source maps), and the [loader](#loader) (which determines how the file contents are interpreted). The CLI doesn't have a way to specify the resolve directory. Instead, it's automatically set to the current working directory.\n\nHere's how to use this feature:\n\n``` sh\necho 'export * from \"./another-file\"' | esbuild --bundle --sourcefile=imaginary-file.js --loader=ts --format=cjs\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet result = await esbuild.build({\n  stdin: {\n    contents: `export * from \"./another-file\"`,\n\n    // These are all optional:\n    resolveDir: './src',\n    sourcefile: 'imaginary-file.js',\n    loader: 'ts',\n  },\n  format: 'cjs',\n  write: false,\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    Stdin: &api.StdinOptions{\n      Contents: \"export * from './another-file'\",\n\n      // These are all optional:\n      ResolveDir: \"./src\",\n      Sourcefile: \"imaginary-file.js\",\n      Loader:     api.LoaderTS,\n    },\n    Format: api.FormatCommonJS,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n## Output contents\n\n### Banner\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nUse this to insert an arbitrary string at the beginning of generated JavaScript and CSS files. This is commonly used to insert comments:\n\n``` sh\nesbuild app.js --banner:js=//comment --banner:css=/*comment*/\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  banner: {\n    js: '//comment',\n    css: '/*comment*/',\n  },\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Banner: map[string]string{\n      \"js\":  \"//comment\",\n      \"css\": \"/*comment*/\",\n    },\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThis is similar to [footer](#footer) which inserts at the end instead of the beginning.\n\nNote that if you are inserting non-comment code into a CSS file, be aware that CSS ignores all `@import` rules that come after a non-`@import` rule (other than a `@charset` rule), so using a banner to inject CSS rules may accidentally disable imports of external stylesheets.\n\n### Charset\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nBy default esbuild's output is ASCII-only. Any non-ASCII characters are escaped using backslash escape sequences. One reason is because non-ASCII characters are misinterpreted by the browser by default, which causes confusion. You have to explicitly add `<meta charset=\"utf-8\">` to your HTML or serve it with the correct `Content-Type` header for the browser to not mangle your code. Another reason is that non-ASCII characters can significantly [slow down the browser's parser](https://v8.dev/blog/scanner). However, using escape sequences makes the generated output slightly bigger, and also makes it harder to read.\n\nIf you would like for esbuild to print the original characters without using escape sequences and you have ensured that the browser will interpret your code as UTF-8, you can disable character escaping by setting the charset:\n\n``` sh\necho 'let π = Math.PI' | esbuild\nlet \\u03C0 = Math.PI;\necho 'let π = Math.PI' | esbuild --charset=utf8\nlet π = Math.PI;\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\nlet js = 'let π = Math.PI'\n(await esbuild.transform(js)).code\n'let \\\\u03C0 = Math.PI;\\n'\n(await esbuild.transform(js, {\n  charset: 'utf8',\n})).code\n'let π = Math.PI;\\n'\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"let π = Math.PI\"\n\n  result1 := api.Transform(js, api.TransformOptions{})\n\n  if len(result1.Errors) == 0 {\n    fmt.Printf(\"%s\", result1.Code)\n  }\n\n  result2 := api.Transform(js, api.TransformOptions{\n    Charset: api.CharsetUTF8,\n  })\n\n  if len(result2.Errors) == 0 {\n    fmt.Printf(\"%s\", result2.Code)\n  }\n}\n```\n\nSome caveats:\n\n- This does not yet escape non-ASCII characters embedded in regular expressions. This is because esbuild does not currently parse the contents of regular expressions at all. The flag was added despite this limitation because it's still useful for code that doesn't contain cases like this.\n\n- This flag does not apply to comments. I believe preserving non-ASCII data in comments should be fine because even if the encoding is wrong, the run time environment should completely ignore the contents of all comments. For example, the [V8 blog post](https://v8.dev/blog/scanner) mentions an optimization that avoids decoding comment contents completely. And all comments other than license-related comments are stripped out by esbuild anyway.\n\n- This option simultaneously applies to all output file types (JavaScript, CSS, and JSON). So if you configure your web server to send the correct `Content-Type` header and want to use the UTF-8 charset, make sure your web server is configured to treat both `.js` and `.css` files as UTF-8.\n\n### Footer\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nUse this to insert an arbitrary string at the end of generated JavaScript and CSS files. This is commonly used to insert comments:\n\n``` sh\nesbuild app.js --footer:js=//comment --footer:css=/*comment*/\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  footer: {\n    js: '//comment',\n    css: '/*comment*/',\n  },\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Footer: map[string]string{\n      \"js\":  \"//comment\",\n      \"css\": \"/*comment*/\",\n    },\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThis is similar to [banner](#banner) which inserts at the beginning instead of the end.\n\n### Format\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis sets the output format for the generated JavaScript files. There are currently three possible values that can be configured: `iife`, `cjs`, and `esm`. When no output format is specified, esbuild picks an output format for you if [bundling](#bundle) is enabled (as described below), or doesn't do any format conversion if [bundling](#bundle) is disabled.\n\n#### IIFE\n\nThe `iife` format stands for \"immediately-invoked function expression\" and is intended to be run in the browser. Wrapping your code in a function expression ensures that any variables in your code don't accidentally conflict with variables in the global scope. If your entry point has exports that you want to expose as a global in the browser, you can configure that global's name using the [global name](#global-name) setting. The `iife` format will automatically be enabled when no output format is specified, [bundling](#bundle) is enabled, and [platform](#platform) is set to `browser` (which it is by default). Specifying the `iife` format looks like this:\n\n``` sh\necho 'alert(\"test\")' | esbuild --format=iife\n(() => {\n  alert(\"test\");\n})();\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet js = 'alert(\"test\")'\nlet result = await esbuild.transform(js, {\n  format: 'iife',\n})\nconsole.log(result.code)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"alert(\\\"test\\\")\"\n\n  result := api.Transform(js, api.TransformOptions{\n    Format: api.FormatIIFE,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\n#### CommonJS\n\nThe `cjs` format stands for \"CommonJS\" and is intended to be run in node. It assumes the environment contains `exports`, `require`, and `module`. Entry points with exports in ECMAScript module syntax will be converted to a module with a getter on `exports` for each export name. The `cjs` format will automatically be enabled when no output format is specified, [bundling](#bundle) is enabled, and [platform](#platform) is set to `node`. Specifying the `cjs` format looks like this:\n\n``` sh\necho 'export default \"test\"' | esbuild --format=cjs\n...\nvar stdin_exports = {};\n__export(stdin_exports, {\n  default: () => stdin_default\n});\nmodule.exports = __toCommonJS(stdin_exports);\nvar stdin_default = \"test\";\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet js = 'export default \"test\"'\nlet result = await esbuild.transform(js, {\n  format: 'cjs',\n})\nconsole.log(result.code)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"export default 'test'\"\n\n  result := api.Transform(js, api.TransformOptions{\n    Format: api.FormatCommonJS,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\n#### ESM\n\nThe `esm` format stands for \"ECMAScript module\". It assumes the environment supports `import` and `export` syntax. Entry points with exports in CommonJS module syntax will be converted to a single `default` export of the value of `module.exports`. The `esm` format will automatically be enabled when no output format is specified, [bundling](#bundle) is enabled, and [platform](#platform) is set to `neutral`. Specifying the `esm` format looks like this:\n\n``` sh\necho 'module.exports = \"test\"' | esbuild --format=esm\n...\nvar require_stdin = __commonJS({\n  \"<stdin>\"(exports, module) {\n    module.exports = \"test\";\n  }\n});\nexport default require_stdin();\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet js = 'module.exports = \"test\"'\nlet result = await esbuild.transform(js, {\n  format: 'esm',\n})\nconsole.log(result.code)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"module.exports = 'test'\"\n\n  result := api.Transform(js, api.TransformOptions{\n    Format: api.FormatESModule,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\nThe `esm` format can be used either in the browser or in node, but you have to explicitly load it as a module. This happens automatically if you `import` it from another module. Otherwise:\n\n- In the browser, you can load a module using `<script src=\"file.js\" type=\"module\"></script>`. Do not forget `type=\"module\"` as this will break your code in subtle and confusing ways (omitting `type=\"module\"` means that all top-level variables will end up in the global scope, which will then collide with top-level variables that have the same name in other JavaScript files).  \n- In node, you can load a module using `node file.mjs`. Note that node requires the `.mjs` extension unless you have configured `\"type\": \"module\"` in your `package.json` file. You can use the [out extension](#out-extension) setting in esbuild to customize the output extension for the files esbuild generates. You can read more about using ECMAScript modules in node [here](https://nodejs.org/api/esm.html#enabling).\n\n### Global name\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis option only matters when the [format](#format) setting is `iife` (which stands for immediately-invoked function expression). It sets the name of the global variable which is used to store the exports from the entry point:\n\n``` sh\necho 'module.exports = \"test\"' | esbuild --format=iife --global-name=xyz\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet js = 'module.exports = \"test\"'\nlet result = await esbuild.transform(js, {\n  format: 'iife',\n  globalName: 'xyz',\n})\nconsole.log(result.code)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"module.exports = 'test'\"\n\n  result := api.Transform(js, api.TransformOptions{\n    Format:     api.FormatIIFE,\n    GlobalName: \"xyz\",\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\nSpecifying the global name with the `iife` format will generate code that looks something like this:\n\n``` javascript\nvar xyz = (() => {\n  ...\n  var require_stdin = __commonJS((exports, module) => {\n    module.exports = \"test\";\n  });\n  return require_stdin();\n})();\n```\n\nThe global name can also be a compound property expression, in which case esbuild will generate a global variable with that property. Existing global variables that conflict will not be overwritten. This can be used to implement \"namespacing\" where multiple independent scripts add their exports onto the same global object. For example:\n\n``` sh\necho 'module.exports = \"test\"' | esbuild --format=iife --global-name='example.versions[\"1.0\"]'\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet js = 'module.exports = \"test\"'\nlet result = await esbuild.transform(js, {\n  format: 'iife',\n  globalName: 'example.versions[\"1.0\"]',\n})\nconsole.log(result.code)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"module.exports = 'test'\"\n\n  result := api.Transform(js, api.TransformOptions{\n    Format:     api.FormatIIFE,\n    GlobalName: `example.versions[\"1.0\"]`,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\nThe compound global name used above generates code that looks like this:\n\n``` javascript\nvar example = example || {};\nexample.versions = example.versions || {};\nexample.versions[\"1.0\"] = (() => {\n  ...\n  var require_stdin = __commonJS((exports, module) => {\n    module.exports = \"test\";\n  });\n  return require_stdin();\n})();\n```\n\n### Legal comments\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nA \"legal comment\" is considered to be any statement-level comment in JS or rule-level comment in CSS that contains `@license` or `@preserve` or that starts with `//!` or `/*!`. These comments are preserved in output files by default since that follows the intent of the original authors of the code. However, this behavior can be configured by using one of the following options:\n\n- `none`  \n  Do not preserve any legal comments.\n\n- `inline`  \n  Preserve all legal comments.\n\n- `eof`  \n  Move all legal comments to the end of the file.\n\n- `linked`  \n  Move all legal comments to a `.LEGAL.txt` file and link to them with a comment.\n\n- `external`  \n  Move all legal comments to a `.LEGAL.txt` file but to not link to them.\n\nThe default behavior is `eof` when [bundling](#bundle) is enabled and `inline` otherwise. Setting the legal comment mode looks like this:\n\n``` sh\nesbuild app.js --legal-comments=eof\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  legalComments: 'eof',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:   []string{\"app.js\"},\n    LegalComments: api.LegalCommentsEndOfFile,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nNote that \"statement-level\" for JS and \"rule-level\" for CSS means the comment must appear in a context where multiple statements or rules are allowed such as in the top-level scope or in a statement or rule block. So comments inside expressions or at the declaration level are not considered legal comments.\n\n### Line limit\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis setting is a way to prevent esbuild from generating output files with really long lines, which can help editing performance in poorly-implemented text editors. Set this to a positive integer to tell esbuild to end a given line soon after it passes that number of bytes. For example, this wraps long lines soon after they pass ~80 characters:\n\n``` sh\nesbuild app.ts --line-limit=80\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.ts'],\n  lineLimit: 80,\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.ts\"},\n    LineLimit:   80,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nLines are truncated after they pass the limit instead of before because it's simpler to check when the limit is passed then to predict when the limit is about to be passed, and because it's faster to avoid backing up and rewriting things when generating an output file. So the limit is only approximate.\n\nThis setting applies to both JavaScript and CSS, and works even when minification is disabled. Note that turning this setting on will make your files bigger, as the extra newlines take up additional space in the file (even after gzip compression).\n\n### Splitting\n\n*Supported by: [Build](#build)*\n\nCode splitting is still a work in progress. It currently only works with the `esm` output [format](#format). There is also a known [ordering issue](https://github.com/evanw/esbuild/issues/399) with `import` statements across code splitting chunks. You can follow [the tracking issue](https://github.com/evanw/esbuild/issues/16) for updates about this feature.\n\nThis enables \"code splitting\" which serves two purposes:\n\n- Code shared between multiple entry points is split off into a separate shared file that both entry points import. That way if the user first browses to one page and then to another page, they don't have to download all of the JavaScript for the second page from scratch if the shared part has already been downloaded and cached by their browser.\n\n- Code referenced through an asynchronous `import()` expression will be split off into a separate file and only loaded when that expression is evaluated. This allows you to improve the initial download time of your app by only downloading the code you need at startup, and then lazily downloading additional code if needed later.\n\n  Without code splitting enabled, an `import()` expression becomes `Promise.resolve().then(() => require())` instead. This still preserves the asynchronous semantics of the expression but it means the imported code is included in the same bundle instead of being split off into a separate file.\n\nWhen you enable code splitting you must also configure the output directory using the [outdir](#outdir) setting:\n\n``` sh\nesbuild home.ts about.ts --bundle --splitting --outdir=out --format=esm\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['home.ts', 'about.ts'],\n  bundle: true,\n  splitting: true,\n  outdir: 'out',\n  format: 'esm',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"home.ts\", \"about.ts\"},\n    Bundle:      true,\n    Splitting:   true,\n    Outdir:      \"out\",\n    Format:      api.FormatESModule,\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n## Output location\n\n### Allow overwrite\n\n*Supported by: [Build](#build)*\n\nEnabling this setting allows output files to overwrite input files. It's not enabled by default because doing so means overwriting your source code, which can lead to data loss if your code is not checked in. But supporting this makes certain workflows easier by avoiding the need for a temporary directory. So you can enable this when you want to deliberately overwrite your source code:\n\n``` sh\nesbuild app.js --outdir=. --allow-overwrite\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  outdir: '.',\n  allowOverwrite: true,\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:    []string{\"app.js\"},\n    Outdir:         \".\",\n    AllowOverwrite: true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n### Asset names\n\n*Supported by: [Build](#build)*\n\nThis option controls the file names of the additional output files generated when the [loader](#loader) is set to [`file`](../content-types/index#external-file). It configures the output paths using a template with placeholders that will be substituted with values specific to the file when the output path is generated. For example, specifying an asset name template of `assets/[name]-[hash]` puts all assets into a subdirectory called `assets` inside of the output directory and includes the content hash of the asset in the file name. Doing that looks like this:\n\n``` sh\nesbuild app.js --asset-names=assets/[name]-[hash] --loader:.png=file --bundle --outdir=out\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  assetNames: 'assets/[name]-[hash]',\n  loader: { '.png': 'file' },\n  bundle: true,\n  outdir: 'out',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    AssetNames:  \"assets/[name]-[hash]\",\n    Loader: map[string]api.Loader{\n      \".png\": api.LoaderFile,\n    },\n    Bundle: true,\n    Outdir: \"out\",\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThere are four placeholders that can be used in asset path templates:\n\n- `[dir]`\n\n  This is the relative path from the directory containing the asset file to the [outbase](#outbase) directory. Its purpose is to help asset output paths look more aesthetically pleasing by mirroring the input directory structure inside of the output directory.\n\n- `[name]`\n\n  This is the original file name of the asset without the extension. For example, if the asset was originally named `image.png` then `[name]` will be substituted with `image` in the template. It is not necessary to use this placeholder; it only exists to provide human-friendly asset names to make debugging easier.\n\n- `[hash]`\n\n  This is the content hash of the asset, which is useful to avoid name collisions. For example, your code may import `components/button/icon.png` and `components/select/icon.png` in which case you'll need the hash to distinguish between the two assets that are both named `icon`.\n\n- `[ext]`\n\n  This is the file extension of the asset (i.e. everything after the end of the last `.` character). It can be used to put different types of assets into different directories. For example, `--asset-names=assets/[ext]/[name]-[hash]` might write out an asset named `image.png` as `assets/png/image-CQFGD2NG.png`.\n\nAsset path templates do not need to include a file extension. The original file extension of the asset will be automatically added to the end of the output path after template substitution.\n\nThis option is similar to the [chunk names](#chunk-names) and [entry names](#entry-names) options.\n\n### Chunk names\n\n*Supported by: [Build](#build)*\n\nThis option controls the file names of the chunks of shared code that are automatically generated when [code splitting](#splitting) is enabled. It configures the output paths using a template with placeholders that will be substituted with values specific to the chunk when the output path is generated. For example, specifying a chunk name template of `chunks/[name]-[hash]` puts all generated chunks into a subdirectory called `chunks` inside of the output directory and includes the content hash of the chunk in the file name. Doing that looks like this:\n\n``` sh\nesbuild app.js --chunk-names=chunks/[name]-[hash] --bundle --outdir=out --splitting --format=esm\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  chunkNames: 'chunks/[name]-[hash]',\n  bundle: true,\n  outdir: 'out',\n  splitting: true,\n  format: 'esm',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    ChunkNames:  \"chunks/[name]-[hash]\",\n    Bundle:      true,\n    Outdir:      \"out\",\n    Splitting:   true,\n    Format:      api.FormatESModule,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThere are three placeholders that can be used in chunk path templates:\n\n- `[name]`\n\n  This will currently always be the text `chunk`, although this placeholder may take on additional values in future releases.\n\n- `[hash]`\n\n  This is the content hash of the chunk. Including this is necessary to distinguish different chunks from each other in the case where multiple chunks of shared code are generated.\n\n- `[ext]`\n\n  This is the file extension of the chunk (i.e. everything after the end of the last `.` character). It can be used to put different types of chunks into different directories. For example, `--chunk-names=chunks/[ext]/[name]-[hash]` might write out a chunk as `chunks/css/chunk-DEFJT7KY.css`.\n\nChunk path templates do not need to include a file extension. The configured [out extension](#out-extension) for the appropriate content type will be automatically added to the end of the output path after template substitution.\n\nNote that this option only controls the names for automatically-generated chunks of shared code. It does *not* control the names for output files related to entry points. The names of these are currently determined from the path of the original entry point file relative to the [outbase](#outbase) directory, and this behavior cannot be changed. An additional API option will be added in the future to let you change the file names of entry point output files.\n\nThis option is similar to the [asset names](#asset-names) and [entry names](#entry-names) options.\n\n### Entry names\n\n*Supported by: [Build](#build)*\n\nThis option controls the file names of the output files corresponding to each input entry point file. It configures the output paths using a template with placeholders that will be substituted with values specific to the file when the output path is generated. For example, specifying an entry name template of `[dir]/[name]-[hash]` includes a hash of the output file in the file name and puts the files into the output directory, potentially under a subdirectory (see the details about `[dir]` below). Doing that looks like this:\n\n``` sh\nesbuild src/main-app/app.js --entry-names=[dir]/[name]-[hash] --outbase=src --bundle --outdir=out\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['src/main-app/app.js'],\n  entryNames: '[dir]/[name]-[hash]',\n  outbase: 'src',\n  bundle: true,\n  outdir: 'out',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"src/main-app/app.js\"},\n    EntryNames:  \"[dir]/[name]-[hash]\",\n    Outbase:     \"src\",\n    Bundle:      true,\n    Outdir:      \"out\",\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThere are four placeholders that can be used in entry path templates:\n\n- `[dir]`\n\n  This is the relative path from the directory containing the input entry point file to the [outbase](#outbase) directory. Its purpose is to help you avoid collisions between identically-named entry points in different subdirectories.\n\n  For example, if there are two entry points `src/pages/home/index.ts` and `src/pages/about/index.ts`, the outbase directory is `src`, and the entry names template is `[dir]/[name]`, the output directory will contain `pages/home/index.js` and `pages/about/index.js`. If the entry names template had been just `[name]` instead, bundling would have failed because there would have been two output files with the same output path `index.js` inside the output directory.\n\n- `[name]`\n\n  This is the original file name of the entry point without the extension. For example, if the input entry point file is named `app.js` then `[name]` will be substituted with `app` in the template.\n\n- `[hash]`\n\n  This is the content hash of the output file, which can be used to take optimal advantage of browser caching. Adding `[hash]` to your entry point names means esbuild will calculate a hash that relates to all content in the corresponding output file (and any output file it imports if [code splitting](#splitting) is active). The hash is designed to change if and only if any of the input files relevant to that output file are changed.\n\n  After that, you can have your web server tell browsers that to cache these files forever (in practice you can say they expire a very long time from now such as in a year). You can then use the information in the [metafile](#metafile) to determine which output file path corresponds to which input entry point so you know what path to include in your `<script>` tag.\n\n- `[ext]`\n\n  This is the file extension that the entry point file will be written out to (i.e. the [out extension](#out-extension) setting, not the original file extension). It can be used to put different types of entry points into different directories. For example, `--entry-names=entries/[ext]/[name]` might write the output file for `app.ts` to `entries/js/app.js`.\n\nEntry path templates do not need to include a file extension. The appropriate [out extension](#out-extension) based on the file type will be automatically added to the end of the output path after template substitution.\n\nThis option is similar to the [asset names](#asset-names) and [chunk names](#chunk-names) options.\n\n### Out extension\n\n*Supported by: [Build](#build)*\n\nThis option lets you customize the file extension of the files that esbuild generates to something other than `.js` or `.css`. In particular, the `.mjs` and `.cjs` file extensions have special meaning in node (they indicate a file in ESM and CommonJS format, respectively). This option is useful if you are using esbuild to generate multiple files and you have to use the [outdir](#outdir) option instead of the [outfile](#outfile) option. You can use it like this:\n\n``` sh\nesbuild app.js --bundle --outdir=dist --out-extension:.js=.mjs\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  outdir: 'dist',\n  outExtension: { '.js': '.mjs' },\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Outdir:      \"dist\",\n    OutExtension: map[string]string{\n      \".js\": \".mjs\",\n    },\n    Write: true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n### Outbase\n\n*Supported by: [Build](#build)*\n\nIf your build contains multiple entry points in separate directories, the directory structure will be replicated into the [output directory](#outdir) relative to the outbase directory. For example, if there are two entry points `src/pages/home/index.ts` and `src/pages/about/index.ts` and the outbase directory is `src`, the output directory will contain `pages/home/index.js` and `pages/about/index.js`. Here's how to use it:\n\n``` sh\nesbuild src/pages/home/index.ts src/pages/about/index.ts --bundle --outdir=out --outbase=src\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: [\n    'src/pages/home/index.ts',\n    'src/pages/about/index.ts',\n  ],\n  bundle: true,\n  outdir: 'out',\n  outbase: 'src',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\n      \"src/pages/home/index.ts\",\n      \"src/pages/about/index.ts\",\n    },\n    Bundle:  true,\n    Outdir:  \"out\",\n    Outbase: \"src\",\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nIf the outbase directory isn't specified, it defaults to the [lowest common ancestor](https://en.wikipedia.org/wiki/Lowest_common_ancestor) directory among all input entry point paths. This is `src/pages` in the example above, which means by default the output directory will contain `home/index.js` and `about/index.js` instead.\n\n### Outdir\n\n*Supported by: [Build](#build)*\n\nThis option sets the output directory for the build operation. For example, this command will generate a directory called `out`:\n\n``` sh\nesbuild app.js --bundle --outdir=out\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  outdir: 'out',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Outdir:      \"out\",\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThe output directory will be generated if it does not already exist, but it will not be cleared if it already contains some files. Any generated files will silently overwrite existing files with the same name. You should clear the output directory yourself before running esbuild if you want the output directory to only contain files from the current run of esbuild.\n\nIf your build contains multiple entry points in separate directories, the directory structure will be replicated into the output directory starting from the [lowest common ancestor](https://en.wikipedia.org/wiki/Lowest_common_ancestor) directory among all input entry point paths. For example, if there are two entry points `src/home/index.ts` and `src/about/index.ts`, the output directory will contain `home/index.js` and `about/index.js`. If you want to customize this behavior, you should change the [outbase directory](#outbase).\n\n### Outfile\n\n*Supported by: [Build](#build)*\n\nThis option sets the output file name for the build operation. This is only applicable if there is a single entry point. If there are multiple entry points, you must use the [outdir](#outdir) option instead to specify an output directory. Using outfile looks like this:\n\n``` sh\nesbuild app.js --bundle --outfile=out.js\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Outfile:     \"out.js\",\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n### Public path\n\n*Supported by: [Build](#build)*\n\nThis is useful in combination with the [external file](../content-types/index#external-file) loader. By default that loader exports the name of the imported file as a string using the `default` export. The public path option lets you prepend a base path to the exported string of each file loaded by this loader:\n\n``` sh\nesbuild app.js --bundle --loader:.png=file --public-path=https://www.example.com/v1 --outdir=out\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  loader: { '.png': 'file' },\n  publicPath: 'https://www.example.com/v1',\n  outdir: 'out',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Loader: map[string]api.Loader{\n      \".png\": api.LoaderFile,\n    },\n    Outdir:     \"out\",\n    PublicPath: \"https://www.example.com/v1\",\n    Write:      true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n### Write\n\n*Supported by: [Build](#build)*\n\nThe build API call can either write to the file system directly or return the files that would have been written as in-memory buffers. By default the CLI and JavaScript APIs write to the file system and the Go API doesn't. To use the in-memory buffers:\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet result = await esbuild.build({\n  entryPoints: ['app.js'],\n  sourcemap: 'external',\n  write: false,\n  outdir: 'out',\n})\n\nfor (let out of result.outputFiles) {\n  console.log(out.path, out.contents, out.hash, out.text)\n}\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Sourcemap:   api.SourceMapExternal,\n    Write:       false,\n    Outdir:      \"out\",\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n\n  for _, out := range result.OutputFiles {\n    fmt.Printf(\"%v %v %s\\n\", out.Path, out.Contents, out.Hash)\n  }\n}\n```\n\nThe `hash` property is a hash of the `contents` field and has been provided for convenience. The hash algorithm (currently [XXH64](https://xxhash.com/)) is implementation-dependent and may be changed at any time in between esbuild versions.\n\n## Path resolution\n\n### Alias\n\n*Supported by: [Build](#build)*\n\nThis feature lets you substitute one package for another when bundling. The example below substitutes the package `oldpkg` with the package `newpkg`:\n\n``` sh\nesbuild app.js --bundle --alias:oldpkg=newpkg\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  write: true,\n  alias: {\n    'oldpkg': 'newpkg',\n  },\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Write:       true,\n    Alias: map[string]string{\n      \"oldpkg\": \"newpkg\",\n    },\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThese new substitutions happen first before all of esbuild's other path resolution logic. One use case for this feature is replacing a node-only package with a browser-friendly package in third-party code that you don't control.\n\nNote that when an import path is substituted using an alias, the resulting import path is resolved in the working directory instead of in the directory containing the source file with the import path. If needed, the working directory that esbuild uses can be set with the [working directory](#working-directory) feature.\n\n### Conditions\n\n*Supported by: [Build](#build)*\n\nThis feature controls how the `exports` field in `package.json` is interpreted. Custom conditions can be added using the conditions setting. You can specify as many of these as you want and the meaning of these is entirely up to package authors. Node has currently only endorsed the `development` and `production` custom conditions for recommended use. Here is an example of adding the custom conditions `custom1` and `custom2`:\n\n``` sh\nesbuild src/app.js --bundle --conditions=custom1,custom2\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['src/app.js'],\n  bundle: true,\n  conditions: ['custom1', 'custom2'],\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"src/app.js\"},\n    Bundle:      true,\n    Conditions:  []string{\"custom1\", \"custom2\"},\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n#### How conditions work\n\nConditions allow you to redirect the same import path to different file locations in different situations. The redirect map containing the conditions and paths is stored in the `exports` field in the package's `package.json` file. For example, this would remap `require('pkg/foo')` to `pkg/required.cjs` and `import 'pkg/foo'` to `pkg/imported.mjs` using the `import` and `require` conditions:\n\n``` javascript\n{\n  \"name\": \"pkg\",\n  \"exports\": {\n    \"./foo\": {\n      \"import\": \"./imported.mjs\",\n      \"require\": \"./required.cjs\",\n      \"default\": \"./fallback.js\"\n    }\n  }\n}\n```\n\nConditions are checked in the order that they appear within the JSON file. So the example above behaves sort of like this:\n\n``` javascript\nif (importPath === './foo') {\n  if (conditions.has('import')) return './imported.mjs'\n  if (conditions.has('require')) return './required.cjs'\n  return './fallback.js'\n}\n```\n\nBy default there are five conditions with special behavior that are built in to esbuild, and cannot be disabled:\n\n- `default`\n\n  This condition is always active. It is intended to come last and lets you provide a fallback for when no other condition applies. This condition is also active when you run your code natively in node.\n\n- `import`\n\n  This condition is only active when the import path is from an ESM `import` statement or `import()` expression. It can be used to provide ESM-specific code. This condition is also active when you run your code natively in node (but only in an ESM context).\n\n- `require`\n\n  This condition is only active when the import path is from a CommonJS `require()` call. It can be used to provide CommonJS-specific code. This condition is also active when you run your code natively in node (but only in a CommonJS context).\n\n- `browser`\n\n  This condition is only active when esbuild's [platform](#platform) setting is set to `browser`. It can be used to provide browser-specific code. This condition is not active when you run your code natively in node.\n\n- `node`\n\n  This condition is only active when esbuild's [platform](#platform) setting is set to `node`. It can be used to provide node-specific code. This condition is also active when you run your code natively in node.\n\nThe following condition is also automatically included when the [platform](#platform) is set to either `browser` or `node` and no custom conditions are configured. If there are any custom conditions configured (even an empty list) then this condition will no longer be automatically included:\n\n- `module`\n\n  This condition can be used to tell esbuild to pick the ESM variant for a given import path to provide better tree-shaking when bundling. This condition is not active when you run your code natively in node. It is specific to bundlers, and originated from Webpack.\n\nNote that when you use the `require` and `import` conditions, *your package may end up in the bundle multiple times!* This is a subtle issue that can cause bugs due to duplicate copies of your code's state in addition to bloating the resulting bundle. This is commonly known as the [dual package hazard](https://nodejs.org/docs/latest/api/packages.html#packages_dual_package_hazard).\n\nOne way of avoiding the dual package hazard that works both for bundlers and when running natively in node is to put all of your code in the `require` condition as CommonJS and have the `import` condition just be a light ESM wrapper that calls `require` on your package and re-exports the package using ESM syntax. This approach doesn't provide good tree-shaking, however, as esbuild doesn't tree-shake CommonJS modules.\n\nAnother way of avoiding a dual package hazard is to use the bundler-specific `module` condition to direct bundlers to always load the ESM version of your package while letting node always fall back to the CommonJS version of your package. Both `import` and `module` are intended to be used with ESM but unlike `import`, the `module` condition is always active even if the import path was loaded using a `require` call. This works well with bundlers because bundlers support loading ESM using `require`, but it's not something that can work with node because node deliberately doesn't implement loading ESM using `require`.\n\n### External\n\n*Supported by: [Build](#build)*\n\nYou can mark a file or a package as external to exclude it from your build. Instead of being bundled, the import will be preserved (using `require` for the `iife` and `cjs` formats and using `import` for the `esm` format) and will be evaluated at run time instead.\n\nThis has several uses. First of all, it can be used to trim unnecessary code from your bundle for a code path that you know will never be executed. For example, a package may contain code that only runs in node but you will only be using that package in the browser. It can also be used to import code in node at run time from a package that cannot be bundled. For example, the `fsevents` package contains a native extension, which esbuild doesn't support. Marking something as external looks like this:\n\n``` sh\necho 'require(\"fsevents\")' > app.js\nesbuild app.js --bundle --external:fsevents --platform=node\n// app.js\nrequire(\"fsevents\");\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\nimport fs from 'node:fs'\n\nfs.writeFileSync('app.js', 'require(\"fsevents\")')\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  outfile: 'out.js',\n  bundle: true,\n  platform: 'node',\n  external: ['fsevents'],\n})\n```\n\n``` go\npackage main\n\nimport \"io/ioutil\"\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  ioutil.WriteFile(\"app.js\", []byte(\"require(\\\"fsevents\\\")\"), 0644)\n\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Outfile:     \"out.js\",\n    Bundle:      true,\n    Write:       true,\n    Platform:    api.PlatformNode,\n    External:    []string{\"fsevents\"},\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nYou can also use the `*` wildcard character in an external path to mark all files matching that pattern as external. For example, you can use `*.png` to remove all `.png` files or `/images/*` to remove all paths starting with `/images/`:\n\n``` sh\nesbuild app.js --bundle \"--external:*.png\" \"--external:/images/*\"\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  outfile: 'out.js',\n  bundle: true,\n  external: ['*.png', '/images/*'],\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Outfile:     \"out.js\",\n    Bundle:      true,\n    Write:       true,\n    External:    []string{\"*.png\", \"/images/*\"},\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nExternal paths are applied both before and after path resolution, which lets you match against both the import path in the source code and the absolute file system path. The path is considered to be external if the external path matches in either case. The specific behavior is as follows:\n\n- Before path resolution begins, import paths are checked against all external paths. In addition, if the external path looks like a package path (i.e. doesn't start with `/` or `./` or `../`), import paths are checked to see if they have that package path as a path prefix.\n\n  This means that `--external:@foo/bar` implicitly also means `--external:@foo/bar/*` which matches the import path `@foo/bar/baz`. So it marks all paths inside the `@foo/bar` package as external too.\n\n- After path resolution ends, the resolved absolute paths are checked against all external paths that don't look like a package path (i.e. those that start with `/` or `./` or `../`). But before checking, the external path is joined with the current working directory and then normalized, becoming an absolute path (even if it contains a `*` wildcard character).\n\n  This means that you can mark everything in the directory `dir` as external using `--external:./dir/*`. Note that the leading `./` is important. Using `--external:dir/*` instead is treated as a package path and is not checked for after path resolution ends.\n\n### Main fields\n\n*Supported by: [Build](#build)*\n\nWhen you import a package in node, the `main` field in that package's `package.json` file determines which file is imported (along with [a lot of other rules](https://nodejs.org/api/modules.html#all-together)). Major JavaScript bundlers including esbuild let you specify additional `package.json` fields to try when resolving a package. There are at least three such fields commonly in use:\n\n- `main`\n\n  This is [the standard field](https://docs.npmjs.com/files/package.json#main) for all packages that are meant to be used with node. The name `main` is hard-coded in to node's module resolution logic itself. Because it's intended for use with node, it's reasonable to expect that the file path in this field is a CommonJS-style module.\n\n- `module`\n\n  This field came from [a proposal](https://github.com/dherman/defense-of-dot-js/blob/f31319be735b21739756b87d551f6711bd7aa283/proposal.md) for how to integrate ECMAScript modules into node. Because of this, it's reasonable to expect that the file path in this field is an ECMAScript-style module. This proposal wasn't adopted by node (node uses `\"type\": \"module\"` instead) but it was adopted by major bundlers because ECMAScript-style modules lead to better [tree shaking](#tree-shaking), or dead code removal.\n\n  For package authors: Some packages incorrectly use the `module` field for browser-specific code, leaving node-specific code for the `main` field. This is probably because node ignores the `module` field and people typically only use bundlers for browser-specific code. However, bundling node-specific code is valuable too (e.g. it decreases download and boot time) and packages that put browser-specific code in `module` prevent bundlers from being able to do tree shaking effectively. If you are trying to publish browser-specific code in a package, use the `browser` field instead.\n\n- `browser`\n\n  This field came from [a proposal](https://gist.github.com/defunctzombie/4339901/49493836fb873ddaa4b8a7aa0ef2352119f69211) that allows bundlers to replace node-specific files or modules with their browser-friendly versions. It lets you specify an alternate browser-specific entry point. Note that it is possible for a package to use both the `browser` and `module` field together (see the note below).\n\nThe default main fields depend on the current [platform](#platform) setting. These defaults should be the most widely compatible with the existing package ecosystem. But you can customize them like this if you want to:\n\n``` sh\nesbuild app.js --bundle --main-fields=module,main\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  mainFields: ['module', 'main'],\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    MainFields:  []string{\"module\", \"main\"},\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n#### For package authors\n\nIf you want to author a package that uses the `browser` field in combination with the `module` field, then you'll probably want to fill out ***all four entries*** in the full CommonJS-vs-ESM and browser-vs-node compatibility matrix. For that you'll need to use the expanded form of the `browser` field that is a map instead of just a string:\n\n``` javascript\n{\n  \"main\": \"./node-cjs.js\",\n  \"module\": \"./node-esm.js\",\n  \"browser\": {\n    \"./node-cjs.js\": \"./browser-cjs.js\",\n    \"./node-esm.js\": \"./browser-esm.js\"\n  }\n}\n```\n\nThe `main` field is expected to be CommonJS while the `module` field is expected to be ESM. The decision about which module format to use is independent from the decision about whether to use a browser-specific or node-specific variant. If you omit one of these four entries, then you risk the wrong variant being chosen. For example, if you omit the entry for the CommonJS browser build, then the CommonJS node build could be chosen instead.\n\nNote that using `main`, `module`, and `browser` is the old way of doing this. There is also a newer way to do this that you may prefer to use instead: the [`exports` field](#how-conditions-work) in `package.json`. It provides a different set of trade-offs. For example, it gives you more precise control over imports for all sub-paths in your package (while `main` fields only give you control over the entry point), but it may cause your package to be imported multiple times depending on how you configure it.\n\n### Node paths\n\n*Supported by: [Build](#build)*\n\nNode's module resolution algorithm supports an environment variable called [`NODE_PATH`](https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders) that contains a list of global directories to use when resolving import paths. These paths are searched for packages in addition to the `node_modules` directories in all parent directories. You can pass this list of directories to esbuild using an environment variable with the CLI and using an array with the JS and Go APIs:\n\n``` sh\nNODE_PATH=someDir esbuild app.js --bundle --outfile=out.js\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  nodePaths: ['someDir'],\n  entryPoints: ['app.js'],\n  bundle: true,\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    NodePaths:   []string{\"someDir\"},\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Outfile:     \"out.js\",\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nIf you are using the CLI and want to pass multiple directories using `NODE_PATH`, you will have to separate them with `:` on Unix and `;` on Windows. This is the same format that Node itself uses.\n\n### Packages\n\n*Supported by: [Build](#build)*\n\nUse this setting to control whether all of your package's dependencies are excluded from the bundle or not. This is useful when [bundling for node](../getting-started/index#bundling-for-node) because many npm packages use node-specific features that esbuild doesn't support while bundling (such as `__dirname`, `import.meta.url`, `fs.readFileSync`, and `*.node` native binary modules). There are two possible values:\n\n- `bundle`\n\n  This is the default value. It means that package imports are allowed to be bundled. Note that this value doesn't mean all packages will be bundled, just that they are allowed to be. You can still exclude individual packages from the bundle using [external](#external).\n\n- `external`\n\n  This means that all package imports considered external to the bundle, and are not bundled. *Note that your dependencies must still be present on the file system when your bundle is run.* It has the same effect as manually passing each dependency to [external](#external) but is more concise. If you want to customize which of your dependencies are external and which ones aren't, then you should set this to `bundle` instead and then use [external](#external) for individual dependencies.\n\n  This setting considers all import paths that \"look like\" package imports in the original source code to be package imports. Specifically import paths that don't start with a path segment of `/` or `.` or `..` are considered to be package imports. The only two exceptions to this rule are [subpath imports](https://nodejs.org/api/packages.html#subpath-imports) (which start with a `#` character) and TypeScript path remappings via [`paths`](https://www.typescriptlang.org/tsconfig/#paths) and/or [`baseUrl`](https://www.typescriptlang.org/tsconfig/#baseUrl) in `tsconfig.json` (which are applied first).\n\nUsing it looks like this:\n\n``` sh\nesbuild app.js --bundle --packages=external\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  packages: 'external',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Packages:    api.PackagesExternal,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nNote that this setting only has an effect when [bundling](#bundle) is enabled. Also note that marking an import path as external happens after the import path is rewritten by any configured [aliases](#alias), so the alias feature still has an effect when this setting is used.\n\n### Preserve symlinks\n\n*Supported by: [Build](#build)*\n\nThis setting mirrors the [`--preserve-symlinks`](https://nodejs.org/api/cli.html#cli_preserve_symlinks) setting in node. If you use that setting (or the similar [`resolve.symlinks`](https://webpack.js.org/configuration/resolve/#resolvesymlinks) setting in Webpack), you will likely need to enable this setting in esbuild too. It can be enabled like this:\n\n``` sh\nesbuild app.js --bundle --preserve-symlinks --outfile=out.js\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  preserveSymlinks: true,\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:      []string{\"app.js\"},\n    Bundle:           true,\n    PreserveSymlinks: true,\n    Outfile:          \"out.js\",\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nEnabling this setting causes esbuild to determine file identity by the original file path (i.e. the path without following symlinks) instead of the real file path (i.e. the path after following symlinks). This can be beneficial with certain directory structures. Keep in mind that this means a file may be given multiple identities if there are multiple symlinks pointing to it, which can result in it appearing multiple times in generated output files.\n\n*Note: The term \"symlink\" means [symbolic link](https://en.wikipedia.org/wiki/Symbolic_link) and refers to a file system feature where a path can redirect to another path.*\n\n### Resolve extensions\n\n*Supported by: [Build](#build)*\n\nThe [resolution algorithm used by node](https://nodejs.org/api/modules.html#modules_file_modules) supports implicit file extensions. You can `require('./file')` and it will check for `./file`, `./file.js`, `./file.json`, and `./file.node` in that order. Modern bundlers including esbuild extend this concept to other file types as well. The full order of implicit file extensions in esbuild can be customized using the resolve extensions setting, which defaults to `.tsx,.ts,.jsx,.js,.css,.json`:\n\n``` sh\nesbuild app.js --bundle --resolve-extensions=.ts,.js\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  resolveExtensions: ['.ts', '.js'],\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:       []string{\"app.js\"},\n    Bundle:            true,\n    ResolveExtensions: []string{\".ts\", \".js\"},\n    Write:             true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nNote that esbuild deliberately does not include the new `.mjs` and `.cjs` extensions in this list. Node's resolution algorithm doesn't treat these as implicit file extensions, so esbuild doesn't either. If you want to import files with these extensions you should either explicitly add the extensions in your import paths or change this setting to include the additional extensions that you want to be implicit.\n\n### Working directory\n\n*Supported by: [Build](#build)*\n\nThis API option lets you specify the working directory to use for the build. It normally defaults to the current [working directory](https://en.wikipedia.org/wiki/Working_directory) of the process you are using to call esbuild's API. The working directory is used by esbuild for a few different things including resolving relative paths given as API options to absolute paths and pretty-printing absolute paths as relative paths in log messages. Here is how to customize esbuild's working directory:\n\n``` sh\ncd \"/var/tmp/custom/working/directory\"\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['file.js'],\n  absWorkingDir: '/var/tmp/custom/working/directory',\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:   []string{\"file.js\"},\n    AbsWorkingDir: \"/var/tmp/custom/working/directory\",\n    Outfile:       \"out.js\",\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nNote: If you are using [Yarn Plug'n'Play](https://yarnpkg.com/features/pnp/), keep in mind that this working directory is used to search for Yarn's manifest file. If you are running esbuild from an unrelated directory, you will have to set this working directory to the directory containing the manifest file (or one of its child directories) for the manifest file to be found by esbuild.\n\n## Transformation\n\n### JSX\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis option tells esbuild what to do about JSX syntax. Here are the available options:\n\n- `transform`\n\n  This tells esbuild to transform JSX to JS using a general-purpose transform that's shared between many libraries that use JSX syntax. Each JSX element is turned into a call to the [JSX factory](#jsx-factory) function with the element's component (or with the [JSX fragment](#jsx-fragment) for fragments) as the first argument. The second argument is an array of props (or `null` if there are no props). Any child elements present become additional arguments after the second argument.\n\n  If you want to configure this setting on a per-file basis, you can do that by using a `// @jsxRuntime classic` comment. This is a convention from [Babel's JSX plugin](https://babeljs.io/docs/en/babel-preset-react/) that esbuild follows.\n\n- `preserve`\n\n  This preserves the JSX syntax in the output instead of transforming it into function calls. JSX elements are treated as first-class syntax and are still affected by other settings such as [minification](#minify) and [property mangling](#mangle-props).\n\n  Note that this means the output files are no longer valid JavaScript code. This feature is intended to be used when you want to transform the JSX syntax in esbuild's output files by another tool after bundling.\n\n- `automatic`\n\n  This transform was [introduced in React 17+](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html) and is very specific to React. It automatically generates `import` statements from the [JSX import source](#jsx-import-source) and introduces many special cases regarding how the syntax is handled. The details are too complicated to describe here. For more information, please read [React's documentation about their new JSX transform](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md). If you want to enable the development mode version of this transform, you need to additionally enable the [JSX dev](#jsx-dev) setting.\n\n  If you want to configure this setting on a per-file basis, you can do that by using a `// @jsxRuntime automatic` comment. This is a convention from [Babel's JSX plugin](https://babeljs.io/docs/en/babel-preset-react/) that esbuild follows.\n\nHere's an example of setting the JSX transform to `preserve`:\n\n``` sh\necho '<div/>' | esbuild --jsx=preserve --loader=jsx\n<div />;\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet result = await esbuild.transform('<div/>', {\n  jsx: 'preserve',\n  loader: 'jsx',\n})\n\nconsole.log(result.code)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  result := api.Transform(\"<div/>\", api.TransformOptions{\n    JSX:    api.JSXPreserve,\n    Loader: api.LoaderJSX,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\n### JSX dev\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nIf the [JSX](#jsx) transform has been set to `automatic`, then enabling this setting causes esbuild to automatically inject the file name and source location into each JSX element. Your JSX library can then use this information to help with debugging. If the JSX transform has been set to something other than `automatic`, then this setting does nothing. Here's an example of enabling this setting:\n\n``` sh\necho '<a/>' | esbuild --loader=jsx --jsx=automatic\nimport { jsx } from \"react/jsx-runtime\";\n/* @__PURE__ */ jsx(\"a\", {});\necho '<a/>' | esbuild --loader=jsx --jsx=automatic --jsx-dev\nimport { jsxDEV } from \"react/jsx-dev-runtime\";\n/* @__PURE__ */ jsxDEV(\"a\", {}, void 0, false, {\n  fileName: \"<stdin>\",\n  lineNumber: 1,\n  columnNumber: 1\n}, this);\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.jsx'],\n  jsxDev: true,\n  jsx: 'automatic',\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.jsx\"},\n    JSXDev:      true,\n    JSX:         api.JSXAutomatic,\n    Outfile:     \"out.js\",\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n### JSX factory\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis sets the function that is called for each JSX element. Normally a JSX expression such as this:\n\n``` javascript\n<div>Example text</div>\n```\n\nis compiled into a function call to `React.createElement` like this:\n\n``` javascript\nReact.createElement(\"div\", null, \"Example text\");\n```\n\nYou can call something other than `React.createElement` by changing the JSX factory. For example, to call the function `h` instead (which is used by other libraries such as [Preact](https://preactjs.com/)):\n\n``` sh\necho '<div/>' | esbuild --jsx-factory=h --loader=jsx\n/* @__PURE__ */ h(\"div\", null);\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet result = await esbuild.transform('<div/>', {\n  jsxFactory: 'h',\n  loader: 'jsx',\n})\n\nconsole.log(result.code)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  result := api.Transform(\"<div/>\", api.TransformOptions{\n    JSXFactory: \"h\",\n    Loader:     api.LoaderJSX,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\nAlternatively, if you are using TypeScript, you can just configure JSX for TypeScript by adding this to your `tsconfig.json` file and esbuild should pick it up automatically without needing to be configured:\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"jsxFactory\": \"h\"\n  }\n}\n```\n\nIf you want to configure this on a per-file basis, you can do that by using a `// @jsx h` comment. Note that this setting does not apply when the [JSX](#jsx) transform has been set to `automatic`.\n\n### JSX fragment\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis sets the function that is called for each JSX fragment. Normally a JSX fragment expression such as this:\n\n``` javascript\n<>Stuff</>\n```\n\nis compiled into a use of the `React.Fragment` component like this:\n\n``` javascript\nReact.createElement(React.Fragment, null, \"Stuff\");\n```\n\nYou can use a component other than `React.Fragment` by changing the JSX fragment. For example, to use the component `Fragment` instead (which is used by other libraries such as [Preact](https://preactjs.com/)):\n\n``` sh\necho '<>x</>' | esbuild --jsx-fragment=Fragment --loader=jsx\n/* @__PURE__ */ React.createElement(Fragment, null, \"x\");\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet result = await esbuild.transform('<>x</>', {\n  jsxFragment: 'Fragment',\n  loader: 'jsx',\n})\n\nconsole.log(result.code)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  result := api.Transform(\"<>x</>\", api.TransformOptions{\n    JSXFragment: \"Fragment\",\n    Loader:      api.LoaderJSX,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\nAlternatively, if you are using TypeScript, you can just configure JSX for TypeScript by adding this to your `tsconfig.json` file and esbuild should pick it up automatically without needing to be configured:\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"jsxFragmentFactory\": \"Fragment\"\n  }\n}\n```\n\nIf you want to configure this on a per-file basis, you can do that by using a `// @jsxFrag Fragment` comment. Note that this setting does not apply when the [JSX](#jsx) transform has been set to `automatic`.\n\n### JSX import source\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nIf the [JSX](#jsx) transform has been set to `automatic`, then setting this lets you change which library esbuild uses to automatically import its JSX helper functions from. Note that this only works with the JSX transform that's [specific to React 17+](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html). If you set the JSX import source to `your-pkg`, then that package must expose at least the following exports:\n\n``` javascript\nimport { createElement } from \"your-pkg\"\nimport { Fragment, jsx, jsxs } from \"your-pkg/jsx-runtime\"\nimport { Fragment, jsxDEV } from \"your-pkg/jsx-dev-runtime\"\n```\n\nThe `/jsx-runtime` and `/jsx-dev-runtime` subpaths are hard-coded by design and cannot be changed. The `jsx` and `jsxs` imports are used when [JSX dev mode](#jsx-dev) is off and the `jsxDEV` import is used when JSX dev mode is on. The meaning of these is described in [React's documentation about their new JSX transform](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md). The `createElement` import is used regardless of the JSX dev mode when an element has a prop spread followed by a `key` prop, which looks like this:\n\n``` javascript\nreturn <div {...props} key={key} />\n```\n\nHere's an example of setting the JSX import source to [`preact`](https://preactjs.com/):\n\n``` sh\nesbuild app.jsx --jsx-import-source=preact --jsx=automatic\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.jsx'],\n  jsxImportSource: 'preact',\n  jsx: 'automatic',\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:     []string{\"app.jsx\"},\n    JSXImportSource: \"preact\",\n    JSX:             api.JSXAutomatic,\n    Outfile:         \"out.js\",\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nAlternatively, if you are using TypeScript, you can just configure the JSX import source for TypeScript by adding this to your `tsconfig.json` file and esbuild should pick it up automatically without needing to be configured:\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"jsx\": \"react-jsx\",\n    \"jsxImportSource\": \"preact\"\n  }\n}\n```\n\nAnd if you want to control this setting on the per-file basis, you can do that with a `// @jsxImportSource your-pkg` comment in each file. You may also need to add a `// @jsxRuntime automatic` comment as well if the [JSX](#jsx) transform has not already been set by other means, or if you want that to be set on a per-file basis as well.\n\n### JSX side effects\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nBy default esbuild assumes that JSX expressions are side-effect free, which means they are annoated with [`/* @__PURE__ */` comments](#pure) and are removed during bundling when they are unused. This follows the common use of JSX for virtual DOM and applies to the vast majority of JSX libraries. However, some people have written JSX libraries that don't have this property (specifically JSX expressions can have arbitrary side effects and can't be removed when unused). If you are using such a library, you can use this setting to tell esbuild that JSX expressions have side effects:\n\n``` sh\nesbuild app.jsx --jsx-side-effects\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.jsx'],\n  outfile: 'out.js',\n  jsxSideEffects: true,\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:    []string{\"app.jsx\"},\n    Outfile:        \"out.js\",\n    JSXSideEffects: true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n### Supported\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis setting lets you customize esbuild's set of unsupported syntax features at the individual syntax feature level. For example, you can use this to tell esbuild that [BigInts](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) are not supported so that esbuild generates an error when you try to use one. Usually this is configured for you when you use the [`target`](#target) setting, which you should typically be using instead of this setting. If the target is specified in addition to this setting, this setting will override whatever is specified by the target.\n\nHere are some examples of why you might want to use this setting instead of or in addition to setting the target:\n\n- JavaScript runtimes often do a quick implementation of newer syntax features that is slower than the equivalent older JavaScript, and you can get a speedup by telling esbuild to pretend this syntax feature isn't supported. For example, [V8](https://v8.dev/) has a [long-standing performance bug regarding object spread](https://bugs.chromium.org/p/v8/issues/detail?id=11536) that can be avoided by manually copying properties instead of using object spread syntax.\n\n- There are many other JavaScript implementations in addition to the ones that esbuild's `target` setting recognizes, and they may not support certain features. If you are targeting such an implementation, you can use this setting to configure esbuild with a custom syntax feature compatibility set without needing to change esbuild itself. For example, [TypeScript's](https://www.typescriptlang.org/) JavaScript parser may not support [arbitrary module namespace identifier names](https://github.com/microsoft/TypeScript/issues/40594) so you may want to turn those off when targeting TypeScript's JavaScript parser.\n\n- You may be processing esbuild's output with another tool, and you may want esbuild to transform certain features and the other tool to transform certain other features. For example, if you are using esbuild to transform files individually to ES5 but you are then feeding the output into [Webpack](https://webpack.js.org/) for bundling, you may want to preserve `import()` expressions even though they are a syntax error in ES5.\n\nIf you want esbuild to consider a certain syntax feature to be unsupported, you can specify that like this:\n\n``` sh\nesbuild app.js --supported:bigint=false\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  supported: {\n    'bigint': false,\n  },\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Supported: map[string]bool{\n      \"bigint\": false,\n    },\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nSyntax features are specified using esbuild-specific feature names. The full set of feature names is as follows:\n\n**JavaScript:**\n\n- `arbitrary-module-namespace-names`\n- `array-spread`\n- `arrow`\n- `async-await`\n- `async-generator`\n- `bigint`\n- `class`\n- `class-field`\n- `class-private-accessor`\n- `class-private-brand-check`\n- `class-private-field`\n- `class-private-method`\n- `class-private-static-accessor`\n- `class-private-static-field`\n- `class-private-static-method`\n- `class-static-blocks`\n- `class-static-field`\n- `const-and-let`\n- `decorators`\n- `default-argument`\n- `destructuring`\n- `dynamic-import`\n- `exponent-operator`\n- `export-star-as`\n- `for-await`\n- `for-of`\n- `function-name-configurable`\n- `function-or-class-property-access`\n- `generator`\n- `hashbang`\n- `import-assertions`\n- `import-attributes`\n- `import-meta`\n- `inline-script`\n- `logical-assignment`\n- `nested-rest-binding`\n- `new-target`\n- `node-colon-prefix-import`\n- `node-colon-prefix-require`\n- `nullish-coalescing`\n- `object-accessors`\n- `object-extensions`\n- `object-rest-spread`\n- `optional-catch-binding`\n- `optional-chain`\n- `regexp-dot-all-flag`\n- `regexp-lookbehind-assertions`\n- `regexp-match-indices`\n- `regexp-named-capture-groups`\n- `regexp-set-notation`\n- `regexp-sticky-and-unicode-flags`\n- `regexp-unicode-property-escapes`\n- `rest-argument`\n- `template-literal`\n- `top-level-await`\n- `typeof-exotic-object-is-object`\n- `unicode-escapes`\n- `using`\n\n**CSS:**\n\n- `color-functions`\n- `gradient-double-position`\n- `gradient-interpolation`\n- `gradient-midpoints`\n- `hwb`\n- `hex-rgba`\n- `inline-style`\n- `inset-property`\n- `is-pseudo-class`\n- `modern-rgb-hsl`\n- `nesting`\n- `rebecca-purple`\n\n### Target\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis sets the target environment for the generated JavaScript and/or CSS code. It tells esbuild to transform JavaScript syntax that is too new for these environments into older JavaScript syntax that will work in these environments. For example, the `??` operator was introduced in Chrome 80 so esbuild will convert it into an equivalent (but more verbose) conditional expression when targeting Chrome 79 or earlier.\n\nNote that this is only concerned with syntax features, not APIs. It does *not* automatically add [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for new APIs that are not used by these environments. You will have to explicitly import polyfills for the APIs you need (e.g. by importing [`core-js`](https://www.npmjs.com/package/core-js)). Automatic polyfill injection is outside of esbuild's scope.\n\nEach target environment is an environment name followed by a version number. The following environment names are currently supported:\n\n- `chrome`\n- `deno`\n- `edge`\n- `firefox`\n- `hermes`\n- `ie`\n- `ios`\n- `node`\n- `opera`\n- `rhino`\n- `safari`\n\nIn addition, you can also specify JavaScript language versions such as `es2020`. The default target is `esnext` which means that by default, esbuild will assume all of the latest JavaScript and CSS features are supported. Here is an example that configures multiple target environments. You don't need to specify all of them; you can just specify the subset of target environments that your project cares about. You can also be more precise about version numbers if you'd like (e.g. `node12.19.0` instead of just `node12`):\n\n``` sh\nesbuild app.js --target=es2020,chrome58,edge16,firefox57,node12,safari11\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  target: [\n    'es2020',\n    'chrome58',\n    'edge16',\n    'firefox57',\n    'node12',\n    'safari11',\n  ],\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Target:      api.ES2020,\n    Engines: []api.Engine{\n      {Name: api.EngineChrome, Version: \"58\"},\n      {Name: api.EngineEdge, Version: \"16\"},\n      {Name: api.EngineFirefox, Version: \"57\"},\n      {Name: api.EngineNode, Version: \"12\"},\n      {Name: api.EngineSafari, Version: \"11\"},\n    },\n    Write: true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nYou can refer to the [JavaScript loader](../content-types/index#javascript) for the details about which syntax features were introduced with which language versions. Keep in mind that while JavaScript language versions such as `es2020` are identified by year, that is the year the specification is approved. It has nothing to do with the year all major browsers implement that specification which often happens earlier or later than that year.\n\nIf you use a syntax feature that esbuild doesn't yet have support for transforming to your current language target, esbuild will generate an error where the unsupported syntax is used. This is often the case when targeting the `es5` language version, for example, since esbuild only supports transforming most newer JavaScript syntax features to `es6`.\n\nIf you need to customize the set of supported syntax features at the individual feature level in addition to or instead of what `target` provides, you can do that with the [`supported`](#supported) setting.\n\n## Optimization\n\n### Define\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis feature provides a way to replace global identifiers with constant expressions. It can be a way to change the behavior some code between builds without changing the code itself:\n\n``` sh\necho 'hooks = DEBUG && require(\"hooks\")' | esbuild --define:DEBUG=true\nhooks = require(\"hooks\");\necho 'hooks = DEBUG && require(\"hooks\")' | esbuild --define:DEBUG=false\nhooks = false;\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'let js = 'hooks = DEBUG && require(\"hooks\")'(await esbuild.transform(js, {\n  define: { DEBUG: 'true' },\n})).code\n'hooks = require(\"hooks\");\\n'\n(await esbuild.transform(js, {\n  define: { DEBUG: 'false' },\n})).code\n'hooks = false;\\n'\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"hooks = DEBUG && require('hooks')\"\n\n  result1 := api.Transform(js, api.TransformOptions{\n    Define: map[string]string{\"DEBUG\": \"true\"},\n  })\n\n  if len(result1.Errors) == 0 {\n    fmt.Printf(\"%s\", result1.Code)\n  }\n\n  result2 := api.Transform(js, api.TransformOptions{\n    Define: map[string]string{\"DEBUG\": \"false\"},\n  })\n\n  if len(result2.Errors) == 0 {\n    fmt.Printf(\"%s\", result2.Code)\n  }\n}\n```\n\nEach `define` entry maps an identifier to a string of code containing an expression. The expression in the string must either be a JSON object (null, boolean, number, string, array, or object) or a single identifier. Replacement expressions other than arrays and objects are substituted inline, which means that they can participate in constant folding. Array and object replacement expressions are stored in a variable and then referenced using an identifier instead of being substituted inline, which avoids substituting repeated copies of the value but means that the values don't participate in constant folding.\n\nIf you want to replace something with a string literal, keep in mind that the replacement value passed to esbuild must itself contain quotes because each `define` entry maps to a string containing code. Omitting the quotes means the replacement value is an identifier instead. This is demonstrated in the example below:\n\n``` sh\necho 'id, str' | esbuild --define:id=text --define:str=\\\"text\\\"\ntext, \"text\";\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'(await esbuild.transform('id, str', {\n  define: { id: 'text', str: '\"text\"' },\n})).code\n'text, \"text\";\\n'\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  result := api.Transform(\"id, text\", api.TransformOptions{\n    Define: map[string]string{\n      \"id\":  \"text\",\n      \"str\": \"\\\"text\\\"\",\n    },\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\nIf you're using the CLI, keep in mind that different shells have different rules for how to escape double-quote characters (which are necessary when the replacement value is a string). Use a `\\\"` backslash escape because it works in both bash and Windows command prompt. Other methods of escaping double quotes that work in bash such as surrounding them with single quotes will not work on Windows, since Windows command prompt does not remove the single quotes. This is relevant when using the CLI from a npm script in your `package.json` file, which people will expect to work on all platforms:\n\n``` javascript\n{\n  \"scripts\": {\n    \"build\": \"esbuild --define:process.env.NODE_ENV=\\\\\\\"production\\\\\\\" app.js\"\n  }\n}\n```\n\nIf you still run into cross-platform quote escaping issues with different shells, you will probably want to switch to using the [JavaScript API](index) instead. There you can use regular JavaScript syntax to eliminate cross-platform differences.\n\nIf you're looking for a more advanced form of the define feature that can replace an expression with something other than a constant (e.g. replacing a global variable with a shim), you may be able to use the similar [inject](#inject) feature to do that.\n\n### Drop\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis tells esbuild to edit your source code before building to drop certain constructs. There are currently two possible things that can be dropped:\n\n- `debugger`\n\n  Passing this flag causes all [`debugger` statements](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger) to be removed from the output. This is similar to the `drop_debugger: true` flag available in the popular [UglifyJS](https://github.com/mishoo/UglifyJS) and [Terser](https://github.com/terser/terser) JavaScript minifiers.\n\n  JavaScript's `debugger` statements cause the active debugger to treat the statement as an automatically-configured breakpoint. Code containing this statement will automatically be paused when the debugger is open. If no debugger is open, the statement does nothing. Dropping these statements from your code just prevents the debugger from automatically stopping when your code runs.\n\n  You can drop `debugger` statements like this:\n\n``` sh\nesbuild app.js --drop:debugger\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  drop: ['debugger'],\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Drop:        api.DropDebugger,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n- `console`\n\n  Passing this flag causes all [`console` API calls](https://developer.mozilla.org/en-US/docs/Web/API/console#methods) to be removed from the output. This is similar to the `drop_console: true` flag available in the popular [UglifyJS](https://github.com/mishoo/UglifyJS) and [Terser](https://github.com/terser/terser) JavaScript minifiers.\n\n  WARNING: Using this flag can introduce bugs into your code! This flag removes the entire call expression including all call arguments. If any of those arguments had important side effects, using this flag will change the behavior of your code. Be very careful when using this flag.\n\n  If you want to remove console API calls without removing the arguments with side effects (so you do not introduce bugs), you should mark the relevant API calls as [pure](#pure) instead. For example, you can mark `console.log` as pure using `--pure:console.log`. This will cause these API calls to be removed safely when minification is enabled.\n\n  You can drop `console` API calls like this:\n\n``` sh\nesbuild app.js --drop:console\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  drop: ['console'],\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Drop:        api.DropConsole,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n### Drop labels\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis tells esbuild to edit your source code before building to drop [labeled statements](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label) with specific label names. For example, consider the following code:\n\n``` javascript\nfunction example() {\n  DEV: doAnExpensiveCheck()\n  return normalCodePath()\n}\n```\n\nIf you use this option to drop all labels named `DEV`, then esbuild will give you this:\n\n``` javascript\nfunction example() {\n  return normalCodePath();\n}\n```\n\nYou can configure this feature like this (which will drop both the `DEV` and `TEST` labels):\n\n``` sh\nesbuild app.js --drop-labels=DEV,TEST\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  dropLabels: ['DEV', 'TEST'],\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    DropLabels:  []string{\"DEV\", \"TEST\"},\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nNote that this is not the only way to conditionally remove code. Another more common way is to use the [define](#define) feature to replace specific global variables with a boolean value. For example, consider the following code:\n\n``` javascript\nfunction example() {\n  DEV && doAnExpensiveCheck()\n  return normalCodePath()\n}\n```\n\nIf you define `DEV` to `false`, then esbuild will give you this:\n\n``` javascript\nfunction example() {\n  return normalCodePath();\n}\n```\n\nThis is pretty much the same thing as using a label. However, an advantage of using a label instead of a global variable to conditionally remove code is that you don't have to worry about the global variable not being defined because someone forgot to configure esbuild to replace it with something. Some drawbacks of using the label approach are that it makes conditionally removing code when the label is *not* dropped slightly harder to read, and it doesn't work for code embedded within nested expressions. Which approach to use for a given project comes down to personal preference.\n\n### Ignore annotations\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nSince JavaScript is a dynamic language, identifying unused code is sometimes very difficult for a compiler, so the community has developed certain annotations to help tell compilers what code should be considered side-effect free and available for removal. Currently there are two forms of side-effect annotations that esbuild supports:\n\n- Inline `/* @__PURE__ */` comments before function calls tell esbuild that the function call can be removed if the resulting value isn't used. See the [pure](#pure) API option for more information.\n\n- The `sideEffects` field in `package.json` can be used to tell esbuild which files in your package can be removed if all imports from that file end up being unused. This is a convention from Webpack and many libraries published to npm already have this field in their package definition. You can learn more about this field in [Webpack's documentation](https://webpack.js.org/guides/tree-shaking/) for this field.\n\nThese annotations can be problematic because the compiler depends completely on developers for accuracy, and developers occasionally publish packages with incorrect annotations. The `sideEffects` field is particularly error-prone for developers because by default it causes all files in your package to be considered dead code if no imports are used. If you add a new file containing side effects and forget to update that field, your package will likely break when people try to bundle it.\n\nThis is why esbuild includes a way to ignore side-effect annotations. You should only enable this if you encounter a problem where the bundle is broken because necessary code was unexpectedly removed from the bundle:\n\n``` sh\nesbuild app.js --bundle --ignore-annotations\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  ignoreAnnotations: true,\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:       []string{\"app.js\"},\n    Bundle:            true,\n    IgnoreAnnotations: true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nEnabling this means esbuild will no longer respect `/* @__PURE__ */` comments or the `sideEffects` field. It will still do automatic [tree shaking](#tree-shaking) of unused imports, however, since that doesn't rely on annotations from developers. Ideally this flag is only a temporary workaround. You should report these issues to the maintainer of the package to get them fixed since they indicate a problem with the package and they will likely trip up other people too.\n\n### Inject\n\n*Supported by: [Build](#build)*\n\nThis option allows you to automatically replace a global variable with an import from another file. This can be a useful tool for adapting code that you don't control to a new environment. For example, assume you have a file called `process-cwd-shim.js` that exports a shim using the export name `process.cwd`:\n\n``` javascript\n// process-cwd-shim.js\nlet processCwdShim = () => ''\nexport { processCwdShim as 'process.cwd' }\n```\n\n``` javascript\n// entry.js\nconsole.log(process.cwd())\n```\n\nThis is intended to replace uses of node's `process.cwd()` function to prevent packages that call it from crashing when run in the browser. You can use the inject feature to replace all references to the global property `process.cwd` with an import from that file:\n\n``` sh\nesbuild entry.js --inject:./process-cwd-shim.js --outfile=out.js\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['entry.js'],\n  inject: ['./process-cwd-shim.js'],\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"entry.js\"},\n    Inject:      []string{\"./process-cwd-shim.js\"},\n    Outfile:     \"out.js\",\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThat results in something like this:\n\n``` javascript\n// out.js\nvar processCwdShim = () => \"\";\nconsole.log(processCwdShim());\n```\n\nYou can think of the inject feature as similar to the [define](#define) feature, except it replaces an expression with an import to a file instead of with a constant, and the expression to replace is specified using an export name in a file instead of using an inline string in esbuild's API.\n\n#### Auto-import for [JSX](../content-types/index#jsx)\n\nReact (the library for which JSX syntax was originally created) has a mode they call `automatic` where you don't have to `import` anything to use JSX syntax. Instead, the JSX-to-JS transformer will automatically import the correct JSX factory function for you. You can enable `automatic` JSX mode with esbuild's [`jsx`](#jsx) setting. If you want auto-import for JSX and you are using a sufficiently new version of React, then you should be using the `automatic` JSX mode.\n\nHowever, setting `jsx` to `automatic` unfortunately also means you are using a highly React-specific JSX transform instead of the default general-purpose JSX transform. This means writing a JSX factory function is more complicated, and it also means that the `automatic` mode doesn't work with libraries that expect to be used with the standard JSX transform (including older versions of React).\n\nYou can use esbuild's inject feature to automatically import the [factory](#jsx-factory) and [fragment](#jsx-fragment) for JSX expressions when the JSX transform is not set to `automatic`. Here's an example file that can be injected to do this:\n\n``` javascript\nconst { createElement, Fragment } = require('react')\nexport {\n  createElement as 'React.createElement',\n  Fragment as 'React.Fragment',\n}\n```\n\nThis code uses the React library as an example, but you can use this approach with any other JSX library as well with appropriate changes.\n\n#### Injecting files without imports\n\nYou can also use this feature with files that have no exports. In that case the injected file just comes first before the rest of the output as if every input file contained `import \"./file.js\"`. Because of the way ECMAScript modules work, this injection is still \"hygienic\" in that symbols with the same name in different files are renamed so they don't collide with each other.\n\n#### Conditionally injecting a file\n\nIf you want to *conditionally* import a file only if the export is actually used, you should mark the injected file as not having side effects by putting it in a package and adding `\"sideEffects\": false` in that package's `package.json` file. This setting is a [convention from Webpack](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free) that esbuild respects for any imported file, not just files used with inject.\n\n### Keep names\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nIn JavaScript the `name` property on functions and classes defaults to a nearby identifier in the source code. These syntax forms all set the `name` property of the function to `\"fn\"`:\n\n``` javascript\nfunction fn() {}\nlet fn = function() {};\nfn = function() {};\nlet [fn = function() {}] = [];\nlet {fn = function() {}} = {};\n[fn = function() {}] = [];\n({fn = function() {}} = {});\n```\n\nHowever, [minification](#minify) renames symbols to reduce code size and [bundling](#bundle) sometimes need to rename symbols to avoid collisions. That changes value of the `name` property for many of these cases. This is usually fine because the `name` property is normally only used for debugging. However, some frameworks rely on the `name` property for registration and binding purposes. If this is the case, you can enable this option to preserve the original `name` values even in minified code:\n\n``` sh\nesbuild app.js --minify --keep-names\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  minify: true,\n  keepNames: true,\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:       []string{\"app.js\"},\n    MinifyWhitespace:  true,\n    MinifyIdentifiers: true,\n    MinifySyntax:      true,\n    KeepNames:         true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nNote that this feature is unavailable if the [target](#target) has been set to an old environment that doesn't allow esbuild to mutate the `name` property on functions and classes. This is the case for environments that don't support ES6.\n\n### Mangle props\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\n**Using this feature can break your code in subtle ways.** Do not use this feature unless you know what you are doing, and you know exactly how it will affect both your code and all of your dependencies.\n\nThis setting lets you pass a regular expression to esbuild to tell esbuild to automatically rename all properties that match this regular expression. It's useful when you want to minify certain property names in your code either to make the generated code smaller or to somewhat obfuscate your code's intent.\n\nHere's an example that uses the regular expression `_$` to mangle all properties ending in an underscore, such as `foo_`. This mangles `print({ foo_: 0 }.foo_)` into `print({ a: 0 }.a)`:\n\n``` sh\nesbuild app.js --mangle-props=_$\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  mangleProps: /_$/,\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    MangleProps: \"_$\",\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nOnly mangling properties that end in an underscore is a reasonable heuristic because normal JS code doesn't typically contain identifiers like that. Browser APIs also don't use this naming convention so this also avoids conflicts with browser APIs. If you want to avoid mangling names such as [`__defineGetter__`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__) you could consider using a more complex regular expression such as `[^_]_$` (i.e. must end in a non-underscore followed by an underscore).\n\nThis is a separate setting instead of being part of the [minify](#minify) setting because it's an unsafe transformation that does not work on arbitrary JavaScript code. It only works if the provided regular expression matches all of the properties that you want mangled and does not match any of the properties that you don't want mangled. It also only works if you do not under any circumstances reference a mangled property indirectly. For example, it means you can't use `obj[prop]` to reference a property where `prop` is a string containing the property name. Specifically the following syntax constructs are the only ones eligible for property mangling:\n\n| Syntax                           | Example                                   |\n|----------------------------------|-------------------------------------------|\n| Dot property accesses            | `x.foo_`                                  |\n| Dot optional chains              | `x?.foo_`                                 |\n| Object properties                | `x = { foo_: y }`                         |\n| Object methods                   | `x = { foo_() {} }`                       |\n| Class fields                     | `class x { foo_ = y }`                    |\n| Class methods                    | `class x { foo_() {} }`                   |\n| Object destructuring bindings    | `let { foo_: x } = y`                     |\n| Object destructuring assignments | `({ foo_: x } = y)`                       |\n| JSX element member expression    | `<X.foo_></X.foo_>`                       |\n| JSX attribute names              | `<X foo_={y} />`                          |\n| TypeScript namespace exports     | `namespace x { export let foo_ = y }`     |\n| TypeScript parameter properties  | `class x { constructor(public foo_) {} }` |\n\nWhen using this feature, keep in mind that property names are only consistently mangled within a single esbuild API call but not across esbuild API calls. Each esbuild API call does an independent property mangling operation so output files generated by two different API calls may mangle the same property to two different names, which could cause the resulting code to behave incorrectly.\n\n#### Quoted properties\n\nBy default, esbuild doesn't modify the contents of string literals. This means you can avoid property mangling for an individual property by quoting it as a string. However, you must consistently use quotes or no quotes for a given property everywhere for this to work. For example, `print({ foo_: 0 }.foo_)` will be mangled into `print({ a: 0 }.a)` while `print({ 'foo_': 0 }['foo_'])` will not be mangled.\n\nIf you would like for esbuild to also mangle the contents of string literals, you can explicitly enable that behavior like this:\n\n``` sh\nesbuild app.js --mangle-props=_$ --mangle-quoted\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  mangleProps: /_$/,\n  mangleQuoted: true,\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:  []string{\"app.js\"},\n    MangleProps:  \"_$\",\n    MangleQuoted: api.MangleQuotedTrue,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nEnabling this makes the following syntax constructs also eligible for property mangling:\n\n| Syntax                                  | Example                   |\n|-----------------------------------------|---------------------------|\n| Quoted property accesses                | `x['foo_']`               |\n| Quoted optional chains                  | `x?.['foo_']`             |\n| Quoted object properties                | `x = { 'foo_': y }`       |\n| Quoted object methods                   | `x = { 'foo_'() {} }`     |\n| Quoted class fields                     | `class x { 'foo_' = y }`  |\n| Quoted class methods                    | `class x { 'foo_'() {} }` |\n| Quoted object destructuring bindings    | `let { 'foo_': x } = y`   |\n| Quoted object destructuring assignments | `({ 'foo_': x } = y)`     |\n| String literals to the left of `in`     | `'foo_' in x`             |\n\n#### Mangling other strings\n\nMangling [quoted properties](#mangle-quoted) still only mangles strings in property name position. Sometimes you may also need to mangle property names in strings at arbitrary other locations in your code. To do that, you can prefix the string with a `/* @__KEY__ */` comment to tell esbuild that the contents of a string should be treated as a property name that can be mangled. For example:\n\n``` javascript\nlet obj = {}\nObject.defineProperty(\n  obj,\n  /* @__KEY__ */ 'foo_',\n  { get: () => 123 },\n)\nconsole.log(obj.foo_)\n```\n\nThis will cause the contents of the string `'foo_'` to be mangled as a property name (assuming [property mangling](#mangle-props) is enabled and `foo_` is eligible for renaming). The `/* @__KEY__ */` comment is a convention from [Terser](https://github.com/terser/terser), a popular JavaScript minifier with a similar property mangling feature.\n\n#### Preventing renaming\n\nIf you would like to exclude certain properties from mangling, you can reserve them with an additional setting. For example, this uses the regular expression `^__.*__$` to reserve all properties that start and end with two underscores, such as `__foo__`:\n\n``` sh\nesbuild app.js --mangle-props=_$ \"--reserve-props=^__.*__$\"\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  mangleProps: /_$/,\n  reserveProps: /^__.*__$/,\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:  []string{\"app.js\"},\n    MangleProps:  \"_$\",\n    ReserveProps: \"^__.*__$\",\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n#### Persisting renaming decisions\n\nAdvanced usage of the property mangling feature involves storing the mapping from original name to mangled name in a persistent cache. When enabled, all mangled property renamings are recorded in the cache during the initial build. Subsequent builds reuse the renamings stored in the cache and add additional renamings for any newly-added properties. This has a few consequences:\n\n- You can customize what mangled properties are renamed to by editing the cache before passing it to esbuild.\n\n- The cache serves as a list of all properties that were mangled. You can easily scan it to see if there are any unexpected property renamings.\n\n- You can disable mangling for individual properties by setting the renamed value to `false` instead of to a string. This is similar to the [reserve props](#reserve-props) setting but on a per-property basis.\n\n- You can ensure consistent renaming between builds (e.g. a main-thread file and a web worker, or a library and a plugin). Without this feature, each build would do an independent renaming operation and the mangled property names likely wouldn't be consistent.\n\nFor example, consider the following input file:\n\n``` javascript\nconsole.log({\n  someProp_: 1,\n  customRenaming_: 2,\n  disabledRenaming_: 3\n});\n```\n\nIf we want `customRenaming_` to be renamed to `cR_` and we don't want `disabledRenaming_` to be renamed at all, we can pass the following mangle cache JSON to esbuild:\n\n``` javascript\n{\n  \"customRenaming_\": \"cR_\",\n  \"disabledRenaming_\": false\n}\n```\n\nThe mangle cache JSON can be passed to esbuild like this:\n\n``` sh\nesbuild app.js --mangle-props=_$ --mangle-cache=cache.json\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet result = await esbuild.build({\n  entryPoints: ['app.js'],\n  mangleProps: /_$/,\n  mangleCache: {\n    customRenaming_: \"cR_\",\n    disabledRenaming_: false\n  },\n})\n\nconsole.log('updated mangle cache:', result.mangleCache)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    MangleProps: \"_$\",\n    MangleCache: map[string]interface{}{\n      \"customRenaming_\":   \"cR_\",\n      \"disabledRenaming_\": false,\n    },\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n\n  fmt.Println(\"updated mangle cache:\", result.MangleCache)\n}\n```\n\nWhen property naming is enabled, that will result in the following output file:\n\n``` javascript\nconsole.log({\n  a: 1,\n  cR_: 2,\n  disabledRenaming_: 3\n});\n```\n\nAnd the following updated mangle cache:\n\n``` javascript\n{\n  \"customRenaming_\": \"cR_\",\n  \"disabledRenaming_\": false,\n  \"someProp_\": \"a\"\n}\n```\n\n### Minify\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nWhen enabled, the generated code will be minified instead of pretty-printed. Minified code is generally equivalent to non-minified code but is smaller, which means it downloads faster but is harder to debug. Usually you minify code in production but not in development.\n\nEnabling minification in esbuild looks like this:\n\n``` sh\necho 'fn = obj => { return obj.x }' | esbuild --minify\nfn=n=>n.x;\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'var js = 'fn = obj => { return obj.x }'\n(await esbuild.transform(js, {\n  minify: true,\n})).code\n'fn=n=>n.x;\\n'\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"fn = obj => { return obj.x }\"\n\n  result := api.Transform(js, api.TransformOptions{\n    MinifyWhitespace:  true,\n    MinifyIdentifiers: true,\n    MinifySyntax:      true,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\nThis option does three separate things in combination: it removes whitespace, it rewrites your syntax to be more compact, and it renames local variables to be shorter. Usually you want to do all of these things, but these options can also be enabled individually if necessary:\n\n``` sh\necho 'fn = obj => { return obj.x }' | esbuild --minify-whitespace\nfn=obj=>{return obj.x};\necho 'fn = obj => { return obj.x }' | esbuild --minify-identifiers\nfn = (n) => {\n  return n.x;\n};\necho 'fn = obj => { return obj.x }' | esbuild --minify-syntax\nfn = (obj) => obj.x;\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'var js = 'fn = obj => { return obj.x }'\n(await esbuild.transform(js, {\n  minifyWhitespace: true,\n})).code\n'fn=obj=>{return obj.x};\\n'\n(await esbuild.transform(js, {\n  minifyIdentifiers: true,\n})).code\n'fn = (n) => {\\n  return n.x;\\n};\\n'\n(await esbuild.transform(js, {\n  minifySyntax: true,\n})).code\n'fn = (obj) => obj.x;\\n'\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  css := \"div { color: yellow }\"\n\n  result1 := api.Transform(css, api.TransformOptions{\n    Loader:           api.LoaderCSS,\n    MinifyWhitespace: true,\n  })\n\n  if len(result1.Errors) == 0 {\n    fmt.Printf(\"%s\", result1.Code)\n  }\n\n  result2 := api.Transform(css, api.TransformOptions{\n    Loader:            api.LoaderCSS,\n    MinifyIdentifiers: true,\n  })\n\n  if len(result2.Errors) == 0 {\n    fmt.Printf(\"%s\", result2.Code)\n  }\n\n  result3 := api.Transform(css, api.TransformOptions{\n    Loader:       api.LoaderCSS,\n    MinifySyntax: true,\n  })\n\n  if len(result3.Errors) == 0 {\n    fmt.Printf(\"%s\", result3.Code)\n  }\n}\n```\n\nThese same concepts also apply to CSS, not just to JavaScript:\n\n``` sh\necho 'div { color: yellow }' | esbuild --loader=css --minify\ndiv{color:#ff0}\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'var css = 'div { color: yellow }'\n(await esbuild.transform(css, {\n  loader: 'css',\n  minify: true,\n})).code\n'div{color:#ff0}\\n'\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  css := \"div { color: yellow }\"\n\n  result := api.Transform(css, api.TransformOptions{\n    Loader:            api.LoaderCSS,\n    MinifyWhitespace:  true,\n    MinifyIdentifiers: true,\n    MinifySyntax:      true,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\nThe JavaScript minification algorithm in esbuild usually generates output that is very close to the minified output size of industry-standard JavaScript minification tools. [This benchmark](https://github.com/privatenumber/minification-benchmarks#readme) has an example comparison of output sizes between different minifiers. While esbuild is not the optimal JavaScript minifier in all cases (and doesn't try to be), it strives to generate minified output within a few percent of the size of dedicated minification tools for most code, and of course to do so much faster than other tools.\n\n#### Considerations\n\nHere are some things to keep in mind when using esbuild as a minifier:\n\n- You should probably also set the [target](#target) option when minification is enabled. By default esbuild takes advantage of modern JavaScript features to make your code smaller. For example, `a === undefined || a === null ? 1 : a` could be minified to `a ?? 1`. If you do not want esbuild to take advantage of modern JavaScript features when minifying, you should use an older language target such as `--target=es6`.\n\n- The character escape sequence `\\n` will be replaced with a newline character in JavaScript template literals. String literals will also be converted into template literals if the [target](#target) supports them and if doing so would result in smaller output. **This is not a bug.** Minification means you are asking for smaller output, and the escape sequence `\\n` takes two bytes while the newline character takes one byte. You can read more about this in the [FAQ entry on this topic](../faq/index#minified-newlines).\n\n- By default esbuild won't minify the names of top-level declarations. This is because esbuild doesn't know what you will be doing with the output. You might be injecting the minified code into the middle of some other code, in which case minifying top-level declaration names would be unsafe. Setting an output [format](#format) (or enabling [bundling](#bundle), which picks an output format for you if you haven't set one) tells esbuild that the output will be run within its own scope, which means it's then safe to minify top-level declaration names.\n\n- Minification is not safe for 100% of all JavaScript code. This is true for esbuild as well as for other popular JavaScript minifiers such as [terser](https://github.com/terser/terser). In particular, esbuild is not designed to preserve the value of calling `.toString()` on a function. The reason for this is because if all code inside all functions had to be preserved verbatim, minification would hardly do anything at all and would be virtually useless. However, this means that JavaScript code relying on the return value of `.toString()` will likely break when minified. For example, some patterns in the [AngularJS](https://angularjs.org/) framework break when code is minified because AngularJS uses `.toString()` to read the argument names of functions. A workaround is to use [explicit annotations instead](https://docs.angularjs.org/api/auto/service/$injector#injection-function-annotation).\n\n- By default esbuild does not preserve the value of `.name` on function and class objects. This is because most code doesn't rely on this property and using shorter names is an important size optimization. However, some code does rely on the `.name` property for registration and binding purposes. If you need to rely on this you should enable the [keep names](#keep-names) option.\n\n- The minifier assumes that built-in JavaScript features behave the way they are expected to behave. These assumptions help esbuild generate more compact code. If you want a JavaScript minifier that doesn't make any assumptions about the behavior of built-in JavaScript features, then esbuild may not be the right JavaScript minifier for you. Here are some examples of these kinds of assumptions (note that this is not an exhaustive list):\n\n  - It's expected that `Array.prototype.join` behaves [as specified](https://tc39.es/ecma262/#sec-array.prototype.join). This means it's safe for esbuild's minifier to transform `x = [1, 2, 3] + ''` into `x=\"1,2,3\";`.\n\n  - Accessing the `log` property on the `console` global is expected to not have any side effects. This means it's safe for esbuild's minifier to transform `var a, b = a ? console.log(x) : console.log(y);` into `var a,b=console.log(a?x:y);` (i.e. esbuild is assuming evaluating `console.log` can't change the value of `a`).\n\n- Use of certain JavaScript features can disable many of esbuild's optimizations including minification. Specifically, using direct `eval` and/or the `with` statement prevent esbuild from renaming identifiers to smaller names since these features cause identifier binding to happen at run time instead of compile time. This is almost always unintentional, and only happens because people are unaware of what direct `eval` is and why it's bad.\n\n  If you are thinking about writing some code like this:\n\n  ``` javascript\n  // Direct eval (will disable minification for the whole file)\n  let result = eval(something)\n  ```\n\n  You should probably write your code like this instead so your code can be minified:\n\n  ``` javascript\n  // Indirect eval (has no effect on the surrounding code)\n  let result = (0, eval)(something)\n  ```\n\n  There is more information about the consequences of direct `eval` and the available alternatives [here](../content-types/index#direct-eval).\n\n- The minification algorithm in esbuild does not yet do advanced code optimizations. In particular, the following code optimizations are possible for JavaScript code but are not done by esbuild (not an exhaustive list):\n\n  - Dead-code elimination within function bodies\n  - Function inlining\n  - Cross-statement constant propagation\n  - Object shape modeling\n  - Allocation sinking\n  - Method devirtualization\n  - Symbolic execution\n  - JSX expression hoisting\n  - TypeScript enum detection and inlining\n\n  If your code makes use of patterns that require some of these forms of code optimization to be compact, or if you are searching for the optimal JavaScript minification algorithm for your use case, you should consider using other tools. Some examples of tools that implement some of these advanced code optimizations include [Terser](https://github.com/terser/terser#readme) and [Google Closure Compiler](https://github.com/google/closure-compiler#readme).\n\n### Pure\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThere is a convention used by various JavaScript tools where a special comment containing either `/* @__PURE__ */` or `/* #__PURE__ */` before a new or call expression means that that expression can be removed if the resulting value is unused. It looks like this:\n\n``` javascript\nlet button = /* @__PURE__ */ React.createElement(Button, null);\n```\n\nThis information is used by bundlers such as esbuild during tree shaking (a.k.a. dead code removal) to perform fine-grained removal of unused imports across module boundaries in situations where the bundler is not able to prove by itself that the removal is safe due to the dynamic nature of JavaScript code.\n\nNote that while the comment says \"pure\", it confusingly does *not* indicate that the function being called is pure. For example, it does not indicate that it is ok to cache repeated calls to that function. The name is essentially just an abstract shorthand for \"ok to be removed if unused\".\n\nSome expressions such as JSX and certain built-in globals are automatically annotated as `/* @__PURE__ */` in esbuild. You can also configure additional globals to be marked `/* @__PURE__ */` as well. For example, you can mark the global `document.createElement` function as such to have it be automatically removed from your bundle when the bundle is minified as long as the result isn't used.\n\nIt's worth mentioning that the effect of the annotation only extends to the call itself, not to the arguments. Arguments with side effects are still kept even when minification is enabled:\n\n``` sh\necho 'document.createElement(elemName())' | esbuild --pure:document.createElement\n/* @__PURE__ */ document.createElement(elemName());\necho 'document.createElement(elemName())' | esbuild --pure:document.createElement --minify\nelemName();\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'let js = 'document.createElement(elemName())'\n(await esbuild.transform(js, {\n  pure: ['document.createElement'],\n})).code\n'/* @__PURE__ */ document.createElement(elemName());\\n'\n(await esbuild.transform(js, {\n  pure: ['document.createElement'],\n  minify: true,\n})).code\n'elemName();\\n'\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"document.createElement(elemName())\"\n\n  result1 := api.Transform(js, api.TransformOptions{\n    Pure: []string{\"document.createElement\"},\n  })\n\n  if len(result1.Errors) == 0 {\n    fmt.Printf(\"%s\", result1.Code)\n  }\n\n  result2 := api.Transform(js, api.TransformOptions{\n    Pure:         []string{\"document.createElement\"},\n    MinifySyntax: true,\n  })\n\n  if len(result2.Errors) == 0 {\n    fmt.Printf(\"%s\", result2.Code)\n  }\n}\n```\n\nNote that if you are trying to remove all calls to `console` API methods such as `console.log` and also want to remove the evaluation of arguments with side effects, there is a special case available for this: you can use the [drop feature](#drop) instead of marking `console` API calls as pure. However, this mechanism is specific to the `console` API and doesn't work with other call expressions.\n\n### Tree shaking\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nTree shaking is the term the JavaScript community uses for dead code elimination, a common compiler optimization that automatically removes unreachable code. Within esbuild, this term specifically refers to declaration-level dead code removal.\n\nTree shaking is easiest to explain with an example. Consider the following file. There is one used function and one unused function:\n\n``` javascript\n// input.js\nfunction one() {\n  console.log('one')\n}\nfunction two() {\n  console.log('two')\n}\none()\n```\n\nIf you bundle this file with `esbuild --bundle input.js --outfile=output.js`, the unused function will automatically be discarded leaving you with the following output:\n\n``` javascript\n// input.js\nfunction one() {\n  console.log(\"one\");\n}\none();\n```\n\nThis even works if we split our functions off into a separate library file and import them using an `import` statement:\n\n``` javascript\n// lib.js\nexport function one() {\n  console.log('one')\n}\nexport function two() {\n  console.log('two')\n}\n```\n\n``` javascript\n// input.js\nimport * as lib from './lib.js'\nlib.one()\n```\n\nIf you bundle this file with `esbuild --bundle input.js --outfile=output.js`, the unused function and unused import will still be automatically discarded leaving you with the following output:\n\n``` javascript\n// lib.js\nfunction one() {\n  console.log(\"one\");\n}\n\n// input.js\none();\n```\n\nThis way esbuild will only bundle the parts of your packages that you actually use, which can sometimes be a substantial size savings. Note that esbuild's tree shaking implementation relies on the use of ECMAScript module `import` and `export` statements. It does not work with CommonJS modules. Many packages on npm include both formats and esbuild tries to pick the format that works with tree shaking by default. You can customize which format esbuild picks using the [main fields](#main-fields) and/or [conditions](#conditions) options depending on the package.\n\nBy default, tree shaking is only enabled either when [bundling](#bundle) is enabled or when the output [format](#format) is set to `iife`, otherwise tree shaking is disabled. You can force-enable tree shaking by setting it to `true`:\n\n``` sh\nesbuild app.js --tree-shaking=true\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  treeShaking: true,\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    TreeShaking: api.TreeShakingTrue,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nYou can also force-disable tree shaking by setting it to `false`:\n\n``` sh\nesbuild app.js --tree-shaking=false\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  treeShaking: false,\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    TreeShaking: api.TreeShakingFalse,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n#### Tree shaking and side effects\n\nThe side effect detection used for tree shaking is conservative, meaning that esbuild only considers code removable as dead code if it can be sure that there are no hidden side effects. For example, primitive literals such as `12.34` and `\"abcd\"` are side-effect free and can be removed while expressions such as `\"ab\" + cd` and `foo.bar` are not side-effect free (joining strings invokes `toString()` which can have side effects, and member access can invoke a getter which can also have side effects). Even referencing a global identifier is considered to be a side effect because it will throw a `ReferenceError` if there is no global with that name. Here's an example:\n\n``` javascript\n// These are considered side-effect free\nlet a = 12.34;\nlet b = \"abcd\";\nlet c = { a: a };\n\n// These are not considered side-effect free\n// since they could cause some code to run\nlet x = \"ab\" + cd;\nlet y = foo.bar;\nlet z = { [x]: x };\n```\n\nSometimes it's desirable to allow some code to be tree shaken even if that code can't be automatically determined to have no side effects. This can be done with a [pure annotation comment](#pure) which tells esbuild to trust the author of the code that there are no side effects within the annotated code. The annotation comment is `/* @__PURE__ */` and can only precede a new or call expression. You can annotate an immediately-invoked function expression and put arbitrary side effects inside the function body:\n\n``` javascript\n// This is considered side-effect free due to\n// the annotation, and will be removed if unused\nlet gammaTable = /* @__PURE__ */ (() => {\n  // Side-effect detection is skipped in here\n  let table = new Uint8Array(256);\n  for (let i = 0; i < 256; i++)\n    table[i] = Math.pow(i / 255, 2.2) * 255;\n  return table;\n})();\n```\n\nWhile the fact that `/* @__PURE__ */` only works on call expressions can sometimes make code more verbose, a big benefit of this syntax is that it's portable across many other tools in the JavaScript ecosystem including the popular [UglifyJS](https://github.com/mishoo/uglifyjs) and [Terser](https://github.com/terser/terser) JavaScript minifiers (which are used by other major tools including [Webpack](https://github.com/webpack/webpack) and [Parcel](https://github.com/parcel-bundler/parcel)).\n\nNote that the annotations cause esbuild to assume that the annotated code is side-effect free. If the annotations are wrong and the code actually does have important side effects, these annotations can result in broken code. If you are bundling third-party code with annotations that have been authored incorrectly, you may need to enable [ignoring annotations](#ignore-annotations) to make sure the bundled code is correct.\n\n## Source maps\n\n### Source root\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis feature is only relevant when [source maps](#sourcemap) are enabled. It lets you set the value of the `sourceRoot` field in the source map, which specifies the path that all other paths in the source map are relative to. If this field is not present, all paths in the source map are interpreted as being relative to the directory containing the source map instead.\n\nYou can configure `sourceRoot` like this:\n\n``` sh\nesbuild app.js --sourcemap --source-root=https://raw.githubusercontent.com/some/repo/v1.2.3/\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  sourcemap: true,\n  sourceRoot: 'https://raw.githubusercontent.com/some/repo/v1.2.3/',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Sourcemap:   api.SourceMapInline,\n    SourceRoot:  \"https://raw.githubusercontent.com/some/repo/v1.2.3/\",\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n### Sourcefile\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis option sets the file name when using an input which has no file name. This happens when using the transform API and when using the build API with stdin. The configured file name is reflected in error messages and in source maps. If it's not configured, the file name defaults to `<stdin>`. It can be configured like this:\n\n``` sh\ncat app.js | esbuild --sourcefile=example.js --sourcemap\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\nimport fs from 'node:fs'\n\nlet js = fs.readFileSync('app.js', 'utf8')\nlet result = await esbuild.transform(js, {\n  sourcefile: 'example.js',\n  sourcemap: 'inline',\n})\n\nconsole.log(result.code)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"io/ioutil\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js, err := ioutil.ReadFile(\"app.js\")\n  if err != nil {\n    panic(err)\n  }\n\n  result := api.Transform(string(js),\n    api.TransformOptions{\n      Sourcefile: \"example.js\",\n      Sourcemap:  api.SourceMapInline,\n    })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s %s\", result.Code)\n  }\n}\n```\n\n### Sourcemap\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nSource maps can make it easier to debug your code. They encode the information necessary to translate from a line/column offset in a generated output file back to a line/column offset in the corresponding original input file. This is useful if your generated code is sufficiently different from your original code (e.g. your original code is TypeScript or you enabled [minification](#minify)). This is also useful if you prefer looking at individual files in your browser's developer tools instead of one big bundled file.\n\nNote that source map output is supported for both JavaScript and CSS, and the same options apply to both. Everything below that talks about `.js` files also applies similarly to `.css` files.\n\nThere are four different modes for source map generation:\n\n1.  `linked`\n\n    This mode means the source map is generated into a separate `.js.map` output file alongside the `.js` output file, and the `.js` output file contains a special `//# sourceMappingURL=` comment that points to the `.js.map` output file. That way the browser knows where to find the source map for a given file when you open the debugger. Use `linked` source map mode like this:\n\n``` sh\nesbuild app.ts --sourcemap --outfile=out.js\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.ts'],\n  sourcemap: true,\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.ts\"},\n    Sourcemap:   api.SourceMapLinked,\n    Outfile:     \"out.js\",\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n2.  `external`\n\n    This mode means the source map is generated into a separate `.js.map` output file alongside the `.js` output file, but unlike `linked` mode the `.js` output file does not contain a `//# sourceMappingURL=` comment. Use `external` source map mode like this:\n\n``` sh\nesbuild app.ts --sourcemap=external --outfile=out.js\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.ts'],\n  sourcemap: 'external',\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.ts\"},\n    Sourcemap:   api.SourceMapExternal,\n    Outfile:     \"out.js\",\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n3.  `inline`\n\n    This mode means the source map is appended to the end of the `.js` output file as a base64 payload inside a `//# sourceMappingURL=` comment. No additional `.js.map` output file is generated. Keep in mind that source maps are usually very big because they contain all of your original source code, so you usually do not want to ship code containing `inline` source maps. To remove the source code from the source map (keeping only the file names and the line/column mappings), use the [sources content](#sources-content) option. Use `inline` source map mode like this:\n\n``` sh\nesbuild app.ts --sourcemap=inline --outfile=out.js\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.ts'],\n  sourcemap: 'inline',\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.ts\"},\n    Sourcemap:   api.SourceMapInline,\n    Outfile:     \"out.js\",\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n4.  `both`\n\n    This mode is a combination of `inline` and `external`. The source map is appended inline to the end of the `.js` output file, and another copy of the same source map is written to a separate `.js.map` output file alongside the `.js` output file. Use `both` source map mode like this:\n\n``` sh\nesbuild app.ts --sourcemap=both --outfile=out.js\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.ts'],\n  sourcemap: 'both',\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.ts\"},\n    Sourcemap:   api.SourceMapInlineAndExternal,\n    Outfile:     \"out.js\",\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThe [build](#build) API supports all four source map modes listed above, but the [transform](#transform) API does not support the `linked` mode. This is because the output returned from the transform API does not have an associated filename. If you want the output of the transform API to have a source map comment, you can append one yourself. In addition, the CLI form of the transform API only supports the `inline` mode because the output is written to stdout so generating multiple output files is not possible.\n\nIf you want to \"peek under the hood\" to see what a source map does (or to debug problems with your source map), you can upload the relevant output file and the associated source map here: [Source Map Visualization](https://evanw.github.io/source-map-visualization/).\n\n#### Using source maps\n\nIn the browser, source maps should be automatically picked up by the browser's developer tools as long as the source map setting is enabled. Note that the browser only uses the source maps to alter the display of stack traces when they are logged to the console. The stack traces themselves are not modified so inspecting `error.stack` in your code will still give the unmapped stack trace containing compiled code. Here's how to enable this setting in your browser's developer tools:\n\n- Chrome: ⚙ → Enable JavaScript source maps\n- Safari: ⚙ → Sources → Enable source maps\n- Firefox: ··· → Enable Source Maps\n\nIn node, source maps are supported natively starting with [version v12.12.0](https://nodejs.org/en/blog/release/v12.12.0/). This feature is disabled by default but can be enabled with a flag. Unlike in the browser, the actual stack traces are also modified in node so inspecting `error.stack` in your code will give the mapped stack trace containing your original source code. Here's how to enable this setting in node (the `--enable-source-maps` flag must come before the script file name):\n\n``` javascript\nnode --enable-source-maps app.js\n```\n\n### Sources content\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\n[Source maps](#sourcemap) are generated using [version 3](https://sourcemaps.info/spec.html) of the source map format, which is by far the most widely-supported variant. Each source map will look something like this:\n\n``` javascript\n{\n  \"version\": 3,\n  \"sources\": [\"bar.js\", \"foo.js\"],\n  \"sourcesContent\": [\"bar()\", \"foo()\\nimport './bar'\"],\n  \"mappings\": \";AAAA;;;ACAA;\",\n  \"names\": []\n}\n```\n\nThe `sourcesContent` field is an optional field that contains all of the original source code. This is helpful for debugging because it means the original source code will be available in the debugger.\n\nHowever, it's not needed in some scenarios. For example, if you are just using source maps in production to generate stack traces that contain the original file name, you don't need the original source code because there is no debugger involved. In that case it can be desirable to omit the `sourcesContent` field to make the source map smaller:\n\n``` sh\nesbuild --bundle app.js --sourcemap --sources-content=false\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  bundle: true,\n  entryPoints: ['app.js'],\n  sourcemap: true,\n  sourcesContent: false,\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    Bundle:         true,\n    EntryPoints:    []string{\"app.js\"},\n    Sourcemap:      api.SourceMapInline,\n    SourcesContent: api.SourcesContentExclude,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n## Build metadata\n\n### Analyze\n\n*Supported by: [Build](#build)*\n\nIf you're looking for an interactive visualization, try esbuild's [Bundle Size Analyzer](../analyze/index) instead. You can upload your esbuild [metafile](#metafile) to see a bundle size breakdown.\n\nUsing the analyze feature generates an easy-to-read report about the contents of your bundle:\n\n``` sh\nesbuild --bundle example.jsx --outfile=out.js --minify --analyze\n\n  out.js                                                                    27.6kb  100.0%\n   ├ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js  19.2kb   69.8%\n   ├ node_modules/react/cjs/react.production.min.js                          5.9kb   21.4%\n   ├ node_modules/object-assign/index.js                                     962b     3.4%\n   ├ example.jsx                                                             137b     0.5%\n   ├ node_modules/react-dom/server.browser.js                                 50b     0.2%\n   └ node_modules/react/index.js                                              50b     0.2%\n\n...\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet result = await esbuild.build({\n  entryPoints: ['example.jsx'],\n  outfile: 'out.js',\n  minify: true,\n  metafile: true,\n})\n\nconsole.log(await esbuild.analyzeMetafile(result.metafile))\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"fmt\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:       []string{\"example.jsx\"},\n    Outfile:           \"out.js\",\n    MinifyWhitespace:  true,\n    MinifyIdentifiers: true,\n    MinifySyntax:      true,\n    Metafile:          true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n\n  fmt.Printf(\"%s\", api.AnalyzeMetafile(result.Metafile, api.AnalyzeMetafileOptions{}))\n}\n```\n\nThe information shows which input files ended up in each output file as well as the percentage of the output file they ended up taking up. If you would like additional information, you can enable the \"verbose\" mode. This currently shows the import path from the entry point to each input file which tells you why a given input file is being included in the bundle:\n\n``` sh\nesbuild --bundle example.jsx --outfile=out.js --minify --analyze=verbose\n\n  out.js ─────────────────────────────────────────────────────────────────── 27.6kb ─ 100.0%\n   ├ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js ─ 19.2kb ── 69.8%\n   │  └ node_modules/react-dom/server.browser.js\n   │     └ example.jsx\n   ├ node_modules/react/cjs/react.production.min.js ───────────────────────── 5.9kb ── 21.4%\n   │  └ node_modules/react/index.js\n   │     └ example.jsx\n   ├ node_modules/object-assign/index.js ──────────────────────────────────── 962b ──── 3.4%\n   │  └ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js\n   │     └ node_modules/react-dom/server.browser.js\n   │        └ example.jsx\n   ├ example.jsx ──────────────────────────────────────────────────────────── 137b ──── 0.5%\n   ├ node_modules/react-dom/server.browser.js ──────────────────────────────── 50b ──── 0.2%\n   │  └ example.jsx\n   └ node_modules/react/index.js ───────────────────────────────────────────── 50b ──── 0.2%\n      └ example.jsx\n\n...\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet result = await esbuild.build({\n  entryPoints: ['example.jsx'],\n  outfile: 'out.js',\n  minify: true,\n  metafile: true,\n})\n\nconsole.log(await esbuild.analyzeMetafile(result.metafile, {\n  verbose: true,\n}))\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"fmt\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:       []string{\"example.jsx\"},\n    Outfile:           \"out.js\",\n    MinifyWhitespace:  true,\n    MinifyIdentifiers: true,\n    MinifySyntax:      true,\n    Metafile:          true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n\n  fmt.Printf(\"%s\", api.AnalyzeMetafile(result.Metafile, api.AnalyzeMetafileOptions{\n    Verbose: true,\n  }))\n}\n```\n\nThis analysis is just a visualization of the information that can be found in the [metafile](#metafile). If this analysis doesn't exactly suit your needs, you are welcome to build your own visualization using the information in the metafile.\n\nNote that this formatted analysis summary is intended for humans, not machines. The specific formatting may change over time which will likely break any tools that try to parse it. You should not write a tool to parse this data. You should be using the information in the [JSON metadata file](#metafile) instead. Everything in this visualization is derived from the JSON metadata so you are not losing out on any information by not parsing esbuild's formatted analysis summary.\n\n### Metafile\n\n*Supported by: [Build](#build)*\n\nThis option tells esbuild to produce some metadata about the build in JSON format. The following example puts the metadata in a file called `meta.json`:\n\n``` sh\nesbuild app.js --bundle --metafile=meta.json --outfile=out.js\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\nimport fs from 'node:fs'\n\nlet result = await esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  metafile: true,\n  outfile: 'out.js',\n})\n\nfs.writeFileSync('meta.json', JSON.stringify(result.metafile))\n```\n\n``` go\npackage main\n\nimport \"io/ioutil\"\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Metafile:    true,\n    Outfile:     \"out.js\",\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n\n  ioutil.WriteFile(\"meta.json\", []byte(result.Metafile), 0644)\n}\n```\n\nThis data can then be analyzed by other tools. For an interactive visualization, you can use esbuild's own [Bundle Size Analyzer](../analyze/index). For a quick textual analysis, you can use esbuild's build-in [analyze](#analyze) feature. Or you can write your own analysis which uses this information.\n\nThe metadata JSON format looks like this (described using a TypeScript interface):\n\n``` javascript\ninterface Metafile {\n  inputs: {\n    [path: string]: {\n      bytes: number\n      imports: {\n        path: string\n        kind: string\n        external?: boolean\n        original?: string\n        with?: Record<string, string>\n      }[]\n      format?: string\n      with?: Record<string, string>\n    }\n  }\n  outputs: {\n    [path: string]: {\n      bytes: number\n      inputs: {\n        [path: string]: {\n          bytesInOutput: number\n        }\n      }\n      imports: {\n        path: string\n        kind: string\n        external?: boolean\n      }[]\n      exports: string[]\n      entryPoint?: string\n      cssBundle?: string\n    }\n  }\n}\n```\n\n## Logging\n\n### Color\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis option enables or disables colors in the error and warning messages that esbuild writes to stderr file descriptor in the terminal. By default, color is automatically enabled if stderr is a TTY session and automatically disabled otherwise. Colored output in esbuild looks like this:\n\n``` javascript\n▲ [WARNING] The \"typeof\" operator will never evaluate to \"null\" [impossible-typeof]\n\n    example.js:2:16:\n      2 │ log(typeof x == \"null\")\n        ╵                 ~~~~~~\n\n  The expression \"typeof x\" actually evaluates to \"object\" in JavaScript, not \"null\". You need to\n  use \"x === null\" to test for null.\n\n✘ [ERROR] Could not resolve \"logger\"\n\n    example.js:1:16:\n      1 │ import log from \"logger\"\n        ╵                 ~~~~~~~~\n\n  You can mark the path \"logger\" as external to exclude it from the bundle, which will remove this\n  error and leave the unresolved path in the bundle.\n```\n\nColored output can be force-enabled by setting color to `true`. This is useful if you are piping esbuild's stderr output into a TTY yourself:\n\n``` sh\necho 'typeof x == \"null\"' | esbuild --color=true 2> stderr.txt\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet js = 'typeof x == \"null\"'\nawait esbuild.transform(js, {\n  color: true,\n})\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"typeof x == 'null'\"\n\n  result := api.Transform(js, api.TransformOptions{\n    Color: api.ColorAlways,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\nColored output can also be set to `false` to disable colors.\n\n### Format messages\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis API call can be used to format the log errors and warnings returned by the [build](#build) API and [transform](#transform) APIs as a string using the same formatting that esbuild itself uses. This is useful if you want to customize the way esbuild's logging works, such as processing the log messages before they are printed or printing them to somewhere other than to the console. Here's an example:\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet formatted = await esbuild.formatMessages([\n  {\n    text: 'This is an error',\n    location: {\n      file: 'app.js',\n      line: 10,\n      column: 4,\n      length: 3,\n      lineText: 'let foo = bar',\n    },\n  },\n], {\n  kind: 'error',\n  color: false,\n  terminalWidth: 100,\n})\n\nconsole.log(formatted.join('\\n'))\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"strings\"\n\nfunc main() {\n  formatted := api.FormatMessages([]api.Message{\n    {\n      Text: \"This is an error\",\n      Location: &api.Location{\n        File:     \"app.js\",\n        Line:     10,\n        Column:   4,\n        Length:   3,\n        LineText: \"let foo = bar\",\n      },\n    },\n  }, api.FormatMessagesOptions{\n    Kind:          api.ErrorMessage,\n    Color:         false,\n    TerminalWidth: 100,\n  })\n\n  fmt.Printf(\"%s\", strings.Join(formatted, \"\\n\"))\n}\n```\n\n#### Options\n\nThe following options can be provided to control the formatting:\n\n``` javascript\ninterface FormatMessagesOptions {\n  kind: 'error' | 'warning';\n  color?: boolean;\n  terminalWidth?: number;\n}\n```\n\n``` go\ntype FormatMessagesOptions struct {\n  Kind          MessageKind\n  Color         bool\n  TerminalWidth int\n}\n```\n\n- `kind`\n\n  Controls whether these log messages are printed as errors or warnings.\n\n- `color`\n\n  If this is `true`, Unix-style terminal escape codes are included for colored output.\n\n- `terminalWidth`\n\n  Provide a positive value to wrap long lines so that they don't overflow past the provided column width. Provide `0` to disable word wrapping.\n\n### Log level\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThe log level can be changed to prevent esbuild from printing warning and/or error messages to the terminal. The six log levels are:\n\n- `silent`  \n  Do not show any log output. This is the default log level when using the JS [transform](#transform) API.\n\n- `error`  \n  Only show errors.\n\n- `warning`  \n  Only show warnings and errors. This is the default log level when using the JS [build](#build) API.\n\n- `info`  \n  Show warnings, errors, and an output file summary. This is the default log level when using the CLI.\n\n- `debug`  \n  Log everything from `info` and some additional messages that may help you debug a broken bundle. This log level has a performance impact and some of the messages may be false positives, so this information is not shown by default.\n\n- `verbose`  \n  This generates a torrent of log messages and was added to debug issues with file system drivers. It's not intended for general use.\n\nThe log level can be set like this:\n\n``` sh\necho 'typeof x == \"null\"' | esbuild --log-level=error\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet js = 'typeof x == \"null\"'\nawait esbuild.transform(js, {\n  logLevel: 'error',\n})\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"typeof x == 'null'\"\n\n  result := api.Transform(js, api.TransformOptions{\n    LogLevel: api.LogLevelError,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\n### Log limit\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nBy default, esbuild stops reporting log messages after 10 messages have been reported. This avoids the accidental generation of an overwhelming number of log messages, which can easily lock up slower terminal emulators such as Windows command prompt. It also avoids accidentally using up the whole scroll buffer for terminal emulators with limited scroll buffers.\n\nThe log limit can be changed to another value, and can also be disabled completely by setting it to zero. This will show all log messages:\n\n``` sh\nesbuild app.js --log-limit=0\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  logLimit: 0,\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    LogLimit:    0,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n### Log override\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis feature lets you change the log level of individual types of log messages. You can use it to silence a particular type of warning, to enable additional warnings that aren't enabled by default, or even to turn warnings into errors.\n\nFor example, when targeting older browsers, esbuild automatically transforms regular expression literals which use features that are too new for those browsers into `new RegExp()` calls to allow the generated code to run without being considered a syntax error by the browser. However, these calls will still throw at runtime if you don't add a polyfill for `RegExp` because that regular expression syntax is still unsupported. If you want esbuild to generate a warning when you use newer unsupported regular expression syntax, you can do that like this:\n\n``` sh\nesbuild app.js --log-override:unsupported-regexp=warning --target=chrome50\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  logOverride: {\n    'unsupported-regexp': 'warning',\n  },\n  target: 'chrome50',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    LogOverride: map[string]api.LogLevel{\n      \"unsupported-regexp\": api.LogLevelWarning,\n    },\n    Engines: []api.Engine{\n      {Name: api.EngineChrome, Version: \"50\"},\n    },\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThe log level for each message type can be overridden to any value supported by the [log level](#log-level) setting. All currently-available message types are listed below (click on each one for an example log message):\n\n- **JS:**\n  - `assert-to-with`\n\n    ``` javascript\n    ▲ [WARNING] The \"assert\" keyword is not supported in the configured target environment [assert-to-with]\n\n        example.js:1:31:\n          1 │ import data from \"./data.json\" assert { type: \"json\" }\n            │                                ~~~~~~\n            ╵                                with\n\n      Did you mean to use \"with\" instead of \"assert\"?\n    ```\n\n  - `assert-type-json`\n\n    ``` javascript\n    ▲ [WARNING] Non-default import \"value\" is undefined with a JSON import assertion [assert-type-json]\n\n        example.js:1:78:\n          1 │ import * as data from \"./data.json\" assert { type: \"json\" }; console.log(data.value)\n            ╵                                                                               ~~~~~\n\n      The JSON import assertion is here:\n\n        example.js:1:45:\n          1 │ import * as data from \"./data.json\" assert { type: \"json\" }; console.log(data.value)\n            ╵                                              ~~~~~~~~~~~~\n\n      You can either keep the import assertion and only use the \"default\" import, or you can remove the\n      import assertion and use the \"value\" import.\n    ```\n\n  - `assign-to-constant`\n\n    ``` javascript\n    ▲ [WARNING] This assignment will throw because \"foo\" is a constant [assign-to-constant]\n\n        example.js:1:15:\n          1 │ const foo = 1; foo = 2\n            ╵                ~~~\n\n      The symbol \"foo\" was declared a constant here:\n\n        example.js:1:6:\n          1 │ const foo = 1; foo = 2\n            ╵       ~~~\n    ```\n\n  - `assign-to-define`\n\n    ``` javascript\n    ▲ [WARNING] Suspicious assignment to defined constant \"DEFINE\" [assign-to-define]\n\n        example.js:1:0:\n          1 │ DEFINE = false\n            ╵ ~~~~~~\n\n      The expression \"DEFINE\" has been configured to be replaced with a constant using the \"define\"\n      feature. If this expression is supposed to be a compile-time constant, then it doesn't make sense\n      to assign to it here. Or if this expression is supposed to change at run-time, this \"define\"\n      substitution should be removed.\n    ```\n\n  - `assign-to-import`\n\n    ``` javascript\n    ▲ [WARNING] This assignment will throw because \"foo\" is an import [assign-to-import]\n\n        example.js:1:23:\n          1 │ import foo from \"foo\"; foo = null\n            ╵                        ~~~\n\n      Imports are immutable in JavaScript. To modify the value of this import, you must export a setter\n      function in the imported file (e.g. \"setFoo\") and then import and call that function here instead.\n    ```\n\n  - `call-import-namespace`\n\n    ``` javascript\n    ▲ [WARNING] Calling \"foo\" will crash at run-time because it's an import namespace object, not a function [call-import-namespace]\n\n        example.js:1:28:\n          1 │ import * as foo from \"foo\"; foo()\n            ╵                             ~~~\n\n      Consider changing \"foo\" to a default import instead:\n\n        example.js:1:7:\n          1 │ import * as foo from \"foo\"; foo()\n            │        ~~~~~~~~\n            ╵        foo\n    ```\n\n  - `class-name-will-throw`\n\n    ``` javascript\n    ▲ [WARNING] Accessing class \"Foo\" before initialization will throw [class-name-will-throw]\n\n        example.js:1:40:\n          1 │ class Foo { static key = \"foo\"; static [Foo.key] = 123 }\n            ╵                                         ~~~\n    ```\n\n  - `commonjs-variable-in-esm`\n\n    ``` javascript\n    ▲ [WARNING] The CommonJS \"exports\" variable is treated as a global variable in an ECMAScript module and may not work as expected [commonjs-variable-in-esm]\n\n        example.js:1:0:\n          1 │ exports.foo = 1; export let bar = 2\n            ╵ ~~~~~~~\n\n      This file is considered to be an ECMAScript module because of the \"export\" keyword here:\n\n        example.js:1:17:\n          1 │ exports.foo = 1; export let bar = 2\n            ╵                  ~~~~~~\n    ```\n\n  - `delete-super-property`\n\n    ``` javascript\n    ▲ [WARNING] Attempting to delete a property of \"super\" will throw a ReferenceError [delete-super-property]\n\n        example.js:1:42:\n          1 │ class Foo extends Object { foo() { delete super.foo } }\n            ╵                                           ~~~~~\n    ```\n\n  - `direct-eval`\n\n    ``` javascript\n    ▲ [WARNING] Using direct eval with a bundler is not recommended and may cause problems [direct-eval]\n\n        example.js:1:22:\n          1 │ let apparentlyUnused; eval(\"actuallyUse(apparentlyUnused)\")\n            ╵                       ~~~~\n\n      You can read more about direct eval and bundling here: https://esbuild.github.io/link/direct-eval\n    ```\n\n  - `duplicate-case`\n\n    ``` javascript\n    ▲ [WARNING] This case clause will never be evaluated because it duplicates an earlier case clause [duplicate-case]\n\n        example.js:1:33:\n          1 │ switch (foo) { case 1: return 1; case 1: return 2 }\n            ╵                                  ~~~~\n\n      The earlier case clause is here:\n\n        example.js:1:15:\n          1 │ switch (foo) { case 1: return 1; case 1: return 2 }\n            ╵                ~~~~\n    ```\n\n  - `duplicate-class-member`\n\n    ``` javascript\n    ▲ [WARNING] Duplicate member \"x\" in class body [duplicate-class-member]\n\n        example.js:1:19:\n          1 │ class Foo { x = 1; x = 2 }\n            ╵                    ^\n\n      The original member \"x\" is here:\n\n        example.js:1:12:\n          1 │ class Foo { x = 1; x = 2 }\n            ╵             ^\n    ```\n\n  - `duplicate-object-key`\n\n    ``` javascript\n    ▲ [WARNING] Duplicate key \"bar\" in object literal [duplicate-object-key]\n\n        example.js:1:16:\n          1 │ foo = { bar: 1, bar: 2 }\n            ╵                 ~~~\n\n      The original key \"bar\" is here:\n\n        example.js:1:8:\n          1 │ foo = { bar: 1, bar: 2 }\n            ╵         ~~~\n    ```\n\n  - `empty-import-meta`\n\n    ``` javascript\n    ▲ [WARNING] \"import.meta\" is not available in the configured target environment (\"chrome50\") and will be empty [empty-import-meta]\n\n        example.js:1:6:\n          1 │ foo = import.meta\n            ╵       ~~~~~~~~~~~\n    ```\n\n  - `equals-nan`\n\n    ``` javascript\n    ▲ [WARNING] Comparison with NaN using the \"!==\" operator here is always true [equals-nan]\n\n        example.js:1:24:\n          1 │ foo = foo.filter(x => x !== NaN)\n            ╵                         ~~~\n\n      Floating-point equality is defined such that NaN is never equal to anything, so \"x === NaN\" always\n      returns false. You need to use \"Number.isNaN(x)\" instead to test for NaN.\n    ```\n\n  - `equals-negative-zero`\n\n    ``` javascript\n    ▲ [WARNING] Comparison with -0 using the \"!==\" operator will also match 0 [equals-negative-zero]\n\n        example.js:1:28:\n          1 │ foo = foo.filter(x => x !== -0)\n            ╵                             ~~\n\n      Floating-point equality is defined such that 0 and -0 are equal, so \"x === -0\" returns true for\n      both 0 and -0. You need to use \"Object.is(x, -0)\" instead to test for -0.\n    ```\n\n  - `equals-new-object`\n\n    ``` javascript\n    ▲ [WARNING] Comparison using the \"!==\" operator here is always true [equals-new-object]\n\n        example.js:1:24:\n          1 │ foo = foo.filter(x => x !== [])\n            ╵                         ~~~\n\n      Equality with a new object is always false in JavaScript because the equality operator tests\n      object identity. You need to write code to compare the contents of the object instead. For\n      example, use \"Array.isArray(x) && x.length === 0\" instead of \"x === []\" to test for an empty\n      array.\n    ```\n\n  - `html-comment-in-js`\n\n    ``` javascript\n    ▲ [WARNING] Treating \"<!--\" as the start of a legacy HTML single-line comment [html-comment-in-js]\n\n        example.js:1:0:\n          1 │ <!-- comment -->\n            ╵ ~~~~\n    ```\n\n  - `impossible-typeof`\n\n    ``` javascript\n    ▲ [WARNING] The \"typeof\" operator will never evaluate to \"null\" [impossible-typeof]\n\n        example.js:1:32:\n          1 │ foo = foo.map(x => typeof x !== \"null\")\n            ╵                                 ~~~~~~\n\n      The expression \"typeof x\" actually evaluates to \"object\" in JavaScript, not \"null\". You need to\n      use \"x === null\" to test for null.\n    ```\n\n  - `indirect-require`\n\n    ``` javascript\n    ▲ [WARNING] Indirect calls to \"require\" will not be bundled [indirect-require]\n\n        example.js:1:8:\n          1 │ let r = require, fs = r(\"fs\")\n            ╵         ~~~~~~~\n    ```\n\n  - `private-name-will-throw`\n\n    ``` javascript\n    ▲ [WARNING] Writing to getter-only property \"#foo\" will throw [private-name-will-throw]\n\n        example.js:1:39:\n          1 │ class Foo { get #foo() {} bar() { this.#foo++ } }\n            ╵                                        ~~~~\n    ```\n\n  - `semicolon-after-return`\n\n    ``` javascript\n    ▲ [WARNING] The following expression is not returned because of an automatically-inserted semicolon [semicolon-after-return]\n\n        example.js:1:6:\n          1 │ return\n            ╵       ^\n    ```\n\n  - `suspicious-boolean-not`\n\n    ``` javascript\n    ▲ [WARNING] Suspicious use of the \"!\" operator inside the \"in\" operator [suspicious-boolean-not]\n\n        example.js:1:4:\n          1 │ if (!foo in bar) {\n            │     ~~~~\n            ╵     (!foo)\n\n      The code \"!x in y\" is parsed as \"(!x) in y\". You need to insert parentheses to get \"!(x in y)\"\n      instead.\n    ```\n\n  - `suspicious-define`\n\n    ``` javascript\n    ▲ [WARNING] \"process.env.NODE_ENV\" is defined as an identifier instead of a string (surround \"production\" with quotes to get a string) [suspicious-define]\n\n        <js>:1:34:\n          1 │ define: { 'process.env.NODE_ENV': 'production' }\n            │                                   ~~~~~~~~~~~~\n            ╵                                   '\"production\"'\n    ```\n\n  - `suspicious-logical-operator`\n\n    ``` javascript\n    ▲ [WARNING] The \"&&\" operator here will always return the left operand [suspicious-logical-operator]\n\n        example.js:1:25:\n          1 │ const isInRange = x => 0 && x <= 1\n            ╵                          ~~\n\n      The \"=>\" symbol creates an arrow function expression in JavaScript. Did you mean to use the\n      greater-than-or-equal-to operator \">=\" here instead?\n\n        example.js:1:20:\n          1 │ const isInRange = x => 0 && x <= 1\n            │                     ~~\n            ╵                     >=\n    ```\n\n  - `suspicious-nullish-coalescing`\n\n    ``` javascript\n    ▲ [WARNING] The \"??\" operator here will always return the left operand [suspicious-nullish-coalescing]\n\n        example.js:1:26:\n          1 │ return name === user.name ?? \"\"\n            ╵                           ~~\n\n      The left operand of the \"??\" operator here will never be null or undefined, so it will always be\n      returned. This usually indicates a bug in your code:\n\n        example.js:1:7:\n          1 │ return name === user.name ?? \"\"\n            ╵        ~~~~~~~~~~~~~~~~~~\n    ```\n\n  - `this-is-undefined-in-esm`\n\n    ``` javascript\n    ▲ [WARNING] Top-level \"this\" will be replaced with undefined since this file is an ECMAScript module [this-is-undefined-in-esm]\n\n        example.js:1:0:\n          1 │ this.foo = 1; export let bar = 2\n            │ ~~~~\n            ╵ undefined\n\n      This file is considered to be an ECMAScript module because of the \"export\" keyword here:\n\n        example.js:1:14:\n          1 │ this.foo = 1; export let bar = 2\n            ╵               ~~~~~~\n    ```\n\n  - `unsupported-dynamic-import`\n\n    ``` javascript\n    ▲ [WARNING] This \"import\" expression will not be bundled because the argument is not a string literal [unsupported-dynamic-import]\n\n        example.js:1:0:\n          1 │ import(foo)\n            ╵ ~~~~~~\n    ```\n\n  - `unsupported-jsx-comment`\n\n    ``` javascript\n    ▲ [WARNING] Invalid JSX factory: 123 [unsupported-jsx-comment]\n\n        example.jsx:1:8:\n          1 │ // @jsx 123\n            ╵         ~~~\n    ```\n\n  - `unsupported-regexp`\n\n    ``` javascript\n    ▲ [WARNING] The regular expression flag \"d\" is not available in the configured target environment (\"chrome50\") [unsupported-regexp]\n\n        example.js:1:3:\n          1 │ /./d\n            ╵    ^\n\n      This regular expression literal has been converted to a \"new RegExp()\" constructor to avoid\n      generating code with a syntax error. However, you will need to include a polyfill for \"RegExp\" for\n      your code to have the correct behavior at run-time.\n    ```\n\n  - `unsupported-require-call`\n\n    ``` javascript\n    ▲ [WARNING] This call to \"require\" will not be bundled because the argument is not a string literal [unsupported-require-call]\n\n        example.js:1:0:\n          1 │ require(foo)\n            ╵ ~~~~~~~\n    ```\n\n    \n- **CSS:**\n  - `css-syntax-error`\n\n    ``` javascript\n    ▲ [WARNING] Expected identifier but found \"]\" [css-syntax-error]\n\n        example.css:1:4:\n          1 │ div[] {\n            ╵     ^\n    ```\n\n  - `invalid-@charset`\n\n    ``` javascript\n    ▲ [WARNING] \"@charset\" must be the first rule in the file [invalid-@charset]\n\n        example.css:1:19:\n          1 │ div { color: red } @charset \"UTF-8\";\n            ╵                    ~~~~~~~~\n\n      This rule cannot come before a \"@charset\" rule\n\n        example.css:1:0:\n          1 │ div { color: red } @charset \"UTF-8\";\n            ╵ ^\n    ```\n\n  - `invalid-@import`\n\n    ``` javascript\n    ▲ [WARNING] All \"@import\" rules must come first [invalid-@import]\n\n        example.css:1:19:\n          1 │ div { color: red } @import \"foo.css\";\n            ╵                    ~~~~~~~\n\n      This rule cannot come before an \"@import\" rule\n\n        example.css:1:0:\n          1 │ div { color: red } @import \"foo.css\";\n            ╵ ^\n    ```\n\n  - `invalid-@layer`\n\n    ``` javascript\n    ▲ [WARNING] \"initial\" cannot be used as a layer name [invalid-@layer]\n\n        example.css:1:7:\n          1 │ @layer initial {\n            ╵        ~~~~~~~\n    ```\n\n  - `invalid-calc`\n\n    ``` javascript\n    ▲ [WARNING] \"-\" can only be used as an infix operator, not a prefix operator [invalid-calc]\n\n        example.css:1:20:\n          1 │ div { z-index: calc(-(1+2)); }\n            ╵                     ^\n\n    ▲ [WARNING] The \"+\" operator only works if there is whitespace on both sides [invalid-calc]\n\n        example.css:1:23:\n          1 │ div { z-index: calc(-(1+2)); }\n            ╵                        ^\n    ```\n\n  - `js-comment-in-css`\n\n    ``` javascript\n    ▲ [WARNING] Comments in CSS use \"/* ... */\" instead of \"//\" [js-comment-in-css]\n\n        example.css:1:0:\n          1 │ // comment\n            ╵ ~~\n    ```\n\n  - `undefined-composes-from`\n\n    ``` javascript\n    ▲ [WARNING] The value of \"zoom\" in the \"foo\" class is undefined [undefined-composes-from]\n\n        example.module.css:1:1:\n          1 │ .foo { composes: bar from \"lib.module.css\"; zoom: 1; }\n            ╵  ~~~\n\n      The first definition of \"zoom\" is here:\n\n        lib.module.css:1:7:\n          1 │ .bar { zoom: 2 }\n            ╵        ~~~~\n\n      The second definition of \"zoom\" is here:\n\n        example.module.css:1:44:\n          1 │ .foo { composes: bar from \"lib.module.css\"; zoom: 1; }\n            ╵                                             ~~~~\n\n      The specification of \"composes\" does not define an order when class declarations from separate\n      files are composed together. The value of the \"zoom\" property for \"foo\" may change unpredictably\n      as the code is edited. Make sure that all definitions of \"zoom\" for \"foo\" are in a single file.\n    ```\n\n  - `unsupported-@charset`\n\n    ``` javascript\n    ▲ [WARNING] \"UTF-8\" will be used instead of unsupported charset \"ASCII\" [unsupported-@charset]\n\n        example.css:1:9:\n          1 │ @charset \"ASCII\";\n            ╵          ~~~~~~~\n    ```\n\n  - `unsupported-@namespace`\n\n    ``` javascript\n    ▲ [WARNING] \"@namespace\" rules are not supported [unsupported-@namespace]\n\n        example.css:1:0:\n          1 │ @namespace \"ns\";\n            ╵ ~~~~~~~~~~\n    ```\n\n  - `unsupported-css-property`\n\n    ``` javascript\n    ▲ [WARNING] \"widht\" is not a known CSS property [unsupported-css-property]\n\n        example.css:1:6:\n          1 │ div { widht: 1px }\n            │       ~~~~~\n            ╵       width\n\n      Did you mean \"width\" instead?\n    ```\n\n  - `unsupported-css-nesting`\n\n    ``` javascript\n    ▲ [WARNING] Transforming this CSS nesting syntax is not supported in the configured target environment (\"chrome50\") [unsupported-css-nesting]\n\n        example.css:2:5:\n          2 │ .foo & {\n            ╵      ^\n\n      The nesting transform for this case must generate an \":is(...)\" but the configured target\n      environment does not support the \":is\" pseudo-class.\n    ```\n\n    \n- **Bundler:**\n  - `ambiguous-reexport`\n\n    ``` javascript\n    ▲ [WARNING] Re-export of \"foo\" in \"example.js\" is ambiguous and has been removed [ambiguous-reexport]\n\n      One definition of \"foo\" comes from \"a.js\" here:\n\n        a.js:1:11:\n          1 │ export let foo = 1\n            ╵            ~~~\n\n      Another definition of \"foo\" comes from \"b.js\" here:\n\n        b.js:1:11:\n          1 │ export let foo = 2\n            ╵            ~~~\n    ```\n\n  - `different-path-case`\n\n    ``` javascript\n    ▲ [WARNING] Use \"foo.js\" instead of \"Foo.js\" to avoid issues with case-sensitive file systems [different-path-case]\n\n        example.js:2:7:\n          2 │ import \"./Foo.js\"\n            ╵        ~~~~~~~~~~\n    ```\n\n  - `empty-glob`\n\n    ``` javascript\n    ▲ [WARNING] The glob pattern import(\"./icon-*.json\") did not match any files [empty-glob]\n\n        example.js:2:16:\n          2 │   return import(\"./icon-\" + name + \".json\")\n            ╵                 ~~~~~~~~~~~~~~~~~~~~~~~~~~\n    ```\n\n  - `ignored-bare-import`\n\n    ``` javascript\n    ▲ [WARNING] Ignoring this import because \"node_modules/foo/index.js\" was marked as having no side effects [ignored-bare-import]\n\n        example.js:1:7:\n          1 │ import \"foo\"\n            ╵        ~~~~~\n\n      \"sideEffects\" is false in the enclosing \"package.json\" file:\n\n        node_modules/foo/package.json:2:2:\n          2 │   \"sideEffects\": false\n            ╵   ~~~~~~~~~~~~~\n    ```\n\n  - `ignored-dynamic-import`\n\n    ``` javascript\n    ▲ [WARNING] Importing \"foo\" was allowed even though it could not be resolved because dynamic import failures appear to be handled here: [ignored-dynamic-import]\n\n        example.js:1:7:\n          1 │ import(\"foo\").catch(e => {\n            ╵        ~~~~~\n\n      The handler for dynamic import failures is here:\n\n        example.js:1:14:\n          1 │ import(\"foo\").catch(e => {\n            ╵               ~~~~~\n    ```\n\n  - `import-is-undefined`\n\n    ``` javascript\n    ▲ [WARNING] Import \"foo\" will always be undefined because the file \"foo.js\" has no exports [import-is-undefined]\n\n        example.js:1:9:\n          1 │ import { foo } from \"./foo\"\n            ╵          ~~~\n    ```\n\n  - `require-resolve-not-external`\n\n    ``` javascript\n    ▲ [WARNING] \"foo\" should be marked as external for use with \"require.resolve\" [require-resolve-not-external]\n\n        example.js:1:26:\n          1 │ let foo = require.resolve(\"foo\")\n            ╵                           ~~~~~\n    ```\n\n    \n- **Source maps:**\n  - `invalid-source-mappings`\n\n    ``` javascript\n    ▲ [WARNING] Bad \"mappings\" data in source map at character 3: Invalid original column value: -2 [invalid-source-mappings]\n\n        example.js.map:2:18:\n          2 │   \"mappings\": \"aAAFA,UAAU;;\"\n            ╵                   ^\n\n      The source map \"example.js.map\" was referenced by the file \"example.js\" here:\n\n        example.js:1:21:\n          1 │ //# sourceMappingURL=example.js.map\n            ╵                      ~~~~~~~~~~~~~~\n    ```\n\n  - `sections-in-source-map`\n\n    ``` javascript\n    ▲ [WARNING] Source maps with \"sections\" are not supported [sections-in-source-map]\n\n        example.js.map:2:2:\n          2 │   \"sections\": []\n            ╵   ~~~~~~~~~~\n\n      The source map \"example.js.map\" was referenced by the file \"example.js\" here:\n\n        example.js:1:21:\n          1 │ //# sourceMappingURL=example.js.map\n            ╵                      ~~~~~~~~~~~~~~\n    ```\n\n  - `missing-source-map`\n\n    ``` javascript\n    ▲ [WARNING] Cannot read file \".\": is a directory [missing-source-map]\n\n        example.js:1:21:\n          1 │ //# sourceMappingURL=.\n            ╵                      ^\n    ```\n\n  - `unsupported-source-map-comment`\n\n    ``` javascript\n    ▲ [WARNING] Unsupported source map comment: could not decode percent-escaped data: invalid URL escape \"%\\\"\" [unsupported-source-map-comment]\n\n        example.js:1:21:\n          1 │ //# sourceMappingURL=data:application/json,\"%\"\n            ╵                      ~~~~~~~~~~~~~~~~~~~~~~~~~\n    ```\n\n    \n- **Resolver:**\n  - `package.json`\n\n    ``` javascript\n    ▲ [WARNING] \"esm\" is not a valid value for the \"type\" field [package.json]\n\n        package.json:1:10:\n          1 │ { \"type\": \"esm\" }\n            ╵           ~~~~~\n\n      The \"type\" field must be set to either \"commonjs\" or \"module\".\n    ```\n\n  - `tsconfig.json`\n\n    ``` javascript\n    ▲ [WARNING] Unrecognized target environment \"ES4\" [tsconfig.json]\n\n        tsconfig.json:1:33:\n          1 │ { \"compilerOptions\": { \"target\": \"ES4\" } }\n            ╵                                  ~~~~~\n    ```\n\n    \n\nThese message types should be reasonably stable but new ones may be added and old ones may occasionally be removed in the future. If a message type is removed, any overrides for that message type will just be silently ignored.\n\n© 2020 Evan Wallace  \nLicensed under the MIT License.  \n[https://esbuild.github.io/api/](https://esbuild.github.io/api/)"
- name: Asset names
  id: api/index#asset-names
  summary: This option controls the file names of the additional output files generated when the loader is set to file
  belongs_to: API
  description: |-
    ### Asset names

    *Supported by: [Build](#build)*

    This option controls the file names of the additional output files generated when the [loader](#loader) is set to [`file`](../content-types/index#external-file). It configures the output paths using a template with placeholders that will be substituted with values specific to the file when the output path is generated. For example, specifying an asset name template of `assets/[name]-[hash]` puts all assets into a subdirectory called `assets` inside of the output directory and includes the content hash of the asset in the file name. Doing that looks like this:

    ``` sh
    esbuild app.js --asset-names=assets/[name]-[hash] --loader:.png=file --bundle --outdir=out
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      assetNames: 'assets/[name]-[hash]',
      loader: { '.png': 'file' },
      bundle: true,
      outdir: 'out',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        AssetNames:  "assets/[name]-[hash]",
        Loader: map[string]api.Loader{
          ".png": api.LoaderFile,
        },
        Bundle: true,
        Outdir: "out",
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    There are four placeholders that can be used in asset path templates:

    - `[dir]`

      This is the relative path from the directory containing the asset file to the [outbase](#outbase) directory. Its purpose is to help asset output paths look more aesthetically pleasing by mirroring the input directory structure inside of the output directory.

    - `[name]`

      This is the original file name of the asset without the extension. For example, if the asset was originally named `image.png` then `[name]` will be substituted with `image` in the template. It is not necessary to use this placeholder; it only exists to provide human-friendly asset names to make debugging easier.

    - `[hash]`

      This is the content hash of the asset, which is useful to avoid name collisions. For example, your code may import `components/button/icon.png` and `components/select/icon.png` in which case you'll need the hash to distinguish between the two assets that are both named `icon`.

    - `[ext]`

      This is the file extension of the asset (i.e. everything after the end of the last `.` character). It can be used to put different types of assets into different directories. For example, `--asset-names=assets/[ext]/[name]-[hash]` might write out an asset named `image.png` as `assets/png/image-CQFGD2NG.png`.

    Asset path templates do not need to include a file extension. The original file extension of the asset will be automatically added to the end of the output path after template substitution.

    This option is similar to the [chunk names](#chunk-names) and [entry names](#entry-names) options.
- name: Auto-import for JSX
  id: content-types/index#auto-import-for-jsx
  summary: Using JSX syntax usually requires you to manually import the JSX library you are using
  belongs_to: Content Types
  description: |-
    ### Auto-import for JSX

    Using JSX syntax usually requires you to manually import the JSX library you are using. For example, if you are using React, by default you will need to import React into each JSX file like this:

    ``` javascript
    import * as React from 'react'
    render(<div/>)
    ```

    This is because the JSX transform turns JSX syntax into a call to `React.createElement` but it does not itself import anything, so the `React` variable is not automatically present.

    If you would like to avoid having to manually `import` your JSX library into each file, you may be able to do this by setting esbuild's [JSX](../api/index#jsx) transform to `automatic`, which generates import statements for you. Keep in mind that this also completely changes how the JSX transform works, so it may break your code if you are using a JSX library that's not React. Doing that looks like this:

    ``` sh
    esbuild app.jsx --jsx=automatic
    ```

    ``` javascript
    require('esbuild').buildSync({
      entryPoints: ['app.jsx'],
      jsx: 'automatic',
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.jsx"},
        JSX:         api.JSXAutomatic,
        Outfile:     "out.js",
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Avoiding name collisions
  id: faq/index#top-level-name-collisions
  summary: Top-level variables in an entry point module should never end up in the global scope when running esbuild's output in a browser
  belongs_to: FAQ
  description: |-
    ## Avoiding name collisions

    Top-level variables in an entry point module should never end up in the global scope when running esbuild's output in a browser. If that happens, it means you did not follow [esbuild's documentation about output formats](../api/index#format) and are using esbuild incorrectly. **This is not a bug with esbuild.**

    Specifically, you must do either one of the following when running esbuild's output in a browser:

    1.  `--format=iife` with `<script src="...">`

        If you are running your code in the global scope, then you should be using `--format=iife`. This causes esbuild's output to wrap your code so that top-level variables are declared in a nested scope.

    2.  `--format=esm` with `<script src="..." type="module">`

        If you are using `--format=esm`, then you must run your code as a module. This causes the browser to wrap your code so that top-level variables are declared in a nested scope.

    Using `--format=esm` with `<script src="...">` will break your code in subtle and confusing ways (omitting `type="module"` means that all top-level variables will end up in the global scope, which will then collide with top-level variables that have the same name in other JavaScript files).
- name: Banner
  id: api/index#banner
  summary: Use this to insert an arbitrary string at the beginning of generated JavaScript and CSS files
  belongs_to: API
  description: |-
    ### Banner

    *Supported by: [Build](#build) and [Transform](#transform)*

    Use this to insert an arbitrary string at the beginning of generated JavaScript and CSS files. This is commonly used to insert comments:

    ``` sh
    esbuild app.js --banner:js=//comment --banner:css=/*comment*/
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      banner: {
        js: '//comment',
        css: '/*comment*/',
      },
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Banner: map[string]string{
          "js":  "//comment",
          "css": "/*comment*/",
        },
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    This is similar to [footer](#footer) which inserts at the end instead of the beginning.

    Note that if you are inserting non-comment code into a CSS file, be aware that CSS ignores all `@import` rules that come after a non-`@import` rule (other than a `@charset` rule), so using a banner to inject CSS rules may accidentally disable imports of external stylesheets.
- name: Base64
  id: content-types/index#base64
  summary: This loader will load the file as a binary buffer at build time and embed it into the bundle as a string using Base64 encoding
  belongs_to: Content Types
  description: |-
    ## Base64

    Loader: `base64`

    This loader will load the file as a binary buffer at build time and embed it into the bundle as a string using Base64 encoding. This string is exported using the default export. Using it looks like this:

    ``` javascript
    import base64string from './example.data'
    console.log(base64string)
    ```

    Note that this loader is not enabled by default. You will need to configure it for the appropriate file extension like this:

    ``` sh
    esbuild app.js --bundle --loader:.data=base64
    ```

    ``` javascript
    require('esbuild').buildSync({
      entryPoints: ['app.js'],
      bundle: true,
      loader: { '.data': 'base64' },
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Loader: map[string]api.Loader{
          ".data": api.LoaderBase64,
        },
        Write: true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    If you intend to turn this into a `Uint8Array` or an `ArrayBuffer`, you should use the `binary` loader instead. It uses an optimized Base64-to-binary converter that is faster than the usual `atob` conversion process.
- name: Benchmark details
  id: faq/index#benchmark-details
  summary: This benchmark approximates a large JavaScript codebase by duplicating the three.js library 10 times and building a single bundle from scratch, without any caches
  belongs_to: FAQ
  description: |-
    ## Benchmark details

    Here are the details about each benchmark:

    This benchmark approximates a large JavaScript codebase by duplicating the [three.js](https://github.com/mrdoob/three.js) library 10 times and building a single bundle from scratch, without any caches. The benchmark can be run with `make bench-three` in the [esbuild repo](https://github.com/evanw/esbuild).

    | Bundler           |   Time | Relative slowdown | Absolute speed | Output size |
    |:------------------|-------:|------------------:|---------------:|------------:|
    | esbuild           |  0.39s |                1x |  1403.7 kloc/s |      5.80mb |
    | parcel 2          | 14.91s |               38x |    36.7 kloc/s |      5.78mb |
    | rollup 4 + terser | 34.10s |               87x |    16.1 kloc/s |      5.82mb |
    | webpack 5         | 41.21s |              106x |    13.3 kloc/s |      5.84mb |

    Each time reported is the best of three runs. I'm running esbuild with `--bundle --minify --sourcemap`. I used the [`@rollup/plugin-terser`](https://github.com/rollup/plugins/tree/master/packages/terser) plugin because Rollup itself doesn't support minification. Webpack 5 uses `--mode=production --devtool=sourcemap`. Parcel 2 uses the default options. Absolute speed is based on the total line count including comments and blank lines, which is currently 547,441. The tests were done on a 6-core 2019 MacBook Pro with 16gb of RAM and with [macOS Spotlight](https://en.wikipedia.org/wiki/Spotlight_(software)) disabled.

    This benchmark uses the old [Rome](https://github.com/rome/tools) code base (prior to their Rust rewrite) to approximate a large TypeScript codebase. All code must be combined into a single minified bundle with source maps and the resulting bundle must work correctly. The benchmark can be run with `make bench-rome` in the [esbuild repo](https://github.com/evanw/esbuild).

    | Bundler   |   Time | Relative slowdown | Absolute speed | Output size |
    |:----------|-------:|------------------:|---------------:|------------:|
    | esbuild   |  0.10s |                1x |  1318.4 kloc/s |      0.97mb |
    | parcel 2  |  6.91ѕ |               69x |    16.1 kloc/s |      0.96mb |
    | webpack 5 | 16.69ѕ |              167x |     8.3 kloc/s |      1.27mb |

    Each time reported is the best of three runs. I'm running esbuild with `--bundle --minify --sourcemap --platform=node`. Webpack 5 uses [`ts-loader`](https://github.com/TypeStrong/ts-loader) with `transpileOnly: true` and `--mode=production --devtool=sourcemap`. Parcel 2 uses `"engines": "node"` in `package.json`. Absolute speed is based on the total line count including comments and blank lines, which is currently 131,836. The tests were done on a 6-core 2019 MacBook Pro with 16gb of RAM and with [macOS Spotlight](https://en.wikipedia.org/wiki/Spotlight_(software)) disabled.

    The results don't include Rollup because I couldn't get it to work for reasons relating to TypeScript compilation. I tried [`@rollup/plugin-typescript`](https://github.com/rollup/plugins/tree/master/packages/typescript) but you can't disable type checking, and I tried [`@rollup/plugin-sucrase`](https://github.com/rollup/plugins/tree/master/packages/sucrase) but there's no way to provide a `tsconfig.json` file (which is required for correct path resolution).
- name: Binary
  id: content-types/index#binary
  summary: This loader will load the file as a binary buffer at build time and embed it into the bundle using Base64 encoding
  belongs_to: Content Types
  description: |-
    ## Binary

    Loader: `binary`

    This loader will load the file as a binary buffer at build time and embed it into the bundle using Base64 encoding. The original bytes of the file are decoded from Base64 at run time and exported as a `Uint8Array` using the default export. Using it looks like this:

    ``` javascript
    import uint8array from './example.data'
    console.log(uint8array)
    ```

    If you need an `ArrayBuffer` instead, you can just access `uint8array.buffer`. Note that this loader is not enabled by default. You will need to configure it for the appropriate file extension like this:

    ``` sh
    esbuild app.js --bundle --loader:.data=binary
    ```

    ``` javascript
    require('esbuild').buildSync({
      entryPoints: ['app.js'],
      bundle: true,
      loader: { '.data': 'binary' },
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Loader: map[string]api.Loader{
          ".data": api.LoaderBinary,
        },
        Write: true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Build
  id: api/index#build
  summary: This is the primary interface to esbuild
  belongs_to: API
  description: "### Build\n\nThis is the primary interface to esbuild. You typically pass one or more [entry point](#entry-points) files to process along with various options, and then esbuild writes the results back out to the file system. Here's a simple example that enables [bundling](#bundle) with an [output directory](#outdir):\n\n``` sh\nesbuild app.ts --bundle --outdir=dist\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet result = await esbuild.build({\n  entryPoints: ['app.ts'],\n  bundle: true,\n  outdir: 'dist',\n})\nconsole.log(result)\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.ts\"},\n    Bundle:      true,\n    Outdir:      \"dist\",\n  })\n  if len(result.Errors) != 0 {\n    os.Exit(1)\n  }\n}\n```\n\nAdvanced use of the build API involves setting up a long-running build context. This context is an explicit object in JS and Go but is implicit with the CLI. All builds done with a given context share the same build options, and subsequent builds are done incrementally (i.e. they reuse some work from previous builds to improve performance). This is useful for development because esbuild can rebuild your app in the background for you while you work.\n\nThere are three different incremental build APIs:\n\n- [**Watch mode**](#watch) tells esbuild to watch the file system and automatically rebuild for you whenever you edit and save a file that could invalidate the build. Here's an example:\n\n``` sh\nesbuild app.ts --bundle --outdir=dist --watch\n[watch] build finished, watching for changes...\n```\n\n``` javascript\nlet ctx = await esbuild.context({\n  entryPoints: ['app.ts'],\n  bundle: true,\n  outdir: 'dist',\n})\n\nawait ctx.watch()\n```\n\n``` go\nctx, err := api.Context(api.BuildOptions{\n  EntryPoints: []string{\"app.ts\"},\n  Bundle:      true,\n  Outdir:      \"dist\",\n})\n\nerr2 := ctx.Watch(api.WatchOptions{})\n```\n\n- [**Serve mode**](#serve) starts a local development server that serves the results of the latest build. Incoming requests automatically start new builds so your web app is always up to date when you reload the page in the browser. Here's an example:\n\n``` sh\nesbuild app.ts --bundle --outdir=dist --serve\n\n > Local:   http://127.0.0.1:8000/\n > Network: http://192.168.0.1:8000/\n\n127.0.0.1:61302 - \"GET /\" 200 [1ms]\n```\n\n``` javascript\nlet ctx = await esbuild.context({\n  entryPoints: ['app.ts'],\n  bundle: true,\n  outdir: 'dist',\n})\n\nlet { host, port } = await ctx.serve()\n```\n\n``` go\nctx, err := api.Context(api.BuildOptions{\n  EntryPoints: []string{\"app.ts\"},\n  Bundle:      true,\n  Outdir:      \"dist\",\n})\n\nserver, err2 := ctx.Serve(api.ServeOptions{})\n```\n\n- [**Rebuild mode**](#rebuild) lets you manually invoke a build. This is useful when integrating esbuild with other tools (e.g. using a custom file watcher or development server instead of esbuild's built-in ones). Here's an example:\n\n``` sh\n# The CLI does not have an API for \"rebuild\"\n```\n\n``` javascript\nlet ctx = await esbuild.context({\n  entryPoints: ['app.ts'],\n  bundle: true,\n  outdir: 'dist',\n})\n\nfor (let i = 0; i < 5; i++) {\n  let result = await ctx.rebuild()\n}\n```\n\n``` go\nctx, err := api.Context(api.BuildOptions{\n  EntryPoints: []string{\"app.ts\"},\n  Bundle:      true,\n  Outdir:      \"dist\",\n})\n\nfor i := 0; i < 5; i++ {\n  result := ctx.Rebuild()\n}\n```\n\nThese three incremental build APIs can be combined. To enable [live reloading](#live-reload) (automatically reloading the page when you edit and save a file) you'll need to enable [watch](#watch) and [serve](#serve) together on the same context.\n\nWhen you are done with a context object, you can call `dispose()` on the context to wait for existing builds to finish, stop watch and/or serve mode, and free up resources.\n\nThe build and context APIs both take the following options:\n\n**General options:**\n\n- [Bundle](#bundle)\n- [Cancel](#cancel)\n- [Live reload](#live-reload)\n- [Platform](#platform)\n- [Rebuild](#rebuild)\n- [Serve](#serve)\n- [Tsconfig](#tsconfig)\n- [Tsconfig raw](#tsconfig-raw)\n- [Watch](#watch)\n\n  \n**Input:**\n\n- [Entry points](#entry-points)\n- [Loader](#loader)\n- [Stdin](#stdin)\n\n  \n**Output contents:**\n\n- [Banner](#banner)\n- [Charset](#charset)\n- [Footer](#footer)\n- [Format](#format)\n- [Global name](#global-name)\n- [Legal comments](#legal-comments)\n- [Line limit](#line-limit)\n- [Splitting](#splitting)\n\n  \n\n**Output location:**\n\n- [Allow overwrite](#allow-overwrite)\n- [Asset names](#asset-names)\n- [Chunk names](#chunk-names)\n- [Entry names](#entry-names)\n- [Out extension](#out-extension)\n- [Outbase](#outbase)\n- [Outdir](#outdir)\n- [Outfile](#outfile)\n- [Public path](#public-path)\n- [Write](#write)\n\n  \n**Path resolution:**\n\n- [Alias](#alias)\n- [Conditions](#conditions)\n- [External](#external)\n- [Main fields](#main-fields)\n- [Node paths](#node-paths)\n- [Packages](#packages)\n- [Preserve symlinks](#preserve-symlinks)\n- [Resolve extensions](#resolve-extensions)\n- [Working directory](#working-directory)\n\n  \n\n**Transformation:**\n\n- [JSX](#jsx)\n- [JSX dev](#jsx-dev)\n- [JSX factory](#jsx-factory)\n- [JSX fragment](#jsx-fragment)\n- [JSX import source](#jsx-import-source)\n- [JSX side effects](#jsx-side-effects)\n- [Supported](#supported)\n- [Target](#target)\n\n  \n**Optimization:**\n\n- [Define](#define)\n- [Drop](#drop)\n- [Drop labels](#drop-labels)\n- [Ignore annotations](#ignore-annotations)\n- [Inject](#inject)\n- [Keep names](#keep-names)\n- [Mangle props](#mangle-props)\n- [Minify](#minify)\n- [Pure](#pure)\n- [Tree shaking](#tree-shaking)\n\n  \n\n**Source maps:**\n\n- [Source root](#source-root)\n- [Sourcefile](#sourcefile)\n- [Sourcemap](#sourcemap)\n- [Sources content](#sources-content)\n\n  \n**Build metadata:**\n\n- [Analyze](#analyze)\n- [Metafile](#metafile)\n\n  \n**Logging:**\n\n- [Color](#color)\n- [Format messages](#format-messages)\n- [Log level](#log-level)\n- [Log limit](#log-limit)\n- [Log override](#log-override)"
- name: Build from source
  id: getting-started/index#build-from-source
  summary: If you want to build for other platforms, you can just prefix the build command with the platform information
  belongs_to: Getting Started
  description: "### Build from source\n\nTo build esbuild from source:\n\n1.  Install the Go compiler:\n\n    <https://go.dev/dl/>\n\n2.  Download the source code for esbuild:\n\n    ``` javascript\n    git clone --depth 1 --branch v0.23.0 https://github.com/evanw/esbuild.git\n    cd esbuild\n    ```\n\n3.  Build the `esbuild` executable (it will be `esbuild.exe` on Windows):\n\n    ``` javascript\n    go build ./cmd/esbuild\n    ```\n\nIf you want to build for other platforms, you can just prefix the build command with the platform information. For example, you can build the 32-bit Linux version using this command:\n\n``` javascript\nGOOS=linux GOARCH=386 go build ./cmd/esbuild\n```\n\n**Why this is not recommended:** The native version can only be used via the command-line interface, which can be unergonomic for complex use cases and which does not support [plugins](../plugins/index). You will need to write JavaScript or Go code and use [esbuild's API](../api/index) to use plugins.\n\n© 2020 Evan Wallace  \nLicensed under the MIT License.  \n[https://esbuild.github.io/getting-started/](https://esbuild.github.io/getting-started/)"
- name: Build metadata
  id: api/index#build-metadata
  summary: null
  belongs_to: API
  description: '## Build metadata'
- name: Build scripts
  id: getting-started/index#build-scripts
  summary: Your build command is something you will be running repeatedly, so you will want to automate it
  belongs_to: Getting Started
  description: |-
    ## Build scripts

    Your build command is something you will be running repeatedly, so you will want to automate it. A natural way of doing this is to add a build script to your `package.json` file like this:

    ``` javascript
    {
      "scripts": {
        "build": "esbuild app.jsx --bundle --outfile=out.js"
      }
    }
    ```

    Notice that this uses the `esbuild` command directly without a relative path. This works because everything in the `scripts` section is run with the `esbuild` command already in the path (as long as you have [installed the package](#install-esbuild)).

    The build script can be invoked like this:

    ``` javascript
    npm run build
    ```

    However, using the command-line interface can become unwieldy if you need to pass many options to esbuild. For more sophisticated uses you will likely want to write a build script in JavaScript using esbuild's JavaScript API. That might look something like this (note that this code must be saved in a file with the `.mjs` extension because it uses the `import` keyword):

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.jsx'],
      bundle: true,
      outfile: 'out.js',
    })
    ```

    The `build` function runs the esbuild executable in a child process and returns a promise that resolves when the build is complete. There is also a `buildSync` API that is not asynchronous, but the asynchronous API is better for build scripts because [plugins](../plugins/index) only work with the asynchronous API. You can read more about the configuration options for the build API in the [API documentation](../api/index#build).
- name: Bundle
  id: api/index#bundle
  summary: To bundle a file means to inline any imported dependencies into the file itself
  belongs_to: API
  description: |-
    ### Bundle

    *Supported by: [Build](#build)*

    To bundle a file means to inline any imported dependencies into the file itself. This process is recursive so dependencies of dependencies (and so on) will also be inlined. By default esbuild will *not* bundle the input files. Bundling must be explicitly enabled like this:

    ``` sh
    esbuild in.js --bundle
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    console.log(await esbuild.build({
      entryPoints: ['in.js'],
      bundle: true,
      outfile: 'out.js',
    }))
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"in.js"},
        Bundle:      true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Refer to the [getting started guide](../getting-started/index#your-first-bundle) for an example of bundling with real-world code.

    Note that bundling is different than file concatenation. Passing esbuild multiple input files with bundling enabled will create multiple separate bundles instead of joining the input files together. To join a set of files together with esbuild, import them all into a single entry point file and bundle just that one file with esbuild.

    #### Non-analyzable imports

    Import paths are currently only bundled if they are a string literal or a [glob pattern](#glob). Other forms of import paths are not bundled, and are instead preserved verbatim in the generated output. This is because bundling is a compile-time operation and esbuild doesn't support all forms of run-time path resolution. Here are some examples:

    ``` javascript
    // Analyzable imports (will be bundled by esbuild)
    import 'pkg';
    import('pkg');
    require('pkg');
    import(`./locale-${foo}.json`);
    require(`./locale-${foo}.json`);

    // Non-analyzable imports (will not be bundled by esbuild)
    import(`pkg/${foo}`);
    require(`pkg/${foo}`);
    ['pkg'].map(require);
    ```

    The way to work around non-analyzable imports is to mark the package containing this problematic code as [external](#external) so that it's not included in the bundle. You will then need to ensure that a copy of the external package is available to your bundled code at run-time.

    Some bundlers such as [Webpack](https://webpack.js.org/) try to support all forms of run-time path resolution by including all potentially-reachable files in the bundle and then emulating a file system at run-time. However, run-time file system emulation is out of scope and will not be implemented in esbuild. If you really need to bundle code that does this, you will likely need to use another bundler instead of esbuild.

    #### Glob-style imports

    Import paths that are evaluated at run-time can now be bundled in certain limited situations. The import path expression must be a form of string concatenation and must start with either `./` or `../`. Each non-string expression in the string concatenation chain becomes a wildcard in a [glob](https://en.wikipedia.org/wiki/Glob_(programming)) pattern. Some examples:

    ``` javascript
    // These two forms are equivalent
    const json1 = require('./data/' + kind + '.json')
    const json2 = require(`./data/${kind}.json`)
    ```

    When you do this, esbuild will search the file system for all files that match the pattern and include all of them in the bundle along with a map that maps the matching import path to the bundled module. The import expression will be replaced with a lookup into that map. An error will be thrown at run-time if the import path is not present in the map. The generated code will look something like this (unimportant parts were omitted for brevity):

    ``` javascript
    // data/bar.json
    var require_bar = ...;

    // data/foo.json
    var require_foo = ...;

    // require("./data/**/*.json") in example.js
    var globRequire_data_json = __glob({
      "./data/bar.json": () => require_bar(),
      "./data/foo.json": () => require_foo()
    });

    // example.js
    var json1 = globRequire_data_json("./data/" + kind + ".json");
    var json2 = globRequire_data_json(`./data/${kind}.json`);
    ```

    This feature works with `require(...)` and `import(...)` because these can all accept run-time expressions. It does not work with `import` and `export` statements because these cannot accept run-time expressions. If you want to prevent esbuild from trying to bundle these imports, you should move the string concatenation expression outside of the `require(...)` or `import(...)`. For example:

    ``` javascript
    // This will be bundled
    const json1 = require('./data/' + kind + '.json')

    // This will not be bundled
    const path = './data/' + kind + '.json'
    const json2 = require(path)
    ```

    Note that using this feature means esbuild will potentially do a lot of file system I/O to find all possible files that might match the pattern. This is by design, and is not a bug. If this is a concern, there are two ways to reduce the amount of file system I/O that esbuild does:

    1.  The simplest approach is to put all files that you want to import for a given run-time import expression in a subdirectory and then include the subdirectory in the pattern. This limits esbuild to searching inside that subdirectory since esbuild doesn't consider `..` path elements during pattern-matching.

    2.  Another approach is to prevent esbuild from searching into any subdirectory at all. The pattern matching algorithm that esbuild uses only allows a wildcard to match something containing a `/` path separator if that wildcard has a `/` before it in the pattern. So for example `'./data/' + x + '.json'` will match `x` with anything in any subdirectory while `'./data-' + x + '.json'` will only match `x` with anything in the top-level directory (but not in any subdirectory).

    &nbsp;
- name: Bundling for node
  id: getting-started/index#bundling-for-node
  summary: Even though a bundler is not necessary when using node, sometimes it can still be beneficial to process your code with esbuild before running it in node
  belongs_to: Getting Started
  description: |-
    ## Bundling for node

    Even though a bundler is not necessary when using node, sometimes it can still be beneficial to process your code with esbuild before running it in node. Bundling can automatically strip TypeScript types, convert ECMAScript module syntax to CommonJS, and transform newer JavaScript syntax into older syntax for a specific version of node. And it may be beneficial to bundle your package before publishing it so that it's a smaller download and so it spends less time reading from the file system when being loaded.

    If you are bundling code that will be run in node, you should configure the [platform](../api/index#platform) setting by passing `--platform=node` to esbuild. This simultaneously changes a few different settings to node-friendly default values. For example, all packages that are built-in to node such as `fs` are automatically marked as external so esbuild doesn't try to bundle them. This setting also disables the interpretation of the browser field in `package.json`.

    If your code uses newer JavaScript syntax that doesn't work in your version of node, you will want to configure the [target](../api/index#target) version of node:

    ``` sh
    esbuild app.js --bundle --platform=node --target=node10.4
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      platform: 'node',
      target: ['node10.4'],
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Platform:    api.PlatformNode,
        Engines: []api.Engine{
          {api.EngineNode, "10.4"},
        },
        Write: true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    You also may not want to bundle your dependencies with esbuild. There are many node-specific features that esbuild doesn't support while bundling such as `__dirname`, `import.meta.url`, `fs.readFileSync`, and `*.node` native binary modules. You can exclude all of your dependencies from the bundle by setting [packages](../api/index#packages) to external:

    ``` sh
    esbuild app.jsx --bundle --platform=node --packages=external
    ```

    ``` javascript
    require('esbuild').buildSync({
      entryPoints: ['app.jsx'],
      bundle: true,
      platform: 'node',
      packages: 'external',
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.jsx"},
        Bundle:      true,
        Platform:    api.PlatformNode,
        Packages:    api.PackagesExternal,
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    If you do this, your dependencies must still be present on the file system at run-time since they are no longer included in the bundle.
- name: Bundling for the browser
  id: getting-started/index#bundling-for-the-browser
  summary: The bundler outputs code for the browser by default, so no additional configuration is necessary to get started
  belongs_to: Getting Started
  description: |-
    ## Bundling for the browser

    The bundler outputs code for the browser by default, so no additional configuration is necessary to get started. For development builds you probably want to enable [source maps](../api/index#sourcemap) with `--sourcemap`, and for production builds you probably want to enable [minification](../api/index#minify) with `--minify`. You probably also want to configure the [target](../api/index#target) environment for the browsers you support so that JavaScript syntax which is too new will be transformed into older JavaScript syntax. All of that might looks something like this:

    ``` sh
    esbuild app.jsx --bundle --minify --sourcemap --target=chrome58,firefox57,safari11,edge16
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.jsx'],
      bundle: true,
      minify: true,
      sourcemap: true,
      target: ['chrome58', 'firefox57', 'safari11', 'edge16'],
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints:       []string{"app.jsx"},
        Bundle:            true,
        MinifyWhitespace:  true,
        MinifyIdentifiers: true,
        MinifySyntax:      true,
        Engines: []api.Engine{
          {api.EngineChrome, "58"},
          {api.EngineFirefox, "57"},
          {api.EngineSafari, "11"},
          {api.EngineEdge, "16"},
        },
        Write: true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Some npm packages you want to use may not be designed to be run in the browser. Sometimes you can use esbuild's configuration options to work around certain issues and successfully bundle the package anyway. Undefined globals can be replaced with either the [define](../api/index#define) feature in simple cases or the [inject](../api/index#inject) feature in more complex cases.
- name: Caching your plugin
  id: plugins/index#caching-your-plugin
  summary: Since esbuild is so fast, it's often the case that plugin evaluation is the main bottleneck when building with esbuild
  belongs_to: Plugins
  description: |-
    ### Caching your plugin

    Since esbuild is so fast, it's often the case that plugin evaluation is the main bottleneck when building with esbuild. Caching of plugin evaluation is left up to each plugin instead of being a part of esbuild itself because cache invalidation is plugin-specific. If you are writing a slow plugin that needs a cache to be fast, you will have to write the cache logic yourself.

    A cache is essentially a map that memoizes the transform function that represents your plugin. The keys of the map usually contain the inputs to your transform function and the values of the map usually contain the outputs of your transform function. In addition, the map usually has some form of least-recently-used cache eviction policy to avoid continually growing larger in size over time.

    The cache can either be stored in memory (beneficial for use with esbuild's [rebuild](../api/index#rebuild) API), on disk (beneficial for caching across separate build script invocations), or even on a server (beneficial for really slow transforms that can be shared between different developer machines). Where to store the cache is case-specific and depends on your plugin.

    Here is a simple caching example. Say we want to cache the function `slowTransform()` that takes as input the contents of a file in the `*.example` format and transforms it to JavaScript. An in-memory cache that avoids redundant calls to this function when used with esbuild's [rebuild](../api/index#rebuild) API) might look something like this:

    ``` javascript
    import fs from 'node:fs'

    let examplePlugin = {
      name: 'example',
      setup(build) {
        let cache = new Map

        build.onLoad({ filter: /\.example$/ }, async (args) => {
          let input = await fs.promises.readFile(args.path, 'utf8')
          let key = args.path
          let value = cache.get(key)

          if (!value || value.input !== input) {
            let contents = slowTransform(input)
            value = { input, output: { contents } }
            cache.set(key, value)
          }

          return value.output
        })
      }
    }
    ```

    Some important caveats about the caching code above:

    - There is no cache eviction policy present in the code above. Memory usage will continue to grow if more and more keys are added to the cache map.

      To combat this limitation somewhat, the `input` value is stored in the cache `value` instead of in the cache `key`. This means that changing the contents of a file will not leak memory because the key only includes the file path, not the file contents. Changing the file contents only overwrites the previous cache entry. This is probably fine for common usage where someone repeatedly edits the same file in between incremental rebuilds and only occasionally adds or renames files. But the cache will continue to grow in size if each build contains new unique path names (e.g. perhaps an auto-generated temporary file path containing the current time). A more advanced version might use a least-recently-used eviction policy.

    - Cache invalidation only works if `slowTransform()` is a [pure function](https://en.wikipedia.org/wiki/Pure_function) (meaning that the output of the function *only* depends on the inputs to the function) and if all of the inputs to the function are somehow captured in the lookup to the cache map. For example if the transform function automatically reads the contents of some other files and the output depends on the contents of those files too, then the cache would fail to be invalidated when those files are changed because they are not included in the cache key.

      This part is easy to mess up so it's worth going through a specific example. Consider a plugin that implements a compile-to-CSS language. If that plugin implements `@import` rules itself by parsing imported files and either bundles them or makes any exported variable declarations available to the importing code, your plugin will not be correct if it only checks that the importing file's contents haven't changed because a change to the imported file could also invalidate the cache.

      You may be thinking that you could just add the contents of the imported file to the cache key to fix this problem. However, even that may be incorrect. Say for example this plugin uses [`require.resolve()`](https://nodejs.org/api/modules.html#modules_require_resolve_request_options) to resolve the import path to an absolute file path. This is a common approach because it uses node's built-in path resolution that can resolve to a path inside a package. This function usually does many checks for files in different locations before returning the resolved path. For example, importing the path `pkg/file` from the file `src/entry.css` might check the following locations (yes, node's package resolution algorithm is very inefficient):

      ``` javascript
      src/node_modules/pkg/file
      src/node_modules/pkg/file.css
      src/node_modules/pkg/file/package.json
      src/node_modules/pkg/file/main
      src/node_modules/pkg/file/main.css
      src/node_modules/pkg/file/main/index.css
      src/node_modules/pkg/file/index.css
      node_modules/pkg/file
      node_modules/pkg/file.css
      node_modules/pkg/file/package.json
      node_modules/pkg/file/main
      node_modules/pkg/file/main.css
      node_modules/pkg/file/main/index.css
      node_modules/pkg/file/index.css
      ```

      Say the import `pkg/file` was ultimately resolved to the absolute path `node_modules/pkg/file/index.css`. Even if you cache the contents of both the importing file and the imported file and verify that the contents of both files are still the same before reusing the cache entry, the cache entry could still be stale if one of the other files that `require.resolve()` checks for has either been created or deleted since the cache entry was added. Caching this correctly essentially involves always re-running all such path resolutions even when none of the input files have been changed and verifying that none of the path resolutions have changed either.

    - These cache keys are only correct for an in-memory cache. It would be incorrect to implement a file system cache using the same cache keys. While an in-memory cache is guaranteed to always run the same code for every build because the code is also stored in memory, a file system cache could potentially be accessed by two separate builds that each contain different code. Specifically the code for the `slowTransform()` function may have been changed in between builds.

      This can happen in various cases. The package containing the function `slowTransform()` may have been updated, or one of its transitive dependencies may have been updated even if you have pinned the package's version due to how npm handles semver, or someone may have [mutated the package contents](https://www.npmjs.com/package/patch-package) on the file system in the meantime, or the transform function may be calling a node API and different builds could be running on different node versions.

      If you want to store your cache on the file system, you should guard against changes to the code for the transform function by storing some representation of the code for the transform function in the cache key. This is usually some form of [hash](https://nodejs.org/api/crypto.html#crypto_class_hash) that contains the contents of all relevant files in all relevant packages as well as potentially other details such as which node version you are currently running on. Getting all of this to be correct is non-trivial.

    &nbsp;
- name: Cancel
  id: api/index#cancel
  summary: If you are using rebuild to manually invoke incremental builds, you may want to use this cancel API to end the current build early so that you can start a new one
  belongs_to: API
  description: |-
    ### Cancel

    *Supported by: [Build](#build)*

    If you are using [rebuild](#rebuild) to manually invoke incremental builds, you may want to use this cancel API to end the current build early so that you can start a new one. You can do that like this:

    ``` sh
    # The CLI does not have an API for "cancel"
    ```

    ``` javascript
    import * as esbuild from 'esbuild'
    import process from 'node:process'

    let ctx = await esbuild.context({
      entryPoints: ['app.ts'],
      bundle: true,
      outdir: 'www',
      logLevel: 'info',
    })

    // Whenever we get some data over stdin
    process.stdin.on('data', async () => {
      try {
        // Cancel the already-running build
        await ctx.cancel()

        // Then start a new build
        console.log('build:', await ctx.rebuild())
      } catch (err) {
        console.error(err)
      }
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      ctx, err := api.Context(api.BuildOptions{
        EntryPoints: []string{"app.ts"},
        Bundle:      true,
        Outdir:      "www",
        LogLevel:    api.LogLevelInfo,
      })
      if err != nil {
        os.Exit(1)
      }

      // Whenever we get some data over stdin
      buf := make([]byte, 100)
      for {
        if n, err := os.Stdin.Read(buf); err != nil || n == 0 {
          break
        }
        go func() {
          // Cancel the already-running build
          ctx.Cancel()

          // Then start a new build
          result := ctx.Rebuild()
          fmt.Fprintf(os.Stderr, "build: %v\n", result)
        }()
      }
    }
    ```

    Make sure to wait until the cancel operation is done before starting a new build (i.e. `await` the returned promise when using JavaScript), otherwise the next [rebuild](#rebuild) will give you the just-canceled build that still hasn't ended yet. Note that plugin [on-end callbacks](../plugins/index#on-end) will still be run regardless of whether or not the build was canceled.
- name: Charset
  id: api/index#charset
  summary: By default esbuild's output is ASCII-only
  belongs_to: API
  description: |-
    ### Charset

    *Supported by: [Build](#build) and [Transform](#transform)*

    By default esbuild's output is ASCII-only. Any non-ASCII characters are escaped using backslash escape sequences. One reason is because non-ASCII characters are misinterpreted by the browser by default, which causes confusion. You have to explicitly add `<meta charset="utf-8">` to your HTML or serve it with the correct `Content-Type` header for the browser to not mangle your code. Another reason is that non-ASCII characters can significantly [slow down the browser's parser](https://v8.dev/blog/scanner). However, using escape sequences makes the generated output slightly bigger, and also makes it harder to read.

    If you would like for esbuild to print the original characters without using escape sequences and you have ensured that the browser will interpret your code as UTF-8, you can disable character escaping by setting the charset:

    ``` sh
    echo 'let π = Math.PI' | esbuild
    let \u03C0 = Math.PI;
    echo 'let π = Math.PI' | esbuild --charset=utf8
    let π = Math.PI;
    ```

    ``` javascript
    import * as esbuild from 'esbuild'
    let js = 'let π = Math.PI'
    (await esbuild.transform(js)).code
    'let \\u03C0 = Math.PI;\n'
    (await esbuild.transform(js, {
      charset: 'utf8',
    })).code
    'let π = Math.PI;\n'
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      js := "let π = Math.PI"

      result1 := api.Transform(js, api.TransformOptions{})

      if len(result1.Errors) == 0 {
        fmt.Printf("%s", result1.Code)
      }

      result2 := api.Transform(js, api.TransformOptions{
        Charset: api.CharsetUTF8,
      })

      if len(result2.Errors) == 0 {
        fmt.Printf("%s", result2.Code)
      }
    }
    ```

    Some caveats:

    - This does not yet escape non-ASCII characters embedded in regular expressions. This is because esbuild does not currently parse the contents of regular expressions at all. The flag was added despite this limitation because it's still useful for code that doesn't contain cases like this.

    - This flag does not apply to comments. I believe preserving non-ASCII data in comments should be fine because even if the encoding is wrong, the run time environment should completely ignore the contents of all comments. For example, the [V8 blog post](https://v8.dev/blog/scanner) mentions an optimization that avoids decoding comment contents completely. And all comments other than license-related comments are stripped out by esbuild anyway.

    - This option simultaneously applies to all output file types (JavaScript, CSS, and JSON). So if you configure your web server to send the correct `Content-Type` header and want to use the UTF-8 charset, make sure your web server is configured to treat both `.js` and `.css` files as UTF-8.

    &nbsp;
- name: Chunk names
  id: api/index#chunk-names
  summary: This option controls the file names of the chunks of shared code that are automatically generated when code splitting is enabled
  belongs_to: API
  description: |-
    ### Chunk names

    *Supported by: [Build](#build)*

    This option controls the file names of the chunks of shared code that are automatically generated when [code splitting](#splitting) is enabled. It configures the output paths using a template with placeholders that will be substituted with values specific to the chunk when the output path is generated. For example, specifying a chunk name template of `chunks/[name]-[hash]` puts all generated chunks into a subdirectory called `chunks` inside of the output directory and includes the content hash of the chunk in the file name. Doing that looks like this:

    ``` sh
    esbuild app.js --chunk-names=chunks/[name]-[hash] --bundle --outdir=out --splitting --format=esm
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      chunkNames: 'chunks/[name]-[hash]',
      bundle: true,
      outdir: 'out',
      splitting: true,
      format: 'esm',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        ChunkNames:  "chunks/[name]-[hash]",
        Bundle:      true,
        Outdir:      "out",
        Splitting:   true,
        Format:      api.FormatESModule,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    There are three placeholders that can be used in chunk path templates:

    - `[name]`

      This will currently always be the text `chunk`, although this placeholder may take on additional values in future releases.

    - `[hash]`

      This is the content hash of the chunk. Including this is necessary to distinguish different chunks from each other in the case where multiple chunks of shared code are generated.

    - `[ext]`

      This is the file extension of the chunk (i.e. everything after the end of the last `.` character). It can be used to put different types of chunks into different directories. For example, `--chunk-names=chunks/[ext]/[name]-[hash]` might write out a chunk as `chunks/css/chunk-DEFJT7KY.css`.

    Chunk path templates do not need to include a file extension. The configured [out extension](#out-extension) for the appropriate content type will be automatically added to the end of the output path after template substitution.

    Note that this option only controls the names for automatically-generated chunks of shared code. It does *not* control the names for output files related to entry points. The names of these are currently determined from the path of the original entry point file relative to the [outbase](#outbase) directory, and this behavior cannot be changed. An additional API option will be added in the future to let you change the file names of entry point output files.

    This option is similar to the [asset names](#asset-names) and [entry names](#entry-names) options.
- name: Color
  id: api/index#color
  summary: This option enables or disables colors in the error and warning messages that esbuild writes to stderr file descriptor in the terminal
  belongs_to: API
  description: |-
    ### Color

    *Supported by: [Build](#build) and [Transform](#transform)*

    This option enables or disables colors in the error and warning messages that esbuild writes to stderr file descriptor in the terminal. By default, color is automatically enabled if stderr is a TTY session and automatically disabled otherwise. Colored output in esbuild looks like this:

    ``` javascript
    ▲ [WARNING] The "typeof" operator will never evaluate to "null" [impossible-typeof]

        example.js:2:16:
          2 │ log(typeof x == "null")
            ╵                 ~~~~~~

      The expression "typeof x" actually evaluates to "object" in JavaScript, not "null". You need to
      use "x === null" to test for null.

    ✘ [ERROR] Could not resolve "logger"

        example.js:1:16:
          1 │ import log from "logger"
            ╵                 ~~~~~~~~

      You can mark the path "logger" as external to exclude it from the bundle, which will remove this
      error and leave the unresolved path in the bundle.
    ```

    Colored output can be force-enabled by setting color to `true`. This is useful if you are piping esbuild's stderr output into a TTY yourself:

    ``` sh
    echo 'typeof x == "null"' | esbuild --color=true 2> stderr.txt
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let js = 'typeof x == "null"'
    await esbuild.transform(js, {
      color: true,
    })
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      js := "typeof x == 'null'"

      result := api.Transform(js, api.TransformOptions{
        Color: api.ColorAlways,
      })

      if len(result.Errors) == 0 {
        fmt.Printf("%s", result.Code)
      }
    }
    ```

    Colored output can also be set to `false` to disable colors.
- name: Concepts
  id: plugins/index#concepts
  summary: Writing a plugin for esbuild works a little differently than writing a plugin for other bundlers
  belongs_to: Plugins
  description: |-
    ## Concepts

    Writing a plugin for esbuild works a little differently than writing a plugin for other bundlers. The concepts below are important to understand before developing your plugin:
- name: Conditions
  id: api/index#conditions
  summary: This feature controls how the exports field in package.json is interpreted
  belongs_to: API
  description: |-
    ### Conditions

    *Supported by: [Build](#build)*

    This feature controls how the `exports` field in `package.json` is interpreted. Custom conditions can be added using the conditions setting. You can specify as many of these as you want and the meaning of these is entirely up to package authors. Node has currently only endorsed the `development` and `production` custom conditions for recommended use. Here is an example of adding the custom conditions `custom1` and `custom2`:

    ``` sh
    esbuild src/app.js --bundle --conditions=custom1,custom2
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['src/app.js'],
      bundle: true,
      conditions: ['custom1', 'custom2'],
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"src/app.js"},
        Bundle:      true,
        Conditions:  []string{"custom1", "custom2"},
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    #### How conditions work

    Conditions allow you to redirect the same import path to different file locations in different situations. The redirect map containing the conditions and paths is stored in the `exports` field in the package's `package.json` file. For example, this would remap `require('pkg/foo')` to `pkg/required.cjs` and `import 'pkg/foo'` to `pkg/imported.mjs` using the `import` and `require` conditions:

    ``` javascript
    {
      "name": "pkg",
      "exports": {
        "./foo": {
          "import": "./imported.mjs",
          "require": "./required.cjs",
          "default": "./fallback.js"
        }
      }
    }
    ```

    Conditions are checked in the order that they appear within the JSON file. So the example above behaves sort of like this:

    ``` javascript
    if (importPath === './foo') {
      if (conditions.has('import')) return './imported.mjs'
      if (conditions.has('require')) return './required.cjs'
      return './fallback.js'
    }
    ```

    By default there are five conditions with special behavior that are built in to esbuild, and cannot be disabled:

    - `default`

      This condition is always active. It is intended to come last and lets you provide a fallback for when no other condition applies. This condition is also active when you run your code natively in node.

    - `import`

      This condition is only active when the import path is from an ESM `import` statement or `import()` expression. It can be used to provide ESM-specific code. This condition is also active when you run your code natively in node (but only in an ESM context).

    - `require`

      This condition is only active when the import path is from a CommonJS `require()` call. It can be used to provide CommonJS-specific code. This condition is also active when you run your code natively in node (but only in a CommonJS context).

    - `browser`

      This condition is only active when esbuild's [platform](#platform) setting is set to `browser`. It can be used to provide browser-specific code. This condition is not active when you run your code natively in node.

    - `node`

      This condition is only active when esbuild's [platform](#platform) setting is set to `node`. It can be used to provide node-specific code. This condition is also active when you run your code natively in node.

    The following condition is also automatically included when the [platform](#platform) is set to either `browser` or `node` and no custom conditions are configured. If there are any custom conditions configured (even an empty list) then this condition will no longer be automatically included:

    - `module`

      This condition can be used to tell esbuild to pick the ESM variant for a given import path to provide better tree-shaking when bundling. This condition is not active when you run your code natively in node. It is specific to bundlers, and originated from Webpack.

    Note that when you use the `require` and `import` conditions, *your package may end up in the bundle multiple times!* This is a subtle issue that can cause bugs due to duplicate copies of your code's state in addition to bloating the resulting bundle. This is commonly known as the [dual package hazard](https://nodejs.org/docs/latest/api/packages.html#packages_dual_package_hazard).

    One way of avoiding the dual package hazard that works both for bundlers and when running natively in node is to put all of your code in the `require` condition as CommonJS and have the `import` condition just be a light ESM wrapper that calls `require` on your package and re-exports the package using ESM syntax. This approach doesn't provide good tree-shaking, however, as esbuild doesn't tree-shake CommonJS modules.

    Another way of avoiding a dual package hazard is to use the bundler-specific `module` condition to direct bundlers to always load the ESM version of your package while letting node always fall back to the CommonJS version of your package. Both `import` and `module` are intended to be used with ESM but unlike `import`, the `module` condition is always active even if the import path was loaded using a `require` call. This works well with bundlers because bundlers support loading ESM using `require`, but it's not something that can work with node because node deliberately doesn't implement loading ESM using `require`.
- name: Content Types
  id: content-types/index
  summary: All of the built-in content types are listed below
  description: "# Content Types\n\nAll of the built-in content types are listed below. Each content type has an associated \"loader\" which tells esbuild how to interpret the file contents. Some file extensions already have a loader configured for them by default, although the defaults can be overridden.\n\n## JavaScript\n\nLoader: `js`\n\nThis loader is enabled by default for `.js`, `.cjs`, and `.mjs` files. The `.cjs` extension is used by node for CommonJS modules and the `.mjs` extension is used by node for ECMAScript modules.\n\nNote that by default, esbuild's output will take advantage of all modern JS features. For example, `a !== void 0 && a !== null ? a : b` will become `a ?? b` when minifying is enabled which makes use of syntax from the [ES2020](https://262.ecma-international.org/11.0/#prod-CoalesceExpression) version of JavaScript. If this is undesired, you must specify esbuild's [target](../api/index#target) setting to say in which browsers you need the output to work correctly. Then esbuild will avoid using JavaScript features that are too modern for those browsers.\n\nAll modern JavaScript syntax is supported by esbuild. Newer syntax may not be supported by older browsers, however, so you may want to configure the [target](../api/index#target) option to tell esbuild to convert newer syntax to older syntax as appropriate.\n\nThese syntax features are always transformed for older browsers:\n\n| Syntax transform                                                                                                   | Language version | Example       |\n|--------------------------------------------------------------------------------------------------------------------|------------------|---------------|\n| [Trailing commas in function parameter lists and calls](https://github.com/tc39/proposal-trailing-function-commas) | `es2017`         | `foo(a, b, )` |\n| [Numeric separators](https://github.com/tc39/proposal-numeric-separator)                                           | `esnext`         | `1_000_000`   |\n\nThese syntax features are conditionally transformed for older browsers depending on the configured language [target](../api/index#target):\n\n| Syntax transform                                                                      | Transformed when `--target` is below | Example                     |\n|---------------------------------------------------------------------------------------|--------------------------------------|-----------------------------|\n| [Exponentiation operator](https://github.com/tc39/proposal-exponentiation-operator)   | `es2016`                             | `a ** b`                    |\n| [Async functions](https://github.com/tc39/ecmascript-asyncawait)                      | `es2017`                             | `async () => {}`            |\n| [Asynchronous iteration](https://github.com/tc39/proposal-async-iteration)            | `es2018`                             | `for await (let x of y) {}` |\n| [Async generators](https://github.com/tc39/proposal-async-iteration)                  | `es2018`                             | `async function* foo() {}`  |\n| [Spread properties](https://github.com/tc39/proposal-object-rest-spread)              | `es2018`                             | `let x = {...y}`            |\n| [Rest properties](https://github.com/tc39/proposal-object-rest-spread)                | `es2018`                             | `let {...x} = y`            |\n| [Optional catch binding](https://github.com/tc39/proposal-optional-catch-binding)     | `es2019`                             | `try {} catch {}`           |\n| [Optional chaining](https://github.com/tc39/proposal-optional-chaining)               | `es2020`                             | `a?.b`                      |\n| [Nullish coalescing](https://github.com/tc39/proposal-nullish-coalescing)             | `es2020`                             | `a ?? b`                    |\n| [`import.meta`](https://github.com/tc39/proposal-import-meta)                         | `es2020`                             | `import.meta`               |\n| [Logical assignment operators](https://github.com/tc39/proposal-logical-assignment)   | `es2021`                             | `a ??= b`                   |\n| [Class instance fields](https://github.com/tc39/proposal-class-fields)                | `es2022`                             | `class { x }`               |\n| [Static class fields](https://github.com/tc39/proposal-static-class-features)         | `es2022`                             | `class { static x }`        |\n| [Private instance methods](https://github.com/tc39/proposal-private-methods)          | `es2022`                             | `class { #x() {} }`         |\n| [Private instance fields](https://github.com/tc39/proposal-class-fields)              | `es2022`                             | `class { #x }`              |\n| [Private static methods](https://github.com/tc39/proposal-static-class-features)      | `es2022`                             | `class { static #x() {} }`  |\n| [Private static fields](https://github.com/tc39/proposal-static-class-features)       | `es2022`                             | `class { static #x }`       |\n| [Ergonomic brand checks](https://github.com/tc39/proposal-private-fields-in-in)       | `es2022`                             | `#x in y`                   |\n| [Class static blocks](https://github.com/tc39/proposal-class-static-block)            | `es2022`                             | `class { static {} }`       |\n| [Import assertions](https://github.com/tc39/proposal-import-assertions)               | `esnext`                             | `import \"x\" assert {}`¹     |\n| [Import attributes](https://github.com/tc39/proposal-import-attributes)               | `esnext`                             | `import \"x\" with {}`        |\n| [Auto-accessors](https://github.com/tc39/proposal-decorators#class-auto-accessors)    | `esnext`                             | `class { accessor x }`      |\n| [`using` declarations](https://github.com/tc39/proposal-explicit-resource-management) | `esnext`                             | `using x = y`               |\n| [Decorators](https://github.com/tc39/proposal-decorators)                             | `esnext`                             | `@foo class Bar {}`         |\n\n¹ Import assertions never made it into the JavaScript specification. They are deprecated in favor of import attributes and are actively being removed from JavaScript runtimes.\n\nThese syntax features are currently always passed through un-transformed:\n\n| Syntax transform                                                                                                   | Unsupported when `--target` is below | Example                   |\n|--------------------------------------------------------------------------------------------------------------------|--------------------------------------|---------------------------|\n| [RegExp `dotAll` flag](https://github.com/tc39/proposal-regexp-dotall-flag)                                        | `es2018`                             | `/./s`¹                   |\n| [RegExp lookbehind assertions](https://github.com/tc39/proposal-regexp-lookbehind)                                 | `es2018`                             | `/(?<=x)y/`¹              |\n| [RegExp named capture groups](https://github.com/tc39/proposal-regexp-named-groups)                                | `es2018`                             | `/(?<foo>\\d+)/`¹          |\n| [RegExp unicode property escapes](https://github.com/tc39/proposal-regexp-unicode-property-escapes)                | `es2018`                             | `/\\p{ASCII}/u`¹           |\n| [BigInt](https://github.com/tc39/proposal-bigint)                                                                  | `es2020`                             | `123n`                    |\n| [Top-level await](https://github.com/tc39/proposal-top-level-await)                                                | `es2022`                             | `await import(x)`         |\n| [Arbitrary module namespace identifiers](https://github.com/bmeck/proposal-arbitrary-module-namespace-identifiers) | `es2022`                             | `export {foo as 'f o o'}` |\n| [RegExp match indices](https://github.com/tc39/proposal-regexp-match-indices)                                      | `es2022`                             | `/x(.+)y/d`¹              |\n| [RegExp set notation](https://github.com/tc39/proposal-regexp-v-flag)                                              | `es2024`                             | `/[\\w--\\d]/v`¹            |\n| [Hashbang grammar](https://github.com/tc39/proposal-hashbang)                                                      | `esnext`                             | `#!/usr/bin/env node`     |\n\n¹ Unsupported regular expression literals are transformed into a `new RegExp()` constructor call so you can bring your own polyfill library to get them to work anyway.\n\nSee also [the list of finished ECMAScript proposals](https://github.com/tc39/proposals/blob/main/finished-proposals.md) and [the list of active ECMAScript proposals](https://github.com/tc39/proposals/blob/main/README.md). Note that while transforming code containing top-level await is supported, bundling code containing top-level await is only supported when the [output format](../api/index#format) is set to [`esm`](../api/index#format-esm).\n\n### JavaScript caveats\n\nYou should keep the following things in mind when using JavaScript with esbuild:\n\n#### ES5 is not supported well\n\nTransforming ES6+ syntax to ES5 is not supported yet. However, if you're using esbuild to transform ES5 code, you should still set the [target](../api/index#target) to `es5`. This prevents esbuild from introducing ES6 syntax into your ES5 code. For example, without this flag the object literal `{x: x}` will become `{x}` and the string `\"a\\nb\"` will become a multi-line template literal when minifying. Both of these substitutions are done because the resulting code is shorter, but the substitutions will not be performed if the [target](../api/index#target) is `es5`.\n\n#### Private member performance\n\nThe private member transform (for the `#name` syntax) uses `WeakMap` and `WeakSet` to preserve the privacy properties of this feature. This is similar to the corresponding transforms in the Babel and TypeScript compilers. Most modern JavaScript engines (V8, JavaScriptCore, and SpiderMonkey but not ChakraCore) may not have good performance characteristics for large `WeakMap` and `WeakSet` objects.\n\nCreating many instances of classes with private fields or private methods with this syntax transform active may cause a lot of overhead for the garbage collector. This is because modern engines (other than ChakraCore) store weak values in an actual map object instead of as hidden properties on the keys themselves, and large map objects can cause performance issues with garbage collection. See [this reference](https://github.com/tc39/ecma262/issues/1657#issuecomment-518916579) for more information.\n\n#### Imports follow ECMAScript module behavior\n\nYou might try to modify global state before importing a module which needs that global state and expect it to work. However, JavaScript (and therefore esbuild) effectively \"hoists\" all `import` statements to the top of the file, so doing this won't work:\n\n``` javascript\nwindow.foo = {}\nimport './something-that-needs-foo'\n```\n\nThere are some broken implementations of ECMAScript modules out there (e.g. the TypeScript compiler) that don't follow the JavaScript specification in this regard. Code compiled with these tools may \"work\" since the `import` is replaced with an inline call to `require()`, which ignores the hoisting requirement. But such code will not work with real ECMAScript module implementations such as node, a browser, or esbuild, so writing code like this is non-portable and is not recommended.\n\nThe way to do this correctly is to move the global state modification into its own import. That way it *will* be run before the other import:\n\n``` javascript\nimport './assign-to-foo-on-window'\nimport './something-that-needs-foo'\n```\n\n#### Avoid direct `eval` when bundling\n\nAlthough the expression `eval(x)` looks like a normal function call, it actually takes on special behavior in JavaScript. Using `eval` in this way means that the evaluated code stored in `x` can reference any variable in any containing scope by name. For example, the code `let y = 123; return eval('y')` will return `123`.\n\nThis is called \"direct eval\" and is problematic when bundling your code for many reasons:\n\n- Modern bundlers contain an optimization called \"scope hoisting\" that merges all bundled files into a single file and renames variables to avoid name collisions. However, this means code evaluated by direct `eval` can read and write variables in any file in the bundle! This is a correctness issue because the evaluated code may try to access a global variable but may accidentally access a private variable with the same name from another file instead. It can potentially even be a security issue if a private variable in another file has sensitive data.\n\n- The evaluated code may not work correctly when it references variables imported using an `import` statement. Imported variables are live bindings to variables in another file. They are not copies of those variables. So when esbuild bundles your code, your imports are replaced with a direct reference to the variable in the imported file. But that variable may have a different name, in which case the code evaluated by direct `eval` will be unable to reference it by the expected name.\n\n- Using direct `eval` forces esbuild to deoptimize all of the code in all of the scopes containing calls to direct `eval`. For correctness, it must assume that the evaluated code might need to access any of the other code in the file reachable from that `eval` call. This means none of that code will be eliminated as dead code and none of that code will be minified.\n\n- Because the code evaluated by the direct `eval` could need to reference any reachable variable by name, esbuild is prevented from renaming all of the variables reachable by the evaluated code. This means it can't rename variables to avoid name collisions with other variables in the bundle. So the direct `eval` causes esbuild to wrap the file in a CommonJS closure, which avoids name collisions by introducing a new scope instead. However, this makes the generated code bigger and slower because exported variables use run-time dynamic binding instead of compile-time static binding.\n\nLuckily it is usually easy to avoid using direct `eval`. There are two commonly-used alternatives that avoid all of the drawbacks mentioned above:\n\n- `(0, eval)('x')`\n\n  This is known as \"indirect eval\" because `eval` is not being called directly, and so does not trigger the grammatical special case for direct eval in the JavaScript VM. You can call indirect eval using any syntax at all except for an expression of the exact form `eval('x')`. For example, `var eval2 = eval; eval2('x')` and `[eval][0]('x')` and `window.eval('x')` are all indirect eval calls. When you use indirect eval, the code is evaluated in the global scope instead of in the inline scope of the caller.\n\n- `new Function('x')`\n\n  This constructs a new function object at run-time. It is as if you wrote `function() { x }` in the global scope except that `x` can be an arbitrary string of code. This form is sometimes convenient because you can add arguments to the function, and use those arguments to expose variables to the evaluated code. For example, `(new Function('env', 'x'))(someEnv)` is as if you wrote `(function(env) { x })(someEnv)`. This is often a sufficient alternative for direct `eval` when the evaluated code needs to access local variables because you can pass the local variables in as arguments.\n\n#### The value of `toString()` is not preserved on functions (and classes)\n\nIt's somewhat common to call `toString()` on a JavaScript function object and then pass that string to some form of `eval` to get a new function object. This effectively \"rips\" the function out of the containing file and breaks links with all variables in that file. Doing this with esbuild is not supported and may not work. In particular, esbuild often uses helper methods to implement certain features and it assumes that JavaScript scope rules have not been tampered with. For example:\n\n``` javascript\nlet pow = (a, b) => a ** b;\nlet pow2 = (0, eval)(pow.toString());\nconsole.log(pow2(2, 3));\n```\n\nWhen this code is compiled for ES6, where the `**` operator isn't available, the `**` operator is replaced with a call to the `__pow` helper function:\n\n``` javascript\nlet __pow = Math.pow;\nlet pow = (a, b) => __pow(a, b);\nlet pow2 = (0, eval)(pow.toString());\nconsole.log(pow2(2, 3));\n```\n\nIf you try to run this code, you'll get an error such as `ReferenceError: __pow is not defined` because the function `(a, b) => __pow(a, b)` depends on the locally-scoped symbol `__pow` which is not available in the global scope. This is the case for many JavaScript language features including `async` functions, as well as some esbuild-specific features such as the [keep names](../api/index#keep-names) setting.\n\nThis problem most often comes up when people get the source code of a function with `.toString()` and then try to use it as the body of a [web worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API). If you are doing this and you want to use esbuild, you should instead build the source code for the web worker in a separate build step and then insert the web worker source code as a string into the code that creates the web worker. The [define](../api/index#define) feature is one way to insert the string at build time.\n\n#### The value of `this` is not preserved on functions called from a module namespace object\n\nIn JavaScript, the value of `this` in a function is automatically filled in for you based on how the function is called. For example if a function is called using `obj.fn()`, the value of `this` during the function call will be `obj`. This behavior is respected by esbuild with one exception: if you call a function from a module namespace object, the value of `this` may not be correct. For example, consider this code that calls `foo` from the module namespace object `ns`:\n\n``` javascript\nimport * as ns from './foo.js'\nns.foo()\n```\n\nIf `foo.js` tries to reference the module namespace object using `this`, then it won't necessarily work after the code is bundled with esbuild:\n\n``` javascript\n// foo.js\nexport function foo() {\n  this.bar()\n}\nexport function bar() {\n  console.log('bar')\n}\n```\n\nThe reason for this is that esbuild automatically rewrites code most code that uses module namespace objects to code that imports things directly instead. That means the example code above will be converted to this instead, which removes the `this` context for the function call:\n\n``` javascript\nimport { foo } from './foo.js'\nfoo()\n```\n\nThis transformation dramatically improves [tree shaking](../api/index#tree-shaking) (a.k.a. dead code elimination) because it makes it possible for esbuild to understand which exported symbols are unused. It has the drawback that this changes the behavior of code that uses `this` to access the module's exports, but this isn't an issue because no one should ever write bizarre code like this in the first place. If you need to access an exported function from the same file, just call it directly (i.e. `bar()` instead of `this.bar()` in the example above).\n\n#### The `default` export can be error-prone\n\nThe ES module format (i.e. ESM) have a special export called `default` that sometimes behaves differently than all other export names. When code in the ESM format that has a `default` export is converted to the CommonJS format, and then that CommonJS code is imported into another module in ESM format, there are two different interpretations of what should happen that are both widely-used (the [Babel](https://babeljs.io/) way and the [Node](https://nodejs.org/) way). This is very unfortunate because it causes endless compatibility headaches, especially since JavaScript libraries are often authored in ESM and published as CommonJS.\n\nWhen esbuild [bundles](../api/index#bundle) code that does this, it has to decide which interpretation to use, and there's no perfect answer. The heuristics that esbuild uses are the same heuristics that [Webpack](https://webpack.js.org/) uses (see below for details). Since Webpack is the most widely-used bundler, this means that esbuild is being the most compatible that it can be with the existing ecosystem regarding this compatibility problem. So the good news is that if you can get code with this problem to work with esbuild, it should also work with Webpack.\n\nHere's an example that demonstrates the problem:\n\n``` javascript\n// index.js\nimport foo from './somelib.js'\nconsole.log(foo)\n```\n\n``` javascript\n// somelib.js\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = 'foo';\n```\n\nAnd here are the two interpretations, both of which are widely-used:\n\n- **The Babel interpretation**\n\n  If the Babel interpretation is used, this code will print `foo`. Their rationale is that `somelib.js` was converted from ESM into CommonJS (as you can tell by the `__esModule` marker) and the original code looked something like this:\n\n  ``` javascript\n  // somelib.js\n  export default 'foo'\n  ```\n\n  If `somelib.js` hadn't been converted from ESM into CommonJS, then this code would print `foo`, so it should still print `foo` regardless of the module format. This is accomplished by detecting when a CommonJS module used to be an ES module via the `__esModule` marker (which all module conversion tools set including Babel, TypeScript, Webpack, and esbuild) and setting the default import to `exports.default` if the `__esModule` marker is present. This behavior is important because it's necessary to run cross-compiled ESM correctly in a CommonJS environment, and for a long time that was the only way to run ESM code in Node before Node eventually added native ESM support.\n\n- **The Node interpretation**\n\n  If the Node interpretation is used, this code will print `{ default: 'foo' }`. Their rationale is that CommonJS code uses dynamic exports while ESM code uses static exports, so the fully general approach to importing CommonJS into ESM is to expose the CommonJS `exports` object itself somehow. For example, CommonJS code can do `exports[Math.random()] = 'foo'` which has no equivalent in ESM syntax. The `default` export is used for this because that's actually what it was originally designed for by the people who came up with the ES module specification. This interpretation is entirely reasonable for normal CommonJS modules. It only causes compatibility problems for CommonJS modules that used to be ES modules (i.e. when `__esModule` is present) in which case the behavior diverges from the Babel interpretation.\n\n*If you are a library author:* When writing new code, you should strongly consider avoiding the `default` export entirely. It has unfortunately been tainted with compatibility problems and using it will likely cause problems for your users at some point.\n\n*If you are a library user:* By default, esbuild will use the Babel interpretation. If you want esbuild to use the Node interpretation instead, you need to either put your code in a file ending in `.mts` or `.mjs`, or you need to add `\"type\": \"module\"` to your `package.json` file. The rationale is that Node's native ESM support can only run ESM code if the file extension is `.mjs` or `\"type\": \"module\"` is present, so doing that is a good signal that the code is intended to be run in Node, and should therefore use the Node interpretation of `default` import. This is the same heuristic that Webpack uses.\n\n## TypeScript\n\nLoader: `ts` or `tsx`\n\nThis loader is enabled by default for `.ts`, `.tsx`, `.mts`, and `.cts` files, which means esbuild has built-in support for parsing TypeScript syntax and discarding the type annotations. However, esbuild *does not* do any type checking so you will still need to run `tsc -noEmit` in parallel with esbuild to check types. This is not something esbuild does itself.\n\nTypeScript type declarations like these are parsed and ignored (a non-exhaustive list):\n\n| Syntax feature              | Example                         |\n|-----------------------------|---------------------------------|\n| Interface declarations      | `interface Foo {}`              |\n| Type declarations           | `type Foo = number`             |\n| Function declarations       | `function foo(): void;`         |\n| Ambient declarations        | `declare module 'foo' {}`       |\n| Type-only imports           | `import type {Type} from 'foo'` |\n| Type-only exports           | `export type {Type} from 'foo'` |\n| Type-only import specifiers | `import {type Type} from 'foo'` |\n| Type-only export specifiers | `export {type Type} from 'foo'` |\n\nTypeScript-only syntax extensions are supported, and are always converted to JavaScript (a non-exhaustive list):\n\n| Syntax feature            | Example                    | Notes                                                                                                                                                                                                          |\n|---------------------------|----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Namespaces                | `namespace Foo {}`         |                                                                                                                                                                                                                |\n| Enums                     | `enum Foo { A, B }`        |                                                                                                                                                                                                                |\n| Const enums               | `const enum Foo { A, B }`  |                                                                                                                                                                                                                |\n| Generic type parameters   | `<T>(a: T): T => a`        | Must write `<T,>(`... with the `tsx` loader                                                                                                                                                                    |\n| JSX with types            | `<Element<T>/>`            |                                                                                                                                                                                                                |\n| Type casts                | `a as B` and `<B>a`        |                                                                                                                                                                                                                |\n| Type imports              | `import {Type} from 'foo'` | Handled by removing all unused imports                                                                                                                                                                         |\n| Type exports              | `export {Type} from 'foo'` | Handled by ignoring missing exports in TypeScript files                                                                                                                                                        |\n| Experimental decorators   | `@sealed class Foo {}`     | Requires [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators), does not support [`emitDecoratorMetadata`](https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata) |\n| Instantiation expressions | `Array<number>`            | TypeScript 4.7+                                                                                                                                                                                                |\n| `extends` on `infer`      | `infer A extends B`        | TypeScript 4.7+                                                                                                                                                                                                |\n| Variance annotations      | `type A<out B> = () => B`  | TypeScript 4.7+                                                                                                                                                                                                |\n| The `satisfies` operator  | `a satisfies T`            | TypeScript 4.9+                                                                                                                                                                                                |\n| `const` type parameters   | `class Foo<const T> {}`    | TypeScript 5.0+                                                                                                                                                                                                |\n\n### TypeScript caveats\n\nYou should keep the following things in mind when using TypeScript with esbuild (in addition to the [JavaScript caveats](#javascript-caveats)):\n\n#### Files are compiled independently\n\nEven when transpiling a single module, the TypeScript compiler actually still parses imported files so it can tell whether an imported name is a type or a value. However, tools like esbuild and Babel (and the TypeScript compiler's `transpileModule` API) compile each file in isolation so they can't tell if an imported name is a type or a value.\n\nBecause of this, you should enable the [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules) TypeScript configuration option if you use TypeScript with esbuild. This option prevents you from using features which could cause mis-compilation in environments like esbuild where each file is compiled independently without tracing type references across files. For example, it prevents you from re-exporting types from another module using `export {T} from './types'` (you need to use `export type {T} from './types'` instead).\n\n#### Imports follow ECMAScript module behavior\n\nFor historical reasons, the TypeScript compiler compiles ESM (ECMAScript module) syntax to CommonJS syntax by default. For example, `import * as foo from 'foo'` is compiled to `const foo = require('foo')`. Presumably this happened because ECMAScript modules were still a proposal when TypeScript adopted the syntax. However, this is legacy behavior that doesn't match how this syntax behaves on real platforms such as node. For example, the `require` function can return any JavaScript value including a string but the `import * as` syntax always results in an object and cannot be a string.\n\nTo avoid problems due to this legacy feature, you should enable the [`esModuleInterop`](https://www.typescriptlang.org/tsconfig#esModuleInterop) TypeScript configuration option if you use TypeScript with esbuild. Enabling it disables this legacy behavior and makes TypeScript's type system compatible with ESM. This option is not enabled by default because it would be a breaking change for existing TypeScript projects, but Microsoft [highly recommends applying it both to new and existing projects](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#support-for-import-d-from-cjs-from-commonjs-modules-with---esmoduleinterop) (and then updating your code) for better compatibility with the rest of the ecosystem.\n\nSpecifically this means that importing a non-object value from a CommonJS module with ESM import syntax must be done using a default import instead of using `import * as`. So if a CommonJS module exports a function via `module.exports = fn`, you need to use `import fn from 'path'` instead of `import * as fn from 'path'`.\n\n#### Features that need a type system are not supported\n\nTypeScript types are treated as comments and are ignored by esbuild, so TypeScript is treated as \"type-checked JavaScript.\" The interpretation of the type annotations is up to the TypeScript type checker, which you should be running in addition to esbuild if you're using TypeScript. This is the same compilation strategy that Babel's TypeScript implementation uses. However, it means that some TypeScript compilation features which require type interpretation to work do not work with esbuild.\n\nSpecifically:\n\n- The [`emitDecoratorMetadata`](https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata) TypeScript configuration option is not supported. This feature passes a JavaScript representation of the corresponding TypeScript type to the attached decorator function. Since esbuild does not replicate TypeScript's type system, it does not have enough information to implement this feature.\n\n- The [`declaration`](https://www.typescriptlang.org/tsconfig#declaration) TypeScript configuration option (i.e. generation of `.d.ts` files) is not supported. If you are writing a library in TypeScript and you want to publish the compiled JavaScript code as a package for others to use, you will probably also want to publish type declarations. This is not something that esbuild can do for you because it doesn't retain any type information. You will likely either need to use the TypeScript compiler to generate them or manually write them yourself.\n\n#### Only certain `tsconfig.json` fields are respected\n\nDuring bundling, the path resolution algorithm in esbuild will consider the contents of the `tsconfig.json` file in the closest parent directory containing one and will modify its behavior accordingly. It is also possible to explicitly set the `tsconfig.json` path with the build API using esbuild's [`tsconfig`](../api/index#tsconfig) setting and to explicitly pass in the contents of a `tsconfig.json` file with the transform API using esbuild's [`tsconfigRaw`](../api/index#tsconfig-raw) setting. However, esbuild currently only inspects the following fields in `tsconfig.json` files:\n\n- [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators)\n\n  This option enables the transformation of decorator syntax in TypeScript files. The transformation follows the outdated decorator design that TypeScript itself follows when `experimentalDecorators` is enabled.\n\n  Note that there is an updated design for decorators that is being added to JavaScript, as well as to TypeScript when `experimentalDecorators` is disabled. This is not something that esbuild implements yet, so esbuild will currently not transform decorators when `experimentalDecorators` is disabled.\n\n- [`target`](https://www.typescriptlang.org/tsconfig#target)  \n  [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)\n\n  These options control whether class fields in TypeScript files are compiled with \"define\" semantics or \"assign\" semantics:\n\n  - **Define semantics** (esbuild's default behavior): TypeScript class fields behave like normal JavaScript class fields. Field initializers do not trigger setters on the base class. You should write all new code this way going forward.\n\n  - **Assign semantics** (which you have to explicitly enable): esbuild emulates TypeScript's legacy class field behavior. Field initializers will trigger base class setters. This may be needed to get legacy code to run.\n\n  The way to disable define semantics (and therefore enable assign semantics) with esbuild is the same way you disable it with TypeScript: by setting `useDefineForClassFields` to `false` in your `tsconfig.json` file.\n\n  For compatibility with TypeScript, esbuild also copies TypeScript's behavior where when `useDefineForClassFields` is not specified, it defaults to `false` when `tsconfig.json` contains a `target` that is earlier than `ES2022`. But I recommend setting `useDefineForClassFields` explicitly if you need it instead of relying on this default value coming from the value of the `target` setting. Note that the `target` setting in `tsconfig.json` is only used by esbuild for determining the default value of `useDefineForClassFields`. It does *not* affect esbuild's own [`target`](../api/index#target) setting, even though they have the same name.\n\n- [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl)  \n  [`paths`](https://www.typescriptlang.org/tsconfig#paths)\n\n  These options affect esbuild's resolution of `import`/`require` paths to files on the file system. You can use it to define package aliases and to rewrite import paths in other ways. Note that using esbuild for import path transformation requires [`bundling`](../api/index#bundle) to be enabled, as esbuild's path resolution only happens during bundling. Also note that esbuild also has a native [`alias`](../api/index#alias) feature which you may want to use instead.\n\n- [`jsx`](https://www.typescriptlang.org/tsconfig#jsx)  \n  [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)  \n  [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)  \n  [`jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource)\n\n  These options affect esbuild's transformation of JSX syntax into JavaScript. They are equivalent to esbuild's native options for these settings: [`jsx`](../api/index#jsx), [`jsxFactory`](../api/index#jsx-factory), [`jsxFragment`](../api/index#jsx-fragment), and [`jsxImportSource`](../api/index#jsx-import-source).\n\n- [`alwaysStrict`](https://www.typescriptlang.org/tsconfig#alwaysStrict)  \n  [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n\n  If either of these options are enabled, esbuild will consider all code in all TypeScript files to be in [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) and will prefix generated code with `\"use strict\"` unless the output [`format`](../api/index#format) is set to [`esm`](../api/index#format-esm) (since all ESM files are automatically in strict mode).\n\n- [`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax)  \n  [`importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues)  \n  [`preserveValueImports`](https://www.typescriptlang.org/tsconfig/#preserveValueImports)\n\n  By default, the TypeScript compiler will delete unused imports when converting TypeScript to JavaScript. That way imports which turn out to be type-only imports accidentally don't cause an error at run-time. This behavior is also implemented by esbuild.\n\n  These options allow you to disable this behavior and preserve unused imports, which can be useful if for example the imported file has useful side-effects. You should use `verbatimModuleSyntax` for this, as that replaces the older `importsNotUsedAsValues` and `preserveValueImports` settings (which TypeScript has now deprecated).\n\n- [`extends`](https://www.typescriptlang.org/tsconfig#extends)\n\n  This option allows you to split up your `tsconfig.json` file across multiple files. This value can be a string for single inheritance or an array for multiple inheritance (new in TypeScript 5.0+).\n\nAll other `tsconfig.json` fields (i.e. those that aren't in the above list) will be ignored.\n\n#### You cannot use the `tsx` loader for `*.ts` files\n\nThe `tsx` loader is *not* a superset of the `ts` loader. They are two different partially-incompatible syntaxes. For example, the character sequence `<a>1</a>/g` parses as `<a>(1 < (/a>/g))` with the `ts` loader and `(<a>1</a>) / g` with the `tsx` loader.\n\nThe most common issue this causes is not being able to use generic type parameters on arrow function expressions such as `<T>() => {}` with the `tsx` loader. This is intentional, and matches the behavior of the official TypeScript compiler. That space in the `tsx` grammar is reserved for JSX elements.\n\n## JSX\n\nLoader: `jsx` or `tsx`\n\n[JSX](https://facebook.github.io/jsx/) is an XML-like syntax extension for JavaScript that was created for [React](https://github.com/facebook/react). It's intended to be converted into normal JavaScript by your build tool. Each XML element becomes a normal JavaScript function call. For example, the following JSX code:\n\n``` javascript\nimport Button from './button'\nlet button = <Button>Click me</Button>\nrender(button)\n```\n\nWill be converted to the following JavaScript code:\n\n``` javascript\nimport Button from \"./button\";\nlet button = React.createElement(Button, null, \"Click me\");\nrender(button);\n```\n\nThis loader is enabled by default for `.jsx` and `.tsx` files. Note that JSX syntax is not enabled in `.js` files by default. If you would like to enable that, you will need to configure it:\n\n``` sh\nesbuild app.js --bundle --loader:.js=jsx\n```\n\n``` javascript\nrequire('esbuild').buildSync({\n  entryPoints: ['app.js'],\n  bundle: true,\n  loader: { '.js': 'jsx' },\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Loader: map[string]api.Loader{\n      \".js\": api.LoaderJSX,\n    },\n    Write: true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n### Auto-import for JSX\n\nUsing JSX syntax usually requires you to manually import the JSX library you are using. For example, if you are using React, by default you will need to import React into each JSX file like this:\n\n``` javascript\nimport * as React from 'react'\nrender(<div/>)\n```\n\nThis is because the JSX transform turns JSX syntax into a call to `React.createElement` but it does not itself import anything, so the `React` variable is not automatically present.\n\nIf you would like to avoid having to manually `import` your JSX library into each file, you may be able to do this by setting esbuild's [JSX](../api/index#jsx) transform to `automatic`, which generates import statements for you. Keep in mind that this also completely changes how the JSX transform works, so it may break your code if you are using a JSX library that's not React. Doing that looks like this:\n\n``` sh\nesbuild app.jsx --jsx=automatic\n```\n\n``` javascript\nrequire('esbuild').buildSync({\n  entryPoints: ['app.jsx'],\n  jsx: 'automatic',\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.jsx\"},\n    JSX:         api.JSXAutomatic,\n    Outfile:     \"out.js\",\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n### Using JSX without React\n\nIf you're using JSX with a library other than React (such as [Preact](https://preactjs.com/)), you'll likely need to configure the [JSX factory](../api/index#jsx-factory) and [JSX fragment](../api/index#jsx-fragment) settings since they default to `React.createElement` and `React.Fragment` respectively:\n\n``` sh\nesbuild app.jsx --jsx-factory=h --jsx-fragment=Fragment\n```\n\n``` javascript\nrequire('esbuild').buildSync({\n  entryPoints: ['app.jsx'],\n  jsxFactory: 'h',\n  jsxFragment: 'Fragment',\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.jsx\"},\n    JSXFactory:  \"h\",\n    JSXFragment: \"Fragment\",\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nAlternatively, if you are using TypeScript, you can just configure JSX for TypeScript by adding this to your `tsconfig.json` file and esbuild should pick it up automatically without needing to be configured:\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"jsxFactory\": \"h\",\n    \"jsxFragmentFactory\": \"Fragment\"\n  }\n}\n```\n\nYou will also have to add `import {h, Fragment} from 'preact'` in files containing JSX syntax unless you use auto-importing as described above.\n\n## JSON\n\nLoader: `json`\n\nThis loader is enabled by default for `.json` files. It parses the JSON file into a JavaScript object at build time and exports the object as the default export. Using it looks something like this:\n\n``` javascript\nimport object from './example.json'\nconsole.log(object)\n```\n\nIn addition to the default export, there are also named exports for each top-level property in the JSON object. Importing a named export directly means esbuild can automatically remove unused parts of the JSON file from the bundle, leaving only the named exports that you actually used. For example, this code will only include the `version` field when bundled:\n\n``` javascript\nimport { version } from './package.json'\nconsole.log(version)\n```\n\n## CSS\n\nLoader: `css` (also `global-css` and `local-css` for [CSS modules](#local-css))\n\nThe `css` loader is enabled by default for `.css` files and the [`local-css`](#local-css) loader is enabled by default for `.module.css` files. These loaders load the file as CSS syntax. CSS is a first-class content type in esbuild, which means esbuild can [bundle](../api/index#bundle) CSS files directly without needing to import your CSS from JavaScript code:\n\n``` sh\nesbuild --bundle app.css --outfile=out.css\n```\n\n``` javascript\nrequire('esbuild').buildSync({\n  entryPoints: ['app.css'],\n  bundle: true,\n  outfile: 'out.css',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.css\"},\n    Bundle:      true,\n    Outfile:     \"out.css\",\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nYou can `@import` other CSS files and reference image and font files with `url()` and esbuild will bundle everything together. Note that you will have to configure a loader for image and font files, since esbuild doesn't have any pre-configured. Usually this is either the [data URL](#data-url) loader or the [external file](#external-file) loader.\n\nThese syntax features are conditionally transformed for older browsers depending on the configured language [target](../api/index#target):\n\n| Syntax transform                                                                                                                               | Example                                           |\n|------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|\n| [Nested declarations](https://www.w3.org/TR/css-nesting-1/)                                                                                    | `a { &:hover { color: red } }`                    |\n| [Modern RGB/HSL syntax](https://www.w3.org/TR/css-color-4/#hex-notation)                                                                       | `#F008`                                           |\n| [`inset` shorthand](https://developer.mozilla.org/en-US/docs/Web/CSS/Inset)                                                                    | `inset: 0`                                        |\n| [`hwb()`](https://www.w3.org/TR/css-color-4/#the-hwb-notation)                                                                                 | `hwb(120 30% 50%)`                                |\n| [`lab()` and `lch()`](https://www.w3.org/TR/css-color-4/#specifying-lab-lch)                                                                   | `lab(60 -5 58)`                                   |\n| [`oklab()` and `oklch()`](https://www.w3.org/TR/css-color-4/#specifying-oklab-oklch)                                                           | `oklab(0.5 -0.1 0.1)`                             |\n| [`color()`](https://www.w3.org/TR/css-color-4/#color-function)                                                                                 | `color(display-p3 1 0 0)`                         |\n| [Color stops with two positions](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images/Using_CSS_gradients#creating_color_bands_stripes) | `linear-gradient(red 2% 4%, blue)`                |\n| [Gradient transition hints](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images/Using_CSS_gradients#gradient_hints)                    | `linear-gradient(red, 20%, blue)` ¹               |\n| [Gradient color spaces](https://developer.mozilla.org/en-US/blog/css-color-module-level-4/#comparing_gradients_in_different_color_spaces)      | `linear-gradient(in hsl, red, blue)` ¹            |\n| [Gradient hue mode](https://developer.mozilla.org/en-US/blog/css-color-module-level-4/#using_hue_interpolation_modes_in_gradients)             | `linear-gradient(in hsl longer hue, red, blue)` ¹ |\n\n¹ This is demonstrated visually by esbuild's [gradient transformation tests](../gradient-tests/index).\n\nNote that by default, esbuild's output will take advantage of modern CSS features. For example, `color: rgba(255, 0, 0, 0.4)` will become `color: #f006` when minifying is enabled which makes use of syntax from [CSS Color Module Level 4](https://www.w3.org/TR/css-color-4/#changes-from-3). If this is undesired, you must specify esbuild's [target](../api/index#target) setting to say in which browsers you need the output to work correctly. Then esbuild will avoid using CSS features that are too modern for those browsers.\n\nWhen you provide a list of browser versions using the [target](../api/index#target) setting, esbuild will also automatically insert vendor prefixes so that your CSS will work in those browsers at those versions or newer. Currently esbuild will do this for the following CSS properties:\n\n- [`appearance`](https://caniuse.com/css-appearance)\n- [`backdrop-filter`](https://caniuse.com/css-backdrop-filter)\n- [`background-clip: text`](https://caniuse.com/background-clip-text)\n- [`box-decoration-break`](https://caniuse.com/css-boxdecorationbreak)\n- [`clip-path`](https://caniuse.com/css-clip-path)\n- [`font-kerning`](https://caniuse.com/font-kerning)\n- [`hyphens`](https://caniuse.com/css-hyphens)\n- [`initial-letter`](https://caniuse.com/css-initial-letter)\n- [`mask-composite`](https://caniuse.com/mdn-css_properties_mask-composite)\n- [`mask-image`](https://caniuse.com/mdn-css_properties_mask-image)\n- [`mask-origin`](https://caniuse.com/mdn-css_properties_mask-origin)\n- [`mask-position`](https://caniuse.com/mdn-css_properties_mask-position)\n- [`mask-repeat`](https://caniuse.com/mdn-css_properties_mask-repeat)\n- [`mask-size`](https://caniuse.com/mdn-css_properties_mask-size)\n- [`position: sticky`](https://caniuse.com/css-sticky)\n- [`print-color-adjust`](https://caniuse.com/css-color-adjust)\n- [`tab-size`](https://caniuse.com/css3-tabsize)\n- [`text-decoration-color`](https://caniuse.com/mdn-css_properties_text-decoration-color)\n- [`text-decoration-line`](https://caniuse.com/mdn-css_properties_text-decoration-line)\n- [`text-decoration-skip`](https://caniuse.com/mdn-css_properties_text-decoration-skip)\n- [`text-emphasis-color`](https://caniuse.com/mdn-css_properties_text-emphasis-color)\n- [`text-emphasis-position`](https://caniuse.com/mdn-css_properties_text-emphasis-position)\n- [`text-emphasis-style`](https://caniuse.com/mdn-css_properties_text-emphasis-style)\n- [`text-orientation`](https://caniuse.com/css-text-orientation)\n- [`text-size-adjust`](https://caniuse.com/text-size-adjust)\n- [`user-select`](https://caniuse.com/mdn-css_properties_user-select)\n\n### Import from JavaScript\n\nYou can also import CSS from JavaScript. When you do this, esbuild will gather all CSS files referenced from a given entry point and bundle it into a sibling CSS output file next to the JavaScript output file for that JavaScript entry point. So if esbuild generates `app.js` it would also generate `app.css` containing all CSS files referenced by `app.js`. Here's an example of importing a CSS file from JavaScript:\n\n``` javascript\nimport './button.css'\n\nexport let Button = ({ text }) =>\n  <div className=\"button\">{text}</div>\n```\n\nThe bundled JavaScript generated by esbuild will not automatically import the generated CSS into your HTML page for you. Instead, you should import the generated CSS into your HTML page yourself along with the generated JavaScript. This means the browser can download the CSS and JavaScript files in parallel, which is the most efficient way to do it. That looks like this:\n\n``` javascript\n<html>\n  <head>\n    <link href=\"app.css\" rel=\"stylesheet\">\n    <script src=\"app.js\"></script>\n  </head>\n</html>\n```\n\nIf the generated output names are not straightforward (for example if you have added `[hash]` to the [entry names](../api/index#entry-names) setting and the output file names have content hashes) then you will likely want to look up the generated output names in the [metafile](../api/index#metafile). To do this, first find the JS file by looking for the output with the matching `entryPoint` property. This file goes in the `<script>` tag. The associated CSS file can then be found using the `cssBundle` property. This file goes in the `<link>` tag.\n\n### CSS modules\n\n[CSS modules](https://github.com/css-modules/css-modules) is a CSS preprocessor technique to avoid unintentional CSS name collisions. CSS class names are normally global, but CSS modules provides a way to make CSS class names local to the file they appear in instead. If two separate CSS files use the same local class name `.button`, esbuild will automatically rename one of them so that they don't collide. This is analogous to how esbuild automatically renames local variables with the same name in separate JS modules to avoid name collisions.\n\nThere is support for bundling with CSS modules in esbuild. To use it, you need to enable [bundling](../api/index#bundle), use the `local-css` loader for your CSS file (e.g. by using the `.module.css` file extension), and then import your CSS module code into a JS file. Each local CSS name in that file can be imported into JS to get the name that esbuild renamed it to. Here's an example:\n\n``` javascript\n// app.js\nimport { outerShell } from './app.module.css'\nconst div = document.createElement('div')\ndiv.className = outerShell\ndocument.body.appendChild(div)\n```\n\n``` javascript\n/* app.module.css */\n.outerShell {\n  position: absolute;\n  inset: 0;\n}\n```\n\nWhen you bundle this with `esbuild app.js --bundle --outdir=out` you'll get this (notice how the local CSS name `outerShell` has been renamed):\n\n``` javascript\n// out/app.js\n(() => {\n  // app.module.css\n  var outerShell = \"app_outerShell\";\n\n  // app.js\n  var div = document.createElement(\"div\");\n  div.className = outerShell;\n  document.body.appendChild(div);\n})();\n```\n\n``` javascript\n/* out/app.css */\n.app_outerShell {\n  position: absolute;\n  inset: 0;\n}\n```\n\nThis feature only makes sense to use when bundling is enabled both because your code needs to `import` the renamed local names so that it can use them, and because esbuild needs to be able to process all CSS files containing local names in a single bundling operation so that it can successfully rename conflicting local names to avoid collisions.\n\nThe names that esbuild generates for local CSS names are an implementation detail and are not intended to be hard-coded anywhere. The only way you should be referencing the local CSS names in your JS or HTML is with an import statement in JS that is bundled with esbuild, as demonstrated above. For example, when [minification](../api/index#minify) is enabled, esbuild will use a different name generation algorithm which generates names that are as short as possible (analogous to how esbuild minifies local identifiers in JS).\n\n#### Using global names\n\nThe [`local-css`](#local-css) loader makes all CSS names in the file local by default. However, sometimes you want to mix local and global names in the same file. There are several ways to do this:\n\n- You can wrap class names in `:global(...)` make them global and `:local(...)` to make them local.\n- You can use `:global` to make names default to being global and `:local` to make names default to being local.\n- You can use the `global-css` loader to still have local CSS features enabled but have names default to being global.\n\nHere are some examples:\n\n``` javascript\n/*\n * This is a local name with the \"local-css\" loader\n * and a global name with the \"global-css\" loader\n */\n.button {\n}\n\n/* This is a local name with both loaders */\n:local(.button) {\n}\n\n/* This is a global name with both loaders */\n:global(.button) {\n}\n\n/* \"foo\" is global and \"bar\" is local */\n:global .foo :local .bar {\n}\n\n/* \"foo\" is global and \"bar\" is local */\n:global {\n  .foo {\n    :local {\n      .bar {}\n    }\n  }\n}\n```\n\n#### The `composes` directive\n\nThe [CSS modules specification](https://github.com/css-modules/css-modules#composition) also describes a `composes` directive. It allows class selectors with local names to reference other class selectors. This can be used to split out common sets of properties to avoid duplicating them. And with the `from` keyword, it can also be used to reference class selectors with local names in other files. Here's an example:\n\n``` javascript\n// app.js\nimport { submit } from './style.css'\nconst div = document.createElement('div')\ndiv.className = submit\ndocument.body.appendChild(div)\n```\n\n``` javascript\n/* style.css */\n.button {\n  composes: pulse from \"anim.css\";\n  display: inline-block;\n}\n.submit {\n  composes: button;\n  font-weight: bold;\n}\n```\n\n``` javascript\n/* anim.css */\n@keyframes pulse {\n  from, to { opacity: 1 }\n  50% { opacity: 0.5 }\n}\n.pulse {\n  animation: 2s ease-in-out infinite pulse;\n}\n```\n\nBundling this with `esbuild app.js --bundle --outdir=dist --loader:.css=local-css` will give you something like this:\n\n``` javascript\n(() => {\n  // style.css\n  var submit = \"anim_pulse style_button style_submit\";\n\n  // app.js\n  var div = document.createElement(\"div\");\n  div.className = submit;\n  document.body.appendChild(div);\n})();\n```\n\n``` javascript\n/* anim.css */\n@keyframes anim_pulse {\n  from, to {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0.5;\n  }\n}\n.anim_pulse {\n  animation: 2s ease-in-out infinite anim_pulse;\n}\n\n/* style.css */\n.style_button {\n  display: inline-block;\n}\n.style_submit {\n  font-weight: bold;\n}\n```\n\nNotice how using `composes` causes the string imported into JavaScript to become a space-separated list of all of the local names that were composed together. This is intended to be passed to the [`className`](https://developer.mozilla.org/en-US/docs/Web/API/Element/className) property on a DOM element. Also notice how using `composes` with `from` allows you to (indirectly) reference local names in other CSS files.\n\nNote that the order in which composed CSS classes from separate files appear in the bundled output file is deliberately *undefined* by design (see [the specification](https://github.com/css-modules/css-modules#composing-from-other-files) for details). You are not supposed to declare the same CSS property in two separate class selectors and then compose them together. You are only supposed to compose CSS class selectors that declare non-overlapping CSS properties.\n\n### CSS caveats\n\nYou should keep the following things in mind when using CSS with esbuild:\n\n#### Limited CSS verification\n\nCSS has a [general syntax specification](https://www.w3.org/TR/css-syntax-3/) that all CSS processors use and then [many specifications](https://www.w3.org/Style/CSS/current-work) that define what specific CSS rules mean. While esbuild understands general CSS syntax and can understand some CSS rules (enough to bundle CSS file together and to minify CSS reasonably well), esbuild does not contain complete knowledge of CSS. This means esbuild takes a \"garbage in, garbage out\" philosophy toward CSS. If you want to verify that your compiled CSS is free of typos, you should be using a CSS linter in addition to esbuild.\n\n#### `@import` order matches the browser\n\nThe `@import` rule in CSS behaves differently than the `import` keyword in JavaScript. In JavaScript, an `import` means roughly \"make sure the imported file is evaluated before this file is evaluated\" but in CSS, `@import` means roughly \"re-evaluate the imported file again here\" instead. For example, consider the following files:\n\n- `entry.css`\n\n  ``` javascript\n  @import \"foreground.css\";@import \"background.css\";\n  ```\n\n- `foreground.css`\n\n  ``` javascript\n  @import \"reset.css\";body {  color: white;}\n  ```\n\n- `background.css`\n\n  ``` javascript\n  @import \"reset.css\";body {  background: black;}\n  ```\n\n- `reset.css`\n\n  ``` javascript\n  body {  color: black;  background: white;}\n  ```\n\nUsing your intuition from JavaScript, you might think that this code first resets the body to black text on a white background, and then overrides that to white text on a black background. ***This is not what happens.*** Instead, the body will be entirely black (both the foreground and the background). This is because `@import` is supposed to behave as if the import rule was replaced by the imported file (sort of like `#include` in C/C++), which leads to the browser seeing the following code:\n\n``` javascript\n/* reset.css */\nbody {\n  color: black;\n  background: white;\n}\n\n/* foreground.css */\nbody {\n  color: white;\n}\n\n/* reset.css */\nbody {\n  color: black;\n  background: white;\n}\n\n/* background.css */\nbody {\n  background: black;\n}\n```\n\nwhich ultimately reduces down to this:\n\n``` javascript\nbody {\n  color: black;\n  background: black;\n}\n```\n\nThis behavior is unfortunate, but esbuild behaves this way because that's how CSS is specified, and that's how CSS works in browsers. This is important to know about because some other commonly-used CSS processing tools such as [`postcss-import`](https://github.com/postcss/postcss-import/issues/462) incorrectly resolve CSS imports in JavaScript order instead of in CSS order. If you are porting CSS code written for those tools to esbuild (or even just switching over to running your CSS code natively in the browser), you may have appearance changes if your code depends on the incorrect import order.\n\n## Text\n\nLoader: `text`\n\nThis loader is enabled by default for `.txt` files. It loads the file as a string at build time and exports the string as the default export. Using it looks something like this:\n\n``` javascript\nimport string from './example.txt'\nconsole.log(string)\n```\n\n## Binary\n\nLoader: `binary`\n\nThis loader will load the file as a binary buffer at build time and embed it into the bundle using Base64 encoding. The original bytes of the file are decoded from Base64 at run time and exported as a `Uint8Array` using the default export. Using it looks like this:\n\n``` javascript\nimport uint8array from './example.data'\nconsole.log(uint8array)\n```\n\nIf you need an `ArrayBuffer` instead, you can just access `uint8array.buffer`. Note that this loader is not enabled by default. You will need to configure it for the appropriate file extension like this:\n\n``` sh\nesbuild app.js --bundle --loader:.data=binary\n```\n\n``` javascript\nrequire('esbuild').buildSync({\n  entryPoints: ['app.js'],\n  bundle: true,\n  loader: { '.data': 'binary' },\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Loader: map[string]api.Loader{\n      \".data\": api.LoaderBinary,\n    },\n    Write: true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n## Base64\n\nLoader: `base64`\n\nThis loader will load the file as a binary buffer at build time and embed it into the bundle as a string using Base64 encoding. This string is exported using the default export. Using it looks like this:\n\n``` javascript\nimport base64string from './example.data'\nconsole.log(base64string)\n```\n\nNote that this loader is not enabled by default. You will need to configure it for the appropriate file extension like this:\n\n``` sh\nesbuild app.js --bundle --loader:.data=base64\n```\n\n``` javascript\nrequire('esbuild').buildSync({\n  entryPoints: ['app.js'],\n  bundle: true,\n  loader: { '.data': 'base64' },\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Loader: map[string]api.Loader{\n      \".data\": api.LoaderBase64,\n    },\n    Write: true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nIf you intend to turn this into a `Uint8Array` or an `ArrayBuffer`, you should use the `binary` loader instead. It uses an optimized Base64-to-binary converter that is faster than the usual `atob` conversion process.\n\n## Data URL\n\nLoader: `dataurl`\n\nThis loader will load the file as a binary buffer at build time and embed it into the bundle as a Base64-encoded data URL. This string is exported using the default export. Using it looks like this:\n\n``` javascript\nimport url from './example.png'\nlet image = new Image\nimage.src = url\ndocument.body.appendChild(image)\n```\n\nThe data URL includes a best guess at the MIME type based on the file extension and/or the file contents, and will look something like this for binary data:\n\n``` javascript\ndata:image/png;base64,iVBORw0KGgo=\n```\n\n...or like this for textual data:\n\n``` javascript\ndata:image/svg+xml,<svg></svg>%0A\n```\n\nNote that this loader is not enabled by default. You will need to configure it for the appropriate file extension like this:\n\n``` sh\nesbuild app.js --bundle --loader:.png=dataurl\n```\n\n``` javascript\nrequire('esbuild').buildSync({\n  entryPoints: ['app.js'],\n  bundle: true,\n  loader: { '.png': 'dataurl' },\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Loader: map[string]api.Loader{\n      \".png\": api.LoaderDataURL,\n    },\n    Write: true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\n## External file\n\nThere are two different loaders that can be used for external files depending on the behavior you're looking for. Both loaders are described below:\n\n#### The `file` loader\n\nLoader: `file`\n\nThis loader will copy the file to the output directory and embed the file name into the bundle as a string. This string is exported using the default export. Using it looks like this:\n\n``` javascript\nimport url from './example.png'\nlet image = new Image\nimage.src = url\ndocument.body.appendChild(image)\n```\n\nThis behavior is intentionally similar to Webpack's [`file-loader`](https://v4.webpack.js.org/loaders/file-loader/) package. Note that this loader is not enabled by default. You will need to configure it for the appropriate file extension like this:\n\n``` sh\nesbuild app.js --bundle --loader:.png=file --outdir=out\n```\n\n``` javascript\nrequire('esbuild').buildSync({\n  entryPoints: ['app.js'],\n  bundle: true,\n  loader: { '.png': 'file' },\n  outdir: 'out',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Loader: map[string]api.Loader{\n      \".png\": api.LoaderFile,\n    },\n    Outdir: \"out\",\n    Write:  true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nBy default the exported string is just the file name. If you would like to prepend a base path to the exported string, this can be done with the [public path](../api/index#public-path) API option.\n\n#### The `copy` loader\n\nLoader: `copy`\n\nThis loader will copy the file to the output directory and rewrite the import path to point to the copied file. This means the import will still exist in the final bundle and the final bundle will still reference the file instead of including the file inside the bundle. This might be useful if you are running additional bundling tools on esbuild's output, if you want to omit a rarely-used data file from the bundle for faster startup performance, or if you want to rely on specific behavior of your runtime that's triggered by an import. For example:\n\n``` javascript\nimport json from './example.json' assert { type: 'json' }\nconsole.log(json)\n```\n\nIf you bundle the above code with the following command:\n\n``` sh\nesbuild app.js --bundle --loader:.json=copy --outdir=out --format=esm\n```\n\n``` javascript\nrequire('esbuild').buildSync({\n  entryPoints: ['app.js'],\n  bundle: true,\n  loader: { '.json': 'copy' },\n  outdir: 'out',\n  format: 'esm',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Loader: map[string]api.Loader{\n      \".json\": api.LoaderCopy,\n    },\n    Outdir: \"out\",\n    Write:  true,\n    Format: api.FormatESModule,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nthe resulting `out/app.js` file might look something like this:\n\n``` javascript\n// app.js\nimport json from \"./example-PVCBWCM4.json\" assert { type: \"json\" };\nconsole.log(json);\n```\n\nNotice how the import path has been rewritten to point to the copied file `out/example-PVCBWCM4.json` (a content hash has been added due to the default value of the [asset names](../api/index#asset-names) setting), and how the [import assertion](https://v8.dev/features/import-assertions) for JSON has been kept so the runtime will be able to load the JSON file.\n\n## Empty file\n\nLoader: `empty`\n\nThis loader tells esbuild to pretend that a file is empty. It can be a helpful way to remove content from your bundle in certain situations. For example, you can configure `.css` files to load with `empty` to prevent esbuild from bundling CSS files that are imported into JavaScript files:\n\n``` sh\nesbuild app.js --bundle --loader:.css=empty\n```\n\n``` javascript\nrequire('esbuild').buildSync({\n  entryPoints: ['app.js'],\n  bundle: true,\n  loader: { '.css': 'empty' },\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Loader: map[string]api.Loader{\n      \".css\": api.LoaderEmpty,\n    },\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThis loader also lets you remove imported assets from CSS files. For example, you can configure `.png` files to load with `empty` so that references to `.png` files in CSS code such as `url(image.png)` are replaced with `url()`.\n\n© 2020 Evan Wallace  \nLicensed under the MIT License.  \n[https://esbuild.github.io/content-types/](https://esbuild.github.io/content-types/)"
- name: CSS
  id: content-types/index#css
  summary: The css loader is enabled by default for .css files and the local-css loader is enabled by default for .module.css files
  belongs_to: Content Types
  description: |-
    ## CSS

    Loader: `css` (also `global-css` and `local-css` for [CSS modules](#local-css))

    The `css` loader is enabled by default for `.css` files and the [`local-css`](#local-css) loader is enabled by default for `.module.css` files. These loaders load the file as CSS syntax. CSS is a first-class content type in esbuild, which means esbuild can [bundle](../api/index#bundle) CSS files directly without needing to import your CSS from JavaScript code:

    ``` sh
    esbuild --bundle app.css --outfile=out.css
    ```

    ``` javascript
    require('esbuild').buildSync({
      entryPoints: ['app.css'],
      bundle: true,
      outfile: 'out.css',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.css"},
        Bundle:      true,
        Outfile:     "out.css",
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    You can `@import` other CSS files and reference image and font files with `url()` and esbuild will bundle everything together. Note that you will have to configure a loader for image and font files, since esbuild doesn't have any pre-configured. Usually this is either the [data URL](#data-url) loader or the [external file](#external-file) loader.

    These syntax features are conditionally transformed for older browsers depending on the configured language [target](../api/index#target):

    | Syntax transform                                                                                                                               | Example                                           |
    |------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|
    | [Nested declarations](https://www.w3.org/TR/css-nesting-1/)                                                                                    | `a { &:hover { color: red } }`                    |
    | [Modern RGB/HSL syntax](https://www.w3.org/TR/css-color-4/#hex-notation)                                                                       | `#F008`                                           |
    | [`inset` shorthand](https://developer.mozilla.org/en-US/docs/Web/CSS/Inset)                                                                    | `inset: 0`                                        |
    | [`hwb()`](https://www.w3.org/TR/css-color-4/#the-hwb-notation)                                                                                 | `hwb(120 30% 50%)`                                |
    | [`lab()` and `lch()`](https://www.w3.org/TR/css-color-4/#specifying-lab-lch)                                                                   | `lab(60 -5 58)`                                   |
    | [`oklab()` and `oklch()`](https://www.w3.org/TR/css-color-4/#specifying-oklab-oklch)                                                           | `oklab(0.5 -0.1 0.1)`                             |
    | [`color()`](https://www.w3.org/TR/css-color-4/#color-function)                                                                                 | `color(display-p3 1 0 0)`                         |
    | [Color stops with two positions](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images/Using_CSS_gradients#creating_color_bands_stripes) | `linear-gradient(red 2% 4%, blue)`                |
    | [Gradient transition hints](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images/Using_CSS_gradients#gradient_hints)                    | `linear-gradient(red, 20%, blue)` ¹               |
    | [Gradient color spaces](https://developer.mozilla.org/en-US/blog/css-color-module-level-4/#comparing_gradients_in_different_color_spaces)      | `linear-gradient(in hsl, red, blue)` ¹            |
    | [Gradient hue mode](https://developer.mozilla.org/en-US/blog/css-color-module-level-4/#using_hue_interpolation_modes_in_gradients)             | `linear-gradient(in hsl longer hue, red, blue)` ¹ |

    ¹ This is demonstrated visually by esbuild's [gradient transformation tests](../gradient-tests/index).

    Note that by default, esbuild's output will take advantage of modern CSS features. For example, `color: rgba(255, 0, 0, 0.4)` will become `color: #f006` when minifying is enabled which makes use of syntax from [CSS Color Module Level 4](https://www.w3.org/TR/css-color-4/#changes-from-3). If this is undesired, you must specify esbuild's [target](../api/index#target) setting to say in which browsers you need the output to work correctly. Then esbuild will avoid using CSS features that are too modern for those browsers.

    When you provide a list of browser versions using the [target](../api/index#target) setting, esbuild will also automatically insert vendor prefixes so that your CSS will work in those browsers at those versions or newer. Currently esbuild will do this for the following CSS properties:

    - [`appearance`](https://caniuse.com/css-appearance)
    - [`backdrop-filter`](https://caniuse.com/css-backdrop-filter)
    - [`background-clip: text`](https://caniuse.com/background-clip-text)
    - [`box-decoration-break`](https://caniuse.com/css-boxdecorationbreak)
    - [`clip-path`](https://caniuse.com/css-clip-path)
    - [`font-kerning`](https://caniuse.com/font-kerning)
    - [`hyphens`](https://caniuse.com/css-hyphens)
    - [`initial-letter`](https://caniuse.com/css-initial-letter)
    - [`mask-composite`](https://caniuse.com/mdn-css_properties_mask-composite)
    - [`mask-image`](https://caniuse.com/mdn-css_properties_mask-image)
    - [`mask-origin`](https://caniuse.com/mdn-css_properties_mask-origin)
    - [`mask-position`](https://caniuse.com/mdn-css_properties_mask-position)
    - [`mask-repeat`](https://caniuse.com/mdn-css_properties_mask-repeat)
    - [`mask-size`](https://caniuse.com/mdn-css_properties_mask-size)
    - [`position: sticky`](https://caniuse.com/css-sticky)
    - [`print-color-adjust`](https://caniuse.com/css-color-adjust)
    - [`tab-size`](https://caniuse.com/css3-tabsize)
    - [`text-decoration-color`](https://caniuse.com/mdn-css_properties_text-decoration-color)
    - [`text-decoration-line`](https://caniuse.com/mdn-css_properties_text-decoration-line)
    - [`text-decoration-skip`](https://caniuse.com/mdn-css_properties_text-decoration-skip)
    - [`text-emphasis-color`](https://caniuse.com/mdn-css_properties_text-emphasis-color)
    - [`text-emphasis-position`](https://caniuse.com/mdn-css_properties_text-emphasis-position)
    - [`text-emphasis-style`](https://caniuse.com/mdn-css_properties_text-emphasis-style)
    - [`text-orientation`](https://caniuse.com/css-text-orientation)
    - [`text-size-adjust`](https://caniuse.com/text-size-adjust)
    - [`user-select`](https://caniuse.com/mdn-css_properties_user-select)
- name: CSS caveats
  id: content-types/index#css-caveats
  summary: CSS has a general syntax specification that all CSS processors use and then many specifications that define what specific CSS rules mean
  belongs_to: Content Types
  description: |-
    ### CSS caveats

    You should keep the following things in mind when using CSS with esbuild:

    #### Limited CSS verification

    CSS has a [general syntax specification](https://www.w3.org/TR/css-syntax-3/) that all CSS processors use and then [many specifications](https://www.w3.org/Style/CSS/current-work) that define what specific CSS rules mean. While esbuild understands general CSS syntax and can understand some CSS rules (enough to bundle CSS file together and to minify CSS reasonably well), esbuild does not contain complete knowledge of CSS. This means esbuild takes a "garbage in, garbage out" philosophy toward CSS. If you want to verify that your compiled CSS is free of typos, you should be using a CSS linter in addition to esbuild.

    #### `@import` order matches the browser

    The `@import` rule in CSS behaves differently than the `import` keyword in JavaScript. In JavaScript, an `import` means roughly "make sure the imported file is evaluated before this file is evaluated" but in CSS, `@import` means roughly "re-evaluate the imported file again here" instead. For example, consider the following files:

    - `entry.css`

      ``` javascript
      @import "foreground.css";@import "background.css";
      ```

    - `foreground.css`

      ``` javascript
      @import "reset.css";body {  color: white;}
      ```

    - `background.css`

      ``` javascript
      @import "reset.css";body {  background: black;}
      ```

    - `reset.css`

      ``` javascript
      body {  color: black;  background: white;}
      ```

    Using your intuition from JavaScript, you might think that this code first resets the body to black text on a white background, and then overrides that to white text on a black background. ***This is not what happens.*** Instead, the body will be entirely black (both the foreground and the background). This is because `@import` is supposed to behave as if the import rule was replaced by the imported file (sort of like `#include` in C/C++), which leads to the browser seeing the following code:

    ``` javascript
    /* reset.css */
    body {
      color: black;
      background: white;
    }

    /* foreground.css */
    body {
      color: white;
    }

    /* reset.css */
    body {
      color: black;
      background: white;
    }

    /* background.css */
    body {
      background: black;
    }
    ```

    which ultimately reduces down to this:

    ``` javascript
    body {
      color: black;
      background: black;
    }
    ```

    This behavior is unfortunate, but esbuild behaves this way because that's how CSS is specified, and that's how CSS works in browsers. This is important to know about because some other commonly-used CSS processing tools such as [`postcss-import`](https://github.com/postcss/postcss-import/issues/462) incorrectly resolve CSS imports in JavaScript order instead of in CSS order. If you are porting CSS code written for those tools to esbuild (or even just switching over to running your CSS code natively in the browser), you may have appearance changes if your code depends on the incorrect import order.
- name: CSS modules
  id: content-types/index#local-css
  summary: CSS modules is a CSS preprocessor technique to avoid unintentional CSS name collisions
  belongs_to: Content Types
  description: |-
    ### CSS modules

    [CSS modules](https://github.com/css-modules/css-modules) is a CSS preprocessor technique to avoid unintentional CSS name collisions. CSS class names are normally global, but CSS modules provides a way to make CSS class names local to the file they appear in instead. If two separate CSS files use the same local class name `.button`, esbuild will automatically rename one of them so that they don't collide. This is analogous to how esbuild automatically renames local variables with the same name in separate JS modules to avoid name collisions.

    There is support for bundling with CSS modules in esbuild. To use it, you need to enable [bundling](../api/index#bundle), use the `local-css` loader for your CSS file (e.g. by using the `.module.css` file extension), and then import your CSS module code into a JS file. Each local CSS name in that file can be imported into JS to get the name that esbuild renamed it to. Here's an example:

    ``` javascript
    // app.js
    import { outerShell } from './app.module.css'
    const div = document.createElement('div')
    div.className = outerShell
    document.body.appendChild(div)
    ```

    ``` javascript
    /* app.module.css */
    .outerShell {
      position: absolute;
      inset: 0;
    }
    ```

    When you bundle this with `esbuild app.js --bundle --outdir=out` you'll get this (notice how the local CSS name `outerShell` has been renamed):

    ``` javascript
    // out/app.js
    (() => {
      // app.module.css
      var outerShell = "app_outerShell";

      // app.js
      var div = document.createElement("div");
      div.className = outerShell;
      document.body.appendChild(div);
    })();
    ```

    ``` javascript
    /* out/app.css */
    .app_outerShell {
      position: absolute;
      inset: 0;
    }
    ```

    This feature only makes sense to use when bundling is enabled both because your code needs to `import` the renamed local names so that it can use them, and because esbuild needs to be able to process all CSS files containing local names in a single bundling operation so that it can successfully rename conflicting local names to avoid collisions.

    The names that esbuild generates for local CSS names are an implementation detail and are not intended to be hard-coded anywhere. The only way you should be referencing the local CSS names in your JS or HTML is with an import statement in JS that is bundled with esbuild, as demonstrated above. For example, when [minification](../api/index#minify) is enabled, esbuild will use a different name generation algorithm which generates names that are as short as possible (analogous to how esbuild minifies local identifiers in JS).

    #### Using global names

    The [`local-css`](#local-css) loader makes all CSS names in the file local by default. However, sometimes you want to mix local and global names in the same file. There are several ways to do this:

    - You can wrap class names in `:global(...)` make them global and `:local(...)` to make them local.
    - You can use `:global` to make names default to being global and `:local` to make names default to being local.
    - You can use the `global-css` loader to still have local CSS features enabled but have names default to being global.

    Here are some examples:

    ``` javascript
    /*
     * This is a local name with the "local-css" loader
     * and a global name with the "global-css" loader
     */
    .button {
    }

    /* This is a local name with both loaders */
    :local(.button) {
    }

    /* This is a global name with both loaders */
    :global(.button) {
    }

    /* "foo" is global and "bar" is local */
    :global .foo :local .bar {
    }

    /* "foo" is global and "bar" is local */
    :global {
      .foo {
        :local {
          .bar {}
        }
      }
    }
    ```

    #### The `composes` directive

    The [CSS modules specification](https://github.com/css-modules/css-modules#composition) also describes a `composes` directive. It allows class selectors with local names to reference other class selectors. This can be used to split out common sets of properties to avoid duplicating them. And with the `from` keyword, it can also be used to reference class selectors with local names in other files. Here's an example:

    ``` javascript
    // app.js
    import { submit } from './style.css'
    const div = document.createElement('div')
    div.className = submit
    document.body.appendChild(div)
    ```

    ``` javascript
    /* style.css */
    .button {
      composes: pulse from "anim.css";
      display: inline-block;
    }
    .submit {
      composes: button;
      font-weight: bold;
    }
    ```

    ``` javascript
    /* anim.css */
    @keyframes pulse {
      from, to { opacity: 1 }
      50% { opacity: 0.5 }
    }
    .pulse {
      animation: 2s ease-in-out infinite pulse;
    }
    ```

    Bundling this with `esbuild app.js --bundle --outdir=dist --loader:.css=local-css` will give you something like this:

    ``` javascript
    (() => {
      // style.css
      var submit = "anim_pulse style_button style_submit";

      // app.js
      var div = document.createElement("div");
      div.className = submit;
      document.body.appendChild(div);
    })();
    ```

    ``` javascript
    /* anim.css */
    @keyframes anim_pulse {
      from, to {
        opacity: 1;
      }
      50% {
        opacity: 0.5;
      }
    }
    .anim_pulse {
      animation: 2s ease-in-out infinite anim_pulse;
    }

    /* style.css */
    .style_button {
      display: inline-block;
    }
    .style_submit {
      font-weight: bold;
    }
    ```

    Notice how using `composes` causes the string imported into JavaScript to become a space-separated list of all of the local names that were composed together. This is intended to be passed to the [`className`](https://developer.mozilla.org/en-US/docs/Web/API/Element/className) property on a DOM element. Also notice how using `composes` with `from` allows you to (indirectly) reference local names in other CSS files.

    Note that the order in which composed CSS classes from separate files appear in the bundled output file is deliberately *undefined* by design (see [the specification](https://github.com/css-modules/css-modules#composing-from-other-files) for details). You are not supposed to declare the same CSS property in two separate class selectors and then compose them together. You are only supposed to compose CSS class selectors that declare non-overlapping CSS properties.
- name: Data URL
  id: content-types/index#data-url
  summary: This loader will load the file as a binary buffer at build time and embed it into the bundle as a Base64-encoded data URL
  belongs_to: Content Types
  description: |-
    ## Data URL

    Loader: `dataurl`

    This loader will load the file as a binary buffer at build time and embed it into the bundle as a Base64-encoded data URL. This string is exported using the default export. Using it looks like this:

    ``` javascript
    import url from './example.png'
    let image = new Image
    image.src = url
    document.body.appendChild(image)
    ```

    The data URL includes a best guess at the MIME type based on the file extension and/or the file contents, and will look something like this for binary data:

    ``` javascript
    data:image/png;base64,iVBORw0KGgo=
    ```

    ...or like this for textual data:

    ``` javascript
    data:image/svg+xml,<svg></svg>%0A
    ```

    Note that this loader is not enabled by default. You will need to configure it for the appropriate file extension like this:

    ``` sh
    esbuild app.js --bundle --loader:.png=dataurl
    ```

    ``` javascript
    require('esbuild').buildSync({
      entryPoints: ['app.js'],
      bundle: true,
      loader: { '.png': 'dataurl' },
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Loader: map[string]api.Loader{
          ".png": api.LoaderDataURL,
        },
        Write: true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Define
  id: api/index#define
  summary: This feature provides a way to replace global identifiers with constant expressions
  belongs_to: API
  description: |-
    ### Define

    *Supported by: [Build](#build) and [Transform](#transform)*

    This feature provides a way to replace global identifiers with constant expressions. It can be a way to change the behavior some code between builds without changing the code itself:

    ``` sh
    echo 'hooks = DEBUG && require("hooks")' | esbuild --define:DEBUG=true
    hooks = require("hooks");
    echo 'hooks = DEBUG && require("hooks")' | esbuild --define:DEBUG=false
    hooks = false;
    ```

    ``` javascript
    import * as esbuild from 'esbuild'let js = 'hooks = DEBUG && require("hooks")'(await esbuild.transform(js, {
      define: { DEBUG: 'true' },
    })).code
    'hooks = require("hooks");\n'
    (await esbuild.transform(js, {
      define: { DEBUG: 'false' },
    })).code
    'hooks = false;\n'
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      js := "hooks = DEBUG && require('hooks')"

      result1 := api.Transform(js, api.TransformOptions{
        Define: map[string]string{"DEBUG": "true"},
      })

      if len(result1.Errors) == 0 {
        fmt.Printf("%s", result1.Code)
      }

      result2 := api.Transform(js, api.TransformOptions{
        Define: map[string]string{"DEBUG": "false"},
      })

      if len(result2.Errors) == 0 {
        fmt.Printf("%s", result2.Code)
      }
    }
    ```

    Each `define` entry maps an identifier to a string of code containing an expression. The expression in the string must either be a JSON object (null, boolean, number, string, array, or object) or a single identifier. Replacement expressions other than arrays and objects are substituted inline, which means that they can participate in constant folding. Array and object replacement expressions are stored in a variable and then referenced using an identifier instead of being substituted inline, which avoids substituting repeated copies of the value but means that the values don't participate in constant folding.

    If you want to replace something with a string literal, keep in mind that the replacement value passed to esbuild must itself contain quotes because each `define` entry maps to a string containing code. Omitting the quotes means the replacement value is an identifier instead. This is demonstrated in the example below:

    ``` sh
    echo 'id, str' | esbuild --define:id=text --define:str=\"text\"
    text, "text";
    ```

    ``` javascript
    import * as esbuild from 'esbuild'(await esbuild.transform('id, str', {
      define: { id: 'text', str: '"text"' },
    })).code
    'text, "text";\n'
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      result := api.Transform("id, text", api.TransformOptions{
        Define: map[string]string{
          "id":  "text",
          "str": "\"text\"",
        },
      })

      if len(result.Errors) == 0 {
        fmt.Printf("%s", result.Code)
      }
    }
    ```

    If you're using the CLI, keep in mind that different shells have different rules for how to escape double-quote characters (which are necessary when the replacement value is a string). Use a `\"` backslash escape because it works in both bash and Windows command prompt. Other methods of escaping double quotes that work in bash such as surrounding them with single quotes will not work on Windows, since Windows command prompt does not remove the single quotes. This is relevant when using the CLI from a npm script in your `package.json` file, which people will expect to work on all platforms:

    ``` javascript
    {
      "scripts": {
        "build": "esbuild --define:process.env.NODE_ENV=\\\"production\\\" app.js"
      }
    }
    ```

    If you still run into cross-platform quote escaping issues with different shells, you will probably want to switch to using the [JavaScript API](index) instead. There you can use regular JavaScript syntax to eliminate cross-platform differences.

    If you're looking for a more advanced form of the define feature that can replace an expression with something other than a constant (e.g. replacing a global variable with a shim), you may be able to use the similar [inject](#inject) feature to do that.
- name: Deno instead of node
  id: getting-started/index#deno
  summary: There is also basic support for the Deno JavaScript environment if you'd like to use esbuild with that instead
  belongs_to: Getting Started
  description: |-
    ### Deno instead of node

    There is also basic support for the [Deno](https://deno.land) JavaScript environment if you'd like to use esbuild with that instead. The package is hosted at <https://deno.land/x/esbuild> and uses the native esbuild executable. The executable will be downloaded and cached from npm at run-time so your computer will need network access to registry.npmjs.org to make use of this package. Using the package looks like this:

    ``` javascript
    import * as esbuild from 'https://deno.land/x/esbuild@v0.23.0/mod.js'
    let ts = 'let test: boolean = true'
    let result = await esbuild.transform(ts, { loader: 'ts' })
    console.log('result:', result)
    await esbuild.stop()
    ```

    It has basically the same API as esbuild's npm package with one addition: you need to call `stop()` when you're done because unlike node, Deno doesn't provide the necessary APIs to allow Deno to exit while esbuild's internal child process is still running.

    If you would like to use esbuild's WebAssembly implementation instead of esbuild's native implementation with Deno, you can do that by importing `wasm.js` instead of `mod.js` like this:

    ``` javascript
    import * as esbuild from 'https://deno.land/x/esbuild@v0.23.0/wasm.js'
    let ts = 'let test: boolean = true'
    let result = await esbuild.transform(ts, { loader: 'ts' })
    console.log('result:', result)
    await esbuild.stop()
    ```

    Using WebAssembly instead of native means you do not need to specify Deno's `--allow-run` permission, and WebAssembly the only option in situations where the file system is unavailable such as with [Deno Deploy](https://deno.com/deploy). However, keep in mind that the WebAssembly version of esbuild is a lot slower than the native version. Another thing to know about WebAssembly is that Deno currently has a bug where process termination is unnecessarily delayed until all loaded WebAssembly modules are fully optimized, which can take many seconds. You may want to manually call `Deno.exit(0)` after your code is done if you are writing a short-lived script that uses esbuild's WebAssembly implementation so that your code exits in a reasonable timeframe.

    **Why this is not recommended:** Deno is newer than node, less widely used, and supports fewer platforms than node, so node is recommended as the primary way to run esbuild. Deno also uses the internet as a package system instead of existing JavaScript package ecosystems, and esbuild is designed around and optimized for npm-style package management. You should still be able to use esbuild with Deno, but you will need a plugin if you would like to be able to bundle HTTP URLs.
- name: Download a build
  id: getting-started/index#download-a-build
  summary: If you don't want to evaluate a shell script from the internet to download esbuild, you can also manually download the package from npm yourself instead (which is all the above shell script is doing)
  belongs_to: Getting Started
  description: "### Download a build\n\nIf you have a Unix system, you can use the following command to download the `esbuild` binary executable for your current platform (it will be downloaded to the current working directory):\n\n``` javascript\ncurl -fsSL https://esbuild.github.io/dl/v0.23.0 | sh\n```\n\nYou can also use `latest` instead of the version number to download the most recent version of esbuild:\n\n``` javascript\ncurl -fsSL https://esbuild.github.io/dl/latest | sh\n```\n\nIf you don't want to evaluate a shell script from the internet to download esbuild, you can also manually download the package from npm yourself instead (which is all the above shell script is doing). Although the precompiled native executables are hosted using npm, you don't actually need npm installed to download them. The npm package registry is a normal HTTP server and packages are normal gzipped tar files.\n\nHere is an example of downloading a binary executable directly:\n\n``` sh\ncurl -O https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.23.0.tgz\ntar xzf ./darwin-x64-0.23.0.tgz\n./package/bin/esbuild\nUsage:\n  esbuild [options] [entry points]\n\n...\n```\n\nThe native executable in the `@esbuild/darwin-x64` package is for the macOS operating system and the 64-bit Intel architecture. As of writing, this is the full list of native executable packages for the platforms esbuild supports:\n\n| Package name                                                                       | OS         | Architecture | Download |\n|------------------------------------------------------------------------------------|------------|--------------|----------|\n| [`@esbuild/aix-ppc64`](https://www.npmjs.org/package/@esbuild/aix-ppc64)           | `aix`      | `ppc64`      |          |\n| [`@esbuild/android-arm`](https://www.npmjs.org/package/@esbuild/android-arm)       | `android`  | `arm`        |          |\n| [`@esbuild/android-arm64`](https://www.npmjs.org/package/@esbuild/android-arm64)   | `android`  | `arm64`      |          |\n| [`@esbuild/android-x64`](https://www.npmjs.org/package/@esbuild/android-x64)       | `android`  | `x64`        |          |\n| [`@esbuild/darwin-arm64`](https://www.npmjs.org/package/@esbuild/darwin-arm64)     | `darwin`   | `arm64`      |          |\n| [`@esbuild/darwin-x64`](https://www.npmjs.org/package/@esbuild/darwin-x64)         | `darwin`   | `x64`        |          |\n| [`@esbuild/freebsd-arm64`](https://www.npmjs.org/package/@esbuild/freebsd-arm64)   | `freebsd`  | `arm64`      |          |\n| [`@esbuild/freebsd-x64`](https://www.npmjs.org/package/@esbuild/freebsd-x64)       | `freebsd`  | `x64`        |          |\n| [`@esbuild/linux-arm`](https://www.npmjs.org/package/@esbuild/linux-arm)           | `linux`    | `arm`        |          |\n| [`@esbuild/linux-arm64`](https://www.npmjs.org/package/@esbuild/linux-arm64)       | `linux`    | `arm64`      |          |\n| [`@esbuild/linux-ia32`](https://www.npmjs.org/package/@esbuild/linux-ia32)         | `linux`    | `ia32`       |          |\n| [`@esbuild/linux-loong64`](https://www.npmjs.org/package/@esbuild/linux-loong64)   | `linux`    | `loong64` ²  |          |\n| [`@esbuild/linux-mips64el`](https://www.npmjs.org/package/@esbuild/linux-mips64el) | `linux`    | `mips64el` ² |          |\n| [`@esbuild/linux-ppc64`](https://www.npmjs.org/package/@esbuild/linux-ppc64)       | `linux`    | `ppc64`      |          |\n| [`@esbuild/linux-riscv64`](https://www.npmjs.org/package/@esbuild/linux-riscv64)   | `linux`    | `riscv64` ²  |          |\n| [`@esbuild/linux-s390x`](https://www.npmjs.org/package/@esbuild/linux-s390x)       | `linux`    | `s390x`      |          |\n| [`@esbuild/linux-x64`](https://www.npmjs.org/package/@esbuild/linux-x64)           | `linux`    | `x64`        |          |\n| [`@esbuild/netbsd-x64`](https://www.npmjs.org/package/@esbuild/netbsd-x64)         | `netbsd` ¹ | `x64`        |          |\n| [`@esbuild/openbsd-arm64`](https://www.npmjs.org/package/@esbuild/openbsd-arm64)   | `openbsd`  | `arm64`      |          |\n| [`@esbuild/openbsd-x64`](https://www.npmjs.org/package/@esbuild/openbsd-x64)       | `openbsd`  | `x64`        |          |\n| [`@esbuild/sunos-x64`](https://www.npmjs.org/package/@esbuild/sunos-x64)           | `sunos`    | `x64`        |          |\n| [`@esbuild/win32-arm64`](https://www.npmjs.org/package/@esbuild/win32-arm64)       | `win32`    | `arm64`      |          |\n| [`@esbuild/win32-ia32`](https://www.npmjs.org/package/@esbuild/win32-ia32)         | `win32`    | `ia32`       |          |\n| [`@esbuild/win32-x64`](https://www.npmjs.org/package/@esbuild/win32-x64)           | `win32`    | `x64`        |          |\n\n**Why this is not recommended:** This approach only works on Unix systems that can run shell scripts, so it will require [WSL](https://learn.microsoft.com/en-us/windows/wsl/) on Windows. An additional drawback is that you cannot use [plugins](../plugins/index) with the native version of esbuild.\n\nIf you choose to write your own code to download esbuild directly from npm, then you are relying on internal implementation details of esbuild's native executable installer. These details may change at some point, in which case this approach will no longer work for new esbuild versions. This is only a minor drawback though since the approach should still work forever for existing esbuild versions (packages published to npm are immutable).\n\n¹ This operating system is not on [node's list of supported platforms](https://nodejs.org/api/process.html#process_process_platform)  \n² This architecture is not on [node's list of supported architectures](https://nodejs.org/api/process.html#processarch)"
- name: Drop
  id: api/index#drop
  summary: This tells esbuild to edit your source code before building to drop certain constructs
  belongs_to: API
  description: |-
    ### Drop

    *Supported by: [Build](#build) and [Transform](#transform)*

    This tells esbuild to edit your source code before building to drop certain constructs. There are currently two possible things that can be dropped:

    - `debugger`

      Passing this flag causes all [`debugger` statements](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger) to be removed from the output. This is similar to the `drop_debugger: true` flag available in the popular [UglifyJS](https://github.com/mishoo/UglifyJS) and [Terser](https://github.com/terser/terser) JavaScript minifiers.

      JavaScript's `debugger` statements cause the active debugger to treat the statement as an automatically-configured breakpoint. Code containing this statement will automatically be paused when the debugger is open. If no debugger is open, the statement does nothing. Dropping these statements from your code just prevents the debugger from automatically stopping when your code runs.

      You can drop `debugger` statements like this:

    ``` sh
    esbuild app.js --drop:debugger
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      drop: ['debugger'],
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Drop:        api.DropDebugger,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    - `console`

      Passing this flag causes all [`console` API calls](https://developer.mozilla.org/en-US/docs/Web/API/console#methods) to be removed from the output. This is similar to the `drop_console: true` flag available in the popular [UglifyJS](https://github.com/mishoo/UglifyJS) and [Terser](https://github.com/terser/terser) JavaScript minifiers.

      WARNING: Using this flag can introduce bugs into your code! This flag removes the entire call expression including all call arguments. If any of those arguments had important side effects, using this flag will change the behavior of your code. Be very careful when using this flag.

      If you want to remove console API calls without removing the arguments with side effects (so you do not introduce bugs), you should mark the relevant API calls as [pure](#pure) instead. For example, you can mark `console.log` as pure using `--pure:console.log`. This will cause these API calls to be removed safely when minification is enabled.

      You can drop `console` API calls like this:

    ``` sh
    esbuild app.js --drop:console
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      drop: ['console'],
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Drop:        api.DropConsole,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Drop labels
  id: api/index#drop-labels
  summary: This tells esbuild to edit your source code before building to drop labeled statements with specific label names
  belongs_to: API
  description: |-
    ### Drop labels

    *Supported by: [Build](#build) and [Transform](#transform)*

    This tells esbuild to edit your source code before building to drop [labeled statements](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label) with specific label names. For example, consider the following code:

    ``` javascript
    function example() {
      DEV: doAnExpensiveCheck()
      return normalCodePath()
    }
    ```

    If you use this option to drop all labels named `DEV`, then esbuild will give you this:

    ``` javascript
    function example() {
      return normalCodePath();
    }
    ```

    You can configure this feature like this (which will drop both the `DEV` and `TEST` labels):

    ``` sh
    esbuild app.js --drop-labels=DEV,TEST
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      dropLabels: ['DEV', 'TEST'],
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        DropLabels:  []string{"DEV", "TEST"},
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Note that this is not the only way to conditionally remove code. Another more common way is to use the [define](#define) feature to replace specific global variables with a boolean value. For example, consider the following code:

    ``` javascript
    function example() {
      DEV && doAnExpensiveCheck()
      return normalCodePath()
    }
    ```

    If you define `DEV` to `false`, then esbuild will give you this:

    ``` javascript
    function example() {
      return normalCodePath();
    }
    ```

    This is pretty much the same thing as using a label. However, an advantage of using a label instead of a global variable to conditionally remove code is that you don't have to worry about the global variable not being defined because someone forgot to configure esbuild to replace it with something. Some drawbacks of using the label approach are that it makes conditionally removing code when the label is *not* dropped slightly harder to read, and it doesn't work for code embedded within nested expressions. Which approach to use for a given project comes down to personal preference.
- name: Empty file
  id: content-types/index#empty-file
  summary: This loader tells esbuild to pretend that a file is empty
  belongs_to: Content Types
  description: "## Empty file\n\nLoader: `empty`\n\nThis loader tells esbuild to pretend that a file is empty. It can be a helpful way to remove content from your bundle in certain situations. For example, you can configure `.css` files to load with `empty` to prevent esbuild from bundling CSS files that are imported into JavaScript files:\n\n``` sh\nesbuild app.js --bundle --loader:.css=empty\n```\n\n``` javascript\nrequire('esbuild').buildSync({\n  entryPoints: ['app.js'],\n  bundle: true,\n  loader: { '.css': 'empty' },\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Loader: map[string]api.Loader{\n      \".css\": api.LoaderEmpty,\n    },\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThis loader also lets you remove imported assets from CSS files. For example, you can configure `.png` files to load with `empty` so that references to `.png` files in CSS code such as `url(image.png)` are replaced with `url()`.\n\n© 2020 Evan Wallace  \nLicensed under the MIT License.  \n[https://esbuild.github.io/content-types/](https://esbuild.github.io/content-types/)"
- name: Entry names
  id: api/index#entry-names
  summary: This option controls the file names of the output files corresponding to each input entry point file
  belongs_to: API
  description: |-
    ### Entry names

    *Supported by: [Build](#build)*

    This option controls the file names of the output files corresponding to each input entry point file. It configures the output paths using a template with placeholders that will be substituted with values specific to the file when the output path is generated. For example, specifying an entry name template of `[dir]/[name]-[hash]` includes a hash of the output file in the file name and puts the files into the output directory, potentially under a subdirectory (see the details about `[dir]` below). Doing that looks like this:

    ``` sh
    esbuild src/main-app/app.js --entry-names=[dir]/[name]-[hash] --outbase=src --bundle --outdir=out
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['src/main-app/app.js'],
      entryNames: '[dir]/[name]-[hash]',
      outbase: 'src',
      bundle: true,
      outdir: 'out',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"src/main-app/app.js"},
        EntryNames:  "[dir]/[name]-[hash]",
        Outbase:     "src",
        Bundle:      true,
        Outdir:      "out",
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    There are four placeholders that can be used in entry path templates:

    - `[dir]`

      This is the relative path from the directory containing the input entry point file to the [outbase](#outbase) directory. Its purpose is to help you avoid collisions between identically-named entry points in different subdirectories.

      For example, if there are two entry points `src/pages/home/index.ts` and `src/pages/about/index.ts`, the outbase directory is `src`, and the entry names template is `[dir]/[name]`, the output directory will contain `pages/home/index.js` and `pages/about/index.js`. If the entry names template had been just `[name]` instead, bundling would have failed because there would have been two output files with the same output path `index.js` inside the output directory.

    - `[name]`

      This is the original file name of the entry point without the extension. For example, if the input entry point file is named `app.js` then `[name]` will be substituted with `app` in the template.

    - `[hash]`

      This is the content hash of the output file, which can be used to take optimal advantage of browser caching. Adding `[hash]` to your entry point names means esbuild will calculate a hash that relates to all content in the corresponding output file (and any output file it imports if [code splitting](#splitting) is active). The hash is designed to change if and only if any of the input files relevant to that output file are changed.

      After that, you can have your web server tell browsers that to cache these files forever (in practice you can say they expire a very long time from now such as in a year). You can then use the information in the [metafile](#metafile) to determine which output file path corresponds to which input entry point so you know what path to include in your `<script>` tag.

    - `[ext]`

      This is the file extension that the entry point file will be written out to (i.e. the [out extension](#out-extension) setting, not the original file extension). It can be used to put different types of entry points into different directories. For example, `--entry-names=entries/[ext]/[name]` might write the output file for `app.ts` to `entries/js/app.js`.

    Entry path templates do not need to include a file extension. The appropriate [out extension](#out-extension) based on the file type will be automatically added to the end of the output path after template substitution.

    This option is similar to the [asset names](#asset-names) and [chunk names](#chunk-names) options.
- name: Entry points
  id: api/index#entry-points
  summary: This is an array of files that each serve as an input to the bundling algorithm
  belongs_to: API
  description: |-
    ### Entry points

    *Supported by: [Build](#build)*

    This is an array of files that each serve as an input to the bundling algorithm. They are called "entry points" because each one is meant to be the initial script that is evaluated which then loads all other aspects of the code that it represents. Instead of loading many libraries in your page with `<script>` tags, you would instead use `import` statements to import them into your entry point (or into another file that is then imported into your entry point).

    Simple apps only need one entry point but additional entry points can be useful if there are multiple logically-independent groups of code such as a main thread and a worker thread, or an app with separate relatively unrelated areas such as a landing page, an editor page, and a settings page. Separate entry points helps introduce separation of concerns and helps reduce the amount of unnecessary code that the browser needs to download. If applicable, enabling [code splitting](#splitting) can further reduce download sizes when browsing to a second page whose entry point shares some already-downloaded code with a first page that has already been visited.

    The simple way to specify entry points is to just pass an array of file paths:

    ``` sh
    esbuild home.ts settings.ts --bundle --outdir=out
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['home.ts', 'settings.ts'],
      bundle: true,
      write: true,
      outdir: 'out',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"home.ts", "settings.ts"},
        Bundle:      true,
        Write:       true,
        Outdir:      "out",
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    This will generate two output files, `out/home.js` and `out/settings.js` corresponding to the two entry points `home.ts` and `settings.ts`.

    For further control over how the paths of the output files are derived from the corresponding input entry points, you should look into these options:

    - [Entry names](#entry-names)
    - [Out extension](#out-extension)
    - [Outbase](#outbase)
    - [Outdir](#outdir)
    - [Outfile](#outfile)

    In addition, you can also specify a fully custom output path for each individual entry point using an alternative entry point syntax:

    ``` sh
    esbuild out1=home.ts out2=settings.ts --bundle --outdir=out
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: [
        { out: 'out1', in: 'home.ts'},
        { out: 'out2', in: 'settings.ts'},
      ],
      bundle: true,
      write: true,
      outdir: 'out',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPointsAdvanced: []api.EntryPoint{{
          OutputPath: "out1",
          InputPath:  "home.ts",
        }, {
          OutputPath: "out2",
          InputPath:  "settings.ts",
        }},
        Bundle: true,
        Write:  true,
        Outdir: "out",
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    This will generate two output files, `out/out1.js` and `out/out2.js` corresponding to the two entry points `home.ts` and `settings.ts`.

    #### Glob-style entry points

    If an entry point contains the `*` character, then it's considered to be a [glob](https://en.wikipedia.org/wiki/Glob_(programming)) pattern. This means esbuild will use that entry point as a pattern to search for files on the file system and will then replace that entry point with any matching files that were found. So for example, an entry point of `*.js` will cause esbuild to consider all files in the current directory that end in `.js` to be entry points.

    The glob matcher that esbuild implements is intentionally simple, and does not support more advanced features found in certain other glob libraries. Only two kinds of wildcards are supported:

    - `*`

      This wildcard matches any number of characters (including none) except that it does not match a slash character (i.e. a `/`), which means it does not cause esbuild to traverse into subdirectories. For example, `*.js` will match `foo.js` but not `bar/foo.js`.

    - `/**/`

      This wildcard matches zero or more path segments, which means it can be used to tell esbuild to match against a whole directory tree. For example, `./**/*.js` will match `./foo.js` and `./bar/foo.js` and `./a/b/c/foo.js`.

    If you are using esbuild via the CLI, keep in mind that if you do not quote arguments that contain shell metacharacters before you pass them to esbuild, your shell will likely expand them before esbuild sees them. So if you run `esbuild "*.js"` (with quotes) then esbuild will see an entry point of `*.js` and the glob-style entry point rules described above will apply. But if you run `esbuild *.js` (without quotes) then esbuild will see whatever your current shell decided to expand `*.js` into (which may include seeing nothing at all if your shell expanded it into nothing). Using esbuild's built-in glob pattern support can be a convenient way to ensure cross-platform consistency by avoiding shell-specific behavior, but it requires you to quote your arguments correctly so that your shell doesn't interpret them.
- name: Example plugins
  id: plugins/index#example-plugins
  summary: The example plugins below are meant to give you an idea of the different types of things you can do with the plugin API
  belongs_to: Plugins
  description: |-
    ## Example plugins

    The example plugins below are meant to give you an idea of the different types of things you can do with the plugin API.
- name: External
  id: api/index#external
  summary: You can mark a file or a package as external to exclude it from your build
  belongs_to: API
  description: |-
    ### External

    *Supported by: [Build](#build)*

    You can mark a file or a package as external to exclude it from your build. Instead of being bundled, the import will be preserved (using `require` for the `iife` and `cjs` formats and using `import` for the `esm` format) and will be evaluated at run time instead.

    This has several uses. First of all, it can be used to trim unnecessary code from your bundle for a code path that you know will never be executed. For example, a package may contain code that only runs in node but you will only be using that package in the browser. It can also be used to import code in node at run time from a package that cannot be bundled. For example, the `fsevents` package contains a native extension, which esbuild doesn't support. Marking something as external looks like this:

    ``` sh
    echo 'require("fsevents")' > app.js
    esbuild app.js --bundle --external:fsevents --platform=node
    // app.js
    require("fsevents");
    ```

    ``` javascript
    import * as esbuild from 'esbuild'
    import fs from 'node:fs'

    fs.writeFileSync('app.js', 'require("fsevents")')

    await esbuild.build({
      entryPoints: ['app.js'],
      outfile: 'out.js',
      bundle: true,
      platform: 'node',
      external: ['fsevents'],
    })
    ```

    ``` go
    package main

    import "io/ioutil"
    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      ioutil.WriteFile("app.js", []byte("require(\"fsevents\")"), 0644)

      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Outfile:     "out.js",
        Bundle:      true,
        Write:       true,
        Platform:    api.PlatformNode,
        External:    []string{"fsevents"},
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    You can also use the `*` wildcard character in an external path to mark all files matching that pattern as external. For example, you can use `*.png` to remove all `.png` files or `/images/*` to remove all paths starting with `/images/`:

    ``` sh
    esbuild app.js --bundle "--external:*.png" "--external:/images/*"
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      outfile: 'out.js',
      bundle: true,
      external: ['*.png', '/images/*'],
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Outfile:     "out.js",
        Bundle:      true,
        Write:       true,
        External:    []string{"*.png", "/images/*"},
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    External paths are applied both before and after path resolution, which lets you match against both the import path in the source code and the absolute file system path. The path is considered to be external if the external path matches in either case. The specific behavior is as follows:

    - Before path resolution begins, import paths are checked against all external paths. In addition, if the external path looks like a package path (i.e. doesn't start with `/` or `./` or `../`), import paths are checked to see if they have that package path as a path prefix.

      This means that `--external:@foo/bar` implicitly also means `--external:@foo/bar/*` which matches the import path `@foo/bar/baz`. So it marks all paths inside the `@foo/bar` package as external too.

    - After path resolution ends, the resolved absolute paths are checked against all external paths that don't look like a package path (i.e. those that start with `/` or `./` or `../`). But before checking, the external path is joined with the current working directory and then normalized, becoming an absolute path (even if it contains a `*` wildcard character).

      This means that you can mark everything in the directory `dir` as external using `--external:./dir/*`. Note that the leading `./` is important. Using `--external:dir/*` instead is treated as a package path and is not checked for after path resolution ends.

    &nbsp;
- name: External file
  id: content-types/index#external-file
  summary: There are two different loaders that can be used for external files depending on the behavior you're looking for
  belongs_to: Content Types
  description: |-
    ## External file

    There are two different loaders that can be used for external files depending on the behavior you're looking for. Both loaders are described below:

    #### The `file` loader

    Loader: `file`

    This loader will copy the file to the output directory and embed the file name into the bundle as a string. This string is exported using the default export. Using it looks like this:

    ``` javascript
    import url from './example.png'
    let image = new Image
    image.src = url
    document.body.appendChild(image)
    ```

    This behavior is intentionally similar to Webpack's [`file-loader`](https://v4.webpack.js.org/loaders/file-loader/) package. Note that this loader is not enabled by default. You will need to configure it for the appropriate file extension like this:

    ``` sh
    esbuild app.js --bundle --loader:.png=file --outdir=out
    ```

    ``` javascript
    require('esbuild').buildSync({
      entryPoints: ['app.js'],
      bundle: true,
      loader: { '.png': 'file' },
      outdir: 'out',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Loader: map[string]api.Loader{
          ".png": api.LoaderFile,
        },
        Outdir: "out",
        Write:  true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    By default the exported string is just the file name. If you would like to prepend a base path to the exported string, this can be done with the [public path](../api/index#public-path) API option.

    #### The `copy` loader

    Loader: `copy`

    This loader will copy the file to the output directory and rewrite the import path to point to the copied file. This means the import will still exist in the final bundle and the final bundle will still reference the file instead of including the file inside the bundle. This might be useful if you are running additional bundling tools on esbuild's output, if you want to omit a rarely-used data file from the bundle for faster startup performance, or if you want to rely on specific behavior of your runtime that's triggered by an import. For example:

    ``` javascript
    import json from './example.json' assert { type: 'json' }
    console.log(json)
    ```

    If you bundle the above code with the following command:

    ``` sh
    esbuild app.js --bundle --loader:.json=copy --outdir=out --format=esm
    ```

    ``` javascript
    require('esbuild').buildSync({
      entryPoints: ['app.js'],
      bundle: true,
      loader: { '.json': 'copy' },
      outdir: 'out',
      format: 'esm',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Loader: map[string]api.Loader{
          ".json": api.LoaderCopy,
        },
        Outdir: "out",
        Write:  true,
        Format: api.FormatESModule,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    the resulting `out/app.js` file might look something like this:

    ``` javascript
    // app.js
    import json from "./example-PVCBWCM4.json" assert { type: "json" };
    console.log(json);
    ```

    Notice how the import path has been rewritten to point to the copied file `out/example-PVCBWCM4.json` (a content hash has been added due to the default value of the [asset names](../api/index#asset-names) setting), and how the [import assertion](https://v8.dev/features/import-assertions) for JSON has been kept so the runtime will be able to load the JSON file.
- name: FAQ
  id: faq/index
  summary: This is a collection of common questions about esbuild
  description: "# FAQ\n\nThis is a collection of common questions about esbuild. You can also ask questions on the [GitHub issue tracker](https://github.com/evanw/esbuild/issues).\n\n- [Why is esbuild fast?](#why-is-esbuild-fast)\n- [Benchmark details](#benchmark-details)\n- [Upcoming roadmap](#upcoming-roadmap)\n- [Production readiness](#production-readiness)\n- [Anti-virus software](#anti-virus-software)\n- [Outdated version of Go](#old-go-version)\n- [Minified newlines](#minified-newlines)\n- [Avoiding name collisions](#top-level-name-collisions)\n- [Top-level `var`](#top-level-var)\n\n## Why is esbuild fast?\n\nSeveral reasons:\n\n- It's written in [Go](https://go.dev/) and compiles to native code.\n\n  Most other bundlers are written in JavaScript, but a command-line application is a worst-case performance situation for a JIT-compiled language. Every time you run your bundler, the JavaScript VM is seeing your bundler's code for the first time without any optimization hints. While esbuild is busy parsing your JavaScript, node is busy parsing your bundler's JavaScript. By the time node has finished parsing your bundler's code, esbuild might have already exited and your bundler hasn't even started bundling yet.\n\n  In addition, Go is designed from the core for parallelism while JavaScript is not. Go has shared memory between threads while JavaScript has to serialize data between threads. Both Go and JavaScript have parallel garbage collectors, but Go's heap is shared between all threads while JavaScript has a separate heap per JavaScript thread. This seems to cut the amount of parallelism that's possible with JavaScript worker threads in half [according to my testing](https://github.com/evanw/esbuild/issues/111#issuecomment-719910381), presumably since half of your CPU cores are busy collecting garbage for the other half.\n\n- Parallelism is used heavily.\n\n  The algorithms inside esbuild are carefully designed to fully saturate all available CPU cores when possible. There are roughly three phases: parsing, linking, and code generation. Parsing and code generation are most of the work and are fully parallelizable (linking is an inherently serial task for the most part). Since all threads share memory, work can easily be shared when bundling different entry points that import the same JavaScript libraries. Most modern computers have many cores so parallelism is a big win.\n\n- Everything in esbuild is written from scratch.\n\n  There are a lot of performance benefits with writing everything yourself instead of using 3rd-party libraries. You can have performance in mind from the beginning, you can make sure everything uses consistent data structures to avoid expensive conversions, and you can make wide architectural changes whenever necessary. The drawback is of course that it's a lot of work.\n\n  For example, many bundlers use the official TypeScript compiler as a parser. But it was built to serve the goals of the TypeScript compiler team and they do not have performance as a top priority. Their code makes pretty heavy use of [megamorphic object shapes](https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html) and unnecessary [dynamic property accesses](https://github.com/microsoft/TypeScript/issues/39247) (both well-known JavaScript speed bumps). And the TypeScript parser appears to still run the type checker even when type checking is disabled. None of these are an issue with esbuild's custom TypeScript parser.\n\n- Memory is used efficiently.\n\n  Compilers are ideally mostly O(n) complexity in the length of the input. So if you are processing a lot of data, memory access speed is likely going to heavily affect performance. The fewer passes you have to make over your data (and also the fewer different representations you need to transform your data into), the faster your compiler will go.\n\n  For example, esbuild only touches the whole JavaScript AST three times:\n\n  1.  A pass for lexing, parsing, scope setup, and declaring symbols\n  2.  A pass for binding symbols, minifying syntax, JSX/TS to JS, and ESNext-to-ES2015\n  3.  A pass for minifying identifiers, minifying whitespace, generating code, and generating source maps\n\n  This maximizes reuse of AST data while it's still hot in the CPU cache. Other bundlers do these steps in separate passes instead of interleaving them. They may also convert between data representations to glue multiple libraries together (e.g. string→TS→JS→string, then string→JS→older JS→string, then string→JS→minified JS→string) which uses more memory and slows things down.\n\n  Another benefit of Go is that it can store things compactly in memory, which enables it to use less memory and fit more in the CPU cache. All object fields have types and fields are packed tightly together so e.g. several boolean flags only take one byte each. Go also has value semantics and can embed one object directly in another so it comes \"for free\" without another allocation. JavaScript doesn't have these features and also has other drawbacks such as JIT overhead (e.g. hidden class slots) and inefficient representations (e.g. non-integer numbers are heap-allocated with pointers).\n\nEach one of these factors is only a somewhat significant speedup, but together they can result in a bundler that is multiple orders of magnitude faster than other bundlers commonly in use today.\n\n## Benchmark details\n\nHere are the details about each benchmark:\n\nThis benchmark approximates a large JavaScript codebase by duplicating the [three.js](https://github.com/mrdoob/three.js) library 10 times and building a single bundle from scratch, without any caches. The benchmark can be run with `make bench-three` in the [esbuild repo](https://github.com/evanw/esbuild).\n\n| Bundler           |   Time | Relative slowdown | Absolute speed | Output size |\n|:------------------|-------:|------------------:|---------------:|------------:|\n| esbuild           |  0.39s |                1x |  1403.7 kloc/s |      5.80mb |\n| parcel 2          | 14.91s |               38x |    36.7 kloc/s |      5.78mb |\n| rollup 4 + terser | 34.10s |               87x |    16.1 kloc/s |      5.82mb |\n| webpack 5         | 41.21s |              106x |    13.3 kloc/s |      5.84mb |\n\nEach time reported is the best of three runs. I'm running esbuild with `--bundle --minify --sourcemap`. I used the [`@rollup/plugin-terser`](https://github.com/rollup/plugins/tree/master/packages/terser) plugin because Rollup itself doesn't support minification. Webpack 5 uses `--mode=production --devtool=sourcemap`. Parcel 2 uses the default options. Absolute speed is based on the total line count including comments and blank lines, which is currently 547,441. The tests were done on a 6-core 2019 MacBook Pro with 16gb of RAM and with [macOS Spotlight](https://en.wikipedia.org/wiki/Spotlight_(software)) disabled.\n\nThis benchmark uses the old [Rome](https://github.com/rome/tools) code base (prior to their Rust rewrite) to approximate a large TypeScript codebase. All code must be combined into a single minified bundle with source maps and the resulting bundle must work correctly. The benchmark can be run with `make bench-rome` in the [esbuild repo](https://github.com/evanw/esbuild).\n\n| Bundler   |   Time | Relative slowdown | Absolute speed | Output size |\n|:----------|-------:|------------------:|---------------:|------------:|\n| esbuild   |  0.10s |                1x |  1318.4 kloc/s |      0.97mb |\n| parcel 2  |  6.91ѕ |               69x |    16.1 kloc/s |      0.96mb |\n| webpack 5 | 16.69ѕ |              167x |     8.3 kloc/s |      1.27mb |\n\nEach time reported is the best of three runs. I'm running esbuild with `--bundle --minify --sourcemap --platform=node`. Webpack 5 uses [`ts-loader`](https://github.com/TypeStrong/ts-loader) with `transpileOnly: true` and `--mode=production --devtool=sourcemap`. Parcel 2 uses `\"engines\": \"node\"` in `package.json`. Absolute speed is based on the total line count including comments and blank lines, which is currently 131,836. The tests were done on a 6-core 2019 MacBook Pro with 16gb of RAM and with [macOS Spotlight](https://en.wikipedia.org/wiki/Spotlight_(software)) disabled.\n\nThe results don't include Rollup because I couldn't get it to work for reasons relating to TypeScript compilation. I tried [`@rollup/plugin-typescript`](https://github.com/rollup/plugins/tree/master/packages/typescript) but you can't disable type checking, and I tried [`@rollup/plugin-sucrase`](https://github.com/rollup/plugins/tree/master/packages/sucrase) but there's no way to provide a `tsconfig.json` file (which is required for correct path resolution).\n\n## Upcoming roadmap\n\nThese features are already in progress and are first priority:\n\n- Code splitting ([\\#16](https://github.com/evanw/esbuild/issues/16), [docs](../api/index#splitting))\n\nThese are potential future features but may not happen or may happen to a more limited extent:\n\n- HTML content type ([\\#31](https://github.com/evanw/esbuild/issues/31))\n\nAfter that point, I will consider esbuild to be relatively complete. I'm planning for esbuild to reach a mostly stable state and then stop accumulating more features. This will involve saying \"no\" to requests for adding major features to esbuild itself. I don't think esbuild should become an all-in-one solution for all frontend needs. In particular, I want to avoid the pain and problems of the \"webpack config\" model where the underlying tool is too flexible and usability suffers.\n\nFor example, I am *not* planning to include these features in esbuild's core itself:\n\n- Support for other frontend languages (e.g. [Elm](https://elm-lang.org/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Angular](https://angular.io/))\n- TypeScript type checking (just run `tsc` separately)\n- An API for custom AST manipulation\n- Hot-module reloading\n- Module federation\n\nI hope that the extensibility points I'm adding to esbuild ([plugins](../plugins/index) and the [API](../api/index)) will make esbuild useful to include as part of more customized build workflows, but I'm not intending or expecting these extensibility points to cover all use cases. If you have very custom requirements then you should be using other tools. I also hope esbuild inspires other build tools to dramatically improve performance by overhauling their implementations so that everyone can benefit, not just those that use esbuild.\n\nI am planning to continue to maintain everything in esbuild's existing scope even after esbuild reaches stability. This means implementing support for newly-released JavaScript and TypeScript syntax features, for example.\n\n## Production readiness\n\nThis project has not yet hit version 1.0.0 and is still in active development. That said, it is far beyond the alpha stage and is pretty stable. I think of it as a late-stage beta. For some early-adopters that means it's good enough to use for real things. Some other people think this means esbuild isn't ready yet. This section doesn't try to convince you either way. It just tries to give you enough information so you can decide for yourself whether you want to use esbuild as your bundler.\n\nSome data points:\n\n- **Used by other projects**\n\n  The API is already being used as a library within many other developer tools. For example, [Vite](https://vitejs.dev/) and [Snowpack](https://www.snowpack.dev/) are using esbuild to transform TypeScript into JavaScript and [Amazon CDK](https://aws.amazon.com/cdk/) (Cloud Development Kit) and [Phoenix](https://www.phoenixframework.org/) are using esbuild to bundle code.\n\n- **API stability**\n\n  Even though esbuild's version is not yet 1.0.0, effort is still made to keep the API stable. Patch versions are intended for backwards-compatible changes and minor versions are intended for backwards-incompatible changes. If you plan to use esbuild for something real, you should either pin the exact version (maximum safety) or pin the major and minor versions (only accept backwards-compatible upgrades).\n\n- **Only one main developer**\n\n  This tool is primarily built by [me](https://github.com/evanw). For some people this is fine, but for others this means esbuild is not a suitable tool for their organization. That's ok with me. I'm building esbuild because I find it fun to build and because it's the tool I'd want to use. I'm sharing it with the world because there are others that want to use it too, because the feedback makes the tool itself better, and because I think it will inspire the ecosystem to make better tools.\n\n- **Not always open to scope expansion**\n\n  I'm not planning on including major features that I'm not interested in building and/or maintaining. I also want to limit the project's scope so it doesn't get too complex and unwieldy, both from an architectural perspective, a testing and correctness perspective, and from a usability perspective. Think of esbuild as a \"linker\" for the web. It knows how to transform and bundle JavaScript and CSS. But the details of how your source code ends up as plain JavaScript or CSS may need to be 3rd-party code.\n\n  I'm hoping that [plugins](../plugins/index) will allow the community to add major features (e.g. WebAssembly import) without needing to contribute to esbuild itself. However, not everything is exposed in the plugin API and it may be the case that it's not possible to add a particular feature to esbuild that you may want to add. This is intentional; esbuild is not meant to be an all-in-one solution for all frontend needs.\n\n## Anti-virus software\n\nSince esbuild is written in native code, anti-virus software can sometimes incorrectly flag it as a virus. *This does not mean esbuild is a virus.* I do not publish malicious code and I take supply chain security very seriously.\n\nVirtually all of esbuild's code is first-party code except for [one dependency](https://github.com/evanw/esbuild/blob/main/go.mod) on Google's set of supplemental Go packages. My development work is done on different machine that is isolated from the one I use to publish builds. I have done additional work to ensure that esbuild's published builds are completely reproducible and after every release, published builds are [automatically compared](https://github.com/evanw/esbuild/blob/main/.github/workflows/validate.yml) to ones locally-built in an unrelated environment to ensure that they are bitwise identical (i.e. that the Go compiler itself has not been compromised). You can also build esbuild from source yourself and compare your build artifacts to the published ones to independently verify this.\n\nHaving to deal with false-positives is an unfortunate reality of using anti-virus software. Here are some possible workarounds if your anti-virus won't let you use esbuild:\n\n- Ignore your anti-virus software and remove esbuild from quarantine\n- Report the specific esbuild native executable as a false-positive to your anti-virus software vendor\n- Use [`esbuild-wasm`](../getting-started/index#wasm) instead of `esbuild` to bypass your anti-virus software (which likely won't flag WebAssembly files the same way it flags native executables)\n- Use another build tool instead of esbuild\n\n## Outdated version of Go\n\nIf you use an automated dependency vulnerability scanner, you may get a report that the version of the Go compiler that esbuild uses and/or the version of `golang.org/x/sys` (esbuild's only dependency) is outdated. These reports are benign and should be ignored.\n\nThis happens because esbuild's code is deliberately intended to be compilable with Go 1.13. Later versions of Go have dropped support for certain older platforms that I want esbuild to be able to run on (e.g. older versions of macOS). While esbuild's published binaries are compiled with a much newer version of the Go compiler (and therefore don't work on older versions of macOS), you are currently still able to compile the latest version of esbuild for yourself with Go 1.13 and use it on older versions of macOS because esbuild's code can still be compiled with Go as far back as 1.13.\n\nPeople and/or automated tools sometimes see the `go 1.13` line in [`go.mod`](https://github.com/evanw/esbuild/blob/main/go.mod) and complain that esbuild's published binaries are built with Go 1.13, which is a really old version of Go. However, that's not true. That line in `go.mod` only specifies the minimum compiler version. It has nothing to do with the version of Go that esbuild's published binaries are built with, which is a much newer version of Go. [Please read the documentation.](https://go.dev/ref/mod#go-mod-file-go)\n\nPeople also sometimes want esbuild to update the `golang.org/x/sys` dependency because there is a known vulnerability in the version that esbuild uses (specifically [GO-2022-0493](https://pkg.go.dev/vuln/GO-2022-0493) about the `Faccessat` function). The problem that prevents esbuild from updating to a newer version of the `golang.org/x/sys` dependency is that newer versions have started using the `unsafe.Slice` function, which was first introduced in Go 1.17 (and therefore doesn't compile in older versions of Go). However, this vulnerability report is irrelevant because a) esbuild doesn't ever call that function in the first place and b) esbuild is a build tool, not a sandbox, and esbuild's file system access is not security-sensitive.\n\nI'm not going to drop compatibility with older platforms and prevent some people from being able to use esbuild just to work around irrelevant vulnerability reports. Please ignore any reports about the issues described above.\n\n## Minified newlines\n\nPeople are sometimes surprised that esbuild's minifier typically changes the character escape sequence `\\n` within JavaScript strings into a newline character in a template literal. But this is intentional. **This is not a bug with esbuild**. The job of a minifier is to generate as compact an output as possible that's equivalent to the input. The character escape sequence `\\n` is two bytes long while a newline character is one byte long.\n\nFor example, this code is 21 bytes long:\n\n``` javascript\nvar text=\"a\\nb\\nc\\n\";\n```\n\nWhile this code is 18 bytes long:\n\n``` javascript\nvar text=`a\nb\nc\n`;\n```\n\nSo the second code is fully minified while the first one isn't. Minifying code does not mean putting it all on one line. Instead, minifying code means generating equivalent code that uses as few bytes as possible. In JavaScript, an untagged template literal is equivalent to a string literal, so esbuild is doing the correct thing here.\n\n## Avoiding name collisions\n\nTop-level variables in an entry point module should never end up in the global scope when running esbuild's output in a browser. If that happens, it means you did not follow [esbuild's documentation about output formats](../api/index#format) and are using esbuild incorrectly. **This is not a bug with esbuild.**\n\nSpecifically, you must do either one of the following when running esbuild's output in a browser:\n\n1.  `--format=iife` with `<script src=\"...\">`\n\n    If you are running your code in the global scope, then you should be using `--format=iife`. This causes esbuild's output to wrap your code so that top-level variables are declared in a nested scope.\n\n2.  `--format=esm` with `<script src=\"...\" type=\"module\">`\n\n    If you are using `--format=esm`, then you must run your code as a module. This causes the browser to wrap your code so that top-level variables are declared in a nested scope.\n\nUsing `--format=esm` with `<script src=\"...\">` will break your code in subtle and confusing ways (omitting `type=\"module\"` means that all top-level variables will end up in the global scope, which will then collide with top-level variables that have the same name in other JavaScript files).\n\n## Top-level `var`\n\nPeople are sometimes surprised that esbuild sometimes rewrites top-level `let`, `const`, and `class` declarations as `var` declarations instead. This is done for a few reasons:\n\n- **For correctness**\n\n  Bundling sometimes needs to lazily-initialize a module. For example, this happens when you call `require()` or `import()` using the path of a module within the bundle. Doing this involves separating the declaration and initialization of top-level symbols by moving the initialization into a closure. So for example `class` statements are rewritten as an assignment of a class expression to a variable. Keeping the declarations out of the lazy-initialization closure is important for performance, since it means other modules can reference them directly instead by name instead of indirectly via a slower property access.\n\n  Another case where this is needed is when transforming top-level `using` declarations. This involves wrapping the entire module body in a `try` block, which also involves separating the declaration and initialization of top-level symbols. Top-level symbols may need to be exported, which means they cannot be declared within the `try` block.\n\n  In both of these cases esbuild will fail with a build error if the source code contains a mutation of a `const` symbol, so it's not possible for esbuild's rewriting of top-level `const` into `var` to result in the mutation of a constant.\n\n  Due to esbuild's current architecture, the part of esbuild that does this transformation (the parser) cannot know whether the current module will end up being lazily initialized or not. The information for this decision may only be discovered later on in the build, or may even change in future incremental builds that reuse the same AST (per-file ASTs are transformed once during parsing and then cached and reused across incremental builds). So this transformation is always done when bundling is active.\n\n- **For performance**\n\n  Multiple JavaScript VMs have had and continue to have performance issues with TDZ (i.e. \"temporal dead zone\") checks. These checks validate that a let, or const, or class symbol isn't used before it's initialized. Here are two issues with well-known VMs:\n\n  - V8: <https://bugs.chromium.org/p/v8/issues/detail?id=13723> (10% slowdown)\n  - JavaScriptCore: <https://bugs.webkit.org/show_bug.cgi?id=199866> (1,000% slowdown!)\n\n  JavaScriptCore had a severe performance issue as their TDZ implementation had time complexity that was quadratic in the number of variables needing TDZ checks in the same scope (with the top-level scope typically being the worst offender). V8 has ongoing issues with TDZ checks being present throughout the code their JIT generates even when they have already been checked earlier in the same function or when the function in question has already been run (so the checks have already happened).\n\n  In JavaScript, `let`, `const`, and `class` declarations all introduce TDZ checks while `var` declarations do not. Since bundling typically merges many modules into a single very large top-level scope, the performance impact of these TDZ checks can be pretty severe. Converting top-level `let`, `const`, and `class` declarations into `var` helps automatically make your code faster.\n\nNote that esbuild doesn't preserve top-level TDZ side effects because modules may need to be lazily initialized (as described above), which means separating declaration from initialization. TDZ checks for top-level symbols could hypothetically still be supported by generating extra code that checks before each use of a top-level symbol and throws if it hasn't been initialized yet (effectively manually implementing what a real JavaScript VM would do). However, this seems like an excessive overhead for both code size and run time, and does not seem like something that a production-oriented bundler should do.\n\n© 2020 Evan Wallace  \nLicensed under the MIT License.  \n[https://esbuild.github.io/faq/](https://esbuild.github.io/faq/)\n\nJavaScript benchmark\n\nTypeScript benchmark"
- name: Filters
  id: plugins/index#filters
  summary: Every callback must provide a regular expression as a filter
  belongs_to: Plugins
  description: |-
    ### Filters

    Every callback must provide a regular expression as a filter. This is used by esbuild to skip calling the callback when the path doesn't match its filter, which is done for performance. Calling from esbuild's highly-parallel internals into single-threaded JavaScript code is expensive and should be avoided whenever possible for maximum speed.

    You should try to use the filter regular expression instead of using JavaScript code for filtering whenever you can. This is faster because the regular expression is evaluated inside of esbuild without calling out to JavaScript at all. For example, the sample [HTTP plugin](#http-plugin) below uses a filter of `^https?://` to ensure that the performance overhead of running the plugin is only incurred for paths that start with `http://` or `https://`.

    The allowed regular expression syntax is the syntax supported by Go's [regular expression engine](https://pkg.go.dev/regexp/). This is slightly different than JavaScript. Specifically, look-ahead, look-behind, and backreferences are not supported. Go's regular expression engine is designed to avoid the catastrophic exponential-time worst case performance issues that can affect JavaScript regular expressions.

    Note that namespaces can also be used for filtering. Callbacks must provide a filter regular expression but can optionally also provide a namespace to further restrict what paths are matched. This can be useful for "remembering" where a virtual module came from. Keep in mind that namespaces are matched using an exact string equality test instead of a regular expression, so unlike module paths they are not intended for storing arbitrary data.
- name: Finding plugins
  id: plugins/index#finding-plugins
  summary: If you're looking for an existing esbuild plugin, you should check out the list of existing esbuild plugins
  belongs_to: Plugins
  description: |-
    ## Finding plugins

    If you're looking for an existing esbuild plugin, you should check out the [list of existing esbuild plugins](https://github.com/esbuild/community-plugins). Plugins on this list have been deliberately added by the author and are intended to be used by others in the esbuild community.

    If you want to share your esbuild plugin, you should:

    1.  [Publish it to npm](https://docs.npmjs.com/creating-and-publishing-unscoped-public-packages) so others can install it.
    2.  Add it to the [list of existing esbuild plugins](https://github.com/esbuild/community-plugins) so others can find it.
- name: Footer
  id: api/index#footer
  summary: Use this to insert an arbitrary string at the end of generated JavaScript and CSS files
  belongs_to: API
  description: |-
    ### Footer

    *Supported by: [Build](#build) and [Transform](#transform)*

    Use this to insert an arbitrary string at the end of generated JavaScript and CSS files. This is commonly used to insert comments:

    ``` sh
    esbuild app.js --footer:js=//comment --footer:css=/*comment*/
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      footer: {
        js: '//comment',
        css: '/*comment*/',
      },
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Footer: map[string]string{
          "js":  "//comment",
          "css": "/*comment*/",
        },
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    This is similar to [banner](#banner) which inserts at the beginning instead of the end.
- name: Format
  id: api/index#format
  summary: This sets the output format for the generated JavaScript files
  belongs_to: API
  description: "### Format\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis sets the output format for the generated JavaScript files. There are currently three possible values that can be configured: `iife`, `cjs`, and `esm`. When no output format is specified, esbuild picks an output format for you if [bundling](#bundle) is enabled (as described below), or doesn't do any format conversion if [bundling](#bundle) is disabled.\n\n#### IIFE\n\nThe `iife` format stands for \"immediately-invoked function expression\" and is intended to be run in the browser. Wrapping your code in a function expression ensures that any variables in your code don't accidentally conflict with variables in the global scope. If your entry point has exports that you want to expose as a global in the browser, you can configure that global's name using the [global name](#global-name) setting. The `iife` format will automatically be enabled when no output format is specified, [bundling](#bundle) is enabled, and [platform](#platform) is set to `browser` (which it is by default). Specifying the `iife` format looks like this:\n\n``` sh\necho 'alert(\"test\")' | esbuild --format=iife\n(() => {\n  alert(\"test\");\n})();\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet js = 'alert(\"test\")'\nlet result = await esbuild.transform(js, {\n  format: 'iife',\n})\nconsole.log(result.code)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"alert(\\\"test\\\")\"\n\n  result := api.Transform(js, api.TransformOptions{\n    Format: api.FormatIIFE,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\n#### CommonJS\n\nThe `cjs` format stands for \"CommonJS\" and is intended to be run in node. It assumes the environment contains `exports`, `require`, and `module`. Entry points with exports in ECMAScript module syntax will be converted to a module with a getter on `exports` for each export name. The `cjs` format will automatically be enabled when no output format is specified, [bundling](#bundle) is enabled, and [platform](#platform) is set to `node`. Specifying the `cjs` format looks like this:\n\n``` sh\necho 'export default \"test\"' | esbuild --format=cjs\n...\nvar stdin_exports = {};\n__export(stdin_exports, {\n  default: () => stdin_default\n});\nmodule.exports = __toCommonJS(stdin_exports);\nvar stdin_default = \"test\";\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet js = 'export default \"test\"'\nlet result = await esbuild.transform(js, {\n  format: 'cjs',\n})\nconsole.log(result.code)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"export default 'test'\"\n\n  result := api.Transform(js, api.TransformOptions{\n    Format: api.FormatCommonJS,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\n#### ESM\n\nThe `esm` format stands for \"ECMAScript module\". It assumes the environment supports `import` and `export` syntax. Entry points with exports in CommonJS module syntax will be converted to a single `default` export of the value of `module.exports`. The `esm` format will automatically be enabled when no output format is specified, [bundling](#bundle) is enabled, and [platform](#platform) is set to `neutral`. Specifying the `esm` format looks like this:\n\n``` sh\necho 'module.exports = \"test\"' | esbuild --format=esm\n...\nvar require_stdin = __commonJS({\n  \"<stdin>\"(exports, module) {\n    module.exports = \"test\";\n  }\n});\nexport default require_stdin();\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet js = 'module.exports = \"test\"'\nlet result = await esbuild.transform(js, {\n  format: 'esm',\n})\nconsole.log(result.code)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"module.exports = 'test'\"\n\n  result := api.Transform(js, api.TransformOptions{\n    Format: api.FormatESModule,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\nThe `esm` format can be used either in the browser or in node, but you have to explicitly load it as a module. This happens automatically if you `import` it from another module. Otherwise:\n\n- In the browser, you can load a module using `<script src=\"file.js\" type=\"module\"></script>`. Do not forget `type=\"module\"` as this will break your code in subtle and confusing ways (omitting `type=\"module\"` means that all top-level variables will end up in the global scope, which will then collide with top-level variables that have the same name in other JavaScript files).  \n- In node, you can load a module using `node file.mjs`. Note that node requires the `.mjs` extension unless you have configured `\"type\": \"module\"` in your `package.json` file. You can use the [out extension](#out-extension) setting in esbuild to customize the output extension for the files esbuild generates. You can read more about using ECMAScript modules in node [here](https://nodejs.org/api/esm.html#enabling).\n\n&nbsp;"
- name: Format messages
  id: api/index#format-messages
  summary: This API call can be used to format the log errors and warnings returned by the build API and transform APIs as a string using the same formatting that esbuild itself uses
  belongs_to: API
  description: |-
    ### Format messages

    *Supported by: [Build](#build) and [Transform](#transform)*

    This API call can be used to format the log errors and warnings returned by the [build](#build) API and [transform](#transform) APIs as a string using the same formatting that esbuild itself uses. This is useful if you want to customize the way esbuild's logging works, such as processing the log messages before they are printed or printing them to somewhere other than to the console. Here's an example:

    ``` javascript
    import * as esbuild from 'esbuild'

    let formatted = await esbuild.formatMessages([
      {
        text: 'This is an error',
        location: {
          file: 'app.js',
          line: 10,
          column: 4,
          length: 3,
          lineText: 'let foo = bar',
        },
      },
    ], {
      kind: 'error',
      color: false,
      terminalWidth: 100,
    })

    console.log(formatted.join('\n'))
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"
    import "strings"

    func main() {
      formatted := api.FormatMessages([]api.Message{
        {
          Text: "This is an error",
          Location: &api.Location{
            File:     "app.js",
            Line:     10,
            Column:   4,
            Length:   3,
            LineText: "let foo = bar",
          },
        },
      }, api.FormatMessagesOptions{
        Kind:          api.ErrorMessage,
        Color:         false,
        TerminalWidth: 100,
      })

      fmt.Printf("%s", strings.Join(formatted, "\n"))
    }
    ```

    #### Options

    The following options can be provided to control the formatting:

    ``` javascript
    interface FormatMessagesOptions {
      kind: 'error' | 'warning';
      color?: boolean;
      terminalWidth?: number;
    }
    ```

    ``` go
    type FormatMessagesOptions struct {
      Kind          MessageKind
      Color         bool
      TerminalWidth int
    }
    ```

    - `kind`

      Controls whether these log messages are printed as errors or warnings.

    - `color`

      If this is `true`, Unix-style terminal escape codes are included for colored output.

    - `terminalWidth`

      Provide a positive value to wrap long lines so that they don't overflow past the provided column width. Provide `0` to disable word wrapping.

    &nbsp;
- name: General options
  id: api/index#general-options
  summary: null
  belongs_to: API
  description: '## General options'
- name: Getting Started
  id: getting-started/index
  summary: First, download and install the esbuild command locally
  description: "# Getting Started\n\n## Install esbuild\n\nFirst, download and install the esbuild command locally. A prebuilt native executable can be installed using [npm](https://docs.npmjs.com/cli/v8/commands/npm-install) (which is automatically installed when you install the [node](https://nodejs.org/) JavaScript runtime):\n\n``` javascript\nnpm install --save-exact --save-dev esbuild\n```\n\nThis should have installed esbuild in your local `node_modules` folder. You can run the esbuild executable to verify that everything is working correctly:\n\n``` javascript\n./node_modules/.bin/esbuild --version\n```\n\n``` javascript\n.\\node_modules\\.bin\\esbuild --version\n```\n\nThe recommended way to install esbuild is to install the native executable using npm. But if you don't want to do that, there are also some [other ways to install](#other-ways-to-install).\n\n## Your first bundle\n\nThis is a quick real-world example of what esbuild is capable of and how to use it. First, install the `react` and `react-dom` packages:\n\n``` javascript\nnpm install react react-dom\n```\n\nThen create a file called `app.jsx` containing the following code:\n\n``` javascript\nimport * as React from 'react'\nimport * as Server from 'react-dom/server'\n\nlet Greet = () => <h1>Hello, world!</h1>\nconsole.log(Server.renderToString(<Greet />))\n```\n\nFinally, tell esbuild to bundle the file:\n\n``` javascript\n./node_modules/.bin/esbuild app.jsx --bundle --outfile=out.js\n```\n\n``` javascript\n.\\node_modules\\.bin\\esbuild app.jsx --bundle --outfile=out.js\n```\n\nThis should have created a file called `out.js` containing your code and the React library bundled together. The code is completely self-contained and no longer depends on your `node_modules` directory. If you run the code using `node out.js`, you should see something like this:\n\n``` javascript\n<h1 data-reactroot=\"\">Hello, world!</h1>\n```\n\nNotice that esbuild also converted JSX syntax to JavaScript without any configuration other than the `.jsx` extension. While esbuild can be configured, it attempts to have reasonable defaults so that many common situations work automatically. If you would like to use JSX syntax in `.js` files instead, you can tell esbuild to allow this using the `--loader:.js=jsx` flag. You can read more about the available configuration options in the [API documentation](../api/index).\n\n## Build scripts\n\nYour build command is something you will be running repeatedly, so you will want to automate it. A natural way of doing this is to add a build script to your `package.json` file like this:\n\n``` javascript\n{\n  \"scripts\": {\n    \"build\": \"esbuild app.jsx --bundle --outfile=out.js\"\n  }\n}\n```\n\nNotice that this uses the `esbuild` command directly without a relative path. This works because everything in the `scripts` section is run with the `esbuild` command already in the path (as long as you have [installed the package](#install-esbuild)).\n\nThe build script can be invoked like this:\n\n``` javascript\nnpm run build\n```\n\nHowever, using the command-line interface can become unwieldy if you need to pass many options to esbuild. For more sophisticated uses you will likely want to write a build script in JavaScript using esbuild's JavaScript API. That might look something like this (note that this code must be saved in a file with the `.mjs` extension because it uses the `import` keyword):\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.jsx'],\n  bundle: true,\n  outfile: 'out.js',\n})\n```\n\nThe `build` function runs the esbuild executable in a child process and returns a promise that resolves when the build is complete. There is also a `buildSync` API that is not asynchronous, but the asynchronous API is better for build scripts because [plugins](../plugins/index) only work with the asynchronous API. You can read more about the configuration options for the build API in the [API documentation](../api/index#build).\n\n## Bundling for the browser\n\nThe bundler outputs code for the browser by default, so no additional configuration is necessary to get started. For development builds you probably want to enable [source maps](../api/index#sourcemap) with `--sourcemap`, and for production builds you probably want to enable [minification](../api/index#minify) with `--minify`. You probably also want to configure the [target](../api/index#target) environment for the browsers you support so that JavaScript syntax which is too new will be transformed into older JavaScript syntax. All of that might looks something like this:\n\n``` sh\nesbuild app.jsx --bundle --minify --sourcemap --target=chrome58,firefox57,safari11,edge16\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.jsx'],\n  bundle: true,\n  minify: true,\n  sourcemap: true,\n  target: ['chrome58', 'firefox57', 'safari11', 'edge16'],\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:       []string{\"app.jsx\"},\n    Bundle:            true,\n    MinifyWhitespace:  true,\n    MinifyIdentifiers: true,\n    MinifySyntax:      true,\n    Engines: []api.Engine{\n      {api.EngineChrome, \"58\"},\n      {api.EngineFirefox, \"57\"},\n      {api.EngineSafari, \"11\"},\n      {api.EngineEdge, \"16\"},\n    },\n    Write: true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nSome npm packages you want to use may not be designed to be run in the browser. Sometimes you can use esbuild's configuration options to work around certain issues and successfully bundle the package anyway. Undefined globals can be replaced with either the [define](../api/index#define) feature in simple cases or the [inject](../api/index#inject) feature in more complex cases.\n\n## Bundling for node\n\nEven though a bundler is not necessary when using node, sometimes it can still be beneficial to process your code with esbuild before running it in node. Bundling can automatically strip TypeScript types, convert ECMAScript module syntax to CommonJS, and transform newer JavaScript syntax into older syntax for a specific version of node. And it may be beneficial to bundle your package before publishing it so that it's a smaller download and so it spends less time reading from the file system when being loaded.\n\nIf you are bundling code that will be run in node, you should configure the [platform](../api/index#platform) setting by passing `--platform=node` to esbuild. This simultaneously changes a few different settings to node-friendly default values. For example, all packages that are built-in to node such as `fs` are automatically marked as external so esbuild doesn't try to bundle them. This setting also disables the interpretation of the browser field in `package.json`.\n\nIf your code uses newer JavaScript syntax that doesn't work in your version of node, you will want to configure the [target](../api/index#target) version of node:\n\n``` sh\nesbuild app.js --bundle --platform=node --target=node10.4\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  platform: 'node',\n  target: ['node10.4'],\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Platform:    api.PlatformNode,\n    Engines: []api.Engine{\n      {api.EngineNode, \"10.4\"},\n    },\n    Write: true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nYou also may not want to bundle your dependencies with esbuild. There are many node-specific features that esbuild doesn't support while bundling such as `__dirname`, `import.meta.url`, `fs.readFileSync`, and `*.node` native binary modules. You can exclude all of your dependencies from the bundle by setting [packages](../api/index#packages) to external:\n\n``` sh\nesbuild app.jsx --bundle --platform=node --packages=external\n```\n\n``` javascript\nrequire('esbuild').buildSync({\n  entryPoints: ['app.jsx'],\n  bundle: true,\n  platform: 'node',\n  packages: 'external',\n  outfile: 'out.js',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.jsx\"},\n    Bundle:      true,\n    Platform:    api.PlatformNode,\n    Packages:    api.PackagesExternal,\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nIf you do this, your dependencies must still be present on the file system at run-time since they are no longer included in the bundle.\n\n## Simultaneous platforms\n\nYou cannot install esbuild on one OS, copy the `node_modules` directory to another OS without reinstalling, and then run esbuild on that other OS. This won't work because esbuild is written with native code and needs to install a platform-specific binary executable. Normally this isn't an issue because you typically check your `package.json` file into version control, not your `node_modules` directory, and then everyone runs `npm install` on their local machine after cloning the repository.\n\nHowever, people sometimes get into this situation by installing esbuild on Windows or macOS and copying their `node_modules` directory into a [Docker](https://www.docker.com/) image that runs Linux, or by copying their `node_modules` directory between Windows and [WSL](https://docs.microsoft.com/en-us/windows/wsl/) environments. The way to get this to work depends on your package manager:\n\n- **npm/pnpm:** If you are installing with npm or pnpm, you can try not copying the `node_modules` directory when you copy the files over, and running `npm ci` or `npm install` on the destination platform after the copy. Or you could consider using [Yarn](https://yarnpkg.com/) instead which has built-in support for installing a package on multiple platforms simultaneously.\n\n- **Yarn:** If you are installing with Yarn, you can try listing both this platform and the other platform in your `.yarnrc.yml` file using [the `supportedArchitectures` feature](https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures). Keep in mind that this means multiple copies of esbuild will be present on the file system.\n\nYou can also get into this situation on a macOS computer with an ARM processor if you install esbuild using the ARM version of npm but then try to run esbuild with the x86-64 version of node running inside of [Rosetta](https://en.wikipedia.org/wiki/Rosetta_(software)). In that case, an easy fix is to run your code using the ARM version of node instead, which can be downloaded here: <https://nodejs.org/en/download/>.\n\nAnother alternative is to [use the `esbuild-wasm` package instead](#wasm), which works the same way on all platforms. But it comes with a heavy performance cost and can sometimes be 10x slower than the `esbuild` package, so you may also not want to do that.\n\n## Using Yarn Plug'n'Play\n\nYarn's [Plug'n'Play](https://yarnpkg.com/features/pnp/) package installation strategy is supported natively by esbuild. To use it, make sure you are running esbuild such that the [current working directory](../api/index#working-directory) contains Yarn's generated package manifest JavaScript file (either `.pnp.cjs` or `.pnp.js`). If a Yarn Plug'n'Play package manifest is detected, esbuild will automatically resolve package imports to paths inside the `.zip` files in Yarn's package cache, and will automatically extract these files on the fly during bundling.\n\nBecause esbuild is written in Go, support for Yarn Plug'n'Play has been completely re-implemented in Go instead of relying on Yarn's JavaScript API. This allows Yarn Plug'n'Play package resolution to integrate well with esbuild's fully parallelized bundling pipeline for maximum speed. Note that Yarn's command-line interface adds a lot of unavoidable performance overhead to every command. For maximum esbuild performance, you may want to consider running esbuild without using Yarn's CLI (i.e. not using `yarn esbuild`). This can result in esbuild running 10x faster.\n\n## Other ways to install\n\nThe recommended way to install esbuild is to [install the native executable using npm](#install-esbuild). But you can also install esbuild in these ways:\n\n### Download a build\n\nIf you have a Unix system, you can use the following command to download the `esbuild` binary executable for your current platform (it will be downloaded to the current working directory):\n\n``` javascript\ncurl -fsSL https://esbuild.github.io/dl/v0.23.0 | sh\n```\n\nYou can also use `latest` instead of the version number to download the most recent version of esbuild:\n\n``` javascript\ncurl -fsSL https://esbuild.github.io/dl/latest | sh\n```\n\nIf you don't want to evaluate a shell script from the internet to download esbuild, you can also manually download the package from npm yourself instead (which is all the above shell script is doing). Although the precompiled native executables are hosted using npm, you don't actually need npm installed to download them. The npm package registry is a normal HTTP server and packages are normal gzipped tar files.\n\nHere is an example of downloading a binary executable directly:\n\n``` sh\ncurl -O https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.23.0.tgz\ntar xzf ./darwin-x64-0.23.0.tgz\n./package/bin/esbuild\nUsage:\n  esbuild [options] [entry points]\n\n...\n```\n\nThe native executable in the `@esbuild/darwin-x64` package is for the macOS operating system and the 64-bit Intel architecture. As of writing, this is the full list of native executable packages for the platforms esbuild supports:\n\n| Package name                                                                       | OS        | Architecture | Download |\n|------------------------------------------------------------------------------------|-----------|--------------|----------|\n| [`@esbuild/aix-ppc64`](https://www.npmjs.org/package/@esbuild/aix-ppc64)           | `aix`     | `ppc64`      |          |\n| [`@esbuild/android-arm`](https://www.npmjs.org/package/@esbuild/android-arm)       | `android` | `arm`        |          |\n| [`@esbuild/android-arm64`](https://www.npmjs.org/package/@esbuild/android-arm64)   | `android` | `arm64`      |          |\n| [`@esbuild/android-x64`](https://www.npmjs.org/package/@esbuild/android-x64)       | `android` | `x64`        |          |\n| [`@esbuild/darwin-arm64`](https://www.npmjs.org/package/@esbuild/darwin-arm64)     | `darwin`  | `arm64`      |          |\n| [`@esbuild/darwin-x64`](https://www.npmjs.org/package/@esbuild/darwin-x64)         | `darwin`  | `x64`        |          |\n| [`@esbuild/freebsd-arm64`](https://www.npmjs.org/package/@esbuild/freebsd-arm64)   | `freebsd` | `arm64`      |          |\n| [`@esbuild/freebsd-x64`](https://www.npmjs.org/package/@esbuild/freebsd-x64)       | `freebsd` | `x64`        |          |\n| [`@esbuild/linux-arm`](https://www.npmjs.org/package/@esbuild/linux-arm)           | `linux`   | `arm`        |          |\n| [`@esbuild/linux-arm64`](https://www.npmjs.org/package/@esbuild/linux-arm64)       | `linux`   | `arm64`      |          |\n| [`@esbuild/linux-ia32`](https://www.npmjs.org/package/@esbuild/linux-ia32)         | `linux`   | `ia32`       |          |\n| [`@esbuild/linux-loong64`](https://www.npmjs.org/package/@esbuild/linux-loong64)   | `linux`   | `loong64`²   |          |\n| [`@esbuild/linux-mips64el`](https://www.npmjs.org/package/@esbuild/linux-mips64el) | `linux`   | `mips64el`²  |          |\n| [`@esbuild/linux-ppc64`](https://www.npmjs.org/package/@esbuild/linux-ppc64)       | `linux`   | `ppc64`      |          |\n| [`@esbuild/linux-riscv64`](https://www.npmjs.org/package/@esbuild/linux-riscv64)   | `linux`   | `riscv64`²   |          |\n| [`@esbuild/linux-s390x`](https://www.npmjs.org/package/@esbuild/linux-s390x)       | `linux`   | `s390x`      |          |\n| [`@esbuild/linux-x64`](https://www.npmjs.org/package/@esbuild/linux-x64)           | `linux`   | `x64`        |          |\n| [`@esbuild/netbsd-x64`](https://www.npmjs.org/package/@esbuild/netbsd-x64)         | `netbsd`¹ | `x64`        |          |\n| [`@esbuild/openbsd-arm64`](https://www.npmjs.org/package/@esbuild/openbsd-arm64)   | `openbsd` | `arm64`      |          |\n| [`@esbuild/openbsd-x64`](https://www.npmjs.org/package/@esbuild/openbsd-x64)       | `openbsd` | `x64`        |          |\n| [`@esbuild/sunos-x64`](https://www.npmjs.org/package/@esbuild/sunos-x64)           | `sunos`   | `x64`        |          |\n| [`@esbuild/win32-arm64`](https://www.npmjs.org/package/@esbuild/win32-arm64)       | `win32`   | `arm64`      |          |\n| [`@esbuild/win32-ia32`](https://www.npmjs.org/package/@esbuild/win32-ia32)         | `win32`   | `ia32`       |          |\n| [`@esbuild/win32-x64`](https://www.npmjs.org/package/@esbuild/win32-x64)           | `win32`   | `x64`        |          |\n\n**Why this is not recommended:** This approach only works on Unix systems that can run shell scripts, so it will require [WSL](https://learn.microsoft.com/en-us/windows/wsl/) on Windows. An additional drawback is that you cannot use [plugins](../plugins/index) with the native version of esbuild.\n\nIf you choose to write your own code to download esbuild directly from npm, then you are relying on internal implementation details of esbuild's native executable installer. These details may change at some point, in which case this approach will no longer work for new esbuild versions. This is only a minor drawback though since the approach should still work forever for existing esbuild versions (packages published to npm are immutable).\n\n¹ This operating system is not on [node's list of supported platforms](https://nodejs.org/api/process.html#process_process_platform)  \n² This architecture is not on [node's list of supported architectures](https://nodejs.org/api/process.html#processarch)\n\n### Install the WASM version\n\nIn addition to the `esbuild` npm package, there is also an `esbuild-wasm` package that functions similarly but that uses WebAssembly instead of native code. Installing it will also install an executable called `esbuild`:\n\n``` javascript\nnpm install --save-exact esbuild-wasm\n```\n\n**Why this is not recommended:** The WebAssembly version is much, much slower than the native version. In many cases it is an order of magnitude (i.e. 10x) slower. This is for various reasons including a) node re-compiles the WebAssembly code from scratch on every run, b) Go's WebAssembly compilation approach is single-threaded, and c) node has WebAssembly bugs that can delay the exiting of the process by many seconds. The WebAssembly version also excludes some features such as the local file server. You should only use the WebAssembly package like this if there is no other option, such as when you want to use esbuild on an unsupported platform. The WebAssembly package is primarily intended to only be used [in the browser](../api/index#browser).\n\n### Deno instead of node\n\nThere is also basic support for the [Deno](https://deno.land) JavaScript environment if you'd like to use esbuild with that instead. The package is hosted at <https://deno.land/x/esbuild> and uses the native esbuild executable. The executable will be downloaded and cached from npm at run-time so your computer will need network access to registry.npmjs.org to make use of this package. Using the package looks like this:\n\n``` javascript\nimport * as esbuild from 'https://deno.land/x/esbuild@v0.23.0/mod.js'\nlet ts = 'let test: boolean = true'\nlet result = await esbuild.transform(ts, { loader: 'ts' })\nconsole.log('result:', result)\nawait esbuild.stop()\n```\n\nIt has basically the same API as esbuild's npm package with one addition: you need to call `stop()` when you're done because unlike node, Deno doesn't provide the necessary APIs to allow Deno to exit while esbuild's internal child process is still running.\n\nIf you would like to use esbuild's WebAssembly implementation instead of esbuild's native implementation with Deno, you can do that by importing `wasm.js` instead of `mod.js` like this:\n\n``` javascript\nimport * as esbuild from 'https://deno.land/x/esbuild@v0.23.0/wasm.js'\nlet ts = 'let test: boolean = true'\nlet result = await esbuild.transform(ts, { loader: 'ts' })\nconsole.log('result:', result)\nawait esbuild.stop()\n```\n\nUsing WebAssembly instead of native means you do not need to specify Deno's `--allow-run` permission, and WebAssembly the only option in situations where the file system is unavailable such as with [Deno Deploy](https://deno.com/deploy). However, keep in mind that the WebAssembly version of esbuild is a lot slower than the native version. Another thing to know about WebAssembly is that Deno currently has a bug where process termination is unnecessarily delayed until all loaded WebAssembly modules are fully optimized, which can take many seconds. You may want to manually call `Deno.exit(0)` after your code is done if you are writing a short-lived script that uses esbuild's WebAssembly implementation so that your code exits in a reasonable timeframe.\n\n**Why this is not recommended:** Deno is newer than node, less widely used, and supports fewer platforms than node, so node is recommended as the primary way to run esbuild. Deno also uses the internet as a package system instead of existing JavaScript package ecosystems, and esbuild is designed around and optimized for npm-style package management. You should still be able to use esbuild with Deno, but you will need a plugin if you would like to be able to bundle HTTP URLs.\n\n### Build from source\n\nTo build esbuild from source:\n\n1.  Install the Go compiler:\n\n    <https://go.dev/dl/>\n\n2.  Download the source code for esbuild:\n\n    ``` javascript\n    git clone --depth 1 --branch v0.23.0 https://github.com/evanw/esbuild.git\n    cd esbuild\n    ```\n\n3.  Build the `esbuild` executable (it will be `esbuild.exe` on Windows):\n\n    ``` javascript\n    go build ./cmd/esbuild\n    ```\n\nIf you want to build for other platforms, you can just prefix the build command with the platform information. For example, you can build the 32-bit Linux version using this command:\n\n``` javascript\nGOOS=linux GOARCH=386 go build ./cmd/esbuild\n```\n\n**Why this is not recommended:** The native version can only be used via the command-line interface, which can be unergonomic for complex use cases and which does not support [plugins](../plugins/index). You will need to write JavaScript or Go code and use [esbuild's API](../api/index) to use plugins.\n\n© 2020 Evan Wallace  \nLicensed under the MIT License.  \n[https://esbuild.github.io/getting-started/](https://esbuild.github.io/getting-started/)"
- name: Global name
  id: api/index#global-name
  summary: This option only matters when the format setting is iife (which stands for immediately-invoked function expression)
  belongs_to: API
  description: |-
    ### Global name

    *Supported by: [Build](#build) and [Transform](#transform)*

    This option only matters when the [format](#format) setting is `iife` (which stands for immediately-invoked function expression). It sets the name of the global variable which is used to store the exports from the entry point:

    ``` sh
    echo 'module.exports = "test"' | esbuild --format=iife --global-name=xyz
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let js = 'module.exports = "test"'
    let result = await esbuild.transform(js, {
      format: 'iife',
      globalName: 'xyz',
    })
    console.log(result.code)
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      js := "module.exports = 'test'"

      result := api.Transform(js, api.TransformOptions{
        Format:     api.FormatIIFE,
        GlobalName: "xyz",
      })

      if len(result.Errors) == 0 {
        fmt.Printf("%s", result.Code)
      }
    }
    ```

    Specifying the global name with the `iife` format will generate code that looks something like this:

    ``` javascript
    var xyz = (() => {
      ...
      var require_stdin = __commonJS((exports, module) => {
        module.exports = "test";
      });
      return require_stdin();
    })();
    ```

    The global name can also be a compound property expression, in which case esbuild will generate a global variable with that property. Existing global variables that conflict will not be overwritten. This can be used to implement "namespacing" where multiple independent scripts add their exports onto the same global object. For example:

    ``` sh
    echo 'module.exports = "test"' | esbuild --format=iife --global-name='example.versions["1.0"]'
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let js = 'module.exports = "test"'
    let result = await esbuild.transform(js, {
      format: 'iife',
      globalName: 'example.versions["1.0"]',
    })
    console.log(result.code)
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      js := "module.exports = 'test'"

      result := api.Transform(js, api.TransformOptions{
        Format:     api.FormatIIFE,
        GlobalName: `example.versions["1.0"]`,
      })

      if len(result.Errors) == 0 {
        fmt.Printf("%s", result.Code)
      }
    }
    ```

    The compound global name used above generates code that looks like this:

    ``` javascript
    var example = example || {};
    example.versions = example.versions || {};
    example.versions["1.0"] = (() => {
      ...
      var require_stdin = __commonJS((exports, module) => {
        module.exports = "test";
      });
      return require_stdin();
    })();
    ```
- name: HTTP plugin
  id: plugins/index#http-plugin
  summary: 'This example demonstrates: using a path format other than file system paths, namespace-specific path resolution, using resolve and load callbacks together'
  belongs_to: Plugins
  description: |-
    ### HTTP plugin

    *This example demonstrates: using a path format other than file system paths, namespace-specific path resolution, using resolve and load callbacks together.*

    This plugin allows you to import HTTP URLs into JavaScript code. The code will automatically be downloaded at build time. It enables the following workflow:

    ``` javascript
    import { zip } from 'https://unpkg.com/lodash-es@4.17.15/lodash.js'
    console.log(zip([1, 2], ['a', 'b']))
    ```

    This can be accomplished with the following plugin. Note that for real usage the downloads should be cached, but caching has been omitted from this example for brevity:

    ``` javascript
    import * as esbuild from 'esbuild'
    import https from 'node:https'
    import http from 'node:http'

    let httpPlugin = {
      name: 'http',
      setup(build) {
        // Intercept import paths starting with "http:" and "https:" so
        // esbuild doesn't attempt to map them to a file system location.
        // Tag them with the "http-url" namespace to associate them with
        // this plugin.
        build.onResolve({ filter: /^https?:\/\// }, args => ({
          path: args.path,
          namespace: 'http-url',
        }))

        // We also want to intercept all import paths inside downloaded
        // files and resolve them against the original URL. All of these
        // files will be in the "http-url" namespace. Make sure to keep
        // the newly resolved URL in the "http-url" namespace so imports
        // inside it will also be resolved as URLs recursively.
        build.onResolve({ filter: /.*/, namespace: 'http-url' }, args => ({
          path: new URL(args.path, args.importer).toString(),
          namespace: 'http-url',
        }))

        // When a URL is loaded, we want to actually download the content
        // from the internet. This has just enough logic to be able to
        // handle the example import from unpkg.com but in reality this
        // would probably need to be more complex.
        build.onLoad({ filter: /.*/, namespace: 'http-url' }, async (args) => {
          let contents = await new Promise((resolve, reject) => {
            function fetch(url) {
              console.log(`Downloading: ${url}`)
              let lib = url.startsWith('https') ? https : http
              let req = lib.get(url, res => {
                if ([301, 302, 307].includes(res.statusCode)) {
                  fetch(new URL(res.headers.location, url).toString())
                  req.abort()
                } else if (res.statusCode === 200) {
                  let chunks = []
                  res.on('data', chunk => chunks.push(chunk))
                  res.on('end', () => resolve(Buffer.concat(chunks)))
                } else {
                  reject(new Error(`GET ${url} failed: status ${res.statusCode}`))
                }
              }).on('error', reject)
            }
            fetch(args.path)
          })
          return { contents }
        })
      },
    }

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      outfile: 'out.js',
      plugins: [httpPlugin],
    })
    ```

    ``` go
    package main

    import "io/ioutil"
    import "net/http"
    import "net/url"
    import "os"
    import "github.com/evanw/esbuild/pkg/api"

    var httpPlugin = api.Plugin{
      Name: "http",
      Setup: func(build api.PluginBuild) {
        // Intercept import paths starting with "http:" and "https:" so
        // esbuild doesn't attempt to map them to a file system location.
        // Tag them with the "http-url" namespace to associate them with
        // this plugin.
        build.OnResolve(api.OnResolveOptions{Filter: `^https?://`},
          func(args api.OnResolveArgs) (api.OnResolveResult, error) {
            return api.OnResolveResult{
              Path:      args.Path,
              Namespace: "http-url",
            }, nil
          })

        // We also want to intercept all import paths inside downloaded
        // files and resolve them against the original URL. All of these
        // files will be in the "http-url" namespace. Make sure to keep
        // the newly resolved URL in the "http-url" namespace so imports
        // inside it will also be resolved as URLs recursively.
        build.OnResolve(api.OnResolveOptions{Filter: ".*", Namespace: "http-url"},
          func(args api.OnResolveArgs) (api.OnResolveResult, error) {
            base, err := url.Parse(args.Importer)
            if err != nil {
              return api.OnResolveResult{}, err
            }
            relative, err := url.Parse(args.Path)
            if err != nil {
              return api.OnResolveResult{}, err
            }
            return api.OnResolveResult{
              Path:      base.ResolveReference(relative).String(),
              Namespace: "http-url",
            }, nil
          })

        // When a URL is loaded, we want to actually download the content
        // from the internet. This has just enough logic to be able to
        // handle the example import from unpkg.com but in reality this
        // would probably need to be more complex.
        build.OnLoad(api.OnLoadOptions{Filter: ".*", Namespace: "http-url"},
          func(args api.OnLoadArgs) (api.OnLoadResult, error) {
            res, err := http.Get(args.Path)
            if err != nil {
              return api.OnLoadResult{}, err
            }
            defer res.Body.Close()
            bytes, err := ioutil.ReadAll(res.Body)
            if err != nil {
              return api.OnLoadResult{}, err
            }
            contents := string(bytes)
            return api.OnLoadResult{Contents: &contents}, nil
          })
      },
    }

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Outfile:     "out.js",
        Plugins:     []api.Plugin{httpPlugin},
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    The plugin first uses a resolver to move `http://` and `https://` URLs to the `http-url` namespace. Setting the namespace tells esbuild to not treat these paths as file system paths. Then, a loader for the `http-url` namespace downloads the module and returns the contents to esbuild. From there, another resolver for import paths inside modules in the `http-url` namespace picks up relative paths and translates them into full URLs by resolving them against the importing module's URL. That then feeds back into the loader allowing downloaded modules to download additional modules recursively.
- name: Ignore annotations
  id: api/index#ignore-annotations
  summary: Since JavaScript is a dynamic language, identifying unused code is sometimes very difficult for a compiler, so the community has developed certain annotations to help tell compilers what code should be considered side-effect free and available for removal
  belongs_to: API
  description: |-
    ### Ignore annotations

    *Supported by: [Build](#build) and [Transform](#transform)*

    Since JavaScript is a dynamic language, identifying unused code is sometimes very difficult for a compiler, so the community has developed certain annotations to help tell compilers what code should be considered side-effect free and available for removal. Currently there are two forms of side-effect annotations that esbuild supports:

    - Inline `/* @__PURE__ */` comments before function calls tell esbuild that the function call can be removed if the resulting value isn't used. See the [pure](#pure) API option for more information.

    - The `sideEffects` field in `package.json` can be used to tell esbuild which files in your package can be removed if all imports from that file end up being unused. This is a convention from Webpack and many libraries published to npm already have this field in their package definition. You can learn more about this field in [Webpack's documentation](https://webpack.js.org/guides/tree-shaking/) for this field.

    These annotations can be problematic because the compiler depends completely on developers for accuracy, and developers occasionally publish packages with incorrect annotations. The `sideEffects` field is particularly error-prone for developers because by default it causes all files in your package to be considered dead code if no imports are used. If you add a new file containing side effects and forget to update that field, your package will likely break when people try to bundle it.

    This is why esbuild includes a way to ignore side-effect annotations. You should only enable this if you encounter a problem where the bundle is broken because necessary code was unexpectedly removed from the bundle:

    ``` sh
    esbuild app.js --bundle --ignore-annotations
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      ignoreAnnotations: true,
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints:       []string{"app.js"},
        Bundle:            true,
        IgnoreAnnotations: true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Enabling this means esbuild will no longer respect `/* @__PURE__ */` comments or the `sideEffects` field. It will still do automatic [tree shaking](#tree-shaking) of unused imports, however, since that doesn't rely on annotations from developers. Ideally this flag is only a temporary workaround. You should report these issues to the maintainer of the package to get them fixed since they indicate a problem with the package and they will likely trip up other people too.
- name: Import from JavaScript
  id: content-types/index#css-from-js
  summary: You can also import CSS from JavaScript
  belongs_to: Content Types
  description: |-
    ### Import from JavaScript

    You can also import CSS from JavaScript. When you do this, esbuild will gather all CSS files referenced from a given entry point and bundle it into a sibling CSS output file next to the JavaScript output file for that JavaScript entry point. So if esbuild generates `app.js` it would also generate `app.css` containing all CSS files referenced by `app.js`. Here's an example of importing a CSS file from JavaScript:

    ``` javascript
    import './button.css'

    export let Button = ({ text }) =>
      <div className="button">{text}</div>
    ```

    The bundled JavaScript generated by esbuild will not automatically import the generated CSS into your HTML page for you. Instead, you should import the generated CSS into your HTML page yourself along with the generated JavaScript. This means the browser can download the CSS and JavaScript files in parallel, which is the most efficient way to do it. That looks like this:

    ``` javascript
    <html>
      <head>
        <link href="app.css" rel="stylesheet">
        <script src="app.js"></script>
      </head>
    </html>
    ```

    If the generated output names are not straightforward (for example if you have added `[hash]` to the [entry names](../api/index#entry-names) setting and the output file names have content hashes) then you will likely want to look up the generated output names in the [metafile](../api/index#metafile). To do this, first find the JS file by looking for the output with the matching `entryPoint` property. This file goes in the `<script>` tag. The associated CSS file can then be found using the `cssBundle` property. This file goes in the `<link>` tag.
- name: In the browser
  id: api/index#browser
  summary: The esbuild API can also run in the browser using WebAssembly in a Web Worker
  belongs_to: API
  description: |-
    ### In the browser

    The esbuild API can also run in the browser using WebAssembly in a Web Worker. To take advantage of this you will need to install the `esbuild-wasm` package instead of the `esbuild` package:

    ``` javascript
    npm install esbuild-wasm
    ```

    The API for the browser is similar to the API for node except that you need to call `initialize()` first, and you need to pass the URL of the WebAssembly binary. The synchronous versions of the API are also not available. Assuming you are using a bundler, that would look something like this:

    ``` javascript
    import * as esbuild from 'esbuild-wasm'

    await esbuild.initialize({
      wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
    })

    let result1 = await esbuild.transform(code, options)
    let result2 = esbuild.build(options)
    ```

    If you're already running this code from a worker and don't want `initialize` to create another worker, you can pass `worker: false` to it. Then it will create a WebAssembly module in the same thread as the thread that calls `initialize`.

    You can also use esbuild's API as a script tag in a HTML file without needing to use a bundler by loading the `lib/browser.min.js` file with a `<script>` tag. In this case the API creates a global called `esbuild` that holds the API object:

    ``` javascript
    <script src="./node_modules/esbuild-wasm/lib/browser.min.js"></script>
    <script>
      esbuild.initialize({
        wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
      }).then(() => {
        ...
      })
    </script>
    ```

    If you want to use this API with ECMAScript modules, you should import the `esm/browser.min.js` file instead:

    ``` javascript
    <script type="module">
      import * as esbuild from './node_modules/esbuild-wasm/esm/browser.min.js'

      await esbuild.initialize({
        wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
      })

      ...
    </script>
    ```
- name: Inject
  id: api/index#inject
  summary: This option allows you to automatically replace a global variable with an import from another file
  belongs_to: API
  description: |-
    ### Inject

    *Supported by: [Build](#build)*

    This option allows you to automatically replace a global variable with an import from another file. This can be a useful tool for adapting code that you don't control to a new environment. For example, assume you have a file called `process-cwd-shim.js` that exports a shim using the export name `process.cwd`:

    ``` javascript
    // process-cwd-shim.js
    let processCwdShim = () => ''
    export { processCwdShim as 'process.cwd' }
    ```

    ``` javascript
    // entry.js
    console.log(process.cwd())
    ```

    This is intended to replace uses of node's `process.cwd()` function to prevent packages that call it from crashing when run in the browser. You can use the inject feature to replace all references to the global property `process.cwd` with an import from that file:

    ``` sh
    esbuild entry.js --inject:./process-cwd-shim.js --outfile=out.js
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['entry.js'],
      inject: ['./process-cwd-shim.js'],
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"entry.js"},
        Inject:      []string{"./process-cwd-shim.js"},
        Outfile:     "out.js",
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    That results in something like this:

    ``` javascript
    // out.js
    var processCwdShim = () => "";
    console.log(processCwdShim());
    ```

    You can think of the inject feature as similar to the [define](#define) feature, except it replaces an expression with an import to a file instead of with a constant, and the expression to replace is specified using an export name in a file instead of using an inline string in esbuild's API.

    #### Auto-import for [JSX](../content-types/index#jsx)

    React (the library for which JSX syntax was originally created) has a mode they call `automatic` where you don't have to `import` anything to use JSX syntax. Instead, the JSX-to-JS transformer will automatically import the correct JSX factory function for you. You can enable `automatic` JSX mode with esbuild's [`jsx`](#jsx) setting. If you want auto-import for JSX and you are using a sufficiently new version of React, then you should be using the `automatic` JSX mode.

    However, setting `jsx` to `automatic` unfortunately also means you are using a highly React-specific JSX transform instead of the default general-purpose JSX transform. This means writing a JSX factory function is more complicated, and it also means that the `automatic` mode doesn't work with libraries that expect to be used with the standard JSX transform (including older versions of React).

    You can use esbuild's inject feature to automatically import the [factory](#jsx-factory) and [fragment](#jsx-fragment) for JSX expressions when the JSX transform is not set to `automatic`. Here's an example file that can be injected to do this:

    ``` javascript
    const { createElement, Fragment } = require('react')
    export {
      createElement as 'React.createElement',
      Fragment as 'React.Fragment',
    }
    ```

    This code uses the React library as an example, but you can use this approach with any other JSX library as well with appropriate changes.

    #### Injecting files without imports

    You can also use this feature with files that have no exports. In that case the injected file just comes first before the rest of the output as if every input file contained `import "./file.js"`. Because of the way ECMAScript modules work, this injection is still "hygienic" in that symbols with the same name in different files are renamed so they don't collide with each other.

    #### Conditionally injecting a file

    If you want to *conditionally* import a file only if the export is actually used, you should mark the injected file as not having side effects by putting it in a package and adding `"sideEffects": false` in that package's `package.json` file. This setting is a [convention from Webpack](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free) that esbuild respects for any imported file, not just files used with inject.
- name: Input
  id: api/index#input
  summary: null
  belongs_to: API
  description: '## Input'
- name: Install esbuild
  id: getting-started/index#install-esbuild
  summary: First, download and install the esbuild command locally
  belongs_to: Getting Started
  description: |-
    ## Install esbuild

    First, download and install the esbuild command locally. A prebuilt native executable can be installed using [npm](https://docs.npmjs.com/cli/v8/commands/npm-install) (which is automatically installed when you install the [node](https://nodejs.org/) JavaScript runtime):

    ``` javascript
    npm install --save-exact --save-dev esbuild
    ```

    This should have installed esbuild in your local `node_modules` folder. You can run the esbuild executable to verify that everything is working correctly:

    ``` javascript
    ./node_modules/.bin/esbuild --version
    ```

    ``` javascript
    .\node_modules\.bin\esbuild --version
    ```

    The recommended way to install esbuild is to install the native executable using npm. But if you don't want to do that, there are also some [other ways to install](#other-ways-to-install).
- name: Install the WASM version
  id: getting-started/index#wasm
  summary: In addition to the esbuild npm package, there is also an esbuild-wasm package that functions similarly but that uses WebAssembly instead of native code
  belongs_to: Getting Started
  description: |-
    ### Install the WASM version

    In addition to the `esbuild` npm package, there is also an `esbuild-wasm` package that functions similarly but that uses WebAssembly instead of native code. Installing it will also install an executable called `esbuild`:

    ``` javascript
    npm install --save-exact esbuild-wasm
    ```

    **Why this is not recommended:** The WebAssembly version is much, much slower than the native version. In many cases it is an order of magnitude (i.e. 10x) slower. This is for various reasons including a) node re-compiles the WebAssembly code from scratch on every run, b) Go's WebAssembly compilation approach is single-threaded, and c) node has WebAssembly bugs that can delay the exiting of the process by many seconds. The WebAssembly version also excludes some features such as the local file server. You should only use the WebAssembly package like this if there is no other option, such as when you want to use esbuild on an unsupported platform. The WebAssembly package is primarily intended to only be used [in the browser](../api/index#browser).
- name: JavaScript
  id: content-types/index#javascript
  summary: This loader is enabled by default for .js, .cjs, and .mjs files
  belongs_to: Content Types
  description: |-
    ## JavaScript

    Loader: `js`

    This loader is enabled by default for `.js`, `.cjs`, and `.mjs` files. The `.cjs` extension is used by node for CommonJS modules and the `.mjs` extension is used by node for ECMAScript modules.

    Note that by default, esbuild's output will take advantage of all modern JS features. For example, `a !== void 0 && a !== null ? a : b` will become `a ?? b` when minifying is enabled which makes use of syntax from the [ES2020](https://262.ecma-international.org/11.0/#prod-CoalesceExpression) version of JavaScript. If this is undesired, you must specify esbuild's [target](../api/index#target) setting to say in which browsers you need the output to work correctly. Then esbuild will avoid using JavaScript features that are too modern for those browsers.

    All modern JavaScript syntax is supported by esbuild. Newer syntax may not be supported by older browsers, however, so you may want to configure the [target](../api/index#target) option to tell esbuild to convert newer syntax to older syntax as appropriate.

    These syntax features are always transformed for older browsers:

    | Syntax transform                                                                                                   | Language version | Example       |
    |--------------------------------------------------------------------------------------------------------------------|------------------|---------------|
    | [Trailing commas in function parameter lists and calls](https://github.com/tc39/proposal-trailing-function-commas) | `es2017`         | `foo(a, b, )` |
    | [Numeric separators](https://github.com/tc39/proposal-numeric-separator)                                           | `esnext`         | `1_000_000`   |

    These syntax features are conditionally transformed for older browsers depending on the configured language [target](../api/index#target):

    | Syntax transform                                                                      | Transformed when `--target` is below | Example                     |
    |---------------------------------------------------------------------------------------|--------------------------------------|-----------------------------|
    | [Exponentiation operator](https://github.com/tc39/proposal-exponentiation-operator)   | `es2016`                             | `a ** b`                    |
    | [Async functions](https://github.com/tc39/ecmascript-asyncawait)                      | `es2017`                             | `async () => {}`            |
    | [Asynchronous iteration](https://github.com/tc39/proposal-async-iteration)            | `es2018`                             | `for await (let x of y) {}` |
    | [Async generators](https://github.com/tc39/proposal-async-iteration)                  | `es2018`                             | `async function* foo() {}`  |
    | [Spread properties](https://github.com/tc39/proposal-object-rest-spread)              | `es2018`                             | `let x = {...y}`            |
    | [Rest properties](https://github.com/tc39/proposal-object-rest-spread)                | `es2018`                             | `let {...x} = y`            |
    | [Optional catch binding](https://github.com/tc39/proposal-optional-catch-binding)     | `es2019`                             | `try {} catch {}`           |
    | [Optional chaining](https://github.com/tc39/proposal-optional-chaining)               | `es2020`                             | `a?.b`                      |
    | [Nullish coalescing](https://github.com/tc39/proposal-nullish-coalescing)             | `es2020`                             | `a ?? b`                    |
    | [`import.meta`](https://github.com/tc39/proposal-import-meta)                         | `es2020`                             | `import.meta`               |
    | [Logical assignment operators](https://github.com/tc39/proposal-logical-assignment)   | `es2021`                             | `a ??= b`                   |
    | [Class instance fields](https://github.com/tc39/proposal-class-fields)                | `es2022`                             | `class { x }`               |
    | [Static class fields](https://github.com/tc39/proposal-static-class-features)         | `es2022`                             | `class { static x }`        |
    | [Private instance methods](https://github.com/tc39/proposal-private-methods)          | `es2022`                             | `class { #x() {} }`         |
    | [Private instance fields](https://github.com/tc39/proposal-class-fields)              | `es2022`                             | `class { #x }`              |
    | [Private static methods](https://github.com/tc39/proposal-static-class-features)      | `es2022`                             | `class { static #x() {} }`  |
    | [Private static fields](https://github.com/tc39/proposal-static-class-features)       | `es2022`                             | `class { static #x }`       |
    | [Ergonomic brand checks](https://github.com/tc39/proposal-private-fields-in-in)       | `es2022`                             | `#x in y`                   |
    | [Class static blocks](https://github.com/tc39/proposal-class-static-block)            | `es2022`                             | `class { static {} }`       |
    | [Import assertions](https://github.com/tc39/proposal-import-assertions)               | `esnext`                             | `import "x" assert {}` ¹    |
    | [Import attributes](https://github.com/tc39/proposal-import-attributes)               | `esnext`                             | `import "x" with {}`        |
    | [Auto-accessors](https://github.com/tc39/proposal-decorators#class-auto-accessors)    | `esnext`                             | `class { accessor x }`      |
    | [`using` declarations](https://github.com/tc39/proposal-explicit-resource-management) | `esnext`                             | `using x = y`               |
    | [Decorators](https://github.com/tc39/proposal-decorators)                             | `esnext`                             | `@foo class Bar {}`         |

    ¹ Import assertions never made it into the JavaScript specification. They are deprecated in favor of import attributes and are actively being removed from JavaScript runtimes.

    These syntax features are currently always passed through un-transformed:

    | Syntax transform                                                                                                   | Unsupported when `--target` is below | Example                   |
    |--------------------------------------------------------------------------------------------------------------------|--------------------------------------|---------------------------|
    | [RegExp `dotAll` flag](https://github.com/tc39/proposal-regexp-dotall-flag)                                        | `es2018`                             | `/./s` ¹                  |
    | [RegExp lookbehind assertions](https://github.com/tc39/proposal-regexp-lookbehind)                                 | `es2018`                             | `/(?<=x)y/` ¹             |
    | [RegExp named capture groups](https://github.com/tc39/proposal-regexp-named-groups)                                | `es2018`                             | `/(?<foo>\d+)/` ¹         |
    | [RegExp unicode property escapes](https://github.com/tc39/proposal-regexp-unicode-property-escapes)                | `es2018`                             | `/\p{ASCII}/u` ¹          |
    | [BigInt](https://github.com/tc39/proposal-bigint)                                                                  | `es2020`                             | `123n`                    |
    | [Top-level await](https://github.com/tc39/proposal-top-level-await)                                                | `es2022`                             | `await import(x)`         |
    | [Arbitrary module namespace identifiers](https://github.com/bmeck/proposal-arbitrary-module-namespace-identifiers) | `es2022`                             | `export {foo as 'f o o'}` |
    | [RegExp match indices](https://github.com/tc39/proposal-regexp-match-indices)                                      | `es2022`                             | `/x(.+)y/d` ¹             |
    | [RegExp set notation](https://github.com/tc39/proposal-regexp-v-flag)                                              | `es2024`                             | `/[\w--\d]/v` ¹           |
    | [Hashbang grammar](https://github.com/tc39/proposal-hashbang)                                                      | `esnext`                             | `#!/usr/bin/env node`     |

    ¹ Unsupported regular expression literals are transformed into a `new RegExp()` constructor call so you can bring your own polyfill library to get them to work anyway.

    See also [the list of finished ECMAScript proposals](https://github.com/tc39/proposals/blob/main/finished-proposals.md) and [the list of active ECMAScript proposals](https://github.com/tc39/proposals/blob/main/README.md). Note that while transforming code containing top-level await is supported, bundling code containing top-level await is only supported when the [output format](../api/index#format) is set to [`esm`](../api/index#format-esm).
- name: JavaScript caveats
  id: content-types/index#javascript-caveats
  summary: Transforming ES6+ syntax to ES5 is not supported yet
  belongs_to: Content Types
  description: |-
    ### JavaScript caveats

    You should keep the following things in mind when using JavaScript with esbuild:

    #### ES5 is not supported well

    Transforming ES6+ syntax to ES5 is not supported yet. However, if you're using esbuild to transform ES5 code, you should still set the [target](../api/index#target) to `es5`. This prevents esbuild from introducing ES6 syntax into your ES5 code. For example, without this flag the object literal `{x: x}` will become `{x}` and the string `"a\nb"` will become a multi-line template literal when minifying. Both of these substitutions are done because the resulting code is shorter, but the substitutions will not be performed if the [target](../api/index#target) is `es5`.

    #### Private member performance

    The private member transform (for the `#name` syntax) uses `WeakMap` and `WeakSet` to preserve the privacy properties of this feature. This is similar to the corresponding transforms in the Babel and TypeScript compilers. Most modern JavaScript engines (V8, JavaScriptCore, and SpiderMonkey but not ChakraCore) may not have good performance characteristics for large `WeakMap` and `WeakSet` objects.

    Creating many instances of classes with private fields or private methods with this syntax transform active may cause a lot of overhead for the garbage collector. This is because modern engines (other than ChakraCore) store weak values in an actual map object instead of as hidden properties on the keys themselves, and large map objects can cause performance issues with garbage collection. See [this reference](https://github.com/tc39/ecma262/issues/1657#issuecomment-518916579) for more information.

    #### Imports follow ECMAScript module behavior

    You might try to modify global state before importing a module which needs that global state and expect it to work. However, JavaScript (and therefore esbuild) effectively "hoists" all `import` statements to the top of the file, so doing this won't work:

    ``` javascript
    window.foo = {}
    import './something-that-needs-foo'
    ```

    There are some broken implementations of ECMAScript modules out there (e.g. the TypeScript compiler) that don't follow the JavaScript specification in this regard. Code compiled with these tools may "work" since the `import` is replaced with an inline call to `require()`, which ignores the hoisting requirement. But such code will not work with real ECMAScript module implementations such as node, a browser, or esbuild, so writing code like this is non-portable and is not recommended.

    The way to do this correctly is to move the global state modification into its own import. That way it *will* be run before the other import:

    ``` javascript
    import './assign-to-foo-on-window'
    import './something-that-needs-foo'
    ```

    #### Avoid direct `eval` when bundling

    Although the expression `eval(x)` looks like a normal function call, it actually takes on special behavior in JavaScript. Using `eval` in this way means that the evaluated code stored in `x` can reference any variable in any containing scope by name. For example, the code `let y = 123; return eval('y')` will return `123`.

    This is called "direct eval" and is problematic when bundling your code for many reasons:

    - Modern bundlers contain an optimization called "scope hoisting" that merges all bundled files into a single file and renames variables to avoid name collisions. However, this means code evaluated by direct `eval` can read and write variables in any file in the bundle! This is a correctness issue because the evaluated code may try to access a global variable but may accidentally access a private variable with the same name from another file instead. It can potentially even be a security issue if a private variable in another file has sensitive data.

    - The evaluated code may not work correctly when it references variables imported using an `import` statement. Imported variables are live bindings to variables in another file. They are not copies of those variables. So when esbuild bundles your code, your imports are replaced with a direct reference to the variable in the imported file. But that variable may have a different name, in which case the code evaluated by direct `eval` will be unable to reference it by the expected name.

    - Using direct `eval` forces esbuild to deoptimize all of the code in all of the scopes containing calls to direct `eval`. For correctness, it must assume that the evaluated code might need to access any of the other code in the file reachable from that `eval` call. This means none of that code will be eliminated as dead code and none of that code will be minified.

    - Because the code evaluated by the direct `eval` could need to reference any reachable variable by name, esbuild is prevented from renaming all of the variables reachable by the evaluated code. This means it can't rename variables to avoid name collisions with other variables in the bundle. So the direct `eval` causes esbuild to wrap the file in a CommonJS closure, which avoids name collisions by introducing a new scope instead. However, this makes the generated code bigger and slower because exported variables use run-time dynamic binding instead of compile-time static binding.

    Luckily it is usually easy to avoid using direct `eval`. There are two commonly-used alternatives that avoid all of the drawbacks mentioned above:

    - `(0, eval)('x')`

      This is known as "indirect eval" because `eval` is not being called directly, and so does not trigger the grammatical special case for direct eval in the JavaScript VM. You can call indirect eval using any syntax at all except for an expression of the exact form `eval('x')`. For example, `var eval2 = eval; eval2('x')` and `[eval][0]('x')` and `window.eval('x')` are all indirect eval calls. When you use indirect eval, the code is evaluated in the global scope instead of in the inline scope of the caller.

    - `new Function('x')`

      This constructs a new function object at run-time. It is as if you wrote `function() { x }` in the global scope except that `x` can be an arbitrary string of code. This form is sometimes convenient because you can add arguments to the function, and use those arguments to expose variables to the evaluated code. For example, `(new Function('env', 'x'))(someEnv)` is as if you wrote `(function(env) { x })(someEnv)`. This is often a sufficient alternative for direct `eval` when the evaluated code needs to access local variables because you can pass the local variables in as arguments.

    #### The value of `toString()` is not preserved on functions (and classes)

    It's somewhat common to call `toString()` on a JavaScript function object and then pass that string to some form of `eval` to get a new function object. This effectively "rips" the function out of the containing file and breaks links with all variables in that file. Doing this with esbuild is not supported and may not work. In particular, esbuild often uses helper methods to implement certain features and it assumes that JavaScript scope rules have not been tampered with. For example:

    ``` javascript
    let pow = (a, b) => a ** b;
    let pow2 = (0, eval)(pow.toString());
    console.log(pow2(2, 3));
    ```

    When this code is compiled for ES6, where the `**` operator isn't available, the `**` operator is replaced with a call to the `__pow` helper function:

    ``` javascript
    let __pow = Math.pow;
    let pow = (a, b) => __pow(a, b);
    let pow2 = (0, eval)(pow.toString());
    console.log(pow2(2, 3));
    ```

    If you try to run this code, you'll get an error such as `ReferenceError: __pow is not defined` because the function `(a, b) => __pow(a, b)` depends on the locally-scoped symbol `__pow` which is not available in the global scope. This is the case for many JavaScript language features including `async` functions, as well as some esbuild-specific features such as the [keep names](../api/index#keep-names) setting.

    This problem most often comes up when people get the source code of a function with `.toString()` and then try to use it as the body of a [web worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API). If you are doing this and you want to use esbuild, you should instead build the source code for the web worker in a separate build step and then insert the web worker source code as a string into the code that creates the web worker. The [define](../api/index#define) feature is one way to insert the string at build time.

    #### The value of `this` is not preserved on functions called from a module namespace object

    In JavaScript, the value of `this` in a function is automatically filled in for you based on how the function is called. For example if a function is called using `obj.fn()`, the value of `this` during the function call will be `obj`. This behavior is respected by esbuild with one exception: if you call a function from a module namespace object, the value of `this` may not be correct. For example, consider this code that calls `foo` from the module namespace object `ns`:

    ``` javascript
    import * as ns from './foo.js'
    ns.foo()
    ```

    If `foo.js` tries to reference the module namespace object using `this`, then it won't necessarily work after the code is bundled with esbuild:

    ``` javascript
    // foo.js
    export function foo() {
      this.bar()
    }
    export function bar() {
      console.log('bar')
    }
    ```

    The reason for this is that esbuild automatically rewrites code most code that uses module namespace objects to code that imports things directly instead. That means the example code above will be converted to this instead, which removes the `this` context for the function call:

    ``` javascript
    import { foo } from './foo.js'
    foo()
    ```

    This transformation dramatically improves [tree shaking](../api/index#tree-shaking) (a.k.a. dead code elimination) because it makes it possible for esbuild to understand which exported symbols are unused. It has the drawback that this changes the behavior of code that uses `this` to access the module's exports, but this isn't an issue because no one should ever write bizarre code like this in the first place. If you need to access an exported function from the same file, just call it directly (i.e. `bar()` instead of `this.bar()` in the example above).

    #### The `default` export can be error-prone

    The ES module format (i.e. ESM) have a special export called `default` that sometimes behaves differently than all other export names. When code in the ESM format that has a `default` export is converted to the CommonJS format, and then that CommonJS code is imported into another module in ESM format, there are two different interpretations of what should happen that are both widely-used (the [Babel](https://babeljs.io/) way and the [Node](https://nodejs.org/) way). This is very unfortunate because it causes endless compatibility headaches, especially since JavaScript libraries are often authored in ESM and published as CommonJS.

    When esbuild [bundles](../api/index#bundle) code that does this, it has to decide which interpretation to use, and there's no perfect answer. The heuristics that esbuild uses are the same heuristics that [Webpack](https://webpack.js.org/) uses (see below for details). Since Webpack is the most widely-used bundler, this means that esbuild is being the most compatible that it can be with the existing ecosystem regarding this compatibility problem. So the good news is that if you can get code with this problem to work with esbuild, it should also work with Webpack.

    Here's an example that demonstrates the problem:

    ``` javascript
    // index.js
    import foo from './somelib.js'
    console.log(foo)
    ```

    ``` javascript
    // somelib.js
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = 'foo';
    ```

    And here are the two interpretations, both of which are widely-used:

    - **The Babel interpretation**

      If the Babel interpretation is used, this code will print `foo`. Their rationale is that `somelib.js` was converted from ESM into CommonJS (as you can tell by the `__esModule` marker) and the original code looked something like this:

      ``` javascript
      // somelib.js
      export default 'foo'
      ```

      If `somelib.js` hadn't been converted from ESM into CommonJS, then this code would print `foo`, so it should still print `foo` regardless of the module format. This is accomplished by detecting when a CommonJS module used to be an ES module via the `__esModule` marker (which all module conversion tools set including Babel, TypeScript, Webpack, and esbuild) and setting the default import to `exports.default` if the `__esModule` marker is present. This behavior is important because it's necessary to run cross-compiled ESM correctly in a CommonJS environment, and for a long time that was the only way to run ESM code in Node before Node eventually added native ESM support.

    - **The Node interpretation**

      If the Node interpretation is used, this code will print `{ default: 'foo' }`. Their rationale is that CommonJS code uses dynamic exports while ESM code uses static exports, so the fully general approach to importing CommonJS into ESM is to expose the CommonJS `exports` object itself somehow. For example, CommonJS code can do `exports[Math.random()] = 'foo'` which has no equivalent in ESM syntax. The `default` export is used for this because that's actually what it was originally designed for by the people who came up with the ES module specification. This interpretation is entirely reasonable for normal CommonJS modules. It only causes compatibility problems for CommonJS modules that used to be ES modules (i.e. when `__esModule` is present) in which case the behavior diverges from the Babel interpretation.

    *If you are a library author:* When writing new code, you should strongly consider avoiding the `default` export entirely. It has unfortunately been tainted with compatibility problems and using it will likely cause problems for your users at some point.

    *If you are a library user:* By default, esbuild will use the Babel interpretation. If you want esbuild to use the Node interpretation instead, you need to either put your code in a file ending in `.mts` or `.mjs`, or you need to add `"type": "module"` to your `package.json` file. The rationale is that Node's native ESM support can only run ESM code if the file extension is `.mjs` or `"type": "module"` is present, so doing that is a good signal that the code is intended to be run in Node, and should therefore use the Node interpretation of `default` import. This is the same heuristic that Webpack uses.
- name: JS-specific details
  id: api/index#js-details
  summary: The JS API for esbuild comes in both asynchronous and synchronous flavors
  belongs_to: API
  description: |-
    ### JS-specific details

    The JS API for esbuild comes in both asynchronous and synchronous flavors. The [asynchronous API](#js-async) is recommended because it works in all environments and it's faster and more powerful. The [synchronous API](#js-sync) only works in node and can only do certain things, but it's sometimes necessary in certain node-specific situations. In detail:

    #### Async API

    Asynchronous API calls return their results using a promise. Note that you'll likely have to use the `.mjs` file extension in node due to the use of the `import` and top-level `await` keywords:

    ``` javascript
    import * as esbuild from 'esbuild'

    let result1 = await esbuild.transform(code, options)
    let result2 = await esbuild.build(options)
    ```

    Pros:

    - You can use [plugins](../plugins/index) with the asynchronous API
    - The current thread is not blocked so you can perform other work in the meantime
    - You can run many simultaneous esbuild API calls concurrently which are then spread across all available CPUs for maximum performance

    Cons:

    - Using promises can result in messier code, especially in CommonJS where [top-level await](https://v8.dev/features/top-level-await) is not available
    - Doesn't work in situations that must be synchronous such as within [`require.extensions`](https://nodejs.org/api/modules.html#requireextensions)

    #### Sync API

    Synchronous API calls return their results inline:

    ``` javascript
    let esbuild = require('esbuild')

    let result1 = esbuild.transformSync(code, options)
    let result2 = esbuild.buildSync(options)
    ```

    Pros:

    - Avoiding promises can result in cleaner code, especially when [top-level await](https://v8.dev/features/top-level-await) is not available
    - Works in situations that must be synchronous such as within [`require.extensions`](https://nodejs.org/api/modules.html#requireextensions)

    Cons:

    - You can't use [plugins](../plugins/index) with the synchronous API since plugins are asynchronous
    - It blocks the current thread so you can't perform other work in the meantime
    - Using the synchronous API prevents esbuild from parallelizing esbuild API calls

    &nbsp;
- name: JSON
  id: content-types/index#json
  summary: This loader is enabled by default for .json files
  belongs_to: Content Types
  description: |-
    ## JSON

    Loader: `json`

    This loader is enabled by default for `.json` files. It parses the JSON file into a JavaScript object at build time and exports the object as the default export. Using it looks something like this:

    ``` javascript
    import object from './example.json'
    console.log(object)
    ```

    In addition to the default export, there are also named exports for each top-level property in the JSON object. Importing a named export directly means esbuild can automatically remove unused parts of the JSON file from the bundle, leaving only the named exports that you actually used. For example, this code will only include the `version` field when bundled:

    ``` javascript
    import { version } from './package.json'
    console.log(version)
    ```
- name: JSX
  id: content-types/index#jsx
  summary: JSX is an XML-like syntax extension for JavaScript that was created for React
  belongs_to: Content Types
  description: |-
    ## JSX

    Loader: `jsx` or `tsx`

    [JSX](https://facebook.github.io/jsx/) is an XML-like syntax extension for JavaScript that was created for [React](https://github.com/facebook/react). It's intended to be converted into normal JavaScript by your build tool. Each XML element becomes a normal JavaScript function call. For example, the following JSX code:

    ``` javascript
    import Button from './button'
    let button = <Button>Click me</Button>
    render(button)
    ```

    Will be converted to the following JavaScript code:

    ``` javascript
    import Button from "./button";
    let button = React.createElement(Button, null, "Click me");
    render(button);
    ```

    This loader is enabled by default for `.jsx` and `.tsx` files. Note that JSX syntax is not enabled in `.js` files by default. If you would like to enable that, you will need to configure it:

    ``` sh
    esbuild app.js --bundle --loader:.js=jsx
    ```

    ``` javascript
    require('esbuild').buildSync({
      entryPoints: ['app.js'],
      bundle: true,
      loader: { '.js': 'jsx' },
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Loader: map[string]api.Loader{
          ".js": api.LoaderJSX,
        },
        Write: true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: JSX
  id: api/index#jsx
  summary: This option tells esbuild what to do about JSX syntax
  belongs_to: API
  description: |-
    ### JSX

    *Supported by: [Build](#build) and [Transform](#transform)*

    This option tells esbuild what to do about JSX syntax. Here are the available options:

    - `transform`

      This tells esbuild to transform JSX to JS using a general-purpose transform that's shared between many libraries that use JSX syntax. Each JSX element is turned into a call to the [JSX factory](#jsx-factory) function with the element's component (or with the [JSX fragment](#jsx-fragment) for fragments) as the first argument. The second argument is an array of props (or `null` if there are no props). Any child elements present become additional arguments after the second argument.

      If you want to configure this setting on a per-file basis, you can do that by using a `// @jsxRuntime classic` comment. This is a convention from [Babel's JSX plugin](https://babeljs.io/docs/en/babel-preset-react/) that esbuild follows.

    - `preserve`

      This preserves the JSX syntax in the output instead of transforming it into function calls. JSX elements are treated as first-class syntax and are still affected by other settings such as [minification](#minify) and [property mangling](#mangle-props).

      Note that this means the output files are no longer valid JavaScript code. This feature is intended to be used when you want to transform the JSX syntax in esbuild's output files by another tool after bundling.

    - `automatic`

      This transform was [introduced in React 17+](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html) and is very specific to React. It automatically generates `import` statements from the [JSX import source](#jsx-import-source) and introduces many special cases regarding how the syntax is handled. The details are too complicated to describe here. For more information, please read [React's documentation about their new JSX transform](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md). If you want to enable the development mode version of this transform, you need to additionally enable the [JSX dev](#jsx-dev) setting.

      If you want to configure this setting on a per-file basis, you can do that by using a `// @jsxRuntime automatic` comment. This is a convention from [Babel's JSX plugin](https://babeljs.io/docs/en/babel-preset-react/) that esbuild follows.

    Here's an example of setting the JSX transform to `preserve`:

    ``` sh
    echo '<div/>' | esbuild --jsx=preserve --loader=jsx
    <div />;
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let result = await esbuild.transform('<div/>', {
      jsx: 'preserve',
      loader: 'jsx',
    })

    console.log(result.code)
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      result := api.Transform("<div/>", api.TransformOptions{
        JSX:    api.JSXPreserve,
        Loader: api.LoaderJSX,
      })

      if len(result.Errors) == 0 {
        fmt.Printf("%s", result.Code)
      }
    }
    ```
- name: JSX dev
  id: api/index#jsx-dev
  summary: If the JSX transform has been set to automatic, then enabling this setting causes esbuild to automatically inject the file name and source location into each JSX element
  belongs_to: API
  description: |-
    ### JSX dev

    *Supported by: [Build](#build) and [Transform](#transform)*

    If the [JSX](#jsx) transform has been set to `automatic`, then enabling this setting causes esbuild to automatically inject the file name and source location into each JSX element. Your JSX library can then use this information to help with debugging. If the JSX transform has been set to something other than `automatic`, then this setting does nothing. Here's an example of enabling this setting:

    ``` sh
    echo '<a/>' | esbuild --loader=jsx --jsx=automatic
    import { jsx } from "react/jsx-runtime";
    /* @__PURE__ */ jsx("a", {});
    echo '<a/>' | esbuild --loader=jsx --jsx=automatic --jsx-dev
    import { jsxDEV } from "react/jsx-dev-runtime";
    /* @__PURE__ */ jsxDEV("a", {}, void 0, false, {
      fileName: "<stdin>",
      lineNumber: 1,
      columnNumber: 1
    }, this);
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.jsx'],
      jsxDev: true,
      jsx: 'automatic',
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.jsx"},
        JSXDev:      true,
        JSX:         api.JSXAutomatic,
        Outfile:     "out.js",
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: JSX factory
  id: api/index#jsx-factory
  summary: This sets the function that is called for each JSX element
  belongs_to: API
  description: |-
    ### JSX factory

    *Supported by: [Build](#build) and [Transform](#transform)*

    This sets the function that is called for each JSX element. Normally a JSX expression such as this:

    ``` javascript
    <div>Example text</div>
    ```

    is compiled into a function call to `React.createElement` like this:

    ``` javascript
    React.createElement("div", null, "Example text");
    ```

    You can call something other than `React.createElement` by changing the JSX factory. For example, to call the function `h` instead (which is used by other libraries such as [Preact](https://preactjs.com/)):

    ``` sh
    echo '<div/>' | esbuild --jsx-factory=h --loader=jsx
    /* @__PURE__ */ h("div", null);
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let result = await esbuild.transform('<div/>', {
      jsxFactory: 'h',
      loader: 'jsx',
    })

    console.log(result.code)
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      result := api.Transform("<div/>", api.TransformOptions{
        JSXFactory: "h",
        Loader:     api.LoaderJSX,
      })

      if len(result.Errors) == 0 {
        fmt.Printf("%s", result.Code)
      }
    }
    ```

    Alternatively, if you are using TypeScript, you can just configure JSX for TypeScript by adding this to your `tsconfig.json` file and esbuild should pick it up automatically without needing to be configured:

    ``` javascript
    {
      "compilerOptions": {
        "jsxFactory": "h"
      }
    }
    ```

    If you want to configure this on a per-file basis, you can do that by using a `// @jsx h` comment. Note that this setting does not apply when the [JSX](#jsx) transform has been set to `automatic`.
- name: JSX fragment
  id: api/index#jsx-fragment
  summary: This sets the function that is called for each JSX fragment
  belongs_to: API
  description: |-
    ### JSX fragment

    *Supported by: [Build](#build) and [Transform](#transform)*

    This sets the function that is called for each JSX fragment. Normally a JSX fragment expression such as this:

    ``` javascript
    <>Stuff</>
    ```

    is compiled into a use of the `React.Fragment` component like this:

    ``` javascript
    React.createElement(React.Fragment, null, "Stuff");
    ```

    You can use a component other than `React.Fragment` by changing the JSX fragment. For example, to use the component `Fragment` instead (which is used by other libraries such as [Preact](https://preactjs.com/)):

    ``` sh
    echo '<>x</>' | esbuild --jsx-fragment=Fragment --loader=jsx
    /* @__PURE__ */ React.createElement(Fragment, null, "x");
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let result = await esbuild.transform('<>x</>', {
      jsxFragment: 'Fragment',
      loader: 'jsx',
    })

    console.log(result.code)
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      result := api.Transform("<>x</>", api.TransformOptions{
        JSXFragment: "Fragment",
        Loader:      api.LoaderJSX,
      })

      if len(result.Errors) == 0 {
        fmt.Printf("%s", result.Code)
      }
    }
    ```

    Alternatively, if you are using TypeScript, you can just configure JSX for TypeScript by adding this to your `tsconfig.json` file and esbuild should pick it up automatically without needing to be configured:

    ``` javascript
    {
      "compilerOptions": {
        "jsxFragmentFactory": "Fragment"
      }
    }
    ```

    If you want to configure this on a per-file basis, you can do that by using a `// @jsxFrag Fragment` comment. Note that this setting does not apply when the [JSX](#jsx) transform has been set to `automatic`.
- name: JSX import source
  id: api/index#jsx-import-source
  summary: If the JSX transform has been set to automatic, then setting this lets you change which library esbuild uses to automatically import its JSX helper functions from
  belongs_to: API
  description: |-
    ### JSX import source

    *Supported by: [Build](#build) and [Transform](#transform)*

    If the [JSX](#jsx) transform has been set to `automatic`, then setting this lets you change which library esbuild uses to automatically import its JSX helper functions from. Note that this only works with the JSX transform that's [specific to React 17+](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html). If you set the JSX import source to `your-pkg`, then that package must expose at least the following exports:

    ``` javascript
    import { createElement } from "your-pkg"
    import { Fragment, jsx, jsxs } from "your-pkg/jsx-runtime"
    import { Fragment, jsxDEV } from "your-pkg/jsx-dev-runtime"
    ```

    The `/jsx-runtime` and `/jsx-dev-runtime` subpaths are hard-coded by design and cannot be changed. The `jsx` and `jsxs` imports are used when [JSX dev mode](#jsx-dev) is off and the `jsxDEV` import is used when JSX dev mode is on. The meaning of these is described in [React's documentation about their new JSX transform](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md). The `createElement` import is used regardless of the JSX dev mode when an element has a prop spread followed by a `key` prop, which looks like this:

    ``` javascript
    return <div {...props} key={key} />
    ```

    Here's an example of setting the JSX import source to [`preact`](https://preactjs.com/):

    ``` sh
    esbuild app.jsx --jsx-import-source=preact --jsx=automatic
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.jsx'],
      jsxImportSource: 'preact',
      jsx: 'automatic',
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints:     []string{"app.jsx"},
        JSXImportSource: "preact",
        JSX:             api.JSXAutomatic,
        Outfile:         "out.js",
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Alternatively, if you are using TypeScript, you can just configure the JSX import source for TypeScript by adding this to your `tsconfig.json` file and esbuild should pick it up automatically without needing to be configured:

    ``` javascript
    {
      "compilerOptions": {
        "jsx": "react-jsx",
        "jsxImportSource": "preact"
      }
    }
    ```

    And if you want to control this setting on the per-file basis, you can do that with a `// @jsxImportSource your-pkg` comment in each file. You may also need to add a `// @jsxRuntime automatic` comment as well if the [JSX](#jsx) transform has not already been set by other means, or if you want that to be set on a per-file basis as well.
- name: JSX side effects
  id: api/index#jsx-side-effects
  summary: By default esbuild assumes that JSX expressions are side-effect free, which means they are annoated with /* @__PURE__ */ comments and are removed during bundling when they are unused
  belongs_to: API
  description: |-
    ### JSX side effects

    *Supported by: [Build](#build) and [Transform](#transform)*

    By default esbuild assumes that JSX expressions are side-effect free, which means they are annoated with [`/* @__PURE__ */` comments](#pure) and are removed during bundling when they are unused. This follows the common use of JSX for virtual DOM and applies to the vast majority of JSX libraries. However, some people have written JSX libraries that don't have this property (specifically JSX expressions can have arbitrary side effects and can't be removed when unused). If you are using such a library, you can use this setting to tell esbuild that JSX expressions have side effects:

    ``` sh
    esbuild app.jsx --jsx-side-effects
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.jsx'],
      outfile: 'out.js',
      jsxSideEffects: true,
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints:    []string{"app.jsx"},
        Outfile:        "out.js",
        JSXSideEffects: true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Keep names
  id: api/index#keep-names
  summary: In JavaScript the name property on functions and classes defaults to a nearby identifier in the source code
  belongs_to: API
  description: |-
    ### Keep names

    *Supported by: [Build](#build) and [Transform](#transform)*

    In JavaScript the `name` property on functions and classes defaults to a nearby identifier in the source code. These syntax forms all set the `name` property of the function to `"fn"`:

    ``` javascript
    function fn() {}
    let fn = function() {};
    fn = function() {};
    let [fn = function() {}] = [];
    let {fn = function() {}} = {};
    [fn = function() {}] = [];
    ({fn = function() {}} = {});
    ```

    However, [minification](#minify) renames symbols to reduce code size and [bundling](#bundle) sometimes need to rename symbols to avoid collisions. That changes value of the `name` property for many of these cases. This is usually fine because the `name` property is normally only used for debugging. However, some frameworks rely on the `name` property for registration and binding purposes. If this is the case, you can enable this option to preserve the original `name` values even in minified code:

    ``` sh
    esbuild app.js --minify --keep-names
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      minify: true,
      keepNames: true,
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints:       []string{"app.js"},
        MinifyWhitespace:  true,
        MinifyIdentifiers: true,
        MinifySyntax:      true,
        KeepNames:         true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Note that this feature is unavailable if the [target](#target) has been set to an old environment that doesn't allow esbuild to mutate the `name` property on functions and classes. This is the case for environments that don't support ES6.
- name: Legal comments
  id: api/index#legal-comments
  summary: A "legal comment" is considered to be any statement-level comment in JS or rule-level comment in CSS that contains @license or @preserve or that starts with //! or /*!. These comments are preserved in output files by default since that follows the intent of the original authors of the code
  belongs_to: API
  description: "### Legal comments\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nA \"legal comment\" is considered to be any statement-level comment in JS or rule-level comment in CSS that contains `@license` or `@preserve` or that starts with `//!` or `/*!`. These comments are preserved in output files by default since that follows the intent of the original authors of the code. However, this behavior can be configured by using one of the following options:\n\n- `none`  \n  Do not preserve any legal comments.\n\n- `inline`  \n  Preserve all legal comments.\n\n- `eof`  \n  Move all legal comments to the end of the file.\n\n- `linked`  \n  Move all legal comments to a `.LEGAL.txt` file and link to them with a comment.\n\n- `external`  \n  Move all legal comments to a `.LEGAL.txt` file but to not link to them.\n\nThe default behavior is `eof` when [bundling](#bundle) is enabled and `inline` otherwise. Setting the legal comment mode looks like this:\n\n``` sh\nesbuild app.js --legal-comments=eof\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  legalComments: 'eof',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints:   []string{\"app.js\"},\n    LegalComments: api.LegalCommentsEndOfFile,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nNote that \"statement-level\" for JS and \"rule-level\" for CSS means the comment must appear in a context where multiple statements or rules are allowed such as in the top-level scope or in a statement or rule block. So comments inside expressions or at the declaration level are not considered legal comments."
- name: Line limit
  id: api/index#line-limit
  summary: This setting is a way to prevent esbuild from generating output files with really long lines, which can help editing performance in poorly-implemented text editors
  belongs_to: API
  description: |-
    ### Line limit

    *Supported by: [Build](#build) and [Transform](#transform)*

    This setting is a way to prevent esbuild from generating output files with really long lines, which can help editing performance in poorly-implemented text editors. Set this to a positive integer to tell esbuild to end a given line soon after it passes that number of bytes. For example, this wraps long lines soon after they pass ~80 characters:

    ``` sh
    esbuild app.ts --line-limit=80
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.ts'],
      lineLimit: 80,
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.ts"},
        LineLimit:   80,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Lines are truncated after they pass the limit instead of before because it's simpler to check when the limit is passed then to predict when the limit is about to be passed, and because it's faster to avoid backing up and rewriting things when generating an output file. So the limit is only approximate.

    This setting applies to both JavaScript and CSS, and works even when minification is disabled. Note that turning this setting on will make your files bigger, as the extra newlines take up additional space in the file (even after gzip compression).
- name: Live reload
  id: api/index#live-reload
  summary: Live reload is an approach to development where you have your browser open and visible at the same time as your code editor
  belongs_to: API
  description: |-
    ### Live reload

    *Supported by: [Build](#build)*

    Live reload is an approach to development where you have your browser open and visible at the same time as your code editor. When you edit and save your source code, the browser automatically reloads and the reloaded version of the app contains your changes. This means you can iterate faster because you don't have to manually switch to your browser, reload, and then switch back to your code editor after every change. It's very helpful when changing CSS, for example.

    There is no esbuild API for live reloading directly. Instead, you can construct live reloading by combining [watch mode](#watch) (to automatically start a build when you edit and save a file) and [serve mode](#serve) (to serve the latest build, but block until it's done) plus a small bit of client-side JavaScript code that you add to your app only during development.

    The first step is to enable [watch](#watch) and [serve](#serve) together:

    ``` sh
    esbuild app.ts --bundle --outdir=www --watch --servedir=www
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let ctx = await esbuild.context({
      entryPoints: ['app.ts'],
      bundle: true,
      outdir: 'www',
    })

    await ctx.watch()

    let { host, port } = await ctx.serve({
      servedir: 'www',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      ctx, err := api.Context(api.BuildOptions{
        EntryPoints: []string{"app.ts"},
        Bundle:      true,
        Outdir:      "www",
      })
      if err != nil {
        os.Exit(1)
      }

      err2 := ctx.Watch(api.WatchOptions{})
      if err2 != nil {
        os.Exit(1)
      }

      result, err3 := ctx.Serve(api.ServeOptions{
        Servedir: "www",
      })
      if err3 != nil {
        os.Exit(1)
      }
    }
    ```

    The second step is to add some code to your JavaScript that subscribes to the `/esbuild` [server-sent event](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events) source. When you get the `change` event, you can reload the page to get the latest version of the app. You can do this in a single line of code:

    ``` javascript
    new EventSource('/esbuild').addEventListener('change', () => location.reload())
    ```

    That's it! If you load your app in the browser, the page should now automatically reload when you edit and save a file (assuming there are no build errors).

    This should only be included during development, and should not be included in production. One way to remove this code in production is to guard it with an if statement such as `if (!window.IS_PRODUCTION)` and then use [define](#define) to set `window.IS_PRODUCTION` to `true` in production.

    #### Live reload caveats

    Implementing live reloading like this has a few known caveats:

    - These events only trigger when esbuild's output changes. They do not trigger when files unrelated to the build being watched are changed. If your HTML file references other files that esbuild doesn't know about and those files are changed, you can either manually reload the page or you can implement your own live reloading infrastructure instead of using esbuild's built-in behavior.

    - The `EventSource` API is supposed to automatically reconnect for you. However, there's [a bug in Firefox](https://bugzilla.mozilla.org/show_bug.cgi?id=1809332) that breaks this if the server is ever temporarily unreachable. Workarounds are to use any other browser, to manually reload the page if this happens, or to write more complicated code that manually closes and re-creates the `EventSource` object if there is a connection error.

    - Browser vendors have decided to not implement HTTP/2 without TLS. This means that when using the `http://` protocol, each `/esbuild` event source will take up one of your precious 6 simultaneous per-domain HTTP/1.1 connections. So if you open more than six HTTP tabs that use this live-reloading technique, you will be unable to use live reloading in some of those tabs (and other things will likely also break). The workaround is to [enable the `https://` protocol](#https).

    #### Hot-reloading for CSS

    The `change` event also contains additional information to enable more advanced use cases. It currently contains the `added`, `removed`, and `updated` arrays with the paths of the files that have changed since the previous build, which can be described by the following TypeScript interface:

    ``` javascript
    interface ChangeEvent {
      added: string[]
      removed: string[]
      updated: string[]
    }
    ```

    The code sample below enables "hot reloading" for CSS, which is when the CSS is automatically updated in place without reloading the page. If an event arrives that isn't CSS-related, then the whole page will be reloaded as a fallback:

    ``` javascript
    new EventSource('/esbuild').addEventListener('change', e => {
      const { added, removed, updated } = JSON.parse(e.data)

      if (!added.length && !removed.length && updated.length === 1) {
        for (const link of document.getElementsByTagName("link")) {
          const url = new URL(link.href)

          if (url.host === location.host && url.pathname === updated[0]) {
            const next = link.cloneNode()
            next.href = updated[0] + '?' + Math.random().toString(36).slice(2)
            next.onload = () => link.remove()
            link.parentNode.insertBefore(next, link.nextSibling)
            return
          }
        }
      }

      location.reload()
    })
    ```

    #### Hot-reloading for JavaScript

    Hot-reloading for JavaScript is not currently implemented by esbuild. It's possible to transparently implement hot-reloading for CSS because CSS is stateless, but JavaScript is stateful so you cannot transparently implement hot-reloading for JavaScript like you can for CSS.

    Some other development servers implement hot-reloading for JavaScript anyway, but it requires additional APIs, sometimes requires framework-specific hacks, and sometimes introduces transient state-related bugs during an editing session. Doing this is outside of esbuild's scope. You are welcome to use other tools instead of esbuild if hot-reloading for JavaScript is one of your requirements.

    However, with esbuild's live-reloading you can persist your app's current JavaScript state in [`sessionStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage) to more easily restore your app's JavaScript state after a page reload. If your app loads quickly (which it already should for your users' sake), live-reloading with JavaScript can be almost as fast as hot-reloading with JavaScript would be.
- name: Loader
  id: api/index#loader
  summary: This option changes how a given input file is interpreted
  belongs_to: API
  description: |-
    ### Loader

    *Supported by: [Build](#build) and [Transform](#transform)*

    This option changes how a given input file is interpreted. For example, the [`js`](../content-types/index#javascript) loader interprets the file as JavaScript and the [`css`](../content-types/index#css) loader interprets the file as CSS. See the [content types](../content-types/index) page for a complete list of all built-in loaders.

    Configuring a loader for a given file type lets you load that file type with an `import` statement or a `require` call. For example, configuring the `.png` file extension to use the [data URL](../content-types/index#data-url) loader means importing a `.png` file gives you a data URL containing the contents of that image:

    ``` javascript
    import url from './example.png'
    let image = new Image
    image.src = url
    document.body.appendChild(image)

    import svg from './example.svg'
    let doc = new DOMParser().parseFromString(svg, 'application/xml')
    let node = document.importNode(doc.documentElement, true)
    document.body.appendChild(node)
    ```

    The above code can be bundled using the [build](#build) API call like this:

    ``` sh
    esbuild app.js --bundle --loader:.png=dataurl --loader:.svg=text
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      loader: {
        '.png': 'dataurl',
        '.svg': 'text',
      },
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Loader: map[string]api.Loader{
          ".png": api.LoaderDataURL,
          ".svg": api.LoaderText,
        },
        Write: true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    This option is specified differently if you are using the build API with input from [stdin](#stdin), since stdin does not have a file extension. Configuring a loader for stdin with the build API looks like this:

    ``` sh
    echo 'import pkg = require("./pkg")' | esbuild --loader=ts --bundle
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      stdin: {
        contents: 'import pkg = require("./pkg")',
        loader: 'ts',
        resolveDir: '.',
      },
      bundle: true,
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        Stdin: &api.StdinOptions{
          Contents:   "import pkg = require('./pkg')",
          Loader:     api.LoaderTS,
          ResolveDir: ".",
        },
        Bundle: true,
      })
      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    The [transform](#transform) API call just takes a single loader since it doesn't involve interacting with the file system, and therefore doesn't deal with file extensions. Configuring a loader (in this case the [`ts`](../content-types/index#typescript) loader) for the transform API looks like this:

    ``` sh
    echo 'let x: number = 1' | esbuild --loader=ts
    let x = 1;
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let ts = 'let x: number = 1'
    let result = await esbuild.transform(ts, {
      loader: 'ts',
    })
    console.log(result.code)
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      ts := "let x: number = 1"
      result := api.Transform(ts, api.TransformOptions{
        Loader: api.LoaderTS,
      })
      if len(result.Errors) == 0 {
        fmt.Printf("%s", result.Code)
      }
    }
    ```
- name: Log level
  id: api/index#log-level
  summary: The log level can be changed to prevent esbuild from printing warning and/or error messages to the terminal
  belongs_to: API
  description: "### Log level\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThe log level can be changed to prevent esbuild from printing warning and/or error messages to the terminal. The six log levels are:\n\n- `silent`  \n  Do not show any log output. This is the default log level when using the JS [transform](#transform) API.\n\n- `error`  \n  Only show errors.\n\n- `warning`  \n  Only show warnings and errors. This is the default log level when using the JS [build](#build) API.\n\n- `info`  \n  Show warnings, errors, and an output file summary. This is the default log level when using the CLI.\n\n- `debug`  \n  Log everything from `info` and some additional messages that may help you debug a broken bundle. This log level has a performance impact and some of the messages may be false positives, so this information is not shown by default.\n\n- `verbose`  \n  This generates a torrent of log messages and was added to debug issues with file system drivers. It's not intended for general use.\n\nThe log level can be set like this:\n\n``` sh\necho 'typeof x == \"null\"' | esbuild --log-level=error\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet js = 'typeof x == \"null\"'\nawait esbuild.transform(js, {\n  logLevel: 'error',\n})\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  js := \"typeof x == 'null'\"\n\n  result := api.Transform(js, api.TransformOptions{\n    LogLevel: api.LogLevelError,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```"
- name: Log limit
  id: api/index#log-limit
  summary: By default, esbuild stops reporting log messages after 10 messages have been reported
  belongs_to: API
  description: |-
    ### Log limit

    *Supported by: [Build](#build) and [Transform](#transform)*

    By default, esbuild stops reporting log messages after 10 messages have been reported. This avoids the accidental generation of an overwhelming number of log messages, which can easily lock up slower terminal emulators such as Windows command prompt. It also avoids accidentally using up the whole scroll buffer for terminal emulators with limited scroll buffers.

    The log limit can be changed to another value, and can also be disabled completely by setting it to zero. This will show all log messages:

    ``` sh
    esbuild app.js --log-limit=0
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      logLimit: 0,
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        LogLimit:    0,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Log override
  id: api/index#log-override
  summary: This feature lets you change the log level of individual types of log messages
  belongs_to: API
  description: "### Log override\n\n*Supported by: [Build](#build) and [Transform](#transform)*\n\nThis feature lets you change the log level of individual types of log messages. You can use it to silence a particular type of warning, to enable additional warnings that aren't enabled by default, or even to turn warnings into errors.\n\nFor example, when targeting older browsers, esbuild automatically transforms regular expression literals which use features that are too new for those browsers into `new RegExp()` calls to allow the generated code to run without being considered a syntax error by the browser. However, these calls will still throw at runtime if you don't add a polyfill for `RegExp` because that regular expression syntax is still unsupported. If you want esbuild to generate a warning when you use newer unsupported regular expression syntax, you can do that like this:\n\n``` sh\nesbuild app.js --log-override:unsupported-regexp=warning --target=chrome50\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  logOverride: {\n    'unsupported-regexp': 'warning',\n  },\n  target: 'chrome50',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    LogOverride: map[string]api.LogLevel{\n      \"unsupported-regexp\": api.LogLevelWarning,\n    },\n    Engines: []api.Engine{\n      {Name: api.EngineChrome, Version: \"50\"},\n    },\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThe log level for each message type can be overridden to any value supported by the [log level](#log-level) setting. All currently-available message types are listed below (click on each one for an example log message):\n\n- **JS:**\n  - `assert-to-with`\n\n    ``` javascript\n    ▲ [WARNING] The \"assert\" keyword is not supported in the configured target environment [assert-to-with]\n\n        example.js:1:31:\n          1 │ import data from \"./data.json\" assert { type: \"json\" }\n            │                                ~~~~~~\n            ╵                                with\n\n      Did you mean to use \"with\" instead of \"assert\"?\n    ```\n\n  - `assert-type-json`\n\n    ``` javascript\n    ▲ [WARNING] Non-default import \"value\" is undefined with a JSON import assertion [assert-type-json]\n\n        example.js:1:78:\n          1 │ import * as data from \"./data.json\" assert { type: \"json\" }; console.log(data.value)\n            ╵                                                                               ~~~~~\n\n      The JSON import assertion is here:\n\n        example.js:1:45:\n          1 │ import * as data from \"./data.json\" assert { type: \"json\" }; console.log(data.value)\n            ╵                                              ~~~~~~~~~~~~\n\n      You can either keep the import assertion and only use the \"default\" import, or you can remove the\n      import assertion and use the \"value\" import.\n    ```\n\n  - `assign-to-constant`\n\n    ``` javascript\n    ▲ [WARNING] This assignment will throw because \"foo\" is a constant [assign-to-constant]\n\n        example.js:1:15:\n          1 │ const foo = 1; foo = 2\n            ╵                ~~~\n\n      The symbol \"foo\" was declared a constant here:\n\n        example.js:1:6:\n          1 │ const foo = 1; foo = 2\n            ╵       ~~~\n    ```\n\n  - `assign-to-define`\n\n    ``` javascript\n    ▲ [WARNING] Suspicious assignment to defined constant \"DEFINE\" [assign-to-define]\n\n        example.js:1:0:\n          1 │ DEFINE = false\n            ╵ ~~~~~~\n\n      The expression \"DEFINE\" has been configured to be replaced with a constant using the \"define\"\n      feature. If this expression is supposed to be a compile-time constant, then it doesn't make sense\n      to assign to it here. Or if this expression is supposed to change at run-time, this \"define\"\n      substitution should be removed.\n    ```\n\n  - `assign-to-import`\n\n    ``` javascript\n    ▲ [WARNING] This assignment will throw because \"foo\" is an import [assign-to-import]\n\n        example.js:1:23:\n          1 │ import foo from \"foo\"; foo = null\n            ╵                        ~~~\n\n      Imports are immutable in JavaScript. To modify the value of this import, you must export a setter\n      function in the imported file (e.g. \"setFoo\") and then import and call that function here instead.\n    ```\n\n  - `call-import-namespace`\n\n    ``` javascript\n    ▲ [WARNING] Calling \"foo\" will crash at run-time because it's an import namespace object, not a function [call-import-namespace]\n\n        example.js:1:28:\n          1 │ import * as foo from \"foo\"; foo()\n            ╵                             ~~~\n\n      Consider changing \"foo\" to a default import instead:\n\n        example.js:1:7:\n          1 │ import * as foo from \"foo\"; foo()\n            │        ~~~~~~~~\n            ╵        foo\n    ```\n\n  - `class-name-will-throw`\n\n    ``` javascript\n    ▲ [WARNING] Accessing class \"Foo\" before initialization will throw [class-name-will-throw]\n\n        example.js:1:40:\n          1 │ class Foo { static key = \"foo\"; static [Foo.key] = 123 }\n            ╵                                         ~~~\n    ```\n\n  - `commonjs-variable-in-esm`\n\n    ``` javascript\n    ▲ [WARNING] The CommonJS \"exports\" variable is treated as a global variable in an ECMAScript module and may not work as expected [commonjs-variable-in-esm]\n\n        example.js:1:0:\n          1 │ exports.foo = 1; export let bar = 2\n            ╵ ~~~~~~~\n\n      This file is considered to be an ECMAScript module because of the \"export\" keyword here:\n\n        example.js:1:17:\n          1 │ exports.foo = 1; export let bar = 2\n            ╵                  ~~~~~~\n    ```\n\n  - `delete-super-property`\n\n    ``` javascript\n    ▲ [WARNING] Attempting to delete a property of \"super\" will throw a ReferenceError [delete-super-property]\n\n        example.js:1:42:\n          1 │ class Foo extends Object { foo() { delete super.foo } }\n            ╵                                           ~~~~~\n    ```\n\n  - `direct-eval`\n\n    ``` javascript\n    ▲ [WARNING] Using direct eval with a bundler is not recommended and may cause problems [direct-eval]\n\n        example.js:1:22:\n          1 │ let apparentlyUnused; eval(\"actuallyUse(apparentlyUnused)\")\n            ╵                       ~~~~\n\n      You can read more about direct eval and bundling here: https://esbuild.github.io/link/direct-eval\n    ```\n\n  - `duplicate-case`\n\n    ``` javascript\n    ▲ [WARNING] This case clause will never be evaluated because it duplicates an earlier case clause [duplicate-case]\n\n        example.js:1:33:\n          1 │ switch (foo) { case 1: return 1; case 1: return 2 }\n            ╵                                  ~~~~\n\n      The earlier case clause is here:\n\n        example.js:1:15:\n          1 │ switch (foo) { case 1: return 1; case 1: return 2 }\n            ╵                ~~~~\n    ```\n\n  - `duplicate-class-member`\n\n    ``` javascript\n    ▲ [WARNING] Duplicate member \"x\" in class body [duplicate-class-member]\n\n        example.js:1:19:\n          1 │ class Foo { x = 1; x = 2 }\n            ╵                    ^\n\n      The original member \"x\" is here:\n\n        example.js:1:12:\n          1 │ class Foo { x = 1; x = 2 }\n            ╵             ^\n    ```\n\n  - `duplicate-object-key`\n\n    ``` javascript\n    ▲ [WARNING] Duplicate key \"bar\" in object literal [duplicate-object-key]\n\n        example.js:1:16:\n          1 │ foo = { bar: 1, bar: 2 }\n            ╵                 ~~~\n\n      The original key \"bar\" is here:\n\n        example.js:1:8:\n          1 │ foo = { bar: 1, bar: 2 }\n            ╵         ~~~\n    ```\n\n  - `empty-import-meta`\n\n    ``` javascript\n    ▲ [WARNING] \"import.meta\" is not available in the configured target environment (\"chrome50\") and will be empty [empty-import-meta]\n\n        example.js:1:6:\n          1 │ foo = import.meta\n            ╵       ~~~~~~~~~~~\n    ```\n\n  - `equals-nan`\n\n    ``` javascript\n    ▲ [WARNING] Comparison with NaN using the \"!==\" operator here is always true [equals-nan]\n\n        example.js:1:24:\n          1 │ foo = foo.filter(x => x !== NaN)\n            ╵                         ~~~\n\n      Floating-point equality is defined such that NaN is never equal to anything, so \"x === NaN\" always\n      returns false. You need to use \"Number.isNaN(x)\" instead to test for NaN.\n    ```\n\n  - `equals-negative-zero`\n\n    ``` javascript\n    ▲ [WARNING] Comparison with -0 using the \"!==\" operator will also match 0 [equals-negative-zero]\n\n        example.js:1:28:\n          1 │ foo = foo.filter(x => x !== -0)\n            ╵                             ~~\n\n      Floating-point equality is defined such that 0 and -0 are equal, so \"x === -0\" returns true for\n      both 0 and -0. You need to use \"Object.is(x, -0)\" instead to test for -0.\n    ```\n\n  - `equals-new-object`\n\n    ``` javascript\n    ▲ [WARNING] Comparison using the \"!==\" operator here is always true [equals-new-object]\n\n        example.js:1:24:\n          1 │ foo = foo.filter(x => x !== [])\n            ╵                         ~~~\n\n      Equality with a new object is always false in JavaScript because the equality operator tests\n      object identity. You need to write code to compare the contents of the object instead. For\n      example, use \"Array.isArray(x) && x.length === 0\" instead of \"x === []\" to test for an empty\n      array.\n    ```\n\n  - `html-comment-in-js`\n\n    ``` javascript\n    ▲ [WARNING] Treating \"<!--\" as the start of a legacy HTML single-line comment [html-comment-in-js]\n\n        example.js:1:0:\n          1 │ <!-- comment -->\n            ╵ ~~~~\n    ```\n\n  - `impossible-typeof`\n\n    ``` javascript\n    ▲ [WARNING] The \"typeof\" operator will never evaluate to \"null\" [impossible-typeof]\n\n        example.js:1:32:\n          1 │ foo = foo.map(x => typeof x !== \"null\")\n            ╵                                 ~~~~~~\n\n      The expression \"typeof x\" actually evaluates to \"object\" in JavaScript, not \"null\". You need to\n      use \"x === null\" to test for null.\n    ```\n\n  - `indirect-require`\n\n    ``` javascript\n    ▲ [WARNING] Indirect calls to \"require\" will not be bundled [indirect-require]\n\n        example.js:1:8:\n          1 │ let r = require, fs = r(\"fs\")\n            ╵         ~~~~~~~\n    ```\n\n  - `private-name-will-throw`\n\n    ``` javascript\n    ▲ [WARNING] Writing to getter-only property \"#foo\" will throw [private-name-will-throw]\n\n        example.js:1:39:\n          1 │ class Foo { get #foo() {} bar() { this.#foo++ } }\n            ╵                                        ~~~~\n    ```\n\n  - `semicolon-after-return`\n\n    ``` javascript\n    ▲ [WARNING] The following expression is not returned because of an automatically-inserted semicolon [semicolon-after-return]\n\n        example.js:1:6:\n          1 │ return\n            ╵       ^\n    ```\n\n  - `suspicious-boolean-not`\n\n    ``` javascript\n    ▲ [WARNING] Suspicious use of the \"!\" operator inside the \"in\" operator [suspicious-boolean-not]\n\n        example.js:1:4:\n          1 │ if (!foo in bar) {\n            │     ~~~~\n            ╵     (!foo)\n\n      The code \"!x in y\" is parsed as \"(!x) in y\". You need to insert parentheses to get \"!(x in y)\"\n      instead.\n    ```\n\n  - `suspicious-define`\n\n    ``` javascript\n    ▲ [WARNING] \"process.env.NODE_ENV\" is defined as an identifier instead of a string (surround \"production\" with quotes to get a string) [suspicious-define]\n\n        <js>:1:34:\n          1 │ define: { 'process.env.NODE_ENV': 'production' }\n            │                                   ~~~~~~~~~~~~\n            ╵                                   '\"production\"'\n    ```\n\n  - `suspicious-logical-operator`\n\n    ``` javascript\n    ▲ [WARNING] The \"&&\" operator here will always return the left operand [suspicious-logical-operator]\n\n        example.js:1:25:\n          1 │ const isInRange = x => 0 && x <= 1\n            ╵                          ~~\n\n      The \"=>\" symbol creates an arrow function expression in JavaScript. Did you mean to use the\n      greater-than-or-equal-to operator \">=\" here instead?\n\n        example.js:1:20:\n          1 │ const isInRange = x => 0 && x <= 1\n            │                     ~~\n            ╵                     >=\n    ```\n\n  - `suspicious-nullish-coalescing`\n\n    ``` javascript\n    ▲ [WARNING] The \"??\" operator here will always return the left operand [suspicious-nullish-coalescing]\n\n        example.js:1:26:\n          1 │ return name === user.name ?? \"\"\n            ╵                           ~~\n\n      The left operand of the \"??\" operator here will never be null or undefined, so it will always be\n      returned. This usually indicates a bug in your code:\n\n        example.js:1:7:\n          1 │ return name === user.name ?? \"\"\n            ╵        ~~~~~~~~~~~~~~~~~~\n    ```\n\n  - `this-is-undefined-in-esm`\n\n    ``` javascript\n    ▲ [WARNING] Top-level \"this\" will be replaced with undefined since this file is an ECMAScript module [this-is-undefined-in-esm]\n\n        example.js:1:0:\n          1 │ this.foo = 1; export let bar = 2\n            │ ~~~~\n            ╵ undefined\n\n      This file is considered to be an ECMAScript module because of the \"export\" keyword here:\n\n        example.js:1:14:\n          1 │ this.foo = 1; export let bar = 2\n            ╵               ~~~~~~\n    ```\n\n  - `unsupported-dynamic-import`\n\n    ``` javascript\n    ▲ [WARNING] This \"import\" expression will not be bundled because the argument is not a string literal [unsupported-dynamic-import]\n\n        example.js:1:0:\n          1 │ import(foo)\n            ╵ ~~~~~~\n    ```\n\n  - `unsupported-jsx-comment`\n\n    ``` javascript\n    ▲ [WARNING] Invalid JSX factory: 123 [unsupported-jsx-comment]\n\n        example.jsx:1:8:\n          1 │ // @jsx 123\n            ╵         ~~~\n    ```\n\n  - `unsupported-regexp`\n\n    ``` javascript\n    ▲ [WARNING] The regular expression flag \"d\" is not available in the configured target environment (\"chrome50\") [unsupported-regexp]\n\n        example.js:1:3:\n          1 │ /./d\n            ╵    ^\n\n      This regular expression literal has been converted to a \"new RegExp()\" constructor to avoid\n      generating code with a syntax error. However, you will need to include a polyfill for \"RegExp\" for\n      your code to have the correct behavior at run-time.\n    ```\n\n  - `unsupported-require-call`\n\n    ``` javascript\n    ▲ [WARNING] This call to \"require\" will not be bundled because the argument is not a string literal [unsupported-require-call]\n\n        example.js:1:0:\n          1 │ require(foo)\n            ╵ ~~~~~~~\n    ```\n\n    \n- **CSS:**\n  - `css-syntax-error`\n\n    ``` javascript\n    ▲ [WARNING] Expected identifier but found \"]\" [css-syntax-error]\n\n        example.css:1:4:\n          1 │ div[] {\n            ╵     ^\n    ```\n\n  - `invalid-@charset`\n\n    ``` javascript\n    ▲ [WARNING] \"@charset\" must be the first rule in the file [invalid-@charset]\n\n        example.css:1:19:\n          1 │ div { color: red } @charset \"UTF-8\";\n            ╵                    ~~~~~~~~\n\n      This rule cannot come before a \"@charset\" rule\n\n        example.css:1:0:\n          1 │ div { color: red } @charset \"UTF-8\";\n            ╵ ^\n    ```\n\n  - `invalid-@import`\n\n    ``` javascript\n    ▲ [WARNING] All \"@import\" rules must come first [invalid-@import]\n\n        example.css:1:19:\n          1 │ div { color: red } @import \"foo.css\";\n            ╵                    ~~~~~~~\n\n      This rule cannot come before an \"@import\" rule\n\n        example.css:1:0:\n          1 │ div { color: red } @import \"foo.css\";\n            ╵ ^\n    ```\n\n  - `invalid-@layer`\n\n    ``` javascript\n    ▲ [WARNING] \"initial\" cannot be used as a layer name [invalid-@layer]\n\n        example.css:1:7:\n          1 │ @layer initial {\n            ╵        ~~~~~~~\n    ```\n\n  - `invalid-calc`\n\n    ``` javascript\n    ▲ [WARNING] \"-\" can only be used as an infix operator, not a prefix operator [invalid-calc]\n\n        example.css:1:20:\n          1 │ div { z-index: calc(-(1+2)); }\n            ╵                     ^\n\n    ▲ [WARNING] The \"+\" operator only works if there is whitespace on both sides [invalid-calc]\n\n        example.css:1:23:\n          1 │ div { z-index: calc(-(1+2)); }\n            ╵                        ^\n    ```\n\n  - `js-comment-in-css`\n\n    ``` javascript\n    ▲ [WARNING] Comments in CSS use \"/* ... */\" instead of \"//\" [js-comment-in-css]\n\n        example.css:1:0:\n          1 │ // comment\n            ╵ ~~\n    ```\n\n  - `undefined-composes-from`\n\n    ``` javascript\n    ▲ [WARNING] The value of \"zoom\" in the \"foo\" class is undefined [undefined-composes-from]\n\n        example.module.css:1:1:\n          1 │ .foo { composes: bar from \"lib.module.css\"; zoom: 1; }\n            ╵  ~~~\n\n      The first definition of \"zoom\" is here:\n\n        lib.module.css:1:7:\n          1 │ .bar { zoom: 2 }\n            ╵        ~~~~\n\n      The second definition of \"zoom\" is here:\n\n        example.module.css:1:44:\n          1 │ .foo { composes: bar from \"lib.module.css\"; zoom: 1; }\n            ╵                                             ~~~~\n\n      The specification of \"composes\" does not define an order when class declarations from separate\n      files are composed together. The value of the \"zoom\" property for \"foo\" may change unpredictably\n      as the code is edited. Make sure that all definitions of \"zoom\" for \"foo\" are in a single file.\n    ```\n\n  - `unsupported-@charset`\n\n    ``` javascript\n    ▲ [WARNING] \"UTF-8\" will be used instead of unsupported charset \"ASCII\" [unsupported-@charset]\n\n        example.css:1:9:\n          1 │ @charset \"ASCII\";\n            ╵          ~~~~~~~\n    ```\n\n  - `unsupported-@namespace`\n\n    ``` javascript\n    ▲ [WARNING] \"@namespace\" rules are not supported [unsupported-@namespace]\n\n        example.css:1:0:\n          1 │ @namespace \"ns\";\n            ╵ ~~~~~~~~~~\n    ```\n\n  - `unsupported-css-property`\n\n    ``` javascript\n    ▲ [WARNING] \"widht\" is not a known CSS property [unsupported-css-property]\n\n        example.css:1:6:\n          1 │ div { widht: 1px }\n            │       ~~~~~\n            ╵       width\n\n      Did you mean \"width\" instead?\n    ```\n\n  - `unsupported-css-nesting`\n\n    ``` javascript\n    ▲ [WARNING] Transforming this CSS nesting syntax is not supported in the configured target environment (\"chrome50\") [unsupported-css-nesting]\n\n        example.css:2:5:\n          2 │ .foo & {\n            ╵      ^\n\n      The nesting transform for this case must generate an \":is(...)\" but the configured target\n      environment does not support the \":is\" pseudo-class.\n    ```\n\n    \n- **Bundler:**\n  - `ambiguous-reexport`\n\n    ``` javascript\n    ▲ [WARNING] Re-export of \"foo\" in \"example.js\" is ambiguous and has been removed [ambiguous-reexport]\n\n      One definition of \"foo\" comes from \"a.js\" here:\n\n        a.js:1:11:\n          1 │ export let foo = 1\n            ╵            ~~~\n\n      Another definition of \"foo\" comes from \"b.js\" here:\n\n        b.js:1:11:\n          1 │ export let foo = 2\n            ╵            ~~~\n    ```\n\n  - `different-path-case`\n\n    ``` javascript\n    ▲ [WARNING] Use \"foo.js\" instead of \"Foo.js\" to avoid issues with case-sensitive file systems [different-path-case]\n\n        example.js:2:7:\n          2 │ import \"./Foo.js\"\n            ╵        ~~~~~~~~~~\n    ```\n\n  - `empty-glob`\n\n    ``` javascript\n    ▲ [WARNING] The glob pattern import(\"./icon-*.json\") did not match any files [empty-glob]\n\n        example.js:2:16:\n          2 │   return import(\"./icon-\" + name + \".json\")\n            ╵                 ~~~~~~~~~~~~~~~~~~~~~~~~~~\n    ```\n\n  - `ignored-bare-import`\n\n    ``` javascript\n    ▲ [WARNING] Ignoring this import because \"node_modules/foo/index.js\" was marked as having no side effects [ignored-bare-import]\n\n        example.js:1:7:\n          1 │ import \"foo\"\n            ╵        ~~~~~\n\n      \"sideEffects\" is false in the enclosing \"package.json\" file:\n\n        node_modules/foo/package.json:2:2:\n          2 │   \"sideEffects\": false\n            ╵   ~~~~~~~~~~~~~\n    ```\n\n  - `ignored-dynamic-import`\n\n    ``` javascript\n    ▲ [WARNING] Importing \"foo\" was allowed even though it could not be resolved because dynamic import failures appear to be handled here: [ignored-dynamic-import]\n\n        example.js:1:7:\n          1 │ import(\"foo\").catch(e => {\n            ╵        ~~~~~\n\n      The handler for dynamic import failures is here:\n\n        example.js:1:14:\n          1 │ import(\"foo\").catch(e => {\n            ╵               ~~~~~\n    ```\n\n  - `import-is-undefined`\n\n    ``` javascript\n    ▲ [WARNING] Import \"foo\" will always be undefined because the file \"foo.js\" has no exports [import-is-undefined]\n\n        example.js:1:9:\n          1 │ import { foo } from \"./foo\"\n            ╵          ~~~\n    ```\n\n  - `require-resolve-not-external`\n\n    ``` javascript\n    ▲ [WARNING] \"foo\" should be marked as external for use with \"require.resolve\" [require-resolve-not-external]\n\n        example.js:1:26:\n          1 │ let foo = require.resolve(\"foo\")\n            ╵                           ~~~~~\n    ```\n\n    \n- **Source maps:**\n  - `invalid-source-mappings`\n\n    ``` javascript\n    ▲ [WARNING] Bad \"mappings\" data in source map at character 3: Invalid original column value: -2 [invalid-source-mappings]\n\n        example.js.map:2:18:\n          2 │   \"mappings\": \"aAAFA,UAAU;;\"\n            ╵                   ^\n\n      The source map \"example.js.map\" was referenced by the file \"example.js\" here:\n\n        example.js:1:21:\n          1 │ //# sourceMappingURL=example.js.map\n            ╵                      ~~~~~~~~~~~~~~\n    ```\n\n  - `sections-in-source-map`\n\n    ``` javascript\n    ▲ [WARNING] Source maps with \"sections\" are not supported [sections-in-source-map]\n\n        example.js.map:2:2:\n          2 │   \"sections\": []\n            ╵   ~~~~~~~~~~\n\n      The source map \"example.js.map\" was referenced by the file \"example.js\" here:\n\n        example.js:1:21:\n          1 │ //# sourceMappingURL=example.js.map\n            ╵                      ~~~~~~~~~~~~~~\n    ```\n\n  - `missing-source-map`\n\n    ``` javascript\n    ▲ [WARNING] Cannot read file \".\": is a directory [missing-source-map]\n\n        example.js:1:21:\n          1 │ //# sourceMappingURL=.\n            ╵                      ^\n    ```\n\n  - `unsupported-source-map-comment`\n\n    ``` javascript\n    ▲ [WARNING] Unsupported source map comment: could not decode percent-escaped data: invalid URL escape \"%\\\"\" [unsupported-source-map-comment]\n\n        example.js:1:21:\n          1 │ //# sourceMappingURL=data:application/json,\"%\"\n            ╵                      ~~~~~~~~~~~~~~~~~~~~~~~~~\n    ```\n\n    \n- **Resolver:**\n  - `package.json`\n\n    ``` javascript\n    ▲ [WARNING] \"esm\" is not a valid value for the \"type\" field [package.json]\n\n        package.json:1:10:\n          1 │ { \"type\": \"esm\" }\n            ╵           ~~~~~\n\n      The \"type\" field must be set to either \"commonjs\" or \"module\".\n    ```\n\n  - `tsconfig.json`\n\n    ``` javascript\n    ▲ [WARNING] Unrecognized target environment \"ES4\" [tsconfig.json]\n\n        tsconfig.json:1:33:\n          1 │ { \"compilerOptions\": { \"target\": \"ES4\" } }\n            ╵                                  ~~~~~\n    ```\n\n    \n\nThese message types should be reasonably stable but new ones may be added and old ones may occasionally be removed in the future. If a message type is removed, any overrides for that message type will just be silently ignored.\n\n© 2020 Evan Wallace  \nLicensed under the MIT License.  \n[https://esbuild.github.io/api/](https://esbuild.github.io/api/)"
- name: Logging
  id: api/index#logging
  summary: null
  belongs_to: API
  description: '## Logging'
- name: Main fields
  id: api/index#main-fields
  summary: When you import a package in node, the main field in that package's package.json file determines which file is imported (along with a lot of other rules)
  belongs_to: API
  description: |-
    ### Main fields

    *Supported by: [Build](#build)*

    When you import a package in node, the `main` field in that package's `package.json` file determines which file is imported (along with [a lot of other rules](https://nodejs.org/api/modules.html#all-together)). Major JavaScript bundlers including esbuild let you specify additional `package.json` fields to try when resolving a package. There are at least three such fields commonly in use:

    - `main`

      This is [the standard field](https://docs.npmjs.com/files/package.json#main) for all packages that are meant to be used with node. The name `main` is hard-coded in to node's module resolution logic itself. Because it's intended for use with node, it's reasonable to expect that the file path in this field is a CommonJS-style module.

    - `module`

      This field came from [a proposal](https://github.com/dherman/defense-of-dot-js/blob/f31319be735b21739756b87d551f6711bd7aa283/proposal.md) for how to integrate ECMAScript modules into node. Because of this, it's reasonable to expect that the file path in this field is an ECMAScript-style module. This proposal wasn't adopted by node (node uses `"type": "module"` instead) but it was adopted by major bundlers because ECMAScript-style modules lead to better [tree shaking](#tree-shaking), or dead code removal.

      For package authors: Some packages incorrectly use the `module` field for browser-specific code, leaving node-specific code for the `main` field. This is probably because node ignores the `module` field and people typically only use bundlers for browser-specific code. However, bundling node-specific code is valuable too (e.g. it decreases download and boot time) and packages that put browser-specific code in `module` prevent bundlers from being able to do tree shaking effectively. If you are trying to publish browser-specific code in a package, use the `browser` field instead.

    - `browser`

      This field came from [a proposal](https://gist.github.com/defunctzombie/4339901/49493836fb873ddaa4b8a7aa0ef2352119f69211) that allows bundlers to replace node-specific files or modules with their browser-friendly versions. It lets you specify an alternate browser-specific entry point. Note that it is possible for a package to use both the `browser` and `module` field together (see the note below).

    The default main fields depend on the current [platform](#platform) setting. These defaults should be the most widely compatible with the existing package ecosystem. But you can customize them like this if you want to:

    ``` sh
    esbuild app.js --bundle --main-fields=module,main
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      mainFields: ['module', 'main'],
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        MainFields:  []string{"module", "main"},
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    #### For package authors

    If you want to author a package that uses the `browser` field in combination with the `module` field, then you'll probably want to fill out ***all four entries*** in the full CommonJS-vs-ESM and browser-vs-node compatibility matrix. For that you'll need to use the expanded form of the `browser` field that is a map instead of just a string:

    ``` javascript
    {
      "main": "./node-cjs.js",
      "module": "./node-esm.js",
      "browser": {
        "./node-cjs.js": "./browser-cjs.js",
        "./node-esm.js": "./browser-esm.js"
      }
    }
    ```

    The `main` field is expected to be CommonJS while the `module` field is expected to be ESM. The decision about which module format to use is independent from the decision about whether to use a browser-specific or node-specific variant. If you omit one of these four entries, then you risk the wrong variant being chosen. For example, if you omit the entry for the CommonJS browser build, then the CommonJS node build could be chosen instead.

    Note that using `main`, `module`, and `browser` is the old way of doing this. There is also a newer way to do this that you may prefer to use instead: the [`exports` field](#how-conditions-work) in `package.json`. It provides a different set of trade-offs. For example, it gives you more precise control over imports for all sub-paths in your package (while `main` fields only give you control over the entry point), but it may cause your package to be imported multiple times depending on how you configure it.
- name: Mangle props
  id: api/index#mangle-props
  summary: Using this feature can break your code in subtle ways
  belongs_to: API
  description: |-
    ### Mangle props

    *Supported by: [Build](#build) and [Transform](#transform)*

    **Using this feature can break your code in subtle ways.** Do not use this feature unless you know what you are doing, and you know exactly how it will affect both your code and all of your dependencies.

    This setting lets you pass a regular expression to esbuild to tell esbuild to automatically rename all properties that match this regular expression. It's useful when you want to minify certain property names in your code either to make the generated code smaller or to somewhat obfuscate your code's intent.

    Here's an example that uses the regular expression `_$` to mangle all properties ending in an underscore, such as `foo_`. This mangles `print({ foo_: 0 }.foo_)` into `print({ a: 0 }.a)`:

    ``` sh
    esbuild app.js --mangle-props=_$
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      mangleProps: /_$/,
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        MangleProps: "_$",
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Only mangling properties that end in an underscore is a reasonable heuristic because normal JS code doesn't typically contain identifiers like that. Browser APIs also don't use this naming convention so this also avoids conflicts with browser APIs. If you want to avoid mangling names such as [`__defineGetter__`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__) you could consider using a more complex regular expression such as `[^_]_$` (i.e. must end in a non-underscore followed by an underscore).

    This is a separate setting instead of being part of the [minify](#minify) setting because it's an unsafe transformation that does not work on arbitrary JavaScript code. It only works if the provided regular expression matches all of the properties that you want mangled and does not match any of the properties that you don't want mangled. It also only works if you do not under any circumstances reference a mangled property indirectly. For example, it means you can't use `obj[prop]` to reference a property where `prop` is a string containing the property name. Specifically the following syntax constructs are the only ones eligible for property mangling:

    | Syntax                           | Example                                   |
    |----------------------------------|-------------------------------------------|
    | Dot property accesses            | `x.foo_`                                  |
    | Dot optional chains              | `x?.foo_`                                 |
    | Object properties                | `x = { foo_: y }`                         |
    | Object methods                   | `x = { foo_() {} }`                       |
    | Class fields                     | `class x { foo_ = y }`                    |
    | Class methods                    | `class x { foo_() {} }`                   |
    | Object destructuring bindings    | `let { foo_: x } = y`                     |
    | Object destructuring assignments | `({ foo_: x } = y)`                       |
    | JSX element member expression    | `<X.foo_></X.foo_>`                       |
    | JSX attribute names              | `<X foo_={y} />`                          |
    | TypeScript namespace exports     | `namespace x { export let foo_ = y }`     |
    | TypeScript parameter properties  | `class x { constructor(public foo_) {} }` |

    When using this feature, keep in mind that property names are only consistently mangled within a single esbuild API call but not across esbuild API calls. Each esbuild API call does an independent property mangling operation so output files generated by two different API calls may mangle the same property to two different names, which could cause the resulting code to behave incorrectly.

    #### Quoted properties

    By default, esbuild doesn't modify the contents of string literals. This means you can avoid property mangling for an individual property by quoting it as a string. However, you must consistently use quotes or no quotes for a given property everywhere for this to work. For example, `print({ foo_: 0 }.foo_)` will be mangled into `print({ a: 0 }.a)` while `print({ 'foo_': 0 }['foo_'])` will not be mangled.

    If you would like for esbuild to also mangle the contents of string literals, you can explicitly enable that behavior like this:

    ``` sh
    esbuild app.js --mangle-props=_$ --mangle-quoted
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      mangleProps: /_$/,
      mangleQuoted: true,
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints:  []string{"app.js"},
        MangleProps:  "_$",
        MangleQuoted: api.MangleQuotedTrue,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Enabling this makes the following syntax constructs also eligible for property mangling:

    | Syntax                                  | Example                   |
    |-----------------------------------------|---------------------------|
    | Quoted property accesses                | `x['foo_']`               |
    | Quoted optional chains                  | `x?.['foo_']`             |
    | Quoted object properties                | `x = { 'foo_': y }`       |
    | Quoted object methods                   | `x = { 'foo_'() {} }`     |
    | Quoted class fields                     | `class x { 'foo_' = y }`  |
    | Quoted class methods                    | `class x { 'foo_'() {} }` |
    | Quoted object destructuring bindings    | `let { 'foo_': x } = y`   |
    | Quoted object destructuring assignments | `({ 'foo_': x } = y)`     |
    | String literals to the left of `in`     | `'foo_' in x`             |

    #### Mangling other strings

    Mangling [quoted properties](#mangle-quoted) still only mangles strings in property name position. Sometimes you may also need to mangle property names in strings at arbitrary other locations in your code. To do that, you can prefix the string with a `/* @__KEY__ */` comment to tell esbuild that the contents of a string should be treated as a property name that can be mangled. For example:

    ``` javascript
    let obj = {}
    Object.defineProperty(
      obj,
      /* @__KEY__ */ 'foo_',
      { get: () => 123 },
    )
    console.log(obj.foo_)
    ```

    This will cause the contents of the string `'foo_'` to be mangled as a property name (assuming [property mangling](#mangle-props) is enabled and `foo_` is eligible for renaming). The `/* @__KEY__ */` comment is a convention from [Terser](https://github.com/terser/terser), a popular JavaScript minifier with a similar property mangling feature.

    #### Preventing renaming

    If you would like to exclude certain properties from mangling, you can reserve them with an additional setting. For example, this uses the regular expression `^__.*__$` to reserve all properties that start and end with two underscores, such as `__foo__`:

    ``` sh
    esbuild app.js --mangle-props=_$ "--reserve-props=^__.*__$"
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      mangleProps: /_$/,
      reserveProps: /^__.*__$/,
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints:  []string{"app.js"},
        MangleProps:  "_$",
        ReserveProps: "^__.*__$",
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    #### Persisting renaming decisions

    Advanced usage of the property mangling feature involves storing the mapping from original name to mangled name in a persistent cache. When enabled, all mangled property renamings are recorded in the cache during the initial build. Subsequent builds reuse the renamings stored in the cache and add additional renamings for any newly-added properties. This has a few consequences:

    - You can customize what mangled properties are renamed to by editing the cache before passing it to esbuild.

    - The cache serves as a list of all properties that were mangled. You can easily scan it to see if there are any unexpected property renamings.

    - You can disable mangling for individual properties by setting the renamed value to `false` instead of to a string. This is similar to the [reserve props](#reserve-props) setting but on a per-property basis.

    - You can ensure consistent renaming between builds (e.g. a main-thread file and a web worker, or a library and a plugin). Without this feature, each build would do an independent renaming operation and the mangled property names likely wouldn't be consistent.

    For example, consider the following input file:

    ``` javascript
    console.log({
      someProp_: 1,
      customRenaming_: 2,
      disabledRenaming_: 3
    });
    ```

    If we want `customRenaming_` to be renamed to `cR_` and we don't want `disabledRenaming_` to be renamed at all, we can pass the following mangle cache JSON to esbuild:

    ``` javascript
    {
      "customRenaming_": "cR_",
      "disabledRenaming_": false
    }
    ```

    The mangle cache JSON can be passed to esbuild like this:

    ``` sh
    esbuild app.js --mangle-props=_$ --mangle-cache=cache.json
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let result = await esbuild.build({
      entryPoints: ['app.js'],
      mangleProps: /_$/,
      mangleCache: {
        customRenaming_: "cR_",
        disabledRenaming_: false
      },
    })

    console.log('updated mangle cache:', result.mangleCache)
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        MangleProps: "_$",
        MangleCache: map[string]interface{}{
          "customRenaming_":   "cR_",
          "disabledRenaming_": false,
        },
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }

      fmt.Println("updated mangle cache:", result.MangleCache)
    }
    ```

    When property naming is enabled, that will result in the following output file:

    ``` javascript
    console.log({
      a: 1,
      cR_: 2,
      disabledRenaming_: 3
    });
    ```

    And the following updated mangle cache:

    ``` javascript
    {
      "customRenaming_": "cR_",
      "disabledRenaming_": false,
      "someProp_": "a"
    }
    ```
- name: Metafile
  id: api/index#metafile
  summary: This option tells esbuild to produce some metadata about the build in JSON format
  belongs_to: API
  description: |-
    ### Metafile

    *Supported by: [Build](#build)*

    This option tells esbuild to produce some metadata about the build in JSON format. The following example puts the metadata in a file called `meta.json`:

    ``` sh
    esbuild app.js --bundle --metafile=meta.json --outfile=out.js
    ```

    ``` javascript
    import * as esbuild from 'esbuild'
    import fs from 'node:fs'

    let result = await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      metafile: true,
      outfile: 'out.js',
    })

    fs.writeFileSync('meta.json', JSON.stringify(result.metafile))
    ```

    ``` go
    package main

    import "io/ioutil"
    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Metafile:    true,
        Outfile:     "out.js",
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }

      ioutil.WriteFile("meta.json", []byte(result.Metafile), 0644)
    }
    ```

    This data can then be analyzed by other tools. For an interactive visualization, you can use esbuild's own [Bundle Size Analyzer](../analyze/index). For a quick textual analysis, you can use esbuild's build-in [analyze](#analyze) feature. Or you can write your own analysis which uses this information.

    The metadata JSON format looks like this (described using a TypeScript interface):

    ``` javascript
    interface Metafile {
      inputs: {
        [path: string]: {
          bytes: number
          imports: {
            path: string
            kind: string
            external?: boolean
            original?: string
            with?: Record<string, string>
          }[]
          format?: string
          with?: Record<string, string>
        }
      }
      outputs: {
        [path: string]: {
          bytes: number
          inputs: {
            [path: string]: {
              bytesInOutput: number
            }
          }
          imports: {
            path: string
            kind: string
            external?: boolean
          }[]
          exports: string[]
          entryPoint?: string
          cssBundle?: string
        }
      }
    }
    ```
- name: Minified newlines
  id: faq/index#minified-newlines
  summary: People are sometimes surprised that esbuild's minifier typically changes the character escape sequence \n within JavaScript strings into a newline character in a template literal
  belongs_to: FAQ
  description: |-
    ## Minified newlines

    People are sometimes surprised that esbuild's minifier typically changes the character escape sequence `\n` within JavaScript strings into a newline character in a template literal. But this is intentional. **This is not a bug with esbuild**. The job of a minifier is to generate as compact an output as possible that's equivalent to the input. The character escape sequence `\n` is two bytes long while a newline character is one byte long.

    For example, this code is 21 bytes long:

    ``` javascript
    var text="a\nb\nc\n";
    ```

    While this code is 18 bytes long:

    ``` javascript
    var text=`a
    b
    c
    `;
    ```

    So the second code is fully minified while the first one isn't. Minifying code does not mean putting it all on one line. Instead, minifying code means generating equivalent code that uses as few bytes as possible. In JavaScript, an untagged template literal is equivalent to a string literal, so esbuild is doing the correct thing here.
- name: Minify
  id: api/index#minify
  summary: When enabled, the generated code will be minified instead of pretty-printed
  belongs_to: API
  description: |-
    ### Minify

    *Supported by: [Build](#build) and [Transform](#transform)*

    When enabled, the generated code will be minified instead of pretty-printed. Minified code is generally equivalent to non-minified code but is smaller, which means it downloads faster but is harder to debug. Usually you minify code in production but not in development.

    Enabling minification in esbuild looks like this:

    ``` sh
    echo 'fn = obj => { return obj.x }' | esbuild --minify
    fn=n=>n.x;
    ```

    ``` javascript
    import * as esbuild from 'esbuild'var js = 'fn = obj => { return obj.x }'
    (await esbuild.transform(js, {
      minify: true,
    })).code
    'fn=n=>n.x;\n'
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      js := "fn = obj => { return obj.x }"

      result := api.Transform(js, api.TransformOptions{
        MinifyWhitespace:  true,
        MinifyIdentifiers: true,
        MinifySyntax:      true,
      })

      if len(result.Errors) == 0 {
        fmt.Printf("%s", result.Code)
      }
    }
    ```

    This option does three separate things in combination: it removes whitespace, it rewrites your syntax to be more compact, and it renames local variables to be shorter. Usually you want to do all of these things, but these options can also be enabled individually if necessary:

    ``` sh
    echo 'fn = obj => { return obj.x }' | esbuild --minify-whitespace
    fn=obj=>{return obj.x};
    echo 'fn = obj => { return obj.x }' | esbuild --minify-identifiers
    fn = (n) => {
      return n.x;
    };
    echo 'fn = obj => { return obj.x }' | esbuild --minify-syntax
    fn = (obj) => obj.x;
    ```

    ``` javascript
    import * as esbuild from 'esbuild'var js = 'fn = obj => { return obj.x }'
    (await esbuild.transform(js, {
      minifyWhitespace: true,
    })).code
    'fn=obj=>{return obj.x};\n'
    (await esbuild.transform(js, {
      minifyIdentifiers: true,
    })).code
    'fn = (n) => {\n  return n.x;\n};\n'
    (await esbuild.transform(js, {
      minifySyntax: true,
    })).code
    'fn = (obj) => obj.x;\n'
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      css := "div { color: yellow }"

      result1 := api.Transform(css, api.TransformOptions{
        Loader:           api.LoaderCSS,
        MinifyWhitespace: true,
      })

      if len(result1.Errors) == 0 {
        fmt.Printf("%s", result1.Code)
      }

      result2 := api.Transform(css, api.TransformOptions{
        Loader:            api.LoaderCSS,
        MinifyIdentifiers: true,
      })

      if len(result2.Errors) == 0 {
        fmt.Printf("%s", result2.Code)
      }

      result3 := api.Transform(css, api.TransformOptions{
        Loader:       api.LoaderCSS,
        MinifySyntax: true,
      })

      if len(result3.Errors) == 0 {
        fmt.Printf("%s", result3.Code)
      }
    }
    ```

    These same concepts also apply to CSS, not just to JavaScript:

    ``` sh
    echo 'div { color: yellow }' | esbuild --loader=css --minify
    div{color:#ff0}
    ```

    ``` javascript
    import * as esbuild from 'esbuild'var css = 'div { color: yellow }'
    (await esbuild.transform(css, {
      loader: 'css',
      minify: true,
    })).code
    'div{color:#ff0}\n'
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      css := "div { color: yellow }"

      result := api.Transform(css, api.TransformOptions{
        Loader:            api.LoaderCSS,
        MinifyWhitespace:  true,
        MinifyIdentifiers: true,
        MinifySyntax:      true,
      })

      if len(result.Errors) == 0 {
        fmt.Printf("%s", result.Code)
      }
    }
    ```

    The JavaScript minification algorithm in esbuild usually generates output that is very close to the minified output size of industry-standard JavaScript minification tools. [This benchmark](https://github.com/privatenumber/minification-benchmarks#readme) has an example comparison of output sizes between different minifiers. While esbuild is not the optimal JavaScript minifier in all cases (and doesn't try to be), it strives to generate minified output within a few percent of the size of dedicated minification tools for most code, and of course to do so much faster than other tools.

    #### Considerations

    Here are some things to keep in mind when using esbuild as a minifier:

    - You should probably also set the [target](#target) option when minification is enabled. By default esbuild takes advantage of modern JavaScript features to make your code smaller. For example, `a === undefined || a === null ? 1 : a` could be minified to `a ?? 1`. If you do not want esbuild to take advantage of modern JavaScript features when minifying, you should use an older language target such as `--target=es6`.

    - The character escape sequence `\n` will be replaced with a newline character in JavaScript template literals. String literals will also be converted into template literals if the [target](#target) supports them and if doing so would result in smaller output. **This is not a bug.** Minification means you are asking for smaller output, and the escape sequence `\n` takes two bytes while the newline character takes one byte. You can read more about this in the [FAQ entry on this topic](../faq/index#minified-newlines).

    - By default esbuild won't minify the names of top-level declarations. This is because esbuild doesn't know what you will be doing with the output. You might be injecting the minified code into the middle of some other code, in which case minifying top-level declaration names would be unsafe. Setting an output [format](#format) (or enabling [bundling](#bundle), which picks an output format for you if you haven't set one) tells esbuild that the output will be run within its own scope, which means it's then safe to minify top-level declaration names.

    - Minification is not safe for 100% of all JavaScript code. This is true for esbuild as well as for other popular JavaScript minifiers such as [terser](https://github.com/terser/terser). In particular, esbuild is not designed to preserve the value of calling `.toString()` on a function. The reason for this is because if all code inside all functions had to be preserved verbatim, minification would hardly do anything at all and would be virtually useless. However, this means that JavaScript code relying on the return value of `.toString()` will likely break when minified. For example, some patterns in the [AngularJS](https://angularjs.org/) framework break when code is minified because AngularJS uses `.toString()` to read the argument names of functions. A workaround is to use [explicit annotations instead](https://docs.angularjs.org/api/auto/service/$injector#injection-function-annotation).

    - By default esbuild does not preserve the value of `.name` on function and class objects. This is because most code doesn't rely on this property and using shorter names is an important size optimization. However, some code does rely on the `.name` property for registration and binding purposes. If you need to rely on this you should enable the [keep names](#keep-names) option.

    - The minifier assumes that built-in JavaScript features behave the way they are expected to behave. These assumptions help esbuild generate more compact code. If you want a JavaScript minifier that doesn't make any assumptions about the behavior of built-in JavaScript features, then esbuild may not be the right JavaScript minifier for you. Here are some examples of these kinds of assumptions (note that this is not an exhaustive list):

      - It's expected that `Array.prototype.join` behaves [as specified](https://tc39.es/ecma262/#sec-array.prototype.join). This means it's safe for esbuild's minifier to transform `x = [1, 2, 3] + ''` into `x="1,2,3";`.

      - Accessing the `log` property on the `console` global is expected to not have any side effects. This means it's safe for esbuild's minifier to transform `var a, b = a ? console.log(x) : console.log(y);` into `var a,b=console.log(a?x:y);` (i.e. esbuild is assuming evaluating `console.log` can't change the value of `a`).

    - Use of certain JavaScript features can disable many of esbuild's optimizations including minification. Specifically, using direct `eval` and/or the `with` statement prevent esbuild from renaming identifiers to smaller names since these features cause identifier binding to happen at run time instead of compile time. This is almost always unintentional, and only happens because people are unaware of what direct `eval` is and why it's bad.

      If you are thinking about writing some code like this:

      ``` javascript
      // Direct eval (will disable minification for the whole file)
      let result = eval(something)
      ```

      You should probably write your code like this instead so your code can be minified:

      ``` javascript
      // Indirect eval (has no effect on the surrounding code)
      let result = (0, eval)(something)
      ```

      There is more information about the consequences of direct `eval` and the available alternatives [here](../content-types/index#direct-eval).

    - The minification algorithm in esbuild does not yet do advanced code optimizations. In particular, the following code optimizations are possible for JavaScript code but are not done by esbuild (not an exhaustive list):

      - Dead-code elimination within function bodies
      - Function inlining
      - Cross-statement constant propagation
      - Object shape modeling
      - Allocation sinking
      - Method devirtualization
      - Symbolic execution
      - JSX expression hoisting
      - TypeScript enum detection and inlining

      If your code makes use of patterns that require some of these forms of code optimization to be compact, or if you are searching for the optimal JavaScript minification algorithm for your use case, you should consider using other tools. Some examples of tools that implement some of these advanced code optimizations include [Terser](https://github.com/terser/terser#readme) and [Google Closure Compiler](https://github.com/google/closure-compiler#readme).

    &nbsp;
- name: Namespaces
  id: plugins/index#namespaces
  summary: Every module has an associated namespace
  belongs_to: Plugins
  description: |-
    ### Namespaces

    Every module has an associated namespace. By default esbuild operates in the `file` namespace, which corresponds to files on the file system. But esbuild can also handle "virtual" modules that don't have a corresponding location on the file system. One case when this happens is when a module is provided using [stdin](../api/index#stdin).

    Plugins can be used to create virtual modules. Virtual modules usually use a namespace other than `file` to distinguish them from file system modules. Usually the namespace is specific to the plugin that created them. For example, the sample [HTTP plugin](#http-plugin) below uses the `http-url` namespace for downloaded files.
- name: Node paths
  id: api/index#node-paths
  summary: Node's module resolution algorithm supports an environment variable called NODE_PATH that contains a list of global directories to use when resolving import paths
  belongs_to: API
  description: |-
    ### Node paths

    *Supported by: [Build](#build)*

    Node's module resolution algorithm supports an environment variable called [`NODE_PATH`](https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders) that contains a list of global directories to use when resolving import paths. These paths are searched for packages in addition to the `node_modules` directories in all parent directories. You can pass this list of directories to esbuild using an environment variable with the CLI and using an array with the JS and Go APIs:

    ``` sh
    NODE_PATH=someDir esbuild app.js --bundle --outfile=out.js
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      nodePaths: ['someDir'],
      entryPoints: ['app.js'],
      bundle: true,
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        NodePaths:   []string{"someDir"},
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Outfile:     "out.js",
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    If you are using the CLI and want to pass multiple directories using `NODE_PATH`, you will have to separate them with `:` on Unix and `;` on Windows. This is the same format that Node itself uses.
- name: On-dispose callbacks
  id: plugins/index#on-dispose
  summary: Register an on-dispose callback to perform cleanup when the plugin is no longer used
  belongs_to: Plugins
  description: |-
    ## On-dispose callbacks

    Register an on-dispose callback to perform cleanup when the plugin is no longer used. It will be called after every `build()` call regardless of whether the build failed or not, as well as after the first `dispose()` call on a given build context. Here's how to add an on-dispose callback:

    ``` javascript
    let examplePlugin = {
      name: 'example',
      setup(build) {
        build.onDispose(() => {
          console.log('This plugin is no longer used')
        })
      },
    }
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    var examplePlugin = api.Plugin{
      Name: "example",
      Setup: func(build api.PluginBuild) {
        build.OnDispose(func() {
          fmt.Println("This plugin is no longer used")
        })
      },
    }

    func main() {
    }
    ```
- name: On-end callbacks
  id: plugins/index#on-end
  summary: Register an on-end callback to be notified when a new build ends
  belongs_to: Plugins
  description: |-
    ## On-end callbacks

    Register an on-end callback to be notified when a new build ends. This triggers for all builds, not just the initial build, so it's especially useful for [rebuilds](../api/index#rebuild), [watch mode](../api/index#watch), and [serve mode](../api/index#serve). Here's how to add an on-end callback:

    ``` javascript
    let examplePlugin = {
      name: 'example',
      setup(build) {
        build.onEnd(result => {
          console.log(`build ended with ${result.errors.length} errors`)
        })
      },
    }
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    var examplePlugin = api.Plugin{
      Name: "example",
      Setup: func(build api.PluginBuild) {
        build.OnEnd(func(result *api.BuildResult) (api.OnEndResult, error) {
          fmt.Fprintf(os.Stderr, "build ended with %d errors\n", len(result.Errors))
          return api.OnEndResult{}, nil
        })
      },
    }

    func main() {
    }
    ```

    All on-end callbacks are run in serial and each callback is given access to the final build result. It can modify the build result before returning and can delay the end of the build by returning a promise. If you want to be able to inspect the build graph, you should enable the [metafile](../api/index#metafile) setting on the [initial options](#build-options) and the build graph will be returned as the `metafile` property on the build result object.
- name: On-load arguments
  id: plugins/index#on-load-arguments
  summary: This is the fully-resolved path to the module
  belongs_to: Plugins
  description: |-
    ### On-load arguments

    When esbuild calls the callback registered by `onLoad`, it will provide these arguments with information about the module to load:

    ``` javascript
    interface OnLoadArgs {
      path: string;
      namespace: string;
      suffix: string;
      pluginData: any;
      with: Record<string, string>;
    }
    ```

    ``` go
    type OnLoadArgs struct {
      Path       string
      Namespace  string
      Suffix     string
      PluginData interface{}
      With       map[string]string
    }
    ```

    - `path`

      This is the fully-resolved path to the module. It should be considered a file system path if the namespace is `file`, but otherwise the path can take any form. For example, the sample [HTTP plugin](#http-plugin) below gives special meaning to paths starting with `http://`.

    - `namespace`

      This is the namespace that the module path is in, as set by the [on-resolve callback](#on-resolve) that resolved this file. It defaults to the `file` namespace for modules loaded with esbuild's default behavior. You can read more about namespaces [here](#namespaces).

    - `suffix`

      This is the URL query and/or hash at the end of the file path, if there is one. It's either filled in by esbuild's native path resolution behavior or returned by the [on-resolve callback](#on-resolve) that resolved this file. This is stored separately from the path so that most plugins can just deal with the path and ignore the suffix. The on-load behavior that's built into esbuild just ignores the suffix and loads the file from its path alone.

      For context, IE8's CSS parser has a bug where it considers certain URLs to extend to the last `)` instead of the first `)`. So the CSS code `url('Foo.eot') format('eot')` is incorrectly considered to have a URL of `Foo.eot') format('eot`. To avoid this, people typically add something like `?#iefix` so that IE8 sees the URL as `Foo.eot?#iefix') format('eot`. Then the path part of the URL is `Foo.eot` and the query part is `?#iefix') format('eot`, which means IE8 can find the file `Foo.eot` by discarding the query.

      The suffix feature was added to esbuild to handle CSS files containing these hacks. A URL of `Foo.eot?#iefix` should be considered [external](../api/index#external) if all files matching `*.eot` have been marked as external, but the `?#iefix` suffix should still be present in the final output file.

    - `pluginData`

      This property is passed from the previous plugin, as set by the [on-resolve callback](#on-resolve) that runs in the plugin chain.

    - `with`

      This contains a map of the [import attributes](https://github.com/tc39/proposal-import-attributes) that were present on the import statement used to import this module. For example, a module imported using `with { type: 'json' }` will provide a `with` value of `{ type: 'json' }` to plugins. A given module is loaded separately for each unique combination of import attributes, so these attributes are guaranteed to have been provided by all import statements used to import this module. That means they can be used by the plugin to alter the content of this module.

    &nbsp;
- name: On-load callbacks
  id: plugins/index#on-load
  summary: A callback added using onLoad will be run for each unique path/namespace pair that has not been marked as external
  belongs_to: Plugins
  description: |-
    ## On-load callbacks

    A callback added using `onLoad` will be run for each unique path/namespace pair that has not been marked as external. Its job is to return the contents of the module and to tell esbuild how to interpret it. Here's an example plugin that converts `.txt` files into an array of words:

    ``` javascript
    import * as esbuild from 'esbuild'
    import fs from 'node:fs'

    let exampleOnLoadPlugin = {
      name: 'example',
      setup(build) {
        // Load ".txt" files and return an array of words
        build.onLoad({ filter: /\.txt$/ }, async (args) => {
          let text = await fs.promises.readFile(args.path, 'utf8')
          return {
            contents: JSON.stringify(text.split(/\s+/)),
            loader: 'json',
          }
        })
      },
    }

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      outfile: 'out.js',
      plugins: [exampleOnLoadPlugin],
    })
    ```

    ``` go
    package main

    import "encoding/json"
    import "io/ioutil"
    import "os"
    import "strings"
    import "github.com/evanw/esbuild/pkg/api"

    var exampleOnLoadPlugin = api.Plugin{
      Name: "example",
      Setup: func(build api.PluginBuild) {
        // Load ".txt" files and return an array of words
        build.OnLoad(api.OnLoadOptions{Filter: `\.txt$`},
          func(args api.OnLoadArgs) (api.OnLoadResult, error) {
            text, err := ioutil.ReadFile(args.Path)
            if err != nil {
              return api.OnLoadResult{}, err
            }
            bytes, err := json.Marshal(strings.Fields(string(text)))
            if err != nil {
              return api.OnLoadResult{}, err
            }
            contents := string(bytes)
            return api.OnLoadResult{
              Contents: &contents,
              Loader:   api.LoaderJSON,
            }, nil
          })
      },
    }

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Outfile:     "out.js",
        Plugins:     []api.Plugin{exampleOnLoadPlugin},
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    The callback can return without providing the contents of the module. In that case the responsibility for loading the module is passed to the next registered callback. For a given module, all `onLoad` callbacks from all plugins will be run in the order they were registered until one takes responsibility for loading the module. If no callback returns contents for the module, esbuild will run its default module loading logic.

    Keep in mind that many callbacks may be running concurrently. In JavaScript, if your callback does expensive work that can run on another thread such as `fs.readFileSync()`, you should make the callback `async` and use `await` (in this case with `fs.promises.readFile()`) to allow other code to run in the meantime. In Go, each callback may be run on a separate goroutine. Make sure you have appropriate synchronization in place if your plugin uses any shared data structures.
- name: On-load options
  id: plugins/index#on-load-options
  summary: The onLoad API is meant to be called within the setup function and registers a callback to be triggered in certain situations
  belongs_to: Plugins
  description: |-
    ### On-load options

    The `onLoad` API is meant to be called within the `setup` function and registers a callback to be triggered in certain situations. It takes a few options:

    ``` javascript
    interface OnLoadOptions {
      filter: RegExp;
      namespace?: string;
    }
    ```

    ``` go
    type OnLoadOptions struct {
      Filter    string
      Namespace string
    }
    ```

    - `filter`

      Every callback must provide a filter, which is a regular expression. The registered callback will be skipped when the path doesn't match this filter. You can read more about filters [here](#filters).

    - `namespace`

      This is optional. If provided, the callback is only run on paths within modules in the provided namespace. You can read more about namespaces [here](#namespaces).

    &nbsp;
- name: On-load results
  id: plugins/index#on-load-results
  summary: This is the object that can be returned by a callback added using onLoad to provide the contents of a module
  belongs_to: Plugins
  description: |-
    ### On-load results

    This is the object that can be returned by a callback added using `onLoad` to provide the contents of a module. If you would like to return from the callback without providing any contents, just return the default value (so `undefined` in JavaScript and `OnLoadResult{}` in Go). Here are the optional properties that can be returned:

    ``` javascript
    interface OnLoadResult {
      contents?: string | Uint8Array;
      errors?: Message[];
      loader?: Loader;
      pluginData?: any;
      pluginName?: string;
      resolveDir?: string;
      warnings?: Message[];
      watchDirs?: string[];
      watchFiles?: string[];
    }

    interface Message {
      text: string;
      location: Location | null;
      detail: any; // The original error from a JavaScript plugin, if applicable
    }

    interface Location {
      file: string;
      namespace: string;
      line: number; // 1-based
      column: number; // 0-based, in bytes
      length: number; // in bytes
      lineText: string;
    }
    ```

    ``` go
    type OnLoadResult struct {
      Contents   *string
      Errors     []Message
      Loader     Loader
      PluginData interface{}
      PluginName string
      ResolveDir string
      Warnings   []Message
      WatchDirs  []string
      WatchFiles []string
    }

    type Message struct {
      Text     string
      Location *Location
      Detail   interface{} // The original error from a Go plugin, if applicable
    }

    type Location struct {
      File      string
      Namespace string
      Line      int // 1-based
      Column    int // 0-based, in bytes
      Length    int // in bytes
      LineText  string
    }
    ```

    - `contents`

      Set this to a string to specify the contents of the module. If this is set, no more on-load callbacks will be run for this resolved path. If this is not set, esbuild will continue to run on-load callbacks that were registered after the current one. Then, if the contents are still not set, esbuild will default to loading the contents from the file system if the resolved path is in the `file` namespace.

    - `loader`

      This tells esbuild how to interpret the contents. For example, the [`js`](../content-types/index#javascript) loader interprets the contents as JavaScript and the [`css`](../content-types/index#css) loader interprets the contents as CSS. The loader defaults to `js` if it's not specified. See the [content types](../content-types/index) page for a complete list of all built-in loaders.

    - `resolveDir`

      This is the file system directory to use when resolving an import path in this module to a real path on the file system. For modules in the `file` namespace, this value defaults to the directory part of the module path. Otherwise this value defaults to empty unless the plugin provides one. If the plugin doesn't provide one, esbuild's default behavior won't resolve any imports in this module. This directory will be passed to any [on-resolve callbacks](#on-resolve) that run on unresolved import paths in this module.

    - `errors` and `warnings`

      These properties let you pass any log messages generated during path resolution to esbuild where they will be displayed in the terminal according to the current [log level](../api/index#log-level) and end up in the final build result. For example, if you are calling a library and that library can return errors and/or warnings, you will want to forward them using these properties.

      If you only have a single error to return, you don't have to pass it via `errors`. You can simply throw the error in JavaScript or return the `error` object as the second return value in Go.

    - `watchFiles` and `watchDirs`

      These properties let you return additional file system paths for esbuild's [watch mode](../api/index#watch) to scan. By default esbuild will only scan the path provided to `onLoad` plugins, and only if the namespace is `file`. If your plugin needs to react to additional changes in the file system, it needs to use one of these properties.

      A rebuild will be triggered if any file in the `watchFiles` array has been changed since the last build. Change detection is somewhat complicated and may check the file contents and/or the file's metadata.

      A rebuild will also be triggered if the list of directory entries for any directory in the `watchDirs` array has been changed since the last build. Note that this does not check anything about the contents of any file in these directories, and it also does not check any subdirectories. Think of this as checking the output of the Unix `ls` command.

      For robustness, you should include all file system paths that were used during the evaluation of the plugin. For example, if your plugin does something equivalent to `require.resolve()`, you'll need to include the paths of all "does this file exist" checks, not just the final path. Otherwise a new file could be created that causes the build to become outdated, but esbuild doesn't detect it because that path wasn't listed.

    - `pluginName`

      This property lets you replace this plugin's name with another name for this module load operation. It's useful for proxying another plugin through this plugin. For example, it lets you have a single plugin that forwards to a child process containing multiple plugins. You probably won't need to use this.

    - `pluginData`

      This property will be passed to the next plugin that runs in the plugin chain. If you return it from an `onLoad` plugin, it will be passed to the `onResolve` plugins for any imports in that file, and if you return it from an `onResolve` plugin, an arbitrary one will be passed to the `onLoad` plugin when it loads the file (it's arbitrary since the relationship is many-to-one). This is useful to pass data between different plugins without them having to coordinate directly.

    &nbsp;
- name: On-resolve arguments
  id: plugins/index#on-resolve-arguments
  summary: This is the verbatim unresolved path from the underlying module's source code
  belongs_to: Plugins
  description: |-
    ### On-resolve arguments

    When esbuild calls the callback registered by `onResolve`, it will provide these arguments with information about the imported path:

    ``` javascript
    interface OnResolveArgs {
      path: string;
      importer: string;
      namespace: string;
      resolveDir: string;
      kind: ResolveKind;
      pluginData: any;
      with: Record<string, string>;
    }

    type ResolveKind =
      | 'entry-point'
      | 'import-statement'
      | 'require-call'
      | 'dynamic-import'
      | 'require-resolve'
      | 'import-rule'
      | 'composes-from'
      | 'url-token'
    ```

    ``` go
    type OnResolveArgs struct {
      Path       string
      Importer   string
      Namespace  string
      ResolveDir string
      Kind       ResolveKind
      PluginData interface{}
      With       map[string]string
    }

    const (
      ResolveEntryPoint        ResolveKind
      ResolveJSImportStatement ResolveKind
      ResolveJSRequireCall     ResolveKind
      ResolveJSDynamicImport   ResolveKind
      ResolveJSRequireResolve  ResolveKind
      ResolveCSSImportRule     ResolveKind
      ResolveCSSComposesFrom   ResolveKind
      ResolveCSSURLToken       ResolveKind
    )
    ```

    - `path`

      This is the verbatim unresolved path from the underlying module's source code. It can take any form. While esbuild's default behavior is to interpret import paths as either a relative path or a package name, plugins can be used to introduce new path forms. For example, the sample [HTTP plugin](#http-plugin) below gives special meaning to paths starting with `http://`.

    - `importer`

      This is the path of the module containing this import to be resolved. Note that this path is only guaranteed to be a file system path if the namespace is `file`. If you want to resolve a path relative to the directory containing the importer module, you should use `resolveDir` instead since that also works for virtual modules.

    - `namespace`

      This is the namespace of the module containing this import to be resolved, as set by the [on-load callback](#on-load) that loaded this file. This defaults to the `file` namespace for modules loaded with esbuild's default behavior. You can read more about namespaces [here](#namespaces).

    - `resolveDir`

      This is the file system directory to use when resolving an import path to a real path on the file system. For modules in the `file` namespace, this value defaults to the directory part of the module path. For virtual modules this value defaults to empty but [on-load callbacks](#on-load) can optionally give virtual modules a resolve directory too. If that happens, it will be provided to resolve callbacks for unresolved paths in that file.

    - `kind`

      This says how the path to be resolved is being imported. For example, `'entry-point'` means the path was provided to the API as an entry point path, `'import-statement'` means the path is from a JavaScript `import` or `export` statement, and `'import-rule'` means the path is from a CSS `@import` rule.

    - `pluginData`

      This property is passed from the previous plugin, as set by the [on-load callback](#on-load) that loaded this file.

    - `with`

      This contains a map of the [import attributes](https://github.com/tc39/proposal-import-attributes) that were present on the import statement used to import this module. For example, a module imported using `with { type: 'json' }` will provide a `with` value of `{ type: 'json' }` to plugins. You can use this to resolve to a different path depending on the import attributes.

    &nbsp;
- name: On-resolve callbacks
  id: plugins/index#on-resolve
  summary: A callback added using onResolve will be run on each import path in each module that esbuild builds
  belongs_to: Plugins
  description: |-
    ## On-resolve callbacks

    A callback added using `onResolve` will be run on each import path in each module that esbuild builds. The callback can customize how esbuild does path resolution. For example, it can intercept import paths and redirect them somewhere else. It can also mark paths as external. Here is an example:

    ``` javascript
    import * as esbuild from 'esbuild'
    import path from 'node:path'

    let exampleOnResolvePlugin = {
      name: 'example',
      setup(build) {
        // Redirect all paths starting with "images/" to "./public/images/"
        build.onResolve({ filter: /^images\// }, args => {
          return { path: path.join(args.resolveDir, 'public', args.path) }
        })

        // Mark all paths starting with "http://" or "https://" as external
        build.onResolve({ filter: /^https?:\/\// }, args => {
          return { path: args.path, external: true }
        })
      },
    }

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      outfile: 'out.js',
      plugins: [exampleOnResolvePlugin],
      loader: { '.png': 'binary' },
    })
    ```

    ``` go
    package main

    import "os"
    import "path/filepath"
    import "github.com/evanw/esbuild/pkg/api"

    var exampleOnResolvePlugin = api.Plugin{
      Name: "example",
      Setup: func(build api.PluginBuild) {
        // Redirect all paths starting with "images/" to "./public/images/"
        build.OnResolve(api.OnResolveOptions{Filter: `^images/`},
          func(args api.OnResolveArgs) (api.OnResolveResult, error) {
            return api.OnResolveResult{
              Path: filepath.Join(args.ResolveDir, "public", args.Path),
            }, nil
          })

        // Mark all paths starting with "http://" or "https://" as external
        build.OnResolve(api.OnResolveOptions{Filter: `^https?://`},
          func(args api.OnResolveArgs) (api.OnResolveResult, error) {
            return api.OnResolveResult{
              Path:     args.Path,
              External: true,
            }, nil
          })
      },
    }

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Outfile:     "out.js",
        Plugins:     []api.Plugin{exampleOnResolvePlugin},
        Write:       true,
        Loader: map[string]api.Loader{
          ".png": api.LoaderBinary,
        },
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    The callback can return without providing a path to pass on responsibility for path resolution to the next callback. For a given import path, all `onResolve` callbacks from all plugins will be run in the order they were registered until one takes responsibility for path resolution. If no callback returns a path, esbuild will run its default path resolution logic.

    Keep in mind that many callbacks may be running concurrently. In JavaScript, if your callback does expensive work that can run on another thread such as `fs.existsSync()`, you should make the callback `async` and use `await` (in this case with `fs.promises.exists()`) to allow other code to run in the meantime. In Go, each callback may be run on a separate goroutine. Make sure you have appropriate synchronization in place if your plugin uses any shared data structures.
- name: On-resolve options
  id: plugins/index#on-resolve-options
  summary: The onResolve API is meant to be called within the setup function and registers a callback to be triggered in certain situations
  belongs_to: Plugins
  description: |-
    ### On-resolve options

    The `onResolve` API is meant to be called within the `setup` function and registers a callback to be triggered in certain situations. It takes a few options:

    ``` javascript
    interface OnResolveOptions {
      filter: RegExp;
      namespace?: string;
    }
    ```

    ``` go
    type OnResolveOptions struct {
      Filter    string
      Namespace string
    }
    ```

    - `filter`

      Every callback must provide a filter, which is a regular expression. The registered callback will be skipped when the path doesn't match this filter. You can read more about filters [here](#filters).

    - `namespace`

      This is optional. If provided, the callback is only run on paths within modules in the provided namespace. You can read more about namespaces [here](#namespaces).

    &nbsp;
- name: On-resolve results
  id: plugins/index#on-resolve-results
  summary: This is the object that can be returned by a callback added using onResolve to provide a custom path resolution
  belongs_to: Plugins
  description: |-
    ### On-resolve results

    This is the object that can be returned by a callback added using `onResolve` to provide a custom path resolution. If you would like to return from the callback without providing a path, just return the default value (so `undefined` in JavaScript and `OnResolveResult{}` in Go). Here are the optional properties that can be returned:

    ``` javascript
    interface OnResolveResult {
      errors?: Message[];
      external?: boolean;
      namespace?: string;
      path?: string;
      pluginData?: any;
      pluginName?: string;
      sideEffects?: boolean;
      suffix?: string;
      warnings?: Message[];
      watchDirs?: string[];
      watchFiles?: string[];
    }

    interface Message {
      text: string;
      location: Location | null;
      detail: any; // The original error from a JavaScript plugin, if applicable
    }

    interface Location {
      file: string;
      namespace: string;
      line: number; // 1-based
      column: number; // 0-based, in bytes
      length: number; // in bytes
      lineText: string;
    }
    ```

    ``` go
    type OnResolveResult struct {
      Errors      []Message
      External    bool
      Namespace   string
      Path        string
      PluginData  interface{}
      PluginName  string
      SideEffects SideEffects
      Suffix      string
      Warnings    []Message
      WatchDirs   []string
      WatchFiles  []string
    }

    type Message struct {
      Text     string
      Location *Location
      Detail   interface{} // The original error from a Go plugin, if applicable
    }

    type Location struct {
      File      string
      Namespace string
      Line      int // 1-based
      Column    int // 0-based, in bytes
      Length    int // in bytes
      LineText  string
    }
    ```

    - `path`

      Set this to a non-empty string to resolve the import to a specific path. If this is set, no more on-resolve callbacks will be run for this import path in this module. If this is not set, esbuild will continue to run on-resolve callbacks that were registered after the current one. Then, if the path still isn't resolved, esbuild will default to resolving the path relative to the resolve directory of the current module.

    - `external`

      Set this to `true` to mark the module as [external](../api/index#external), which means it will not be included in the bundle and will instead be imported at run-time.

    - `namespace`

      This is the namespace associated with the resolved path. If left empty, it will default to the `file` namespace for non-external paths. Paths in the file namespace must be an absolute path for the current file system (so starting with a forward slash on Unix and with a drive letter on Windows).

      If you want to resolve to a path that isn't a file system path, you should set the namespace to something other than `file` or an empty string. This tells esbuild to not treat the path as pointing to something on the file system.

    - `errors` and `warnings`

      These properties let you pass any log messages generated during path resolution to esbuild where they will be displayed in the terminal according to the current [log level](../api/index#log-level) and end up in the final build result. For example, if you are calling a library and that library can return errors and/or warnings, you will want to forward them using these properties.

      If you only have a single error to return, you don't have to pass it via `errors`. You can simply throw the error in JavaScript or return the `error` object as the second return value in Go.

    - `watchFiles` and `watchDirs`

      These properties let you return additional file system paths for esbuild's [watch mode](../api/index#watch) to scan. By default esbuild will only scan the path provided to `onLoad` plugins, and only if the namespace is `file`. If your plugin needs to react to additional changes in the file system, it needs to use one of these properties.

      A rebuild will be triggered if any file in the `watchFiles` array has been changed since the last build. Change detection is somewhat complicated and may check the file contents and/or the file's metadata.

      A rebuild will also be triggered if the list of directory entries for any directory in the `watchDirs` array has been changed since the last build. Note that this does not check anything about the contents of any file in these directories, and it also does not check any subdirectories. Think of this as checking the output of the Unix `ls` command.

      For robustness, you should include all file system paths that were used during the evaluation of the plugin. For example, if your plugin does something equivalent to `require.resolve()`, you'll need to include the paths of all "does this file exist" checks, not just the final path. Otherwise a new file could be created that causes the build to become outdated, but esbuild doesn't detect it because that path wasn't listed.

    - `pluginName`

      This property lets you replace this plugin's name with another name for this path resolution operation. It's useful for proxying another plugin through this plugin. For example, it lets you have a single plugin that forwards to a child process containing multiple plugins. You probably won't need to use this.

    - `pluginData`

      This property will be passed to the next plugin that runs in the plugin chain. If you return it from an `onLoad` plugin, it will be passed to the `onResolve` plugins for any imports in that file, and if you return it from an `onResolve` plugin, an arbitrary one will be passed to the `onLoad` plugin when it loads the file (it's arbitrary since the relationship is many-to-one). This is useful to pass data between different plugins without them having to coordinate directly.

    - `sideEffects`

      Setting this property to false tells esbuild that imports of this module can be removed if the imported names are unused. This behaves as if `"sideEffects": false` was specified the corresponding `package.json` file. For example, `import { x } from "y"` may be completely removed if `x` is unused and `y` has been marked as `sideEffects: false`. You can read more about what `sideEffects` means in [Webpack's documentation about the feature](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free).

    - `suffix`

      Returning a value here lets you pass along an optional URL query or hash to append to the path that is not included in the path itself. Storing this separately is beneficial in cases when the path is processed by something that is not aware of the suffix, either by esbuild itself or by another plugin.

      For example, an on-resolve plugin might return a suffix of `?#iefix` for a `.eot` file in a build with a different on-load plugin for paths ending in `.eot`. Keeping the suffix separate means the suffix is still associated with the path but the `.eot` plugin will still match the file without needing to know anything about suffixes.

      If you do set a suffix, it must begin with either `?` or `#` because it's intended to be a URL query or hash. This feature has certain obscure uses such as hacking around bugs in IE8's CSS parser and may not be that useful otherwise. If you do use it, keep in mind that each unique namespace, path, and suffix combination is considered by esbuild to be a unique module identifier so by returning a different suffix for the same path, you are telling esbuild to create another copy of the module.

    &nbsp;
- name: On-start callbacks
  id: plugins/index#on-start
  summary: Register an on-start callback to be notified when a new build starts
  belongs_to: Plugins
  description: |-
    ## On-start callbacks

    Register an on-start callback to be notified when a new build starts. This triggers for all builds, not just the initial build, so it's especially useful for [rebuilds](../api/index#rebuild), [watch mode](../api/index#watch), and [serve mode](../api/index#serve). Here's how to add an on-start callback:

    ``` javascript
    let examplePlugin = {
      name: 'example',
      setup(build) {
        build.onStart(() => {
          console.log('build started')
        })
      },
    }
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    var examplePlugin = api.Plugin{
      Name: "example",
      Setup: func(build api.PluginBuild) {
        build.OnStart(func() (api.OnStartResult, error) {
          fmt.Fprintf(os.Stderr, "build started\n")
          return api.OnStartResult{}, nil
        })
      },
    }

    func main() {
    }
    ```

    You should not use an on-start callback for initialization since it can be run multiple times. If you want to initialize something, just put your plugin initialization code directly inside the `setup` function instead.

    The on-start callback can be `async` and can return a promise. All on-start callbacks from all plugins are run concurrently, and then the build waits for all on-start callbacks to finish before proceeding. On-start callbacks can optionally return errors and/or warnings to be included with the build.

    Note that on-start callbacks do not have the ability to mutate the [build options](#build-options). The initial build options can only be modified within the `setup` function and are consumed once `setup` returns. All builds after the first one reuse the same initial options so the initial options are never re-consumed, and modifications to `build.initialOptions` that are done within the start callback are ignored.
- name: Optimization
  id: api/index#optimization
  summary: null
  belongs_to: API
  description: '## Optimization'
- name: Other ways to install
  id: getting-started/index#other-ways-to-install
  summary: The recommended way to install esbuild is to install the native executable using npm
  belongs_to: Getting Started
  description: |-
    ## Other ways to install

    The recommended way to install esbuild is to [install the native executable using npm](#install-esbuild). But you can also install esbuild in these ways:
- name: Out extension
  id: api/index#out-extension
  summary: This option lets you customize the file extension of the files that esbuild generates to something other than .js or .css
  belongs_to: API
  description: |-
    ### Out extension

    *Supported by: [Build](#build)*

    This option lets you customize the file extension of the files that esbuild generates to something other than `.js` or `.css`. In particular, the `.mjs` and `.cjs` file extensions have special meaning in node (they indicate a file in ESM and CommonJS format, respectively). This option is useful if you are using esbuild to generate multiple files and you have to use the [outdir](#outdir) option instead of the [outfile](#outfile) option. You can use it like this:

    ``` sh
    esbuild app.js --bundle --outdir=dist --out-extension:.js=.mjs
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      outdir: 'dist',
      outExtension: { '.js': '.mjs' },
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Outdir:      "dist",
        OutExtension: map[string]string{
          ".js": ".mjs",
        },
        Write: true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Outbase
  id: api/index#outbase
  summary: If your build contains multiple entry points in separate directories, the directory structure will be replicated into the output directory relative to the outbase directory
  belongs_to: API
  description: |-
    ### Outbase

    *Supported by: [Build](#build)*

    If your build contains multiple entry points in separate directories, the directory structure will be replicated into the [output directory](#outdir) relative to the outbase directory. For example, if there are two entry points `src/pages/home/index.ts` and `src/pages/about/index.ts` and the outbase directory is `src`, the output directory will contain `pages/home/index.js` and `pages/about/index.js`. Here's how to use it:

    ``` sh
    esbuild src/pages/home/index.ts src/pages/about/index.ts --bundle --outdir=out --outbase=src
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: [
        'src/pages/home/index.ts',
        'src/pages/about/index.ts',
      ],
      bundle: true,
      outdir: 'out',
      outbase: 'src',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{
          "src/pages/home/index.ts",
          "src/pages/about/index.ts",
        },
        Bundle:  true,
        Outdir:  "out",
        Outbase: "src",
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    If the outbase directory isn't specified, it defaults to the [lowest common ancestor](https://en.wikipedia.org/wiki/Lowest_common_ancestor) directory among all input entry point paths. This is `src/pages` in the example above, which means by default the output directory will contain `home/index.js` and `about/index.js` instead.
- name: Outdated version of Go
  id: faq/index#old-go-version
  summary: If you use an automated dependency vulnerability scanner, you may get a report that the version of the Go compiler that esbuild uses and/or the version of golang.org/x/sys (esbuild's only dependency) is outdated
  belongs_to: FAQ
  description: |-
    ## Outdated version of Go

    If you use an automated dependency vulnerability scanner, you may get a report that the version of the Go compiler that esbuild uses and/or the version of `golang.org/x/sys` (esbuild's only dependency) is outdated. These reports are benign and should be ignored.

    This happens because esbuild's code is deliberately intended to be compilable with Go 1.13. Later versions of Go have dropped support for certain older platforms that I want esbuild to be able to run on (e.g. older versions of macOS). While esbuild's published binaries are compiled with a much newer version of the Go compiler (and therefore don't work on older versions of macOS), you are currently still able to compile the latest version of esbuild for yourself with Go 1.13 and use it on older versions of macOS because esbuild's code can still be compiled with Go as far back as 1.13.

    People and/or automated tools sometimes see the `go 1.13` line in [`go.mod`](https://github.com/evanw/esbuild/blob/main/go.mod) and complain that esbuild's published binaries are built with Go 1.13, which is a really old version of Go. However, that's not true. That line in `go.mod` only specifies the minimum compiler version. It has nothing to do with the version of Go that esbuild's published binaries are built with, which is a much newer version of Go. [Please read the documentation.](https://go.dev/ref/mod#go-mod-file-go)

    People also sometimes want esbuild to update the `golang.org/x/sys` dependency because there is a known vulnerability in the version that esbuild uses (specifically [GO-2022-0493](https://pkg.go.dev/vuln/GO-2022-0493) about the `Faccessat` function). The problem that prevents esbuild from updating to a newer version of the `golang.org/x/sys` dependency is that newer versions have started using the `unsafe.Slice` function, which was first introduced in Go 1.17 (and therefore doesn't compile in older versions of Go). However, this vulnerability report is irrelevant because a) esbuild doesn't ever call that function in the first place and b) esbuild is a build tool, not a sandbox, and esbuild's file system access is not security-sensitive.

    I'm not going to drop compatibility with older platforms and prevent some people from being able to use esbuild just to work around irrelevant vulnerability reports. Please ignore any reports about the issues described above.
- name: Outdir
  id: api/index#outdir
  summary: This option sets the output directory for the build operation
  belongs_to: API
  description: |-
    ### Outdir

    *Supported by: [Build](#build)*

    This option sets the output directory for the build operation. For example, this command will generate a directory called `out`:

    ``` sh
    esbuild app.js --bundle --outdir=out
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      outdir: 'out',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Outdir:      "out",
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    The output directory will be generated if it does not already exist, but it will not be cleared if it already contains some files. Any generated files will silently overwrite existing files with the same name. You should clear the output directory yourself before running esbuild if you want the output directory to only contain files from the current run of esbuild.

    If your build contains multiple entry points in separate directories, the directory structure will be replicated into the output directory starting from the [lowest common ancestor](https://en.wikipedia.org/wiki/Lowest_common_ancestor) directory among all input entry point paths. For example, if there are two entry points `src/home/index.ts` and `src/about/index.ts`, the output directory will contain `home/index.js` and `about/index.js`. If you want to customize this behavior, you should change the [outbase directory](#outbase).
- name: Outfile
  id: api/index#outfile
  summary: This option sets the output file name for the build operation
  belongs_to: API
  description: |-
    ### Outfile

    *Supported by: [Build](#build)*

    This option sets the output file name for the build operation. This is only applicable if there is a single entry point. If there are multiple entry points, you must use the [outdir](#outdir) option instead to specify an output directory. Using outfile looks like this:

    ``` sh
    esbuild app.js --bundle --outfile=out.js
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Outfile:     "out.js",
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Output contents
  id: api/index#output-contents
  summary: null
  belongs_to: API
  description: '## Output contents'
- name: Output location
  id: api/index#output-location
  summary: null
  belongs_to: API
  description: '## Output location'
- name: Overview
  id: api/index#overview
  summary: The two most commonly-used esbuild APIs are build and transform
  belongs_to: API
  description: |-
    ## Overview

    The two most commonly-used esbuild APIs are [build](#build) and [transform](#transform). Each is described below at a high level, followed by documentation for each individual API option.
- name: Packages
  id: api/index#packages
  summary: Use this setting to control whether all of your package's dependencies are excluded from the bundle or not
  belongs_to: API
  description: |-
    ### Packages

    *Supported by: [Build](#build)*

    Use this setting to control whether all of your package's dependencies are excluded from the bundle or not. This is useful when [bundling for node](../getting-started/index#bundling-for-node) because many npm packages use node-specific features that esbuild doesn't support while bundling (such as `__dirname`, `import.meta.url`, `fs.readFileSync`, and `*.node` native binary modules). There are two possible values:

    - `bundle`

      This is the default value. It means that package imports are allowed to be bundled. Note that this value doesn't mean all packages will be bundled, just that they are allowed to be. You can still exclude individual packages from the bundle using [external](#external).

    - `external`

      This means that all package imports considered external to the bundle, and are not bundled. *Note that your dependencies must still be present on the file system when your bundle is run.* It has the same effect as manually passing each dependency to [external](#external) but is more concise. If you want to customize which of your dependencies are external and which ones aren't, then you should set this to `bundle` instead and then use [external](#external) for individual dependencies.

      This setting considers all import paths that "look like" package imports in the original source code to be package imports. Specifically import paths that don't start with a path segment of `/` or `.` or `..` are considered to be package imports. The only two exceptions to this rule are [subpath imports](https://nodejs.org/api/packages.html#subpath-imports) (which start with a `#` character) and TypeScript path remappings via [`paths`](https://www.typescriptlang.org/tsconfig/#paths) and/or [`baseUrl`](https://www.typescriptlang.org/tsconfig/#baseUrl) in `tsconfig.json` (which are applied first).

    Using it looks like this:

    ``` sh
    esbuild app.js --bundle --packages=external
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      packages: 'external',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Packages:    api.PackagesExternal,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Note that this setting only has an effect when [bundling](#bundle) is enabled. Also note that marking an import path as external happens after the import path is rewritten by any configured [aliases](#alias), so the alias feature still has an effect when this setting is used.
- name: Path resolution
  id: api/index#path-resolution
  summary: null
  belongs_to: API
  description: '## Path resolution'
- name: Platform
  id: api/index#platform
  summary: By default, esbuild's bundler is configured to generate code intended for the browser
  belongs_to: API
  description: |-
    ### Platform

    *Supported by: [Build](#build) and [Transform](#transform)*

    By default, esbuild's bundler is configured to generate code intended for the browser. If your bundled code is intended to run in node instead, you should set the platform to `node`:

    ``` sh
    esbuild app.js --bundle --platform=node
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      platform: 'node',
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Platform:    api.PlatformNode,
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    When the platform is set to `browser` (the default value):

    - When [bundling](#bundle) is enabled the default output [format](#format) is set to `iife`, which wraps the generated JavaScript code in an immediately-invoked function expression to prevent variables from leaking into the global scope.

    - If a package specifies a map for the [`browser`](https://gist.github.com/defunctzombie/4339901/49493836fb873ddaa4b8a7aa0ef2352119f69211) field in its `package.json` file, esbuild will use that map to replace specific files or modules with their browser-friendly versions. For example, a package might contain a substitution of [`path`](https://nodejs.org/api/path.html) with [`path-browserify`](https://www.npmjs.com/package/path-browserify).

    - The [main fields](#main-fields) setting is set to `browser,module,main` but with some additional special behavior: if a package provides `module` and `main` entry points but not a `browser` entry point then `main` is used instead of `module` if that package is ever imported using `require()`. This behavior improves compatibility with CommonJS modules that export a function by assigning it to `module.exports`. If you want to disable this additional special behavior, you can explicitly set the [main fields](#main-fields) setting to `browser,module,main`.

    - The [conditions](#conditions) setting automatically includes the `browser` condition. This changes how the `exports` field in `package.json` files is interpreted to prefer browser-specific code.

    - If no custom [conditions](#conditions) are configured, the Webpack-specific `module` condition is also included. The `module` condition is used by package authors to provide a tree-shakable ESM alternative to a CommonJS file without creating a [dual package hazard](https://nodejs.org/api/packages.html#dual-package-hazard). You can prevent the `module` condition from being included by explicitly configuring some custom conditions (even an empty list).

    - When using the [build](#build) API, all `process.env.NODE_ENV` expressions are automatically [defined](#define) to `"production"` if all [minification](#minify) options are enabled and `"development"` otherwise. This only happens if `process`, `process.env`, and `process.env.NODE_ENV` are not already defined. This substitution is necessary to avoid React-based code crashing instantly (since `process` is a node API, not a web API).

    - The character sequence `</script>` will be escaped in JavaScript code and the character sequence `</style>` will be escaped in CSS code. This is done in case you inline esbuild's output directly into an HTML file. This can be disabled with esbuild's [supported](#supported) feature by setting `inline-script` (for JavaScript) and/or `inline-style` (for CSS) to `false`.

    When the platform is set to `node`:

    - When [bundling](#bundle) is enabled the default output [format](#format) is set to `cjs`, which stands for CommonJS (the module format used by node). ES6-style exports using `export` statements will be converted into getters on the CommonJS `exports` object.

    - All [built-in node modules](https://nodejs.org/docs/latest/api/) such as `fs` are automatically marked as [external](#external) so they don't cause errors when the bundler tries to bundle them.

    - The [main fields](#main-fields) setting is set to `main,module`. This means tree shaking will likely not happen for packages that provide both `module` and `main` since tree shaking works with ECMAScript modules but not with CommonJS modules.

      Unfortunately some packages incorrectly treat `module` as meaning "browser code" instead of "ECMAScript module code" so this default behavior is required for compatibility. You can manually configure the [main fields](#main-fields) setting to `module,main` if you want to enable tree shaking and know it is safe to do so.

    - The [conditions](#conditions) setting automatically includes the `node` condition. This changes how the `exports` field in `package.json` files is interpreted to prefer node-specific code.

    - If no custom [conditions](#conditions) are configured, the Webpack-specific `module` condition is also included. The `module` condition is used by package authors to provide a tree-shakable ESM alternative to a CommonJS file without creating a [dual package hazard](https://nodejs.org/api/packages.html#dual-package-hazard). You can prevent the `module` condition from being included by explicitly configuring some custom conditions (even an empty list).

    - When the [format](#format) is set to `cjs` but the entry point is ESM, esbuild will add special annotations for any named exports to enable importing those named exports using ESM syntax from the resulting CommonJS file. Node's documentation has more information about [node's detection of CommonJS named exports](https://nodejs.org/api/esm.html#commonjs-namespaces).

    - The [`binary`](../content-types/index#binary) loader will make use of node's built-in [`Buffer.from`](https://nodejs.org/api/buffer.html#static-method-bufferfromstring-encoding) API to decode the base64 data embedded in the bundle into a `Uint8Array`. This is faster than what esbuild can do otherwise since it's implemented by node in native code.

    When the platform is set to `neutral`:

    - When [bundling](#bundle) is enabled the default output [format](#format) is set to `esm`, which uses the `export` syntax introduced with ECMAScript 2015 (i.e. ES6). You can change the output format if this default is not appropriate.

    - The [main fields](#main-fields) setting is empty by default. If you want to use npm-style packages, you will likely have to configure this to be something else such as `main` for the standard main field used by node.

    - The [conditions](#conditions) setting does not automatically include any platform-specific values.

    See also [bundling for the browser](../getting-started/index#bundling-for-the-browser) and [bundling for node](../getting-started/index#bundling-for-node).
- name: Plugin API limitations
  id: plugins/index#plugin-api-limitations
  summary: This API does not intend to cover all use cases
  belongs_to: Plugins
  description: "## Plugin API limitations\n\nThis API does not intend to cover all use cases. It's not possible to hook into every part of the bundling process. For example, it's not currently possible to modify the AST directly. This restriction exists to preserve the excellent performance characteristics of esbuild as well as to avoid exposing too much API surface which would be a maintenance burden and would prevent improvements that involve changing the AST.\n\nOne way to think about esbuild is as a \"linker\" for the web. Just like a linker for native code, esbuild's job is to take a set of files, resolve and bind references between them, and generate a single file containing all of the code linked together. A plugin's job is to generate the individual files that end up being linked.\n\nPlugins in esbuild work best when they are relatively scoped and only customize a small aspect of the build. For example, a plugin for a special configuration file in a custom format (e.g. YAML) is very appropriate. The more plugins you use, the slower your build will get, especially if your plugin is written in JavaScript. If a plugin applies to every file in your build, then your build will likely be very slow. If caching is applicable, it must be done by the plugin itself.\n\n© 2020 Evan Wallace  \nLicensed under the MIT License.  \n[https://esbuild.github.io/plugins/](https://esbuild.github.io/plugins/)"
- name: Plugins
  id: plugins/index
  summary: The plugin API allows you to inject code into various parts of the build process
  description: "# Plugins\n\nThe plugin API allows you to inject code into various parts of the build process. Unlike the rest of the API, it's not available from the command line. You must write either JavaScript or Go code to use the plugin API. Plugins can also only be used with the [build](../api/index#build) API, not with the [transform](../api/index#transform) API.\n\n## Finding plugins\n\nIf you're looking for an existing esbuild plugin, you should check out the [list of existing esbuild plugins](https://github.com/esbuild/community-plugins). Plugins on this list have been deliberately added by the author and are intended to be used by others in the esbuild community.\n\nIf you want to share your esbuild plugin, you should:\n\n1.  [Publish it to npm](https://docs.npmjs.com/creating-and-publishing-unscoped-public-packages) so others can install it.\n2.  Add it to the [list of existing esbuild plugins](https://github.com/esbuild/community-plugins) so others can find it.\n\n## Using plugins\n\nAn esbuild plugin is an object with a `name` and a `setup` function. They are passed in an array to the [build](../api/index#build) API call. The `setup` function is run once for each build API call.\n\nHere's a simple plugin example that allows you to import the current environment variables at build time:\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet envPlugin = {\n  name: 'env',\n  setup(build) {\n    // Intercept import paths called \"env\" so esbuild doesn't attempt\n    // to map them to a file system location. Tag them with the \"env-ns\"\n    // namespace to reserve them for this plugin.\n    build.onResolve({ filter: /^env$/ }, args => ({\n      path: args.path,\n      namespace: 'env-ns',\n    }))\n\n    // Load paths tagged with the \"env-ns\" namespace and behave as if\n    // they point to a JSON file containing the environment variables.\n    build.onLoad({ filter: /.*/, namespace: 'env-ns' }, () => ({\n      contents: JSON.stringify(process.env),\n      loader: 'json',\n    }))\n  },\n}\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  outfile: 'out.js',\n  plugins: [envPlugin],\n})\n```\n\n``` go\npackage main\n\nimport \"encoding/json\"\nimport \"os\"\nimport \"strings\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nvar envPlugin = api.Plugin{\n  Name: \"env\",\n  Setup: func(build api.PluginBuild) {\n    // Intercept import paths called \"env\" so esbuild doesn't attempt\n    // to map them to a file system location. Tag them with the \"env-ns\"\n    // namespace to reserve them for this plugin.\n    build.OnResolve(api.OnResolveOptions{Filter: `^env$`},\n      func(args api.OnResolveArgs) (api.OnResolveResult, error) {\n        return api.OnResolveResult{\n          Path:      args.Path,\n          Namespace: \"env-ns\",\n        }, nil\n      })\n\n    // Load paths tagged with the \"env-ns\" namespace and behave as if\n    // they point to a JSON file containing the environment variables.\n    build.OnLoad(api.OnLoadOptions{Filter: `.*`, Namespace: \"env-ns\"},\n      func(args api.OnLoadArgs) (api.OnLoadResult, error) {\n        mappings := make(map[string]string)\n        for _, item := range os.Environ() {\n          if equals := strings.IndexByte(item, '='); equals != -1 {\n            mappings[item[:equals]] = item[equals+1:]\n          }\n        }\n        bytes, err := json.Marshal(mappings)\n        if err != nil {\n          return api.OnLoadResult{}, err\n        }\n        contents := string(bytes)\n        return api.OnLoadResult{\n          Contents: &contents,\n          Loader:   api.LoaderJSON,\n        }, nil\n      })\n  },\n}\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Outfile:     \"out.js\",\n    Plugins:     []api.Plugin{envPlugin},\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nYou would use it like this:\n\n``` javascript\nimport { PATH } from 'env'\nconsole.log(`PATH is ${PATH}`)\n```\n\n## Concepts\n\nWriting a plugin for esbuild works a little differently than writing a plugin for other bundlers. The concepts below are important to understand before developing your plugin:\n\n### Namespaces\n\nEvery module has an associated namespace. By default esbuild operates in the `file` namespace, which corresponds to files on the file system. But esbuild can also handle \"virtual\" modules that don't have a corresponding location on the file system. One case when this happens is when a module is provided using [stdin](../api/index#stdin).\n\nPlugins can be used to create virtual modules. Virtual modules usually use a namespace other than `file` to distinguish them from file system modules. Usually the namespace is specific to the plugin that created them. For example, the sample [HTTP plugin](#http-plugin) below uses the `http-url` namespace for downloaded files.\n\n### Filters\n\nEvery callback must provide a regular expression as a filter. This is used by esbuild to skip calling the callback when the path doesn't match its filter, which is done for performance. Calling from esbuild's highly-parallel internals into single-threaded JavaScript code is expensive and should be avoided whenever possible for maximum speed.\n\nYou should try to use the filter regular expression instead of using JavaScript code for filtering whenever you can. This is faster because the regular expression is evaluated inside of esbuild without calling out to JavaScript at all. For example, the sample [HTTP plugin](#http-plugin) below uses a filter of `^https?://` to ensure that the performance overhead of running the plugin is only incurred for paths that start with `http://` or `https://`.\n\nThe allowed regular expression syntax is the syntax supported by Go's [regular expression engine](https://pkg.go.dev/regexp/). This is slightly different than JavaScript. Specifically, look-ahead, look-behind, and backreferences are not supported. Go's regular expression engine is designed to avoid the catastrophic exponential-time worst case performance issues that can affect JavaScript regular expressions.\n\nNote that namespaces can also be used for filtering. Callbacks must provide a filter regular expression but can optionally also provide a namespace to further restrict what paths are matched. This can be useful for \"remembering\" where a virtual module came from. Keep in mind that namespaces are matched using an exact string equality test instead of a regular expression, so unlike module paths they are not intended for storing arbitrary data.\n\n## On-resolve callbacks\n\nA callback added using `onResolve` will be run on each import path in each module that esbuild builds. The callback can customize how esbuild does path resolution. For example, it can intercept import paths and redirect them somewhere else. It can also mark paths as external. Here is an example:\n\n``` javascript\nimport * as esbuild from 'esbuild'\nimport path from 'node:path'\n\nlet exampleOnResolvePlugin = {\n  name: 'example',\n  setup(build) {\n    // Redirect all paths starting with \"images/\" to \"./public/images/\"\n    build.onResolve({ filter: /^images\\// }, args => {\n      return { path: path.join(args.resolveDir, 'public', args.path) }\n    })\n\n    // Mark all paths starting with \"http://\" or \"https://\" as external\n    build.onResolve({ filter: /^https?:\\/\\// }, args => {\n      return { path: args.path, external: true }\n    })\n  },\n}\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  outfile: 'out.js',\n  plugins: [exampleOnResolvePlugin],\n  loader: { '.png': 'binary' },\n})\n```\n\n``` go\npackage main\n\nimport \"os\"\nimport \"path/filepath\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nvar exampleOnResolvePlugin = api.Plugin{\n  Name: \"example\",\n  Setup: func(build api.PluginBuild) {\n    // Redirect all paths starting with \"images/\" to \"./public/images/\"\n    build.OnResolve(api.OnResolveOptions{Filter: `^images/`},\n      func(args api.OnResolveArgs) (api.OnResolveResult, error) {\n        return api.OnResolveResult{\n          Path: filepath.Join(args.ResolveDir, \"public\", args.Path),\n        }, nil\n      })\n\n    // Mark all paths starting with \"http://\" or \"https://\" as external\n    build.OnResolve(api.OnResolveOptions{Filter: `^https?://`},\n      func(args api.OnResolveArgs) (api.OnResolveResult, error) {\n        return api.OnResolveResult{\n          Path:     args.Path,\n          External: true,\n        }, nil\n      })\n  },\n}\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Outfile:     \"out.js\",\n    Plugins:     []api.Plugin{exampleOnResolvePlugin},\n    Write:       true,\n    Loader: map[string]api.Loader{\n      \".png\": api.LoaderBinary,\n    },\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThe callback can return without providing a path to pass on responsibility for path resolution to the next callback. For a given import path, all `onResolve` callbacks from all plugins will be run in the order they were registered until one takes responsibility for path resolution. If no callback returns a path, esbuild will run its default path resolution logic.\n\nKeep in mind that many callbacks may be running concurrently. In JavaScript, if your callback does expensive work that can run on another thread such as `fs.existsSync()`, you should make the callback `async` and use `await` (in this case with `fs.promises.exists()`) to allow other code to run in the meantime. In Go, each callback may be run on a separate goroutine. Make sure you have appropriate synchronization in place if your plugin uses any shared data structures.\n\n### On-resolve options\n\nThe `onResolve` API is meant to be called within the `setup` function and registers a callback to be triggered in certain situations. It takes a few options:\n\n``` javascript\ninterface OnResolveOptions {\n  filter: RegExp;\n  namespace?: string;\n}\n```\n\n``` go\ntype OnResolveOptions struct {\n  Filter    string\n  Namespace string\n}\n```\n\n- `filter`\n\n  Every callback must provide a filter, which is a regular expression. The registered callback will be skipped when the path doesn't match this filter. You can read more about filters [here](#filters).\n\n- `namespace`\n\n  This is optional. If provided, the callback is only run on paths within modules in the provided namespace. You can read more about namespaces [here](#namespaces).\n\n### On-resolve arguments\n\nWhen esbuild calls the callback registered by `onResolve`, it will provide these arguments with information about the imported path:\n\n``` javascript\ninterface OnResolveArgs {\n  path: string;\n  importer: string;\n  namespace: string;\n  resolveDir: string;\n  kind: ResolveKind;\n  pluginData: any;\n  with: Record<string, string>;\n}\n\ntype ResolveKind =\n  | 'entry-point'\n  | 'import-statement'\n  | 'require-call'\n  | 'dynamic-import'\n  | 'require-resolve'\n  | 'import-rule'\n  | 'composes-from'\n  | 'url-token'\n```\n\n``` go\ntype OnResolveArgs struct {\n  Path       string\n  Importer   string\n  Namespace  string\n  ResolveDir string\n  Kind       ResolveKind\n  PluginData interface{}\n  With       map[string]string\n}\n\nconst (\n  ResolveEntryPoint        ResolveKind\n  ResolveJSImportStatement ResolveKind\n  ResolveJSRequireCall     ResolveKind\n  ResolveJSDynamicImport   ResolveKind\n  ResolveJSRequireResolve  ResolveKind\n  ResolveCSSImportRule     ResolveKind\n  ResolveCSSComposesFrom   ResolveKind\n  ResolveCSSURLToken       ResolveKind\n)\n```\n\n- `path`\n\n  This is the verbatim unresolved path from the underlying module's source code. It can take any form. While esbuild's default behavior is to interpret import paths as either a relative path or a package name, plugins can be used to introduce new path forms. For example, the sample [HTTP plugin](#http-plugin) below gives special meaning to paths starting with `http://`.\n\n- `importer`\n\n  This is the path of the module containing this import to be resolved. Note that this path is only guaranteed to be a file system path if the namespace is `file`. If you want to resolve a path relative to the directory containing the importer module, you should use `resolveDir` instead since that also works for virtual modules.\n\n- `namespace`\n\n  This is the namespace of the module containing this import to be resolved, as set by the [on-load callback](#on-load) that loaded this file. This defaults to the `file` namespace for modules loaded with esbuild's default behavior. You can read more about namespaces [here](#namespaces).\n\n- `resolveDir`\n\n  This is the file system directory to use when resolving an import path to a real path on the file system. For modules in the `file` namespace, this value defaults to the directory part of the module path. For virtual modules this value defaults to empty but [on-load callbacks](#on-load) can optionally give virtual modules a resolve directory too. If that happens, it will be provided to resolve callbacks for unresolved paths in that file.\n\n- `kind`\n\n  This says how the path to be resolved is being imported. For example, `'entry-point'` means the path was provided to the API as an entry point path, `'import-statement'` means the path is from a JavaScript `import` or `export` statement, and `'import-rule'` means the path is from a CSS `@import` rule.\n\n- `pluginData`\n\n  This property is passed from the previous plugin, as set by the [on-load callback](#on-load) that loaded this file.\n\n- `with`\n\n  This contains a map of the [import attributes](https://github.com/tc39/proposal-import-attributes) that were present on the import statement used to import this module. For example, a module imported using `with { type: 'json' }` will provide a `with` value of `{ type: 'json' }` to plugins. You can use this to resolve to a different path depending on the import attributes.\n\n### On-resolve results\n\nThis is the object that can be returned by a callback added using `onResolve` to provide a custom path resolution. If you would like to return from the callback without providing a path, just return the default value (so `undefined` in JavaScript and `OnResolveResult{}` in Go). Here are the optional properties that can be returned:\n\n``` javascript\ninterface OnResolveResult {\n  errors?: Message[];\n  external?: boolean;\n  namespace?: string;\n  path?: string;\n  pluginData?: any;\n  pluginName?: string;\n  sideEffects?: boolean;\n  suffix?: string;\n  warnings?: Message[];\n  watchDirs?: string[];\n  watchFiles?: string[];\n}\n\ninterface Message {\n  text: string;\n  location: Location | null;\n  detail: any; // The original error from a JavaScript plugin, if applicable\n}\n\ninterface Location {\n  file: string;\n  namespace: string;\n  line: number; // 1-based\n  column: number; // 0-based, in bytes\n  length: number; // in bytes\n  lineText: string;\n}\n```\n\n``` go\ntype OnResolveResult struct {\n  Errors      []Message\n  External    bool\n  Namespace   string\n  Path        string\n  PluginData  interface{}\n  PluginName  string\n  SideEffects SideEffects\n  Suffix      string\n  Warnings    []Message\n  WatchDirs   []string\n  WatchFiles  []string\n}\n\ntype Message struct {\n  Text     string\n  Location *Location\n  Detail   interface{} // The original error from a Go plugin, if applicable\n}\n\ntype Location struct {\n  File      string\n  Namespace string\n  Line      int // 1-based\n  Column    int // 0-based, in bytes\n  Length    int // in bytes\n  LineText  string\n}\n```\n\n- `path`\n\n  Set this to a non-empty string to resolve the import to a specific path. If this is set, no more on-resolve callbacks will be run for this import path in this module. If this is not set, esbuild will continue to run on-resolve callbacks that were registered after the current one. Then, if the path still isn't resolved, esbuild will default to resolving the path relative to the resolve directory of the current module.\n\n- `external`\n\n  Set this to `true` to mark the module as [external](../api/index#external), which means it will not be included in the bundle and will instead be imported at run-time.\n\n- `namespace`\n\n  This is the namespace associated with the resolved path. If left empty, it will default to the `file` namespace for non-external paths. Paths in the file namespace must be an absolute path for the current file system (so starting with a forward slash on Unix and with a drive letter on Windows).\n\n  If you want to resolve to a path that isn't a file system path, you should set the namespace to something other than `file` or an empty string. This tells esbuild to not treat the path as pointing to something on the file system.\n\n- `errors` and `warnings`\n\n  These properties let you pass any log messages generated during path resolution to esbuild where they will be displayed in the terminal according to the current [log level](../api/index#log-level) and end up in the final build result. For example, if you are calling a library and that library can return errors and/or warnings, you will want to forward them using these properties.\n\n  If you only have a single error to return, you don't have to pass it via `errors`. You can simply throw the error in JavaScript or return the `error` object as the second return value in Go.\n\n- `watchFiles` and `watchDirs`\n\n  These properties let you return additional file system paths for esbuild's [watch mode](../api/index#watch) to scan. By default esbuild will only scan the path provided to `onLoad` plugins, and only if the namespace is `file`. If your plugin needs to react to additional changes in the file system, it needs to use one of these properties.\n\n  A rebuild will be triggered if any file in the `watchFiles` array has been changed since the last build. Change detection is somewhat complicated and may check the file contents and/or the file's metadata.\n\n  A rebuild will also be triggered if the list of directory entries for any directory in the `watchDirs` array has been changed since the last build. Note that this does not check anything about the contents of any file in these directories, and it also does not check any subdirectories. Think of this as checking the output of the Unix `ls` command.\n\n  For robustness, you should include all file system paths that were used during the evaluation of the plugin. For example, if your plugin does something equivalent to `require.resolve()`, you'll need to include the paths of all \"does this file exist\" checks, not just the final path. Otherwise a new file could be created that causes the build to become outdated, but esbuild doesn't detect it because that path wasn't listed.\n\n- `pluginName`\n\n  This property lets you replace this plugin's name with another name for this path resolution operation. It's useful for proxying another plugin through this plugin. For example, it lets you have a single plugin that forwards to a child process containing multiple plugins. You probably won't need to use this.\n\n- `pluginData`\n\n  This property will be passed to the next plugin that runs in the plugin chain. If you return it from an `onLoad` plugin, it will be passed to the `onResolve` plugins for any imports in that file, and if you return it from an `onResolve` plugin, an arbitrary one will be passed to the `onLoad` plugin when it loads the file (it's arbitrary since the relationship is many-to-one). This is useful to pass data between different plugins without them having to coordinate directly.\n\n- `sideEffects`\n\n  Setting this property to false tells esbuild that imports of this module can be removed if the imported names are unused. This behaves as if `\"sideEffects\": false` was specified the corresponding `package.json` file. For example, `import { x } from \"y\"` may be completely removed if `x` is unused and `y` has been marked as `sideEffects: false`. You can read more about what `sideEffects` means in [Webpack's documentation about the feature](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free).\n\n- `suffix`\n\n  Returning a value here lets you pass along an optional URL query or hash to append to the path that is not included in the path itself. Storing this separately is beneficial in cases when the path is processed by something that is not aware of the suffix, either by esbuild itself or by another plugin.\n\n  For example, an on-resolve plugin might return a suffix of `?#iefix` for a `.eot` file in a build with a different on-load plugin for paths ending in `.eot`. Keeping the suffix separate means the suffix is still associated with the path but the `.eot` plugin will still match the file without needing to know anything about suffixes.\n\n  If you do set a suffix, it must begin with either `?` or `#` because it's intended to be a URL query or hash. This feature has certain obscure uses such as hacking around bugs in IE8's CSS parser and may not be that useful otherwise. If you do use it, keep in mind that each unique namespace, path, and suffix combination is considered by esbuild to be a unique module identifier so by returning a different suffix for the same path, you are telling esbuild to create another copy of the module.\n\n## On-load callbacks\n\nA callback added using `onLoad` will be run for each unique path/namespace pair that has not been marked as external. Its job is to return the contents of the module and to tell esbuild how to interpret it. Here's an example plugin that converts `.txt` files into an array of words:\n\n``` javascript\nimport * as esbuild from 'esbuild'\nimport fs from 'node:fs'\n\nlet exampleOnLoadPlugin = {\n  name: 'example',\n  setup(build) {\n    // Load \".txt\" files and return an array of words\n    build.onLoad({ filter: /\\.txt$/ }, async (args) => {\n      let text = await fs.promises.readFile(args.path, 'utf8')\n      return {\n        contents: JSON.stringify(text.split(/\\s+/)),\n        loader: 'json',\n      }\n    })\n  },\n}\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  outfile: 'out.js',\n  plugins: [exampleOnLoadPlugin],\n})\n```\n\n``` go\npackage main\n\nimport \"encoding/json\"\nimport \"io/ioutil\"\nimport \"os\"\nimport \"strings\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nvar exampleOnLoadPlugin = api.Plugin{\n  Name: \"example\",\n  Setup: func(build api.PluginBuild) {\n    // Load \".txt\" files and return an array of words\n    build.OnLoad(api.OnLoadOptions{Filter: `\\.txt$`},\n      func(args api.OnLoadArgs) (api.OnLoadResult, error) {\n        text, err := ioutil.ReadFile(args.Path)\n        if err != nil {\n          return api.OnLoadResult{}, err\n        }\n        bytes, err := json.Marshal(strings.Fields(string(text)))\n        if err != nil {\n          return api.OnLoadResult{}, err\n        }\n        contents := string(bytes)\n        return api.OnLoadResult{\n          Contents: &contents,\n          Loader:   api.LoaderJSON,\n        }, nil\n      })\n  },\n}\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Outfile:     \"out.js\",\n    Plugins:     []api.Plugin{exampleOnLoadPlugin},\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThe callback can return without providing the contents of the module. In that case the responsibility for loading the module is passed to the next registered callback. For a given module, all `onLoad` callbacks from all plugins will be run in the order they were registered until one takes responsibility for loading the module. If no callback returns contents for the module, esbuild will run its default module loading logic.\n\nKeep in mind that many callbacks may be running concurrently. In JavaScript, if your callback does expensive work that can run on another thread such as `fs.readFileSync()`, you should make the callback `async` and use `await` (in this case with `fs.promises.readFile()`) to allow other code to run in the meantime. In Go, each callback may be run on a separate goroutine. Make sure you have appropriate synchronization in place if your plugin uses any shared data structures.\n\n### On-load options\n\nThe `onLoad` API is meant to be called within the `setup` function and registers a callback to be triggered in certain situations. It takes a few options:\n\n``` javascript\ninterface OnLoadOptions {\n  filter: RegExp;\n  namespace?: string;\n}\n```\n\n``` go\ntype OnLoadOptions struct {\n  Filter    string\n  Namespace string\n}\n```\n\n- `filter`\n\n  Every callback must provide a filter, which is a regular expression. The registered callback will be skipped when the path doesn't match this filter. You can read more about filters [here](#filters).\n\n- `namespace`\n\n  This is optional. If provided, the callback is only run on paths within modules in the provided namespace. You can read more about namespaces [here](#namespaces).\n\n### On-load arguments\n\nWhen esbuild calls the callback registered by `onLoad`, it will provide these arguments with information about the module to load:\n\n``` javascript\ninterface OnLoadArgs {\n  path: string;\n  namespace: string;\n  suffix: string;\n  pluginData: any;\n  with: Record<string, string>;\n}\n```\n\n``` go\ntype OnLoadArgs struct {\n  Path       string\n  Namespace  string\n  Suffix     string\n  PluginData interface{}\n  With       map[string]string\n}\n```\n\n- `path`\n\n  This is the fully-resolved path to the module. It should be considered a file system path if the namespace is `file`, but otherwise the path can take any form. For example, the sample [HTTP plugin](#http-plugin) below gives special meaning to paths starting with `http://`.\n\n- `namespace`\n\n  This is the namespace that the module path is in, as set by the [on-resolve callback](#on-resolve) that resolved this file. It defaults to the `file` namespace for modules loaded with esbuild's default behavior. You can read more about namespaces [here](#namespaces).\n\n- `suffix`\n\n  This is the URL query and/or hash at the end of the file path, if there is one. It's either filled in by esbuild's native path resolution behavior or returned by the [on-resolve callback](#on-resolve) that resolved this file. This is stored separately from the path so that most plugins can just deal with the path and ignore the suffix. The on-load behavior that's built into esbuild just ignores the suffix and loads the file from its path alone.\n\n  For context, IE8's CSS parser has a bug where it considers certain URLs to extend to the last `)` instead of the first `)`. So the CSS code `url('Foo.eot') format('eot')` is incorrectly considered to have a URL of `Foo.eot') format('eot`. To avoid this, people typically add something like `?#iefix` so that IE8 sees the URL as `Foo.eot?#iefix') format('eot`. Then the path part of the URL is `Foo.eot` and the query part is `?#iefix') format('eot`, which means IE8 can find the file `Foo.eot` by discarding the query.\n\n  The suffix feature was added to esbuild to handle CSS files containing these hacks. A URL of `Foo.eot?#iefix` should be considered [external](../api/index#external) if all files matching `*.eot` have been marked as external, but the `?#iefix` suffix should still be present in the final output file.\n\n- `pluginData`\n\n  This property is passed from the previous plugin, as set by the [on-resolve callback](#on-resolve) that runs in the plugin chain.\n\n- `with`\n\n  This contains a map of the [import attributes](https://github.com/tc39/proposal-import-attributes) that were present on the import statement used to import this module. For example, a module imported using `with { type: 'json' }` will provide a `with` value of `{ type: 'json' }` to plugins. A given module is loaded separately for each unique combination of import attributes, so these attributes are guaranteed to have been provided by all import statements used to import this module. That means they can be used by the plugin to alter the content of this module.\n\n### On-load results\n\nThis is the object that can be returned by a callback added using `onLoad` to provide the contents of a module. If you would like to return from the callback without providing any contents, just return the default value (so `undefined` in JavaScript and `OnLoadResult{}` in Go). Here are the optional properties that can be returned:\n\n``` javascript\ninterface OnLoadResult {\n  contents?: string | Uint8Array;\n  errors?: Message[];\n  loader?: Loader;\n  pluginData?: any;\n  pluginName?: string;\n  resolveDir?: string;\n  warnings?: Message[];\n  watchDirs?: string[];\n  watchFiles?: string[];\n}\n\ninterface Message {\n  text: string;\n  location: Location | null;\n  detail: any; // The original error from a JavaScript plugin, if applicable\n}\n\ninterface Location {\n  file: string;\n  namespace: string;\n  line: number; // 1-based\n  column: number; // 0-based, in bytes\n  length: number; // in bytes\n  lineText: string;\n}\n```\n\n``` go\ntype OnLoadResult struct {\n  Contents   *string\n  Errors     []Message\n  Loader     Loader\n  PluginData interface{}\n  PluginName string\n  ResolveDir string\n  Warnings   []Message\n  WatchDirs  []string\n  WatchFiles []string\n}\n\ntype Message struct {\n  Text     string\n  Location *Location\n  Detail   interface{} // The original error from a Go plugin, if applicable\n}\n\ntype Location struct {\n  File      string\n  Namespace string\n  Line      int // 1-based\n  Column    int // 0-based, in bytes\n  Length    int // in bytes\n  LineText  string\n}\n```\n\n- `contents`\n\n  Set this to a string to specify the contents of the module. If this is set, no more on-load callbacks will be run for this resolved path. If this is not set, esbuild will continue to run on-load callbacks that were registered after the current one. Then, if the contents are still not set, esbuild will default to loading the contents from the file system if the resolved path is in the `file` namespace.\n\n- `loader`\n\n  This tells esbuild how to interpret the contents. For example, the [`js`](../content-types/index#javascript) loader interprets the contents as JavaScript and the [`css`](../content-types/index#css) loader interprets the contents as CSS. The loader defaults to `js` if it's not specified. See the [content types](../content-types/index) page for a complete list of all built-in loaders.\n\n- `resolveDir`\n\n  This is the file system directory to use when resolving an import path in this module to a real path on the file system. For modules in the `file` namespace, this value defaults to the directory part of the module path. Otherwise this value defaults to empty unless the plugin provides one. If the plugin doesn't provide one, esbuild's default behavior won't resolve any imports in this module. This directory will be passed to any [on-resolve callbacks](#on-resolve) that run on unresolved import paths in this module.\n\n- `errors` and `warnings`\n\n  These properties let you pass any log messages generated during path resolution to esbuild where they will be displayed in the terminal according to the current [log level](../api/index#log-level) and end up in the final build result. For example, if you are calling a library and that library can return errors and/or warnings, you will want to forward them using these properties.\n\n  If you only have a single error to return, you don't have to pass it via `errors`. You can simply throw the error in JavaScript or return the `error` object as the second return value in Go.\n\n- `watchFiles` and `watchDirs`\n\n  These properties let you return additional file system paths for esbuild's [watch mode](../api/index#watch) to scan. By default esbuild will only scan the path provided to `onLoad` plugins, and only if the namespace is `file`. If your plugin needs to react to additional changes in the file system, it needs to use one of these properties.\n\n  A rebuild will be triggered if any file in the `watchFiles` array has been changed since the last build. Change detection is somewhat complicated and may check the file contents and/or the file's metadata.\n\n  A rebuild will also be triggered if the list of directory entries for any directory in the `watchDirs` array has been changed since the last build. Note that this does not check anything about the contents of any file in these directories, and it also does not check any subdirectories. Think of this as checking the output of the Unix `ls` command.\n\n  For robustness, you should include all file system paths that were used during the evaluation of the plugin. For example, if your plugin does something equivalent to `require.resolve()`, you'll need to include the paths of all \"does this file exist\" checks, not just the final path. Otherwise a new file could be created that causes the build to become outdated, but esbuild doesn't detect it because that path wasn't listed.\n\n- `pluginName`\n\n  This property lets you replace this plugin's name with another name for this module load operation. It's useful for proxying another plugin through this plugin. For example, it lets you have a single plugin that forwards to a child process containing multiple plugins. You probably won't need to use this.\n\n- `pluginData`\n\n  This property will be passed to the next plugin that runs in the plugin chain. If you return it from an `onLoad` plugin, it will be passed to the `onResolve` plugins for any imports in that file, and if you return it from an `onResolve` plugin, an arbitrary one will be passed to the `onLoad` plugin when it loads the file (it's arbitrary since the relationship is many-to-one). This is useful to pass data between different plugins without them having to coordinate directly.\n\n### Caching your plugin\n\nSince esbuild is so fast, it's often the case that plugin evaluation is the main bottleneck when building with esbuild. Caching of plugin evaluation is left up to each plugin instead of being a part of esbuild itself because cache invalidation is plugin-specific. If you are writing a slow plugin that needs a cache to be fast, you will have to write the cache logic yourself.\n\nA cache is essentially a map that memoizes the transform function that represents your plugin. The keys of the map usually contain the inputs to your transform function and the values of the map usually contain the outputs of your transform function. In addition, the map usually has some form of least-recently-used cache eviction policy to avoid continually growing larger in size over time.\n\nThe cache can either be stored in memory (beneficial for use with esbuild's [rebuild](../api/index#rebuild) API), on disk (beneficial for caching across separate build script invocations), or even on a server (beneficial for really slow transforms that can be shared between different developer machines). Where to store the cache is case-specific and depends on your plugin.\n\nHere is a simple caching example. Say we want to cache the function `slowTransform()` that takes as input the contents of a file in the `*.example` format and transforms it to JavaScript. An in-memory cache that avoids redundant calls to this function when used with esbuild's [rebuild](../api/index#rebuild) API) might look something like this:\n\n``` javascript\nimport fs from 'node:fs'\n\nlet examplePlugin = {\n  name: 'example',\n  setup(build) {\n    let cache = new Map\n\n    build.onLoad({ filter: /\\.example$/ }, async (args) => {\n      let input = await fs.promises.readFile(args.path, 'utf8')\n      let key = args.path\n      let value = cache.get(key)\n\n      if (!value || value.input !== input) {\n        let contents = slowTransform(input)\n        value = { input, output: { contents } }\n        cache.set(key, value)\n      }\n\n      return value.output\n    })\n  }\n}\n```\n\nSome important caveats about the caching code above:\n\n- There is no cache eviction policy present in the code above. Memory usage will continue to grow if more and more keys are added to the cache map.\n\n  To combat this limitation somewhat, the `input` value is stored in the cache `value` instead of in the cache `key`. This means that changing the contents of a file will not leak memory because the key only includes the file path, not the file contents. Changing the file contents only overwrites the previous cache entry. This is probably fine for common usage where someone repeatedly edits the same file in between incremental rebuilds and only occasionally adds or renames files. But the cache will continue to grow in size if each build contains new unique path names (e.g. perhaps an auto-generated temporary file path containing the current time). A more advanced version might use a least-recently-used eviction policy.\n\n- Cache invalidation only works if `slowTransform()` is a [pure function](https://en.wikipedia.org/wiki/Pure_function) (meaning that the output of the function *only* depends on the inputs to the function) and if all of the inputs to the function are somehow captured in the lookup to the cache map. For example if the transform function automatically reads the contents of some other files and the output depends on the contents of those files too, then the cache would fail to be invalidated when those files are changed because they are not included in the cache key.\n\n  This part is easy to mess up so it's worth going through a specific example. Consider a plugin that implements a compile-to-CSS language. If that plugin implements `@import` rules itself by parsing imported files and either bundles them or makes any exported variable declarations available to the importing code, your plugin will not be correct if it only checks that the importing file's contents haven't changed because a change to the imported file could also invalidate the cache.\n\n  You may be thinking that you could just add the contents of the imported file to the cache key to fix this problem. However, even that may be incorrect. Say for example this plugin uses [`require.resolve()`](https://nodejs.org/api/modules.html#modules_require_resolve_request_options) to resolve the import path to an absolute file path. This is a common approach because it uses node's built-in path resolution that can resolve to a path inside a package. This function usually does many checks for files in different locations before returning the resolved path. For example, importing the path `pkg/file` from the file `src/entry.css` might check the following locations (yes, node's package resolution algorithm is very inefficient):\n\n  ``` javascript\n  src/node_modules/pkg/file\n  src/node_modules/pkg/file.css\n  src/node_modules/pkg/file/package.json\n  src/node_modules/pkg/file/main\n  src/node_modules/pkg/file/main.css\n  src/node_modules/pkg/file/main/index.css\n  src/node_modules/pkg/file/index.css\n  node_modules/pkg/file\n  node_modules/pkg/file.css\n  node_modules/pkg/file/package.json\n  node_modules/pkg/file/main\n  node_modules/pkg/file/main.css\n  node_modules/pkg/file/main/index.css\n  node_modules/pkg/file/index.css\n  ```\n\n  Say the import `pkg/file` was ultimately resolved to the absolute path `node_modules/pkg/file/index.css`. Even if you cache the contents of both the importing file and the imported file and verify that the contents of both files are still the same before reusing the cache entry, the cache entry could still be stale if one of the other files that `require.resolve()` checks for has either been created or deleted since the cache entry was added. Caching this correctly essentially involves always re-running all such path resolutions even when none of the input files have been changed and verifying that none of the path resolutions have changed either.\n\n- These cache keys are only correct for an in-memory cache. It would be incorrect to implement a file system cache using the same cache keys. While an in-memory cache is guaranteed to always run the same code for every build because the code is also stored in memory, a file system cache could potentially be accessed by two separate builds that each contain different code. Specifically the code for the `slowTransform()` function may have been changed in between builds.\n\n  This can happen in various cases. The package containing the function `slowTransform()` may have been updated, or one of its transitive dependencies may have been updated even if you have pinned the package's version due to how npm handles semver, or someone may have [mutated the package contents](https://www.npmjs.com/package/patch-package) on the file system in the meantime, or the transform function may be calling a node API and different builds could be running on different node versions.\n\n  If you want to store your cache on the file system, you should guard against changes to the code for the transform function by storing some representation of the code for the transform function in the cache key. This is usually some form of [hash](https://nodejs.org/api/crypto.html#crypto_class_hash) that contains the contents of all relevant files in all relevant packages as well as potentially other details such as which node version you are currently running on. Getting all of this to be correct is non-trivial.\n\n## On-start callbacks\n\nRegister an on-start callback to be notified when a new build starts. This triggers for all builds, not just the initial build, so it's especially useful for [rebuilds](../api/index#rebuild), [watch mode](../api/index#watch), and [serve mode](../api/index#serve). Here's how to add an on-start callback:\n\n``` javascript\nlet examplePlugin = {\n  name: 'example',\n  setup(build) {\n    build.onStart(() => {\n      console.log('build started')\n    })\n  },\n}\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nvar examplePlugin = api.Plugin{\n  Name: \"example\",\n  Setup: func(build api.PluginBuild) {\n    build.OnStart(func() (api.OnStartResult, error) {\n      fmt.Fprintf(os.Stderr, \"build started\\n\")\n      return api.OnStartResult{}, nil\n    })\n  },\n}\n\nfunc main() {\n}\n```\n\nYou should not use an on-start callback for initialization since it can be run multiple times. If you want to initialize something, just put your plugin initialization code directly inside the `setup` function instead.\n\nThe on-start callback can be `async` and can return a promise. All on-start callbacks from all plugins are run concurrently, and then the build waits for all on-start callbacks to finish before proceeding. On-start callbacks can optionally return errors and/or warnings to be included with the build.\n\nNote that on-start callbacks do not have the ability to mutate the [build options](#build-options). The initial build options can only be modified within the `setup` function and are consumed once `setup` returns. All builds after the first one reuse the same initial options so the initial options are never re-consumed, and modifications to `build.initialOptions` that are done within the start callback are ignored.\n\n## On-end callbacks\n\nRegister an on-end callback to be notified when a new build ends. This triggers for all builds, not just the initial build, so it's especially useful for [rebuilds](../api/index#rebuild), [watch mode](../api/index#watch), and [serve mode](../api/index#serve). Here's how to add an on-end callback:\n\n``` javascript\nlet examplePlugin = {\n  name: 'example',\n  setup(build) {\n    build.onEnd(result => {\n      console.log(`build ended with ${result.errors.length} errors`)\n    })\n  },\n}\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nvar examplePlugin = api.Plugin{\n  Name: \"example\",\n  Setup: func(build api.PluginBuild) {\n    build.OnEnd(func(result *api.BuildResult) (api.OnEndResult, error) {\n      fmt.Fprintf(os.Stderr, \"build ended with %d errors\\n\", len(result.Errors))\n      return api.OnEndResult{}, nil\n    })\n  },\n}\n\nfunc main() {\n}\n```\n\nAll on-end callbacks are run in serial and each callback is given access to the final build result. It can modify the build result before returning and can delay the end of the build by returning a promise. If you want to be able to inspect the build graph, you should enable the [metafile](../api/index#metafile) setting on the [initial options](#build-options) and the build graph will be returned as the `metafile` property on the build result object.\n\n## On-dispose callbacks\n\nRegister an on-dispose callback to perform cleanup when the plugin is no longer used. It will be called after every `build()` call regardless of whether the build failed or not, as well as after the first `dispose()` call on a given build context. Here's how to add an on-dispose callback:\n\n``` javascript\nlet examplePlugin = {\n  name: 'example',\n  setup(build) {\n    build.onDispose(() => {\n      console.log('This plugin is no longer used')\n    })\n  },\n}\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nvar examplePlugin = api.Plugin{\n  Name: \"example\",\n  Setup: func(build api.PluginBuild) {\n    build.OnDispose(func() {\n      fmt.Println(\"This plugin is no longer used\")\n    })\n  },\n}\n\nfunc main() {\n}\n```\n\n## Accessing build options\n\nPlugins can access the initial build options from within the `setup` method. This lets you inspect how the build is configured as well as modify the build options before the build starts. Here is an example:\n\n``` javascript\nlet examplePlugin = {\n  name: 'auto-node-env',\n  setup(build) {\n    const options = build.initialOptions\n    options.define = options.define || {}\n    options.define['process.env.NODE_ENV'] =\n      options.minify ? '\"production\"' : '\"development\"'\n  },\n}\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nvar examplePlugin = api.Plugin{\n  Name: \"auto-node-env\",\n  Setup: func(build api.PluginBuild) {\n    options := build.InitialOptions\n    if options.Define == nil {\n      options.Define = map[string]string{}\n    }\n    if options.MinifyWhitespace && options.MinifyIdentifiers && options.MinifySyntax {\n      options.Define[`process.env.NODE_ENV`] = `\"production\"`\n    } else {\n      options.Define[`process.env.NODE_ENV`] = `\"development\"`\n    }\n  },\n}\n\nfunc main() {\n}\n```\n\nNote that modifications to the build options after the build starts do not affect the build. In particular, [rebuilds](../api/index#rebuild), [watch mode](../api/index#watch), and [serve mode](../api/index#serve) do not update their build options if plugins mutate the build options object after the first build has started.\n\n## Resolving paths\n\nWhen a plugin returns a result from an [on-resolve callback](#on-resolve), the result completely replaces esbuild's built-in path resolution. This gives the plugin complete control over how path resolution works, but it means that the plugin may have to reimplement some of the behavior that esbuild already has built-in if it wants to have similar behavior. For example, a plugin may want to search for a package in the user's `node_modules` directory, which is something esbuild already implements.\n\nInstead of reimplementing esbuild's built-in behavior, plugins have the option of running esbuild's path resolution manually and inspecting the result. This lets you adjust the inputs and/or the outputs of esbuild's path resolution. Here's an example:\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet examplePlugin = {\n  name: 'example',\n  setup(build) {\n    build.onResolve({ filter: /^example$/ }, async () => {\n      const result = await build.resolve('./foo', {\n        kind: 'import-statement',\n        resolveDir: './bar',\n      })\n      if (result.errors.length > 0) {\n        return { errors: result.errors }\n      }\n      return { path: result.path, external: true }\n    })\n  },\n}\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  outfile: 'out.js',\n  plugins: [examplePlugin],\n})\n```\n\n``` go\npackage main\n\nimport \"os\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nvar examplePlugin = api.Plugin{\n  Name: \"example\",\n  Setup: func(build api.PluginBuild) {\n    build.OnResolve(api.OnResolveOptions{Filter: `^example$`},\n      func(api.OnResolveArgs) (api.OnResolveResult, error) {\n        result := build.Resolve(\"./foo\", api.ResolveOptions{\n          Kind:       api.ResolveJSImportStatement,\n          ResolveDir: \"./bar\",\n        })\n        if len(result.Errors) > 0 {\n          return api.OnResolveResult{Errors: result.Errors}, nil\n        }\n        return api.OnResolveResult{Path: result.Path, External: true}, nil\n      })\n  },\n}\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Outfile:     \"out.js\",\n    Plugins:     []api.Plugin{examplePlugin},\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThis plugin intercepts imports to the path `example`, tells esbuild to resolve the import `./foo` in the directory `./bar`, forces whatever path esbuild returns to be considered external, and maps the import for `example` to that external path.\n\nHere are some additional things to know about this API:\n\n- If you don't pass the optional `resolveDir` parameter, esbuild will still run `onResolve` plugin callbacks but will not attempt any path resolution itself. All of esbuild's path resolution logic depends on the `resolveDir` parameter including looking for packages in `node_modules` directories (since it needs to know where those `node_modules` directories might be).\n\n- If you want to resolve a file name in a specific directory, make sure the input path starts with `./`. Otherwise the input path will be treated as a package path instead of a relative path. This behavior is identical to esbuild's normal path resolution logic.\n\n- If path resolution fails, the `errors` property on the returned object will be a non-empty array containing the error information. This function does not always throw an error when it fails. You need to check for errors after calling it.\n\n- The behavior of this function depends on the build configuration. That's why it's a property of the `build` object instead of being a top-level API call. This also means you can't call it until all plugin `setup` functions have finished since these give plugins the opportunity to adjust the build configuration before it's frozen at the start of the build. So the `resolve` function is going to be most useful inside your `onResolve` and/or `onLoad` callbacks.\n\n- There is currently no attempt made to detect infinite path resolution loops. Calling `resolve` from within `onResolve` with the same parameters is almost certainly a bad idea.\n\n### Resolve options\n\nThe `resolve` function takes the path to resolve as the first argument and an object with optional properties as the second argument. This options object is very similar to the [arguments that are passed to `onResolve`](#on-resolve-arguments). Here are the available options:\n\n``` javascript\ninterface ResolveOptions {\n  kind: ResolveKind;\n  importer?: string;\n  namespace?: string;\n  resolveDir?: string;\n  pluginData?: any;\n  with?: Record<string, string>;\n}\n\ntype ResolveKind =\n  | 'entry-point'\n  | 'import-statement'\n  | 'require-call'\n  | 'dynamic-import'\n  | 'require-resolve'\n  | 'import-rule'\n  | 'url-token'\n```\n\n``` go\ntype ResolveOptions struct {\n  Kind       ResolveKind\n  Importer   string\n  Namespace  string\n  ResolveDir string\n  PluginData interface{}\n  With       map[string]string\n}\n\nconst (\n  ResolveEntryPoint        ResolveKind\n  ResolveJSImportStatement ResolveKind\n  ResolveJSRequireCall     ResolveKind\n  ResolveJSDynamicImport   ResolveKind\n  ResolveJSRequireResolve  ResolveKind\n  ResolveCSSImportRule     ResolveKind\n  ResolveCSSURLToken       ResolveKind\n)\n```\n\n- `kind`\n\n  This tells esbuild how the path was imported, which can affect path resolution. For example, [node's path resolution rules](https://nodejs.org/api/packages.html#conditional-exports) say that paths imported using `'require-call'` should respect [conditional package imports](../api/index#conditions) in the `\"require\"` section in `package.json` while paths imported using `'import-statement'` should respect conditional package imports in the `\"import\"` section instead.\n\n- `importer`\n\n  If set, this is interpreted as the path of the module containing this import to be resolved. This affects plugins with `onResolve` callbacks that check the `importer` value.\n\n- `namespace`\n\n  If set, this is interpreted as the namespace of the module containing this import to be resolved. This affects plugins with `onResolve` callbacks that check the `namespace` value. You can read more about namespaces [here](#namespaces).\n\n- `resolveDir`\n\n  This is the file system directory to use when resolving an import path to a real path on the file system. This must be set for esbuild's built-in path resolution to be able to find a given file, even for non-relative package paths (since esbuild needs to know where the `node_modules` directory is).\n\n- `pluginData`\n\n  This property can be used to pass custom data to whatever [on-resolve callbacks](#on-resolve) match this import path. The meaning of this data is left entirely up to you.\n\n- `with`\n\n  This is the [import attributes](https://github.com/tc39/proposal-import-attributes) assocated with the import statement for this path. For example, a `with` value of `{ type: 'json' }` would be appropriate for a module imported using `with { type: 'json' }` attributes on the import statement. This information isn't used by esbuild but may be used by [on-resolve callbacks](#on-resolve).\n\n### Resolve results\n\nThe `resolve` function returns an object that's very similar to what plugins can [return from an `onResolve` callback](#on-resolve-results). It has the following properties:\n\n``` javascript\nexport interface ResolveResult {\n  errors: Message[];\n  external: boolean;\n  namespace: string;\n  path: string;\n  pluginData: any;\n  sideEffects: boolean;\n  suffix: string;\n  warnings: Message[];\n}\n\ninterface Message {\n  text: string;\n  location: Location | null;\n  detail: any; // The original error from a JavaScript plugin, if applicable\n}\n\ninterface Location {\n  file: string;\n  namespace: string;\n  line: number; // 1-based\n  column: number; // 0-based, in bytes\n  length: number; // in bytes\n  lineText: string;\n}\n```\n\n``` go\ntype ResolveResult struct {\n  Errors      []Message\n  External    bool\n  Namespace   string\n  Path        string\n  PluginData  interface{}\n  SideEffects bool\n  Suffix      string\n  Warnings    []Message\n}\n\ntype Message struct {\n  Text     string\n  Location *Location\n  Detail   interface{} // The original error from a Go plugin, if applicable\n}\n\ntype Location struct {\n  File      string\n  Namespace string\n  Line      int // 1-based\n  Column    int // 0-based, in bytes\n  Length    int // in bytes\n  LineText  string\n}\n```\n\n- `path`\n\n  This is the result of path resolution, or an empty string if path resolution failed.\n\n- `external`\n\n  This will be `true` if the path was marked as [external](../api/index#external), which means it will not be included in the bundle and will instead be imported at run-time.\n\n- `namespace`\n\n  This is the namespace associated with the resolved path. You can read more about namespaces [here](#namespaces).\n\n- `errors` and `warnings`\n\n  These properties hold any log messages generated during path resolution, either by any plugins that responded to this path resolution operation or by esbuild itself. These log messages are not automatically included in the log, so they will be completely invisible if you discard them. If you want them to be included in the log, you'll need to return them from either `onResolve` or `onLoad`.\n\n- `pluginData`\n\n  If a plugin responded to this path resolution operation and returned `pluginData` from its `onResolve` callback, that data will end up here. This is useful to pass data between different plugins without them having to coordinate directly.\n\n- `sideEffects`\n\n  This property will be `true` unless the module is somehow annotated as having no side effects, in which case it will be `false`. This will be `false` for packages that have `\"sideEffects\": false` in the corresponding `package.json` file, and also if a plugin responds to this path resolution operation and returns `sideEffects: false`. You can read more about what `sideEffects` means in [Webpack's documentation about the feature](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free).\n\n- `suffix`\n\n  This can contain an optional URL query or hash if there was one at the end of the path to be resolved and if removing it was required for the path to resolve successfully.\n\n## Example plugins\n\nThe example plugins below are meant to give you an idea of the different types of things you can do with the plugin API.\n\n### HTTP plugin\n\n*This example demonstrates: using a path format other than file system paths, namespace-specific path resolution, using resolve and load callbacks together.*\n\nThis plugin allows you to import HTTP URLs into JavaScript code. The code will automatically be downloaded at build time. It enables the following workflow:\n\n``` javascript\nimport { zip } from 'https://unpkg.com/lodash-es@4.17.15/lodash.js'\nconsole.log(zip([1, 2], ['a', 'b']))\n```\n\nThis can be accomplished with the following plugin. Note that for real usage the downloads should be cached, but caching has been omitted from this example for brevity:\n\n``` javascript\nimport * as esbuild from 'esbuild'\nimport https from 'node:https'\nimport http from 'node:http'\n\nlet httpPlugin = {\n  name: 'http',\n  setup(build) {\n    // Intercept import paths starting with \"http:\" and \"https:\" so\n    // esbuild doesn't attempt to map them to a file system location.\n    // Tag them with the \"http-url\" namespace to associate them with\n    // this plugin.\n    build.onResolve({ filter: /^https?:\\/\\// }, args => ({\n      path: args.path,\n      namespace: 'http-url',\n    }))\n\n    // We also want to intercept all import paths inside downloaded\n    // files and resolve them against the original URL. All of these\n    // files will be in the \"http-url\" namespace. Make sure to keep\n    // the newly resolved URL in the \"http-url\" namespace so imports\n    // inside it will also be resolved as URLs recursively.\n    build.onResolve({ filter: /.*/, namespace: 'http-url' }, args => ({\n      path: new URL(args.path, args.importer).toString(),\n      namespace: 'http-url',\n    }))\n\n    // When a URL is loaded, we want to actually download the content\n    // from the internet. This has just enough logic to be able to\n    // handle the example import from unpkg.com but in reality this\n    // would probably need to be more complex.\n    build.onLoad({ filter: /.*/, namespace: 'http-url' }, async (args) => {\n      let contents = await new Promise((resolve, reject) => {\n        function fetch(url) {\n          console.log(`Downloading: ${url}`)\n          let lib = url.startsWith('https') ? https : http\n          let req = lib.get(url, res => {\n            if ([301, 302, 307].includes(res.statusCode)) {\n              fetch(new URL(res.headers.location, url).toString())\n              req.abort()\n            } else if (res.statusCode === 200) {\n              let chunks = []\n              res.on('data', chunk => chunks.push(chunk))\n              res.on('end', () => resolve(Buffer.concat(chunks)))\n            } else {\n              reject(new Error(`GET ${url} failed: status ${res.statusCode}`))\n            }\n          }).on('error', reject)\n        }\n        fetch(args.path)\n      })\n      return { contents }\n    })\n  },\n}\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  outfile: 'out.js',\n  plugins: [httpPlugin],\n})\n```\n\n``` go\npackage main\n\nimport \"io/ioutil\"\nimport \"net/http\"\nimport \"net/url\"\nimport \"os\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nvar httpPlugin = api.Plugin{\n  Name: \"http\",\n  Setup: func(build api.PluginBuild) {\n    // Intercept import paths starting with \"http:\" and \"https:\" so\n    // esbuild doesn't attempt to map them to a file system location.\n    // Tag them with the \"http-url\" namespace to associate them with\n    // this plugin.\n    build.OnResolve(api.OnResolveOptions{Filter: `^https?://`},\n      func(args api.OnResolveArgs) (api.OnResolveResult, error) {\n        return api.OnResolveResult{\n          Path:      args.Path,\n          Namespace: \"http-url\",\n        }, nil\n      })\n\n    // We also want to intercept all import paths inside downloaded\n    // files and resolve them against the original URL. All of these\n    // files will be in the \"http-url\" namespace. Make sure to keep\n    // the newly resolved URL in the \"http-url\" namespace so imports\n    // inside it will also be resolved as URLs recursively.\n    build.OnResolve(api.OnResolveOptions{Filter: \".*\", Namespace: \"http-url\"},\n      func(args api.OnResolveArgs) (api.OnResolveResult, error) {\n        base, err := url.Parse(args.Importer)\n        if err != nil {\n          return api.OnResolveResult{}, err\n        }\n        relative, err := url.Parse(args.Path)\n        if err != nil {\n          return api.OnResolveResult{}, err\n        }\n        return api.OnResolveResult{\n          Path:      base.ResolveReference(relative).String(),\n          Namespace: \"http-url\",\n        }, nil\n      })\n\n    // When a URL is loaded, we want to actually download the content\n    // from the internet. This has just enough logic to be able to\n    // handle the example import from unpkg.com but in reality this\n    // would probably need to be more complex.\n    build.OnLoad(api.OnLoadOptions{Filter: \".*\", Namespace: \"http-url\"},\n      func(args api.OnLoadArgs) (api.OnLoadResult, error) {\n        res, err := http.Get(args.Path)\n        if err != nil {\n          return api.OnLoadResult{}, err\n        }\n        defer res.Body.Close()\n        bytes, err := ioutil.ReadAll(res.Body)\n        if err != nil {\n          return api.OnLoadResult{}, err\n        }\n        contents := string(bytes)\n        return api.OnLoadResult{Contents: &contents}, nil\n      })\n  },\n}\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Outfile:     \"out.js\",\n    Plugins:     []api.Plugin{httpPlugin},\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThe plugin first uses a resolver to move `http://` and `https://` URLs to the `http-url` namespace. Setting the namespace tells esbuild to not treat these paths as file system paths. Then, a loader for the `http-url` namespace downloads the module and returns the contents to esbuild. From there, another resolver for import paths inside modules in the `http-url` namespace picks up relative paths and translates them into full URLs by resolving them against the importing module's URL. That then feeds back into the loader allowing downloaded modules to download additional modules recursively.\n\n### WebAssembly plugin\n\n*This example demonstrates: working with binary data, creating virtual modules using import statements, re-using the same path with different namespaces.*\n\nThis plugin allows you to import `.wasm` files into JavaScript code. It does not generate the WebAssembly files themselves; that can either be done by another tool or by modifying this example plugin to suit your needs. It enables the following workflow:\n\n``` javascript\nimport load from './example.wasm'\nload(imports).then(exports => { ... })\n```\n\nWhen you import a `.wasm` file, this plugin generates a virtual JavaScript module in the `wasm-stub` namespace with a single function that loads the WebAssembly module exported as the default export. That stub module looks something like this:\n\n``` javascript\nimport wasm from '/path/to/example.wasm'\nexport default (imports) =>\n  WebAssembly.instantiate(wasm, imports).then(\n    result => result.instance.exports)\n```\n\nThen that stub module imports the WebAssembly file itself as another module in the `wasm-binary` namespace using esbuild's built-in [binary](../content-types/index#binary) loader. This means importing a `.wasm` file actually generates two virtual modules. Here's the code for the plugin:\n\n``` javascript\nimport * as esbuild from 'esbuild'\nimport path from 'node:path'\nimport fs from 'node:fs'\n\nlet wasmPlugin = {\n  name: 'wasm',\n  setup(build) {\n    // Resolve \".wasm\" files to a path with a namespace\n    build.onResolve({ filter: /\\.wasm$/ }, args => {\n      // If this is the import inside the stub module, import the\n      // binary itself. Put the path in the \"wasm-binary\" namespace\n      // to tell our binary load callback to load the binary file.\n      if (args.namespace === 'wasm-stub') {\n        return {\n          path: args.path,\n          namespace: 'wasm-binary',\n        }\n      }\n\n      // Otherwise, generate the JavaScript stub module for this\n      // \".wasm\" file. Put it in the \"wasm-stub\" namespace to tell\n      // our stub load callback to fill it with JavaScript.\n      //\n      // Resolve relative paths to absolute paths here since this\n      // resolve callback is given \"resolveDir\", the directory to\n      // resolve imports against.\n      if (args.resolveDir === '') {\n        return // Ignore unresolvable paths\n      }\n      return {\n        path: path.isAbsolute(args.path) ? args.path : path.join(args.resolveDir, args.path),\n        namespace: 'wasm-stub',\n      }\n    })\n\n    // Virtual modules in the \"wasm-stub\" namespace are filled with\n    // the JavaScript code for compiling the WebAssembly binary. The\n    // binary itself is imported from a second virtual module.\n    build.onLoad({ filter: /.*/, namespace: 'wasm-stub' }, async (args) => ({\n      contents: `import wasm from ${JSON.stringify(args.path)}\n        export default (imports) =>\n          WebAssembly.instantiate(wasm, imports).then(\n            result => result.instance.exports)`,\n    }))\n\n    // Virtual modules in the \"wasm-binary\" namespace contain the\n    // actual bytes of the WebAssembly file. This uses esbuild's\n    // built-in \"binary\" loader instead of manually embedding the\n    // binary data inside JavaScript code ourselves.\n    build.onLoad({ filter: /.*/, namespace: 'wasm-binary' }, async (args) => ({\n      contents: await fs.promises.readFile(args.path),\n      loader: 'binary',\n    }))\n  },\n}\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  outfile: 'out.js',\n  plugins: [wasmPlugin],\n})\n```\n\n``` go\npackage main\n\nimport \"encoding/json\"\nimport \"io/ioutil\"\nimport \"os\"\nimport \"path/filepath\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nvar wasmPlugin = api.Plugin{\n  Name: \"wasm\",\n  Setup: func(build api.PluginBuild) {\n    // Resolve \".wasm\" files to a path with a namespace\n    build.OnResolve(api.OnResolveOptions{Filter: `\\.wasm$`},\n      func(args api.OnResolveArgs) (api.OnResolveResult, error) {\n        // If this is the import inside the stub module, import the\n        // binary itself. Put the path in the \"wasm-binary\" namespace\n        // to tell our binary load callback to load the binary file.\n        if args.Namespace == \"wasm-stub\" {\n          return api.OnResolveResult{\n            Path:      args.Path,\n            Namespace: \"wasm-binary\",\n          }, nil\n        }\n\n        // Otherwise, generate the JavaScript stub module for this\n        // \".wasm\" file. Put it in the \"wasm-stub\" namespace to tell\n        // our stub load callback to fill it with JavaScript.\n        //\n        // Resolve relative paths to absolute paths here since this\n        // resolve callback is given \"resolveDir\", the directory to\n        // resolve imports against.\n        if args.ResolveDir == \"\" {\n          return api.OnResolveResult{}, nil // Ignore unresolvable paths\n        }\n        if !filepath.IsAbs(args.Path) {\n          args.Path = filepath.Join(args.ResolveDir, args.Path)\n        }\n        return api.OnResolveResult{\n          Path:      args.Path,\n          Namespace: \"wasm-stub\",\n        }, nil\n      })\n\n    // Virtual modules in the \"wasm-stub\" namespace are filled with\n    // the JavaScript code for compiling the WebAssembly binary. The\n    // binary itself is imported from a second virtual module.\n    build.OnLoad(api.OnLoadOptions{Filter: `.*`, Namespace: \"wasm-stub\"},\n      func(args api.OnLoadArgs) (api.OnLoadResult, error) {\n        bytes, err := json.Marshal(args.Path)\n        if err != nil {\n          return api.OnLoadResult{}, err\n        }\n        contents := `import wasm from ` + string(bytes) + `\n          export default (imports) =>\n            WebAssembly.instantiate(wasm, imports).then(\n              result => result.instance.exports)`\n        return api.OnLoadResult{Contents: &contents}, nil\n      })\n\n    // Virtual modules in the \"wasm-binary\" namespace contain the\n    // actual bytes of the WebAssembly file. This uses esbuild's\n    // built-in \"binary\" loader instead of manually embedding the\n    // binary data inside JavaScript code ourselves.\n    build.OnLoad(api.OnLoadOptions{Filter: `.*`, Namespace: \"wasm-binary\"},\n      func(args api.OnLoadArgs) (api.OnLoadResult, error) {\n        bytes, err := ioutil.ReadFile(args.Path)\n        if err != nil {\n          return api.OnLoadResult{}, err\n        }\n        contents := string(bytes)\n        return api.OnLoadResult{\n          Contents: &contents,\n          Loader:   api.LoaderBinary,\n        }, nil\n      })\n  },\n}\n\nfunc main() {\n  result := api.Build(api.BuildOptions{\n    EntryPoints: []string{\"app.js\"},\n    Bundle:      true,\n    Outfile:     \"out.js\",\n    Plugins:     []api.Plugin{wasmPlugin},\n    Write:       true,\n  })\n\n  if len(result.Errors) > 0 {\n    os.Exit(1)\n  }\n}\n```\n\nThe plugin works in multiple steps. First, a resolve callback captures `.wasm` paths in normal modules and moves them to the `wasm-stub` namespace. Then load callback for the `wasm-stub` namespace generates a JavaScript stub module that exports the loader function and imports the `.wasm` path. This invokes the resolve callback again which this time moves the path to the `wasm-binary` namespace. Then the second load callback for the `wasm-binary` namespace causes the WebAssembly file to be loaded using the `binary` loader, which tells esbuild to embed the file itself in the bundle.\n\n### Svelte plugin\n\n*This example demonstrates: supporting a compile-to-JavaScript language, reporting warnings and errors, integrating source maps.*\n\nThis plugin allows you to bundle `.svelte` files, which are from the [Svelte](https://svelte.dev/) framework. You write code in an HTML-like syntax that is then converted to JavaScript by the Svelte compiler. Svelte code looks something like this:\n\n``` javascript\n<script>\n  let a = 1;\n  let b = 2;\n</script>\n<input type=\"number\" bind:value={a}>\n<input type=\"number\" bind:value={b}>\n<p>{a} + {b} = {a + b}</p>\n```\n\nCompiling this code with the Svelte compiler generates a JavaScript module that depends on the `svelte/internal` package and that exports the component as a a single class using the `default` export. This means `.svelte` files can be compiled independently, which makes Svelte a good fit for an esbuild plugin. This plugin is triggered by importing a `.svelte` file like this:\n\n``` javascript\nimport Button from './button.svelte'\n```\n\nHere's the code for the plugin (there is no Go version of this plugin because the Svelte compiler is written in JavaScript):\n\n``` javascript\nimport * as esbuild from 'esbuild'\nimport * as svelte from 'svelte/compiler'\nimport path from 'node:path'\nimport fs from 'node:fs'\n\nlet sveltePlugin = {\n  name: 'svelte',\n  setup(build) {\n    build.onLoad({ filter: /\\.svelte$/ }, async (args) => {\n      // This converts a message in Svelte's format to esbuild's format\n      let convertMessage = ({ message, start, end }) => {\n        let location\n        if (start && end) {\n          let lineText = source.split(/\\r\\n|\\r|\\n/g)[start.line - 1]\n          let lineEnd = start.line === end.line ? end.column : lineText.length\n          location = {\n            file: filename,\n            line: start.line,\n            column: start.column,\n            length: lineEnd - start.column,\n            lineText,\n          }\n        }\n        return { text: message, location }\n      }\n\n      // Load the file from the file system\n      let source = await fs.promises.readFile(args.path, 'utf8')\n      let filename = path.relative(process.cwd(), args.path)\n\n      // Convert Svelte syntax to JavaScript\n      try {\n        let { js, warnings } = svelte.compile(source, { filename })\n        let contents = js.code + `//# sourceMappingURL=` + js.map.toUrl()\n        return { contents, warnings: warnings.map(convertMessage) }\n      } catch (e) {\n        return { errors: [convertMessage(e)] }\n      }\n    })\n  }\n}\n\nawait esbuild.build({\n  entryPoints: ['app.js'],\n  bundle: true,\n  outfile: 'out.js',\n  plugins: [sveltePlugin],\n})\n```\n\nThis plugin only needs a load callback, not a resolve callback, because it's simple enough that it just needs to transform the loaded code into JavaScript without worrying about where the code comes from.\n\nIt appends a `//# sourceMappingURL=` comment to the generated JavaScript to tell esbuild how to map the generated JavaScript back to the original source code. If source maps are enabled during the build, esbuild will use this to ensure that the generated positions in the final source map are mapped all the way back to the original Svelte file instead of to the intermediate JavaScript code.\n\n## Plugin API limitations\n\nThis API does not intend to cover all use cases. It's not possible to hook into every part of the bundling process. For example, it's not currently possible to modify the AST directly. This restriction exists to preserve the excellent performance characteristics of esbuild as well as to avoid exposing too much API surface which would be a maintenance burden and would prevent improvements that involve changing the AST.\n\nOne way to think about esbuild is as a \"linker\" for the web. Just like a linker for native code, esbuild's job is to take a set of files, resolve and bind references between them, and generate a single file containing all of the code linked together. A plugin's job is to generate the individual files that end up being linked.\n\nPlugins in esbuild work best when they are relatively scoped and only customize a small aspect of the build. For example, a plugin for a special configuration file in a custom format (e.g. YAML) is very appropriate. The more plugins you use, the slower your build will get, especially if your plugin is written in JavaScript. If a plugin applies to every file in your build, then your build will likely be very slow. If caching is applicable, it must be done by the plugin itself.\n\n© 2020 Evan Wallace  \nLicensed under the MIT License.  \n[https://esbuild.github.io/plugins/](https://esbuild.github.io/plugins/)"
- name: Preserve symlinks
  id: api/index#preserve-symlinks
  summary: This setting mirrors the --preserve-symlinks setting in node
  belongs_to: API
  description: |-
    ### Preserve symlinks

    *Supported by: [Build](#build)*

    This setting mirrors the [`--preserve-symlinks`](https://nodejs.org/api/cli.html#cli_preserve_symlinks) setting in node. If you use that setting (or the similar [`resolve.symlinks`](https://webpack.js.org/configuration/resolve/#resolvesymlinks) setting in Webpack), you will likely need to enable this setting in esbuild too. It can be enabled like this:

    ``` sh
    esbuild app.js --bundle --preserve-symlinks --outfile=out.js
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      preserveSymlinks: true,
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints:      []string{"app.js"},
        Bundle:           true,
        PreserveSymlinks: true,
        Outfile:          "out.js",
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Enabling this setting causes esbuild to determine file identity by the original file path (i.e. the path without following symlinks) instead of the real file path (i.e. the path after following symlinks). This can be beneficial with certain directory structures. Keep in mind that this means a file may be given multiple identities if there are multiple symlinks pointing to it, which can result in it appearing multiple times in generated output files.

    *Note: The term "symlink" means [symbolic link](https://en.wikipedia.org/wiki/Symbolic_link) and refers to a file system feature where a path can redirect to another path.*
- name: Production readiness
  id: faq/index#production-readiness
  summary: This project has not yet hit version 1.0.0 and is still in active development
  belongs_to: FAQ
  description: |-
    ## Production readiness

    This project has not yet hit version 1.0.0 and is still in active development. That said, it is far beyond the alpha stage and is pretty stable. I think of it as a late-stage beta. For some early-adopters that means it's good enough to use for real things. Some other people think this means esbuild isn't ready yet. This section doesn't try to convince you either way. It just tries to give you enough information so you can decide for yourself whether you want to use esbuild as your bundler.

    Some data points:

    - **Used by other projects**

      The API is already being used as a library within many other developer tools. For example, [Vite](https://vitejs.dev/) and [Snowpack](https://www.snowpack.dev/) are using esbuild to transform TypeScript into JavaScript and [Amazon CDK](https://aws.amazon.com/cdk/) (Cloud Development Kit) and [Phoenix](https://www.phoenixframework.org/) are using esbuild to bundle code.

    - **API stability**

      Even though esbuild's version is not yet 1.0.0, effort is still made to keep the API stable. Patch versions are intended for backwards-compatible changes and minor versions are intended for backwards-incompatible changes. If you plan to use esbuild for something real, you should either pin the exact version (maximum safety) or pin the major and minor versions (only accept backwards-compatible upgrades).

    - **Only one main developer**

      This tool is primarily built by [me](https://github.com/evanw). For some people this is fine, but for others this means esbuild is not a suitable tool for their organization. That's ok with me. I'm building esbuild because I find it fun to build and because it's the tool I'd want to use. I'm sharing it with the world because there are others that want to use it too, because the feedback makes the tool itself better, and because I think it will inspire the ecosystem to make better tools.

    - **Not always open to scope expansion**

      I'm not planning on including major features that I'm not interested in building and/or maintaining. I also want to limit the project's scope so it doesn't get too complex and unwieldy, both from an architectural perspective, a testing and correctness perspective, and from a usability perspective. Think of esbuild as a "linker" for the web. It knows how to transform and bundle JavaScript and CSS. But the details of how your source code ends up as plain JavaScript or CSS may need to be 3rd-party code.

      I'm hoping that [plugins](../plugins/index) will allow the community to add major features (e.g. WebAssembly import) without needing to contribute to esbuild itself. However, not everything is exposed in the plugin API and it may be the case that it's not possible to add a particular feature to esbuild that you may want to add. This is intentional; esbuild is not meant to be an all-in-one solution for all frontend needs.

    &nbsp;
- name: Public path
  id: api/index#public-path
  summary: This is useful in combination with the external file loader
  belongs_to: API
  description: |-
    ### Public path

    *Supported by: [Build](#build)*

    This is useful in combination with the [external file](../content-types/index#external-file) loader. By default that loader exports the name of the imported file as a string using the `default` export. The public path option lets you prepend a base path to the exported string of each file loaded by this loader:

    ``` sh
    esbuild app.js --bundle --loader:.png=file --public-path=https://www.example.com/v1 --outdir=out
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      loader: { '.png': 'file' },
      publicPath: 'https://www.example.com/v1',
      outdir: 'out',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Loader: map[string]api.Loader{
          ".png": api.LoaderFile,
        },
        Outdir:     "out",
        PublicPath: "https://www.example.com/v1",
        Write:      true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Pure
  id: api/index#pure
  summary: 'There is a convention used by various JavaScript tools where a special comment containing either /* @__PURE__ */ or /* #__PURE__ */ before a new or call expression means that that expression can be removed if the resulting value is unused'
  belongs_to: API
  description: |-
    ### Pure

    *Supported by: [Build](#build) and [Transform](#transform)*

    There is a convention used by various JavaScript tools where a special comment containing either `/* @__PURE__ */` or `/* #__PURE__ */` before a new or call expression means that that expression can be removed if the resulting value is unused. It looks like this:

    ``` javascript
    let button = /* @__PURE__ */ React.createElement(Button, null);
    ```

    This information is used by bundlers such as esbuild during tree shaking (a.k.a. dead code removal) to perform fine-grained removal of unused imports across module boundaries in situations where the bundler is not able to prove by itself that the removal is safe due to the dynamic nature of JavaScript code.

    Note that while the comment says "pure", it confusingly does *not* indicate that the function being called is pure. For example, it does not indicate that it is ok to cache repeated calls to that function. The name is essentially just an abstract shorthand for "ok to be removed if unused".

    Some expressions such as JSX and certain built-in globals are automatically annotated as `/* @__PURE__ */` in esbuild. You can also configure additional globals to be marked `/* @__PURE__ */` as well. For example, you can mark the global `document.createElement` function as such to have it be automatically removed from your bundle when the bundle is minified as long as the result isn't used.

    It's worth mentioning that the effect of the annotation only extends to the call itself, not to the arguments. Arguments with side effects are still kept even when minification is enabled:

    ``` sh
    echo 'document.createElement(elemName())' | esbuild --pure:document.createElement
    /* @__PURE__ */ document.createElement(elemName());
    echo 'document.createElement(elemName())' | esbuild --pure:document.createElement --minify
    elemName();
    ```

    ``` javascript
    import * as esbuild from 'esbuild'let js = 'document.createElement(elemName())'
    (await esbuild.transform(js, {
      pure: ['document.createElement'],
    })).code
    '/* @__PURE__ */ document.createElement(elemName());\n'
    (await esbuild.transform(js, {
      pure: ['document.createElement'],
      minify: true,
    })).code
    'elemName();\n'
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      js := "document.createElement(elemName())"

      result1 := api.Transform(js, api.TransformOptions{
        Pure: []string{"document.createElement"},
      })

      if len(result1.Errors) == 0 {
        fmt.Printf("%s", result1.Code)
      }

      result2 := api.Transform(js, api.TransformOptions{
        Pure:         []string{"document.createElement"},
        MinifySyntax: true,
      })

      if len(result2.Errors) == 0 {
        fmt.Printf("%s", result2.Code)
      }
    }
    ```

    Note that if you are trying to remove all calls to `console` API methods such as `console.log` and also want to remove the evaluation of arguments with side effects, there is a special case available for this: you can use the [drop feature](#drop) instead of marking `console` API calls as pure. However, this mechanism is specific to the `console` API and doesn't work with other call expressions.
- name: Rebuild
  id: api/index#rebuild
  summary: You may want to use this API if your use case involves calling esbuild's build API repeatedly with the same options
  belongs_to: API
  description: |-
    ### Rebuild

    *Supported by: [Build](#build)*

    You may want to use this API if your use case involves calling esbuild's [build](#build) API repeatedly with the same options. For example, this is useful if you are implementing your own file watcher service. Rebuilding is more efficient than building again because some of the data from the previous build is cached and can be reused if the original files haven't changed since the previous build. There are currently two forms of caching used by the rebuild API:

    - Files are stored in memory and are not re-read from the file system if the file metadata hasn't changed since the last build. This optimization only applies to file system paths. It does not apply to virtual modules created by [plugins](../plugins/index).

    - Parsed [ASTs](https://en.wikipedia.org/wiki/Abstract_syntax_tree) are stored in memory and re-parsing the AST is avoided if the file contents haven't changed since the last build. This optimization applies to virtual modules created by plugins in addition to file system modules, as long as the virtual module path remains the same.

    Here's how to do a rebuild:

    ``` sh
    # The CLI does not have an API for "rebuild"
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let ctx = await esbuild.context({
      entryPoints: ['app.js'],
      bundle: true,
      outfile: 'out.js',
    })

    // Call "rebuild" as many times as you want
    for (let i = 0; i < 5; i++) {
      let result = await ctx.rebuild()
    }

    // Call "dispose" when you're done to free up resources
    ctx.dispose()
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      ctx, err := api.Context(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Outfile:     "out.js",
      })
      if err != nil {
        os.Exit(1)
      }

      // Call "Rebuild" as many times as you want
      for i := 0; i < 5; i++ {
        result := ctx.Rebuild()
        if len(result.Errors) > 0 {
          os.Exit(1)
        }
      }

      // Call "Dispose" when you're done to free up resources
      ctx.Dispose()
    }
    ```
- name: Resolve extensions
  id: api/index#resolve-extensions
  summary: The resolution algorithm used by node supports implicit file extensions
  belongs_to: API
  description: |-
    ### Resolve extensions

    *Supported by: [Build](#build)*

    The [resolution algorithm used by node](https://nodejs.org/api/modules.html#modules_file_modules) supports implicit file extensions. You can `require('./file')` and it will check for `./file`, `./file.js`, `./file.json`, and `./file.node` in that order. Modern bundlers including esbuild extend this concept to other file types as well. The full order of implicit file extensions in esbuild can be customized using the resolve extensions setting, which defaults to `.tsx,.ts,.jsx,.js,.css,.json`:

    ``` sh
    esbuild app.js --bundle --resolve-extensions=.ts,.js
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      resolveExtensions: ['.ts', '.js'],
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints:       []string{"app.js"},
        Bundle:            true,
        ResolveExtensions: []string{".ts", ".js"},
        Write:             true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Note that esbuild deliberately does not include the new `.mjs` and `.cjs` extensions in this list. Node's resolution algorithm doesn't treat these as implicit file extensions, so esbuild doesn't either. If you want to import files with these extensions you should either explicitly add the extensions in your import paths or change this setting to include the additional extensions that you want to be implicit.
- name: Resolve options
  id: plugins/index#resolve-options
  summary: The resolve function takes the path to resolve as the first argument and an object with optional properties as the second argument
  belongs_to: Plugins
  description: |-
    ### Resolve options

    The `resolve` function takes the path to resolve as the first argument and an object with optional properties as the second argument. This options object is very similar to the [arguments that are passed to `onResolve`](#on-resolve-arguments). Here are the available options:

    ``` javascript
    interface ResolveOptions {
      kind: ResolveKind;
      importer?: string;
      namespace?: string;
      resolveDir?: string;
      pluginData?: any;
      with?: Record<string, string>;
    }

    type ResolveKind =
      | 'entry-point'
      | 'import-statement'
      | 'require-call'
      | 'dynamic-import'
      | 'require-resolve'
      | 'import-rule'
      | 'url-token'
    ```

    ``` go
    type ResolveOptions struct {
      Kind       ResolveKind
      Importer   string
      Namespace  string
      ResolveDir string
      PluginData interface{}
      With       map[string]string
    }

    const (
      ResolveEntryPoint        ResolveKind
      ResolveJSImportStatement ResolveKind
      ResolveJSRequireCall     ResolveKind
      ResolveJSDynamicImport   ResolveKind
      ResolveJSRequireResolve  ResolveKind
      ResolveCSSImportRule     ResolveKind
      ResolveCSSURLToken       ResolveKind
    )
    ```

    - `kind`

      This tells esbuild how the path was imported, which can affect path resolution. For example, [node's path resolution rules](https://nodejs.org/api/packages.html#conditional-exports) say that paths imported using `'require-call'` should respect [conditional package imports](../api/index#conditions) in the `"require"` section in `package.json` while paths imported using `'import-statement'` should respect conditional package imports in the `"import"` section instead.

    - `importer`

      If set, this is interpreted as the path of the module containing this import to be resolved. This affects plugins with `onResolve` callbacks that check the `importer` value.

    - `namespace`

      If set, this is interpreted as the namespace of the module containing this import to be resolved. This affects plugins with `onResolve` callbacks that check the `namespace` value. You can read more about namespaces [here](#namespaces).

    - `resolveDir`

      This is the file system directory to use when resolving an import path to a real path on the file system. This must be set for esbuild's built-in path resolution to be able to find a given file, even for non-relative package paths (since esbuild needs to know where the `node_modules` directory is).

    - `pluginData`

      This property can be used to pass custom data to whatever [on-resolve callbacks](#on-resolve) match this import path. The meaning of this data is left entirely up to you.

    - `with`

      This is the [import attributes](https://github.com/tc39/proposal-import-attributes) assocated with the import statement for this path. For example, a `with` value of `{ type: 'json' }` would be appropriate for a module imported using `with { type: 'json' }` attributes on the import statement. This information isn't used by esbuild but may be used by [on-resolve callbacks](#on-resolve).

    &nbsp;
- name: Resolve results
  id: plugins/index#resolve-results
  summary: The resolve function returns an object that's very similar to what plugins can return from an onResolve callback
  belongs_to: Plugins
  description: |-
    ### Resolve results

    The `resolve` function returns an object that's very similar to what plugins can [return from an `onResolve` callback](#on-resolve-results). It has the following properties:

    ``` javascript
    export interface ResolveResult {
      errors: Message[];
      external: boolean;
      namespace: string;
      path: string;
      pluginData: any;
      sideEffects: boolean;
      suffix: string;
      warnings: Message[];
    }

    interface Message {
      text: string;
      location: Location | null;
      detail: any; // The original error from a JavaScript plugin, if applicable
    }

    interface Location {
      file: string;
      namespace: string;
      line: number; // 1-based
      column: number; // 0-based, in bytes
      length: number; // in bytes
      lineText: string;
    }
    ```

    ``` go
    type ResolveResult struct {
      Errors      []Message
      External    bool
      Namespace   string
      Path        string
      PluginData  interface{}
      SideEffects bool
      Suffix      string
      Warnings    []Message
    }

    type Message struct {
      Text     string
      Location *Location
      Detail   interface{} // The original error from a Go plugin, if applicable
    }

    type Location struct {
      File      string
      Namespace string
      Line      int // 1-based
      Column    int // 0-based, in bytes
      Length    int // in bytes
      LineText  string
    }
    ```

    - `path`

      This is the result of path resolution, or an empty string if path resolution failed.

    - `external`

      This will be `true` if the path was marked as [external](../api/index#external), which means it will not be included in the bundle and will instead be imported at run-time.

    - `namespace`

      This is the namespace associated with the resolved path. You can read more about namespaces [here](#namespaces).

    - `errors` and `warnings`

      These properties hold any log messages generated during path resolution, either by any plugins that responded to this path resolution operation or by esbuild itself. These log messages are not automatically included in the log, so they will be completely invisible if you discard them. If you want them to be included in the log, you'll need to return them from either `onResolve` or `onLoad`.

    - `pluginData`

      If a plugin responded to this path resolution operation and returned `pluginData` from its `onResolve` callback, that data will end up here. This is useful to pass data between different plugins without them having to coordinate directly.

    - `sideEffects`

      This property will be `true` unless the module is somehow annotated as having no side effects, in which case it will be `false`. This will be `false` for packages that have `"sideEffects": false` in the corresponding `package.json` file, and also if a plugin responds to this path resolution operation and returns `sideEffects: false`. You can read more about what `sideEffects` means in [Webpack's documentation about the feature](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free).

    - `suffix`

      This can contain an optional URL query or hash if there was one at the end of the path to be resolved and if removing it was required for the path to resolve successfully.

    &nbsp;
- name: Resolving paths
  id: plugins/index#resolve
  summary: When a plugin returns a result from an on-resolve callback, the result completely replaces esbuild's built-in path resolution
  belongs_to: Plugins
  description: |-
    ## Resolving paths

    When a plugin returns a result from an [on-resolve callback](#on-resolve), the result completely replaces esbuild's built-in path resolution. This gives the plugin complete control over how path resolution works, but it means that the plugin may have to reimplement some of the behavior that esbuild already has built-in if it wants to have similar behavior. For example, a plugin may want to search for a package in the user's `node_modules` directory, which is something esbuild already implements.

    Instead of reimplementing esbuild's built-in behavior, plugins have the option of running esbuild's path resolution manually and inspecting the result. This lets you adjust the inputs and/or the outputs of esbuild's path resolution. Here's an example:

    ``` javascript
    import * as esbuild from 'esbuild'

    let examplePlugin = {
      name: 'example',
      setup(build) {
        build.onResolve({ filter: /^example$/ }, async () => {
          const result = await build.resolve('./foo', {
            kind: 'import-statement',
            resolveDir: './bar',
          })
          if (result.errors.length > 0) {
            return { errors: result.errors }
          }
          return { path: result.path, external: true }
        })
      },
    }

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      outfile: 'out.js',
      plugins: [examplePlugin],
    })
    ```

    ``` go
    package main

    import "os"
    import "github.com/evanw/esbuild/pkg/api"

    var examplePlugin = api.Plugin{
      Name: "example",
      Setup: func(build api.PluginBuild) {
        build.OnResolve(api.OnResolveOptions{Filter: `^example$`},
          func(api.OnResolveArgs) (api.OnResolveResult, error) {
            result := build.Resolve("./foo", api.ResolveOptions{
              Kind:       api.ResolveJSImportStatement,
              ResolveDir: "./bar",
            })
            if len(result.Errors) > 0 {
              return api.OnResolveResult{Errors: result.Errors}, nil
            }
            return api.OnResolveResult{Path: result.Path, External: true}, nil
          })
      },
    }

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Outfile:     "out.js",
        Plugins:     []api.Plugin{examplePlugin},
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    This plugin intercepts imports to the path `example`, tells esbuild to resolve the import `./foo` in the directory `./bar`, forces whatever path esbuild returns to be considered external, and maps the import for `example` to that external path.

    Here are some additional things to know about this API:

    - If you don't pass the optional `resolveDir` parameter, esbuild will still run `onResolve` plugin callbacks but will not attempt any path resolution itself. All of esbuild's path resolution logic depends on the `resolveDir` parameter including looking for packages in `node_modules` directories (since it needs to know where those `node_modules` directories might be).

    - If you want to resolve a file name in a specific directory, make sure the input path starts with `./`. Otherwise the input path will be treated as a package path instead of a relative path. This behavior is identical to esbuild's normal path resolution logic.

    - If path resolution fails, the `errors` property on the returned object will be a non-empty array containing the error information. This function does not always throw an error when it fails. You need to check for errors after calling it.

    - The behavior of this function depends on the build configuration. That's why it's a property of the `build` object instead of being a top-level API call. This also means you can't call it until all plugin `setup` functions have finished since these give plugins the opportunity to adjust the build configuration before it's frozen at the start of the build. So the `resolve` function is going to be most useful inside your `onResolve` and/or `onLoad` callbacks.

    - There is currently no attempt made to detect infinite path resolution loops. Calling `resolve` from within `onResolve` with the same parameters is almost certainly a bad idea.

    &nbsp;
- name: Serve
  id: api/index#serve
  summary: If you want your app to automatically reload as you edit, you should read about live reloading
  belongs_to: API
  description: "### Serve\n\n*Supported by: [Build](#build)*\n\nIf you want your app to automatically reload as you edit, you should read about [live reloading](#live-reload). It combines serve mode with [watch mode](#watch) to listen for changes to the file system.\n\nServe mode starts a web server that serves your code to your browser on your device. Here's an example that bundles `src/app.ts` into `www/js/app.js` and then also serves the `www` directory over `http://localhost:8000/`:\n\n``` sh\nesbuild src/app.ts --outdir=www/js --bundle --servedir=www\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet ctx = await esbuild.context({\n  entryPoints: ['src/app.ts'],\n  outdir: 'www/js',\n  bundle: true,\n})\n\nlet { host, port } = await ctx.serve({\n  servedir: 'www',\n})\n```\n\n``` go\npackage main\n\nimport \"github.com/evanw/esbuild/pkg/api\"\nimport \"os\"\n\nfunc main() {\n  ctx, err := api.Context(api.BuildOptions{\n    EntryPoints: []string{\"src/app.ts\"},\n    Outdir:     \"www/js\",\n    Bundle:      true,\n  })\n  if err != nil {\n    os.Exit(1)\n  }\n\n  server, err2 := ctx.Serve(api.ServeOptions{\n    Servedir: \"www\",\n  })\n  if err2 != nil {\n    os.Exit(1)\n  }\n\n  // Returning from main() exits immediately in Go.\n  // Block forever so we keep serving and don't exit.\n  <-make(chan struct{})\n}\n```\n\nIf you create the file `www/index.html` with the following contents, the code contained in `src/app.ts` will load when you navigate to `http://localhost:8000/`:\n\n``` javascript\n<script src=\"js/app.js\"></script>\n```\n\nOne benefit of using esbuild's built-in web server instead of another web server is that whenever you reload, the files that esbuild serves are always up to date. That's not necessarily the case with other development setups. One common setup is to run a local file watcher that rebuilds output files whenever their input files change, and then separately to run a local file server to serve those output files. But that means reloading after an edit may reload the old output files if the rebuild hasn't finished yet. With esbuild's web server, each incoming request starts a rebuild if one is not already in progress, and then waits for the current rebuild to complete before serving the file. This means esbuild never serves stale build results.\n\nNote that this web server is intended to only be used in development. *Do not use this in production.*\n\n#### Arguments\n\nThe arguments to the serve API are as follows:\n\n``` sh\n# Enable serve mode\n--serve\n\n# Set the port\n--serve=9000\n\n# Set the host and port (IPv4)\n--serve=127.0.0.1:9000\n\n# Set the host and port (IPv6)\n--serve=[::1]:9000\n\n# Set the directory to serve\n--servedir=www\n\n# Enable HTTPS\n--keyfile=your.key --certfile=your.cert\n\n# Specify a fallback HTML file\n--serve-fallback=some-file.html\n```\n\n``` javascript\ninterface ServeOptions {\n  port?: number\n  host?: string\n  servedir?: string\n  keyfile?: string\n  certfile?: string\n  fallback?: string\n  onRequest?: (args: ServeOnRequestArgs) => void\n}\n\ninterface ServeOnRequestArgs {\n  remoteAddress: string\n  method: string\n  path: string\n  status: number\n  timeInMS: number\n}\n```\n\n``` go\ntype ServeOptions struct {\n  Port      uint16\n  Host      string\n  Servedir  string\n  Keyfile   string\n  Certfile  string\n  Fallback  string\n  OnRequest func(ServeOnRequestArgs)\n}\n\ntype ServeOnRequestArgs struct {\n  RemoteAddress string\n  Method        string\n  Path          string\n  Status        int\n  TimeInMS      int\n}\n```\n\n- `host`\n\n  By default, esbuild makes the web server available on all IPv4 network interfaces. This corresponds to a host address of `0.0.0.0`. If you would like to configure a different host (for example, to only serve on the `127.0.0.1` loopback interface without exposing anything to the network), you can specify the host using this argument.\n\n  If you need to use IPv6 instead of IPv4, you just need to specify an IPv6 host address. The equivalent to the `127.0.0.1` loopback interface in IPv6 is `::1` and the equivalent to the `0.0.0.0` universal interface in IPv6 is `::`.\n\n- `port`\n\n  The HTTP port can optionally be configured here. If omitted, it will default to an open port with a preference for ports in the range 8000 to 8009.\n\n- `servedir`\n\n  This is a directory of extra content for esbuild's HTTP server to serve instead of a 404 when incoming requests don't match any of the generated output file paths. This lets you use esbuild as a general-purpose local web server.\n\n  For example, you might want to create an `index.html` file and then set `servedir` to `\".\"` to serve the current directory (which includes the `index.html` file). If you don't set `servedir` then esbuild will only serve the build results, but not any other files.\n\n- `keyfile` and `certfile`\n\n  If you pass a private key and certificate to esbuild using `keyfile` and `certfile`, then esbuild's web server will use the `https://` protocol instead of the `http://` protocol. See [enabling HTTPS](#https) for more information.\n\n- `fallback`\n\n  This is a HTML file for esbuild's HTTP server to serve instead of a 404 when incoming requests don't match any of the generated output file paths. You can use this for a custom \"not found\" page. You can also use this as the entry point of a [single-page application](https://en.wikipedia.org/wiki/Single-page_application) that mutates the current URL and therefore needs to be served from many different URLs simultaneously.\n\n- `onRequest`\n\n  This is called once for each incoming request with some information about the request. This callback is used by the CLI to print out a log message for each request. The time field is the time to generate the data for the request, but it does not include the time to stream the request to the client.\n\n  Note that this is called after the request has completed. It's not possible to use this callback to modify the request in any way. If you want to do this, you should [put a proxy in front of esbuild](#serve-proxy) instead.\n\n#### Return values\n\n``` sh\n# The CLI will print the host and port like this:\n\n > Local: http://127.0.0.1:8000/\n```\n\n``` javascript\ninterface ServeResult {\n  host: string\n  port: number\n}\n```\n\n``` go\ntype ServeResult struct {\n  Host string\n  Port uint16\n}\n```\n\n- `host`\n\n  This is the host that ended up being used by the web server. It will be `0.0.0.0` (i.e. serving on all available network interfaces) unless a custom host was configured. If you are using the CLI and the host is `0.0.0.0`, all available network interfaces will be printed as hosts instead.\n\n- `port`\n\n  This is the port that ended up being used by the web server. You'll want to use this if you don't specify a port since esbuild will end up picking an arbitrary open port, and you need to know which port it picked to be able to connect to it.\n\n#### Enabling HTTPS\n\nBy default, esbuild's web server uses the `http://` protocol. However, certain modern web features are unavailable to HTTP websites. If you want to use these features, then you'll need to tell esbuild to use the `https://` protocol instead.\n\nTo enable HTTPS with esbuild:\n\n1.  Generate a self-signed certificate. There are many ways to do this. Here's one way, assuming you have the `openssl` command installed:\n\n    ``` javascript\n     openssl req -x509 -newkey rsa:4096 -keyout your.key -out your.cert -days 9999 -nodes -subj /CN=127.0.0.1 \n    ```\n\n2.  Pass `your.key` and `your.cert` to esbuild using the `keyfile` and `certfile` [serve arguments](#serve-arguments).\n\n3.  Click past the scary warning in your browser when you load your page (self-signed certificates aren't secure, but that doesn't matter since we're just doing local development).\n\nIf you have more complex needs than this, you can still [put a proxy in front of esbuild](#serve-proxy) and use that for HTTPS instead. Note that if you see the message `Client sent an HTTP request to an HTTPS server` when you load your page, then you are using the incorrect protocol. Replace `http://` with `https://` in your browser's URL bar.\n\nKeep in mind that esbuild's HTTPS support has nothing to do with security. The only reason to enable HTTPS in esbuild is because browsers have made it impossible to do local development with certain modern web features without jumping through these extra hoops. *Please do not use esbuild's development server for anything that needs to be secure.* It's only intended for local development and no considerations have been made for production environments whatsoever.\n\n#### Customizing server behavior\n\nIt's not possible to hook into esbuild's local server to customize the behavior of the server itself. Instead, behavior should be customized by putting a proxy in front of esbuild.\n\nHere's a simple example of a proxy server to get you started, using node's built-in [`http`](https://nodejs.org/api/http.html) module. It adds a custom 404 page instead of esbuild's default 404 page:\n\n``` javascript\nimport * as esbuild from 'esbuild'\nimport http from 'node:http'\n\n// Start esbuild's server on a random local port\nlet ctx = await esbuild.context({\n  // ... your build options go here ...\n})\n\n// The return value tells us where esbuild's local server is\nlet { host, port } = await ctx.serve({ servedir: '.' })\n\n// Then start a proxy server on port 3000\nhttp.createServer((req, res) => {\n  const options = {\n    hostname: host,\n    port: port,\n    path: req.url,\n    method: req.method,\n    headers: req.headers,\n  }\n\n  // Forward each incoming request to esbuild\n  const proxyReq = http.request(options, proxyRes => {\n    // If esbuild returns \"not found\", send a custom 404 page\n    if (proxyRes.statusCode === 404) {\n      res.writeHead(404, { 'Content-Type': 'text/html' })\n      res.end('<h1>A custom 404 page</h1>')\n      return\n    }\n\n    // Otherwise, forward the response from esbuild to the client\n    res.writeHead(proxyRes.statusCode, proxyRes.headers)\n    proxyRes.pipe(res, { end: true })\n  })\n\n  // Forward the body of the request to esbuild\n  req.pipe(proxyReq, { end: true })\n}).listen(3000)\n```\n\nThis code starts esbuild's server on random local port and then starts a proxy server on port 3000. During development you would load <http://localhost:3000> in your browser, which talks to the proxy. This example demonstrates modifying a response after esbuild has handled the request, but you can also modify or replace the request before esbuild has handled it.\n\nYou can do many things with a proxy like this including:\n\n- Injecting your own 404 page (the example above)\n- Customizing the mapping of routes to files on the file system\n- Redirecting some routes to an API server instead of to esbuild\n\nYou can also use a real proxy such as [nginx](https://nginx.org/en/docs/beginners_guide.html#proxy) if you have more advanced needs."
- name: Simultaneous platforms
  id: getting-started/index#simultaneous-platforms
  summary: You cannot install esbuild on one OS, copy the node_modules directory to another OS without reinstalling, and then run esbuild on that other OS
  belongs_to: Getting Started
  description: |-
    ## Simultaneous platforms

    You cannot install esbuild on one OS, copy the `node_modules` directory to another OS without reinstalling, and then run esbuild on that other OS. This won't work because esbuild is written with native code and needs to install a platform-specific binary executable. Normally this isn't an issue because you typically check your `package.json` file into version control, not your `node_modules` directory, and then everyone runs `npm install` on their local machine after cloning the repository.

    However, people sometimes get into this situation by installing esbuild on Windows or macOS and copying their `node_modules` directory into a [Docker](https://www.docker.com/) image that runs Linux, or by copying their `node_modules` directory between Windows and [WSL](https://docs.microsoft.com/en-us/windows/wsl/) environments. The way to get this to work depends on your package manager:

    - **npm/pnpm:** If you are installing with npm or pnpm, you can try not copying the `node_modules` directory when you copy the files over, and running `npm ci` or `npm install` on the destination platform after the copy. Or you could consider using [Yarn](https://yarnpkg.com/) instead which has built-in support for installing a package on multiple platforms simultaneously.

    - **Yarn:** If you are installing with Yarn, you can try listing both this platform and the other platform in your `.yarnrc.yml` file using [the `supportedArchitectures` feature](https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures). Keep in mind that this means multiple copies of esbuild will be present on the file system.

    You can also get into this situation on a macOS computer with an ARM processor if you install esbuild using the ARM version of npm but then try to run esbuild with the x86-64 version of node running inside of [Rosetta](https://en.wikipedia.org/wiki/Rosetta_(software)). In that case, an easy fix is to run your code using the ARM version of node instead, which can be downloaded here: <https://nodejs.org/en/download/>.

    Another alternative is to [use the `esbuild-wasm` package instead](#wasm), which works the same way on all platforms. But it comes with a heavy performance cost and can sometimes be 10x slower than the `esbuild` package, so you may also not want to do that.
- name: Source maps
  id: api/index#source-maps
  summary: null
  belongs_to: API
  description: '## Source maps'
- name: Source root
  id: api/index#source-root
  summary: This feature is only relevant when source maps are enabled
  belongs_to: API
  description: |-
    ### Source root

    *Supported by: [Build](#build) and [Transform](#transform)*

    This feature is only relevant when [source maps](#sourcemap) are enabled. It lets you set the value of the `sourceRoot` field in the source map, which specifies the path that all other paths in the source map are relative to. If this field is not present, all paths in the source map are interpreted as being relative to the directory containing the source map instead.

    You can configure `sourceRoot` like this:

    ``` sh
    esbuild app.js --sourcemap --source-root=https://raw.githubusercontent.com/some/repo/v1.2.3/
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      sourcemap: true,
      sourceRoot: 'https://raw.githubusercontent.com/some/repo/v1.2.3/',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Sourcemap:   api.SourceMapInline,
        SourceRoot:  "https://raw.githubusercontent.com/some/repo/v1.2.3/",
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Sourcefile
  id: api/index#sourcefile
  summary: This option sets the file name when using an input which has no file name
  belongs_to: API
  description: |-
    ### Sourcefile

    *Supported by: [Build](#build) and [Transform](#transform)*

    This option sets the file name when using an input which has no file name. This happens when using the transform API and when using the build API with stdin. The configured file name is reflected in error messages and in source maps. If it's not configured, the file name defaults to `<stdin>`. It can be configured like this:

    ``` sh
    cat app.js | esbuild --sourcefile=example.js --sourcemap
    ```

    ``` javascript
    import * as esbuild from 'esbuild'
    import fs from 'node:fs'

    let js = fs.readFileSync('app.js', 'utf8')
    let result = await esbuild.transform(js, {
      sourcefile: 'example.js',
      sourcemap: 'inline',
    })

    console.log(result.code)
    ```

    ``` go
    package main

    import "fmt"
    import "io/ioutil"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      js, err := ioutil.ReadFile("app.js")
      if err != nil {
        panic(err)
      }

      result := api.Transform(string(js),
        api.TransformOptions{
          Sourcefile: "example.js",
          Sourcemap:  api.SourceMapInline,
        })

      if len(result.Errors) == 0 {
        fmt.Printf("%s %s", result.Code)
      }
    }
    ```
- name: Sourcemap
  id: api/index#sourcemap
  summary: Source maps can make it easier to debug your code
  belongs_to: API
  description: |-
    ### Sourcemap

    *Supported by: [Build](#build) and [Transform](#transform)*

    Source maps can make it easier to debug your code. They encode the information necessary to translate from a line/column offset in a generated output file back to a line/column offset in the corresponding original input file. This is useful if your generated code is sufficiently different from your original code (e.g. your original code is TypeScript or you enabled [minification](#minify)). This is also useful if you prefer looking at individual files in your browser's developer tools instead of one big bundled file.

    Note that source map output is supported for both JavaScript and CSS, and the same options apply to both. Everything below that talks about `.js` files also applies similarly to `.css` files.

    There are four different modes for source map generation:

    1.  `linked`

        This mode means the source map is generated into a separate `.js.map` output file alongside the `.js` output file, and the `.js` output file contains a special `//# sourceMappingURL=` comment that points to the `.js.map` output file. That way the browser knows where to find the source map for a given file when you open the debugger. Use `linked` source map mode like this:

    ``` sh
    esbuild app.ts --sourcemap --outfile=out.js
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.ts'],
      sourcemap: true,
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.ts"},
        Sourcemap:   api.SourceMapLinked,
        Outfile:     "out.js",
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    2.  `external`

        This mode means the source map is generated into a separate `.js.map` output file alongside the `.js` output file, but unlike `linked` mode the `.js` output file does not contain a `//# sourceMappingURL=` comment. Use `external` source map mode like this:

    ``` sh
    esbuild app.ts --sourcemap=external --outfile=out.js
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.ts'],
      sourcemap: 'external',
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.ts"},
        Sourcemap:   api.SourceMapExternal,
        Outfile:     "out.js",
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    3.  `inline`

        This mode means the source map is appended to the end of the `.js` output file as a base64 payload inside a `//# sourceMappingURL=` comment. No additional `.js.map` output file is generated. Keep in mind that source maps are usually very big because they contain all of your original source code, so you usually do not want to ship code containing `inline` source maps. To remove the source code from the source map (keeping only the file names and the line/column mappings), use the [sources content](#sources-content) option. Use `inline` source map mode like this:

    ``` sh
    esbuild app.ts --sourcemap=inline --outfile=out.js
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.ts'],
      sourcemap: 'inline',
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.ts"},
        Sourcemap:   api.SourceMapInline,
        Outfile:     "out.js",
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    4.  `both`

        This mode is a combination of `inline` and `external`. The source map is appended inline to the end of the `.js` output file, and another copy of the same source map is written to a separate `.js.map` output file alongside the `.js` output file. Use `both` source map mode like this:

    ``` sh
    esbuild app.ts --sourcemap=both --outfile=out.js
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.ts'],
      sourcemap: 'both',
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.ts"},
        Sourcemap:   api.SourceMapInlineAndExternal,
        Outfile:     "out.js",
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    The [build](#build) API supports all four source map modes listed above, but the [transform](#transform) API does not support the `linked` mode. This is because the output returned from the transform API does not have an associated filename. If you want the output of the transform API to have a source map comment, you can append one yourself. In addition, the CLI form of the transform API only supports the `inline` mode because the output is written to stdout so generating multiple output files is not possible.

    If you want to "peek under the hood" to see what a source map does (or to debug problems with your source map), you can upload the relevant output file and the associated source map here: [Source Map Visualization](https://evanw.github.io/source-map-visualization/).

    #### Using source maps

    In the browser, source maps should be automatically picked up by the browser's developer tools as long as the source map setting is enabled. Note that the browser only uses the source maps to alter the display of stack traces when they are logged to the console. The stack traces themselves are not modified so inspecting `error.stack` in your code will still give the unmapped stack trace containing compiled code. Here's how to enable this setting in your browser's developer tools:

    - Chrome: ⚙ → Enable JavaScript source maps
    - Safari: ⚙ → Sources → Enable source maps
    - Firefox: ··· → Enable Source Maps

    In node, source maps are supported natively starting with [version v12.12.0](https://nodejs.org/en/blog/release/v12.12.0/). This feature is disabled by default but can be enabled with a flag. Unlike in the browser, the actual stack traces are also modified in node so inspecting `error.stack` in your code will give the mapped stack trace containing your original source code. Here's how to enable this setting in node (the `--enable-source-maps` flag must come before the script file name):

    ``` javascript
    node --enable-source-maps app.js
    ```
- name: Sources content
  id: api/index#sources-content
  summary: Source maps are generated using version 3 of the source map format, which is by far the most widely-supported variant
  belongs_to: API
  description: |-
    ### Sources content

    *Supported by: [Build](#build) and [Transform](#transform)*

    [Source maps](#sourcemap) are generated using [version 3](https://sourcemaps.info/spec.html) of the source map format, which is by far the most widely-supported variant. Each source map will look something like this:

    ``` javascript
    {
      "version": 3,
      "sources": ["bar.js", "foo.js"],
      "sourcesContent": ["bar()", "foo()\nimport './bar'"],
      "mappings": ";AAAA;;;ACAA;",
      "names": []
    }
    ```

    The `sourcesContent` field is an optional field that contains all of the original source code. This is helpful for debugging because it means the original source code will be available in the debugger.

    However, it's not needed in some scenarios. For example, if you are just using source maps in production to generate stack traces that contain the original file name, you don't need the original source code because there is no debugger involved. In that case it can be desirable to omit the `sourcesContent` field to make the source map smaller:

    ``` sh
    esbuild --bundle app.js --sourcemap --sources-content=false
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      bundle: true,
      entryPoints: ['app.js'],
      sourcemap: true,
      sourcesContent: false,
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        Bundle:         true,
        EntryPoints:    []string{"app.js"},
        Sourcemap:      api.SourceMapInline,
        SourcesContent: api.SourcesContentExclude,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Splitting
  id: api/index#splitting
  summary: Code splitting is still a work in progress
  belongs_to: API
  description: |-
    ### Splitting

    *Supported by: [Build](#build)*

    Code splitting is still a work in progress. It currently only works with the `esm` output [format](#format). There is also a known [ordering issue](https://github.com/evanw/esbuild/issues/399) with `import` statements across code splitting chunks. You can follow [the tracking issue](https://github.com/evanw/esbuild/issues/16) for updates about this feature.

    This enables "code splitting" which serves two purposes:

    - Code shared between multiple entry points is split off into a separate shared file that both entry points import. That way if the user first browses to one page and then to another page, they don't have to download all of the JavaScript for the second page from scratch if the shared part has already been downloaded and cached by their browser.

    - Code referenced through an asynchronous `import()` expression will be split off into a separate file and only loaded when that expression is evaluated. This allows you to improve the initial download time of your app by only downloading the code you need at startup, and then lazily downloading additional code if needed later.

      Without code splitting enabled, an `import()` expression becomes `Promise.resolve().then(() => require())` instead. This still preserves the asynchronous semantics of the expression but it means the imported code is included in the same bundle instead of being split off into a separate file.

    When you enable code splitting you must also configure the output directory using the [outdir](#outdir) setting:

    ``` sh
    esbuild home.ts about.ts --bundle --splitting --outdir=out --format=esm
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['home.ts', 'about.ts'],
      bundle: true,
      splitting: true,
      outdir: 'out',
      format: 'esm',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"home.ts", "about.ts"},
        Bundle:      true,
        Splitting:   true,
        Outdir:      "out",
        Format:      api.FormatESModule,
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Stdin
  id: api/index#stdin
  summary: Normally the build API call takes one or more file names as input
  belongs_to: API
  description: |-
    ### Stdin

    *Supported by: [Build](#build)*

    Normally the build API call takes one or more file names as input. However, this option can be used to run a build without a module existing on the file system at all. It's called "stdin" because it corresponds to piping a file to stdin on the command line.

    In addition to specifying the contents of the stdin file, you can optionally also specify the resolve directory (used to determine where relative imports are located), the [sourcefile](#sourcefile) (the file name to use in error messages and source maps), and the [loader](#loader) (which determines how the file contents are interpreted). The CLI doesn't have a way to specify the resolve directory. Instead, it's automatically set to the current working directory.

    Here's how to use this feature:

    ``` sh
    echo 'export * from "./another-file"' | esbuild --bundle --sourcefile=imaginary-file.js --loader=ts --format=cjs
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let result = await esbuild.build({
      stdin: {
        contents: `export * from "./another-file"`,

        // These are all optional:
        resolveDir: './src',
        sourcefile: 'imaginary-file.js',
        loader: 'ts',
      },
      format: 'cjs',
      write: false,
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        Stdin: &api.StdinOptions{
          Contents: "export * from './another-file'",

          // These are all optional:
          ResolveDir: "./src",
          Sourcefile: "imaginary-file.js",
          Loader:     api.LoaderTS,
        },
        Format: api.FormatCommonJS,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Supported
  id: api/index#supported
  summary: This setting lets you customize esbuild's set of unsupported syntax features at the individual syntax feature level
  belongs_to: API
  description: |-
    ### Supported

    *Supported by: [Build](#build) and [Transform](#transform)*

    This setting lets you customize esbuild's set of unsupported syntax features at the individual syntax feature level. For example, you can use this to tell esbuild that [BigInts](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) are not supported so that esbuild generates an error when you try to use one. Usually this is configured for you when you use the [`target`](#target) setting, which you should typically be using instead of this setting. If the target is specified in addition to this setting, this setting will override whatever is specified by the target.

    Here are some examples of why you might want to use this setting instead of or in addition to setting the target:

    - JavaScript runtimes often do a quick implementation of newer syntax features that is slower than the equivalent older JavaScript, and you can get a speedup by telling esbuild to pretend this syntax feature isn't supported. For example, [V8](https://v8.dev/) has a [long-standing performance bug regarding object spread](https://bugs.chromium.org/p/v8/issues/detail?id=11536) that can be avoided by manually copying properties instead of using object spread syntax.

    - There are many other JavaScript implementations in addition to the ones that esbuild's `target` setting recognizes, and they may not support certain features. If you are targeting such an implementation, you can use this setting to configure esbuild with a custom syntax feature compatibility set without needing to change esbuild itself. For example, [TypeScript's](https://www.typescriptlang.org/) JavaScript parser may not support [arbitrary module namespace identifier names](https://github.com/microsoft/TypeScript/issues/40594) so you may want to turn those off when targeting TypeScript's JavaScript parser.

    - You may be processing esbuild's output with another tool, and you may want esbuild to transform certain features and the other tool to transform certain other features. For example, if you are using esbuild to transform files individually to ES5 but you are then feeding the output into [Webpack](https://webpack.js.org/) for bundling, you may want to preserve `import()` expressions even though they are a syntax error in ES5.

    If you want esbuild to consider a certain syntax feature to be unsupported, you can specify that like this:

    ``` sh
    esbuild app.js --supported:bigint=false
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      supported: {
        'bigint': false,
      },
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Supported: map[string]bool{
          "bigint": false,
        },
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Syntax features are specified using esbuild-specific feature names. The full set of feature names is as follows:

    **JavaScript:**

    - `arbitrary-module-namespace-names`
    - `array-spread`
    - `arrow`
    - `async-await`
    - `async-generator`
    - `bigint`
    - `class`
    - `class-field`
    - `class-private-accessor`
    - `class-private-brand-check`
    - `class-private-field`
    - `class-private-method`
    - `class-private-static-accessor`
    - `class-private-static-field`
    - `class-private-static-method`
    - `class-static-blocks`
    - `class-static-field`
    - `const-and-let`
    - `decorators`
    - `default-argument`
    - `destructuring`
    - `dynamic-import`
    - `exponent-operator`
    - `export-star-as`
    - `for-await`
    - `for-of`
    - `function-name-configurable`
    - `function-or-class-property-access`
    - `generator`
    - `hashbang`
    - `import-assertions`
    - `import-attributes`
    - `import-meta`
    - `inline-script`
    - `logical-assignment`
    - `nested-rest-binding`
    - `new-target`
    - `node-colon-prefix-import`
    - `node-colon-prefix-require`
    - `nullish-coalescing`
    - `object-accessors`
    - `object-extensions`
    - `object-rest-spread`
    - `optional-catch-binding`
    - `optional-chain`
    - `regexp-dot-all-flag`
    - `regexp-lookbehind-assertions`
    - `regexp-match-indices`
    - `regexp-named-capture-groups`
    - `regexp-set-notation`
    - `regexp-sticky-and-unicode-flags`
    - `regexp-unicode-property-escapes`
    - `rest-argument`
    - `template-literal`
    - `top-level-await`
    - `typeof-exotic-object-is-object`
    - `unicode-escapes`
    - `using`

    **CSS:**

    - `color-functions`
    - `gradient-double-position`
    - `gradient-interpolation`
    - `gradient-midpoints`
    - `hwb`
    - `hex-rgba`
    - `inline-style`
    - `inset-property`
    - `is-pseudo-class`
    - `modern-rgb-hsl`
    - `nesting`
    - `rebecca-purple`

    &nbsp;
- name: Svelte plugin
  id: plugins/index#svelte-plugin
  summary: 'This example demonstrates: supporting a compile-to-JavaScript language, reporting warnings and errors, integrating source maps'
  belongs_to: Plugins
  description: |-
    ### Svelte plugin

    *This example demonstrates: supporting a compile-to-JavaScript language, reporting warnings and errors, integrating source maps.*

    This plugin allows you to bundle `.svelte` files, which are from the [Svelte](https://svelte.dev/) framework. You write code in an HTML-like syntax that is then converted to JavaScript by the Svelte compiler. Svelte code looks something like this:

    ``` javascript
    <script>
      let a = 1;
      let b = 2;
    </script>
    <input type="number" bind:value={a}>
    <input type="number" bind:value={b}>
    <p>{a} + {b} = {a + b}</p>
    ```

    Compiling this code with the Svelte compiler generates a JavaScript module that depends on the `svelte/internal` package and that exports the component as a a single class using the `default` export. This means `.svelte` files can be compiled independently, which makes Svelte a good fit for an esbuild plugin. This plugin is triggered by importing a `.svelte` file like this:

    ``` javascript
    import Button from './button.svelte'
    ```

    Here's the code for the plugin (there is no Go version of this plugin because the Svelte compiler is written in JavaScript):

    ``` javascript
    import * as esbuild from 'esbuild'
    import * as svelte from 'svelte/compiler'
    import path from 'node:path'
    import fs from 'node:fs'

    let sveltePlugin = {
      name: 'svelte',
      setup(build) {
        build.onLoad({ filter: /\.svelte$/ }, async (args) => {
          // This converts a message in Svelte's format to esbuild's format
          let convertMessage = ({ message, start, end }) => {
            let location
            if (start && end) {
              let lineText = source.split(/\r\n|\r|\n/g)[start.line - 1]
              let lineEnd = start.line === end.line ? end.column : lineText.length
              location = {
                file: filename,
                line: start.line,
                column: start.column,
                length: lineEnd - start.column,
                lineText,
              }
            }
            return { text: message, location }
          }

          // Load the file from the file system
          let source = await fs.promises.readFile(args.path, 'utf8')
          let filename = path.relative(process.cwd(), args.path)

          // Convert Svelte syntax to JavaScript
          try {
            let { js, warnings } = svelte.compile(source, { filename })
            let contents = js.code + `//# sourceMappingURL=` + js.map.toUrl()
            return { contents, warnings: warnings.map(convertMessage) }
          } catch (e) {
            return { errors: [convertMessage(e)] }
          }
        })
      }
    }

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      outfile: 'out.js',
      plugins: [sveltePlugin],
    })
    ```

    This plugin only needs a load callback, not a resolve callback, because it's simple enough that it just needs to transform the loaded code into JavaScript without worrying about where the code comes from.

    It appends a `//# sourceMappingURL=` comment to the generated JavaScript to tell esbuild how to map the generated JavaScript back to the original source code. If source maps are enabled during the build, esbuild will use this to ensure that the generated positions in the final source map are mapped all the way back to the original Svelte file instead of to the intermediate JavaScript code.
- name: Target
  id: api/index#target
  summary: This sets the target environment for the generated JavaScript and/or CSS code
  belongs_to: API
  description: |-
    ### Target

    *Supported by: [Build](#build) and [Transform](#transform)*

    This sets the target environment for the generated JavaScript and/or CSS code. It tells esbuild to transform JavaScript syntax that is too new for these environments into older JavaScript syntax that will work in these environments. For example, the `??` operator was introduced in Chrome 80 so esbuild will convert it into an equivalent (but more verbose) conditional expression when targeting Chrome 79 or earlier.

    Note that this is only concerned with syntax features, not APIs. It does *not* automatically add [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for new APIs that are not used by these environments. You will have to explicitly import polyfills for the APIs you need (e.g. by importing [`core-js`](https://www.npmjs.com/package/core-js)). Automatic polyfill injection is outside of esbuild's scope.

    Each target environment is an environment name followed by a version number. The following environment names are currently supported:

    - `chrome`
    - `deno`
    - `edge`
    - `firefox`
    - `hermes`
    - `ie`
    - `ios`
    - `node`
    - `opera`
    - `rhino`
    - `safari`

    In addition, you can also specify JavaScript language versions such as `es2020`. The default target is `esnext` which means that by default, esbuild will assume all of the latest JavaScript and CSS features are supported. Here is an example that configures multiple target environments. You don't need to specify all of them; you can just specify the subset of target environments that your project cares about. You can also be more precise about version numbers if you'd like (e.g. `node12.19.0` instead of just `node12`):

    ``` sh
    esbuild app.js --target=es2020,chrome58,edge16,firefox57,node12,safari11
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      target: [
        'es2020',
        'chrome58',
        'edge16',
        'firefox57',
        'node12',
        'safari11',
      ],
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Target:      api.ES2020,
        Engines: []api.Engine{
          {Name: api.EngineChrome, Version: "58"},
          {Name: api.EngineEdge, Version: "16"},
          {Name: api.EngineFirefox, Version: "57"},
          {Name: api.EngineNode, Version: "12"},
          {Name: api.EngineSafari, Version: "11"},
        },
        Write: true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    You can refer to the [JavaScript loader](../content-types/index#javascript) for the details about which syntax features were introduced with which language versions. Keep in mind that while JavaScript language versions such as `es2020` are identified by year, that is the year the specification is approved. It has nothing to do with the year all major browsers implement that specification which often happens earlier or later than that year.

    If you use a syntax feature that esbuild doesn't yet have support for transforming to your current language target, esbuild will generate an error where the unsupported syntax is used. This is often the case when targeting the `es5` language version, for example, since esbuild only supports transforming most newer JavaScript syntax features to `es6`.

    If you need to customize the set of supported syntax features at the individual feature level in addition to or instead of what `target` provides, you can do that with the [`supported`](#supported) setting.
- name: Text
  id: content-types/index#text
  summary: This loader is enabled by default for .txt files
  belongs_to: Content Types
  description: |-
    ## Text

    Loader: `text`

    This loader is enabled by default for `.txt` files. It loads the file as a string at build time and exports the string as the default export. Using it looks something like this:

    ``` javascript
    import string from './example.txt'
    console.log(string)
    ```
- name: Top-level var
  id: faq/index#top-level-var
  summary: People are sometimes surprised that esbuild sometimes rewrites top-level let, const, and class declarations as var declarations instead
  belongs_to: FAQ
  description: "## Top-level `var`\n\nPeople are sometimes surprised that esbuild sometimes rewrites top-level `let`, `const`, and `class` declarations as `var` declarations instead. This is done for a few reasons:\n\n- **For correctness**\n\n  Bundling sometimes needs to lazily-initialize a module. For example, this happens when you call `require()` or `import()` using the path of a module within the bundle. Doing this involves separating the declaration and initialization of top-level symbols by moving the initialization into a closure. So for example `class` statements are rewritten as an assignment of a class expression to a variable. Keeping the declarations out of the lazy-initialization closure is important for performance, since it means other modules can reference them directly instead by name instead of indirectly via a slower property access.\n\n  Another case where this is needed is when transforming top-level `using` declarations. This involves wrapping the entire module body in a `try` block, which also involves separating the declaration and initialization of top-level symbols. Top-level symbols may need to be exported, which means they cannot be declared within the `try` block.\n\n  In both of these cases esbuild will fail with a build error if the source code contains a mutation of a `const` symbol, so it's not possible for esbuild's rewriting of top-level `const` into `var` to result in the mutation of a constant.\n\n  Due to esbuild's current architecture, the part of esbuild that does this transformation (the parser) cannot know whether the current module will end up being lazily initialized or not. The information for this decision may only be discovered later on in the build, or may even change in future incremental builds that reuse the same AST (per-file ASTs are transformed once during parsing and then cached and reused across incremental builds). So this transformation is always done when bundling is active.\n\n- **For performance**\n\n  Multiple JavaScript VMs have had and continue to have performance issues with TDZ (i.e. \"temporal dead zone\") checks. These checks validate that a let, or const, or class symbol isn't used before it's initialized. Here are two issues with well-known VMs:\n\n  - V8: <https://bugs.chromium.org/p/v8/issues/detail?id=13723> (10% slowdown)\n  - JavaScriptCore: <https://bugs.webkit.org/show_bug.cgi?id=199866> (1,000% slowdown!)\n\n  JavaScriptCore had a severe performance issue as their TDZ implementation had time complexity that was quadratic in the number of variables needing TDZ checks in the same scope (with the top-level scope typically being the worst offender). V8 has ongoing issues with TDZ checks being present throughout the code their JIT generates even when they have already been checked earlier in the same function or when the function in question has already been run (so the checks have already happened).\n\n  In JavaScript, `let`, `const`, and `class` declarations all introduce TDZ checks while `var` declarations do not. Since bundling typically merges many modules into a single very large top-level scope, the performance impact of these TDZ checks can be pretty severe. Converting top-level `let`, `const`, and `class` declarations into `var` helps automatically make your code faster.\n\nNote that esbuild doesn't preserve top-level TDZ side effects because modules may need to be lazily initialized (as described above), which means separating declaration from initialization. TDZ checks for top-level symbols could hypothetically still be supported by generating extra code that checks before each use of a top-level symbol and throws if it hasn't been initialized yet (effectively manually implementing what a real JavaScript VM would do). However, this seems like an excessive overhead for both code size and run time, and does not seem like something that a production-oriented bundler should do.\n\n© 2020 Evan Wallace  \nLicensed under the MIT License.  \n[https://esbuild.github.io/faq/](https://esbuild.github.io/faq/)\n\nJavaScript benchmark\n\nTypeScript benchmark"
- name: Transform
  id: api/index#transform
  summary: This is a limited special-case of build that transforms a string of code representing an in-memory file in an isolated environment that's completely disconnected from any other files
  belongs_to: API
  description: "### Transform\n\nThis is a limited special-case of [build](#build) that transforms a string of code representing an in-memory file in an isolated environment that's completely disconnected from any other files. Common uses include minifying code and transforming TypeScript into JavaScript. Here's an example:\n\n``` sh\necho 'let x: number = 1' | esbuild --loader=ts\nlet x = 1;\n```\n\n``` javascript\nimport * as esbuild from 'esbuild'\n\nlet ts = 'let x: number = 1'\nlet result = await esbuild.transform(ts, {\n  loader: 'ts',\n})\nconsole.log(result)\n```\n\n``` go\npackage main\n\nimport \"fmt\"\nimport \"github.com/evanw/esbuild/pkg/api\"\n\nfunc main() {\n  ts := \"let x: number = 1\"\n  result := api.Transform(ts, api.TransformOptions{\n    Loader: api.LoaderTS,\n  })\n\n  if len(result.Errors) == 0 {\n    fmt.Printf(\"%s\", result.Code)\n  }\n}\n```\n\nTaking a string instead of a file as input is more ergonomic for certain use cases. File system isolation has certain advantages (e.g. works in the browser, not affected by nearby `package.json` files) and certain disadvantages (e.g. can't be used with [bundling](#bundle) or [plugins](../plugins/index)). If your use case doesn't fit the transform API then you should use the more general [build](#build) API instead.\n\nThe transform API takes the following options:\n\n**General options:**\n\n- [Platform](#platform)\n- [Tsconfig raw](#tsconfig-raw)\n\n  \n**Input:**\n\n- [Loader](#loader)\n\n  \n\n**Output contents:**\n\n- [Banner](#banner)\n- [Charset](#charset)\n- [Footer](#footer)\n- [Format](#format)\n- [Global name](#global-name)\n- [Legal comments](#legal-comments)\n- [Line limit](#line-limit)\n\n  \n\n**Transformation:**\n\n- [JSX](#jsx)\n- [JSX dev](#jsx-dev)\n- [JSX factory](#jsx-factory)\n- [JSX fragment](#jsx-fragment)\n- [JSX import source](#jsx-import-source)\n- [JSX side effects](#jsx-side-effects)\n- [Supported](#supported)\n- [Target](#target)\n\n  \n\n**Optimization:**\n\n- [Define](#define)\n- [Drop](#drop)\n- [Drop labels](#drop-labels)\n- [Ignore annotations](#ignore-annotations)\n- [Keep names](#keep-names)\n- [Mangle props](#mangle-props)\n- [Minify](#minify)\n- [Pure](#pure)\n- [Tree shaking](#tree-shaking)\n\n  \n\n**Source maps:**\n\n- [Source root](#source-root)\n- [Sourcefile](#sourcefile)\n- [Sourcemap](#sourcemap)\n- [Sources content](#sources-content)\n\n  \n**Logging:**\n\n- [Color](#color)\n- [Format messages](#format-messages)\n- [Log level](#log-level)\n- [Log limit](#log-limit)\n- [Log override](#log-override)"
- name: Transformation
  id: api/index#transformation
  summary: null
  belongs_to: API
  description: '## Transformation'
- name: Tree shaking
  id: api/index#tree-shaking
  summary: Tree shaking is the term the JavaScript community uses for dead code elimination, a common compiler optimization that automatically removes unreachable code
  belongs_to: API
  description: |-
    ### Tree shaking

    *Supported by: [Build](#build) and [Transform](#transform)*

    Tree shaking is the term the JavaScript community uses for dead code elimination, a common compiler optimization that automatically removes unreachable code. Within esbuild, this term specifically refers to declaration-level dead code removal.

    Tree shaking is easiest to explain with an example. Consider the following file. There is one used function and one unused function:

    ``` javascript
    // input.js
    function one() {
      console.log('one')
    }
    function two() {
      console.log('two')
    }
    one()
    ```

    If you bundle this file with `esbuild --bundle input.js --outfile=output.js`, the unused function will automatically be discarded leaving you with the following output:

    ``` javascript
    // input.js
    function one() {
      console.log("one");
    }
    one();
    ```

    This even works if we split our functions off into a separate library file and import them using an `import` statement:

    ``` javascript
    // lib.js
    export function one() {
      console.log('one')
    }
    export function two() {
      console.log('two')
    }
    ```

    ``` javascript
    // input.js
    import * as lib from './lib.js'
    lib.one()
    ```

    If you bundle this file with `esbuild --bundle input.js --outfile=output.js`, the unused function and unused import will still be automatically discarded leaving you with the following output:

    ``` javascript
    // lib.js
    function one() {
      console.log("one");
    }

    // input.js
    one();
    ```

    This way esbuild will only bundle the parts of your packages that you actually use, which can sometimes be a substantial size savings. Note that esbuild's tree shaking implementation relies on the use of ECMAScript module `import` and `export` statements. It does not work with CommonJS modules. Many packages on npm include both formats and esbuild tries to pick the format that works with tree shaking by default. You can customize which format esbuild picks using the [main fields](#main-fields) and/or [conditions](#conditions) options depending on the package.

    By default, tree shaking is only enabled either when [bundling](#bundle) is enabled or when the output [format](#format) is set to `iife`, otherwise tree shaking is disabled. You can force-enable tree shaking by setting it to `true`:

    ``` sh
    esbuild app.js --tree-shaking=true
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      treeShaking: true,
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        TreeShaking: api.TreeShakingTrue,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    You can also force-disable tree shaking by setting it to `false`:

    ``` sh
    esbuild app.js --tree-shaking=false
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.js'],
      treeShaking: false,
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        TreeShaking: api.TreeShakingFalse,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    #### Tree shaking and side effects

    The side effect detection used for tree shaking is conservative, meaning that esbuild only considers code removable as dead code if it can be sure that there are no hidden side effects. For example, primitive literals such as `12.34` and `"abcd"` are side-effect free and can be removed while expressions such as `"ab" + cd` and `foo.bar` are not side-effect free (joining strings invokes `toString()` which can have side effects, and member access can invoke a getter which can also have side effects). Even referencing a global identifier is considered to be a side effect because it will throw a `ReferenceError` if there is no global with that name. Here's an example:

    ``` javascript
    // These are considered side-effect free
    let a = 12.34;
    let b = "abcd";
    let c = { a: a };

    // These are not considered side-effect free
    // since they could cause some code to run
    let x = "ab" + cd;
    let y = foo.bar;
    let z = { [x]: x };
    ```

    Sometimes it's desirable to allow some code to be tree shaken even if that code can't be automatically determined to have no side effects. This can be done with a [pure annotation comment](#pure) which tells esbuild to trust the author of the code that there are no side effects within the annotated code. The annotation comment is `/* @__PURE__ */` and can only precede a new or call expression. You can annotate an immediately-invoked function expression and put arbitrary side effects inside the function body:

    ``` javascript
    // This is considered side-effect free due to
    // the annotation, and will be removed if unused
    let gammaTable = /* @__PURE__ */ (() => {
      // Side-effect detection is skipped in here
      let table = new Uint8Array(256);
      for (let i = 0; i < 256; i++)
        table[i] = Math.pow(i / 255, 2.2) * 255;
      return table;
    })();
    ```

    While the fact that `/* @__PURE__ */` only works on call expressions can sometimes make code more verbose, a big benefit of this syntax is that it's portable across many other tools in the JavaScript ecosystem including the popular [UglifyJS](https://github.com/mishoo/uglifyjs) and [Terser](https://github.com/terser/terser) JavaScript minifiers (which are used by other major tools including [Webpack](https://github.com/webpack/webpack) and [Parcel](https://github.com/parcel-bundler/parcel)).

    Note that the annotations cause esbuild to assume that the annotated code is side-effect free. If the annotations are wrong and the code actually does have important side effects, these annotations can result in broken code. If you are bundling third-party code with annotations that have been authored incorrectly, you may need to enable [ignoring annotations](#ignore-annotations) to make sure the bundled code is correct.
- name: Tsconfig
  id: api/index#tsconfig
  summary: Normally the build API automatically discovers tsconfig.json files and reads their contents during a build
  belongs_to: API
  description: |-
    ### Tsconfig

    *Supported by: [Build](#build)*

    Normally the [build](#build) API automatically discovers `tsconfig.json` files and reads their contents during a build. However, you can also configure a custom `tsconfig.json` file to use instead. This can be useful if you need to do multiple builds of the same code with different settings:

    ``` sh
    esbuild app.ts --bundle --tsconfig=custom-tsconfig.json
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['app.ts'],
      bundle: true,
      tsconfig: 'custom-tsconfig.json',
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.ts"},
        Bundle:      true,
        Tsconfig:    "custom-tsconfig.json",
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```
- name: Tsconfig raw
  id: api/index#tsconfig-raw
  summary: This option can be used to pass your tsconfig.json file to the transform API, which doesn't access the file system
  belongs_to: API
  description: |-
    ### Tsconfig raw

    *Supported by: [Build](#build) and [Transform](#transform)*

    This option can be used to pass your `tsconfig.json` file to the [transform](#transform) API, which doesn't access the file system. It can also be used to pass the contents of your `tsconfig.json` file to the [build](#build) API inline without writing it to a file. Using it looks like this:

    ``` sh
    echo 'class Foo { foo }' | esbuild --loader=ts --tsconfig-raw='{"compilerOptions":{"useDefineForClassFields":false}}'
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let ts = 'class Foo { foo }'
    let result = await esbuild.transform(ts, {
      loader: 'ts',
      tsconfigRaw: `{
        "compilerOptions": {
          "useDefineForClassFields": false,
        },
      }`,
    })
    console.log(result.code)
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"

    func main() {
      ts := "class Foo { foo }"

      result := api.Transform(ts, api.TransformOptions{
        Loader: api.LoaderTS,
        TsconfigRaw: `{
          "compilerOptions": {
            "useDefineForClassFields": false,
          },
        }`,
      })

      if len(result.Errors) == 0 {
        fmt.Printf("%s", result.Code)
      }
    }
    ```
- name: TypeScript
  id: content-types/index#typescript
  summary: This loader is enabled by default for .ts, .tsx, .mts, and .cts files, which means esbuild has built-in support for parsing TypeScript syntax and discarding the type annotations
  belongs_to: Content Types
  description: |-
    ## TypeScript

    Loader: `ts` or `tsx`

    This loader is enabled by default for `.ts`, `.tsx`, `.mts`, and `.cts` files, which means esbuild has built-in support for parsing TypeScript syntax and discarding the type annotations. However, esbuild *does not* do any type checking so you will still need to run `tsc -noEmit` in parallel with esbuild to check types. This is not something esbuild does itself.

    TypeScript type declarations like these are parsed and ignored (a non-exhaustive list):

    | Syntax feature              | Example                         |
    |-----------------------------|---------------------------------|
    | Interface declarations      | `interface Foo {}`              |
    | Type declarations           | `type Foo = number`             |
    | Function declarations       | `function foo(): void;`         |
    | Ambient declarations        | `declare module 'foo' {}`       |
    | Type-only imports           | `import type {Type} from 'foo'` |
    | Type-only exports           | `export type {Type} from 'foo'` |
    | Type-only import specifiers | `import {type Type} from 'foo'` |
    | Type-only export specifiers | `export {type Type} from 'foo'` |

    TypeScript-only syntax extensions are supported, and are always converted to JavaScript (a non-exhaustive list):

    | Syntax feature            | Example                    | Notes                                                                                                                                                                                                          |
    |---------------------------|----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | Namespaces                | `namespace Foo {}`         |                                                                                                                                                                                                                |
    | Enums                     | `enum Foo { A, B }`        |                                                                                                                                                                                                                |
    | Const enums               | `const enum Foo { A, B }`  |                                                                                                                                                                                                                |
    | Generic type parameters   | `<T>(a: T): T => a`        | Must write `<T,>(`... with the `tsx` loader                                                                                                                                                                    |
    | JSX with types            | `<Element<T>/>`            |                                                                                                                                                                                                                |
    | Type casts                | `a as B` and `<B>a`        |                                                                                                                                                                                                                |
    | Type imports              | `import {Type} from 'foo'` | Handled by removing all unused imports                                                                                                                                                                         |
    | Type exports              | `export {Type} from 'foo'` | Handled by ignoring missing exports in TypeScript files                                                                                                                                                        |
    | Experimental decorators   | `@sealed class Foo {}`     | Requires [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators), does not support [`emitDecoratorMetadata`](https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata) |
    | Instantiation expressions | `Array<number>`            | TypeScript 4.7+                                                                                                                                                                                                |
    | `extends` on `infer`      | `infer A extends B`        | TypeScript 4.7+                                                                                                                                                                                                |
    | Variance annotations      | `type A<out B> = () => B`  | TypeScript 4.7+                                                                                                                                                                                                |
    | The `satisfies` operator  | `a satisfies T`            | TypeScript 4.9+                                                                                                                                                                                                |
    | `const` type parameters   | `class Foo<const T> {}`    | TypeScript 5.0+                                                                                                                                                                                                |
- name: TypeScript caveats
  id: content-types/index#typescript-caveats
  summary: Even when transpiling a single module, the TypeScript compiler actually still parses imported files so it can tell whether an imported name is a type or a value
  belongs_to: Content Types
  description: "### TypeScript caveats\n\nYou should keep the following things in mind when using TypeScript with esbuild (in addition to the [JavaScript caveats](#javascript-caveats)):\n\n#### Files are compiled independently\n\nEven when transpiling a single module, the TypeScript compiler actually still parses imported files so it can tell whether an imported name is a type or a value. However, tools like esbuild and Babel (and the TypeScript compiler's `transpileModule` API) compile each file in isolation so they can't tell if an imported name is a type or a value.\n\nBecause of this, you should enable the [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules) TypeScript configuration option if you use TypeScript with esbuild. This option prevents you from using features which could cause mis-compilation in environments like esbuild where each file is compiled independently without tracing type references across files. For example, it prevents you from re-exporting types from another module using `export {T} from './types'` (you need to use `export type {T} from './types'` instead).\n\n#### Imports follow ECMAScript module behavior\n\nFor historical reasons, the TypeScript compiler compiles ESM (ECMAScript module) syntax to CommonJS syntax by default. For example, `import * as foo from 'foo'` is compiled to `const foo = require('foo')`. Presumably this happened because ECMAScript modules were still a proposal when TypeScript adopted the syntax. However, this is legacy behavior that doesn't match how this syntax behaves on real platforms such as node. For example, the `require` function can return any JavaScript value including a string but the `import * as` syntax always results in an object and cannot be a string.\n\nTo avoid problems due to this legacy feature, you should enable the [`esModuleInterop`](https://www.typescriptlang.org/tsconfig#esModuleInterop) TypeScript configuration option if you use TypeScript with esbuild. Enabling it disables this legacy behavior and makes TypeScript's type system compatible with ESM. This option is not enabled by default because it would be a breaking change for existing TypeScript projects, but Microsoft [highly recommends applying it both to new and existing projects](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#support-for-import-d-from-cjs-from-commonjs-modules-with---esmoduleinterop) (and then updating your code) for better compatibility with the rest of the ecosystem.\n\nSpecifically this means that importing a non-object value from a CommonJS module with ESM import syntax must be done using a default import instead of using `import * as`. So if a CommonJS module exports a function via `module.exports = fn`, you need to use `import fn from 'path'` instead of `import * as fn from 'path'`.\n\n#### Features that need a type system are not supported\n\nTypeScript types are treated as comments and are ignored by esbuild, so TypeScript is treated as \"type-checked JavaScript.\" The interpretation of the type annotations is up to the TypeScript type checker, which you should be running in addition to esbuild if you're using TypeScript. This is the same compilation strategy that Babel's TypeScript implementation uses. However, it means that some TypeScript compilation features which require type interpretation to work do not work with esbuild.\n\nSpecifically:\n\n- The [`emitDecoratorMetadata`](https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata) TypeScript configuration option is not supported. This feature passes a JavaScript representation of the corresponding TypeScript type to the attached decorator function. Since esbuild does not replicate TypeScript's type system, it does not have enough information to implement this feature.\n\n- The [`declaration`](https://www.typescriptlang.org/tsconfig#declaration) TypeScript configuration option (i.e. generation of `.d.ts` files) is not supported. If you are writing a library in TypeScript and you want to publish the compiled JavaScript code as a package for others to use, you will probably also want to publish type declarations. This is not something that esbuild can do for you because it doesn't retain any type information. You will likely either need to use the TypeScript compiler to generate them or manually write them yourself.\n\n#### Only certain `tsconfig.json` fields are respected\n\nDuring bundling, the path resolution algorithm in esbuild will consider the contents of the `tsconfig.json` file in the closest parent directory containing one and will modify its behavior accordingly. It is also possible to explicitly set the `tsconfig.json` path with the build API using esbuild's [`tsconfig`](../api/index#tsconfig) setting and to explicitly pass in the contents of a `tsconfig.json` file with the transform API using esbuild's [`tsconfigRaw`](../api/index#tsconfig-raw) setting. However, esbuild currently only inspects the following fields in `tsconfig.json` files:\n\n- [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators)\n\n  This option enables the transformation of decorator syntax in TypeScript files. The transformation follows the outdated decorator design that TypeScript itself follows when `experimentalDecorators` is enabled.\n\n  Note that there is an updated design for decorators that is being added to JavaScript, as well as to TypeScript when `experimentalDecorators` is disabled. This is not something that esbuild implements yet, so esbuild will currently not transform decorators when `experimentalDecorators` is disabled.\n\n- [`target`](https://www.typescriptlang.org/tsconfig#target)  \n  [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)\n\n  These options control whether class fields in TypeScript files are compiled with \"define\" semantics or \"assign\" semantics:\n\n  - **Define semantics** (esbuild's default behavior): TypeScript class fields behave like normal JavaScript class fields. Field initializers do not trigger setters on the base class. You should write all new code this way going forward.\n\n  - **Assign semantics** (which you have to explicitly enable): esbuild emulates TypeScript's legacy class field behavior. Field initializers will trigger base class setters. This may be needed to get legacy code to run.\n\n  The way to disable define semantics (and therefore enable assign semantics) with esbuild is the same way you disable it with TypeScript: by setting `useDefineForClassFields` to `false` in your `tsconfig.json` file.\n\n  For compatibility with TypeScript, esbuild also copies TypeScript's behavior where when `useDefineForClassFields` is not specified, it defaults to `false` when `tsconfig.json` contains a `target` that is earlier than `ES2022`. But I recommend setting `useDefineForClassFields` explicitly if you need it instead of relying on this default value coming from the value of the `target` setting. Note that the `target` setting in `tsconfig.json` is only used by esbuild for determining the default value of `useDefineForClassFields`. It does *not* affect esbuild's own [`target`](../api/index#target) setting, even though they have the same name.\n\n- [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl)  \n  [`paths`](https://www.typescriptlang.org/tsconfig#paths)\n\n  These options affect esbuild's resolution of `import`/`require` paths to files on the file system. You can use it to define package aliases and to rewrite import paths in other ways. Note that using esbuild for import path transformation requires [`bundling`](../api/index#bundle) to be enabled, as esbuild's path resolution only happens during bundling. Also note that esbuild also has a native [`alias`](../api/index#alias) feature which you may want to use instead.\n\n- [`jsx`](https://www.typescriptlang.org/tsconfig#jsx)  \n  [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)  \n  [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)  \n  [`jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource)\n\n  These options affect esbuild's transformation of JSX syntax into JavaScript. They are equivalent to esbuild's native options for these settings: [`jsx`](../api/index#jsx), [`jsxFactory`](../api/index#jsx-factory), [`jsxFragment`](../api/index#jsx-fragment), and [`jsxImportSource`](../api/index#jsx-import-source).\n\n- [`alwaysStrict`](https://www.typescriptlang.org/tsconfig#alwaysStrict)  \n  [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n\n  If either of these options are enabled, esbuild will consider all code in all TypeScript files to be in [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) and will prefix generated code with `\"use strict\"` unless the output [`format`](../api/index#format) is set to [`esm`](../api/index#format-esm) (since all ESM files are automatically in strict mode).\n\n- [`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax)  \n  [`importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues)  \n  [`preserveValueImports`](https://www.typescriptlang.org/tsconfig/#preserveValueImports)\n\n  By default, the TypeScript compiler will delete unused imports when converting TypeScript to JavaScript. That way imports which turn out to be type-only imports accidentally don't cause an error at run-time. This behavior is also implemented by esbuild.\n\n  These options allow you to disable this behavior and preserve unused imports, which can be useful if for example the imported file has useful side-effects. You should use `verbatimModuleSyntax` for this, as that replaces the older `importsNotUsedAsValues` and `preserveValueImports` settings (which TypeScript has now deprecated).\n\n- [`extends`](https://www.typescriptlang.org/tsconfig#extends)\n\n  This option allows you to split up your `tsconfig.json` file across multiple files. This value can be a string for single inheritance or an array for multiple inheritance (new in TypeScript 5.0+).\n\nAll other `tsconfig.json` fields (i.e. those that aren't in the above list) will be ignored.\n\n#### You cannot use the `tsx` loader for `*.ts` files\n\nThe `tsx` loader is *not* a superset of the `ts` loader. They are two different partially-incompatible syntaxes. For example, the character sequence `<a>1</a>/g` parses as `<a>(1 < (/a>/g))` with the `ts` loader and `(<a>1</a>) / g` with the `tsx` loader.\n\nThe most common issue this causes is not being able to use generic type parameters on arrow function expressions such as `<T>() => {}` with the `tsx` loader. This is intentional, and matches the behavior of the official TypeScript compiler. That space in the `tsx` grammar is reserved for JSX elements."
- name: Upcoming roadmap
  id: faq/index#upcoming-roadmap
  summary: After that point, I will consider esbuild to be relatively complete
  belongs_to: FAQ
  description: |-
    ## Upcoming roadmap

    These features are already in progress and are first priority:

    - Code splitting ([\#16](https://github.com/evanw/esbuild/issues/16), [docs](../api/index#splitting))

    These are potential future features but may not happen or may happen to a more limited extent:

    - HTML content type ([\#31](https://github.com/evanw/esbuild/issues/31))

    After that point, I will consider esbuild to be relatively complete. I'm planning for esbuild to reach a mostly stable state and then stop accumulating more features. This will involve saying "no" to requests for adding major features to esbuild itself. I don't think esbuild should become an all-in-one solution for all frontend needs. In particular, I want to avoid the pain and problems of the "webpack config" model where the underlying tool is too flexible and usability suffers.

    For example, I am *not* planning to include these features in esbuild's core itself:

    - Support for other frontend languages (e.g. [Elm](https://elm-lang.org/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [Angular](https://angular.io/))
    - TypeScript type checking (just run `tsc` separately)
    - An API for custom AST manipulation
    - Hot-module reloading
    - Module federation

    I hope that the extensibility points I'm adding to esbuild ([plugins](../plugins/index) and the [API](../api/index)) will make esbuild useful to include as part of more customized build workflows, but I'm not intending or expecting these extensibility points to cover all use cases. If you have very custom requirements then you should be using other tools. I also hope esbuild inspires other build tools to dramatically improve performance by overhauling their implementations so that everyone can benefit, not just those that use esbuild.

    I am planning to continue to maintain everything in esbuild's existing scope even after esbuild reaches stability. This means implementing support for newly-released JavaScript and TypeScript syntax features, for example.
- name: Using JSX without React
  id: content-types/index#using-jsx-without-react
  summary: You will also have to add import {h, Fragment} from 'preact' in files containing JSX syntax unless you use auto-importing as described above
  belongs_to: Content Types
  description: |-
    ### Using JSX without React

    If you're using JSX with a library other than React (such as [Preact](https://preactjs.com/)), you'll likely need to configure the [JSX factory](../api/index#jsx-factory) and [JSX fragment](../api/index#jsx-fragment) settings since they default to `React.createElement` and `React.Fragment` respectively:

    ``` sh
    esbuild app.jsx --jsx-factory=h --jsx-fragment=Fragment
    ```

    ``` javascript
    require('esbuild').buildSync({
      entryPoints: ['app.jsx'],
      jsxFactory: 'h',
      jsxFragment: 'Fragment',
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.jsx"},
        JSXFactory:  "h",
        JSXFragment: "Fragment",
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Alternatively, if you are using TypeScript, you can just configure JSX for TypeScript by adding this to your `tsconfig.json` file and esbuild should pick it up automatically without needing to be configured:

    ``` javascript
    {
      "compilerOptions": {
        "jsxFactory": "h",
        "jsxFragmentFactory": "Fragment"
      }
    }
    ```

    You will also have to add `import {h, Fragment} from 'preact'` in files containing JSX syntax unless you use auto-importing as described above.
- name: Using plugins
  id: plugins/index#using-plugins
  summary: An esbuild plugin is an object with a name and a setup function
  belongs_to: Plugins
  description: |-
    ## Using plugins

    An esbuild plugin is an object with a `name` and a `setup` function. They are passed in an array to the [build](../api/index#build) API call. The `setup` function is run once for each build API call.

    Here's a simple plugin example that allows you to import the current environment variables at build time:

    ``` javascript
    import * as esbuild from 'esbuild'

    let envPlugin = {
      name: 'env',
      setup(build) {
        // Intercept import paths called "env" so esbuild doesn't attempt
        // to map them to a file system location. Tag them with the "env-ns"
        // namespace to reserve them for this plugin.
        build.onResolve({ filter: /^env$/ }, args => ({
          path: args.path,
          namespace: 'env-ns',
        }))

        // Load paths tagged with the "env-ns" namespace and behave as if
        // they point to a JSON file containing the environment variables.
        build.onLoad({ filter: /.*/, namespace: 'env-ns' }, () => ({
          contents: JSON.stringify(process.env),
          loader: 'json',
        }))
      },
    }

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      outfile: 'out.js',
      plugins: [envPlugin],
    })
    ```

    ``` go
    package main

    import "encoding/json"
    import "os"
    import "strings"
    import "github.com/evanw/esbuild/pkg/api"

    var envPlugin = api.Plugin{
      Name: "env",
      Setup: func(build api.PluginBuild) {
        // Intercept import paths called "env" so esbuild doesn't attempt
        // to map them to a file system location. Tag them with the "env-ns"
        // namespace to reserve them for this plugin.
        build.OnResolve(api.OnResolveOptions{Filter: `^env$`},
          func(args api.OnResolveArgs) (api.OnResolveResult, error) {
            return api.OnResolveResult{
              Path:      args.Path,
              Namespace: "env-ns",
            }, nil
          })

        // Load paths tagged with the "env-ns" namespace and behave as if
        // they point to a JSON file containing the environment variables.
        build.OnLoad(api.OnLoadOptions{Filter: `.*`, Namespace: "env-ns"},
          func(args api.OnLoadArgs) (api.OnLoadResult, error) {
            mappings := make(map[string]string)
            for _, item := range os.Environ() {
              if equals := strings.IndexByte(item, '='); equals != -1 {
                mappings[item[:equals]] = item[equals+1:]
              }
            }
            bytes, err := json.Marshal(mappings)
            if err != nil {
              return api.OnLoadResult{}, err
            }
            contents := string(bytes)
            return api.OnLoadResult{
              Contents: &contents,
              Loader:   api.LoaderJSON,
            }, nil
          })
      },
    }

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Outfile:     "out.js",
        Plugins:     []api.Plugin{envPlugin},
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    You would use it like this:

    ``` javascript
    import { PATH } from 'env'
    console.log(`PATH is ${PATH}`)
    ```
- name: Using Yarn Plug'n'Play
  id: getting-started/index#yarn-pnp
  summary: Yarn's Plug'n'Play package installation strategy is supported natively by esbuild
  belongs_to: Getting Started
  description: |-
    ## Using Yarn Plug'n'Play

    Yarn's [Plug'n'Play](https://yarnpkg.com/features/pnp/) package installation strategy is supported natively by esbuild. To use it, make sure you are running esbuild such that the [current working directory](../api/index#working-directory) contains Yarn's generated package manifest JavaScript file (either `.pnp.cjs` or `.pnp.js`). If a Yarn Plug'n'Play package manifest is detected, esbuild will automatically resolve package imports to paths inside the `.zip` files in Yarn's package cache, and will automatically extract these files on the fly during bundling.

    Because esbuild is written in Go, support for Yarn Plug'n'Play has been completely re-implemented in Go instead of relying on Yarn's JavaScript API. This allows Yarn Plug'n'Play package resolution to integrate well with esbuild's fully parallelized bundling pipeline for maximum speed. Note that Yarn's command-line interface adds a lot of unavoidable performance overhead to every command. For maximum esbuild performance, you may want to consider running esbuild without using Yarn's CLI (i.e. not using `yarn esbuild`). This can result in esbuild running 10x faster.
- name: Watch
  id: api/index#watch
  summary: Enabling watch mode tells esbuild to listen for changes on the file system and to automatically rebuild whenever a file changes that could invalidate the build
  belongs_to: API
  description: |-
    ### Watch

    *Supported by: [Build](#build)*

    Enabling watch mode tells esbuild to listen for changes on the file system and to automatically rebuild whenever a file changes that could invalidate the build. Using it looks like this:

    ``` sh
    esbuild app.js --outfile=out.js --bundle --watch
    [watch] build finished, watching for changes...
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let ctx = await esbuild.context({
      entryPoints: ['app.js'],
      outfile: 'out.js',
      bundle: true,
    })

    await ctx.watch()
    console.log('watching...')
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      ctx, err := api.Context(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Outfile:     "out.js",
        Bundle:      true,
        Write:       true,
      })
      if err != nil {
        os.Exit(1)
      }

      err2 := ctx.Watch(api.WatchOptions{})
      if err2 != nil {
        os.Exit(1)
      }
      fmt.Printf("watching...\n")

      // Returning from main() exits immediately in Go.
      // Block forever so we keep watching and don't exit.
      <-make(chan struct{})
    }
    ```

    If you want to stop watch mode at some point in the future, you can call `dispose` on the context object to terminate the file watcher:

    ``` sh
    # Use Ctrl+C to stop the CLI in watch mode
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    let ctx = await esbuild.context({
      entryPoints: ['app.js'],
      outfile: 'out.js',
      bundle: true,
    })

    await ctx.watch()
    console.log('watching...')

    await new Promise(r => setTimeout(r, 10 * 1000))
    await ctx.dispose()
    console.log('stopped watching')
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"
    import "os"
    import "time"

    func main() {
      ctx, err := api.Context(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Outfile:     "out.js",
        Bundle:      true,
        Write:       true,
      })
      if err != nil {
        os.Exit(1)
      }

      err2 := ctx.Watch(api.WatchOptions{})
      if err2 != nil {
        os.Exit(1)
      }
      fmt.Printf("watching...\n")

      time.Sleep(10 * time.Second)
      ctx.Dispose()
      fmt.Printf("stopped watching\n")
    }
    ```

    Watch mode in esbuild is implemented using polling instead of OS-specific file system APIs for portability. The polling system is designed to use relatively little CPU vs. a more traditional polling system that scans the whole directory tree at once. The file system is still scanned regularly but each scan only checks a random subset of your files, which means a change to a file will be picked up soon after the change is made but not necessarily instantly.

    With the current heuristics, large projects should be completely scanned around every 2 seconds so in the worst case it could take up to 2 seconds for a change to be noticed. However, after a change has been noticed the change's path goes on a short list of recently changed paths which are checked on every scan, so further changes to recently changed files should be noticed almost instantly.

    Note that it is still possible to implement watch mode yourself using esbuild's [rebuild](#rebuild) API and a file watcher library of your choice if you don't want to use a polling-based approach.

    If you are using the CLI, keep in mind that watch mode will be terminated when esbuild's stdin is closed. This prevents esbuild from accidentally outliving the parent process and unexpectedly continuing to consume resources on the system. If you have a use case that requires esbuild to continue to watch forever even when the parent process has finished, you may use `--watch=forever` instead of `--watch`.
- name: WebAssembly plugin
  id: plugins/index#webassembly-plugin
  summary: 'This example demonstrates: working with binary data, creating virtual modules using import statements, re-using the same path with different namespaces'
  belongs_to: Plugins
  description: |-
    ### WebAssembly plugin

    *This example demonstrates: working with binary data, creating virtual modules using import statements, re-using the same path with different namespaces.*

    This plugin allows you to import `.wasm` files into JavaScript code. It does not generate the WebAssembly files themselves; that can either be done by another tool or by modifying this example plugin to suit your needs. It enables the following workflow:

    ``` javascript
    import load from './example.wasm'
    load(imports).then(exports => { ... })
    ```

    When you import a `.wasm` file, this plugin generates a virtual JavaScript module in the `wasm-stub` namespace with a single function that loads the WebAssembly module exported as the default export. That stub module looks something like this:

    ``` javascript
    import wasm from '/path/to/example.wasm'
    export default (imports) =>
      WebAssembly.instantiate(wasm, imports).then(
        result => result.instance.exports)
    ```

    Then that stub module imports the WebAssembly file itself as another module in the `wasm-binary` namespace using esbuild's built-in [binary](../content-types/index#binary) loader. This means importing a `.wasm` file actually generates two virtual modules. Here's the code for the plugin:

    ``` javascript
    import * as esbuild from 'esbuild'
    import path from 'node:path'
    import fs from 'node:fs'

    let wasmPlugin = {
      name: 'wasm',
      setup(build) {
        // Resolve ".wasm" files to a path with a namespace
        build.onResolve({ filter: /\.wasm$/ }, args => {
          // If this is the import inside the stub module, import the
          // binary itself. Put the path in the "wasm-binary" namespace
          // to tell our binary load callback to load the binary file.
          if (args.namespace === 'wasm-stub') {
            return {
              path: args.path,
              namespace: 'wasm-binary',
            }
          }

          // Otherwise, generate the JavaScript stub module for this
          // ".wasm" file. Put it in the "wasm-stub" namespace to tell
          // our stub load callback to fill it with JavaScript.
          //
          // Resolve relative paths to absolute paths here since this
          // resolve callback is given "resolveDir", the directory to
          // resolve imports against.
          if (args.resolveDir === '') {
            return // Ignore unresolvable paths
          }
          return {
            path: path.isAbsolute(args.path) ? args.path : path.join(args.resolveDir, args.path),
            namespace: 'wasm-stub',
          }
        })

        // Virtual modules in the "wasm-stub" namespace are filled with
        // the JavaScript code for compiling the WebAssembly binary. The
        // binary itself is imported from a second virtual module.
        build.onLoad({ filter: /.*/, namespace: 'wasm-stub' }, async (args) => ({
          contents: `import wasm from ${JSON.stringify(args.path)}
            export default (imports) =>
              WebAssembly.instantiate(wasm, imports).then(
                result => result.instance.exports)`,
        }))

        // Virtual modules in the "wasm-binary" namespace contain the
        // actual bytes of the WebAssembly file. This uses esbuild's
        // built-in "binary" loader instead of manually embedding the
        // binary data inside JavaScript code ourselves.
        build.onLoad({ filter: /.*/, namespace: 'wasm-binary' }, async (args) => ({
          contents: await fs.promises.readFile(args.path),
          loader: 'binary',
        }))
      },
    }

    await esbuild.build({
      entryPoints: ['app.js'],
      bundle: true,
      outfile: 'out.js',
      plugins: [wasmPlugin],
    })
    ```

    ``` go
    package main

    import "encoding/json"
    import "io/ioutil"
    import "os"
    import "path/filepath"
    import "github.com/evanw/esbuild/pkg/api"

    var wasmPlugin = api.Plugin{
      Name: "wasm",
      Setup: func(build api.PluginBuild) {
        // Resolve ".wasm" files to a path with a namespace
        build.OnResolve(api.OnResolveOptions{Filter: `\.wasm$`},
          func(args api.OnResolveArgs) (api.OnResolveResult, error) {
            // If this is the import inside the stub module, import the
            // binary itself. Put the path in the "wasm-binary" namespace
            // to tell our binary load callback to load the binary file.
            if args.Namespace == "wasm-stub" {
              return api.OnResolveResult{
                Path:      args.Path,
                Namespace: "wasm-binary",
              }, nil
            }

            // Otherwise, generate the JavaScript stub module for this
            // ".wasm" file. Put it in the "wasm-stub" namespace to tell
            // our stub load callback to fill it with JavaScript.
            //
            // Resolve relative paths to absolute paths here since this
            // resolve callback is given "resolveDir", the directory to
            // resolve imports against.
            if args.ResolveDir == "" {
              return api.OnResolveResult{}, nil // Ignore unresolvable paths
            }
            if !filepath.IsAbs(args.Path) {
              args.Path = filepath.Join(args.ResolveDir, args.Path)
            }
            return api.OnResolveResult{
              Path:      args.Path,
              Namespace: "wasm-stub",
            }, nil
          })

        // Virtual modules in the "wasm-stub" namespace are filled with
        // the JavaScript code for compiling the WebAssembly binary. The
        // binary itself is imported from a second virtual module.
        build.OnLoad(api.OnLoadOptions{Filter: `.*`, Namespace: "wasm-stub"},
          func(args api.OnLoadArgs) (api.OnLoadResult, error) {
            bytes, err := json.Marshal(args.Path)
            if err != nil {
              return api.OnLoadResult{}, err
            }
            contents := `import wasm from ` + string(bytes) + `
              export default (imports) =>
                WebAssembly.instantiate(wasm, imports).then(
                  result => result.instance.exports)`
            return api.OnLoadResult{Contents: &contents}, nil
          })

        // Virtual modules in the "wasm-binary" namespace contain the
        // actual bytes of the WebAssembly file. This uses esbuild's
        // built-in "binary" loader instead of manually embedding the
        // binary data inside JavaScript code ourselves.
        build.OnLoad(api.OnLoadOptions{Filter: `.*`, Namespace: "wasm-binary"},
          func(args api.OnLoadArgs) (api.OnLoadResult, error) {
            bytes, err := ioutil.ReadFile(args.Path)
            if err != nil {
              return api.OnLoadResult{}, err
            }
            contents := string(bytes)
            return api.OnLoadResult{
              Contents: &contents,
              Loader:   api.LoaderBinary,
            }, nil
          })
      },
    }

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Bundle:      true,
        Outfile:     "out.js",
        Plugins:     []api.Plugin{wasmPlugin},
        Write:       true,
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    The plugin works in multiple steps. First, a resolve callback captures `.wasm` paths in normal modules and moves them to the `wasm-stub` namespace. Then load callback for the `wasm-stub` namespace generates a JavaScript stub module that exports the loader function and imports the `.wasm` path. This invokes the resolve callback again which this time moves the path to the `wasm-binary` namespace. Then the second load callback for the `wasm-binary` namespace causes the WebAssembly file to be loaded using the `binary` loader, which tells esbuild to embed the file itself in the bundle.
- name: Why is esbuild fast?
  id: faq/index#why-is-esbuild-fast
  summary: It's written in Go and compiles to native code
  belongs_to: FAQ
  description: |-
    ## Why is esbuild fast?

    Several reasons:

    - It's written in [Go](https://go.dev/) and compiles to native code.

      Most other bundlers are written in JavaScript, but a command-line application is a worst-case performance situation for a JIT-compiled language. Every time you run your bundler, the JavaScript VM is seeing your bundler's code for the first time without any optimization hints. While esbuild is busy parsing your JavaScript, node is busy parsing your bundler's JavaScript. By the time node has finished parsing your bundler's code, esbuild might have already exited and your bundler hasn't even started bundling yet.

      In addition, Go is designed from the core for parallelism while JavaScript is not. Go has shared memory between threads while JavaScript has to serialize data between threads. Both Go and JavaScript have parallel garbage collectors, but Go's heap is shared between all threads while JavaScript has a separate heap per JavaScript thread. This seems to cut the amount of parallelism that's possible with JavaScript worker threads in half [according to my testing](https://github.com/evanw/esbuild/issues/111#issuecomment-719910381), presumably since half of your CPU cores are busy collecting garbage for the other half.

    - Parallelism is used heavily.

      The algorithms inside esbuild are carefully designed to fully saturate all available CPU cores when possible. There are roughly three phases: parsing, linking, and code generation. Parsing and code generation are most of the work and are fully parallelizable (linking is an inherently serial task for the most part). Since all threads share memory, work can easily be shared when bundling different entry points that import the same JavaScript libraries. Most modern computers have many cores so parallelism is a big win.

    - Everything in esbuild is written from scratch.

      There are a lot of performance benefits with writing everything yourself instead of using 3rd-party libraries. You can have performance in mind from the beginning, you can make sure everything uses consistent data structures to avoid expensive conversions, and you can make wide architectural changes whenever necessary. The drawback is of course that it's a lot of work.

      For example, many bundlers use the official TypeScript compiler as a parser. But it was built to serve the goals of the TypeScript compiler team and they do not have performance as a top priority. Their code makes pretty heavy use of [megamorphic object shapes](https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html) and unnecessary [dynamic property accesses](https://github.com/microsoft/TypeScript/issues/39247) (both well-known JavaScript speed bumps). And the TypeScript parser appears to still run the type checker even when type checking is disabled. None of these are an issue with esbuild's custom TypeScript parser.

    - Memory is used efficiently.

      Compilers are ideally mostly O(n) complexity in the length of the input. So if you are processing a lot of data, memory access speed is likely going to heavily affect performance. The fewer passes you have to make over your data (and also the fewer different representations you need to transform your data into), the faster your compiler will go.

      For example, esbuild only touches the whole JavaScript AST three times:

      1.  A pass for lexing, parsing, scope setup, and declaring symbols
      2.  A pass for binding symbols, minifying syntax, JSX/TS to JS, and ESNext-to-ES2015
      3.  A pass for minifying identifiers, minifying whitespace, generating code, and generating source maps

      This maximizes reuse of AST data while it's still hot in the CPU cache. Other bundlers do these steps in separate passes instead of interleaving them. They may also convert between data representations to glue multiple libraries together (e.g. string→TS→JS→string, then string→JS→older JS→string, then string→JS→minified JS→string) which uses more memory and slows things down.

      Another benefit of Go is that it can store things compactly in memory, which enables it to use less memory and fit more in the CPU cache. All object fields have types and fields are packed tightly together so e.g. several boolean flags only take one byte each. Go also has value semantics and can embed one object directly in another so it comes "for free" without another allocation. JavaScript doesn't have these features and also has other drawbacks such as JIT overhead (e.g. hidden class slots) and inefficient representations (e.g. non-integer numbers are heap-allocated with pointers).

    Each one of these factors is only a somewhat significant speedup, but together they can result in a bundler that is multiple orders of magnitude faster than other bundlers commonly in use today.
- name: Working directory
  id: api/index#working-directory
  summary: This API option lets you specify the working directory to use for the build
  belongs_to: API
  description: |-
    ### Working directory

    *Supported by: [Build](#build)*

    This API option lets you specify the working directory to use for the build. It normally defaults to the current [working directory](https://en.wikipedia.org/wiki/Working_directory) of the process you are using to call esbuild's API. The working directory is used by esbuild for a few different things including resolving relative paths given as API options to absolute paths and pretty-printing absolute paths as relative paths in log messages. Here is how to customize esbuild's working directory:

    ``` sh
    cd "/var/tmp/custom/working/directory"
    ```

    ``` javascript
    import * as esbuild from 'esbuild'

    await esbuild.build({
      entryPoints: ['file.js'],
      absWorkingDir: '/var/tmp/custom/working/directory',
      outfile: 'out.js',
    })
    ```

    ``` go
    package main

    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints:   []string{"file.js"},
        AbsWorkingDir: "/var/tmp/custom/working/directory",
        Outfile:       "out.js",
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }
    }
    ```

    Note: If you are using [Yarn Plug'n'Play](https://yarnpkg.com/features/pnp/), keep in mind that this working directory is used to search for Yarn's manifest file. If you are running esbuild from an unrelated directory, you will have to set this working directory to the directory containing the manifest file (or one of its child directories) for the manifest file to be found by esbuild.
- name: Write
  id: api/index#write
  summary: The build API call can either write to the file system directly or return the files that would have been written as in-memory buffers
  belongs_to: API
  description: |-
    ### Write

    *Supported by: [Build](#build)*

    The build API call can either write to the file system directly or return the files that would have been written as in-memory buffers. By default the CLI and JavaScript APIs write to the file system and the Go API doesn't. To use the in-memory buffers:

    ``` javascript
    import * as esbuild from 'esbuild'

    let result = await esbuild.build({
      entryPoints: ['app.js'],
      sourcemap: 'external',
      write: false,
      outdir: 'out',
    })

    for (let out of result.outputFiles) {
      console.log(out.path, out.contents, out.hash, out.text)
    }
    ```

    ``` go
    package main

    import "fmt"
    import "github.com/evanw/esbuild/pkg/api"
    import "os"

    func main() {
      result := api.Build(api.BuildOptions{
        EntryPoints: []string{"app.js"},
        Sourcemap:   api.SourceMapExternal,
        Write:       false,
        Outdir:      "out",
      })

      if len(result.Errors) > 0 {
        os.Exit(1)
      }

      for _, out := range result.OutputFiles {
        fmt.Printf("%v %v %s\n", out.Path, out.Contents, out.Hash)
      }
    }
    ```

    The `hash` property is a hash of the `contents` field and has been provided for convenience. The hash algorithm (currently [XXH64](https://xxhash.com/)) is implementation-dependent and may be changed at any time in between esbuild versions.
- name: Your first bundle
  id: getting-started/index#your-first-bundle
  summary: This is a quick real-world example of what esbuild is capable of and how to use it
  belongs_to: Getting Started
  description: |-
    ## Your first bundle

    This is a quick real-world example of what esbuild is capable of and how to use it. First, install the `react` and `react-dom` packages:

    ``` javascript
    npm install react react-dom
    ```

    Then create a file called `app.jsx` containing the following code:

    ``` javascript
    import * as React from 'react'
    import * as Server from 'react-dom/server'

    let Greet = () => <h1>Hello, world!</h1>
    console.log(Server.renderToString(<Greet />))
    ```

    Finally, tell esbuild to bundle the file:

    ``` javascript
    ./node_modules/.bin/esbuild app.jsx --bundle --outfile=out.js
    ```

    ``` javascript
    .\node_modules\.bin\esbuild app.jsx --bundle --outfile=out.js
    ```

    This should have created a file called `out.js` containing your code and the React library bundled together. The code is completely self-contained and no longer depends on your `node_modules` directory. If you run the code using `node out.js`, you should see something like this:

    ``` javascript
    <h1 data-reactroot="">Hello, world!</h1>
    ```

    Notice that esbuild also converted JSX syntax to JavaScript without any configuration other than the `.jsx` extension. While esbuild can be configured, it attempts to have reasonable defaults so that many common situations work automatically. If you would like to use JSX syntax in `.js` files instead, you can tell esbuild to allow this using the `--loader:.js=jsx` flag. You can read more about the available configuration options in the [API documentation](../api/index).
