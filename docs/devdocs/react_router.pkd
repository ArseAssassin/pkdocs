---
name: React Router
slug: react_router
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © React Training 2015-2019
  © Remix Software 2020-2022
  Licensed under the MIT License (MIT).
  https://reactrouterdotcom.fly.dev/docs/en/v6
homepage: https://reactrouterdotcom.fly.dev/

---
- name: <BrowserRouter>
  id: router-components/browser-router
  summary: A <BrowserRouter> stores the current location in the browser's address bar using clean URLs and navigates using the browser's built-in history stack
  description: "# `<BrowserRouter>`\n\nType declaration\n\n``` javascript\ndeclare function BrowserRouter(\n  props: BrowserRouterProps\n): React.ReactElement;\n\ninterface BrowserRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  window?: Window;\n}\n```\n\nA `<BrowserRouter>` stores the current location in the browser's address bar using clean URLs and navigates using the browser's built-in history stack.\n\n`<BrowserRouter window>` defaults to using the current [document's `defaultView`](https://developer.mozilla.org/en-US/docs/Web/API/Document/defaultView), but it may also be used to track changes to another window's URL, in an `<iframe>`, for example.\n\n``` javascript\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { BrowserRouter } from \"react-router-dom\";\n\nReactDOM.render(\n  <BrowserRouter>\n    {/* The rest of your app goes here */}\n  </BrowserRouter>,\n  root\n);\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/router-components/browser-router](https://reactrouterdotcom.fly.dev/docs/en/v6/router-components/browser-router)"
- name: <Form>
  id: components/form
  summary: The Form component is a wrapper around a plain HTML form that emulates the browser for client side routing and data mutations
  description: "# `<Form>`\n\nThe Form component is a wrapper around a plain HTML [form](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form) that emulates the browser for client side routing and data mutations. It is *not* a form validation/state management library like you might be used to in the React ecosystem (for that, we recommend the browser's built in [HTML Form Validation](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation) and data validation on your backend server).\n\n``` javascript\nimport { Form } from \"react-router-dom\";\n\nfunction NewEvent() {\n  return (\n    <Form method=\"post\" action=\"/events\">\n      <input type=\"text\" name=\"title\" />\n      <input type=\"text\" name=\"description\" />\n      <button type=\"submit\">Create</button>\n    </Form>\n  );\n}\n```\n\nMake sure your inputs have names or else the `FormData` will not include that field's value.\n\nAll of this will trigger state updates to any rendered [`useNavigation`](../hooks/use-navigation) hooks so you can build pending indicators and optimistic UI while the async operations are in-flight.\n\nIf the form doesn't *feel* like navigation, you probably want [`useFetcher`](../hooks/use-fetcher).\n\n## `action`\n\nThe url to which the form will be submitted, just like [HTML form action](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#attr-action). The only difference is the default action. With HTML forms, it defaults to the full URL. With `<Form>`, it defaults to the relative URL of the closest route in context.\n\nConsider the following routes and components:\n\n``` javascript\nfunction ProjectsLayout() {\n  return (\n    <>\n      <Form method=\"post\" />\n      <Outlet />\n    </>\n  );\n}\n\nfunction ProjectsPage() {\n  return <Form method=\"post\" />;\n}\n\n<DataBrowserRouter>\n  <Route\n    path=\"/projects\"\n    element={<ProjectsLayout />}\n    action={ProjectsLayout.action}\n  >\n    <Route\n      path=\":projectId\"\n      element={<ProjectPage />}\n      action={ProjectsPage.action}\n    />\n  </Route>\n</DataBrowserRouter>;\n```\n\nIf the the current URL is `\"/projects/123\"`, the form inside the child route, `ProjectsPage`, will have a default action as you might expect: `\"/projects/123\"`. In this case, where the route is the deepest matching route, both `<Form>` and plain HTML forms have the same result.\n\nBut the form inside of `ProjectsLayout` will point to `\"/projects\"`, not the full URL. In other words, it points to the matching segment of the URL for the route in which the form is rendered.\n\nThis helps with portability as well as co-location of forms and their action handlers when if you add some convention around your route modules.\n\nIf you need to post to a different route, then add an action prop:\n\n``` javascript\n<Form action=\"/projects/new\" method=\"post\" />\n```\n\n**See also:**\n\n- [Index Search Param](../guides/index-search-param) (index vs parent route disambiguation)\n\n## `method`\n\nThis determines the [HTTP verb](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) to be used. The same as plain HTML [form method](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#attr-method), except it also supports \"put\", \"patch\", and \"delete\" in addition to \"get\" and \"post\". The default is \"get\".\n\n### GET submissions\n\nThe default method is \"get\". Get submissions *will not call an action*. Get submissions are the same as a normal navigation (user clicks a link) except the user gets to supply the search params that go to the URL from the form.\n\n``` javascript\n<Form method=\"get\" action=\"/products\">\n  <input\n    aria-label=\"search products\"\n    type=\"text\"\n    name=\"q\"\n  />\n  <button type=\"submit\">Search</button>\n</Form>\n```\n\nLet's say the user types in \"running shoes\" and submits the form. React Router emulates the browser and will serialize the form into [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) and then navigate the user to `\"/products?q=running+shoes\"`. It's as if you rendered a `<Link to=\"/products?q=running+shoes\">` as the developer, but instead you let the user supply the query string dynamically.\n\nYour route loader can access these values most conveniently by creating a new [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL) from the `request.url` and then load the data.\n\n``` javascript\n<Route\n  path=\"/products\"\n  loader={async ({ request }) => {\n    let url = new URL(request.url);\n    let searchTerm = url.searchParams.get(\"q\");\n    return fakeSearchProducts(searchTerm);\n  }}\n/>\n```\n\n### Mutation Submissions\n\nAll other methods are \"mutation submissions\", meaning you intend to change something about your data with POST, PUT, PATCH, or DELETE. Note that plain HTML forms only support \"post\" and \"get\", we tend to stick to those two as well.\n\nWhen the user submits the form, React Router will match the `action` to the app's routes and call the `<Route action>` with the serialized [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData). When the action completes, all of the loader data on the page will automatically revalidate to keep your UI in sync with your data.\n\nThe method will be available on [`request.method`](https://developer.mozilla.org/en-US/docs/Web/API/Request/method) inside the route action that is called. You can use this to instruct your data abstractions about the intent of the submission.\n\n``` javascript\n<Route\n  path=\"/projects/:id\"\n  element={<Project />}\n  loader={async ({ params }) => {\n    return fakeLoadProject(params.id)\n  }}\n  action={async ({ request, params }) => {\n    switch (request.method) {\n      case \"put\": {\n        let formData = await request.formData();\n        let name = formData.get(\"projectName\");\n        return fakeUpdateProject(name);\n      }\n      case \"delete\": {\n        return fakeDeleteProject(params.id);\n      }\n      default {\n        throw new Response(\"\", { status: 405 })\n      }\n    }\n  }}\n/>;\n\nfunction Project() {\n  let project = useLoaderData();\n\n  return (\n    <>\n      <Form method=\"put\">\n        <input\n          type=\"text\"\n          name=\"projectName\"\n          defaultValue={project.name}\n        />\n        <button type=\"submit\">Update Project</button>\n      </Form>\n\n      <Form method=\"delete\">\n        <button type=\"submit\">Delete Project</button>\n      </Form>\n    </>\n  );\n}\n```\n\nAs you can see, both forms submit to the same route but you can use the `request.method` to branch on what you intend to do. After the actions completes, the `loader` will be revalidated and the UI will automatically synchronize with the new data.\n\n## `replace`\n\nInstructs the form to replace the current entry in the history stack, instead of pushing the new entry.\n\n``` javascript\n<Form replace />\n```\n\nThe default behavior is conditional on the form `method`:\n\n- `get` defaults to `false`\n- every other method defaults to `true` if your `action` is successful\n- if your `action` redirects or throws, then it will still push by default\n\nWe've found with `get` you often want the user to be able to click \"back\" to see the previous search results/filters, etc. But with the other methods the default is `true` to avoid the \"are you sure you want to resubmit the form?\" prompt. Note that even if `replace={false}` React Router *will not* resubmit the form when the back button is clicked and the method is post, put, patch, or delete.\n\nIn other words, this is really only useful for GET submissions and you want to avoid the back button showing the previous results.\n\n## `relative`\n\nBy default, paths are relative to the route hierarchy, so `..` will go up one `Route` level. Occasionally, you may find that you have matching URL patterns that do not make sense to be nested, and you're prefer to use relative *path* routing. You can opt into this behavior with `<Form to=\"../some/where\" relative=\"path\">`\n\n## `reloadDocument`\n\nInstructs the form to skip React Router and submit the form with the browser's built in behavior.\n\n``` javascript\n<Form reloadDocument />\n```\n\nThis is recommended over `<form>` so you can get the benefits of default and relative `action`, but otherwise is the same as a plain HTML form.\n\nWithout a framework like [Remix](https://remix.run), or your own server handling of posts to routes, this isn't very useful.\n\nSee also:\n\n- [`useNavigation`](../hooks/use-navigation)\n- [`useActionData`](../hooks/use-action-data)\n- [`useSubmit`](../hooks/use-submit)\n\n# Examples\n\nTODO: More examples\n\n## Large List Filtering\n\nA common use case for GET submissions is filtering a large list, like ecommerce and travel booking sites.\n\n``` javascript\nfunction FilterForm() {\n  return (\n    <Form method=\"get\" action=\"/slc/hotels\">\n      <select name=\"sort\">\n        <option value=\"price\">Price</option>\n        <option value=\"stars\">Stars</option>\n        <option value=\"distance\">Distance</option>\n      </select>\n\n      <fieldset>\n        <legend>Star Rating</legend>\n        <label>\n          <input type=\"radio\" name=\"stars\" value=\"5\" />{\" \"}\n          ★★★★★\n        </label>\n        <label>\n          <input type=\"radio\" name=\"stars\" value=\"4\" /> ★★★★\n        </label>\n        <label>\n          <input type=\"radio\" name=\"stars\" value=\"3\" /> ★★★\n        </label>\n        <label>\n          <input type=\"radio\" name=\"stars\" value=\"2\" /> ★★\n        </label>\n        <label>\n          <input type=\"radio\" name=\"stars\" value=\"1\" /> ★\n        </label>\n      </fieldset>\n\n      <fieldset>\n        <legend>Amenities</legend>\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"amenities\"\n            value=\"pool\"\n          />{\" \"}\n          Pool\n        </label>\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"amenities\"\n            value=\"exercise\"\n          />{\" \"}\n          Exercise Room\n        </label>\n      </fieldset>\n      <button type=\"submit\">Search</button>\n    </Form>\n  );\n}\n```\n\nWhen the user submits this form, the form will be serialized to the URL with something like this, depending on the user's selections:\n\nYou can access those values from the `request.url`\n\n``` javascript\n<Route\n  path=\"/:city/hotels\"\n  loader={async ({ request }) => {\n    let url = new URL(request.url);\n    let sort = url.searchParams.get(\"sort\");\n    let stars = url.searchParams.get(\"stars\");\n    let amenities = url.searchParams.getAll(\"amenities\");\n    return fakeGetHotels({ sort, stars, amenities });\n  }}\n/>\n```\n\n**See also:**\n\n- [useSubmit](../hooks/use-submit)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/components/form](https://reactrouterdotcom.fly.dev/docs/en/v6/components/form)"
- name: <HashRouter>
  id: router-components/hash-router
  summary: <HashRouter> is for use in web browsers when the URL should not (or cannot) be sent to the server for some reason
  description: "# `<HashRouter>`\n\nType declaration\n\n``` javascript\ndeclare function HashRouter(\n  props: HashRouterProps\n): React.ReactElement;\n\ninterface HashRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  window?: Window;\n}\n```\n\n`<HashRouter>` is for use in web browsers when the URL should not (or cannot) be sent to the server for some reason. This may happen in some shared hosting scenarios where you do not have full control over the server. In these situations, `<HashRouter>` makes it possible to store the current location in the `hash` portion of the current URL, so it is never sent to the server.\n\n`<HashRouter window>` defaults to using the current [document's `defaultView`](https://developer.mozilla.org/en-US/docs/Web/API/Document/defaultView), but it may also be used to track changes to another window's URL, in an `<iframe>`, for example.\n\n``` javascript\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { HashRouter } from \"react-router-dom\";\n\nReactDOM.render(\n  <HashRouter>\n    {/* The rest of your app goes here */}\n  </HashRouter>,\n  root\n);\n```\n\nWe strongly recommend you do not use `HashRouter` unless you absolutely have to.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/router-components/hash-router](https://reactrouterdotcom.fly.dev/docs/en/v6/router-components/hash-router)"
- name: <Link>
  id: components/link
  summary: This is the web version of <Link>. For the React Native version, go here
  description: "# `<Link>`\n\nThis is the web version of `<Link>`. For the React Native version, [go here](link-native).\n\nType declaration\n\n``` javascript\ndeclare function Link(props: LinkProps): React.ReactElement;\n\ninterface LinkProps\n  extends Omit<\n    React.AnchorHTMLAttributes<HTMLAnchorElement>,\n    \"href\"\n  > {\n  replace?: boolean;\n  state?: any;\n  to: To;\n  reloadDocument?: boolean;\n}\n\ntype To = string | Partial<Path>;\n```\n\nA `<Link>` is an element that lets the user navigate to another page by clicking or tapping on it. In `react-router-dom`, a `<Link>` renders an accessible `<a>` element with a real `href` that points to the resource it's linking to. This means that things like right-clicking a `<Link>` work as you'd expect. You can use `<Link reloadDocument>` to skip client side routing and let the browser handle the transition normally (as if it were an `<a href>`).\n\n``` javascript\nimport * as React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nfunction UsersIndexPage({ users }) {\n  return (\n    <div>\n      <h1>Users</h1>\n      <ul>\n        {users.map((user) => (\n          <li key={user.id}>\n            <Link to={user.id}>{user.name}</Link>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\nA relative `<Link to>` value (that does not begin with `/`) resolves relative to the parent route, which means that it builds upon the URL path that was matched by the route that rendered that `<Link>`. It may contain `..` to link to routes further up the hierarchy. In these cases, `..` works exactly like the command-line `cd` function; each `..` removes one segment of the parent path.\n\n`<Link to>` with a `..` behaves differently from a normal `<a href>` when the current URL ends with `/`. `<Link to>` ignores the trailing slash, and removes one URL segment for each `..`. But an `<a href>` value handles `..` differently when the current URL ends with `/` vs when it does not.\n\n## `relative`\n\nBy default, links are relative to the route hierarchy, so `..` will go up one `Route` level. Occasionally, you may find that you have matching URL patterns that do not make sense to be nested, and you're prefer to use relative *path* routing. You can opt into this behavior with `relative`:\n\n``` javascript\n// Contact and EditContact do not share additional UI layout\n<Route path=\"/\" element={<Layout />}>\n  <Route path=\"contacts/:id\" element={<Contact />} />\n  <Route\n    path=\"contacts/:id/edit\"\n    element={<EditContact />}\n  />\n</Route>;\n\nfunction EditContact() {\n  // Since Contact is not a parent of EditContact we need to go up one level\n  // in the path, instead of one level in the Route hierarchy\n  return (\n    <Link to=\"..\" relative=\"path\">\n      Cancel\n    </Link>\n  );\n}\n```\n\n## `preventScrollReset`\n\nIf you are using [`<ScrollRestoration>`](scroll-restoration), this lets you prevent the scroll position from being reset to the top of the window when the link is clicked.\n\n``` javascript\n<Link to=\"?tab=one\" preventScrollReset={true} />\n```\n\nThis does not prevent the scroll position from being restored when the user comes back to the location with the back/forward buttons, it just prevents the reset when the user clicks the link.\n\nAn example when you might want this behavior is a list of tabs that manipulate the url search params that aren't at the top of the page. You wouldn't want the scroll position to jump up to the top because it might scroll the toggled content out of the viewport!\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/components/link](https://reactrouterdotcom.fly.dev/docs/en/v6/components/link)"
- name: <Link> (React Native)
  id: components/link-native
  summary: This is the React Native version of <Link>. For the web version, go here
  description: "# `<Link>` (React Native)\n\nThis is the React Native version of `<Link>`. For the web version, [go here](link).\n\nType declaration\n\n``` javascript\ndeclare function Link(props: LinkProps): React.ReactElement;\n\ninterface LinkProps extends TouchableHighlightProps {\n  children?: React.ReactNode;\n  onPress?(event: GestureResponderEvent): void;\n  replace?: boolean;\n  state?: any;\n  to: To;\n}\n```\n\nA `<Link>` is an element that lets the user navigate to another view by tapping it, similar to how `<a>` elements work in a web app. In `react-router-native`, a `<Link>` renders a `TouchableHighlight`. To override default styling and behaviour, please refer to the [Props reference for `TouchableHighlight`](https://reactnative.dev/docs/touchablehighlight#props).\n\n``` javascript\nimport * as React from \"react\";\nimport { View, Text } from \"react-native\";\nimport { Link } from \"react-router-native\";\n\nfunction Home() {\n  return (\n    <View>\n      <Text>Welcome!</Text>\n      <Link to=\"/profile\">\n        <Text>Visit your profile</Text>\n      </Link>\n    </View>\n  );\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/components/link-native](https://reactrouterdotcom.fly.dev/docs/en/v6/components/link-native)"
- name: <MemoryRouter>
  id: router-components/memory-router
  summary: A <MemoryRouter> stores its locations internally in an array
  description: "# `<MemoryRouter>`\n\nType declaration\n\n``` javascript\ndeclare function MemoryRouter(\n  props: MemoryRouterProps\n): React.ReactElement;\n\ninterface MemoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n}\n```\n\nA `<MemoryRouter>` stores its locations internally in an array. Unlike `<BrowserHistory>` and `<HashHistory>`, it isn't tied to an external source, like the history stack in a browser. This makes it ideal for scenarios where you need complete control over the history stack, like testing.\n\n- `<MemoryRouter initialEntries>` defaults to `[\"/\"]` (a single entry at the root `/` URL)\n- `<MemoryRouter initialIndex>` defaults to the last index of `initialEntries`\n\n> **Tip:**\n>\n> Most of React Router's tests are written using a `<MemoryRouter>` as the source of truth, so you can see some great examples of using it by just [browsing through our tests](https://github.com/remix-run/react-router/tree/main/packages/react-router/__tests__).\n\n``` javascript\nimport * as React from \"react\";\nimport { create } from \"react-test-renderer\";\nimport {\n  MemoryRouter,\n  Routes,\n  Route,\n} from \"react-router-dom\";\n\ndescribe(\"My app\", () => {\n  it(\"renders correctly\", () => {\n    let renderer = create(\n      <MemoryRouter initialEntries={[\"/users/mjackson\"]}>\n        <Routes>\n          <Route path=\"users\" element={<Users />}>\n            <Route path=\":id\" element={<UserProfile />} />\n          </Route>\n        </Routes>\n      </MemoryRouter>\n    );\n\n    expect(renderer.toJSON()).toMatchSnapshot();\n  });\n});\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/router-components/memory-router](https://reactrouterdotcom.fly.dev/docs/en/v6/router-components/memory-router)"
- name: <NativeRouter>
  id: router-components/native-router
  summary: <NativeRouter> is the recommended interface for running React Router in a React Native app
  description: "# `<NativeRouter>`\n\nType declaration\n\n``` javascript\ndeclare function NativeRouter(\n  props: NativeRouterProps\n): React.ReactElement;\n\ninterface NativeRouterProps extends MemoryRouterProps {}\n```\n\n`<NativeRouter>` is the recommended interface for running React Router in a [React Native](https://reactnative.dev) app.\n\n- `<NativeRouter initialEntries>` defaults to `[\"/\"]` (a single entry at the root `/` URL)\n- `<NativeRouter initialIndex>` defaults to the last index of `initialEntries`\n\n``` javascript\nimport * as React from \"react\";\nimport { NativeRouter } from \"react-router-native\";\n\nfunction App() {\n  return (\n    <NativeRouter>\n      {/* The rest of your app goes here */}\n    </NativeRouter>\n  );\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/router-components/native-router](https://reactrouterdotcom.fly.dev/docs/en/v6/router-components/native-router)"
- name: <Navigate>
  id: components/navigate
  summary: A <Navigate> element changes the current location when it is rendered
  description: "# `<Navigate>`\n\nType declaration\n\n``` javascript\ndeclare function Navigate(props: NavigateProps): null;\n\ninterface NavigateProps {\n  to: To;\n  replace?: boolean;\n  state?: any;\n  relative?: RelativeRoutingType;\n}\n```\n\nA `<Navigate>` element changes the current location when it is rendered. It's a component wrapper around [`useNavigate`](../hooks/use-navigate), and accepts all the same arguments as props.\n\nHaving a component-based version of the `useNavigate` hook makes it easier to use this feature in a [`React.Component`](https://reactjs.org/docs/react-component.html) subclass where hooks are not able to be used.\n\n``` javascript\nimport * as React from \"react\";\nimport { Navigate } from \"react-router-dom\";\n\nclass LoginForm extends React.Component {\n  state = { user: null, error: null };\n\n  async handleSubmit(event) {\n    event.preventDefault();\n    try {\n      let user = await login(event.target);\n      this.setState({ user });\n    } catch (error) {\n      this.setState({ error });\n    }\n  }\n\n  render() {\n    let { user, error } = this.state;\n    return (\n      <div>\n        {error && <p>{error.message}</p>}\n        {user && (\n          <Navigate to=\"/dashboard\" replace={true} />\n        )}\n        <form\n          onSubmit={(event) => this.handleSubmit(event)}\n        >\n          <input type=\"text\" name=\"username\" />\n          <input type=\"password\" name=\"password\" />\n        </form>\n      </div>\n    );\n  }\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/components/navigate](https://reactrouterdotcom.fly.dev/docs/en/v6/components/navigate)"
- name: <NavLink>
  id: components/nav-link
  summary: A <NavLink> is a special kind of <Link> that knows whether or not it is "active". This is useful when building a navigation menu such as a breadcrumb or a set of tabs where you'd like to show which of them is currently selected
  description: "# `<NavLink>`\n\nType declaration\n\n``` javascript\ndeclare function NavLink(\n  props: NavLinkProps\n): React.ReactElement;\n\ninterface NavLinkProps\n  extends Omit<\n    LinkProps,\n    \"className\" | \"style\" | \"children\"\n  > {\n  caseSensitive?: boolean;\n  children?:\n    | React.ReactNode\n    | ((props: { isActive: boolean }) => React.ReactNode);\n  className?:\n    | string\n    | ((props: {\n        isActive: boolean;\n      }) => string | undefined);\n  end?: boolean;\n  style?:\n    | React.CSSProperties\n    | ((props: {\n        isActive: boolean;\n      }) => React.CSSProperties);\n}\n```\n\nA `<NavLink>` is a special kind of [`<Link>`](link) that knows whether or not it is \"active\". This is useful when building a navigation menu such as a breadcrumb or a set of tabs where you'd like to show which of them is currently selected. It also provides useful context for assistive technology like screen readers.\n\nBy default, an `active` class is added to a `<NavLink>` component when it is active. This provides the same simple styling mechanism for most users who are upgrading from v5. One difference as of `v6.0.0-beta.3` is that `activeClassName` and `activeStyle` have been removed from `NavLinkProps`. Instead, you can pass a function to either `style` or `className` that will allow you to customize the inline styling or the class string based on the component's active state. You can also pass a function as children to customize the content of the `<NavLink>` component based on their active state, specially useful to change styles on internal elements.\n\n``` javascript\nimport * as React from \"react\";\nimport { NavLink } from \"react-router-dom\";\n\nfunction NavList() {\n  // This styling will be applied to a <NavLink> when the\n  // route that it links to is currently selected.\n  let activeStyle = {\n    textDecoration: \"underline\",\n  };\n\n  let activeClassName = \"underline\";\n\n  return (\n    <nav>\n      <ul>\n        <li>\n          <NavLink\n            to=\"messages\"\n            style={({ isActive }) =>\n              isActive ? activeStyle : undefined\n            }\n          >\n            Messages\n          </NavLink>\n        </li>\n        <li>\n          <NavLink\n            to=\"tasks\"\n            className={({ isActive }) =>\n              isActive ? activeClassName : undefined\n            }\n          >\n            Tasks\n          </NavLink>\n        </li>\n        <li>\n          <NavLink to=\"tasks\">\n            {({ isActive }) => (\n              <span\n                className={\n                  isActive ? activeClassName : undefined\n                }\n              >\n                Tasks\n              </span>\n            )}\n          </NavLink>\n        </li>\n      </ul>\n    </nav>\n  );\n}\n```\n\nIf you prefer the v5 API, you can create your own `<NavLink />` as a wrapper component:\n\n``` javascript\nimport * as React from \"react\";\nimport { NavLink as BaseNavLink } from \"react-router-dom\";\n\nconst NavLink = React.forwardRef(\n  ({ activeClassName, activeStyle, ...props }, ref) => {\n    return (\n      <BaseNavLink\n        ref={ref}\n        {...props}\n        className={({ isActive }) =>\n          [\n            props.className,\n            isActive ? activeClassName : null,\n          ]\n            .filter(Boolean)\n            .join(\" \")\n        }\n        style={({ isActive }) => ({\n          ...props.style,\n          ...(isActive ? activeStyle : null),\n        })}\n      />\n    );\n  }\n);\n```\n\nIf the `end` prop is used, it will ensure this component isn't matched as \"active\" when its descendant paths are matched. For example, to render a link that is only active at the website root and not any other URLs, you can use:\n\n``` javascript\n<NavLink to=\"/\" end>\n  Home\n</NavLink>\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/components/nav-link](https://reactrouterdotcom.fly.dev/docs/en/v6/components/nav-link)"
- name: <Outlet>
  id: components/outlet
  summary: An <Outlet> should be used in parent route elements to render their child route elements
  description: "# `<Outlet>`\n\nType declaration\n\n``` javascript\ninterface OutletProps {\n  context?: unknown;\n}\ndeclare function Outlet(\n  props: OutletProps\n): React.ReactElement | null;\n```\n\nAn `<Outlet>` should be used in parent route elements to render their child route elements. This allows nested UI to show up when child routes are rendered. If the parent route matched exactly, it will render a child index route or nothing if there is no index route.\n\n``` javascript\nfunction Dashboard() {\n  return (\n    <div>\n      <h1>Dashboard</h1>\n\n      {/* This element will render either <DashboardMessages> when the URL is\n          \"/messages\", <DashboardTasks> at \"/tasks\", or null if it is \"/\"\n      */}\n      <Outlet />\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Dashboard />}>\n        <Route\n          path=\"messages\"\n          element={<DashboardMessages />}\n        />\n        <Route path=\"tasks\" element={<DashboardTasks />} />\n      </Route>\n    </Routes>\n  );\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/components/outlet](https://reactrouterdotcom.fly.dev/docs/en/v6/components/outlet)"
- name: <Route> doesn't render? How do I compose?
  id: start/faq#route-doesnt-render-how-do-i-compose
  summary: In v5 the <Route> component was just a normal component that was like an if statement that rendered when the URL matched its path
  belongs_to: FAQs
  description: |-
    ## `<Route>` doesn't render? How do I compose?

    In v5 the `<Route>` component was just a normal component that was like an `if` statement that rendered when the URL matched its path. In v6, a `<Route>` element doesn't actually ever render, it's simply there for configuration.

    In v5, since routes were just components, `MyRoute` will be rendered when the path is "/my-route".

    ``` javascript
    let App = () => (
      <div>
        <MyRoute />
      </div>
    );

    let MyRoute = ({ element, ...rest }) => {
      return (
        <Route path="/my-route" children={<p>Hello!</p>} />
      );
    };
    ```

    In v6, however, the `<Route>` is only used for its props, so the following code will never render `<p>Hello!</p>` because `<MyRoute>` has no path that `<Routes>` can see:

    ``` javascript
    let App = () => (
      <Routes>
        <MyRoute />
      </Routes>
    );

    let MyRoute = () => {
      // won't ever render because the path is down here
      return (
        <Route path="/my-route" children={<p>Hello!</p>} />
      );
    };
    ```

    You can get the same behavior by:

    - Only rendering `<Route>` elements inside of `<Routes>`
    - Moving the composition into the `element` prop

    ``` javascript
    let App = () => (
      <div>
        <Routes>
          <Route path="/my-route" element={<MyRoute />} />
        </Routes>
      </div>
    );

    let MyRoute = () => {
      return <p>Hello!</p>;
    };
    ```

    Having a full nested route config available statically in `<Routes>` is going to enable a lot of features in `v6.x`, so we encourage you to put your routes in one top-level config. If you really like the idea of components that match the URL independent of any other components, you can make a component that behaves similarly to the v5 `Route` with this:

    ``` javascript
    function MatchPath({ path, Comp }) {
      let match = useMatch(path);
      return match ? <Comp {...match} /> : null;
    }

    // Will match anywhere w/o needing to be in a `<Routes>`
    <MatchPath path="/accounts/:id" Comp={Account} />;
    ```
- name: <Router>
  id: router-components/router
  summary: <Router> is the low-level interface that is shared by all router components (like <BrowserRouter> and <StaticRouter>)
  description: "# `<Router>`\n\nType declaration\n\n``` javascript\ndeclare function Router(\n  props: RouterProps\n): React.ReactElement | null;\n\ninterface RouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  location: Partial<Location> | string;\n  navigationType?: NavigationType;\n  navigator: Navigator;\n  static?: boolean;\n}\n```\n\n`<Router>` is the low-level interface that is shared by all router components (like `<BrowserRouter>` and `<StaticRouter>`). In terms of React, `<Router>` is a [context provider](https://reactjs.org/docs/context.html#contextprovider) that supplies routing information to the rest of the app.\n\nYou probably never need to render a `<Router>` manually. Instead, you should use one of the higher-level routers depending on your environment. You only ever need one router in a given app.\n\nThe `<Router basename>` prop may be used to make all routes and links in your app relative to a \"base\" portion of the URL pathname that they all share. This is useful when rendering only a portion of a larger app with React Router or when your app has multiple entry points. Basenames are not case-sensitive.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/router-components/router](https://reactrouterdotcom.fly.dev/docs/en/v6/router-components/router)"
- name: <RouterProvider>
  id: routers/router-provider
  summary: All router objects are passed to this component to render your app and enable the rest of the APIs
  description: "# `<RouterProvider>`\n\nAll router objects are passed to this component to render your app and enable the rest of the APIs.\n\n``` javascript\nimport {\n  createBrowserRouter,\n  RouterProvider,\n} from \"react-router-dom\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    children: [\n      {\n        path: \"dashboard\",\n        element: <Dashboard />,\n      },\n      {\n        path: \"about\",\n        element: <About />,\n      },\n    ],\n  },\n]);\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <RouterProvider\n    router={router}\n    fallbackElement={<BigSpinner />}\n  />\n);\n```\n\n## `fallbackElement`\n\nIf you are not server rendering your app, `DataBrowserRouter` will initiate all matching route loaders when it mounts. During this time, you can provide a `fallbackElement` to give the user some indication that the app is working. Make that static hosting TTFB count!\n\n``` javascript\n<RouterProvider\n  router={router}\n  fallbackElement={<SpinnerOfDoom />}\n/>\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/routers/router-provider](https://reactrouterdotcom.fly.dev/docs/en/v6/routers/router-provider)"
- name: <Routes>
  id: components/routes
  summary: Rendered anywhere in the app, <Routes> will match a set of child routes from the current location
  description: "# `<Routes>`\n\nRendered anywhere in the app, `<Routes>` will match a set of child routes from the current [location](../hook/location).\n\n``` javascript\ninterface RoutesProps {\n  children?: React.ReactNode;\n  location?: Partial<Location> | string;\n}\n\n<Routes location>\n  <Route />\n</Routes>;\n```\n\nIf you're using a data router like [`createBrowserRouter`](../routers/create-browser-router) it is uncommon to use this component as it does not participate in data loading.\n\nWhenever the location changes, `<Routes>` looks through all its child routes to find the best match and renders that branch of the UI. `<Route>` elements may be nested to indicate nested UI, which also correspond to nested URL paths. Parent routes render their child routes by rendering an [`<Outlet>`](outlet).\n\n``` javascript\n<Routes>\n  <Route path=\"/\" element={<Dashboard />}>\n    <Route\n      path=\"messages\"\n      element={<DashboardMessages />}\n    />\n    <Route path=\"tasks\" element={<DashboardTasks />} />\n  </Route>\n  <Route path=\"about\" element={<AboutPage />} />\n</Routes>\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/components/routes](https://reactrouterdotcom.fly.dev/docs/en/v6/components/routes)"
- name: <ScrollRestoration />
  id: components/scroll-restoration
  summary: This component will emulate the browser's scroll restoration on location changes after loaders have completed to ensure the scroll position is restored to the right spot, even across domains
  description: "# `<ScrollRestoration />`\n\nThis component will emulate the browser's scroll restoration on location changes after loaders have completed to ensure the scroll position is restored to the right spot, even across domains.\n\nYou should only render one of these and it's recommended you render it in the root route of your app:\n\n``` javascript\nimport { ScrollRestoration } from \"react-router-dom\";\n\nfunction RootRouteComponent() {\n  return (\n    <div>\n      {/* ... */}\n      <ScrollRestoration />\n    </div>\n  );\n}\n```\n\n## `getKey`\n\nOptional prop that defines the key React Router should use to restore scroll positions.\n\n``` javascript\n<ScrollRestoration\n  getKey={(location, matches) => {\n    // default behavior\n    return location.key;\n  }}\n/>\n```\n\nBy default it uses `location.key`, emulating the browser's default behavior without client side routing. The user can navigate to the same URL multiple times in the stack and each entry gets its own scroll position to restore.\n\nSome apps may want to override this behavior and restore position based on something else. Consider a social app that has four primary pages:\n\n- \"/home\"\n- \"/messages\"\n- \"/notifications\"\n- \"/search\"\n\nIf the user starts at \"/home\", scrolls down a bit, clicks \"messages\" in the navigation menu, then clicks \"home\" in the navigation menu (not the back button!) there will be three entries in the history stack:\n\nBy default, React Router (and the browser) will have two different scroll positions stored for `1` and `3` even though they have the same URL. That means as the user navigated from `2` → `3` the scroll position goes to the top instead of restoring to where it was in `1`.\n\nA solid product decision here is to keep the users scroll position on the home feed no matter how they got there (back button or new link clicks). For this, you'd want to use the `location.pathname` as the key.\n\n``` javascript\n<ScrollRestoration\n  getKey={(location, matches) => {\n    return location.pathname;\n  }}\n/>\n```\n\nOr you may want to only use the pathname for some paths, and use the normal behavior for everything else:\n\n``` javascript\n<ScrollRestoration\n  getKey={(location, matches) => {\n    const paths = [\"/home\", \"/notifications\"];\n    return paths.includes(location.pathname)\n      ? // home and notifications restore by pathname\n        location.pathname\n      : // everything else by location like the browser\n        location.key;\n  }}\n/>\n```\n\n## Preventing Scroll Reset\n\nWhen navigation creates new scroll keys, the scroll position is reset to the top of the page. You can prevent the \"scroll to top\" behavior from your links:\n\n``` javascript\n<Link preventScrollReset={true} />\n```\n\nSee also: [`<Link preventScrollReset>`](link#preventscrollreset)\n\n## Scroll Flashing\n\nWithout a server side rendering framework like [Remix](https://remix.run), you may experience some scroll flashing on initial page loads. This is because React Router can't restore scroll position until your JS bundles have downloaded, data has loaded, and the full page has rendered (if you're rendering a spinner, the viewport is likely not the size it was when the scroll position was saved).\n\nServer Rendering frameworks can prevent scroll flashing because they can send a fully formed document on the initial load, so scroll can be restored when the page first renders.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/components/scroll-restoration](https://reactrouterdotcom.fly.dev/docs/en/v6/components/scroll-restoration)"
- name: <StaticRouter>
  id: router-components/static-router
  summary: <StaticRouter> is used to render a React Router web app in node
  description: "# `<StaticRouter>`\n\nType declaration\n\n``` javascript\ndeclare function StaticRouter(\n  props: StaticRouterProps\n): React.ReactElement;\n\ninterface StaticRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  location?: Path | LocationPieces;\n}\n```\n\n`<StaticRouter>` is used to render a React Router web app in [node](https://nodejs.org). Provide the current location via the `location` prop.\n\n- `<StaticRouter location>` defaults to `\"/\"`\n\n``` javascript\nimport * as React from \"react\";\nimport * as ReactDOMServer from \"react-dom/server\";\nimport { StaticRouter } from \"react-router-dom/server\";\nimport http from \"http\";\n\nfunction requestHandler(req, res) {\n  let html = ReactDOMServer.renderToString(\n    <StaticRouter location={req.url}>\n      {/* The rest of your app goes here */}\n    </StaticRouter>\n  );\n\n  res.write(html);\n  res.end();\n}\n\nhttp.createServer(requestHandler).listen(3000);\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/router-components/static-router](https://reactrouterdotcom.fly.dev/docs/en/v6/router-components/static-router)"
- name: Abstractions
  id: route/error-element#abstractions
  summary: This pattern of throwing when you know you can't continue down the data loading path you're on makes it pretty simple to properly handle exceptional situations
  belongs_to: errorElement
  description: "## Abstractions\n\nThis pattern of throwing when you know you can't continue down the data loading path you're on makes it pretty simple to properly handle exceptional situations.\n\nImagine a function that gets the user's web token for authorized requests looking something like this:\n\n``` javascript\nasync function getUserToken() {\n  const token = await getTokenFromWebWorker();\n  if (!token) {\n    throw new Response(\"\", { status: 401 });\n  }\n  return token;\n}\n```\n\nNo matter which loader or action uses that function, it will stop executing code in the current call stack and send the app over to the error path instead.\n\nNow let's add a function that fetches a project:\n\n``` javascript\nfunction fetchProject(id) {\n  const token = await getUserToken();\n  const response = await fetch(`/projects/${id}`, {\n    headers: { Authorization: `Bearer ${token}` },\n  });\n\n  if (res.status === 404) {\n    throw new Response(\"Not Found\", { status: 404 });\n  }\n\n  // the fetch failed\n  if (!res.ok) {\n    throw new Error(\"Could not fetch project\");\n  }\n}\n```\n\nThanks to `getUserToken`, this code can assume it gets a token. If there isn't one, the error path will be rendered. Then if the project doesn't exist, no matter which loader is calling this function, it will throw a 404 over to the `errorElement`. Finally, if the fetch fails completely, it will send an error.\n\nAt any time you realize \"I don't have what I need\", you can simply `throw`, knowing that you're still rendering something useful for the end user.\n\nLet's put it together into a route:\n\n``` javascript\n<Route\n  path=\"/\"\n  element={<Root />}\n  errorElement={<RootBoundary />}\n>\n  <Route\n    path=\"projects/:projectId\"\n    loader={({ params }) => fetchProject(params.projectId)}\n    element={<Project />}\n  />\n</Route>\n```\n\nThe project route doesn't have to think about errors at all. Between the loader utility functions like `fetchProject` and `getUserToken` throwing whenever something isn't right, and the `RootBoundary` handling all of the cases, the project route gets to focus strictly on the happy path.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/route/error-element](https://reactrouterdotcom.fly.dev/docs/en/v6/route/error-element)"
- name: Accessing Data in Components
  id: guides/data-libs#accessing-data-in-components
  summary: While React Router's useLoaderData returns whatever you returned from your loader, you can use your data abstraction's hooks instead to get access to the full feature set of that package
  belongs_to: Data Library Integration
  description: |-
    ## Accessing Data in Components

    While React Router's `useLoaderData` returns whatever you returned from your loader, you can use your data abstraction's hooks instead to get access to the full feature set of that package.

    ``` javascript
    export default function SomeRouteComponent() {
    - const data = useLoaderData();
    + const { data } = useQuery(someQueryKey);
    }
    ```
- name: action
  id: components/form#action
  summary: The url to which the form will be submitted, just like HTML form action
  belongs_to: <Form>
  description: |-
    ## `action`

    The url to which the form will be submitted, just like [HTML form action](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#attr-action). The only difference is the default action. With HTML forms, it defaults to the full URL. With `<Form>`, it defaults to the relative URL of the closest route in context.

    Consider the following routes and components:

    ``` javascript
    function ProjectsLayout() {
      return (
        <>
          <Form method="post" />
          <Outlet />
        </>
      );
    }

    function ProjectsPage() {
      return <Form method="post" />;
    }

    <DataBrowserRouter>
      <Route
        path="/projects"
        element={<ProjectsLayout />}
        action={ProjectsLayout.action}
      >
        <Route
          path=":projectId"
          element={<ProjectPage />}
          action={ProjectsPage.action}
        />
      </Route>
    </DataBrowserRouter>;
    ```

    If the the current URL is `"/projects/123"`, the form inside the child route, `ProjectsPage`, will have a default action as you might expect: `"/projects/123"`. In this case, where the route is the deepest matching route, both `<Form>` and plain HTML forms have the same result.

    But the form inside of `ProjectsLayout` will point to `"/projects"`, not the full URL. In other words, it points to the matching segment of the URL for the route in which the form is rendered.

    This helps with portability as well as co-location of forms and their action handlers when if you add some convention around your route modules.

    If you need to post to a different route, then add an action prop:

    ``` javascript
    <Form action="/projects/new" method="post" />
    ```

    **See also:**

    - [Index Search Param](../guides/index-search-param) (index vs parent route disambiguation)
- name: action
  id: route/route#action
  summary: The route action is called when a submission is sent to the route from a Form, fetcher, or submission
  belongs_to: Route
  description: |-
    ## `action`

    The route action is called when a submission is sent to the route from a [Form](../components/form), [fetcher](../hooks/use-fetcher), or [submission](../hooks/use-submit).

    ``` javascript
    <Route
      path="/teams/:teamId"
      action={({ request }) => {
        const formData = await request.formData();
        return updateTeam(formData);
      }}
    />
    ```

    If you are not using a data router like [`createBrowserRouter`](../routers/create-browser-router), this will do nothing

    Please see the [action](action) documentation for more details.
- name: action
  id: route/action
  summary: Route actions are the "writes" to route loader "reads". They provide a way for apps to perform data mutations with simple HTML and HTTP semantics while React Router abstracts away the complexity of asynchronous UI and revalidation
  description: "# `action`\n\nRoute actions are the \"writes\" to route [loader](loader) \"reads\". They provide a way for apps to perform data mutations with simple HTML and HTTP semantics while React Router abstracts away the complexity of asynchronous UI and revalidation. This gives you the simple mental model of HTML + HTTP (where the browser handles the asynchrony and revalidation) with the behavior and UX capabilities of modern SPAs.\n\nThis feature only works if using a data router like [`createBrowserRouter`](../routers/create-browser-router)\n\n``` javascript\n<Route\n  path=\"/song/:songId/edit\"\n  element={<EditSong />}\n  action={async ({ params, request }) => {\n    let formData = await request.formData();\n    return fakeUpdateSong(params.songId, formData);\n  }}\n  loader={({ params }) => {\n    return fakeGetSong(params.songId);\n  }}\n/>\n```\n\nActions are called whenever the app sends a non-get submission (\"post\", \"put\", \"patch\", \"delete\") to your route. This can happen in a few ways:\n\n``` javascript\n// forms\n<Form method=\"post\" action=\"/songs\" />;\n<fetcher.Form method=\"put\" action=\"/songs/123/edit\" />;\n\n// imperative submissions\nlet submit = useSubmit();\nsubmit(data, {\n  method: \"delete\",\n  action: \"/songs/123\",\n});\nfetcher.submit(data, {\n  method: \"patch\",\n  action: \"/songs/123/edit\",\n});\n```\n\n## `params`\n\nRoute params are parsed from [dynamic segments](route#dynamic-segments) and passed to your action. This is useful for figuring out which resource to mutate:\n\n``` javascript\n<Route\n  path=\"/projects/:projectId/delete\"\n  action={({ params }) => {\n    return fakeDeleteProject(params.projectId);\n  }}\n/>\n```\n\n## `request`\n\nThis is a [Fetch Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) instance being sent to your route. The most common use case is to parse the [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) from the request\n\n``` javascript\n<Route\n  action={async ({ request }) => {\n    let formData = await request.formData();\n    // ...\n  }}\n/>\n```\n\n> A Request?!\n\nIt might seem odd at first that actions receive a \"request\". Have you ever written this line of code?\n\n``` javascript\n<form\n  onSubmit={(event) => {\n    event.preventDefault();\n    // ...\n  }}\n/>\n```\n\nWhat exactly are you preventing?\n\nWithout JavaScript, just plain HTML and an HTTP web server, that default event that was prevented is actually pretty great. Browsers will serialize all the data in the form into [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) and send it as the body of a new request to your server. Like the code above, React Router [`<Form>`](../components/form) prevents the browser from sending that request and instead sends the request to your route action! This enables highly dynamic web apps with the simple model of HTML and HTTP.\n\nRemember that the values in the `formData` are automatically serialized from the form submission, so your inputs need a `name`.\n\n``` javascript\n<Form method=\"post\">\n  <input name=\"songTitle\" />\n  <textarea name=\"lyrics\" />\n  <button type=\"submit\">Save</button>\n</Form>;\n\n// accessed by the same names\nformData.get(\"songTitle\");\nformData.get(\"lyrics\");\n```\n\nFor more information on `formData` see [Working with FormData](../guides/form-data).\n\n## Returning Responses\n\nWhile you can return anything you want from an action and get access to it from [`useActionData`](../hooks/use-action-data), you can also return a web [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response).\n\nFor more information, see the [loader documentation](loader#returning-responses).\n\n## Throwing in Actions\n\nYou can `throw` in your action to break out of the current call stack (stop running the current code) and React Router will start over down the \"error path\".\n\n``` javascript\n<Route\n  action={async ({ params }) => {\n    const res = await fetch(\n      `/api/properties/${params.id}`,\n      {\n        method: \"put\",\n        body: await request.formData(),\n      }\n    );\n    if (!res.ok) throw res;\n    return { ok: true };\n  }}\n/>\n```\n\nFor more details and expanded use cases, read the [errorElement](error-element) documentation.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/route/action](https://reactrouterdotcom.fly.dev/docs/en/v6/route/action)"
- name: Active Link Styling
  id: start/tutorial#active-link-styling
  summary: Now that we have a bunch of records, it's not clear which one we're looking at in the sidebar
  belongs_to: Tutorial
  description: |-
    ## Active Link Styling

    Now that we have a bunch of records, it's not clear which one we're looking at in the sidebar. We can use [`NavLink`](../components/nav-link) to fix this.

    👉 **Use a `NavLink` in the sidebar**

    ``` javascript
    import {
      Outlet,
      NavLink,
      useLoaderData,
      Form,
      redirect,
    } from "react-router-dom";

    export default function Root() {
      return (
        <>
          <div id="sidebar">
            {/* other code */}

            <nav>
              {contacts.length ? (
                <ul>
                  {contacts.map((contact) => (
                    <li key={contact.id}>
                      <NavLink
                        to={`contacts/${contact.id}`}
                        className={({ isActive, isPending }) =>
                          isActive
                            ? "active"
                            : isPending
                            ? "pending"
                            : ""
                        }
                      >
                        {/* other code */}
                      </NavLink>
                    </li>
                  ))}
                </ul>
              ) : (
                <p>{/* other code */}</p>
              )}
            </nav>
          </div>
        </>
      );
    }
    ```

    Note that we are passing a function to `className`. When the user is at the URL in the `NavLink`, then `isActive` will be true. When it's *about* to be active (the data is still loading) then `isPending` will be true. This allows us to easily indicate where the user is, as well as provide immediate feedback on links that have been clicked but we're still waiting for data to load.
- name: Active Links
  id: start/overview#active-links
  summary: Most web apps have persistent navigation sections at the top of the UI, the sidebar, and often multiple levels
  belongs_to: Feature Overview
  description: |-
    ## Active Links

    Most web apps have persistent navigation sections at the top of the UI, the sidebar, and often multiple levels. Styling the active navigation items so the user knows where they are (`isActive`) or where they're going (`isPending`) in the app is done easily with `<NavLink>`.

    ``` javascript
    <NavLink
      style={({ isActive, isPending }) => {
        return {
          color: isActive ? "red" : "inherit",
        };
      }}
      className={({ isActive, isPending }) => {
        return isActive ? "active" : isPending ? "pending" : "";
      }}
    />
    ```

    You can also [`useMatch`](../hooks/use-match) for any other "active" indication outside of links.

    ``` javascript
    function SomeComp() {
      const match = useMatch("/messages");
      return <li className={Boolean(match) ? "active" : ""} />;
    }
    ```

    See:

    - [`NavLink`](../components/nav-link)
    - [`useMatch`](../hooks/use-match)

    &nbsp;
- name: Adding a Router
  id: start/tutorial#adding-a-router
  summary: First thing to do is create a Browser Router and configure our first route
  belongs_to: Tutorial
  description: |-
    ## Adding a Router

    First thing to do is create a [Browser Router](../routers/create-browser-router) and configure our first route. This will enable client side routing for our web app.

    The `main.jsx` file is the entry point. Open it up and we'll put React Router on the page.

    👉 **Create and render a [browser router](../routers/create-browser-router) in `main.jsx`**

    ``` javascript
    import React from "react";
    import ReactDOM from "react-dom/client";
    import {
      createBrowserRouter,
      RouterProvider,
      Route,
    } from "react-router-dom";
    import "./index.css";

    const router = createBrowserRouter([
      {
        path: "/",
        element: <div>Hello world!</div>,
      },
    ]);

    ReactDOM.createRoot(document.getElementById("root")).render(
      <React.StrictMode>
        <RouterProvider router={router} />
      </React.StrictMode>
    );
    ```

    This first route is what we often call the "root route" since the rest of our routes will render inside of it. It will serve as the root layout of the UI, we'll have nested layouts as we get farther along.
- name: Adding Search Spinner
  id: start/tutorial#adding-search-spinner
  summary: In a production app, it's likely this search will be looking for records in a database that is too large to send all at once and filter client side
  belongs_to: Tutorial
  description: |-
    ## Adding Search Spinner

    In a production app, it's likely this search will be looking for records in a database that is too large to send all at once and filter client side. That's why this demo has some faked network latency.

    Without any loading indicator, the search feels kinda sluggish. Even if we could make our database faster, we'll always have the user's network latency in the way and out of our control. For a better UX, let's add some immediate UI feedback for the search. For this we'll use [`useNavigation`](../hooks/use-navigation) again.

    👉 **Add the search spinner**

    ``` javascript
    // existing code

    export default function Root() {
      const { contacts, q } = useLoaderData();
      const navigation = useNavigation();
      const submit = useSubmit();

      const searching =
        navigation.location &&
        new URLSearchParams(navigation.location.search).has(
          "q"
        );

      useEffect(() => {
        document.getElementById("q").value = q;
      }, [q]);

      return (
        <>
          <div id="sidebar">
            <h1>React Router Contacts</h1>
            <div>
              <Form id="search-form" role="search">
                <input
                  id="q"
                  className={searching ? "loading" : ""}
                  // existing code
                />
                <div
                  id="search-spinner"
                  aria-hidden
                  hidden={!searching}
                />
                {/* existing code */}
              </Form>
              {/* existing code */}
            </div>
            {/* existing code */}
          </div>
          {/* existing code */}
        </>
      );
    }
    ```

    The `navigation.location` will show up when the app is navigating to a new URL and loading the data for it. It then goes away when there is no pending navigation anymore.
- name: Auth Example
  id: examples/auth
  summary: This example demonstrates how to restrict access to routes to authenticated users
  description: "# Auth Example\n\nThis example demonstrates how to restrict access to routes to authenticated users.\n\nBe sure to pay attention to the following features:\n\n- The use of the `useNavigate()` hook and the `<Navigate>` component for navigating both imperatively after the login form is submitted and declaratively when a non-authenticated user visits a particular route\n- The use of `location.state` to preserve the previous location so you can send the user there after they authenticate\n- The use of `navigate(\"...\", { replace: true })` to replace the `/login` route in the history stack so the user doesn't return to the login page when clicking the back button after logging in\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/auth?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/auth](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/auth)"
- name: basename
  id: routers/create-browser-router#basename
  summary: The basename of the app for situations where you can't deploy to the root of the domain, but a sub directory
  belongs_to: createBrowserRouter
  description: |-
    ## `basename`

    The basename of the app for situations where you can't deploy to the root of the domain, but a sub directory.

    ``` javascript
    createBrowserRouter(routes, {
      basename: "/app",
    });
    ```

    The trailing slash will be respected when linking to the root:

    ``` javascript
    createBrowserRouter(routes, {
      basename: "/app",
    });
    <Link to="/" />; // results in <a href="/app" />

    createBrowserRouter(routes, {
      basename: "/app/",
    });
    <Link to="/" />; // results in <a href="/app/" />
    ```
- name: Basic Example
  id: examples/basic
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  description: "# Basic Example\n\nThis example demonstrates some of the basic features of React Router, including:\n\n- Layouts and nested `<Route>`s\n- Index `<Route>`s\n- Catch-all `<Route>`s\n- Using `<Outlet>` as a placeholder for child routes\n- Using `<Link>`s for navigation\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/basic?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/basic](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/basic)"
- name: Breadcrumbs
  id: hooks/use-matches#breadcrumbs
  summary: The proverbial use case here is adding breadcrumbs to a parent layout that uses data from the child routes
  belongs_to: useMatches
  description: "## Breadcrumbs\n\nThe proverbial use case here is adding breadcrumbs to a parent layout that uses data from the child routes.\n\n``` javascript\n<Route element={<Root />}>\n  <Route\n    path=\"messages\"\n    element={<Messages />}\n    loader={loadMessages}\n    handle={{\n      // you can put whatever you want on a route handle\n      // here we use \"crumb\" and return some elements,\n      // this is what we'll render in the breadcrumbs\n      // for this route\n      crumb: () => <Link to=\"/message\">Messages</Link>,\n    }}\n  >\n    <Route\n      path=\"conversation/:id\"\n      element={<Thread />}\n      loader={loadThread}\n      handle={{\n        // `crumb` is your own abstraction, we decided\n        // to make this one a function so we can pass\n        // the data from the loader to it so that our\n        // breadcrumb is made up of dynamic content\n        crumb: (data) => <span>{data.threadName}</span>,\n      }}\n    />\n  </Route>\n</Route>\n```\n\nNow we can create a `Breadcrumbs` component that takes advantage of our home-grown `crumb` abstraction with `useMatches` and `handle`.\n\n``` javascript\nfunction Breadcrumbs() {\n  let matches = useMatches();\n  let crumbs = matches\n    // first get rid of any matches that don't have handle and crumb\n    .filter((match) => Boolean(match.handle?.crumb))\n    // now map them into an array of elements, passing the loader\n    // data to each one\n    .map((match) => match.handle.crumb(match.data));\n\n  return (\n    <ol>\n      {crumbs.map((crumb, index) => (\n        <li key={index}>{crumb}</li>\n      ))}\n    </ol>\n  );\n}\n```\n\nNow you can render `<Breadcrumbs/>` anywhere you want, probably in the root component.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-matches](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-matches)"
- name: Bubbling
  id: route/error-element#bubbling
  summary: When a route does not have an errorElement, errors will bubble up through parent routes
  belongs_to: errorElement
  description: |-
    ## Bubbling

    When a route does not have an `errorElement`, errors will bubble up through parent routes. This lets you get as granular or general as you like.

    Put an `errorElement` at the top of your route tree and handle nearly every error in your app in one place. Or, put them on all of your routes and allow the parts of the app that don't have errors to continue to render normally. This gives the user more options to recover from errors instead of a hard refresh and 🤞.
- name: Building
  id: guides/contributing#building
  summary: Calling yarn build from the root directory will run the build, which should take only a few seconds
  belongs_to: Contributing to React Router
  description: |-
    ### Building

    Calling `yarn build` from the root directory will run the build, which should take only a few seconds. It's important to build all the packages together because `react-router-dom` and `react-router-native` both use `react-router` as a dependency.
- name: Busy Indicators
  id: start/overview#busy-indicators
  summary: When forms are being submitted to route actions, you have access to the navigation state to display busy indicators, disable fieldsets, etc
  belongs_to: Feature Overview
  description: |-
    ## Busy Indicators

    When forms are being submitted to route actions, you have access to the navigation state to display busy indicators, disable fieldsets, etc.

    ``` javascript
    function NewProjectForm() {
      const navigation = useNavigation();
      const busy = navigation.state === "submitting";
      return (
        <Form action="/project/new">
          <fieldset disabled={busy}>
            <label>
              Project title
              <br />
              <input type="text" name="title" />
            </label>

            <label>
              Target Finish Date
              <br />
              <input type="date" name="due" />
            </label>
          </fieldset>
          <button type="submit" disabled={busy}>
            {busy ? "Creating..." : "Create"}
          </button>
        </Form>
      );
    }
    ```

    See:

    - [`useNavigation`](../hooks/use-navigation)

    &nbsp;
- name: Cancel Button
  id: start/tutorial#cancel-button
  summary: On the edit page we've got a cancel button that doesn't do anything yet
  belongs_to: Tutorial
  description: |-
    ## Cancel Button

    On the edit page we've got a cancel button that doesn't do anything yet. We'd like it to do the same thing as the browser's back button.

    We'll need a click handler on the button as well as [`useNavigate`](../hooks/use-navigate) from React Router.

    👉 **Add the cancel button click handler with `useNavigate`**

    ``` javascript
    import {
      Form,
      useLoaderData,
      redirect,
      useNavigate,
    } from "react-router-dom";

    export default function Edit() {
      const contact = useLoaderData();
      const navigate = useNavigate();

      return (
        <Form method="post" id="contact-form">
          {/* existing code */}

          <p>
            <button type="submit">Save</button>
            <button
              type="button"
              onClick={() => {
                navigate(-1);
              }}
            >
              Cancel
            </button>
          </p>
        </Form>
      );
    }
    ```

    Now when the user clicks "Cancel", they'll be sent back one entry in the browser's history.

    > 🧐 Why is there no `event.preventDefault` on the button?

    A `<button type="button">`, while seemingly redundant, is the HTML way of preventing a button from submitting its form.

    Two more features to go. We're on the home stretch!
- name: caseSensitive
  id: route/route#casesensitive
  summary: null
  belongs_to: Route
  description: |-
    ## `caseSensitive`

    Instructs the route to match case or not:

    ``` javascript
    <Route caseSensitive path="/wEll-aCtuA11y" />
    ```

    - Will match `"wEll-aCtuA11y"`
    - Will not match `"well-actua11y"`
- name: children
  id: route/route#children
  summary: null
  belongs_to: Route
  description: |-
    ## `children`

    (TODO: need to talk about nesting, maybe even a separate doc)
- name: Client Side Routing
  id: start/overview#client-side-routing
  summary: In traditional websites, the browser requests a document from a web server, downloads and evaluates CSS and JavaScript assets, and renders the HTML sent from the server
  belongs_to: Feature Overview
  description: |-
    ## Client Side Routing

    React Router enables "client side routing".

    In traditional websites, the browser requests a document from a web server, downloads and evaluates CSS and JavaScript assets, and renders the HTML sent from the server. When the user clicks a link, it starts the process all over again for a new page.

    Client side routing allows your app to update the URL from a link click without making another request for another document from the server. Instead, your app can immediately render some new UI and make data requests with `fetch` to update the page with new information.

    This enables faster user experiences because the browser doesn't need to request an entirely new document or re-evaluate CSS and JavaScript assets for the next page. It also enables more dynamic user experiences with things like animation.

    Client side routing is enabled by creating a `Router` and linking/submitting to pages with `Link` and `<Form>`:

    ``` javascript
    import React from "react";
    import { createRoot } from "react-dom/client";
    import {
      createBrowserRouter,
      RouterProvider,
      Route,
      Link,
    } from "react-router-dom";

    const router = createBrowserRouter([
      {
        path: "/",
        element: (
          <div>
            <h1>Hello World</h1>
            <Link to="about">About Us</Link>
          </div>
        ),
      },
      {
        path: "about",
        element: <div>About</div>,
      },
    ]);

    createRoot(document.getElementById("root")).render(
      <RouterProvider router={router} />
    );
    ```
- name: Client Side Routing
  id: start/tutorial#client-side-routing
  summary: You may or may not have noticed, but when we click the links in the sidebar, the browser is doing a full document request for the next URL instead of using React Router
  belongs_to: Tutorial
  description: |-
    ## Client Side Routing

    You may or may not have noticed, but when we click the links in the sidebar, the browser is doing a full document request for the next URL instead of using React Router.

    Client side routing allows our app to update the URL without requesting another document from the server. Instead, the app can immediately render new UI. Let's make it happen with [`<Link>`](../components/link).

    👉 **Change the sidebar `<a href>` to `<Link to>`**

    ``` javascript
    import { Outlet, Link } from "react-router-dom";

    export default function Root() {
      return (
        <>
          <div id="sidebar">
            {/* other elements */}

            <nav>
              <ul>
                <li>
                  <Link to={`contacts/1`}>Your Name</Link>
                </li>
                <li>
                  <Link to={`contacts/2`}>Your Friend</Link>
                </li>
              </ul>
            </nav>

            {/* other elements */}
          </div>
        </>
      );
    }
    ```

    You can open the network tab in the browser devtools to see that it's not requesting documents anymore.
- name: Conclusion
  id: guides/data-libs#conclusion
  summary: With all of these APIs working together, you can now use useNavigation from React Router to build pending states, optimistic UI, and more
  belongs_to: Data Library Integration
  description: "## Conclusion\n\nWith all of these APIs working together, you can now use [`useNavigation`](../hooks/use-navigation) from React Router to build pending states, optimistic UI, and more. Use React Router for timing of data loading, mutations, and navigation state, then use libraries like React Query for the actual implementation of loading, invalidating, storage, and caching.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/guides/data-libs](https://reactrouterdotcom.fly.dev/docs/en/v6/guides/data-libs)"
- name: Contextual Errors
  id: start/tutorial#contextual-errors
  summary: Recognize that screen? It's our errorElement from before
  belongs_to: Tutorial
  description: |-
    ## Contextual Errors

    Just for kicks, throw an error in the destroy action:

    ``` javascript
    export async function action({ params }) {
      throw new Error("oh dang!");
      await deleteContact(params.contactId);
      return redirect("/");
    }
    ```

    Recognize that screen? It's our [`errorElement`](../route/error-element) from before. The user, however, can't really do anything to recover from this screen except to hit refresh.

    Let's create a contextual error message for the destroy route:

    ``` javascript
    [
      /* other routes */
      {
        path: "contacts/:contactId/destroy",
        action: destroyAction,
        errorElement: <div>Oops! There was an error.</div>,
      },
    ];
    ```

    Now try it again:

    Our user now has more options than slamming refresh, they can continue to interact with the parts of the page that aren't having trouble 🙌

    Because the destroy route has its own `errorElement` and is a child of the root route, the error will render there instead of the root. As you probably noticed, these errors bubble up to the nearest `errorElement`. Add as many or as few as you like, as long as you've got one at the root.
- name: Contributing to React Router
  id: guides/contributing
  summary: When it comes to open source, there are many different kinds of contributions that can be made, all of which are valuable
  description: "# Contributing to React Router\n\nThanks for contributing, you rock!\n\nWhen it comes to open source, there are many different kinds of contributions that can be made, all of which are valuable. Here are a few guidelines that should help you as you prepare your contribution.\n\n## Setup\n\nBefore you can contribute to the codebase, you will need to fork the repo. This will look a bit different depending on what type of contribution you are making:\n\n- All new features, bug-fixes, or **anything that touches `react-router` code** should be branched off of and merged into the `dev` branch\n- Changes that only touch documentation can be branched off of and merged into the `main` branch\n\nThe following steps will get you set up to contribute changes to this repo:\n\n1.  Fork the repo (click the Fork button at the top right of [this page](https://github.com/remix-run/react-router))\n2.  Clone your fork locally\n\n``` javascript\n# in a terminal, cd to parent directory where you want your clone to be, then\ngit clone https://github.com/<your_github_username>/react-router.git\ncd react-router\n\n# if you are making *any* code changes, make sure to checkout the dev branch\ngit checkout dev\n```\n\n3.  Install dependencies and build. React Router uses [`yarn` (version 1)](https://classic.yarnpkg.com/lang/en/docs/install), so you should too. If you install using `npm`, unnecessary `package-lock.json` files will be generated.\n\n## Think You Found a Bug?\n\nPlease conform to the issue template and provide a clear path to reproduction with a code example. Best is a pull request with a failing test. Next best is a link to CodeSandbox or repository that illustrates the bug.\n\n## Proposing New or Changed API?\n\nPlease provide thoughtful comments and some sample code that show what you'd like to do with React Router in your app. It helps the conversation if you can show us how you're limited by the current API first before jumping to a conclusion about what needs to be changed and/or added.\n\nWe have learned by experience that small APIs are usually better, so we may be a little reluctant to add something new unless there's an obvious limitation with the current API. That being said, we are always anxious to hear about cases that we just haven't considered before, so please don't be shy! :)\n\n## Issue Not Getting Attention?\n\nIf you need a bug fixed and nobody is fixing it, your best bet is to provide a fix for it and make a [pull request](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request). Open source code belongs to all of us, and it's all of our responsibility to push it forward.\n\n## Making a Pull Request?\n\nPull requests need only the approval of two or more collaborators to be merged; when the PR author is a collaborator, that counts as one.\n\nWhen creating the PR in GitHub, make sure that you set the base to the correct branch. If you are submitting a PR that touches any code, this should be the `dev` branch. You set the base in GitHub when authoring the PR with the dropdown below the \"Compare changes\" heading:\n\n### Tests\n\nAll commits that fix bugs or add features need a test.\n\n`<blink>`Do not merge code without tests!`</blink>`\n\n### Docs + Examples\n\nAll commits that change or add to the API must be done in a pull request that also updates all relevant examples and docs.\n\n## Development\n\n### Packages\n\nReact Router uses a monorepo to host code for multiple packages. These packages live in the `packages` directory.\n\nWe use [Yarn workspaces](https://classic.yarnpkg.com/en/docs/workspaces/) to manage installation of dependencies and running various scripts. To get everything installed, make sure you have [Yarn (version 1) installed](https://classic.yarnpkg.com/lang/en/docs/install), and then run `yarn` or `yarn install` from the repo root.\n\n### Building\n\nCalling `yarn build` from the root directory will run the build, which should take only a few seconds. It's important to build all the packages together because `react-router-dom` and `react-router-native` both use `react-router` as a dependency.\n\n### Testing\n\nBefore running the tests, you need to run a build. After you build, running `yarn test` from the root directory will run **every** package's tests. If you want to run tests for a specific package, use `yarn test --projects packages/<package-name>`:\n\n``` javascript\n# Test all packages\nyarn test\n\n# Test only react-router-dom\nyarn test --projects packages/react-router-dom\n```\n\n## Repository Branching\n\nThis repo maintains separate branches for different purposes. They will look something like this:\n\nThere may be other branches for various features and experimentation, but all of the magic happens from these branches.\n\n## New Releases\n\nWhen it's time to cut a new release, we follow a process based on our branching strategy depending on the type of release.\n\n### `react-router@next` Releases\n\nWe create experimental releases from the current state of the `dev` branch. They can be installed by using the `@next` tag:\n\n``` javascript\nyarn add react-router-dom@next\n# or\nnpm install react-router-dom@next\n```\n\nThese releases will be automated as PRs are merged into the `dev` branch.\n\n### Latest Major Releases\n\n``` javascript\n# Start from the dev branch.\ngit checkout dev\n\n# Merge the main branch into dev to ensure that any hotfixes and\n# docs updates are available in the release.\ngit merge main\n\n# Create a new release branch from dev.\ngit checkout -b release/v6.1.0\n\n# Create a new tag and update version references throughout the\n# codebase.\nyarn run version minor # | \"patch\" | \"major\"\n\n# Push the release branch along with the new release tag.\ngit push origin release/v6.1.0 --follow-tags\n\n# Wait for GitHub actions to run all tests. If the tests pass, the\n# release is ready to go! Merge the release branch into main and dev.\ngit checkout main\ngit merge release/v6.1.0\ngit checkout dev\ngit merge release/v6.1.0\n\n# The release branch can now be deleted.\ngit branch -D release/v6.1.0\ngit push origin --delete release/v6.1.0\n\n# Now go to GitHub and create the release from the new tag. Let\n# GitHub Actions take care of the rest!\n```\n\n### Hot-fix Releases\n\nSometimes we have a crucial bug that needs to be patched right away. If the bug affects the latest release, we can create a new version directly from `main` (or the relevant major release branch where the bug exists):\n\n``` javascript\n# From the main branch, make sure to run the build and all tests\n# before creating a new release.\nyarn && yarn build && yarn test\n\n# Assuming the tests pass, create the release tag and update\n# version references throughout the codebase.\nyarn run version patch\n\n# Push changes along with the new release tag.\ngit push origin main --follow-tags\n\n# In GitHub, create the release from the new tag and it will be\n# published via GitHub actions\n\n# When the hot-fix is done, merge the changes into dev and clean\n# up conflicts as needed.\ngit checkout dev\ngit merge main\ngit push origin dev\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/guides/contributing](https://reactrouterdotcom.fly.dev/docs/en/v6/guides/contributing)"
- name: createBrowserRouter
  id: routers/create-browser-router
  summary: This is the recommended router for all React Router web projects
  description: "# `createBrowserRouter`\n\nThis is the recommended router for all React Router web projects. It uses the [DOM History API](https://developer.mozilla.org/en-US/docs/Web/API/History) to update the URL and manage the history stack.\n\nIt also enables the v6.4 data APIs like [loaders](../route/loader), [actions](../route/action), [fetchers](../hooks/use-fetcher) and more.\n\n``` javascript\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport {\n  createBrowserRouter,\n  RouterProvider,\n} from \"react-router-dom\";\n\nimport Root, { rootLoader } from \"./routes/root\";\nimport Team, { teamLoader } from \"./routes/team\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    loader: rootLoader,\n    children: [\n      {\n        path: \"team\",\n        element: <Team />,\n        loader: teamLoader,\n      },\n    ],\n  },\n]);\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <RouterProvider router={router} />\n);\n```\n\n## Type Declaration\n\n``` javascript\nfunction createBrowserRouter(\n  routes: RouteObject[],\n  opts?: {\n    basename?: string;\n    window?: Window;\n  }\n): RemixRouter;\n```\n\n## `routes`\n\nAn array of [`Route`](../components/route) objects with nested routes on the `children` property.\n\n``` javascript\ncreateBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    loader: rootLoader,\n    children: [\n      {\n        path: \"events/:id\",\n        element: <Event />,\n        loader: eventLoader,\n      },\n    ],\n  },\n]);\n```\n\n## `basename`\n\nThe basename of the app for situations where you can't deploy to the root of the domain, but a sub directory.\n\n``` javascript\ncreateBrowserRouter(routes, {\n  basename: \"/app\",\n});\n```\n\nThe trailing slash will be respected when linking to the root:\n\n``` javascript\ncreateBrowserRouter(routes, {\n  basename: \"/app\",\n});\n<Link to=\"/\" />; // results in <a href=\"/app\" />\n\ncreateBrowserRouter(routes, {\n  basename: \"/app/\",\n});\n<Link to=\"/\" />; // results in <a href=\"/app/\" />\n```\n\n## `window`\n\nUseful for environments like browser devtool plugins or testing to use a different window than the global `window`.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/routers/create-browser-router](https://reactrouterdotcom.fly.dev/docs/en/v6/routers/create-browser-router)"
- name: createHashRouter
  id: routers/create-hash-router
  summary: This router is useful if you are unable to configure your web server to direct all traffic to your React Router application
  description: "# `createHashRouter`\n\nThis router is useful if you are unable to configure your web server to direct all traffic to your React Router application. Instead of using normal URLs, it will use the hash (#) portion of the URL to manage the \"application URL\".\n\nUsing hash URLs is not recommended.\n\nOther than that, it is functionally the same as [`createBrowserRouter`](create-browser-router).\n\n``` javascript\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport {\n  createHashRouter,\n  RouterProvider,\n} from \"react-router-dom\";\n\nimport Root, { rootLoader } from \"./routes/root\";\nimport Team, { teamLoader } from \"./routes/team\";\n\nconst router = createHashRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    loader: rootLoader,\n    children: [\n      {\n        path: \"team\",\n        element: <Team />,\n        loader: teamLoader,\n      },\n    ],\n  },\n]);\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <RouterProvider router={router} />\n);\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/routers/create-hash-router](https://reactrouterdotcom.fly.dev/docs/en/v6/routers/create-hash-router)"
- name: createMemoryRouter
  id: routers/create-memory-router
  summary: Instead of using the browsers history a memory router manages it's own history stack in memory
  description: "# `createMemoryRouter`\n\nInstead of using the browsers history a memory router manages it's own history stack in memory. It's primarily useful for testing and component development tools like Storybook, but can also be used for running React Router in any non-browser environment.\n\n``` javascript\nimport {\n  RouterProvider,\n  createMemoryRouter,\n} from \"react-router-dom\";\nimport * as React from \"react\";\nimport {\n  render,\n  waitFor,\n  screen,\n} from \"@testing-library/react\";\nimport \"@testing-library/jest-dom\";\nimport CalendarEvent from \"./routes/event\";\n\ntest(\"event route\", async () => {\n  const FAKE_EVENT = { name: \"test event\" };\n  const routes = [\n    {\n      path: \"/events/:id\",\n      element: <CalendarEvent />,\n      loader: () => FAKE_EVENT,\n    },\n  ];\n\n  const router = createMemoryRouter(routes, {\n    initialEntries: [\"/\", \"/events/123\"],\n    initialIndex: 1,\n  });\n\n  render(<RouterProvider router={router} />);\n\n  await waitFor(() => screen.getByRole(\"heading\"));\n  expect(screen.getByRole(\"heading\")).toHaveTextContent(\n    FAKE_EVENT.name\n  );\n});\n```\n\n## Type Declaration\n\n``` javascript\nfunction createMemoryRouter(\n  routes: RouteObject[],\n  opts?: {\n    basename?: string;\n    initialEntries?: InitialEntry[];\n    initialIndex?: number;\n    window?: Window;\n  }\n): RemixRouter;\n```\n\n## `initialEntries`\n\nThe initial entries in the history stack. This allows you to start a test (or an app) with multiple locations already in the history stack (for testing a back navigation, etc.)\n\n``` javascript\ncreateMemoryRouter(routes, {\n  initialEntries: [\"/\", \"/events/123\"],\n});\n```\n\n## `initialIndex`\n\nThe initial index in the history stack to render. This allows you to start a test at a specific entry. It defaults to the last entry in `initialEntries`.\n\n``` javascript\ncreateMemoryRouter(routes, {\n  initialEntries: [\"/\", \"/events/123\"],\n  initialIndex: 1, // start at \"/events/123\"\n});\n```\n\n## Other props\n\nFor all other props, see [`createBrowserRouter`](create-browser-router)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/routers/create-memory-router](https://reactrouterdotcom.fly.dev/docs/en/v6/routers/create-memory-router)"
- name: createRoutesFromChildren
  id: utils/create-routes-from-children
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  description: "# `createRoutesFromChildren`\n\nAlias for [`createRoutesFromElements`](create-routes-from-elements)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/utils/create-routes-from-children](https://reactrouterdotcom.fly.dev/docs/en/v6/utils/create-routes-from-children)"
- name: createRoutesFromElements
  id: utils/create-routes-from-elements
  summary: createRoutesFromElements is a helper that creates route objects from <Route> elements
  description: "# `createRoutesFromElements`\n\n`createRoutesFromElements` is a helper that creates route objects from `<Route>` elements. It's useful if you prefer to create your routes as JSX instead of objects.\n\n``` javascript\nimport {\n  createBrowserRouter,\n  RouterProvider,\n} from \"react-router-dom\";\n\n// You can do this:\nconst router = createBrowserRouter(\n  createRoutesFromElements(\n    <Route path=\"/\" element={<Root />}>\n      <Route path=\"dashboard\" element={<Dashboard />} />\n      <Route path=\"about\" element={<About />} />\n    </Route>\n  )\n);\n\n// Instead of this:\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    children: [\n      {\n        path: \"dashboard\",\n        element: <Dashboard />,\n      },\n      {\n        path: \"about\",\n        element: <About />,\n      },\n    ],\n  },\n]);\n```\n\nIt's also used internally by [`<Routes>`](../components/routes) to generate a route objects from its [`<Route>`](../components/route) children.\n\n## Type declaration\n\n``` javascript\ndeclare function createRoutesFromElements(\n  children: React.ReactNode\n): RouteObject[];\n\ninterface RouteObject {\n  caseSensitive?: boolean;\n  children?: RouteObject[];\n  element?: React.ReactNode;\n  index?: boolean;\n  path?: string;\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/utils/create-routes-from-elements](https://reactrouterdotcom.fly.dev/docs/en/v6/utils/create-routes-from-elements)"
- name: createSearchParams
  id: utils/create-search-params
  summary: createSearchParams is a thin wrapper around new URLSearchParams(init) that adds support for using objects with array values
  description: "# `createSearchParams`\n\nType declaration\n\n``` javascript\ndeclare function createSearchParams(\n  init?: URLSearchParamsInit\n): URLSearchParams;\n```\n\n`createSearchParams` is a thin wrapper around [`new URLSearchParams(init)`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams) that adds support for using objects with array values. This is the same function that `useSearchParams` uses internally for creating `URLSearchParams` objects from `URLSearchParamsInit` values.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/utils/create-search-params](https://reactrouterdotcom.fly.dev/docs/en/v6/utils/create-search-params)"
- name: Creating Contacts
  id: start/tutorial#creating-contacts
  summary: The createContact method just creates an empty contact with no name or data or anything
  belongs_to: Tutorial
  description: |-
    ## Creating Contacts

    We'll create new contacts by exporting an `action` in our root route, wiring it up to the route config, and changing our `<form>` to a React Router [`<Form>`](../components/form).

    👉 **Create the action and change `<form>` to `<Form>`**

    ``` javascript
    import {
      Outlet,
      Link,
      useLoaderData,
      Form,
    } from "react-router-dom";
    import { getContacts, createContact } from "../contacts";

    export async function action() {
      await createContact();
    }

    /* other code */

    export default function Root() {
      const { contacts } = useLoaderData();
      return (
        <>
          <div id="sidebar">
            <h1>React Router Contacts</h1>
            <div>
              {/* other code */}
              <Form method="post">
                <button type="submit">New</button>
              </Form>
            </div>

            {/* other code */}
          </div>
        </>
      );
    }
    ```

    👉 **Import and set the action on the route**

    ``` javascript
    /* other imports */

    import Root, {
      loader as rootLoader,
      action as rootAction,
    } from "./routes/root";

    const router = createBrowserRouter([
      {
        path: "/",
        element: <Root />,
        errorElement: <ErrorPage />,
        loader: rootLoader,
        action: rootAction,
        children: [
          {
            path: "contacts/:contactId",
            element: <Contact />,
          },
        ],
      },
    ]);
    ```

    That's it! Go ahead and click the "New" button and you should see a new record pop into the list 🥳

    The `createContact` method just creates an empty contact with no name or data or anything. But it does still create a record, promise!

    > 🧐 Wait a sec ... How did the sidebar update? Where did we call the `action`? Where's the code to refetch the data? Where are `useState`, `onSubmit` and `useEffect`?!

    This is where the "old school web" programming model shows up. As we discussed earlier, [`<Form>`](../components/form) prevents the browser from sending the request to the server and sends it to your route `action` instead. In web semantics, a POST usually means some data is changing. By convention, React Router uses this as a hint to automatically revalidate the data on the page after the action finishes. That means all of your `useLoaderData` hooks update and the UI stays in sync with your data automatically! Pretty cool.
- name: Custom Filter Link Example
  id: examples/custom-filter-link
  summary: This example demonstrates how to use a query string parameter to mark a link as "active" or not
  description: "# Custom Filter Link Example\n\nThis example demonstrates how to use a query string parameter to mark a link as \"active\" or not. This is a common technique when implementing a filter in a sidebar where you're browsing products.\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/custom-filter-link?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/custom-filter-link](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/custom-filter-link)"
- name: Custom Link Example
  id: examples/custom-link
  summary: This example demonstrates how to make a custom <Link> component to render something different when the link is "active" using the useMatch() and useResolvedPath() hooks
  description: "# Custom Link Example\n\nThis example demonstrates how to make a custom `<Link>` component to render something different when the link is \"active\" using the `useMatch()` and `useResolvedPath()` hooks.\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/custom-link?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/custom-link](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/custom-link)"
- name: Custom Query Parsing Example
  id: examples/custom-query-parsing
  summary: This example demonstrates how to store a complex data structure in the URL query string using a custom hook
  description: "# Custom Query Parsing Example\n\nThis example demonstrates how to store a complex data structure in the URL query string using a custom hook.\n\nIt's a good example of how React Router's low-level hooks provide you with all the flexibility you need to create your own custom hooks that fit the needs of your app.\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/custom-query-parsing?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/custom-query-parsing](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/custom-query-parsing)"
- name: Data Access
  id: start/concepts#data-access
  summary: Finally, an application is going to want to ask React Router for a few pieces of information in order to build out the full UI
  belongs_to: Main Concepts
  description: |-
    ## Data Access

    Finally, an application is going to want to ask React Router for a few pieces of information in order to build out the full UI. For this, React Router has a pile of hooks

    ``` javascript
    let location = useLocation();
    let urlParams = useParams();
    let [urlSearchParams] = useSearchParams();
    ```
- name: Data Fetchers
  id: start/overview#data-fetchers
  summary: 'HTML Forms are the model for mutations but they have one major limitation: you can have only one at a time because a form submission is a navigation'
  belongs_to: Feature Overview
  description: |-
    ## Data Fetchers

    HTML Forms are the model for mutations but they have one major limitation: you can have only one at a time because a form submission is a navigation.

    Most web apps need to allow for multiple mutations to be happening at the same time, like a list of records where each can be independently deleted, marked complete, liked, etc.

    [Fetchers](../hooks/use-fetcher) allow you to interact with the route [actions](../route/action) and [loaders](../route/loader) without causing a navigation in the browser, but still getting all the conventional benefits like error handling, revalidation, interruption handling, and race condition handling.

    Imagine a list of tasks:

    ``` javascript
    function Tasks() {
      const tasks = useLoaderData();
      return tasks.map((task) => (
        <div>
          <p>{task.name}</p>
          <ToggleCompleteButton task={task} />
        </div>
      ));
    }
    ```

    Each task can be marked complete independently of the rest, with its own pending state and without causing a navigation with a [fetcher](../hooks/use-fetcher):

    ``` javascript
    function ToggleCompleteButton({ task }) {
      const fetcher = useFetcher();

      return (
        <fetcher.Form method="post" action="/toggle-complete">
          <fieldset disabled={fetcher.state !== "idle"}>
            <input type="hidden" name="id" value={task.id} />
            <input
              type="hidden"
              name="status"
              value={task.complete ? "incomplete" : "complete"}
            />
            <button type="submit">
              {task.status === "complete"
                ? "Mark Incomplete"
                : "Mark Complete"}
            </button>
          </fieldset>
        </fetcher.Form>
      );
    }
    ```

    See:

    - [`useFetcher`](../hooks/use-fetcher)

    &nbsp;
- name: Data Library Integration
  id: guides/data-libs
  summary: Since the release of v6.4 some folks wonder if React Router is attempting to replace libraries like React Query, useSwr, etc
  description: "# Data Library Integration\n\nSince the release of v6.4 some folks wonder if React Router is attempting to replace libraries like [React Query](https://tanstack.com/query/v4/), [useSwr](https://swr.vercel.app/), etc.\n\nThe answer is \"nope!\".\n\nReact Router's data APIs are about *when* to load, mutate, and revalidate data, but not *how* to do it. It's about the data lifecycle, not the actual implementation of data fetching, mutation, storage, and caching.\n\nConsidering that `<a href>` and `<form action>` are both navigation events, and both coupled to data (what data to show or what data to change), it makes sense that a client side router would help you with the *navigation state* of both elements. But the actual data implementation is up to you.\n\nThe examples here were adapted from [TkDodo's blog](https://tkdodo.eu/blog/react-query-meets-react-router), thank you for the great post!\n\n## Loading Data\n\nInstead of loading data in components, you use your data abstractions inside of loaders. Note that this loading happens outside of the React render lifecycle, so you can't use hooks like React Query's `useQuery`, you'll need to use the query client's methods directly.\n\n``` javascript\nimport { queryClient } from \"./query-client\";\n\nexport const loader = ({ params }) => {\n  return queryClient.fetchQuery(queryKey, queryFn, {\n    staleTime: 10000,\n  });\n};\n```\n\nIf the query client throws errors correctly, then React Router's [`errorElement`](../route/error-element) will work the same.\n\nOf course, you can use all of the features of the data library, like caching. Caching your data ensures that when the user clicks the back button to a page you've already seen, the data is loaded from the cache immediately. Sometimes caching is the right choice, sometimes you always want it fresh, but that's not a decision within the scope of React Router's data APIs.\n\nReact Router only retains the *current page's loaderData*. If users click \"back\", all loaders are called again. Without a data caching library like React Query (or HTTP cache headers on your JSON API to use the browser's own HTTP cache), your app will refetch all of the data again.\n\nIn this way, React Router is about *timing*, where React Query is about *caching*.\n\n## Accessing Data in Components\n\nWhile React Router's `useLoaderData` returns whatever you returned from your loader, you can use your data abstraction's hooks instead to get access to the full feature set of that package.\n\n``` javascript\nexport default function SomeRouteComponent() {\n- const data = useLoaderData();\n+ const { data } = useQuery(someQueryKey);\n}\n```\n\n## Invalidating Data in Mutations\n\nBecause most of these library's have some mechanism for caching, you'll need to invalidate those caches at some point.\n\nThe perfect place to invalidate those caches is in a React Router [action](../route/action).\n\n``` javascript\nimport { queryClient } from \"./query-client\";\n\nexport const action = async ({ request, params }) => {\n  const formData = await request.formData();\n  const updates = Object.fromEntries(formData);\n  await updateContact(params.contactId, updates);\n  await queryClient.invalidateQueries([\"contacts\"]);\n  return redirect(`/contacts/${params.contactId}`);\n};\n```\n\n## Usage with `defer`\n\nYou can similarly take advantage of the deferred APIs:\n\n``` javascript\nfunction loader() {\n  return defer({\n    // no await!\n    someData: queryClient.fetchQuery(\"someKey\", fn),\n  });\n}\n\nfunction Comp() {\n  // *do* useLoaderData for promise\n  const { someData } = useLoaderData();\n  return (\n    <div>\n      <h1>Something</h1>\n      <Await\n        resolve={someData}\n        errorElement={<div>Oops!</div>}\n      >\n        <SomeView />\n      </Await>\n    </div>\n  );\n}\n\nfunction SomeView() {\n  // instead of accessing with useAsyncValue\n  // const someData = useAsyncValue();\n  // `useQuery` as usual\n  const { data } = useQuery(\"someKey\");\n  // ...\n}\n```\n\n## The Overlap\n\nHooks like `useQuery` often return pending and error states you can use to branch your UI. With React Router, you can keep all of that branching out of your happy path components and rely on [`errorElement`](../route/error-element), [`useNavigation`](../hooks/use-navigation), and [`Await`](../components/await) instead.\n\n## Conclusion\n\nWith all of these APIs working together, you can now use [`useNavigation`](../hooks/use-navigation) from React Router to build pending states, optimistic UI, and more. Use React Router for timing of data loading, mutations, and navigation state, then use libraries like React Query for the actual implementation of loading, invalidating, storage, and caching.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/guides/data-libs](https://reactrouterdotcom.fly.dev/docs/en/v6/guides/data-libs)"
- name: Data Loading
  id: start/overview#data-loading
  summary: Because URL segments usually map to your app's persistent data, React Router provides conventional data loading hooks to initiate data loading during a navigation
  belongs_to: Feature Overview
  description: |-
    ## Data Loading

    Because URL segments usually map to your app's persistent data, React Router provides conventional data loading hooks to initiate data loading during a navigation. Combined with nested routes, all of the data for multiple layouts at a specific URL can be loaded in parallel.

    ``` javascript
    <Route
      path="/"
      loader={async ({ request }) => {
        // loaders can be async functions
        const res = await fetch("/api/user.json", {
          signal: request.signal,
        });
        const user = await res.json();
        return user;
      }}
      element={<Root />}
    >
      <Route
        path=":teamId"
        // loaders understand Fetch Responses and will automatically
        // unwrap the res.json(), so you can simply return a fetch
        loader={({ params }) => {
          return fetch(`/api/teams/${params.teamId}`);
        }}
        element={<Team />}
      >
        <Route
          path=":gameId"
          loader={({ params }) => {
            // of course you can use any data store
            return fakeSdk.getTeam(params.gameId);
          }}
          element={<Game />}
        />
      </Route>
    </Route>
    ```

    Data is made available to your components through `useLoaderData`.

    ``` javascript
    function Root() {
      const user = useLoaderData();
      // data from <Route path="/">
    }

    function Team() {
      const team = useLoaderData();
      // data from <Route path=":teamId">
    }

    function Game() {
      const game = useLoaderData();
      // data from <Route path=":gameId">
    }
    ```

    When the user visits or clicks links to <https://example.com/real-salt-lake/45face3>, all three route loaders will be called and loaded in parallel, before the UI for that URL renders.
- name: Data Mutations
  id: start/overview#data-mutations
  summary: HTML forms are navigation events, just like links
  belongs_to: Feature Overview
  description: |-
    ## Data Mutations

    HTML forms are navigation events, just like links. React Router supports HTML form workflows with client side routing.

    When a form is submitted, the normal browser navigation event is prevented and a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request), with a body containing the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) of the submission, is created. This request is sent to the `<Route action>` that matches the form's `<Form action>`.

    Form elements's `name` prop are submitted to the action:

    ``` javascript
    <Form action="/project/new">
      <label>
        Project title
        <br />
        <input type="text" name="title" />
      </label>

      <label>
        Target Finish Date
        <br />
        <input type="date" name="due" />
      </label>
    </Form>
    ```

    The normal HTML document request is prevented and sent to the matching route's action (`<Route path>` that matches the `<form action>`), including the `request.formData`.

    ``` javascript
    <Route
      path="project/new"
      action={async ({ request }) => {
        const formData = await request.formData();
        const newProject = await createProject({
          title: formData.get("title"),
          due: formData.get("due"),
        });
        return redirect(`/projects/${newProject.id}`);
      }}
    />
    ```
- name: Data Revalidation
  id: start/overview#data-revalidation
  summary: Decades old web conventions indicate that when a form is posted to the server, data is changing and a new page is rendered
  belongs_to: Feature Overview
  description: |-
    ## Data Revalidation

    Decades old web conventions indicate that when a form is posted to the server, data is changing and a new page is rendered. That convention is followed in React Router's HTML-based data mutation APIs.

    After route actions are called, the loaders for all of the data on the page is called again to ensure the UI stays up-to-date with the data automatically. No cache keys to expire, no context providers to reload.

    See:

    - [Tutorial "Creating Contacts"](tutorial#creating-contacts)

    &nbsp;
- name: Data Router Server-side Rendering Example
  id: examples/ssr-data-router
  summary: This example adds server-side rendering (SSR) to our basic example using a data router
  description: "# Data Router Server-side Rendering Example\n\nThis example adds [server-side rendering](https://reactjs.org/docs/react-dom-server.html) (SSR) to our basic example using a data router.\n\nWith SSR, the server renders your app and sends real HTML to the browser instead of an empty HTML document with a bunch of `<script>` tags. After the browser loads the HTML and JavaScript from the server, React \"hydrates\" the HTML document using the same components it used to render the app on the server.\n\nThis example contains a server (see [server.js](https://github.com/remix-run/react-router/blob/main/examples/ssr-data-router/server.js)) that can run in both development and production modes.\n\nIn the browser entry point (see [src/entry.client.tsx](https://github.com/remix-run/react-router/blob/main/examples/ssr-data-router/src/entry.client.tsx)), we use React Router like we would traditionally do in a purely client-side app and render a `<DataBrowserRouter>` to provide routing context to the rest of the app. The main difference is that instead of using `ReactDOM.createRoot(el).render()` to render the app, since the HTML was already sent by the server, all we need is `ReactDOM.hydrateRoot()`.\n\nOn the server (see [src/entry.server.tsx](https://github.com/remix-run/react-router/blob/main/examples/ssr-data-router/src/entry.server.tsx)), we create a static request handler using `createStaticHandler` and query for the incoming `Request` we get from Express (note that we convert the Express request to a Web Fetch Request). Once the router is finished with data loading, we use React Router's `<unstable_DataStaticRouter>` to render the app in the correct state.\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/ssr-data-router?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/ssr-data-router](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/ssr-data-router)"
- name: Data Routers
  id: examples/notes
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  description: "# Data Routers\n\nThis example demonstrates some of the basic features of Data Router, including:\n\n- Loader functions\n- Action functions\n- and\n\nnavigations\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/remixing/examples/notes?file=src/main.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/notes](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/notes)"
- name: Data Routers
  id: examples/data-router
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  description: "# Data Routers\n\nThis example demonstrates some of the basic features of Data Router, including:\n\n- Loader functions\n- Action functions\n- and\n\nnavigations\n\n- \\<fetcher.Form\\> submissions\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/data-router?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/data-router](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/data-router)"
- name: Data Writes + HTML Forms
  id: start/tutorial#data-writes--html-forms
  summary: We'll create our first contact in a second, but first let's talk about HTML
  belongs_to: Tutorial
  description: |-
    ## Data Writes + HTML Forms

    We'll create our first contact in a second, but first let's talk about HTML.

    React Router emulates HTML Form navigation as the data mutation primitive, a la web development before the JavaScript cambrian explosion. It gives you the UX capabilities of client rendered apps with the simplicity of the "old school" web model.

    While unfamiliar to some web developers, HTML forms actually cause a navigation in the browser, just like clicking a link. The only difference is in the request: links can only change the URL while forms can also change the request method (GET vs POST) and the request body (POST form data).

    Without client side routing, the browser will serialize the form's data automatically and send it to the server as the request body for POST, and as URLSearchParams for GET. React Router does the same thing, except instead of sending the request to the server, it uses client side routing and sends it to a route [`action`](../route/action).

    We can test this out by clicking the "New" button in our app. The app should blow up because the Vite server isn't configured to handle a POST request (it sends a 404, though it should probably be a 405 🤷).

    Instead of sending that POST to the Vite server to create a new contact, let's use client side routing instead.
- name: defer
  id: utils/defer
  summary: This utility allows you to defer values returned from loaders by passing promises instead of resolved values
  description: "# `defer`\n\nThis utility allows you to defer values returned from loaders by passing promises instead of resolved values.\n\n``` javascript\nfunction loader() {\n  let product = await getProduct();\n  let reviews = getProductReviews();\n  return defer({ product, reviews });\n}\n```\n\nSee the [Deferred Guide](../guides/deferred) for more information.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/utils/defer](https://reactrouterdotcom.fly.dev/docs/en/v6/utils/defer)"
- name: Deferred Data Guide
  id: guides/deferred
  summary: Imagine a scenario where one of your routes' loaders needs to retrieve some data that for one reason or another is quite slow
  description: "# Deferred Data Guide\n\n## The problem\n\nImagine a scenario where one of your routes' loaders needs to retrieve some data that for one reason or another is quite slow. For example, let's say you're showing the user the location of a package that's being delivered to their home:\n\n``` javascript\nimport { json, useLoaderData } from \"react-router-dom\";\nimport { getPackageLocation } from \"./api/packages\";\n\nasync function loader({ params }) {\n  const packageLocation = await getPackageLocation(\n    params.packageId\n  );\n\n  return json({ packageLocation });\n}\n\nfunction PackageRoute() {\n  const data = useLoaderData();\n  const { packageLocation } = data;\n\n  return (\n    <main>\n      <h1>Let's locate your package</h1>\n      <p>\n        Your package is at {packageLocation.latitude} lat\n        and {packageLocation.longitude} long.\n      </p>\n    </main>\n  );\n}\n```\n\nWe'll assume that `getPackageLocation` is slow. This will lead to initial page load times and transitions to that route to take as long as the slowest bit of data. There are a few things you can do to optimize this and improve the user experience:\n\n- Speed up the slow thing (😅).\n- Parallelize data loading with `Promise.all` (we have nothing to parallelize in our example, but it might help a bit in other situations).\n- Add a global transition spinner (helps a bit with UX).\n- Add a localized skeleton UI (helps a bit with UX).\n\nIf these approaches don't work well, then you may feel forced to move the slow data out of the `loader` into a component fetch (and show a skeleton fallback UI while loading). In this case you'd render the fallback UI on mount and fire off the fetch for the data. This is actually not so terrible from a DX standpoint thanks to [`useFetcher`](../hooks/use-fetcher). And from a UX standpoint this improves the loading experience for both client-side transitions as well as initial page load. So it does seem to solve the problem.\n\nBut it's still sub optimal in most cases (especially if you're code-splitting route components) for two reasons:\n\n1.  Client-side fetching puts your data request on a waterfall: document -\\> JavaScript -\\> Lazy Loaded Route -\\> data fetch\n2.  Your code can't easily switch between component fetching and route fetching (more on this later).\n\n## The solution\n\nReact Router takes advantage of React 18's Suspense for data fetching using the [`defer` Response](../fetch/defer) utility and [`<Await />`](../components/await) component / [`useAsyncValue`](../hooks/use-async-data) hook. By using these APIs, you can solve both of these problems:\n\n1.  Your data is no longer on a waterfall: document -\\> JavaScript -\\> Lazy Loaded Route & data (in parallel)\n2.  Your can easily switch between rendering the fallback and waiting for the data\n\nLet's take a dive into how to accomplish this.\n\n### Using `defer`\n\nStart by adding `<Await />` for your slow data requests where you'd rather render a fallback UI. Let's do that for our example above:\n\n``` javascript\nimport { defer, useLoaderData } from \"react-router-dom\";\nimport { getPackageLocation } from \"./api/packages\";\n\nasync function loader({ params }) {\n  const packageLocationPromise = getPackageLocation(\n    params.packageId\n  );\n\n  return defer({\n    packageLocation: packageLocationPromise,\n  });\n}\n\nexport default function PackageRoute() {\n  const data = useLoaderData();\n\n  return (\n    <main>\n      <h1>Let's locate your package</h1>\n      <React.Suspense\n        fallback={<p>Loading package location...</p>}\n      >\n        <Await\n          resolve={data.packageLocation}\n          errorElement={\n            <p>Error loading package location!</p>\n          }\n        >\n          {(packageLocation) => (\n            <p>\n              Your package is at {packageLocation.latitude}{\" \"}\n              lat and {packageLocation.longitude} long.\n            </p>\n          )}\n        </Await>\n      </React.Suspense>\n    </main>\n  );\n}\n```\n\nAlternatively, you can use the \\`useAsyncValue\\` hook:\n\nIf you're not jazzed about bringing back render props, you can use a hook, but you'll have to break things out into another component:\n\n``` javascript\nexport default function PackageRoute() {\n  const data = useLoaderData();\n\n  return (\n    <main>\n      <h1>Let's locate your package</h1>\n      <React.Suspense\n        fallback={<p>Loading package location...</p>}\n      >\n        <Await\n          resolve={data.packageLocation}\n          errorElement={\n            <p>Error loading package location!</p>\n          }\n        >\n          <PackageLocation />\n        </Await>\n      </React.Suspense>\n    </main>\n  );\n}\n\nfunction PackageLocation() {\n  const packageLocation = useAsyncValue();\n  return (\n    <p>\n      Your package is at {packageLocation.latitude} lat and{\" \"}\n      {packageLocation.longitude} long.\n    </p>\n  );\n}\n```\n\n## Evaluating the solution\n\nSo rather than waiting for the component before we can trigger the fetch request, we start the request for the slow data as soon as the user starts the transition to the new route. This can significantly speed up the user experience for slower networks.\n\nAdditionally, the API that React Router exposes for this is extremely ergonomic. You can literally switch between whether something is going to be deferred or not based on whether you include the `await` keyword:\n\n``` javascript\nreturn defer({\n  // not deferred:\n  packageLocation: await packageLocationPromise,\n  // deferred:\n  packageLocation: packageLocationPromise,\n});\n```\n\nBecause of this, you can A/B test deferring, or even determine whether to defer based on the user or data being requested:\n\n``` javascript\nasync function loader({ request, params }) {\n  const packageLocationPromise = getPackageLocation(\n    params.packageId\n  );\n  const shouldDefer = shouldDeferPackageLocation(\n    request,\n    params.packageId\n  );\n\n  return defer({\n    packageLocation: shouldDefer\n      ? packageLocationPromise\n      : await packageLocationPromise,\n  });\n}\n```\n\nThat `shouldDeferPackageLocation` could be implemented to check the user making the request, whether the package location data is in a cache, the status of an A/B test, or whatever else you want. This is pretty sweet 🍭\n\n## FAQ\n\n### Why not defer everything by default?\n\nThe React Router defer API is another lever React Router offers to give you a nice way to choose between trade-offs. Do you want the page to render more quickly? Defer stuff. Do you want a lower CLS (Content Layout Shift)? Don't defer stuff. You want a faster render, but also want a lower CLS? Defer just the slow and unimportant stuff.\n\nIt's all trade-offs, and what's neat about the API design is that it's well suited for you to do easy experimentation to see which trade-offs lead to better results for your real-world key indicators.\n\n### When does the `<Suspense/>` fallback render?\n\nThe `<Await />` component will only throw the promise up the `<Suspense>` boundary on the initial render of the `<Await />` component with an unsettled promise. It will not re-render the fallback if props change. Effectively, this means that you *will not* get a fallback rendered when a user submits a form and loader data is revalidated. You *will* get a fallback rendered when the user navigates to the same route with different params (in the context of our above example, if the user selects from a list of packages on the left to find their location on the right).\n\nThis may feel counter-intuitive at first, but stay with us, we really thought this through and it's important that it works this way. Let's imagine a world without the deferred API. For those scenarios you're probably going to want to implement Optimistic UI for form submissions/revalidation.\n\nWhen you decide you'd like to try the trade-offs of `defer`, we don't want you to have to change or remove those optimizations because we want you to be able to easily switch between deferring some data and not deferring it. So, we ensure that your existing optimistic states work the same way. If we didn't do this, then you could experience what we call \"Popcorn UI\" where submissions of data trigger the fallback loading state instead of the optimistic UI you'd worked hard on.\n\nSo just keep this in mind: **Deferred is 100% only about the initial load of a route and it's params.**\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/guides/deferred](https://reactrouterdotcom.fly.dev/docs/en/v6/guides/deferred)"
- name: Defining Routes
  id: start/concepts#defining-routes
  summary: In fact, instead of <Routes> you can use the hook useRoutes(routesGoHere) instead
  belongs_to: Main Concepts
  description: |-
    ### Defining Routes

    A route config is a tree of [routes](#route) that looks something like this:

    ``` javascript
    <Routes>
      <Route path="/" element={<App />}>
        <Route index element={<Home />} />
        <Route path="teams" element={<Teams />}>
          <Route path=":teamId" element={<Team />} />
          <Route path=":teamId/edit" element={<EditTeam />} />
          <Route path="new" element={<NewTeamForm />} />
          <Route index element={<LeagueStandings />} />
        </Route>
      </Route>
      <Route element={<PageLayout />}>
        <Route path="/privacy" element={<Privacy />} />
        <Route path="/tos" element={<Tos />} />
      </Route>
      <Route path="contact-us" element={<Contact />} />
    </Routes>
    ```

    The `<Routes>` component recurses through its `props.children`, strips their props, and generates an object like this:

    ``` javascript
    let routes = [
      {
        element: <App />,
        path: "/",
        children: [
          {
            index: true,
            element: <Home />,
          },
          {
            path: "teams",
            element: <Teams />,
            children: [
              {
                index: true,
                element: <LeagueStandings />,
              },
              {
                path: ":teamId",
                element: <Team />,
              },
              {
                path: ":teamId/edit",
                element: <EditTeam />,
              },
              {
                path: "new",
                element: <NewTeamForm />,
              },
            ],
          },
        ],
      },
      {
        element: <PageLayout />,
        children: [
          {
            element: <Privacy />,
            path: "/privacy",
          },
          {
            element: <Tos />,
            path: "/tos",
          },
        ],
      },
      {
        element: <Contact />,
        path: "/contact-us",
      },
    ];
    ```

    In fact, instead of `<Routes>` you can use the hook `useRoutes(routesGoHere)` instead. That's all `<Routes>` is doing.

    As you can see, routes can define multiple [segments](#segment) like `:teamId/edit`, or just one like `:teamId`. All of the segments down a branch of the [route config](#route-config) are added together to create a final [path pattern](#path-pattern) for a route.
- name: Definitions
  id: start/concepts#definitions
  summary: But first, some definitions! There are a lot of different ideas around routing from back and front end frameworks
  belongs_to: Main Concepts
  description: |-
    ## Definitions

    But first, some definitions! There are a lot of different ideas around routing from back and front end frameworks. Sometimes a word in one context might have different meaning than another.

    Here are some words we use a lot when we talk about React Router. The rest of this guide will go into more detail on each one.

    - **URL** - The URL in the address bar. A lot of people use the term "URL" and "route" interchangeably, but this is not a route in React Router, it's just a URL.

    - **Location** - This is a React Router specific object that is based on the built-in browser's `window.location` object. It represents "where the user is at". It's mostly an object representation of the URL but has a bit more to it than that.

    - **Location State** - A value that persists with a [location](#location) that isn't encoded in the [URL](#url). Much like hash or search params (data encoded in the URL), but stored invisibly in the browser's memory.

    - **History Stack** - As the user navigates, the browser keeps track of each [location](#location) in a stack. If you click and hold the back button in a browser you can see the browser's history stack right there.

    - **Client Side Routing (CSR)** - A plain HTML document can link to other documents and the browser handles the [history stack](#history-stack) itself. Client Side Routing enables developers to manipulate the browser history stack without making a document request to the server.

    - **History** - An object that allows React Router to subscribe to changes in the [URL](#url) as well as providing APIs to manipulate the browser [history stack](#history-stack) programmatically.

    - **History Action** - One of `POP`, `PUSH`, or `REPLACE`. Users can arrive at a [URL](#url) for one of these three reasons. A push when a new entry is added to the history stack (typically a link click or the programmer forced a navigation). A replace is similar except it replaces the current entry on the stack instead of pushing a new one. Finally, a pop happens when the user clicks the back or forward buttons in the browser chrome.

    - **Segment** - The parts of a [URL](#url) or [path pattern](#path-pattern) between the `/` characters. For example, "/users/123" has two segments.

    - **Path Pattern** - These look like URLs but can have special characters for matching URLs to routes, like **dynamic segments** (`"/users/:userId"`) or **star segments** (`"/docs/*"`). They aren't URLs, they're patterns that React Router will match.

    - **Dynamic Segment** - A segment of a path pattern that is dynamic, meaning it can match any values in the segment. For example the pattern `/users/:userId` will match URLs like `/users/123`

    - **URL Params** - The parsed values from the URL that matched a [dynamic segment](#dynamic-segment).

    - **Router** - Stateful, top-level component that makes all the other components and hooks work.

    - **Route Config** - A tree of **routes objects** that will be ranked and matched (with nesting) against the current location to create a branch of **route matches**.

    - **Route** - An object or Route Element typically with a shape of `{ path, element }` or `<Route path element>`. The `path` is a path pattern. When the path pattern matches the current URL, the element will be rendered.

    - **Route Element** - Or `<Route>`. This element's props are read to create a [route](#route) by `<Routes>`, but otherwise does nothing.

    - **Nested Routes** - Because routes can have children and each route defines a portion of the [URL](#url) through [segments](#segment), a single URL can match multiple routes in a nested "branch" of the tree. This enables automatic layout nesting through [outlet](#outlet), [relative links](#relative-links), and more.

    - **Relative links** - Links that don't start with `/` will inherit the closest route in which they are rendered. This makes it easy to link to deeper URLs without having to know and build up the entire path.

    - **Match** - An object that holds information when a route matches the URL, like the [url params](#url-params) and pathname that matched.

    - **Matches** - An array of routes (or branch of the [route config](#route-config)) that matches the current [location](#location). This structure enables [nested routes](#nested-routes).

    - **Parent Route** - A route with child routes.

    - **Outlet** - A component that renders the next match in a set of [matches](#match).

    - **Index Route** - A child route with no path that renders in the parent's [outlet](#outlet) at the parent's [URL](#url).

    - **Layout Route** - A **parent route** without a path, used exclusively for grouping child routes inside a specific layout.

    &nbsp;
- name: Deleting Records
  id: start/tutorial#deleting-records
  summary: Note the action points to "destroy". Like <Link to>, <Form action> can take a relative value
  belongs_to: Tutorial
  description: |-
    ## Deleting Records

    If we review code in the contact route, we can find the delete button looks like this:

    ``` javascript
    <Form
      method="post"
      action="destroy"
      onSubmit={(event) => {
        if (
          !confirm(
            "Please confirm you want to delete this record."
          )
        ) {
          event.preventDefault();
        }
      }}
    >
      <button type="submit">Delete</button>
    </Form>
    ```

    Note the `action` points to `"destroy"`. Like `<Link to>`, `<Form action>` can take a *relative* value. Since the form is rendered in `contact/:contactId`, then a relative action with `destroy` will submit the form to `contact/:contactId/destroy` when clicked.

    At this point you should know everything you need to know to make the delete button work. Maybe give it a shot before moving on? You'll need:

    1.  A new route
    2.  An `action` at that route
    3.  `deleteContact` from `src/contacts.js`

    👉 **Create the "destroy" route module**

    👉 **Add the destroy action**

    ``` javascript
    import { redirect } from "react-router-dom";
    import { deleteContact } from "../contacts";

    export async function action({ params }) {
      await deleteContact(params.contactId);
      return redirect("/");
    }
    ```

    👉 **Add the destroy route to the route config**

    ``` javascript
    /* existing code */
    import { action as destroyAction } from "./routes/destroy";

    const router = createBrowserRouter([
      {
        path: "/",
        /* existing root route props */
        children: [
          /* existing routes */
          {
            path: "contacts/:contactId/destroy",
            action: destroyAction,
          },
        ],
      },
    ]);

    /* existing code */
    ```

    Alright, navigate to a record and click the "Delete" button. It works!

    > 😅 I'm still confused why this all works

    When the user clicks the submit button:

    1.  `<Form>` prevents the default browser behavior of sending a new POST request to the server, but instead emulates the browser by creating a POST request with client side routing
    2.  The `<Form action="destroy">` matches the new route at `"contacts/:contactId/destroy"` and sends it the request
    3.  After the action redirects, React Router calls all of the loaders for the data on the page to get the latest values (this is "revalidation"). `useLoaderData` returns new values and causes the components to update!

    Add a form, add an action, React Router does the rest.
- name: Development
  id: guides/contributing#development
  summary: null
  belongs_to: Contributing to React Router
  description: '## Development'
- name: Docs + Examples
  id: guides/contributing#docs--examples
  summary: All commits that change or add to the API must be done in a pull request that also updates all relevant examples and docs
  belongs_to: Contributing to React Router
  description: |-
    ### Docs + Examples

    All commits that change or add to the API must be done in a pull request that also updates all relevant examples and docs.
- name: Dynamic Segments
  id: start/overview#dynamic-segments
  summary: Segments of the URL can be dynamic placeholders that are parsed and provided to various apis
  belongs_to: Feature Overview
  description: |-
    ## Dynamic Segments

    Segments of the URL can be dynamic placeholders that are parsed and provided to various apis.

    ``` javascript
    <Route path="projects/:projectId/tasks/:taskId" />
    ```

    The two segments with `:` are dynamic, and provided to the following APIs:

    ``` javascript
    // If the current location is /projects/abc/tasks/3
    <Route
      // sent to loaders
      loader={({ params }) => {
        params.projectId; // abc
        params.taskId; // 3
      }}
      // and actions
      action={({ params }) => {
        params.projectId; // abc
        params.taskId; // 3
      }}
      element={<Task />}
    />;

    function Task() {
      // returned from `useParams`
      const params = useParams();
      params.projectId; // abc
      params.taskId; // 3
    }

    function Random() {
      const match = useMatch("/projects/:projectId/tasks/3");
      match.params.projectId; // abc
      match.params.taskId; // 3
    }
    ```

    See:

    - [`<Route path>`](../route/route#path)
    - [`<Route loader>`](../route/loader)
    - [`<Route action>`](../route/action)
    - [`useParams`](../hooks/use-params)
    - [`useMatch`](../hooks/use-match)
- name: Dynamic Segments
  id: route/route#dynamic-segments
  summary: 'If a path segment starts with : then it becomes a "dynamic segment". When the route matches the URL, the dynamic segment will be parsed from the URL and provided as params to other router APIs'
  belongs_to: Route
  description: |-
    ### Dynamic Segments

    If a path segment starts with `:` then it becomes a "dynamic segment". When the route matches the URL, the dynamic segment will be parsed from the URL and provided as `params` to other router APIs.

    ``` javascript
    <Route
      // this path will match URLs like
      // - /teams/hotspur
      // - /teams/real
      path="/teams/:teamId"
      // the matching param will be available to the loader
      loader={({ params }) => {
        console.log(params.teamId); // "hotspur"
      }}
      // and the action
      action={({ params }) => {}}
      element={<Team />}
    />;

    // and the element through `useParams`
    function Team() {
      let params = useParams();
      console.log(params.teamId); // "hotspur"
    }
    ```

    You can have multiple dynamic segments in one route path:

    ``` javascript
    <Route path="/c/:categoryId/p/:productId" />;
    // both will be available
    params.categoryId;
    params.productId;
    ```

    Dynamic segments cannot be "partial":

    - 🚫 `"/teams-:teamId"`
    - ✅ `"/teams/:teamId"`
    - 🚫 `"/:category--:productId"`
    - ✅ `"/:productSlug"`

    You can still support URL patterns like that, you just have to do a bit of your own parsing:

    ``` javascript
    function Product() {
      const { productSlug } = useParams();
      const [category, product] = productSlug.split("--");
      // ...
    }
    ```
- name: element
  id: route/route#element
  summary: The element to render when the route matches the URL
  belongs_to: Route
  description: |-
    ## `element`

    The element to render when the route matches the URL.

    ``` javascript
    <Route path="/for-sale" element={<Properties />} />
    ```
- name: Error Boundaries
  id: examples/error-boundaries
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  description: "# Error Boundaries\n\nThis example demonstrates some of the basic features of React Router's `errorElement` boundaries, including:\n\n- Handling thrown `loader` errors\n- Handling render errors\n- Re-throwing errors from an `errorElement`\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/error-boundaries?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/error-boundaries](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/error-boundaries)"
- name: Error Handling
  id: start/overview#error-handling
  summary: The vast majority of your application errors are handled automatically by React Router
  belongs_to: Feature Overview
  description: |-
    ## Error Handling

    The vast majority of your application errors are handled automatically by React Router. It will catch any errors that are thrown while:

    - rendering
    - loading data
    - updating data

    In practice, this is pretty much every error in your app except those thrown in event handlers (`<button onClick>`) or `useEffect`. React Router apps tend to have very few of either.

    When an error is thrown, instead of rendering the route's [`element`](../route/route#element), the [`errorElement`](../route/error-element) is rendered.

    ``` javascript
    <Route
      path="/"
      loader={() => {
        something.that.throws.an.error();
      }}
      // this will not be rendered
      element={<HappyPath />}
      // but this will instead
      errorElement={<ErrorBoundary />}
    />
    ```

    If a route doesn't have an `errorElement`, the error will bubble to the nearest parent route with an `errorElement`:

    ``` javascript
    <Route
      path="/"
      element={<HappyPath />}
      errorElement={<ErrorBoundary />}
    >
      {/* Errors here bubble up to the parent route */}
      <Route path="login" element={<Login />} />
    </Route>
    ```

    See:

    - [`<Route errorElement>`](../route/error-element)
    - [`useRouteError`](../hooks/use-route-error)

    &nbsp;
- name: errorElement
  id: route/route#errorelement
  summary: When a route throws an exception while rendering, in a loader or in an action, this element will render instead of the normal element
  belongs_to: Route
  description: "## `errorElement`\n\nWhen a route throws an exception while rendering, in a `loader` or in an `action`, this element will render instead of the normal `element`.\n\n``` javascript\n<Route\n  path=\"/for-sale\"\n  // if this throws an error while rendering\n  element={<Properties />}\n  // or this while loading properties\n  loader={() => loadProperties()}\n  // or this while creating a property\n  action={async ({ request }) =>\n    createProperty(await request.formData())\n  }\n  // then this element will render\n  errorElement={<ErrorBoundary />}\n/>\n```\n\nIf you are not using a data router like [`createBrowserRouter`](../routers/create-browser-router), this will do nothing\n\nPlease see the [errorElement](error-element) documentation for more details.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/route/route](https://reactrouterdotcom.fly.dev/docs/en/v6/route/route)"
- name: errorElement
  id: route/error-element
  summary: When exceptions are thrown in loaders, actions, or component rendering, instead of the normal render path for your Routes (<Route element>), the error path will be rendered (<Route errorElement>) and the error made available with useRouteError
  description: "# `errorElement`\n\nWhen exceptions are thrown in [loaders](loader), [actions](action), or component rendering, instead of the normal render path for your Routes (`<Route element>`), the error path will be rendered (`<Route errorElement>`) and the error made available with [`useRouteError`](../hooks/use-route-error).\n\nThis feature only works if using a data router like [`createBrowserRouter`](../routers/create-browser-router)\n\n``` javascript\n<Route\n  path=\"/invoices/:id\"\n  // if an exception is thrown here\n  loader={loadInvoice}\n  // here\n  action={updateInvoice}\n  // or here\n  element={<Invoice />}\n  // this will render instead of `element`\n  errorElement={<ErrorBoundary />}\n/>;\n\nfunction Invoice() {\n  return <div>Happy {path}</div>;\n}\n\nfunction ErrorBoundary() {\n  let error = useRouteError();\n  console.error(error);\n  // Uncaught ReferenceError: path is not defined\n  return <div>Dang!</div>;\n}\n```\n\n## Bubbling\n\nWhen a route does not have an `errorElement`, errors will bubble up through parent routes. This lets you get as granular or general as you like.\n\nPut an `errorElement` at the top of your route tree and handle nearly every error in your app in one place. Or, put them on all of your routes and allow the parts of the app that don't have errors to continue to render normally. This gives the user more options to recover from errors instead of a hard refresh and 🤞.\n\n## Throwing Manually\n\nWhile `errorElement` handles unexpected errors, it can also be used to handle exceptions you expect.\n\nParticularly in loaders and actions, where you work with external data not in your control, you can't always plan on the data existing, the service being available, or the user having access to it. In these cases you can `throw` your own exceptions.\n\nHere's a \"not found\" case in a [loader](loader):\n\n``` javascript\n<Route\n  path=\"/properties/:id\"\n  element={<PropertyForSale />}\n  errorElement={<PropertyError />}\n  loader={async ({ params }) => {\n    const res = await fetch(`/api/properties/${params.id}`);\n    if (res.status === 404) {\n      throw new Response(\"Not Found\", { status: 404 });\n    }\n    const home = res.json();\n    const descriptionHtml = parseMarkdown(\n      data.descriptionMarkdown\n    );\n    return { home, descriptionHtml };\n  }}\n/>\n```\n\nAs soon as you know you can't render the route with the data you're loading, you can throw to break the call stack. You don't have to worry about the rest of the work in the loader (like parsing the user's markdown bio) when it doesn't exist. Just throw and get out of there.\n\nThis also means you don't have to worry about a bunch of error branching code in your route component, it won't even try to render if you throw in the loader or action, instead your `errorElement` will render.\n\nYou can throw anything from a loader or action just like you can return anything: responses (like the previous example), errors, or plain objects.\n\n## Throwing Responses\n\nWhile you can throw anything and it will be provided back to you through [`useRouteError`](../hooks/use-route-error), If you throw a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response), React Router will automatically parse the response data before returning it to your components.\n\nAdditionally, [`isRouteErrorResponse`](../utils/is-route-error-response) lets you check for this specific type in your boundaries. Coupled with [`json`](../fetch/json), you can easily throw responses with some data and render different cases in your boundary:\n\n``` javascript\nimport { json } from \"react-router-dom\";\n\nfunction loader() {\n  const stillWorksHere = await userStillWorksHere();\n  if (!stillWorksHere) {\n    throw json(\n      {\n        sorry: \"You have been fired.\",\n        hrEmail: \"hr@bigco.com\",\n      },\n      { status: 401 }\n    );\n  }\n}\n\nfunction ErrorBoundary() {\n  const error = useRouteError();\n\n  if (isRouteErrorResponse(error) && error.status === 401) {\n    // the response json is automatically parsed to\n    // `error.data`, you also have access to the status\n    return (\n      <div>\n        <h1>{error.status}</h1>\n        <h2>{error.data.sorry}</h2>\n        <p>\n          Go ahead and email {error.data.hrEmail} if you\n          feel like this is a mistake.\n        </p>\n      </div>\n    );\n  }\n\n  // rethrow to let the parent error boundary handle it\n  // when it's not a special case for this route\n  throw error;\n}\n```\n\nThis makes it possible to create a general error boundary, usually on your root route, that handles many cases:\n\n``` javascript\nfunction RootBoundary() {\n  const error = useRouteError();\n\n  if (isRouteErrorResponse(error)) {\n    if (error.status === 404) {\n      return <div>This page doesn't exist!</div>;\n    }\n\n    if (error.status === 401) {\n      return <div>You aren't authorized to see this</div>;\n    }\n\n    if (error.status === 503) {\n      return <div>Looks like our API is down</div>;\n    }\n\n    if (error.status === 418) {\n      return <div>🫖</div>;\n    }\n  }\n\n  return <div>Something went wrong</div>;\n}\n```\n\n## Abstractions\n\nThis pattern of throwing when you know you can't continue down the data loading path you're on makes it pretty simple to properly handle exceptional situations.\n\nImagine a function that gets the user's web token for authorized requests looking something like this:\n\n``` javascript\nasync function getUserToken() {\n  const token = await getTokenFromWebWorker();\n  if (!token) {\n    throw new Response(\"\", { status: 401 });\n  }\n  return token;\n}\n```\n\nNo matter which loader or action uses that function, it will stop executing code in the current call stack and send the app over to the error path instead.\n\nNow let's add a function that fetches a project:\n\n``` javascript\nfunction fetchProject(id) {\n  const token = await getUserToken();\n  const response = await fetch(`/projects/${id}`, {\n    headers: { Authorization: `Bearer ${token}` },\n  });\n\n  if (res.status === 404) {\n    throw new Response(\"Not Found\", { status: 404 });\n  }\n\n  // the fetch failed\n  if (!res.ok) {\n    throw new Error(\"Could not fetch project\");\n  }\n}\n```\n\nThanks to `getUserToken`, this code can assume it gets a token. If there isn't one, the error path will be rendered. Then if the project doesn't exist, no matter which loader is calling this function, it will throw a 404 over to the `errorElement`. Finally, if the fetch fails completely, it will send an error.\n\nAt any time you realize \"I don't have what I need\", you can simply `throw`, knowing that you're still rendering something useful for the end user.\n\nLet's put it together into a route:\n\n``` javascript\n<Route\n  path=\"/\"\n  element={<Root />}\n  errorElement={<RootBoundary />}\n>\n  <Route\n    path=\"projects/:projectId\"\n    loader={({ params }) => fetchProject(params.projectId)}\n    element={<Project />}\n  />\n</Route>\n```\n\nThe project route doesn't have to think about errors at all. Between the loader utility functions like `fetchProject` and `getUserToken` throwing whenever something isn't right, and the `RootBoundary` handling all of the cases, the project route gets to focus strictly on the happy path.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/route/error-element](https://reactrouterdotcom.fly.dev/docs/en/v6/route/error-element)"
- name: Evaluating the solution
  id: guides/deferred#evaluating-the-solution
  summary: So rather than waiting for the component before we can trigger the fetch request, we start the request for the slow data as soon as the user starts the transition to the new route
  belongs_to: Deferred Data Guide
  description: |-
    ## Evaluating the solution

    So rather than waiting for the component before we can trigger the fetch request, we start the request for the slow data as soon as the user starts the transition to the new route. This can significantly speed up the user experience for slower networks.

    Additionally, the API that React Router exposes for this is extremely ergonomic. You can literally switch between whether something is going to be deferred or not based on whether you include the `await` keyword:

    ``` javascript
    return defer({
      // not deferred:
      packageLocation: await packageLocationPromise,
      // deferred:
      packageLocation: packageLocationPromise,
    });
    ```

    Because of this, you can A/B test deferring, or even determine whether to defer based on the user or data being requested:

    ``` javascript
    async function loader({ request, params }) {
      const packageLocationPromise = getPackageLocation(
        params.packageId
      );
      const shouldDefer = shouldDeferPackageLocation(
        request,
        params.packageId
      );

      return defer({
        packageLocation: shouldDefer
          ? packageLocationPromise
          : await packageLocationPromise,
      });
    }
    ```

    That `shouldDeferPackageLocation` could be implemented to check the user making the request, whether the package location data is in a cache, the status of an A/B test, or whatever else you want. This is pretty sweet 🍭
- name: Examples
  id: start/examples
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  description: "# Examples\n\nYou can find many examples, including running version of them on StackBlitz in the GitHub repository:\n\n<https://github.com/remix-run/react-router/tree/dev/examples>\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/start/examples](https://reactrouterdotcom.fly.dev/docs/en/v6/start/examples)"
- name: fallbackElement
  id: routers/router-provider#fallbackelement
  summary: If you are not server rendering your app, DataBrowserRouter will initiate all matching route loaders when it mounts
  belongs_to: <RouterProvider>
  description: "## `fallbackElement`\n\nIf you are not server rendering your app, `DataBrowserRouter` will initiate all matching route loaders when it mounts. During this time, you can provide a `fallbackElement` to give the user some indication that the app is working. Make that static hosting TTFB count!\n\n``` javascript\n<RouterProvider\n  router={router}\n  fallbackElement={<SpinnerOfDoom />}\n/>\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/routers/router-provider](https://reactrouterdotcom.fly.dev/docs/en/v6/routers/router-provider)"
- name: FAQ
  id: guides/deferred#faq
  summary: null
  belongs_to: Deferred Data Guide
  description: '## FAQ'
- name: FAQs
  id: start/faq
  summary: Here are some questions that people commonly have about React Router v6
  description: "# FAQs\n\nHere are some questions that people commonly have about React Router v6. You might also find what you're looking for in the [examples](https://github.com/remix-run/react-router/tree/dev/examples).\n\n## What happened to withRouter? I need it!\n\nThis question usually stems from the fact that you're using React class components, which don't support hooks. In React Router v6, we fully embraced hooks and use them to share all the router's internal state. But that doesn't mean you can't use the router. Assuming you can actually use hooks (you're on React 16.8+), you just need a wrapper.\n\n``` javascript\nimport {\n  useLocation,\n  useNavigate,\n  useParams,\n} from \"react-router-dom\";\n\nfunction withRouter(Component) {\n  function ComponentWithRouterProp(props) {\n    let location = useLocation();\n    let navigate = useNavigate();\n    let params = useParams();\n    return (\n      <Component\n        {...props}\n        router={{ location, navigate, params }}\n      />\n    );\n  }\n\n  return ComponentWithRouterProp;\n}\n```\n\n## Why does `<Route>` have an `element` prop instead of `render` or `component`?\n\nIn React Router v6 we switched from using v5's `<Route component>` and `<Route render>` APIs to `<Route element>`. Why is that?\n\nFor starters, we see React itself taking the lead here with the `<Suspense fallback={<Spinner />}>` API. The `fallback` prop takes a React **element**, not a **component**. This lets you easily pass whatever props you want to your `<Spinner>` from the component that renders it.\n\nUsing elements instead of components means we don't have to provide a `passProps`-style API, so you can get the props you need to your elements. For example, in a component-based API there is no good way to pass props to the `<Profile>` element that is rendered when `<Route path=\":userId\" component={Profile} />` matches. Most React libraries who take this approach end up with either an API like `<Route component={Profile} passProps={{ animate: true }} />` or use a render prop or higher-order component.\n\nAlso, `Route`'s rendering API in v5 was rather large. As we worked on v4/5, the conversation went something like this:\n\n``` javascript\n// Ah, this is nice and simple!\n<Route path=\":userId\" component={Profile} />\n\n// But wait, how do I pass custom props to the <Profile> element??\n// Hmm, maybe we can use a render prop in those situations?\n<Route\n  path=\":userId\"\n  render={routeProps => (\n    <Profile routeProps={routeProps} animate={true} />\n  )}\n/>\n\n// Ok, now we have two ways to render something with a route. :/\n\n// But wait, what if we want to render something when a route\n// *doesn't* match the URL, like a Not Found page? Maybe we\n// can use another render prop with slightly different semantics?\n<Route\n  path=\":userId\"\n  children={({ match }) => (\n    match ? (\n      <Profile match={match} animate={true} />\n    ) : (\n      <NotFound />\n    )\n  )}\n/>\n\n// What if I want to get access to the route match, or I need\n// to redirect deeper in the tree?\nfunction DeepComponent(routeStuff) {\n  // got routeStuff, phew!\n}\nexport default withRouter(DeepComponent);\n\n// Well hey, now at least we've covered all our use cases!\n// ... *facepalm*\n```\n\nAt least part of the reason for this API sprawl was that React did not provide any way for us to get the information from the `<Route>` to your route element, so we had to invent clever ways to get both the route data **and** your own custom props through to your elements: `component`, render props, `passProps` higher-order-components ... until **hooks** came along!\n\nNow, the conversation above goes like this:\n\n``` javascript\n// Ah, nice and simple API. And it's just like the <Suspense> API!\n// Nothing more to learn here.\n<Route path=\":userId\" element={<Profile />} />\n\n// But wait, how do I pass custom props to the <Profile>\n// element? Oh ya, it's just an element. Easy.\n<Route path=\":userId\" element={<Profile animate={true} />} />\n\n// Ok, but how do I access the router's data, like the URL params\n// or the current location?\nfunction Profile({ animate }) {\n  let params = useParams();\n  let location = useLocation();\n}\n\n// But what about components deep in the tree?\nfunction DeepComponent() {\n  // oh right, same as anywhere else\n  let navigate = useNavigate();\n}\n\n// Aaaaaaaaand we're done here.\n```\n\nAnother important reason for using the `element` prop in v6 is that `<Route children>` is reserved for nesting routes. You can read more about this in [the guide about getting started](overview#nested-routes) with v6.\n\n## How do I add a No Match (404) Route in react-router v6?\n\nIn v4 we would have just left the path prop off a route. In v5 we would have wrapped our 404 element in a Route and used `path=\"*\"`. In v6 use the new element prop, pass `path=\"*\"` instead:\n\n``` javascript\n<Route path=\"*\" element={<NoMatch />} />\n```\n\n## `<Route>` doesn't render? How do I compose?\n\nIn v5 the `<Route>` component was just a normal component that was like an `if` statement that rendered when the URL matched its path. In v6, a `<Route>` element doesn't actually ever render, it's simply there for configuration.\n\nIn v5, since routes were just components, `MyRoute` will be rendered when the path is \"/my-route\".\n\n``` javascript\nlet App = () => (\n  <div>\n    <MyRoute />\n  </div>\n);\n\nlet MyRoute = ({ element, ...rest }) => {\n  return (\n    <Route path=\"/my-route\" children={<p>Hello!</p>} />\n  );\n};\n```\n\nIn v6, however, the `<Route>` is only used for its props, so the following code will never render `<p>Hello!</p>` because `<MyRoute>` has no path that `<Routes>` can see:\n\n``` javascript\nlet App = () => (\n  <Routes>\n    <MyRoute />\n  </Routes>\n);\n\nlet MyRoute = () => {\n  // won't ever render because the path is down here\n  return (\n    <Route path=\"/my-route\" children={<p>Hello!</p>} />\n  );\n};\n```\n\nYou can get the same behavior by:\n\n- Only rendering `<Route>` elements inside of `<Routes>`\n- Moving the composition into the `element` prop\n\n``` javascript\nlet App = () => (\n  <div>\n    <Routes>\n      <Route path=\"/my-route\" element={<MyRoute />} />\n    </Routes>\n  </div>\n);\n\nlet MyRoute = () => {\n  return <p>Hello!</p>;\n};\n```\n\nHaving a full nested route config available statically in `<Routes>` is going to enable a lot of features in `v6.x`, so we encourage you to put your routes in one top-level config. If you really like the idea of components that match the URL independent of any other components, you can make a component that behaves similarly to the v5 `Route` with this:\n\n``` javascript\nfunction MatchPath({ path, Comp }) {\n  let match = useMatch(path);\n  return match ? <Comp {...match} /> : null;\n}\n\n// Will match anywhere w/o needing to be in a `<Routes>`\n<MatchPath path=\"/accounts/:id\" Comp={Account} />;\n```\n\n## How do I nest routes deep in the tree?\n\nIn v5 you could render a `<Route>` or `<Switch>` anywhere you want. You can keep doing the very same thing, but you need to use `<Routes>` (`<Route>` without an 's' will not work). We call these \"Descendant `<Routes>`\".\n\nIt might have looked like this in v5\n\n``` javascript\n// somewhere up the tree\n<Switch>\n  <Route path=\"/users\" component={Users} />\n</Switch>;\n\n// and now deeper in the tree\nfunction Users() {\n  return (\n    <div>\n      <h1>Users</h1>\n      <Switch>\n        <Route path=\"/users/account\" component={Account} />\n      </Switch>\n    </div>\n  );\n}\n```\n\nIn v6 it's almost the same:\n\n- Note the `*` in the ancestor routes to get it to match deeper URLs even though it has no direct children\n- You no longer need to know the entire child route path, you can use a relative route now\n\n``` javascript\n// somewhere up the tree\n<Routes>\n  <Route path=\"/users/*\" element={<Users />} />\n</Routes>;\n\n// and now deeper in the tree\nfunction Users() {\n  return (\n    <div>\n      <h1>Users</h1>\n      <Routes>\n        <Route path=\"account\" element={<Account />} />\n      </Routes>\n    </div>\n  );\n}\n```\n\nIf you had a \"floating route\" in v5 (not wrapped in a `<Switch>`), simply wrap it in a `<Routes>` instead.\n\n``` javascript\n// v5\n<Route path=\"/contact\" component={Contact} />\n\n// v6\n<Routes>\n  <Route path=\"contact\" element={<Contact />} />\n</Routes>\n```\n\n## What Happened to Regexp Routes Paths?\n\nRegexp route paths were removed for two reasons:\n\n1.  Regular expression paths in routes raised a lot of questions for v6's ranked route matching. How do you rank a regex?\n\n2.  We were able to shed an entire dependency (path-to-regexp) and cut the package weight sent to your user's browser significantly. If it were added back, it would represent 1/3 of React Router's page weight!\n\nAfter looking at a lot of use cases, we found we can still meet them without direct regexp path support, so we made the tradeoff to significantly decrease the bundle size and avoid the open questions around ranking regexp routes.\n\nThe majority of regexp routes were only concerned about one URL segment at a time and doing one of two things:\n\n1.  Matching multiple static values\n2.  Validating the param in some way (is a number, not a number, etc.)\n\n**Matching generally static values**\n\nA very common route we've seen is a regex matching multiple language codes:\n\n``` javascript\nfunction App() {\n  return (\n    <Switch>\n      <Route path={/(en|es|fr)/} component={Lang} />\n    </Switch>\n  );\n}\n\nfunction Lang({ params }) {\n  let lang = params[0];\n  let translations = I81n[lang];\n  // ...\n}\n```\n\nThese are all actually just static paths, so in v6 you can make three routes and pass the code directly to the component. If you've got a lot of them, make an array and map it into routes to avoid the repetition.\n\n``` javascript\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"en\" element={<Lang lang=\"en\" />} />\n      <Route path=\"es\" element={<Lang lang=\"es\" />} />\n      <Route path=\"fr\" element={<Lang lang=\"fr\" />} />\n    </Routes>\n  );\n}\n\nfunction Lang({ lang }) {\n  let translations = I81n[lang];\n  // ...\n}\n```\n\n**Doing some sort of param validation**\n\nAnother common case was ensuring that parameters were an integer.\n\n``` javascript\nfunction App() {\n  return (\n    <Switch>\n      <Route path={/users\\/(\\d+)/} component={User} />\n    </Switch>\n  );\n}\n\nfunction User({ params }) {\n  let id = params[0];\n  // ...\n}\n```\n\nIn this case you have to do a bit of work yourself with the regex inside the matching component:\n\n``` javascript\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/users/:id\" element={<ValidateUser />} />\n      <Route path=\"/users/*\" element={<NotFound />} />\n    </Routes>\n  );\n}\n\nfunction ValidateUser() {\n  let params = useParams();\n  let userId = params.id.match(/\\d+/);\n  if (!userId) {\n    return <NotFound />;\n  }\n  return <User id={params.userId} />;\n}\n\nfunction User(props) {\n  let id = props.id;\n  // ...\n}\n```\n\nIn v5 if the regex didn't match then `<Switch>` would keep trying to match the next routes:\n\n``` javascript\nfunction App() {\n  return (\n    <Switch>\n      <Route path={/users\\/(\\d+)/} component={User} />\n      <Route path=\"/users/new\" exact component={NewUser} />\n      <Route\n        path=\"/users/inactive\"\n        exact\n        component={InactiveUsers}\n      />\n      <Route path=\"/users/*\" component={NotFound} />\n    </Switch>\n  );\n}\n```\n\nLooking at this example you might be concerned that in the v6 version your other routes won't get rendered at their URLs because the `:userId` route might match first. But, thanks to route ranking, that is not the case. The \"new\" and \"inactive\" routes will rank higher and therefore render at their respective URLs:\n\n``` javascript\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/users/:id\" element={<ValidateUser />} />\n      <Route path=\"/users/new\" element={<NewUser />} />\n      <Route\n        path=\"/users/inactive\"\n        element={<InactiveUsers />}\n      />\n    </Routes>\n  );\n}\n```\n\nIn fact, the v5 version has all sorts of problems if your routes aren't ordered *just right*. V6 completely eliminates this problem.\n\n**Remix Users**\n\nIf you're using [Remix](https://remix.run), you can send proper 40x responses to the browser by moving this work into your loader. This also decreases the size of the browser bundles sent to the user because loaders only run on the server.\n\n``` javascript\nimport { useLoaderData } from \"remix\";\n\nexport async function loader({ params }) {\n  if (!params.id.match(/\\d+/)) {\n    throw new Response(\"\", { status: 400 });\n  }\n\n  let user = await fakeDb.user.find({\n    where: { id: params.id },\n  });\n  if (!user) {\n    throw new Response(\"\", { status: 404 });\n  }\n\n  return user;\n}\n\nfunction User() {\n  let user = useLoaderData();\n  // ...\n}\n```\n\nInstead of rending your component, remix will render the nearest [catch boundary](https://remix.run/docs/en/v1/api/conventions#catchboundary) instead.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/start/faq](https://reactrouterdotcom.fly.dev/docs/en/v6/start/faq)"
- name: Feature Overview
  id: start/overview
  summary: In traditional websites, the browser requests a document from a web server, downloads and evaluates CSS and JavaScript assets, and renders the HTML sent from the server
  description: "# Feature Overview\n\n## Client Side Routing\n\nReact Router enables \"client side routing\".\n\nIn traditional websites, the browser requests a document from a web server, downloads and evaluates CSS and JavaScript assets, and renders the HTML sent from the server. When the user clicks a link, it starts the process all over again for a new page.\n\nClient side routing allows your app to update the URL from a link click without making another request for another document from the server. Instead, your app can immediately render some new UI and make data requests with `fetch` to update the page with new information.\n\nThis enables faster user experiences because the browser doesn't need to request an entirely new document or re-evaluate CSS and JavaScript assets for the next page. It also enables more dynamic user experiences with things like animation.\n\nClient side routing is enabled by creating a `Router` and linking/submitting to pages with `Link` and `<Form>`:\n\n``` javascript\nimport React from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport {\n  createBrowserRouter,\n  RouterProvider,\n  Route,\n  Link,\n} from \"react-router-dom\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: (\n      <div>\n        <h1>Hello World</h1>\n        <Link to=\"about\">About Us</Link>\n      </div>\n    ),\n  },\n  {\n    path: \"about\",\n    element: <div>About</div>,\n  },\n]);\n\ncreateRoot(document.getElementById(\"root\")).render(\n  <RouterProvider router={router} />\n);\n```\n\n## Nested Routes\n\nNested Routing is the general idea of coupling segments of the URL to component hierarchy and data. React Router's nested routes were inspired by the routing system in Ember.js circa 2014. The Ember team realized that in nearly every case, segments of the URL determine:\n\n- The layouts to render on the page\n- The data dependencies of those layouts\n\nReact Router embraces this convention with APIs for creating nested layouts coupled to URL segments and data.\n\n``` javascript\n// Configure nested routes with JSX\ncreateBrowserRouter(\n  createRoutesFromElements(\n    <Route path=\"/\" element={<Root />}>\n      <Route path=\"contact\" element={<Contact />} />\n      <Route\n        path=\"dashboard\"\n        element={<Dashboard />}\n        loader={({ request }) =>\n          fetch(\"/api/dashboard.json\", {\n            signal: request.signal,\n          })\n        }\n      />\n      <Route element={<AuthLayout />}>\n        <Route\n          path=\"login\"\n          element={<Login />}\n          loader={redirectIfUser}\n        />\n        <Route path=\"logout\" />\n      </Route>\n    </Route>\n  )\n);\n\n// Or use plain objects\ncreateBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    children: [\n      {\n        path: \"contact\",\n        element: <Contact />,\n      },\n      {\n        path: \"dashboard\",\n        element: <Dashboard />,\n        loader: ({ request }) =>\n          fetch(\"/api/dashboard.json\", {\n            signal: request.signal,\n          }),\n      },\n      {\n        element: <AuthLayout />,\n        children: [\n          {\n            path: \"login\",\n            element: <Login />,\n            loader: redirectIfUser,\n          },\n          {\n            path: \"logout\",\n            action: logoutUser,\n          },\n        ],\n      },\n    ],\n  },\n]);\n```\n\nThis [visualization](https://remix.run/_docs/routing) might be helpful.\n\n## Dynamic Segments\n\nSegments of the URL can be dynamic placeholders that are parsed and provided to various apis.\n\n``` javascript\n<Route path=\"projects/:projectId/tasks/:taskId\" />\n```\n\nThe two segments with `:` are dynamic, and provided to the following APIs:\n\n``` javascript\n// If the current location is /projects/abc/tasks/3\n<Route\n  // sent to loaders\n  loader={({ params }) => {\n    params.projectId; // abc\n    params.taskId; // 3\n  }}\n  // and actions\n  action={({ params }) => {\n    params.projectId; // abc\n    params.taskId; // 3\n  }}\n  element={<Task />}\n/>;\n\nfunction Task() {\n  // returned from `useParams`\n  const params = useParams();\n  params.projectId; // abc\n  params.taskId; // 3\n}\n\nfunction Random() {\n  const match = useMatch(\"/projects/:projectId/tasks/3\");\n  match.params.projectId; // abc\n  match.params.taskId; // 3\n}\n```\n\nSee:\n\n- [`<Route path>`](../route/route#path)\n- [`<Route loader>`](../route/loader)\n- [`<Route action>`](../route/action)\n- [`useParams`](../hooks/use-params)\n- [`useMatch`](../hooks/use-match)\n\n## Ranked Route Matching\n\nWhen matching URLs to routes, React Router will rank the routes according the number of segments, static segments, dynamic segments, splats, etc. and pick the *most specific* match.\n\nFor example, consider these two routes:\n\n``` javascript\n<Route path=\"/teams/:teamId\" />\n<Route path=\"/teams/new\" />\n```\n\nNow consider the URL is <http://example.com/teams/new>.\n\nEven though both routes technically match the URL (`new` could be the `:teamId`), you intuitively know that we want the second route (`/teams/new`) to be picked. React Router's matching algorithm knows that, too.\n\nWith ranked routes, you don't have to worry about route ordering.\n\n## Active Links\n\nMost web apps have persistent navigation sections at the top of the UI, the sidebar, and often multiple levels. Styling the active navigation items so the user knows where they are (`isActive`) or where they're going (`isPending`) in the app is done easily with `<NavLink>`.\n\n``` javascript\n<NavLink\n  style={({ isActive, isPending }) => {\n    return {\n      color: isActive ? \"red\" : \"inherit\",\n    };\n  }}\n  className={({ isActive, isPending }) => {\n    return isActive ? \"active\" : isPending ? \"pending\" : \"\";\n  }}\n/>\n```\n\nYou can also [`useMatch`](../hooks/use-match) for any other \"active\" indication outside of links.\n\n``` javascript\nfunction SomeComp() {\n  const match = useMatch(\"/messages\");\n  return <li className={Boolean(match) ? \"active\" : \"\"} />;\n}\n```\n\nSee:\n\n- [`NavLink`](../components/nav-link)\n- [`useMatch`](../hooks/use-match)\n\n## Relative Links\n\nLike HTML `<a href>`, `<Link to>` and `<NavLink to>` can take relative paths, with enhanced behavior with nested routes.\n\nGiven the following route config:\n\n``` javascript\n<Route path=\"home\" element={<Home />}>\n  <Route path=\"project/:projectId\" element={<Project />}>\n    <Route path=\":taskId\" element={<Task />} />\n  </Route>\n</Route>\n```\n\nConsider the url <https://example.com/home/project/123>, which renders the following route component hierarchy:\n\n``` javascript\n<Home>\n  <Project />\n</Home>\n```\n\nIf `<Project />` renders the following links, the hrefs of the links will resolve like so:\n\n| In `<Project>` @ `/home/project/123` | Resolved `<a href>`      |\n|--------------------------------------|--------------------------|\n| `<Link to=\"abc\">`                    | `/home/projects/123/abc` |\n| `<Link to=\".\">`                      | `/home/projects/123`     |\n| `<Link to=\"..\">`                     | `/home`                  |\n| `<Link to=\"..\" relative=\"path\">`     | `/home/projects`         |\n\nNote that the first `..` removes both segments of the `project/:projectId` route. By default, the `..` in relative links traverse the route hierarchy, not the URL segments. Adding `relative=\"path\"` in the next example allows you to traverse the path segments instead.\n\nRelative links are always relative to the route path they are *rendered in*, not to the full URL. That means if the user navigates deeper with `<Link to=\"abc\">` to `<Task />` at the URL `/home/projects/123/abc`, the hrefs in `<Project>` will not change (contrary to plain `<a href>`, a common problem with client side routers).\n\n## Data Loading\n\nBecause URL segments usually map to your app's persistent data, React Router provides conventional data loading hooks to initiate data loading during a navigation. Combined with nested routes, all of the data for multiple layouts at a specific URL can be loaded in parallel.\n\n``` javascript\n<Route\n  path=\"/\"\n  loader={async ({ request }) => {\n    // loaders can be async functions\n    const res = await fetch(\"/api/user.json\", {\n      signal: request.signal,\n    });\n    const user = await res.json();\n    return user;\n  }}\n  element={<Root />}\n>\n  <Route\n    path=\":teamId\"\n    // loaders understand Fetch Responses and will automatically\n    // unwrap the res.json(), so you can simply return a fetch\n    loader={({ params }) => {\n      return fetch(`/api/teams/${params.teamId}`);\n    }}\n    element={<Team />}\n  >\n    <Route\n      path=\":gameId\"\n      loader={({ params }) => {\n        // of course you can use any data store\n        return fakeSdk.getTeam(params.gameId);\n      }}\n      element={<Game />}\n    />\n  </Route>\n</Route>\n```\n\nData is made available to your components through `useLoaderData`.\n\n``` javascript\nfunction Root() {\n  const user = useLoaderData();\n  // data from <Route path=\"/\">\n}\n\nfunction Team() {\n  const team = useLoaderData();\n  // data from <Route path=\":teamId\">\n}\n\nfunction Game() {\n  const game = useLoaderData();\n  // data from <Route path=\":gameId\">\n}\n```\n\nWhen the user visits or clicks links to <https://example.com/real-salt-lake/45face3>, all three route loaders will be called and loaded in parallel, before the UI for that URL renders.\n\n## Redirects\n\nWhile loading or changing data, it's common to [redirect](../fetch/redirect) the user to a different route.\n\n``` javascript\n<Route\n  path=\"dashboard\"\n  loader={async () => {\n    const user = await fake.getUser();\n    if (!user) {\n      // if you know you can't render the route, you can\n      // throw a redirect to stop executing code here,\n      // sending the user to a new route\n      throw redirect(\"/login\");\n    }\n\n    // otherwise continue\n    const stats = await fake.getDashboardStats();\n    return { user, stats };\n  }}\n/>\n```\n\n``` javascript\n<Route\n  path=\"project/new\"\n  action={async ({ request }) => {\n    const data = await request.formData();\n    const newProject = await createProject(data);\n    // it's common to redirect after actions complete,\n    // sending the user to the new record\n    return redirect(`/projects/${newProject.id}`);\n  }}\n/>\n```\n\nSee:\n\n- [`redirect`](../fetch/redirect)\n- [Throwing in Loaders](../route/loader#throwing-in-loaders)\n- [`useNavigate`](../hooks/use-navigate)\n\n## Pending Navigation UI\n\nWhen users navigate around the app, the data for the next page is loaded before the page is rendered. It's important to provide user feedback during this time so the app doesn't feel like it's unresponsive.\n\n``` javascript\nfunction Root() {\n  const navigation = useNavigation();\n  return (\n    <div>\n      {navigation.state === \"loading\" && <GlobalSpinner />}\n      <FakeSidebar />\n      <Outlet />\n      <FakeFooter />\n    </div>\n  );\n}\n```\n\nSee:\n\n- [`useNavigation`](../hooks/use-navigation)\n\n## Skeleton UI with `<Suspense>`\n\nInstead of waiting for the data for the next page, you can [`defer`](../utils/defer) data so the UI flips over to the next screen with placeholder UI immediately while the data loads.\n\n``` javascript\n<Route\n  path=\"issue/:issueId\"\n  element={<Issue />}\n  loader={async ({ params }) => {\n    // these are promises, but *not* awaited\n    const comments = fake.getIssueComments(params.issueId);\n    const history = fake.getIssueHistory(params.issueId);\n    // the issue, however, *is* awaited\n    const issue = await fake.getIssue(params.issueId);\n\n    // defer enables suspense for the un-awaited promises\n    return defer({ issue, comments, history });\n  }}\n/>;\n\nfunction Issue() {\n  const { issue, history, comments } = useLoaderData();\n  return (\n    <div>\n      <IssueDescription issue={issue} />\n\n      {/* Suspense provides the placeholder fallback */}\n      <Suspense fallback={<IssueHistorySkeleton />}>\n        {/* Await manages the deferred data (promise) */}\n        <Await resolve={history}>\n          {/* this calls back when the data is resolved */}\n          {(resolvedHistory) => (\n            <IssueHistory history={resolvedHistory} />\n          )}\n        </Await>\n      </Suspense>\n\n      <Suspense fallback={<IssueCommentsSkeleton />}>\n        <Await resolve={comments}>\n          {/* ... or you can use hooks to access the data */}\n          <IssueComments />\n        </Await>\n      </Suspense>\n    </div>\n  );\n}\n\nfunction IssueComments() {\n  const comments = useAsyncValue();\n  return <div>{/* ... */}</div>;\n}\n```\n\nSee\n\n- [Deferred Data Guide](../guides/deferred)\n- [`defer`](../utils/defer)\n- [`Await`](../components/await)\n- [`useAsyncValue`](../hooks/use-async-value)\n\n## Data Mutations\n\nHTML forms are navigation events, just like links. React Router supports HTML form workflows with client side routing.\n\nWhen a form is submitted, the normal browser navigation event is prevented and a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request), with a body containing the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) of the submission, is created. This request is sent to the `<Route action>` that matches the form's `<Form action>`.\n\nForm elements's `name` prop are submitted to the action:\n\n``` javascript\n<Form action=\"/project/new\">\n  <label>\n    Project title\n    <br />\n    <input type=\"text\" name=\"title\" />\n  </label>\n\n  <label>\n    Target Finish Date\n    <br />\n    <input type=\"date\" name=\"due\" />\n  </label>\n</Form>\n```\n\nThe normal HTML document request is prevented and sent to the matching route's action (`<Route path>` that matches the `<form action>`), including the `request.formData`.\n\n``` javascript\n<Route\n  path=\"project/new\"\n  action={async ({ request }) => {\n    const formData = await request.formData();\n    const newProject = await createProject({\n      title: formData.get(\"title\"),\n      due: formData.get(\"due\"),\n    });\n    return redirect(`/projects/${newProject.id}`);\n  }}\n/>\n```\n\n## Data Revalidation\n\nDecades old web conventions indicate that when a form is posted to the server, data is changing and a new page is rendered. That convention is followed in React Router's HTML-based data mutation APIs.\n\nAfter route actions are called, the loaders for all of the data on the page is called again to ensure the UI stays up-to-date with the data automatically. No cache keys to expire, no context providers to reload.\n\nSee:\n\n- [Tutorial \"Creating Contacts\"](tutorial#creating-contacts)\n\n## Busy Indicators\n\nWhen forms are being submitted to route actions, you have access to the navigation state to display busy indicators, disable fieldsets, etc.\n\n``` javascript\nfunction NewProjectForm() {\n  const navigation = useNavigation();\n  const busy = navigation.state === \"submitting\";\n  return (\n    <Form action=\"/project/new\">\n      <fieldset disabled={busy}>\n        <label>\n          Project title\n          <br />\n          <input type=\"text\" name=\"title\" />\n        </label>\n\n        <label>\n          Target Finish Date\n          <br />\n          <input type=\"date\" name=\"due\" />\n        </label>\n      </fieldset>\n      <button type=\"submit\" disabled={busy}>\n        {busy ? \"Creating...\" : \"Create\"}\n      </button>\n    </Form>\n  );\n}\n```\n\nSee:\n\n- [`useNavigation`](../hooks/use-navigation)\n\n## Optimistic UI\n\nKnowing the [`formData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) being sent to an [action](../route/action) is often enough to skip the busy indicators and render the UI in the next state immediately, even if your asynchronous work is still pending. This is called \"optimistic UI\".\n\n``` javascript\nfunction LikeButton({ tweet }) {\n  const fetcher = useFetcher();\n\n  // if there is `formData` then it is posting to the action\n  const liked = fetcher.formData\n    ? // check the formData to be optimistic\n      fetcher.formData.get(\"liked\") === \"yes\"\n    : // if its not posting to the action, use the record's value\n      tweet.liked;\n\n  return (\n    <fetcher.Form method=\"post\" action=\"toggle-liked\">\n      <button\n        type=\"submit\"\n        name=\"liked\"\n        value={liked ? \"yes\" : \"no\"}\n      />\n    </fetcher.Form>\n  );\n}\n```\n\n(Yes, HTML buttons can have a `name` and a `value`).\n\nWhile it is more common to do optimistic UI with a [`fetcher`](../hooks/use-fetcher), you can do the same with a normal form using [`navigation.formData`](../hooks/use-navigation#navigationformdata).\n\n## Data Fetchers\n\nHTML Forms are the model for mutations but they have one major limitation: you can have only one at a time because a form submission is a navigation.\n\nMost web apps need to allow for multiple mutations to be happening at the same time, like a list of records where each can be independently deleted, marked complete, liked, etc.\n\n[Fetchers](../hooks/use-fetcher) allow you to interact with the route [actions](../route/action) and [loaders](../route/loader) without causing a navigation in the browser, but still getting all the conventional benefits like error handling, revalidation, interruption handling, and race condition handling.\n\nImagine a list of tasks:\n\n``` javascript\nfunction Tasks() {\n  const tasks = useLoaderData();\n  return tasks.map((task) => (\n    <div>\n      <p>{task.name}</p>\n      <ToggleCompleteButton task={task} />\n    </div>\n  ));\n}\n```\n\nEach task can be marked complete independently of the rest, with its own pending state and without causing a navigation with a [fetcher](../hooks/use-fetcher):\n\n``` javascript\nfunction ToggleCompleteButton({ task }) {\n  const fetcher = useFetcher();\n\n  return (\n    <fetcher.Form method=\"post\" action=\"/toggle-complete\">\n      <fieldset disabled={fetcher.state !== \"idle\"}>\n        <input type=\"hidden\" name=\"id\" value={task.id} />\n        <input\n          type=\"hidden\"\n          name=\"status\"\n          value={task.complete ? \"incomplete\" : \"complete\"}\n        />\n        <button type=\"submit\">\n          {task.status === \"complete\"\n            ? \"Mark Incomplete\"\n            : \"Mark Complete\"}\n        </button>\n      </fieldset>\n    </fetcher.Form>\n  );\n}\n```\n\nSee:\n\n- [`useFetcher`](../hooks/use-fetcher)\n\n## Race Condition Handling\n\nReact Router will cancel stale operations and only commit fresh data automatically.\n\nAny time you have asynchronous UI you have the risk of race conditions: when an async operation starts after but completes before an earlier operation. The result is a user interface that shows the wrong state.\n\nConsider a search field that updates a list as the user types:\n\nEven though the query for `q?=ryan` went out later, it completed earlier. If not handled correctly, the results will briefly be the correct values for `?q=ryan` but then flip over the incorrect results for `?q=ry`. Throttling and debouncing are not enough (you can still interrupt the requests that get through). You need to cancellation.\n\nIf you're using React Router's data conventions you avoid this problem completely and automatically.\n\nNot only does React Router handle race conditions for a navigation like this, it also handles it for many other cases like loading results for an autocomplete or performing multiple concurrent mutations with [`fetcher`](../hooks/use-fetcher) (and its automatic, concurrent revalidations).\n\n## Error Handling\n\nThe vast majority of your application errors are handled automatically by React Router. It will catch any errors that are thrown while:\n\n- rendering\n- loading data\n- updating data\n\nIn practice, this is pretty much every error in your app except those thrown in event handlers (`<button onClick>`) or `useEffect`. React Router apps tend to have very few of either.\n\nWhen an error is thrown, instead of rendering the route's [`element`](../route/route#element), the [`errorElement`](../route/error-element) is rendered.\n\n``` javascript\n<Route\n  path=\"/\"\n  loader={() => {\n    something.that.throws.an.error();\n  }}\n  // this will not be rendered\n  element={<HappyPath />}\n  // but this will instead\n  errorElement={<ErrorBoundary />}\n/>\n```\n\nIf a route doesn't have an `errorElement`, the error will bubble to the nearest parent route with an `errorElement`:\n\n``` javascript\n<Route\n  path=\"/\"\n  element={<HappyPath />}\n  errorElement={<ErrorBoundary />}\n>\n  {/* Errors here bubble up to the parent route */}\n  <Route path=\"login\" element={<Login />} />\n</Route>\n```\n\nSee:\n\n- [`<Route errorElement>`](../route/error-element)\n- [`useRouteError`](../hooks/use-route-error)\n\n## Scroll Restoration\n\nReact Router will emulate the browser's scroll restoration on navigation, waiting for data to load before scrolling. This ensures the scroll position is restored to the right spot.\n\nYou can also customize the behavior by restoring based on something other than locations (like a url pathname) and preventing the scroll from happening on certain links (like tabs in the middle of a page).\n\nSee:\n\n- [`<ScrollRestoration>`](../components/scroll-restoration)\n\n## Web Standard APIs\n\nReact Router is built on web standard APIs. [Loaders](../route/loader) and [actions](../route/action) receive standard Web Fetch API [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) objects and can return [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) objects, too. Cancellation is done with [Abort Signals](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal), search params are handled with [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams), and data mutations are handled with [HTML Forms](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form).\n\nWhen you get better at React Router, you get better at the web platform.\n\n## Search Params\n\nTODO:\n\n## Location State\n\nTODO:\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/start/overview](https://reactrouterdotcom.fly.dev/docs/en/v6/start/overview)"
- name: fetcher.data
  id: hooks/use-fetcher#fetcherdata
  summary: The returned data from the loader or action is stored here
  belongs_to: useFetcher
  description: |-
    ## `fetcher.data`

    The returned data from the loader or action is stored here. Once the data is set, it persists on the fetcher even through reloads and resubmissions.

    ``` javascript
    function ProductDetails({ product }) {
      const fetcher = useFetcher();

      return (
        <details
          onToggle={(event) => {
            if (
              event.currentTarget.open &&
              fetcher.state === "idle" &&
              !fetcher.data
            ) {
              fetcher.load(`/product/${product.id}/details`);
            }
          }}
        >
          <summary>{product.name}</summary>
          {fetcher.data ? (
            <div>{fetcher.data}</div>
          ) : (
            <div>Loading product details...</div>
          )}
        </details>
      );
    }
    ```
- name: fetcher.Form
  id: hooks/use-fetcher#fetcherform
  summary: Just like <Form> except it doesn't cause a navigation
  belongs_to: useFetcher
  description: |-
    ## `fetcher.Form`

    Just like `<Form>` except it doesn't cause a navigation. (You'll get over the dot in JSX ... we hope!)

    ``` javascript
    function SomeComponent() {
      const fetcher = useFetcher();
      return (
        <fetcher.Form method="post" action="/some/route">
          <input type="text" />
        </fetcher.Form>
      );
    }
    ```
- name: fetcher.formAction
  id: hooks/use-fetcher#fetcherformaction
  summary: Tells you the action url the form is being submitted to
  belongs_to: useFetcher
  description: |-
    ## `fetcher.formAction`

    Tells you the action url the form is being submitted to.

    ``` javascript
    <fetcher.Form action="/mark-as-read" />;

    // when the form is submitting
    fetcher.formAction; // "mark-as-read"
    ```
- name: fetcher.formData
  id: hooks/use-fetcher#fetcherformdata
  summary: When using <fetcher.Form> or fetcher.submit(), the form data is available to build optimistic UI
  belongs_to: useFetcher
  description: |-
    ## `fetcher.formData`

    When using `<fetcher.Form>` or `fetcher.submit()`, the form data is available to build optimistic UI.

    ``` javascript
    function TaskCheckbox({ task }) {
      let fetcher = useFetcher();

      // while data is in flight, use that to immediately render
      // the state you expect the task to be in when the form
      // submission completes, instead of waiting for the
      // network to respond. When the network responds, the
      // formData will no longer be available and the UI will
      // use the value in `task.status` from the revalidation
      let status =
        fetcher.formData?.get("status") || task.status;

      let isComplete = status === "complete";

      return (
        <fetcher.Form method="post">
          <button
            type="submit"
            name="status"
            value={isComplete ? "incomplete" : "complete"}
          >
            {isComplete ? "Mark Incomplete" : "Mark Complete"}
          </button>
        </fetcher.Form>
      );
    }
    ```
- name: fetcher.formMethod
  id: hooks/use-fetcher#fetcherformmethod
  summary: 'Tells you the method of the form being submitted: get, post, put, patch, or delete'
  belongs_to: useFetcher
  description: "## `fetcher.formMethod`\n\nTells you the method of the form being submitted: get, post, put, patch, or delete.\n\n``` javascript\n<fetcher.Form method=\"post\" />;\n\n// when the form is submitting\nfetcher.formMethod; // \"post\"\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-fetcher](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-fetcher)"
- name: fetcher.load()
  id: hooks/use-fetcher#fetcherload
  summary: Loads data from a route loader
  belongs_to: useFetcher
  description: |-
    ## `fetcher.load()`

    Loads data from a route loader.

    ``` javascript
    import { useFetcher } from "react-router-dom";

    function SomeComponent() {
      const fetcher = useFetcher();

      useEffect(() => {
        if (fetcher.state === "idle" && !fetcher.data) {
          fetcher.load("/some/route");
        }
      }, [fetcher]);

      return <div>{fetcher.data || "Loading..."}</div>;
    }
    ```

    Although a URL might match multiple nested routes, a `fetcher.load()` call will only call the loader on the leaf match (or parent of [index routes](../guides/index-search-param)).

    If you find yourself calling this function inside of click handlers, you can probably simplify your code by using `<fetcher.Form>` instead.

    Any `fetcher.load` calls that are active on the page will be re-executed as part of revalidation (either after a navigation submission, another fetcher submission, or a `useRevalidator()` call)
- name: fetcher.state
  id: hooks/use-fetcher#fetcherstate
  summary: You can know the state of the fetcher with fetcher.state
  belongs_to: useFetcher
  description: |-
    ## `fetcher.state`

    You can know the state of the fetcher with `fetcher.state`. It will be one of:

    - **idle** - nothing is being fetched.
    - **submitting** - A route action is being called due to a fetcher submission using POST, PUT, PATCH, or DELETE
    - **loading** - The fetcher is calling a loader (from a `fetcher.load`) or is being revalidated after a separate submission or `useRevalidator` call

    &nbsp;
- name: fetcher.submit()
  id: hooks/use-fetcher#fetchersubmit
  summary: The imperative version of <fetcher.Form>. If a user interaction should initiate the fetch, you should use <fetcher.Form>. But if you, the programmer are initiating the fetch (not in response to a user clicking a button, etc.), then use this function
  belongs_to: useFetcher
  description: |-
    ## `fetcher.submit()`

    The imperative version of `<fetcher.Form>`. If a user interaction should initiate the fetch, you should use `<fetcher.Form>`. But if you, the programmer are initiating the fetch (not in response to a user clicking a button, etc.), then use this function.

    For example, you may want to log the user out after a certain amount of idle time:

    ``` javascript
    import { useFetcher } from "react-router-dom";
    import { useFakeUserIsIdle } from "./fake/hooks";

    export function useIdleLogout() {
      const fetcher = useFetcher();
      const userIsIdle = useFakeUserIsIdle();

      useEffect(() => {
        if (userIsIdle) {
          fetcher.submit(
            { idle: true },
            { method: "post", action: "/logout" }
          );
        }
      }, [userIsIdle]);
    }
    ```

    If you want to submit to an index route, use the [`?index` param](../guides/index-search-param).

    If you find yourself calling this function inside of click handlers, you can probably simplify your code by using `<fetcher.Form>` instead.
- name: generatePath
  id: utils/generate-path
  summary: generatePath interpolates a set of params into a route path string with :id and * placeholders
  description: "# `generatePath`\n\nType declaration\n\n``` javascript\ndeclare function generatePath<Path extends string>(\n  path: Path,\n  params?: {\n    [key in PathParams<Path>]: string;\n  }\n): string;\n```\n\n`generatePath` interpolates a set of params into a route path string with `:id` and `*` placeholders. This can be useful when you want to eliminate placeholders from a route path so it matches statically instead of using a dynamic parameter.\n\n``` javascript\ngeneratePath(\"/users/:id\", { id: \"42\" }); // \"/users/42\"\ngeneratePath(\"/files/:type/*\", {\n  type: \"img\",\n  \"*\": \"cat.jpg\",\n}); // \"/files/img/cat.jpg\"\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/utils/generate-path](https://reactrouterdotcom.fly.dev/docs/en/v6/utils/generate-path)"
- name: GET submissions
  id: components/form#get-submissions
  summary: The default method is "get". Get submissions will not call an action
  belongs_to: <Form>
  description: |-
    ### GET submissions

    The default method is "get". Get submissions *will not call an action*. Get submissions are the same as a normal navigation (user clicks a link) except the user gets to supply the search params that go to the URL from the form.

    ``` javascript
    <Form method="get" action="/products">
      <input
        aria-label="search products"
        type="text"
        name="q"
      />
      <button type="submit">Search</button>
    </Form>
    ```

    Let's say the user types in "running shoes" and submits the form. React Router emulates the browser and will serialize the form into [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) and then navigate the user to `"/products?q=running+shoes"`. It's as if you rendered a `<Link to="/products?q=running+shoes">` as the developer, but instead you let the user supply the query string dynamically.

    Your route loader can access these values most conveniently by creating a new [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL) from the `request.url` and then load the data.

    ``` javascript
    <Route
      path="/products"
      loader={async ({ request }) => {
        let url = new URL(request.url);
        let searchTerm = url.searchParams.get("q");
        return fakeSearchProducts(searchTerm);
      }}
    />
    ```
- name: GET Submissions with Client Side Routing
  id: start/tutorial#get-submissions-with-client-side-routing
  summary: Let's use client side routing to submit this form and filter the list in our existing loader
  belongs_to: Tutorial
  description: |-
    ## GET Submissions with Client Side Routing

    Let's use client side routing to submit this form and filter the list in our existing loader.

    👉 **Change `<form>` to `<Form>`**

    ``` javascript
    <Form id="search-form" role="search">
      <input
        id="q"
        aria-label="Search contacts"
        placeholder="Search"
        type="search"
        name="q"
      />
      <div id="search-spinner" aria-hidden hidden={true} />
      <div className="sr-only" aria-live="polite"></div>
    </Form>
    ```

    👉 **Filter the list if there are URLSearchParams**

    ``` javascript
    export async function loader({ request }) {
      const url = new URL(request.url);
      const q = url.searchParams.get("q");
      const contacts = await getContacts(q);
      return { contacts };
    }
    ```

    Because this is a GET, not a POST, React Router *does not* call the `action`. Submitting a GET form is the same as clicking a link: only the URL changes. That's why the code we added for filtering is in the `loader`, not the `action` of this route.

    This also means it's a normal page navigation. You can click the back button to get back to where you were.
- name: getKey
  id: components/scroll-restoration#getkey
  summary: Optional prop that defines the key React Router should use to restore scroll positions
  belongs_to: <ScrollRestoration />
  description: |-
    ## `getKey`

    Optional prop that defines the key React Router should use to restore scroll positions.

    ``` javascript
    <ScrollRestoration
      getKey={(location, matches) => {
        // default behavior
        return location.key;
      }}
    />
    ```

    By default it uses `location.key`, emulating the browser's default behavior without client side routing. The user can navigate to the same URL multiple times in the stack and each entry gets its own scroll position to restore.

    Some apps may want to override this behavior and restore position based on something else. Consider a social app that has four primary pages:

    - "/home"
    - "/messages"
    - "/notifications"
    - "/search"

    If the user starts at "/home", scrolls down a bit, clicks "messages" in the navigation menu, then clicks "home" in the navigation menu (not the back button!) there will be three entries in the history stack:

    By default, React Router (and the browser) will have two different scroll positions stored for `1` and `3` even though they have the same URL. That means as the user navigated from `2` → `3` the scroll position goes to the top instead of restoring to where it was in `1`.

    A solid product decision here is to keep the users scroll position on the home feed no matter how they got there (back button or new link clicks). For this, you'd want to use the `location.pathname` as the key.

    ``` javascript
    <ScrollRestoration
      getKey={(location, matches) => {
        return location.pathname;
      }}
    />
    ```

    Or you may want to only use the pathname for some paths, and use the normal behavior for everything else:

    ``` javascript
    <ScrollRestoration
      getKey={(location, matches) => {
        const paths = ["/home", "/notifications"];
        return paths.includes(location.pathname)
          ? // home and notifications restore by pathname
            location.pathname
          : // everything else by location like the browser
            location.key;
      }}
    />
    ```
- name: Global Pending UI
  id: start/tutorial#global-pending-ui
  summary: As the user navigates the app, React Router will leave the old page up as data is loading for the next page
  belongs_to: Tutorial
  description: |-
    ## Global Pending UI

    As the user navigates the app, React Router will *leave the old page up* as data is loading for the next page. You may have noticed the app feels a little unresponsive as you click between the list. Let's provide the user with some feedback so the app doesn't feel unresponsive.

    React Router is managing all of the state behind the scenes and reveals the pieces of it you need to build dynamic web apps. In this case, we'll use the [`useNavigation`](../hooks/use-navigation) hook.

    👉 **`useNavigation` to add global pending UI**

    ``` javascript
    import {
      // existing code
      useNavigation,
    } from "react-router-dom";

    // existing code

    export default function Root() {
      const { contacts } = useLoaderData();
      const navigation = useNavigation();

      return (
        <>
          <div id="sidebar">{/* existing code */}</div>
          <div
            id="detail"
            className={
              navigation.state === "loading" ? "loading" : ""
            }
          >
            <Outlet />
          </div>
        </>
      );
    }
    ```

    [`useNavigation`](../hooks/use-navigation) returns the current navigation state: it can be one of `"idle" | "submitting" | "loading"`.

    In our case, we add a `"loading"` class to the main part of the app if we're not idle. The CSS then adds a nice fade after a short delay (to avoid flickering the UI for fast loads). You could do anything you want though, like show a spinner or loading bar across the top.

    Note that our data model (`src/contact.js`) has a clientside cache, so navigating to the same contact is fast the second time. This behavior is *not* React Router, it will re-load data for changing routes no matter if you've been there before or not. It does, however, avoid calling the loaders for *unchanging* routes (like the list) during a navigation.
- name: Handling Not Found Errors
  id: start/tutorial#handling-not-found-errors
  summary: It's always a good idea to know how your app responds to errors early in the project because we all write far more bugs than features when building a new app! Not only will your users get a good experience when this happens, but it helps you during development as well
  belongs_to: Tutorial
  description: |-
    ## Handling Not Found Errors

    It's always a good idea to know how your app responds to errors early in the project because we all write far more bugs than features when building a new app! Not only will your users get a good experience when this happens, but it helps you during development as well.

    We added some links to this app, let's see what happens when we click them?

    👉 **Click one of the sidebar names**

    Gross! This is the default error screen in React Router, made worse by our flex box styles on the root element in this app 😂.

    Anytime your app throws an error while rendering, loading data, or performing data mutations, React Router will catch it and render an error screen. Let's make our own error page.

    👉 **Create an error page component**

    ``` javascript
    touch src/error-page.jsx
    ```

    ``` javascript
    import { useRouteError } from "react-router-dom";

    export default function ErrorPage() {
      const error = useRouteError();
      console.error(error);

      return (
        <div id="error-page">
          <h1>Oops!</h1>
          <p>Sorry, an unexpected error has occurred.</p>
          <p>
            <i>{error.statusText || error.message}</i>
          </p>
        </div>
      );
    }
    ```

    👉 **Set the `<ErrorPage>` as the [`errorElement`](../route/error-element) on the root route**

    ``` javascript
    /* previous imports */
    import ErrorPage from "./error-page";

    const router = createBrowserRouter([
      {
        path: "/",
        element: <Root />,
        errorElement: <ErrorPage />,
      },
    ]);

    ReactDOM.createRoot(document.getElementById("root")).render(
      <React.StrictMode>
        <RouterProvider router={router} />
      </React.StrictMode>
    );
    ```

    The error page should now look like this:

    (Well, that's not much better. Maybe somebody forgot to ask the designer to make an error page. Maybe everybody forgets to ask the designer to make an error page and then blames the designer for not thinking of it 😆)

    Note that [`useRouteError`](../hooks/use-route-error) provides the error that was thrown. When the user navigates to routes that don't exist you'll get an [error response](../utils/is-route-error-response) with a "Not Found" `statusText`. We'll see some other errors later in the tutorial and discuss them more.

    For now, it's enough to know that pretty much all of your errors will now be handled by this page instead of infinite spinners, unresponsive pages, or blank screens 🙌
- name: History and Locations
  id: start/concepts#history-and-locations
  summary: Before React Router can do anything, it has to be able to subscribe to changes in the browser history stack
  belongs_to: Main Concepts
  description: |-
    ## History and Locations

    Before React Router can do anything, it has to be able to subscribe to changes in the browser [history stack](#history-stack).

    Browsers maintain their own history stack as the user navigates around. That's how the back and forward buttons can work. In a traditional website (HTML documents without JavaScript) the browser will make requests to the server every time the user clicks a link, submits a form, or clicks the back and forward buttons.

    For example, consider the user:

    1.  clicks a link to `/dashboard`
    2.  clicks a link to `/accounts`
    3.  clicks a link to `/customers/123`
    4.  clicks the back button
    5.  clicks a link to `/dashboard`

    The history stack will change as follows where **bold** entries denote the current [URL](#url):

    1.  **`/dashboard`**
    2.  `/dashboard`, **`/accounts`**
    3.  `/dashboard`, `/accounts`, **`/customers/123`**
    4.  `/dashboard`, **`/accounts`**, `/customers/123`
    5.  `/dashboard`, `/accounts`, **`/dashboard`**

    &nbsp;
- name: History Object
  id: start/concepts#history-object
  summary: With client side routing, developers are able to manipulate the browser history stack programmatically
  belongs_to: Main Concepts
  description: |-
    ### History Object

    With **client side routing**, developers are able to manipulate the browser [history stack](#history-stack) programmatically. For example, we can write some code like this to change the [URL](#url) without the browsers default behavior of making a request to the server:

    ``` javascript
    <a
      href="/contact"
      onClick={(event) => {
        // stop the browser from changing the URL and requesting the new document
        event.preventDefault();
        // push an entry into the browser history stack and change the URL
        window.history.pushState({}, undefined, "/contact");
      }}
    />
    ```

    For illustration only, don't use `window.history.pushState` directly in React Router

    This code changes the [URL](#url) but doesn't do anything for the UI. We would need to write some more code that changed some state somewhere to get the UI to change to the contact page. The trouble is, the browser doesn't give us a way to "listen to the URL" and subscribe to changes like this.

    Well, that's not totally true. We can listen for changes to the URL via [pop](#history-actions) events:

    ``` javascript
    window.addEventListener("popstate", () => {
      // URL changed!
    });
    ```

    But that only fires when the user clicks the back or forward buttons. There is no event for when the programmer called `window.history.pushState` or `window.history.replaceState`.

    That's where a React Router specific `history` object comes into play. It provides a way to "listen for [URL](#url)" changes whether the [history action](#history-actions) is **push**, **pop**, or **replace**.

    ``` javascript
    let history = createBrowserHistory();
    history.listen(({ location, action }) => {
      // this is called whenever new locations come in
      // the action is POP, PUSH, or REPLACE
    });
    ```

    Apps don't need to set up their own history objects--that's job of `<Router>`. It sets up one of these objects, subscribe to changes in the [history stack](#history-stack), and finally updates its state when the [URL](#url) changes. This causes the app to re-render and the correct UI to display. The only thing it needs to put on state is a `location`, everything else works from that single object.
- name: Hot-fix Releases
  id: guides/contributing#hot-fix-releases
  summary: Sometimes we have a crucial bug that needs to be patched right away
  belongs_to: Contributing to React Router
  description: "### Hot-fix Releases\n\nSometimes we have a crucial bug that needs to be patched right away. If the bug affects the latest release, we can create a new version directly from `main` (or the relevant major release branch where the bug exists):\n\n``` javascript\n# From the main branch, make sure to run the build and all tests\n# before creating a new release.\nyarn && yarn build && yarn test\n\n# Assuming the tests pass, create the release tag and update\n# version references throughout the codebase.\nyarn run version patch\n\n# Push changes along with the new release tag.\ngit push origin main --follow-tags\n\n# In GitHub, create the release from the new tag and it will be\n# published via GitHub actions\n\n# When the hot-fix is done, merge the changes into dev and clean\n# up conflicts as needed.\ngit checkout dev\ngit merge main\ngit push origin dev\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/guides/contributing](https://reactrouterdotcom.fly.dev/docs/en/v6/guides/contributing)"
- name: How do I add a No Match (404) Route in react-router v6?
  id: start/faq#how-do-i-add-a-no-match-404-route-in-react-router-v6
  summary: In v4 we would have just left the path prop off a route
  belongs_to: FAQs
  description: |-
    ## How do I add a No Match (404) Route in react-router v6?

    In v4 we would have just left the path prop off a route. In v5 we would have wrapped our 404 element in a Route and used `path="*"`. In v6 use the new element prop, pass `path="*"` instead:

    ``` javascript
    <Route path="*" element={<NoMatch />} />
    ```
- name: How do I nest routes deep in the tree?
  id: start/faq#how-do-i-nest-routes-deep-in-the-tree
  summary: In v5 you could render a <Route> or <Switch> anywhere you want
  belongs_to: FAQs
  description: |-
    ## How do I nest routes deep in the tree?

    In v5 you could render a `<Route>` or `<Switch>` anywhere you want. You can keep doing the very same thing, but you need to use `<Routes>` (`<Route>` without an 's' will not work). We call these "Descendant `<Routes>`".

    It might have looked like this in v5

    ``` javascript
    // somewhere up the tree
    <Switch>
      <Route path="/users" component={Users} />
    </Switch>;

    // and now deeper in the tree
    function Users() {
      return (
        <div>
          <h1>Users</h1>
          <Switch>
            <Route path="/users/account" component={Account} />
          </Switch>
        </div>
      );
    }
    ```

    In v6 it's almost the same:

    - Note the `*` in the ancestor routes to get it to match deeper URLs even though it has no direct children
    - You no longer need to know the entire child route path, you can use a relative route now

    ``` javascript
    // somewhere up the tree
    <Routes>
      <Route path="/users/*" element={<Users />} />
    </Routes>;

    // and now deeper in the tree
    function Users() {
      return (
        <div>
          <h1>Users</h1>
          <Routes>
            <Route path="account" element={<Account />} />
          </Routes>
        </div>
      );
    }
    ```

    If you had a "floating route" in v5 (not wrapped in a `<Switch>`), simply wrap it in a `<Routes>` instead.

    ``` javascript
    // v5
    <Route path="/contact" component={Contact} />

    // v6
    <Routes>
      <Route path="contact" element={<Contact />} />
    </Routes>
    ```
- name: index
  id: route/route#index
  summary: Determines if the route is an index route
  belongs_to: Route
  description: |-
    ## `index`

    Determines if the route is an index route. Index routes render into their parent's [Outlet](outlet) at their parent's URL (like a default child route).

    ``` javascript
    <Route path="/teams" element={<Teams />}>
      <Route index element={<TeamsIndex />} />
      <Route path=":teamId" element={<Team />} />
    </Route>
    ```

    These special routes can be confusing to understand at first, so we have a guide dedicated to them here: [Index Route](../guides/index-route).
- name: Index Query Param
  id: guides/index-search-param
  summary: You may find a wild ?index appear in the URL of your app when submitting forms
  description: "# Index Query Param\n\nYou may find a wild `?index` appear in the URL of your app when submitting forms.\n\nBecause of nested routes, multiple routes in your route hierarchy can match the URL. Unlike navigations where all matching route loaders are called to build up the UI, when a form is submitted *only one action is called*.\n\nBecause index routes share the same URL as their parent, the `?index` param lets you disambiguate between the two.\n\nFor example, consider the following router and forms:\n\n``` javascript\ncreateBrowserRouter([\n  {\n    path: \"/projects\",\n    element: <ProjectsLayout />,\n    action: ProjectsLayout.action,\n    children: [\n      {\n        index: true,\n        element: <ProjectsIndex />,\n        action: ProjectsPage.action,\n      },\n    ],\n  },\n]);\n\n<Form method=\"post\" action=\"/projects\" />;\n<Form method=\"post\" action=\"/projects?index\" />;\n```\n\nThe `?index` param will submit to the index route, the action without the index param will submit to the parent route.\n\nWhen a `<Form>` is rendered in an index route without an `action`, the `?index` param will automatically be appended so that the form posts to the index route. The following form, when submitted, will post to `/projects?index` because it is rendered in the context of the projects index route:\n\n``` javascript\nfunction ProjectsIndex() {\n  return <Form method=\"post\" />;\n}\n```\n\nIf you moved the code to the `ProjectsLayout` route, it would instead post to `/projects`.\n\nThis applies to `<Form>` and all of its cousins:\n\n``` javascript\nlet submit = useSubmit();\nsubmit({}, { action: \"/projects\" });\nsubmit({}, { action: \"/projects?index\" });\n\nlet fetcher = useFetcher();\nfetcher.submit({}, { action: \"/projects\" });\nfetcher.submit({}, { action: \"/projects?index\" });\n<fetcher.Form action=\"/projects\" />;\n<fetcher.Form action=\"/projects?index\" />;\n<fetcher.Form />; // defaults to the route in context\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/guides/index-search-param](https://reactrouterdotcom.fly.dev/docs/en/v6/guides/index-search-param)"
- name: Index Route
  id: guides/index-route
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  description: "# Index Route\n\nTODO\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/guides/index-route](https://reactrouterdotcom.fly.dev/docs/en/v6/guides/index-route)"
- name: Index Routes
  id: start/concepts#index-routes
  summary: League standings? How the heck did <Route index element={<LeagueStandings>}/> pop in there? It doesn't even have a path! The reason is that it's an index route
  belongs_to: Main Concepts
  description: |-
    ### Index Routes

    Remember the [route config](#route-config) for `/teams`:

    ``` javascript
    <Route path="teams" element={<Teams />}>
      <Route path=":teamId" element={<Team />} />
      <Route path="new" element={<NewTeamForm />} />
      <Route index element={<LeagueStandings />} />
    </Route>
    ```

    If the URL were `/teams/firebirds`, the element tree would be:

    ``` javascript
    <App>
      <Teams>
        <Team />
      </Teams>
    </App>
    ```

    But if the URL were `/teams`, the element tree would be:

    ``` javascript
    <App>
      <Teams>
        <LeagueStandings />
      </Teams>
    </App>
    ```

    League standings? How the heck did `<Route index element={<LeagueStandings>}/>` pop in there? It doesn't even have a path! The reason is that it's an [index route](#index-route). Index routes render in their parent route's [outlet](#outlet) at the parent route's path.

    Think of it this way, if you're not at one of the child routes' paths, the `<Outlet>` will render nothing in the UI:

    ``` javascript
    <App>
      <Teams />
    </App>
    ```

    If all the teams are in a list on the left then an empty outlet means you've got a blank page on the right! Your UI needs something to fill the space: index routes to the rescue.

    Another way to think of an index route is that it's the default child route when the parent matches but none of its children do.

    Depending on the user interface, you might not need an index route, but if there is any sort of persistent navigation in the parent route you'll most likely want index route to fill the space when the user hasn't clicked one of the items yet.
- name: Index Routes
  id: start/tutorial#index-routes
  summary: When we load up the app, you'll notice a big blank page on the right side of our list
  belongs_to: Tutorial
  description: |-
    ## Index Routes

    When we load up the app, you'll notice a big blank page on the right side of our list.

    When a route has children, and you're at the parent route's path, the `<Outlet>` has nothing to render because no children match. You can think of index routes as the default child route to fill in that space.

    👉 **Create the index route module**

    👉 **Fill in the index component's elements**

    Feel free to copy paste, nothing special here.

    ``` javascript
    export default function Index() {
      return (
        <p id="zero-state">
          This is a demo for React Router.
          <br />
          Check out{" "}
          <a href="https://reactrouter.com/">
            the docs at reactrouter.com
          </a>
          .
        </p>
      );
    }
    ```

    👉 **Configure the index route**

    ``` javascript
    // existing code
    import Index from "./routes/index";

    const router = createBrowserRouter([
      {
        path: "/",
        element: <Root />,
        errorElement: <ErrorPage />,
        loader: rootLoader,
        action: rootAction,
        children: [
          { index: true, element: <Index /> },
          /* existing routes */
        ],
      },
    ]);
    ```

    Note the [`{ index:true }`](../route/route#index) instead of [`{ path: "" }`](../route/route#path). That tells the router to match and render this route when the user is at the parent route's exact path, so there are no other child routes to render in the `<Outlet>`.

    Voila! No more blank space. It's common to put dashboards, stats, feeds, etc. at index routes. They can participate in data loading as well.
- name: init
  id: fetch/redirect#init
  summary: The Response options to be used in the response
  belongs_to: redirect
  description: "## `init`\n\nThe [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response) options to be used in the response.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/fetch/redirect](https://reactrouterdotcom.fly.dev/docs/en/v6/fetch/redirect)"
- name: initialEntries
  id: routers/create-memory-router#initialentries
  summary: The initial entries in the history stack
  belongs_to: createMemoryRouter
  description: |-
    ## `initialEntries`

    The initial entries in the history stack. This allows you to start a test (or an app) with multiple locations already in the history stack (for testing a back navigation, etc.)

    ``` javascript
    createMemoryRouter(routes, {
      initialEntries: ["/", "/events/123"],
    });
    ```
- name: initialIndex
  id: routers/create-memory-router#initialindex
  summary: The initial index in the history stack to render
  belongs_to: createMemoryRouter
  description: |-
    ## `initialIndex`

    The initial index in the history stack to render. This allows you to start a test at a specific entry. It defaults to the last entry in `initialEntries`.

    ``` javascript
    createMemoryRouter(routes, {
      initialEntries: ["/", "/events/123"],
      initialIndex: 1, // start at "/events/123"
    });
    ```
- name: Invalidating Data in Mutations
  id: guides/data-libs#invalidating-data-in-mutations
  summary: Because most of these library's have some mechanism for caching, you'll need to invalidate those caches at some point
  belongs_to: Data Library Integration
  description: |-
    ## Invalidating Data in Mutations

    Because most of these library's have some mechanism for caching, you'll need to invalidate those caches at some point.

    The perfect place to invalidate those caches is in a React Router [action](../route/action).

    ``` javascript
    import { queryClient } from "./query-client";

    export const action = async ({ request, params }) => {
      const formData = await request.formData();
      const updates = Object.fromEntries(formData);
      await updateContact(params.contactId, updates);
      await queryClient.invalidateQueries(["contacts"]);
      return redirect(`/contacts/${params.contactId}`);
    };
    ```
- name: isRouteErrorResponse
  id: utils/is-route-error-response
  summary: This returns true if a route error is a route error response
  description: "# `isRouteErrorResponse`\n\nThis returns `true` if a [route error](../hooks/use-route-error) is a *route error response*.\n\n``` javascript\nimport { isRouteErrorResponse } from \"react-router-dom\";\n\nfunction ErrorBoundary() {\n  const error = useRouteError();\n  if (isRouteErrorResponse(error)) {\n    return (\n      <div>\n        <h1>Oops!</h1>\n        <h2>{error.status}</h2>\n        <p>{error.statusText}</p>\n        {error.data?.message && <p>{error.data.message}</p>}\n      </div>\n    );\n  } else {\n    return <div>Oops</div>;\n  }\n}\n```\n\nWhen a response is thrown from an action or loader, it will be unwrapped into an `ErrorResponse` so that your component doesn't have to deal with the complexity of unwrapping it (which would require React state and effects to deal with the promise returned from `res.json()`)\n\n``` javascript\nimport { json } from \"react-router-dom\";\n\n<Route\n  errorElement={<ErrorBoundary />}\n  action={() => {\n    throw json(\n      { message: \"email is required\" },\n      { status: 400 }\n    );\n  }}\n/>;\n\nfunction ErrorBoundary() {\n  const error = useRouteError();\n  if (isRouteErrorResponse(error)) {\n    error.status; // 400\n    error.data; // { \"message: \"email is required\" }\n  }\n}\n```\n\nIf the user visits a route that does not match any routes in the app, React Router itself will throw a 404 response.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/utils/is-route-error-response](https://reactrouterdotcom.fly.dev/docs/en/v6/utils/is-route-error-response)"
- name: Issue Not Getting Attention?
  id: guides/contributing#issue-not-getting-attention
  summary: If you need a bug fixed and nobody is fixing it, your best bet is to provide a fix for it and make a pull request
  belongs_to: Contributing to React Router
  description: |-
    ## Issue Not Getting Attention?

    If you need a bug fixed and nobody is fixing it, your best bet is to provide a fix for it and make a [pull request](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request). Open source code belongs to all of us, and it's all of our responsibility to push it forward.
- name: json
  id: fetch/json
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  description: "# `json`\n\nA shortcut for:\n\n``` javascript\nnew Response(JSON.stringify(someValue), {\n  headers: {\n    \"Content-Type\": \"application/json; utf-8\",\n  },\n});\n```\n\nTypically used in loaders:\n\n``` javascript\nimport { json } from \"react-router-dom\";\n\nconst loader = async () => {\n  const data = getSomeData();\n  return json(data);\n};\n```\n\nSee also:\n\n- [Returning Responses from Loaders](../route/loader#returning-responses)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/fetch/json](https://reactrouterdotcom.fly.dev/docs/en/v6/fetch/json)"
- name: JSX Routes
  id: start/tutorial#jsx-routes
  summary: And for our final trick, many folks prefer to configure their routes with JSX
  belongs_to: Tutorial
  description: "## JSX Routes\n\nAnd for our final trick, many folks prefer to configure their routes with JSX. You can do that with `createRoutesFromElements`. There is no functional difference between JSX or objects when configuring your routes, it's simply a stylistic preference.\n\n``` javascript\nimport {\n  createRoutesFromElements,\n  createBrowserRouter,\n} from \"react-router-dom\";\n\nconst router = createBrowserRouter(\n  createRoutesFromElements(\n    <Route\n      path=\"/\"\n      element={<Root />}\n      loader={rootLoader}\n      action={rootAction}\n      errorElement={<ErrorPage />}\n    >\n      <Route errorElement={<ErrorPage />}>\n        <Route index element={<Index />} />\n        <Route\n          path=\"contacts/:contactId\"\n          element={<Contact />}\n          loader={contactLoader}\n          action={contactAction}\n        />\n        <Route\n          path=\"contacts/:contactId/edit\"\n          element={<EditContact />}\n          loader={contactLoader}\n          action={editAction}\n        />\n        <Route\n          path=\"contacts/:contactId/destroy\"\n          action={destroyAction}\n        />\n      </Route>\n    </Route>\n  )\n);\n```\n\n------------------------------------------------------------------------\n\nThat's it! Thanks for giving React Router a shot. We hope this tutorial gives you a solid start to build great user experiences. There's a lot more you can do with React Router, so make sure to check out all the APIs 😀\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/start/tutorial](https://reactrouterdotcom.fly.dev/docs/en/v6/start/tutorial)"
- name: Large List Filtering
  id: components/form#large-list-filtering
  summary: A common use case for GET submissions is filtering a large list, like ecommerce and travel booking sites
  belongs_to: <Form>
  description: "## Large List Filtering\n\nA common use case for GET submissions is filtering a large list, like ecommerce and travel booking sites.\n\n``` javascript\nfunction FilterForm() {\n  return (\n    <Form method=\"get\" action=\"/slc/hotels\">\n      <select name=\"sort\">\n        <option value=\"price\">Price</option>\n        <option value=\"stars\">Stars</option>\n        <option value=\"distance\">Distance</option>\n      </select>\n\n      <fieldset>\n        <legend>Star Rating</legend>\n        <label>\n          <input type=\"radio\" name=\"stars\" value=\"5\" />{\" \"}\n          ★★★★★\n        </label>\n        <label>\n          <input type=\"radio\" name=\"stars\" value=\"4\" /> ★★★★\n        </label>\n        <label>\n          <input type=\"radio\" name=\"stars\" value=\"3\" /> ★★★\n        </label>\n        <label>\n          <input type=\"radio\" name=\"stars\" value=\"2\" /> ★★\n        </label>\n        <label>\n          <input type=\"radio\" name=\"stars\" value=\"1\" /> ★\n        </label>\n      </fieldset>\n\n      <fieldset>\n        <legend>Amenities</legend>\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"amenities\"\n            value=\"pool\"\n          />{\" \"}\n          Pool\n        </label>\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"amenities\"\n            value=\"exercise\"\n          />{\" \"}\n          Exercise Room\n        </label>\n      </fieldset>\n      <button type=\"submit\">Search</button>\n    </Form>\n  );\n}\n```\n\nWhen the user submits this form, the form will be serialized to the URL with something like this, depending on the user's selections:\n\nYou can access those values from the `request.url`\n\n``` javascript\n<Route\n  path=\"/:city/hotels\"\n  loader={async ({ request }) => {\n    let url = new URL(request.url);\n    let sort = url.searchParams.get(\"sort\");\n    let stars = url.searchParams.get(\"stars\");\n    let amenities = url.searchParams.getAll(\"amenities\");\n    return fakeGetHotels({ sort, stars, amenities });\n  }}\n/>\n```\n\n**See also:**\n\n- [useSubmit](../hooks/use-submit)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/components/form](https://reactrouterdotcom.fly.dev/docs/en/v6/components/form)"
- name: Latest Major Releases
  id: guides/contributing#latest-major-releases
  summary: null
  belongs_to: Contributing to React Router
  description: |-
    ### Latest Major Releases

    ``` javascript
    # Start from the dev branch.
    git checkout dev

    # Merge the main branch into dev to ensure that any hotfixes and
    # docs updates are available in the release.
    git merge main

    # Create a new release branch from dev.
    git checkout -b release/v6.1.0

    # Create a new tag and update version references throughout the
    # codebase.
    yarn run version minor # | "patch" | "major"

    # Push the release branch along with the new release tag.
    git push origin release/v6.1.0 --follow-tags

    # Wait for GitHub actions to run all tests. If the tests pass, the
    # release is ready to go! Merge the release branch into main and dev.
    git checkout main
    git merge release/v6.1.0
    git checkout dev
    git merge release/v6.1.0

    # The release branch can now be deleted.
    git branch -D release/v6.1.0
    git push origin --delete release/v6.1.0

    # Now go to GitHub and create the release from the new tag. Let
    # GitHub Actions take care of the rest!
    ```
- name: Layout Routes
  id: route/route#layout-routes
  summary: Omitting the path makes this route a "layout route". It participates in UI nesting, but it does not add any segments to the URL
  belongs_to: Route
  description: |-
    ### Layout Routes

    TODO: expand with example

    Omitting the path makes this route a "layout route". It participates in UI nesting, but it does not add any segments to the URL.
- name: Layout Routes
  id: start/concepts#layout-routes
  summary: 'Here''s a part of our route config we haven''t matched yet: /privacy'
  belongs_to: Main Concepts
  description: |-
    ### Layout Routes

    Here's a part of our route config we haven't matched yet: `/privacy`. Let's look at the route config again, highlighting the matched routes:

    ``` javascript
    <Routes>
      <Route path="/" element={<App />}>
        <Route index element={<Home />} />
        <Route path="teams" element={<Teams />}>
          <Route path=":teamId" element={<Team />} />
          <Route path=":teamId/edit" element={<EditTeam />} />
          <Route path="new" element={<NewTeamForm />} />
          <Route index element={<LeagueStandings />} />
        </Route>
      </Route>
      <Route element={<PageLayout />}>
        <Route path="/privacy" element={<Privacy />} />
        <Route path="/tos" element={<Tos />} />
      </Route>
      <Route path="contact-us" element={<Contact />} />
    </Routes>
    ```

    And the resulting element tree rendered will be:

    ``` javascript
    <PageLayout>
      <Privacy />
    </PageLayout>
    ```

    The `PageLayout` route is admittedly weird. We call it a [layout route](#layout-route) because it doesn't participate in the matching at all (though its children do). It only exists to make wrapping multiple child routes in the same layout simpler. If we didn't allow this then you'd have to handle layouts in two different ways: sometimes your routes do it for you, sometimes you do it manually with lots of layout component repetition throughout your app:

    You can do it like this, but we recommend using a layout route

    ``` javascript
    <Routes>
      <Route path="/" element={<App />}>
        <Route index element={<Home />} />
        <Route path="teams" element={<Teams />}>
          <Route path=":teamId" element={<Team />} />
          <Route path=":teamId/edit" element={<EditTeam />} />
          <Route path="new" element={<NewTeamForm />} />
          <Route index element={<LeagueStandings />} />
        </Route>
      </Route>
      <Route
        path="/privacy"
        element={
          <PageLayout>
            <Privacy />
          </PageLayout>
        }
      />
      <Route
        path="/tos"
        element={
          <PageLayout>
            <Tos />
          </PageLayout>
        }
      />
      <Route path="contact-us" element={<Contact />} />
    </Routes>
    ```

    So, yeah, the semantics of a layout "route" is a bit silly since it has nothing to do with the URL matching, but it's just too convenient to disallow.
- name: Lazy Loading Example
  id: examples/lazy-loading
  summary: on demand using React.lazy() and dynamic import()
  description: "# Lazy Loading Example\n\nThis example demonstrates how to lazily load both\n\n- individual route elements\n- entire portions of your route hierarchy\n\non demand using `React.lazy()` and dynamic `import()`. Using this technique, pages that are not required on the home page can be split out into separate bundles, thereby decreasing load time on the initial page and improving performance.\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/lazy-loading?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/lazy-loading](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/lazy-loading)"
- name: Link
  id: start/concepts#link
  summary: This is the primary means of navigation
  belongs_to: Main Concepts
  description: |-
    ### Link

    This is the primary means of navigation. Rendering a `<Link>` allows the user to change the URL when they click it. React Router will prevent the browser's default behavior and tell the [history](#history) to push a new entry into the [history stack](#history-stack). The [location](#location) changes and the new [matches](#match) will render.

    However, links are accessible in that they:

    - Still render a `<a href>` so all default accessibility concerns are met (like keyboard, focusability, SEO, etc.)
    - Don't prevent the browser's default behavior if it's a right click or command/control click to "open in new tab"

    [Nested routes](#nested-routes) aren't just about rendering layouts; they also enable "relative links". Consider our `teams` route from before:

    ``` javascript
    <Route path="teams" element={<Teams />}>
      <Route path=":teamId" element={<Team />} />
    </Route>
    ```

    The `<Teams>` component can render links like:

    ``` javascript
    <Link to="psg" />
    <Link to="new" />
    ```

    The full path it links to will be `/teams/psg` and `/teams/new`. They inherit the route within which they are rendered. This makes it so your route components don't have to really know anything about the rest of the routes in the app. A very large amount of links just go one more [segment](#segment) deeper. You can rearrange your whole [route config](#route-config) and these links will likely still work just fine. This is very valuable when building out a site in the beginning and the designs and layouts are shifting around.
- name: loader
  id: route/loader
  summary: Each route can define a "loader" function to provide data to the route element before it renders
  description: "# `loader`\n\nEach route can define a \"loader\" function to provide data to the route element before it renders.\n\nThis feature only works if using a data router, see [Picking a Router](../routers/picking-a-router)\n\n``` javascript\ncreateBrowserRouter([\n  {\n    element: <Teams />,\n    path: \"teams\",\n    loader: async () => {\n      return fakeDb.from(\"teams\").select(\"*\");\n    },\n    children: [\n      {\n        element: <Team />,\n        path: \":teamId\",\n        loader: async ({ params }) => {\n          return fetch(`/api/teams/${params.teamId}.json`);\n        },\n      },\n    ],\n  },\n]);\n```\n\nAs the user navigates around the app, the loaders for the next matching branch of routes will be called in parallel and their data made available to components through [`useLoaderData`](../hooks/use-loader-data).\n\n## `params`\n\nRoute params are parsed from [dynamic segments](route#dynamic-segments) and passed to your loader. This is useful for figuring out which resource to load:\n\n``` javascript\ncreateBrowserRouter([\n  {\n    path: \"/teams/:teamId\",\n    loader: ({ params }) => {\n      return fakeGetTeam(params.teamId);\n    },\n  },\n]);\n```\n\nNote that the `:teamId` in the path is parsed as provided as `params.teamId` by the same name.\n\n## `request`\n\nThis is a [Fetch Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) instance being made to your application.\n\n``` javascript\nfunction loader({ request }) {}\n```\n\n> A request?!\n\nIt might seem odd at first that loaders receive a \"request\". Consider that `<Link>` does something like the following code and ask yourself, \"what default behavior is being prevented here?\".\n\n``` javascript\n<a\n  href={props.to}\n  onClick={(event) => {\n    event.preventDefault();\n    navigate(props.to);\n  }}\n/>\n```\n\nWithout React Router, the browser would have made a *Request* to your server, but React Router prevented it! Instead of the browser sending the request to your server, React Router sends the request to your loaders.\n\nThe most common use case is creating a [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL) and reading the [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) from it:\n\n``` javascript\nfunction loader({ request }) {\n  const url = new URL(request.url);\n  const searchTerm = url.searchParams.get(\"q\");\n  return searchProducts(searchTerm);\n}\n```\n\nNote that the APIs here are not React Router specific, but rather standard web objects: [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request), [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL), [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams).\n\n## Returning Responses\n\nWhile you can return anything you want from a loader and get access to it from [`useLoaderData`](../hooks/use-loader-data), you can also return a web [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response).\n\nThis might not seem immediately useful, but consider `fetch`. Since the return value of of `fetch` is a Response, and loaders understand responses, many loaders can return a simple fetch!\n\n``` javascript\n// an HTTP/REST API\nfunction loader({ request }) {\n  return fetch(\"/api/teams.json\", {\n    signal: request.signal,\n  });\n}\n\n// or even a graphql endpoint\nfunction loader({ request, params }) {\n  return fetch(\"/_gql\", {\n    signal: request.signal,\n    method: \"post\",\n    body: JSON.stringify({\n      query: gql`...`,\n      params: params,\n    }),\n  });\n}\n```\n\nYou can construct the response yourself as well:\n\n``` javascript\nfunction loader({ request, params }) {\n  const data = { some: \"thing\" };\n  return new Response(JSON.stringify(data), {\n    status: 200,\n    headers: {\n      \"Content-Type\": \"application/json; utf-8\",\n    },\n  });\n}\n```\n\nReact Router will automatically call `response.json()` so your components don't need to parse it while rendering:\n\n``` javascript\nfunction SomeRoute() {\n  const data = useLoaderData();\n  // { some: \"thing\" }\n}\n```\n\nUsing the [`json`](../fetch/json) utility simplifies this so you don't have to construct them yourself. This next example is effectively the same as the previous example:\n\n``` javascript\nimport { json } from \"react-router-dom\";\n\nfunction loader({ request, params }) {\n  const data = { some: \"thing\" };\n  return json(data, { status: 200 });\n}\n```\n\nIf you're planning an upgrade to Remix, returning responses from every loader will make the migration smoother.\n\n## Throwing in Loaders\n\nYou can `throw` in your loader to break out of the current call stack (stop running the current code) and React Router will start over down the \"error path\".\n\n``` javascript\nfunction loader({ request, params }) {\n  const res = await fetch(`/api/properties/${params.id}`);\n  if (res.status === 404) {\n    throw new Response(\"Not Found\", { status: 404 });\n  }\n  return res.json();\n}\n```\n\nFor more details, read the [`errorElement`](error-element) documentation.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/route/loader](https://reactrouterdotcom.fly.dev/docs/en/v6/route/loader)"
- name: loader
  id: route/route#loader
  summary: The route loader is called before the route renders and provides data for the element through useLoaderData
  belongs_to: Route
  description: |-
    ## `loader`

    The route loader is called before the route renders and provides data for the element through [`useLoaderData`](../hooks/use-loader-data).

    ``` javascript
    <Route
      path="/teams/:teamId"
      loader={({ params }) => {
        return fetchTeam(params.teamId);
      }}
    />;

    function Team() {
      let team = useLoaderData();
      // ...
    }
    ```

    If you are not using a data router like [`createBrowserRouter`](../routers/create-browser-router), this will do nothing

    Please see the [loader](loader) documentation for more details.
- name: Loading Data
  id: start/tutorial#loading-data
  summary: URL segments, layouts, and data are more often than not coupled (tripled?) together
  belongs_to: Tutorial
  description: |-
    ## Loading Data

    URL segments, layouts, and data are more often than not coupled (tripled?) together. We can see it in this app already:

    | URL Segment  | Component   | Data               |
    |--------------|-------------|--------------------|
    | /            | `<Root>`    | list of contacts   |
    | contacts/:id | `<Contact>` | individual contact |

    Because of this natural coupling, React Router has data conventions to get data into your route components easily.

    There are two APIs we'll be using to load data, [`loader`](../route/loader) and [`useLoaderData`](../hooks/use-loader-data). First we'll create and export a loader function in the root module, then we'll hook it up to the route. Finally, we'll access and render the data.

    👉 **Export a loader from `root.jsx`**

    ``` javascript
    import { Outlet, Link } from "react-router-dom";
    import { getContacts } from "../contacts";

    export async function loader() {
      const contacts = await getContacts();
      return { contacts };
    }
    ```

    👉 **Configure the loader on the route**

    ``` javascript
    /* other imports */
    import Root, { loader as rootLoader } from "./routes/root";

    const router = createBrowserRouter([
      {
        path: "/",
        element: <Root />,
        errorElement: <ErrorPage />,
        loader: rootLoader,
        children: [
          {
            path: "contacts/:contactId",
            element: <Contact />,
          },
        ],
      },
    ]);
    ```

    👉 **Access and render the data**

    ``` javascript
    import {
      Outlet,
      Link,
      useLoaderData,
    } from "react-router-dom";
    import { getContacts } from "../contacts";

    /* other code */

    export default function Root() {
      const { contacts } = useLoaderData();
      return (
        <>
          <div id="sidebar">
            <h1>React Router Contacts</h1>
            {/* other code */}

            <nav>
              {contacts.length ? (
                <ul>
                  {contacts.map((contact) => (
                    <li key={contact.id}>
                      <Link to={`contacts/${contact.id}`}>
                        {contact.first || contact.last ? (
                          <>
                            {contact.first} {contact.last}
                          </>
                        ) : (
                          <i>No Name</i>
                        )}{" "}
                        {contact.favorite && <span>★</span>}
                      </Link>
                    </li>
                  ))}
                </ul>
              ) : (
                <p>
                  <i>No contacts</i>
                </p>
              )}
            </nav>

            {/* other code */}
          </div>
        </>
      );
    }
    ```

    That's it! React Router will now automatically keep that data in sync with your UI. We don't have any data yet, so you're probably getting a blank list like this:
- name: Loading Data
  id: guides/data-libs#loading-data
  summary: Instead of loading data in components, you use your data abstractions inside of loaders
  belongs_to: Data Library Integration
  description: |-
    ## Loading Data

    Instead of loading data in components, you use your data abstractions inside of loaders. Note that this loading happens outside of the React render lifecycle, so you can't use hooks like React Query's `useQuery`, you'll need to use the query client's methods directly.

    ``` javascript
    import { queryClient } from "./query-client";

    export const loader = ({ params }) => {
      return queryClient.fetchQuery(queryKey, queryFn, {
        staleTime: 10000,
      });
    };
    ```

    If the query client throws errors correctly, then React Router's [`errorElement`](../route/error-element) will work the same.

    Of course, you can use all of the features of the data library, like caching. Caching your data ensures that when the user clicks the back button to a page you've already seen, the data is loaded from the cache immediately. Sometimes caching is the right choice, sometimes you always want it fresh, but that's not a decision within the scope of React Router's data APIs.

    React Router only retains the *current page's loaderData*. If users click "back", all loaders are called again. Without a data caching library like React Query (or HTTP cache headers on your JSON API to use the browser's own HTTP cache), your app will refetch all of the data again.

    In this way, React Router is about *timing*, where React Query is about *caching*.
- name: Location
  id: utils/location
  summary: The term "location" in React Router refers to the Location interface from the history library
  description: "# `Location`\n\nThe term \"location\" in React Router refers to [the `Location` interface](https://github.com/remix-run/history/blob/main/docs/api-reference.md#location) from the [history](https://github.com/remix-run/history) library.\n\nThe `history` package is React Router's only dependency and many of the core types in React Router come directly from that library including `Location`, `To`, `Path`, and others. You can read more about the history library in [its documentation](https://github.com/remix-run/history/tree/main/docs).\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/utils/location](https://reactrouterdotcom.fly.dev/docs/en/v6/utils/location)"
- name: Location State
  id: start/overview#location-state
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Feature Overview
  description: "## Location State\n\nTODO:\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/start/overview](https://reactrouterdotcom.fly.dev/docs/en/v6/start/overview)"
- name: Locations
  id: start/concepts#locations
  summary: The browser has a location object on window.location
  belongs_to: Main Concepts
  description: |-
    ### Locations

    The browser has a location object on `window.location`. It tells you information about the [URL](#url) but also has some methods to change it:

    ``` javascript
    window.location.pathname; // /getting-started/concepts/
    window.location.hash; // #location
    window.location.reload(); // force a refresh w/ the server
    // and a lot more
    ```

    For illustration. You don't typically work with `window.location` in a React Router app

    Instead of using `window.location`, React Router has the concept of a [location](#location) that's patterned after `window.location` but is much simpler. It looks like this:

    ``` javascript
    {
      pathname: "/bbq/pig-pickins",
      search: "?campaign=instagram",
      hash: "#menu",
      state: null,
      key: "aefz24ie"
    }
    ```

    The first three: `{ pathname, search, hash }` are exactly like `window.location`. If you just add up the three you'll get the [URL](#url) the user sees in the browser:

    ``` javascript
    location.pathname + location.search + location.hash;
    // /bbq/pig-pickins?campaign=instagram#menu
    ```

    The last two, `{ state, key }`, are React Router specific.

    **Location Pathname**

    This is the part of [URL](#url) after the origin, so for `https://example.com/teams/hotspurs` the pathname is `/teams/hotspurs`. This is the only part of the location that routes match against.

    **Location Search**

    People use a lot of different terms for this part of the [URL](#url):

    - location search
    - search params
    - URL search params
    - query string

    In React Router we call it the "location search". However, location search is a serialized version of [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams). So sometimes we might call it "URL search params" as well.

    ``` javascript
    // given a location like this:
    let location = {
      pathname: "/bbq/pig-pickins",
      search: "?campaign=instagram&popular=true",
      hash: "",
      state: null,
      key: "aefz24ie",
    };

    // we can turn the location.search into URLSearchParams
    let params = new URLSearchParams(location.search);
    params.get("campaign"); // "instagram"
    params.get("popular"); // "true"
    params.toString(); // "campaign=instagram&popular=true",
    ```

    When being precise, refer to the serialized string version as "search" and the parsed version as "search params", but it's common to use the terms interchangeably when precision isn't important.

    **Location Hash**

    Hashes in URLs indicate a scroll position *on the current page*. Before the `window.history.pushState` API was introduced, web developers did client side routing exclusively with the hash portion of the [URL](#url), it was the only part we could manipulate without making a new request to the server. However, today we can use it for its designed purpose.

    **Location State**

    You may have wondered why the `window.history.pushState()` API is called "push state". State? Aren't we just changing the [URL](#url)? Shouldn't it be `history.push`? Well, we weren't in the room when the API was designed, so we're not sure why "state" was the focus, but it is a cool feature of browsers nonetheless.

    Browsers let us persist information about a navigation by passing a value to `pushState`. When the user clicks back, the value on `history.state` changes to whatever was "pushed" before.

    ``` javascript
    window.history.pushState("look ma!", undefined, "/contact");
    window.history.state; // "look ma!"
    // user clicks back
    window.history.state; // undefined
    // user clicks forward
    window.history.state; // "look ma!"
    ```

    For illustration. You don't read `history.state` directly in React Router apps

    React Router takes advantage of this browser feature, abstracts it a bit, and surfaces the values on the `location` instead of `history`.

    You can think about `location.state` just like `location.hash` or `location.search` except instead of putting the values in the [URL](#url) it's hidden--like a super secret piece of the URL only the programmer knows about.

    A couple of great use-cases for location state are:

    - Telling the next page where the user came from and branching the UI. The most popular implementation here is showing a record in a modal if the user clicked on an item in a grid view, but if they show up to the URL directly, show the record in its own layout (pinterest, old instagram).
    - Sending a partial record from a list to the next screen so it can render the partial data immediately and then fetching the rest of the data afterward.

    You set location state in two ways: on `<Link>` or `navigate`:

    ``` javascript
    <Link to="/pins/123" state={{ fromDashboard: true }} />;

    let navigate = useNavigate();
    navigate("/users/123", { state: partialUser });
    ```

    And on the next page you can access it with `useLocation`:

    ``` javascript
    let location = useLocation();
    location.state;
    ```

    Location state values will get serialized, so something like `new Date()` will be turned into a string.

    **Location Key**

    Each location gets a unique key. This is useful for advanced cases like location-based scroll management, client side data caching, and more. Because each new location gets a unique key, you can build abstractions that store information in a plain object, `new Map()`, or even `locationStorage`.

    For example, a very basic client side data cache could store values by location key (and the fetch [URL](#url)) and skip fetching the data when the user clicks back into it:

    ``` javascript
    let cache = new Map();

    function useFakeFetch(URL) {
      let location = useLocation();
      let cacheKey = location.key + URL;
      let cached = cache.get(cacheKey);

      let [data, setData] = useState(() => {
        // initialize from the cache
        return cached || null;
      });

      let [state, setState] = useState(() => {
        // avoid the fetch if cached
        return cached ? "done" : "loading";
      });

      useEffect(() => {
        if (state === "loading") {
          let controller = new AbortController();
          fetch(URL, { signal: controller.signal })
            .then((res) => res.json())
            .then((data) => {
              if (controller.signal.aborted) return;
              // set the cache
              cache.set(cacheKey, data);
              setData(data);
            });
          return () => controller.abort();
        }
      }, [state, cacheKey]);

      useEffect(() => {
        setState("loading");
      }, [URL]);

      return data;
    }
    ```
- name: Main Concepts
  id: start/concepts
  summary: This document is a deep dive into the core concepts behind routing as implemented in React Router
  description: "# Main Concepts\n\nThis document needs to be updated for 6.4 data APIs\n\nThis document is a deep dive into the core concepts behind routing as implemented in React Router. It's pretty long, so if you're looking for a more practical guide check out our [quick start tutorial](tutorial).\n\nYou might be wondering what exactly React Router does. How can it help you build your app? What exactly is a **router**, anyway?\n\nIf you've ever had any of these questions, or you'd just like to dig into the fundamental pieces of routing, you're in the right place. This document contains detailed explanations of all the core concepts behind routing as implemented in React Router.\n\nPlease don't let this document overwhelm you! For everyday use, React Router is pretty simple. You don't need to go this deep to use it.\n\nReact Router isn't just about matching a url to a function or component: it's about building a full user interface that maps to the URL, so it might have more concepts in it than you're used to. We'll go into detail on the three main jobs of React Router:\n\n1.  Subscribing and manipulating the [history stack](#history-stack)\n2.  Matching the [URL](#url) to your [routes](#route-config)\n3.  Rendering a nested UI from the [route matches](#matches)\n\n## Definitions\n\nBut first, some definitions! There are a lot of different ideas around routing from back and front end frameworks. Sometimes a word in one context might have different meaning than another.\n\nHere are some words we use a lot when we talk about React Router. The rest of this guide will go into more detail on each one.\n\n- **URL** - The URL in the address bar. A lot of people use the term \"URL\" and \"route\" interchangeably, but this is not a route in React Router, it's just a URL.\n\n- **Location** - This is a React Router specific object that is based on the built-in browser's `window.location` object. It represents \"where the user is at\". It's mostly an object representation of the URL but has a bit more to it than that.\n\n- **Location State** - A value that persists with a [location](#location) that isn't encoded in the [URL](#url). Much like hash or search params (data encoded in the URL), but stored invisibly in the browser's memory.\n\n- **History Stack** - As the user navigates, the browser keeps track of each [location](#location) in a stack. If you click and hold the back button in a browser you can see the browser's history stack right there.\n\n- **Client Side Routing (CSR)** - A plain HTML document can link to other documents and the browser handles the [history stack](#history-stack) itself. Client Side Routing enables developers to manipulate the browser history stack without making a document request to the server.\n\n- **History** - An object that allows React Router to subscribe to changes in the [URL](#url) as well as providing APIs to manipulate the browser [history stack](#history-stack) programmatically.\n\n- **History Action** - One of `POP`, `PUSH`, or `REPLACE`. Users can arrive at a [URL](#url) for one of these three reasons. A push when a new entry is added to the history stack (typically a link click or the programmer forced a navigation). A replace is similar except it replaces the current entry on the stack instead of pushing a new one. Finally, a pop happens when the user clicks the back or forward buttons in the browser chrome.\n\n- **Segment** - The parts of a [URL](#url) or [path pattern](#path-pattern) between the `/` characters. For example, \"/users/123\" has two segments.\n\n- **Path Pattern** - These look like URLs but can have special characters for matching URLs to routes, like **dynamic segments** (`\"/users/:userId\"`) or **star segments** (`\"/docs/*\"`). They aren't URLs, they're patterns that React Router will match.\n\n- **Dynamic Segment** - A segment of a path pattern that is dynamic, meaning it can match any values in the segment. For example the pattern `/users/:userId` will match URLs like `/users/123`\n\n- **URL Params** - The parsed values from the URL that matched a [dynamic segment](#dynamic-segment).\n\n- **Router** - Stateful, top-level component that makes all the other components and hooks work.\n\n- **Route Config** - A tree of **routes objects** that will be ranked and matched (with nesting) against the current location to create a branch of **route matches**.\n\n- **Route** - An object or Route Element typically with a shape of `{ path, element }` or `<Route path element>`. The `path` is a path pattern. When the path pattern matches the current URL, the element will be rendered.\n\n- **Route Element** - Or `<Route>`. This element's props are read to create a [route](#route) by `<Routes>`, but otherwise does nothing.\n\n- **Nested Routes** - Because routes can have children and each route defines a portion of the [URL](#url) through [segments](#segment), a single URL can match multiple routes in a nested \"branch\" of the tree. This enables automatic layout nesting through [outlet](#outlet), [relative links](#relative-links), and more.\n\n- **Relative links** - Links that don't start with `/` will inherit the closest route in which they are rendered. This makes it easy to link to deeper URLs without having to know and build up the entire path.\n\n- **Match** - An object that holds information when a route matches the URL, like the [url params](#url-params) and pathname that matched.\n\n- **Matches** - An array of routes (or branch of the [route config](#route-config)) that matches the current [location](#location). This structure enables [nested routes](#nested-routes).\n\n- **Parent Route** - A route with child routes.\n\n- **Outlet** - A component that renders the next match in a set of [matches](#match).\n\n- **Index Route** - A child route with no path that renders in the parent's [outlet](#outlet) at the parent's [URL](#url).\n\n- **Layout Route** - A **parent route** without a path, used exclusively for grouping child routes inside a specific layout.\n\n## History and Locations\n\nBefore React Router can do anything, it has to be able to subscribe to changes in the browser [history stack](#history-stack).\n\nBrowsers maintain their own history stack as the user navigates around. That's how the back and forward buttons can work. In a traditional website (HTML documents without JavaScript) the browser will make requests to the server every time the user clicks a link, submits a form, or clicks the back and forward buttons.\n\nFor example, consider the user:\n\n1.  clicks a link to `/dashboard`\n2.  clicks a link to `/accounts`\n3.  clicks a link to `/customers/123`\n4.  clicks the back button\n5.  clicks a link to `/dashboard`\n\nThe history stack will change as follows where **bold** entries denote the current [URL](#url):\n\n1.  **`/dashboard`**\n2.  `/dashboard`, **`/accounts`**\n3.  `/dashboard`, `/accounts`, **`/customers/123`**\n4.  `/dashboard`, **`/accounts`**, `/customers/123`\n5.  `/dashboard`, `/accounts`, **`/dashboard`**\n\n### History Object\n\nWith **client side routing**, developers are able to manipulate the browser [history stack](#history-stack) programmatically. For example, we can write some code like this to change the [URL](#url) without the browsers default behavior of making a request to the server:\n\n``` javascript\n<a\n  href=\"/contact\"\n  onClick={(event) => {\n    // stop the browser from changing the URL and requesting the new document\n    event.preventDefault();\n    // push an entry into the browser history stack and change the URL\n    window.history.pushState({}, undefined, \"/contact\");\n  }}\n/>\n```\n\nFor illustration only, don't use `window.history.pushState` directly in React Router\n\nThis code changes the [URL](#url) but doesn't do anything for the UI. We would need to write some more code that changed some state somewhere to get the UI to change to the contact page. The trouble is, the browser doesn't give us a way to \"listen to the URL\" and subscribe to changes like this.\n\nWell, that's not totally true. We can listen for changes to the URL via [pop](#history-actions) events:\n\n``` javascript\nwindow.addEventListener(\"popstate\", () => {\n  // URL changed!\n});\n```\n\nBut that only fires when the user clicks the back or forward buttons. There is no event for when the programmer called `window.history.pushState` or `window.history.replaceState`.\n\nThat's where a React Router specific `history` object comes into play. It provides a way to \"listen for [URL](#url)\" changes whether the [history action](#history-actions) is **push**, **pop**, or **replace**.\n\n``` javascript\nlet history = createBrowserHistory();\nhistory.listen(({ location, action }) => {\n  // this is called whenever new locations come in\n  // the action is POP, PUSH, or REPLACE\n});\n```\n\nApps don't need to set up their own history objects--that's job of `<Router>`. It sets up one of these objects, subscribe to changes in the [history stack](#history-stack), and finally updates its state when the [URL](#url) changes. This causes the app to re-render and the correct UI to display. The only thing it needs to put on state is a `location`, everything else works from that single object.\n\n### Locations\n\nThe browser has a location object on `window.location`. It tells you information about the [URL](#url) but also has some methods to change it:\n\n``` javascript\nwindow.location.pathname; // /getting-started/concepts/\nwindow.location.hash; // #location\nwindow.location.reload(); // force a refresh w/ the server\n// and a lot more\n```\n\nFor illustration. You don't typically work with `window.location` in a React Router app\n\nInstead of using `window.location`, React Router has the concept of a [location](#location) that's patterned after `window.location` but is much simpler. It looks like this:\n\n``` javascript\n{\n  pathname: \"/bbq/pig-pickins\",\n  search: \"?campaign=instagram\",\n  hash: \"#menu\",\n  state: null,\n  key: \"aefz24ie\"\n}\n```\n\nThe first three: `{ pathname, search, hash }` are exactly like `window.location`. If you just add up the three you'll get the [URL](#url) the user sees in the browser:\n\n``` javascript\nlocation.pathname + location.search + location.hash;\n// /bbq/pig-pickins?campaign=instagram#menu\n```\n\nThe last two, `{ state, key }`, are React Router specific.\n\n**Location Pathname**\n\nThis is the part of [URL](#url) after the origin, so for `https://example.com/teams/hotspurs` the pathname is `/teams/hotspurs`. This is the only part of the location that routes match against.\n\n**Location Search**\n\nPeople use a lot of different terms for this part of the [URL](#url):\n\n- location search\n- search params\n- URL search params\n- query string\n\nIn React Router we call it the \"location search\". However, location search is a serialized version of [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams). So sometimes we might call it \"URL search params\" as well.\n\n``` javascript\n// given a location like this:\nlet location = {\n  pathname: \"/bbq/pig-pickins\",\n  search: \"?campaign=instagram&popular=true\",\n  hash: \"\",\n  state: null,\n  key: \"aefz24ie\",\n};\n\n// we can turn the location.search into URLSearchParams\nlet params = new URLSearchParams(location.search);\nparams.get(\"campaign\"); // \"instagram\"\nparams.get(\"popular\"); // \"true\"\nparams.toString(); // \"campaign=instagram&popular=true\",\n```\n\nWhen being precise, refer to the serialized string version as \"search\" and the parsed version as \"search params\", but it's common to use the terms interchangeably when precision isn't important.\n\n**Location Hash**\n\nHashes in URLs indicate a scroll position *on the current page*. Before the `window.history.pushState` API was introduced, web developers did client side routing exclusively with the hash portion of the [URL](#url), it was the only part we could manipulate without making a new request to the server. However, today we can use it for its designed purpose.\n\n**Location State**\n\nYou may have wondered why the `window.history.pushState()` API is called \"push state\". State? Aren't we just changing the [URL](#url)? Shouldn't it be `history.push`? Well, we weren't in the room when the API was designed, so we're not sure why \"state\" was the focus, but it is a cool feature of browsers nonetheless.\n\nBrowsers let us persist information about a navigation by passing a value to `pushState`. When the user clicks back, the value on `history.state` changes to whatever was \"pushed\" before.\n\n``` javascript\nwindow.history.pushState(\"look ma!\", undefined, \"/contact\");\nwindow.history.state; // \"look ma!\"\n// user clicks back\nwindow.history.state; // undefined\n// user clicks forward\nwindow.history.state; // \"look ma!\"\n```\n\nFor illustration. You don't read `history.state` directly in React Router apps\n\nReact Router takes advantage of this browser feature, abstracts it a bit, and surfaces the values on the `location` instead of `history`.\n\nYou can think about `location.state` just like `location.hash` or `location.search` except instead of putting the values in the [URL](#url) it's hidden--like a super secret piece of the URL only the programmer knows about.\n\nA couple of great use-cases for location state are:\n\n- Telling the next page where the user came from and branching the UI. The most popular implementation here is showing a record in a modal if the user clicked on an item in a grid view, but if they show up to the URL directly, show the record in its own layout (pinterest, old instagram).\n- Sending a partial record from a list to the next screen so it can render the partial data immediately and then fetching the rest of the data afterward.\n\nYou set location state in two ways: on `<Link>` or `navigate`:\n\n``` javascript\n<Link to=\"/pins/123\" state={{ fromDashboard: true }} />;\n\nlet navigate = useNavigate();\nnavigate(\"/users/123\", { state: partialUser });\n```\n\nAnd on the next page you can access it with `useLocation`:\n\n``` javascript\nlet location = useLocation();\nlocation.state;\n```\n\nLocation state values will get serialized, so something like `new Date()` will be turned into a string.\n\n**Location Key**\n\nEach location gets a unique key. This is useful for advanced cases like location-based scroll management, client side data caching, and more. Because each new location gets a unique key, you can build abstractions that store information in a plain object, `new Map()`, or even `locationStorage`.\n\nFor example, a very basic client side data cache could store values by location key (and the fetch [URL](#url)) and skip fetching the data when the user clicks back into it:\n\n``` javascript\nlet cache = new Map();\n\nfunction useFakeFetch(URL) {\n  let location = useLocation();\n  let cacheKey = location.key + URL;\n  let cached = cache.get(cacheKey);\n\n  let [data, setData] = useState(() => {\n    // initialize from the cache\n    return cached || null;\n  });\n\n  let [state, setState] = useState(() => {\n    // avoid the fetch if cached\n    return cached ? \"done\" : \"loading\";\n  });\n\n  useEffect(() => {\n    if (state === \"loading\") {\n      let controller = new AbortController();\n      fetch(URL, { signal: controller.signal })\n        .then((res) => res.json())\n        .then((data) => {\n          if (controller.signal.aborted) return;\n          // set the cache\n          cache.set(cacheKey, data);\n          setData(data);\n        });\n      return () => controller.abort();\n    }\n  }, [state, cacheKey]);\n\n  useEffect(() => {\n    setState(\"loading\");\n  }, [URL]);\n\n  return data;\n}\n```\n\n## Matching\n\nOn the initial render, and when the [history stack](#history-stack) changes, React Router will match the [location](#location) against your [route config](#route-config) to come up with a set of [matches](#match) to render.\n\n### Defining Routes\n\nA route config is a tree of [routes](#route) that looks something like this:\n\n``` javascript\n<Routes>\n  <Route path=\"/\" element={<App />}>\n    <Route index element={<Home />} />\n    <Route path=\"teams\" element={<Teams />}>\n      <Route path=\":teamId\" element={<Team />} />\n      <Route path=\":teamId/edit\" element={<EditTeam />} />\n      <Route path=\"new\" element={<NewTeamForm />} />\n      <Route index element={<LeagueStandings />} />\n    </Route>\n  </Route>\n  <Route element={<PageLayout />}>\n    <Route path=\"/privacy\" element={<Privacy />} />\n    <Route path=\"/tos\" element={<Tos />} />\n  </Route>\n  <Route path=\"contact-us\" element={<Contact />} />\n</Routes>\n```\n\nThe `<Routes>` component recurses through its `props.children`, strips their props, and generates an object like this:\n\n``` javascript\nlet routes = [\n  {\n    element: <App />,\n    path: \"/\",\n    children: [\n      {\n        index: true,\n        element: <Home />,\n      },\n      {\n        path: \"teams\",\n        element: <Teams />,\n        children: [\n          {\n            index: true,\n            element: <LeagueStandings />,\n          },\n          {\n            path: \":teamId\",\n            element: <Team />,\n          },\n          {\n            path: \":teamId/edit\",\n            element: <EditTeam />,\n          },\n          {\n            path: \"new\",\n            element: <NewTeamForm />,\n          },\n        ],\n      },\n    ],\n  },\n  {\n    element: <PageLayout />,\n    children: [\n      {\n        element: <Privacy />,\n        path: \"/privacy\",\n      },\n      {\n        element: <Tos />,\n        path: \"/tos\",\n      },\n    ],\n  },\n  {\n    element: <Contact />,\n    path: \"/contact-us\",\n  },\n];\n```\n\nIn fact, instead of `<Routes>` you can use the hook `useRoutes(routesGoHere)` instead. That's all `<Routes>` is doing.\n\nAs you can see, routes can define multiple [segments](#segment) like `:teamId/edit`, or just one like `:teamId`. All of the segments down a branch of the [route config](#route-config) are added together to create a final [path pattern](#path-pattern) for a route.\n\n### Match Params\n\nNote the `:teamId` segments. This is what we call a [dynamic segment](#dynamic-segment) of the [path pattern](#path-pattern), meaning it doesn't match the URL statically (the actual characters) but it matches it dynamically. Any value can fill in for `:teamId`. Both `/teams/123` or `/teams/cupcakes` will match. We call the parsed values [URL params](#url-params). So in this case our `teamId` param would be `\"123\"` or `\"cupcakes\"`. We'll see how to use them in your app in the [Rendering](#rendering) section.\n\n### Ranking Routes\n\nIf we add up all the segments of all the branches of our [route config](#route-config), we end up with the following path patterns that our app responds to:\n\n``` javascript\n[\n  \"/\",\n  \"/teams\",\n  \"/teams/:teamId\",\n  \"/teams/:teamId/edit\",\n  \"/teams/new\",\n  \"/privacy\",\n  \"/tos\",\n  \"/contact-us\",\n];\n```\n\nNow this is where things get really interesting. Consider the [URL](#url) `/teams/new`. Which pattern in that list matches the URL?\n\nThat's right, two of them!\n\nReact Router has to make a decision here, there can be only one. Many routers, both client side and server side, will simply process the patterns in the order in which they were defined. First to match wins. In this case we would match `/` and render the `<Home/>` component. Definitely not what we wanted. These kinds of routers require us to order our routes perfectly to get the expected result. This is how React Router has worked up until v6, but now it's much smarter.\n\nLooking at those patterns, you intuitively know that we want `/teams/new` to match the URL `/teams/new`. It's a perfect match! React Router also knows that. When matching, it will rank your routes according the number of segments, static segments, dynamic segments, star patterns, etc. and pick the most specific match. You'll never have to think about ordering your routes.\n\n### Pathless Routes\n\nYou may have noticed the weird routes from earlier:\n\n``` javascript\n<Route index element={<Home />} />\n<Route index element={<LeagueStandings />} />\n<Route element={<PageLayout />} />\n```\n\nThey don't even have a path, how can they be a route? This is where the word \"route\" in React Router is used pretty loosely. `<Home/>` and `<LeagueStandings/>` are [index routes](#index-route) and `<PageLayout/>` is a [layout route](#layout-route). We'll discuss how they work in the [Rendering](#rendering) section. Neither really has much to do with matching.\n\n### Route Matches\n\nWhen a route matches the URL, it's represented by a [match](#match) object. A match for `<Route path=\":teamId\" element={<Team/>}/>` would look something like this:\n\n``` javascript\n{\n  pathname: \"/teams/firebirds\",\n  params: {\n    teamId: \"firebirds\"\n  },\n  route: {\n    element: <Team />,\n    path: \":teamId\"\n  }\n}\n```\n\n`pathname` holds the portion of the URL that matched this route (in our case it's all of it). `params` holds the parsed values from any [dynamic segments](#dynamic-segment) that matched. Note that the param's object keys map directly to the name of the segment: `:teamId` becomes `params.teamId`.\n\nBecause our routes are a tree, a single URL can match an entire branch of the tree. Consider the URL `/teams/firebirds`, it would be the following route branch:\n\n``` javascript\n<Routes>\n  <Route path=\"/\" element={<App />}>\n    <Route index element={<Home />} />\n    <Route path=\"teams\" element={<Teams />}>\n      <Route path=\":teamId\" element={<Team />} />\n      <Route path=\":teamId/edit\" element={<EditTeam />} />\n      <Route path=\"new\" element={<NewTeamForm />} />\n      <Route index element={<LeagueStandings />} />\n    </Route>\n  </Route>\n  <Route element={<PageLayout />}>\n    <Route path=\"/privacy\" element={<Privacy />} />\n    <Route path=\"/tos\" element={<Tos />} />\n  </Route>\n  <Route path=\"contact-us\" element={<Contact />} />\n</Routes>\n```\n\nReact Router will create an array of [matches](#match) from these routes and the url so it can render a nested UI that matches the route nesting.\n\n``` javascript\n[\n  {\n    pathname: \"/\",\n    params: null,\n    route: {\n      element: <App />,\n      path: \"/\",\n    },\n  },\n  {\n    pathname: \"/teams\",\n    params: null,\n    route: {\n      element: <Teams />,\n      path: \"teams\",\n    },\n  },\n  {\n    pathname: \"/teams/firebirds\",\n    params: {\n      teamId: \"firebirds\",\n    },\n    route: {\n      element: <Team />,\n      path: \":teamId\",\n    },\n  },\n];\n```\n\n## Rendering\n\nThe final concept is rendering. Consider that the entry to your app looks like this:\n\n``` javascript\nconst root = ReactDOM.createRoot(\n  document.getElementById(\"root\")\n);\nroot.render(\n  <BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<App />}>\n        <Route index element={<Home />} />\n        <Route path=\"teams\" element={<Teams />}>\n          <Route path=\":teamId\" element={<Team />} />\n          <Route path=\"new\" element={<NewTeamForm />} />\n          <Route index element={<LeagueStandings />} />\n        </Route>\n      </Route>\n      <Route element={<PageLayout />}>\n        <Route path=\"/privacy\" element={<Privacy />} />\n        <Route path=\"/tos\" element={<Tos />} />\n      </Route>\n      <Route path=\"contact-us\" element={<Contact />} />\n    </Routes>\n  </BrowserRouter>\n);\n```\n\nLet's use the `/teams/firebirds` URL as an example again. `<Routes>` will match the [location](#location) to your [route config](#route-config), get a set of [matches](#match), and then render a React element tree like this:\n\n``` javascript\n<App>\n  <Teams>\n    <Team />\n  </Teams>\n</App>\n```\n\nEach match rendered inside the parent route's element is a really powerful abstraction. Most websites and apps share this characteristic: boxes inside of boxes inside of boxes, each with a navigation section that changes a child section of the page.\n\n### Outlets\n\nThis nested element tree won't happen automatically. `<Routes>` will render the first match's element for you (In our case that's `<App/>`). The next match's element is `<Teams>`. In order to render that, `App` needs to render an [outlet](#outlet).\n\n``` javascript\nfunction App() {\n  return (\n    <div>\n      <GlobalNav />\n      <Outlet />\n      <GlobalFooter />\n    </div>\n  );\n}\n```\n\nThe `Outlet` component will always render the next match. That means `<Teams>` also needs an outlet to render `<Team/>`.\n\nIf the URL were `/contact-us`, the element tree would change to:\n\n``` javascript\n<ContactForm />\n```\n\nBecause the contact form is not under the main `<App>` route.\n\nIf the URL were `/teams/firebirds/edit`, the element tree would change to:\n\n``` javascript\n<App>\n  <Teams>\n    <EditTeam />\n  </Teams>\n</App>\n```\n\nThe outlet swaps out the child for the new child that matches, but the parent layout persists. It's subtle but very effective at cleaning up your components.\n\n### Index Routes\n\nRemember the [route config](#route-config) for `/teams`:\n\n``` javascript\n<Route path=\"teams\" element={<Teams />}>\n  <Route path=\":teamId\" element={<Team />} />\n  <Route path=\"new\" element={<NewTeamForm />} />\n  <Route index element={<LeagueStandings />} />\n</Route>\n```\n\nIf the URL were `/teams/firebirds`, the element tree would be:\n\n``` javascript\n<App>\n  <Teams>\n    <Team />\n  </Teams>\n</App>\n```\n\nBut if the URL were `/teams`, the element tree would be:\n\n``` javascript\n<App>\n  <Teams>\n    <LeagueStandings />\n  </Teams>\n</App>\n```\n\nLeague standings? How the heck did `<Route index element={<LeagueStandings>}/>` pop in there? It doesn't even have a path! The reason is that it's an [index route](#index-route). Index routes render in their parent route's [outlet](#outlet) at the parent route's path.\n\nThink of it this way, if you're not at one of the child routes' paths, the `<Outlet>` will render nothing in the UI:\n\n``` javascript\n<App>\n  <Teams />\n</App>\n```\n\nIf all the teams are in a list on the left then an empty outlet means you've got a blank page on the right! Your UI needs something to fill the space: index routes to the rescue.\n\nAnother way to think of an index route is that it's the default child route when the parent matches but none of its children do.\n\nDepending on the user interface, you might not need an index route, but if there is any sort of persistent navigation in the parent route you'll most likely want index route to fill the space when the user hasn't clicked one of the items yet.\n\n### Layout Routes\n\nHere's a part of our route config we haven't matched yet: `/privacy`. Let's look at the route config again, highlighting the matched routes:\n\n``` javascript\n<Routes>\n  <Route path=\"/\" element={<App />}>\n    <Route index element={<Home />} />\n    <Route path=\"teams\" element={<Teams />}>\n      <Route path=\":teamId\" element={<Team />} />\n      <Route path=\":teamId/edit\" element={<EditTeam />} />\n      <Route path=\"new\" element={<NewTeamForm />} />\n      <Route index element={<LeagueStandings />} />\n    </Route>\n  </Route>\n  <Route element={<PageLayout />}>\n    <Route path=\"/privacy\" element={<Privacy />} />\n    <Route path=\"/tos\" element={<Tos />} />\n  </Route>\n  <Route path=\"contact-us\" element={<Contact />} />\n</Routes>\n```\n\nAnd the resulting element tree rendered will be:\n\n``` javascript\n<PageLayout>\n  <Privacy />\n</PageLayout>\n```\n\nThe `PageLayout` route is admittedly weird. We call it a [layout route](#layout-route) because it doesn't participate in the matching at all (though its children do). It only exists to make wrapping multiple child routes in the same layout simpler. If we didn't allow this then you'd have to handle layouts in two different ways: sometimes your routes do it for you, sometimes you do it manually with lots of layout component repetition throughout your app:\n\nYou can do it like this, but we recommend using a layout route\n\n``` javascript\n<Routes>\n  <Route path=\"/\" element={<App />}>\n    <Route index element={<Home />} />\n    <Route path=\"teams\" element={<Teams />}>\n      <Route path=\":teamId\" element={<Team />} />\n      <Route path=\":teamId/edit\" element={<EditTeam />} />\n      <Route path=\"new\" element={<NewTeamForm />} />\n      <Route index element={<LeagueStandings />} />\n    </Route>\n  </Route>\n  <Route\n    path=\"/privacy\"\n    element={\n      <PageLayout>\n        <Privacy />\n      </PageLayout>\n    }\n  />\n  <Route\n    path=\"/tos\"\n    element={\n      <PageLayout>\n        <Tos />\n      </PageLayout>\n    }\n  />\n  <Route path=\"contact-us\" element={<Contact />} />\n</Routes>\n```\n\nSo, yeah, the semantics of a layout \"route\" is a bit silly since it has nothing to do with the URL matching, but it's just too convenient to disallow.\n\n## Navigating\n\nWhen the [URL](#url) changes we call that a \"navigation\". There are two ways to navigate in React Router:\n\n- `<Link>`\n- `navigate`\n\n### Link\n\nThis is the primary means of navigation. Rendering a `<Link>` allows the user to change the URL when they click it. React Router will prevent the browser's default behavior and tell the [history](#history) to push a new entry into the [history stack](#history-stack). The [location](#location) changes and the new [matches](#match) will render.\n\nHowever, links are accessible in that they:\n\n- Still render a `<a href>` so all default accessibility concerns are met (like keyboard, focusability, SEO, etc.)\n- Don't prevent the browser's default behavior if it's a right click or command/control click to \"open in new tab\"\n\n[Nested routes](#nested-routes) aren't just about rendering layouts; they also enable \"relative links\". Consider our `teams` route from before:\n\n``` javascript\n<Route path=\"teams\" element={<Teams />}>\n  <Route path=\":teamId\" element={<Team />} />\n</Route>\n```\n\nThe `<Teams>` component can render links like:\n\n``` javascript\n<Link to=\"psg\" />\n<Link to=\"new\" />\n```\n\nThe full path it links to will be `/teams/psg` and `/teams/new`. They inherit the route within which they are rendered. This makes it so your route components don't have to really know anything about the rest of the routes in the app. A very large amount of links just go one more [segment](#segment) deeper. You can rearrange your whole [route config](#route-config) and these links will likely still work just fine. This is very valuable when building out a site in the beginning and the designs and layouts are shifting around.\n\n### Navigate Function\n\nThis function is returned from the `useNavigate` hook and allows you, the programmer, to change the URL whenever you want. You could do it on a timeout:\n\n``` javascript\nlet navigate = useNavigate();\nuseEffect(() => {\n  setTimeout(() => {\n    navigate(\"/logout\");\n  }, 30000);\n}, []);\n```\n\nOr after a form is submitted:\n\n``` javascript\n<form onSubmit={event => {\n  event.preventDefault();\n  let data = new FormData(event.target)\n  let urlEncoded = new URLSearchParams(data)\n  navigate(\"/create\", { state: urlEncoded })\n}}>\n```\n\nLike `Link`, `navigate` works with nested \"to\" values as well.\n\n``` javascript\nnavigate(\"psg\");\n```\n\nYou should have a good reason to use `navigate` instead of `<Link>`. This makes us very sad:\n\n``` javascript\n<li onClick={() => navigate(\"/somewhere\")} />\n```\n\nAside from links and forms, very few interactions should change the URL because it introduces complexity around accessibility and user expectations.\n\n## Data Access\n\nFinally, an application is going to want to ask React Router for a few pieces of information in order to build out the full UI. For this, React Router has a pile of hooks\n\n``` javascript\nlet location = useLocation();\nlet urlParams = useParams();\nlet [urlSearchParams] = useSearchParams();\n```\n\n## Review\n\nLet's put it all together from the top!\n\n1.  You render your app:\n\n    ``` javascript\n    const root = ReactDOM.createRoot(\n      document.getElementById(\"root\")\n    );\n    root.render(\n      <BrowserRouter>\n        <Routes>\n          <Route path=\"/\" element={<App />}>\n            <Route index element={<Home />} />\n            <Route path=\"teams\" element={<Teams />}>\n              <Route path=\":teamId\" element={<Team />} />\n              <Route path=\"new\" element={<NewTeamForm />} />\n              <Route index element={<LeagueStandings />} />\n            </Route>\n          </Route>\n          <Route element={<PageLayout />}>\n            <Route path=\"/privacy\" element={<Privacy />} />\n            <Route path=\"/tos\" element={<Tos />} />\n          </Route>\n          <Route path=\"contact-us\" element={<Contact />} />\n        </Routes>\n      </BrowserRouter>\n    );\n    ```\n\n2.  `<BrowserRouter>` creates a [history](#history), puts the initial [location](#location) in to state, and subscribes to the [URL](#url).\n\n3.  `<Routes>` recurses its [child routes](#child-route) to build a [route config](#route-config), matches those routes against the [location](#location), creates some route [matches](#match), and renders the first match's route element.\n\n4.  You render an [`<Outlet/>`](#outlet) in each [parent route](#parent-route).\n\n5.  The outlets render the next match in the route [matches](#match).\n\n6.  The user clicks a link\n\n7.  The link calls `navigate()`\n\n8.  The [history](#history) changes the URL and notifies `<BrowserRouter>`.\n\n9.  `<BrowserRouter>` rerenders, start over at (2)!\n\nThat's it! We hope this guide has helped you gain a deeper understanding of the main concepts in React Router.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/start/concepts](https://reactrouterdotcom.fly.dev/docs/en/v6/start/concepts)"
- name: Making a Pull Request?
  id: guides/contributing#making-a-pull-request
  summary: Pull requests need only the approval of two or more collaborators to be merged; when the PR author is a collaborator, that counts as one
  belongs_to: Contributing to React Router
  description: |-
    ## Making a Pull Request?

    Pull requests need only the approval of two or more collaborators to be merged; when the PR author is a collaborator, that counts as one.

    When creating the PR in GitHub, make sure that you set the base to the correct branch. If you are submitting a PR that touches any code, this should be the `dev` branch. You set the base in GitHub when authoring the PR with the dropdown below the "Compare changes" heading:
- name: Managing the History Stack
  id: start/tutorial#managing-the-history-stack
  summary: We can avoid this by replacing the current entry in the history stack with the next page, instead of pushing into it
  belongs_to: Tutorial
  description: |-
    ## Managing the History Stack

    Now that the form is submitted for every key stroke, if we type the characters "seba" and then delete them with backspace, we end up with 7 new entries in the stack 😂. We definitely don't want this

    We can avoid this by *replacing* the current entry in the history stack with the next page, instead of pushing into it.

    👉 **Use `replace` in `submit`**

    ``` javascript
    // existing code

    export default function Root() {
      // existing code

      return (
        <>
          <div id="sidebar">
            <h1>React Router Contacts</h1>
            <div>
              <Form id="search-form" role="search">
                <input
                  id="q"
                  // existing code
                  onChange={(event) => {
                    const isFirstSearch = q == null;
                    submit(event.currentTarget.form, {
                      replace: !isFirstSearch,
                    });
                  }}
                />
                {/* existing code */}
              </Form>
              {/* existing code */}
            </div>
            {/* existing code */}
          </div>
          {/* existing code */}
        </>
      );
    }
    ```

    We only want to replace search results, not the page before we started searching, so we do a quick check if this is the first search or not and then decide to replace.

    Each key stroke no longer creates new entries, so the user can click back out of the search results without having to click it 7 times 😅.
- name: Match Params
  id: start/concepts#match-params
  summary: Note the :teamId segments
  belongs_to: Main Concepts
  description: |-
    ### Match Params

    Note the `:teamId` segments. This is what we call a [dynamic segment](#dynamic-segment) of the [path pattern](#path-pattern), meaning it doesn't match the URL statically (the actual characters) but it matches it dynamically. Any value can fill in for `:teamId`. Both `/teams/123` or `/teams/cupcakes` will match. We call the parsed values [URL params](#url-params). So in this case our `teamId` param would be `"123"` or `"cupcakes"`. We'll see how to use them in your app in the [Rendering](#rendering) section.
- name: Matching
  id: start/concepts#matching
  summary: On the initial render, and when the history stack changes, React Router will match the location against your route config to come up with a set of matches to render
  belongs_to: Main Concepts
  description: |-
    ## Matching

    On the initial render, and when the [history stack](#history-stack) changes, React Router will match the [location](#location) against your [route config](#route-config) to come up with a set of [matches](#match) to render.
- name: matchPath
  id: utils/match-path
  summary: matchPath matches a route path pattern against a URL pathname and returns information about the match
  description: "# `matchPath`\n\nType declaration\n\n``` javascript\ndeclare function matchPath<\n  ParamKey extends string = string\n>(\n  pattern: PathPattern | string,\n  pathname: string\n): PathMatch<ParamKey> | null;\n\ninterface PathMatch<ParamKey extends string = string> {\n  params: Params<ParamKey>;\n  pathname: string;\n  pattern: PathPattern;\n}\n\ninterface PathPattern {\n  path: string;\n  caseSensitive?: boolean;\n  end?: boolean;\n}\n```\n\n`matchPath` matches a route path pattern against a URL pathname and returns information about the match. This is useful whenever you need to manually run the router's matching algorithm to determine if a route path matches or not. It returns `null` if the pattern does not match the given pathname.\n\nThe [`useMatch` hook](../hooks/use-match) uses this function internally to match a route path relative to the current location.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/utils/match-path](https://reactrouterdotcom.fly.dev/docs/en/v6/utils/match-path)"
- name: matchRoutes
  id: utils/match-routes
  summary: matchRoutes runs the route matching algorithm for a set of routes against a given location to see which routes (if any) match
  description: "# `matchRoutes`\n\nType declaration\n\n``` javascript\ndeclare function matchRoutes(\n  routes: RouteObject[],\n  location: Partial<Location> | string,\n  basename?: string\n): RouteMatch[] | null;\n\ninterface RouteMatch<ParamKey extends string = string> {\n  params: Params<ParamKey>;\n  pathname: string;\n  route: RouteObject;\n}\n```\n\n`matchRoutes` runs the route matching algorithm for a set of routes against a given [`location`](location) to see which routes (if any) match. If it finds a match, an array of `RouteMatch` objects is returned, one for each route that matched.\n\nThis is the heart of React Router's matching algorithm. It is used internally by [`useRoutes`](../hooks/use-routes) and the [`<Routes>` component](../components/routes) to determine which routes match the current location. It can also be useful in some situations where you want to manually match a set of routes.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/utils/match-routes](https://reactrouterdotcom.fly.dev/docs/en/v6/utils/match-routes)"
- name: method
  id: components/form#method
  summary: This determines the HTTP verb to be used
  belongs_to: <Form>
  description: |-
    ## `method`

    This determines the [HTTP verb](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) to be used. The same as plain HTML [form method](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#attr-method), except it also supports "put", "patch", and "delete" in addition to "get" and "post". The default is "get".
- name: Modal Example
  id: examples/modal
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  description: "# Modal Example\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/modal?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/modal](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/modal)"
- name: Multi App Example
  id: examples/multi-app
  summary: This example demonstrates how to build a site with multiple React Router apps by mounting each at a URL pathname prefix using the <Router basename> prop
  description: "# Multi App Example\n\nThis example demonstrates how to build a site with multiple React Router apps by mounting each at a URL pathname prefix using the `<Router basename>` prop. This essentially decouples the apps from each other and allows them to be portable and even deployed separately.\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/multi-app?file=home/main.jsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/multi-app](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/multi-app)"
- name: Mutation Discussion
  id: start/tutorial#mutation-discussion
  summary: Open up src/routes/edit.jsx and look at the form elements
  belongs_to: Tutorial
  description: |-
    ## Mutation Discussion

    > 😑 It worked, but I have no idea what is going on here...

    Let's dig in a bit...

    Open up `src/routes/edit.jsx` and look at the form elements. Notice how they each have a name:

    ``` javascript
    <input
      placeholder="First"
      aria-label="First name"
      type="text"
      name="first"
      defaultValue={contact.first}
    />
    ```

    Without JavaScript, when a form is submitted, the browser will create [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) and set it as the body of the request when it sends it to the server. As mentioned before, React Router prevents that and sends the request to your action instead, including the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData).

    Each field in the form is accessible with `formData.get(name)`. For example, given the input field from above, you could access the first and last names like this:

    ``` javascript
    export async function action({ request, params }) {
      const formData = await request.formData();
      const firstName = formData.get("first");
      const lastName = formData.get("last");
      // ...
    }
    ```

    Since we have a handful of form fields, we used [`Object.fromEntries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) to collect them all into an object, which is exactly what our `updateContact` function wants.

    ``` javascript
    const updates = Object.fromEntries(formData);
    updates.first; // "Some"
    updates.last; // "Name"
    ```

    Aside from `action`, none of these APIs we're discussing are provided by React Router: [`request`](https://developer.mozilla.org/en-US/docs/Web/API/Request), [`request.formData`](https://developer.mozilla.org/en-US/docs/Web/API/Request/formData), [`Object.fromEntries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) are all provided by the web platform.

    After we finished the action, note the [`redirect`](../fetch/redirect) at the end:

    ``` javascript
    export async function action({ request, params }) {
      const formData = await request.formData();
      const updates = Object.fromEntries(formData);
      await updateContact(params.contactId, updates);
      return redirect(`/contacts/${params.contactId}`);
    }
    ```

    Loaders and actions can both [return a `Response`](../route/loader#returning-responses) (makes sense, since they received a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request)!). The [`redirect`](../fetch/redirect) helper just makes it easier to return a [response](https://developer.mozilla.org/en-US/docs/Web/API/Response) that tells the app to change locations.

    Without client side routing, if a server redirected after a POST request, the new page would fetch the latest data and render. As we learned before, React Router emulates this model and automatically revalidates the data on the page after the action. That's why the sidebar automatically updates when we save the form. The extra revalidation code doesn't exist without client side routing, so it doesn't need to exist with client side routing either!
- name: Mutation Submissions
  id: components/form#mutation-submissions
  summary: All other methods are "mutation submissions", meaning you intend to change something about your data with POST, PUT, PATCH, or DELETE
  belongs_to: <Form>
  description: |-
    ### Mutation Submissions

    All other methods are "mutation submissions", meaning you intend to change something about your data with POST, PUT, PATCH, or DELETE. Note that plain HTML forms only support "post" and "get", we tend to stick to those two as well.

    When the user submits the form, React Router will match the `action` to the app's routes and call the `<Route action>` with the serialized [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData). When the action completes, all of the loader data on the page will automatically revalidate to keep your UI in sync with your data.

    The method will be available on [`request.method`](https://developer.mozilla.org/en-US/docs/Web/API/Request/method) inside the route action that is called. You can use this to instruct your data abstractions about the intent of the submission.

    ``` javascript
    <Route
      path="/projects/:id"
      element={<Project />}
      loader={async ({ params }) => {
        return fakeLoadProject(params.id)
      }}
      action={async ({ request, params }) => {
        switch (request.method) {
          case "put": {
            let formData = await request.formData();
            let name = formData.get("projectName");
            return fakeUpdateProject(name);
          }
          case "delete": {
            return fakeDeleteProject(params.id);
          }
          default {
            throw new Response("", { status: 405 })
          }
        }
      }}
    />;

    function Project() {
      let project = useLoaderData();

      return (
        <>
          <Form method="put">
            <input
              type="text"
              name="projectName"
              defaultValue={project.name}
            />
            <button type="submit">Update Project</button>
          </Form>

          <Form method="delete">
            <button type="submit">Delete Project</button>
          </Form>
        </>
      );
    }
    ```

    As you can see, both forms submit to the same route but you can use the `request.method` to branch on what you intend to do. After the actions completes, the `loader` will be revalidated and the UI will automatically synchronize with the new data.
- name: Mutations Without Navigation
  id: start/tutorial#mutations-without-navigation
  summary: So far all of our mutations (the times we change data) have used forms that navigate, creating new entries in the history stack
  belongs_to: Tutorial
  description: |-
    ## Mutations Without Navigation

    So far all of our mutations (the times we change data) have used forms that navigate, creating new entries in the history stack. While these user flows are common, it's equally as common to want to change data *without* causing a navigation.

    For these cases, we have the [`useFetcher`](../hooks/use-fetcher) hook. It allows us to communicate with loaders and actions without causing a navigation.

    The ★ button on the contact page makes sense for this. We aren't creating or deleting a new record, we don't want to change pages, we simply want to change the data on the page we're looking at.

    👉 **Change the `<Favorite>` form to a fetcher form**

    ``` javascript
    import {
      useLoaderData,
      Form,
      useFetcher,
    } from "react-router-dom";

    // existing code

    function Favorite({ contact }) {
      const fetcher = useFetcher();
      let favorite = contact.favorite;

      return (
        <fetcher.Form method="post">
          <button
            name="favorite"
            value={favorite ? "false" : "true"}
            aria-label={
              favorite
                ? "Remove from favorites"
                : "Add to favorites"
            }
          >
            {favorite ? "★" : "☆"}
          </button>
        </fetcher.Form>
      );
    }
    ```

    Might want to take a look at that form while we're here. As always, our form has fields with a `name` prop. This form will send [`formData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) with a `favorite` key that's either `"true" | "false"`. Since it's got `method="post"` it will call the action. Since there is no `<fetcher.Form action="...">` prop, it will post to the route where the form is rendered.

    👉 **Create the action**

    ``` javascript
    // existing code
    import { getContact, updateContact } from "../contacts";

    export async function action({ request, params }) {
      let formData = await request.formData();
      return updateContact(params.contactId, {
        favorite: formData.get("favorite") === "true",
      });
    }

    export default function Contact() {
      // existing code
    }
    ```

    Pretty simple. Pull the form data off the request and send it to the data model.

    👉 **Configure the route's new action**

    ``` javascript
    // existing code
    import Contact, {
      loader as contactLoader,
      action as contactAction,
    } from "./routes/contact";

    const router = createBrowserRouter([
      {
        path: "/",
        element: <Root />,
        errorElement: <ErrorPage />,
        loader: rootLoader,
        action: rootAction,
        children: [
          { index: true, element: <Index /> },
          {
            path: "contacts/:contactId",
            element: <Contact />,
            loader: contactLoader,
            action: contactAction,
          },
          /* existing code */
        ],
      },
    ]);
    ```

    Alright, we're ready to click the star next to the user's name!

    Check that out, both stars automatically update. Our new `<fetcher.Form method="post">` works almost exactly like a the `<Form>` we've been using: it calls the action and then all data is revalidated automatically--even your errors will be caught the same way.

    There is one key difference though, it's not a navigation--the URL doesn't change, the history stack is unaffected.
- name: Navigate Function
  id: start/concepts#navigate-function
  summary: This function is returned from the useNavigate hook and allows you, the programmer, to change the URL whenever you want
  belongs_to: Main Concepts
  description: |-
    ### Navigate Function

    This function is returned from the `useNavigate` hook and allows you, the programmer, to change the URL whenever you want. You could do it on a timeout:

    ``` javascript
    let navigate = useNavigate();
    useEffect(() => {
      setTimeout(() => {
        navigate("/logout");
      }, 30000);
    }, []);
    ```

    Or after a form is submitted:

    ``` javascript
    <form onSubmit={event => {
      event.preventDefault();
      let data = new FormData(event.target)
      let urlEncoded = new URLSearchParams(data)
      navigate("/create", { state: urlEncoded })
    }}>
    ```

    Like `Link`, `navigate` works with nested "to" values as well.

    ``` javascript
    navigate("psg");
    ```

    You should have a good reason to use `navigate` instead of `<Link>`. This makes us very sad:

    ``` javascript
    <li onClick={() => navigate("/somewhere")} />
    ```

    Aside from links and forms, very few interactions should change the URL because it introduces complexity around accessibility and user expectations.
- name: Navigating
  id: start/concepts#navigating
  summary: null
  belongs_to: Main Concepts
  description: |-
    ## Navigating

    When the [URL](#url) changes we call that a "navigation". There are two ways to navigate in React Router:

    - `<Link>`
    - `navigate`

    &nbsp;
- name: navigation.formData
  id: hooks/use-navigation#navigationformdata
  summary: Any POST, PUT, PATCH, or DELETE navigation that started from a <Form> or useSubmit will have your form's submission data attached to it
  belongs_to: useNavigation
  description: |-
    ## `navigation.formData`

    Any POST, PUT, PATCH, or DELETE navigation that started from a `<Form>` or `useSubmit` will have your form's submission data attached to it. This is primarily useful to build "Optimistic UI" with the `submission.formData` [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object.

    In the case of a GET form submission, `formData` will be empty and the data will be reflected in `navigation.location.search`.
- name: navigation.location
  id: hooks/use-navigation#navigationlocation
  summary: This tells you what the next location is going to be
  belongs_to: useNavigation
  description: "## `navigation.location`\n\nThis tells you what the next [location](../utils/location) is going to be.\n\nNote that this link will not appear \"pending\" if a form is being submitted to the URL the link points to, because we only do this for \"loading\" states. The form will contain the pending UI for when the state is \"submitting\", once the action is complete, then the link will go pending.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-navigation](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-navigation)"
- name: navigation.state
  id: hooks/use-navigation#navigationstate
  summary: null
  belongs_to: useNavigation
  description: |-
    ## `navigation.state`

    - **idle** - There is no navigation pending.
    - **submitting** - A route action is being called due to a form submission using POST, PUT, PATCH, or DELETE
    - **loading** - The loaders for the next routes are being called to render the next page

    Normal navigations and GET form submissions transition through these states:

    Form submissions with POST, PUT, PATCH, or DELETE transition through these states:

    Here's a simple submit button that changes its text when the navigation state is changing:

    ``` javascript
    function SubmitButton() {
      const navigation = useNavigation();

      const text =
        navigation.state === "submitting"
          ? "Saving..."
          : navigation.state === "loading"
          ? "Saved!"
          : "Go";

      return <button type="submit">{text}</button>;
    }
    ```

    While `navigation.state` provides the high-level state of the active navigation, you can deduce more granular information by combining it with other `navigation` aspects:

    ``` javascript
    // Is this just a normal load?
    let isNormalLoad =
      navigation.state === "loading" &&
      navigation.formData == null;

    // Are we reloading after an action?
    let isReloading =
      navigation.state === "loading" &&
      navigation.formData != null &&
      navigation.formAction === navigation.location.pathname;

    // Are we redirecting after an action?
    let isRedirecting =
      navigation.state === "loading" &&
      navigation.formData != null &&
      navigation.formAction !== navigation.location.pathname;
    ```
- name: Nested Routes
  id: start/tutorial#nested-routes
  summary: We want the contact component to render inside of the <Root> layout like this
  belongs_to: Tutorial
  description: |-
    ## Nested Routes

    We want the contact component to render *inside* of the `<Root>` layout like this.

    We do it by making the contact route a *child* of the root route.

    👉 **Move the contacts route to be a child of the root route**

    ``` javascript
    const router = createBrowserRouter([
      {
        path: "/",
        element: <Root />,
        errorElement: <ErrorPage />,
        children: [
          {
            path: "contacts/:contactId",
            element: <Contact />,
          },
        ],
      },
    ]);
    ```

    You'll now see the root layout again but a blank page on the right. We need to tell the root route *where* we want it to render its child routes. We do that with [`<Outlet>`](../components/outlet).

    Find the `<div id="detail">` and put an outlet inside

    👉 **Render an [`<Outlet>`](../components/outlet)**

    ``` javascript
    import { Outlet } from "react-router-dom";

    export default function Root() {
      return (
        <>
          {/* all the other elements */}
          <div id="detail">
            <Outlet />
          </div>
        </>
      );
    }
    ```
- name: Nested Routes
  id: start/overview#nested-routes
  summary: Nested Routing is the general idea of coupling segments of the URL to component hierarchy and data
  belongs_to: Feature Overview
  description: |-
    ## Nested Routes

    Nested Routing is the general idea of coupling segments of the URL to component hierarchy and data. React Router's nested routes were inspired by the routing system in Ember.js circa 2014. The Ember team realized that in nearly every case, segments of the URL determine:

    - The layouts to render on the page
    - The data dependencies of those layouts

    React Router embraces this convention with APIs for creating nested layouts coupled to URL segments and data.

    ``` javascript
    // Configure nested routes with JSX
    createBrowserRouter(
      createRoutesFromElements(
        <Route path="/" element={<Root />}>
          <Route path="contact" element={<Contact />} />
          <Route
            path="dashboard"
            element={<Dashboard />}
            loader={({ request }) =>
              fetch("/api/dashboard.json", {
                signal: request.signal,
              })
            }
          />
          <Route element={<AuthLayout />}>
            <Route
              path="login"
              element={<Login />}
              loader={redirectIfUser}
            />
            <Route path="logout" />
          </Route>
        </Route>
      )
    );

    // Or use plain objects
    createBrowserRouter([
      {
        path: "/",
        element: <Root />,
        children: [
          {
            path: "contact",
            element: <Contact />,
          },
          {
            path: "dashboard",
            element: <Dashboard />,
            loader: ({ request }) =>
              fetch("/api/dashboard.json", {
                signal: request.signal,
              }),
          },
          {
            element: <AuthLayout />,
            children: [
              {
                path: "login",
                element: <Login />,
                loader: redirectIfUser,
              },
              {
                path: "logout",
                action: logoutUser,
              },
            ],
          },
        ],
      },
    ]);
    ```

    This [visualization](https://remix.run/_docs/routing) might be helpful.
- name: New Releases
  id: guides/contributing#new-releases
  summary: When it's time to cut a new release, we follow a process based on our branching strategy depending on the type of release
  belongs_to: Contributing to React Router
  description: |-
    ## New Releases

    When it's time to cut a new release, we follow a process based on our branching strategy depending on the type of release.
- name: Not Found Data
  id: start/tutorial#not-found-data
  summary: Our root errorElement is catching this unexpected error as we try to render a null contact
  belongs_to: Tutorial
  description: |-
    ## Not Found Data

    What happens if the contact we're trying load doesn't exist?

    Our root [`errorElement`](../route/error-element) is catching this unexpected error as we try to render a `null` contact. Nice the error was properly handled, but we can do better!

    Whenever you have an expected error case in a loader or action–like the data not existing–you can `throw`. The call stack will break, React Router will catch it, and the error path is rendered instead. We won't even try to render a `null` contact.

    👉 **Throw a 404 response in the loader**

    ``` javascript
    export async function loader({ params }) {
      const contact = await getContact(params.contactId);
      if (!contact) {
        throw new Response("", {
          status: 404,
          statusText: "Not Found",
        });
      }
      return contact;
    }
    ```

    Instead of hitting a render error with `Cannot read properties of null`, we avoid the component completely and render the error path instead, telling the user something more specific.

    This keeps your happy paths, happy. Your route elements don't need to concern themselves with error and loading states.
- name: Notes
  id: hooks/use-revalidator#notes
  summary: While you can render multiple occurrences of useRevalidator at the same time, underneath it is a singleton
  belongs_to: useRevalidator
  description: "## Notes\n\nWhile you can render multiple occurrences of `useRevalidator` at the same time, underneath it is a singleton. This means when one `revalidator.revalidate()` is called, all instances go into the `\"loading\"` state together (or rather, they all update to report the singleton state).\n\nRace conditions are automatically handled when calling `revalidate()` when a revalidation is already in progress.\n\nIf a navigation happens while a revalidation is in flight, the revalidation will be cancelled and fresh data will be requested from all loaders for the next page.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-revalidator](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-revalidator)"
- name: Optimistic UI
  id: start/tutorial#optimistic-ui
  summary: You probably noticed the app felt kind of unresponsive when we clicked the the favorite button from the last section
  belongs_to: Tutorial
  description: |-
    ## Optimistic UI

    You probably noticed the app felt kind of unresponsive when we clicked the the favorite button from the last section. Once again, we added some network latency because you're going to have it in the real world!

    To give the user some feedback, we could put the star into a loading state with [`fetcher.state`](../hooks/use-fetcher#fetcherstate) (a lot like `navigation.state` from before), but we can do something even better this time. We can use a strategy called "optimistic UI"

    The fetcher knows the form data being submitted to the action, so it's available to you on `fetcher.formData`. We'll use that to immediately update the star's state, even though the network hasn't finished. If the update eventually fails, the UI will revert to the real data.

    👉 **Read the optimistic value from `fetcher.formData`**

    ``` javascript
    // existing code

    function Favorite({ contact }) {
      const fetcher = useFetcher();

      let favorite = contact.favorite;
      if (fetcher.formData) {
        favorite = fetcher.formData.get("favorite") === "true";
      }

      return (
        <fetcher.Form method="post">
          <button
            name="favorite"
            value={favorite ? "false" : "true"}
            aria-label={
              favorite
                ? "Remove from favorites"
                : "Add to favorites"
            }
          >
            {favorite ? "★" : "☆"}
          </button>
        </fetcher.Form>
      );
    }
    ```

    If you click the button now you should see the star *immediately* change to the new state. Instead of always rendering the actual data, we check if the fetcher has any `formData` being submitted, if so, we'll use that instead. When the action is done, the `fetcher.formData` will no longer exist and we're back to using the actual data. So even if you write bugs in your optimistic UI code, it'll eventually go back to the correct state 🥹
- name: Optimistic UI
  id: start/overview#optimistic-ui
  summary: Knowing the formData being sent to an action is often enough to skip the busy indicators and render the UI in the next state immediately, even if your asynchronous work is still pending
  belongs_to: Feature Overview
  description: |-
    ## Optimistic UI

    Knowing the [`formData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) being sent to an [action](../route/action) is often enough to skip the busy indicators and render the UI in the next state immediately, even if your asynchronous work is still pending. This is called "optimistic UI".

    ``` javascript
    function LikeButton({ tweet }) {
      const fetcher = useFetcher();

      // if there is `formData` then it is posting to the action
      const liked = fetcher.formData
        ? // check the formData to be optimistic
          fetcher.formData.get("liked") === "yes"
        : // if its not posting to the action, use the record's value
          tweet.liked;

      return (
        <fetcher.Form method="post" action="toggle-liked">
          <button
            type="submit"
            name="liked"
            value={liked ? "yes" : "no"}
          />
        </fetcher.Form>
      );
    }
    ```

    (Yes, HTML buttons can have a `name` and a `value`).

    While it is more common to do optimistic UI with a [`fetcher`](../hooks/use-fetcher), you can do the same with a normal form using [`navigation.formData`](../hooks/use-navigation#navigationformdata).
- name: Other props
  id: routers/create-memory-router#other-props
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: createMemoryRouter
  description: "## Other props\n\nFor all other props, see [`createBrowserRouter`](create-browser-router)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/routers/create-memory-router](https://reactrouterdotcom.fly.dev/docs/en/v6/routers/create-memory-router)"
- name: Outlets
  id: start/concepts#outlets
  summary: This nested element tree won't happen automatically
  belongs_to: Main Concepts
  description: |-
    ### Outlets

    This nested element tree won't happen automatically. `<Routes>` will render the first match's element for you (In our case that's `<App/>`). The next match's element is `<Teams>`. In order to render that, `App` needs to render an [outlet](#outlet).

    ``` javascript
    function App() {
      return (
        <div>
          <GlobalNav />
          <Outlet />
          <GlobalFooter />
        </div>
      );
    }
    ```

    The `Outlet` component will always render the next match. That means `<Teams>` also needs an outlet to render `<Team/>`.

    If the URL were `/contact-us`, the element tree would change to:

    ``` javascript
    <ContactForm />
    ```

    Because the contact form is not under the main `<App>` route.

    If the URL were `/teams/firebirds/edit`, the element tree would change to:

    ``` javascript
    <App>
      <Teams>
        <EditTeam />
      </Teams>
    </App>
    ```

    The outlet swaps out the child for the new child that matches, but the parent layout persists. It's subtle but very effective at cleaning up your components.
- name: Packages
  id: guides/contributing#packages
  summary: React Router uses a monorepo to host code for multiple packages
  belongs_to: Contributing to React Router
  description: |-
    ### Packages

    React Router uses a monorepo to host code for multiple packages. These packages live in the `packages` directory.

    We use [Yarn workspaces](https://classic.yarnpkg.com/en/docs/workspaces/) to manage installation of dependencies and running various scripts. To get everything installed, make sure you have [Yarn (version 1) installed](https://classic.yarnpkg.com/lang/en/docs/install), and then run `yarn` or `yarn install` from the repo root.
- name: params
  id: route/action#params
  summary: Route params are parsed from dynamic segments and passed to your action
  belongs_to: action
  description: |-
    ## `params`

    Route params are parsed from [dynamic segments](route#dynamic-segments) and passed to your action. This is useful for figuring out which resource to mutate:

    ``` javascript
    <Route
      path="/projects/:projectId/delete"
      action={({ params }) => {
        return fakeDeleteProject(params.projectId);
      }}
    />
    ```
- name: params
  id: route/loader#params
  summary: Route params are parsed from dynamic segments and passed to your loader
  belongs_to: loader
  description: |-
    ## `params`

    Route params are parsed from [dynamic segments](route#dynamic-segments) and passed to your loader. This is useful for figuring out which resource to load:

    ``` javascript
    createBrowserRouter([
      {
        path: "/teams/:teamId",
        loader: ({ params }) => {
          return fakeGetTeam(params.teamId);
        },
      },
    ]);
    ```

    Note that the `:teamId` in the path is parsed as provided as `params.teamId` by the same name.
- name: path
  id: route/route#path
  summary: The path pattern to match against the URL to determine if this route matches a URL, link href, or form action
  belongs_to: Route
  description: |-
    ## `path`

    The path pattern to match against the URL to determine if this route matches a URL, link href, or form action.
- name: Pathless Routes
  id: start/concepts#pathless-routes
  summary: They don't even have a path, how can they be a route? This is where the word "route" in React Router is used pretty loosely
  belongs_to: Main Concepts
  description: |-
    ### Pathless Routes

    You may have noticed the weird routes from earlier:

    ``` javascript
    <Route index element={<Home />} />
    <Route index element={<LeagueStandings />} />
    <Route element={<PageLayout />} />
    ```

    They don't even have a path, how can they be a route? This is where the word "route" in React Router is used pretty loosely. `<Home/>` and `<LeagueStandings/>` are [index routes](#index-route) and `<PageLayout/>` is a [layout route](#layout-route). We'll discuss how they work in the [Rendering](#rendering) section. Neither really has much to do with matching.
- name: Pathless Routes
  id: start/tutorial#pathless-routes
  summary: One last thing
  belongs_to: Tutorial
  description: |-
    ## Pathless Routes

    One last thing. The last error page we saw would be better if it rendered inside the root outlet, instead of the whole page. In fact, every error in all of our child routes would be better in the outlet, then the user has more options than hitting refresh.

    We'd like it to look like this:

    We could add the error element to every one of the child routes but, since it's all the same error page, this isn't recommended.

    There's a cleaner way. Routes can be used *without* a path, which lets them participate in the UI layout without requiring new path segments in the URL. Check it out:

    👉 **Wrap the child routes in a pathless route**

    ``` javascript
    createBrowserRouter([
      {
        path: "/",
        element: <Root />,
        loader: rootLoader,
        action: rootAction,
        errorElement: <ErrorPage />,
        children: [
          {
            errorElement: <ErrorPage />,
            children: [
              { index: true, element: <Index /> },
              {
                path: "contacts/:contactId",
                element: <Contact />,
                loader: contactLoader,
                action: contactAction,
              },
              /* the rest of the routes */
            ],
          },
        ],
      },
    ]);
    ```

    When any errors are thrown in the child routes, our new pathless route will catch it and render, preserving the root route's UI!
- name: Pending Navigation UI
  id: start/overview#pending-navigation-ui
  summary: When users navigate around the app, the data for the next page is loaded before the page is rendered
  belongs_to: Feature Overview
  description: |-
    ## Pending Navigation UI

    When users navigate around the app, the data for the next page is loaded before the page is rendered. It's important to provide user feedback during this time so the app doesn't feel like it's unresponsive.

    ``` javascript
    function Root() {
      const navigation = useNavigation();
      return (
        <div>
          {navigation.state === "loading" && <GlobalSpinner />}
          <FakeSidebar />
          <Outlet />
          <FakeFooter />
        </div>
      );
    }
    ```

    See:

    - [`useNavigation`](../hooks/use-navigation)

    &nbsp;
- name: Picking a Router
  id: routers/picking-a-router
  summary: While your app will only use a single router, several routers are available depending on the environment you're app is running in
  description: "# Picking a Router\n\nWhile your app will only use a single router, several routers are available depending on the environment you're app is running in. This document should help you figure out which one to use.\n\n## Using v6.4 Data APIs\n\nIn v6.4, new routers were introduced that support the new data APIs:\n\n- [`createBrowserRouter`](create-browser-router)\n- [`createMemoryRouter`](create-memory-router)\n- [`createHashRouter`](create-hash-router)\n\nThe following routers do not support the data APIs:\n\n- [`<BrowserRouter>`](../router-components/browser-router)\n- [`<MemoryRouter>`](memory-router)\n- [`<HashRouter>`](../router-components/hash-router)\n- [`<NativeRouter>`](native-router)\n- [`<StaticRouter>`](static-router)\n\nWe recommend updating your app to use one of the new routers from 6.4. The data APIs are currently not supported in React Native, but should be eventually.\n\nThe easiest way to quickly update to a v6.4 is to get the help from [`createRoutesFromElements`](../utils/create-routes-from-elements) so you don't need to convert your `<Route>` elements to route objects.\n\n``` javascript\nimport {\n  createBrowserRouter,\n  RouterProvider,\n} from \"react-router-dom\";\n\nconst router = createBrowserRouter(\n  createRoutesFromElements(\n    <Route path=\"/\" element={<Root />}>\n      <Route path=\"dashboard\" element={<Dashboard />} />\n      {/* ... etc. */}\n    </Route>\n  )\n);\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <React.StrictMode>\n    <RouterProvider router={router} />\n  </React.StrictMode>\n);\n```\n\n## Web Projects\n\nWe recommend all web projects use [`createBrowserRouter`](create-browser-router).\n\nIt uses the full URL instead of the hash urls (`#this/stuff`) common in web apps before `window.pushState` was standardized. Full URLs are better for SEO, better for server rendering, and are just more compatible with the rest of the web platform.\n\nIf you're hosting your app on a static file server, you'll need to configure it to send all requests to your `index.html` to avoid getting 404s.\n\nIf for some reason you can't use the full URL, [`createHashRouter`](create-hash-router) is the next best thing.\n\nIf you're not interested in the data APIs, you can continue to use [`<BrowserRouter>`](../router-components/browser-router) or, if you can't use full URLs, [`<HashRouter>`](../router-components/hash-router).\n\n## Testing\n\nTesting components that use React Router APIs is easiest with [`createMemoryRouter`](create-memory-router) or [`<MemoryRouter>`](memory-router) instead of the routers you use in your app that require DOM history APIs.\n\n## React Native\n\nYou will use [`<NativeRouter>`](native-router) from React Native projects.\n\nThe data APIs from v6.4 are currently not supported in React Native, but should be eventually.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/routers/picking-a-router](https://reactrouterdotcom.fly.dev/docs/en/v6/routers/picking-a-router)"
- name: Preventing Scroll Reset
  id: components/scroll-restoration#preventing-scroll-reset
  summary: When navigation creates new scroll keys, the scroll position is reset to the top of the page
  belongs_to: <ScrollRestoration />
  description: |-
    ## Preventing Scroll Reset

    When navigation creates new scroll keys, the scroll position is reset to the top of the page. You can prevent the "scroll to top" behavior from your links:

    ``` javascript
    <Link preventScrollReset={true} />
    ```

    See also: [`<Link preventScrollReset>`](link#preventscrollreset)
- name: preventScrollReset
  id: components/link#preventscrollreset
  summary: If you are using <ScrollRestoration>, this lets you prevent the scroll position from being reset to the top of the window when the link is clicked
  belongs_to: <Link>
  description: "## `preventScrollReset`\n\nIf you are using [`<ScrollRestoration>`](scroll-restoration), this lets you prevent the scroll position from being reset to the top of the window when the link is clicked.\n\n``` javascript\n<Link to=\"?tab=one\" preventScrollReset={true} />\n```\n\nThis does not prevent the scroll position from being restored when the user comes back to the location with the back/forward buttons, it just prevents the reset when the user clicks the link.\n\nAn example when you might want this behavior is a list of tabs that manipulate the url search params that aren't at the top of the page. You wouldn't want the scroll position to jump up to the top because it might scroll the toggled content out of the viewport!\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/components/link](https://reactrouterdotcom.fly.dev/docs/en/v6/components/link)"
- name: Preview
  id: examples/error-boundaries#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Error Boundaries
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/error-boundaries?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/error-boundaries](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/error-boundaries)"
- name: Preview
  id: examples/ssr#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Server-side Rendering Example
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/ssr?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/ssr](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/ssr)"
- name: Preview
  id: examples/custom-link#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Custom Link Example
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/custom-link?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/custom-link](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/custom-link)"
- name: Preview
  id: examples/search-params#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Search Params Example
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/search-params?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/search-params](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/search-params)"
- name: Preview
  id: examples/route-objects#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Route Objects Example
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/route-objects?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/route-objects](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/route-objects)"
- name: Preview
  id: examples/multi-app#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Multi App Example
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/multi-app?file=home/main.jsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/multi-app](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/multi-app)"
- name: Preview
  id: examples/custom-query-parsing#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Custom Query Parsing Example
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/custom-query-parsing?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/custom-query-parsing](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/custom-query-parsing)"
- name: Preview
  id: examples/modal#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Modal Example
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/modal?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/modal](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/modal)"
- name: Preview
  id: examples/custom-filter-link#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Custom Filter Link Example
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/custom-filter-link?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/custom-filter-link](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/custom-filter-link)"
- name: Preview
  id: examples/basic#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Basic Example
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/basic?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/basic](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/basic)"
- name: Preview
  id: examples/ssr-data-router#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Data Router Server-side Rendering Example
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/ssr-data-router?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/ssr-data-router](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/ssr-data-router)"
- name: Preview
  id: examples/notes#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Data Routers
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/remixing/examples/notes?file=src/main.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/notes](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/notes)"
- name: Preview
  id: examples/data-router#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Data Routers
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/data-router?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/data-router](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/data-router)"
- name: Preview
  id: examples/auth#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Auth Example
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/auth?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/auth](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/auth)"
- name: Preview
  id: examples/scroll-restoration#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Scroll Restoration
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/scroll-restoration?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/scroll-restoration](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/scroll-restoration)"
- name: Preview
  id: examples/lazy-loading#preview
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: Lazy Loading Example
  description: "## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/lazy-loading?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/lazy-loading](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/lazy-loading)"
- name: Previous Versions
  id: index#previous-versions
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  description: "## Previous Versions\n\n- [React Router v4/5 docs](https://v5.reactrouter.com)\n- [React Router v3 docs](https://github.com/remix-run/react-router/tree/v3.2.6/docs)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6](https://reactrouterdotcom.fly.dev/docs/en/v6)"
- name: Proposing New or Changed API?
  id: guides/contributing#proposing-new-or-changed-api
  summary: Please provide thoughtful comments and some sample code that show what you'd like to do with React Router in your app
  belongs_to: Contributing to React Router
  description: |-
    ## Proposing New or Changed API?

    Please provide thoughtful comments and some sample code that show what you'd like to do with React Router in your app. It helps the conversation if you can show us how you're limited by the current API first before jumping to a conclusion about what needs to be changed and/or added.

    We have learned by experience that small APIs are usually better, so we may be a little reluctant to add something new unless there's an obvious limitation with the current API. That being said, we are always anxious to hear about cases that we just haven't considered before, so please don't be shy! :)
- name: Race Condition Handling
  id: start/overview#race-condition-handling
  summary: React Router will cancel stale operations and only commit fresh data automatically
  belongs_to: Feature Overview
  description: |-
    ## Race Condition Handling

    React Router will cancel stale operations and only commit fresh data automatically.

    Any time you have asynchronous UI you have the risk of race conditions: when an async operation starts after but completes before an earlier operation. The result is a user interface that shows the wrong state.

    Consider a search field that updates a list as the user types:

    Even though the query for `q?=ryan` went out later, it completed earlier. If not handled correctly, the results will briefly be the correct values for `?q=ryan` but then flip over the incorrect results for `?q=ry`. Throttling and debouncing are not enough (you can still interrupt the requests that get through). You need to cancellation.

    If you're using React Router's data conventions you avoid this problem completely and automatically.

    Not only does React Router handle race conditions for a navigation like this, it also handles it for many other cases like loading results for an autocomplete or performing multiple concurrent mutations with [`fetcher`](../hooks/use-fetcher) (and its automatic, concurrent revalidations).
- name: Ranked Route Matching
  id: start/overview#ranked-route-matching
  summary: When matching URLs to routes, React Router will rank the routes according the number of segments, static segments, dynamic segments, splats, etc
  belongs_to: Feature Overview
  description: |-
    ## Ranked Route Matching

    When matching URLs to routes, React Router will rank the routes according the number of segments, static segments, dynamic segments, splats, etc. and pick the *most specific* match.

    For example, consider these two routes:

    ``` javascript
    <Route path="/teams/:teamId" />
    <Route path="/teams/new" />
    ```

    Now consider the URL is <http://example.com/teams/new>.

    Even though both routes technically match the URL (`new` could be the `:teamId`), you intuitively know that we want the second route (`/teams/new`) to be picked. React Router's matching algorithm knows that, too.

    With ranked routes, you don't have to worry about route ordering.
- name: Ranking Routes
  id: start/concepts#ranking-routes
  summary: Now this is where things get really interesting
  belongs_to: Main Concepts
  description: |-
    ### Ranking Routes

    If we add up all the segments of all the branches of our [route config](#route-config), we end up with the following path patterns that our app responds to:

    ``` javascript
    [
      "/",
      "/teams",
      "/teams/:teamId",
      "/teams/:teamId/edit",
      "/teams/new",
      "/privacy",
      "/tos",
      "/contact-us",
    ];
    ```

    Now this is where things get really interesting. Consider the [URL](#url) `/teams/new`. Which pattern in that list matches the URL?

    That's right, two of them!

    React Router has to make a decision here, there can be only one. Many routers, both client side and server side, will simply process the patterns in the order in which they were defined. First to match wins. In this case we would match `/` and render the `<Home/>` component. Definitely not what we wanted. These kinds of routers require us to order our routes perfectly to get the expected result. This is how React Router has worked up until v6, but now it's much smarter.

    Looking at those patterns, you intuitively know that we want `/teams/new` to match the URL `/teams/new`. It's a perfect match! React Router also knows that. When matching, it will rank your routes according the number of segments, static segments, dynamic segments, star patterns, etc. and pick the most specific match. You'll never have to think about ordering your routes.
- name: React Native
  id: routers/picking-a-router#react-native
  summary: You will use <NativeRouter> from React Native projects
  belongs_to: Picking a Router
  description: "## React Native\n\nYou will use [`<NativeRouter>`](native-router) from React Native projects.\n\nThe data APIs from v6.4 are currently not supported in React Native, but should be eventually.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/routers/picking-a-router](https://reactrouterdotcom.fly.dev/docs/en/v6/routers/picking-a-router)"
- name: React Router Examples
  id: examples
  summary: Welcome to the examples for React Router
  description: "# React Router Examples\n\nWelcome to the examples for React Router.\n\nHere you'll find various examples of using React Router to accomplish certain tasks. Each example is a complete application including a build and even a button to preview a live instance of the app so you can play with it. You'll most often be interested in checking out the code in `src/App.tsx` (or `src/App.js`), but we included the entire source code for the app for completeness.\n\nAlso, remember to check out the README!\n\nEnjoy!\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples](https://reactrouterdotcom.fly.dev/docs/en/v6/examples)"
- name: react-router@next Releases
  id: guides/contributing#react-routernext-releases
  summary: We create experimental releases from the current state of the dev branch
  belongs_to: Contributing to React Router
  description: |-
    ### `react-router@next` Releases

    We create experimental releases from the current state of the `dev` branch. They can be installed by using the `@next` tag:

    ``` javascript
    yarn add react-router-dom@next
    # or
    npm install react-router-dom@next
    ```

    These releases will be automated as PRs are merged into the `dev` branch.
- name: redirect
  id: fetch/redirect
  summary: Because you can return or throw responses in loaders and actions, you can use redirect to redirect to another route
  description: "# `redirect`\n\nBecause you can return or throw responses in loaders and actions, you can use `redirect` to redirect to another route.\n\n``` javascript\nimport { redirect } from \"react-router-dom\";\n\nconst loader = async () => {\n  const user = await getUser();\n  if (!user) {\n    return redirect(\"/login\");\n  }\n};\n```\n\nIt's really just a shortcut for this:\n\n``` javascript\nnew Response(\"\", {\n  status: 302,\n  headers: {\n    Location: someUrl,\n  },\n});\n```\n\nIt's recommended to use `redirect` in loaders and actions rather than `useNavigate` in your components when the redirect is in response to data.\n\nSee also:\n\n- [Returning Responses from Loaders](../route/loader#returning-responses)\n\n## Type Declaration\n\n``` javascript\ntype RedirectFunction = (\n  url: string,\n  init?: number | ResponseInit\n) => Response;\n```\n\n## `url`\n\nThe URL to redirect to.\n\n``` javascript\nredirect(\"/login\");\n```\n\n## `init`\n\nThe [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response) options to be used in the response.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/fetch/redirect](https://reactrouterdotcom.fly.dev/docs/en/v6/fetch/redirect)"
- name: Redirecting new records to the edit page
  id: start/tutorial#redirecting-new-records-to-the-edit-page
  summary: null
  belongs_to: Tutorial
  description: |-
    ## Redirecting new records to the edit page

    Now that we know how to redirect, let's update the action that creates new contacts to redirect to the edit page:

    👉 **Redirect to the new record's edit page**

    ``` javascript
    import {
      Outlet,
      Link,
      useLoaderData,
      Form,
      redirect,
    } from "react-router-dom";
    import { getContacts, createContact } from "../contacts";

    export async function action() {
      const contact = await createContact();
      return redirect(`/contacts/${contact.id}/edit`);
    }
    ```

    Now when we click "New", we should end up on the edit page:

    👉 **Add a handful of records**

    I'm going to use the stellar lineup of speakers from the first Remix Conference 😁
- name: Redirects
  id: start/overview#redirects
  summary: While loading or changing data, it's common to redirect the user to a different route
  belongs_to: Feature Overview
  description: |-
    ## Redirects

    While loading or changing data, it's common to [redirect](../fetch/redirect) the user to a different route.

    ``` javascript
    <Route
      path="dashboard"
      loader={async () => {
        const user = await fake.getUser();
        if (!user) {
          // if you know you can't render the route, you can
          // throw a redirect to stop executing code here,
          // sending the user to a new route
          throw redirect("/login");
        }

        // otherwise continue
        const stats = await fake.getDashboardStats();
        return { user, stats };
      }}
    />
    ```

    ``` javascript
    <Route
      path="project/new"
      action={async ({ request }) => {
        const data = await request.formData();
        const newProject = await createProject(data);
        // it's common to redirect after actions complete,
        // sending the user to the new record
        return redirect(`/projects/${newProject.id}`);
      }}
    />
    ```

    See:

    - [`redirect`](../fetch/redirect)
    - [Throwing in Loaders](../route/loader#throwing-in-loaders)
    - [`useNavigate`](../hooks/use-navigate)

    &nbsp;
- name: relative
  id: components/link#relative
  summary: By default, links are relative to the route hierarchy, so .. will go up one Route level
  belongs_to: <Link>
  description: |-
    ## `relative`

    By default, links are relative to the route hierarchy, so `..` will go up one `Route` level. Occasionally, you may find that you have matching URL patterns that do not make sense to be nested, and you're prefer to use relative *path* routing. You can opt into this behavior with `relative`:

    ``` javascript
    // Contact and EditContact do not share additional UI layout
    <Route path="/" element={<Layout />}>
      <Route path="contacts/:id" element={<Contact />} />
      <Route
        path="contacts/:id/edit"
        element={<EditContact />}
      />
    </Route>;

    function EditContact() {
      // Since Contact is not a parent of EditContact we need to go up one level
      // in the path, instead of one level in the Route hierarchy
      return (
        <Link to=".." relative="path">
          Cancel
        </Link>
      );
    }
    ```
- name: relative
  id: components/form#relative
  summary: By default, paths are relative to the route hierarchy, so .. will go up one Route level
  belongs_to: <Form>
  description: |-
    ## `relative`

    By default, paths are relative to the route hierarchy, so `..` will go up one `Route` level. Occasionally, you may find that you have matching URL patterns that do not make sense to be nested, and you're prefer to use relative *path* routing. You can opt into this behavior with `<Form to="../some/where" relative="path">`
- name: Relative Links
  id: start/overview#relative-links
  summary: Like HTML <a href>, <Link to> and <NavLink to> can take relative paths, with enhanced behavior with nested routes
  belongs_to: Feature Overview
  description: |-
    ## Relative Links

    Like HTML `<a href>`, `<Link to>` and `<NavLink to>` can take relative paths, with enhanced behavior with nested routes.

    Given the following route config:

    ``` javascript
    <Route path="home" element={<Home />}>
      <Route path="project/:projectId" element={<Project />}>
        <Route path=":taskId" element={<Task />} />
      </Route>
    </Route>
    ```

    Consider the url <https://example.com/home/project/123>, which renders the following route component hierarchy:

    ``` javascript
    <Home>
      <Project />
    </Home>
    ```

    If `<Project />` renders the following links, the hrefs of the links will resolve like so:

    | In `<Project>` @ `/home/project/123` | Resolved `<a href>`      |
    |--------------------------------------|--------------------------|
    | `<Link to="abc">`                    | `/home/projects/123/abc` |
    | `<Link to=".">`                      | `/home/projects/123`     |
    | `<Link to="..">`                     | `/home`                  |
    | `<Link to=".." relative="path">`     | `/home/projects`         |

    Note that the first `..` removes both segments of the `project/:projectId` route. By default, the `..` in relative links traverse the route hierarchy, not the URL segments. Adding `relative="path"` in the next example allows you to traverse the path segments instead.

    Relative links are always relative to the route path they are *rendered in*, not to the full URL. That means if the user navigates deeper with `<Link to="abc">` to `<Task />` at the URL `/home/projects/123/abc`, the hrefs in `<Project>` will not change (contrary to plain `<a href>`, a common problem with client side routers).
- name: reloadDocument
  id: components/form#reloaddocument
  summary: Instructs the form to skip React Router and submit the form with the browser's built in behavior
  belongs_to: <Form>
  description: |-
    ## `reloadDocument`

    Instructs the form to skip React Router and submit the form with the browser's built in behavior.

    ``` javascript
    <Form reloadDocument />
    ```

    This is recommended over `<form>` so you can get the benefits of default and relative `action`, but otherwise is the same as a plain HTML form.

    Without a framework like [Remix](https://remix.run), or your own server handling of posts to routes, this isn't very useful.

    See also:

    - [`useNavigation`](../hooks/use-navigation)
    - [`useActionData`](../hooks/use-action-data)
    - [`useSubmit`](../hooks/use-submit)

    # Examples

    TODO: More examples
- name: Rendering
  id: start/concepts#rendering
  summary: The final concept is rendering
  belongs_to: Main Concepts
  description: |-
    ## Rendering

    The final concept is rendering. Consider that the entry to your app looks like this:

    ``` javascript
    const root = ReactDOM.createRoot(
      document.getElementById("root")
    );
    root.render(
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<App />}>
            <Route index element={<Home />} />
            <Route path="teams" element={<Teams />}>
              <Route path=":teamId" element={<Team />} />
              <Route path="new" element={<NewTeamForm />} />
              <Route index element={<LeagueStandings />} />
            </Route>
          </Route>
          <Route element={<PageLayout />}>
            <Route path="/privacy" element={<Privacy />} />
            <Route path="/tos" element={<Tos />} />
          </Route>
          <Route path="contact-us" element={<Contact />} />
        </Routes>
      </BrowserRouter>
    );
    ```

    Let's use the `/teams/firebirds` URL as an example again. `<Routes>` will match the [location](#location) to your [route config](#route-config), get a set of [matches](#match), and then render a React element tree like this:

    ``` javascript
    <App>
      <Teams>
        <Team />
      </Teams>
    </App>
    ```

    Each match rendered inside the parent route's element is a really powerful abstraction. Most websites and apps share this characteristic: boxes inside of boxes inside of boxes, each with a navigation section that changes a child section of the page.
- name: renderMatches
  id: utils/render-matches
  summary: renderMatches renders the result of matchRoutes() into a React element
  description: "# `renderMatches`\n\nType declaration\n\n``` javascript\ndeclare function renderMatches(\n  matches: RouteMatch[] | null\n): React.ReactElement | null;\n```\n\n`renderMatches` renders the result of `matchRoutes()` into a React element.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/utils/render-matches](https://reactrouterdotcom.fly.dev/docs/en/v6/utils/render-matches)"
- name: replace
  id: components/form#replace
  summary: Instructs the form to replace the current entry in the history stack, instead of pushing the new entry
  belongs_to: <Form>
  description: |-
    ## `replace`

    Instructs the form to replace the current entry in the history stack, instead of pushing the new entry.

    ``` javascript
    <Form replace />
    ```

    The default behavior is conditional on the form `method`:

    - `get` defaults to `false`
    - every other method defaults to `true` if your `action` is successful
    - if your `action` redirects or throws, then it will still push by default

    We've found with `get` you often want the user to be able to click "back" to see the previous search results/filters, etc. But with the other methods the default is `true` to avoid the "are you sure you want to resubmit the form?" prompt. Note that even if `replace={false}` React Router *will not* resubmit the form when the back button is clicked and the method is post, put, patch, or delete.

    In other words, this is really only useful for GET submissions and you want to avoid the back button showing the previous results.
- name: Repository Branching
  id: guides/contributing#repository-branching
  summary: This repo maintains separate branches for different purposes
  belongs_to: Contributing to React Router
  description: |-
    ## Repository Branching

    This repo maintains separate branches for different purposes. They will look something like this:

    There may be other branches for various features and experimentation, but all of the magic happens from these branches.
- name: request
  id: route/action#request
  summary: This is a Fetch Request instance being sent to your route
  belongs_to: action
  description: |-
    ## `request`

    This is a [Fetch Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) instance being sent to your route. The most common use case is to parse the [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) from the request

    ``` javascript
    <Route
      action={async ({ request }) => {
        let formData = await request.formData();
        // ...
      }}
    />
    ```

    > A Request?!

    It might seem odd at first that actions receive a "request". Have you ever written this line of code?

    ``` javascript
    <form
      onSubmit={(event) => {
        event.preventDefault();
        // ...
      }}
    />
    ```

    What exactly are you preventing?

    Without JavaScript, just plain HTML and an HTTP web server, that default event that was prevented is actually pretty great. Browsers will serialize all the data in the form into [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) and send it as the body of a new request to your server. Like the code above, React Router [`<Form>`](../components/form) prevents the browser from sending that request and instead sends the request to your route action! This enables highly dynamic web apps with the simple model of HTML and HTTP.

    Remember that the values in the `formData` are automatically serialized from the form submission, so your inputs need a `name`.

    ``` javascript
    <Form method="post">
      <input name="songTitle" />
      <textarea name="lyrics" />
      <button type="submit">Save</button>
    </Form>;

    // accessed by the same names
    formData.get("songTitle");
    formData.get("lyrics");
    ```

    For more information on `formData` see [Working with FormData](../guides/form-data).
- name: request
  id: route/loader#request
  summary: This is a Fetch Request instance being made to your application
  belongs_to: loader
  description: |-
    ## `request`

    This is a [Fetch Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) instance being made to your application.

    ``` javascript
    function loader({ request }) {}
    ```

    > A request?!

    It might seem odd at first that loaders receive a "request". Consider that `<Link>` does something like the following code and ask yourself, "what default behavior is being prevented here?".

    ``` javascript
    <a
      href={props.to}
      onClick={(event) => {
        event.preventDefault();
        navigate(props.to);
      }}
    />
    ```

    Without React Router, the browser would have made a *Request* to your server, but React Router prevented it! Instead of the browser sending the request to your server, React Router sends the request to your loaders.

    The most common use case is creating a [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL) and reading the [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) from it:

    ``` javascript
    function loader({ request }) {
      const url = new URL(request.url);
      const searchTerm = url.searchParams.get("q");
      return searchProducts(searchTerm);
    }
    ```

    Note that the APIs here are not React Router specific, but rather standard web objects: [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request), [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL), [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams).
- name: resolvePath
  id: utils/resolve-path
  summary: resolvePath resolves a given To value into an actual Path object with an absolute pathname
  description: "# `resolvePath`\n\nType declaration\n\n``` javascript\ndeclare function resolvePath(\n  to: To,\n  fromPathname?: string\n): Path;\n\ntype To = string | Partial<Path>;\n\ninterface Path {\n  pathname: string;\n  search: string;\n  hash: string;\n}\n```\n\n`resolvePath` resolves a given `To` value into an actual `Path` object with an absolute `pathname`. This is useful whenever you need to know the exact path for a relative `To` value. For example, the `<Link>` component uses this function to know the actual URL it points to.\n\nThe [`useResolvedPath` hook](../hooks/use-resolved-path) uses `resolvePath` internally to resolve the pathname. If `to` contains a pathname, it is resolved against the current route pathname. Otherwise, it is resolved against the current URL (`location.pathname`).\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/utils/resolve-path](https://reactrouterdotcom.fly.dev/docs/en/v6/utils/resolve-path)"
- name: Returning Responses
  id: route/action#returning-responses
  summary: While you can return anything you want from an action and get access to it from useActionData, you can also return a web Response
  belongs_to: action
  description: |-
    ## Returning Responses

    While you can return anything you want from an action and get access to it from [`useActionData`](../hooks/use-action-data), you can also return a web [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response).

    For more information, see the [loader documentation](loader#returning-responses).
- name: Returning Responses
  id: route/loader#returning-responses
  summary: While you can return anything you want from a loader and get access to it from useLoaderData, you can also return a web Response
  belongs_to: loader
  description: |-
    ## Returning Responses

    While you can return anything you want from a loader and get access to it from [`useLoaderData`](../hooks/use-loader-data), you can also return a web [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response).

    This might not seem immediately useful, but consider `fetch`. Since the return value of of `fetch` is a Response, and loaders understand responses, many loaders can return a simple fetch!

    ``` javascript
    // an HTTP/REST API
    function loader({ request }) {
      return fetch("/api/teams.json", {
        signal: request.signal,
      });
    }

    // or even a graphql endpoint
    function loader({ request, params }) {
      return fetch("/_gql", {
        signal: request.signal,
        method: "post",
        body: JSON.stringify({
          query: gql`...`,
          params: params,
        }),
      });
    }
    ```

    You can construct the response yourself as well:

    ``` javascript
    function loader({ request, params }) {
      const data = { some: "thing" };
      return new Response(JSON.stringify(data), {
        status: 200,
        headers: {
          "Content-Type": "application/json; utf-8",
        },
      });
    }
    ```

    React Router will automatically call `response.json()` so your components don't need to parse it while rendering:

    ``` javascript
    function SomeRoute() {
      const data = useLoaderData();
      // { some: "thing" }
    }
    ```

    Using the [`json`](../fetch/json) utility simplifies this so you don't have to construct them yourself. This next example is effectively the same as the previous example:

    ``` javascript
    import { json } from "react-router-dom";

    function loader({ request, params }) {
      const data = { some: "thing" };
      return json(data, { status: 200 });
    }
    ```

    If you're planning an upgrade to Remix, returning responses from every loader will make the migration smoother.
- name: revalidator.revalidate()
  id: hooks/use-revalidator#revalidatorrevalidate
  summary: This initiates a revalidation
  belongs_to: useRevalidator
  description: |-
    ## `revalidator.revalidate()`

    This initiates a revalidation.

    ``` javascript
    function useLivePageData() {
      let revalidator = useRevalidator();
      let interval = useInterval(5000);

      useEffect(() => {
        if (revalidator.state === "idle") {
          revalidator.revalidate();
        }
      }, [interval]);
    }
    ```
- name: revalidator.state
  id: hooks/use-revalidator#revalidatorstate
  summary: This is useful for creating loading indicators and spinners to let the user know the app is thinking
  belongs_to: useRevalidator
  description: |-
    ## `revalidator.state`

    Tells you the state the revalidation is in, either `"idle"` or `"loading"`.

    This is useful for creating loading indicators and spinners to let the user know the app is thinking.
- name: Review
  id: start/concepts#review
  summary: <BrowserRouter> creates a history, puts the initial location in to state, and subscribes to the URL
  belongs_to: Main Concepts
  description: "## Review\n\nLet's put it all together from the top!\n\n1.  You render your app:\n\n    ``` javascript\n    const root = ReactDOM.createRoot(\n      document.getElementById(\"root\")\n    );\n    root.render(\n      <BrowserRouter>\n        <Routes>\n          <Route path=\"/\" element={<App />}>\n            <Route index element={<Home />} />\n            <Route path=\"teams\" element={<Teams />}>\n              <Route path=\":teamId\" element={<Team />} />\n              <Route path=\"new\" element={<NewTeamForm />} />\n              <Route index element={<LeagueStandings />} />\n            </Route>\n          </Route>\n          <Route element={<PageLayout />}>\n            <Route path=\"/privacy\" element={<Privacy />} />\n            <Route path=\"/tos\" element={<Tos />} />\n          </Route>\n          <Route path=\"contact-us\" element={<Contact />} />\n        </Routes>\n      </BrowserRouter>\n    );\n    ```\n\n2.  `<BrowserRouter>` creates a [history](#history), puts the initial [location](#location) in to state, and subscribes to the [URL](#url).\n\n3.  `<Routes>` recurses its [child routes](#child-route) to build a [route config](#route-config), matches those routes against the [location](#location), creates some route [matches](#match), and renders the first match's route element.\n\n4.  You render an [`<Outlet/>`](#outlet) in each [parent route](#parent-route).\n\n5.  The outlets render the next match in the route [matches](#match).\n\n6.  The user clicks a link\n\n7.  The link calls `navigate()`\n\n8.  The [history](#history) changes the URL and notifies `<BrowserRouter>`.\n\n9.  `<BrowserRouter>` rerenders, start over at (2)!\n\nThat's it! We hope this guide has helped you gain a deeper understanding of the main concepts in React Router.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/start/concepts](https://reactrouterdotcom.fly.dev/docs/en/v6/start/concepts)"
- name: Route
  id: route/route
  summary: Routes are perhaps the most important part of a React Router app
  description: "# `Route`\n\nRoutes are perhaps the most important part of a React Router app. They couple URL segments to components, data loading and data mutations. Through route nesting, complex application layouts and data dependencies become simple and declarative.\n\nRoutes are objects passed to the router creation functions:\n\n``` javascript\nconst router = createBrowserRouter([\n  {\n    // it renders this element\n    element: <Team />,\n\n    // when the URL matches this segment\n    path: \"teams/:teamId\",\n\n    // with this data loaded before rendering\n    loader: async ({ request, params }) => {\n      return fetch(\n        `/fake/api/teams/${params.teamId}.json`,\n        { signal: request.signal }\n      );\n    },\n\n    // performing this mutation when data is submitted to it\n    action: async ({ request }) => {\n      return updateFakeTeam(await request.formData());\n    },\n\n    // and renders this element in case something went wrong\n    errorElement: <ErrorBoundary />,\n  },\n]);\n```\n\nYou can also declare your routes with JSX and [`createRoutesFromElements`](../utils/create-routes-from-elements), the props to the element are identical to the properties of the route objects:\n\n``` javascript\nconst router = createBrowserRouter(\n  createRoutesFromElements(\n    <Route\n      element={<Team />}\n      path=\"teams/:teamId\"\n      loader={async ({ params }) => {\n        return fetch(\n          `/fake/api/teams/${params.teamId}.json`\n        );\n      }}\n      action={async ({ request }) => {\n        return updateFakeTeam(await request.formData());\n      }}\n      errorElement={<ErrorBoundary />}\n    />\n  )\n);\n```\n\nNeither style is discouraged and behavior is identical. For the majority of this doc we will use the JSX style because that's what most people are accustomed to in the context of React Router.\n\n## Type declaration\n\n``` javascript\ninterface RouteObject {\n  path?: string;\n  index?: boolean;\n  children?: React.ReactNode;\n  caseSensitive?: boolean;\n  id?: string;\n  loader?: LoaderFunction;\n  action?: ActionFunction;\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n  handle?: RouteObject[\"handle\"];\n  shouldRevalidate?: ShouldRevalidateFunction;\n}\n```\n\n## `path`\n\nThe path pattern to match against the URL to determine if this route matches a URL, link href, or form action.\n\n### Dynamic Segments\n\nIf a path segment starts with `:` then it becomes a \"dynamic segment\". When the route matches the URL, the dynamic segment will be parsed from the URL and provided as `params` to other router APIs.\n\n``` javascript\n<Route\n  // this path will match URLs like\n  // - /teams/hotspur\n  // - /teams/real\n  path=\"/teams/:teamId\"\n  // the matching param will be available to the loader\n  loader={({ params }) => {\n    console.log(params.teamId); // \"hotspur\"\n  }}\n  // and the action\n  action={({ params }) => {}}\n  element={<Team />}\n/>;\n\n// and the element through `useParams`\nfunction Team() {\n  let params = useParams();\n  console.log(params.teamId); // \"hotspur\"\n}\n```\n\nYou can have multiple dynamic segments in one route path:\n\n``` javascript\n<Route path=\"/c/:categoryId/p/:productId\" />;\n// both will be available\nparams.categoryId;\nparams.productId;\n```\n\nDynamic segments cannot be \"partial\":\n\n- 🚫 `\"/teams-:teamId\"`\n- ✅ `\"/teams/:teamId\"`\n- 🚫 `\"/:category--:productId\"`\n- ✅ `\"/:productSlug\"`\n\nYou can still support URL patterns like that, you just have to do a bit of your own parsing:\n\n``` javascript\nfunction Product() {\n  const { productSlug } = useParams();\n  const [category, product] = productSlug.split(\"--\");\n  // ...\n}\n```\n\n### Splats\n\nAlso known as \"catchall\" and \"star\" segments. If a route path pattern ends with `/*` then it will match any characters following the `/`, including other `/` characters.\n\n``` javascript\n<Route\n  // this path will match URLs like\n  // - /files\n  // - /files/one\n  // - /files/one/two\n  // - /files/one/two/three\n  path=\"/files/*\"\n  // the matching param will be available to the loader\n  loader={({ params }) => {\n    console.log(params[\"*\"]); // \"one/two\"\n  }}\n  // and the action\n  action={({ params }) => {}}\n  element={<Team />}\n/>;\n\n// and the element through `useParams`\nfunction Team() {\n  let params = useParams();\n  console.log(params[\"*\"]); // \"one/two\"\n}\n```\n\nYou can destructure the `*`, you just have to assign it a new name. A common name is `splat`:\n\n``` javascript\nlet { org, \"*\": splat } = params;\n```\n\n### Layout Routes\n\nTODO: expand with example\n\nOmitting the path makes this route a \"layout route\". It participates in UI nesting, but it does not add any segments to the URL.\n\n## `index`\n\nDetermines if the route is an index route. Index routes render into their parent's [Outlet](outlet) at their parent's URL (like a default child route).\n\n``` javascript\n<Route path=\"/teams\" element={<Teams />}>\n  <Route index element={<TeamsIndex />} />\n  <Route path=\":teamId\" element={<Team />} />\n</Route>\n```\n\nThese special routes can be confusing to understand at first, so we have a guide dedicated to them here: [Index Route](../guides/index-route).\n\n## `children`\n\n(TODO: need to talk about nesting, maybe even a separate doc)\n\n## `caseSensitive`\n\nInstructs the route to match case or not:\n\n``` javascript\n<Route caseSensitive path=\"/wEll-aCtuA11y\" />\n```\n\n- Will match `\"wEll-aCtuA11y\"`\n- Will not match `\"well-actua11y\"`\n\n## `loader`\n\nThe route loader is called before the route renders and provides data for the element through [`useLoaderData`](../hooks/use-loader-data).\n\n``` javascript\n<Route\n  path=\"/teams/:teamId\"\n  loader={({ params }) => {\n    return fetchTeam(params.teamId);\n  }}\n/>;\n\nfunction Team() {\n  let team = useLoaderData();\n  // ...\n}\n```\n\nIf you are not using a data router like [`createBrowserRouter`](../routers/create-browser-router), this will do nothing\n\nPlease see the [loader](loader) documentation for more details.\n\n## `action`\n\nThe route action is called when a submission is sent to the route from a [Form](../components/form), [fetcher](../hooks/use-fetcher), or [submission](../hooks/use-submit).\n\n``` javascript\n<Route\n  path=\"/teams/:teamId\"\n  action={({ request }) => {\n    const formData = await request.formData();\n    return updateTeam(formData);\n  }}\n/>\n```\n\nIf you are not using a data router like [`createBrowserRouter`](../routers/create-browser-router), this will do nothing\n\nPlease see the [action](action) documentation for more details.\n\n## `element`\n\nThe element to render when the route matches the URL.\n\n``` javascript\n<Route path=\"/for-sale\" element={<Properties />} />\n```\n\n## `errorElement`\n\nWhen a route throws an exception while rendering, in a `loader` or in an `action`, this element will render instead of the normal `element`.\n\n``` javascript\n<Route\n  path=\"/for-sale\"\n  // if this throws an error while rendering\n  element={<Properties />}\n  // or this while loading properties\n  loader={() => loadProperties()}\n  // or this while creating a property\n  action={async ({ request }) =>\n    createProperty(await request.formData())\n  }\n  // then this element will render\n  errorElement={<ErrorBoundary />}\n/>\n```\n\nIf you are not using a data router like [`createBrowserRouter`](../routers/create-browser-router), this will do nothing\n\nPlease see the [errorElement](error-element) documentation for more details.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/route/route](https://reactrouterdotcom.fly.dev/docs/en/v6/route/route)"
- name: Route APIs
  id: components/route
  summary: Because the API and use cases for <Route /> includes data loading, mutations, and more, <Route> has its own documentation category
  description: "# Route APIs\n\nBecause the API and use cases for `<Route />` includes data loading, mutations, and more, `<Route>` has its own documentation category.\n\nPlease refer to:\n\n- [`<Route>`](../route/route)\n- [`loader`](../route/loader)\n- [`action`](../route/action)\n- [`errorElement`](../route/error-element)\n- [`shouldRevalidate`](../route/should-revalidate)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/components/route](https://reactrouterdotcom.fly.dev/docs/en/v6/components/route)"
- name: Route Matches
  id: start/concepts#route-matches
  summary: When a route matches the URL, it's represented by a match object
  belongs_to: Main Concepts
  description: |-
    ### Route Matches

    When a route matches the URL, it's represented by a [match](#match) object. A match for `<Route path=":teamId" element={<Team/>}/>` would look something like this:

    ``` javascript
    {
      pathname: "/teams/firebirds",
      params: {
        teamId: "firebirds"
      },
      route: {
        element: <Team />,
        path: ":teamId"
      }
    }
    ```

    `pathname` holds the portion of the URL that matched this route (in our case it's all of it). `params` holds the parsed values from any [dynamic segments](#dynamic-segment) that matched. Note that the param's object keys map directly to the name of the segment: `:teamId` becomes `params.teamId`.

    Because our routes are a tree, a single URL can match an entire branch of the tree. Consider the URL `/teams/firebirds`, it would be the following route branch:

    ``` javascript
    <Routes>
      <Route path="/" element={<App />}>
        <Route index element={<Home />} />
        <Route path="teams" element={<Teams />}>
          <Route path=":teamId" element={<Team />} />
          <Route path=":teamId/edit" element={<EditTeam />} />
          <Route path="new" element={<NewTeamForm />} />
          <Route index element={<LeagueStandings />} />
        </Route>
      </Route>
      <Route element={<PageLayout />}>
        <Route path="/privacy" element={<Privacy />} />
        <Route path="/tos" element={<Tos />} />
      </Route>
      <Route path="contact-us" element={<Contact />} />
    </Routes>
    ```

    React Router will create an array of [matches](#match) from these routes and the url so it can render a nested UI that matches the route nesting.

    ``` javascript
    [
      {
        pathname: "/",
        params: null,
        route: {
          element: <App />,
          path: "/",
        },
      },
      {
        pathname: "/teams",
        params: null,
        route: {
          element: <Teams />,
          path: "teams",
        },
      },
      {
        pathname: "/teams/firebirds",
        params: {
          teamId: "firebirds",
        },
        route: {
          element: <Team />,
          path: ":teamId",
        },
      },
    ];
    ```
- name: Route Objects Example
  id: examples/route-objects
  summary: This example demonstrates how to use the useRoutes() hook to define and render routes using regular JavaScript objects instead of <Routes> and <Route> elements
  description: "# Route Objects Example\n\nThis example demonstrates how to use the `useRoutes()` hook to define and render routes using regular JavaScript objects instead of `<Routes>` and `<Route>` elements. This is mainly a stylistic preference that may make more sense in some scenarios, depending on the data structures you're working with to define your routes.\n\nOne interesting thing to note is that even if you don't use this hook directly, `<Routes>` uses it internally. So either way you're using the exact same code path!\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/route-objects?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/route-objects](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/route-objects)"
- name: routes
  id: routers/create-browser-router#routes
  summary: An array of Route objects with nested routes on the children property
  belongs_to: createBrowserRouter
  description: |-
    ## `routes`

    An array of [`Route`](../components/route) objects with nested routes on the `children` property.

    ``` javascript
    createBrowserRouter([
      {
        path: "/",
        element: <Root />,
        loader: rootLoader,
        children: [
          {
            path: "events/:id",
            element: <Event />,
            loader: eventLoader,
          },
        ],
      },
    ]);
    ```
- name: Scroll Flashing
  id: components/scroll-restoration#scroll-flashing
  summary: Without a server side rendering framework like Remix, you may experience some scroll flashing on initial page loads
  belongs_to: <ScrollRestoration />
  description: "## Scroll Flashing\n\nWithout a server side rendering framework like [Remix](https://remix.run), you may experience some scroll flashing on initial page loads. This is because React Router can't restore scroll position until your JS bundles have downloaded, data has loaded, and the full page has rendered (if you're rendering a spinner, the viewport is likely not the size it was when the scroll position was saved).\n\nServer Rendering frameworks can prevent scroll flashing because they can send a fully formed document on the initial load, so scroll can be restored when the page first renders.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/components/scroll-restoration](https://reactrouterdotcom.fly.dev/docs/en/v6/components/scroll-restoration)"
- name: Scroll Restoration
  id: start/overview#scroll-restoration
  summary: React Router will emulate the browser's scroll restoration on navigation, waiting for data to load before scrolling
  belongs_to: Feature Overview
  description: |-
    ## Scroll Restoration

    React Router will emulate the browser's scroll restoration on navigation, waiting for data to load before scrolling. This ensures the scroll position is restored to the right spot.

    You can also customize the behavior by restoring based on something other than locations (like a url pathname) and preventing the scroll from happening on certain links (like tabs in the middle of a page).

    See:

    - [`<ScrollRestoration>`](../components/scroll-restoration)

    &nbsp;
- name: Scroll Restoration
  id: examples/scroll-restoration
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  description: "# Scroll Restoration\n\nThis example demonstrates the basic usage of the `<ScrollRestoration>` component, including:\n\n- Restoring scroll position via `location.key`\n- Restoring scroll position via `location.pathname`\n- Preventing scroll resetting via `<Link>`\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/scroll-restoration?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/scroll-restoration](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/scroll-restoration)"
- name: Search Params
  id: start/overview#search-params
  summary: null
  belongs_to: Feature Overview
  description: |-
    ## Search Params

    TODO:
- name: Search Params Example
  id: examples/search-params
  summary: This example demonstrates how to read and write the URL query string using the useSearchParams() hook
  description: "# Search Params Example\n\nThis example demonstrates how to read and write the URL query string using the `useSearchParams()` hook. This hook is similar to the `useNavigate()` hook, but just for the [`search` portion of the URL](https://developer.mozilla.org/en-US/docs/Web/API/Location/search).\n\nIn this example, we have a form to search for a user on GitHub and display their user profile.\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/search-params?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/search-params](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/search-params)"
- name: Server-Side Rendering
  id: guides/ssr
  summary: The most basic server rendering in React Router is pretty straightforward
  description: "# Server-Side Rendering\n\nThis doc needs updates for 6.4 and only applies to \\<=6.3\n\nThe most basic server rendering in React Router is pretty straightforward. However, there's a lot more to consider than just getting the right routes to render. Here's an incomplete list of things you'll need to handle:\n\n- Bundling your code for the server and the browser\n- Not bundling server-only code into the browser bundles\n- Code splitting that works on the server and in the browser\n- Server Side data loading so you actually have something to render\n- Data loading strategies that work on the client and server\n- Handling code splitting in the server and client\n- Proper HTTP status codes and redirects\n- Environment variables and secrets\n- Deployment\n\nSetting all of this up well can be pretty involved but is worth the performance and UX characteristics you can only get when server rendering.\n\nIf you want to server render your React Router app, we highly recommend you use [Remix](https://remix.run). This is another project of ours that's built on top of React Router and handles all of the things mentioned above and more. Give it a shot!\n\nIf you want to tackle it on your own, you'll need to use `<StaticRouter>` on the server.\n\nFirst you'll need some sort of \"app\" or \"root\" component that gets rendered on the server and in the browser:\n\n``` javascript\nexport default function App() {\n  return (\n    <html>\n      <head>\n        <title>Server Rendered App</title>\n      </head>\n      <body>\n        <Routes>\n          <Route path=\"/\" element={<div>Home</div>} />\n          <Route path=\"/about\" element={<div>About</div>} />\n        </Routes>\n        <script src=\"/build/client.entry.js\" />\n      </body>\n    </html>\n  );\n}\n```\n\nHere's a simple express server that renders the app on the server. Note the use of `StaticRouter`.\n\n``` javascript\nimport express from \"express\";\nimport ReactDOMServer from \"react-dom/server\";\nimport { StaticRouter } from \"react-router-dom/server\";\nimport App from \"./App\";\n\nlet app = express();\n\napp.get(\"*\", (req, res) => {\n  let html = ReactDOMServer.renderToString(\n    <StaticRouter location={req.url}>\n      <App />\n    </StaticRouter>\n  );\n  res.send(\"<!DOCTYPE html>\" + html);\n});\n\napp.listen(3000);\n```\n\nAnd finally, you'll need a similar file to \"hydrate\" the app with your JavaScript bundle that includes the very same `App` component. Note the use of `BrowserRouter` instead of `StaticRouter`.\n\n``` javascript\nimport ReactDOM from \"react-dom\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport App from \"./App\";\n\nReactDOM.hydrate(\n  <BrowserRouter>\n    <App />\n  </BrowserRouter>,\n  document.documentElement\n);\n```\n\nThe only real differences from the client entry are:\n\n- `StaticRouter` instead of `BrowserRouter`\n- passing the URL from the server to `<StaticRouter url>`\n- Using `ReactDOMServer.renderToString` instead of `ReactDOM.render`.\n\nSome parts you'll need to do yourself for this to work:\n\n- How to bundle the code to work in the browser and server\n- How to know where the client entry is for `<script>` in the `<App>` component.\n- Figuring out data loading (especially for the `<title>`).\n\nAgain, we recommend you give [Remix](https://remix.run) a look. It's the best way to server render a React Router app--and perhaps the best way to build any React app 😉.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/guides/ssr](https://reactrouterdotcom.fly.dev/docs/en/v6/guides/ssr)"
- name: Server-side Rendering Example
  id: examples/ssr
  summary: This example adds server-side rendering (SSR) to our basic example
  description: "# Server-side Rendering Example\n\nThis example adds [server-side rendering](https://reactjs.org/docs/react-dom-server.html) (SSR) to our basic example.\n\nWith SSR, the server renders your app and sends real HTML to the browser instead of an empty HTML document with a bunch of `<script>` tags. After the browser loads the HTML and JavaScript from the server, React \"hydrates\" the HTML document using the same components it used to render the app on the server.\n\nThis example contains a server (see [server.js](https://github.com/remix-run/react-router/blob/main/examples/ssr/server.js)) that can run in both development and production modes.\n\nIn the browser entry point (see [src/entry.client.tsx](https://github.com/remix-run/react-router/blob/main/examples/ssr/src/entry.client.tsx)), we use React Router like we would traditionally do in a purely client-side app and render a `<BrowserRouter>` to provide routing context to the rest of the app. The main difference is that instead of using `ReactDOM.createRoot(el).render()` to render the app, since the HTML was already sent by the server, all we need is `ReactDOM.hydrateRoot()`.\n\nOn the server (see [src/entry.server.tsx](https://github.com/remix-run/react-router/blob/main/examples/ssr/src/entry.server.tsx)), we use React Router's `<StaticRouter>` to render the app and plug in the URL we get from the incoming HTTP request.\n\n## Preview\n\nOpen this example on [StackBlitz](https://stackblitz.com):\n\n[](https://stackblitz.com/github/remix-run/react-router/tree/main/examples/ssr?file=src/App.tsx)\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/examples/ssr](https://reactrouterdotcom.fly.dev/docs/en/v6/examples/ssr)"
- name: Setup
  id: start/tutorial#setup
  summary: We'll be using Vite for our bundler and dev server for this tutorial
  belongs_to: Tutorial
  description: |-
    ## Setup

    If you're not going to follow along in your own app, you can skip this section

    We'll be using [Vite](https://vitejs.dev/guide/) for our bundler and dev server for this tutorial. You'll need [Node.js](https://nodejs.org) installed for the `npm` command line tool.

    👉️ **Open up your terminal and bootstrap a new React app with Vite:**

    ``` javascript
    npm create vite@latest name-of-your-project -- --template react
    # follow prompts
    cd <your new project directory>
    npm install react-router-dom localforage match-sorter sort-by
    npm run dev
    ```

    You should be able to visit the URL printed in the terminal:

    We've got some pre-written CSS for this tutorial so we can stay focused on React Router. Feel free to judge it harshly or write your own 😅 (We did things we normally wouldn't in CSS so that the markup in this tutorial could stay as minimal as possible.)

    👉 **Copy/Paste the tutorial CSS [found here](https://gist.githubusercontent.com/ryanflorence/ba20d473ef59e1965543fa013ae4163f/raw/499707f25a5690d490c7b3d54c65c65eb895930c/react-router-6.4-tutorial-css.css) into `src/index.css`**

    This tutorial will be creating, reading, searching, updating, and deleting data. A typical web app would probably be talking to an API on your web server, but we're going to use browser storage and fake some network latency to keep this focused. None of this code is relevant to React Router, so just go ahead and copy/paste it all.

    👉 **Copy/Paste the tutorial data module [found here](https://gist.githubusercontent.com/ryanflorence/1e7f5d3344c0db4a8394292c157cd305/raw/f7ff21e9ae7ffd55bfaaaf320e09c6a08a8a6611/contacts.js) into `src/contacts.js`**

    All you need in the src folder are `contacts.js`, `main.jsx`, and `index.css`. You can delete anything else (like `App.js` and `assets`, etc.).

    👉 **Delete unused files in `src/` so all you have left are these:**

    If your app is running, it might blow up momentarily, just keep going 😋. And with that, we're ready to get started!
- name: Setup
  id: guides/contributing#setup
  summary: Before you can contribute to the codebase, you will need to fork the repo
  belongs_to: Contributing to React Router
  description: |-
    ## Setup

    Before you can contribute to the codebase, you will need to fork the repo. This will look a bit different depending on what type of contribution you are making:

    - All new features, bug-fixes, or **anything that touches `react-router` code** should be branched off of and merged into the `dev` branch
    - Changes that only touch documentation can be branched off of and merged into the `main` branch

    The following steps will get you set up to contribute changes to this repo:

    1.  Fork the repo (click the Fork button at the top right of [this page](https://github.com/remix-run/react-router))
    2.  Clone your fork locally

    ``` javascript
    # in a terminal, cd to parent directory where you want your clone to be, then
    git clone https://github.com/<your_github_username>/react-router.git
    cd react-router

    # if you are making *any* code changes, make sure to checkout the dev branch
    git checkout dev
    ```

    3.  Install dependencies and build. React Router uses [`yarn` (version 1)](https://classic.yarnpkg.com/lang/en/docs/install), so you should too. If you install using `npm`, unnecessary `package-lock.json` files will be generated.
- name: shouldRevalidate
  id: route/should-revalidate
  summary: This function allows you opt-out of revalidation for a route's loader as an optimization
  description: "# `shouldRevalidate`\n\nThis function allows you opt-out of revalidation for a route's loader as an optimization.\n\nThere are several instances where data is revalidated, keeping your UI in sync with your data automatically:\n\n- After an [`action`](action) is called from a [`<Form>`](../components/form).\n- After an [`action`](action) is called from a [`<fetcher.Form>`](../hooks/use-fetcher)\n- After an [`action`](action) is called from \\[`useSubmit`\\]\\[usesubmit\\]\n- After an [`action`](action) is called from a [`fetcher.submit`](../hooks/use-fetcher)\n- When the [URL params](route#dynamic-segments) change for an already rendered route\n- When the URL Search params change\n- When navigating to the same URL as the current URL\n\nIf you define `shouldRevalidate` on a route, it will first check the function before calling the route loader for new data. If the function returns `false`, then the loader *will not* be called and the existing data for that loader will persist on the page.\n\n``` javascript\n<Route\n  path=\"meals-plans\"\n  element={<MealPlans />}\n  loader={loadMealPlans}\n  shouldRevalidate={({ currentUrl }) => {\n    // only revalidate if the submission originates from\n    // the `/meal-plans/new` route.\n    return currentUrl.pathname === \"/meal-plans/new\";\n  }}\n>\n  <Route\n    path=\"new\"\n    element={<NewMealPlanForm />}\n    // `loadMealPlans` will be revalidated after\n    // this action...\n    action={createMealPlan}\n  />\n  <Route\n    path=\":planId/meal\"\n    element={<Meal />}\n    // ...but not this one because origin the URL\n    // is not \"/meal-plans/new\"\n    action={updateMeal}\n  />\n</Route>\n```\n\nNote that this is only for data that has already been loaded, is currently rendered, and will continue to be rendered at the new URL. Data for new routes and fetchers at the new URL will always be fetched initially.\n\nUsing this API risks your UI getting out of sync with your data, use with caution!\n\n## Type Declaration\n\n``` javascript\ninterface ShouldRevalidateFunction {\n  (args: {\n    currentUrl: URL;\n    currentParams: AgnosticDataRouteMatch[\"params\"];\n    nextUrl: URL;\n    nextParams: AgnosticDataRouteMatch[\"params\"];\n    formMethod?: Submission[\"formMethod\"];\n    formAction?: Submission[\"formAction\"];\n    formEncType?: Submission[\"formEncType\"];\n    formData?: Submission[\"formData\"];\n    actionResult?: DataResult;\n    defaultShouldRevalidate: boolean;\n  }): boolean;\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/route/should-revalidate](https://reactrouterdotcom.fly.dev/docs/en/v6/route/should-revalidate)"
- name: Skeleton UI with <Suspense>
  id: start/overview#skeleton-ui-with-suspense
  summary: Instead of waiting for the data for the next page, you can defer data so the UI flips over to the next screen with placeholder UI immediately while the data loads
  belongs_to: Feature Overview
  description: |-
    ## Skeleton UI with `<Suspense>`

    Instead of waiting for the data for the next page, you can [`defer`](../utils/defer) data so the UI flips over to the next screen with placeholder UI immediately while the data loads.

    ``` javascript
    <Route
      path="issue/:issueId"
      element={<Issue />}
      loader={async ({ params }) => {
        // these are promises, but *not* awaited
        const comments = fake.getIssueComments(params.issueId);
        const history = fake.getIssueHistory(params.issueId);
        // the issue, however, *is* awaited
        const issue = await fake.getIssue(params.issueId);

        // defer enables suspense for the un-awaited promises
        return defer({ issue, comments, history });
      }}
    />;

    function Issue() {
      const { issue, history, comments } = useLoaderData();
      return (
        <div>
          <IssueDescription issue={issue} />

          {/* Suspense provides the placeholder fallback */}
          <Suspense fallback={<IssueHistorySkeleton />}>
            {/* Await manages the deferred data (promise) */}
            <Await resolve={history}>
              {/* this calls back when the data is resolved */}
              {(resolvedHistory) => (
                <IssueHistory history={resolvedHistory} />
              )}
            </Await>
          </Suspense>

          <Suspense fallback={<IssueCommentsSkeleton />}>
            <Await resolve={comments}>
              {/* ... or you can use hooks to access the data */}
              <IssueComments />
            </Await>
          </Suspense>
        </div>
      );
    }

    function IssueComments() {
      const comments = useAsyncValue();
      return <div>{/* ... */}</div>;
    }
    ```

    See

    - [Deferred Data Guide](../guides/deferred)
    - [`defer`](../utils/defer)
    - [`Await`](../components/await)
    - [`useAsyncValue`](../hooks/use-async-value)

    &nbsp;
- name: Splats
  id: route/route#splats
  summary: Also known as "catchall" and "star" segments
  belongs_to: Route
  description: |-
    ### Splats

    Also known as "catchall" and "star" segments. If a route path pattern ends with `/*` then it will match any characters following the `/`, including other `/` characters.

    ``` javascript
    <Route
      // this path will match URLs like
      // - /files
      // - /files/one
      // - /files/one/two
      // - /files/one/two/three
      path="/files/*"
      // the matching param will be available to the loader
      loader={({ params }) => {
        console.log(params["*"]); // "one/two"
      }}
      // and the action
      action={({ params }) => {}}
      element={<Team />}
    />;

    // and the element through `useParams`
    function Team() {
      let params = useParams();
      console.log(params["*"]); // "one/two"
    }
    ```

    You can destructure the `*`, you just have to assign it a new name. A common name is `splat`:

    ``` javascript
    let { org, "*": splat } = params;
    ```
- name: Submit options
  id: hooks/use-submit#submit-options
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: useSubmit
  description: "## Submit options\n\nThe second argument is a set of options that map directly to form submission attributes:\n\n``` javascript\nsubmit(null, {\n  action: \"/logout\",\n  method: \"post\",\n});\n\n// same as\n<Form action=\"/logout\" method=\"post\" />;\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-submit](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-submit)"
- name: Submit target
  id: hooks/use-submit#submit-target
  summary: The first argument to submit accepts many different values
  belongs_to: useSubmit
  description: |-
    ## Submit target

    The first argument to submit accepts many different values.

    You can submit any form or form input element:

    ``` javascript
    // input element events
    <input onChange={(event) => submit(event.currentTarget)} />;

    // React refs
    let ref = useRef();
    <button ref={ref} />;
    submit(ref.current);
    ```

    You can submit `FormData`:

    ``` javascript
    let formData = new FormData();
    formData.append("cheese", "gouda");
    submit(formData);
    ```
- name: Submitting Forms onChange
  id: start/tutorial#submitting-forms-onchange
  summary: We've got a product decision to make here
  belongs_to: Tutorial
  description: |-
    ## Submitting Forms `onChange`

    We've got a product decision to make here. For this UI, we'd probably rather have the filtering happen on every key stroke instead of when the form is explicitly submitted.

    We've seen `useNavigate` already, we'll use its cousin, [`useSubmit`](../hooks/use-submit), for this.

    ``` javascript
    // existing code
    import {
      // existing code
      useSubmit,
    } from "react-router-dom";

    export default function Root() {
      const { contacts, q } = useLoaderData();
      const navigation = useNavigation();
      const submit = useSubmit();

      return (
        <>
          <div id="sidebar">
            <h1>React Router Contacts</h1>
            <div>
              <Form id="search-form" role="search">
                <input
                  id="q"
                  aria-label="Search contacts"
                  placeholder="Search"
                  type="search"
                  name="q"
                  defaultValue={q}
                  onChange={(event) => {
                    submit(event.currentTarget.form);
                  }}
                />
                {/* existing code */}
              </Form>
              {/* existing code */}
            </div>
            {/* existing code */}
          </div>
          {/* existing code */}
        </>
      );
    }
    ```

    Now as you type, the form is submitted automatically!

    Note the argument to [`submit`](../hooks/use-submit). We're passing in `event.currentTarget.form`. The `currentTarget` is the DOM node the event is attached to, and the `currentTarget.form` is the input's parent form node. The `submit` function will serialize and submit any form you pass to it.
- name: Synchronizing URLs to Form State
  id: start/tutorial#synchronizing-urls-to-form-state
  summary: There are a couple of UX issues here that we can take care of quickly
  belongs_to: Tutorial
  description: |-
    ## Synchronizing URLs to Form State

    There are a couple of UX issues here that we can take care of quickly.

    1.  If you click back after a search, the form field still has the value you entered even though the list is no longer filtered.
    2.  If you refresh the page after searching, the form field no longer has the value in it, even though the list is filtered

    In other words, the URL and our form state are out of sync.

    👉 **Return `q` from your loader and set it as the search field default value**

    ``` javascript
    // existing code

    export async function loader({ request }) {
      const url = new URL(request.url);
      const q = url.searchParams.get("q");
      const contacts = await getContacts(q);
      return { contacts, q };
    }

    export default function Root() {
      const { contacts, q } = useLoaderData();
      const navigation = useNavigation();

      return (
        <>
          <div id="sidebar">
            <h1>React Router Contacts</h1>
            <div>
              <Form id="search-form" role="search">
                <input
                  id="q"
                  aria-label="Search contacts"
                  placeholder="Search"
                  type="search"
                  name="q"
                  defaultValue={q}
                />
                {/* existing code */}
              </Form>
              {/* existing code */}
            </div>
            {/* existing code */}
          </div>
          {/* existing code */}
        </>
      );
    }
    ```

    That solves problem (2). If you refresh the page now, the input field will show the query.

    Now for problem (1), clicking the back button and updating the input. We can bring in `useEffect` from React to manipulate the form's state in the DOM directly.

    👉 **Synchronize input value with the URL Search Params**

    ``` javascript
    import { useEffect } from "react";

    // existing code

    export default function Root() {
      const { contacts, q } = useLoaderData();
      const navigation = useNavigation();

      useEffect(() => {
        document.getElementById("q").value = q;
      }, [q]);

      // existing code
    }
    ```

    > 🤔 Shouldn't you use a controlled component and React State for this?

    You could certainly do this as a controlled component, but you'll end up with more complexity for the same behavior. You don't control the URL, the user does with the back/forward buttons. There would be more synchronization points with a controlled component.

    If you're still concerned, expand this to see what it would look like

    Notice how controlling the input requires three points of synchronization now instead of just one. The behavior is identical but the code is more complex.

    ``` javascript
    import { useEffect, useState } from "react";
    // existing code

    export default function Root() {
      const { contacts, q } = useLoaderData();
      const [query, setQuery] = useState(q);
      const navigation = useNavigation();

      useEffect(() => {
        setQuery(q);
      }, [q]);

      return (
        <>
          <div id="sidebar">
            <h1>React Router Contacts</h1>
            <div>
              <Form id="search-form" role="search">
                <input
                  id="q"
                  aria-label="Search contacts"
                  placeholder="Search"
                  type="search"
                  name="q"
                  value={query}
                  onChange={(e) => {
                    setQuery(e.target.value);
                  }}
                />
                {/* existing code */}
              </Form>
              {/* existing code */}
            </div>
            {/* existing code */}
          </div>
        </>
      );
    }
    ```
- name: Testing
  id: routers/picking-a-router#testing
  summary: Testing components that use React Router APIs is easiest with createMemoryRouter or <MemoryRouter> instead of the routers you use in your app that require DOM history APIs
  belongs_to: Picking a Router
  description: |-
    ## Testing

    Testing components that use React Router APIs is easiest with [`createMemoryRouter`](create-memory-router) or [`<MemoryRouter>`](memory-router) instead of the routers you use in your app that require DOM history APIs.
- name: Testing
  id: guides/contributing#testing
  summary: Before running the tests, you need to run a build
  belongs_to: Contributing to React Router
  description: |-
    ### Testing

    Before running the tests, you need to run a build. After you build, running `yarn test` from the root directory will run **every** package's tests. If you want to run tests for a specific package, use `yarn test --projects packages/<package-name>`:

    ``` javascript
    # Test all packages
    yarn test

    # Test only react-router-dom
    yarn test --projects packages/react-router-dom
    ```
- name: Tests
  id: guides/contributing#tests
  summary: All commits that fix bugs or add features need a test
  belongs_to: Contributing to React Router
  description: |-
    ### Tests

    All commits that fix bugs or add features need a test.

    `<blink>`Do not merge code without tests!`</blink>`
- name: The Contact Route UI
  id: start/tutorial#the-contact-route-ui
  summary: Instead of a 404 "Not Found" page, we want to actually render something at the URLs we've linked to
  belongs_to: Tutorial
  description: |-
    ## The Contact Route UI

    Instead of a 404 "Not Found" page, we want to actually render something at the URLs we've linked to. For that, we need to make a new route.

    👉 **Create the contact route module**

    ``` javascript
    touch src/routes/contact.jsx
    ```

    👉 **Add the contact component UI**

    It's just a bunch of elements, feel free to copy/paste.

    ``` javascript
    import { Form } from "react-router-dom";

    export default function Contact() {
      const contact = {
        first: "Your",
        last: "Name",
        avatar: "https://placekitten.com/g/200/200",
        twitter: "your_handle",
        notes: "Some notes",
        favorite: true,
      };

      return (
        <div id="contact">
          <div>
            <img
              key={contact.avatar}
              src={contact.avatar || null}
            />
          </div>

          <div>
            <h1>
              {contact.first || contact.last ? (
                <>
                  {contact.first} {contact.last}
                </>
              ) : (
                <i>No Name</i>
              )}{" "}
              <Favorite contact={contact} />
            </h1>

            {contact.twitter && (
              <p>
                <a
                  target="_blank"
                  href={`https://twitter.com/${contact.twitter}`}
                >
                  {contact.twitter}
                </a>
              </p>
            )}

            {contact.notes && <p>{contact.notes}</p>}

            <div>
              <Form action="edit">
                <button type="submit">Edit</button>
              </Form>
              <Form
                method="post"
                action="destroy"
                onSubmit={(event) => {
                  if (
                    !confirm(
                      "Please confirm you want to delete this record."
                    )
                  ) {
                    event.preventDefault();
                  }
                }}
              >
                <button type="submit">Delete</button>
              </Form>
            </div>
          </div>
        </div>
      );
    }

    function Favorite({ contact }) {
      // yes, this is a `let` for later
      let favorite = contact.favorite;
      return (
        <Form method="post">
          <button
            name="favorite"
            value={favorite ? "false" : "true"}
            aria-label={
              favorite
                ? "Remove from favorites"
                : "Add to favorites"
            }
          >
            {favorite ? "★" : "☆"}
          </button>
        </Form>
      );
    }
    ```

    Now that we've got a component, let's hook it up to a new route.

    👉 **Import the contact component and create a new route**

    ``` javascript
    /* existing imports */
    import Contact from "./routes/contact";

    const router = createBrowserRouter([
      {
        path: "/",
        element: <Root />,
        errorElement: <ErrorPage />,
      },
      {
        path: "contacts/:contactId",
        element: <Contact />,
      },
    ]);

    /* existing code */
    ```

    Now if we click one of the links or visit `/contacts/1` we get our new component!

    However, it's not inside of our root layout 😠
- name: The Overlap
  id: guides/data-libs#the-overlap
  summary: Hooks like useQuery often return pending and error states you can use to branch your UI
  belongs_to: Data Library Integration
  description: |-
    ## The Overlap

    Hooks like `useQuery` often return pending and error states you can use to branch your UI. With React Router, you can keep all of that branching out of your happy path components and rely on [`errorElement`](../route/error-element), [`useNavigation`](../hooks/use-navigation), and [`Await`](../components/await) instead.
- name: The problem
  id: guides/deferred#the-problem
  summary: Imagine a scenario where one of your routes' loaders needs to retrieve some data that for one reason or another is quite slow
  belongs_to: Deferred Data Guide
  description: |-
    ## The problem

    Imagine a scenario where one of your routes' loaders needs to retrieve some data that for one reason or another is quite slow. For example, let's say you're showing the user the location of a package that's being delivered to their home:

    ``` javascript
    import { json, useLoaderData } from "react-router-dom";
    import { getPackageLocation } from "./api/packages";

    async function loader({ params }) {
      const packageLocation = await getPackageLocation(
        params.packageId
      );

      return json({ packageLocation });
    }

    function PackageRoute() {
      const data = useLoaderData();
      const { packageLocation } = data;

      return (
        <main>
          <h1>Let's locate your package</h1>
          <p>
            Your package is at {packageLocation.latitude} lat
            and {packageLocation.longitude} long.
          </p>
        </main>
      );
    }
    ```

    We'll assume that `getPackageLocation` is slow. This will lead to initial page load times and transitions to that route to take as long as the slowest bit of data. There are a few things you can do to optimize this and improve the user experience:

    - Speed up the slow thing (😅).
    - Parallelize data loading with `Promise.all` (we have nothing to parallelize in our example, but it might help a bit in other situations).
    - Add a global transition spinner (helps a bit with UX).
    - Add a localized skeleton UI (helps a bit with UX).

    If these approaches don't work well, then you may feel forced to move the slow data out of the `loader` into a component fetch (and show a skeleton fallback UI while loading). In this case you'd render the fallback UI on mount and fire off the fetch for the data. This is actually not so terrible from a DX standpoint thanks to [`useFetcher`](../hooks/use-fetcher). And from a UX standpoint this improves the loading experience for both client-side transitions as well as initial page load. So it does seem to solve the problem.

    But it's still sub optimal in most cases (especially if you're code-splitting route components) for two reasons:

    1.  Client-side fetching puts your data request on a waterfall: document -\> JavaScript -\> Lazy Loaded Route -\> data fetch
    2.  Your code can't easily switch between component fetching and route fetching (more on this later).
- name: The Root Route
  id: start/tutorial#the-root-route
  summary: Let's add the global layout for this app
  belongs_to: Tutorial
  description: |-
    ## The Root Route

    Let's add the global layout for this app.

    👉 **Create `src/routes` and `src/routes/root.jsx`**

    ``` javascript
    mkdir src/routes
    touch src/routes/root.jsx
    ```

    (If you don't want to be a command line nerd, use your editor instead of those commands 🤓)

    👉 **Create the root layout component**

    ``` javascript
    export default function Root() {
      return (
        <>
          <div id="sidebar">
            <h1>React Router Contacts</h1>
            <div>
              <form id="search-form" role="search">
                <input
                  id="q"
                  aria-label="Search contacts"
                  placeholder="Search"
                  type="search"
                  name="q"
                />
                <div
                  id="search-spinner"
                  aria-hidden
                  hidden={true}
                />
                <div
                  className="sr-only"
                  aria-live="polite"
                ></div>
              </form>
              <form method="post">
                <button type="submit">New</button>
              </form>
            </div>
            <nav>
              <ul>
                <li>
                  <a href={`contacts/1`}>Your Name</a>
                </li>
                <li>
                  <a href={`contacts/2`}>Your Friend</a>
                </li>
              </ul>
            </nav>
          </div>
          <div id="detail"></div>
        </>
      );
    }
    ```

    Nothing React Router specific yet, so feel free to copy/paste all of that.

    👉 **Set `<Root>` as the root route's [`element`](../route/route#element)**

    ``` javascript
    /* existing imports */
    import Root from "./routes/root";

    const router = createBrowserRouter([
      {
        path: "/",
        element: <Root />,
      },
    ]);

    ReactDOM.createRoot(document.getElementById("root")).render(
      <React.StrictMode>
        <RouterProvider router={router} />
      </React.StrictMode>
    );
    ```

    The app should look something like this now. It sure is nice having a designer who can also write the CSS, isn't it? (Thank you [Jim](https://blog.jim-nielsen.com/) 🙏).
- name: The solution
  id: guides/deferred#the-solution
  summary: React Router takes advantage of React 18's Suspense for data fetching using the defer Response utility and <Await /> component / useAsyncValue hook
  belongs_to: Deferred Data Guide
  description: |-
    ## The solution

    React Router takes advantage of React 18's Suspense for data fetching using the [`defer` Response](../fetch/defer) utility and [`<Await />`](../components/await) component / [`useAsyncValue`](../hooks/use-async-data) hook. By using these APIs, you can solve both of these problems:

    1.  Your data is no longer on a waterfall: document -\> JavaScript -\> Lazy Loaded Route & data (in parallel)
    2.  Your can easily switch between rendering the fallback and waiting for the data

    Let's take a dive into how to accomplish this.
- name: Think You Found a Bug?
  id: guides/contributing#think-you-found-a-bug
  summary: Please conform to the issue template and provide a clear path to reproduction with a code example
  belongs_to: Contributing to React Router
  description: |-
    ## Think You Found a Bug?

    Please conform to the issue template and provide a clear path to reproduction with a code example. Best is a pull request with a failing test. Next best is a link to CodeSandbox or repository that illustrates the bug.
- name: Throwing in Actions
  id: route/action#throwing-in-actions
  summary: For more details and expanded use cases, read the errorElement documentation
  belongs_to: action
  description: "## Throwing in Actions\n\nYou can `throw` in your action to break out of the current call stack (stop running the current code) and React Router will start over down the \"error path\".\n\n``` javascript\n<Route\n  action={async ({ params }) => {\n    const res = await fetch(\n      `/api/properties/${params.id}`,\n      {\n        method: \"put\",\n        body: await request.formData(),\n      }\n    );\n    if (!res.ok) throw res;\n    return { ok: true };\n  }}\n/>\n```\n\nFor more details and expanded use cases, read the [errorElement](error-element) documentation.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/route/action](https://reactrouterdotcom.fly.dev/docs/en/v6/route/action)"
- name: Throwing in Loaders
  id: route/loader#throwing-in-loaders
  summary: For more details, read the errorElement documentation
  belongs_to: loader
  description: "## Throwing in Loaders\n\nYou can `throw` in your loader to break out of the current call stack (stop running the current code) and React Router will start over down the \"error path\".\n\n``` javascript\nfunction loader({ request, params }) {\n  const res = await fetch(`/api/properties/${params.id}`);\n  if (res.status === 404) {\n    throw new Response(\"Not Found\", { status: 404 });\n  }\n  return res.json();\n}\n```\n\nFor more details, read the [`errorElement`](error-element) documentation.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/route/loader](https://reactrouterdotcom.fly.dev/docs/en/v6/route/loader)"
- name: Throwing Manually
  id: route/error-element#throwing-manually
  summary: While errorElement handles unexpected errors, it can also be used to handle exceptions you expect
  belongs_to: errorElement
  description: |-
    ## Throwing Manually

    While `errorElement` handles unexpected errors, it can also be used to handle exceptions you expect.

    Particularly in loaders and actions, where you work with external data not in your control, you can't always plan on the data existing, the service being available, or the user having access to it. In these cases you can `throw` your own exceptions.

    Here's a "not found" case in a [loader](loader):

    ``` javascript
    <Route
      path="/properties/:id"
      element={<PropertyForSale />}
      errorElement={<PropertyError />}
      loader={async ({ params }) => {
        const res = await fetch(`/api/properties/${params.id}`);
        if (res.status === 404) {
          throw new Response("Not Found", { status: 404 });
        }
        const home = res.json();
        const descriptionHtml = parseMarkdown(
          data.descriptionMarkdown
        );
        return { home, descriptionHtml };
      }}
    />
    ```

    As soon as you know you can't render the route with the data you're loading, you can throw to break the call stack. You don't have to worry about the rest of the work in the loader (like parsing the user's markdown bio) when it doesn't exist. Just throw and get out of there.

    This also means you don't have to worry about a bunch of error branching code in your route component, it won't even try to render if you throw in the loader or action, instead your `errorElement` will render.

    You can throw anything from a loader or action just like you can return anything: responses (like the previous example), errors, or plain objects.
- name: Throwing Responses
  id: route/error-element#throwing-responses
  summary: While you can throw anything and it will be provided back to you through useRouteError, If you throw a Response, React Router will automatically parse the response data before returning it to your components
  belongs_to: errorElement
  description: |-
    ## Throwing Responses

    While you can throw anything and it will be provided back to you through [`useRouteError`](../hooks/use-route-error), If you throw a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response), React Router will automatically parse the response data before returning it to your components.

    Additionally, [`isRouteErrorResponse`](../utils/is-route-error-response) lets you check for this specific type in your boundaries. Coupled with [`json`](../fetch/json), you can easily throw responses with some data and render different cases in your boundary:

    ``` javascript
    import { json } from "react-router-dom";

    function loader() {
      const stillWorksHere = await userStillWorksHere();
      if (!stillWorksHere) {
        throw json(
          {
            sorry: "You have been fired.",
            hrEmail: "hr@bigco.com",
          },
          { status: 401 }
        );
      }
    }

    function ErrorBoundary() {
      const error = useRouteError();

      if (isRouteErrorResponse(error) && error.status === 401) {
        // the response json is automatically parsed to
        // `error.data`, you also have access to the status
        return (
          <div>
            <h1>{error.status}</h1>
            <h2>{error.data.sorry}</h2>
            <p>
              Go ahead and email {error.data.hrEmail} if you
              feel like this is a mistake.
            </p>
          </div>
        );
      }

      // rethrow to let the parent error boundary handle it
      // when it's not a special case for this route
      throw error;
    }
    ```

    This makes it possible to create a general error boundary, usually on your root route, that handles many cases:

    ``` javascript
    function RootBoundary() {
      const error = useRouteError();

      if (isRouteErrorResponse(error)) {
        if (error.status === 404) {
          return <div>This page doesn't exist!</div>;
        }

        if (error.status === 401) {
          return <div>You aren't authorized to see this</div>;
        }

        if (error.status === 503) {
          return <div>Looks like our API is down</div>;
        }

        if (error.status === 418) {
          return <div>🫖</div>;
        }
      }

      return <div>Something went wrong</div>;
    }
    ```
- name: Tutorial
  id: start/tutorial
  summary: Welcome to the tutorial! We'll be building a small, but feature-rich app that let's you keep track of your contacts
  description: "# Tutorial\n\nWelcome to the tutorial! We'll be building a small, but feature-rich app that let's you keep track of your contacts. We expect it to take between 30-60m if you're following along.\n\n👉 **Every time you see this it means you need to do something in the app!**\n\nThe rest is just there for your information and deeper understanding. Let's get to it.\n\n## Setup\n\nIf you're not going to follow along in your own app, you can skip this section\n\nWe'll be using [Vite](https://vitejs.dev/guide/) for our bundler and dev server for this tutorial. You'll need [Node.js](https://nodejs.org) installed for the `npm` command line tool.\n\n👉️ **Open up your terminal and bootstrap a new React app with Vite:**\n\n``` javascript\nnpm create vite@latest name-of-your-project -- --template react\n# follow prompts\ncd <your new project directory>\nnpm install react-router-dom localforage match-sorter sort-by\nnpm run dev\n```\n\nYou should be able to visit the URL printed in the terminal:\n\nWe've got some pre-written CSS for this tutorial so we can stay focused on React Router. Feel free to judge it harshly or write your own 😅 (We did things we normally wouldn't in CSS so that the markup in this tutorial could stay as minimal as possible.)\n\n👉 **Copy/Paste the tutorial CSS [found here](https://gist.githubusercontent.com/ryanflorence/ba20d473ef59e1965543fa013ae4163f/raw/499707f25a5690d490c7b3d54c65c65eb895930c/react-router-6.4-tutorial-css.css) into `src/index.css`**\n\nThis tutorial will be creating, reading, searching, updating, and deleting data. A typical web app would probably be talking to an API on your web server, but we're going to use browser storage and fake some network latency to keep this focused. None of this code is relevant to React Router, so just go ahead and copy/paste it all.\n\n👉 **Copy/Paste the tutorial data module [found here](https://gist.githubusercontent.com/ryanflorence/1e7f5d3344c0db4a8394292c157cd305/raw/f7ff21e9ae7ffd55bfaaaf320e09c6a08a8a6611/contacts.js) into `src/contacts.js`**\n\nAll you need in the src folder are `contacts.js`, `main.jsx`, and `index.css`. You can delete anything else (like `App.js` and `assets`, etc.).\n\n👉 **Delete unused files in `src/` so all you have left are these:**\n\nIf your app is running, it might blow up momentarily, just keep going 😋. And with that, we're ready to get started!\n\n## Adding a Router\n\nFirst thing to do is create a [Browser Router](../routers/create-browser-router) and configure our first route. This will enable client side routing for our web app.\n\nThe `main.jsx` file is the entry point. Open it up and we'll put React Router on the page.\n\n👉 **Create and render a [browser router](../routers/create-browser-router) in `main.jsx`**\n\n``` javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport {\n  createBrowserRouter,\n  RouterProvider,\n  Route,\n} from \"react-router-dom\";\nimport \"./index.css\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <div>Hello world!</div>,\n  },\n]);\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <React.StrictMode>\n    <RouterProvider router={router} />\n  </React.StrictMode>\n);\n```\n\nThis first route is what we often call the \"root route\" since the rest of our routes will render inside of it. It will serve as the root layout of the UI, we'll have nested layouts as we get farther along.\n\n## The Root Route\n\nLet's add the global layout for this app.\n\n👉 **Create `src/routes` and `src/routes/root.jsx`**\n\n``` javascript\nmkdir src/routes\ntouch src/routes/root.jsx\n```\n\n(If you don't want to be a command line nerd, use your editor instead of those commands 🤓)\n\n👉 **Create the root layout component**\n\n``` javascript\nexport default function Root() {\n  return (\n    <>\n      <div id=\"sidebar\">\n        <h1>React Router Contacts</h1>\n        <div>\n          <form id=\"search-form\" role=\"search\">\n            <input\n              id=\"q\"\n              aria-label=\"Search contacts\"\n              placeholder=\"Search\"\n              type=\"search\"\n              name=\"q\"\n            />\n            <div\n              id=\"search-spinner\"\n              aria-hidden\n              hidden={true}\n            />\n            <div\n              className=\"sr-only\"\n              aria-live=\"polite\"\n            ></div>\n          </form>\n          <form method=\"post\">\n            <button type=\"submit\">New</button>\n          </form>\n        </div>\n        <nav>\n          <ul>\n            <li>\n              <a href={`contacts/1`}>Your Name</a>\n            </li>\n            <li>\n              <a href={`contacts/2`}>Your Friend</a>\n            </li>\n          </ul>\n        </nav>\n      </div>\n      <div id=\"detail\"></div>\n    </>\n  );\n}\n```\n\nNothing React Router specific yet, so feel free to copy/paste all of that.\n\n👉 **Set `<Root>` as the root route's [`element`](../route/route#element)**\n\n``` javascript\n/* existing imports */\nimport Root from \"./routes/root\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n  },\n]);\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <React.StrictMode>\n    <RouterProvider router={router} />\n  </React.StrictMode>\n);\n```\n\nThe app should look something like this now. It sure is nice having a designer who can also write the CSS, isn't it? (Thank you [Jim](https://blog.jim-nielsen.com/) 🙏).\n\n## Handling Not Found Errors\n\nIt's always a good idea to know how your app responds to errors early in the project because we all write far more bugs than features when building a new app! Not only will your users get a good experience when this happens, but it helps you during development as well.\n\nWe added some links to this app, let's see what happens when we click them?\n\n👉 **Click one of the sidebar names**\n\nGross! This is the default error screen in React Router, made worse by our flex box styles on the root element in this app 😂.\n\nAnytime your app throws an error while rendering, loading data, or performing data mutations, React Router will catch it and render an error screen. Let's make our own error page.\n\n👉 **Create an error page component**\n\n``` javascript\ntouch src/error-page.jsx\n```\n\n``` javascript\nimport { useRouteError } from \"react-router-dom\";\n\nexport default function ErrorPage() {\n  const error = useRouteError();\n  console.error(error);\n\n  return (\n    <div id=\"error-page\">\n      <h1>Oops!</h1>\n      <p>Sorry, an unexpected error has occurred.</p>\n      <p>\n        <i>{error.statusText || error.message}</i>\n      </p>\n    </div>\n  );\n}\n```\n\n👉 **Set the `<ErrorPage>` as the [`errorElement`](../route/error-element) on the root route**\n\n``` javascript\n/* previous imports */\nimport ErrorPage from \"./error-page\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    errorElement: <ErrorPage />,\n  },\n]);\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <React.StrictMode>\n    <RouterProvider router={router} />\n  </React.StrictMode>\n);\n```\n\nThe error page should now look like this:\n\n(Well, that's not much better. Maybe somebody forgot to ask the designer to make an error page. Maybe everybody forgets to ask the designer to make an error page and then blames the designer for not thinking of it 😆)\n\nNote that [`useRouteError`](../hooks/use-route-error) provides the error that was thrown. When the user navigates to routes that don't exist you'll get an [error response](../utils/is-route-error-response) with a \"Not Found\" `statusText`. We'll see some other errors later in the tutorial and discuss them more.\n\nFor now, it's enough to know that pretty much all of your errors will now be handled by this page instead of infinite spinners, unresponsive pages, or blank screens 🙌\n\n## The Contact Route UI\n\nInstead of a 404 \"Not Found\" page, we want to actually render something at the URLs we've linked to. For that, we need to make a new route.\n\n👉 **Create the contact route module**\n\n``` javascript\ntouch src/routes/contact.jsx\n```\n\n👉 **Add the contact component UI**\n\nIt's just a bunch of elements, feel free to copy/paste.\n\n``` javascript\nimport { Form } from \"react-router-dom\";\n\nexport default function Contact() {\n  const contact = {\n    first: \"Your\",\n    last: \"Name\",\n    avatar: \"https://placekitten.com/g/200/200\",\n    twitter: \"your_handle\",\n    notes: \"Some notes\",\n    favorite: true,\n  };\n\n  return (\n    <div id=\"contact\">\n      <div>\n        <img\n          key={contact.avatar}\n          src={contact.avatar || null}\n        />\n      </div>\n\n      <div>\n        <h1>\n          {contact.first || contact.last ? (\n            <>\n              {contact.first} {contact.last}\n            </>\n          ) : (\n            <i>No Name</i>\n          )}{\" \"}\n          <Favorite contact={contact} />\n        </h1>\n\n        {contact.twitter && (\n          <p>\n            <a\n              target=\"_blank\"\n              href={`https://twitter.com/${contact.twitter}`}\n            >\n              {contact.twitter}\n            </a>\n          </p>\n        )}\n\n        {contact.notes && <p>{contact.notes}</p>}\n\n        <div>\n          <Form action=\"edit\">\n            <button type=\"submit\">Edit</button>\n          </Form>\n          <Form\n            method=\"post\"\n            action=\"destroy\"\n            onSubmit={(event) => {\n              if (\n                !confirm(\n                  \"Please confirm you want to delete this record.\"\n                )\n              ) {\n                event.preventDefault();\n              }\n            }}\n          >\n            <button type=\"submit\">Delete</button>\n          </Form>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nfunction Favorite({ contact }) {\n  // yes, this is a `let` for later\n  let favorite = contact.favorite;\n  return (\n    <Form method=\"post\">\n      <button\n        name=\"favorite\"\n        value={favorite ? \"false\" : \"true\"}\n        aria-label={\n          favorite\n            ? \"Remove from favorites\"\n            : \"Add to favorites\"\n        }\n      >\n        {favorite ? \"★\" : \"☆\"}\n      </button>\n    </Form>\n  );\n}\n```\n\nNow that we've got a component, let's hook it up to a new route.\n\n👉 **Import the contact component and create a new route**\n\n``` javascript\n/* existing imports */\nimport Contact from \"./routes/contact\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    errorElement: <ErrorPage />,\n  },\n  {\n    path: \"contacts/:contactId\",\n    element: <Contact />,\n  },\n]);\n\n/* existing code */\n```\n\nNow if we click one of the links or visit `/contacts/1` we get our new component!\n\nHowever, it's not inside of our root layout 😠\n\n## Nested Routes\n\nWe want the contact component to render *inside* of the `<Root>` layout like this.\n\nWe do it by making the contact route a *child* of the root route.\n\n👉 **Move the contacts route to be a child of the root route**\n\n``` javascript\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    errorElement: <ErrorPage />,\n    children: [\n      {\n        path: \"contacts/:contactId\",\n        element: <Contact />,\n      },\n    ],\n  },\n]);\n```\n\nYou'll now see the root layout again but a blank page on the right. We need to tell the root route *where* we want it to render its child routes. We do that with [`<Outlet>`](../components/outlet).\n\nFind the `<div id=\"detail\">` and put an outlet inside\n\n👉 **Render an [`<Outlet>`](../components/outlet)**\n\n``` javascript\nimport { Outlet } from \"react-router-dom\";\n\nexport default function Root() {\n  return (\n    <>\n      {/* all the other elements */}\n      <div id=\"detail\">\n        <Outlet />\n      </div>\n    </>\n  );\n}\n```\n\n## Client Side Routing\n\nYou may or may not have noticed, but when we click the links in the sidebar, the browser is doing a full document request for the next URL instead of using React Router.\n\nClient side routing allows our app to update the URL without requesting another document from the server. Instead, the app can immediately render new UI. Let's make it happen with [`<Link>`](../components/link).\n\n👉 **Change the sidebar `<a href>` to `<Link to>`**\n\n``` javascript\nimport { Outlet, Link } from \"react-router-dom\";\n\nexport default function Root() {\n  return (\n    <>\n      <div id=\"sidebar\">\n        {/* other elements */}\n\n        <nav>\n          <ul>\n            <li>\n              <Link to={`contacts/1`}>Your Name</Link>\n            </li>\n            <li>\n              <Link to={`contacts/2`}>Your Friend</Link>\n            </li>\n          </ul>\n        </nav>\n\n        {/* other elements */}\n      </div>\n    </>\n  );\n}\n```\n\nYou can open the network tab in the browser devtools to see that it's not requesting documents anymore.\n\n## Loading Data\n\nURL segments, layouts, and data are more often than not coupled (tripled?) together. We can see it in this app already:\n\n| URL Segment  | Component   | Data               |\n|--------------|-------------|--------------------|\n| /            | `<Root>`    | list of contacts   |\n| contacts/:id | `<Contact>` | individual contact |\n\nBecause of this natural coupling, React Router has data conventions to get data into your route components easily.\n\nThere are two APIs we'll be using to load data, [`loader`](../route/loader) and [`useLoaderData`](../hooks/use-loader-data). First we'll create and export a loader function in the root module, then we'll hook it up to the route. Finally, we'll access and render the data.\n\n👉 **Export a loader from `root.jsx`**\n\n``` javascript\nimport { Outlet, Link } from \"react-router-dom\";\nimport { getContacts } from \"../contacts\";\n\nexport async function loader() {\n  const contacts = await getContacts();\n  return { contacts };\n}\n```\n\n👉 **Configure the loader on the route**\n\n``` javascript\n/* other imports */\nimport Root, { loader as rootLoader } from \"./routes/root\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    errorElement: <ErrorPage />,\n    loader: rootLoader,\n    children: [\n      {\n        path: \"contacts/:contactId\",\n        element: <Contact />,\n      },\n    ],\n  },\n]);\n```\n\n👉 **Access and render the data**\n\n``` javascript\nimport {\n  Outlet,\n  Link,\n  useLoaderData,\n} from \"react-router-dom\";\nimport { getContacts } from \"../contacts\";\n\n/* other code */\n\nexport default function Root() {\n  const { contacts } = useLoaderData();\n  return (\n    <>\n      <div id=\"sidebar\">\n        <h1>React Router Contacts</h1>\n        {/* other code */}\n\n        <nav>\n          {contacts.length ? (\n            <ul>\n              {contacts.map((contact) => (\n                <li key={contact.id}>\n                  <Link to={`contacts/${contact.id}`}>\n                    {contact.first || contact.last ? (\n                      <>\n                        {contact.first} {contact.last}\n                      </>\n                    ) : (\n                      <i>No Name</i>\n                    )}{\" \"}\n                    {contact.favorite && <span>★</span>}\n                  </Link>\n                </li>\n              ))}\n            </ul>\n          ) : (\n            <p>\n              <i>No contacts</i>\n            </p>\n          )}\n        </nav>\n\n        {/* other code */}\n      </div>\n    </>\n  );\n}\n```\n\nThat's it! React Router will now automatically keep that data in sync with your UI. We don't have any data yet, so you're probably getting a blank list like this:\n\n## Data Writes + HTML Forms\n\nWe'll create our first contact in a second, but first let's talk about HTML.\n\nReact Router emulates HTML Form navigation as the data mutation primitive, a la web development before the JavaScript cambrian explosion. It gives you the UX capabilities of client rendered apps with the simplicity of the \"old school\" web model.\n\nWhile unfamiliar to some web developers, HTML forms actually cause a navigation in the browser, just like clicking a link. The only difference is in the request: links can only change the URL while forms can also change the request method (GET vs POST) and the request body (POST form data).\n\nWithout client side routing, the browser will serialize the form's data automatically and send it to the server as the request body for POST, and as URLSearchParams for GET. React Router does the same thing, except instead of sending the request to the server, it uses client side routing and sends it to a route [`action`](../route/action).\n\nWe can test this out by clicking the \"New\" button in our app. The app should blow up because the Vite server isn't configured to handle a POST request (it sends a 404, though it should probably be a 405 🤷).\n\nInstead of sending that POST to the Vite server to create a new contact, let's use client side routing instead.\n\n## Creating Contacts\n\nWe'll create new contacts by exporting an `action` in our root route, wiring it up to the route config, and changing our `<form>` to a React Router [`<Form>`](../components/form).\n\n👉 **Create the action and change `<form>` to `<Form>`**\n\n``` javascript\nimport {\n  Outlet,\n  Link,\n  useLoaderData,\n  Form,\n} from \"react-router-dom\";\nimport { getContacts, createContact } from \"../contacts\";\n\nexport async function action() {\n  await createContact();\n}\n\n/* other code */\n\nexport default function Root() {\n  const { contacts } = useLoaderData();\n  return (\n    <>\n      <div id=\"sidebar\">\n        <h1>React Router Contacts</h1>\n        <div>\n          {/* other code */}\n          <Form method=\"post\">\n            <button type=\"submit\">New</button>\n          </Form>\n        </div>\n\n        {/* other code */}\n      </div>\n    </>\n  );\n}\n```\n\n👉 **Import and set the action on the route**\n\n``` javascript\n/* other imports */\n\nimport Root, {\n  loader as rootLoader,\n  action as rootAction,\n} from \"./routes/root\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    errorElement: <ErrorPage />,\n    loader: rootLoader,\n    action: rootAction,\n    children: [\n      {\n        path: \"contacts/:contactId\",\n        element: <Contact />,\n      },\n    ],\n  },\n]);\n```\n\nThat's it! Go ahead and click the \"New\" button and you should see a new record pop into the list 🥳\n\nThe `createContact` method just creates an empty contact with no name or data or anything. But it does still create a record, promise!\n\n> 🧐 Wait a sec ... How did the sidebar update? Where did we call the `action`? Where's the code to refetch the data? Where are `useState`, `onSubmit` and `useEffect`?!\n\nThis is where the \"old school web\" programming model shows up. As we discussed earlier, [`<Form>`](../components/form) prevents the browser from sending the request to the server and sends it to your route `action` instead. In web semantics, a POST usually means some data is changing. By convention, React Router uses this as a hint to automatically revalidate the data on the page after the action finishes. That means all of your `useLoaderData` hooks update and the UI stays in sync with your data automatically! Pretty cool.\n\n## URL Params in Loaders\n\n👉 **Click on the No Name record**\n\nWe should be seeing our old static contact page again, with one difference: the URL now has a real ID for the record.\n\nReviewing the route config, the route looks like this:\n\n``` javascript\n[\n  {\n    path: \"contacts/:contactId\",\n    element: <Contact />,\n  },\n];\n```\n\nNote the `:contactId` URL segment. The colon (`:`) has special meaning, turning it into a \"dynamic segment\". Dynamic segments will match dynamic (changing) values in that position of the URL, like the contact ID. We call these values in the URL \"URL Params\", or just \"params\" for short.\n\nThese [`params`](../route/loader#params) are passed to the loader with keys that match the dynamic segment. For example, our segment is named `:contactId` so the value will be passed as `params.contactId`.\n\nThese params are most often used to find a record by ID. Let's try it out.\n\n👉 **Add a loader to the contact page and access data with `useLoaderData`**\n\n``` javascript\nimport { Form, useLoaderData } from \"react-router-dom\";\nimport { getContact } from \"../contacts\";\n\nexport async function loader({ params }) {\n  return getContact(params.contactId);\n}\n\nexport default function Contact() {\n  const contact = useLoaderData();\n  // existing code\n}\n```\n\n👉 **Configure the loader on the route**\n\n``` javascript\n/* existing code */\nimport Contact, {\n  loader as contactLoader,\n} from \"./routes/contact\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    errorElement: <ErrorPage />,\n    loader: rootLoader,\n    action: rootAction,\n    children: [\n      {\n        path: \"contacts/:contactId\",\n        element: <Contact />,\n        loader: contactLoader,\n      },\n    ],\n  },\n]);\n\n/* existing code */\n```\n\n## Updating Data\n\nJust like creating data, you update data with [`<Form>`](../components/form). Let's make a new route at `contacts/:contactId/edit`. Again, we'll start with the component and then wire it up to the route config.\n\n👉 **Create the edit component**\n\n👉 **Add the edit page UI**\n\nNothing we haven't seen before, feel free to copy/paste:\n\n``` javascript\nimport { Form, useLoaderData } from \"react-router-dom\";\nimport { getContact } from \"../contacts\";\n\nexport function loader({ params }) {\n  return getContact(params.contactId);\n}\n\nexport default function EditContact() {\n  const contact = useLoaderData();\n\n  return (\n    <Form method=\"post\" id=\"contact-form\">\n      <p>\n        <span>Name</span>\n        <input\n          placeholder=\"First\"\n          aria-label=\"First name\"\n          type=\"text\"\n          name=\"first\"\n          defaultValue={contact.first}\n        />\n        <input\n          placeholder=\"Last\"\n          aria-label=\"Last name\"\n          type=\"text\"\n          name=\"last\"\n          defaultValue={contact.last}\n        />\n      </p>\n      <label>\n        <span>Twitter</span>\n        <input\n          type=\"text\"\n          name=\"twitter\"\n          placeholder=\"@jack\"\n          defaultValue={contact.twitter}\n        />\n      </label>\n      <label>\n        <span>Avatar URL</span>\n        <input\n          placeholder=\"https://example.com/avatar.jpg\"\n          aria-label=\"Avatar URL\"\n          type=\"text\"\n          name=\"avatar\"\n          defaultValue={contact.avatar}\n        />\n      </label>\n      <label>\n        <span>Notes</span>\n        <textarea\n          name=\"notes\"\n          defaultValue={contact.notes}\n          rows={6}\n        />\n      </label>\n      <p>\n        <button type=\"submit\">Save</button>\n        <button type=\"button\">Cancel</button>\n      </p>\n    </Form>\n  );\n}\n```\n\n👉 **Add the new edit route**\n\n``` javascript\n/* existing code */\nimport EditContact from \"./routes/edit\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    errorElement: <ErrorPage />,\n    loader: rootLoader,\n    action: rootAction,\n    children: [\n      {\n        path: \"contacts/:contactId\",\n        element: <Contact />,\n        loader: contactLoader,\n      },\n      {\n        path: \"contacts/:contactId/edit\",\n        element: <EditContact />,\n        loader: contactLoader,\n      },\n    ],\n  },\n]);\n\n/* existing code */\n```\n\nWe want it to be rendered in the root route's outlet, so we made it a sibling to the existing child route.\n\n(You might note we reused the `contactLoader` for this route. This is only because we're being lazy in the tutorial. There is no reason to attempt to share loaders among routes, they usually have their own.)\n\nAlright, clicking the \"Edit\" button gives us this new UI:\n\n## Updating Contacts with FormData\n\nThe edit route we just created already renders a form. All we need to do to update the record is wire up an action to the route. The form will post to the action and the data will be automatically revalidated.\n\n👉 **Add an action to the edit module**\n\n``` javascript\nimport {\n  Form,\n  useLoaderData,\n  redirect,\n} from \"react-router-dom\";\nimport { getContact, updateContact } from \"../contacts\";\n\nexport async function action({ request, params }) {\n  const formData = await request.formData();\n  const updates = Object.fromEntries(formData);\n  await updateContact(params.contactId, updates);\n  return redirect(`/contacts/${params.contactId}`);\n}\n\n/* existing code */\n```\n\n👉 **Wire the action up to the route**\n\n``` javascript\n/* existing code */\nimport EditContact, {\n  action as editAction,\n} from \"./routes/edit\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    errorElement: <ErrorPage />,\n    loader: rootLoader,\n    action: rootAction,\n    children: [\n      {\n        path: \"contacts/:contactId\",\n        element: <Contact />,\n        loader: contactLoader,\n      },\n      {\n        path: \"contacts/:contactId/edit\",\n        element: <EditContact />,\n        loader: contactLoader,\n        action: editAction,\n      },\n    ],\n  },\n]);\n\n/* existing code */\n```\n\nFill out the form, hit save, and you should see something like this! (Except easier on the eyes and maybe less hairy.)\n\n## Mutation Discussion\n\n> 😑 It worked, but I have no idea what is going on here...\n\nLet's dig in a bit...\n\nOpen up `src/routes/edit.jsx` and look at the form elements. Notice how they each have a name:\n\n``` javascript\n<input\n  placeholder=\"First\"\n  aria-label=\"First name\"\n  type=\"text\"\n  name=\"first\"\n  defaultValue={contact.first}\n/>\n```\n\nWithout JavaScript, when a form is submitted, the browser will create [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) and set it as the body of the request when it sends it to the server. As mentioned before, React Router prevents that and sends the request to your action instead, including the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData).\n\nEach field in the form is accessible with `formData.get(name)`. For example, given the input field from above, you could access the first and last names like this:\n\n``` javascript\nexport async function action({ request, params }) {\n  const formData = await request.formData();\n  const firstName = formData.get(\"first\");\n  const lastName = formData.get(\"last\");\n  // ...\n}\n```\n\nSince we have a handful of form fields, we used [`Object.fromEntries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) to collect them all into an object, which is exactly what our `updateContact` function wants.\n\n``` javascript\nconst updates = Object.fromEntries(formData);\nupdates.first; // \"Some\"\nupdates.last; // \"Name\"\n```\n\nAside from `action`, none of these APIs we're discussing are provided by React Router: [`request`](https://developer.mozilla.org/en-US/docs/Web/API/Request), [`request.formData`](https://developer.mozilla.org/en-US/docs/Web/API/Request/formData), [`Object.fromEntries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) are all provided by the web platform.\n\nAfter we finished the action, note the [`redirect`](../fetch/redirect) at the end:\n\n``` javascript\nexport async function action({ request, params }) {\n  const formData = await request.formData();\n  const updates = Object.fromEntries(formData);\n  await updateContact(params.contactId, updates);\n  return redirect(`/contacts/${params.contactId}`);\n}\n```\n\nLoaders and actions can both [return a `Response`](../route/loader#returning-responses) (makes sense, since they received a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request)!). The [`redirect`](../fetch/redirect) helper just makes it easier to return a [response](https://developer.mozilla.org/en-US/docs/Web/API/Response) that tells the app to change locations.\n\nWithout client side routing, if a server redirected after a POST request, the new page would fetch the latest data and render. As we learned before, React Router emulates this model and automatically revalidates the data on the page after the action. That's why the sidebar automatically updates when we save the form. The extra revalidation code doesn't exist without client side routing, so it doesn't need to exist with client side routing either!\n\n## Redirecting new records to the edit page\n\nNow that we know how to redirect, let's update the action that creates new contacts to redirect to the edit page:\n\n👉 **Redirect to the new record's edit page**\n\n``` javascript\nimport {\n  Outlet,\n  Link,\n  useLoaderData,\n  Form,\n  redirect,\n} from \"react-router-dom\";\nimport { getContacts, createContact } from \"../contacts\";\n\nexport async function action() {\n  const contact = await createContact();\n  return redirect(`/contacts/${contact.id}/edit`);\n}\n```\n\nNow when we click \"New\", we should end up on the edit page:\n\n👉 **Add a handful of records**\n\nI'm going to use the stellar lineup of speakers from the first Remix Conference 😁\n\n## Active Link Styling\n\nNow that we have a bunch of records, it's not clear which one we're looking at in the sidebar. We can use [`NavLink`](../components/nav-link) to fix this.\n\n👉 **Use a `NavLink` in the sidebar**\n\n``` javascript\nimport {\n  Outlet,\n  NavLink,\n  useLoaderData,\n  Form,\n  redirect,\n} from \"react-router-dom\";\n\nexport default function Root() {\n  return (\n    <>\n      <div id=\"sidebar\">\n        {/* other code */}\n\n        <nav>\n          {contacts.length ? (\n            <ul>\n              {contacts.map((contact) => (\n                <li key={contact.id}>\n                  <NavLink\n                    to={`contacts/${contact.id}`}\n                    className={({ isActive, isPending }) =>\n                      isActive\n                        ? \"active\"\n                        : isPending\n                        ? \"pending\"\n                        : \"\"\n                    }\n                  >\n                    {/* other code */}\n                  </NavLink>\n                </li>\n              ))}\n            </ul>\n          ) : (\n            <p>{/* other code */}</p>\n          )}\n        </nav>\n      </div>\n    </>\n  );\n}\n```\n\nNote that we are passing a function to `className`. When the user is at the URL in the `NavLink`, then `isActive` will be true. When it's *about* to be active (the data is still loading) then `isPending` will be true. This allows us to easily indicate where the user is, as well as provide immediate feedback on links that have been clicked but we're still waiting for data to load.\n\n## Global Pending UI\n\nAs the user navigates the app, React Router will *leave the old page up* as data is loading for the next page. You may have noticed the app feels a little unresponsive as you click between the list. Let's provide the user with some feedback so the app doesn't feel unresponsive.\n\nReact Router is managing all of the state behind the scenes and reveals the pieces of it you need to build dynamic web apps. In this case, we'll use the [`useNavigation`](../hooks/use-navigation) hook.\n\n👉 **`useNavigation` to add global pending UI**\n\n``` javascript\nimport {\n  // existing code\n  useNavigation,\n} from \"react-router-dom\";\n\n// existing code\n\nexport default function Root() {\n  const { contacts } = useLoaderData();\n  const navigation = useNavigation();\n\n  return (\n    <>\n      <div id=\"sidebar\">{/* existing code */}</div>\n      <div\n        id=\"detail\"\n        className={\n          navigation.state === \"loading\" ? \"loading\" : \"\"\n        }\n      >\n        <Outlet />\n      </div>\n    </>\n  );\n}\n```\n\n[`useNavigation`](../hooks/use-navigation) returns the current navigation state: it can be one of `\"idle\" | \"submitting\" | \"loading\"`.\n\nIn our case, we add a `\"loading\"` class to the main part of the app if we're not idle. The CSS then adds a nice fade after a short delay (to avoid flickering the UI for fast loads). You could do anything you want though, like show a spinner or loading bar across the top.\n\nNote that our data model (`src/contact.js`) has a clientside cache, so navigating to the same contact is fast the second time. This behavior is *not* React Router, it will re-load data for changing routes no matter if you've been there before or not. It does, however, avoid calling the loaders for *unchanging* routes (like the list) during a navigation.\n\n## Deleting Records\n\nIf we review code in the contact route, we can find the delete button looks like this:\n\n``` javascript\n<Form\n  method=\"post\"\n  action=\"destroy\"\n  onSubmit={(event) => {\n    if (\n      !confirm(\n        \"Please confirm you want to delete this record.\"\n      )\n    ) {\n      event.preventDefault();\n    }\n  }}\n>\n  <button type=\"submit\">Delete</button>\n</Form>\n```\n\nNote the `action` points to `\"destroy\"`. Like `<Link to>`, `<Form action>` can take a *relative* value. Since the form is rendered in `contact/:contactId`, then a relative action with `destroy` will submit the form to `contact/:contactId/destroy` when clicked.\n\nAt this point you should know everything you need to know to make the delete button work. Maybe give it a shot before moving on? You'll need:\n\n1.  A new route\n2.  An `action` at that route\n3.  `deleteContact` from `src/contacts.js`\n\n👉 **Create the \"destroy\" route module**\n\n👉 **Add the destroy action**\n\n``` javascript\nimport { redirect } from \"react-router-dom\";\nimport { deleteContact } from \"../contacts\";\n\nexport async function action({ params }) {\n  await deleteContact(params.contactId);\n  return redirect(\"/\");\n}\n```\n\n👉 **Add the destroy route to the route config**\n\n``` javascript\n/* existing code */\nimport { action as destroyAction } from \"./routes/destroy\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    /* existing root route props */\n    children: [\n      /* existing routes */\n      {\n        path: \"contacts/:contactId/destroy\",\n        action: destroyAction,\n      },\n    ],\n  },\n]);\n\n/* existing code */\n```\n\nAlright, navigate to a record and click the \"Delete\" button. It works!\n\n> 😅 I'm still confused why this all works\n\nWhen the user clicks the submit button:\n\n1.  `<Form>` prevents the default browser behavior of sending a new POST request to the server, but instead emulates the browser by creating a POST request with client side routing\n2.  The `<Form action=\"destroy\">` matches the new route at `\"contacts/:contactId/destroy\"` and sends it the request\n3.  After the action redirects, React Router calls all of the loaders for the data on the page to get the latest values (this is \"revalidation\"). `useLoaderData` returns new values and causes the components to update!\n\nAdd a form, add an action, React Router does the rest.\n\n## Contextual Errors\n\nJust for kicks, throw an error in the destroy action:\n\n``` javascript\nexport async function action({ params }) {\n  throw new Error(\"oh dang!\");\n  await deleteContact(params.contactId);\n  return redirect(\"/\");\n}\n```\n\nRecognize that screen? It's our [`errorElement`](../route/error-element) from before. The user, however, can't really do anything to recover from this screen except to hit refresh.\n\nLet's create a contextual error message for the destroy route:\n\n``` javascript\n[\n  /* other routes */\n  {\n    path: \"contacts/:contactId/destroy\",\n    action: destroyAction,\n    errorElement: <div>Oops! There was an error.</div>,\n  },\n];\n```\n\nNow try it again:\n\nOur user now has more options than slamming refresh, they can continue to interact with the parts of the page that aren't having trouble 🙌\n\nBecause the destroy route has its own `errorElement` and is a child of the root route, the error will render there instead of the root. As you probably noticed, these errors bubble up to the nearest `errorElement`. Add as many or as few as you like, as long as you've got one at the root.\n\n## Index Routes\n\nWhen we load up the app, you'll notice a big blank page on the right side of our list.\n\nWhen a route has children, and you're at the parent route's path, the `<Outlet>` has nothing to render because no children match. You can think of index routes as the default child route to fill in that space.\n\n👉 **Create the index route module**\n\n👉 **Fill in the index component's elements**\n\nFeel free to copy paste, nothing special here.\n\n``` javascript\nexport default function Index() {\n  return (\n    <p id=\"zero-state\">\n      This is a demo for React Router.\n      <br />\n      Check out{\" \"}\n      <a href=\"https://reactrouter.com/\">\n        the docs at reactrouter.com\n      </a>\n      .\n    </p>\n  );\n}\n```\n\n👉 **Configure the index route**\n\n``` javascript\n// existing code\nimport Index from \"./routes/index\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    errorElement: <ErrorPage />,\n    loader: rootLoader,\n    action: rootAction,\n    children: [\n      { index: true, element: <Index /> },\n      /* existing routes */\n    ],\n  },\n]);\n```\n\nNote the [`{ index:true }`](../route/route#index) instead of [`{ path: \"\" }`](../route/route#path). That tells the router to match and render this route when the user is at the parent route's exact path, so there are no other child routes to render in the `<Outlet>`.\n\nVoila! No more blank space. It's common to put dashboards, stats, feeds, etc. at index routes. They can participate in data loading as well.\n\n## Cancel Button\n\nOn the edit page we've got a cancel button that doesn't do anything yet. We'd like it to do the same thing as the browser's back button.\n\nWe'll need a click handler on the button as well as [`useNavigate`](../hooks/use-navigate) from React Router.\n\n👉 **Add the cancel button click handler with `useNavigate`**\n\n``` javascript\nimport {\n  Form,\n  useLoaderData,\n  redirect,\n  useNavigate,\n} from \"react-router-dom\";\n\nexport default function Edit() {\n  const contact = useLoaderData();\n  const navigate = useNavigate();\n\n  return (\n    <Form method=\"post\" id=\"contact-form\">\n      {/* existing code */}\n\n      <p>\n        <button type=\"submit\">Save</button>\n        <button\n          type=\"button\"\n          onClick={() => {\n            navigate(-1);\n          }}\n        >\n          Cancel\n        </button>\n      </p>\n    </Form>\n  );\n}\n```\n\nNow when the user clicks \"Cancel\", they'll be sent back one entry in the browser's history.\n\n> 🧐 Why is there no `event.preventDefault` on the button?\n\nA `<button type=\"button\">`, while seemingly redundant, is the HTML way of preventing a button from submitting its form.\n\nTwo more features to go. We're on the home stretch!\n\n## URL Search Params and GET Submissions\n\nAll of our interactive UI so far have been either links that change the URL or forms that post data to actions. The search field is interesting because it's a mix of both: it's a form but it only changes the URL, it doesn't change data.\n\nRight now it's just a normal HTML `<form>`, not a React Router `<Form>`. Let's see what the browser does with it by default:\n\n👉 **Type a name into the search field and hit the enter key**\n\nNote the browser's URL now contains your query in the URL as [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams):\n\nIf we review the search form, it looks like this:\n\n``` javascript\n<form id=\"search-form\" role=\"search\">\n  <input\n    id=\"q\"\n    aria-label=\"Search contacts\"\n    placeholder=\"Search\"\n    type=\"search\"\n    name=\"q\"\n  />\n  <div id=\"search-spinner\" aria-hidden hidden={true} />\n  <div className=\"sr-only\" aria-live=\"polite\"></div>\n</form>\n```\n\nAs we've seen before, browsers can serialize forms by the `name` attribute of it's input elements. The name of this input is `q`, that's why the URL has `?q=`. If we named it `search` the URL would be `?search=`.\n\nNote that this form is different from the others we've used, it does not have `<form method=\"post\">`. The default `method` is `\"get\"`. That means when the browser creates the request for the next document, it doesn't put the form data into the request POST body, but into the [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) of a GET request.\n\n## GET Submissions with Client Side Routing\n\nLet's use client side routing to submit this form and filter the list in our existing loader.\n\n👉 **Change `<form>` to `<Form>`**\n\n``` javascript\n<Form id=\"search-form\" role=\"search\">\n  <input\n    id=\"q\"\n    aria-label=\"Search contacts\"\n    placeholder=\"Search\"\n    type=\"search\"\n    name=\"q\"\n  />\n  <div id=\"search-spinner\" aria-hidden hidden={true} />\n  <div className=\"sr-only\" aria-live=\"polite\"></div>\n</Form>\n```\n\n👉 **Filter the list if there are URLSearchParams**\n\n``` javascript\nexport async function loader({ request }) {\n  const url = new URL(request.url);\n  const q = url.searchParams.get(\"q\");\n  const contacts = await getContacts(q);\n  return { contacts };\n}\n```\n\nBecause this is a GET, not a POST, React Router *does not* call the `action`. Submitting a GET form is the same as clicking a link: only the URL changes. That's why the code we added for filtering is in the `loader`, not the `action` of this route.\n\nThis also means it's a normal page navigation. You can click the back button to get back to where you were.\n\n## Synchronizing URLs to Form State\n\nThere are a couple of UX issues here that we can take care of quickly.\n\n1.  If you click back after a search, the form field still has the value you entered even though the list is no longer filtered.\n2.  If you refresh the page after searching, the form field no longer has the value in it, even though the list is filtered\n\nIn other words, the URL and our form state are out of sync.\n\n👉 **Return `q` from your loader and set it as the search field default value**\n\n``` javascript\n// existing code\n\nexport async function loader({ request }) {\n  const url = new URL(request.url);\n  const q = url.searchParams.get(\"q\");\n  const contacts = await getContacts(q);\n  return { contacts, q };\n}\n\nexport default function Root() {\n  const { contacts, q } = useLoaderData();\n  const navigation = useNavigation();\n\n  return (\n    <>\n      <div id=\"sidebar\">\n        <h1>React Router Contacts</h1>\n        <div>\n          <Form id=\"search-form\" role=\"search\">\n            <input\n              id=\"q\"\n              aria-label=\"Search contacts\"\n              placeholder=\"Search\"\n              type=\"search\"\n              name=\"q\"\n              defaultValue={q}\n            />\n            {/* existing code */}\n          </Form>\n          {/* existing code */}\n        </div>\n        {/* existing code */}\n      </div>\n      {/* existing code */}\n    </>\n  );\n}\n```\n\nThat solves problem (2). If you refresh the page now, the input field will show the query.\n\nNow for problem (1), clicking the back button and updating the input. We can bring in `useEffect` from React to manipulate the form's state in the DOM directly.\n\n👉 **Synchronize input value with the URL Search Params**\n\n``` javascript\nimport { useEffect } from \"react\";\n\n// existing code\n\nexport default function Root() {\n  const { contacts, q } = useLoaderData();\n  const navigation = useNavigation();\n\n  useEffect(() => {\n    document.getElementById(\"q\").value = q;\n  }, [q]);\n\n  // existing code\n}\n```\n\n> 🤔 Shouldn't you use a controlled component and React State for this?\n\nYou could certainly do this as a controlled component, but you'll end up with more complexity for the same behavior. You don't control the URL, the user does with the back/forward buttons. There would be more synchronization points with a controlled component.\n\nIf you're still concerned, expand this to see what it would look like\n\nNotice how controlling the input requires three points of synchronization now instead of just one. The behavior is identical but the code is more complex.\n\n``` javascript\nimport { useEffect, useState } from \"react\";\n// existing code\n\nexport default function Root() {\n  const { contacts, q } = useLoaderData();\n  const [query, setQuery] = useState(q);\n  const navigation = useNavigation();\n\n  useEffect(() => {\n    setQuery(q);\n  }, [q]);\n\n  return (\n    <>\n      <div id=\"sidebar\">\n        <h1>React Router Contacts</h1>\n        <div>\n          <Form id=\"search-form\" role=\"search\">\n            <input\n              id=\"q\"\n              aria-label=\"Search contacts\"\n              placeholder=\"Search\"\n              type=\"search\"\n              name=\"q\"\n              value={query}\n              onChange={(e) => {\n                setQuery(e.target.value);\n              }}\n            />\n            {/* existing code */}\n          </Form>\n          {/* existing code */}\n        </div>\n        {/* existing code */}\n      </div>\n    </>\n  );\n}\n```\n\n## Submitting Forms `onChange`\n\nWe've got a product decision to make here. For this UI, we'd probably rather have the filtering happen on every key stroke instead of when the form is explicitly submitted.\n\nWe've seen `useNavigate` already, we'll use its cousin, [`useSubmit`](../hooks/use-submit), for this.\n\n``` javascript\n// existing code\nimport {\n  // existing code\n  useSubmit,\n} from \"react-router-dom\";\n\nexport default function Root() {\n  const { contacts, q } = useLoaderData();\n  const navigation = useNavigation();\n  const submit = useSubmit();\n\n  return (\n    <>\n      <div id=\"sidebar\">\n        <h1>React Router Contacts</h1>\n        <div>\n          <Form id=\"search-form\" role=\"search\">\n            <input\n              id=\"q\"\n              aria-label=\"Search contacts\"\n              placeholder=\"Search\"\n              type=\"search\"\n              name=\"q\"\n              defaultValue={q}\n              onChange={(event) => {\n                submit(event.currentTarget.form);\n              }}\n            />\n            {/* existing code */}\n          </Form>\n          {/* existing code */}\n        </div>\n        {/* existing code */}\n      </div>\n      {/* existing code */}\n    </>\n  );\n}\n```\n\nNow as you type, the form is submitted automatically!\n\nNote the argument to [`submit`](../hooks/use-submit). We're passing in `event.currentTarget.form`. The `currentTarget` is the DOM node the event is attached to, and the `currentTarget.form` is the input's parent form node. The `submit` function will serialize and submit any form you pass to it.\n\n## Adding Search Spinner\n\nIn a production app, it's likely this search will be looking for records in a database that is too large to send all at once and filter client side. That's why this demo has some faked network latency.\n\nWithout any loading indicator, the search feels kinda sluggish. Even if we could make our database faster, we'll always have the user's network latency in the way and out of our control. For a better UX, let's add some immediate UI feedback for the search. For this we'll use [`useNavigation`](../hooks/use-navigation) again.\n\n👉 **Add the search spinner**\n\n``` javascript\n// existing code\n\nexport default function Root() {\n  const { contacts, q } = useLoaderData();\n  const navigation = useNavigation();\n  const submit = useSubmit();\n\n  const searching =\n    navigation.location &&\n    new URLSearchParams(navigation.location.search).has(\n      \"q\"\n    );\n\n  useEffect(() => {\n    document.getElementById(\"q\").value = q;\n  }, [q]);\n\n  return (\n    <>\n      <div id=\"sidebar\">\n        <h1>React Router Contacts</h1>\n        <div>\n          <Form id=\"search-form\" role=\"search\">\n            <input\n              id=\"q\"\n              className={searching ? \"loading\" : \"\"}\n              // existing code\n            />\n            <div\n              id=\"search-spinner\"\n              aria-hidden\n              hidden={!searching}\n            />\n            {/* existing code */}\n          </Form>\n          {/* existing code */}\n        </div>\n        {/* existing code */}\n      </div>\n      {/* existing code */}\n    </>\n  );\n}\n```\n\nThe `navigation.location` will show up when the app is navigating to a new URL and loading the data for it. It then goes away when there is no pending navigation anymore.\n\n## Managing the History Stack\n\nNow that the form is submitted for every key stroke, if we type the characters \"seba\" and then delete them with backspace, we end up with 7 new entries in the stack 😂. We definitely don't want this\n\nWe can avoid this by *replacing* the current entry in the history stack with the next page, instead of pushing into it.\n\n👉 **Use `replace` in `submit`**\n\n``` javascript\n// existing code\n\nexport default function Root() {\n  // existing code\n\n  return (\n    <>\n      <div id=\"sidebar\">\n        <h1>React Router Contacts</h1>\n        <div>\n          <Form id=\"search-form\" role=\"search\">\n            <input\n              id=\"q\"\n              // existing code\n              onChange={(event) => {\n                const isFirstSearch = q == null;\n                submit(event.currentTarget.form, {\n                  replace: !isFirstSearch,\n                });\n              }}\n            />\n            {/* existing code */}\n          </Form>\n          {/* existing code */}\n        </div>\n        {/* existing code */}\n      </div>\n      {/* existing code */}\n    </>\n  );\n}\n```\n\nWe only want to replace search results, not the page before we started searching, so we do a quick check if this is the first search or not and then decide to replace.\n\nEach key stroke no longer creates new entries, so the user can click back out of the search results without having to click it 7 times 😅.\n\n## Mutations Without Navigation\n\nSo far all of our mutations (the times we change data) have used forms that navigate, creating new entries in the history stack. While these user flows are common, it's equally as common to want to change data *without* causing a navigation.\n\nFor these cases, we have the [`useFetcher`](../hooks/use-fetcher) hook. It allows us to communicate with loaders and actions without causing a navigation.\n\nThe ★ button on the contact page makes sense for this. We aren't creating or deleting a new record, we don't want to change pages, we simply want to change the data on the page we're looking at.\n\n👉 **Change the `<Favorite>` form to a fetcher form**\n\n``` javascript\nimport {\n  useLoaderData,\n  Form,\n  useFetcher,\n} from \"react-router-dom\";\n\n// existing code\n\nfunction Favorite({ contact }) {\n  const fetcher = useFetcher();\n  let favorite = contact.favorite;\n\n  return (\n    <fetcher.Form method=\"post\">\n      <button\n        name=\"favorite\"\n        value={favorite ? \"false\" : \"true\"}\n        aria-label={\n          favorite\n            ? \"Remove from favorites\"\n            : \"Add to favorites\"\n        }\n      >\n        {favorite ? \"★\" : \"☆\"}\n      </button>\n    </fetcher.Form>\n  );\n}\n```\n\nMight want to take a look at that form while we're here. As always, our form has fields with a `name` prop. This form will send [`formData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) with a `favorite` key that's either `\"true\" | \"false\"`. Since it's got `method=\"post\"` it will call the action. Since there is no `<fetcher.Form action=\"...\">` prop, it will post to the route where the form is rendered.\n\n👉 **Create the action**\n\n``` javascript\n// existing code\nimport { getContact, updateContact } from \"../contacts\";\n\nexport async function action({ request, params }) {\n  let formData = await request.formData();\n  return updateContact(params.contactId, {\n    favorite: formData.get(\"favorite\") === \"true\",\n  });\n}\n\nexport default function Contact() {\n  // existing code\n}\n```\n\nPretty simple. Pull the form data off the request and send it to the data model.\n\n👉 **Configure the route's new action**\n\n``` javascript\n// existing code\nimport Contact, {\n  loader as contactLoader,\n  action as contactAction,\n} from \"./routes/contact\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    errorElement: <ErrorPage />,\n    loader: rootLoader,\n    action: rootAction,\n    children: [\n      { index: true, element: <Index /> },\n      {\n        path: \"contacts/:contactId\",\n        element: <Contact />,\n        loader: contactLoader,\n        action: contactAction,\n      },\n      /* existing code */\n    ],\n  },\n]);\n```\n\nAlright, we're ready to click the star next to the user's name!\n\nCheck that out, both stars automatically update. Our new `<fetcher.Form method=\"post\">` works almost exactly like a the `<Form>` we've been using: it calls the action and then all data is revalidated automatically--even your errors will be caught the same way.\n\nThere is one key difference though, it's not a navigation--the URL doesn't change, the history stack is unaffected.\n\n## Optimistic UI\n\nYou probably noticed the app felt kind of unresponsive when we clicked the the favorite button from the last section. Once again, we added some network latency because you're going to have it in the real world!\n\nTo give the user some feedback, we could put the star into a loading state with [`fetcher.state`](../hooks/use-fetcher#fetcherstate) (a lot like `navigation.state` from before), but we can do something even better this time. We can use a strategy called \"optimistic UI\"\n\nThe fetcher knows the form data being submitted to the action, so it's available to you on `fetcher.formData`. We'll use that to immediately update the star's state, even though the network hasn't finished. If the update eventually fails, the UI will revert to the real data.\n\n👉 **Read the optimistic value from `fetcher.formData`**\n\n``` javascript\n// existing code\n\nfunction Favorite({ contact }) {\n  const fetcher = useFetcher();\n\n  let favorite = contact.favorite;\n  if (fetcher.formData) {\n    favorite = fetcher.formData.get(\"favorite\") === \"true\";\n  }\n\n  return (\n    <fetcher.Form method=\"post\">\n      <button\n        name=\"favorite\"\n        value={favorite ? \"false\" : \"true\"}\n        aria-label={\n          favorite\n            ? \"Remove from favorites\"\n            : \"Add to favorites\"\n        }\n      >\n        {favorite ? \"★\" : \"☆\"}\n      </button>\n    </fetcher.Form>\n  );\n}\n```\n\nIf you click the button now you should see the star *immediately* change to the new state. Instead of always rendering the actual data, we check if the fetcher has any `formData` being submitted, if so, we'll use that instead. When the action is done, the `fetcher.formData` will no longer exist and we're back to using the actual data. So even if you write bugs in your optimistic UI code, it'll eventually go back to the correct state 🥹\n\n## Not Found Data\n\nWhat happens if the contact we're trying load doesn't exist?\n\nOur root [`errorElement`](../route/error-element) is catching this unexpected error as we try to render a `null` contact. Nice the error was properly handled, but we can do better!\n\nWhenever you have an expected error case in a loader or action–like the data not existing–you can `throw`. The call stack will break, React Router will catch it, and the error path is rendered instead. We won't even try to render a `null` contact.\n\n👉 **Throw a 404 response in the loader**\n\n``` javascript\nexport async function loader({ params }) {\n  const contact = await getContact(params.contactId);\n  if (!contact) {\n    throw new Response(\"\", {\n      status: 404,\n      statusText: \"Not Found\",\n    });\n  }\n  return contact;\n}\n```\n\nInstead of hitting a render error with `Cannot read properties of null`, we avoid the component completely and render the error path instead, telling the user something more specific.\n\nThis keeps your happy paths, happy. Your route elements don't need to concern themselves with error and loading states.\n\n## Pathless Routes\n\nOne last thing. The last error page we saw would be better if it rendered inside the root outlet, instead of the whole page. In fact, every error in all of our child routes would be better in the outlet, then the user has more options than hitting refresh.\n\nWe'd like it to look like this:\n\nWe could add the error element to every one of the child routes but, since it's all the same error page, this isn't recommended.\n\nThere's a cleaner way. Routes can be used *without* a path, which lets them participate in the UI layout without requiring new path segments in the URL. Check it out:\n\n👉 **Wrap the child routes in a pathless route**\n\n``` javascript\ncreateBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    loader: rootLoader,\n    action: rootAction,\n    errorElement: <ErrorPage />,\n    children: [\n      {\n        errorElement: <ErrorPage />,\n        children: [\n          { index: true, element: <Index /> },\n          {\n            path: \"contacts/:contactId\",\n            element: <Contact />,\n            loader: contactLoader,\n            action: contactAction,\n          },\n          /* the rest of the routes */\n        ],\n      },\n    ],\n  },\n]);\n```\n\nWhen any errors are thrown in the child routes, our new pathless route will catch it and render, preserving the root route's UI!\n\n## JSX Routes\n\nAnd for our final trick, many folks prefer to configure their routes with JSX. You can do that with `createRoutesFromElements`. There is no functional difference between JSX or objects when configuring your routes, it's simply a stylistic preference.\n\n``` javascript\nimport {\n  createRoutesFromElements,\n  createBrowserRouter,\n} from \"react-router-dom\";\n\nconst router = createBrowserRouter(\n  createRoutesFromElements(\n    <Route\n      path=\"/\"\n      element={<Root />}\n      loader={rootLoader}\n      action={rootAction}\n      errorElement={<ErrorPage />}\n    >\n      <Route errorElement={<ErrorPage />}>\n        <Route index element={<Index />} />\n        <Route\n          path=\"contacts/:contactId\"\n          element={<Contact />}\n          loader={contactLoader}\n          action={contactAction}\n        />\n        <Route\n          path=\"contacts/:contactId/edit\"\n          element={<EditContact />}\n          loader={contactLoader}\n          action={editAction}\n        />\n        <Route\n          path=\"contacts/:contactId/destroy\"\n          action={destroyAction}\n        />\n      </Route>\n    </Route>\n  )\n);\n```\n\n------------------------------------------------------------------------\n\nThat's it! Thanks for giving React Router a shot. We hope this tutorial gives you a solid start to build great user experiences. There's a lot more you can do with React Router, so make sure to check out all the APIs 😀\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/start/tutorial](https://reactrouterdotcom.fly.dev/docs/en/v6/start/tutorial)"
- name: Type Declaration
  id: routers/create-memory-router#type-declaration
  summary: null
  belongs_to: createMemoryRouter
  description: |-
    ## Type Declaration

    ``` javascript
    function createMemoryRouter(
      routes: RouteObject[],
      opts?: {
        basename?: string;
        initialEntries?: InitialEntry[];
        initialIndex?: number;
        window?: Window;
      }
    ): RemixRouter;
    ```
- name: Type Declaration
  id: route/should-revalidate#type-declaration
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: shouldRevalidate
  description: "## Type Declaration\n\n``` javascript\ninterface ShouldRevalidateFunction {\n  (args: {\n    currentUrl: URL;\n    currentParams: AgnosticDataRouteMatch[\"params\"];\n    nextUrl: URL;\n    nextParams: AgnosticDataRouteMatch[\"params\"];\n    formMethod?: Submission[\"formMethod\"];\n    formAction?: Submission[\"formAction\"];\n    formEncType?: Submission[\"formEncType\"];\n    formData?: Submission[\"formData\"];\n    actionResult?: DataResult;\n    defaultShouldRevalidate: boolean;\n  }): boolean;\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/route/should-revalidate](https://reactrouterdotcom.fly.dev/docs/en/v6/route/should-revalidate)"
- name: Type declaration
  id: route/route#type-declaration
  summary: null
  belongs_to: Route
  description: |-
    ## Type declaration

    ``` javascript
    interface RouteObject {
      path?: string;
      index?: boolean;
      children?: React.ReactNode;
      caseSensitive?: boolean;
      id?: string;
      loader?: LoaderFunction;
      action?: ActionFunction;
      element?: React.ReactNode | null;
      errorElement?: React.ReactNode | null;
      handle?: RouteObject["handle"];
      shouldRevalidate?: ShouldRevalidateFunction;
    }
    ```
- name: Type Declaration
  id: routers/create-browser-router#type-declaration
  summary: null
  belongs_to: createBrowserRouter
  description: |-
    ## Type Declaration

    ``` javascript
    function createBrowserRouter(
      routes: RouteObject[],
      opts?: {
        basename?: string;
        window?: Window;
      }
    ): RemixRouter;
    ```
- name: Type Declaration
  id: hooks/use-navigate#type-declaration
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: useNavigate
  description: "## Type Declaration\n\n``` javascript\ndeclare function useNavigate(): NavigateFunction;\n\ninterface NavigateFunction {\n  (\n    to: To,\n    options?: {\n      replace?: boolean;\n      state?: any;\n      relative?: RelativeRoutingType;\n    }\n  ): void;\n  (delta: number): void;\n}\n```\n\nThe `navigate` function has two signatures:\n\n- Either pass a `To` value (same type as `<Link to>`) with an optional second `{ replace, state }` arg or\n- Pass the delta you want to go in the history stack. For example, `navigate(-1)` is equivalent to hitting the back button.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-navigate](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-navigate)"
- name: Type declaration
  id: utils/create-routes-from-elements#type-declaration
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  belongs_to: createRoutesFromElements
  description: "## Type declaration\n\n``` javascript\ndeclare function createRoutesFromElements(\n  children: React.ReactNode\n): RouteObject[];\n\ninterface RouteObject {\n  caseSensitive?: boolean;\n  children?: RouteObject[];\n  element?: React.ReactNode;\n  index?: boolean;\n  path?: string;\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/utils/create-routes-from-elements](https://reactrouterdotcom.fly.dev/docs/en/v6/utils/create-routes-from-elements)"
- name: Type Declaration
  id: fetch/redirect#type-declaration
  summary: null
  belongs_to: redirect
  description: |-
    ## Type Declaration

    ``` javascript
    type RedirectFunction = (
      url: string,
      init?: number | ResponseInit
    ) => Response;
    ```
- name: Updating Contacts with FormData
  id: start/tutorial#updating-contacts-with-formdata
  summary: The edit route we just created already renders a form
  belongs_to: Tutorial
  description: |-
    ## Updating Contacts with FormData

    The edit route we just created already renders a form. All we need to do to update the record is wire up an action to the route. The form will post to the action and the data will be automatically revalidated.

    👉 **Add an action to the edit module**

    ``` javascript
    import {
      Form,
      useLoaderData,
      redirect,
    } from "react-router-dom";
    import { getContact, updateContact } from "../contacts";

    export async function action({ request, params }) {
      const formData = await request.formData();
      const updates = Object.fromEntries(formData);
      await updateContact(params.contactId, updates);
      return redirect(`/contacts/${params.contactId}`);
    }

    /* existing code */
    ```

    👉 **Wire the action up to the route**

    ``` javascript
    /* existing code */
    import EditContact, {
      action as editAction,
    } from "./routes/edit";

    const router = createBrowserRouter([
      {
        path: "/",
        element: <Root />,
        errorElement: <ErrorPage />,
        loader: rootLoader,
        action: rootAction,
        children: [
          {
            path: "contacts/:contactId",
            element: <Contact />,
            loader: contactLoader,
          },
          {
            path: "contacts/:contactId/edit",
            element: <EditContact />,
            loader: contactLoader,
            action: editAction,
          },
        ],
      },
    ]);

    /* existing code */
    ```

    Fill out the form, hit save, and you should see something like this! (Except easier on the eyes and maybe less hairy.)
- name: Updating Data
  id: start/tutorial#updating-data
  summary: Just like creating data, you update data with <Form>. Let's make a new route at contacts/:contactId/edit
  belongs_to: Tutorial
  description: |-
    ## Updating Data

    Just like creating data, you update data with [`<Form>`](../components/form). Let's make a new route at `contacts/:contactId/edit`. Again, we'll start with the component and then wire it up to the route config.

    👉 **Create the edit component**

    👉 **Add the edit page UI**

    Nothing we haven't seen before, feel free to copy/paste:

    ``` javascript
    import { Form, useLoaderData } from "react-router-dom";
    import { getContact } from "../contacts";

    export function loader({ params }) {
      return getContact(params.contactId);
    }

    export default function EditContact() {
      const contact = useLoaderData();

      return (
        <Form method="post" id="contact-form">
          <p>
            <span>Name</span>
            <input
              placeholder="First"
              aria-label="First name"
              type="text"
              name="first"
              defaultValue={contact.first}
            />
            <input
              placeholder="Last"
              aria-label="Last name"
              type="text"
              name="last"
              defaultValue={contact.last}
            />
          </p>
          <label>
            <span>Twitter</span>
            <input
              type="text"
              name="twitter"
              placeholder="@jack"
              defaultValue={contact.twitter}
            />
          </label>
          <label>
            <span>Avatar URL</span>
            <input
              placeholder="https://example.com/avatar.jpg"
              aria-label="Avatar URL"
              type="text"
              name="avatar"
              defaultValue={contact.avatar}
            />
          </label>
          <label>
            <span>Notes</span>
            <textarea
              name="notes"
              defaultValue={contact.notes}
              rows={6}
            />
          </label>
          <p>
            <button type="submit">Save</button>
            <button type="button">Cancel</button>
          </p>
        </Form>
      );
    }
    ```

    👉 **Add the new edit route**

    ``` javascript
    /* existing code */
    import EditContact from "./routes/edit";

    const router = createBrowserRouter([
      {
        path: "/",
        element: <Root />,
        errorElement: <ErrorPage />,
        loader: rootLoader,
        action: rootAction,
        children: [
          {
            path: "contacts/:contactId",
            element: <Contact />,
            loader: contactLoader,
          },
          {
            path: "contacts/:contactId/edit",
            element: <EditContact />,
            loader: contactLoader,
          },
        ],
      },
    ]);

    /* existing code */
    ```

    We want it to be rendered in the root route's outlet, so we made it a sibling to the existing child route.

    (You might note we reused the `contactLoader` for this route. This is only because we're being lazy in the tutorial. There is no reason to attempt to share loaders among routes, they usually have their own.)

    Alright, clicking the "Edit" button gives us this new UI:
- name: url
  id: fetch/redirect#url
  summary: The URL to redirect to
  belongs_to: redirect
  description: |-
    ## `url`

    The URL to redirect to.

    ``` javascript
    redirect("/login");
    ```
- name: URL Params in Loaders
  id: start/tutorial#url-params-in-loaders
  summary: 'We should be seeing our old static contact page again, with one difference: the URL now has a real ID for the record'
  belongs_to: Tutorial
  description: |-
    ## URL Params in Loaders

    👉 **Click on the No Name record**

    We should be seeing our old static contact page again, with one difference: the URL now has a real ID for the record.

    Reviewing the route config, the route looks like this:

    ``` javascript
    [
      {
        path: "contacts/:contactId",
        element: <Contact />,
      },
    ];
    ```

    Note the `:contactId` URL segment. The colon (`:`) has special meaning, turning it into a "dynamic segment". Dynamic segments will match dynamic (changing) values in that position of the URL, like the contact ID. We call these values in the URL "URL Params", or just "params" for short.

    These [`params`](../route/loader#params) are passed to the loader with keys that match the dynamic segment. For example, our segment is named `:contactId` so the value will be passed as `params.contactId`.

    These params are most often used to find a record by ID. Let's try it out.

    👉 **Add a loader to the contact page and access data with `useLoaderData`**

    ``` javascript
    import { Form, useLoaderData } from "react-router-dom";
    import { getContact } from "../contacts";

    export async function loader({ params }) {
      return getContact(params.contactId);
    }

    export default function Contact() {
      const contact = useLoaderData();
      // existing code
    }
    ```

    👉 **Configure the loader on the route**

    ``` javascript
    /* existing code */
    import Contact, {
      loader as contactLoader,
    } from "./routes/contact";

    const router = createBrowserRouter([
      {
        path: "/",
        element: <Root />,
        errorElement: <ErrorPage />,
        loader: rootLoader,
        action: rootAction,
        children: [
          {
            path: "contacts/:contactId",
            element: <Contact />,
            loader: contactLoader,
          },
        ],
      },
    ]);

    /* existing code */
    ```
- name: URL Search Params and GET Submissions
  id: start/tutorial#url-search-params-and-get-submissions
  summary: All of our interactive UI so far have been either links that change the URL or forms that post data to actions
  belongs_to: Tutorial
  description: |-
    ## URL Search Params and GET Submissions

    All of our interactive UI so far have been either links that change the URL or forms that post data to actions. The search field is interesting because it's a mix of both: it's a form but it only changes the URL, it doesn't change data.

    Right now it's just a normal HTML `<form>`, not a React Router `<Form>`. Let's see what the browser does with it by default:

    👉 **Type a name into the search field and hit the enter key**

    Note the browser's URL now contains your query in the URL as [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams):

    If we review the search form, it looks like this:

    ``` javascript
    <form id="search-form" role="search">
      <input
        id="q"
        aria-label="Search contacts"
        placeholder="Search"
        type="search"
        name="q"
      />
      <div id="search-spinner" aria-hidden hidden={true} />
      <div className="sr-only" aria-live="polite"></div>
    </form>
    ```

    As we've seen before, browsers can serialize forms by the `name` attribute of it's input elements. The name of this input is `q`, that's why the URL has `?q=`. If we named it `search` the URL would be `?search=`.

    Note that this form is different from the others we've used, it does not have `<form method="post">`. The default `method` is `"get"`. That means when the browser creates the request for the next document, it doesn't put the form data into the request POST body, but into the [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) of a GET request.
- name: Usage with defer
  id: guides/data-libs#usage-with-defer
  summary: null
  belongs_to: Data Library Integration
  description: |-
    ## Usage with `defer`

    You can similarly take advantage of the deferred APIs:

    ``` javascript
    function loader() {
      return defer({
        // no await!
        someData: queryClient.fetchQuery("someKey", fn),
      });
    }

    function Comp() {
      // *do* useLoaderData for promise
      const { someData } = useLoaderData();
      return (
        <div>
          <h1>Something</h1>
          <Await
            resolve={someData}
            errorElement={<div>Oops!</div>}
          >
            <SomeView />
          </Await>
        </div>
      );
    }

    function SomeView() {
      // instead of accessing with useAsyncValue
      // const someData = useAsyncValue();
      // `useQuery` as usual
      const { data } = useQuery("someKey");
      // ...
    }
    ```
- name: useActionData
  id: hooks/use-action-data
  summary: This hook provides the returned value from the previous navigation's action result, or undefined if there was no submission
  description: "# `useActionData`\n\nThis hook provides the returned value from the previous navigation's `action` result, or `undefined` if there was no submission.\n\n``` javascript\nimport { useActionData } from \"react-router-dom\";\n\nfunction SomeComponent() {\n  let actionData = useActionData();\n  // ...\n}\n```\n\nThe most common use-case for this hook is form validation errors. If the form isn't right, you can return the errors and let the user try again:\n\n``` javascript\nimport {\n  useActionData,\n  Form,\n  redirect,\n} from \"react-router-dom\";\n\nexport default function SignUp() {\n  const errors = useActionData();\n\n  return (\n    <Form method=\"post\">\n      <p>\n        <input type=\"text\" name=\"email\" />\n        {errors?.email && <span>{errors.email}</span>}\n      </p>\n\n      <p>\n        <input type=\"text\" name=\"password\" />\n        {errors?.password && <span>{errors.password}</span>}\n      </p>\n\n      <p>\n        <button type=\"submit\">Sign up</button>\n      </p>\n    </Form>\n  );\n}\n\nexport async function action({ request }) {\n  const formData = await request.formData();\n  const email = formData.get(\"email\");\n  const password = formData.get(\"password\");\n  const errors = {};\n\n  // validate the fields\n  if (typeof email !== \"string\" || !email.includes(\"@\")) {\n    errors.email =\n      \"That doesn't look like an email address\";\n  }\n\n  if (typeof password !== \"string\" || password.length < 6) {\n    errors.password = \"Password must be > 6 characters\";\n  }\n\n  // return data if we have errors\n  if (Object.keys(errors).length) {\n    return errors;\n  }\n\n  // otherwise create the user and redirect\n  await createUser(email, password);\n  return redirect(\"/dashboard\");\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-action-data](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-action-data)"
- name: useAsyncError
  id: hooks/use-async-error
  summary: Returns the rejection value from the nearest [<Await>][await] component
  description: "# `useAsyncError`\n\nReturns the rejection value from the nearest \\[`<Await>`\\]\\[await\\] component.\n\n``` javascript\nimport { useAsyncError, Await } from \"react-router-dom\";\n\nfunction ErrorElement() {\n  const error = useAsyncError();\n  return (\n    <p>Uh Oh, something went wrong! {error.message}</p>\n  );\n}\n\n<Await\n  resolve={promiseThatRejects}\n  errorElement={<ErrorElement />}\n/>;\n```\n\nSee the [Deferred Data Guide](../guides/deferred) and [`<Await>` docs](../components/await) for more information.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-async-error](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-async-error)"
- name: useAsyncValue
  id: hooks/use-async-value
  summary: Returns the resolved data from the nearest <Await> ancestor component
  description: "# `useAsyncValue`\n\nReturns the resolved data from the nearest `<Await>` ancestor component.\n\n``` javascript\nfunction ProductVariants() {\n  const variants = useAsyncValue();\n  return <div>{/* ... */}</div>;\n}\n\n// Await creates the context for the value\n<Await resolve={somePromiseForProductVariants}>\n  <ProductVariants />\n</Await>;\n```\n\nSee the [Deferred Data Guide](../guides/deferred) and [`<Await>` docs](../components/await) for more information.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-async-value](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-async-value)"
- name: useFetcher
  id: hooks/use-fetcher
  summary: 'In HTML/HTTP, data mutations and loads are modeled with navigation: <a href> and <form action>. Both cause a navigation in the browser'
  description: "# `useFetcher`\n\nIn HTML/HTTP, data mutations and loads are modeled with navigation: `<a href>` and `<form action>`. Both cause a navigation in the browser. The React Router equivalents are [`<Link>`](../components/link) and [`<Form>`](../components/form).\n\nBut sometimes you want to call a loader outside of navigation, or call an action (and get the data on the page to revalidate) without changing the URL. Or you need to have multiple mutations in-flight at the same time.\n\nMany interactions with the server aren't navigation events. This hook lets you plug your UI into your actions and loaders without navigating.\n\nThis is useful when you need to:\n\n- fetch data not associated with UI routes (popovers, dynamic forms, etc.)\n- submit data to actions without navigating (shared components like a newsletter sign ups)\n- handle multiple concurrent submissions in a list (typical \"todo app\" list where you can click multiple buttons and all should be pending at the same time)\n- infinite scroll containers\n- and more!\n\nIf you're building a highly interactive, \"app like\" user interface, you will `useFetcher` often.\n\n``` javascript\nimport { useFetcher } from \"react-router-dom\";\n\nfunction SomeComponent() {\n  const fetcher = useFetcher();\n\n  // call submit or load in a useEffect\n  React.useEffect(() => {\n    fetcher.submit(data, options);\n    fetcher.load(href);\n  }, [fetcher]);\n\n  // build your UI with these properties\n  fetcher.state;\n  fetcher.formData;\n  fetcher.formMethod;\n  fetcher.formAction;\n  fetcher.data;\n\n  // render a form that doesn't cause navigation\n  return <fetcher.Form />;\n}\n```\n\nFetchers have a lot of built-in behavior:\n\n- Automatically handles cancellation on interruptions of the fetch\n- When submitting with POST, PUT, PATCH, DELETE, the action is called first\n  - After the action completes, the data on the page is revalidated to capture any mutations that may have happened, automatically keeping your UI in sync with your server state\n- When multiple fetchers are inflight at once, it will\n  - commit the freshest available data as they each land\n  - ensure no stale loads override fresher data, no matter which order the responses return\n- Handles uncaught errors by rendering the nearest `errorElement` (just like a normal navigation from `<Link>` or `<Form>`)\n- Will redirect the app if your action/loader being called returns a redirect (just like a normal navigation from `<Link>` or `<Form>`)\n\n## `fetcher.state`\n\nYou can know the state of the fetcher with `fetcher.state`. It will be one of:\n\n- **idle** - nothing is being fetched.\n- **submitting** - A route action is being called due to a fetcher submission using POST, PUT, PATCH, or DELETE\n- **loading** - The fetcher is calling a loader (from a `fetcher.load`) or is being revalidated after a separate submission or `useRevalidator` call\n\n## `fetcher.Form`\n\nJust like `<Form>` except it doesn't cause a navigation. (You'll get over the dot in JSX ... we hope!)\n\n``` javascript\nfunction SomeComponent() {\n  const fetcher = useFetcher();\n  return (\n    <fetcher.Form method=\"post\" action=\"/some/route\">\n      <input type=\"text\" />\n    </fetcher.Form>\n  );\n}\n```\n\n## `fetcher.load()`\n\nLoads data from a route loader.\n\n``` javascript\nimport { useFetcher } from \"react-router-dom\";\n\nfunction SomeComponent() {\n  const fetcher = useFetcher();\n\n  useEffect(() => {\n    if (fetcher.state === \"idle\" && !fetcher.data) {\n      fetcher.load(\"/some/route\");\n    }\n  }, [fetcher]);\n\n  return <div>{fetcher.data || \"Loading...\"}</div>;\n}\n```\n\nAlthough a URL might match multiple nested routes, a `fetcher.load()` call will only call the loader on the leaf match (or parent of [index routes](../guides/index-search-param)).\n\nIf you find yourself calling this function inside of click handlers, you can probably simplify your code by using `<fetcher.Form>` instead.\n\nAny `fetcher.load` calls that are active on the page will be re-executed as part of revalidation (either after a navigation submission, another fetcher submission, or a `useRevalidator()` call)\n\n## `fetcher.submit()`\n\nThe imperative version of `<fetcher.Form>`. If a user interaction should initiate the fetch, you should use `<fetcher.Form>`. But if you, the programmer are initiating the fetch (not in response to a user clicking a button, etc.), then use this function.\n\nFor example, you may want to log the user out after a certain amount of idle time:\n\n``` javascript\nimport { useFetcher } from \"react-router-dom\";\nimport { useFakeUserIsIdle } from \"./fake/hooks\";\n\nexport function useIdleLogout() {\n  const fetcher = useFetcher();\n  const userIsIdle = useFakeUserIsIdle();\n\n  useEffect(() => {\n    if (userIsIdle) {\n      fetcher.submit(\n        { idle: true },\n        { method: \"post\", action: \"/logout\" }\n      );\n    }\n  }, [userIsIdle]);\n}\n```\n\nIf you want to submit to an index route, use the [`?index` param](../guides/index-search-param).\n\nIf you find yourself calling this function inside of click handlers, you can probably simplify your code by using `<fetcher.Form>` instead.\n\n## `fetcher.data`\n\nThe returned data from the loader or action is stored here. Once the data is set, it persists on the fetcher even through reloads and resubmissions.\n\n``` javascript\nfunction ProductDetails({ product }) {\n  const fetcher = useFetcher();\n\n  return (\n    <details\n      onToggle={(event) => {\n        if (\n          event.currentTarget.open &&\n          fetcher.state === \"idle\" &&\n          !fetcher.data\n        ) {\n          fetcher.load(`/product/${product.id}/details`);\n        }\n      }}\n    >\n      <summary>{product.name}</summary>\n      {fetcher.data ? (\n        <div>{fetcher.data}</div>\n      ) : (\n        <div>Loading product details...</div>\n      )}\n    </details>\n  );\n}\n```\n\n## `fetcher.formData`\n\nWhen using `<fetcher.Form>` or `fetcher.submit()`, the form data is available to build optimistic UI.\n\n``` javascript\nfunction TaskCheckbox({ task }) {\n  let fetcher = useFetcher();\n\n  // while data is in flight, use that to immediately render\n  // the state you expect the task to be in when the form\n  // submission completes, instead of waiting for the\n  // network to respond. When the network responds, the\n  // formData will no longer be available and the UI will\n  // use the value in `task.status` from the revalidation\n  let status =\n    fetcher.formData?.get(\"status\") || task.status;\n\n  let isComplete = status === \"complete\";\n\n  return (\n    <fetcher.Form method=\"post\">\n      <button\n        type=\"submit\"\n        name=\"status\"\n        value={isComplete ? \"incomplete\" : \"complete\"}\n      >\n        {isComplete ? \"Mark Incomplete\" : \"Mark Complete\"}\n      </button>\n    </fetcher.Form>\n  );\n}\n```\n\n## `fetcher.formAction`\n\nTells you the action url the form is being submitted to.\n\n``` javascript\n<fetcher.Form action=\"/mark-as-read\" />;\n\n// when the form is submitting\nfetcher.formAction; // \"mark-as-read\"\n```\n\n## `fetcher.formMethod`\n\nTells you the method of the form being submitted: get, post, put, patch, or delete.\n\n``` javascript\n<fetcher.Form method=\"post\" />;\n\n// when the form is submitting\nfetcher.formMethod; // \"post\"\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-fetcher](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-fetcher)"
- name: useFetchers
  id: hooks/use-fetchers
  summary: This is useful for components throughout the app that didn't create the fetchers but want to use their submissions to participate in optimistic UI
  description: "# `useFetchers`\n\nReturns an array of all inflight [fetchers](use-fetcher) without their `load`, `submit`, or `Form` properties (can't have parent components trying to control the behavior of their children! We know from IRL experience that this is a fool's errand.)\n\n``` javascript\nimport { useFetchers } from \"react-router-dom\";\n\nfunction SomeComp() {\n  const fetchers = useFetchers();\n  // array of inflight fetchers\n}\n```\n\nThis is useful for components throughout the app that didn't create the fetchers but want to use their submissions to participate in optimistic UI.\n\nFor example, imagine a UI where the sidebar lists projects, and the main view displays a list of checkboxes for the current project. The sidebar could display the number of completed and total tasks for each project.\n\nWhen the user clicks a checkbox, the submission goes to the action to change the state of the task. Instead of creating a \"loading state\" we want to create an \"optimistic UI\" that will **immediately** update the checkbox to appear checked even though the server hasn't processed it yet. In the checkbox component, we can use `fetcher.submission`:\n\n``` javascript\nfunction Task({ task }) {\n  const { projectId, id } = task;\n  const toggle = useFetcher();\n  const checked =\n    toggle.formData?.get(\"complete\") || task.complete;\n\n  return (\n    <toggle.Form\n      method=\"put\"\n      action={`/project/${projectId}/tasks/${id}`}\n    >\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={checked}\n          onChange={(e) => toggle.submit(e.target.form)}\n        />\n      </label>\n    </toggle.Form>\n  );\n}\n```\n\nThis awesome for the checkbox, but the sidebar will say 2/4 while the checkboxes show 3/4 when the user clicks on of them!\n\nBecause routes are automatically revalidated, the sidebar will quickly update and be correct. But for a moment, it's gonna feel a little funny.\n\nThis is where `useFetchers` comes in. Up in the sidebar, we can access all the inflight fetcher states from the checkboxes - even though it's not the component that created them.\n\nThe strategy has three steps:\n\n1.  Find the submissions for tasks in a specific project\n2.  Use the `fetcher.formData` to immediately update the count\n3.  Use the normal task's state if it's not inflight\n\n``` javascript\nfunction ProjectTaskCount({ project }) {\n  let completedTasks = 0;\n  const fetchers = useFetchers();\n\n  // Find this project's fetchers\n  let projectFetchers = fetchers.filter((fetcher) => {\n    return fetcher.formAction?.startsWith(\n      `/projects/${project.id}/task`\n    );\n  });\n\n  // Store in a map for easy lookup\n  const myFetchers = new Map(\n    fetchers.map(({ formData }) => [\n      formData.get(\"id\"),\n      formData.get(\"complete\") === \"on\",\n    ])\n  );\n\n  // Increment the count\n  for (const task of project.tasks) {\n    if (myFetchers.has(task.id)) {\n      if (myFetchers.get(task.id)) {\n        // if it's being submitted, increment optimistically\n        completedTasks++;\n      }\n    } else if (task.complete) {\n      // otherwise use the real task's data\n      completedTasks++;\n    }\n  }\n\n  return (\n    <small>\n      {completedTasks}/{project.tasks.length}\n    </small>\n  );\n}\n```\n\nIt's a little bit of work, but it's mostly just asking React Router for the state it's tracking and doing an optimistic calculation based on it.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-fetchers](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-fetchers)"
- name: useFormAction
  id: hooks/use-form-action
  summary: This hook is used internally in <Form> to automatically resolve default and relative actions to the current route in context
  description: "# `useFormAction`\n\nType declaration\n\n``` javascript\ndeclare function useFormAction(\n  action?: string,\n  { relative }: { relative?: RelativeRoutingType } = {}\n): string;\n```\n\nThis hook is used internally in [`<Form>`](../components/form) to automatically resolve default and relative actions to the current route in context. While uncommon, you can use it directly to do things like compute the correct action for a `<button formAction>` to change the action of the button's `<Form>`. (Yes, HTML buttons can change the action of their form!)\n\n``` javascript\nimport { useFormAction } from \"react-router-dom\";\n\nfunction DeleteButton() {\n  return (\n    <button\n      formAction={useFormAction(\"destroy\")}\n      formMethod=\"post\"\n    >\n      Delete\n    </button>\n  );\n}\n```\n\nIt's also useful for automatically resolving the action for [`submit`](use-submit) and [`fetcher.submit`](use-fetcher#fetchersubmit).\n\n``` javascript\nlet submit = useSubmit();\nlet action = useFormAction();\nsubmit(formData, { action });\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-form-action](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-form-action)"
- name: useHref
  id: hooks/use-href
  summary: The useHref hook returns a URL that may be used to link to the given to location, even outside of React Router
  description: "# `useHref`\n\nType declaration\n\n``` javascript\ndeclare function useHref(\n  to: To,\n  options?: { relative?: RelativeRoutingType }\n): string;\n```\n\nThe `useHref` hook returns a URL that may be used to link to the given `to` location, even outside of React Router.\n\n> **Tip:**\n>\n> You may be interested in taking a look at the source for the `<Link>` component in `react-router-dom` to see how it uses `useHref` internally to determine its own `href` value.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-href](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-href)"
- name: useInRouterContext
  id: hooks/use-in-router-context
  summary: The useInRouterContext hooks returns true if the component is being rendered in the context of a <Router>, false otherwise
  description: "# `useInRouterContext`\n\nType declaration\n\n``` javascript\ndeclare function useInRouterContext(): boolean;\n```\n\nThe `useInRouterContext` hooks returns `true` if the component is being rendered in the context of a `<Router>`, `false` otherwise. This can be useful for some 3rd-party extensions that need to know if they are being rendered in the context of a React Router app.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-in-router-context](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-in-router-context)"
- name: useLinkClickHandler
  id: hooks/use-link-click-handler
  summary: The useLinkClickHandler hook returns a click event handler for navigation when building a custom <Link> in react-router-dom
  description: "# `useLinkClickHandler`\n\nType declaration\n\n``` javascript\ndeclare function useLinkClickHandler<\n  E extends Element = HTMLAnchorElement\n>(\n  to: To,\n  options?: {\n    target?: React.HTMLAttributeAnchorTarget;\n    replace?: boolean;\n    state?: any;\n    options?: { relative?: RelativeRoutingType };\n  }\n): (event: React.MouseEvent<E, MouseEvent>) => void;\n```\n\nThe `useLinkClickHandler` hook returns a click event handler for navigation when building a custom `<Link>` in `react-router-dom`.\n\n``` javascript\nimport {\n  useHref,\n  useLinkClickHandler,\n} from \"react-router-dom\";\n\nconst StyledLink = styled(\"a\", { color: \"fuchsia\" });\n\nconst Link = React.forwardRef(\n  (\n    {\n      onClick,\n      replace = false,\n      state,\n      target,\n      to,\n      ...rest\n    },\n    ref\n  ) => {\n    let href = useHref(to);\n    let handleClick = useLinkClickHandler(to, {\n      replace,\n      state,\n      target,\n    });\n\n    return (\n      <StyledLink\n        {...rest}\n        href={href}\n        onClick={(event) => {\n          onClick?.(event);\n          if (!event.defaultPrevented) {\n            handleClick(event);\n          }\n        }}\n        ref={ref}\n        target={target}\n      />\n    );\n  }\n);\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-link-click-handler](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-link-click-handler)"
- name: useLinkPressHandler
  id: hooks/use-link-press-handler
  summary: The react-router-native counterpart to useLinkClickHandler, useLinkPressHandler returns a press event handler for custom <Link> navigation
  description: "# `useLinkPressHandler`\n\nType declaration\n\n``` javascript\ndeclare function useLinkPressHandler(\n  to: To,\n  options?: {\n    replace?: boolean;\n    state?: any;\n  }\n): (event: GestureResponderEvent) => void;\n```\n\nThe `react-router-native` counterpart to `useLinkClickHandler`, `useLinkPressHandler` returns a press event handler for custom `<Link>` navigation.\n\n``` javascript\nimport { TouchableHighlight } from \"react-native\";\nimport { useLinkPressHandler } from \"react-router-native\";\n\nfunction Link({\n  onPress,\n  replace = false,\n  state,\n  to,\n  ...rest\n}) {\n  let handlePress = useLinkPressHandler(to, {\n    replace,\n    state,\n  });\n\n  return (\n    <TouchableHighlight\n      {...rest}\n      onPress={(event) => {\n        onPress?.(event);\n        if (!event.defaultPrevented) {\n          handlePress(event);\n        }\n      }}\n    />\n  );\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-link-press-handler](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-link-press-handler)"
- name: useLoaderData
  id: hooks/use-loader-data
  summary: This hook provides the value returned from your route loader
  description: "# `useLoaderData`\n\nThis hook provides the value returned from your route loader.\n\n``` javascript\nimport {\n  createBrowserRouter,\n  RouterProvider,\n  useLoaderData,\n} from \"react-router-dom\";\n\nfunction loader() {\n  return fetchFakeAlbums();\n}\n\nexport function Albums() {\n  const albums = useLoaderData();\n  // ...\n}\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    loader: loader,\n    element: <Albums />,\n  },\n]);\n\nReactDOM.createRoot(el).render(\n  <RouterProvider router={router} />\n);\n```\n\nAfter route [actions](../components/route#action) are called, the data will be revalidated automatically and return the latest result from your loader.\n\nNote that `useLoaderData` *does not initiate a fetch*. It simply reads the result of a fetch React Router manages internally, so you don't need to worry about it refetching when it re-renders for reasons outside of routing.\n\nThis also means data returned is stable between renders, so you can safely pass it to dependency arrays in React hooks like `useEffect`. It only changes when the loader is called again after actions or certain navigations. In these cases the identity will change (even if the values don't).\n\nYou can use this hook in any component or any custom hook, not just the Route element. It will return the data from the nearest route on context.\n\nTo get data from any active route on the page, see [`useRouteLoaderData`](use-route-loader-data).\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-loader-data](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-loader-data)"
- name: useLocation
  id: hooks/use-location
  summary: This hook returns the current location object
  description: "# `useLocation`\n\nType declaration\n\n``` javascript\ndeclare function useLocation(): Location;\n\ninterface Location extends Path {\n  state: unknown;\n  key: Key;\n}\n```\n\nThis hook returns the current [`location`](../utils/location) object. This can be useful if you'd like to perform some side effect whenever the current location changes.\n\n``` javascript\nimport * as React from 'react';\nimport { useLocation } from 'react-router-dom';\n\nfunction App() {\n  let location = useLocation();\n\n  React.useEffect(() => {\n    // Google Analytics\n    ga('send', 'pageview');\n  }, [location]);\n\n  return (\n    // ...\n  );\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-location](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-location)"
- name: useMatch
  id: hooks/use-match
  summary: Returns match data about a route at the given path relative to the current location
  description: "# `useMatch`\n\nType declaration\n\n``` javascript\ndeclare function useMatch<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path\n): PathMatch<ParamKey> | null;\n```\n\nReturns match data about a route at the given path relative to the current location.\n\nSee [`matchPath`](../utils/match-path) for more information.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-match](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-match)"
- name: useMatches
  id: hooks/use-matches
  summary: Returns the current route matches on the page
  description: "# `useMatches`\n\nReturns the current route matches on the page. This is most useful for creating abstractions in parent layouts to get access to their child route's data.\n\n``` javascript\nimport { useMatches } from \"react-router-dom\";\n\nfunction SomeComponent() {\n  const matches = useMatches();\n  // [match1, match2, ...]\n}\n```\n\nA `match` has the following shape:\n\n``` javascript\n{\n  // route id\n  id,\n\n  // the portion of the URL the route matched\n  pathname,\n\n  // the data from the loader\n  data,\n\n  // the parsed params from the URL\n  params,\n\n  // the <Route handle> with any app specific data\n  handle,\n};\n```\n\nPairing `<Route handle>` with `useMatches` gets very powerful since you can put whatever you want on a route `handle` and have access to `useMatches` anywhere.\n\n`useMatches` only works with a data router like [`createBrowserRouter`](../routers/create-browser-router), since they know the full route tree up front and can provide all of the current matches. Additionally, `useMatches` will not match down into any descendant route trees since the router isn't aware of the descendant routes.\n\n## Breadcrumbs\n\nThe proverbial use case here is adding breadcrumbs to a parent layout that uses data from the child routes.\n\n``` javascript\n<Route element={<Root />}>\n  <Route\n    path=\"messages\"\n    element={<Messages />}\n    loader={loadMessages}\n    handle={{\n      // you can put whatever you want on a route handle\n      // here we use \"crumb\" and return some elements,\n      // this is what we'll render in the breadcrumbs\n      // for this route\n      crumb: () => <Link to=\"/message\">Messages</Link>,\n    }}\n  >\n    <Route\n      path=\"conversation/:id\"\n      element={<Thread />}\n      loader={loadThread}\n      handle={{\n        // `crumb` is your own abstraction, we decided\n        // to make this one a function so we can pass\n        // the data from the loader to it so that our\n        // breadcrumb is made up of dynamic content\n        crumb: (data) => <span>{data.threadName}</span>,\n      }}\n    />\n  </Route>\n</Route>\n```\n\nNow we can create a `Breadcrumbs` component that takes advantage of our home-grown `crumb` abstraction with `useMatches` and `handle`.\n\n``` javascript\nfunction Breadcrumbs() {\n  let matches = useMatches();\n  let crumbs = matches\n    // first get rid of any matches that don't have handle and crumb\n    .filter((match) => Boolean(match.handle?.crumb))\n    // now map them into an array of elements, passing the loader\n    // data to each one\n    .map((match) => match.handle.crumb(match.data));\n\n  return (\n    <ol>\n      {crumbs.map((crumb, index) => (\n        <li key={index}>{crumb}</li>\n      ))}\n    </ol>\n  );\n}\n```\n\nNow you can render `<Breadcrumbs/>` anywhere you want, probably in the root component.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-matches](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-matches)"
- name: useNavigate
  id: hooks/use-navigate
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  description: "# `useNavigate`\n\nIt's usually better to use [`redirect`](../fetch/redirect) in loaders and actions than this hook\n\nThe `useNavigate` hook returns a function that lets you navigate programmatically, for example in an effect:\n\n``` javascript\nimport { useNavigate } from \"react-router-dom\";\n\nfunction useLogoutTimer() {\n  const userIsInactive = useFakeInactiveUser();\n  const navigate = useNavigate();\n\n  useEffect(() => {\n    if (userIsInactive) {\n      fake.logout();\n      navigate(\"/session-timed-out\");\n    }\n  }, [userIsInactive]);\n}\n```\n\n## Type Declaration\n\n``` javascript\ndeclare function useNavigate(): NavigateFunction;\n\ninterface NavigateFunction {\n  (\n    to: To,\n    options?: {\n      replace?: boolean;\n      state?: any;\n      relative?: RelativeRoutingType;\n    }\n  ): void;\n  (delta: number): void;\n}\n```\n\nThe `navigate` function has two signatures:\n\n- Either pass a `To` value (same type as `<Link to>`) with an optional second `{ replace, state }` arg or\n- Pass the delta you want to go in the history stack. For example, `navigate(-1)` is equivalent to hitting the back button.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-navigate](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-navigate)"
- name: useNavigation
  id: hooks/use-navigation
  summary: This hook tells you everything you need to know about a page navigation to build pending navigation indicators and optimistic UI on data mutations
  description: "# `useNavigation`\n\nThis hook tells you everything you need to know about a page navigation to build pending navigation indicators and optimistic UI on data mutations. Things like:\n\n- Global loading indicators\n- Disabling forms while a mutation is happening\n- Adding busy indicators to submit buttons\n- Optimistically showing a new record while it's being created on the server\n- Optimistically showing the new state of a record while it's being updated\n\n``` javascript\nimport { useNavigation } from \"react-router-dom\";\n\nfunction SomeComponent() {\n  const navigation = useNavigation();\n  navigation.state;\n  navigation.location;\n  navigation.formData;\n  navigation.formAction;\n  navigation.formMethod;\n}\n```\n\n## `navigation.state`\n\n- **idle** - There is no navigation pending.\n- **submitting** - A route action is being called due to a form submission using POST, PUT, PATCH, or DELETE\n- **loading** - The loaders for the next routes are being called to render the next page\n\nNormal navigations and GET form submissions transition through these states:\n\nForm submissions with POST, PUT, PATCH, or DELETE transition through these states:\n\nHere's a simple submit button that changes its text when the navigation state is changing:\n\n``` javascript\nfunction SubmitButton() {\n  const navigation = useNavigation();\n\n  const text =\n    navigation.state === \"submitting\"\n      ? \"Saving...\"\n      : navigation.state === \"loading\"\n      ? \"Saved!\"\n      : \"Go\";\n\n  return <button type=\"submit\">{text}</button>;\n}\n```\n\nWhile `navigation.state` provides the high-level state of the active navigation, you can deduce more granular information by combining it with other `navigation` aspects:\n\n``` javascript\n// Is this just a normal load?\nlet isNormalLoad =\n  navigation.state === \"loading\" &&\n  navigation.formData == null;\n\n// Are we reloading after an action?\nlet isReloading =\n  navigation.state === \"loading\" &&\n  navigation.formData != null &&\n  navigation.formAction === navigation.location.pathname;\n\n// Are we redirecting after an action?\nlet isRedirecting =\n  navigation.state === \"loading\" &&\n  navigation.formData != null &&\n  navigation.formAction !== navigation.location.pathname;\n```\n\n## `navigation.formData`\n\nAny POST, PUT, PATCH, or DELETE navigation that started from a `<Form>` or `useSubmit` will have your form's submission data attached to it. This is primarily useful to build \"Optimistic UI\" with the `submission.formData` [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object.\n\nIn the case of a GET form submission, `formData` will be empty and the data will be reflected in `navigation.location.search`.\n\n## `navigation.location`\n\nThis tells you what the next [location](../utils/location) is going to be.\n\nNote that this link will not appear \"pending\" if a form is being submitted to the URL the link points to, because we only do this for \"loading\" states. The form will contain the pending UI for when the state is \"submitting\", once the action is complete, then the link will go pending.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-navigation](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-navigation)"
- name: useNavigationType
  id: hooks/use-navigation-type
  summary: This hook returns the current type of navigation or how the user came to the current page; either via a pop, push, or replace action on the history stack
  description: "# `useNavigationType`\n\nType declaration\n\n``` javascript\ndeclare function useNavigationType(): NavigationType;\n\ntype NavigationType = \"POP\" | \"PUSH\" | \"REPLACE\";\n```\n\nThis hook returns the current type of navigation or how the user came to the current page; either via a pop, push, or replace action on the history stack.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-navigation-type](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-navigation-type)"
- name: useOutlet
  id: hooks/use-outlet
  summary: Returns the element for the child route at this level of the route hierarchy
  description: "# `useOutlet`\n\nType declaration\n\n``` javascript\ndeclare function useOutlet(): React.ReactElement | null;\n```\n\nReturns the element for the child route at this level of the route hierarchy. This hook is used internally by [`<Outlet>`](../components/outlet) to render child routes.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-outlet](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-outlet)"
- name: useOutletContext
  id: hooks/use-outlet-context
  summary: Often parent routes manage state or other values you want shared with child routes
  description: "# `useOutletContext`\n\nType declaration\n\n``` javascript\ndeclare function useOutletContext<\n  Context = unknown\n>(): Context;\n```\n\nOften parent routes manage state or other values you want shared with child routes. You can create your own [context provider](https://reactjs.org/docs/context.html) if you like, but this is such a common situation that it's built-into `<Outlet />`:\n\n``` javascript\nfunction Parent() {\n  const [count, setCount] = React.useState(0);\n  return <Outlet context={[count, setCount]} />;\n}\n```\n\n``` javascript\nimport { useOutletContext } from \"react-router-dom\";\n\nfunction Child() {\n  const [count, setCount] = useOutletContext();\n  const increment = () => setCount((c) => c + 1);\n  return <button onClick={increment}>{count}</button>;\n}\n```\n\nIf you're using TypeScript, we recommend the parent component provide a custom hook for accessing the context value. This makes it easier for consumers to get nice typings, control consumers, and know who's consuming the context value. Here's a more realistic example:\n\n``` javascript\nimport * as React from \"react\";\nimport type { User } from \"./types\";\nimport { Outlet, useOutletContext } from \"react-router-dom\";\n\ntype ContextType = { user: User | null };\n\nexport default function Dashboard() {\n  const [user, setUser] = React.useState<User | null>(null);\n\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      <Outlet context={{ user }} />\n    </div>\n  );\n}\n\nexport function useUser() {\n  return useOutletContext<ContextType>();\n}\n```\n\n``` javascript\nimport { useUser } from \"../dashboard\";\n\nexport default function DashboardMessages() {\n  const { user } = useUser();\n  return (\n    <div>\n      <h2>Messages</h2>\n      <p>Hello, {user.name}!</p>\n    </div>\n  );\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-outlet-context](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-outlet-context)"
- name: useParams
  id: hooks/use-params
  summary: The useParams hook returns an object of key/value pairs of the dynamic params from the current URL that were matched by the <Route path>. Child routes inherit all params from their parent routes
  description: "# `useParams`\n\nType declaration\n\n``` javascript\ndeclare function useParams<\n  K extends string = string\n>(): Readonly<Params<K>>;\n```\n\nThe `useParams` hook returns an object of key/value pairs of the dynamic params from the current URL that were matched by the `<Route path>`. Child routes inherit all params from their parent routes.\n\n``` javascript\nimport * as React from 'react';\nimport { Routes, Route, useParams } from 'react-router-dom';\n\nfunction ProfilePage() {\n  // Get the userId param from the URL.\n  let { userId } = useParams();\n  // ...\n}\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"users\">\n        <Route path=\":userId\" element={<ProfilePage />} />\n        <Route path=\"me\" element={...} />\n      </Route>\n    </Routes>\n  );\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-params](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-params)"
- name: useResolvedPath
  id: hooks/use-resolved-path
  summary: This hook resolves the pathname of the location in the given to value against the pathname of the current location
  description: "# `useResolvedPath`\n\nType declaration\n\n``` javascript\ndeclare function useResolvedPath(\n  to: To,\n  options?: { relative?: RelativeRoutingType }\n): Path;\n```\n\nThis hook resolves the `pathname` of the location in the given `to` value against the pathname of the current location.\n\nThis is useful when building links from relative values. For example, check out the source to [`<NavLink>`](../components/nav-link) which calls `useResolvedPath` internally to resolve the full pathname of the page being linked to.\n\nSee [resolvePath](../utils/resolve-path) for more information.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-resolved-path](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-resolved-path)"
- name: useRevalidator
  id: hooks/use-revalidator
  summary: This hook allows you to revalidate the data for any reason
  description: "# `useRevalidator`\n\nThis hook allows you to revalidate the data for any reason. React Router automatically revalidates the data after actions are called, but you may want to revalidate for other reasons like when focus returns to the window.\n\n``` javascript\nimport { useRevalidator } from \"react-router-dom\";\n\nfunction WindowFocusRevalidator() {\n  let revalidator = useRevalidator();\n\n  useFakeWindowFocus(() => {\n    revalidator.revalidate();\n  });\n\n  return (\n    <div hidden={revalidator.state === \"idle\"}>\n      Revalidating...\n    </div>\n  );\n}\n```\n\nAgain, React Router already revalidates the data on the page automatically in the vast majority of cases so this should rarely be needed. If you find yourself using this for normal CRUD operations on your data in response to user interactions, you're probably not taking advantage of the other APIs like [`<Form>`](../components/form), [`useSubmit`](use-submit), or [`useFetcher`](use-fetcher) that do this automatically.\n\n## `revalidator.state`\n\nTells you the state the revalidation is in, either `\"idle\"` or `\"loading\"`.\n\nThis is useful for creating loading indicators and spinners to let the user know the app is thinking.\n\n## `revalidator.revalidate()`\n\nThis initiates a revalidation.\n\n``` javascript\nfunction useLivePageData() {\n  let revalidator = useRevalidator();\n  let interval = useInterval(5000);\n\n  useEffect(() => {\n    if (revalidator.state === \"idle\") {\n      revalidator.revalidate();\n    }\n  }, [interval]);\n}\n```\n\n## Notes\n\nWhile you can render multiple occurrences of `useRevalidator` at the same time, underneath it is a singleton. This means when one `revalidator.revalidate()` is called, all instances go into the `\"loading\"` state together (or rather, they all update to report the singleton state).\n\nRace conditions are automatically handled when calling `revalidate()` when a revalidation is already in progress.\n\nIf a navigation happens while a revalidation is in flight, the revalidation will be cancelled and fresh data will be requested from all loaders for the next page.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-revalidator](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-revalidator)"
- name: useRouteError
  id: hooks/use-route-error
  summary: Inside of an errorElement, this hooks returns anything thrown during an action, loader, or rendering
  description: "# `useRouteError`\n\nInside of an [`errorElement`](../route/error-element), this hooks returns anything thrown during an action, loader, or rendering. Note that thrown responses have special treatment, see [`isRouteErrorResponse`](../utils/is-route-error-response) for more information.\n\n``` javascript\nfunction ErrorBoundary() {\n  const error = useRouteError();\n  console.error(error);\n  return <div>{error.message}</div>;\n}\n\n<Route\n  errorElement={<ErrorBoundary />}\n  loader={() => {\n    // unexpected errors in loaders/actions\n    something.that.breaks();\n  }}\n  action={() => {\n    // stuff you throw on purpose in loaders/actions\n    throw new Response(\"Bad Request\", { status: 400 });\n  }}\n  element={\n    // and errors thrown while rendering\n    <div>{breaks.while.rendering}</div>\n  }\n/>;\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-route-error](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-route-error)"
- name: useRouteLoaderData
  id: hooks/use-route-loader-data
  summary: This hook makes the data at any currently rendered route available anywhere in the tree
  description: "# `useRouteLoaderData`\n\nThis hook makes the data at any currently rendered route available anywhere in the tree. This is useful for components deep in the tree needing data from routes much farther up, as well as parent routes needing the data of child routes deeper in the tree.\n\n``` javascript\nimport { useRouteLoaderData } from \"react-router-dom\";\n\nfunction SomeComp() {\n  const user = useRouteLoaderData(\"root\");\n  // ...\n}\n```\n\nReact Router stores data internally with deterministic, auto-generated route ids, but you can supply your own route id to make this hook much easier to work with. Consider a router with a route that defines an id:\n\n``` javascript\ncreateBrowserRouter([\n  {\n    path: \"/\",\n    loader: () => fetchUser(),\n    element: <Root />,\n    id: \"root\",\n    children: [\n      {\n        path: \"jobs/:jobId\",\n        loader: loadJob,\n        element: <JobListing />,\n      },\n    ],\n  },\n]);\n```\n\nNow the user is available anywhere else in the app.\n\n``` javascript\nconst user = useRouteLoaderData(\"root\");\n```\n\nThe only data available is the routes that are currently rendered. If you ask for data from a route that is not currently rendered, the hook will return `undefined`.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-route-loader-data](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-route-loader-data)"
- name: useRoutes
  id: hooks/use-routes
  summary: The useRoutes hook is the functional equivalent of <Routes>, but it uses JavaScript objects instead of <Route> elements to define your routes
  description: "# `useRoutes`\n\nType declaration\n\n``` javascript\ndeclare function useRoutes(\n  routes: RouteObject[],\n  location?: Partial<Location> | string;\n): React.ReactElement | null;\n```\n\nThe `useRoutes` hook is the functional equivalent of [`<Routes>`](../components/routes), but it uses JavaScript objects instead of `<Route>` elements to define your routes. These objects have the same properties as normal [`<Route>` elements](../components/route), but they don't require JSX.\n\nThe return value of `useRoutes` is either a valid React element you can use to render the route tree, or `null` if nothing matched.\n\n``` javascript\nimport * as React from \"react\";\nimport { useRoutes } from \"react-router-dom\";\n\nfunction App() {\n  let element = useRoutes([\n    {\n      path: \"/\",\n      element: <Dashboard />,\n      children: [\n        {\n          path: \"messages\",\n          element: <DashboardMessages />,\n        },\n        { path: \"tasks\", element: <DashboardTasks /> },\n      ],\n    },\n    { path: \"team\", element: <AboutPage /> },\n  ]);\n\n  return element;\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-routes](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-routes)"
- name: useSearchParams
  id: hooks/use-search-params
  summary: This is the web version of useSearchParams
  description: "# `useSearchParams`\n\nThis is the web version of `useSearchParams`. For the React Native version, [go here](use-search-params-rn).\n\nType declaration\n\n``` javascript\ndeclare function useSearchParams(\n  defaultInit?: URLSearchParamsInit\n): [URLSearchParams, SetURLSearchParams];\n\ntype ParamKeyValuePair = [string, string];\n\ntype URLSearchParamsInit =\n  | string\n  | ParamKeyValuePair[]\n  | Record<string, string | string[]>\n  | URLSearchParams;\n\ntype SetURLSearchParams = (\n  nextInit?:\n    | URLSearchParamsInit\n    | ((prev: URLSearchParams) => URLSearchParamsInit),\n  navigateOpts?: : NavigateOptions\n) => void;\n\ninterface NavigateOptions {\n  replace?: boolean;\n  state?: any;\n  preventScrollReset?: boolean;\n}\n```\n\nThe `useSearchParams` hook is used to read and modify the query string in the URL for the current location. Like React's own [`useState` hook](https://reactjs.org/docs/hooks-reference.html#usestate), `useSearchParams` returns an array of two values: the current location's [search params](https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams) and a function that may be used to update them. Just as React's [`useState` hook](https://reactjs.org/docs/hooks-reference.html#usestate), `setSearchParams` also supports [functional updates](https://reactjs.org/docs/hooks-reference.html#functional-updates). Therefore, you may provide a function that takes a `searchParams` and returns an updated version.\n\n``` javascript\nimport * as React from \"react\";\nimport { useSearchParams } from \"react-router-dom\";\n\nfunction App() {\n  let [searchParams, setSearchParams] = useSearchParams();\n\n  function handleSubmit(event) {\n    event.preventDefault();\n    // The serialize function here would be responsible for\n    // creating an object of { key: value } pairs from the\n    // fields in the form that make up the query.\n    let params = serializeFormQuery(event.target);\n    setSearchParams(params);\n  }\n\n  return (\n    <div>\n      <form onSubmit={handleSubmit}>{/* ... */}</form>\n    </div>\n  );\n}\n```\n\nThe `setSearchParams` function works like [`navigate`](use-navigate), but only for the [search portion](https://developer.mozilla.org/en-US/docs/Web/API/Location/search) of the URL. Also note that the second arg to `setSearchParams` is the same type as the second arg to `navigate`.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-search-params](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-search-params)"
- name: useSearchParams (React Native)
  id: hooks/use-search-params-rn
  summary: This is the React Native version of useSearchParams
  description: "# `useSearchParams` (React Native)\n\nThis is the React Native version of `useSearchParams`. For the web version, [go here](use-search-params.md).\n\nType declaration\n\n``` javascript\ndeclare function useSearchParams(\n  defaultInit?: URLSearchParamsInit\n): [URLSearchParams, SetURLSearchParams];\n\ntype ParamKeyValuePair = [string, string];\n\ntype URLSearchParamsInit =\n  | string\n  | ParamKeyValuePair[]\n  | Record<string, string | string[]>\n  | URLSearchParams;\n\ntype SetURLSearchParams = (\n  nextInit?:\n    | URLSearchParamsInit\n    | ((prev: URLSearchParams) => URLSearchParamsInit),\n  navigateOpts?: : NavigateOptions\n) => void;\n\ninterface NavigateOptions {\n  replace?: boolean;\n  state?: any;\n  preventScrollReset?: boolean;\n}\n```\n\nThe `useSearchParams` hook is used to read and modify the query string in the URL for the current location. Like React's own [`useState` hook](https://reactjs.org/docs/hooks-reference.html#usestate), `useSearchParams` returns an array of two values: the current location's [search params](https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams) and a function that may be used to update them. Just as React's [`useState` hook](https://reactjs.org/docs/hooks-reference.html#usestate), `setSearchParams` also supports [functional updates](https://reactjs.org/docs/hooks-reference.html#functional-updates). Therefore, you may provide a function that takes a `searchParams` and returns an updated version.\n\n``` javascript\nimport * as React from \"react\";\nimport { View, SearchForm, TextInput } from \"react-native\";\nimport { useSearchParams } from \"react-router-native\";\n\nfunction App() {\n  let [searchParams, setSearchParams] = useSearchParams();\n  let [query, setQuery] = React.useState(\n    searchParams.get(\"query\")\n  );\n\n  function handleSubmit() {\n    setSearchParams({ query });\n  }\n\n  return (\n    <View>\n      <SearchForm onSubmit={handleSubmit}>\n        <TextInput value={query} onChangeText={setQuery} />\n      </SearchForm>\n    </View>\n  );\n}\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-search-params-rn](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-search-params-rn)"
- name: useSubmit
  id: hooks/use-submit
  summary: The imperative version of <Form> that let's you, the programmer, submit a form instead of the user
  description: "# `useSubmit`\n\nThe imperative version of `<Form>` that let's you, the programmer, submit a form instead of the user. For example, submitting the form every time a value changes inside the form:\n\n``` javascript\nimport { useSubmit, Form } from \"react-router-dom\";\n\nfunction SearchField() {\n  let submit = useSubmit();\n  return (\n    <Form\n      onChange={(event) => {\n        submit(event.currentTarget);\n      }}\n    >\n      <input type=\"text\" name=\"search\" />\n      <button type=\"submit\">Search</button>\n    </Form>\n  );\n}\n```\n\nThis can also be useful if you'd like to automatically sign someone out of your website after a period of inactivity. In this case, we've defined inactivity as the user hasn't navigated to any other pages after 5 minutes.\n\n``` javascript\nimport { useSubmit, useLocation } from \"react-router-dom\";\nimport { useEffect } from \"react\";\n\nfunction AdminPage() {\n  useSessionTimeout();\n  return <div>{/* ... */}</div>;\n}\n\nfunction useSessionTimeout() {\n  const submit = useSubmit();\n  const location = useLocation();\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      submit(null, { method: \"post\", action: \"/logout\" });\n    }, 5 * 60_000);\n\n    return () => clearTimeout(timer);\n  }, [submit, location]);\n}\n```\n\n## Submit target\n\nThe first argument to submit accepts many different values.\n\nYou can submit any form or form input element:\n\n``` javascript\n// input element events\n<input onChange={(event) => submit(event.currentTarget)} />;\n\n// React refs\nlet ref = useRef();\n<button ref={ref} />;\nsubmit(ref.current);\n```\n\nYou can submit `FormData`:\n\n``` javascript\nlet formData = new FormData();\nformData.append(\"cheese\", \"gouda\");\nsubmit(formData);\n```\n\n## Submit options\n\nThe second argument is a set of options that map directly to form submission attributes:\n\n``` javascript\nsubmit(null, {\n  action: \"/logout\",\n  method: \"post\",\n});\n\n// same as\n<Form action=\"/logout\" method=\"post\" />;\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-submit](https://reactrouterdotcom.fly.dev/docs/en/v6/hooks/use-submit)"
- name: Using defer
  id: guides/deferred#using-defer
  summary: Start by adding <Await /> for your slow data requests where you'd rather render a fallback UI
  belongs_to: Deferred Data Guide
  description: |-
    ### Using `defer`

    Start by adding `<Await />` for your slow data requests where you'd rather render a fallback UI. Let's do that for our example above:

    ``` javascript
    import { defer, useLoaderData } from "react-router-dom";
    import { getPackageLocation } from "./api/packages";

    async function loader({ params }) {
      const packageLocationPromise = getPackageLocation(
        params.packageId
      );

      return defer({
        packageLocation: packageLocationPromise,
      });
    }

    export default function PackageRoute() {
      const data = useLoaderData();

      return (
        <main>
          <h1>Let's locate your package</h1>
          <React.Suspense
            fallback={<p>Loading package location...</p>}
          >
            <Await
              resolve={data.packageLocation}
              errorElement={
                <p>Error loading package location!</p>
              }
            >
              {(packageLocation) => (
                <p>
                  Your package is at {packageLocation.latitude}{" "}
                  lat and {packageLocation.longitude} long.
                </p>
              )}
            </Await>
          </React.Suspense>
        </main>
      );
    }
    ```

    Alternatively, you can use the \`useAsyncValue\` hook:

    If you're not jazzed about bringing back render props, you can use a hook, but you'll have to break things out into another component:

    ``` javascript
    export default function PackageRoute() {
      const data = useLoaderData();

      return (
        <main>
          <h1>Let's locate your package</h1>
          <React.Suspense
            fallback={<p>Loading package location...</p>}
          >
            <Await
              resolve={data.packageLocation}
              errorElement={
                <p>Error loading package location!</p>
              }
            >
              <PackageLocation />
            </Await>
          </React.Suspense>
        </main>
      );
    }

    function PackageLocation() {
      const packageLocation = useAsyncValue();
      return (
        <p>
          Your package is at {packageLocation.latitude} lat and{" "}
          {packageLocation.longitude} long.
        </p>
      );
    }
    ```
- name: Using v6.4 Data APIs
  id: routers/picking-a-router#using-v64-data-apis
  summary: We recommend updating your app to use one of the new routers from 6.4
  belongs_to: Picking a Router
  description: |-
    ## Using v6.4 Data APIs

    In v6.4, new routers were introduced that support the new data APIs:

    - [`createBrowserRouter`](create-browser-router)
    - [`createMemoryRouter`](create-memory-router)
    - [`createHashRouter`](create-hash-router)

    The following routers do not support the data APIs:

    - [`<BrowserRouter>`](../router-components/browser-router)
    - [`<MemoryRouter>`](memory-router)
    - [`<HashRouter>`](../router-components/hash-router)
    - [`<NativeRouter>`](native-router)
    - [`<StaticRouter>`](static-router)

    We recommend updating your app to use one of the new routers from 6.4. The data APIs are currently not supported in React Native, but should be eventually.

    The easiest way to quickly update to a v6.4 is to get the help from [`createRoutesFromElements`](../utils/create-routes-from-elements) so you don't need to convert your `<Route>` elements to route objects.

    ``` javascript
    import {
      createBrowserRouter,
      RouterProvider,
    } from "react-router-dom";

    const router = createBrowserRouter(
      createRoutesFromElements(
        <Route path="/" element={<Root />}>
          <Route path="dashboard" element={<Dashboard />} />
          {/* ... etc. */}
        </Route>
      )
    );

    ReactDOM.createRoot(document.getElementById("root")).render(
      <React.StrictMode>
        <RouterProvider router={router} />
      </React.StrictMode>
    );
    ```
- name: Web Projects
  id: routers/picking-a-router#web-projects
  summary: We recommend all web projects use createBrowserRouter
  belongs_to: Picking a Router
  description: |-
    ## Web Projects

    We recommend all web projects use [`createBrowserRouter`](create-browser-router).

    It uses the full URL instead of the hash urls (`#this/stuff`) common in web apps before `window.pushState` was standardized. Full URLs are better for SEO, better for server rendering, and are just more compatible with the rest of the web platform.

    If you're hosting your app on a static file server, you'll need to configure it to send all requests to your `index.html` to avoid getting 404s.

    If for some reason you can't use the full URL, [`createHashRouter`](create-hash-router) is the next best thing.

    If you're not interested in the data APIs, you can continue to use [`<BrowserRouter>`](../router-components/browser-router) or, if you can't use full URLs, [`<HashRouter>`](../router-components/hash-router).
- name: Web Standard APIs
  id: start/overview#web-standard-apis
  summary: React Router is built on web standard APIs
  belongs_to: Feature Overview
  description: |-
    ## Web Standard APIs

    React Router is built on web standard APIs. [Loaders](../route/loader) and [actions](../route/action) receive standard Web Fetch API [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) objects and can return [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) objects, too. Cancellation is done with [Abort Signals](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal), search params are handled with [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams), and data mutations are handled with [HTML Forms](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form).

    When you get better at React Router, you get better at the web platform.
- name: What Happened to Regexp Routes Paths?
  id: start/faq#what-happened-to-regexp-routes-paths
  summary: Regular expression paths in routes raised a lot of questions for v6's ranked route matching
  belongs_to: FAQs
  description: "## What Happened to Regexp Routes Paths?\n\nRegexp route paths were removed for two reasons:\n\n1.  Regular expression paths in routes raised a lot of questions for v6's ranked route matching. How do you rank a regex?\n\n2.  We were able to shed an entire dependency (path-to-regexp) and cut the package weight sent to your user's browser significantly. If it were added back, it would represent 1/3 of React Router's page weight!\n\nAfter looking at a lot of use cases, we found we can still meet them without direct regexp path support, so we made the tradeoff to significantly decrease the bundle size and avoid the open questions around ranking regexp routes.\n\nThe majority of regexp routes were only concerned about one URL segment at a time and doing one of two things:\n\n1.  Matching multiple static values\n2.  Validating the param in some way (is a number, not a number, etc.)\n\n**Matching generally static values**\n\nA very common route we've seen is a regex matching multiple language codes:\n\n``` javascript\nfunction App() {\n  return (\n    <Switch>\n      <Route path={/(en|es|fr)/} component={Lang} />\n    </Switch>\n  );\n}\n\nfunction Lang({ params }) {\n  let lang = params[0];\n  let translations = I81n[lang];\n  // ...\n}\n```\n\nThese are all actually just static paths, so in v6 you can make three routes and pass the code directly to the component. If you've got a lot of them, make an array and map it into routes to avoid the repetition.\n\n``` javascript\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"en\" element={<Lang lang=\"en\" />} />\n      <Route path=\"es\" element={<Lang lang=\"es\" />} />\n      <Route path=\"fr\" element={<Lang lang=\"fr\" />} />\n    </Routes>\n  );\n}\n\nfunction Lang({ lang }) {\n  let translations = I81n[lang];\n  // ...\n}\n```\n\n**Doing some sort of param validation**\n\nAnother common case was ensuring that parameters were an integer.\n\n``` javascript\nfunction App() {\n  return (\n    <Switch>\n      <Route path={/users\\/(\\d+)/} component={User} />\n    </Switch>\n  );\n}\n\nfunction User({ params }) {\n  let id = params[0];\n  // ...\n}\n```\n\nIn this case you have to do a bit of work yourself with the regex inside the matching component:\n\n``` javascript\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/users/:id\" element={<ValidateUser />} />\n      <Route path=\"/users/*\" element={<NotFound />} />\n    </Routes>\n  );\n}\n\nfunction ValidateUser() {\n  let params = useParams();\n  let userId = params.id.match(/\\d+/);\n  if (!userId) {\n    return <NotFound />;\n  }\n  return <User id={params.userId} />;\n}\n\nfunction User(props) {\n  let id = props.id;\n  // ...\n}\n```\n\nIn v5 if the regex didn't match then `<Switch>` would keep trying to match the next routes:\n\n``` javascript\nfunction App() {\n  return (\n    <Switch>\n      <Route path={/users\\/(\\d+)/} component={User} />\n      <Route path=\"/users/new\" exact component={NewUser} />\n      <Route\n        path=\"/users/inactive\"\n        exact\n        component={InactiveUsers}\n      />\n      <Route path=\"/users/*\" component={NotFound} />\n    </Switch>\n  );\n}\n```\n\nLooking at this example you might be concerned that in the v6 version your other routes won't get rendered at their URLs because the `:userId` route might match first. But, thanks to route ranking, that is not the case. The \"new\" and \"inactive\" routes will rank higher and therefore render at their respective URLs:\n\n``` javascript\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/users/:id\" element={<ValidateUser />} />\n      <Route path=\"/users/new\" element={<NewUser />} />\n      <Route\n        path=\"/users/inactive\"\n        element={<InactiveUsers />}\n      />\n    </Routes>\n  );\n}\n```\n\nIn fact, the v5 version has all sorts of problems if your routes aren't ordered *just right*. V6 completely eliminates this problem.\n\n**Remix Users**\n\nIf you're using [Remix](https://remix.run), you can send proper 40x responses to the browser by moving this work into your loader. This also decreases the size of the browser bundles sent to the user because loaders only run on the server.\n\n``` javascript\nimport { useLoaderData } from \"remix\";\n\nexport async function loader({ params }) {\n  if (!params.id.match(/\\d+/)) {\n    throw new Response(\"\", { status: 400 });\n  }\n\n  let user = await fakeDb.user.find({\n    where: { id: params.id },\n  });\n  if (!user) {\n    throw new Response(\"\", { status: 404 });\n  }\n\n  return user;\n}\n\nfunction User() {\n  let user = useLoaderData();\n  // ...\n}\n```\n\nInstead of rending your component, remix will render the nearest [catch boundary](https://remix.run/docs/en/v1/api/conventions#catchboundary) instead.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/start/faq](https://reactrouterdotcom.fly.dev/docs/en/v6/start/faq)"
- name: What happened to withRouter? I need it!
  id: start/faq#what-happened-to-withrouter-i-need-it
  summary: This question usually stems from the fact that you're using React class components, which don't support hooks
  belongs_to: FAQs
  description: |-
    ## What happened to withRouter? I need it!

    This question usually stems from the fact that you're using React class components, which don't support hooks. In React Router v6, we fully embraced hooks and use them to share all the router's internal state. But that doesn't mean you can't use the router. Assuming you can actually use hooks (you're on React 16.8+), you just need a wrapper.

    ``` javascript
    import {
      useLocation,
      useNavigate,
      useParams,
    } from "react-router-dom";

    function withRouter(Component) {
      function ComponentWithRouterProp(props) {
        let location = useLocation();
        let navigate = useNavigate();
        let params = useParams();
        return (
          <Component
            {...props}
            router={{ location, navigate, params }}
          />
        );
      }

      return ComponentWithRouterProp;
    }
    ```
- name: When does the <Suspense/> fallback render?
  id: guides/deferred#when-does-the-suspense-fallback-render
  summary: The <Await /> component will only throw the promise up the <Suspense> boundary on the initial render of the <Await /> component with an unsettled promise
  belongs_to: Deferred Data Guide
  description: "### When does the `<Suspense/>` fallback render?\n\nThe `<Await />` component will only throw the promise up the `<Suspense>` boundary on the initial render of the `<Await />` component with an unsettled promise. It will not re-render the fallback if props change. Effectively, this means that you *will not* get a fallback rendered when a user submits a form and loader data is revalidated. You *will* get a fallback rendered when the user navigates to the same route with different params (in the context of our above example, if the user selects from a list of packages on the left to find their location on the right).\n\nThis may feel counter-intuitive at first, but stay with us, we really thought this through and it's important that it works this way. Let's imagine a world without the deferred API. For those scenarios you're probably going to want to implement Optimistic UI for form submissions/revalidation.\n\nWhen you decide you'd like to try the trade-offs of `defer`, we don't want you to have to change or remove those optimizations because we want you to be able to easily switch between deferring some data and not deferring it. So, we ensure that your existing optimistic states work the same way. If we didn't do this, then you could experience what we call \"Popcorn UI\" where submissions of data trigger the fallback loading state instead of the optimistic UI you'd worked hard on.\n\nSo just keep this in mind: **Deferred is 100% only about the initial load of a route and it's params.**\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/guides/deferred](https://reactrouterdotcom.fly.dev/docs/en/v6/guides/deferred)"
- name: Why does <Route> have an element prop instead of render or component?
  id: start/faq#why-does-route-have-an-element-prop-instead-of-render-or-component
  summary: For starters, we see React itself taking the lead here with the <Suspense fallback={<Spinner />}> API
  belongs_to: FAQs
  description: |-
    ## Why does `<Route>` have an `element` prop instead of `render` or `component`?

    In React Router v6 we switched from using v5's `<Route component>` and `<Route render>` APIs to `<Route element>`. Why is that?

    For starters, we see React itself taking the lead here with the `<Suspense fallback={<Spinner />}>` API. The `fallback` prop takes a React **element**, not a **component**. This lets you easily pass whatever props you want to your `<Spinner>` from the component that renders it.

    Using elements instead of components means we don't have to provide a `passProps`-style API, so you can get the props you need to your elements. For example, in a component-based API there is no good way to pass props to the `<Profile>` element that is rendered when `<Route path=":userId" component={Profile} />` matches. Most React libraries who take this approach end up with either an API like `<Route component={Profile} passProps={{ animate: true }} />` or use a render prop or higher-order component.

    Also, `Route`'s rendering API in v5 was rather large. As we worked on v4/5, the conversation went something like this:

    ``` javascript
    // Ah, this is nice and simple!
    <Route path=":userId" component={Profile} />

    // But wait, how do I pass custom props to the <Profile> element??
    // Hmm, maybe we can use a render prop in those situations?
    <Route
      path=":userId"
      render={routeProps => (
        <Profile routeProps={routeProps} animate={true} />
      )}
    />

    // Ok, now we have two ways to render something with a route. :/

    // But wait, what if we want to render something when a route
    // *doesn't* match the URL, like a Not Found page? Maybe we
    // can use another render prop with slightly different semantics?
    <Route
      path=":userId"
      children={({ match }) => (
        match ? (
          <Profile match={match} animate={true} />
        ) : (
          <NotFound />
        )
      )}
    />

    // What if I want to get access to the route match, or I need
    // to redirect deeper in the tree?
    function DeepComponent(routeStuff) {
      // got routeStuff, phew!
    }
    export default withRouter(DeepComponent);

    // Well hey, now at least we've covered all our use cases!
    // ... *facepalm*
    ```

    At least part of the reason for this API sprawl was that React did not provide any way for us to get the information from the `<Route>` to your route element, so we had to invent clever ways to get both the route data **and** your own custom props through to your elements: `component`, render props, `passProps` higher-order-components ... until **hooks** came along!

    Now, the conversation above goes like this:

    ``` javascript
    // Ah, nice and simple API. And it's just like the <Suspense> API!
    // Nothing more to learn here.
    <Route path=":userId" element={<Profile />} />

    // But wait, how do I pass custom props to the <Profile>
    // element? Oh ya, it's just an element. Easy.
    <Route path=":userId" element={<Profile animate={true} />} />

    // Ok, but how do I access the router's data, like the URL params
    // or the current location?
    function Profile({ animate }) {
      let params = useParams();
      let location = useLocation();
    }

    // But what about components deep in the tree?
    function DeepComponent() {
      // oh right, same as anywhere else
      let navigate = useNavigate();
    }

    // Aaaaaaaaand we're done here.
    ```

    Another important reason for using the `element` prop in v6 is that `<Route children>` is reserved for nesting routes. You can read more about this in [the guide about getting started](overview#nested-routes) with v6.
- name: Why not defer everything by default?
  id: guides/deferred#why-not-defer-everything-by-default
  summary: The React Router defer API is another lever React Router offers to give you a nice way to choose between trade-offs
  belongs_to: Deferred Data Guide
  description: |-
    ### Why not defer everything by default?

    The React Router defer API is another lever React Router offers to give you a nice way to choose between trade-offs. Do you want the page to render more quickly? Defer stuff. Do you want a lower CLS (Content Layout Shift)? Don't defer stuff. You want a faster render, but also want a lower CLS? Defer just the slow and unimportant stuff.

    It's all trade-offs, and what's neat about the API design is that it's well suited for you to do easy experimentation to see which trade-offs lead to better results for your real-world key indicators.
- name: window
  id: routers/create-browser-router#window
  summary: Useful for environments like browser devtool plugins or testing to use a different window than the global window
  belongs_to: createBrowserRouter
  description: "## `window`\n\nUseful for environments like browser devtool plugins or testing to use a different window than the global `window`.\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/routers/create-browser-router](https://reactrouterdotcom.fly.dev/docs/en/v6/routers/create-browser-router)"
- name: Working With FormData
  id: guides/form-data
  summary: © React Training 2015-2019 © Remix Software 2020-2022 Licensed under the MIT License (MIT)
  description: "# Working With FormData\n\nTODO: This document is a stub\n\nA common trick is to turn the entire formData into an object with [`Object.fromEntries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries):\n\n``` javascript\nconst data = Object.fromEntries(await request.formData());\ndata.songTitle;\ndata.lyrics;\n```\n\n© React Training 2015-2019  \n© Remix Software 2020-2022  \nLicensed under the MIT License (MIT).  \n[https://reactrouterdotcom.fly.dev/docs/en/v6/guides/form-data](https://reactrouterdotcom.fly.dev/docs/en/v6/guides/form-data)"
