---
name: Vuex
slug: vuex~4
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: '4'
copyright: |-
  © 2015–present Evan You
  Licensed under the MIT License.
  https://next.vuex.vuejs.org/index.html
homepage: https://vuex.vuejs.org

---
- name: Actions
  id: guide/actions
  summary: Action handlers receive a context object which exposes the same set of methods/properties on the store instance, so you can call context.commit to commit a mutation, or access the state and getters via context.state and context.getters
  description: "# Actions\n\n[Try this lesson on Scrimba](https://scrimba.com/p/pnyzgAP/c6ggR3cG)\n\nActions are similar to mutations, the differences being that:\n\n- Instead of mutating the state, actions commit mutations.\n- Actions can contain arbitrary asynchronous operations.\n\nLet's register a simple action:\n\n    const store = createStore({\n      state: {\n        count: 0\n      },\n      mutations: {\n        increment (state) {\n          state.count++\n        }\n      },\n      actions: {\n        increment (context) {\n          context.commit('increment')\n        }\n      }\n    })\n\nAction handlers receive a context object which exposes the same set of methods/properties on the store instance, so you can call `context.commit` to commit a mutation, or access the state and getters via `context.state` and `context.getters`. We can even call other actions with `context.dispatch`. We will see why this context object is not the store instance itself when we introduce [Modules](modules) later.\n\nIn practice, we often use ES2015 [argument destructuring](https://github.com/lukehoban/es6features#destructuring) to simplify the code a bit (especially when we need to call `commit` multiple times):\n\n    actions: {\n      increment ({ commit }) {\n        commit('increment')\n      }\n    }\n\n## Dispatching Actions\n\nActions are triggered with the `store.dispatch` method:\n\n    store.dispatch('increment')\n\nThis may look silly at first sight: if we want to increment the count, why don't we just call `store.commit('increment')` directly? Remember that **mutations have to be synchronous**. Actions don't. We can perform **asynchronous** operations inside an action:\n\n    actions: {\n      incrementAsync ({ commit }) {\n        setTimeout(() => {\n          commit('increment')\n        }, 1000)\n      }\n    }\n\nActions support the same payload format and object-style dispatch:\n\n    // dispatch with a payload\n    store.dispatch('incrementAsync', {\n      amount: 10\n    })\n\n    // dispatch with an object\n    store.dispatch({\n      type: 'incrementAsync',\n      amount: 10\n    })\n\nA more practical example of real-world actions would be an action to checkout a shopping cart, which involves **calling an async API** and **committing multiple mutations**:\n\n    actions: {\n      checkout ({ commit, state }, products) {\n        // save the items currently in the cart\n        const savedCartItems = [...state.cart.added]\n        // send out checkout request, and optimistically\n        // clear the cart\n        commit(types.CHECKOUT_REQUEST)\n        // the shop API accepts a success callback and a failure callback\n        shop.buyProducts(\n          products,\n          // handle success\n          () => commit(types.CHECKOUT_SUCCESS),\n          // handle failure\n          () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n        )\n      }\n    }\n\nNote we are performing a flow of asynchronous operations, and recording the side effects (state mutations) of the action by committing them.\n\n## Dispatching Actions in Components\n\nYou can dispatch actions in components with `this.$store.dispatch('xxx')`, or use the `mapActions` helper which maps component methods to `store.dispatch` calls (requires root `store` injection):\n\n    import { mapActions } from 'vuex'\n\n    export default {\n      // ...\n      methods: {\n        ...mapActions([\n          'increment', // map `this.increment()` to `this.$store.dispatch('increment')`\n\n          // `mapActions` also supports payloads:\n          'incrementBy' // map `this.incrementBy(amount)` to `this.$store.dispatch('incrementBy', amount)`\n        ]),\n        ...mapActions({\n          add: 'increment' // map `this.add()` to `this.$store.dispatch('increment')`\n        })\n      }\n    }\n\n## Composing Actions\n\nActions are often asynchronous, so how do we know when an action is done? And more importantly, how can we compose multiple actions together to handle more complex async flows?\n\nThe first thing to know is that `store.dispatch` can handle Promise returned by the triggered action handler and it also returns Promise:\n\n    actions: {\n      actionA ({ commit }) {\n        return new Promise((resolve, reject) => {\n          setTimeout(() => {\n            commit('someMutation')\n            resolve()\n          }, 1000)\n        })\n      }\n    }\n\nNow you can do:\n\n    store.dispatch('actionA').then(() => {\n      // ...\n    })\n\nAnd also in another action:\n\n    actions: {\n      // ...\n      actionB ({ dispatch, commit }) {\n        return dispatch('actionA').then(() => {\n          commit('someOtherMutation')\n        })\n      }\n    }\n\nFinally, if we make use of [async / await](https://tc39.github.io/ecmascript-asyncawait/), we can compose our actions like this:\n\n    // assuming `getData()` and `getOtherData()` return Promises\n\n    actions: {\n      async actionA ({ commit }) {\n        commit('gotData', await getData())\n      },\n      async actionB ({ dispatch, commit }) {\n        await dispatch('actionA') // wait for `actionA` to finish\n        commit('gotOtherData', await getOtherData())\n      }\n    }\n\n> It's possible for a `store.dispatch` to trigger multiple action handlers in different modules. In such a case the returned value will be a Promise that resolves when all triggered handlers have been resolved.\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/actions.md)\n\nLast Updated:\n\n[Mutations](mutations)\n\n[Modules](modules)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/actions.html](https://next.vuex.vuejs.org/guide/actions.html)"
- name: actions
  id: api/index#actions
  summary: Register actions on the store
  belongs_to: API Reference
  description: "### actions\n\n- type: `{ [type: string]: Function }`\n\n  Register actions on the store. The handler function receives a `context` object that exposes the following properties:\n\n                        {\n        state,      // same as `store.state`, or local state if in modules\n        rootState,  // same as `store.state`, only in modules\n        commit,     // same as `store.commit`\n        dispatch,   // same as `store.dispatch`\n        getters,    // same as `store.getters`, or local getters if in modules\n        rootGetters // same as `store.getters`, only in modules\n      }\n\n                      \n\n  And also receives a second `payload` argument if there is one.\n\n  [Details](../guide/actions)\n\n&nbsp;"
- name: API Reference
  id: api/index
  summary: Creates a new store
  description: "# API Reference\n\n## Store\n\n### createStore\n\n- `createStore<S>(options: StoreOptions<S>): Store<S>`\n\n  Creates a new store.\n\n      import { createStore } from 'vuex'\n\n      const store = createStore({ ...options })\n\n## Store Constructor Options\n\n### state\n\n- type: `Object | Function`\n\n  The root state object for the Vuex store. [Details](../guide/state)\n\n  If you pass a function that returns an object, the returned object is used as the root state. This is useful when you want to reuse the state object especially for module reuse. [Details](../guide/modules#module-reuse)\n\n### mutations\n\n- type: `{ [type: string]: Function }`\n\n  Register mutations on the store. The handler function always receives `state` as the first argument (will be module local state if defined in a module), and receives a second `payload` argument if there is one.\n\n  [Details](../guide/mutations)\n\n### actions\n\n- type: `{ [type: string]: Function }`\n\n  Register actions on the store. The handler function receives a `context` object that exposes the following properties:\n\n      {\n        state,      // same as `store.state`, or local state if in modules\n        rootState,  // same as `store.state`, only in modules\n        commit,     // same as `store.commit`\n        dispatch,   // same as `store.dispatch`\n        getters,    // same as `store.getters`, or local getters if in modules\n        rootGetters // same as `store.getters`, only in modules\n      }\n\n  And also receives a second `payload` argument if there is one.\n\n  [Details](../guide/actions)\n\n### getters\n\n- type: `{ [key: string]: Function }`\n\n  Register getters on the store. The getter function receives the following arguments:\n\n      state,     // will be module local state if defined in a module.\n      getters    // same as store.getters\n\n  Specific when defined in a module\n\n      state,       // will be module local state if defined in a module.\n      getters,     // module local getters of the current module\n      rootState,   // global state\n      rootGetters  // all getters\n\n  Registered getters are exposed on `store.getters`.\n\n  [Details](../guide/getters)\n\n### modules\n\n- type: `Object`\n\n  An object containing sub modules to be merged into the store, in the shape of:\n\n      {\n        key: {\n          state,\n          namespaced?,\n          mutations?,\n          actions?,\n          getters?,\n          modules?\n        },\n        ...\n      }\n\n  Each module can contain `state` and `mutations` similar to the root options. A module's state will be attached to the store's root state using the module's key. A module's mutations and getters will only receives the module's local state as the first argument instead of the root state, and module actions' `context.state` will also point to the local state.\n\n  [Details](../guide/modules)\n\n### plugins\n\n- type: `Array<Function>`\n\n  An array of plugin functions to be applied to the store. The plugin simply receives the store as the only argument and can either listen to mutations (for outbound data persistence, logging, or debugging) or dispatch mutations (for inbound data e.g. websockets or observables).\n\n  [Details](../guide/plugins)\n\n### strict\n\n- type: `boolean`\n\n- default: `false`\n\n  Force the Vuex store into strict mode. In strict mode any mutations to Vuex state outside of mutation handlers will throw an Error.\n\n  [Details](../guide/strict)\n\n### devtools\n\n- type: `boolean`\n\n  Turn the devtools on or off for a particular Vuex instance. For instance, passing `false` tells the Vuex store to not subscribe to devtools plugin. Useful when you have multiple stores on a single page.\n\n      {\n        devtools: false\n      }\n\n## Store Instance Properties\n\n### state\n\n- type: `Object`\n\n  The root state. Read only.\n\n### getters\n\n- type: `Object`\n\n  Exposes registered getters. Read only.\n\n## Store Instance Methods\n\n### commit\n\n- `commit(type: string, payload?: any, options?: Object)`\n- `commit(mutation: Object, options?: Object)`\n\nCommit a mutation. `options` can have `root: true` that allows to commit root mutations in [namespaced modules](../guide/modules#namespacing). [Details](../guide/mutations)\n\n### dispatch\n\n- `dispatch(type: string, payload?: any, options?: Object): Promise<any>`\n- `dispatch(action: Object, options?: Object): Promise<any>`\n\nDispatch an action. `options` can have `root: true` that allows to dispatch root actions in [namespaced modules](../guide/modules#namespacing). Returns a Promise that resolves all triggered action handlers. [Details](../guide/actions)\n\n### replaceState\n\n- `replaceState(state: Object)`\n\nReplace the store's root state. Use this only for state hydration / time-travel purposes.\n\n### watch\n\n- `watch(fn: Function, callback: Function, options?: Object): Function`\n\nReactively watch `fn`'s return value, and call the callback when the value changes. `fn` receives the store's state as the first argument, and getters as the second argument. Accepts an optional options object that takes the same options as [Vue's `vm.$watch` method](https://vuejs.org/v2/api/#vm-watch).\n\nTo stop watching, call the returned unwatch function.\n\n### subscribe\n\n- `subscribe(handler: Function, options?: Object): Function`\n\nSubscribe to store mutations. The `handler` is called after every mutation and receives the mutation descriptor and post-mutation state as arguments.\n\n    const unsubscribe = store.subscribe((mutation, state) => {\n      console.log(mutation.type)\n      console.log(mutation.payload)\n    })\n\n    // you may call unsubscribe to stop the subscription\n    unsubscribe()\n\nBy default, new handler is added to the end of the chain, so it will be executed after other handlers that were added before. This can be overridden by adding `prepend: true` to `options`, which will add the handler to the beginning of the chain.\n\n    store.subscribe(handler, { prepend: true })\n\nThe `subscribe` method will return an `unsubscribe` function, which should be called when the subscription is no longer needed. For example, you might subscribe to a Vuex Module and unsubscribe when you unregister the module. Or you might call `subscribe` from inside a Vue Component and then destroy the component later. In these cases, you should remember to unsubscribe the subscription manually.\n\nMost commonly used in plugins. [Details](../guide/plugins)\n\n### subscribeAction\n\n- `subscribeAction(handler: Function, options?: Object): Function`\n\nSubscribe to store actions. The `handler` is called for every dispatched action and receives the action descriptor and current store state as arguments. The `subscribe` method will return an `unsubscribe` function, which should be called when the subscription is no longer needed. For example, when unregistering a Vuex module or before destroying a Vue component.\n\n    const unsubscribe = store.subscribeAction((action, state) => {\n      console.log(action.type)\n      console.log(action.payload)\n    })\n\n    // you may call unsubscribe to stop the subscription\n    unsubscribe()\n\nBy default, new handler is added to the end of the chain, so it will be executed after other handlers that were added before. This can be overridden by adding `prepend: true` to `options`, which will add the handler to the beginning of the chain.\n\n    store.subscribeAction(handler, { prepend: true })\n\nThe `subscribeAction` method will return an `unsubscribe` function, which should be called when the subscription is no longer needed. For example, you might subscribe to a Vuex Module and unsubscribe when you unregister the module. Or you might call `subscribeAction` from inside a Vue Component and then destroy the component later. In these cases, you should remember to unsubscribe the subscription manually.\n\n`subscribeAction` can also specify whether the subscribe handler should be called *before* or *after* an action dispatch (the default behavior is *before*):\n\n    store.subscribeAction({\n      before: (action, state) => {\n        console.log(`before action ${action.type}`)\n      },\n      after: (action, state) => {\n        console.log(`after action ${action.type}`)\n      }\n    })\n\n`subscribeAction` can also specify an `error` handler to catch an error thrown when an action is dispatched. The function will receive an `error` object as the third argument.\n\n    store.subscribeAction({\n      error: (action, state, error) => {\n        console.log(`error action ${action.type}`)\n        console.error(error)\n      }\n    })\n\nThe `subscribeAction` method is most commonly used in plugins. [Details](../guide/plugins)\n\n### registerModule\n\n- `registerModule(path: string | Array<string>, module: Module, options?: Object)`\n\nRegister a dynamic module. [Details](../guide/modules#dynamic-module-registration)\n\n`options` can have `preserveState: true` that allows to preserve the previous state. Useful with Server Side Rendering.\n\n### unregisterModule\n\n- `unregisterModule(path: string | Array<string>)`\n\nUnregister a dynamic module. [Details](../guide/modules#dynamic-module-registration)\n\n### hasModule\n\n- `hasModule(path: string | Array<string>): boolean`\n\n  Check if the module with the given name is already registered. [Details](../guide/modules#dynamic-module-registration)\n\n### hotUpdate\n\n- `hotUpdate(newOptions: Object)`\n\nHot swap new actions and mutations. [Details](../guide/hot-reload)\n\n## Component Binding Helpers\n\n### mapState\n\n- `mapState(namespace?: string, map: Array<string> | Object<string | function>): Object`\n\nCreate component computed options that return the sub tree of the Vuex store. [Details](../guide/state#the-mapstate-helper)\n\nThe first argument can optionally be a namespace string. [Details](../guide/modules#binding-helpers-with-namespace)\n\nThe second object argument's members can be a function. `function(state: any)`\n\n### mapGetters\n\n- `mapGetters(namespace?: string, map: Array<string> | Object<string>): Object`\n\nCreate component computed options that return the evaluated value of a getter. [Details](../guide/getters#the-mapgetters-helper)\n\nThe first argument can optionally be a namespace string. [Details](../guide/modules#binding-helpers-with-namespace)\n\n### mapActions\n\n- `mapActions(namespace?: string, map: Array<string> | Object<string | function>): Object`\n\nCreate component methods options that dispatch an action. [Details](../guide/actions#dispatching-actions-in-components)\n\nThe first argument can optionally be a namespace string. [Details](../guide/modules#binding-helpers-with-namespace)\n\nThe second object argument's members can be a function. `function(dispatch: function, ...args: any[])`\n\n### mapMutations\n\n- `mapMutations(namespace?: string, map: Array<string> | Object<string | function>): Object`\n\nCreate component methods options that commit a mutation. [Details](../guide/mutations#committing-mutations-in-components)\n\nThe first argument can optionally be a namespace string. [Details](../guide/modules#binding-helpers-with-namespace)\n\nThe second object argument's members can be a function. `function(commit: function, ...args: any[])`\n\n### createNamespacedHelpers\n\n- `createNamespacedHelpers(namespace: string): Object`\n\nCreate namespaced component binding helpers. The returned object contains `mapState`, `mapGetters`, `mapActions` and `mapMutations` that are bound with the given namespace. [Details](../guide/modules#binding-helpers-with-namespace)\n\n## Composable Functions\n\n### useStore\n\n- `useStore<S = any>(injectKey?: InjectionKey<Store<S>> | string): Store<S>;`\n\n  Fetches the injected store when called inside the `setup` hook. When using the Composition API, you can retrieve the store by calling this method.\n\n      import { useStore } from 'vuex'\n\n      export default {\n        setup () {\n          const store = useStore()\n        }\n      }\n\n  TypeScript users can use an injection key to retrieve a typed store. In order for this to work, you must define the injection key and pass it along with the store when installing the store instance to the Vue app.\n\n  First, declare the injection key using Vue's `InjectionKey` interface.\n\n      // store.ts\n      import { InjectionKey } from 'vue'\n      import { createStore, Store } from 'vuex'\n\n      export interface State {\n        count: number\n      }\n\n      export const key: InjectionKey<Store<State>> = Symbol()\n\n      export const store = createStore<State>({\n        state: {\n          count: 0\n        }\n      })\n\n  Then, pass the defined key as the second argument for the `app.use` method.\n\n      // main.ts\n      import { createApp } from 'vue'\n      import { store, key } from './store'\n\n      const app = createApp({ ... })\n\n      app.use(store, key)\n\n      app.mount('#app')\n\n  Finally, you can pass the key to the `useStore` method to retrieve the typed store instance.\n\n      // in a vue component\n      import { useStore } from 'vuex'\n      import { key } from './store'\n\n      export default {\n        setup () {\n          const store = useStore(key)\n\n          store.state.count // typed as number\n        }\n      }\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/api/index.md)\n\nLast Updated:\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/api/index.html](https://next.vuex.vuejs.org/api/index.html)"
- name: Application Structure
  id: guide/structure
  summary: Vuex doesn't really restrict how you structure your code
  description: "# Application Structure\n\nVuex doesn't really restrict how you structure your code. Rather, it enforces a set of high-level principles:\n\n1.  Application-level state is centralized in the store.\n\n2.  The only way to mutate the state is by committing **mutations**, which are synchronous transactions.\n\n3.  Asynchronous logic should be encapsulated in, and can be composed with **actions**.\n\nAs long as you follow these rules, it's up to you how to structure your project. If your store file gets too big, simply start splitting the actions, mutations and getters into separate files.\n\nFor any non-trivial app, we will likely need to leverage modules. Here's an example project structure:\n\n    ├── index.html\n    ├── main.js\n    ├── api\n    │   └── ... # abstractions for making API requests\n    ├── components\n    │   ├── App.vue\n    │   └── ...\n    └── store\n        ├── index.js          # where we assemble modules and export the store\n        ├── actions.js        # root actions\n        ├── mutations.js      # root mutations\n        └── modules\n            ├── cart.js       # cart module\n            └── products.js   # products module\n\nAs a reference, check out the [Shopping Cart Example](https://github.com/vuejs/vuex/tree/4.0/examples/classic/shopping-cart).\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/structure.md)\n\nLast Updated:\n\n[Modules](modules)\n\n[Composition API](composition-api)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/structure.html](https://next.vuex.vuejs.org/guide/structure.html)"
- name: commit
  id: api/index#commit
  summary: Commit a mutation
  belongs_to: API Reference
  description: |-
    ### commit

    - `commit(type: string, payload?: any, options?: Object)`
    - `commit(mutation: Object, options?: Object)`

    Commit a mutation. `options` can have `root: true` that allows to commit root mutations in [namespaced modules](../guide/modules#namespacing). [Details](../guide/mutations)
- name: Component Binding Helpers
  id: api/index#component-binding-helpers
  summary: null
  belongs_to: API Reference
  description: '## Component Binding Helpers'
- name: Composition API
  id: guide/composition-api
  summary: To access the store within the setup hook, you can call the useStore function
  description: "# Composition API\n\nTo access the store within the `setup` hook, you can call the `useStore` function. This is the equivalent of retrieving `this.$store` within a component using the Option API.\n\n    import { useStore } from 'vuex'\n\n    export default {\n      setup () {\n        const store = useStore()\n      }\n    }\n\n## Accessing State and Getters\n\nIn order to access state and getters, you will want to create `computed` references to retain reactivity. This is the equivalent of creating computed properties using the Option API.\n\n    import { computed } from 'vue'\n    import { useStore } from 'vuex'\n\n    export default {\n      setup () {\n        const store = useStore()\n\n        return {\n          // access a state in computed function\n          count: computed(() => store.state.count),\n\n          // access a getter in computed function\n          double: computed(() => store.getters.double)\n        }\n      }\n    }\n\n## Accessing Mutations and Actions\n\nWhen accessing mutations and actions, you can simply provide the `commit` and `dispatch` method inside the `setup` hook.\n\n    import { useStore } from 'vuex'\n\n    export default {\n      setup () {\n        const store = useStore()\n\n        return {\n          // access a mutation\n          increment: () => store.commit('increment'),\n\n          // access an action\n          asyncIncrement: () => store.dispatch('asyncIncrement')\n        }\n      }\n    }\n\n## Examples\n\nCheck out the [Composition API example](https://github.com/vuejs/vuex/tree/4.0/examples/composition) to see example applications utilizing Vuex and Vue's Composition API.\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/composition-api.md)\n\nLast Updated:\n\n[Application Structure](structure)\n\n[Plugins](plugins)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/composition-api.html](https://next.vuex.vuejs.org/guide/composition-api.html)"
- name: createNamespacedHelpers
  id: api/index#createnamespacedhelpers
  summary: Create namespaced component binding helpers
  belongs_to: API Reference
  description: |-
    ### createNamespacedHelpers

    - `createNamespacedHelpers(namespace: string): Object`

    Create namespaced component binding helpers. The returned object contains `mapState`, `mapGetters`, `mapActions` and `mapMutations` that are bound with the given namespace. [Details](../guide/modules#binding-helpers-with-namespace)

    ## Composable Functions
- name: createStore
  id: api/index#createstore
  summary: Creates a new store
  belongs_to: API Reference
  description: "### createStore\n\n- `createStore<S>(options: StoreOptions<S>): Store<S>`\n\n  Creates a new store.\n\n                        import{ createStore } from 'vuex'\n\n      const store = createStore({ ...options })\n\n                      \n\n## Store Constructor Options"
- name: devtools
  id: api/index#devtools
  summary: Turn the devtools on or off for a particular Vuex instance
  belongs_to: API Reference
  description: "### devtools\n\n- type: `boolean`\n\n  Turn the devtools on or off for a particular Vuex instance. For instance, passing `false` tells the Vuex store to not subscribe to devtools plugin. Useful when you have multiple stores on a single page.\n\n                        {\n        devtools: false\n      }\n\n                      \n\n## Store Instance Properties"
- name: dispatch
  id: api/index#dispatch
  summary: Dispatch an action
  belongs_to: API Reference
  description: |-
    ### dispatch

    - `dispatch(type: string, payload?: any, options?: Object): Promise<any>`
    - `dispatch(action: Object, options?: Object): Promise<any>`

    Dispatch an action. `options` can have `root: true` that allows to dispatch root actions in [namespaced modules](../guide/modules#namespacing). Returns a Promise that resolves all triggered action handlers. [Details](../guide/actions)
- name: Form Handling
  id: guide/forms
  summary: Assuming obj is a computed property that returns an Object from the store, the v-model here will attempt to directly mutate obj.message when the user types in the input
  description: "# Form Handling\n\n[Try this lesson on Scrimba](https://scrimba.com/p/pnyzgAP/cqKRgEC9)\n\nWhen using Vuex in strict mode, it could be a bit tricky to use `v-model` on a piece of state that belongs to Vuex:\n\n    <input v-model=\"obj.message\">\n\nAssuming `obj` is a computed property that returns an Object from the store, the `v-model` here will attempt to directly mutate `obj.message` when the user types in the input. In strict mode, this will result in an error because the mutation is not performed inside an explicit Vuex mutation handler.\n\nThe \"Vuex way\" to deal with it is binding the `<input>`'s value and call a method on the `input` or `change` event:\n\n    <input :value=\"message\" @input=\"updateMessage\">\n\n    // ...\n    computed: {\n      ...mapState({\n        message: state => state.obj.message\n      })\n    },\n    methods: {\n      updateMessage (e) {\n        this.$store.commit('updateMessage', e.target.value)\n      }\n    }\n\nAnd here's the mutation handler:\n\n    // ...\n    mutations: {\n      updateMessage (state, message) {\n        state.obj.message = message\n      }\n    }\n\n## Two-way Computed Property\n\nAdmittedly, the above is quite a bit more verbose than `v-model` + local state, and we lose some of the useful features from `v-model` as well. An alternative approach is using a two-way computed property with a setter:\n\n    <input v-model=\"message\">\n\n    // ...\n    computed: {\n      message: {\n        get () {\n          return this.$store.state.obj.message\n        },\n        set (value) {\n          this.$store.commit('updateMessage', value)\n        }\n      }\n    }\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/forms.md)\n\nLast Updated:\n\n[Strict Mode](strict)\n\n[Testing](testing)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/forms.html](https://next.vuex.vuejs.org/guide/forms.html)"
- name: Getters
  id: guide/getters
  summary: If more than one component needs to make use of this, we have to either duplicate the function, or extract it into a shared helper and import it in multiple places - both are less than ideal
  description: "# Getters\n\n[Try this lesson on Scrimba](https://scrimba.com/p/pnyzgAP/c2Be7TB)\n\nSometimes we may need to compute derived state based on store state, for example filtering through a list of items and counting them:\n\n    computed: {\n      doneTodosCount () {\n        return this.$store.state.todos.filter(todo => todo.done).length\n      }\n    }\n\nIf more than one component needs to make use of this, we have to either duplicate the function, or extract it into a shared helper and import it in multiple places - both are less than ideal.\n\nVuex allows us to define \"getters\" in the store. You can think of them as computed properties for stores.\n\nWARNING\n\nAs of Vue 3.0, the getter's result is **not cached** as the computed property does. This is a known issue that requires Vue 3.1 to be released. You can learn more at [PR \\#1878](https://github.com/vuejs/vuex/pull/1878).\n\nGetters will receive the state as their 1st argument:\n\n    const store = createStore({\n      state: {\n        todos: [\n          { id: 1, text: '...', done: true },\n          { id: 2, text: '...', done: false }\n        ]\n      },\n      getters: {\n        doneTodos (state) {\n          return state.todos.filter(todo => todo.done)\n        }\n      }\n    })\n\n## Property-Style Access\n\nThe getters will be exposed on the `store.getters` object, and you access values as properties:\n\n    store.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]\n\nGetters will also receive other getters as the 2nd argument:\n\n    getters: {\n      // ...\n      doneTodosCount (state, getters) {\n        return getters.doneTodos.length\n      }\n    }\n\n    store.getters.doneTodosCount // -> 1\n\nWe can now easily make use of it inside any component:\n\n    computed: {\n      doneTodosCount () {\n        return this.$store.getters.doneTodosCount\n      }\n    }\n\nNote that getters accessed as properties are cached as part of Vue's reactivity system.\n\n## Method-Style Access\n\nYou can also pass arguments to getters by returning a function. This is particularly useful when you want to query an array in the store:\n\n    getters: {\n      // ...\n      getTodoById: (state) => (id) => {\n        return state.todos.find(todo => todo.id === id)\n      }\n    }\n\n    store.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }\n\nNote that getters accessed via methods will run each time you call them, and the result is not cached.\n\n## The `mapGetters` Helper\n\nThe `mapGetters` helper simply maps store getters to local computed properties:\n\n    import { mapGetters } from 'vuex'\n\n    export default {\n      // ...\n      computed: {\n        // mix the getters into computed with object spread operator\n        ...mapGetters([\n          'doneTodosCount',\n          'anotherGetter',\n          // ...\n        ])\n      }\n    }\n\nIf you want to map a getter to a different name, use an object:\n\n    ...mapGetters({\n      // map `this.doneCount` to `this.$store.getters.doneTodosCount`\n      doneCount: 'doneTodosCount'\n    })\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/getters.md)\n\nLast Updated:\n\n[State](state)\n\n[Mutations](mutations)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/getters.html](https://next.vuex.vuejs.org/guide/getters.html)"
- name: getters
  id: api/index#getters
  summary: Register getters on the store
  belongs_to: API Reference
  description: "### getters\n\n- type: `{ [key: string]: Function }`\n\n  Register getters on the store. The getter function receives the following arguments:\n\n                        state,     // will be module local state if defined in a module.\n      getters    // same as store.getters\n\n                      \n\n  Specific when defined in a module\n\n                        state,       // will be module local state if defined in a module.\n      getters,     // module local getters of the current module\n      rootState,   // global state\n      rootGetters  // all getters\n\n                      \n\n  Registered getters are exposed on `store.getters`.\n\n  [Details](../guide/getters)\n\n&nbsp;"
- name: getters
  id: api/index#getters-1
  summary: Exposes registered getters
  belongs_to: API Reference
  description: |-
    ### getters

    - type: `Object`

      Exposes registered getters. Read only.

    ## Store Instance Methods
- name: Getting Started
  id: guide/index
  summary: At the center of every Vuex application is the store
  description: "# Getting Started\n\n[Try this lesson on Scrimba](https://scrimba.com/p/pnyzgAP/cMPa2Uk)\n\nAt the center of every Vuex application is the **store**. A \"store\" is basically a container that holds your application **state**. There are two things that make a Vuex store different from a plain global object:\n\n1.  Vuex stores are reactive. When Vue components retrieve state from it, they will reactively and efficiently update if the store's state changes.\n\n2.  You cannot directly mutate the store's state. The only way to change a store's state is by explicitly **committing mutations**. This ensures every state change leaves a track-able record, and enables tooling that helps us better understand our applications.\n\n## The Simplest Store\n\nNOTE\n\nWe will be using ES2015 syntax for code examples for the rest of the docs. If you haven't picked it up, [you should](https://babeljs.io/docs/learn-es2015/)!\n\nAfter [installing](../installation) Vuex, let's create a store. It is pretty straightforward - just provide an initial state object, and some mutations:\n\n    import { createApp } from 'vue'\n    import { createStore } from 'vuex'\n\n    // Create a new store instance.\n    const store = createStore({\n      state () {\n        return {\n          count: 0\n        }\n      },\n      mutations: {\n        increment (state) {\n          state.count++\n        }\n      }\n    })\n\n    const app = createApp({ /* your root component */ })\n\n    // Install the store instance as a plugin\n    app.use(store)\n\nNow, you can access the state object as `store.state`, and trigger a state change with the `store.commit` method:\n\n    store.commit('increment')\n\n    console.log(store.state.count) // -> 1\n\nIn a Vue component, you can access the store as `this.$store`. Now we can commit a mutation using a component method:\n\n    methods: {\n      increment() {\n        this.$store.commit('increment')\n        console.log(this.$store.state.count)\n      }\n    }\n\nAgain, the reason we are committing a mutation instead of changing `store.state.count` directly, is because we want to explicitly track it. This simple convention makes your intention more explicit, so that you can reason about state changes in your app better when reading the code. In addition, this gives us the opportunity to implement tools that can log every mutation, take state snapshots, or even perform time travel debugging.\n\nUsing store state in a component simply involves returning the state within a computed property, because the store state is reactive. Triggering changes simply means committing mutations in component methods.\n\nNext, we will discuss each core concept in much finer details, starting with [State](state).\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/index.md)\n\nLast Updated:\n\n[Installation](../installation)\n\n[State](state)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/index.html](https://next.vuex.vuejs.org/guide/index.html)"
- name: hasModule
  id: api/index#hasmodule
  summary: Check if the module with the given name is already registered
  belongs_to: API Reference
  description: |-
    ### hasModule

    - `hasModule(path: string | Array<string>): boolean`

      Check if the module with the given name is already registered. [Details](../guide/modules#dynamic-module-registration)

    &nbsp;
- name: Hot Reloading
  id: guide/hot-reload
  summary: Vuex supports hot-reloading mutations, modules, actions and getters during development, using webpack's Hot Module Replacement API
  description: "# Hot Reloading\n\nVuex supports hot-reloading mutations, modules, actions and getters during development, using webpack's [Hot Module Replacement API](https://webpack.js.org/guides/hot-module-replacement/). You can also use it in Browserify with the [browserify-hmr](https://github.com/AgentME/browserify-hmr/) plugin.\n\nFor mutations and modules, you need to use the `store.hotUpdate()` API method:\n\n    // store.js\n    import { createStore } from 'vuex'\n    import mutations from './mutations'\n    import moduleA from './modules/a'\n\n    const state = { ... }\n\n    const store = createStore({\n      state,\n      mutations,\n      modules: {\n        a: moduleA\n      }\n    })\n\n    if (module.hot) {\n      // accept actions and mutations as hot modules\n      module.hot.accept(['./mutations', './modules/a'], () => {\n        // require the updated modules\n        // have to add .default here due to babel 6 module output\n        const newMutations = require('./mutations').default\n        const newModuleA = require('./modules/a').default\n        // swap in the new modules and mutations\n        store.hotUpdate({\n          mutations: newMutations,\n          modules: {\n            a: newModuleA\n          }\n        })\n      })\n    }\n\nCheckout the [counter-hot example](https://github.com/vuejs/vuex/tree/dev/examples/counter-hot) to play with hot-reload.\n\n## Dynamic module hot reloading\n\nIf you use modules exclusively, you can use `require.context` to load and hot reload all modules dynamically.\n\n    // store.js\n    import { createStore } from 'vuex'\n\n    // Load all modules.\n    function loadModules() {\n      const context = require.context(\"./modules\", false, /([a-z_]+)\\.js$/i)\n\n      const modules = context\n        .keys()\n        .map((key) => ({ key, name: key.match(/([a-z_]+)\\.js$/i)[1] }))\n        .reduce(\n          (modules, { key, name }) => ({\n            ...modules,\n            [name]: context(key).default\n          }),\n          {}\n        )\n\n      return { context, modules }\n    }\n\n    const { context, modules } = loadModules()\n\n    const store = createStore({\n      modules\n    })\n\n    if (module.hot) {\n      // Hot reload whenever any module changes.\n      module.hot.accept(context.id, () => {\n        const { modules } = loadModules()\n\n        store.hotUpdate({\n          modules\n        })\n      })\n    }\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/hot-reload.md)\n\nLast Updated:\n\n[Testing](testing)\n\n[TypeScript Support](typescript-support)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/hot-reload.html](https://next.vuex.vuejs.org/guide/hot-reload.html)"
- name: hotUpdate
  id: api/index#hotupdate
  summary: Hot swap new actions and mutations
  belongs_to: API Reference
  description: |-
    ### hotUpdate

    - `hotUpdate(newOptions: Object)`

    Hot swap new actions and mutations. [Details](../guide/hot-reload)
- name: Installation
  id: installation
  summary: Unpkg.com provides NPM-based CDN links
  description: "# Installation\n\n## Direct Download / CDN\n\n[https://unpkg.com/vuex@4](https://unpkg.com/vuex@4)\n\n[Unpkg.com](https://unpkg.com) provides NPM-based CDN links. The above link will always point to the latest release on NPM. You can also use a specific version/tag via URLs like `https://unpkg.com/vuex@4.0.0/dist/vuex.global.js`.\n\nInclude `vuex` after Vue and it will install itself automatically:\n\n    <script src=\"/path/to/vue.js\"></script>\n    <script src=\"/path/to/vuex.js\"></script>\n\n## NPM\n\n    npm install vuex@next --save\n\n## Yarn\n\n    yarn add vuex@next --save\n\n## Dev Build\n\nYou will have to clone directly from GitHub and build `vuex` yourself if you want to use the latest dev build.\n\n    git clone https://github.com/vuejs/vuex.git node_modules/vuex\n    cd node_modules/vuex\n    yarn\n    yarn build\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/installation.md)\n\nLast Updated:\n\n[What is Vuex?](index)\n\n[Getting Started](guide/index)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/installation.html](https://next.vuex.vuejs.org/installation.html)"
- name: mapActions
  id: api/index#mapactions
  summary: Create component methods options that dispatch an action
  belongs_to: API Reference
  description: |-
    ### mapActions

    - `mapActions(namespace?: string, map: Array<string> | Object<string | function>): Object`

    Create component methods options that dispatch an action. [Details](../guide/actions#dispatching-actions-in-components)

    The first argument can optionally be a namespace string. [Details](../guide/modules#binding-helpers-with-namespace)

    The second object argument's members can be a function. `function(dispatch: function, ...args: any[])`
- name: mapGetters
  id: api/index#mapgetters
  summary: Create component computed options that return the evaluated value of a getter
  belongs_to: API Reference
  description: |-
    ### mapGetters

    - `mapGetters(namespace?: string, map: Array<string> | Object<string>): Object`

    Create component computed options that return the evaluated value of a getter. [Details](../guide/getters#the-mapgetters-helper)

    The first argument can optionally be a namespace string. [Details](../guide/modules#binding-helpers-with-namespace)
- name: mapMutations
  id: api/index#mapmutations
  summary: Create component methods options that commit a mutation
  belongs_to: API Reference
  description: |-
    ### mapMutations

    - `mapMutations(namespace?: string, map: Array<string> | Object<string | function>): Object`

    Create component methods options that commit a mutation. [Details](../guide/mutations#committing-mutations-in-components)

    The first argument can optionally be a namespace string. [Details](../guide/modules#binding-helpers-with-namespace)

    The second object argument's members can be a function. `function(commit: function, ...args: any[])`
- name: mapState
  id: api/index#mapstate
  summary: Create component computed options that return the sub tree of the Vuex store
  belongs_to: API Reference
  description: |-
    ### mapState

    - `mapState(namespace?: string, map: Array<string> | Object<string | function>): Object`

    Create component computed options that return the sub tree of the Vuex store. [Details](../guide/state#the-mapstate-helper)

    The first argument can optionally be a namespace string. [Details](../guide/modules#binding-helpers-with-namespace)

    The second object argument's members can be a function. `function(state: any)`
- name: Migrating to 4.0 from 3.x
  id: guide/migrating-to-4-0-from-3-x
  summary: Almost all Vuex 4 APIs have remained unchanged from Vuex 3
  description: "# Migrating to 4.0 from 3.x\n\nAlmost all Vuex 4 APIs have remained unchanged from Vuex 3. However, there are still a few breaking changes that you must fix.\n\n- [Breaking Changes](#breaking-changes)\n  - [Installation process](#installation-process)\n  - [TypeScript support](#typescript-support)\n  - [Bundles are now aligned with Vue 3](#bundles-are-now-aligned-with-vue-3)\n  - [\"createLogger\" function is exported from the core module](#createlogger-function-is-exported-from-the-core-module)\n- [New Features](#new-features)\n  - [New \"useStore\" composition function](#new-usestore-composition-function)\n\n## Breaking Changes\n\n### Installation process\n\nTo align with the new Vue 3 initialization process, the installation process of Vuex has changed. To create a new store, users are now encouraged to use the newly introduced createStore function.\n\n    import { createStore } from 'vuex'\n\n    export const store = createStore({\n      state () {\n        return {\n          count: 1\n        }\n      }\n    })\n\nTo install Vuex to a Vue instance, pass the `store` instead of Vuex.\n\n    import { createApp } from 'vue'\n    import { store } from './store'\n    import App from './App.vue'\n\n    const app = createApp(App)\n\n    app.use(store)\n\n    app.mount('#app')\n\nNOTE\n\nWhilst this is not technically a breaking change, you may still use the `new Store(...)` syntax, we recommend this approach to align with Vue 3 and Vue Router Next.\n\n### TypeScript support\n\nVuex 4 removes its global typings for `this.$store` within a Vue component to solve [issue \\#994](https://github.com/vuejs/vuex/issues/994). When used with TypeScript, you must declare your own module augmentation.\n\nPlace the following code in your project to allow `this.$store` to be typed correctly:\n\n    // vuex-shim.d.ts\n\n    import { ComponentCustomProperties } from 'vue'\n    import { Store } from 'vuex'\n\n    declare module '@vue/runtime-core' {\n      // Declare your own store states.\n      interface State {\n        count: number\n      }\n\n      interface ComponentCustomProperties {\n        $store: Store<State>\n      }\n    }\n\nYou can learn more in the [TypeScript Support](typescript-support) section.\n\n### Bundles are now aligned with Vue 3\n\nThe following bundles are generated to align with Vue 3 bundles:\n\n- `vuex.global(.prod).js`\n  - For direct use with `<script src=\"...\">` in the browser. Exposes the Vuex global.\n  - Global build is built as IIFE, and not UMD, and is only meant for direct use with `<script src=\"...\">`.\n  - Contains hard-coded prod/dev branches and the prod build is pre-minified. Use the `.prod.js` files for production.\n- `vuex.esm-browser(.prod).js`\n  - For use with native ES module imports (including module supporting browsers via `<script type=\"module\">`.\n- `vuex.esm-bundler.js`\n  - For use with bundlers such as `webpack`, `rollup` and `parcel`.\n  - Leaves prod/dev branches with `process.env.NODE_ENV` guards (must be replaced by bundler).\n  - Does not ship minified builds (to be done together with the rest of the code after bundling).\n- `vuex.cjs.js`\n  - For use in Node.js server-side rendering with `require()`.\n\n### `createLogger` function is exported from the core module\n\nIn Vuex 3, `createLogger` function was exported from `vuex/dist/logger` but it's now included in the core package. The function should be imported directly from the `vuex` package.\n\n    import { createLogger } from 'vuex'\n\n## New Features\n\n### New `useStore` composition function\n\nVuex 4 introduces a new API to interact with the store in Composition API. You can use the `useStore` composition function to retrieve the store within the component `setup` hook.\n\n    import { useStore } from 'vuex'\n\n    export default {\n      setup () {\n        const store = useStore()\n      }\n    }\n\nYou can learn more in the [Composition API](composition-api) section.\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/migrating-to-4-0-from-3-x.md)\n\nLast Updated:\n\n[TypeScript Support](typescript-support)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/migrating-to-4-0-from-3-x.html](https://next.vuex.vuejs.org/guide/migrating-to-4-0-from-3-x.html)"
- name: Modules
  id: guide/modules
  summary: Due to using a single state tree, all states of our application are contained inside one big object
  description: "# Modules\n\n[Try this lesson on Scrimba](https://scrimba.com/p/pnyzgAP/cqKK4psq)\n\nDue to using a single state tree, all states of our application are contained inside one big object. However, as our application grows in scale, the store can get really bloated.\n\nTo help with that, Vuex allows us to divide our store into **modules**. Each module can contain its own state, mutations, actions, getters, and even nested modules - it's fractal all the way down:\n\n    const moduleA = {\n      state: () => ({ ... }),\n      mutations: { ... },\n      actions: { ... },\n      getters: { ... }\n    }\n\n    const moduleB = {\n      state: () => ({ ... }),\n      mutations: { ... },\n      actions: { ... }\n    }\n\n    const store = createStore({\n      modules: {\n        a: moduleA,\n        b: moduleB\n      }\n    })\n\n    store.state.a // -> `moduleA`'s state\n    store.state.b // -> `moduleB`'s state\n\n## Module Local State\n\nInside a module's mutations and getters, the first argument received will be **the module's local state**.\n\n    const moduleA = {\n      state: () => ({\n        count: 0\n      }),\n      mutations: {\n        increment (state) {\n          // `state` is the local module state\n          state.count++\n        }\n      },\n      getters: {\n        doubleCount (state) {\n          return state.count * 2\n        }\n      }\n    }\n\nSimilarly, inside module actions, `context.state` will expose the local state, and root state will be exposed as `context.rootState`:\n\n    const moduleA = {\n      // ...\n      actions: {\n        incrementIfOddOnRootSum ({ state, commit, rootState }) {\n          if ((state.count + rootState.count) % 2 === 1) {\n            commit('increment')\n          }\n        }\n      }\n    }\n\nAlso, inside module getters, the root state will be exposed as their 3rd argument:\n\n    const moduleA = {\n      // ...\n      getters: {\n        sumWithRootCount (state, getters, rootState) {\n          return state.count + rootState.count\n        }\n      }\n    }\n\n## Namespacing\n\nBy default, actions and mutations are still registered under the **global namespace** - this allows multiple modules to react to the same action/mutation type. Getters are also registered in the global namespace by default. However, this currently has no functional purpose (it's as is to avoid breaking changes). You must be careful not to define two getters with the same name in different, non-namespaced modules, resulting in an error.\n\nIf you want your modules to be more self-contained or reusable, you can mark it as namespaced with `namespaced: true`. When the module is registered, all of its getters, actions and mutations will be automatically namespaced based on the path the module is registered at. For example:\n\n    const store = createStore({\n      modules: {\n        account: {\n          namespaced: true,\n\n          // module assets\n          state: () => ({ ... }), // module state is already nested and not affected by namespace option\n          getters: {\n            isAdmin () { ... } // -> getters['account/isAdmin']\n          },\n          actions: {\n            login () { ... } // -> dispatch('account/login')\n          },\n          mutations: {\n            login () { ... } // -> commit('account/login')\n          },\n\n          // nested modules\n          modules: {\n            // inherits the namespace from parent module\n            myPage: {\n              state: () => ({ ... }),\n              getters: {\n                profile () { ... } // -> getters['account/profile']\n              }\n            },\n\n            // further nest the namespace\n            posts: {\n              namespaced: true,\n\n              state: () => ({ ... }),\n              getters: {\n                popular () { ... } // -> getters['account/posts/popular']\n              }\n            }\n          }\n        }\n      }\n    })\n\nNamespaced getters and actions will receive localized `getters`, `dispatch` and `commit`. In other words, you can use the module assets without writing prefix in the same module. Toggling between namespaced or not does not affect the code inside the module.\n\n### Accessing Global Assets in Namespaced Modules\n\nIf you want to use global state and getters, `rootState` and `rootGetters` are passed as the 3rd and 4th arguments to getter functions, and also exposed as properties on the `context` object passed to action functions.\n\nTo dispatch actions or commit mutations in the global namespace, pass `{ root: true }` as the 3rd argument to `dispatch` and `commit`.\n\n    modules: {\n      foo: {\n        namespaced: true,\n\n        getters: {\n          // `getters` is localized to this module's getters\n          // you can use rootGetters via 4th argument of getters\n          someGetter (state, getters, rootState, rootGetters) {\n            getters.someOtherGetter // -> 'foo/someOtherGetter'\n            rootGetters.someOtherGetter // -> 'someOtherGetter'\n            rootGetters['bar/someOtherGetter'] // -> 'bar/someOtherGetter'\n          },\n          someOtherGetter: state => { ... }\n        },\n\n        actions: {\n          // dispatch and commit are also localized for this module\n          // they will accept `root` option for the root dispatch/commit\n          someAction ({ dispatch, commit, getters, rootGetters }) {\n            getters.someGetter // -> 'foo/someGetter'\n            rootGetters.someGetter // -> 'someGetter'\n            rootGetters['bar/someGetter'] // -> 'bar/someGetter'\n\n            dispatch('someOtherAction') // -> 'foo/someOtherAction'\n            dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'\n\n            commit('someMutation') // -> 'foo/someMutation'\n            commit('someMutation', null, { root: true }) // -> 'someMutation'\n          },\n          someOtherAction (ctx, payload) { ... }\n        }\n      }\n    }\n\n### Register Global Action in Namespaced Modules\n\nIf you want to register global actions in namespaced modules, you can mark it with `root: true` and place the action definition to function `handler`. For example:\n\n    {\n      actions: {\n        someOtherAction ({dispatch}) {\n          dispatch('someAction')\n        }\n      },\n      modules: {\n        foo: {\n          namespaced: true,\n\n          actions: {\n            someAction: {\n              root: true,\n              handler (namespacedContext, payload) { ... } // -> 'someAction'\n            }\n          }\n        }\n      }\n    }\n\n### Binding Helpers with Namespace\n\nWhen binding a namespaced module to components with the `mapState`, `mapGetters`, `mapActions` and `mapMutations` helpers, it can get a bit verbose:\n\n    computed: {\n      ...mapState({\n        a: state => state.some.nested.module.a,\n        b: state => state.some.nested.module.b\n      }),\n      ...mapGetters([\n        'some/nested/module/someGetter', // -> this['some/nested/module/someGetter']\n        'some/nested/module/someOtherGetter', // -> this['some/nested/module/someOtherGetter']\n      ])\n    },\n    methods: {\n      ...mapActions([\n        'some/nested/module/foo', // -> this['some/nested/module/foo']()\n        'some/nested/module/bar' // -> this['some/nested/module/bar']()\n      ])\n    }\n\nIn such cases, you can pass the module namespace string as the first argument to the helpers so that all bindings are done using that module as the context. The above can be simplified to:\n\n    computed: {\n      ...mapState('some/nested/module', {\n        a: state => state.a,\n        b: state => state.b\n      }),\n      ...mapGetters('some/nested/module', [\n        'someGetter', // -> this.someGetter\n        'someOtherGetter', // -> this.someOtherGetter\n      ])\n    },\n    methods: {\n      ...mapActions('some/nested/module', [\n        'foo', // -> this.foo()\n        'bar' // -> this.bar()\n      ])\n    }\n\nFurthermore, you can create namespaced helpers by using `createNamespacedHelpers`. It returns an object having new component binding helpers that are bound with the given namespace value:\n\n    import { createNamespacedHelpers } from 'vuex'\n\n    const { mapState, mapActions } = createNamespacedHelpers('some/nested/module')\n\n    export default {\n      computed: {\n        // look up in `some/nested/module`\n        ...mapState({\n          a: state => state.a,\n          b: state => state.b\n        })\n      },\n      methods: {\n        // look up in `some/nested/module`\n        ...mapActions([\n          'foo',\n          'bar'\n        ])\n      }\n    }\n\n### Caveat for Plugin Developers\n\nYou may care about unpredictable namespacing for your modules when you create a [plugin](plugins) that provides the modules and let users add them to a Vuex store. Your modules will be also namespaced if the plugin users add your modules under a namespaced module. To adapt this situation, you may need to receive a namespace value via your plugin option:\n\n    // get namespace value via plugin option\n    // and returns Vuex plugin function\n    export function createPlugin (options = {}) {\n      return function (store) {\n        // add namespace to plugin module's types\n        const namespace = options.namespace || ''\n        store.dispatch(namespace + 'pluginAction')\n      }\n    }\n\n## Dynamic Module Registration\n\nYou can register a module **after** the store has been created with the `store.registerModule` method:\n\n    import { createStore } from 'vuex'\n\n    const store = createStore({ /* options */ })\n\n    // register a module `myModule`\n    store.registerModule('myModule', {\n      // ...\n    })\n\n    // register a nested module `nested/myModule`\n    store.registerModule(['nested', 'myModule'], {\n      // ...\n    })\n\nThe module's state will be exposed as `store.state.myModule` and `store.state.nested.myModule`.\n\nDynamic module registration makes it possible for other Vue plugins to also leverage Vuex for state management by attaching a module to the application's store. For example, the [`vuex-router-sync`](https://github.com/vuejs/vuex-router-sync) library integrates vue-router with vuex by managing the application's route state in a dynamically attached module.\n\nYou can also remove a dynamically registered module with `store.unregisterModule(moduleName)`. Note you cannot remove static modules (declared at store creation) with this method.\n\nNote that you may check if the module is already registered to the store or not via `store.hasModule(moduleName)` method. One thing to keep in mind is that nested modules should be passed as arrays for both the `registerModule` and `hasModule` and not as a string with the path to the module.\n\n### Preserving state\n\nIt may be likely that you want to preserve the previous state when registering a new module, such as preserving state from a Server Side Rendered app. You can achieve this with `preserveState` option: `store.registerModule('a', module, { preserveState: true })`\n\nWhen you set `preserveState: true`, the module is registered, actions, mutations and getters are added to the store, but the state is not. It's assumed that your store state already contains state for that module and you don't want to overwrite it.\n\n## Module Reuse\n\nSometimes we may need to create multiple instances of a module, for example:\n\n- Creating multiple stores that use the same module (e.g. To [avoid stateful singletons in the SSR](https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons) when the `runInNewContext` option is `false` or `'once'`);\n- Register the same module multiple times in the same store.\n\nIf we use a plain object to declare the state of the module, then that state object will be shared by reference and cause cross store/module state pollution when it's mutated.\n\nThis is actually the exact same problem with `data` inside Vue components. So the solution is also the same - use a function for declaring module state (supported in 2.3.0+):\n\n    const MyReusableModule = {\n      state: () => ({\n        foo: 'bar'\n      }),\n      // mutations, actions, getters...\n    }\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/modules.md)\n\nLast Updated:\n\n[Actions](actions)\n\n[Application Structure](structure)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/modules.html](https://next.vuex.vuejs.org/guide/modules.html)"
- name: modules
  id: api/index#modules
  summary: Each module can contain state and mutations similar to the root options
  belongs_to: API Reference
  description: "### modules\n\n- type: `Object`\n\n  An object containing sub modules to be merged into the store, in the shape of:\n\n                        {\n        key: {\n          state,\n          namespaced?,\n          mutations?,\n          actions?,\n          getters?,\n          modules?\n        },\n        ...\n      }\n\n                      \n\n  Each module can contain `state` and `mutations` similar to the root options. A module's state will be attached to the store's root state using the module's key. A module's mutations and getters will only receives the module's local state as the first argument instead of the root state, and module actions' `context.state` will also point to the local state.\n\n  [Details](../guide/modules)\n\n&nbsp;"
- name: Mutations
  id: guide/mutations
  summary: The only way to actually change state in a Vuex store is by committing a mutation
  description: "# Mutations\n\n[Try this lesson on Scrimba](https://scrimba.com/p/pnyzgAP/ckMZp4HN)\n\nThe only way to actually change state in a Vuex store is by committing a mutation. Vuex mutations are very similar to events: each mutation has a string **type** and a **handler**. The handler function is where we perform actual state modifications, and it will receive the state as the first argument:\n\n    const store = createStore({\n      state: {\n        count: 1\n      },\n      mutations: {\n        increment (state) {\n          // mutate state\n          state.count++\n        }\n      }\n    })\n\nYou cannot directly call a mutation handler. Think of it more like event registration: \"When a mutation with type `increment` is triggered, call this handler.\" To invoke a mutation handler, you need to call `store.commit` with its type:\n\n    store.commit('increment')\n\n## Commit with Payload\n\nYou can pass an additional argument to `store.commit`, which is called the **payload** for the mutation:\n\n    // ...\n    mutations: {\n      increment (state, n) {\n        state.count += n\n      }\n    }\n\n    store.commit('increment', 10)\n\nIn most cases, the payload should be an object so that it can contain multiple fields, and the recorded mutation will also be more descriptive:\n\n    // ...\n    mutations: {\n      increment (state, payload) {\n        state.count += payload.amount\n      }\n    }\n\n    store.commit('increment', {\n      amount: 10\n    })\n\n## Object-Style Commit\n\nAn alternative way to commit a mutation is by directly using an object that has a `type` property:\n\n    store.commit({\n      type: 'increment',\n      amount: 10\n    })\n\nWhen using object-style commit, the entire object will be passed as the payload to mutation handlers, so the handler remains the same:\n\n    mutations: {\n      increment (state, payload) {\n        state.count += payload.amount\n      }\n    }\n\n## Using Constants for Mutation Types\n\nIt is a commonly seen pattern to use constants for mutation types in various Flux implementations. This allows the code to take advantage of tooling like linters, and putting all constants in a single file allows your collaborators to get an at-a-glance view of what mutations are possible in the entire application:\n\n    // mutation-types.js\n    export const SOME_MUTATION = 'SOME_MUTATION'\n\n    // store.js\n    import { createStore } from 'vuex'\n    import { SOME_MUTATION } from './mutation-types'\n\n    const store = createStore({\n      state: { ... },\n      mutations: {\n        // we can use the ES2015 computed property name feature\n        // to use a constant as the function name\n        [SOME_MUTATION] (state) {\n          // mutate state\n        }\n      }\n    })\n\nWhether to use constants is largely a preference - it can be helpful in large projects with many developers, but it's totally optional if you don't like them.\n\n## Mutations Must Be Synchronous\n\nOne important rule to remember is that **mutation handler functions must be synchronous**. Why? Consider the following example:\n\n    mutations: {\n      someMutation (state) {\n        api.callAsyncMethod(() => {\n          state.count++\n        })\n      }\n    }\n\nNow imagine we are debugging the app and looking at the devtool's mutation logs. For every mutation logged, the devtool will need to capture a \"before\" and \"after\" snapshots of the state. However, the asynchronous callback inside the example mutation above makes that impossible: the callback is not called yet when the mutation is committed, and there's no way for the devtool to know when the callback will actually be called - any state mutation performed in the callback is essentially un-trackable!\n\n## Committing Mutations in Components\n\nYou can commit mutations in components with `this.$store.commit('xxx')`, or use the `mapMutations` helper which maps component methods to `store.commit` calls (requires root `store` injection):\n\n    import { mapMutations } from 'vuex'\n\n    export default {\n      // ...\n      methods: {\n        ...mapMutations([\n          'increment', // map `this.increment()` to `this.$store.commit('increment')`\n\n          // `mapMutations` also supports payloads:\n          'incrementBy' // map `this.incrementBy(amount)` to `this.$store.commit('incrementBy', amount)`\n        ]),\n        ...mapMutations({\n          add: 'increment' // map `this.add()` to `this.$store.commit('increment')`\n        })\n      }\n    }\n\n## On to Actions\n\nAsynchronicity combined with state mutation can make your program very hard to reason about. For example, when you call two methods both with async callbacks that mutate the state, how do you know when they are called and which callback was called first? This is exactly why we want to separate the two concepts. In Vuex, **mutations are synchronous transactions**:\n\n    store.commit('increment')\n    // any state change that the \"increment\" mutation may cause\n    // should be done at this moment.\n\nTo handle asynchronous operations, let's introduce [Actions](actions).\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/mutations.md)\n\nLast Updated:\n\n[Getters](getters)\n\n[Actions](actions)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/mutations.html](https://next.vuex.vuejs.org/guide/mutations.html)"
- name: mutations
  id: api/index#mutations
  summary: Register mutations on the store
  belongs_to: API Reference
  description: |-
    ### mutations

    - type: `{ [type: string]: Function }`

      Register mutations on the store. The handler function always receives `state` as the first argument (will be module local state if defined in a module), and receives a second `payload` argument if there is one.

      [Details](../guide/mutations)

    &nbsp;
- name: Plugins
  id: guide/plugins
  summary: Vuex stores accept the plugins option that exposes hooks for each mutation
  description: "# Plugins\n\n[Try this lesson on Scrimba](https://scrimba.com/p/pnyzgAP/cvp8ZkCR)\n\nVuex stores accept the `plugins` option that exposes hooks for each mutation. A Vuex plugin is simply a function that receives the store as the only argument:\n\n    const myPlugin = (store) => {\n      // called when the store is initialized\n      store.subscribe((mutation, state) => {\n        // called after every mutation.\n        // The mutation comes in the format of `{ type, payload }`.\n      })\n    }\n\nAnd can be used like this:\n\n    const store = createStore({\n      // ...\n      plugins: [myPlugin]\n    })\n\n## Committing Mutations Inside Plugins\n\nPlugins are not allowed to directly mutate state - similar to your components, they can only trigger changes by committing mutations.\n\nBy committing mutations, a plugin can be used to sync a data source to the store. For example, to sync a websocket data source to the store (this is just a contrived example, in reality the `createWebSocketPlugin` function can take some additional options for more complex tasks):\n\n    export default function createWebSocketPlugin (socket) {\n      return (store) => {\n        socket.on('data', data => {\n          store.commit('receiveData', data)\n        })\n        store.subscribe(mutation => {\n          if (mutation.type === 'UPDATE_DATA') {\n            socket.emit('update', mutation.payload)\n          }\n        })\n      }\n    }\n\n    const plugin = createWebSocketPlugin(socket)\n\n    const store = createStore({\n      state,\n      mutations,\n      plugins: [plugin]\n    })\n\n## Taking State Snapshots\n\nSometimes a plugin may want to receive \"snapshots\" of the state, and also compare the post-mutation state with pre-mutation state. To achieve that, you will need to perform a deep-copy on the state object:\n\n    const myPluginWithSnapshot = (store) => {\n      let prevState = _.cloneDeep(store.state)\n      store.subscribe((mutation, state) => {\n        let nextState = _.cloneDeep(state)\n\n        // compare `prevState` and `nextState`...\n\n        // save state for next mutation\n        prevState = nextState\n      })\n    }\n\n**Plugins that take state snapshots should be used only during development.** When using webpack or Browserify, we can let our build tools handle that for us:\n\n    const store = createStore({\n      // ...\n      plugins: process.env.NODE_ENV !== 'production'\n        ? [myPluginWithSnapshot]\n        : []\n    })\n\nThe plugin will be used by default. For production, you will need [DefinePlugin](https://webpack.js.org/plugins/define-plugin/) for webpack or [envify](https://github.com/hughsk/envify) for Browserify to convert the value of `process.env.NODE_ENV !== 'production'` to `false` for the final build.\n\n## Built-in Logger Plugin\n\nVuex comes with a logger plugin for common debugging usage:\n\n    import { createLogger } from 'vuex'\n\n    const store = createStore({\n      plugins: [createLogger()]\n    })\n\nThe `createLogger` function takes a few options:\n\n    const logger = createLogger({\n      collapsed: false, // auto-expand logged mutations\n      filter (mutation, stateBefore, stateAfter) {\n        // returns `true` if a mutation should be logged\n        // `mutation` is a `{ type, payload }`\n        return mutation.type !== \"aBlocklistedMutation\"\n      },\n      actionFilter (action, state) {\n        // same as `filter` but for actions\n        // `action` is a `{ type, payload }`\n        return action.type !== \"aBlocklistedAction\"\n      },\n      transformer (state) {\n        // transform the state before logging it.\n        // for example return only a specific sub-tree\n        return state.subTree\n      },\n      mutationTransformer (mutation) {\n        // mutations are logged in the format of `{ type, payload }`\n        // we can format it any way we want.\n        return mutation.type\n      },\n      actionTransformer (action) {\n        // Same as mutationTransformer but for actions\n        return action.type\n      },\n      logActions: true, // Log Actions\n      logMutations: true, // Log mutations\n      logger: console, // implementation of the `console` API, default `console`\n    })\n\nThe logger file can also be included directly via a `<script>` tag, and will expose the `createVuexLogger` function globally.\n\nNote the logger plugin takes state snapshots, so use it only during development.\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/plugins.md)\n\nLast Updated:\n\n[Composition API](composition-api)\n\n[Strict Mode](strict)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/plugins.html](https://next.vuex.vuejs.org/guide/plugins.html)"
- name: plugins
  id: api/index#plugins
  summary: An array of plugin functions to be applied to the store
  belongs_to: API Reference
  description: |-
    ### plugins

    - type: `Array<Function>`

      An array of plugin functions to be applied to the store. The plugin simply receives the store as the only argument and can either listen to mutations (for outbound data persistence, logging, or debugging) or dispatch mutations (for inbound data e.g. websockets or observables).

      [Details](../guide/plugins)

    &nbsp;
- name: registerModule
  id: api/index#registermodule
  summary: Register a dynamic module
  belongs_to: API Reference
  description: |-
    ### registerModule

    - `registerModule(path: string | Array<string>, module: Module, options?: Object)`

    Register a dynamic module. [Details](../guide/modules#dynamic-module-registration)

    `options` can have `preserveState: true` that allows to preserve the previous state. Useful with Server Side Rendering.
- name: replaceState
  id: api/index#replacestate
  summary: Replace the store's root state
  belongs_to: API Reference
  description: |-
    ### replaceState

    - `replaceState(state: Object)`

    Replace the store's root state. Use this only for state hydration / time-travel purposes.
- name: state
  id: api/index#state-1
  summary: The root state
  belongs_to: API Reference
  description: |-
    ### state

    - type: `Object`

      The root state. Read only.

    &nbsp;
- name: State
  id: guide/state
  summary: Vuex uses a single state tree - that is, this single object contains all your application level state and serves as the "single source of truth." This also means usually you will have only one store for each application
  description: "# State\n\n## Single State Tree\n\n[Try this lesson on Scrimba](https://scrimba.com/p/pnyzgAP/cWw3Zhb)\n\nVuex uses a **single state tree** - that is, this single object contains all your application level state and serves as the \"single source of truth.\" This also means usually you will have only one store for each application. A single state tree makes it straightforward to locate a specific piece of state, and allows us to easily take snapshots of the current app state for debugging purposes.\n\nThe single state tree does not conflict with modularity - in later chapters we will discuss how to split your state and mutations into sub modules.\n\nThe data you store in Vuex follows the same rules as the `data` in a Vue instance, ie the state object must be plain. **See also:** [Vue#data](https://v3.vuejs.org/api/options-data.html#data-2).\n\n## Getting Vuex State into Vue Components\n\nSo how do we display state inside the store in our Vue components? Since Vuex stores are reactive, the simplest way to \"retrieve\" state from it is simply returning some store state from within a [computed property](https://vuejs.org/guide/computed.html):\n\n    // let's create a Counter component\n    const Counter = {\n      template: `<div>{{ count }}</div>`,\n      computed: {\n        count () {\n          return store.state.count\n        }\n      }\n    }\n\nWhenever `store.state.count` changes, it will cause the computed property to re-evaluate, and trigger associated DOM updates.\n\nHowever, this pattern causes the component to rely on the global store singleton. When using a module system, it requires importing the store in every component that uses store state, and also requires mocking when testing the component.\n\nVuex \"injects\" the store into all child components from the root component through Vue's plugin system, and will be available on them as `this.$store`. Let's update our `Counter` implementation:\n\n    const Counter = {\n      template: `<div>{{ count }}</div>`,\n      computed: {\n        count () {\n          return this.$store.state.count\n        }\n      }\n    }\n\n## The `mapState` Helper\n\n[Try this lesson on Scrimba](https://scrimba.com/p/pnyzgAP/c8Pz7BSK)\n\nWhen a component needs to make use of multiple store state properties or getters, declaring all these computed properties can get repetitive and verbose. To deal with this we can make use of the `mapState` helper which generates computed getter functions for us, saving us some keystrokes:\n\n    // in full builds helpers are exposed as Vuex.mapState\n    import { mapState } from 'vuex'\n\n    export default {\n      // ...\n      computed: mapState({\n        // arrow functions can make the code very succinct!\n        count: state => state.count,\n\n        // passing the string value 'count' is same as `state => state.count`\n        countAlias: 'count',\n\n        // to access local state with `this`, a normal function must be used\n        countPlusLocalState (state) {\n          return state.count + this.localCount\n        }\n      })\n    }\n\nWe can also pass a string array to `mapState` when the name of a mapped computed property is the same as a state sub tree name.\n\n    computed: mapState([\n      // map this.count to store.state.count\n      'count'\n    ])\n\n## Object Spread Operator\n\nNote that `mapState` returns an object. How do we use it in combination with other local computed properties? Normally, we'd have to use a utility to merge multiple objects into one so that we can pass the final object to `computed`. However with the [object spread operator](https://github.com/tc39/proposal-object-rest-spread), we can greatly simplify the syntax:\n\n    computed: {\n      localComputed () { /* ... */ },\n      // mix this into the outer object with the object spread operator\n      ...mapState({\n        // ...\n      })\n    }\n\n## Components Can Still Have Local State\n\nUsing Vuex doesn't mean you should put **all** the state in Vuex. Although putting more state into Vuex makes your state mutations more explicit and debuggable, sometimes it could also make the code more verbose and indirect. If a piece of state strictly belongs to a single component, it could be just fine leaving it as local state. You should weigh the trade-offs and make decisions that fit the development needs of your app.\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/state.md)\n\nLast Updated:\n\n[Getting Started](index)\n\n[Getters](getters)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/state.html](https://next.vuex.vuejs.org/guide/state.html)"
- name: state
  id: api/index#state
  summary: The root state object for the Vuex store
  belongs_to: API Reference
  description: |-
    ### state

    - type: `Object | Function`

      The root state object for the Vuex store. [Details](../guide/state)

      If you pass a function that returns an object, the returned object is used as the root state. This is useful when you want to reuse the state object especially for module reuse. [Details](../guide/modules#module-reuse)
- name: Store
  id: api/index#vuex-store
  summary: Creates a new store
  belongs_to: API Reference
  description: "# API Reference\n\n## Store\n\n### createStore\n\n- `createStore<S>(options: StoreOptions<S>): Store<S>`\n\n  Creates a new store.\n\n      import { createStore } from 'vuex'\n\n      const store = createStore({ ...options })\n\n## Store Constructor Options\n\n### state\n\n- type: `Object | Function`\n\n  The root state object for the Vuex store. [Details](../guide/state)\n\n  If you pass a function that returns an object, the returned object is used as the root state. This is useful when you want to reuse the state object especially for module reuse. [Details](../guide/modules#module-reuse)\n\n### mutations\n\n- type: `{ [type: string]: Function }`\n\n  Register mutations on the store. The handler function always receives `state` as the first argument (will be module local state if defined in a module), and receives a second `payload` argument if there is one.\n\n  [Details](../guide/mutations)\n\n### actions\n\n- type: `{ [type: string]: Function }`\n\n  Register actions on the store. The handler function receives a `context` object that exposes the following properties:\n\n      {\n        state,      // same as `store.state`, or local state if in modules\n        rootState,  // same as `store.state`, only in modules\n        commit,     // same as `store.commit`\n        dispatch,   // same as `store.dispatch`\n        getters,    // same as `store.getters`, or local getters if in modules\n        rootGetters // same as `store.getters`, only in modules\n      }\n\n  And also receives a second `payload` argument if there is one.\n\n  [Details](../guide/actions)\n\n### getters\n\n- type: `{ [key: string]: Function }`\n\n  Register getters on the store. The getter function receives the following arguments:\n\n      state,     // will be module local state if defined in a module.\n      getters    // same as store.getters\n\n  Specific when defined in a module\n\n      state,       // will be module local state if defined in a module.\n      getters,     // module local getters of the current module\n      rootState,   // global state\n      rootGetters  // all getters\n\n  Registered getters are exposed on `store.getters`.\n\n  [Details](../guide/getters)\n\n### modules\n\n- type: `Object`\n\n  An object containing sub modules to be merged into the store, in the shape of:\n\n      {\n        key: {\n          state,\n          namespaced?,\n          mutations?,\n          actions?,\n          getters?,\n          modules?\n        },\n        ...\n      }\n\n  Each module can contain `state` and `mutations` similar to the root options. A module's state will be attached to the store's root state using the module's key. A module's mutations and getters will only receives the module's local state as the first argument instead of the root state, and module actions' `context.state` will also point to the local state.\n\n  [Details](../guide/modules)\n\n### plugins\n\n- type: `Array<Function>`\n\n  An array of plugin functions to be applied to the store. The plugin simply receives the store as the only argument and can either listen to mutations (for outbound data persistence, logging, or debugging) or dispatch mutations (for inbound data e.g. websockets or observables).\n\n  [Details](../guide/plugins)\n\n### strict\n\n- type: `boolean`\n\n- default: `false`\n\n  Force the Vuex store into strict mode. In strict mode any mutations to Vuex state outside of mutation handlers will throw an Error.\n\n  [Details](../guide/strict)\n\n### devtools\n\n- type: `boolean`\n\n  Turn the devtools on or off for a particular Vuex instance. For instance, passing `false` tells the Vuex store to not subscribe to devtools plugin. Useful when you have multiple stores on a single page.\n\n      {\n        devtools: false\n      }\n\n## Store Instance Properties\n\n### state\n\n- type: `Object`\n\n  The root state. Read only.\n\n### getters\n\n- type: `Object`\n\n  Exposes registered getters. Read only.\n\n## Store Instance Methods\n\n### commit\n\n- `commit(type: string, payload?: any, options?: Object)`\n- `commit(mutation: Object, options?: Object)`\n\nCommit a mutation. `options` can have `root: true` that allows to commit root mutations in [namespaced modules](../guide/modules#namespacing). [Details](../guide/mutations)\n\n### dispatch\n\n- `dispatch(type: string, payload?: any, options?: Object): Promise<any>`\n- `dispatch(action: Object, options?: Object): Promise<any>`\n\nDispatch an action. `options` can have `root: true` that allows to dispatch root actions in [namespaced modules](../guide/modules#namespacing). Returns a Promise that resolves all triggered action handlers. [Details](../guide/actions)\n\n### replaceState\n\n- `replaceState(state: Object)`\n\nReplace the store's root state. Use this only for state hydration / time-travel purposes.\n\n### watch\n\n- `watch(fn: Function, callback: Function, options?: Object): Function`\n\nReactively watch `fn`'s return value, and call the callback when the value changes. `fn` receives the store's state as the first argument, and getters as the second argument. Accepts an optional options object that takes the same options as [Vue's `vm.$watch` method](https://vuejs.org/v2/api/#vm-watch).\n\nTo stop watching, call the returned unwatch function.\n\n### subscribe\n\n- `subscribe(handler: Function, options?: Object): Function`\n\nSubscribe to store mutations. The `handler` is called after every mutation and receives the mutation descriptor and post-mutation state as arguments.\n\n    const unsubscribe = store.subscribe((mutation, state) => {\n      console.log(mutation.type)\n      console.log(mutation.payload)\n    })\n\n    // you may call unsubscribe to stop the subscription\n    unsubscribe()\n\nBy default, new handler is added to the end of the chain, so it will be executed after other handlers that were added before. This can be overridden by adding `prepend: true` to `options`, which will add the handler to the beginning of the chain.\n\n    store.subscribe(handler, { prepend: true })\n\nThe `subscribe` method will return an `unsubscribe` function, which should be called when the subscription is no longer needed. For example, you might subscribe to a Vuex Module and unsubscribe when you unregister the module. Or you might call `subscribe` from inside a Vue Component and then destroy the component later. In these cases, you should remember to unsubscribe the subscription manually.\n\nMost commonly used in plugins. [Details](../guide/plugins)\n\n### subscribeAction\n\n- `subscribeAction(handler: Function, options?: Object): Function`\n\nSubscribe to store actions. The `handler` is called for every dispatched action and receives the action descriptor and current store state as arguments. The `subscribe` method will return an `unsubscribe` function, which should be called when the subscription is no longer needed. For example, when unregistering a Vuex module or before destroying a Vue component.\n\n    const unsubscribe = store.subscribeAction((action, state) => {\n      console.log(action.type)\n      console.log(action.payload)\n    })\n\n    // you may call unsubscribe to stop the subscription\n    unsubscribe()\n\nBy default, new handler is added to the end of the chain, so it will be executed after other handlers that were added before. This can be overridden by adding `prepend: true` to `options`, which will add the handler to the beginning of the chain.\n\n    store.subscribeAction(handler, { prepend: true })\n\nThe `subscribeAction` method will return an `unsubscribe` function, which should be called when the subscription is no longer needed. For example, you might subscribe to a Vuex Module and unsubscribe when you unregister the module. Or you might call `subscribeAction` from inside a Vue Component and then destroy the component later. In these cases, you should remember to unsubscribe the subscription manually.\n\n`subscribeAction` can also specify whether the subscribe handler should be called *before* or *after* an action dispatch (the default behavior is *before*):\n\n    store.subscribeAction({\n      before: (action, state) => {\n        console.log(`before action ${action.type}`)\n      },\n      after: (action, state) => {\n        console.log(`after action ${action.type}`)\n      }\n    })\n\n`subscribeAction` can also specify an `error` handler to catch an error thrown when an action is dispatched. The function will receive an `error` object as the third argument.\n\n    store.subscribeAction({\n      error: (action, state, error) => {\n        console.log(`error action ${action.type}`)\n        console.error(error)\n      }\n    })\n\nThe `subscribeAction` method is most commonly used in plugins. [Details](../guide/plugins)\n\n### registerModule\n\n- `registerModule(path: string | Array<string>, module: Module, options?: Object)`\n\nRegister a dynamic module. [Details](../guide/modules#dynamic-module-registration)\n\n`options` can have `preserveState: true` that allows to preserve the previous state. Useful with Server Side Rendering.\n\n### unregisterModule\n\n- `unregisterModule(path: string | Array<string>)`\n\nUnregister a dynamic module. [Details](../guide/modules#dynamic-module-registration)\n\n### hasModule\n\n- `hasModule(path: string | Array<string>): boolean`\n\n  Check if the module with the given name is already registered. [Details](../guide/modules#dynamic-module-registration)\n\n### hotUpdate\n\n- `hotUpdate(newOptions: Object)`\n\nHot swap new actions and mutations. [Details](../guide/hot-reload)\n\n## Component Binding Helpers\n\n### mapState\n\n- `mapState(namespace?: string, map: Array<string> | Object<string | function>): Object`\n\nCreate component computed options that return the sub tree of the Vuex store. [Details](../guide/state#the-mapstate-helper)\n\nThe first argument can optionally be a namespace string. [Details](../guide/modules#binding-helpers-with-namespace)\n\nThe second object argument's members can be a function. `function(state: any)`\n\n### mapGetters\n\n- `mapGetters(namespace?: string, map: Array<string> | Object<string>): Object`\n\nCreate component computed options that return the evaluated value of a getter. [Details](../guide/getters#the-mapgetters-helper)\n\nThe first argument can optionally be a namespace string. [Details](../guide/modules#binding-helpers-with-namespace)\n\n### mapActions\n\n- `mapActions(namespace?: string, map: Array<string> | Object<string | function>): Object`\n\nCreate component methods options that dispatch an action. [Details](../guide/actions#dispatching-actions-in-components)\n\nThe first argument can optionally be a namespace string. [Details](../guide/modules#binding-helpers-with-namespace)\n\nThe second object argument's members can be a function. `function(dispatch: function, ...args: any[])`\n\n### mapMutations\n\n- `mapMutations(namespace?: string, map: Array<string> | Object<string | function>): Object`\n\nCreate component methods options that commit a mutation. [Details](../guide/mutations#committing-mutations-in-components)\n\nThe first argument can optionally be a namespace string. [Details](../guide/modules#binding-helpers-with-namespace)\n\nThe second object argument's members can be a function. `function(commit: function, ...args: any[])`\n\n### createNamespacedHelpers\n\n- `createNamespacedHelpers(namespace: string): Object`\n\nCreate namespaced component binding helpers. The returned object contains `mapState`, `mapGetters`, `mapActions` and `mapMutations` that are bound with the given namespace. [Details](../guide/modules#binding-helpers-with-namespace)\n\n## Composable Functions\n\n### useStore\n\n- `useStore<S = any>(injectKey?: InjectionKey<Store<S>> | string): Store<S>;`\n\n  Fetches the injected store when called inside the `setup` hook. When using the Composition API, you can retrieve the store by calling this method.\n\n      import { useStore } from 'vuex'\n\n      export default {\n        setup () {\n          const store = useStore()\n        }\n      }\n\n  TypeScript users can use an injection key to retrieve a typed store. In order for this to work, you must define the injection key and pass it along with the store when installing the store instance to the Vue app.\n\n  First, declare the injection key using Vue's `InjectionKey` interface.\n\n      // store.ts\n      import { InjectionKey } from 'vue'\n      import { createStore, Store } from 'vuex'\n\n      export interface State {\n        count: number\n      }\n\n      export const key: InjectionKey<Store<State>> = Symbol()\n\n      export const store = createStore<State>({\n        state: {\n          count: 0\n        }\n      })\n\n  Then, pass the defined key as the second argument for the `app.use` method.\n\n      // main.ts\n      import { createApp } from 'vue'\n      import { store, key } from './store'\n\n      const app = createApp({ ... })\n\n      app.use(store, key)\n\n      app.mount('#app')\n\n  Finally, you can pass the key to the `useStore` method to retrieve the typed store instance.\n\n      // in a vue component\n      import { useStore } from 'vuex'\n      import { key } from './store'\n\n      export default {\n        setup () {\n          const store = useStore(key)\n\n          store.state.count // typed as number\n        }\n      }\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/api/index.md)\n\nLast Updated:\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/api/index.html](https://next.vuex.vuejs.org/api/index.html)"
- name: strict
  id: api/index#strict
  summary: Force the Vuex store into strict mode
  belongs_to: API Reference
  description: |-
    ### strict

    - type: `boolean`

    - default: `false`

      Force the Vuex store into strict mode. In strict mode any mutations to Vuex state outside of mutation handlers will throw an Error.

      [Details](../guide/strict)

    &nbsp;
- name: Strict Mode
  id: guide/strict
  summary: In strict mode, whenever Vuex state is mutated outside of mutation handlers, an error will be thrown
  description: "# Strict Mode\n\nTo enable strict mode, simply pass in `strict: true` when creating a Vuex store:\n\n    const store = createStore({\n      // ...\n      strict: true\n    })\n\nIn strict mode, whenever Vuex state is mutated outside of mutation handlers, an error will be thrown. This ensures that all state mutations can be explicitly tracked by debugging tools.\n\n## Development vs. Production\n\n**Do not enable strict mode when deploying for production!** Strict mode runs a synchronous deep watcher on the state tree for detecting inappropriate mutations, and it can be quite expensive when you make large amount of mutations to the state. Make sure to turn it off in production to avoid the performance cost.\n\nSimilar to plugins, we can let the build tools handle that:\n\n    const store = createStore({\n      // ...\n      strict: process.env.NODE_ENV !== 'production'\n    })\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/strict.md)\n\nLast Updated:\n\n[Plugins](plugins)\n\n[Form Handling](forms)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/strict.html](https://next.vuex.vuejs.org/guide/strict.html)"
- name: subscribe
  id: api/index#subscribe
  summary: Subscribe to store mutations
  belongs_to: API Reference
  description: "### subscribe\n\n- `subscribe(handler: Function, options?: Object): Function`\n\nSubscribe to store mutations. The `handler` is called after every mutation and receives the mutation descriptor and post-mutation state as arguments.\n\n                  const unsubscribe = store.subscribe((mutation, state) => {\n      console.log(mutation.type)\n      console.log(mutation.payload)\n    })\n\n    // you may call unsubscribe to stop the subscription\n    unsubscribe()\n\n                \n\nBy default, new handler is added to the end of the chain, so it will be executed after other handlers that were added before. This can be overridden by adding `prepend: true` to `options`, which will add the handler to the beginning of the chain.\n\n                  store.subscribe(handler, { prepend: true })\n\n                \n\nThe `subscribe` method will return an `unsubscribe` function, which should be called when the subscription is no longer needed. For example, you might subscribe to a Vuex Module and unsubscribe when you unregister the module. Or you might call `subscribe` from inside a Vue Component and then destroy the component later. In these cases, you should remember to unsubscribe the subscription manually.\n\nMost commonly used in plugins. [Details](../guide/plugins)"
- name: subscribeAction
  id: api/index#subscribeaction
  summary: Subscribe to store actions
  belongs_to: API Reference
  description: "### subscribeAction\n\n- `subscribeAction(handler: Function, options?: Object): Function`\n\nSubscribe to store actions. The `handler` is called for every dispatched action and receives the action descriptor and current store state as arguments. The `subscribe` method will return an `unsubscribe` function, which should be called when the subscription is no longer needed. For example, when unregistering a Vuex module or before destroying a Vue component.\n\n                  const unsubscribe = store.subscribeAction((action, state) => {\n      console.log(action.type)\n      console.log(action.payload)\n    })\n\n    // you may call unsubscribe to stop the subscription\n    unsubscribe()\n\n                \n\nBy default, new handler is added to the end of the chain, so it will be executed after other handlers that were added before. This can be overridden by adding `prepend: true` to `options`, which will add the handler to the beginning of the chain.\n\n                  store.subscribeAction(handler, { prepend: true })\n\n                \n\nThe `subscribeAction` method will return an `unsubscribe` function, which should be called when the subscription is no longer needed. For example, you might subscribe to a Vuex Module and unsubscribe when you unregister the module. Or you might call `subscribeAction` from inside a Vue Component and then destroy the component later. In these cases, you should remember to unsubscribe the subscription manually.\n\n`subscribeAction` can also specify whether the subscribe handler should be called *before* or *after* an action dispatch (the default behavior is *before*):\n\n                  store.subscribeAction({\n      before: (action, state) => {\n        console.log(`before action ${action.type}`)\n      },\n      after: (action, state) => {\n        console.log(`after action ${action.type}`)\n      }\n    })\n\n                \n\n`subscribeAction` can also specify an `error` handler to catch an error thrown when an action is dispatched. The function will receive an `error` object as the third argument.\n\n                  store.subscribeAction({\n      error: (action, state, error) => {\n        console.log(`error action ${action.type}`)\n        console.error(error)\n      }\n    })\n\n                \n\nThe `subscribeAction` method is most commonly used in plugins. [Details](../guide/plugins)"
- name: Testing
  id: guide/testing
  summary: The main parts we want to unit test in Vuex are mutations and actions
  description: "# Testing\n\n[Try this lesson on Scrimba](https://scrimba.com/p/pnyzgAP/cPGkpJhq)\n\nThe main parts we want to unit test in Vuex are mutations and actions.\n\n## Testing Mutations\n\nMutations are very straightforward to test, because they are just functions that completely rely on their arguments. One trick is that if you are using ES2015 modules and put your mutations inside your `store.js` file, in addition to the default export, you should also export the mutations as a named export:\n\n    const state = { ... }\n\n    // export `mutations` as a named export\n    export const mutations = { ... }\n\n    export default createStore({\n      state,\n      mutations\n    })\n\nExample testing a mutation using Mocha + Chai (you can use any framework/assertion libraries you like):\n\n    // mutations.js\n    export const mutations = {\n      increment: state => state.count++\n    }\n\n    // mutations.spec.js\n    import { expect } from 'chai'\n    import { mutations } from './store'\n\n    // destructure assign `mutations`\n    const { increment } = mutations\n\n    describe('mutations', () => {\n      it('INCREMENT', () => {\n        // mock state\n        const state = { count: 0 }\n        // apply mutation\n        increment(state)\n        // assert result\n        expect(state.count).to.equal(1)\n      })\n    })\n\n## Testing Actions\n\nActions can be a bit more tricky because they may call out to external APIs. When testing actions, we usually need to do some level of mocking - for example, we can abstract the API calls into a service and mock that service inside our tests. In order to easily mock dependencies, we can use webpack and [inject-loader](https://github.com/plasticine/inject-loader) to bundle our test files.\n\nExample testing an async action:\n\n    // actions.js\n    import shop from '../api/shop'\n\n    export const getAllProducts = ({ commit }) => {\n      commit('REQUEST_PRODUCTS')\n      shop.getProducts(products => {\n        commit('RECEIVE_PRODUCTS', products)\n      })\n    }\n\n    // actions.spec.js\n\n    // use require syntax for inline loaders.\n    // with inject-loader, this returns a module factory\n    // that allows us to inject mocked dependencies.\n    import { expect } from 'chai'\n    const actionsInjector = require('inject-loader!./actions')\n\n    // create the module with our mocks\n    const actions = actionsInjector({\n      '../api/shop': {\n        getProducts (cb) {\n          setTimeout(() => {\n            cb([ /* mocked response */ ])\n          }, 100)\n        }\n      }\n    })\n\n    // helper for testing action with expected mutations\n    const testAction = (action, payload, state, expectedMutations, done) => {\n      let count = 0\n\n      // mock commit\n      const commit = (type, payload) => {\n        const mutation = expectedMutations[count]\n\n        try {\n          expect(type).to.equal(mutation.type)\n          expect(payload).to.deep.equal(mutation.payload)\n        } catch (error) {\n          done(error)\n        }\n\n        count++\n        if (count >= expectedMutations.length) {\n          done()\n        }\n      }\n\n      // call the action with mocked store and arguments\n      action({ commit, state }, payload)\n\n      // check if no mutations should have been dispatched\n      if (expectedMutations.length === 0) {\n        expect(count).to.equal(0)\n        done()\n      }\n    }\n\n    describe('actions', () => {\n      it('getAllProducts', done => {\n        testAction(actions.getAllProducts, null, {}, [\n          { type: 'REQUEST_PRODUCTS' },\n          { type: 'RECEIVE_PRODUCTS', payload: { /* mocked response */ } }\n        ], done)\n      })\n    })\n\nIf you have spies available in your testing environment (for example via [Sinon.JS](http://sinonjs.org/)), you can use them instead of the `testAction` helper:\n\n    describe('actions', () => {\n      it('getAllProducts', () => {\n        const commit = sinon.spy()\n        const state = {}\n\n        actions.getAllProducts({ commit, state })\n\n        expect(commit.args).to.deep.equal([\n          ['REQUEST_PRODUCTS'],\n          ['RECEIVE_PRODUCTS', { /* mocked response */ }]\n        ])\n      })\n    })\n\n## Testing Getters\n\nIf your getters have complicated computation, it is worth testing them. Getters are also very straightforward to test for the same reason as mutations.\n\nExample testing a getter:\n\n    // getters.js\n    export const getters = {\n      filteredProducts (state, { filterCategory }) {\n        return state.products.filter(product => {\n          return product.category === filterCategory\n        })\n      }\n    }\n\n    // getters.spec.js\n    import { expect } from 'chai'\n    import { getters } from './getters'\n\n    describe('getters', () => {\n      it('filteredProducts', () => {\n        // mock state\n        const state = {\n          products: [\n            { id: 1, title: 'Apple', category: 'fruit' },\n            { id: 2, title: 'Orange', category: 'fruit' },\n            { id: 3, title: 'Carrot', category: 'vegetable' }\n          ]\n        }\n        // mock getter\n        const filterCategory = 'fruit'\n\n        // get the result from the getter\n        const result = getters.filteredProducts(state, { filterCategory })\n\n        // assert the result\n        expect(result).to.deep.equal([\n          { id: 1, title: 'Apple', category: 'fruit' },\n          { id: 2, title: 'Orange', category: 'fruit' }\n        ])\n      })\n    })\n\n## Running Tests\n\nIf your mutations and actions are written properly, the tests should have no direct dependency on Browser APIs after proper mocking. Thus you can simply bundle the tests with webpack and run it directly in Node. Alternatively, you can use `mocha-loader` or Karma + `karma-webpack` to run the tests in real browsers.\n\n### Running in Node\n\nCreate the following webpack config (together with proper [`.babelrc`](https://babeljs.io/docs/usage/babelrc/)):\n\n    // webpack.config.js\n    module.exports = {\n      entry: './test.js',\n      output: {\n        path: __dirname,\n        filename: 'test-bundle.js'\n      },\n      module: {\n        loaders: [\n          {\n            test: /\\.js$/,\n            loader: 'babel-loader',\n            exclude: /node_modules/\n          }\n        ]\n      }\n    }\n\nThen:\n\n    webpack\n    mocha test-bundle.js\n\n### Running in Browser\n\n1.  Install `mocha-loader`.\n2.  Change the `entry` from the webpack config above to `'mocha-loader!babel-loader!./test.js'`.\n3.  Start `webpack-dev-server` using the config.\n4.  Go to `localhost:8080/webpack-dev-server/test-bundle`.\n\n### Running in Browser with Karma + karma-webpack\n\nConsult the setup in [vue-loader documentation](https://vue-loader.vuejs.org/en/workflow/testing.html).\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/testing.md)\n\nLast Updated:\n\n[Form Handling](forms)\n\n[Hot Reloading](hot-reload)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/testing.html](https://next.vuex.vuejs.org/guide/testing.html)"
- name: TypeScript Support
  id: guide/typescript-support
  summary: Vuex provides its typings so you can use TypeScript to write a store definition
  description: "# TypeScript Support\n\nVuex provides its typings so you can use TypeScript to write a store definition. You don't need any special TypeScript configuration for Vuex. Please follow [Vue's basic TypeScript setup](https://v3.vuejs.org/guide/typescript-support.html) to configure your project.\n\nHowever, if you're writing your Vue components in TypeScript, there're a few steps to follow that require for you to correctly provide typings for a store.\n\n## Typing `$store` Property in Vue Component\n\nVuex doesn't provide typings for `this.$store` property out of the box. When used with TypeScript, you must declare your own module augmentation.\n\nTo do so, declare custom typings for Vue's `ComponentCustomProperties` by adding a declaration file in your project folder:\n\n    // vuex.d.ts\n    import { Store } from 'vuex'\n\n    declare module '@vue/runtime-core' {\n      // declare your own store states\n      interface State {\n        count: number\n      }\n\n      // provide typings for `this.$store`\n      interface ComponentCustomProperties {\n        $store: Store<State>\n      }\n    }\n\n## Typing `useStore` Composition Function\n\nWhen you're writing your Vue component in Composition API, you will most likely want `useStore` to return the typed store. For `useStore` to correctly return the typed store, you must:\n\n1.  Define the typed `InjectionKey`.\n2.  Provide the typed `InjectionKey` when installing a store to the Vue app.\n3.  Pass the typed `InjectionKey` to the `useStore` method.\n\nLet's tackle this step by step. First, define the key using Vue's `InjectionKey` interface along with your own store typing definition:\n\n    // store.ts\n    import { InjectionKey } from 'vue'\n    import { createStore, Store } from 'vuex'\n\n    // define your typings for the store state\n    export interface State {\n      count: number\n    }\n\n    // define injection key\n    export const key: InjectionKey<Store<State>> = Symbol()\n\n    export const store = createStore<State>({\n      state: {\n        count: 0\n      }\n    })\n\nNext, pass the defined injection key when installing the store to the Vue app:\n\n    // main.ts\n    import { createApp } from 'vue'\n    import { store, key } from './store'\n\n    const app = createApp({ ... })\n\n    // pass the injection key\n    app.use(store, key)\n\n    app.mount('#app')\n\nFinally, you can pass the key to the `useStore` method to retrieve the typed store.\n\n    // in a vue component\n    import { useStore } from 'vuex'\n    import { key } from './store'\n\n    export default {\n      setup () {\n        const store = useStore(key)\n\n        store.state.count // typed as number\n      }\n    }\n\nUnder the hood, Vuex installs the store to the Vue app using Vue's [Provide/Inject](https://v3.vuejs.org/api/composition-api.html#provide-inject) feature which is why the injection key is an important factor.\n\n### Simplifying `useStore` usage\n\nHaving to import `InjectionKey` and passing it to `useStore` everywhere it's used can quickly become a repetitive task. To simplify matters, you can define your own composable function to retrieve a typed store:\n\n    // store.ts\n    import { InjectionKey } from 'vue'\n    import { createStore, useStore as baseUseStore, Store } from 'vuex'\n\n    export interface State {\n      count: number\n    }\n\n    export const key: InjectionKey<Store<State>> = Symbol()\n\n    export const store = createStore<State>({\n      state: {\n        count: 0\n      }\n    })\n\n    // define your own `useStore` composition function\n    export function useStore () {\n      return baseUseStore(key)\n    }\n\nNow, by importing your own composable function, you can retrieve the typed store **without** having to provide the injection key and its typing:\n\n    // in a vue component\n    import { useStore } from './store'\n\n    export default {\n      setup () {\n        const store = useStore()\n\n        store.state.count // typed as number\n      }\n    }\n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/guide/typescript-support.md)\n\nLast Updated:\n\n[Hot Reloading](hot-reload)\n\n[Migrating to 4.0 from 3.x](migrating-to-4-0-from-3-x)\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/guide/typescript-support.html](https://next.vuex.vuejs.org/guide/typescript-support.html)"
- name: unregisterModule
  id: api/index#unregistermodule
  summary: Unregister a dynamic module
  belongs_to: API Reference
  description: |-
    ### unregisterModule

    - `unregisterModule(path: string | Array<string>)`

    Unregister a dynamic module. [Details](../guide/modules#dynamic-module-registration)
- name: useStore
  id: api/index#usestore
  summary: Fetches the injected store when called inside the setup hook
  belongs_to: API Reference
  description: "### useStore\n\n- `useStore<S = any>(injectKey?: InjectionKey<Store<S>> | string): Store<S>;`\n\n  Fetches the injected store when called inside the `setup` hook. When using the Composition API, you can retrieve the store by calling this method.\n\n                        import{ useStore } from 'vuex'\n\n      export default {\n        setup () {\n          const store = useStore()\n        }\n      }\n\n                      \n\n  TypeScript users can use an injection key to retrieve a typed store. In order for this to work, you must define the injection key and pass it along with the store when installing the store instance to the Vue app.\n\n  First, declare the injection key using Vue's `InjectionKey` interface.\n\n                        // store.tsimport{ InjectionKey } from 'vue'\n      import { createStore, Store } from 'vuex'\n\n      export interface State {\n        count: number\n      }\n\n      export const key: InjectionKey<Store<State>> = Symbol()\n\n      export const store = createStore<State>({\n        state: {\n          count: 0\n        }\n      })\n\n                      \n\n  Then, pass the defined key as the second argument for the `app.use` method.\n\n                        // main.tsimport{ createApp } from 'vue'\n      import { store, key } from './store'\n\n      const app = createApp({ ... })\n\n      app.use(store, key)\n\n      app.mount('#app')\n\n                      \n\n  Finally, you can pass the key to the `useStore` method to retrieve the typed store instance.\n\n                        // in a vue componentimport{ useStore } from 'vuex'\n      import { key } from './store'\n\n      export default {\n        setup () {\n          const store = useStore(key)\n\n          store.state.count // typed as number\n        }\n      }\n\n                      \n\n[Edit this page on GitHub](https://github.com/vuejs/vuex/edit/4.0/docs/api/index.md)\n\nLast Updated:\n\n© 2015–present Evan You  \nLicensed under the MIT License.  \n[https://next.vuex.vuejs.org/api/index.html](https://next.vuex.vuejs.org/api/index.html)"
- name: watch
  id: api/index#watch
  summary: Reactively watch fn's return value, and call the callback when the value changes
  belongs_to: API Reference
  description: |-
    ### watch

    - `watch(fn: Function, callback: Function, options?: Object): Function`

    Reactively watch `fn`'s return value, and call the callback when the value changes. `fn` receives the store's state as the first argument, and getters as the second argument. Accepts an optional options object that takes the same options as [Vue's `vm.$watch` method](https://vuejs.org/v2/api/#vm-watch).

    To stop watching, call the returned unwatch function.
