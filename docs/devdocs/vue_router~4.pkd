---
name: Vue Router
slug: vue_router~4
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: '4'
copyright: |-
  © 2013–present Evan You
  Licensed under the MIT License.
  https://next.router.vuejs.org/index.html
homepage: https://router.vuejs.org

---
- name: $route
  id: api/index#the-route-object
  summary: Denotes the target route of the link
  belongs_to: API Reference
  description: "# API Reference\n\n## `<router-link>` Props\n\n### to\n\n- **Type**: [`RouteLocationRaw`](#routelocationraw)\n\n- **Details**:\n\n  Denotes the target route of the link. When clicked, the value of the `to` prop will be passed to `router.push()` internally, so it can either be a `string` or a [route location object](#routelocationraw).\n\n    <!-- literal string -->\n    <router-link to=\"/home\">Home</router-link>\n    <!-- renders to -->\n    <a href=\"/home\">Home</a>\n\n    <!-- javascript expression using `v-bind` -->\n    <router-link :to=\"'/home'\">Home</router-link>\n\n    <!-- same as above -->\n    <router-link :to=\"{ path: '/home' }\">Home</router-link>\n\n    <!-- named route -->\n    <router-link :to=\"{ name: 'user', params: { userId: '123' }}\">User</router-link>\n\n    <!-- with query, resulting in `/register?plan=private` -->\n    <router-link :to=\"{ path: '/register', query: { plan: 'private' }}\">\n      Register\n    </router-link>\n\n### replace\n\n- **Type**: `boolean`\n\n- **Default**: `false`\n\n- **Details**:\n\n  Setting `replace` prop will call `router.replace()` instead of `router.push()` when clicked, so the navigation will not leave a history record.\n\n    <router-link to=\"/abc\" replace></router-link>\n\n### active-class\n\n- **Type**: `string`\n\n- **Default**: `\"router-link-active\"` (or global [`linkActiveClass`](#linkactiveclass))\n\n- **Details**:\n\n  Class to apply on the rendered `<a>` when the link is active.\n\n### aria-current-value\n\n- **Type**: `'page' | 'step' | 'location' | 'date' | 'time' | 'true' | 'false'` (`string`)\n\n- **Default**: `\"page\"`\n\n- **Details**:\n\n  Value passed to the attribute `aria-current` when the link is exactly active.\n\n### custom\n\n- **Type**: `boolean`\n\n- **Default**: `false`\n\n- **Details**:\n\n  Whether `<router-link>` should not wrap its content in an `<a>` element. Useful when using [`v-slot`](#router-link-s-v-slot) to create a custom RouterLink. By default, `<router-link>` will render its content wrapped in an `<a>` element, even when using `v-slot`. Passing the `custom` prop, removes that behavior.\n\n- **Examples**:\n\n      <router-link to=\"/home\" custom v-slot=\"{ navigate, href, route }\">\n        <a :href=\"href\" @click=\"navigate\">{{ route.fullPath }}</a>\n      </router-link>\n\n  Renders `<a href=\"/home\">/home</a>`.\n\n      <router-link to=\"/home\" v-slot=\"{ route }\">\n        <span>{{ route.fullPath }}</span>\n      </router-link>\n\n  Renders `<a href=\"/home\"><span>/home</span></a>`.\n\n### exact-active-class\n\n- **Type**: `string`\n\n- **Default**: `\"router-link-exact-active\"` (or global [`linkExactActiveClass`](#linkexactactiveclass))\n\n- **Details**:\n\n  Class to apply on the rendered `<a>` when the link is exact active.\n\n## `<router-link>`'s `v-slot`\n\n`<router-link>` exposes a low level customization through a [scoped slot](https://v3.vuejs.org/guide/component-slots.html#scoped-slots). This is a more advanced API that primarily targets library authors but can come in handy for developers as well, to build a custom component like a *NavLink* or other.\n\n**TIP**\n\nRemember to pass the `custom` option to `<router-link>` to prevent it from wrapping its content inside of an `<a>` element.\n\n    <router-link\n      to=\"/about\"\n      custom\n      v-slot=\"{ href, route, navigate, isActive, isExactActive }\"\n    >\n      <NavLink :active=\"isActive\" :href=\"href\" @click=\"navigate\">\n        {{ route.fullPath }}\n      </NavLink>\n    </router-link>\n\n- `href`: resolved url. This would be the `href` attribute of an `<a>` element. It contains the `base` if any was provided.\n- `route`: resolved normalized location.\n- `navigate`: function to trigger the navigation. **It will automatically prevent events when necessary**, the same way `router-link` does, e.g. `ctrl` or `cmd` + click will still be ignored by `navigate`.\n- `isActive`: `true` if the [active class](#active-class) should be applied. Allows to apply an arbitrary class.\n- `isExactActive`: `true` if the [exact active class](#exact-active-class) should be applied. Allows to apply an arbitrary class.\n\n### Example: Applying Active Class to Outer Element\n\nSometimes we may want the active class to be applied to an outer element rather than the `<a>` element itself, in that case, you can wrap that element inside a `router-link` and use the `v-slot` properties to create your link:\n\n    <router-link\n      to=\"/foo\"\n      custom\n      v-slot=\"{ href, route, navigate, isActive, isExactActive }\"\n    >\n      <li\n        :class=\"[isActive && 'router-link-active', isExactActive && 'router-link-exact-active']\"\n      >\n        <a :href=\"href\" @click=\"navigate\">{{ route.fullPath }}</a>\n      </li>\n    </router-link>\n\n**TIP**\n\nIf you add a `target=\"_blank\"` to your `a` element, you must omit the `@click=\"navigate\"` handler.\n\n## `<router-view>` Props\n\n### name\n\n- **Type**: `string`\n\n- **Default**: `\"default\"`\n\n- **Details**:\n\n  When a `<router-view>` has a `name`, it will render the component with the corresponding name in the matched route record's `components` option.\n\n- **See Also**: [Named Views](../guide/essentials/named-views)\n\n### route\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  A route location that has all of its component resolved (if any was lazy loaded) so it can be displayed.\n\n## `<router-view>`'s `v-slot`\n\n`<router-view>` exposes a `v-slot` API mainly to wrap your route components with `<transition>` and `<keep-alive>` components.\n\n    <router-view v-slot=\"{ Component, route }\">\n      <transition :name=\"route.meta.transition || 'fade'\" mode=\"out-in\">\n        <keep-alive>\n          <suspense>\n            <template #default>\n              <component\n                :is=\"Component\"\n                :key=\"route.meta.usePathKey ? route.path : undefined\"\n              />\n            </template>\n            <template #fallback> Loading... </template>\n          </suspense>\n        </keep-alive>\n      </transition>\n    </router-view>\n\n- `Component`: VNodes to be passed to a `<component>`'s `is` prop.\n- `route`: resolved normalized [route location](#routelocationnormalized).\n\n## createRouter\n\nCreates a Router instance that can be used by a Vue app. Check the [`RouterOptions`](#routeroptions) for a list of all the properties that can be passed.\n\n**Signature:**\n\n    export declare function createRouter(options: RouterOptions): Router\n\n### Parameters\n\n| Parameter | Type                            | Description                      |\n|-----------|---------------------------------|----------------------------------|\n| options   | [RouterOptions](#routeroptions) | Options to initialize the router |\n\n## createWebHistory\n\nCreates an HTML5 history. Most common history for single page applications. The application must be served through the http protocol.\n\n**Signature:**\n\n    export declare function createWebHistory(base?: string): RouterHistory\n\n### Parameters\n\n| Parameter | Type     | Description                                                                                                           |\n|-----------|----------|-----------------------------------------------------------------------------------------------------------------------|\n| base      | `string` | optional base to provide. Useful when the application is hosted inside of a folder like `https://example.com/folder/` |\n\n### Examples\n\n    createWebHistory() // No base, the app is hosted at the root of the domain `https://example.com`\n    createWebHistory('/folder/') // gives a url of `https://example.com/folder/`\n\n## createWebHashHistory\n\nCreates a hash history. Useful for web applications with no host (e.g. `file://`) or when configuring a server to handle any URL isn't an option. **Note you should use [`createWebHistory`](#createwebhistory) if SEO matters to you**.\n\n**Signature:**\n\n    export declare function createWebHashHistory(base?: string): RouterHistory\n\n### Parameters\n\n| Parameter | Type     | Description                                                                                                                                                                                                                                                                                                                                                       |\n|-----------|----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| base      | `string` | optional base to provide. Defaults to `location.pathname + location.search`. If there is a `<base>` tag in the `head`, its value will be ignored in favor of this parameter **but note it affects all the history.pushState() calls**, meaning that if you use a `<base>` tag, its `href` value **has to match this parameter** (ignoring anything after the `#`) |\n\n### Examples\n\n    // at https://example.com/folder\n    createWebHashHistory() // gives a url of `https://example.com/folder#`\n    createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\n    // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\n    createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\n    // you should avoid doing this because it changes the original url and breaks copying urls\n    createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\n\n    // at file:///usr/etc/folder/index.html\n    // for locations with no `host`, the base is ignored\n    createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\n\n## createMemoryHistory\n\nCreates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere. If the user is not on a browser context, it's up to them to replace that location with the starter location by either calling `router.push()` or `router.replace()`.\n\n**Signature:**\n\n    export declare function createMemoryHistory(base?: string): RouterHistory\n\n### Parameters\n\n| Parameter | Type     | Description                               |\n|-----------|----------|-------------------------------------------|\n| base      | `string` | Base applied to all urls, defaults to '/' |\n\n### Returns\n\nA history object that can be passed to the router constructor\n\n## NavigationFailureType\n\nEnumeration with all possible types for navigation failures. Can be passed to [isNavigationFailure](#isnavigationfailure) to check for specific failures. **Never use any of the numerical values**, always use the variables like `NavigationFailureType.aborted`.\n\n**Signature:**\n\n    export declare enum NavigationFailureType\n\n### Members\n\n| Member     | Value | Description                                                                                                                      |\n|------------|-------|----------------------------------------------------------------------------------------------------------------------------------|\n| aborted    | 4     | An aborted navigation is a navigation that failed because a navigation guard returned `false` or called `next(false)`            |\n| cancelled  | 8     | A cancelled navigation is a navigation that failed because a more recent navigation finished started (not necessarily finished). |\n| duplicated | 16    | A duplicated navigation is a navigation that failed because it was initiated while already being at the exact same location.     |\n\n## START_LOCATION\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  Initial route location where the router is. Can be used in navigation guards to differentiate the initial navigation.\n\n      import { START_LOCATION } from 'vue-router'\n\n      router.beforeEach((to, from) => {\n        if (from === START_LOCATION) {\n          // initial navigation\n        }\n      })\n\n## Composition API\n\n### onBeforeRouteLeave\n\nAdd a navigation guard that triggers whenever the component for the current location is about to be left. Similar to `beforeRouteLeave` but can be used in any component. The guard is removed when the component is unmounted.\n\n**Signature:**\n\n    export declare function onBeforeRouteLeave(leaveGuard: NavigationGuard): void\n\n#### Parameters\n\n| Parameter  | Type                                  | Description             |\n|------------|---------------------------------------|-------------------------|\n| leaveGuard | [`NavigationGuard`](#navigationguard) | Navigation guard to add |\n\n### onBeforeRouteUpdate\n\nAdd a navigation guard that triggers whenever the current location is about to be updated. Similar to `beforeRouteUpdate` but can be used in any component. The guard is removed when the component is unmounted.\n\n**Signature:**\n\n    export declare function onBeforeRouteUpdate(updateGuard: NavigationGuard): void\n\n#### Parameters\n\n| Parameter   | Type                                  | Description             |\n|-------------|---------------------------------------|-------------------------|\n| updateGuard | [`NavigationGuard`](#navigationguard) | Navigation guard to add |\n\n### useLink\n\nReturns everything exposed by the [`v-slot` API](#router-link-s-v-slot).\n\n**Signature:**\n\n    export declare function useLink(props: RouterLinkOptions): {\n      route: ComputedRef<RouteLocationNormalized & { href: string }>,\n      href: ComputedRef<string>,\n      isActive: ComputedRef<boolean>,\n      isExactActive: ComputedRef<boolean>,\n      navigate: (event?: MouseEvent) => Promise(NavigationFailure | void),\n    }\n\n#### Parameters\n\n| Parameter | Type                | Description                                                                           |\n|-----------|---------------------|---------------------------------------------------------------------------------------|\n| props     | `RouterLinkOptions` | props object that can be passed to `<router-link>`. Accepts `Ref`s and `ComputedRef`s |\n\n### useRoute\n\nReturns the current route location. Equivalent to using `$route` inside templates. Must be called inside of `setup()`.\n\n**Signature:**\n\n    export declare function useRoute(): RouteLocationNormalized\n\n### useRouter\n\nReturns the [router](#router-properties) instance. Equivalent to using `$router` inside templates. Must be called inside of `setup()`.\n\n**Signature:**\n\n    export declare function useRouter(): Router\n\n## TypeScript\n\nHere are some of the interfaces and types used by Vue Router. The documentation references them to give you an idea of the existing properties in objects.\n\n## Router Properties\n\n### currentRoute\n\n- **Type**: [`Ref<RouteLocationNormalized>`](#routelocationnormalized)\n\n- **Details**:\n\n  Current route location. Readonly.\n\n### options\n\n- **Type**: [`RouterOptions`](#routeroptions)\n\n- **Details**:\n\n  Original options object passed to create the Router. Readonly.\n\n## Router Methods\n\n### addRoute\n\nAdd a new [Route Record](#routerecordraw) as the child of an existing route. If the route has a `name` and there is already an existing one with the same one, it removes it first.\n\n**Signature:**\n\n    addRoute(parentName: string | symbol, route: RouteRecordRaw): () => void\n\n*Parameters*\n\n| Parameter  | Type                                | Description                                             |\n|------------|-------------------------------------|---------------------------------------------------------|\n| parentName | `string | symbol`                   | Parent Route Record where `route` should be appended at |\n| route      | [`RouteRecordRaw`](#routerecordraw) | Route Record to add                                     |\n\n### addRoute\n\nAdd a new [route record](#routerecordraw) to the router. If the route has a `name` and there is already an existing one with the same one, it removes it first.\n\n**Signature:**\n\n    addRoute(route: RouteRecordRaw): () => void\n\n*Parameters*\n\n| Parameter | Type                                | Description         |\n|-----------|-------------------------------------|---------------------|\n| route     | [`RouteRecordRaw`](#routerecordraw) | Route Record to add |\n\n**TIP**\n\nNote adding routes does not trigger a new navigation, meaning that the added route will not be displayed unless a new navigation is triggered.\n\n### afterEach\n\nAdd a navigation hook that is executed after every navigation. Returns a function that removes the registered hook.\n\n**Signature:**\n\n    afterEach(guard: NavigationHookAfter): () => void\n\n*Parameters*\n\n| Parameter | Type                  | Description            |\n|-----------|-----------------------|------------------------|\n| guard     | `NavigationHookAfter` | navigation hook to add |\n\n#### Examples\n\n    router.afterEach((to, from, failure) => {\n      if (isNavigationFailure(failure)) {\n        console.log('failed navigation', failure)\n      }\n    })\n\n### back\n\nGo back in history if possible by calling `history.back()`. Equivalent to `router.go(-1)`.\n\n**Signature:**\n\n    back(): void\n\n### beforeEach\n\nAdd a navigation guard that executes before any navigation. Returns a function that removes the registered guard.\n\n**Signature:**\n\n    beforeEach(guard: NavigationGuard): () => void\n\n*Parameters*\n\n| Parameter | Type                                  | Description             |\n|-----------|---------------------------------------|-------------------------|\n| guard     | [`NavigationGuard`](#navigationguard) | navigation guard to add |\n\n### beforeResolve\n\nAdd a navigation guard that executes before navigation is about to be resolved. At this state all component have been fetched and other navigation guards have been successful. Returns a function that removes the registered guard.\n\n**Signature:**\n\n    beforeResolve(guard: NavigationGuard): () => void\n\n*Parameters*\n\n| Parameter | Type                                  | Description             |\n|-----------|---------------------------------------|-------------------------|\n| guard     | [`NavigationGuard`](#navigationguard) | navigation guard to add |\n\n#### Examples\n\n    router.beforeResolve(to => {\n      if (to.meta.requiresAuth && !isAuthenticated) return false\n    })\n\n### forward\n\nGo forward in history if possible by calling `history.forward()`. Equivalent to `router.go(1)`.\n\n**Signature:**\n\n    forward(): void\n\n### getRoutes\n\nGet a full list of all the [route records](#routerecord).\n\n**Signature:**\n\n    getRoutes(): RouteRecord[]\n\n### go\n\nAllows you to move forward or backward through the history.\n\n**Signature:**\n\n    go(delta: number): void\n\n*Parameters*\n\n| Parameter | Type     | Description                                                                         |\n|-----------|----------|-------------------------------------------------------------------------------------|\n| delta     | `number` | The position in the history to which you want to move, relative to the current page |\n\n### hasRoute\n\nChecks if a route with a given name exists\n\n**Signature:**\n\n    hasRoute(name: string | symbol): boolean\n\n*Parameters*\n\n| Parameter | Type              | Description                |\n|-----------|-------------------|----------------------------|\n| name      | `string | symbol` | Name of the route to check |\n\n### isReady\n\nReturns a Promise that resolves when the router has completed the initial navigation, which means it has resolved all async enter hooks and async components that are associated with the initial route. If the initial navigation already happened, the promise resolves immediately.This is useful in server-side rendering to ensure consistent output on both the server and the client. Note that on server side, you need to manually push the initial location while on client side, the router automatically picks it up from the URL.\n\n**Signature:**\n\n    isReady(): Promise<void>\n\n### onError\n\nAdds an error handler that is called every time a non caught error happens during navigation. This includes errors thrown synchronously and asynchronously, errors returned or passed to `next` in any navigation guard, and errors occurred when trying to resolve an async component that is required to render a route.\n\n**Signature:**\n\n    onError(handler: (error: any, to: RouteLocationNormalized, from: RouteLocationNormalized) => any): () => void\n\n*Parameters*\n\n| Parameter | Type                                                                              | Description               |\n|-----------|-----------------------------------------------------------------------------------|---------------------------|\n| handler   | `(error: any, to: RouteLocationNormalized, from: RouteLocationNormalized) => any` | error handler to register |\n\n### push\n\nProgrammatically navigate to a new URL by pushing an entry in the history stack.\n\n**Signature:**\n\n    push(to: RouteLocationRaw): Promise<NavigationFailure | void | undefined>\n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Route location to navigate to |\n\n### removeRoute\n\nRemove an existing route by its name.\n\n**Signature:**\n\n    removeRoute(name: string | symbol): void\n\n*Parameters*\n\n| Parameter | Type              | Description                 |\n|-----------|-------------------|-----------------------------|\n| name      | `string | symbol` | Name of the route to remove |\n\n### replace\n\nProgrammatically navigate to a new URL by replacing the current entry in the history stack.\n\n**Signature:**\n\n    replace(to: RouteLocationRaw): Promise<NavigationFailure | void | undefined>\n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Route location to navigate to |\n\n### resolve\n\nReturns the [normalized version](#routelocation) of a [route location](#routelocationraw). Also includes an `href` property that includes any existing `base`.\n\n**Signature:**\n\n    resolve(to: RouteLocationRaw): RouteLocation & {\n      href: string\n    }\n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Raw route location to resolve |\n\n## RouterOptions\n\n### history\n\nHistory implementation used by the router. Most web applications should use `createWebHistory` but it requires the server to be properly configured. You can also use a *hash* based history with `createWebHashHistory` that does not require any configuration on the server but isn't handled at all by search engines and does poorly on SEO.\n\n**Signature:**\n\n    history: RouterHistory\n\n#### Examples\n\n    createRouter({\n      history: createWebHistory(),\n      // other options...\n    })\n\n### linkActiveClass\n\nDefault class applied to active [RouterLink](#router-link-props). If none is provided, `router-link-active` will be applied.\n\n**Signature:**\n\n    linkActiveClass?: string\n\n### linkExactActiveClass\n\nDefault class applied to exact active [RouterLink](#router-link-props). If none is provided, `router-link-exact-active` will be applied.\n\n**Signature:**\n\n    linkExactActiveClass?: string\n\n### parseQuery\n\nCustom implementation to parse a query. Must decode query keys and values. See its counterpart, [stringifyQuery](#stringifyquery).\n\n**Signature:**\n\n    parseQuery?: (searchQuery: string) => Record<string, (string | null)[] | string | null>\n\n#### Examples\n\nLet's say you want to use the package [qs](https://github.com/ljharb/qs) to parse queries, you can provide both `parseQuery` and `stringifyQuery`:\n\n    import qs from 'qs'\n\n    createRouter({\n      // other options...\n      parseQuery: qs.parse,\n      stringifyQuery: qs.stringify,\n    })\n\n### routes\n\nInitial list of routes that should be added to the router.\n\n**Signature:**\n\n    routes: RouteRecordRaw[]\n\n### scrollBehavior\n\nFunction to control scrolling when navigating between pages. Can return a Promise to delay when the scrolling happens. See [Scroll Behaviour](../guide/advanced/scroll-behavior) for more details.\n\n**Signature:**\n\n    scrollBehavior?: RouterScrollBehavior\n\n#### Examples\n\n    function scrollBehavior(to, from, savedPosition) {\n      // `to` and `from` are both route locations\n      // `savedPosition` can be null if there isn't one\n    }\n\n### stringifyQuery\n\nCustom implementation to stringify a query object. Should not prepend a leading `?`. Should properly encode query keys and values. [parseQuery](#parsequery) counterpart to handle query parsing.\n\n**Signature:**\n\n    stringifyQuery?: (\n      query: Record<\n        string | number,\n        string | number | null | undefined | (string | number | null | undefined)[]\n      >\n    ) => string\n\n## RouteRecordRaw\n\nRoute record that can be provided by the user when adding routes via the [`routes` option](#routeroptions) or via [`router.addRoute()`](#addroute-2). There are three different kind of route records:\n\n- Single views records: have a `component` option\n- Multiple views records ([named views](../guide/essentials/named-views)): have a `components` option\n- Redirect records: cannot have `component` or `components` option because a redirect record is never reached.\n\n### path\n\n- **Type**: `string`\n\n- **Details**:\n\n  Path of the record. Should start with `/` unless the record is the child of another record. Can define parameters: `/users/:id` matches `/users/1` as well as `/users/posva`.\n\n- **See Also**: [Dynamic Route Matching](../guide/essentials/dynamic-matching)\n\n### redirect\n\n- **Type**: `RouteLocationRaw | (to: RouteLocationNormalized) => RouteLocationRaw` (Optional)\n\n- **Details**:\n\n  Where to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location. Can also be a function that receives the target route location and returns the location we should redirect to.\n\n### children\n\n- **Type**: Array of [`RouteRecordRaw`](#routerecordraw) (Optional)\n\n- **Details**:\n\n  Nested routes of the current record.\n\n- **See Also**: [Nested Routes](../guide/essentials/nested-routes)\n\n### alias\n\n- **Type**: `string | string[]` (Optional)\n\n- **Details**:\n\n  Aliases for the route. Allows defining extra paths that will behave like a copy of the record. This enables paths shorthands like `/users/:id` and `/u/:id`. **All `alias` and `path` values must share the same params**.\n\n### name\n\n- **Type**: `string | symbol` (Optional)\n\n- **Details**:\n\n  Unique name for the route record.\n\n### beforeEnter\n\n- **Type**: [`NavigationGuard | NavigationGuard[]`](#navigationguard) (Optional)\n\n- **Details**:\n\n  Before enter guard specific to this record. Note `beforeEnter` has no effect if the record has a `redirect` property.\n\n### props\n\n- **Type**: `boolean | Record<string, any> | (to: RouteLocationNormalized) => Record<string, any>` (Optional)\n\n- **Details**:\n\n  Allows passing down params as props to the component rendered by `router-view`. When passed to a *multiple views record*, it should be an object with the same keys as `components` or a `boolean` to be applied to each component. target location.\n\n- **See Also**: [Passing props to Route Components](../guide/essentials/passing-props)\n\n### meta\n\n- **Type**: [`RouteMeta`](#routemeta) (Optional)\n\n- **Details**:\n\n  Custom data attached to the record.\n\n- **See Also**: [Meta fields](../guide/advanced/meta)\n\n**TIP**\n\nIf you want to use a functional component, make sure to add a `displayName` to it.\n\nFor example:\n\n    const HomeView = () => h('div', 'HomePage')\n    // in TypeScript, you will need to use the FunctionalComponent type\n    HomeView.displayName = 'HomeView'\n    const routes = [{ path: '/', component: HomeView }]\n\n## RouteRecordNormalized\n\nNormalized version of a [Route Record](#routerecordraw)\n\n### aliasOf\n\n- **Type**: `RouteRecordNormalized | undefined`\n\n- **Details**:\n\n  Defines if this record is the alias of another one. This property is `undefined` if the record is the original one.\n\n### beforeEnter\n\n- **Type**: [`NavigationGuard`](#navigationguard)\n\n- **Details**:\n\n  Navigation guard applied when entering this record from somewhere else.\n\n- **See Also**: [Navigation guards](../guide/advanced/navigation-guards)\n\n### children\n\n- **Type**: Array of normalized [route records](#routerecordnormalized)\n\n- **Details**:\n\n  Children route records of a route at the time it was added. Empty array if none. Note this array doesn't update when `addRoute()` and `removeRoute()` are called.\n\n### components\n\n- **Type**: `Record<string, Component>`\n\n- **Details**:\n\n  Dictionary of named views, if none, contains an object with the key `default`.\n\n### meta\n\n- **Type**: `RouteMeta`\n\n- **Details**:\n\n  Arbitrary data attached to the record.\n\n- **See also**: [Meta fields](../guide/advanced/meta)\n\n### name\n\n- **Type**: `string | symbol | undefined`\n\n- **Details**:\n\n  Name for the route record. `undefined` if none was provided.\n\n### path\n\n- **Type**: `string`\n\n- **Details**:\n\n  Normalized path of the record. Includes any parent's `path`.\n\n### props\n\n- **Type**: `Record<string, boolean | Function | Record<string, any>>`\n\n- **Details**:\n\n  Dictionary of the [`props` option](#props) for each named view. If none, it will contain only one property named `default`.\n\n### redirect\n\n- **Type**: [`RouteLocationRaw`](#routelocationraw)\n\n- **Details**:\n\n  Where to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\n## RouteLocationRaw\n\nUser-level route location that can be passed to `router.push()`, `redirect`, and returned in [Navigation Guards](../guide/advanced/navigation-guards).\n\nA raw location can either be a `string` like `/users/posva#bio` or an object:\n\n    // these three forms are equivalent\n    router.push('/users/posva#bio')\n    router.push({ path: '/users/posva', hash: '#bio' })\n    router.push({ name: 'users', params: { username: 'posva' }, hash: '#bio' })\n    // only change the hash\n    router.push({ hash: '#bio' })\n    // only change query\n    router.push({ query: { page: '2' } })\n    // change one param\n    router.push({ params: { username: 'jolyne' } })\n\nNote `path` must be provided encoded (e.g. `phantom blood` becomes `phantom%20blood`) while `params`, `query` and `hash` must not, they are encoded by the router.\n\nRaw route locations also support an extra option `replace` to call `router.replace()` instead of `router.push()` in navigation guards. Note this also internally calls `router.replace()` even when calling `router.push()`:\n\n    router.push({ hash: '#bio', replace: true })\n    // equivalent to\n    router.replace({ hash: '#bio' })\n\n## RouteLocation\n\nResolved [RouteLocationRaw](#routelocationraw) that can contain [redirect records](#routerecordraw). Apart from that it has the same properties as [RouteLocationNormalized](#routelocationnormalized).\n\n## RouteLocationNormalized\n\nNormalized route location. Does not have any [redirect records](#routerecordraw). In navigation guards, `to` and `from` are always of this type.\n\n### fullPath\n\n- **Type**: `string`\n\n- **Details**:\n\n  Encoded URL associated to the route location. Contains `path`, `query` and `hash`.\n\n### hash\n\n- **Type**: `string`\n\n- **Details**:\n\n  Decoded `hash` section of the URL. Always starts with a `#`. Empty string if there is no `hash` in the URL.\n\n### query\n\n- **Type**: `Record<string, string | string[]>`\n\n- **Details**:\n\n  Dictionary of decoded query params extracted from the `search` section of the URL.\n\n### matched\n\n- **Type**: [`RouteRecordNormalized[]`](#routerecordnormalized)\n\n- **Details**:\n\n  Array of [normalized route records](#routerecord) that were matched with the given route location.\n\n### meta\n\n- **Type**: `RouteMeta`\n\n- **Details**:\n\n  Arbitrary data attached to all matched records merged (non recursively) from parent to child.\n\n- **See also**: [Meta fields](../guide/advanced/meta)\n\n### name\n\n- **Type**: `string | symbol | undefined | null`\n\n- **Details**:\n\n  Name for the route record. `undefined` if none was provided.\n\n### params\n\n- **Type**: `Record<string, string | string[]>`\n\n- **Details**:\n\n  Dictionary of decoded params extracted from `path`.\n\n### path\n\n- **Type**: `string`\n\n- **Details**:\n\n  Encoded `pathname` section of the URL associated to the route location.\n\n### redirectedFrom\n\n- **Type**: [`RouteLocation`](#routelocation)\n\n- **Details**:\n\n  Route location we were initially trying to access before ending up on the current location when a `redirect` option was found or a navigation guard called `next()` with a route location. `undefined` if there was no redirection.\n\n## NavigationFailure\n\n### from\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  Route location we were navigating from\n\n### to\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  Route location we were navigating to\n\n### type\n\n- **Type**: [`NavigationFailureType`](#navigationfailuretype)\n\n- **Details**:\n\n  Type of the navigation failure.\n\n- **See Also**: [Navigation Failures](../guide/advanced/navigation-failures)\n\n## NavigationGuard\n\n- **Arguments**:\n\n  - [`RouteLocationNormalized`](#routelocationnormalized) to - Route location we are navigating to\n  - [`RouteLocationNormalized`](#routelocationnormalized) from - Route location we are navigating from\n  - `Function` next (Optional) - Callback to validate the navigation\n\n- **Details**:\n\n  Function that can be passed to control a router navigation. The `next` callback can be omitted if you return a value (or a Promise) instead, which is encouraged. Possible return values (and parameters for `next`) are:\n\n  - `undefined | void | true`: validates the navigation\n  - `false`: cancels the navigation\n  - [`RouteLocationRaw`](#routelocationraw): redirects to a different location\n  - `(vm: ComponentPublicInstance) => any` **only for `beforeRouteEnter`**: A callback to be executed once the navigation completes. Receives the route component instance as the parameter.\n\n- **See Also**: [Navigation Guards](../guide/advanced/navigation-guards)\n\n## Component Injections\n\n### Component Injected Properties\n\nThese properties are injected into every child component by calling `app.use(router)`.\n\n- **this.$router**\n\n  The router instance.\n\n- **this.$route**\n\n  The current active [route location](#routelocationnormalized). This property is read-only and its properties are immutable, but it can be watched.\n\n### Component Enabled Options\n\n- **beforeRouteEnter**\n- **beforeRouteUpdate**\n- **beforeRouteLeave**\n\nSee [In Component Guards](../guide/advanced/navigation-guards#in-component-guards).\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/api/index.md)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/api/index.html](https://next.router.vuejs.org/api/index.html)"
- name: <router-link>
  id: api/index#router-link
  summary: Denotes the target route of the link
  belongs_to: API Reference
  description: "# API Reference\n\n## `<router-link>` Props\n\n### to\n\n- **Type**: [`RouteLocationRaw`](#routelocationraw)\n\n- **Details**:\n\n  Denotes the target route of the link. When clicked, the value of the `to` prop will be passed to `router.push()` internally, so it can either be a `string` or a [route location object](#routelocationraw).\n\n    <!-- literal string -->\n    <router-link to=\"/home\">Home</router-link>\n    <!-- renders to -->\n    <a href=\"/home\">Home</a>\n\n    <!-- javascript expression using `v-bind` -->\n    <router-link :to=\"'/home'\">Home</router-link>\n\n    <!-- same as above -->\n    <router-link :to=\"{ path: '/home' }\">Home</router-link>\n\n    <!-- named route -->\n    <router-link :to=\"{ name: 'user', params: { userId: '123' }}\">User</router-link>\n\n    <!-- with query, resulting in `/register?plan=private` -->\n    <router-link :to=\"{ path: '/register', query: { plan: 'private' }}\">\n      Register\n    </router-link>\n\n### replace\n\n- **Type**: `boolean`\n\n- **Default**: `false`\n\n- **Details**:\n\n  Setting `replace` prop will call `router.replace()` instead of `router.push()` when clicked, so the navigation will not leave a history record.\n\n    <router-link to=\"/abc\" replace></router-link>\n\n### active-class\n\n- **Type**: `string`\n\n- **Default**: `\"router-link-active\"` (or global [`linkActiveClass`](#linkactiveclass))\n\n- **Details**:\n\n  Class to apply on the rendered `<a>` when the link is active.\n\n### aria-current-value\n\n- **Type**: `'page' | 'step' | 'location' | 'date' | 'time' | 'true' | 'false'` (`string`)\n\n- **Default**: `\"page\"`\n\n- **Details**:\n\n  Value passed to the attribute `aria-current` when the link is exactly active.\n\n### custom\n\n- **Type**: `boolean`\n\n- **Default**: `false`\n\n- **Details**:\n\n  Whether `<router-link>` should not wrap its content in an `<a>` element. Useful when using [`v-slot`](#router-link-s-v-slot) to create a custom RouterLink. By default, `<router-link>` will render its content wrapped in an `<a>` element, even when using `v-slot`. Passing the `custom` prop, removes that behavior.\n\n- **Examples**:\n\n      <router-link to=\"/home\" custom v-slot=\"{ navigate, href, route }\">\n        <a :href=\"href\" @click=\"navigate\">{{ route.fullPath }}</a>\n      </router-link>\n\n  Renders `<a href=\"/home\">/home</a>`.\n\n      <router-link to=\"/home\" v-slot=\"{ route }\">\n        <span>{{ route.fullPath }}</span>\n      </router-link>\n\n  Renders `<a href=\"/home\"><span>/home</span></a>`.\n\n### exact-active-class\n\n- **Type**: `string`\n\n- **Default**: `\"router-link-exact-active\"` (or global [`linkExactActiveClass`](#linkexactactiveclass))\n\n- **Details**:\n\n  Class to apply on the rendered `<a>` when the link is exact active.\n\n## `<router-link>`'s `v-slot`\n\n`<router-link>` exposes a low level customization through a [scoped slot](https://v3.vuejs.org/guide/component-slots.html#scoped-slots). This is a more advanced API that primarily targets library authors but can come in handy for developers as well, to build a custom component like a *NavLink* or other.\n\n**TIP**\n\nRemember to pass the `custom` option to `<router-link>` to prevent it from wrapping its content inside of an `<a>` element.\n\n    <router-link\n      to=\"/about\"\n      custom\n      v-slot=\"{ href, route, navigate, isActive, isExactActive }\"\n    >\n      <NavLink :active=\"isActive\" :href=\"href\" @click=\"navigate\">\n        {{ route.fullPath }}\n      </NavLink>\n    </router-link>\n\n- `href`: resolved url. This would be the `href` attribute of an `<a>` element. It contains the `base` if any was provided.\n- `route`: resolved normalized location.\n- `navigate`: function to trigger the navigation. **It will automatically prevent events when necessary**, the same way `router-link` does, e.g. `ctrl` or `cmd` + click will still be ignored by `navigate`.\n- `isActive`: `true` if the [active class](#active-class) should be applied. Allows to apply an arbitrary class.\n- `isExactActive`: `true` if the [exact active class](#exact-active-class) should be applied. Allows to apply an arbitrary class.\n\n### Example: Applying Active Class to Outer Element\n\nSometimes we may want the active class to be applied to an outer element rather than the `<a>` element itself, in that case, you can wrap that element inside a `router-link` and use the `v-slot` properties to create your link:\n\n    <router-link\n      to=\"/foo\"\n      custom\n      v-slot=\"{ href, route, navigate, isActive, isExactActive }\"\n    >\n      <li\n        :class=\"[isActive && 'router-link-active', isExactActive && 'router-link-exact-active']\"\n      >\n        <a :href=\"href\" @click=\"navigate\">{{ route.fullPath }}</a>\n      </li>\n    </router-link>\n\n**TIP**\n\nIf you add a `target=\"_blank\"` to your `a` element, you must omit the `@click=\"navigate\"` handler.\n\n## `<router-view>` Props\n\n### name\n\n- **Type**: `string`\n\n- **Default**: `\"default\"`\n\n- **Details**:\n\n  When a `<router-view>` has a `name`, it will render the component with the corresponding name in the matched route record's `components` option.\n\n- **See Also**: [Named Views](../guide/essentials/named-views)\n\n### route\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  A route location that has all of its component resolved (if any was lazy loaded) so it can be displayed.\n\n## `<router-view>`'s `v-slot`\n\n`<router-view>` exposes a `v-slot` API mainly to wrap your route components with `<transition>` and `<keep-alive>` components.\n\n    <router-view v-slot=\"{ Component, route }\">\n      <transition :name=\"route.meta.transition || 'fade'\" mode=\"out-in\">\n        <keep-alive>\n          <suspense>\n            <template #default>\n              <component\n                :is=\"Component\"\n                :key=\"route.meta.usePathKey ? route.path : undefined\"\n              />\n            </template>\n            <template #fallback> Loading... </template>\n          </suspense>\n        </keep-alive>\n      </transition>\n    </router-view>\n\n- `Component`: VNodes to be passed to a `<component>`'s `is` prop.\n- `route`: resolved normalized [route location](#routelocationnormalized).\n\n## createRouter\n\nCreates a Router instance that can be used by a Vue app. Check the [`RouterOptions`](#routeroptions) for a list of all the properties that can be passed.\n\n**Signature:**\n\n    export declare function createRouter(options: RouterOptions): Router\n\n### Parameters\n\n| Parameter | Type                            | Description                      |\n|-----------|---------------------------------|----------------------------------|\n| options   | [RouterOptions](#routeroptions) | Options to initialize the router |\n\n## createWebHistory\n\nCreates an HTML5 history. Most common history for single page applications. The application must be served through the http protocol.\n\n**Signature:**\n\n    export declare function createWebHistory(base?: string): RouterHistory\n\n### Parameters\n\n| Parameter | Type     | Description                                                                                                           |\n|-----------|----------|-----------------------------------------------------------------------------------------------------------------------|\n| base      | `string` | optional base to provide. Useful when the application is hosted inside of a folder like `https://example.com/folder/` |\n\n### Examples\n\n    createWebHistory() // No base, the app is hosted at the root of the domain `https://example.com`\n    createWebHistory('/folder/') // gives a url of `https://example.com/folder/`\n\n## createWebHashHistory\n\nCreates a hash history. Useful for web applications with no host (e.g. `file://`) or when configuring a server to handle any URL isn't an option. **Note you should use [`createWebHistory`](#createwebhistory) if SEO matters to you**.\n\n**Signature:**\n\n    export declare function createWebHashHistory(base?: string): RouterHistory\n\n### Parameters\n\n| Parameter | Type     | Description                                                                                                                                                                                                                                                                                                                                                       |\n|-----------|----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| base      | `string` | optional base to provide. Defaults to `location.pathname + location.search`. If there is a `<base>` tag in the `head`, its value will be ignored in favor of this parameter **but note it affects all the history.pushState() calls**, meaning that if you use a `<base>` tag, its `href` value **has to match this parameter** (ignoring anything after the `#`) |\n\n### Examples\n\n    // at https://example.com/folder\n    createWebHashHistory() // gives a url of `https://example.com/folder#`\n    createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\n    // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\n    createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\n    // you should avoid doing this because it changes the original url and breaks copying urls\n    createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\n\n    // at file:///usr/etc/folder/index.html\n    // for locations with no `host`, the base is ignored\n    createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\n\n## createMemoryHistory\n\nCreates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere. If the user is not on a browser context, it's up to them to replace that location with the starter location by either calling `router.push()` or `router.replace()`.\n\n**Signature:**\n\n    export declare function createMemoryHistory(base?: string): RouterHistory\n\n### Parameters\n\n| Parameter | Type     | Description                               |\n|-----------|----------|-------------------------------------------|\n| base      | `string` | Base applied to all urls, defaults to '/' |\n\n### Returns\n\nA history object that can be passed to the router constructor\n\n## NavigationFailureType\n\nEnumeration with all possible types for navigation failures. Can be passed to [isNavigationFailure](#isnavigationfailure) to check for specific failures. **Never use any of the numerical values**, always use the variables like `NavigationFailureType.aborted`.\n\n**Signature:**\n\n    export declare enum NavigationFailureType\n\n### Members\n\n| Member     | Value | Description                                                                                                                      |\n|------------|-------|----------------------------------------------------------------------------------------------------------------------------------|\n| aborted    | 4     | An aborted navigation is a navigation that failed because a navigation guard returned `false` or called `next(false)`            |\n| cancelled  | 8     | A cancelled navigation is a navigation that failed because a more recent navigation finished started (not necessarily finished). |\n| duplicated | 16    | A duplicated navigation is a navigation that failed because it was initiated while already being at the exact same location.     |\n\n## START_LOCATION\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  Initial route location where the router is. Can be used in navigation guards to differentiate the initial navigation.\n\n      import { START_LOCATION } from 'vue-router'\n\n      router.beforeEach((to, from) => {\n        if (from === START_LOCATION) {\n          // initial navigation\n        }\n      })\n\n## Composition API\n\n### onBeforeRouteLeave\n\nAdd a navigation guard that triggers whenever the component for the current location is about to be left. Similar to `beforeRouteLeave` but can be used in any component. The guard is removed when the component is unmounted.\n\n**Signature:**\n\n    export declare function onBeforeRouteLeave(leaveGuard: NavigationGuard): void\n\n#### Parameters\n\n| Parameter  | Type                                  | Description             |\n|------------|---------------------------------------|-------------------------|\n| leaveGuard | [`NavigationGuard`](#navigationguard) | Navigation guard to add |\n\n### onBeforeRouteUpdate\n\nAdd a navigation guard that triggers whenever the current location is about to be updated. Similar to `beforeRouteUpdate` but can be used in any component. The guard is removed when the component is unmounted.\n\n**Signature:**\n\n    export declare function onBeforeRouteUpdate(updateGuard: NavigationGuard): void\n\n#### Parameters\n\n| Parameter   | Type                                  | Description             |\n|-------------|---------------------------------------|-------------------------|\n| updateGuard | [`NavigationGuard`](#navigationguard) | Navigation guard to add |\n\n### useLink\n\nReturns everything exposed by the [`v-slot` API](#router-link-s-v-slot).\n\n**Signature:**\n\n    export declare function useLink(props: RouterLinkOptions): {\n      route: ComputedRef<RouteLocationNormalized & { href: string }>,\n      href: ComputedRef<string>,\n      isActive: ComputedRef<boolean>,\n      isExactActive: ComputedRef<boolean>,\n      navigate: (event?: MouseEvent) => Promise(NavigationFailure | void),\n    }\n\n#### Parameters\n\n| Parameter | Type                | Description                                                                           |\n|-----------|---------------------|---------------------------------------------------------------------------------------|\n| props     | `RouterLinkOptions` | props object that can be passed to `<router-link>`. Accepts `Ref`s and `ComputedRef`s |\n\n### useRoute\n\nReturns the current route location. Equivalent to using `$route` inside templates. Must be called inside of `setup()`.\n\n**Signature:**\n\n    export declare function useRoute(): RouteLocationNormalized\n\n### useRouter\n\nReturns the [router](#router-properties) instance. Equivalent to using `$router` inside templates. Must be called inside of `setup()`.\n\n**Signature:**\n\n    export declare function useRouter(): Router\n\n## TypeScript\n\nHere are some of the interfaces and types used by Vue Router. The documentation references them to give you an idea of the existing properties in objects.\n\n## Router Properties\n\n### currentRoute\n\n- **Type**: [`Ref<RouteLocationNormalized>`](#routelocationnormalized)\n\n- **Details**:\n\n  Current route location. Readonly.\n\n### options\n\n- **Type**: [`RouterOptions`](#routeroptions)\n\n- **Details**:\n\n  Original options object passed to create the Router. Readonly.\n\n## Router Methods\n\n### addRoute\n\nAdd a new [Route Record](#routerecordraw) as the child of an existing route. If the route has a `name` and there is already an existing one with the same one, it removes it first.\n\n**Signature:**\n\n    addRoute(parentName: string | symbol, route: RouteRecordRaw): () => void\n\n*Parameters*\n\n| Parameter  | Type                                | Description                                             |\n|------------|-------------------------------------|---------------------------------------------------------|\n| parentName | `string | symbol`                   | Parent Route Record where `route` should be appended at |\n| route      | [`RouteRecordRaw`](#routerecordraw) | Route Record to add                                     |\n\n### addRoute\n\nAdd a new [route record](#routerecordraw) to the router. If the route has a `name` and there is already an existing one with the same one, it removes it first.\n\n**Signature:**\n\n    addRoute(route: RouteRecordRaw): () => void\n\n*Parameters*\n\n| Parameter | Type                                | Description         |\n|-----------|-------------------------------------|---------------------|\n| route     | [`RouteRecordRaw`](#routerecordraw) | Route Record to add |\n\n**TIP**\n\nNote adding routes does not trigger a new navigation, meaning that the added route will not be displayed unless a new navigation is triggered.\n\n### afterEach\n\nAdd a navigation hook that is executed after every navigation. Returns a function that removes the registered hook.\n\n**Signature:**\n\n    afterEach(guard: NavigationHookAfter): () => void\n\n*Parameters*\n\n| Parameter | Type                  | Description            |\n|-----------|-----------------------|------------------------|\n| guard     | `NavigationHookAfter` | navigation hook to add |\n\n#### Examples\n\n    router.afterEach((to, from, failure) => {\n      if (isNavigationFailure(failure)) {\n        console.log('failed navigation', failure)\n      }\n    })\n\n### back\n\nGo back in history if possible by calling `history.back()`. Equivalent to `router.go(-1)`.\n\n**Signature:**\n\n    back(): void\n\n### beforeEach\n\nAdd a navigation guard that executes before any navigation. Returns a function that removes the registered guard.\n\n**Signature:**\n\n    beforeEach(guard: NavigationGuard): () => void\n\n*Parameters*\n\n| Parameter | Type                                  | Description             |\n|-----------|---------------------------------------|-------------------------|\n| guard     | [`NavigationGuard`](#navigationguard) | navigation guard to add |\n\n### beforeResolve\n\nAdd a navigation guard that executes before navigation is about to be resolved. At this state all component have been fetched and other navigation guards have been successful. Returns a function that removes the registered guard.\n\n**Signature:**\n\n    beforeResolve(guard: NavigationGuard): () => void\n\n*Parameters*\n\n| Parameter | Type                                  | Description             |\n|-----------|---------------------------------------|-------------------------|\n| guard     | [`NavigationGuard`](#navigationguard) | navigation guard to add |\n\n#### Examples\n\n    router.beforeResolve(to => {\n      if (to.meta.requiresAuth && !isAuthenticated) return false\n    })\n\n### forward\n\nGo forward in history if possible by calling `history.forward()`. Equivalent to `router.go(1)`.\n\n**Signature:**\n\n    forward(): void\n\n### getRoutes\n\nGet a full list of all the [route records](#routerecord).\n\n**Signature:**\n\n    getRoutes(): RouteRecord[]\n\n### go\n\nAllows you to move forward or backward through the history.\n\n**Signature:**\n\n    go(delta: number): void\n\n*Parameters*\n\n| Parameter | Type     | Description                                                                         |\n|-----------|----------|-------------------------------------------------------------------------------------|\n| delta     | `number` | The position in the history to which you want to move, relative to the current page |\n\n### hasRoute\n\nChecks if a route with a given name exists\n\n**Signature:**\n\n    hasRoute(name: string | symbol): boolean\n\n*Parameters*\n\n| Parameter | Type              | Description                |\n|-----------|-------------------|----------------------------|\n| name      | `string | symbol` | Name of the route to check |\n\n### isReady\n\nReturns a Promise that resolves when the router has completed the initial navigation, which means it has resolved all async enter hooks and async components that are associated with the initial route. If the initial navigation already happened, the promise resolves immediately.This is useful in server-side rendering to ensure consistent output on both the server and the client. Note that on server side, you need to manually push the initial location while on client side, the router automatically picks it up from the URL.\n\n**Signature:**\n\n    isReady(): Promise<void>\n\n### onError\n\nAdds an error handler that is called every time a non caught error happens during navigation. This includes errors thrown synchronously and asynchronously, errors returned or passed to `next` in any navigation guard, and errors occurred when trying to resolve an async component that is required to render a route.\n\n**Signature:**\n\n    onError(handler: (error: any, to: RouteLocationNormalized, from: RouteLocationNormalized) => any): () => void\n\n*Parameters*\n\n| Parameter | Type                                                                              | Description               |\n|-----------|-----------------------------------------------------------------------------------|---------------------------|\n| handler   | `(error: any, to: RouteLocationNormalized, from: RouteLocationNormalized) => any` | error handler to register |\n\n### push\n\nProgrammatically navigate to a new URL by pushing an entry in the history stack.\n\n**Signature:**\n\n    push(to: RouteLocationRaw): Promise<NavigationFailure | void | undefined>\n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Route location to navigate to |\n\n### removeRoute\n\nRemove an existing route by its name.\n\n**Signature:**\n\n    removeRoute(name: string | symbol): void\n\n*Parameters*\n\n| Parameter | Type              | Description                 |\n|-----------|-------------------|-----------------------------|\n| name      | `string | symbol` | Name of the route to remove |\n\n### replace\n\nProgrammatically navigate to a new URL by replacing the current entry in the history stack.\n\n**Signature:**\n\n    replace(to: RouteLocationRaw): Promise<NavigationFailure | void | undefined>\n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Route location to navigate to |\n\n### resolve\n\nReturns the [normalized version](#routelocation) of a [route location](#routelocationraw). Also includes an `href` property that includes any existing `base`.\n\n**Signature:**\n\n    resolve(to: RouteLocationRaw): RouteLocation & {\n      href: string\n    }\n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Raw route location to resolve |\n\n## RouterOptions\n\n### history\n\nHistory implementation used by the router. Most web applications should use `createWebHistory` but it requires the server to be properly configured. You can also use a *hash* based history with `createWebHashHistory` that does not require any configuration on the server but isn't handled at all by search engines and does poorly on SEO.\n\n**Signature:**\n\n    history: RouterHistory\n\n#### Examples\n\n    createRouter({\n      history: createWebHistory(),\n      // other options...\n    })\n\n### linkActiveClass\n\nDefault class applied to active [RouterLink](#router-link-props). If none is provided, `router-link-active` will be applied.\n\n**Signature:**\n\n    linkActiveClass?: string\n\n### linkExactActiveClass\n\nDefault class applied to exact active [RouterLink](#router-link-props). If none is provided, `router-link-exact-active` will be applied.\n\n**Signature:**\n\n    linkExactActiveClass?: string\n\n### parseQuery\n\nCustom implementation to parse a query. Must decode query keys and values. See its counterpart, [stringifyQuery](#stringifyquery).\n\n**Signature:**\n\n    parseQuery?: (searchQuery: string) => Record<string, (string | null)[] | string | null>\n\n#### Examples\n\nLet's say you want to use the package [qs](https://github.com/ljharb/qs) to parse queries, you can provide both `parseQuery` and `stringifyQuery`:\n\n    import qs from 'qs'\n\n    createRouter({\n      // other options...\n      parseQuery: qs.parse,\n      stringifyQuery: qs.stringify,\n    })\n\n### routes\n\nInitial list of routes that should be added to the router.\n\n**Signature:**\n\n    routes: RouteRecordRaw[]\n\n### scrollBehavior\n\nFunction to control scrolling when navigating between pages. Can return a Promise to delay when the scrolling happens. See [Scroll Behaviour](../guide/advanced/scroll-behavior) for more details.\n\n**Signature:**\n\n    scrollBehavior?: RouterScrollBehavior\n\n#### Examples\n\n    function scrollBehavior(to, from, savedPosition) {\n      // `to` and `from` are both route locations\n      // `savedPosition` can be null if there isn't one\n    }\n\n### stringifyQuery\n\nCustom implementation to stringify a query object. Should not prepend a leading `?`. Should properly encode query keys and values. [parseQuery](#parsequery) counterpart to handle query parsing.\n\n**Signature:**\n\n    stringifyQuery?: (\n      query: Record<\n        string | number,\n        string | number | null | undefined | (string | number | null | undefined)[]\n      >\n    ) => string\n\n## RouteRecordRaw\n\nRoute record that can be provided by the user when adding routes via the [`routes` option](#routeroptions) or via [`router.addRoute()`](#addroute-2). There are three different kind of route records:\n\n- Single views records: have a `component` option\n- Multiple views records ([named views](../guide/essentials/named-views)): have a `components` option\n- Redirect records: cannot have `component` or `components` option because a redirect record is never reached.\n\n### path\n\n- **Type**: `string`\n\n- **Details**:\n\n  Path of the record. Should start with `/` unless the record is the child of another record. Can define parameters: `/users/:id` matches `/users/1` as well as `/users/posva`.\n\n- **See Also**: [Dynamic Route Matching](../guide/essentials/dynamic-matching)\n\n### redirect\n\n- **Type**: `RouteLocationRaw | (to: RouteLocationNormalized) => RouteLocationRaw` (Optional)\n\n- **Details**:\n\n  Where to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location. Can also be a function that receives the target route location and returns the location we should redirect to.\n\n### children\n\n- **Type**: Array of [`RouteRecordRaw`](#routerecordraw) (Optional)\n\n- **Details**:\n\n  Nested routes of the current record.\n\n- **See Also**: [Nested Routes](../guide/essentials/nested-routes)\n\n### alias\n\n- **Type**: `string | string[]` (Optional)\n\n- **Details**:\n\n  Aliases for the route. Allows defining extra paths that will behave like a copy of the record. This enables paths shorthands like `/users/:id` and `/u/:id`. **All `alias` and `path` values must share the same params**.\n\n### name\n\n- **Type**: `string | symbol` (Optional)\n\n- **Details**:\n\n  Unique name for the route record.\n\n### beforeEnter\n\n- **Type**: [`NavigationGuard | NavigationGuard[]`](#navigationguard) (Optional)\n\n- **Details**:\n\n  Before enter guard specific to this record. Note `beforeEnter` has no effect if the record has a `redirect` property.\n\n### props\n\n- **Type**: `boolean | Record<string, any> | (to: RouteLocationNormalized) => Record<string, any>` (Optional)\n\n- **Details**:\n\n  Allows passing down params as props to the component rendered by `router-view`. When passed to a *multiple views record*, it should be an object with the same keys as `components` or a `boolean` to be applied to each component. target location.\n\n- **See Also**: [Passing props to Route Components](../guide/essentials/passing-props)\n\n### meta\n\n- **Type**: [`RouteMeta`](#routemeta) (Optional)\n\n- **Details**:\n\n  Custom data attached to the record.\n\n- **See Also**: [Meta fields](../guide/advanced/meta)\n\n**TIP**\n\nIf you want to use a functional component, make sure to add a `displayName` to it.\n\nFor example:\n\n    const HomeView = () => h('div', 'HomePage')\n    // in TypeScript, you will need to use the FunctionalComponent type\n    HomeView.displayName = 'HomeView'\n    const routes = [{ path: '/', component: HomeView }]\n\n## RouteRecordNormalized\n\nNormalized version of a [Route Record](#routerecordraw)\n\n### aliasOf\n\n- **Type**: `RouteRecordNormalized | undefined`\n\n- **Details**:\n\n  Defines if this record is the alias of another one. This property is `undefined` if the record is the original one.\n\n### beforeEnter\n\n- **Type**: [`NavigationGuard`](#navigationguard)\n\n- **Details**:\n\n  Navigation guard applied when entering this record from somewhere else.\n\n- **See Also**: [Navigation guards](../guide/advanced/navigation-guards)\n\n### children\n\n- **Type**: Array of normalized [route records](#routerecordnormalized)\n\n- **Details**:\n\n  Children route records of a route at the time it was added. Empty array if none. Note this array doesn't update when `addRoute()` and `removeRoute()` are called.\n\n### components\n\n- **Type**: `Record<string, Component>`\n\n- **Details**:\n\n  Dictionary of named views, if none, contains an object with the key `default`.\n\n### meta\n\n- **Type**: `RouteMeta`\n\n- **Details**:\n\n  Arbitrary data attached to the record.\n\n- **See also**: [Meta fields](../guide/advanced/meta)\n\n### name\n\n- **Type**: `string | symbol | undefined`\n\n- **Details**:\n\n  Name for the route record. `undefined` if none was provided.\n\n### path\n\n- **Type**: `string`\n\n- **Details**:\n\n  Normalized path of the record. Includes any parent's `path`.\n\n### props\n\n- **Type**: `Record<string, boolean | Function | Record<string, any>>`\n\n- **Details**:\n\n  Dictionary of the [`props` option](#props) for each named view. If none, it will contain only one property named `default`.\n\n### redirect\n\n- **Type**: [`RouteLocationRaw`](#routelocationraw)\n\n- **Details**:\n\n  Where to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\n## RouteLocationRaw\n\nUser-level route location that can be passed to `router.push()`, `redirect`, and returned in [Navigation Guards](../guide/advanced/navigation-guards).\n\nA raw location can either be a `string` like `/users/posva#bio` or an object:\n\n    // these three forms are equivalent\n    router.push('/users/posva#bio')\n    router.push({ path: '/users/posva', hash: '#bio' })\n    router.push({ name: 'users', params: { username: 'posva' }, hash: '#bio' })\n    // only change the hash\n    router.push({ hash: '#bio' })\n    // only change query\n    router.push({ query: { page: '2' } })\n    // change one param\n    router.push({ params: { username: 'jolyne' } })\n\nNote `path` must be provided encoded (e.g. `phantom blood` becomes `phantom%20blood`) while `params`, `query` and `hash` must not, they are encoded by the router.\n\nRaw route locations also support an extra option `replace` to call `router.replace()` instead of `router.push()` in navigation guards. Note this also internally calls `router.replace()` even when calling `router.push()`:\n\n    router.push({ hash: '#bio', replace: true })\n    // equivalent to\n    router.replace({ hash: '#bio' })\n\n## RouteLocation\n\nResolved [RouteLocationRaw](#routelocationraw) that can contain [redirect records](#routerecordraw). Apart from that it has the same properties as [RouteLocationNormalized](#routelocationnormalized).\n\n## RouteLocationNormalized\n\nNormalized route location. Does not have any [redirect records](#routerecordraw). In navigation guards, `to` and `from` are always of this type.\n\n### fullPath\n\n- **Type**: `string`\n\n- **Details**:\n\n  Encoded URL associated to the route location. Contains `path`, `query` and `hash`.\n\n### hash\n\n- **Type**: `string`\n\n- **Details**:\n\n  Decoded `hash` section of the URL. Always starts with a `#`. Empty string if there is no `hash` in the URL.\n\n### query\n\n- **Type**: `Record<string, string | string[]>`\n\n- **Details**:\n\n  Dictionary of decoded query params extracted from the `search` section of the URL.\n\n### matched\n\n- **Type**: [`RouteRecordNormalized[]`](#routerecordnormalized)\n\n- **Details**:\n\n  Array of [normalized route records](#routerecord) that were matched with the given route location.\n\n### meta\n\n- **Type**: `RouteMeta`\n\n- **Details**:\n\n  Arbitrary data attached to all matched records merged (non recursively) from parent to child.\n\n- **See also**: [Meta fields](../guide/advanced/meta)\n\n### name\n\n- **Type**: `string | symbol | undefined | null`\n\n- **Details**:\n\n  Name for the route record. `undefined` if none was provided.\n\n### params\n\n- **Type**: `Record<string, string | string[]>`\n\n- **Details**:\n\n  Dictionary of decoded params extracted from `path`.\n\n### path\n\n- **Type**: `string`\n\n- **Details**:\n\n  Encoded `pathname` section of the URL associated to the route location.\n\n### redirectedFrom\n\n- **Type**: [`RouteLocation`](#routelocation)\n\n- **Details**:\n\n  Route location we were initially trying to access before ending up on the current location when a `redirect` option was found or a navigation guard called `next()` with a route location. `undefined` if there was no redirection.\n\n## NavigationFailure\n\n### from\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  Route location we were navigating from\n\n### to\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  Route location we were navigating to\n\n### type\n\n- **Type**: [`NavigationFailureType`](#navigationfailuretype)\n\n- **Details**:\n\n  Type of the navigation failure.\n\n- **See Also**: [Navigation Failures](../guide/advanced/navigation-failures)\n\n## NavigationGuard\n\n- **Arguments**:\n\n  - [`RouteLocationNormalized`](#routelocationnormalized) to - Route location we are navigating to\n  - [`RouteLocationNormalized`](#routelocationnormalized) from - Route location we are navigating from\n  - `Function` next (Optional) - Callback to validate the navigation\n\n- **Details**:\n\n  Function that can be passed to control a router navigation. The `next` callback can be omitted if you return a value (or a Promise) instead, which is encouraged. Possible return values (and parameters for `next`) are:\n\n  - `undefined | void | true`: validates the navigation\n  - `false`: cancels the navigation\n  - [`RouteLocationRaw`](#routelocationraw): redirects to a different location\n  - `(vm: ComponentPublicInstance) => any` **only for `beforeRouteEnter`**: A callback to be executed once the navigation completes. Receives the route component instance as the parameter.\n\n- **See Also**: [Navigation Guards](../guide/advanced/navigation-guards)\n\n## Component Injections\n\n### Component Injected Properties\n\nThese properties are injected into every child component by calling `app.use(router)`.\n\n- **this.$router**\n\n  The router instance.\n\n- **this.$route**\n\n  The current active [route location](#routelocationnormalized). This property is read-only and its properties are immutable, but it can be watched.\n\n### Component Enabled Options\n\n- **beforeRouteEnter**\n- **beforeRouteUpdate**\n- **beforeRouteLeave**\n\nSee [In Component Guards](../guide/advanced/navigation-guards#in-component-guards).\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/api/index.md)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/api/index.html](https://next.router.vuejs.org/api/index.html)"
- name: <router-view>
  id: api/index#router-view
  summary: Denotes the target route of the link
  belongs_to: API Reference
  description: "# API Reference\n\n## `<router-link>` Props\n\n### to\n\n- **Type**: [`RouteLocationRaw`](#routelocationraw)\n\n- **Details**:\n\n  Denotes the target route of the link. When clicked, the value of the `to` prop will be passed to `router.push()` internally, so it can either be a `string` or a [route location object](#routelocationraw).\n\n    <!-- literal string -->\n    <router-link to=\"/home\">Home</router-link>\n    <!-- renders to -->\n    <a href=\"/home\">Home</a>\n\n    <!-- javascript expression using `v-bind` -->\n    <router-link :to=\"'/home'\">Home</router-link>\n\n    <!-- same as above -->\n    <router-link :to=\"{ path: '/home' }\">Home</router-link>\n\n    <!-- named route -->\n    <router-link :to=\"{ name: 'user', params: { userId: '123' }}\">User</router-link>\n\n    <!-- with query, resulting in `/register?plan=private` -->\n    <router-link :to=\"{ path: '/register', query: { plan: 'private' }}\">\n      Register\n    </router-link>\n\n### replace\n\n- **Type**: `boolean`\n\n- **Default**: `false`\n\n- **Details**:\n\n  Setting `replace` prop will call `router.replace()` instead of `router.push()` when clicked, so the navigation will not leave a history record.\n\n    <router-link to=\"/abc\" replace></router-link>\n\n### active-class\n\n- **Type**: `string`\n\n- **Default**: `\"router-link-active\"` (or global [`linkActiveClass`](#linkactiveclass))\n\n- **Details**:\n\n  Class to apply on the rendered `<a>` when the link is active.\n\n### aria-current-value\n\n- **Type**: `'page' | 'step' | 'location' | 'date' | 'time' | 'true' | 'false'` (`string`)\n\n- **Default**: `\"page\"`\n\n- **Details**:\n\n  Value passed to the attribute `aria-current` when the link is exactly active.\n\n### custom\n\n- **Type**: `boolean`\n\n- **Default**: `false`\n\n- **Details**:\n\n  Whether `<router-link>` should not wrap its content in an `<a>` element. Useful when using [`v-slot`](#router-link-s-v-slot) to create a custom RouterLink. By default, `<router-link>` will render its content wrapped in an `<a>` element, even when using `v-slot`. Passing the `custom` prop, removes that behavior.\n\n- **Examples**:\n\n      <router-link to=\"/home\" custom v-slot=\"{ navigate, href, route }\">\n        <a :href=\"href\" @click=\"navigate\">{{ route.fullPath }}</a>\n      </router-link>\n\n  Renders `<a href=\"/home\">/home</a>`.\n\n      <router-link to=\"/home\" v-slot=\"{ route }\">\n        <span>{{ route.fullPath }}</span>\n      </router-link>\n\n  Renders `<a href=\"/home\"><span>/home</span></a>`.\n\n### exact-active-class\n\n- **Type**: `string`\n\n- **Default**: `\"router-link-exact-active\"` (or global [`linkExactActiveClass`](#linkexactactiveclass))\n\n- **Details**:\n\n  Class to apply on the rendered `<a>` when the link is exact active.\n\n## `<router-link>`'s `v-slot`\n\n`<router-link>` exposes a low level customization through a [scoped slot](https://v3.vuejs.org/guide/component-slots.html#scoped-slots). This is a more advanced API that primarily targets library authors but can come in handy for developers as well, to build a custom component like a *NavLink* or other.\n\n**TIP**\n\nRemember to pass the `custom` option to `<router-link>` to prevent it from wrapping its content inside of an `<a>` element.\n\n    <router-link\n      to=\"/about\"\n      custom\n      v-slot=\"{ href, route, navigate, isActive, isExactActive }\"\n    >\n      <NavLink :active=\"isActive\" :href=\"href\" @click=\"navigate\">\n        {{ route.fullPath }}\n      </NavLink>\n    </router-link>\n\n- `href`: resolved url. This would be the `href` attribute of an `<a>` element. It contains the `base` if any was provided.\n- `route`: resolved normalized location.\n- `navigate`: function to trigger the navigation. **It will automatically prevent events when necessary**, the same way `router-link` does, e.g. `ctrl` or `cmd` + click will still be ignored by `navigate`.\n- `isActive`: `true` if the [active class](#active-class) should be applied. Allows to apply an arbitrary class.\n- `isExactActive`: `true` if the [exact active class](#exact-active-class) should be applied. Allows to apply an arbitrary class.\n\n### Example: Applying Active Class to Outer Element\n\nSometimes we may want the active class to be applied to an outer element rather than the `<a>` element itself, in that case, you can wrap that element inside a `router-link` and use the `v-slot` properties to create your link:\n\n    <router-link\n      to=\"/foo\"\n      custom\n      v-slot=\"{ href, route, navigate, isActive, isExactActive }\"\n    >\n      <li\n        :class=\"[isActive && 'router-link-active', isExactActive && 'router-link-exact-active']\"\n      >\n        <a :href=\"href\" @click=\"navigate\">{{ route.fullPath }}</a>\n      </li>\n    </router-link>\n\n**TIP**\n\nIf you add a `target=\"_blank\"` to your `a` element, you must omit the `@click=\"navigate\"` handler.\n\n## `<router-view>` Props\n\n### name\n\n- **Type**: `string`\n\n- **Default**: `\"default\"`\n\n- **Details**:\n\n  When a `<router-view>` has a `name`, it will render the component with the corresponding name in the matched route record's `components` option.\n\n- **See Also**: [Named Views](../guide/essentials/named-views)\n\n### route\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  A route location that has all of its component resolved (if any was lazy loaded) so it can be displayed.\n\n## `<router-view>`'s `v-slot`\n\n`<router-view>` exposes a `v-slot` API mainly to wrap your route components with `<transition>` and `<keep-alive>` components.\n\n    <router-view v-slot=\"{ Component, route }\">\n      <transition :name=\"route.meta.transition || 'fade'\" mode=\"out-in\">\n        <keep-alive>\n          <suspense>\n            <template #default>\n              <component\n                :is=\"Component\"\n                :key=\"route.meta.usePathKey ? route.path : undefined\"\n              />\n            </template>\n            <template #fallback> Loading... </template>\n          </suspense>\n        </keep-alive>\n      </transition>\n    </router-view>\n\n- `Component`: VNodes to be passed to a `<component>`'s `is` prop.\n- `route`: resolved normalized [route location](#routelocationnormalized).\n\n## createRouter\n\nCreates a Router instance that can be used by a Vue app. Check the [`RouterOptions`](#routeroptions) for a list of all the properties that can be passed.\n\n**Signature:**\n\n    export declare function createRouter(options: RouterOptions): Router\n\n### Parameters\n\n| Parameter | Type                            | Description                      |\n|-----------|---------------------------------|----------------------------------|\n| options   | [RouterOptions](#routeroptions) | Options to initialize the router |\n\n## createWebHistory\n\nCreates an HTML5 history. Most common history for single page applications. The application must be served through the http protocol.\n\n**Signature:**\n\n    export declare function createWebHistory(base?: string): RouterHistory\n\n### Parameters\n\n| Parameter | Type     | Description                                                                                                           |\n|-----------|----------|-----------------------------------------------------------------------------------------------------------------------|\n| base      | `string` | optional base to provide. Useful when the application is hosted inside of a folder like `https://example.com/folder/` |\n\n### Examples\n\n    createWebHistory() // No base, the app is hosted at the root of the domain `https://example.com`\n    createWebHistory('/folder/') // gives a url of `https://example.com/folder/`\n\n## createWebHashHistory\n\nCreates a hash history. Useful for web applications with no host (e.g. `file://`) or when configuring a server to handle any URL isn't an option. **Note you should use [`createWebHistory`](#createwebhistory) if SEO matters to you**.\n\n**Signature:**\n\n    export declare function createWebHashHistory(base?: string): RouterHistory\n\n### Parameters\n\n| Parameter | Type     | Description                                                                                                                                                                                                                                                                                                                                                       |\n|-----------|----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| base      | `string` | optional base to provide. Defaults to `location.pathname + location.search`. If there is a `<base>` tag in the `head`, its value will be ignored in favor of this parameter **but note it affects all the history.pushState() calls**, meaning that if you use a `<base>` tag, its `href` value **has to match this parameter** (ignoring anything after the `#`) |\n\n### Examples\n\n    // at https://example.com/folder\n    createWebHashHistory() // gives a url of `https://example.com/folder#`\n    createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\n    // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\n    createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\n    // you should avoid doing this because it changes the original url and breaks copying urls\n    createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\n\n    // at file:///usr/etc/folder/index.html\n    // for locations with no `host`, the base is ignored\n    createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\n\n## createMemoryHistory\n\nCreates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere. If the user is not on a browser context, it's up to them to replace that location with the starter location by either calling `router.push()` or `router.replace()`.\n\n**Signature:**\n\n    export declare function createMemoryHistory(base?: string): RouterHistory\n\n### Parameters\n\n| Parameter | Type     | Description                               |\n|-----------|----------|-------------------------------------------|\n| base      | `string` | Base applied to all urls, defaults to '/' |\n\n### Returns\n\nA history object that can be passed to the router constructor\n\n## NavigationFailureType\n\nEnumeration with all possible types for navigation failures. Can be passed to [isNavigationFailure](#isnavigationfailure) to check for specific failures. **Never use any of the numerical values**, always use the variables like `NavigationFailureType.aborted`.\n\n**Signature:**\n\n    export declare enum NavigationFailureType\n\n### Members\n\n| Member     | Value | Description                                                                                                                      |\n|------------|-------|----------------------------------------------------------------------------------------------------------------------------------|\n| aborted    | 4     | An aborted navigation is a navigation that failed because a navigation guard returned `false` or called `next(false)`            |\n| cancelled  | 8     | A cancelled navigation is a navigation that failed because a more recent navigation finished started (not necessarily finished). |\n| duplicated | 16    | A duplicated navigation is a navigation that failed because it was initiated while already being at the exact same location.     |\n\n## START_LOCATION\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  Initial route location where the router is. Can be used in navigation guards to differentiate the initial navigation.\n\n      import { START_LOCATION } from 'vue-router'\n\n      router.beforeEach((to, from) => {\n        if (from === START_LOCATION) {\n          // initial navigation\n        }\n      })\n\n## Composition API\n\n### onBeforeRouteLeave\n\nAdd a navigation guard that triggers whenever the component for the current location is about to be left. Similar to `beforeRouteLeave` but can be used in any component. The guard is removed when the component is unmounted.\n\n**Signature:**\n\n    export declare function onBeforeRouteLeave(leaveGuard: NavigationGuard): void\n\n#### Parameters\n\n| Parameter  | Type                                  | Description             |\n|------------|---------------------------------------|-------------------------|\n| leaveGuard | [`NavigationGuard`](#navigationguard) | Navigation guard to add |\n\n### onBeforeRouteUpdate\n\nAdd a navigation guard that triggers whenever the current location is about to be updated. Similar to `beforeRouteUpdate` but can be used in any component. The guard is removed when the component is unmounted.\n\n**Signature:**\n\n    export declare function onBeforeRouteUpdate(updateGuard: NavigationGuard): void\n\n#### Parameters\n\n| Parameter   | Type                                  | Description             |\n|-------------|---------------------------------------|-------------------------|\n| updateGuard | [`NavigationGuard`](#navigationguard) | Navigation guard to add |\n\n### useLink\n\nReturns everything exposed by the [`v-slot` API](#router-link-s-v-slot).\n\n**Signature:**\n\n    export declare function useLink(props: RouterLinkOptions): {\n      route: ComputedRef<RouteLocationNormalized & { href: string }>,\n      href: ComputedRef<string>,\n      isActive: ComputedRef<boolean>,\n      isExactActive: ComputedRef<boolean>,\n      navigate: (event?: MouseEvent) => Promise(NavigationFailure | void),\n    }\n\n#### Parameters\n\n| Parameter | Type                | Description                                                                           |\n|-----------|---------------------|---------------------------------------------------------------------------------------|\n| props     | `RouterLinkOptions` | props object that can be passed to `<router-link>`. Accepts `Ref`s and `ComputedRef`s |\n\n### useRoute\n\nReturns the current route location. Equivalent to using `$route` inside templates. Must be called inside of `setup()`.\n\n**Signature:**\n\n    export declare function useRoute(): RouteLocationNormalized\n\n### useRouter\n\nReturns the [router](#router-properties) instance. Equivalent to using `$router` inside templates. Must be called inside of `setup()`.\n\n**Signature:**\n\n    export declare function useRouter(): Router\n\n## TypeScript\n\nHere are some of the interfaces and types used by Vue Router. The documentation references them to give you an idea of the existing properties in objects.\n\n## Router Properties\n\n### currentRoute\n\n- **Type**: [`Ref<RouteLocationNormalized>`](#routelocationnormalized)\n\n- **Details**:\n\n  Current route location. Readonly.\n\n### options\n\n- **Type**: [`RouterOptions`](#routeroptions)\n\n- **Details**:\n\n  Original options object passed to create the Router. Readonly.\n\n## Router Methods\n\n### addRoute\n\nAdd a new [Route Record](#routerecordraw) as the child of an existing route. If the route has a `name` and there is already an existing one with the same one, it removes it first.\n\n**Signature:**\n\n    addRoute(parentName: string | symbol, route: RouteRecordRaw): () => void\n\n*Parameters*\n\n| Parameter  | Type                                | Description                                             |\n|------------|-------------------------------------|---------------------------------------------------------|\n| parentName | `string | symbol`                   | Parent Route Record where `route` should be appended at |\n| route      | [`RouteRecordRaw`](#routerecordraw) | Route Record to add                                     |\n\n### addRoute\n\nAdd a new [route record](#routerecordraw) to the router. If the route has a `name` and there is already an existing one with the same one, it removes it first.\n\n**Signature:**\n\n    addRoute(route: RouteRecordRaw): () => void\n\n*Parameters*\n\n| Parameter | Type                                | Description         |\n|-----------|-------------------------------------|---------------------|\n| route     | [`RouteRecordRaw`](#routerecordraw) | Route Record to add |\n\n**TIP**\n\nNote adding routes does not trigger a new navigation, meaning that the added route will not be displayed unless a new navigation is triggered.\n\n### afterEach\n\nAdd a navigation hook that is executed after every navigation. Returns a function that removes the registered hook.\n\n**Signature:**\n\n    afterEach(guard: NavigationHookAfter): () => void\n\n*Parameters*\n\n| Parameter | Type                  | Description            |\n|-----------|-----------------------|------------------------|\n| guard     | `NavigationHookAfter` | navigation hook to add |\n\n#### Examples\n\n    router.afterEach((to, from, failure) => {\n      if (isNavigationFailure(failure)) {\n        console.log('failed navigation', failure)\n      }\n    })\n\n### back\n\nGo back in history if possible by calling `history.back()`. Equivalent to `router.go(-1)`.\n\n**Signature:**\n\n    back(): void\n\n### beforeEach\n\nAdd a navigation guard that executes before any navigation. Returns a function that removes the registered guard.\n\n**Signature:**\n\n    beforeEach(guard: NavigationGuard): () => void\n\n*Parameters*\n\n| Parameter | Type                                  | Description             |\n|-----------|---------------------------------------|-------------------------|\n| guard     | [`NavigationGuard`](#navigationguard) | navigation guard to add |\n\n### beforeResolve\n\nAdd a navigation guard that executes before navigation is about to be resolved. At this state all component have been fetched and other navigation guards have been successful. Returns a function that removes the registered guard.\n\n**Signature:**\n\n    beforeResolve(guard: NavigationGuard): () => void\n\n*Parameters*\n\n| Parameter | Type                                  | Description             |\n|-----------|---------------------------------------|-------------------------|\n| guard     | [`NavigationGuard`](#navigationguard) | navigation guard to add |\n\n#### Examples\n\n    router.beforeResolve(to => {\n      if (to.meta.requiresAuth && !isAuthenticated) return false\n    })\n\n### forward\n\nGo forward in history if possible by calling `history.forward()`. Equivalent to `router.go(1)`.\n\n**Signature:**\n\n    forward(): void\n\n### getRoutes\n\nGet a full list of all the [route records](#routerecord).\n\n**Signature:**\n\n    getRoutes(): RouteRecord[]\n\n### go\n\nAllows you to move forward or backward through the history.\n\n**Signature:**\n\n    go(delta: number): void\n\n*Parameters*\n\n| Parameter | Type     | Description                                                                         |\n|-----------|----------|-------------------------------------------------------------------------------------|\n| delta     | `number` | The position in the history to which you want to move, relative to the current page |\n\n### hasRoute\n\nChecks if a route with a given name exists\n\n**Signature:**\n\n    hasRoute(name: string | symbol): boolean\n\n*Parameters*\n\n| Parameter | Type              | Description                |\n|-----------|-------------------|----------------------------|\n| name      | `string | symbol` | Name of the route to check |\n\n### isReady\n\nReturns a Promise that resolves when the router has completed the initial navigation, which means it has resolved all async enter hooks and async components that are associated with the initial route. If the initial navigation already happened, the promise resolves immediately.This is useful in server-side rendering to ensure consistent output on both the server and the client. Note that on server side, you need to manually push the initial location while on client side, the router automatically picks it up from the URL.\n\n**Signature:**\n\n    isReady(): Promise<void>\n\n### onError\n\nAdds an error handler that is called every time a non caught error happens during navigation. This includes errors thrown synchronously and asynchronously, errors returned or passed to `next` in any navigation guard, and errors occurred when trying to resolve an async component that is required to render a route.\n\n**Signature:**\n\n    onError(handler: (error: any, to: RouteLocationNormalized, from: RouteLocationNormalized) => any): () => void\n\n*Parameters*\n\n| Parameter | Type                                                                              | Description               |\n|-----------|-----------------------------------------------------------------------------------|---------------------------|\n| handler   | `(error: any, to: RouteLocationNormalized, from: RouteLocationNormalized) => any` | error handler to register |\n\n### push\n\nProgrammatically navigate to a new URL by pushing an entry in the history stack.\n\n**Signature:**\n\n    push(to: RouteLocationRaw): Promise<NavigationFailure | void | undefined>\n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Route location to navigate to |\n\n### removeRoute\n\nRemove an existing route by its name.\n\n**Signature:**\n\n    removeRoute(name: string | symbol): void\n\n*Parameters*\n\n| Parameter | Type              | Description                 |\n|-----------|-------------------|-----------------------------|\n| name      | `string | symbol` | Name of the route to remove |\n\n### replace\n\nProgrammatically navigate to a new URL by replacing the current entry in the history stack.\n\n**Signature:**\n\n    replace(to: RouteLocationRaw): Promise<NavigationFailure | void | undefined>\n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Route location to navigate to |\n\n### resolve\n\nReturns the [normalized version](#routelocation) of a [route location](#routelocationraw). Also includes an `href` property that includes any existing `base`.\n\n**Signature:**\n\n    resolve(to: RouteLocationRaw): RouteLocation & {\n      href: string\n    }\n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Raw route location to resolve |\n\n## RouterOptions\n\n### history\n\nHistory implementation used by the router. Most web applications should use `createWebHistory` but it requires the server to be properly configured. You can also use a *hash* based history with `createWebHashHistory` that does not require any configuration on the server but isn't handled at all by search engines and does poorly on SEO.\n\n**Signature:**\n\n    history: RouterHistory\n\n#### Examples\n\n    createRouter({\n      history: createWebHistory(),\n      // other options...\n    })\n\n### linkActiveClass\n\nDefault class applied to active [RouterLink](#router-link-props). If none is provided, `router-link-active` will be applied.\n\n**Signature:**\n\n    linkActiveClass?: string\n\n### linkExactActiveClass\n\nDefault class applied to exact active [RouterLink](#router-link-props). If none is provided, `router-link-exact-active` will be applied.\n\n**Signature:**\n\n    linkExactActiveClass?: string\n\n### parseQuery\n\nCustom implementation to parse a query. Must decode query keys and values. See its counterpart, [stringifyQuery](#stringifyquery).\n\n**Signature:**\n\n    parseQuery?: (searchQuery: string) => Record<string, (string | null)[] | string | null>\n\n#### Examples\n\nLet's say you want to use the package [qs](https://github.com/ljharb/qs) to parse queries, you can provide both `parseQuery` and `stringifyQuery`:\n\n    import qs from 'qs'\n\n    createRouter({\n      // other options...\n      parseQuery: qs.parse,\n      stringifyQuery: qs.stringify,\n    })\n\n### routes\n\nInitial list of routes that should be added to the router.\n\n**Signature:**\n\n    routes: RouteRecordRaw[]\n\n### scrollBehavior\n\nFunction to control scrolling when navigating between pages. Can return a Promise to delay when the scrolling happens. See [Scroll Behaviour](../guide/advanced/scroll-behavior) for more details.\n\n**Signature:**\n\n    scrollBehavior?: RouterScrollBehavior\n\n#### Examples\n\n    function scrollBehavior(to, from, savedPosition) {\n      // `to` and `from` are both route locations\n      // `savedPosition` can be null if there isn't one\n    }\n\n### stringifyQuery\n\nCustom implementation to stringify a query object. Should not prepend a leading `?`. Should properly encode query keys and values. [parseQuery](#parsequery) counterpart to handle query parsing.\n\n**Signature:**\n\n    stringifyQuery?: (\n      query: Record<\n        string | number,\n        string | number | null | undefined | (string | number | null | undefined)[]\n      >\n    ) => string\n\n## RouteRecordRaw\n\nRoute record that can be provided by the user when adding routes via the [`routes` option](#routeroptions) or via [`router.addRoute()`](#addroute-2). There are three different kind of route records:\n\n- Single views records: have a `component` option\n- Multiple views records ([named views](../guide/essentials/named-views)): have a `components` option\n- Redirect records: cannot have `component` or `components` option because a redirect record is never reached.\n\n### path\n\n- **Type**: `string`\n\n- **Details**:\n\n  Path of the record. Should start with `/` unless the record is the child of another record. Can define parameters: `/users/:id` matches `/users/1` as well as `/users/posva`.\n\n- **See Also**: [Dynamic Route Matching](../guide/essentials/dynamic-matching)\n\n### redirect\n\n- **Type**: `RouteLocationRaw | (to: RouteLocationNormalized) => RouteLocationRaw` (Optional)\n\n- **Details**:\n\n  Where to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location. Can also be a function that receives the target route location and returns the location we should redirect to.\n\n### children\n\n- **Type**: Array of [`RouteRecordRaw`](#routerecordraw) (Optional)\n\n- **Details**:\n\n  Nested routes of the current record.\n\n- **See Also**: [Nested Routes](../guide/essentials/nested-routes)\n\n### alias\n\n- **Type**: `string | string[]` (Optional)\n\n- **Details**:\n\n  Aliases for the route. Allows defining extra paths that will behave like a copy of the record. This enables paths shorthands like `/users/:id` and `/u/:id`. **All `alias` and `path` values must share the same params**.\n\n### name\n\n- **Type**: `string | symbol` (Optional)\n\n- **Details**:\n\n  Unique name for the route record.\n\n### beforeEnter\n\n- **Type**: [`NavigationGuard | NavigationGuard[]`](#navigationguard) (Optional)\n\n- **Details**:\n\n  Before enter guard specific to this record. Note `beforeEnter` has no effect if the record has a `redirect` property.\n\n### props\n\n- **Type**: `boolean | Record<string, any> | (to: RouteLocationNormalized) => Record<string, any>` (Optional)\n\n- **Details**:\n\n  Allows passing down params as props to the component rendered by `router-view`. When passed to a *multiple views record*, it should be an object with the same keys as `components` or a `boolean` to be applied to each component. target location.\n\n- **See Also**: [Passing props to Route Components](../guide/essentials/passing-props)\n\n### meta\n\n- **Type**: [`RouteMeta`](#routemeta) (Optional)\n\n- **Details**:\n\n  Custom data attached to the record.\n\n- **See Also**: [Meta fields](../guide/advanced/meta)\n\n**TIP**\n\nIf you want to use a functional component, make sure to add a `displayName` to it.\n\nFor example:\n\n    const HomeView = () => h('div', 'HomePage')\n    // in TypeScript, you will need to use the FunctionalComponent type\n    HomeView.displayName = 'HomeView'\n    const routes = [{ path: '/', component: HomeView }]\n\n## RouteRecordNormalized\n\nNormalized version of a [Route Record](#routerecordraw)\n\n### aliasOf\n\n- **Type**: `RouteRecordNormalized | undefined`\n\n- **Details**:\n\n  Defines if this record is the alias of another one. This property is `undefined` if the record is the original one.\n\n### beforeEnter\n\n- **Type**: [`NavigationGuard`](#navigationguard)\n\n- **Details**:\n\n  Navigation guard applied when entering this record from somewhere else.\n\n- **See Also**: [Navigation guards](../guide/advanced/navigation-guards)\n\n### children\n\n- **Type**: Array of normalized [route records](#routerecordnormalized)\n\n- **Details**:\n\n  Children route records of a route at the time it was added. Empty array if none. Note this array doesn't update when `addRoute()` and `removeRoute()` are called.\n\n### components\n\n- **Type**: `Record<string, Component>`\n\n- **Details**:\n\n  Dictionary of named views, if none, contains an object with the key `default`.\n\n### meta\n\n- **Type**: `RouteMeta`\n\n- **Details**:\n\n  Arbitrary data attached to the record.\n\n- **See also**: [Meta fields](../guide/advanced/meta)\n\n### name\n\n- **Type**: `string | symbol | undefined`\n\n- **Details**:\n\n  Name for the route record. `undefined` if none was provided.\n\n### path\n\n- **Type**: `string`\n\n- **Details**:\n\n  Normalized path of the record. Includes any parent's `path`.\n\n### props\n\n- **Type**: `Record<string, boolean | Function | Record<string, any>>`\n\n- **Details**:\n\n  Dictionary of the [`props` option](#props) for each named view. If none, it will contain only one property named `default`.\n\n### redirect\n\n- **Type**: [`RouteLocationRaw`](#routelocationraw)\n\n- **Details**:\n\n  Where to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\n## RouteLocationRaw\n\nUser-level route location that can be passed to `router.push()`, `redirect`, and returned in [Navigation Guards](../guide/advanced/navigation-guards).\n\nA raw location can either be a `string` like `/users/posva#bio` or an object:\n\n    // these three forms are equivalent\n    router.push('/users/posva#bio')\n    router.push({ path: '/users/posva', hash: '#bio' })\n    router.push({ name: 'users', params: { username: 'posva' }, hash: '#bio' })\n    // only change the hash\n    router.push({ hash: '#bio' })\n    // only change query\n    router.push({ query: { page: '2' } })\n    // change one param\n    router.push({ params: { username: 'jolyne' } })\n\nNote `path` must be provided encoded (e.g. `phantom blood` becomes `phantom%20blood`) while `params`, `query` and `hash` must not, they are encoded by the router.\n\nRaw route locations also support an extra option `replace` to call `router.replace()` instead of `router.push()` in navigation guards. Note this also internally calls `router.replace()` even when calling `router.push()`:\n\n    router.push({ hash: '#bio', replace: true })\n    // equivalent to\n    router.replace({ hash: '#bio' })\n\n## RouteLocation\n\nResolved [RouteLocationRaw](#routelocationraw) that can contain [redirect records](#routerecordraw). Apart from that it has the same properties as [RouteLocationNormalized](#routelocationnormalized).\n\n## RouteLocationNormalized\n\nNormalized route location. Does not have any [redirect records](#routerecordraw). In navigation guards, `to` and `from` are always of this type.\n\n### fullPath\n\n- **Type**: `string`\n\n- **Details**:\n\n  Encoded URL associated to the route location. Contains `path`, `query` and `hash`.\n\n### hash\n\n- **Type**: `string`\n\n- **Details**:\n\n  Decoded `hash` section of the URL. Always starts with a `#`. Empty string if there is no `hash` in the URL.\n\n### query\n\n- **Type**: `Record<string, string | string[]>`\n\n- **Details**:\n\n  Dictionary of decoded query params extracted from the `search` section of the URL.\n\n### matched\n\n- **Type**: [`RouteRecordNormalized[]`](#routerecordnormalized)\n\n- **Details**:\n\n  Array of [normalized route records](#routerecord) that were matched with the given route location.\n\n### meta\n\n- **Type**: `RouteMeta`\n\n- **Details**:\n\n  Arbitrary data attached to all matched records merged (non recursively) from parent to child.\n\n- **See also**: [Meta fields](../guide/advanced/meta)\n\n### name\n\n- **Type**: `string | symbol | undefined | null`\n\n- **Details**:\n\n  Name for the route record. `undefined` if none was provided.\n\n### params\n\n- **Type**: `Record<string, string | string[]>`\n\n- **Details**:\n\n  Dictionary of decoded params extracted from `path`.\n\n### path\n\n- **Type**: `string`\n\n- **Details**:\n\n  Encoded `pathname` section of the URL associated to the route location.\n\n### redirectedFrom\n\n- **Type**: [`RouteLocation`](#routelocation)\n\n- **Details**:\n\n  Route location we were initially trying to access before ending up on the current location when a `redirect` option was found or a navigation guard called `next()` with a route location. `undefined` if there was no redirection.\n\n## NavigationFailure\n\n### from\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  Route location we were navigating from\n\n### to\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  Route location we were navigating to\n\n### type\n\n- **Type**: [`NavigationFailureType`](#navigationfailuretype)\n\n- **Details**:\n\n  Type of the navigation failure.\n\n- **See Also**: [Navigation Failures](../guide/advanced/navigation-failures)\n\n## NavigationGuard\n\n- **Arguments**:\n\n  - [`RouteLocationNormalized`](#routelocationnormalized) to - Route location we are navigating to\n  - [`RouteLocationNormalized`](#routelocationnormalized) from - Route location we are navigating from\n  - `Function` next (Optional) - Callback to validate the navigation\n\n- **Details**:\n\n  Function that can be passed to control a router navigation. The `next` callback can be omitted if you return a value (or a Promise) instead, which is encouraged. Possible return values (and parameters for `next`) are:\n\n  - `undefined | void | true`: validates the navigation\n  - `false`: cancels the navigation\n  - [`RouteLocationRaw`](#routelocationraw): redirects to a different location\n  - `(vm: ComponentPublicInstance) => any` **only for `beforeRouteEnter`**: A callback to be executed once the navigation completes. Receives the route component instance as the parameter.\n\n- **See Also**: [Navigation Guards](../guide/advanced/navigation-guards)\n\n## Component Injections\n\n### Component Injected Properties\n\nThese properties are injected into every child component by calling `app.use(router)`.\n\n- **this.$router**\n\n  The router instance.\n\n- **this.$route**\n\n  The current active [route location](#routelocationnormalized). This property is read-only and its properties are immutable, but it can be watched.\n\n### Component Enabled Options\n\n- **beforeRouteEnter**\n- **beforeRouteUpdate**\n- **beforeRouteLeave**\n\nSee [In Component Guards](../guide/advanced/navigation-guards#in-component-guards).\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/api/index.md)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/api/index.html](https://next.router.vuejs.org/api/index.html)"
- name: active-class
  id: api/index#active-class
  summary: Class to apply on the rendered <a> when the link is active
  belongs_to: API Reference
  description: |-
    ### active-class

    - **Type**: `string`

    - **Default**: `"router-link-active"` (or global [`linkActiveClass`](#linkactiveclass))

    - **Details**:

      Class to apply on the rendered `<a>` when the link is active.
- name: addRoute
  id: api/index#addroute-1
  summary: Add a new route record to the router
  belongs_to: API Reference
  description: "### addRoute\n\nAdd a new [route record](#routerecordraw) to the router. If the route has a `name` and there is already an existing one with the same one, it removes it first.\n\n**Signature:**\n\n                  addRoute(route: RouteRecordRaw): () => void\n\n                \n\n*Parameters*\n\n| Parameter | Type                                | Description         |\n|-----------|-------------------------------------|---------------------|\n| route     | [`RouteRecordRaw`](#routerecordraw) | Route Record to add |\n\n**TIP**\n\nNote adding routes does not trigger a new navigation, meaning that the added route will not be displayed unless a new navigation is triggered."
- name: addRoute
  id: api/index#addroute
  summary: Add a new Route Record as the child of an existing route
  belongs_to: API Reference
  description: "### addRoute\n\nAdd a new [Route Record](#routerecordraw) as the child of an existing route. If the route has a `name` and there is already an existing one with the same one, it removes it first.\n\n**Signature:**\n\n                  addRoute(parentName:string|symbol, route: RouteRecordRaw): () => void\n\n                \n\n*Parameters*\n\n| Parameter  | Type                                | Description                                             |\n|------------|-------------------------------------|---------------------------------------------------------|\n| parentName | `string | symbol`                   | Parent Route Record where `route` should be appended at |\n| route      | [`RouteRecordRaw`](#routerecordraw) | Route Record to add                                     |"
- name: afterEach
  id: api/index#aftereach
  summary: Add a navigation hook that is executed after every navigation
  belongs_to: API Reference
  description: "### afterEach\n\nAdd a navigation hook that is executed after every navigation. Returns a function that removes the registered hook.\n\n**Signature:**\n\n                  afterEach(guard: NavigationHookAfter): () => void\n\n                \n\n*Parameters*\n\n| Parameter | Type                  | Description            |\n|-----------|-----------------------|------------------------|\n| guard     | `NavigationHookAfter` | navigation hook to add |\n\n#### Examples\n\n                  router.afterEach((to, from, failure) => {\n      if (isNavigationFailure(failure)) {\n        console.log('failed navigation', failure)\n      }\n    })"
- name: alias
  id: api/index#alias
  summary: Aliases for the route
  belongs_to: API Reference
  description: |-
    ### alias

    - **Type**: `string | string[]` (Optional)

    - **Details**:

      Aliases for the route. Allows defining extra paths that will behave like a copy of the record. This enables paths shorthands like `/users/:id` and `/u/:id`. **All `alias` and `path` values must share the same params**.

    &nbsp;
- name: aliasOf
  id: api/index#aliasof
  summary: Defines if this record is the alias of another one
  belongs_to: API Reference
  description: |-
    ### aliasOf

    - **Type**: `RouteRecordNormalized | undefined`

    - **Details**:

      Defines if this record is the alias of another one. This property is `undefined` if the record is the original one.

    &nbsp;
- name: API Reference
  id: api/index
  summary: Denotes the target route of the link
  description: "# API Reference\n\n## `<router-link>` Props\n\n### to\n\n- **Type**: [`RouteLocationRaw`](#routelocationraw)\n\n- **Details**:\n\n  Denotes the target route of the link. When clicked, the value of the `to` prop will be passed to `router.push()` internally, so it can either be a `string` or a [route location object](#routelocationraw).\n\n    <!-- literal string -->\n    <router-link to=\"/home\">Home</router-link>\n    <!-- renders to -->\n    <a href=\"/home\">Home</a>\n\n    <!-- javascript expression using `v-bind` -->\n    <router-link :to=\"'/home'\">Home</router-link>\n\n    <!-- same as above -->\n    <router-link :to=\"{ path: '/home' }\">Home</router-link>\n\n    <!-- named route -->\n    <router-link :to=\"{ name: 'user', params: { userId: '123' }}\">User</router-link>\n\n    <!-- with query, resulting in `/register?plan=private` -->\n    <router-link :to=\"{ path: '/register', query: { plan: 'private' }}\">\n      Register\n    </router-link>\n\n### replace\n\n- **Type**: `boolean`\n\n- **Default**: `false`\n\n- **Details**:\n\n  Setting `replace` prop will call `router.replace()` instead of `router.push()` when clicked, so the navigation will not leave a history record.\n\n    <router-link to=\"/abc\" replace></router-link>\n\n### active-class\n\n- **Type**: `string`\n\n- **Default**: `\"router-link-active\"` (or global [`linkActiveClass`](#linkactiveclass))\n\n- **Details**:\n\n  Class to apply on the rendered `<a>` when the link is active.\n\n### aria-current-value\n\n- **Type**: `'page' | 'step' | 'location' | 'date' | 'time' | 'true' | 'false'` (`string`)\n\n- **Default**: `\"page\"`\n\n- **Details**:\n\n  Value passed to the attribute `aria-current` when the link is exactly active.\n\n### custom\n\n- **Type**: `boolean`\n\n- **Default**: `false`\n\n- **Details**:\n\n  Whether `<router-link>` should not wrap its content in an `<a>` element. Useful when using [`v-slot`](#router-link-s-v-slot) to create a custom RouterLink. By default, `<router-link>` will render its content wrapped in an `<a>` element, even when using `v-slot`. Passing the `custom` prop, removes that behavior.\n\n- **Examples**:\n\n      <router-link to=\"/home\" custom v-slot=\"{ navigate, href, route }\">\n        <a :href=\"href\" @click=\"navigate\">{{ route.fullPath }}</a>\n      </router-link>\n\n  Renders `<a href=\"/home\">/home</a>`.\n\n      <router-link to=\"/home\" v-slot=\"{ route }\">\n        <span>{{ route.fullPath }}</span>\n      </router-link>\n\n  Renders `<a href=\"/home\"><span>/home</span></a>`.\n\n### exact-active-class\n\n- **Type**: `string`\n\n- **Default**: `\"router-link-exact-active\"` (or global [`linkExactActiveClass`](#linkexactactiveclass))\n\n- **Details**:\n\n  Class to apply on the rendered `<a>` when the link is exact active.\n\n## `<router-link>`'s `v-slot`\n\n`<router-link>` exposes a low level customization through a [scoped slot](https://v3.vuejs.org/guide/component-slots.html#scoped-slots). This is a more advanced API that primarily targets library authors but can come in handy for developers as well, to build a custom component like a *NavLink* or other.\n\n**TIP**\n\nRemember to pass the `custom` option to `<router-link>` to prevent it from wrapping its content inside of an `<a>` element.\n\n    <router-link\n      to=\"/about\"\n      custom\n      v-slot=\"{ href, route, navigate, isActive, isExactActive }\"\n    >\n      <NavLink :active=\"isActive\" :href=\"href\" @click=\"navigate\">\n        {{ route.fullPath }}\n      </NavLink>\n    </router-link>\n\n- `href`: resolved url. This would be the `href` attribute of an `<a>` element. It contains the `base` if any was provided.\n- `route`: resolved normalized location.\n- `navigate`: function to trigger the navigation. **It will automatically prevent events when necessary**, the same way `router-link` does, e.g. `ctrl` or `cmd` + click will still be ignored by `navigate`.\n- `isActive`: `true` if the [active class](#active-class) should be applied. Allows to apply an arbitrary class.\n- `isExactActive`: `true` if the [exact active class](#exact-active-class) should be applied. Allows to apply an arbitrary class.\n\n### Example: Applying Active Class to Outer Element\n\nSometimes we may want the active class to be applied to an outer element rather than the `<a>` element itself, in that case, you can wrap that element inside a `router-link` and use the `v-slot` properties to create your link:\n\n    <router-link\n      to=\"/foo\"\n      custom\n      v-slot=\"{ href, route, navigate, isActive, isExactActive }\"\n    >\n      <li\n        :class=\"[isActive && 'router-link-active', isExactActive && 'router-link-exact-active']\"\n      >\n        <a :href=\"href\" @click=\"navigate\">{{ route.fullPath }}</a>\n      </li>\n    </router-link>\n\n**TIP**\n\nIf you add a `target=\"_blank\"` to your `a` element, you must omit the `@click=\"navigate\"` handler.\n\n## `<router-view>` Props\n\n### name\n\n- **Type**: `string`\n\n- **Default**: `\"default\"`\n\n- **Details**:\n\n  When a `<router-view>` has a `name`, it will render the component with the corresponding name in the matched route record's `components` option.\n\n- **See Also**: [Named Views](../guide/essentials/named-views)\n\n### route\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  A route location that has all of its component resolved (if any was lazy loaded) so it can be displayed.\n\n## `<router-view>`'s `v-slot`\n\n`<router-view>` exposes a `v-slot` API mainly to wrap your route components with `<transition>` and `<keep-alive>` components.\n\n    <router-view v-slot=\"{ Component, route }\">\n      <transition :name=\"route.meta.transition || 'fade'\" mode=\"out-in\">\n        <keep-alive>\n          <suspense>\n            <template #default>\n              <component\n                :is=\"Component\"\n                :key=\"route.meta.usePathKey ? route.path : undefined\"\n              />\n            </template>\n            <template #fallback> Loading... </template>\n          </suspense>\n        </keep-alive>\n      </transition>\n    </router-view>\n\n- `Component`: VNodes to be passed to a `<component>`'s `is` prop.\n- `route`: resolved normalized [route location](#routelocationnormalized).\n\n## createRouter\n\nCreates a Router instance that can be used by a Vue app. Check the [`RouterOptions`](#routeroptions) for a list of all the properties that can be passed.\n\n**Signature:**\n\n    export declare function createRouter(options: RouterOptions): Router\n\n### Parameters\n\n| Parameter | Type                            | Description                      |\n|-----------|---------------------------------|----------------------------------|\n| options   | [RouterOptions](#routeroptions) | Options to initialize the router |\n\n## createWebHistory\n\nCreates an HTML5 history. Most common history for single page applications. The application must be served through the http protocol.\n\n**Signature:**\n\n    export declare function createWebHistory(base?: string): RouterHistory\n\n### Parameters\n\n| Parameter | Type     | Description                                                                                                           |\n|-----------|----------|-----------------------------------------------------------------------------------------------------------------------|\n| base      | `string` | optional base to provide. Useful when the application is hosted inside of a folder like `https://example.com/folder/` |\n\n### Examples\n\n    createWebHistory() // No base, the app is hosted at the root of the domain `https://example.com`\n    createWebHistory('/folder/') // gives a url of `https://example.com/folder/`\n\n## createWebHashHistory\n\nCreates a hash history. Useful for web applications with no host (e.g. `file://`) or when configuring a server to handle any URL isn't an option. **Note you should use [`createWebHistory`](#createwebhistory) if SEO matters to you**.\n\n**Signature:**\n\n    export declare function createWebHashHistory(base?: string): RouterHistory\n\n### Parameters\n\n| Parameter | Type     | Description                                                                                                                                                                                                                                                                                                                                                       |\n|-----------|----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| base      | `string` | optional base to provide. Defaults to `location.pathname + location.search`. If there is a `<base>` tag in the `head`, its value will be ignored in favor of this parameter **but note it affects all the history.pushState() calls**, meaning that if you use a `<base>` tag, its `href` value **has to match this parameter** (ignoring anything after the `#`) |\n\n### Examples\n\n    // at https://example.com/folder\n    createWebHashHistory() // gives a url of `https://example.com/folder#`\n    createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\n    // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\n    createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\n    // you should avoid doing this because it changes the original url and breaks copying urls\n    createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\n\n    // at file:///usr/etc/folder/index.html\n    // for locations with no `host`, the base is ignored\n    createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\n\n## createMemoryHistory\n\nCreates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere. If the user is not on a browser context, it's up to them to replace that location with the starter location by either calling `router.push()` or `router.replace()`.\n\n**Signature:**\n\n    export declare function createMemoryHistory(base?: string): RouterHistory\n\n### Parameters\n\n| Parameter | Type     | Description                               |\n|-----------|----------|-------------------------------------------|\n| base      | `string` | Base applied to all urls, defaults to '/' |\n\n### Returns\n\nA history object that can be passed to the router constructor\n\n## NavigationFailureType\n\nEnumeration with all possible types for navigation failures. Can be passed to [isNavigationFailure](#isnavigationfailure) to check for specific failures. **Never use any of the numerical values**, always use the variables like `NavigationFailureType.aborted`.\n\n**Signature:**\n\n    export declare enum NavigationFailureType\n\n### Members\n\n| Member     | Value | Description                                                                                                                      |\n|------------|-------|----------------------------------------------------------------------------------------------------------------------------------|\n| aborted    | 4     | An aborted navigation is a navigation that failed because a navigation guard returned `false` or called `next(false)`            |\n| cancelled  | 8     | A cancelled navigation is a navigation that failed because a more recent navigation finished started (not necessarily finished). |\n| duplicated | 16    | A duplicated navigation is a navigation that failed because it was initiated while already being at the exact same location.     |\n\n## START_LOCATION\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  Initial route location where the router is. Can be used in navigation guards to differentiate the initial navigation.\n\n      import { START_LOCATION } from 'vue-router'\n\n      router.beforeEach((to, from) => {\n        if (from === START_LOCATION) {\n          // initial navigation\n        }\n      })\n\n## Composition API\n\n### onBeforeRouteLeave\n\nAdd a navigation guard that triggers whenever the component for the current location is about to be left. Similar to `beforeRouteLeave` but can be used in any component. The guard is removed when the component is unmounted.\n\n**Signature:**\n\n    export declare function onBeforeRouteLeave(leaveGuard: NavigationGuard): void\n\n#### Parameters\n\n| Parameter  | Type                                  | Description             |\n|------------|---------------------------------------|-------------------------|\n| leaveGuard | [`NavigationGuard`](#navigationguard) | Navigation guard to add |\n\n### onBeforeRouteUpdate\n\nAdd a navigation guard that triggers whenever the current location is about to be updated. Similar to `beforeRouteUpdate` but can be used in any component. The guard is removed when the component is unmounted.\n\n**Signature:**\n\n    export declare function onBeforeRouteUpdate(updateGuard: NavigationGuard): void\n\n#### Parameters\n\n| Parameter   | Type                                  | Description             |\n|-------------|---------------------------------------|-------------------------|\n| updateGuard | [`NavigationGuard`](#navigationguard) | Navigation guard to add |\n\n### useLink\n\nReturns everything exposed by the [`v-slot` API](#router-link-s-v-slot).\n\n**Signature:**\n\n    export declare function useLink(props: RouterLinkOptions): {\n      route: ComputedRef<RouteLocationNormalized & { href: string }>,\n      href: ComputedRef<string>,\n      isActive: ComputedRef<boolean>,\n      isExactActive: ComputedRef<boolean>,\n      navigate: (event?: MouseEvent) => Promise(NavigationFailure | void),\n    }\n\n#### Parameters\n\n| Parameter | Type                | Description                                                                           |\n|-----------|---------------------|---------------------------------------------------------------------------------------|\n| props     | `RouterLinkOptions` | props object that can be passed to `<router-link>`. Accepts `Ref`s and `ComputedRef`s |\n\n### useRoute\n\nReturns the current route location. Equivalent to using `$route` inside templates. Must be called inside of `setup()`.\n\n**Signature:**\n\n    export declare function useRoute(): RouteLocationNormalized\n\n### useRouter\n\nReturns the [router](#router-properties) instance. Equivalent to using `$router` inside templates. Must be called inside of `setup()`.\n\n**Signature:**\n\n    export declare function useRouter(): Router\n\n## TypeScript\n\nHere are some of the interfaces and types used by Vue Router. The documentation references them to give you an idea of the existing properties in objects.\n\n## Router Properties\n\n### currentRoute\n\n- **Type**: [`Ref<RouteLocationNormalized>`](#routelocationnormalized)\n\n- **Details**:\n\n  Current route location. Readonly.\n\n### options\n\n- **Type**: [`RouterOptions`](#routeroptions)\n\n- **Details**:\n\n  Original options object passed to create the Router. Readonly.\n\n## Router Methods\n\n### addRoute\n\nAdd a new [Route Record](#routerecordraw) as the child of an existing route. If the route has a `name` and there is already an existing one with the same one, it removes it first.\n\n**Signature:**\n\n    addRoute(parentName: string | symbol, route: RouteRecordRaw): () => void\n\n*Parameters*\n\n| Parameter  | Type                                | Description                                             |\n|------------|-------------------------------------|---------------------------------------------------------|\n| parentName | `string | symbol`                   | Parent Route Record where `route` should be appended at |\n| route      | [`RouteRecordRaw`](#routerecordraw) | Route Record to add                                     |\n\n### addRoute\n\nAdd a new [route record](#routerecordraw) to the router. If the route has a `name` and there is already an existing one with the same one, it removes it first.\n\n**Signature:**\n\n    addRoute(route: RouteRecordRaw): () => void\n\n*Parameters*\n\n| Parameter | Type                                | Description         |\n|-----------|-------------------------------------|---------------------|\n| route     | [`RouteRecordRaw`](#routerecordraw) | Route Record to add |\n\n**TIP**\n\nNote adding routes does not trigger a new navigation, meaning that the added route will not be displayed unless a new navigation is triggered.\n\n### afterEach\n\nAdd a navigation hook that is executed after every navigation. Returns a function that removes the registered hook.\n\n**Signature:**\n\n    afterEach(guard: NavigationHookAfter): () => void\n\n*Parameters*\n\n| Parameter | Type                  | Description            |\n|-----------|-----------------------|------------------------|\n| guard     | `NavigationHookAfter` | navigation hook to add |\n\n#### Examples\n\n    router.afterEach((to, from, failure) => {\n      if (isNavigationFailure(failure)) {\n        console.log('failed navigation', failure)\n      }\n    })\n\n### back\n\nGo back in history if possible by calling `history.back()`. Equivalent to `router.go(-1)`.\n\n**Signature:**\n\n    back(): void\n\n### beforeEach\n\nAdd a navigation guard that executes before any navigation. Returns a function that removes the registered guard.\n\n**Signature:**\n\n    beforeEach(guard: NavigationGuard): () => void\n\n*Parameters*\n\n| Parameter | Type                                  | Description             |\n|-----------|---------------------------------------|-------------------------|\n| guard     | [`NavigationGuard`](#navigationguard) | navigation guard to add |\n\n### beforeResolve\n\nAdd a navigation guard that executes before navigation is about to be resolved. At this state all component have been fetched and other navigation guards have been successful. Returns a function that removes the registered guard.\n\n**Signature:**\n\n    beforeResolve(guard: NavigationGuard): () => void\n\n*Parameters*\n\n| Parameter | Type                                  | Description             |\n|-----------|---------------------------------------|-------------------------|\n| guard     | [`NavigationGuard`](#navigationguard) | navigation guard to add |\n\n#### Examples\n\n    router.beforeResolve(to => {\n      if (to.meta.requiresAuth && !isAuthenticated) return false\n    })\n\n### forward\n\nGo forward in history if possible by calling `history.forward()`. Equivalent to `router.go(1)`.\n\n**Signature:**\n\n    forward(): void\n\n### getRoutes\n\nGet a full list of all the [route records](#routerecord).\n\n**Signature:**\n\n    getRoutes(): RouteRecord[]\n\n### go\n\nAllows you to move forward or backward through the history.\n\n**Signature:**\n\n    go(delta: number): void\n\n*Parameters*\n\n| Parameter | Type     | Description                                                                         |\n|-----------|----------|-------------------------------------------------------------------------------------|\n| delta     | `number` | The position in the history to which you want to move, relative to the current page |\n\n### hasRoute\n\nChecks if a route with a given name exists\n\n**Signature:**\n\n    hasRoute(name: string | symbol): boolean\n\n*Parameters*\n\n| Parameter | Type              | Description                |\n|-----------|-------------------|----------------------------|\n| name      | `string | symbol` | Name of the route to check |\n\n### isReady\n\nReturns a Promise that resolves when the router has completed the initial navigation, which means it has resolved all async enter hooks and async components that are associated with the initial route. If the initial navigation already happened, the promise resolves immediately.This is useful in server-side rendering to ensure consistent output on both the server and the client. Note that on server side, you need to manually push the initial location while on client side, the router automatically picks it up from the URL.\n\n**Signature:**\n\n    isReady(): Promise<void>\n\n### onError\n\nAdds an error handler that is called every time a non caught error happens during navigation. This includes errors thrown synchronously and asynchronously, errors returned or passed to `next` in any navigation guard, and errors occurred when trying to resolve an async component that is required to render a route.\n\n**Signature:**\n\n    onError(handler: (error: any, to: RouteLocationNormalized, from: RouteLocationNormalized) => any): () => void\n\n*Parameters*\n\n| Parameter | Type                                                                              | Description               |\n|-----------|-----------------------------------------------------------------------------------|---------------------------|\n| handler   | `(error: any, to: RouteLocationNormalized, from: RouteLocationNormalized) => any` | error handler to register |\n\n### push\n\nProgrammatically navigate to a new URL by pushing an entry in the history stack.\n\n**Signature:**\n\n    push(to: RouteLocationRaw): Promise<NavigationFailure | void | undefined>\n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Route location to navigate to |\n\n### removeRoute\n\nRemove an existing route by its name.\n\n**Signature:**\n\n    removeRoute(name: string | symbol): void\n\n*Parameters*\n\n| Parameter | Type              | Description                 |\n|-----------|-------------------|-----------------------------|\n| name      | `string | symbol` | Name of the route to remove |\n\n### replace\n\nProgrammatically navigate to a new URL by replacing the current entry in the history stack.\n\n**Signature:**\n\n    replace(to: RouteLocationRaw): Promise<NavigationFailure | void | undefined>\n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Route location to navigate to |\n\n### resolve\n\nReturns the [normalized version](#routelocation) of a [route location](#routelocationraw). Also includes an `href` property that includes any existing `base`.\n\n**Signature:**\n\n    resolve(to: RouteLocationRaw): RouteLocation & {\n      href: string\n    }\n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Raw route location to resolve |\n\n## RouterOptions\n\n### history\n\nHistory implementation used by the router. Most web applications should use `createWebHistory` but it requires the server to be properly configured. You can also use a *hash* based history with `createWebHashHistory` that does not require any configuration on the server but isn't handled at all by search engines and does poorly on SEO.\n\n**Signature:**\n\n    history: RouterHistory\n\n#### Examples\n\n    createRouter({\n      history: createWebHistory(),\n      // other options...\n    })\n\n### linkActiveClass\n\nDefault class applied to active [RouterLink](#router-link-props). If none is provided, `router-link-active` will be applied.\n\n**Signature:**\n\n    linkActiveClass?: string\n\n### linkExactActiveClass\n\nDefault class applied to exact active [RouterLink](#router-link-props). If none is provided, `router-link-exact-active` will be applied.\n\n**Signature:**\n\n    linkExactActiveClass?: string\n\n### parseQuery\n\nCustom implementation to parse a query. Must decode query keys and values. See its counterpart, [stringifyQuery](#stringifyquery).\n\n**Signature:**\n\n    parseQuery?: (searchQuery: string) => Record<string, (string | null)[] | string | null>\n\n#### Examples\n\nLet's say you want to use the package [qs](https://github.com/ljharb/qs) to parse queries, you can provide both `parseQuery` and `stringifyQuery`:\n\n    import qs from 'qs'\n\n    createRouter({\n      // other options...\n      parseQuery: qs.parse,\n      stringifyQuery: qs.stringify,\n    })\n\n### routes\n\nInitial list of routes that should be added to the router.\n\n**Signature:**\n\n    routes: RouteRecordRaw[]\n\n### scrollBehavior\n\nFunction to control scrolling when navigating between pages. Can return a Promise to delay when the scrolling happens. See [Scroll Behaviour](../guide/advanced/scroll-behavior) for more details.\n\n**Signature:**\n\n    scrollBehavior?: RouterScrollBehavior\n\n#### Examples\n\n    function scrollBehavior(to, from, savedPosition) {\n      // `to` and `from` are both route locations\n      // `savedPosition` can be null if there isn't one\n    }\n\n### stringifyQuery\n\nCustom implementation to stringify a query object. Should not prepend a leading `?`. Should properly encode query keys and values. [parseQuery](#parsequery) counterpart to handle query parsing.\n\n**Signature:**\n\n    stringifyQuery?: (\n      query: Record<\n        string | number,\n        string | number | null | undefined | (string | number | null | undefined)[]\n      >\n    ) => string\n\n## RouteRecordRaw\n\nRoute record that can be provided by the user when adding routes via the [`routes` option](#routeroptions) or via [`router.addRoute()`](#addroute-2). There are three different kind of route records:\n\n- Single views records: have a `component` option\n- Multiple views records ([named views](../guide/essentials/named-views)): have a `components` option\n- Redirect records: cannot have `component` or `components` option because a redirect record is never reached.\n\n### path\n\n- **Type**: `string`\n\n- **Details**:\n\n  Path of the record. Should start with `/` unless the record is the child of another record. Can define parameters: `/users/:id` matches `/users/1` as well as `/users/posva`.\n\n- **See Also**: [Dynamic Route Matching](../guide/essentials/dynamic-matching)\n\n### redirect\n\n- **Type**: `RouteLocationRaw | (to: RouteLocationNormalized) => RouteLocationRaw` (Optional)\n\n- **Details**:\n\n  Where to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location. Can also be a function that receives the target route location and returns the location we should redirect to.\n\n### children\n\n- **Type**: Array of [`RouteRecordRaw`](#routerecordraw) (Optional)\n\n- **Details**:\n\n  Nested routes of the current record.\n\n- **See Also**: [Nested Routes](../guide/essentials/nested-routes)\n\n### alias\n\n- **Type**: `string | string[]` (Optional)\n\n- **Details**:\n\n  Aliases for the route. Allows defining extra paths that will behave like a copy of the record. This enables paths shorthands like `/users/:id` and `/u/:id`. **All `alias` and `path` values must share the same params**.\n\n### name\n\n- **Type**: `string | symbol` (Optional)\n\n- **Details**:\n\n  Unique name for the route record.\n\n### beforeEnter\n\n- **Type**: [`NavigationGuard | NavigationGuard[]`](#navigationguard) (Optional)\n\n- **Details**:\n\n  Before enter guard specific to this record. Note `beforeEnter` has no effect if the record has a `redirect` property.\n\n### props\n\n- **Type**: `boolean | Record<string, any> | (to: RouteLocationNormalized) => Record<string, any>` (Optional)\n\n- **Details**:\n\n  Allows passing down params as props to the component rendered by `router-view`. When passed to a *multiple views record*, it should be an object with the same keys as `components` or a `boolean` to be applied to each component. target location.\n\n- **See Also**: [Passing props to Route Components](../guide/essentials/passing-props)\n\n### meta\n\n- **Type**: [`RouteMeta`](#routemeta) (Optional)\n\n- **Details**:\n\n  Custom data attached to the record.\n\n- **See Also**: [Meta fields](../guide/advanced/meta)\n\n**TIP**\n\nIf you want to use a functional component, make sure to add a `displayName` to it.\n\nFor example:\n\n    const HomeView = () => h('div', 'HomePage')\n    // in TypeScript, you will need to use the FunctionalComponent type\n    HomeView.displayName = 'HomeView'\n    const routes = [{ path: '/', component: HomeView }]\n\n## RouteRecordNormalized\n\nNormalized version of a [Route Record](#routerecordraw)\n\n### aliasOf\n\n- **Type**: `RouteRecordNormalized | undefined`\n\n- **Details**:\n\n  Defines if this record is the alias of another one. This property is `undefined` if the record is the original one.\n\n### beforeEnter\n\n- **Type**: [`NavigationGuard`](#navigationguard)\n\n- **Details**:\n\n  Navigation guard applied when entering this record from somewhere else.\n\n- **See Also**: [Navigation guards](../guide/advanced/navigation-guards)\n\n### children\n\n- **Type**: Array of normalized [route records](#routerecordnormalized)\n\n- **Details**:\n\n  Children route records of a route at the time it was added. Empty array if none. Note this array doesn't update when `addRoute()` and `removeRoute()` are called.\n\n### components\n\n- **Type**: `Record<string, Component>`\n\n- **Details**:\n\n  Dictionary of named views, if none, contains an object with the key `default`.\n\n### meta\n\n- **Type**: `RouteMeta`\n\n- **Details**:\n\n  Arbitrary data attached to the record.\n\n- **See also**: [Meta fields](../guide/advanced/meta)\n\n### name\n\n- **Type**: `string | symbol | undefined`\n\n- **Details**:\n\n  Name for the route record. `undefined` if none was provided.\n\n### path\n\n- **Type**: `string`\n\n- **Details**:\n\n  Normalized path of the record. Includes any parent's `path`.\n\n### props\n\n- **Type**: `Record<string, boolean | Function | Record<string, any>>`\n\n- **Details**:\n\n  Dictionary of the [`props` option](#props) for each named view. If none, it will contain only one property named `default`.\n\n### redirect\n\n- **Type**: [`RouteLocationRaw`](#routelocationraw)\n\n- **Details**:\n\n  Where to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\n## RouteLocationRaw\n\nUser-level route location that can be passed to `router.push()`, `redirect`, and returned in [Navigation Guards](../guide/advanced/navigation-guards).\n\nA raw location can either be a `string` like `/users/posva#bio` or an object:\n\n    // these three forms are equivalent\n    router.push('/users/posva#bio')\n    router.push({ path: '/users/posva', hash: '#bio' })\n    router.push({ name: 'users', params: { username: 'posva' }, hash: '#bio' })\n    // only change the hash\n    router.push({ hash: '#bio' })\n    // only change query\n    router.push({ query: { page: '2' } })\n    // change one param\n    router.push({ params: { username: 'jolyne' } })\n\nNote `path` must be provided encoded (e.g. `phantom blood` becomes `phantom%20blood`) while `params`, `query` and `hash` must not, they are encoded by the router.\n\nRaw route locations also support an extra option `replace` to call `router.replace()` instead of `router.push()` in navigation guards. Note this also internally calls `router.replace()` even when calling `router.push()`:\n\n    router.push({ hash: '#bio', replace: true })\n    // equivalent to\n    router.replace({ hash: '#bio' })\n\n## RouteLocation\n\nResolved [RouteLocationRaw](#routelocationraw) that can contain [redirect records](#routerecordraw). Apart from that it has the same properties as [RouteLocationNormalized](#routelocationnormalized).\n\n## RouteLocationNormalized\n\nNormalized route location. Does not have any [redirect records](#routerecordraw). In navigation guards, `to` and `from` are always of this type.\n\n### fullPath\n\n- **Type**: `string`\n\n- **Details**:\n\n  Encoded URL associated to the route location. Contains `path`, `query` and `hash`.\n\n### hash\n\n- **Type**: `string`\n\n- **Details**:\n\n  Decoded `hash` section of the URL. Always starts with a `#`. Empty string if there is no `hash` in the URL.\n\n### query\n\n- **Type**: `Record<string, string | string[]>`\n\n- **Details**:\n\n  Dictionary of decoded query params extracted from the `search` section of the URL.\n\n### matched\n\n- **Type**: [`RouteRecordNormalized[]`](#routerecordnormalized)\n\n- **Details**:\n\n  Array of [normalized route records](#routerecord) that were matched with the given route location.\n\n### meta\n\n- **Type**: `RouteMeta`\n\n- **Details**:\n\n  Arbitrary data attached to all matched records merged (non recursively) from parent to child.\n\n- **See also**: [Meta fields](../guide/advanced/meta)\n\n### name\n\n- **Type**: `string | symbol | undefined | null`\n\n- **Details**:\n\n  Name for the route record. `undefined` if none was provided.\n\n### params\n\n- **Type**: `Record<string, string | string[]>`\n\n- **Details**:\n\n  Dictionary of decoded params extracted from `path`.\n\n### path\n\n- **Type**: `string`\n\n- **Details**:\n\n  Encoded `pathname` section of the URL associated to the route location.\n\n### redirectedFrom\n\n- **Type**: [`RouteLocation`](#routelocation)\n\n- **Details**:\n\n  Route location we were initially trying to access before ending up on the current location when a `redirect` option was found or a navigation guard called `next()` with a route location. `undefined` if there was no redirection.\n\n## NavigationFailure\n\n### from\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  Route location we were navigating from\n\n### to\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  Route location we were navigating to\n\n### type\n\n- **Type**: [`NavigationFailureType`](#navigationfailuretype)\n\n- **Details**:\n\n  Type of the navigation failure.\n\n- **See Also**: [Navigation Failures](../guide/advanced/navigation-failures)\n\n## NavigationGuard\n\n- **Arguments**:\n\n  - [`RouteLocationNormalized`](#routelocationnormalized) to - Route location we are navigating to\n  - [`RouteLocationNormalized`](#routelocationnormalized) from - Route location we are navigating from\n  - `Function` next (Optional) - Callback to validate the navigation\n\n- **Details**:\n\n  Function that can be passed to control a router navigation. The `next` callback can be omitted if you return a value (or a Promise) instead, which is encouraged. Possible return values (and parameters for `next`) are:\n\n  - `undefined | void | true`: validates the navigation\n  - `false`: cancels the navigation\n  - [`RouteLocationRaw`](#routelocationraw): redirects to a different location\n  - `(vm: ComponentPublicInstance) => any` **only for `beforeRouteEnter`**: A callback to be executed once the navigation completes. Receives the route component instance as the parameter.\n\n- **See Also**: [Navigation Guards](../guide/advanced/navigation-guards)\n\n## Component Injections\n\n### Component Injected Properties\n\nThese properties are injected into every child component by calling `app.use(router)`.\n\n- **this.$router**\n\n  The router instance.\n\n- **this.$route**\n\n  The current active [route location](#routelocationnormalized). This property is read-only and its properties are immutable, but it can be watched.\n\n### Component Enabled Options\n\n- **beforeRouteEnter**\n- **beforeRouteUpdate**\n- **beforeRouteLeave**\n\nSee [In Component Guards](../guide/advanced/navigation-guards#in-component-guards).\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/api/index.md)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/api/index.html](https://next.router.vuejs.org/api/index.html)"
- name: aria-current-value
  id: api/index#aria-current-value
  summary: Value passed to the attribute aria-current when the link is exactly active
  belongs_to: API Reference
  description: |-
    ### aria-current-value

    - **Type**: `'page' | 'step' | 'location' | 'date' | 'time' | 'true' | 'false'` (`string`)

    - **Default**: `"page"`

    - **Details**:

      Value passed to the attribute `aria-current` when the link is exactly active.

    &nbsp;
- name: back
  id: api/index#back
  summary: Go back in history if possible by calling history.back()
  belongs_to: API Reference
  description: "### back\n\nGo back in history if possible by calling `history.back()`. Equivalent to `router.go(-1)`.\n\n**Signature:**\n\n                  \n                    back\n                    (\n                    )\n                    :\n                    void"
- name: beforeEach
  id: api/index#beforeeach
  summary: Add a navigation guard that executes before any navigation
  belongs_to: API Reference
  description: "### beforeEach\n\nAdd a navigation guard that executes before any navigation. Returns a function that removes the registered guard.\n\n**Signature:**\n\n                  beforeEach(guard: NavigationGuard): () => void\n\n                \n\n*Parameters*\n\n| Parameter | Type                                  | Description             |\n|-----------|---------------------------------------|-------------------------|\n| guard     | [`NavigationGuard`](#navigationguard) | navigation guard to add |"
- name: beforeEnter
  id: api/index#beforeenter-1
  summary: Navigation guard applied when entering this record from somewhere else
  belongs_to: API Reference
  description: |-
    ### beforeEnter

    - **Type**: [`NavigationGuard`](#navigationguard)

    - **Details**:

      Navigation guard applied when entering this record from somewhere else.

    - **See Also**: [Navigation guards](../guide/advanced/navigation-guards)

    &nbsp;
- name: beforeEnter
  id: api/index#beforeenter
  summary: Before enter guard specific to this record
  belongs_to: API Reference
  description: |-
    ### beforeEnter

    - **Type**: [`NavigationGuard | NavigationGuard[]`](#navigationguard) (Optional)

    - **Details**:

      Before enter guard specific to this record. Note `beforeEnter` has no effect if the record has a `redirect` property.

    &nbsp;
- name: beforeResolve
  id: api/index#beforeresolve
  summary: Add a navigation guard that executes before navigation is about to be resolved
  belongs_to: API Reference
  description: "### beforeResolve\n\nAdd a navigation guard that executes before navigation is about to be resolved. At this state all component have been fetched and other navigation guards have been successful. Returns a function that removes the registered guard.\n\n**Signature:**\n\n                  beforeResolve(guard: NavigationGuard): () => void\n\n                \n\n*Parameters*\n\n| Parameter | Type                                  | Description             |\n|-----------|---------------------------------------|-------------------------|\n| guard     | [`NavigationGuard`](#navigationguard) | navigation guard to add |\n\n#### Examples\n\n                  router.beforeResolve(to => {\n      if (to.meta.requiresAuth && !isAuthenticated) return false\n    })"
- name: children
  id: api/index#children
  summary: Nested routes of the current record
  belongs_to: API Reference
  description: |-
    ### children

    - **Type**: Array of [`RouteRecordRaw`](#routerecordraw) (Optional)

    - **Details**:

      Nested routes of the current record.

    - **See Also**: [Nested Routes](../guide/essentials/nested-routes)

    &nbsp;
- name: children
  id: api/index#children-1
  summary: Children route records of a route at the time it was added
  belongs_to: API Reference
  description: |-
    ### children

    - **Type**: Array of normalized [route records](#routerecordnormalized)

    - **Details**:

      Children route records of a route at the time it was added. Empty array if none. Note this array doesn't update when `addRoute()` and `removeRoute()` are called.

    &nbsp;
- name: Component Enabled Options
  id: api/index#component-enabled-options
  summary: See In Component Guards
  belongs_to: API Reference
  description: "### Component Enabled Options\n\n- **beforeRouteEnter**\n- **beforeRouteUpdate**\n- **beforeRouteLeave**\n\nSee [In Component Guards](../guide/advanced/navigation-guards#in-component-guards).\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/api/index.md)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/api/index.html](https://next.router.vuejs.org/api/index.html)"
- name: Component Injected Properties
  id: api/index#component-injected-properties
  summary: These properties are injected into every child component by calling app.use(router)
  belongs_to: API Reference
  description: |-
    ### Component Injected Properties

    These properties are injected into every child component by calling `app.use(router)`.

    - **this.$router**

      The router instance.

    - **this.$route**

      The current active [route location](#routelocationnormalized). This property is read-only and its properties are immutable, but it can be watched.

    &nbsp;
- name: Component Injections
  id: api/index#component-injections
  summary: null
  belongs_to: API Reference
  description: '## Component Injections'
- name: components
  id: api/index#components
  summary: Dictionary of named views, if none, contains an object with the key default
  belongs_to: API Reference
  description: |-
    ### components

    - **Type**: `Record<string, Component>`

    - **Details**:

      Dictionary of named views, if none, contains an object with the key `default`.

    &nbsp;
- name: currentRoute
  id: api/index#currentroute
  summary: Current route location
  belongs_to: API Reference
  description: |-
    ### currentRoute

    - **Type**: [`Ref<RouteLocationNormalized>`](#routelocationnormalized)

    - **Details**:

      Current route location. Readonly.

    &nbsp;
- name: custom
  id: api/index#custom
  summary: Whether <router-link> should not wrap its content in an <a> element
  belongs_to: API Reference
  description: "### custom\n\n- **Type**: `boolean`\n\n- **Default**: `false`\n\n- **Details**:\n\n  Whether `<router-link>` should not wrap its content in an `<a>` element. Useful when using [`v-slot`](#router-link-s-v-slot) to create a custom RouterLink. By default, `<router-link>` will render its content wrapped in an `<a>` element, even when using `v-slot`. Passing the `custom` prop, removes that behavior.\n\n- **Examples**:\n\n                        <router-linkto=\"/home\"customv-slot=\"{ navigate, href, route }\"><a:href=\"href\"@click=\"navigate\">{{ route.fullPath }}</a></router-link>\n                      \n\n  Renders `<a href=\"/home\">/home</a>`.\n\n                        <router-linkto=\"/home\"v-slot=\"{ route }\"><span>{{ route.fullPath }}</span></router-link>\n                      \n\n  Renders `<a href=\"/home\"><span>/home</span></a>`.\n\n&nbsp;"
- name: Data Fetching
  id: guide/advanced/data-fetching
  summary: Sometimes you need to fetch data from the server when a route is activated
  description: "# Data Fetching\n\nSometimes you need to fetch data from the server when a route is activated. For example, before rendering a user profile, you need to fetch the user's data from the server. We can achieve this in two different ways:\n\n- **Fetching After Navigation**: perform the navigation first, and fetch data in the incoming component's lifecycle hook. Display a loading state while data is being fetched.\n\n- **Fetching Before Navigation**: Fetch data before navigation in the route enter guard, and perform the navigation after data has been fetched.\n\nTechnically, both are valid choices - it ultimately depends on the user experience you are aiming for.\n\n## Fetching After Navigation\n\nWhen using this approach, we navigate and render the incoming component immediately, and fetch data in the component's `created` hook. It gives us the opportunity to display a loading state while the data is being fetched over the network, and we can also handle loading differently for each view.\n\nLet's assume we have a `Post` component that needs to fetch the data for a post based on `$route.params.id`:\n\n    <template>\n      <div class=\"post\">\n        <div v-if=\"loading\" class=\"loading\">Loading...</div>\n\n        <div v-if=\"error\" class=\"error\">{{ error }}</div>\n\n        <div v-if=\"post\" class=\"content\">\n          <h2>{{ post.title }}</h2>\n          <p>{{ post.body }}</p>\n        </div>\n      </div>\n    </template>\n\n    export default {\n      data() {\n        return {\n          loading: false,\n          post: null,\n          error: null,\n        }\n      },\n      created() {\n        // watch the params of the route to fetch the data again\n        this.$watch(\n          () => this.$route.params,\n          () => {\n            this.fetchData()\n          },\n          // fetch the data when the view is created and the data is\n          // already being observed\n          { immediate: true }\n        )\n      },\n      methods: {\n        fetchData() {\n          this.error = this.post = null\n          this.loading = true\n          // replace `getPost` with your data fetching util / API wrapper\n          getPost(this.$route.params.id, (err, post) => {\n            this.loading = false\n            if (err) {\n              this.error = err.toString()\n            } else {\n              this.post = post\n            }\n          })\n        },\n      },\n    }\n\n## Fetching Before Navigation\n\nWith this approach we fetch the data before actually navigating to the new route. We can perform the data fetching in the `beforeRouteEnter` guard in the incoming component, and only call `next` when the fetch is complete:\n\n    export default {\n      data() {\n        return {\n          post: null,\n          error: null,\n        }\n      },\n      beforeRouteEnter(to, from, next) {\n        getPost(to.params.id, (err, post) => {\n          next(vm => vm.setData(err, post))\n        })\n      },\n      // when route changes and this component is already rendered,\n      // the logic will be slightly different.\n      async beforeRouteUpdate(to, from) {\n        this.post = null\n        try {\n          this.post = await getPost(to.params.id)\n        } catch (error) {\n          this.error = error.toString()\n        }\n      },\n    }\n\nThe user will stay on the previous view while the resource is being fetched for the incoming view. It is therefore recommended to display a progress bar or some kind of indicator while the data is being fetched. If the data fetch fails, it's also necessary to display some kind of global warning message.\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/advanced/data-fetching.md)\n\n[Route Meta Fields](meta)\n\n[Composition API](composition-api)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/advanced/data-fetching](https://next.router.vuejs.org/guide/advanced/data-fetching)"
- name: Different History modes
  id: guide/essentials/history-mode
  summary: The history option when creating the router instance allows us to choose among different history modes
  description: "# Different History modes\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/history-mode?friend=vuerouter \"Learn about the differences between Hash Mode and HTML5 Mode\")\n\nThe `history` option when creating the router instance allows us to choose among different history modes.\n\n## Hash Mode\n\nThe hash history mode is created with `createWebHashHistory()`:\n\n    import { createRouter, createWebHashHistory } from 'vue-router'\n\n    const router = createRouter({\n      history: createWebHashHistory(),\n      routes: [\n        //...\n      ],\n    })\n\nIt uses a hash character (`#`) before the actual URL that is internally passed. Because this section of the URL is never sent to the server, it doesn't require any special treatment on the server level. **It does however have a bad impact in SEO**. If that's a concern for you, use the HTML5 history mode.\n\n## HTML5 Mode\n\nThe HTML5 mode is created with `createWebHistory()` and is the recommended mode:\n\n    import { createRouter, createWebHistory } from 'vue-router'\n\n    const router = createRouter({\n      history: createWebHistory(),\n      routes: [\n        //...\n      ],\n    })\n\nWhen using history mode, the URL will look \"normal,\" e.g. `https://example.com/user/id`. Beautiful!\n\nHere comes a problem, though: Since our app is a single page client side app, without a proper server configuration, the users will get a 404 error if they access `https://example.com/user/id` directly in their browser. Now that's ugly.\n\nNot to worry: To fix the issue, all you need to do is add a simple catch-all fallback route to your server. If the URL doesn't match any static assets, it should serve the same `index.html` page that your app lives in. Beautiful, again!\n\n## Example Server Configurations\n\n**Note**: The following examples assume you are serving your app from the root folder. If you deploy to a subfolder, you should use [the `publicPath` option of Vue CLI](https://cli.vuejs.org/config/#publicpath) and the related [`base` property of the router](../../api/index#createwebhistory). You also need to adjust the examples below to use the subfolder instead of the root folder (e.g. replacing `RewriteBase /` with `RewriteBase /name-of-your-subfolder/`).\n\n### Apache\n\n    <IfModule mod_rewrite.c>\n      RewriteEngine On\n      RewriteBase /\n      RewriteRule ^index\\.html$ - [L]\n      RewriteCond %{REQUEST_FILENAME} !-f\n      RewriteCond %{REQUEST_FILENAME} !-d\n      RewriteRule . /index.html [L]\n    </IfModule>\n\nInstead of `mod_rewrite`, you could also use [`FallbackResource`](https://httpd.apache.org/docs/2.2/mod/mod_dir.html#fallbackresource).\n\n### nginx\n\n    location / {\n      try_files $uri $uri/ /index.html;\n    }\n\n### Native Node.js\n\n    const http = require('http')\n    const fs = require('fs')\n    const httpPort = 80\n\n    http\n      .createServer((req, res) => {\n        fs.readFile('index.html', 'utf-8', (err, content) => {\n          if (err) {\n            console.log('We cannot open \"index.html\" file.')\n          }\n\n          res.writeHead(200, {\n            'Content-Type': 'text/html; charset=utf-8',\n          })\n\n          res.end(content)\n        })\n      })\n      .listen(httpPort, () => {\n        console.log('Server listening on: http://localhost:%s', httpPort)\n      })\n\n### Express with Node.js\n\nFor Node.js/Express, consider using [connect-history-api-fallback middleware](https://github.com/bripkens/connect-history-api-fallback).\n\n### Internet Information Services (IIS)\n\n1.  Install [IIS UrlRewrite](https://www.iis.net/downloads/microsoft/url-rewrite)\n2.  Create a `web.config` file in the root directory of your site with the following:\n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <configuration>\n      <system.webServer>\n        <rewrite>\n          <rules>\n            <rule name=\"Handle History Mode and custom 404/500\" stopProcessing=\"true\">\n              <match url=\"(.*)\" />\n              <conditions logicalGrouping=\"MatchAll\">\n                <add input=\"{REQUEST_FILENAME}\" matchType=\"IsFile\" negate=\"true\" />\n                <add input=\"{REQUEST_FILENAME}\" matchType=\"IsDirectory\" negate=\"true\" />\n              </conditions>\n              <action type=\"Rewrite\" url=\"/\" />\n            </rule>\n          </rules>\n        </rewrite>\n      </system.webServer>\n    </configuration>\n\n### Caddy v2\n\n    try_files {path} /\n\n### Caddy v1\n\n    rewrite {\n        regexp .*\n        to {path} /\n    }\n\n### Firebase hosting\n\nAdd this to your `firebase.json`:\n\n    {\n      \"hosting\": {\n        \"public\": \"dist\",\n        \"rewrites\": [\n          {\n            \"source\": \"**\",\n            \"destination\": \"/index.html\"\n          }\n        ]\n      }\n    }\n\n### Netlify\n\nCreate a `_redirects` file that is included with your deployed files:\n\n    /* /index.html 200\n\nIn vue-cli, nuxt, and vite projects, this file usually goes under a folder named `static` or `public`.\n\nYou can more about the syntax on [Netlify documentation](https://docs.netlify.com/routing/redirects/rewrites-proxies/#history-pushstate-and-single-page-apps). You can also [create a `netlify.toml`](https://docs.netlify.com/configure-builds/file-based-configuration/) to combine *redirections* with other Netlify features.\n\n## Caveat\n\nThere is a caveat to this: Your server will no longer report 404 errors as all not-found paths now serve up your `index.html` file. To get around the issue, you should implement a catch-all route within your Vue app to show a 404 page:\n\n    const router = createRouter({\n      history: createWebHistory(),\n      routes: [{ path: '/:pathMatch(.*)', component: NotFoundComponent }],\n    })\n\nAlternatively, if you are using a Node.js server, you can implement the fallback by using the router on the server side to match the incoming URL and respond with 404 if no route is matched. Check out the [Vue server side rendering documentation](https://v3.vuejs.org/guide/ssr/introduction.html#what-is-server-side-rendering-ssr) for more information.\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/essentials/history-mode.md)\n\n[Passing Props to Route Components](passing-props)\n\n[Navigation guards](../advanced/navigation-guards)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/essentials/history-mode](https://next.router.vuejs.org/guide/essentials/history-mode)"
- name: Dynamic Route Matching with Params
  id: guide/essentials/dynamic-matching
  summary: Very often we will need to map routes with the given pattern to the same component
  description: "# Dynamic Route Matching with Params\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/dynamic-routes?friend=vuerouter \"Learn about dynamic route matching with params\")\n\nVery often we will need to map routes with the given pattern to the same component. For example we may have a `User` component which should be rendered for all users but with different user IDs. In Vue Router we can use a dynamic segment in the path to achieve that, we call that a *param*:\n\n    const User = {\n      template: '<div>User</div>',\n    }\n\n    // these are passed to `createRouter`\n    const routes = [\n      // dynamic segments start with a colon\n      { path: '/users/:id', component: User },\n    ]\n\nNow URLs like `/users/johnny` and `/users/jolyne` will both map to the same route.\n\nA *param* is denoted by a colon `:`. When a route is matched, the value of its *params* will be exposed as `this.$route.params` in every component. Therefore, we can render the current user ID by updating `User`'s template to this:\n\n    const User = {\n      template: '<div>User {{ $route.params.id }}</div>',\n    }\n\nYou can have multiple *params* in the same route, and they will map to corresponding fields on `$route.params`. Examples:\n\n| pattern                        | matched path             | $route.params                            |\n|--------------------------------|--------------------------|------------------------------------------|\n| /users/:username               | /users/eduardo           | `{ username: 'eduardo' }`                |\n| /users/:username/posts/:postId | /users/eduardo/posts/123 | `{ username: 'eduardo', postId: '123' }` |\n\nIn addition to `$route.params`, the `$route` object also exposes other useful information such as `$route.query` (if there is a query in the URL), `$route.hash`, etc. You can check out the full details in the [API Reference](../../api/index#routelocationnormalized).\n\nA working demo of this example can be found [here](https://codesandbox.io/s/route-params-vue-router-examples-mlb14?from-embed&initialpath=%2Fusers%2Feduardo%2Fposts%2F1).\n\n## Reacting to Params Changes\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/reacting-to-param-changes?friend=vuerouter \"Learn how to react to param changes\")\n\nOne thing to note when using routes with params is that when the user navigates from `/users/johnny` to `/users/jolyne`, **the same component instance will be reused**. Since both routes render the same component, this is more efficient than destroying the old instance and then creating a new one. **However, this also means that the lifecycle hooks of the component will not be called**.\n\nTo react to params changes in the same component, you can simply watch anything on the `$route` object, in this scenario, the `$route.params`:\n\n    const User = {\n      template: '...',\n      created() {\n        this.$watch(\n          () => this.$route.params,\n          (toParams, previousParams) => {\n            // react to route changes...\n          }\n        )\n      },\n    }\n\nOr, use the `beforeRouteUpdate` [navigation guard](../advanced/navigation-guards), which also allows to cancel the navigation:\n\n    const User = {\n      template: '...',\n      async beforeRouteUpdate(to, from) {\n        // react to route changes...\n        this.userData = await fetchUser(to.params.id)\n      },\n    }\n\n## Catch all / 404 Not found Route\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/404-not-found-page?friend=vuerouter \"Learn how to make a catch all/404 not found route\")\n\nRegular params will only match characters in between url fragments, separated by `/`. If we want to match **anything**, we can use a custom *param* regexp by adding the regexp inside parentheses right after the *param*:\n\n    const routes = [\n      // will match everything and put it under `$route.params.pathMatch`\n      { path: '/:pathMatch(.*)*', name: 'NotFound', component: NotFound },\n      // will match anything starting with `/user-` and put it under `$route.params.afterUser`\n      { path: '/user-:afterUser(.*)', component: UserGeneric },\n    ]\n\nIn this specific scenario we are using a [custom regexp](route-matching-syntax#custom-regexp-in-params) between parentheses and marking the `pathMatch` param as [optionally repeatable](route-matching-syntax#optional-parameters). This allows us to directly navigate to the route if we need to by splitting the `path` into an array:\n\n    this.$router.push({\n      name: 'NotFound',\n      // preserve current path and remove the first char to avoid the target URL starting with `//`\n      params: { pathMatch: this.$route.path.substring(1).split('/') },\n      // preserve existing query and hash if any\n      query: this.$route.query,\n      hash: this.$route.hash,\n    })\n\nSee more in the [repeated params](route-matching-syntax#repeatable-params) section.\n\nIf you are using [History mode](history-mode), make sure to follow the instructions to correctly configure your server as well.\n\n## Advanced Matching Patterns\n\nVue Router uses its own path matching syntax, inspired by the one used by `express`, so it supports many advanced matching patterns such as optional params, zero or more / one or more requirements, and even custom regex patterns. Please check the [Advanced Matching](route-matching-syntax) documentation to explore them.\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/essentials/dynamic-matching.md)\n\n[Getting Started](../index)\n\n[Routes' Matching Syntax](route-matching-syntax)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/essentials/dynamic-matching](https://next.router.vuejs.org/guide/essentials/dynamic-matching)"
- name: Dynamic Routing
  id: guide/advanced/dynamic-routing
  summary: Adding routes to your router is usually done via the routes option but in some situations, you might want to add or remove routes while the application is already running
  description: "# Dynamic Routing\n\nAdding routes to your router is usually done via the [`routes` option](../../api/index#routes) but in some situations, you might want to add or remove routes while the application is already running. Application with extensible interfaces like [Vue CLI UI](https://cli.vuejs.org/dev-guide/ui-api.html) can use this to make the application grow.\n\n## Adding Routes\n\nDynamic routing is achieved mainly via two functions: `router.addRoute()` and `router.removeRoute()`. They **only** register a new route, meaning that if the newly added route matches the current location, it would require you to **manually navigate** with `router.push()` or `router.replace()` to display that new route. Let's take a look at an example:\n\nImagine having the following router with one single route:\n\n    const router = createRouter({\n      history: createWebHistory(),\n      routes: [{ path: '/:articleName', component: Article }],\n    })\n\nGoing to any page, `/about`, `/store`, or `/3-tricks-to-improve-your-routing-code` ends up rendering the `Article` component. If we are on `/about` and we add a new route:\n\n    router.addRoute({ path: '/about', component: About })\n\nThe page will still show the `Article` component, we need to manually call `router.replace()` to change the current location and overwrite where we were (instead of pushing a new entry, ending up in the same location twice in our history):\n\n    router.addRoute({ path: '/about', component: About })\n    // we could also use this.$route or route = useRoute() (inside a setup)\n    router.replace(router.currentRoute.value.fullPath)\n\nRemember you can `await router.replace()` if you need to wait for the new route to be displayed.\n\n## Adding Routes inside navigation guards\n\nIf you decide to add or remove routes inside of a navigation guard, you should not call `router.replace()` but trigger a redirection by returning the new location:\n\n    router.beforeEach(to => {\n      if (!hasNecessaryRoute(to)) {\n        router.addRoute(generateRoute(to))\n        // trigger a redirection\n        return to.fullPath\n      }\n    })\n\nThe example above assumes two things: first, the newly added route record will match the `to` location, effectively resulting in a different location from the one we were trying to access. Second, `hasNecessaryRoute()` returns `false` after adding the new route to avoid an infinite redirection.\n\nBecause we are redirecting, we are replacing the ongoing navigation, effectively behaving like the example shown before. In real world scenarios, adding is more likely to happen outside of navigation guards, e.g. when a view component mounts, it register new routes.\n\n## Removing routes\n\nThere are few different ways to remove existing routes:\n\n- By adding a route with a conflicting name. If you add a route that has the same name as an existing route, it will remove the route first and then add the route:\n      router.addRoute({ path: '/about', name: 'about', component: About })\n      // this will remove the previously added route because they have the same name and names are unique\n      router.addRoute({ path: '/other', name: 'about', component: Other })\n- By calling the callback returned by `router.addRoute()`:\n      const removeRoute = router.addRoute(routeRecord)\n      removeRoute() // removes the route if it exists\n\n  This is useful when the routes do not have a name\n- By using `router.removeRoute()` to remove a route by its name:\n      router.addRoute({ path: '/about', name: 'about', component: About })\n      // remove the route\n      router.removeRoute('about')\n\n  Note you can use `Symbol`s for names in routes if you wish to use this function but want to avoid conflicts in names.\n\nWhenever a route is removed, **all of its aliases and children** are removed with it.\n\n## Adding nested routes\n\nTo add nested routes to an existing route, you can pass the *name* of the route as its first parameter to `router.addRoute()`, this will effectively add the route as if it was added through `children`:\n\n    router.addRoute({ name: 'admin', path: '/admin', component: Admin })\n    router.addRoute('admin', { path: 'settings', component: AdminSettings })\n\nThis is equivalent to:\n\n    router.addRoute({\n      name: 'admin',\n      path: '/admin',\n      component: Admin,\n      children: [{ path: 'settings', component: AdminSettings }],\n    })\n\n## Looking at existing routes\n\nVue Router gives you two functions to look at existing routes:\n\n- [`router.hasRoute()`](../../api/index#hasroute): check if a route exists\n- [`router.getRoutes()`](../../api/index#getroutes): get an array with all the route records.\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/advanced/dynamic-routing.md)\n\n[Navigation Failures](navigation-failures)\n\n[Migrating from Vue 2](../migration/index)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/advanced/dynamic-routing](https://next.router.vuejs.org/guide/advanced/dynamic-routing)"
- name: exact-active-class
  id: api/index#exact-active-class
  summary: Class to apply on the rendered <a> when the link is exact active
  belongs_to: API Reference
  description: "### exact-active-class\n\n- **Type**: `string`\n\n- **Default**: `\"router-link-exact-active\"` (or global [`linkExactActiveClass`](#linkexactactiveclass))\n\n- **Details**:\n\n  Class to apply on the rendered `<a>` when the link is exact active.\n\n## `<router-link>`'s `v-slot`\n\n`<router-link>` exposes a low level customization through a [scoped slot](https://v3.vuejs.org/guide/component-slots.html#scoped-slots). This is a more advanced API that primarily targets library authors but can come in handy for developers as well, to build a custom component like a *NavLink* or other.\n\n**TIP**\n\nRemember to pass the `custom` option to `<router-link>` to prevent it from wrapping its content inside of an `<a>` element.\n\n                  <router-linkto=\"/about\"customv-slot=\"{ href, route, navigate, isActive, isExactActive }\"><NavLink:active=\"isActive\":href=\"href\"@click=\"navigate\">\n        {{ route.fullPath }}\n      </NavLink>\n    </router-link>\n\n                \n\n- `href`: resolved url. This would be the `href` attribute of an `<a>` element. It contains the `base` if any was provided.\n- `route`: resolved normalized location.\n- `navigate`: function to trigger the navigation. **It will automatically prevent events when necessary**, the same way `router-link` does, e.g. `ctrl` or `cmd` + click will still be ignored by `navigate`.\n- `isActive`: `true` if the [active class](#active-class) should be applied. Allows to apply an arbitrary class.\n- `isExactActive`: `true` if the [exact active class](#exact-active-class) should be applied. Allows to apply an arbitrary class.\n\n&nbsp;"
- name: 'Example: Applying Active Class to Outer Element'
  id: api/index#example-applying-active-class-to-outer-element
  summary: If you add a target="_blank" to your a element, you must omit the @click="navigate" handler
  belongs_to: API Reference
  description: "### Example: Applying Active Class to Outer Element\n\nSometimes we may want the active class to be applied to an outer element rather than the `<a>` element itself, in that case, you can wrap that element inside a `router-link` and use the `v-slot` properties to create your link:\n\n                  <router-linkto=\"/foo\"customv-slot=\"{ href, route, navigate, isActive, isExactActive }\"><li:class=\"[isActive && 'router-link-active', isExactActive && 'router-link-exact-active']\"><a:href=\"href\"@click=\"navigate\">{{ route.fullPath }}</a></li></router-link>\n                \n\n**TIP**\n\nIf you add a `target=\"_blank\"` to your `a` element, you must omit the `@click=\"navigate\"` handler.\n\n## `<router-view>` Props"
- name: Examples
  id: api/index#examples-1
  summary: Creates a in-memory based history
  belongs_to: API Reference
  description: "### Examples\n\n                  \n                    // at https://example.com/folder\n                    createWebHashHistory\n                    (\n                    )\n                    // gives a url of `https://example.com/folder#`\n                    createWebHashHistory\n                    (\n                    '/folder/'\n                    )\n                    // gives a url of `https://example.com/folder/#`\n                    // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\n                    createWebHashHistory\n                    (\n                    '/folder/#/app/'\n                    )\n                    // gives a url of `https://example.com/folder/#/app/`\n                    // you should avoid doing this because it changes the original url and breaks copying urls\n                    createWebHashHistory\n                    (\n                    '/other-folder/'\n                    )\n                    // gives a url of `https://example.com/other-folder/#`\n                    // at file:///usr/etc/folder/index.html\n                    // for locations with no `host`, the base is ignored\n                    createWebHashHistory\n                    (\n                    '/iAmIgnored'\n                    )\n                    // gives a url of `file:///usr/etc/folder/index.html#`\n                  \n                \n\n## createMemoryHistory\n\nCreates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere. If the user is not on a browser context, it's up to them to replace that location with the starter location by either calling `router.push()` or `router.replace()`.\n\n**Signature:**\n\n                  exportdeclarefunctioncreateMemoryHistory(base?:string): RouterHistory"
- name: Examples
  id: api/index#examples
  summary: Creates a hash history
  belongs_to: API Reference
  description: "### Examples\n\n                  \n                    createWebHistory\n                    (\n                    )\n                    // No base, the app is hosted at the root of the domain `https://example.com`\n                    createWebHistory\n                    (\n                    '/folder/'\n                    )\n                    // gives a url of `https://example.com/folder/`\n                  \n                \n\n## createWebHashHistory\n\nCreates a hash history. Useful for web applications with no host (e.g. `file://`) or when configuring a server to handle any URL isn't an option. **Note you should use [`createWebHistory`](#createwebhistory) if SEO matters to you**.\n\n**Signature:**\n\n                  exportdeclarefunctioncreateWebHashHistory(base?:string): RouterHistory"
- name: Extending RouterLink
  id: guide/advanced/extending-router-link
  summary: The RouterLink component exposes enough props to suffice most basic applications but it doesn't try to cover every possible use case and you will likely find yourself using v-slot for some advanced cases
  description: "# Extending RouterLink\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/extending-router-link-for-external-urls?friend=vuerouter \"Learn how to extend router-link\")\n\nThe RouterLink component exposes enough `props` to suffice most basic applications but it doesn't try to cover every possible use case and you will likely find yourself using `v-slot` for some advanced cases. In most medium to large sized applications, it's worth creating one if not multiple custom RouterLink components to reuse them across your application. Some examples are Links in a Navigation Menu, handling external links, adding an `inactive-class`, etc.\n\nLet's extend RouterLink to handle external links as well and adding a custom `inactive-class` in an `AppLink.vue` file:\n\n    <template>\n      <a v-if=\"isExternalLink\" v-bind=\"$attrs\" :href=\"to\" target=\"_blank\">\n        <slot />\n      </a>\n      <router-link\n        v-else\n        v-bind=\"$props\"\n        custom\n        v-slot=\"{ isActive, href, navigate }\"\n      >\n        <a\n          v-bind=\"$attrs\"\n          :href=\"href\"\n          @click=\"navigate\"\n          :class=\"isActive ? activeClass : inactiveClass\"\n        >\n          <slot />\n        </a>\n      </router-link>\n    </template>\n\n    <script>\n    import { RouterLink } from 'vue-router'\n\n    export default {\n      name: 'AppLink',\n      inheritAttrs: false,\n\n      props: {\n        // add @ts-ignore if using TypeScript\n        ...RouterLink.props,\n        inactiveClass: String,\n      },\n\n      computed: {\n        isExternalLink() {\n          return typeof this.to === 'string' && this.to.startsWith('http')\n        },\n      },\n    }\n    </script>\n\nIf you prefer using a render function or create `computed` properties, you can use the `useLink` from the [Composition API](composition-api):\n\n    import { RouterLink, useLink } from 'vue-router'\n\n    export default {\n      name: 'AppLink',\n\n      props: {\n        // add @ts-ignore if using TypeScript\n        ...RouterLink.props,\n        inactiveClass: String,\n      },\n\n      setup(props) {\n        // `props` contains `to` and any other prop that can be passed to <router-link>\n        const { navigate, href, route, isActive, isExactActive } = useLink(props)\n\n        // profit!\n\n        return { isExternalLink }\n      },\n    }\n\nIn practice, you might want to use your `AppLink` component for different parts of your application. e.g. using [Tailwind CSS](https://tailwindcss.com), you could create a `NavLink.vue` component with all the classes:\n\n    <template>\n      <AppLink\n        v-bind=\"$attrs\"\n        class=\"inline-flex items-center px-1 pt-1 border-b-2 border-transparent text-sm font-medium leading-5 text-gray-500 focus:outline-none transition duration-150 ease-in-out hover:text-gray-700 hover:border-gray-300 focus:outline-none focus:text-gray-700 focus:border-gray-300 transition duration-150 ease-in-out\"\n        active-class=\"border-indigo-500 text-gray-900 focus:border-indigo-700\"\n        inactive-class=\"text-gray-500 hover:text-gray-700 hover:border-gray-300 focus:text-gray-700 focus:border-gray-300\"\n      >\n        <slot />\n      </AppLink>\n    </template>\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/advanced/extending-router-link.md)\n\n[Lazy Loading Routes](lazy-loading)\n\n[Navigation Failures](navigation-failures)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/advanced/extending-router-link](https://next.router.vuejs.org/guide/advanced/extending-router-link)"
- name: forward
  id: api/index#forward
  summary: Go forward in history if possible by calling history.forward()
  belongs_to: API Reference
  description: "### forward\n\nGo forward in history if possible by calling `history.forward()`. Equivalent to `router.go(1)`.\n\n**Signature:**\n\n                  \n                    forward\n                    (\n                    )\n                    :\n                    void"
- name: from
  id: api/index#from
  summary: null
  belongs_to: API Reference
  description: |-
    ### from

    - **Type**: [`RouteLocationNormalized`](#routelocationnormalized)

    - **Details**:

      Route location we were navigating from

    &nbsp;
- name: fullPath
  id: api/index#fullpath
  summary: Encoded URL associated to the route location
  belongs_to: API Reference
  description: |-
    ### fullPath

    - **Type**: `string`

    - **Details**:

      Encoded URL associated to the route location. Contains `path`, `query` and `hash`.

    &nbsp;
- name: getRoutes
  id: api/index#getroutes
  summary: Get a full list of all the route records
  belongs_to: API Reference
  description: |-
    ### getRoutes

    Get a full list of all the [route records](#routerecord).

    **Signature:**

                      getRoutes(): RouteRecord[]
- name: Getting Started
  id: guide/index
  summary: 'Creating a Single-page Application with Vue + Vue Router feels natural: with Vue.js, we are already composing our application with components'
  description: "# Getting Started\n\n[](#)\n\nCreating a Single-page Application with Vue + Vue Router feels natural: with Vue.js, we are already composing our application with components. When adding Vue Router to the mix, all we need to do is map our components to the routes and let Vue Router know where to render them. Here's a basic example:\n\n## HTML\n\n    <script src=\"https://unpkg.com/vue@3\"></script>\n    <script src=\"https://unpkg.com/vue-router@4\"></script>\n\n    <div id=\"app\">\n      <h1>Hello App!</h1>\n      <p>\n        <!-- use the router-link component for navigation. -->\n        <!-- specify the link by passing the `to` prop. -->\n        <!-- `<router-link>` will render an `<a>` tag with the correct `href` attribute -->\n        <router-link to=\"/\">Go to Home</router-link>\n        <router-link to=\"/about\">Go to About</router-link>\n      </p>\n      <!-- route outlet -->\n      <!-- component matched by the route will render here -->\n      <router-view></router-view>\n    </div>\n\n### `router-link`\n\nNote how instead of using regular `a` tags, we use a custom component `router-link` to create links. This allows Vue Router to change the URL without reloading the page, handle URL generation as well as its encoding. We will see later how to benefit from these features.\n\n### `router-view`\n\n`router-view` will display the component that corresponds to the url. You can put it anywhere to adapt it to your layout.\n\n## JavaScript\n\n    // 1. Define route components.\n    // These can be imported from other files\n    const Home = { template: '<div>Home</div>' }\n    const About = { template: '<div>About</div>' }\n\n    // 2. Define some routes\n    // Each route should map to a component.\n    // We'll talk about nested routes later.\n    const routes = [\n      { path: '/', component: Home },\n      { path: '/about', component: About },\n    ]\n\n    // 3. Create the router instance and pass the `routes` option\n    // You can pass in additional options here, but let's\n    // keep it simple for now.\n    const router = VueRouter.createRouter({\n      // 4. Provide the history implementation to use. We are using the hash history for simplicity here.\n      history: VueRouter.createWebHashHistory(),\n      routes, // short for `routes: routes`\n    })\n\n    // 5. Create and mount the root instance.\n    const app = Vue.createApp({})\n    // Make sure to _use_ the router instance to make the\n    // whole app router-aware.\n    app.use(router)\n\n    app.mount('#app')\n\n    // Now the app has started!\n\nBy calling `app.use(router)`, we get access to it as `this.$router` as well as the current route as `this.$route` inside of any component:\n\n    // Home.vue\n    export default {\n      computed: {\n        username() {\n          // We will see what `params` is shortly\n          return this.$route.params.username\n        },\n      },\n      methods: {\n        goToDashboard() {\n          if (isAuthenticated) {\n            this.$router.push('/dashboard')\n          } else {\n            this.$router.push('/login')\n          }\n        },\n      },\n    }\n\nTo access the router or the route inside the `setup` function, call the `useRouter` or `useRoute` functions. We will learn more about this in [the Composition API](advanced/composition-api#accessing-the-router-and-current-route-inside-setup)\n\nThroughout the docs, we will often use the `router` instance. Keep in mind that `this.$router` is exactly the same as directly using the `router` instance created through `createRouter`. The reason we use `this.$router` is because we don't want to import the router in every single component that needs to manipulate routing.\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/index.md)\n\n[Installation](../installation)\n\n[Dynamic Route Matching](essentials/dynamic-matching)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/index.html](https://next.router.vuejs.org/guide/index.html)"
- name: go
  id: api/index#go
  summary: Allows you to move forward or backward through the history
  belongs_to: API Reference
  description: "### go\n\nAllows you to move forward or backward through the history.\n\n**Signature:**\n\n                  go(delta:number):void\n                \n\n*Parameters*\n\n| Parameter | Type     | Description                                                                         |\n|-----------|----------|-------------------------------------------------------------------------------------|\n| delta     | `number` | The position in the history to which you want to move, relative to the current page |"
- name: hash
  id: api/index#hash
  summary: Decoded hash section of the URL
  belongs_to: API Reference
  description: |-
    ### hash

    - **Type**: `string`

    - **Details**:

      Decoded `hash` section of the URL. Always starts with a `#`. Empty string if there is no `hash` in the URL.

    &nbsp;
- name: hasRoute
  id: api/index#hasroute
  summary: null
  belongs_to: API Reference
  description: "### hasRoute\n\nChecks if a route with a given name exists\n\n**Signature:**\n\n                  hasRoute(name:string|symbol):boolean\n                \n\n*Parameters*\n\n| Parameter | Type              | Description                |\n|-----------|-------------------|----------------------------|\n| name      | `string | symbol` | Name of the route to check |"
- name: history
  id: api/index#history
  summary: History implementation used by the router
  belongs_to: API Reference
  description: "### history\n\nHistory implementation used by the router. Most web applications should use `createWebHistory` but it requires the server to be properly configured. You can also use a *hash* based history with `createWebHashHistory` that does not require any configuration on the server but isn't handled at all by search engines and does poorly on SEO.\n\n**Signature:**\n\n                  history: RouterHistory\n\n                \n\n#### Examples\n\n                  createRouter({\n      history: createWebHistory(),\n      // other options...\n    })"
- name: Installation
  id: installation
  summary: Unpkg.com provides npm-based CDN links
  description: "# Installation\n\n## Direct Download / CDN\n\n[https://unpkg.com/vue-router@4](https://unpkg.com/vue-router@4)\n\n[Unpkg.com](https://unpkg.com) provides npm-based CDN links. The above link will always point to the latest release on npm. You can also use a specific version/tag via URLs like `https://unpkg.com/vue-router@4.0.5/dist/vue-router.global.js`.\n\n## npm\n\n    npm install vue-router@4\n\n## yarn\n\n    yarn add vue-router@4\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/installation.md)\n\n[Introduction](introduction)\n\n[Getting Started](guide/index)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/installation](https://next.router.vuejs.org/installation)"
- name: Introduction
  id: introduction
  summary: Vue Router is the official router for Vue.js
  description: "# Introduction\n\nVue Router is the official router for [Vue.js](http://v3.vuejs.org). It deeply integrates with Vue.js core to make building Single Page Applications with Vue.js a breeze. Features include:\n\n- Nested routes mapping\n- Dynamic Routing\n- Modular, component-based router configuration\n- Route params, query, wildcards\n- View transition effects powered by Vue.js' transition system\n- Fine-grained navigation control\n- Links with automatic active CSS classes\n- HTML5 history mode or hash mode\n- Customizable Scroll Behavior\n- Proper encoding for URLs\n\n[Get started](guide/index) or play with the [playground](https://github.com/vuejs/vue-router-next/tree/master/playground) (see [`README.md`](https://github.com/vuejs/vue-router-next) to run them).\n\n### Platinum Sponsors\n\n[](https://www.finclip.com/#/home?from=vue \"Finogeeks\")\n\n### Gold Sponsors\n\n[](https://passionatepeople.io/ \"Passionate People\")[](https://vuejobs.com/?utm_source=vuerouter&utm_campaign=sponsor \"VueJobs\")[](https://www.vuetifyjs.com/ \"Vuetify\")\n\n### Silver Sponsors\n\n[](https://www.vuemastery.com/ \"VueMastery\")[](https://birdeatsbug.com/?utm_source=vuerouter&utm_medium=sponsor&utm_campaign=silver \"Bird Eats Bug\")\n\n[Become a Sponsor!](https://github.com/sponsors/posva)\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/introduction.md)\n\n[Installation](installation)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/introduction](https://next.router.vuejs.org/introduction)"
- name: isReady
  id: api/index#isready
  summary: Returns a Promise that resolves when the router has completed the initial navigation, which means it has resolved all async enter hooks and async components that are associated with the initial route
  belongs_to: API Reference
  description: "### isReady\n\nReturns a Promise that resolves when the router has completed the initial navigation, which means it has resolved all async enter hooks and async components that are associated with the initial route. If the initial navigation already happened, the promise resolves immediately.This is useful in server-side rendering to ensure consistent output on both the server and the client. Note that on server side, you need to manually push the initial location while on client side, the router automatically picks it up from the URL.\n\n**Signature:**\n\n                  \n                    isReady\n                    (\n                    )\n                    :\n                    Promise\n                    <\n                    void\n                    >"
- name: Lazy Loading Routes
  id: guide/advanced/lazy-loading
  summary: When building apps with a bundler, the JavaScript bundle can become quite large, and thus affect the page load time
  description: "# Lazy Loading Routes\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/lazy-loading-routes-vue-cli-only?friend=vuerouter \"Learn about lazy loading routes\")\n\nWhen building apps with a bundler, the JavaScript bundle can become quite large, and thus affect the page load time. It would be more efficient if we can split each route's components into a separate chunks, and only load them when the route is visited.\n\nVue Router supports [dynamic imports](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) out of the box, meaning you can replace static imports with dynamic ones:\n\n    // replace\n    // import UserDetails from './views/UserDetails'\n    // with\n    const UserDetails = () => import('./views/UserDetails')\n\n    const router = createRouter({\n      // ...\n      routes: [{ path: '/users/:id', component: UserDetails }],\n    })\n\nThe `component` (and `components`) option accepts a function that returns a Promise of a component and Vue Router **will only fetch it when entering the page for the first time**, then use the cached version. Which means you can also have more complex functions as long as they return a Promise:\n\n    const UserDetails = () =>\n      Promise.resolve({\n        /* component definition */\n      })\n\nIn general, it's a good idea **to always use dynamic imports** for all your routes.\n\n**Note**\n\nDo **not** use [Async components](https://v3.vuejs.org/guide/component-dynamic-async.html#async-components) for routes. Async components can still be used inside route components but route component themselves are just dynamic imports.\n\nWhen using a bundler like webpack, this will automatically benefit from [code splitting](https://webpack.js.org/guides/code-splitting/)\n\nWhen using Babel, you will need to add the [syntax-dynamic-import](https://babeljs.io/docs/plugins/syntax-dynamic-import/) plugin so that Babel can properly parse the syntax.\n\n## Grouping Components in the Same Chunk\n\nSometimes we may want to group all the components nested under the same route into the same async chunk. To achieve that we need to use [named chunks](https://webpack.js.org/guides/code-splitting/#dynamic-imports) by providing a chunk name using a special comment syntax (requires webpack \\> 2.4):\n\n    const UserDetails = () =>\n      import(/* webpackChunkName: \"group-user\" */ './UserDetails.vue')\n    const UserDashboard = () =>\n      import(/* webpackChunkName: \"group-user\" */ './UserDashboard.vue')\n    const UserProfileEdit = () =>\n      import(/* webpackChunkName: \"group-user\" */ './UserProfileEdit.vue')\n\nwebpack will group any async module with the same chunk name into the same async chunk.\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/advanced/lazy-loading.md)\n\n[Scroll Behavior](scroll-behavior)\n\n[Extending RouterLink](extending-router-link)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/advanced/lazy-loading](https://next.router.vuejs.org/guide/advanced/lazy-loading)"
- name: linkActiveClass
  id: api/index#linkactiveclass
  summary: Default class applied to active RouterLink
  belongs_to: API Reference
  description: |-
    ### linkActiveClass

    Default class applied to active [RouterLink](#router-link-props). If none is provided, `router-link-active` will be applied.

    **Signature:**

                      linkActiveClass?: string
- name: linkExactActiveClass
  id: api/index#linkexactactiveclass
  summary: Default class applied to exact active RouterLink
  belongs_to: API Reference
  description: |-
    ### linkExactActiveClass

    Default class applied to exact active [RouterLink](#router-link-props). If none is provided, `router-link-exact-active` will be applied.

    **Signature:**

                      linkExactActiveClass?: string
- name: matched
  id: api/index#matched
  summary: Array of normalized route records that were matched with the given route location
  belongs_to: API Reference
  description: |-
    ### matched

    - **Type**: [`RouteRecordNormalized[]`](#routerecordnormalized)

    - **Details**:

      Array of [normalized route records](#routerecord) that were matched with the given route location.

    &nbsp;
- name: Members
  id: api/index#members
  summary: Initial route location where the router is
  belongs_to: API Reference
  description: "### Members\n\n| Member     | Value | Description                                                                                                                      |\n|------------|-------|----------------------------------------------------------------------------------------------------------------------------------|\n| aborted    | 4     | An aborted navigation is a navigation that failed because a navigation guard returned `false` or called `next(false)`            |\n| cancelled  | 8     | A cancelled navigation is a navigation that failed because a more recent navigation finished started (not necessarily finished). |\n| duplicated | 16    | A duplicated navigation is a navigation that failed because it was initiated while already being at the exact same location.     |\n\n## START_LOCATION\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  Initial route location where the router is. Can be used in navigation guards to differentiate the initial navigation.\n\n                        import{START_LOCATION}from'vue-router'\n\n      router.beforeEach((to, from) => {\n        if (from === START_LOCATION) {\n          // initial navigation\n        }\n      })\n\n                      \n\n## Composition API"
- name: meta
  id: api/index#meta-1
  summary: Arbitrary data attached to the record
  belongs_to: API Reference
  description: |-
    ### meta

    - **Type**: `RouteMeta`

    - **Details**:

      Arbitrary data attached to the record.

    - **See also**: [Meta fields](../guide/advanced/meta)

    &nbsp;
- name: meta
  id: api/index#meta-2
  summary: Arbitrary data attached to all matched records merged (non recursively) from parent to child
  belongs_to: API Reference
  description: |-
    ### meta

    - **Type**: `RouteMeta`

    - **Details**:

      Arbitrary data attached to all matched records merged (non recursively) from parent to child.

    - **See also**: [Meta fields](../guide/advanced/meta)

    &nbsp;
- name: meta
  id: api/index#meta
  summary: Custom data attached to the record
  belongs_to: API Reference
  description: "### meta\n\n- **Type**: [`RouteMeta`](#routemeta) (Optional)\n\n- **Details**:\n\n  Custom data attached to the record.\n\n- **See Also**: [Meta fields](../guide/advanced/meta)\n\n**TIP**\n\nIf you want to use a functional component, make sure to add a `displayName` to it.\n\nFor example:\n\n                  constHomeView=()=>h('div','HomePage')// in TypeScript, you will need to use the FunctionalComponent type\n    HomeView.displayName = 'HomeView'\n    const routes = [{ path: '/', component: HomeView }]\n\n                \n\n## RouteRecordNormalized\n\nNormalized version of a [Route Record](#routerecordraw)"
- name: Migrating from Vue 2
  id: guide/migration/index
  summary: Most of Vue Router API has remained unchanged during its rewrite from v3 (for Vue 2) to v4 (for Vue 3) but there are still a few breaking changes that you might encounter while migrating your application
  description: "# Migrating from Vue 2\n\nMost of Vue Router API has remained unchanged during its rewrite from v3 (for Vue 2) to v4 (for Vue 3) but there are still a few breaking changes that you might encounter while migrating your application. This guide is here to help you understand why these changes happened and how to adapt your application to make it work with Vue Router 4.\n\n## Breaking Changes\n\nChanges are ordered by their usage. It is therefore recommended to follow this list in order.\n\n### new Router becomes createRouter\n\nVue Router is no longer a class but a set of functions. Instead of writing `new Router()`, you now have to call `createRouter`:\n\n    // previously was\n    // import Router from 'vue-router'\n    import { createRouter } from 'vue-router'\n\n    const router = createRouter({\n      // ...\n    })\n\n### New `history` option to replace `mode`\n\nThe `mode: 'history'` option has been replaced with a more flexible one named `history`. Depending on which mode you were using, you will have to replace it with the appropriate function:\n\n- `\"history\"`: `createWebHistory()`\n- `\"hash\"`: `createWebHashHistory()`\n- `\"abstract\"`: `createMemoryHistory()`\n\nHere is a full snippet:\n\n    import { createRouter, createWebHistory } from 'vue-router'\n    // there is also createWebHashHistory and createMemoryHistory\n\n    createRouter({\n      history: createWebHistory(),\n      routes: [],\n    })\n\nOn SSR, you need to manually pass the appropriate history:\n\n    // router.js\n    let history = isServer ? createMemoryHistory() : createWebHistory()\n    let router = createRouter({ routes, history })\n    // somewhere in your server-entry.js\n    router.push(req.url) // request url\n    router.isReady().then(() => {\n      // resolve the request\n    })\n\n**Reason**: enable tree shaking of non used histories as well as implementing custom histories for advanced use cases like native solutions.\n\n### Moved the `base` option\n\nThe `base` option is now passed as the first argument to `createWebHistory` (and other histories):\n\n    import { createRouter, createWebHistory } from 'vue-router'\n    createRouter({\n      history: createWebHistory('/base-directory/'),\n      routes: [],\n    })\n\n### Removal of the `fallback` option\n\nThe `fallback` option is no longer supported when creating the router:\n\n    -new VueRouter({\n    +createRouter({\n    -  fallback: false,\n    // other options...\n    })\n\n**Reason**: All browsers supported by Vue support the [HTML5 History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API), allowing us to avoid hacks around modifying `location.hash` and directly use `history.pushState()`.\n\n### Removed `*` (star or catch all) routes\n\nCatch all routes (`*`, `/*`) must now be defined using a parameter with a custom regex:\n\n    const routes = [\n      // pathMatch is the name of the param, e.g., going to /not/found yields\n      // { params: { pathMatch: ['not', 'found'] }}\n      // this is thanks to the last *, meaning repeated params and it is necessary if you\n      // plan on directly navigating to the not-found route using its name\n      { path: '/:pathMatch(.*)*', name: 'not-found', component: NotFound },\n      // if you omit the last `*`, the `/` character in params will be encoded when resolving or pushing\n      { path: '/:pathMatch(.*)', name: 'bad-not-found', component: NotFound },\n    ]\n    // bad example if using named routes:\n    router.resolve({\n      name: 'bad-not-found',\n      params: { pathMatch: 'not/found' },\n    }).href // '/not%2Ffound'\n    // good example:\n    router.resolve({\n      name: 'not-found',\n      params: { pathMatch: ['not', 'found'] },\n    }).href // '/not/found'\n\n**TIP**\n\nYou don't need to add the `*` for repeated params if you don't plan to directly push to the not found route using its name. If you call `router.push('/not/found/url')`, it will provide the right `pathMatch` param.\n\n**Reason**: Vue Router doesn't use `path-to-regexp` anymore, instead it implements its own parsing system that allows route ranking and enables dynamic routing. Since we usually add one single catch-all route per project, there is no big benefit in supporting a special syntax for `*`. The encoding of params is encoding across routes, without exception to make things easier to predict.\n\n### Replaced `onReady` with `isReady`\n\nThe existing `router.onReady()` function has been replaced with `router.isReady()` which doesn't take any argument and returns a Promise:\n\n    // replace\n    router.onReady(onSuccess, onError)\n    // with\n    router.isReady().then(onSuccess).catch(onError)\n    // or use await:\n    try {\n      await router.isReady()\n      // onSuccess\n    } catch (err) {\n      // onError\n    }\n\n### `scrollBehavior` changes\n\nThe object returned in `scrollBehavior` is now similar to [`ScrollToOptions`](https://developer.mozilla.org/en-US/docs/Web/API/ScrollToOptions): `x` is renamed to `left` and `y` is renamed to `top`. See [RFC](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0035-router-scroll-position.md).\n\n**Reason**: making the object similar to `ScrollToOptions` to make it feel more familiar with native JS APIs and potentially enable future new options.\n\n### `<router-view>`, `<keep-alive>`, and `<transition>`\n\n`transition` and `keep-alive` must now be used **inside** of `RouterView` via the `v-slot` API:\n\n    <router-view v-slot=\"{ Component }\">\n      <transition>\n        <keep-alive>\n          <component :is=\"Component\" />\n        </keep-alive>\n      </transition>\n    </router-view>\n\n**Reason**: This was a necessary change. See the [related RFC](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0034-router-view-keep-alive-transitions.md).\n\n### Removal of `append` prop in `<router-link>`\n\nThe `append` prop has been removed from `<router-link>`. You can manually concatenate the value to an existing `path` instead:\n\n    replace\n    <router-link to=\"child-route\" append>to relative child</router-link>\n    with\n    <router-link :to=\"append($route.path, 'child-route')\">\n      to relative child\n    </router-link>\n\nYou must define a global `append` function on your *App* instance:\n\n    app.config.globalProperties.append = (path, pathToAppend) =>\n      path + (path.endsWith('/') ? '' : '/') + pathToAppend\n\n**Reason**: `append` wasn't used very often, is easy to replicate in user land.\n\n### Removal of `event` and `tag` props in `<router-link>`\n\nBoth `event`, and `tag` props have been removed from `<router-link>`. You can use the [`v-slot` API](../../api/index#router-link-s-v-slot) to fully customize `<router-link>`:\n\n    replace\n    <router-link to=\"/about\" tag=\"span\" event=\"dblclick\">About Us</router-link>\n    with\n    <router-link to=\"/about\" custom v-slot=\"{ navigate }\">\n      <span @click=\"navigate\" @keypress.enter=\"navigate\" role=\"link\">About Us</span>\n    </router-link>\n\n**Reason**: These props were often used together to use something different from an `<a>` tag but were introduced before the `v-slot` API and are not used enough to justify adding to the bundle size for everybody.\n\n### Removal of the `exact` prop in `<router-link>`\n\nThe `exact` prop has been removed because the caveat it was fixing is no longer present so you should be able to safely remove it. There are however two things you should be aware of:\n\n- Routes are now active based on the route records they represent instead of the generated route location objects and their `path`, `query`, and `hash` properties\n- Only the `path` section is matched, `query`, and `hash` aren't taken into account anymore\n\nIf you wish to customize this behavior, e.g. take into account the `hash` section, you should use the [`v-slot` API](../../api/index#router-link-s-v-slot) to extend `<router-link>`.\n\n**Reason**: See the [RFC about active matching](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0028-router-active-link.md#summary) changes for more details.\n\n### Navigation guards in mixins are ignored\n\nAt the moment navigation guards in mixins are not supported. You can track its support at [vue-router#454](https://github.com/vuejs/vue-router-next/issues/454).\n\n### Removal of `router.match` and changes to `router.resolve`\n\nBoth `router.match`, and `router.resolve` have been merged together into `router.resolve` with a slightly different signature. [Refer to the API](../../api/index#resolve) for more details.\n\n**Reason**: Uniting multiple methods that were used for the same purpose.\n\n### Removal of `router.getMatchedComponents()`\n\nThe method `router.getMatchedComponents` is now removed as matched components can be retrieved from `router.currentRoute.value.matched`:\n\n    router.currentRoute.value.matched.flatMap(record =>\n      Object.values(record.components)\n    )\n\n**Reason**: This method was only used during SSR and is a one liner that can be done by the user.\n\n### **All** navigations are now always asynchronous\n\nAll navigations, including the first one, are now asynchronous, meaning that, if you use a `transition`, you may need to wait for the router to be *ready* before mounting the app:\n\n    app.use(router)\n    // Note: on Server Side, you need to manually push the initial location\n    router.isReady().then(() => app.mount('#app'))\n\nOtherwise there will be an initial transition as if you provided the `appear` prop to `transition` because the router displays its initial location (nothing) and then displays the first location.\n\nNote that **if you have navigation guards upon the initial navigation**, you might not want to block the app render until they are resolved unless you are doing Server Side Rendering. In this scenario, not waiting the router to be ready to mount the app would yield the same result as in Vue 2.\n\n### Removal of `router.app`\n\n`router.app` used to represent the last root component (Vue instance) that injected the router. Vue Router can now be safely used by multiple Vue applications at the same time. You can still add it when using the router:\n\n    app.use(router)\n    router.app = app\n\nYou can also extend the TypeScript definition of the `Router` interface to add the `app` property.\n\n**Reason**: Vue 3 applications do not exist in Vue 2 and now we properly support multiple applications using the same Router instance, so having an `app` property would have been misleading because it would have been the application instead of the root instance.\n\n### Passing content to route components' `<slot>`\n\nBefore you could directly pass a template to be rendered by a route components' `<slot>` by nesting it under a `<router-view>` component:\n\n    <router-view>\n      <p>In Vue Router 3, I render inside the route component</p>\n    </router-view>\n\nBecause of the introduction of the `v-slot` api for `<router-view>`, you must pass it to the `<component>` using the `v-slot` API:\n\n    <router-view v-slot=\"{ Component }\">\n      <component :is=\"Component\">\n        <p>In Vue Router 3, I render inside the route component</p>\n      </component>\n    </router-view>\n\n### Removal of `parent` from route locations\n\nThe `parent` property has been removed from normalized route locations (`this.$route` and object returned by `router.resolve`). You can still access it via the `matched` array:\n\n    const parent = this.$route.matched[this.$route.matched.length - 2]\n\n**Reason**: Having `parent` and `children` creates unnecessary circular references while the properties could be retrieved already through `matched`.\n\n### Removal of `pathToRegexpOptions`\n\nThe `pathToRegexpOptions` and `caseSensitive` properties of route records have been replaced with `sensitive` and `strict` options for `createRouter()`. They can now also be directly passed when creating the router with `createRouter()`. Any other option specific to `path-to-regexp` has been removed as `path-to-regexp` is no longer used to parse paths.\n\n### Removal of unnamed parameters\n\nDue to the removal of `path-to-regexp`, unnamed parameters are no longer supported:\n\n- `/foo(/foo)?/suffix` becomes `/foo/:_(foo)?/suffix`\n- `/foo(foo)?` becomes `/foo:_(foo)?`\n- `/foo/(.*)` becomes `/foo/:_(.*)`\n\n**TIP**\n\nNote you can use any name instead of `_` for the param. The point is to provide one.\n\n### Usage of `history.state`\n\nVue Router saves information on the `history.state`. If you have any code manually calling `history.pushState()`, you should likely avoid it or refactor it with a regular `router.push()` and a `history.replaceState()`:\n\n    // replace\n    history.pushState(myState, '', url)\n    // with\n    await router.push(url)\n    history.replaceState({ ...history.state, ...myState }, '')\n\nSimilarly, if you were calling `history.replaceState()` without preserving the current state, you will need to pass the current `history.state`:\n\n    // replace\n    history.replaceState({}, '', url)\n    // with\n    history.replaceState(history.state, '', url)\n\n**Reason**: We use the history state to save information about the navigation like the scroll position, previous location, etc.\n\n### `routes` option is required in `options`\n\nThe property `routes` is now required in `options`.\n\n    createRouter({ routes: [] })\n\n**Reason**: The router is designed to be created with routes even though you can add them later on. You need at least one route in most scenarios and this is written once per app in general.\n\n### Non existent named routes\n\nPushing or resolving a non existent named route throws an error:\n\n    // Oops, we made a typo in name\n    router.push({ name: 'homee' }) // throws\n    router.resolve({ name: 'homee' }) // throws\n\n**Reason**: Previously, the router would navigate to `/` but display nothing (instead of the home page). Throwing an error makes more sense because we cannot produce a valid URL to navigate to.\n\n### Missing required `params` on named routes\n\nPushing or resolving a named route without its required params will throw an error:\n\n    // given the following route:\n    const routes = [{ path: '/users/:id', name: 'user', component: UserDetails }]\n\n    // Missing the `id` param will fail\n    router.push({ name: 'user' })\n    router.resolve({ name: 'user' })\n\n**Reason**: Same as above.\n\n### Named children routes with an empty `path` no longer appends a slash\n\nGiven any nested named route with an empty `path`:\n\n    const routes = [\n      {\n        path: '/dashboard',\n        name: 'dashboard-parent',\n        component: DashboardParent,\n        children: [\n          { path: '', name: 'dashboard', component: DashboardDefault },\n          {\n            path: 'settings',\n            name: 'dashboard-settings',\n            component: DashboardSettings,\n          },\n        ],\n      },\n    ]\n\nNavigating or resolving to the named route `dashboard` will now produce a URL **without a trailing slash**:\n\n    router.resolve({ name: 'dashboard' }).href // '/dashboard'\n\nThis has an important side effect about children `redirect` records like these:\n\n    const routes = [\n      {\n        path: '/parent',\n        component: Parent,\n        children: [\n          // this would now redirect to `/home` instead of `/parent/home`\n          { path: '', redirect: 'home' },\n          { path: 'home', component: Home },\n        ],\n      },\n    ]\n\nNote this will work if `path` was `/parent/` as the relative location `home` to `/parent/` is indeed `/parent/home` but the relative location of `home` to `/parent` is `/home`.\n\n**Reason**: This is to make trailing slash behavior consistent: by default all routes allow a trailing slash. It can be disabled by using the `strict` option and manually appending (or not) a slash to the routes.\n\n### `$route` properties Encoding\n\nDecoded values in `params`, `query`, and `hash` are now consistent no matter where the navigation is initiated (older browsers will still produce unencoded `path` and `fullPath`). The initial navigation should yield the same results as in-app navigations.\n\nGiven any [normalized route location](../../api/index#routelocationnormalized):\n\n- Values in `path`, `fullPath` are not decoded anymore. They will appear as provided by the browser (most browsers provide them encoded). e.g. directly writing on the address bar `https://example.com/hello world` will yield the encoded version: `https://example.com/hello%20world` and both `path` and `fullPath` will be `/hello%20world`.\n- `hash` is now decoded, that way it can be copied over: `router.push({ hash: $route.hash })` and be used directly in [scrollBehavior](../../api/index#scrollbehavior)'s `el` option.\n- When using `push`, `resolve`, and `replace` and providing a `string` location or a `path` property in an object, **it must be encoded** (like in the previous version). On the other hand, `params`, `query` and `hash` must be provided in its unencoded version.\n- The slash character (`/`) is now properly decoded inside `params` while still producing an encoded version on the URL: `%2F`.\n\n**Reason**: This allows to easily copy existing properties of a location when calling `router.push()` and `router.resolve()`, and make the resulting route location consistent across browsers. `router.push()` is now idempotent, meaning that calling `router.push(route.fullPath)`, `router.push({ hash: route.hash })`, `router.push({ query: route.query })`, and `router.push({ params: route.params })` will not create extra encoding.\n\n### TypeScript changes\n\nTo make typings more consistent and expressive, some types have been renamed:\n\n| `vue-router@3` | `vue-router@4`          |\n|----------------|-------------------------|\n| RouteConfig    | RouteRecordRaw          |\n| Location       | RouteLocation           |\n| Route          | RouteLocationNormalized |\n\n## New Features\n\nSome of new features to keep an eye on in Vue Router 4 include:\n\n- [Dynamic Routing](../advanced/dynamic-routing)\n- [Composition API](../advanced/composition-api)\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/migration/index.md)\n\n[Dynamic Routing](../advanced/dynamic-routing)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/migration/](https://next.router.vuejs.org/guide/migration/)"
- name: name
  id: api/index#name-2
  summary: Name for the route record
  belongs_to: API Reference
  description: |-
    ### name

    - **Type**: `string | symbol | undefined`

    - **Details**:

      Name for the route record. `undefined` if none was provided.

    &nbsp;
- name: name
  id: api/index#name
  summary: When a <router-view> has a name, it will render the component with the corresponding name in the matched route record's components option
  belongs_to: API Reference
  description: |-
    ### name

    - **Type**: `string`

    - **Default**: `"default"`

    - **Details**:

      When a `<router-view>` has a `name`, it will render the component with the corresponding name in the matched route record's `components` option.

    - **See Also**: [Named Views](../guide/essentials/named-views)

    &nbsp;
- name: name
  id: api/index#name-1
  summary: Unique name for the route record
  belongs_to: API Reference
  description: |-
    ### name

    - **Type**: `string | symbol` (Optional)

    - **Details**:

      Unique name for the route record.

    &nbsp;
- name: name
  id: api/index#name-3
  summary: Name for the route record
  belongs_to: API Reference
  description: |-
    ### name

    - **Type**: `string | symbol | undefined | null`

    - **Details**:

      Name for the route record. `undefined` if none was provided.

    &nbsp;
- name: Named Routes
  id: guide/essentials/named-routes
  summary: Alongside the path, you can provide a name to any route
  description: "# Named Routes\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/named-routes?friend=vuerouter \"Learn about the named routes\")\n\nAlongside the `path`, you can provide a `name` to any route. This has the following advantages:\n\n- No hardcoded URLs\n- Automatic encoding/decoding of `params`\n- Prevents you from having a typo in the url\n- Bypassing path ranking (e.g. to display a )\n\n    const routes = [\n      {\n        path: '/user/:username',\n        name: 'user',\n        component: User\n      }\n    ]\n\nTo link to a named route, you can pass an object to the `router-link` component's `to` prop:\n\n    <router-link :to=\"{ name: 'user', params: { username: 'erina' }}\">\n      User\n    </router-link>\n\nThis is the exact same object used programmatically with `router.push()`:\n\n    router.push({ name: 'user', params: { username: 'erina' } })\n\nIn both cases, the router will navigate to the path `/user/erina`.\n\nFull example [here](https://github.com/vuejs/vue-router/blob/dev/examples/named-routes/app.js).\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/essentials/named-routes.md)\n\n[Programmatic Navigation](navigation)\n\n[Named Views](named-views)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/essentials/named-routes](https://next.router.vuejs.org/guide/essentials/named-routes)"
- name: Named Views
  id: guide/essentials/named-views
  summary: Sometimes you need to display multiple views at the same time instead of nesting them, e.g
  description: "# Named Views\n\nSometimes you need to display multiple views at the same time instead of nesting them, e.g. creating a layout with a `sidebar` view and a `main` view. This is where named views come in handy. Instead of having one single outlet in your view, you can have multiple and give each of them a name. A `router-view` without a name will be given `default` as its name.\n\n    <router-view class=\"view left-sidebar\" name=\"LeftSidebar\"></router-view>\n    <router-view class=\"view main-content\"></router-view>\n    <router-view class=\"view right-sidebar\" name=\"RightSidebar\"></router-view>\n\nA view is rendered by using a component, therefore multiple views require multiple components for the same route. Make sure to use the `components` (with an **s**) option:\n\n    const router = createRouter({\n      history: createWebHashHistory(),\n      routes: [\n        {\n          path: '/',\n          components: {\n            default: Home,\n            // short for LeftSidebar: LeftSidebar\n            LeftSidebar,\n            // they match the `name` attribute on `<router-view>`\n            RightSidebar,\n          },\n        },\n      ],\n    })\n\nA working demo of this example can be found [here](https://codesandbox.io/s/named-views-vue-router-4-examples-rd20l).\n\n## Nested Named Views\n\nIt is possible to create complex layouts using named views with nested views. When doing so, you will also need to give nested `router-view` a name. Let's take a Settings panel example:\n\n    /settings/emails                                       /settings/profile\n    +-----------------------------------+                  +------------------------------+\n    | UserSettings                      |                  | UserSettings                 |\n    | +-----+-------------------------+ |                  | +-----+--------------------+ |\n    | | Nav | UserEmailsSubscriptions | |  +------------>  | | Nav | UserProfile        | |\n    | |     +-------------------------+ |                  | |     +--------------------+ |\n    | |     |                         | |                  | |     | UserProfilePreview | |\n    | +-----+-------------------------+ |                  | +-----+--------------------+ |\n    +-----------------------------------+                  +------------------------------+\n\n- `Nav` is just a regular component\n- `UserSettings` is the parent view component\n- `UserEmailsSubscriptions`, `UserProfile`, `UserProfilePreview` are nested view components\n\n**Note**: *Let's forget about how the HTML/CSS should look like to represent such layout and focus on the components used.*\n\nThe `<template>` section for `UserSettings` component in the above layout would look something like this:\n\n    <!-- UserSettings.vue -->\n    <div>\n      <h1>User Settings</h1>\n      <NavBar />\n      <router-view />\n      <router-view name=\"helper\" />\n    </div>\n\nThen you can achieve the layout above with this route configuration:\n\n    {\n      path: '/settings',\n      // You could also have named views at the top\n      component: UserSettings,\n      children: [{\n        path: 'emails',\n        component: UserEmailsSubscriptions\n      }, {\n        path: 'profile',\n        components: {\n          default: UserProfile,\n          helper: UserProfilePreview\n        }\n      }]\n    }\n\nA working demo of this example can be found [here](https://codesandbox.io/s/nested-named-views-vue-router-4-examples-re9yl?&initialpath=%2Fsettings%2Femails).\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/essentials/named-views.md)\n\n[Named Routes](named-routes)\n\n[Redirect and Alias](redirect-and-alias)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/essentials/named-views](https://next.router.vuejs.org/guide/essentials/named-views)"
- name: Navigation Guards
  id: guide/advanced/navigation-guards
  summary: As the name suggests, the navigation guards provided by Vue router are primarily used to guard navigations either by redirecting it or canceling it
  description: "# Navigation Guards\n\nAs the name suggests, the navigation guards provided by Vue router are primarily used to guard navigations either by redirecting it or canceling it. There are a number of ways to hook into the route navigation process: globally, per-route, or in-component.\n\n## Global Before Guards\n\nYou can register global before guards using `router.beforeEach`:\n\n    const router = createRouter({ ... })\n\n    router.beforeEach((to, from) => {\n      // ...\n      // explicitly return false to cancel the navigation\n      return false\n    })\n\nGlobal before guards are called in creation order, whenever a navigation is triggered. Guards may be resolved asynchronously, and the navigation is considered **pending** before all hooks have been resolved.\n\nEvery guard function receives two arguments:\n\n- **`to`**: the target route location [in a normalized format](../../api/index#routelocationnormalized) being navigated to.\n- **`from`**: the current route location [in a normalized format](../../api/index#routelocationnormalized) being navigated away from.\n\nAnd can optionally return any of the following values:\n\n- `false`: cancel the current navigation. If the browser URL was changed (either manually by the user or via back button), it will be reset to that of the `from` route.\n- A [Route Location](../../api/index#routelocationraw): Redirect to a different location by passing a route location as if you were calling [`router.push()`](../../api/index#push), which allows you to pass options like `replace: true` or `name: 'home'`. The current navigation is dropped and a new one is created with the same `from`.\n\nIt's also possible to throw an `Error` if an unexpected situation was met. This will also cancel the navigation and call any callback registered via [`router.onError()`](../../api/index#onerror).\n\nIf nothing, `undefined` or `true` is returned, **the navigation is validated**, and the next navigation guard is called.\n\nAll of the the things above **work the same way with `async` functions** and Promises:\n\n    router.beforeEach(async (to, from) => {\n      // canUserAccess() returns `true` or `false`\n      const canAccess = await canUserAccess(to)\n      if (!canAccess) return '/login'\n    })\n\n### Optional third argument `next`\n\nIn previous versions of Vue Router, it was also possible to use a *third argument* `next`, this was a common source of mistakes and went through an [RFC](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0037-router-return-guards.md#motivation) to remove it. However, it is still supported, meaning you can pass a third argument to any navigation guard. In that case, **you must call `next` exactly once** in any given pass through a navigation guard. It can appear more than once, but only if the logical paths have no overlap, otherwise the hook will never be resolved or produce errors. Here is **a bad example** of redirecting to user to `/login` if they are not authenticated:\n\n    // BAD\n    router.beforeEach((to, from, next) => {\n      if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })\n      // if the user is not authenticated, `next` is called twice\n      next()\n    })\n\nHere is the correct version:\n\n    // GOOD\n    router.beforeEach((to, from, next) => {\n      if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })\n      else next()\n    })\n\n## Global Resolve Guards\n\nYou can register a global guard with `router.beforeResolve`. This is similar to `router.beforeEach` because it triggers on **every navigation**, but resolve guards are called right before the navigation is confirmed, **after all in-component guards and async route components are resolved**. Here is an example that ensures the user has given access to the Camera for routes that [have defined a custom meta](meta) property `requiresCamera`:\n\n    router.beforeResolve(async to => {\n      if (to.meta.requiresCamera) {\n        try {\n          await askForCameraPermission()\n        } catch (error) {\n          if (error instanceof NotAllowedError) {\n            // ... handle the error and then cancel the navigation\n            return false\n          } else {\n            // unexpected error, cancel the navigation and pass the error to the global handler\n            throw error\n          }\n        }\n      }\n    })\n\n`router.beforeResolve` is the ideal spot to fetch data or do any other operation that you want to avoid doing if the user cannot enter a page.\n\n## Global After Hooks\n\nYou can also register global after hooks, however unlike guards, these hooks do not get a `next` function and cannot affect the navigation:\n\n    router.afterEach((to, from) => {\n      sendToAnalytics(to.fullPath)\n    })\n\nThey are useful for analytics, changing the title of the page, accessibility features like announcing the page and many other things.\n\nThey also reflect [navigation failures](navigation-failures) as the third argument:\n\n    router.afterEach((to, from, failure) => {\n      if (!failure) sendToAnalytics(to.fullPath)\n    })\n\nLearn more about navigation failures on [its guide](navigation-failures).\n\n## Per-Route Guard\n\nYou can define `beforeEnter` guards directly on a route's configuration object:\n\n    const routes = [\n      {\n        path: '/users/:id',\n        component: UserDetails,\n        beforeEnter: (to, from) => {\n          // reject the navigation\n          return false\n        },\n      },\n    ]\n\n`beforeEnter` guards **only trigger when entering the route**, they don't trigger when the `params`, `query` or `hash` change e.g. going from `/users/2` to `/users/3` or going from `/users/2#info` to `/users/2#projects`. They are only triggered when navigating **from a different** route.\n\nYou can also pass an array of functions to `beforeEnter`, this is useful when reusing guards for different routes:\n\n    function removeQueryParams(to) {\n      if (Object.keys(to.query).length)\n        return { path: to.path, query: {}, hash: to.hash }\n    }\n\n    function removeHash(to) {\n      if (to.hash) return { path: to.path, query: to.query, hash: '' }\n    }\n\n    const routes = [\n      {\n        path: '/users/:id',\n        component: UserDetails,\n        beforeEnter: [removeQueryParams, removeHash],\n      },\n      {\n        path: '/about',\n        component: UserDetails,\n        beforeEnter: [removeQueryParams],\n      },\n    ]\n\nNote it is possible to achieve a similar behavior by using [route meta fields](meta) and [global navigation guards](#global-before-guards).\n\n## In-Component Guards\n\nFinally, you can directly define route navigation guards inside route components (the ones passed to the router configuration)\n\n### Using the options API\n\nYou can add the following options to route components:\n\n- `beforeRouteEnter`\n- `beforeRouteUpdate`\n- `beforeRouteLeave`\n\n    const UserDetails = {\n      template: `...`,\n      beforeRouteEnter(to, from) {\n        // called before the route that renders this component is confirmed.\n        // does NOT have access to `this` component instance,\n        // because it has not been created yet when this guard is called!\n      },\n      beforeRouteUpdate(to, from) {\n        // called when the route that renders this component has changed,\n        // but this component is reused in the new route.\n        // For example, given a route with params `/users/:id`, when we\n        // navigate between `/users/1` and `/users/2`, the same `UserDetails` component instance\n        // will be reused, and this hook will be called when that happens.\n        // Because the component is mounted while this happens, the navigation guard has access to `this` component instance.\n      },\n      beforeRouteLeave(to, from) {\n        // called when the route that renders this component is about to\n        // be navigated away from.\n        // As with `beforeRouteUpdate`, it has access to `this` component instance.\n      },\n    }\n\nThe `beforeRouteEnter` guard does **NOT** have access to `this`, because the guard is called before the navigation is confirmed, thus the new entering component has not even been created yet.\n\nHowever, you can access the instance by passing a callback to `next`. The callback will be called when the navigation is confirmed, and the component instance will be passed to the callback as the argument:\n\n    beforeRouteEnter (to, from, next) {\n      next(vm => {\n        // access to component public instance via `vm`\n      })\n    }\n\nNote that `beforeRouteEnter` is the only guard that supports passing a callback to `next`. For `beforeRouteUpdate` and `beforeRouteLeave`, `this` is already available, so passing a callback is unnecessary and therefore *not supported*:\n\n    beforeRouteUpdate (to, from) {\n      // just use `this`\n      this.name = to.params.name\n    }\n\nThe **leave guard** is usually used to prevent the user from accidentally leaving the route with unsaved edits. The navigation can be canceled by returning `false`.\n\n    beforeRouteLeave (to, from) {\n      const answer = window.confirm('Do you really want to leave? you have unsaved changes!')\n      if (!answer) return false\n    }\n\n### Using the composition API\n\nIf you are writing your component using the [composition API and a `setup` function](https://v3.vuejs.org/guide/composition-api-setup.html#setup), you can add update and leave guards through `onBeforeRouteUpdate` and `onBeforeRouteLeave` respectively. Please refer to the [Composition API section](composition-api#navigation-guards) for more details.\n\n## The Full Navigation Resolution Flow\n\n1.  Navigation triggered.\n2.  Call `beforeRouteLeave` guards in deactivated components.\n3.  Call global `beforeEach` guards.\n4.  Call `beforeRouteUpdate` guards in reused components.\n5.  Call `beforeEnter` in route configs.\n6.  Resolve async route components.\n7.  Call `beforeRouteEnter` in activated components.\n8.  Call global `beforeResolve` guards.\n9.  Navigation is confirmed.\n10. Call global `afterEach` hooks.\n11. DOM updates triggered.\n12. Call callbacks passed to `next` in `beforeRouteEnter` guards with instantiated instances.\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/advanced/navigation-guards.md)\n\n[Different History modes](../essentials/history-mode)\n\n[Route Meta Fields](meta)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/advanced/navigation-guards](https://next.router.vuejs.org/guide/advanced/navigation-guards)"
- name: Nested Routes
  id: guide/essentials/nested-routes
  summary: Some application's UIs are composed of components that are nested multiple levels deep
  description: "# Nested Routes\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/nested-routes?friend=vuerouter \"Learn about nested routes\")\n\nSome application's UIs are composed of components that are nested multiple levels deep. In this case, it is very common that the segments of a URL corresponds to a certain structure of nested components, for example:\n\n    /user/johnny/profile                     /user/johnny/posts\n    +------------------+                  +-----------------+\n    | User             |                  | User            |\n    | +--------------+ |                  | +-------------+ |\n    | | Profile      | |  +------------>  | | Posts       | |\n    | |              | |                  | |             | |\n    | +--------------+ |                  | +-------------+ |\n    +------------------+                  +-----------------+\n\nWith Vue Router, you can express this relationship using nested route configurations.\n\nGiven the app we created in the last chapter:\n\n    <div id=\"app\">\n      <router-view></router-view>\n    </div>\n\n    const User = {\n      template: '<div>User {{ $route.params.id }}</div>',\n    }\n\n    // these are passed to `createRouter`\n    const routes = [{ path: '/user/:id', component: User }]\n\nThe `<router-view>` here is a top-level `router-view`. It renders the component matched by a top level route. Similarly, a rendered component can also contain its own, nested `<router-view>`. For example, if we add one inside the `User` component's template:\n\n    const User = {\n      template: `\n        <div class=\"user\">\n          <h2>User {{ $route.params.id }}</h2>\n          <router-view></router-view>\n        </div>\n      `,\n    }\n\nTo render components into this nested `router-view`, we need to use the `children` option in any of the routes:\n\n    const routes = [\n      {\n        path: '/user/:id',\n        component: User,\n        children: [\n          {\n            // UserProfile will be rendered inside User's <router-view>\n            // when /user/:id/profile is matched\n            path: 'profile',\n            component: UserProfile,\n          },\n          {\n            // UserPosts will be rendered inside User's <router-view>\n            // when /user/:id/posts is matched\n            path: 'posts',\n            component: UserPosts,\n          },\n        ],\n      },\n    ]\n\n**Note that nested paths that start with `/` will be treated as a root path. This allows you to leverage the component nesting without having to use a nested URL.**\n\nAs you can see the `children` option is just another Array of routes like `routes` itself. Therefore, you can keep nesting views as much as you need.\n\nAt this point, with the above configuration, when you visit `/user/eduardo`, nothing will be rendered inside `User`'s `router-view`, because no nested route is matched. Maybe you do want to render something there. In such case you can provide an empty nested path:\n\n    const routes = [\n      {\n        path: '/user/:id',\n        component: User,\n        children: [\n          // UserHome will be rendered inside User's <router-view>\n          // when /user/:id is matched\n          { path: '', component: UserHome },\n\n          // ...other sub routes\n        ],\n      },\n    ]\n\nA working demo of this example can be found [here](https://codesandbox.io/s/nested-views-vue-router-4-examples-hl326?initialpath=%2Fusers%2Feduardo).\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/essentials/nested-routes.md)\n\n[Routes' Matching Syntax](route-matching-syntax)\n\n[Programmatic Navigation](navigation)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/essentials/nested-routes](https://next.router.vuejs.org/guide/essentials/nested-routes)"
- name: onBeforeRouteLeave
  id: api/index#onbeforerouteleave
  summary: Add a navigation guard that triggers whenever the component for the current location is about to be left
  belongs_to: API Reference
  description: "### onBeforeRouteLeave\n\nAdd a navigation guard that triggers whenever the component for the current location is about to be left. Similar to `beforeRouteLeave` but can be used in any component. The guard is removed when the component is unmounted.\n\n**Signature:**\n\n                  exportdeclarefunctiononBeforeRouteLeave(leaveGuard: NavigationGuard): void\n\n                \n\n#### Parameters\n\n| Parameter  | Type                                  | Description             |\n|------------|---------------------------------------|-------------------------|\n| leaveGuard | [`NavigationGuard`](#navigationguard) | Navigation guard to add |"
- name: onBeforeRouteUpdate
  id: api/index#onbeforerouteupdate
  summary: Add a navigation guard that triggers whenever the current location is about to be updated
  belongs_to: API Reference
  description: "### onBeforeRouteUpdate\n\nAdd a navigation guard that triggers whenever the current location is about to be updated. Similar to `beforeRouteUpdate` but can be used in any component. The guard is removed when the component is unmounted.\n\n**Signature:**\n\n                  exportdeclarefunctiononBeforeRouteUpdate(updateGuard: NavigationGuard): void\n\n                \n\n#### Parameters\n\n| Parameter   | Type                                  | Description             |\n|-------------|---------------------------------------|-------------------------|\n| updateGuard | [`NavigationGuard`](#navigationguard) | Navigation guard to add |"
- name: onError
  id: api/index#onerror
  summary: Adds an error handler that is called every time a non caught error happens during navigation
  belongs_to: API Reference
  description: "### onError\n\nAdds an error handler that is called every time a non caught error happens during navigation. This includes errors thrown synchronously and asynchronously, errors returned or passed to `next` in any navigation guard, and errors occurred when trying to resolve an async component that is required to render a route.\n\n**Signature:**\n\n                  onError(handler:(error:any, to: RouteLocationNormalized, from: RouteLocationNormalized) => any): () => void\n\n                \n\n*Parameters*\n\n| Parameter | Type                                                                              | Description               |\n|-----------|-----------------------------------------------------------------------------------|---------------------------|\n| handler   | `(error: any, to: RouteLocationNormalized, from: RouteLocationNormalized) => any` | error handler to register |"
- name: options
  id: api/index#options
  summary: Original options object passed to create the Router
  belongs_to: API Reference
  description: |-
    ### options

    - **Type**: [`RouterOptions`](#routeroptions)

    - **Details**:

      Original options object passed to create the Router. Readonly.

    ## Router Methods
- name: Parameters
  id: api/index#parameters-1
  summary: null
  belongs_to: API Reference
  description: |-
    ### Parameters

    | Parameter | Type     | Description                                                                                                           |
    |-----------|----------|-----------------------------------------------------------------------------------------------------------------------|
    | base      | `string` | optional base to provide. Useful when the application is hosted inside of a folder like `https://example.com/folder/` |
- name: Parameters
  id: api/index#parameters-2
  summary: null
  belongs_to: API Reference
  description: |-
    ### Parameters

    | Parameter | Type     | Description                                                                                                                                                                                                                                                                                                                                                       |
    |-----------|----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | base      | `string` | optional base to provide. Defaults to `location.pathname + location.search`. If there is a `<base>` tag in the `head`, its value will be ignored in favor of this parameter **but note it affects all the history.pushState() calls**, meaning that if you use a `<base>` tag, its `href` value **has to match this parameter** (ignoring anything after the `#`) |
- name: Parameters
  id: api/index#parameters
  summary: Creates an HTML5 history
  belongs_to: API Reference
  description: |-
    ### Parameters

    | Parameter | Type                            | Description                      |
    |-----------|---------------------------------|----------------------------------|
    | options   | [RouterOptions](#routeroptions) | Options to initialize the router |

    ## createWebHistory

    Creates an HTML5 history. Most common history for single page applications. The application must be served through the http protocol.

    **Signature:**

                      exportdeclarefunctioncreateWebHistory(base?:string): RouterHistory
- name: Parameters
  id: api/index#parameters-3
  summary: null
  belongs_to: API Reference
  description: |-
    ### Parameters

    | Parameter | Type     | Description                               |
    |-----------|----------|-------------------------------------------|
    | base      | `string` | Base applied to all urls, defaults to '/' |
- name: params
  id: api/index#params
  summary: Dictionary of decoded params extracted from path
  belongs_to: API Reference
  description: |-
    ### params

    - **Type**: `Record<string, string | string[]>`

    - **Details**:

      Dictionary of decoded params extracted from `path`.

    &nbsp;
- name: parseQuery
  id: api/index#parsequery
  summary: Custom implementation to parse a query
  belongs_to: API Reference
  description: "### parseQuery\n\nCustom implementation to parse a query. Must decode query keys and values. See its counterpart, [stringifyQuery](#stringifyquery).\n\n**Signature:**\n\n                  parseQuery?: (searchQuery: string) => Record<string, (string | null)[] | string | null>\n\n                \n\n#### Examples\n\nLet's say you want to use the package [qs](https://github.com/ljharb/qs) to parse queries, you can provide both `parseQuery` and `stringifyQuery`:\n\n                  import qs from 'qs'\n\n    createRouter({\n      // other options...\n      parseQuery: qs.parse,\n      stringifyQuery: qs.stringify,\n    })"
- name: Passing Props to Route Components
  id: guide/essentials/passing-props
  summary: Using $route in your component creates a tight coupling with the route which limits the flexibility of the component as it can only be used on certain URLs
  description: "# Passing Props to Route Components\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/route-props?friend=vuerouter \"Learn how to pass props to route components\")\n\nUsing `$route` in your component creates a tight coupling with the route which limits the flexibility of the component as it can only be used on certain URLs. While this is not necessarily a bad thing, we can decouple this behavior with a `props` option:\n\nWe can replace\n\n    const User = {\n      template: '<div>User {{ $route.params.id }}</div>'\n    }\n    const routes = [{ path: '/user/:id', component: User }]\n\nwith\n\n    const User = {\n      // make sure to add a prop named exactly like the route param\n      props: ['id'],\n      template: '<div>User {{ id }}</div>'\n    }\n    const routes = [{ path: '/user/:id', component: User, props: true }]\n\nThis allows you to use the component anywhere, which makes the component easier to reuse and test.\n\n## Boolean mode\n\nWhen `props` is set to `true`, the `route.params` will be set as the component props.\n\n## Named views\n\nFor routes with named views, you have to define the `props` option for each named view:\n\n    const routes = [\n      {\n        path: '/user/:id',\n        components: { default: User, sidebar: Sidebar },\n        props: { default: true, sidebar: false }\n      }\n    ]\n\n## Object mode\n\nWhen `props` is an object, this will be set as the component props as-is. Useful for when the props are static.\n\n    const routes = [\n      {\n        path: '/promotion/from-newsletter',\n        component: Promotion,\n        props: { newsletterPopup: false }\n      }\n    ]\n\n## Function mode\n\nYou can create a function that returns props. This allows you to cast parameters into other types, combine static values with route-based values, etc.\n\n    const routes = [\n      {\n        path: '/search',\n        component: SearchUser,\n        props: route => ({ query: route.query.q })\n      }\n    ]\n\nThe URL `/search?q=vue` would pass `{query: 'vue'}` as props to the `SearchUser` component.\n\nTry to keep the `props` function stateless, as it's only evaluated on route changes. Use a wrapper component if you need state to define the props, that way vue can react to state changes.\n\nFor advanced usage, check out the [example](https://github.com/vuejs/vue-router/blob/dev/examples/route-props/app.js).\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/essentials/passing-props.md)\n\n[Redirect and Alias](redirect-and-alias)\n\n[Different History modes](history-mode)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/essentials/passing-props](https://next.router.vuejs.org/guide/essentials/passing-props)"
- name: path
  id: api/index#path-1
  summary: Normalized path of the record
  belongs_to: API Reference
  description: |-
    ### path

    - **Type**: `string`

    - **Details**:

      Normalized path of the record. Includes any parent's `path`.

    &nbsp;
- name: path
  id: api/index#path-2
  summary: Encoded pathname section of the URL associated to the route location
  belongs_to: API Reference
  description: |-
    ### path

    - **Type**: `string`

    - **Details**:

      Encoded `pathname` section of the URL associated to the route location.

    &nbsp;
- name: path
  id: api/index#path
  summary: Path of the record
  belongs_to: API Reference
  description: |-
    ### path

    - **Type**: `string`

    - **Details**:

      Path of the record. Should start with `/` unless the record is the child of another record. Can define parameters: `/users/:id` matches `/users/1` as well as `/users/posva`.

    - **See Also**: [Dynamic Route Matching](../guide/essentials/dynamic-matching)

    &nbsp;
- name: Programmatic Navigation
  id: guide/essentials/navigation
  summary: Aside from using <router-link> to create anchor tags for declarative navigation, we can do this programmatically using the router's instance methods
  description: "# Programmatic Navigation\n\nAside from using `<router-link>` to create anchor tags for declarative navigation, we can do this programmatically using the router's instance methods.\n\n## Navigate to a different location\n\n**Note: Inside of a Vue instance, you have access to the router instance as `$router`. You can therefore call `this.$router.push`.**\n\nTo navigate to a different URL, use `router.push`. This method pushes a new entry into the history stack, so when the user clicks the browser back button they will be taken to the previous URL.\n\nThis is the method called internally when you click a `<router-link>`, so clicking `<router-link :to=\"...\">` is the equivalent of calling `router.push(...)`.\n\n| Declarative               | Programmatic       |\n|---------------------------|--------------------|\n| `<router-link :to=\"...\">` | `router.push(...)` |\n\nThe argument can be a string path, or a location descriptor object. Examples:\n\n    // literal string path\n    router.push('/users/eduardo')\n\n    // object with path\n    router.push({ path: '/users/eduardo' })\n\n    // named route with params to let the router build the url\n    router.push({ name: 'user', params: { username: 'eduardo' } })\n\n    // with query, resulting in /register?plan=private\n    router.push({ path: '/register', query: { plan: 'private' } })\n\n    // with hash, resulting in /about#team\n    router.push({ path: '/about', hash: '#team' })\n\n**Note**: `params` are ignored if a `path` is provided, which is not the case for `query`, as shown in the example above. Instead, you need to provide the `name` of the route or manually specify the whole `path` with any parameter:\n\n    const username = 'eduardo'\n    // we can manually build the url but we will have to handle the encoding ourselves\n    router.push(`/user/${username}`) // -> /user/eduardo\n    // same as\n    router.push({ path: `/user/${username}` }) // -> /user/eduardo\n    // if possible use `name` and `params` to benefit from automatic URL encoding\n    router.push({ name: 'user', params: { username } }) // -> /user/eduardo\n    // `params` cannot be used alongside `path`\n    router.push({ path: '/user', params: { username } }) // -> /user\n\nWhen specifying `params`, make sure to either provide a `string` or `number` (or an array of these for [repeatable params](route-matching-syntax#repeatable-params)). **Any other type (like `undefined`, `false`, etc) will be automatically stringified**. For [optional params](route-matching-syntax#repeatable-params), you can provide an empty string (`\"\"`) as the value to skip it.\n\nSince the prop `to` accepts the same kind of object as `router.push`, the exact same rules apply to both of them.\n\n`router.push` and all the other navigation methods return a *Promise* that allows us to wait til the navigation is finished and to know if it succeeded or failed. We will talk more about that in [Navigation Handling](../advanced/navigation-failures).\n\n## Replace current location\n\nIt acts like `router.push`, the only difference is that it navigates without pushing a new history entry, as its name suggests - it replaces the current entry.\n\n| Declarative                       | Programmatic          |\n|-----------------------------------|-----------------------|\n| `<router-link :to=\"...\" replace>` | `router.replace(...)` |\n\nIt's also possible to directly add a property `replace: true` to the `routeLocation` that is passed to `router.push`:\n\n    router.push({ path: '/home', replace: true })\n    // equivalent to\n    router.replace({ path: '/home' })\n\n## Traverse history\n\nThis method takes a single integer as parameter that indicates by how many steps to go forward or go backward in the history stack, similar to `window.history.go(n)`.\n\nExamples\n\n    // go forward by one record, the same as router.forward()\n    router.go(1)\n\n    // go back by one record, the same as router.back()\n    router.go(-1)\n\n    // go forward by 3 records\n    router.go(3)\n\n    // fails silently if there aren't that many records\n    router.go(-100)\n    router.go(100)\n\n## History Manipulation\n\nYou may have noticed that `router.push`, `router.replace` and `router.go` are counterparts of [`window.history.pushState`, `window.history.replaceState` and `window.history.go`](https://developer.mozilla.org/en-US/docs/Web/API/History), and they do imitate the `window.history` APIs.\n\nTherefore, if you are already familiar with [Browser History APIs](https://developer.mozilla.org/en-US/docs/Web/API/History_API), manipulating history will feel familiar when using Vue Router.\n\nIt is worth mentioning that Vue Router navigation methods (`push`, `replace`, `go`) work consistently no matter the kind of [`history` option](../../api/index#history) is passed when creating the router instance.\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/essentials/navigation.md)\n\n[Nested Routes](nested-routes)\n\n[Named Routes](named-routes)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/essentials/navigation](https://next.router.vuejs.org/guide/essentials/navigation)"
- name: props
  id: api/index#props-1
  summary: Dictionary of the props option for each named view
  belongs_to: API Reference
  description: |-
    ### props

    - **Type**: `Record<string, boolean | Function | Record<string, any>>`

    - **Details**:

      Dictionary of the [`props` option](#props) for each named view. If none, it will contain only one property named `default`.

    &nbsp;
- name: props
  id: api/index#props
  summary: Allows passing down params as props to the component rendered by router-view
  belongs_to: API Reference
  description: |-
    ### props

    - **Type**: `boolean | Record<string, any> | (to: RouteLocationNormalized) => Record<string, any>` (Optional)

    - **Details**:

      Allows passing down params as props to the component rendered by `router-view`. When passed to a *multiple views record*, it should be an object with the same keys as `components` or a `boolean` to be applied to each component. target location.

    - **See Also**: [Passing props to Route Components](../guide/essentials/passing-props)

    &nbsp;
- name: push
  id: api/index#push
  summary: Programmatically navigate to a new URL by pushing an entry in the history stack
  belongs_to: API Reference
  description: "### push\n\nProgrammatically navigate to a new URL by pushing an entry in the history stack.\n\n**Signature:**\n\n                  push(to: RouteLocationRaw): Promise<NavigationFailure | void | undefined>\n\n                \n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Route location to navigate to |"
- name: query
  id: api/index#query
  summary: Dictionary of decoded query params extracted from the search section of the URL
  belongs_to: API Reference
  description: |-
    ### query

    - **Type**: `Record<string, string | string[]>`

    - **Details**:

      Dictionary of decoded query params extracted from the `search` section of the URL.

    &nbsp;
- name: redirect
  id: api/index#redirect
  summary: Where to redirect if the route is directly matched
  belongs_to: API Reference
  description: |-
    ### redirect

    - **Type**: `RouteLocationRaw | (to: RouteLocationNormalized) => RouteLocationRaw` (Optional)

    - **Details**:

      Where to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location. Can also be a function that receives the target route location and returns the location we should redirect to.

    &nbsp;
- name: redirect
  id: api/index#redirect-1
  summary: Where to redirect if the route is directly matched
  belongs_to: API Reference
  description: "### redirect\n\n- **Type**: [`RouteLocationRaw`](#routelocationraw)\n\n- **Details**:\n\n  Where to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\n## RouteLocationRaw\n\nUser-level route location that can be passed to `router.push()`, `redirect`, and returned in [Navigation Guards](../guide/advanced/navigation-guards).\n\nA raw location can either be a `string` like `/users/posva#bio` or an object:\n\n                  // these three forms are equivalent\n    router.push('/users/posva#bio')\n    router.push({ path: '/users/posva', hash: '#bio' })\n    router.push({ name: 'users', params: { username: 'posva' }, hash: '#bio' })\n    // only change the hash\n    router.push({ hash: '#bio' })\n    // only change query\n    router.push({ query: { page: '2' } })\n    // change one param\n    router.push({ params: { username: 'jolyne' } })\n\n                \n\nNote `path` must be provided encoded (e.g. `phantom blood` becomes `phantom%20blood`) while `params`, `query` and `hash` must not, they are encoded by the router.\n\nRaw route locations also support an extra option `replace` to call `router.replace()` instead of `router.push()` in navigation guards. Note this also internally calls `router.replace()` even when calling `router.push()`:\n\n                  router.push({ hash: '#bio', replace: true })\n    // equivalent to\n    router.replace({ hash: '#bio' })\n\n                \n\n## RouteLocation\n\nResolved [RouteLocationRaw](#routelocationraw) that can contain [redirect records](#routerecordraw). Apart from that it has the same properties as [RouteLocationNormalized](#routelocationnormalized).\n\n## RouteLocationNormalized\n\nNormalized route location. Does not have any [redirect records](#routerecordraw). In navigation guards, `to` and `from` are always of this type."
- name: Redirect and Alias
  id: guide/essentials/redirect-and-alias
  summary: Redirecting is also done in the routes configuration
  description: "# Redirect and Alias\n\n## Redirect\n\nRedirecting is also done in the `routes` configuration. To redirect from `/a` to `/b`:\n\n    const routes = [{ path: '/home', redirect: '/' }]\n\nThe redirect can also be targeting a named route:\n\n    const routes = [{ path: '/home', redirect: { name: 'homepage' } }]\n\nOr even use a function for dynamic redirecting:\n\n    const routes = [\n      {\n        // /search/screens -> /search?q=screens\n        path: '/search/:searchText',\n        redirect: to => {\n          // the function receives the target route as the argument\n          // we return a redirect path/location here.\n          return { path: '/search', query: { q: to.params.searchText } }\n        },\n      },\n      {\n        path: '/search',\n        // ...\n      },\n    ]\n\nNote that **[Navigation Guards](../advanced/navigation-guards) are not applied on the route that redirects, only on its target**. e.g. In the above example, adding a `beforeEnter` guard to the `/home` route would not have any effect.\n\nWhen writing a `redirect`, you can omit the `component` option because it is never directly reached so there is no component to render. The only exception are [nested routes](nested-routes): if a route record has `children` and a `redirect` property, it should also have a `component` property.\n\n### Relative redirecting\n\nIt's also possible to redirect to a relative location:\n\n    const routes = [\n      {\n        // will always redirect /users/123/posts to /users/123/profile\n        path: '/users/:id/posts',\n        redirect: to => {\n          // the function receives the target route as the argument\n          // a relative location doesn't start with `/`\n          // or { path: 'profile'}\n          return 'profile'\n        },\n      },\n    ]\n\n## Alias\n\nA redirect means when the user visits `/home`, the URL will be replaced by `/`, and then matched as `/`. But what is an alias?\n\n**An alias of `/` as `/home` means when the user visits `/home`, the URL remains `/home`, but it will be matched as if the user is visiting `/`.**\n\nThe above can be expressed in the route configuration as:\n\n    const routes = [{ path: '/', component: Homepage, alias: '/home' }]\n\nAn alias gives you the freedom to map a UI structure to an arbitrary URL, instead of being constrained by the configuration's nesting structure. Make the alias start with a `/` to make the path absolute in nested routes. You can even combine both and provide multiple aliases with an array:\n\n    const routes = [\n      {\n        path: '/users',\n        component: UsersLayout,\n        children: [\n          // this will render the UserList for these 3 URLs\n          // - /users\n          // - /users/list\n          // - /people\n          { path: '', component: UserList, alias: ['/people', 'list'] },\n        ],\n      },\n    ]\n\nIf your route has parameters, make sure to include them in any absolute alias:\n\n    const routes = [\n      {\n        path: '/users/:id',\n        component: UsersByIdLayout,\n        children: [\n          // this will render the UserDetails for these 3 URLs\n          // - /users/24\n          // - /users/24/profile\n          // - /24\n          { path: 'profile', component: UserDetails, alias: ['/:id', ''] },\n        ],\n      },\n    ]\n\n**Note about SEO**: when using aliases, make sure to [define canonical links](https://support.google.com/webmasters/answer/139066?hl=en).\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/essentials/redirect-and-alias.md)\n\n[Named Views](named-views)\n\n[Passing Props to Route Components](passing-props)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/essentials/redirect-and-alias](https://next.router.vuejs.org/guide/essentials/redirect-and-alias)"
- name: redirectedFrom
  id: api/index#redirectedfrom
  summary: Route location we were initially trying to access before ending up on the current location when a redirect option was found or a navigation guard called next() with a route location
  belongs_to: API Reference
  description: |-
    ### redirectedFrom

    - **Type**: [`RouteLocation`](#routelocation)

    - **Details**:

      Route location we were initially trying to access before ending up on the current location when a `redirect` option was found or a navigation guard called `next()` with a route location. `undefined` if there was no redirection.

    ## NavigationFailure
- name: removeRoute
  id: api/index#removeroute
  summary: Remove an existing route by its name
  belongs_to: API Reference
  description: "### removeRoute\n\nRemove an existing route by its name.\n\n**Signature:**\n\n                  removeRoute(name:string|symbol):void\n                \n\n*Parameters*\n\n| Parameter | Type              | Description                 |\n|-----------|-------------------|-----------------------------|\n| name      | `string | symbol` | Name of the route to remove |"
- name: replace
  id: api/index#replace
  summary: Setting replace prop will call router.replace() instead of router.push() when clicked, so the navigation will not leave a history record
  belongs_to: API Reference
  description: "### replace\n\n- **Type**: `boolean`\n\n- **Default**: `false`\n\n- **Details**:\n\n  Setting `replace` prop will call `router.replace()` instead of `router.push()` when clicked, so the navigation will not leave a history record.\n\n                  \n                    \n                      <router-link\n                      to\n                      =\"/abc\"\n                      replace\n                      >\n                    \n                    \n                      </router-link\n                      >"
- name: replace
  id: api/index#replace-1
  summary: Programmatically navigate to a new URL by replacing the current entry in the history stack
  belongs_to: API Reference
  description: "### replace\n\nProgrammatically navigate to a new URL by replacing the current entry in the history stack.\n\n**Signature:**\n\n                  replace(to: RouteLocationRaw): Promise<NavigationFailure | void | undefined>\n\n                \n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Route location to navigate to |"
- name: resolve
  id: api/index#resolve
  summary: Returns the normalized version of a route location
  belongs_to: API Reference
  description: "### resolve\n\nReturns the [normalized version](#routelocation) of a [route location](#routelocationraw). Also includes an `href` property that includes any existing `base`.\n\n**Signature:**\n\n                  resolve(to: RouteLocationRaw): RouteLocation & {\n      href: string\n    }\n\n                \n\n*Parameters*\n\n| Parameter | Type                                    | Description                   |\n|-----------|-----------------------------------------|-------------------------------|\n| to        | [`RouteLocationRaw`](#routelocationraw) | Raw route location to resolve |\n\n## RouterOptions"
- name: Returns
  id: api/index#returns
  summary: Enumeration with all possible types for navigation failures
  belongs_to: API Reference
  description: |-
    ### Returns

    A history object that can be passed to the router constructor

    ## NavigationFailureType

    Enumeration with all possible types for navigation failures. Can be passed to [isNavigationFailure](#isnavigationfailure) to check for specific failures. **Never use any of the numerical values**, always use the variables like `NavigationFailureType.aborted`.

    **Signature:**

                      exportdeclareenum NavigationFailureType
- name: route
  id: api/index#route
  summary: A route location that has all of its component resolved (if any was lazy loaded) so it can be displayed
  belongs_to: API Reference
  description: "### route\n\n- **Type**: [`RouteLocationNormalized`](#routelocationnormalized)\n\n- **Details**:\n\n  A route location that has all of its component resolved (if any was lazy loaded) so it can be displayed.\n\n## `<router-view>`'s `v-slot`\n\n`<router-view>` exposes a `v-slot` API mainly to wrap your route components with `<transition>` and `<keep-alive>` components.\n\n                  <router-viewv-slot=\"{ Component, route }\"><transition:name=\"route.meta.transition || 'fade'\"mode=\"out-in\"><keep-alive><suspense><template#default><component:is=\"Component\":key=\"route.meta.usePathKey ? route.path : undefined\"/></template><template#fallback> Loading... </template>\n          </suspense>\n        </keep-alive>\n      </transition>\n    </router-view>\n\n                \n\n- `Component`: VNodes to be passed to a `<component>`'s `is` prop.\n- `route`: resolved normalized [route location](#routelocationnormalized).\n\n## createRouter\n\nCreates a Router instance that can be used by a Vue app. Check the [`RouterOptions`](#routeroptions) for a list of all the properties that can be passed.\n\n**Signature:**\n\n                  exportdeclarefunctioncreateRouter(options: RouterOptions): Router"
- name: Route Meta Fields
  id: guide/advanced/meta
  summary: Sometimes, you might want to attach arbitrary information to routes like transition names, who can access the route, etc
  description: "# Route Meta Fields\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/route-meta-fields?friend=vuerouter \"Learn how to use route meta fields\")\n\nSometimes, you might want to attach arbitrary information to routes like transition names, who can access the route, etc. This can be achieved through the `meta` property which accepts an object of properties and can be accessed on the route location and navigation guards. You can define `meta` properties like this:\n\n    const routes = [\n      {\n        path: '/posts',\n        component: PostsLayout,\n        children: [\n          {\n            path: 'new',\n            component: PostsNew,\n            // only authenticated users can create posts\n            meta: { requiresAuth: true }\n          },\n          {\n            path: ':id',\n            component: PostsDetail,\n            // anybody can read a post\n            meta: { requiresAuth: false }\n          }\n        ]\n      }\n    ]\n\nSo how do we access this `meta` field?\n\nFirst, each route object in the `routes` configuration is called a **route record**. Route records may be nested. Therefore when a route is matched, it can potentially match more than one route record.\n\nFor example, with the above route config, the URL `/posts/new` will match both the parent route record (`path: '/posts'`) and the child route record (`path: 'new'`).\n\nAll route records matched by a route are exposed on the `$route` object (and also route objects in navigation guards) as the `$route.matched` Array. We could loop through that array to check all `meta` fields, but Vue Router also provides you a `$route.meta` that is a non-recursive merge of **all `meta`** fields from parent to child. Meaning you can simply write\n\n    router.beforeEach((to, from) => {\n      // instead of having to check every route record with\n      // to.matched.some(record => record.meta.requiresAuth)\n      if (to.meta.requiresAuth && !auth.isLoggedIn()) {\n        // this route requires auth, check if logged in\n        // if not, redirect to login page.\n        return {\n          path: '/login',\n          // save the location we were at to come back later\n          query: { redirect: to.fullPath },\n        }\n      }\n    })\n\n## TypeScript\n\nIt is possible to type the meta field by extending the `RouteMeta` interface:\n\n    // typings.d.ts or router.ts\n    import 'vue-router'\n\n    declare module 'vue-router' {\n      interface RouteMeta {\n        // is optional\n        isAdmin?: boolean\n        // must be declared by every route\n        requiresAuth: boolean\n      }\n    }\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/advanced/meta.md)\n\n[Navigation guards](navigation-guards)\n\n[Data Fetching](data-fetching)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/advanced/meta](https://next.router.vuejs.org/guide/advanced/meta)"
- name: routes
  id: api/index#routes
  summary: Initial list of routes that should be added to the router
  belongs_to: API Reference
  description: |-
    ### routes

    Initial list of routes that should be added to the router.

    **Signature:**

                      routes: RouteRecordRaw[]
- name: Routes' Matching Syntax
  id: guide/essentials/route-matching-syntax
  summary: For the sake of simplicity, all route records are omitting the component property to focus on the path value
  description: "# Routes' Matching Syntax\n\nMost applications will use static routes like `/about` and dynamic routes like `/users/:userId` like we just saw in [Dynamic Route Matching](dynamic-matching), but Vue Router has much more to offer!\n\n**TIP**\n\nFor the sake of simplicity, all route records **are omitting the `component` property** to focus on the `path` value.\n\n## Custom Regexp in params\n\nWhen defining a param like `:userId`, we internally use the following regexp `([^/]+)` (at least one character that isn't a slash `/`) to extract params from URLs. This works well unless you need to differentiate two routes based on the param content. Imagine two routes `/:orderId` and `/:productName`, both would match the exact same URLs, so we need a way to differentiate them. The easiest way would be to add a static section to the path that differentiates them:\n\n    const routes = [\n      // matches /o/3549\n      { path: '/o/:orderId' },\n      // matches /p/books\n      { path: '/p/:productName' },\n    ]\n\nBut in some scenarios we don't want to add that static section `/o`/`p`. However, `orderId` is always a number while `productName` can be anything, so we can specify a custom regexp for a param in parentheses:\n\n    const routes = [\n      // /:orderId -> matches only numbers\n      { path: '/:orderId(\\\\d+)' },\n      // /:productName -> matches anything else\n      { path: '/:productName' },\n    ]\n\nNow, going to `/25` will match `/:orderId` while going to anything else will match `/:productName`. The order of the `routes` array doesn't even matter!\n\n**TIP**\n\nMake sure to **escape backslashes (`\\`)** like we did with `\\d` (becomes `\\\\d`) to actually pass the backslash character in a string in JavaScript.\n\n## Repeatable params\n\nIf you need to match routes with multiple sections like `/first/second/third`, you should mark a param as repeatable with `*` (0 or more) and `+` (1 or more):\n\n    const routes = [\n      // /:chapters -> matches /one, /one/two, /one/two/three, etc\n      { path: '/:chapters+' },\n      // /:chapters -> matches /, /one, /one/two, /one/two/three, etc\n      { path: '/:chapters*' },\n    ]\n\nThis will give you an array of params instead of a string and will also require you to pass an array when using named routes:\n\n    // given { path: '/:chapters*', name: 'chapters' },\n    router.resolve({ name: 'chapters', params: { chapters: [] } }).href\n    // produces /\n    router.resolve({ name: 'chapters', params: { chapters: ['a', 'b'] } }).href\n    // produces /a/b\n\n    // given { path: '/:chapters+', name: 'chapters' },\n    router.resolve({ name: 'chapters', params: { chapters: [] } }).href\n    // throws an Error because `chapters` is empty\n\nThese can also be combined with custom Regexp by adding them **after the closing parentheses**:\n\n    const routes = [\n      // only match numbers\n      // matches /1, /1/2, etc\n      { path: '/:chapters(\\\\d+)+' },\n      // matches /, /1, /1/2, etc\n      { path: '/:chapters(\\\\d+)*' },\n    ]\n\n## Optional parameters\n\nYou can also mark a parameter as optional by using the `?` modifier (0 or 1):\n\n    const routes = [\n      // will match /users and /users/posva\n      { path: '/users/:userId?' },\n      // will match /users and /users/42\n      { path: '/users/:userId(\\\\d+)?' },\n    ]\n\nNote that `*` technically also marks a parameter as optional but `?` parameters cannot be repeated.\n\n## Debugging\n\nIf you need to dig how your routes are transformed into Regexp to understand why a route isn't being matched or, to report a bug, you can use the [path ranker tool](https://paths.esm.dev/?p=AAMeJSyAwR4UbFDAFxAcAGAIJXMAAA..#). It supports sharing your routes through the URL.\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/essentials/route-matching-syntax.md)\n\n[Dynamic Route Matching](dynamic-matching)\n\n[Nested Routes](nested-routes)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/essentials/route-matching-syntax](https://next.router.vuejs.org/guide/essentials/route-matching-syntax)"
- name: Scroll Behavior
  id: guide/advanced/scroll-behavior
  summary: When using client-side routing, we may want to scroll to top when navigating to a new route, or preserve the scrolling position of history entries just like real page reload does
  description: "# Scroll Behavior\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/scroll-behavior?friend=vuerouter \"Learn how to customize scroll behavior\")\n\nWhen using client-side routing, we may want to scroll to top when navigating to a new route, or preserve the scrolling position of history entries just like real page reload does. Vue Router allows you to achieve these and even better, allows you to completely customize the scroll behavior on route navigation.\n\n**Note: this feature only works if the browser supports `history.pushState`.**\n\nWhen creating the router instance, you can provide the `scrollBehavior` function:\n\n    const router = createRouter({\n      history: createWebHashHistory(),\n      routes: [...],\n      scrollBehavior (to, from, savedPosition) {\n        // return desired position\n      }\n    })\n\nThe `scrollBehavior` function receives the `to` and `from` route objects, like [Navigation Guards](navigation-guards). The third argument, `savedPosition`, is only available if this is a `popstate` navigation (triggered by the browser's back/forward buttons).\n\nThe function can return a [`ScrollToOptions`](https://developer.mozilla.org/en-US/docs/Web/API/ScrollToOptions) position object:\n\n    const router = createRouter({\n      scrollBehavior(to, from, savedPosition) {\n        // always scroll to top\n        return { top: 0 }\n      },\n    })\n\nYou can also pass a CSS selector or a DOM element via `el`. In that scenario, `top` and `left` will be treated as relative offsets to that element.\n\n    const router = createRouter({\n      scrollBehavior(to, from, savedPosition) {\n        // always scroll 10px above the element #main\n        return {\n          // could also be\n          // el: document.getElementById('main'),\n          el: '#main',\n          top: -10,\n        }\n      },\n    })\n\nIf a falsy value or an empty object is returned, no scrolling will happen.\n\nReturning the `savedPosition` will result in a native-like behavior when navigating with back/forward buttons:\n\n    const router = createRouter({\n      scrollBehavior(to, from, savedPosition) {\n        if (savedPosition) {\n          return savedPosition\n        } else {\n          return { top: 0 }\n        }\n      },\n    })\n\nIf you want to simulate the \"scroll to anchor\" behavior:\n\n    const router = createRouter({\n      scrollBehavior(to, from, savedPosition) {\n        if (to.hash) {\n          return {\n            el: to.hash,\n          }\n        }\n      },\n    })\n\nIf your browser supports [scroll behavior](https://developer.mozilla.org/en-US/docs/Web/API/ScrollToOptions/behavior), you can make it smooth:\n\n    const router = createRouter({\n      scrollBehavior(to, from, savedPosition) {\n        if (to.hash) {\n          return {\n            el: to.hash,\n            behavior: 'smooth',\n          }\n        }\n      }\n    })\n\n## Delaying the scroll\n\nSometimes we need to wait a bit before scrolling in the page. For example, when dealing with transitions, we want to wait for the transition to finish before scrolling. To do this you can return a Promise that returns the desired position descriptor. Here is an example where we wait 500ms before scrolling:\n\n    const router = createRouter({\n      scrollBehavior(to, from, savedPosition) {\n        return new Promise((resolve, reject) => {\n          setTimeout(() => {\n            resolve({ left: 0, top: 0 })\n          }, 500)\n        })\n      },\n    })\n\nIt's possible to hook this up with events from a page-level transition component to make the scroll behavior play nicely with your page transitions, but due to the possible variance and complexity in use cases, we simply provide this primitive to enable specific userland implementations.\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/advanced/scroll-behavior.md)\n\n[Transitions](transitions)\n\n[Lazy Loading Routes](lazy-loading)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/advanced/scroll-behavior](https://next.router.vuejs.org/guide/advanced/scroll-behavior)"
- name: scrollBehavior
  id: api/index#scrollbehavior
  summary: Function to control scrolling when navigating between pages
  belongs_to: API Reference
  description: "### scrollBehavior\n\nFunction to control scrolling when navigating between pages. Can return a Promise to delay when the scrolling happens. See [Scroll Behaviour](../guide/advanced/scroll-behavior) for more details.\n\n**Signature:**\n\n                  scrollBehavior?: RouterScrollBehavior\n\n                \n\n#### Examples\n\n                  \n                    function\n                    scrollBehavior\n                    (\n                    to, from, savedPosition\n                    )\n                    {\n                    // `to` and `from` are both route locations\n                    // `savedPosition` can be null if there isn't one\n                    }"
- name: stringifyQuery
  id: api/index#stringifyquery
  summary: Custom implementation to stringify a query object
  belongs_to: API Reference
  description: "### stringifyQuery\n\nCustom implementation to stringify a query object. Should not prepend a leading `?`. Should properly encode query keys and values. [parseQuery](#parsequery) counterpart to handle query parsing.\n\n**Signature:**\n\n                  stringifyQuery?: (\n      query: Record<\n        string | number,\n        string | number | null | undefined | (string | number | null | undefined)[]\n      >\n    ) => string\n\n                \n\n## RouteRecordRaw\n\nRoute record that can be provided by the user when adding routes via the [`routes` option](#routeroptions) or via [`router.addRoute()`](#addroute-2). There are three different kind of route records:\n\n- Single views records: have a `component` option\n- Multiple views records ([named views](../guide/essentials/named-views)): have a `components` option\n- Redirect records: cannot have `component` or `components` option because a redirect record is never reached.\n\n&nbsp;"
- name: to
  id: api/index#to-1
  summary: null
  belongs_to: API Reference
  description: |-
    ### to

    - **Type**: [`RouteLocationNormalized`](#routelocationnormalized)

    - **Details**:

      Route location we were navigating to

    &nbsp;
- name: to
  id: api/index#to
  summary: Denotes the target route of the link
  belongs_to: API Reference
  description: |-
    ### to

    - **Type**: [`RouteLocationRaw`](#routelocationraw)

    - **Details**:

      Denotes the target route of the link. When clicked, the value of the `to` prop will be passed to `router.push()` internally, so it can either be a `string` or a [route location object](#routelocationraw).

                      <!-- literal string --><router-linkto="/home">Home</router-link><!-- renders to --><ahref="/home">Home</a><!-- javascript expression using `v-bind` --><router-link:to="'/home'">Home</router-link><!-- same as above --><router-link:to="{ path: '/home' }">Home</router-link><!-- named route --><router-link:to="{ name: 'user', params: { userId: '123' }}">User</router-link><!-- with query, resulting in `/register?plan=private` --><router-link:to="{ path: '/register', query: { plan: 'private' }}">
          Register
        </router-link>
- name: Transitions
  id: guide/advanced/transitions
  summary: All transition APIs work the same here
  description: "# Transitions\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/route-transitions?friend=vuerouter \"Learn about route transitions\")\n\nIn order to use transitions on your route components and animate navigations, you need to use the [v-slot API](../../api/index#router-view-s-v-slot):\n\n    <router-view v-slot=\"{ Component }\">\n      <transition name=\"fade\">\n        <component :is=\"Component\" />\n      </transition>\n    </router-view>\n\n[All transition APIs](https://v3.vuejs.org/guide/transitions-enterleave.html) work the same here.\n\n## Per-Route Transition\n\nThe above usage will apply the same transition for all routes. If you want each route's component to have different transitions, you can instead combine [meta fields](meta) and a dynamic `name` on `<transition>`:\n\n    const routes = [\n      {\n        path: '/custom-transition',\n        component: PanelLeft,\n        meta: { transition: 'slide-left' },\n      },\n      {\n        path: '/other-transition',\n        component: PanelRight,\n        meta: { transition: 'slide-right' },\n      },\n    ]\n\n    <router-view v-slot=\"{ Component, route }\">\n      <!-- Use any custom transition and fallback to `fade` -->\n      <transition :name=\"route.meta.transition || 'fade'\">\n        <component :is=\"Component\" />\n      </transition>\n    </router-view>\n\n## Route-Based Dynamic Transition\n\nIt is also possible to determine the transition to use dynamically based on the relationship between the target route and current route. Using a very similar snippet to the one just before:\n\n    <!-- use a dynamic transition name -->\n    <router-view v-slot=\"{ Component, route }\">\n      <transition :name=\"route.meta.transitionName\">\n        <component :is=\"Component\" />\n      </transition>\n    </router-view>\n\nWe can add an [after navigation hook](navigation-guards#global-after-hooks) to dynamically add information to the `meta` field based on the depth of the route\n\n    router.afterEach((to, from) => {\n      const toDepth = to.path.split('/').length\n      const fromDepth = from.path.split('/').length\n      to.meta.transitionName = toDepth < fromDepth ? 'slide-right' : 'slide-left'\n    })\n\n## Forcing a transition between reused views\n\nVue might automatically reuse components that look alike, avoiding any transition. Fortunately, it is possible [to add a `key` attribute](https://v3.vuejs.org/api/special-attributes.html#key) to force transitions. This also allows you to trigger transitions while staying on the same route with different params:\n\n    <router-view v-slot=\"{ Component, route }\">\n      <transition name=\"fade\">\n        <component :is=\"Component\" :key=\"route.path\" />\n      </transition>\n    </router-view>\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/advanced/transitions.md)\n\n[Composition API](composition-api)\n\n[Scroll Behavior](scroll-behavior)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/advanced/transitions](https://next.router.vuejs.org/guide/advanced/transitions)"
- name: type
  id: api/index#type
  summary: Type of the navigation failure
  belongs_to: API Reference
  description: |-
    ### type

    - **Type**: [`NavigationFailureType`](#navigationfailuretype)

    - **Details**:

      Type of the navigation failure.

    - **See Also**: [Navigation Failures](../guide/advanced/navigation-failures)

    ## NavigationGuard

    - **Arguments**:

      - [`RouteLocationNormalized`](#routelocationnormalized) to - Route location we are navigating to
      - [`RouteLocationNormalized`](#routelocationnormalized) from - Route location we are navigating from
      - `Function` next (Optional) - Callback to validate the navigation

    - **Details**:

      Function that can be passed to control a router navigation. The `next` callback can be omitted if you return a value (or a Promise) instead, which is encouraged. Possible return values (and parameters for `next`) are:

      - `undefined | void | true`: validates the navigation
      - `false`: cancels the navigation
      - [`RouteLocationRaw`](#routelocationraw): redirects to a different location
      - `(vm: ComponentPublicInstance) => any`**only for `beforeRouteEnter`**: A callback to be executed once the navigation completes. Receives the route component instance as the parameter.

    - **See Also**: [Navigation Guards](../guide/advanced/navigation-guards)

    &nbsp;
- name: useLink
  id: api/index#uselink
  summary: Returns everything exposed by the v-slot API
  belongs_to: API Reference
  description: "### useLink\n\nReturns everything exposed by the [`v-slot` API](#router-link-s-v-slot).\n\n**Signature:**\n\n                  exportdeclarefunctionuseLink(props: RouterLinkOptions): {\n      route: ComputedRef<RouteLocationNormalized & { href: string }>,\n      href: ComputedRef<string>,\n      isActive: ComputedRef<boolean>,\n      isExactActive: ComputedRef<boolean>,\n      navigate: (event?: MouseEvent) => Promise(NavigationFailure | void),\n    }\n\n                \n\n#### Parameters\n\n| Parameter | Type                | Description                                                                           |\n|-----------|---------------------|---------------------------------------------------------------------------------------|\n| props     | `RouterLinkOptions` | props object that can be passed to `<router-link>`. Accepts `Ref`s and `ComputedRef`s |"
- name: useRoute
  id: api/index#useroute
  summary: Returns the current route location
  belongs_to: API Reference
  description: |-
    ### useRoute

    Returns the current route location. Equivalent to using `$route` inside templates. Must be called inside of `setup()`.

    **Signature:**

                      exportdeclarefunctionuseRoute(): RouteLocationNormalized
- name: useRouter
  id: api/index#userouter
  summary: Returns the router instance
  belongs_to: API Reference
  description: "### useRouter\n\nReturns the [router](#router-properties) instance. Equivalent to using `$router` inside templates. Must be called inside of `setup()`.\n\n**Signature:**\n\n                  exportdeclarefunctionuseRouter(): Router\n\n                \n\n## TypeScript\n\nHere are some of the interfaces and types used by Vue Router. The documentation references them to give you an idea of the existing properties in objects.\n\n## Router Properties"
- name: Vue Router and the Composition API
  id: guide/advanced/composition-api
  summary: The introduction of setup and Vue's Composition API, open up new possibilities but to be able to get the full potential out of Vue Router, we will need to use a few new functions to replace access to this and in-component navigation guards
  description: "# Vue Router and the Composition API\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/router-and-the-composition-api?friend=vuerouter \"Learn how to use Vue Router with the composition API\")\n\nThe introduction of `setup` and Vue's [Composition API](https://v3.vuejs.org/guide/composition-api-introduction.html), open up new possibilities but to be able to get the full potential out of Vue Router, we will need to use a few new functions to replace access to `this` and in-component navigation guards.\n\n## Accessing the Router and current Route inside `setup`\n\nBecause we don't have access to `this` inside of `setup`, we cannot directly access `this.$router` or `this.$route` anymore. Instead we use the `useRouter` function:\n\n    import { useRouter, useRoute } from 'vue-router'\n\n    export default {\n      setup() {\n        const router = useRouter()\n        const route = useRoute()\n\n        function pushWithQuery(query) {\n          router.push({\n            name: 'search',\n            query: {\n              ...route.query,\n            },\n          })\n        }\n      },\n    }\n\nThe `route` object is a reactive object, so any of its properties can be watched and you should **avoid watching the whole `route`** object. In most scenarios, you should directly watch the param you are expecting to change\n\n    import { useRoute } from 'vue-router'\n    import { ref, watch } from 'vue'\n\n    export default {\n      setup() {\n        const route = useRoute()\n        const userData = ref()\n\n        // fetch the user information when params change\n        watch(\n          () => route.params.id,\n          async newId => {\n            userData.value = await fetchUser(newId)\n          }\n        )\n      },\n    }\n\nNote we still have access to `$router` and `$route` in templates, so there is no need to return `router` or `route` inside of `setup`.\n\n## Navigation Guards\n\nWhile you can still use in-component navigation guards with a `setup` function, Vue Router exposes update and leave guards as Composition API functions:\n\n    import { onBeforeRouteLeave, onBeforeRouteUpdate } from 'vue-router'\n    import { ref } from 'vue'\n\n    export default {\n      setup() {\n        // same as beforeRouteLeave option with no access to `this`\n        onBeforeRouteLeave((to, from) => {\n          const answer = window.confirm(\n            'Do you really want to leave? you have unsaved changes!'\n          )\n          // cancel the navigation and stay on the same page\n          if (!answer) return false\n        })\n\n        const userData = ref()\n\n        // same as beforeRouteUpdate option with no access to `this`\n        onBeforeRouteUpdate(async (to, from) => {\n          // only fetch the user if the id changed as maybe only the query or the hash changed\n          if (to.params.id !== from.params.id) {\n            userData.value = await fetchUser(to.params.id)\n          }\n        })\n      },\n    }\n\nComposition API guards can also be used in any component rendered by `<router-view>`, they don't have to be used directly on the route component like in-component guards.\n\n## `useLink`\n\nVue Router exposes the internal behavior of RouterLink as a Composition API function. It gives access the same properties as the [`v-slot` API](../../api/index#router-link-s-v-slot):\n\n    import { RouterLink, useLink } from 'vue-router'\n    import { computed } from 'vue'\n\n    export default {\n      name: 'AppLink',\n\n      props: {\n        // add @ts-ignore if using TypeScript\n        ...RouterLink.props,\n        inactiveClass: String,\n      },\n\n      setup(props) {\n        const { route, href, isActive, isExactActive, navigate } = useLink(props)\n\n        const isExternalLink = computed(\n          () => typeof props.to === 'string' && props.to.startsWith('http')\n        )\n\n        return { isExternalLink, href, navigate, isActive }\n      },\n    }\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/advanced/composition-api.md)\n\n[Data Fetching](data-fetching)\n\n[Transitions](transitions)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/advanced/composition-api](https://next.router.vuejs.org/guide/advanced/composition-api)"
- name: Waiting for the result of a Navigation
  id: guide/advanced/navigation-failures
  summary: When using router-link, Vue Router calls router.push to trigger a navigation
  description: "# Waiting for the result of a Navigation\n\nWhen using `router-link`, Vue Router calls `router.push` to trigger a navigation. While the expected behavior for most links is to navigate a user to a new page, there are a few situations where users will remain on the same page:\n\n- Users are already on the page that they are trying to navigate to.\n- A [navigation guard](navigation-guards) aborts the navigation by doing `return false`.\n- A new navigation guard takes place while the previous one not finished.\n- A [navigation guard](navigation-guards) redirects somewhere else by returning a new location (e.g. `return '/login'`).\n- A [navigation guard](navigation-guards) throws an `Error`.\n\nIf we want to do something after a navigation is finished, we need a way to wait after calling `router.push`. Imagine we have a mobile menu that allows us to go to different pages and we only want to hide the menu once we have navigated to the new page, we might want to do something like this:\n\n    router.push('/my-profile')\n    this.isMenuOpen = false\n\nBut this will close the menu right away because **navigations are asynchronous**, we need to `await` the promise returned by `router.push`:\n\n    await router.push('/my-profile')\n    this.isMenuOpen = false\n\nNow the menu will close once the navigation is finished but it will also close if the navigation was prevented. We need a way to detect if we actually changed the page we are on or not.\n\n## Detecting Navigation Failures\n\nIf a navigation is prevented, resulting in the user staying on the same page, the resolved value of the `Promise` returned by `router.push` will be a *Navigation Failure*. Otherwise, it will be a *falsy* value (usually `undefined`). This allows us to differentiate the case where we navigated away from where we are or not:\n\n    const navigationResult = await router.push('/my-profile')\n\n    if (navigationResult) {\n      // navigation prevented\n    } else {\n      // navigation succeeded (this includes the case of a redirection)\n      this.isMenuOpen = false\n    }\n\n*Navigation Failures* are `Error` instances with a few extra properties that gives us enough information to know what navigation was prevented and why. To check the nature of a navigation result, use the `isNavigationFailure` function:\n\n    import { NavigationFailureType, isNavigationFailure } from 'vue-router'\n\n    // trying to leave the editing page of an article without saving\n    const failure = await router.push('/articles/2')\n\n    if (isNavigationFailure(failure, NavigationFailureType.aborted)) {\n      // show a small notification to the user\n      showToast('You have unsaved changes, discard and leave anyway?')\n    }\n\n**TIP**\n\nIf you omit the second parameter: `isNavigationFailure(failure)`, it will only check if `failure` is a *Navigation Failure*.\n\n## Differentiating Navigation Failures\n\nAs we said at the beginning, there are different situations aborting a navigation, all of them resulting in different *Navigation Failures*. They can be differentiated using the `isNavigationFailure` and `NavigationFailureType`. There are three different types:\n\n- `aborted`: `false` was returned inside of a navigation guard to the navigation.\n- `cancelled`: A new navigation took place before the current navigation could finish. e.g. `router.push` was called while waiting inside of a navigation guard.\n- `duplicated`: The navigation was prevented because we are already at the target location.\n\n## *Navigation Failures*'s properties\n\nAll navigation failures expose `to` and `from` properties to reflect the current location as well as the target location for the navigation that failed:\n\n    // trying to access the admin page\n    router.push('/admin').then(failure => {\n      if (isNavigationFailure(failure, NavigationFailureType.redirected)) {\n        failure.to.path // '/admin'\n        failure.from.path // '/'\n      }\n    })\n\nIn all cases, `to` and `from` are normalized route locations.\n\n## Detecting Redirections\n\nWhen returning a new location inside of a Navigation Guard, we are triggering a new navigation that overrides the ongoing one. Differently from other return values, a redirection doesn't prevent a navigation, **it creates a new one**. It is therefore checked differently, by reading the `redirectedFrom` property in a Route Location:\n\n    await router.push('/my-profile')\n    if (router.currentRoute.value.redirectedFrom) {\n      // redirectedFrom is resolved route location like to and from in navigation\n      // guards\n    }\n\n[Suggest changes to this page](https://github.com/vuejs/vue-router-next/edit/master/docs/guide/advanced/navigation-failures.md)\n\n[Extending RouterLink](extending-router-link)\n\n[Dynamic Routing](dynamic-routing)\n\n© 2013–present Evan You  \nLicensed under the MIT License.  \n[https://next.router.vuejs.org/guide/advanced/navigation-failures](https://next.router.vuejs.org/guide/advanced/navigation-failures)"
