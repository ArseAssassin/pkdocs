---
name: Less
slug: less~4
text_format: markdown
generator: src:devdocs
version: '4'
copyright: |-
  © 2009–2020 The Core Less Team
  Licensed under the Creative Commons Attribution License 3.0.
  http://lesscss.org/features
homepage: http://lesscss.org/
generator_command: doc src:devdocs use less~4

---
- name: '% format'
  id: functions#string-functions--format
  summary: The function %(string, arguments ...) formats a string
  belongs_to: Logical Functions
  description: |-
    ### % format

    The function `%(string, arguments ...)` formats a string.

    The first argument is string with placeholders. All placeholders start with percentage symbol `%` followed by letter `s`,`S`,`d`,`D`,`a`, or `A`. Remaining arguments contain expressions to replace placeholders. If you need to print the percentage symbol, escape it by another percentage `%%`.

    Use uppercase placeholders if you need to escape special characters into their utf-8 escape codes. The function escapes all special characters except `()'~!`. Space is encoded as `%20`. Lowercase placeholders leave special characters as they are.

    Placeholders:

    - `d`, `D`, `a`, `A` - can be replaced by any kind of argument (color, number, escaped value, expression, ...). If you use them in combination with string, the whole string will be used - including its quotes. However, the quotes are placed into the string as they are, they are not escaped by "/" nor anything similar.
    - `s`, `S` - can be replaced by any expression. If you use it with string, only the string value is used - quotes are omitted.

    Parameters:

    - `string`: format string with placeholders,
    - `anything`\* : values to replace placeholders.

    Returns: formatted `string`.

    Example:

        format-a-d: %("repetitions: %a file: %d", 1 + 2, "directory/file.less");
        format-a-d-upper: %('repetitions: %A file: %D', 1 + 2, "directory/file.less");
        format-s: %("repetitions: %s file: %s", 1 + 2, "directory/file.less");
        format-s-upper: %('repetitions: %S file: %S', 1 + 2, "directory/file.less");

    Output:

        format-a-d: "repetitions: 3 file: "directory/file.less"";
        format-a-d-upper: "repetitions: 3 file: %22directory%2Ffile.less%22";
        format-s: "repetitions: 3 file: directory/file.less";
        format-s-upper: "repetitions: 3 file: directory%2Ffile.less";
- name: .loop()
  id: index#loops-feature
  summary: An in-depth guide to features of the LESS language
  description: "# Less\n\n## Overview\n\nAn in-depth guide to features of the LESS language. See the [Overview](http://lesscss.org/#overview) for a quick summary of Less.\n\n*For an in-depth guide to installing and setting up a Less environment, as well as documentation on developing for Less, see: [Using Less.js](usage).*\n\n## Variables\n\nControl commonly used values in a single location.\n\n### Overview\n\nIt's not uncommon to see the same value repeated dozens *if not hundreds of times* across your stylesheets:\n\n    a,\n    .link {\n      color: #428bca;\n    }\n    .widget {\n      color: #fff;\n      background: #428bca;\n    }\n\nVariables make your code easier to maintain by giving you a way to control those values from a single location:\n\n    // Variables\n    @link-color:        #428bca; // sea blue\n    @link-color-hover:  darken(@link-color, 10%);\n\n    // Usage\n    a,\n    .link {\n      color: @link-color;\n    }\n    a:hover {\n      color: @link-color-hover;\n    }\n    .widget {\n      color: #fff;\n      background: @link-color;\n    }\n\n### Variable Interpolation\n\nThe examples above focused on using variables to control *values in CSS rules*, but they can also be used in other places as well, such as selector names, property names, URLs and `@import` statements.\n\n### Selectors\n\n*v1.4.0*\n\n    // Variables\n    @my-selector: banner;\n\n    // Usage\n    .@{my-selector} {\n      font-weight: bold;\n      line-height: 40px;\n      margin: 0 auto;\n    }\n\nCompiles to:\n\n    .banner {\n      font-weight: bold;\n      line-height: 40px;\n      margin: 0 auto;\n    }\n\n### URLs\n\n    // Variables\n    @images: \"../img\";\n\n    // Usage\n    body {\n      color: #444;\n      background: url(\"@{images}/white-sand.png\");\n    }\n\n### Import Statements\n\n*v1.4.0*\n\nSyntax: `@import \"@{themes}/tidal-wave.less\";`\n\nNote that before v2.0.0, only variables which have been declared in the root or current scope were considered and that only the current file and calling files were considered when looking for a variable.\n\nExample:\n\n    // Variables\n    @themes: \"../../src/themes\";\n\n    // Usage\n    @import \"@{themes}/tidal-wave.less\";\n\n### Properties\n\n*v1.6.0*\n\n    @property: color;\n\n    .widget {\n      @{property}: #0ee;\n      background-@{property}: #999;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #0ee;\n      background-color: #999;\n    }\n\n### Variable Variables\n\nIn Less, you can define a variable's name using another variable.\n\n    @primary:  green;\n    @secondary: blue;\n\n    .section {\n      @color: primary;\n\n      .element {\n        color: @@color;\n      }\n    }\n\nWhich compiles to:\n\n    .section .element {\n      color: green;\n    }\n\n### Lazy Evaluation\n\nVariables do not have to be declared before being used.\n\nValid Less snippet:\n\n    .lazy-eval {\n      width: @var;\n    }\n\n    @var: @a;\n    @a: 9%;\n\nthis is valid Less too:\n\n    .lazy-eval {\n      width: @var;\n      @a: 9%;\n    }\n\n    @var: @a;\n    @a: 100%;\n\nboth compile into:\n\n    .lazy-eval {\n      width: 9%;\n    }\n\nWhen defining a variable twice, the last definition of the variable is used, searching from the current scope upwards. This is similar to css itself where the last property inside a definition is used to determine the value.\n\nFor instance:\n\n    @var: 0;\n    .class {\n      @var: 1;\n      .brass {\n        @var: 2;\n        three: @var;\n        @var: 3;\n      }\n      one: @var;\n    }\n\nCompiles to:\n\n    .class {\n      one: 1;\n    }\n    .class .brass {\n      three: 3;\n    }\n\nEssentially, each scope has a \"final\" value, similar to properties in the browser, like this example using custom properties:\n\n    .header {\n      --color: white;\n      color: var(--color);  // the color is black\n      --color: black;\n    }\n\nThis means that, unlike other CSS pre-processing languages, Less variables behave very much like CSS's.\n\n### Properties as Variables **(NEW!)**\n\n*v3.0.0*\n\nYou can easily treat properties like variables using the `$prop` syntax. Sometimes this can make your code a little lighter.\n\n    .widget {\n      color: #efefef;\n      background-color: $color;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #efefef;\n      background-color: #efefef;\n    }\n\nNote that, like variables, Less will choose the last property within the current/parent scope as being the \"final\" value.\n\n    .block {\n      color: red; \n      .inner {\n        background-color: $color; \n      }\n      color: blue;  \n    } \n\nCompiles to:\n\n    .block {\n      color: red; \n      color: blue;  \n    } \n    .block .inner {\n      background-color: blue; \n    }\n\n### Default Variables\n\nWe sometimes get requests for default variables - an ability to set a variable only if it is not already set. This feature is not required because you can easily override a variable by putting the definition afterwards.\n\nFor instance:\n\n    // library\n    @base-color: green;\n    @dark-color: darken(@base-color, 10%);\n\n    // use of library\n    @import \"library.less\";\n    @base-color: red;\n\nThis works fine because of [Lazy Loading](#variables-feature-lazy-loading) - `@base-color` is overridden and `@dark-color` is a dark red.\n\n## Parent Selectors\n\nReferencing parent selectors with `&`\n\nThe `&` operator represents the parent selectors of a [nested rule](#features-overview-feature-nested-rules) and is most commonly used when applying a modifying class or pseudo-class to an existing selector:\n\n    a {\n      color: blue;\n      &:hover {\n        color: green;\n      }\n    }\n\nresults in:\n\n    a {\n      color: blue;\n    }\n\n    a:hover {\n      color: green;\n    }\n\nNotice that without the `&`, the above example would result in `a :hover` rule (a descendant selector that matches hovered elements inside of `<a>` tags) and this is not what we typically would want with the nested `:hover`.\n\nThe \"parent selectors\" operator has a variety of uses. Basically any time you need the selectors of the nested rules to be combined in other ways than the default. For example another typical use of the `&` is to produce repetitive class names:\n\n    .button {\n      &-ok {\n        background-image: url(\"ok.png\");\n      }\n      &-cancel {\n        background-image: url(\"cancel.png\");\n      }\n\n      &-custom {\n        background-image: url(\"custom.png\");\n      }\n    }\n\noutput:\n\n    .button-ok {\n      background-image: url(\"ok.png\");\n    }\n    .button-cancel {\n      background-image: url(\"cancel.png\");\n    }\n    .button-custom {\n      background-image: url(\"custom.png\");\n    }\n\n### Multiple `&`\n\n`&` may appear more than once within a selector. This makes it possible to repeatedly refer to a parent selector without repeating its name.\n\n    .link {\n      & + & {\n        color: red;\n      }\n\n      & & {\n        color: green;\n      }\n\n      && {\n        color: blue;\n      }\n\n      &, &ish {\n        color: cyan;\n      }\n    }\n\nwill output:\n\n    .link + .link {\n      color: red;\n    }\n    .link .link {\n      color: green;\n    }\n    .link.link {\n      color: blue;\n    }\n    .link, .linkish {\n      color: cyan;\n    }\n\nNote that `&` represents all parent selectors (not just the nearest ancestor) so the following example:\n\n    .grand {\n      .parent {\n        & > & {\n          color: red;\n        }\n\n        & & {\n          color: green;\n        }\n\n        && {\n          color: blue;\n        }\n\n        &, &ish {\n          color: cyan;\n        }\n      }\n    }\n\nresults in:\n\n    .grand .parent > .grand .parent {\n      color: red;\n    }\n    .grand .parent .grand .parent {\n      color: green;\n    }\n    .grand .parent.grand .parent {\n      color: blue;\n    }\n    .grand .parent,\n    .grand .parentish {\n      color: cyan;\n    }\n\n### Changing Selector Order\n\nIt can be useful to prepend a selector to the inherited (parent) selectors. This can be done by putting the `&` after current selector. For example, when using Modernizr, you might want to specify different rules based on supported features:\n\n    .header {\n      .menu {\n        border-radius: 5px;\n        .no-borderradius & {\n          background-image: url('images/button-background.png');\n        }\n      }\n    }\n\nThe selector `.no-borderradius &` will prepend `.no-borderradius` to its parent `.header .menu` to form the`.no-borderradius .header .menu` on output:\n\n    .header .menu {\n      border-radius: 5px;\n    }\n    .no-borderradius .header .menu {\n      background-image: url('images/button-background.png');\n    }\n\n### Combinatorial Explosion\n\n`&` can also be used to generate every possible permutation of selectors in a comma separated list:\n\n    p, a, ul, li {\n      border-top: 2px dotted #366;\n      & + & {\n        border-top: 0;\n      }\n    }\n\nThis expands to all possible (16) combinations of the specified elements:\n\n    p,\n    a,\n    ul,\n    li {\n      border-top: 2px dotted #366;\n    }\n    p + p,\n    p + a,\n    p + ul,\n    p + li,\n    a + p,\n    a + a,\n    a + ul,\n    a + li,\n    ul + p,\n    ul + a,\n    ul + ul,\n    ul + li,\n    li + p,\n    li + a,\n    li + ul,\n    li + li {\n      border-top: 0;\n    }\n\n## Extend\n\nExtend is a Less pseudo-class which merges the selector it is put on with ones that match what it references.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\n    nav ul {\n      &:extend(.inline);\n      background: blue;\n    }\n\nIn the rule set above, the `:extend` selector will apply the \"extending selector\" (`nav ul`) onto the `.inline` class *wherever the `.inline` class appears*. The declaration block will be kept as-is, but without any reference to the extend (because extend isn't css).\n\nSo the following:\n\n    nav ul {\n      &:extend(.inline);\n      background: blue;\n    }\n    .inline {\n      color: red;\n    }\n\nOutputs\n\n    nav ul {\n      background: blue;\n    }\n    .inline,\n    nav ul {\n      color: red;\n    }\n\nNotice how the `nav ul:extend(.inline)` selector gets output as `nav ul` - the extend gets removed before output and the selector block left as-is. If no properties are put in that block then it gets removed from the output (but the extend still may affect other selectors).\n\n### Extend Syntax\n\nThe extend is either attached to a selector or placed into a ruleset. It looks like a pseudo-class with selector parameter optionally followed by the keyword `all`:\n\nExample:\n\n    .a:extend(.b) {}\n\n    // the above block does the same thing as the below block\n    .a {\n      &:extend(.b);\n    }\n\n    .c:extend(.d all) {\n      // extends all instances of \".d\" e.g. \".x.d\" or \".d.x\"\n    }\n    .c:extend(.d) {\n      // extends only instances where the selector will be output as just \".d\"\n    }\n\nIt can contain one or more classes to extend, separated by commas.\n\nExample:\n\n    .e:extend(.f) {}\n    .e:extend(.g) {}\n\n    // the above and the below do the same thing\n    .e:extend(.f, .g) {}\n\n### Extend Attached to Selector\n\nExtend attached to a selector looks like an ordinary pseudo-class with selector as a parameter. A selector can contain multiple extend clauses, but all extends must be at the end of the selector.\n\n- Extend after the selector: `pre:hover:extend(div pre)`.\n- Space between selector and extend is allowed: `pre:hover :extend(div pre)`.\n- Multiple extends are allowed: `pre:hover:extend(div pre):extend(.bucket tr)` - Note this is the same as `pre:hover:extend(div pre, .bucket tr)`\n- This is NOT allowed: `pre:hover:extend(div pre).nth-child(odd)`. Extend must be last.\n\nIf a ruleset contains multiple selectors, any of them can have the extend keyword. Multiple selectors with extend in one ruleset:\n\n    .big-division,\n    .big-bag:extend(.bag),\n    .big-bucket:extend(.bucket) {\n      // body\n    }\n\n### Extend Inside Ruleset\n\nExtend can be placed into a ruleset's body using `&:extend(selector)` syntax. Placing extend into a body is a shortcut for placing it into every single selector of that ruleset.\n\nExtend inside a body:\n\n    pre:hover,\n    .some-class {\n      &:extend(div pre);\n    }\n\nis exactly the same as adding an extend after each selector:\n\n    pre:hover:extend(div pre),\n    .some-class:extend(div pre) {}\n\n### Extending Nested Selectors\n\nExtend is able to match nested selectors. Following less:\n\nExample:\n\n    .bucket {\n      tr { // nested ruleset with target selector\n        color: blue;\n      }\n    }\n    .some-class:extend(.bucket tr) {} // nested ruleset is recognized\n\nOutputs\n\n    .bucket tr,\n    .some-class {\n      color: blue;\n    }\n\nEssentially the extend looks at the compiled css, not the original less.\n\nExample:\n\n    .bucket {\n      tr & { // nested ruleset with target selector\n        color: blue;\n      }\n    }\n    .some-class:extend(tr .bucket) {} // nested ruleset is recognized\n\nOutputs\n\n    tr .bucket,\n    .some-class {\n      color: blue;\n    }\n\n### Exact Matching with Extend\n\nExtend by default looks for exact match between selectors. It does matter whether selector uses leading star or not. It does not matter that two nth-expressions have the same meaning, they need to have to same form in order to be matched. The only exception are quotes in attribute selector, less knows they have the same meaning and matches them.\n\nExample:\n\n    .a.class,\n    .class.a,\n    .class > .a {\n      color: blue;\n    }\n    .test:extend(.class) {} // this will NOT match the any selectors above\n\nLeading star does matter. Selectors `*.class` and `.class` are equivalent, but extend will not match them:\n\n    *.class {\n      color: blue;\n    }\n    .noStar:extend(.class) {} // this will NOT match the *.class selector\n\nOutputs\n\n    *.class {\n      color: blue;\n    }\n\nOrder of pseudo-classes does matter. Selectors `link:hover:visited` and `link:visited:hover` match the same set of elements, but extend treats them as different:\n\n    link:hover:visited {\n      color: blue;\n    }\n    .selector:extend(link:visited:hover) {}\n\nOutputs\n\n    link:hover:visited {\n      color: blue;\n    }\n\n### nth Expression\n\nNth expression form does matter. Nth-expressions `1n+3` and `n+3` are equivalent, but extend will not match them:\n\n    :nth-child(1n+3) {\n      color: blue;\n    }\n    .child:extend(:nth-child(n+3)) {}\n\nOutputs\n\n    :nth-child(1n+3) {\n      color: blue;\n    }\n\nQuote type in attribute selector does not matter. All of the following are equivalent.\n\n    [title=identifier] {\n      color: blue;\n    }\n    [title='identifier'] {\n      color: blue;\n    }\n    [title=\"identifier\"] {\n      color: blue;\n    }\n\n    .noQuote:extend([title=identifier]) {}\n    .singleQuote:extend([title='identifier']) {}\n    .doubleQuote:extend([title=\"identifier\"]) {}\n\nOutputs\n\n    [title=identifier],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n    [title='identifier'],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n    [title=\"identifier\"],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n### Extend \"all\"\n\nWhen you specify the all keyword last in an extend argument it tells Less to match that selector as part of another selector. The selector will be copied and the matched part of the selector only will then be replaced with the extend, making a new selector.\n\nExample:\n\n    .a.b.test,\n    .test.c {\n      color: orange;\n    }\n    .test {\n      &:hover {\n        color: green;\n      }\n    }\n\n    .replacement:extend(.test all) {}\n\nOutputs\n\n    .a.b.test,\n    .test.c,\n    .a.b.replacement,\n    .replacement.c {\n      color: orange;\n    }\n    .test:hover,\n    .replacement:hover {\n      color: green;\n    }\n\n*You can think of this mode of operation as essentially doing a non-destructive search and replace.*\n\n### Selector Interpolation with Extend\n\nExtend is **not** able to match selectors with variables. If selector contains variable, extend will ignore it.\n\nHowever, extend can be attached to interpolated selector.\n\nSelector with variable will not be matched:\n\n    @variable: .bucket;\n    @{variable} { // interpolated selector\n      color: blue;\n    }\n    .some-class:extend(.bucket) {} // does nothing, no match is found\n\nand extend with variable in target selector matches nothing:\n\n    .bucket {\n      color: blue;\n    }\n    .some-class:extend(@{variable}) {} // interpolated selector matches nothing\n    @variable: .bucket;\n\nBoth of the above examples compile into:\n\n    .bucket {\n      color: blue;\n    }\n\nHowever, `:extend` attached to an interpolated selector works:\n\n    .bucket {\n      color: blue;\n    }\n    @{variable}:extend(.bucket) {}\n    @variable: .selector;\n\ncompiles to:\n\n    .bucket, .selector {\n      color: blue;\n    }\n\n### Scoping / Extend Inside @media\n\nCurrently, an `:extend` inside a `@media` declaration will only match selectors inside the same media declaration:\n\n    @media print {\n      .screenClass:extend(.selector) {} // extend inside media\n      .selector { // this will be matched - it is in the same media\n        color: black;\n      }\n    }\n    .selector { // ruleset on top of style sheet - extend ignores it\n      color: red;\n    }\n    @media screen {\n      .selector {  // ruleset inside another media - extend ignores it\n        color: blue;\n      }\n    }\n\ncompiles into:\n\n    @media print {\n      .selector,\n      .screenClass { /*  ruleset inside the same media was extended */\n        color: black;\n      }\n    }\n    .selector { /* ruleset on top of style sheet was ignored */\n      color: red;\n    }\n    @media screen {\n      .selector { /* ruleset inside another media was ignored */\n        color: blue;\n      }\n    }\n\nNote: extending does not match selectors inside a nested `@media` declaration:\n\n    @media screen {\n      .screenClass:extend(.selector) {} // extend inside media\n      @media (min-width: 1023px) {\n        .selector {  // ruleset inside nested media - extend ignores it\n          color: blue;\n        }\n      }\n    }\n\nThis compiles into:\n\n    @media screen and (min-width: 1023px) {\n      .selector { /* ruleset inside another nested media was ignored */\n        color: blue;\n      }\n    }\n\nTop level extend matches everything including selectors inside nested media:\n\n    @media screen {\n      .selector {  /* ruleset inside nested media - top level extend works */\n        color: blue;\n      }\n      @media (min-width: 1023px) {\n        .selector {  /* ruleset inside nested media - top level extend works */\n          color: blue;\n        }\n      }\n    }\n\n    .topLevel:extend(.selector) {} /* top level extend matches everything */\n\ncompiles into:\n\n    @media screen {\n      .selector,\n      .topLevel { /* ruleset inside media was extended */\n        color: blue;\n      }\n    }\n    @media screen and (min-width: 1023px) {\n      .selector,\n      .topLevel { /* ruleset inside nested media was extended */\n        color: blue;\n      }\n    }\n\n### Duplication Detection\n\nCurrently there is no duplication detection.\n\nExample:\n\n    .alert-info,\n    .widget {\n      /* declarations */\n    }\n\n    .alert:extend(.alert-info, .widget) {}\n\nOutputs\n\n    .alert-info,\n    .widget,\n    .alert,\n    .alert {\n      /* declarations */\n    }\n\n### Use Cases for Extend\n\n### Classic Use Case\n\nThe classic use case is to avoid adding a base class. For example, if you have\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n\nand you want to have a subtype of animal which overrides the background color then you have two options, firstly change your HTML\n\n    <a class=\"animal bear\">Bear</a>\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n    .bear {\n      background-color: brown;\n    }\n\nor have simplified html and use extend in your less. e.g.\n\n    <a class=\"bear\">Bear</a>\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n    .bear {\n      &:extend(.animal);\n      background-color: brown;\n    }\n\n### Reducing CSS Size\n\nMixins copy all of the properties into a selector, which can lead to unnecessary duplication. Therefore you can use extends instead of mixins to move the selector up to the properties you wish to use, which leads to less CSS being generated.\n\nExample - with mixin:\n\n    .my-inline-block() {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing1 {\n      .my-inline-block;\n    }\n    .thing2 {\n      .my-inline-block;\n    }\n\nOutputs\n\n    .thing1 {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing2 {\n      display: inline-block;\n      font-size: 0;\n    }\n\nExample (with extends):\n\n    .my-inline-block {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing1 {\n      &:extend(.my-inline-block);\n    }\n    .thing2 {\n      &:extend(.my-inline-block);\n    }\n\nOutputs\n\n    .my-inline-block,\n    .thing1,\n    .thing2 {\n      display: inline-block;\n      font-size: 0;\n    }\n\n### Combining Styles / A More Advanced Mixin\n\nAnother use-case is as an alternative for a mixin - because mixins can only be used with simple selectors, if you have two different blocks of html, but need to apply the same styles to both you can use extends to relate two areas.\n\nExample:\n\n    li.list > a {\n      // list styles\n    }\n    button.list-style {\n      &:extend(li.list > a); // use the same list styles\n    }\n\n## Merge\n\nCombine properties\n\nThe `merge` feature allows for aggregating values from multiple properties into a comma or space separated list under a single property. `merge` is useful for properties such as background and transform.\n\n### Comma\n\nAppend property value with comma\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    .mixin() {\n      box-shadow+: inset 0 0 10px #555;\n    }\n    .myclass {\n      .mixin();\n      box-shadow+: 0 0 20px black;\n    }\n\nOutputs\n\n    .myclass {\n      box-shadow: inset 0 0 10px #555, 0 0 20px black;\n    }\n\n### Space\n\nAppend property value with space\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    .mixin() {\n      transform+_: scale(2);\n    }\n    .myclass {\n      .mixin();\n      transform+_: rotate(15deg);\n    }\n\nOutputs\n\n    .myclass {\n      transform: scale(2) rotate(15deg);\n    }\n\nTo avoid any unintentional joins, `merge` requires an explicit `+` or `+_` flag on each join pending declaration.\n\n## Mixins\n\n\"mix-in\" properties from existing styles\n\nYou can mix-in class selectors and id selectors, e.g.\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      .a();\n    }\n    .mixin-id {\n      #b();\n    }\n\nwhich results in:\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      color: red;\n    }\n    .mixin-id {\n      color: red;\n    }\n\nHistorically, the parentheses in a mixin call are optional, but optional parentheses are deprecated and will be required in a future release.\n\n    .a(); \n    .a;    // currently works, but deprecated; don't use\n    .a (); // white-space before parentheses is also deprecated\n\n### Mixins With Parentheses\n\nIf you want to create a mixin but you do not want that mixin to be in your CSS output, put parentheses after the mixin definition.\n\n    .my-mixin {\n      color: black;\n    }\n    .my-other-mixin() {\n      background: white;\n    }\n    .class {\n      .my-mixin();\n      .my-other-mixin();\n    }\n\noutputs\n\n    .my-mixin {\n      color: black;\n    }\n    .class {\n      color: black;\n      background: white;\n    }\n\n### Selectors in Mixins\n\nMixins can contain more than just properties, they can contain selectors too.\n\nFor example:\n\n    .my-hover-mixin() {\n      &:hover {\n        border: 1px solid red;\n      }\n    }\n    button {\n      .my-hover-mixin();\n    }\n\nOutputs\n\n    button:hover {\n      border: 1px solid red;\n    }\n\n### Namespaces\n\nIf you want to mixin properties inside a more complicated selector, you can stack up multiple ids or classes.\n\n    #outer() {\n      .inner {\n        color: red;\n      }\n    }\n\n    .c {\n      #outer.inner();\n    }\n\nNote: legacy Less syntax allows `>` and whitespace between namespaces and mixins. This syntax is deprecated and may be removed. Currently, these do the same thing.\n\n    #outer > .inner(); // deprecated\n    #outer .inner();   // deprecated\n    #outer.inner();    // preferred\n\nNamespacing your mixins like this reduces conflicts with other library mixins or user mixins, but can also be a way to \"organize\" groups of mixins.\n\nExample:\n\n    #my-library {\n      .my-mixin() {\n        color: black;\n      }\n    }\n    // which can be used like this\n    .class {\n      #my-library.my-mixin();\n    }\n\n### Guarded Namespaces\n\nIf a namespace has a guard, mixins defined by it are used only if the guard condition returns true. A namespace guard is evaluated exactly the same as a guard on a mixin, so the following two mixins work the same way:\n\n    #namespace when (@mode = huge) {\n      .mixin() { /* */ }\n    }\n\n    #namespace {\n      .mixin() when (@mode = huge) { /* */ }\n    }\n\nThe `default` function is assumed to have the same value for all nested namespaces and mixin. The following mixin is never evaluated; one of its guards is guaranteed to be false:\n\n    #sp_1 when (default()) {\n      #sp_2 when (default()) {\n        .mixin() when not(default()) { /* */ }\n      }\n    }\n\n### The `!important` keyword\n\nUse the `!important` keyword after mixin call to mark all properties inherited by it as `!important`:\n\nExample:\n\n    .foo (@bg: #f5f5f5; @color: #900) {\n      background: @bg;\n      color: @color;\n    }\n    .unimportant {\n      .foo();\n    }\n    .important {\n      .foo() !important;\n    }\n\nResults in:\n\n    .unimportant {\n      background: #f5f5f5;\n      color: #900;\n    }\n    .important {\n      background: #f5f5f5 !important;\n      color: #900 !important;\n    }\n\n### Parametric Mixins\n\nHow to pass arguments to mixins\n\nMixins can also take arguments, which are variables passed to the block of selectors when it is mixed in.\n\nFor example:\n\n    .border-radius(@radius) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nAnd here's how we can mix it into various rulesets:\n\n    #header {\n      .border-radius(4px);\n    }\n    .button {\n      .border-radius(6px);\n    }\n\nParametric mixins can also have default values for their parameters:\n\n    .border-radius(@radius: 5px) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nWe can invoke it like this now:\n\n    #header {\n      .border-radius();\n    }\n\nAnd it will include a 5px border-radius.\n\nYou can also use parametric mixins which don't take parameters. This is useful if you want to hide the ruleset from the CSS output, but want to include its properties in other rulesets:\n\n    .wrap() {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n    pre { .wrap() }\n\nWhich would output:\n\n    pre {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n### Parameter separators\n\nParameters are currently either *semicolon* or *comma* separated.\n\nOriginally, parameters were only separated by commas, but the semi-colon was later added to support passing comma-separated list values to single arguments.\n\n- two arguments and each contains comma separated list: `.name(1, 2, 3; something, else)`,\n- three arguments and each contains one number: `.name(1, 2, 3)`,\n- use dummy semicolon to create mixin call with one argument containing comma separated css list: `.name(1, 2, 3;)`,\n- comma separated default value: `.name(@param1: red, blue;)`.\n- As of Less 4.0, you can wrap a list value using a paren escape \\[`~()`\\], e.g. `.name(@param1: ~(red, blue))`. This is similar to the quote escape syntax: `~\"quote\"`\n\n### Overloading mixins\n\nIt is legal to define multiple mixins with the same name and number of parameters. Less will use properties of all that can apply. If you used the mixin with one parameter e.g. `.mixin(green);`, then properties of all mixins with exactly one mandatory parameter will be used:\n\n    .mixin(@color) {\n      color-1: @color;\n    }\n    .mixin(@color, @padding: 2) {\n      color-2: @color;\n      padding-2: @padding;\n    }\n    .mixin(@color, @padding, @margin: 2) {\n      color-3: @color;\n      padding-3: @padding;\n      margin: @margin @margin @margin @margin;\n    }\n    .some .selector div {\n      .mixin(#008000);\n    }\n\ncompiles into:\n\n    .some .selector div {\n      color-1: #008000;\n      color-2: #008000;\n      padding-2: 2;\n    }\n\n### Named Parameters\n\nA mixin reference can supply parameters values by their names instead of just positions. Any parameter can be referenced by its name and they do not have to be in any special order:\n\n    .mixin(@color: black; @margin: 10px; @padding: 20px) {\n      color: @color;\n      margin: @margin;\n      padding: @padding;\n    }\n    .class1 {\n      .mixin(@margin: 20px; @color: #33acfe);\n    }\n    .class2 {\n      .mixin(#efca44; @padding: 40px);\n    }\n\ncompiles into:\n\n    .class1 {\n      color: #33acfe;\n      margin: 20px;\n      padding: 20px;\n    }\n    .class2 {\n      color: #efca44;\n      margin: 10px;\n      padding: 40px;\n    }\n\n### The `@arguments` Variable\n\n`@arguments` has a special meaning inside mixins, it contains all the arguments passed, when the mixin was called. This is useful if you don't want to deal with individual parameters:\n\n    .box-shadow(@x: 0, @y: 0, @blur: 1px, @color: #000) {\n      -webkit-box-shadow: @arguments;\n         -moz-box-shadow: @arguments;\n              box-shadow: @arguments;\n    }\n    .big-block {\n      .box-shadow(2px, 5px);\n    }\n\nWhich results in:\n\n    .big-block {\n      -webkit-box-shadow: 2px 5px 1px #000;\n         -moz-box-shadow: 2px 5px 1px #000;\n              box-shadow: 2px 5px 1px #000;\n    }\n\n### Advanced Arguments and the `@rest` Variable\n\nYou can use `...` if you want your mixin to take a variable number of arguments. Using this after a variable name will assign those arguments to the variable.\n\n    .mixin(...) {        // matches 0-N arguments\n    .mixin() {           // matches exactly 0 arguments\n    .mixin(@a: 1) {      // matches 0-1 arguments\n    .mixin(@a: 1, ...) { // matches 0-N arguments\n    .mixin(@a, ...) {    // matches 1-N arguments\n\nFurthermore:\n\n    .mixin(@a, @rest...) {\n       // @rest is bound to arguments after @a\n       // @arguments is bound to all arguments\n    }\n\n### Pattern-matching\n\nSometimes, you may want to change the behavior of a mixin, based on the parameters you pass to it. Let's start with something basic:\n\n    .mixin(@s, @color) { ... }\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nNow let's say we want `.mixin` to behave differently, based on the value of `@switch`, we could define `.mixin` as such:\n\n    .mixin(dark, @color) {\n      color: darken(@color, 10%);\n    }\n    .mixin(light, @color) {\n      color: lighten(@color, 10%);\n    }\n    .mixin(@_, @color) {\n      display: block;\n    }\n\nNow, if we run:\n\n    @switch: light;\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nWe will get the following CSS:\n\n    .class {\n      color: #a2a2a2;\n      display: block;\n    }\n\nWhere the color passed to `.mixin` was lightened. If the value of `@switch` was `dark`, the result would be a darker color.\n\nHere's what happened:\n\n- The first mixin definition didn't match because it expected `dark` as the first argument.\n- The second mixin definition matched, because it expected `light`.\n- The third mixin definition matched because it expected any value.\n\nOnly mixin definitions which matched were used. Variables match and bind to any value. Anything other than a variable matches only with a value equal to itself.\n\nWe can also match on arity, here's an example:\n\n    .mixin(@a) {\n      color: @a;\n    }\n    .mixin(@a, @b) {\n      color: fade(@a, @b);\n    }\n\nNow if we call `.mixin` with a single argument, we will get the output of the first definition, but if we call it with *two* arguments, we will get the second definition, namely `@a` faded to `@b`.\n\n### Using Mixins as Functions\n\nSelecting properties and variables from mixin calls\n\n### Property / value accessors\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors to select a value from an evaluated mixin's rules. This can allow you to use mixins similar to functions.\n\nExample:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its \"@result\" value\n      padding: .average(16px, 50px)[@result];\n    }\n\nResults in:\n\n    div {\n      padding: 33px;\n    }\n\n### Overriding mixin values\n\nIf you have multiple matching mixins, all rules are evaluated and merged, and the last matching value with that identifier is returned. This is similar to the cascade in CSS, and it allows you to \"override\" mixin values.\n\n    // library.less\n    #library() {\n      .mixin() {\n        prop: foo;\n      }\n    }\n\n    // customize.less\n    @import \"library\";\n    #library() {\n      .mixin() {\n        prop: bar;\n      }\n    }\n\n    .box {\n      my-value: #library.mixin[prop];\n    }\n\nOutputs:\n\n    .box {\n      my-value: bar;\n    }\n\n### Unnamed lookups\n\nIf you don't specify a lookup value in `[@lookup]` and instead write `[]` after a mixin or ruleset call, *all* values will cascade and the last declared value will be selected.\n\nMeaning: the averaging mixin from the above example could be written as:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its final value\n      padding: .average(16px, 50px)[];\n    }\n\nThe output is the same:\n\n    div {\n      padding: 33px;\n    }\n\nThe same cascading behavior is true for rulesets or variables aliased to mixin calls.\n\n    @dr: {\n      value: foo;\n    }\n    .box {\n      my-value: @dr[];\n    }\n\nThis outputs:\n\n    .box {\n      my-value: foo;\n    }\n\n### Unlocking mixins & variables into caller scope\n\n***DEPRECATED - Use Property / Value Accessors***\n\nVariables and mixins defined in a mixin are visible and can be used in caller's scope. There is only one exception: a variable is not copied if the caller contains a variable with the same name (that includes variables defined by another mixin call). Only variables present in callers local scope are protected. Variables inherited from parent scopes are overridden.\n\n*Note: this behavior is deprecated, and in the future, variables and mixins will not be merged into the caller scope in this way.*\n\nExample:\n\n    .mixin() {\n      @width:  100%;\n      @height: 200px;\n    }\n\n    .caller {\n      .mixin();\n      width:  @width;\n      height: @height;\n    }\n\nResults in:\n\n    .caller {\n      width:  100%;\n      height: 200px;\n    }\n\nVariables defined directly in callers scope cannot be overridden. However, variables defined in callers parent scope is not protected and will be overridden:\n\n    .mixin() {\n      @size: in-mixin;\n      @definedOnlyInMixin: in-mixin;\n    }\n\n    .class {\n      margin: @size @definedOnlyInMixin;\n      .mixin();\n    }\n\n    @size: globaly-defined-value; // callers parent scope - no protection\n\nResults in:\n\n    .class {\n      margin: in-mixin in-mixin;\n    }\n\nFinally, mixin defined in mixin acts as return value too:\n\n    .unlock(@value) { // outer mixin\n      .doSomething() { // nested mixin\n        declaration: @value;\n      }\n    }\n\n    #namespace {\n      .unlock(5); // unlock doSomething mixin\n      .doSomething(); //nested mixin was copied here and is usable\n    }\n\nResults in:\n\n    #namespace {\n      declaration: 5;\n    }\n\n### Recursive Mixins\n\nCreating loops\n\nIn Less a mixin can call itself. Such recursive mixins, when combined with [Guard Expressions](#mixin-guards-feature) and [Pattern Matching](#mixins-parametric-feature-pattern-matching), can be used to create various iterative/loop structures.\n\nExample:\n\n    .loop(@counter) when (@counter > 0) {\n      .loop((@counter - 1));    // next iteration\n      width: (10px * @counter); // code for each iteration\n    }\n\n    div {\n      .loop(5); // launch the loop\n    }\n\nOutput:\n\n    div {\n      width: 10px;\n      width: 20px;\n      width: 30px;\n      width: 40px;\n      width: 50px;\n    }\n\nA generic example of using a recursive loop to generate CSS grid classes:\n\n    .generate-columns(4);\n\n    .generate-columns(@n, @i: 1) when (@i =< @n) {\n      .column-@{i} {\n        width: (@i * 100% / @n);\n      }\n      .generate-columns(@n, (@i + 1));\n    }\n\nOutput:\n\n    .column-1 {\n      width: 25%;\n    }\n    .column-2 {\n      width: 50%;\n    }\n    .column-3 {\n      width: 75%;\n    }\n    .column-4 {\n      width: 100%;\n    }\n\n### Mixin Guards\n\nGuards are useful when you want to match on *expressions*, as opposed to simple values or arity. If you are familiar with functional programming, you have probably encountered them already.\n\nIn trying to stay as close as possible to the declarative nature of CSS, Less has opted to implement conditional execution via **guarded mixins** instead of `if`/`else` statements, in the vein of `@media` query feature specifications.\n\nLet's start with an example:\n\n    .mixin(@a) when (lightness(@a) >= 50%) {\n      background-color: black;\n    }\n    .mixin(@a) when (lightness(@a) < 50%) {\n      background-color: white;\n    }\n    .mixin(@a) {\n      color: @a;\n    }\n\nThe key is the `when` keyword, which introduces a guard sequence (here with only one guard). Now if we run the following code:\n\n    .class1 { .mixin(#ddd) }\n    .class2 { .mixin(#555) }\n\nHere's what we'll get:\n\n    .class1 {\n      background-color: black;\n      color: #ddd;\n    }\n    .class2 {\n      background-color: white;\n      color: #555;\n    }\n\n### Guard Comparison Operators\n\nThe full list of comparison operators usable in guards are: `>`, `>=`, `=`, `=<`, `<`. Additionally, the keyword `true` is the only truthy value, making these two mixins equivalent:\n\n    .truth(@a) when (@a) { ... }\n    .truth(@a) when (@a = true) { ... }\n\nAny value other than the keyword `true` is falsy:\n\n    .class {\n      .truth(40); // Will not match any of the above definitions.\n    }\n\nNote that you can also compare arguments with each other, or with non-arguments:\n\n    @media: mobile;\n\n    .mixin(@a) when (@media = mobile) { ... }\n    .mixin(@a) when (@media = desktop) { ... }\n\n    .max(@a; @b) when (@a > @b) { width: @a }\n    .max(@a; @b) when (@a < @b) { width: @b }\n\n### Guard Logical Operators\n\nYou can use logical operators with guards. The syntax is based on CSS media queries.\n\nUse the `and` keyword to combine guards:\n\n    .mixin(@a) when (isnumber(@a)) and (@a > 0) { ... }\n\nYou can emulate the *or* operator by separating guards with a comma `,`. If any of the guards evaluate to true, it's considered a match:\n\n    .mixin(@a) when (@a > 10), (@a < -10) { ... }\n\nUse the `not` keyword to negate conditions:\n\n    .mixin(@b) when not (@b > 0) { ... }\n\n### Type Checking Functions\n\nLastly, if you want to match mixins based on value type, you can use the `is` functions:\n\n    .mixin(@a; @b: 0) when (isnumber(@b)) { ... }\n    .mixin(@a; @b: black) when (iscolor(@b)) { ... }\n\nHere are the basic type checking functions:\n\n- `iscolor`\n- `isnumber`\n- `isstring`\n- `iskeyword`\n- `isurl`\n\nIf you want to check if a value is in a specific unit in addition to being a number, you may use one of:\n\n- `ispixel`\n- `ispercentage`\n- `isem`\n- `isunit`\n\n### Aliasing Mixins\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nAssigning mixin calls to a variable\n\nMixins can be assigned to a variable to be called as a variable call, or can be used for map lookup.\n\n    #theme.dark.navbar {\n      .colors(light) {\n        primary: purple;\n      }\n      .colors(dark) {\n        primary: black;\n        secondary: grey;\n      }\n    }\n\n    .navbar {\n      @colors: #theme.dark.navbar.colors(dark);\n      background: @colors[primary];\n      border: 1px solid @colors[secondary];\n    }\n\nThis would output:\n\n    .navbar {\n      background: black;\n      border: 1px solid grey;\n    }\n\n### Variable calls\n\nEntire mixin calls can be aliased and called as variable calls. As in:\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors();\n      @alias();\n    }\n\nOutputs:\n\n    .box {\n      background: green;\n    }\n\nNote, unlike mixins used in root, mixin calls assigned to variables and *called with no arguments* always require parentheses. The following is not valid.\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors;\n      @alias();   // ERROR: Could not evaluate variable call @alias\n    }\n\nThis is because it's ambiguous if variable is assigned a list of selectors or a mixin call. For example, in Less 3.5+, this variable could be used this way.\n\n    .box {\n      @alias: #library.colors;\n      @{alias} {\n        a: b;\n      }\n    }\n\nThe above would output:\n\n    .box #library.colors {\n      a: b;\n    }\n\n## CSS Guards\n\n\"if\"'s around selectors\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nLike Mixin Guards, guards can also be applied to css selectors, which is syntactic sugar for declaring the mixin and then calling it immediately.\n\nFor instance, before 1.5.0 you would have had to do this:\n\n    .my-optional-style() when (@my-option = true) {\n      button {\n        color: white;\n      }\n    }\n    .my-optional-style();\n\nNow, you can apply the guard directly to a style.\n\n    button when (@my-option = true) {\n      color: white;\n    }\n\nYou can also achieve an `if` type statement by combining this with the `&` feature, allowing you to group multiple guards.\n\n    & when (@my-option = true) {\n      button {\n        color: white;\n      }\n      a {\n        color: blue;\n      }\n    }\n\nNote that you can also achieve a similar pattern by using the actual `if()` function and a variable call. As in:\n\n    @dr: if(@my-option = true, {\n      button {\n        color: white;\n      }\n      a {\n        color: blue;\n      }\n    });\n    @dr();\n\n## Detached Rulesets\n\nAssign a ruleset to a variable\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nA detached ruleset is a group of css properties, nested rulesets, media declarations or anything else stored in a variable. You can include it into a ruleset or another structure and all its properties are going to be copied there. You can also use it as a mixin argument and pass it around as any other variable.\n\nSimple example:\n\n    // declare detached ruleset\n    @detached-ruleset: { background: red; }; // semi-colon is optional in 3.5.0+\n\n    // use detached ruleset\n    .top {\n        @detached-ruleset(); \n    }\n\ncompiles into:\n\n    .top {\n      background: red;\n    }\n\nParentheses after a detached ruleset call are mandatory (except when followed by a [lookup value](#detached-rulesets-feature-property-variable-accessors)). The call `@detached-ruleset;` would not work.\n\nIt is useful when you want to define a mixin that abstracts out either wrapping a piece of code in a media query or a non-supported browser class name. The rulesets can be passed to mixin so that the mixin can wrap the content, e.g.\n\n    .desktop-and-old-ie(@rules) {\n      @media screen and (min-width: 1200px) { @rules(); }\n      html.lt-ie9 &                         { @rules(); }\n    }\n\n    header {\n      background-color: blue;\n\n      .desktop-and-old-ie({\n        background-color: red;\n      });\n    }\n\nHere the `desktop-and-old-ie` mixin defines the media query and root class so that you can use a mixin to wrap a piece of code. This will output\n\n    header {\n      background-color: blue;\n    }\n    @media screen and (min-width: 1200px) {\n      header {\n        background-color: red;\n      }\n    }\n    html.lt-ie9 header {\n      background-color: red;\n    }\n\nA ruleset can be now assigned to a variable or passed in to a mixin and can contain the full set of Less features, e.g.\n\n    @my-ruleset: {\n        .my-selector {\n          background-color: black;\n        }\n      };\n\nYou can even take advantage of [media query bubbling](#features-overview-feature-media-query-bubbling-and-nested-media-queries), for instance\n\n    @my-ruleset: {\n        .my-selector {\n          @media tv {\n            background-color: black;\n          }\n        }\n      };\n    @media (orientation:portrait) {\n        @my-ruleset();\n    }\n\nwhich will output\n\n    @media (orientation: portrait) and tv {\n      .my-selector {\n        background-color: black;\n      }\n    }\n\nA detached ruleset call unlocks (returns) all its mixins into caller the same way as mixin calls do. However, it does **not** return variables.\n\nReturned mixin:\n\n    // detached ruleset with a mixin\n    @detached-ruleset: { \n        .mixin() {\n            color: blue;\n        }\n    };\n    // call detached ruleset\n    .caller {\n        @detached-ruleset(); \n        .mixin();\n    }\n\nResults in:\n\n    .caller {\n      color: blue;\n    }\n\nPrivate variables:\n\n    @detached-ruleset: { \n        @color:blue; // this variable is private\n    };\n    .caller {\n        color: @color; // syntax error\n    }\n\n### Scoping\n\nA detached ruleset can use all variables and mixins accessible where it is *defined* and where it is *called*. Otherwise said, both definition and caller scopes are available to it. If both scopes contains the same variable or mixin, declaration scope value takes precedence.\n\n*Declaration scope* is the one where detached ruleset body is defined. Copying a detached ruleset from one variable into another cannot modify its scope. The ruleset does not gain access to new scopes just by being referenced there.\n\nLastly, a detached ruleset can gain access to scope by being unlocked (imported) into it.\n\n*Note: unlocking variables into scope via a called mixin is deprecated. Use [property / variable accessors](#detached-rulesets-feature-property-variable-accessors).*\n\n### Definition and Caller Scope Visibility\n\nA detached ruleset sees the caller's variables and mixins:\n\n    @detached-ruleset: {\n      caller-variable: @caller-variable; // variable is undefined here\n      .caller-mixin(); // mixin is undefined here\n    };\n\n    selector {\n      // use detached ruleset\n      @detached-ruleset(); \n\n      // define variable and mixin needed inside the detached ruleset\n      @caller-variable: value;\n      .caller-mixin() {\n        variable: declaration;\n      }\n    }\n\ncompiles into:\n\n    selector {\n      caller-variable: value;\n      variable: declaration;\n    }\n\nVariable and mixins accessible from definition win over those available in the caller:\n\n    @variable: global;\n    @detached-ruleset: {\n      // will use global variable, because it is accessible\n      // from detached-ruleset definition\n      variable: @variable; \n    };\n\n    selector {\n      @detached-ruleset();\n      @variable: value; // variable defined in caller - will be ignored\n    }\n\ncompiles into:\n\n    selector {\n      variable: global;\n    }\n\n### Referencing *Won't* Modify Detached Ruleset Scope\n\nA ruleset does not gain access to new scopes just by being referenced there:\n\n    @detached-1: { scope-detached: @one @two; };\n    .one {\n      @one: visible;\n      .two {\n        @detached-2: @detached-1; // copying/renaming ruleset \n        @two: visible; // ruleset can not see this variable\n      }\n    }\n\n    .use-place {\n      .one > .two(); \n      @detached-2();\n    }\n\nthrows an error:\n\n    ERROR 1:32 The variable \"@one\" was not declared.\n\n### Unlocking *Will* Modify Detached Ruleset Scope\n\nA detached ruleset gains access by being unlocked (imported) inside a scope:\n\n    #space {\n      .importer-1() {\n        @detached: { scope-detached: @variable; }; // define detached ruleset\n      }\n    }\n\n    .importer-2() {\n      @variable: value; // unlocked detached ruleset CAN see this variable\n      #space > .importer-1(); // unlock/import detached ruleset\n    }\n\n    .use-place {\n      .importer-2(); // unlock/import detached ruleset second time\n       @detached();\n    }\n\ncompiles into:\n\n    .use-place {\n      scope-detached: value;\n    }\n\n### Property / variable accessors\n\n### (Lookup values)\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors (also called \"lookups\") to select a value from variable (detached) rulesets.\n\n    @config: {\n      option1: true;\n      option2: false;\n    }\n\n    .mixin() when (@config[option1] = true) {\n      selected: value;\n    }\n\n    .box {\n      .mixin();\n    }\n\nOutputs:\n\n    .box {\n      selected: value;\n    }\n\nIf what is returned from a lookup is another detached ruleset, you can use a second lookup to get that value.\n\n    @config: {\n      @colors: {\n        primary: blue;\n      }\n    }\n\n    .box {\n      color: @config[@colors][primary];\n    }\n\n### Variable variables in lookups\n\nThe lookup value that is returned can itself be variable. As in, you can write:\n\n    @config: {\n      @dark: {\n        primary: darkblue;\n      }\n      @light: {\n        primary: lightblue;\n      }\n    }\n\n    .box {\n      @lookup: dark;\n      color: @config[@@lookup][primary];\n    }\n\nThis will output:\n\n    .box {\n      color: darkblue;\n    }\n\n## @import At-Rules\n\nImport styles from other style sheets\n\nIn standard CSS, `@import` at-rules must precede all other types of rules. But Less doesn't care where you put `@import` statements.\n\nExample:\n\n    .foo {\n      background: #900;\n    }\n    @import \"this-is-valid.less\";\n\n### File Extensions\n\n`@import` statements may be treated differently by Less depending on the file extension:\n\n- If the file has a `.css` extension it will be treated as CSS and the `@import` statement left as-is (see the [inline option](#import-options-inline) below).\n- If it has *any other extension* it will be treated as Less and imported.\n- If it does not have an extension, `.less` will be appended and it will be included as a imported Less file.\n\nExamples:\n\n    @import \"foo\";      // foo.less is imported\n    @import \"foo.less\"; // foo.less is imported\n    @import \"foo.php\";  // foo.php imported as a Less file\n    @import \"foo.css\";  // statement left in place, as-is\n\nThe following options can be used to override this behavior.\n\n### Import Options\n\nLess offers several extensions to the CSS `@import` CSS at-rule to provide more flexibility over what you can do with external files.\n\nSyntax: `@import (keyword) \"filename\";`\n\nThe following import options have been implemented:\n\n- `reference`: use a Less file but do not output it\n- `inline`: include the source file in the output but do not process it\n- `less`: treat the file as a Less file, no matter what the file extension\n- `css`: treat the file as a CSS file, no matter what the file extension\n- `once`: only include the file once (this is default behavior)\n- `multiple`: include the file multiple times\n- `optional`: continue compiling when file is not found\n\nMore than one keyword per `@import` is allowed, you will have to use commas to separate the keywords:\n\nExample: `@import (optional, reference) \"foo.less\";`\n\n### reference\n\nUse `@import (reference)` to import external files, but without adding the imported styles to the compiled output unless referenced.\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample: `@import (reference) \"foo.less\";`\n\nImagine that `reference` marks every at-rule and selector with a *reference flag* in the imported file, imports as normal, but when the CSS is generated, \"reference\" selectors (as well as any media queries containing only reference selectors) are not output. `reference` styles will not show up in your generated CSS unless the reference styles are used as [mixins](#mixins-feature) or [extended](#extend-feature).\n\nAdditionally, **`reference`** produces different results depending on which method was used (mixin or extend):\n\n- **[extend](#extend-feature)**: When a selector is extended, only the new selector is marked as *not referenced*, and it is pulled in at the position of the reference `@import` statement.\n- **[mixins](#mixins-feature)**: When a `reference` style is used as an [implicit mixin](#mixins-feature), its rules are mixed-in, marked \"not reference\", and appear in the referenced place as normal.\n\n### reference example\n\nThis allows you to pull in only specific, targeted styles from a library such as [Bootstrap](https://github.com/twbs/bootstrap) by doing something like this:\n\n    .navbar:extend(.navbar all) {}\n\nAnd you will pull in only `.navbar` related styles from Bootstrap.\n\n### inline\n\nUse `@import (inline)` to include external files, but not process them.\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample: `@import (inline) \"not-less-compatible.css\";`\n\nYou will use this when a CSS file may not be Less compatible; this is because although Less supports most known standards CSS, it does not support comments in some places and does not support all known CSS hacks without modifying the CSS.\n\nSo you can use this to include the file in the output so that all CSS will be in one file.\n\n### less\n\nUse `@import (less)` to treat imported files as Less, regardless of file extension.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    @import (less) \"foo.css\";\n\n### css\n\nUse `@import (css)` to treat imported files as regular CSS, regardless of file extension. This means the import statement will be left as it is.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    @import (css) \"foo.less\";\n\noutputs\n\n    @import \"foo.less\";\n\n### once\n\nThe default behavior of `@import` statements. It means the file is imported only once and subsequent import statements for that file will be ignored.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nThis is the default behavior of `@import` statements.\n\nExample:\n\n    @import (once) \"foo.less\";\n    @import (once) \"foo.less\"; // this statement will be ignored\n\n### multiple\n\nUse `@import (multiple)` to allow importing of multiple files with the same name. This is the opposite behavior to once.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    // file: foo.less\n    .a {\n      color: green;\n    }\n    // file: main.less\n    @import (multiple) \"foo.less\";\n    @import (multiple) \"foo.less\";\n\nOutputs\n\n    .a {\n      color: green;\n    }\n    .a {\n      color: green;\n    }\n\n### optional\n\nUse `@import (optional)` to allow importing of a file only when it exists. Without the `optional` keyword Less throws a FileError and stops compiling when importing a file that can not be found.\n\nReleased [v2.3.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\n## @plugin At-Rules\n\nReleased [v2.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nImport JavaScript plugins to add Less.js functions and features\n\n### Writing your first plugin\n\nUsing a `@plugin` at-rule is similar to using an `@import` for your `.less` files.\n\n    @plugin \"my-plugin\";  // automatically appends .js if no extension\n\nSince Less plugins are evaluated within the Less scope, the plugin definition can be quite simple.\n\n    registerPlugin({\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    })\n\nor you can use `module.exports` (shimmed to work in browser as well as Node.js).\n\n    module.exports = {\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    };\n\nNote that other Node.js CommonJS conventions, like `require()` are not available in the browser. Keep this in mind when writing cross-platform plugins.\n\nWhat can you do with a plugin? A lot, but let's start with the basics. We'll focus first on what you might put inside the `install` function. Let's say you write this:\n\n    // my-plugin.js\n    install: function(less, pluginManager, functions) {\n        functions.add('pi', function() {\n            return Math.PI;\n        });\n    }\n    // etc\n\nCongratulations! You've written a Less plugin!\n\nIf you were to use this in your stylesheet:\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi();\n    }\n\nYou would get:\n\n    .show-me-pi {\n      value: 3.141592653589793;\n    }\n\nHowever, you would need to return a proper Less node if you wanted to, say, multiply that against other values or do other Less operations. Otherwise the output in your stylesheet is plain text (which may be fine for your purposes).\n\nMeaning, this is more correct:\n\n    functions.add('pi', function() {\n        return new tree.Dimension(Math.PI);\n    });\n\n*Note: A dimension is a number with or without a unit, like \"10px\", which would be `less.Dimension(10, \"px\")`. For a list of units, see the [Less API](todo).*\n\nNow you can use your function in operations.\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi() * 2;\n    }\n\nYou may have noticed that there are available globals for your plugin file, namely a function registry (`functions` object), and the `less` object. These are there for convenience.\n\n### Plugin Scope\n\nFunctions added by a `@plugin` at-rule adheres to Less scoping rules. This is great for Less library authors that want to add functionality without introducing naming conflicts.\n\nFor instance, say you have 2 plugins from two third-party libraries that both have a function named \"foo\".\n\n    // lib1.js\n    // ...\n        functions.add('foo', function() {\n            return \"foo\";\n        });\n    // ...\n\n    // lib2.js\n    // ...\n        functions.add('foo', function() {\n            return \"bar\";\n        });\n    // ...\n\nThat's ok! You can choose which library's function creates which output.\n\n    .el-1 {\n        @plugin \"lib1\";\n        value: foo();\n    }\n    .el-2 {\n        @plugin \"lib2\";\n        value: foo();\n    }\n\nThis will produce:\n\n    .el-1 {\n        value: foo;\n    }\n    .el-2 {\n        value: bar;\n    }\n\nFor plugin authors sharing their plugins, that means you can also effectively make private functions by placing them in a particular scope. As in, this will cause an error:\n\n    .el {\n        @plugin \"lib1\";\n    }\n    @value: foo();\n\nAs of Less 3.0, functions can return any kind of Node type, and can be called at any level.\n\nMeaning, this would throw an error in 2.x, as functions had to be part of the value of a property or variable assignment:\n\n    .block {\n        color: blue;\n        my-function-rules();\n    }\n\nIn 3.x, that's no longer the case, and functions can return At-Rules, Rulesets, any other Less node, strings, and numbers (the latter two are converted to Anonymous nodes).\n\n### Null Functions\n\nThere are times when you may want to call a function, but you don't want anything output (such as storing a value for later use). In that case, you just need to return `false` from the function.\n\n    var collection = [];\n\n    functions.add('store', function(val) {\n        collection.push(val);  // imma store this for later\n        return false;\n    });\n\n    @plugin \"collections\";\n    @var: 32;\n    store(@var);\n\nLater you could do something like:\n\n    functions.add('retrieve', function(val) {\n        return new tree.Value(collection);\n    });\n\n    .get-my-values {\n        @plugin \"collections\";\n        values: retrieve();   \n    }\n\n### The Less.js Plugin Object\n\nA Less.js plugin should export an object that has one or more of these properties.\n\n    {\n        /* Called immediately after the plugin is \n         * first imported, only once. */\n        install: function(less, pluginManager, functions) { },\n\n        /* Called for each instance of your @plugin. */\n        use: function(context) { },\n\n        /* Called for each instance of your @plugin, \n         * when rules are being evaluated.\n         * It's just later in the evaluation lifecycle */\n        eval: function(context) { },\n\n        /* Passes an arbitrary string to your plugin \n         * e.g. @plugin (args) \"file\";\n         * This string is not parsed for you, \n         * so it can contain (almost) anything */\n        setOptions: function(argumentString) { },\n\n        /* Set a minimum Less compatibility string\n         * You can also use an array, as in [3, 0] */\n        minVersion: ['3.0'],\n\n        /* Used for lessc only, to explain \n         * options in a Terminal */\n        printUsage: function() { },\n\n    }\n\nThe PluginManager instance for the `install()` function provides methods for adding visitors, file managers, and post-processors.\n\nHere are some example repos showing the different plugin types.\n\n- post-processor: <https://github.com/less/less-plugin-clean-css>\n- visitor: <https://github.com/less/less-plugin-inline-urls>\n- file-manager: <https://github.com/less/less-plugin-npm-import>\n\n### Pre-Loaded Plugins\n\nWhile a `@plugin` call works well for most scenarios, there are times when you might want to load a plugin before parsing starts.\n\nSee: [Pre-Loaded Plugins](usage#plugins) in the \"Using Less.js\" section for how to do that.\n\n## Maps (NEW!)\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nUse rulesets and mixins as maps of values\n\nBy combining namespacing with the lookup `[]` syntax, you can turn your rulesets / mixins into maps.\n\n    @sizes: {\n      mobile: 320px;\n      tablet: 768px;\n      desktop: 1024px;\n    }\n\n    .navbar {\n      display: block;\n\n      @media (min-width: @sizes[tablet]) {\n        display: inline-block;\n      }\n    }\n\nOutputs:\n\n    .navbar {\n      display: block;\n    }\n    @media (min-width: 768px) {\n      .navbar {\n        display: inline-block;\n      }\n    }\n\nMixins are a little more versatile as maps because of namespacing and the ability to overload mixins.\n\n    #library() {\n      .colors() {\n        primary: green;\n        secondary: blue;\n      }\n    }\n\n    #library() {\n      .colors() { primary: grey; }\n    }\n\n    .button {\n      color: #library.colors[primary];\n      border-color: #library.colors[secondary];\n    }\n\nOutputs:\n\n    .button {\n      color: grey;\n      border-color: blue;\n    }\n\nYou can also make this easier by [aliasing mixins](#mixins-feature-mixin-aliasing-feature). That is:\n\n    .button {\n      @colors: #library.colors();\n      color: @colors[primary];\n      border-color: @colors[secondary];\n    }\n\nNote, if a lookup value produces another ruleset, you can append a second `[]` lookup, as in:\n\n    @config: {\n      @options: {\n        library-on: true\n      }\n    }\n\n    & when (@config[@options][library-on] = true) {\n      .produce-ruleset {\n        prop: val;\n      }\n    }\n\nIn this way, rulesets and variable calls can emulate a type of \"namespacing\", similar to mixins.\n\nAs far as whether to use mixins or rulesets assigned to variables as maps, it's up to you. You may want to replace entire maps by re-declaring a variable assigned to a rulset. Or you may want to \"merge\" individual key/value pairs, in which case mixins as maps might be more appropriate.\n\n### Using variable variables in lookups\n\nOne important thing to notice is that the value in `[@lookup]` is the key (variable) name `@lookup`, and is not evaluated as a variable. If you want the key name itself to be variable, you can use the `@@variable` syntax.\n\nE.g.\n\n    .foods() {\n      @dessert: ice cream;\n    }\n\n    @key-to-lookup: dessert;\n\n    .lunch {\n      treat: .foods[@@key-to-lookup];\n    }\n\nThis would output:\n\n    .lunch {\n      treat: ice cream;\n    }\n\n© 2009–2020 The Core Less Team  \nLicensed under the Creative Commons Attribution License 3.0.  \n[http://lesscss.org/features](http://lesscss.org/features)"
- name: :extend(all)
  id: index#extend-feature-extend-all-
  summary: An in-depth guide to features of the LESS language
  description: "# Less\n\n## Overview\n\nAn in-depth guide to features of the LESS language. See the [Overview](http://lesscss.org/#overview) for a quick summary of Less.\n\n*For an in-depth guide to installing and setting up a Less environment, as well as documentation on developing for Less, see: [Using Less.js](usage).*\n\n## Variables\n\nControl commonly used values in a single location.\n\n### Overview\n\nIt's not uncommon to see the same value repeated dozens *if not hundreds of times* across your stylesheets:\n\n    a,\n    .link {\n      color: #428bca;\n    }\n    .widget {\n      color: #fff;\n      background: #428bca;\n    }\n\nVariables make your code easier to maintain by giving you a way to control those values from a single location:\n\n    // Variables\n    @link-color:        #428bca; // sea blue\n    @link-color-hover:  darken(@link-color, 10%);\n\n    // Usage\n    a,\n    .link {\n      color: @link-color;\n    }\n    a:hover {\n      color: @link-color-hover;\n    }\n    .widget {\n      color: #fff;\n      background: @link-color;\n    }\n\n### Variable Interpolation\n\nThe examples above focused on using variables to control *values in CSS rules*, but they can also be used in other places as well, such as selector names, property names, URLs and `@import` statements.\n\n### Selectors\n\n*v1.4.0*\n\n    // Variables\n    @my-selector: banner;\n\n    // Usage\n    .@{my-selector} {\n      font-weight: bold;\n      line-height: 40px;\n      margin: 0 auto;\n    }\n\nCompiles to:\n\n    .banner {\n      font-weight: bold;\n      line-height: 40px;\n      margin: 0 auto;\n    }\n\n### URLs\n\n    // Variables\n    @images: \"../img\";\n\n    // Usage\n    body {\n      color: #444;\n      background: url(\"@{images}/white-sand.png\");\n    }\n\n### Import Statements\n\n*v1.4.0*\n\nSyntax: `@import \"@{themes}/tidal-wave.less\";`\n\nNote that before v2.0.0, only variables which have been declared in the root or current scope were considered and that only the current file and calling files were considered when looking for a variable.\n\nExample:\n\n    // Variables\n    @themes: \"../../src/themes\";\n\n    // Usage\n    @import \"@{themes}/tidal-wave.less\";\n\n### Properties\n\n*v1.6.0*\n\n    @property: color;\n\n    .widget {\n      @{property}: #0ee;\n      background-@{property}: #999;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #0ee;\n      background-color: #999;\n    }\n\n### Variable Variables\n\nIn Less, you can define a variable's name using another variable.\n\n    @primary:  green;\n    @secondary: blue;\n\n    .section {\n      @color: primary;\n\n      .element {\n        color: @@color;\n      }\n    }\n\nWhich compiles to:\n\n    .section .element {\n      color: green;\n    }\n\n### Lazy Evaluation\n\nVariables do not have to be declared before being used.\n\nValid Less snippet:\n\n    .lazy-eval {\n      width: @var;\n    }\n\n    @var: @a;\n    @a: 9%;\n\nthis is valid Less too:\n\n    .lazy-eval {\n      width: @var;\n      @a: 9%;\n    }\n\n    @var: @a;\n    @a: 100%;\n\nboth compile into:\n\n    .lazy-eval {\n      width: 9%;\n    }\n\nWhen defining a variable twice, the last definition of the variable is used, searching from the current scope upwards. This is similar to css itself where the last property inside a definition is used to determine the value.\n\nFor instance:\n\n    @var: 0;\n    .class {\n      @var: 1;\n      .brass {\n        @var: 2;\n        three: @var;\n        @var: 3;\n      }\n      one: @var;\n    }\n\nCompiles to:\n\n    .class {\n      one: 1;\n    }\n    .class .brass {\n      three: 3;\n    }\n\nEssentially, each scope has a \"final\" value, similar to properties in the browser, like this example using custom properties:\n\n    .header {\n      --color: white;\n      color: var(--color);  // the color is black\n      --color: black;\n    }\n\nThis means that, unlike other CSS pre-processing languages, Less variables behave very much like CSS's.\n\n### Properties as Variables **(NEW!)**\n\n*v3.0.0*\n\nYou can easily treat properties like variables using the `$prop` syntax. Sometimes this can make your code a little lighter.\n\n    .widget {\n      color: #efefef;\n      background-color: $color;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #efefef;\n      background-color: #efefef;\n    }\n\nNote that, like variables, Less will choose the last property within the current/parent scope as being the \"final\" value.\n\n    .block {\n      color: red; \n      .inner {\n        background-color: $color; \n      }\n      color: blue;  \n    } \n\nCompiles to:\n\n    .block {\n      color: red; \n      color: blue;  \n    } \n    .block .inner {\n      background-color: blue; \n    }\n\n### Default Variables\n\nWe sometimes get requests for default variables - an ability to set a variable only if it is not already set. This feature is not required because you can easily override a variable by putting the definition afterwards.\n\nFor instance:\n\n    // library\n    @base-color: green;\n    @dark-color: darken(@base-color, 10%);\n\n    // use of library\n    @import \"library.less\";\n    @base-color: red;\n\nThis works fine because of [Lazy Loading](#variables-feature-lazy-loading) - `@base-color` is overridden and `@dark-color` is a dark red.\n\n## Parent Selectors\n\nReferencing parent selectors with `&`\n\nThe `&` operator represents the parent selectors of a [nested rule](#features-overview-feature-nested-rules) and is most commonly used when applying a modifying class or pseudo-class to an existing selector:\n\n    a {\n      color: blue;\n      &:hover {\n        color: green;\n      }\n    }\n\nresults in:\n\n    a {\n      color: blue;\n    }\n\n    a:hover {\n      color: green;\n    }\n\nNotice that without the `&`, the above example would result in `a :hover` rule (a descendant selector that matches hovered elements inside of `<a>` tags) and this is not what we typically would want with the nested `:hover`.\n\nThe \"parent selectors\" operator has a variety of uses. Basically any time you need the selectors of the nested rules to be combined in other ways than the default. For example another typical use of the `&` is to produce repetitive class names:\n\n    .button {\n      &-ok {\n        background-image: url(\"ok.png\");\n      }\n      &-cancel {\n        background-image: url(\"cancel.png\");\n      }\n\n      &-custom {\n        background-image: url(\"custom.png\");\n      }\n    }\n\noutput:\n\n    .button-ok {\n      background-image: url(\"ok.png\");\n    }\n    .button-cancel {\n      background-image: url(\"cancel.png\");\n    }\n    .button-custom {\n      background-image: url(\"custom.png\");\n    }\n\n### Multiple `&`\n\n`&` may appear more than once within a selector. This makes it possible to repeatedly refer to a parent selector without repeating its name.\n\n    .link {\n      & + & {\n        color: red;\n      }\n\n      & & {\n        color: green;\n      }\n\n      && {\n        color: blue;\n      }\n\n      &, &ish {\n        color: cyan;\n      }\n    }\n\nwill output:\n\n    .link + .link {\n      color: red;\n    }\n    .link .link {\n      color: green;\n    }\n    .link.link {\n      color: blue;\n    }\n    .link, .linkish {\n      color: cyan;\n    }\n\nNote that `&` represents all parent selectors (not just the nearest ancestor) so the following example:\n\n    .grand {\n      .parent {\n        & > & {\n          color: red;\n        }\n\n        & & {\n          color: green;\n        }\n\n        && {\n          color: blue;\n        }\n\n        &, &ish {\n          color: cyan;\n        }\n      }\n    }\n\nresults in:\n\n    .grand .parent > .grand .parent {\n      color: red;\n    }\n    .grand .parent .grand .parent {\n      color: green;\n    }\n    .grand .parent.grand .parent {\n      color: blue;\n    }\n    .grand .parent,\n    .grand .parentish {\n      color: cyan;\n    }\n\n### Changing Selector Order\n\nIt can be useful to prepend a selector to the inherited (parent) selectors. This can be done by putting the `&` after current selector. For example, when using Modernizr, you might want to specify different rules based on supported features:\n\n    .header {\n      .menu {\n        border-radius: 5px;\n        .no-borderradius & {\n          background-image: url('images/button-background.png');\n        }\n      }\n    }\n\nThe selector `.no-borderradius &` will prepend `.no-borderradius` to its parent `.header .menu` to form the`.no-borderradius .header .menu` on output:\n\n    .header .menu {\n      border-radius: 5px;\n    }\n    .no-borderradius .header .menu {\n      background-image: url('images/button-background.png');\n    }\n\n### Combinatorial Explosion\n\n`&` can also be used to generate every possible permutation of selectors in a comma separated list:\n\n    p, a, ul, li {\n      border-top: 2px dotted #366;\n      & + & {\n        border-top: 0;\n      }\n    }\n\nThis expands to all possible (16) combinations of the specified elements:\n\n    p,\n    a,\n    ul,\n    li {\n      border-top: 2px dotted #366;\n    }\n    p + p,\n    p + a,\n    p + ul,\n    p + li,\n    a + p,\n    a + a,\n    a + ul,\n    a + li,\n    ul + p,\n    ul + a,\n    ul + ul,\n    ul + li,\n    li + p,\n    li + a,\n    li + ul,\n    li + li {\n      border-top: 0;\n    }\n\n## Extend\n\nExtend is a Less pseudo-class which merges the selector it is put on with ones that match what it references.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\n    nav ul {\n      &:extend(.inline);\n      background: blue;\n    }\n\nIn the rule set above, the `:extend` selector will apply the \"extending selector\" (`nav ul`) onto the `.inline` class *wherever the `.inline` class appears*. The declaration block will be kept as-is, but without any reference to the extend (because extend isn't css).\n\nSo the following:\n\n    nav ul {\n      &:extend(.inline);\n      background: blue;\n    }\n    .inline {\n      color: red;\n    }\n\nOutputs\n\n    nav ul {\n      background: blue;\n    }\n    .inline,\n    nav ul {\n      color: red;\n    }\n\nNotice how the `nav ul:extend(.inline)` selector gets output as `nav ul` - the extend gets removed before output and the selector block left as-is. If no properties are put in that block then it gets removed from the output (but the extend still may affect other selectors).\n\n### Extend Syntax\n\nThe extend is either attached to a selector or placed into a ruleset. It looks like a pseudo-class with selector parameter optionally followed by the keyword `all`:\n\nExample:\n\n    .a:extend(.b) {}\n\n    // the above block does the same thing as the below block\n    .a {\n      &:extend(.b);\n    }\n\n    .c:extend(.d all) {\n      // extends all instances of \".d\" e.g. \".x.d\" or \".d.x\"\n    }\n    .c:extend(.d) {\n      // extends only instances where the selector will be output as just \".d\"\n    }\n\nIt can contain one or more classes to extend, separated by commas.\n\nExample:\n\n    .e:extend(.f) {}\n    .e:extend(.g) {}\n\n    // the above and the below do the same thing\n    .e:extend(.f, .g) {}\n\n### Extend Attached to Selector\n\nExtend attached to a selector looks like an ordinary pseudo-class with selector as a parameter. A selector can contain multiple extend clauses, but all extends must be at the end of the selector.\n\n- Extend after the selector: `pre:hover:extend(div pre)`.\n- Space between selector and extend is allowed: `pre:hover :extend(div pre)`.\n- Multiple extends are allowed: `pre:hover:extend(div pre):extend(.bucket tr)` - Note this is the same as `pre:hover:extend(div pre, .bucket tr)`\n- This is NOT allowed: `pre:hover:extend(div pre).nth-child(odd)`. Extend must be last.\n\nIf a ruleset contains multiple selectors, any of them can have the extend keyword. Multiple selectors with extend in one ruleset:\n\n    .big-division,\n    .big-bag:extend(.bag),\n    .big-bucket:extend(.bucket) {\n      // body\n    }\n\n### Extend Inside Ruleset\n\nExtend can be placed into a ruleset's body using `&:extend(selector)` syntax. Placing extend into a body is a shortcut for placing it into every single selector of that ruleset.\n\nExtend inside a body:\n\n    pre:hover,\n    .some-class {\n      &:extend(div pre);\n    }\n\nis exactly the same as adding an extend after each selector:\n\n    pre:hover:extend(div pre),\n    .some-class:extend(div pre) {}\n\n### Extending Nested Selectors\n\nExtend is able to match nested selectors. Following less:\n\nExample:\n\n    .bucket {\n      tr { // nested ruleset with target selector\n        color: blue;\n      }\n    }\n    .some-class:extend(.bucket tr) {} // nested ruleset is recognized\n\nOutputs\n\n    .bucket tr,\n    .some-class {\n      color: blue;\n    }\n\nEssentially the extend looks at the compiled css, not the original less.\n\nExample:\n\n    .bucket {\n      tr & { // nested ruleset with target selector\n        color: blue;\n      }\n    }\n    .some-class:extend(tr .bucket) {} // nested ruleset is recognized\n\nOutputs\n\n    tr .bucket,\n    .some-class {\n      color: blue;\n    }\n\n### Exact Matching with Extend\n\nExtend by default looks for exact match between selectors. It does matter whether selector uses leading star or not. It does not matter that two nth-expressions have the same meaning, they need to have to same form in order to be matched. The only exception are quotes in attribute selector, less knows they have the same meaning and matches them.\n\nExample:\n\n    .a.class,\n    .class.a,\n    .class > .a {\n      color: blue;\n    }\n    .test:extend(.class) {} // this will NOT match the any selectors above\n\nLeading star does matter. Selectors `*.class` and `.class` are equivalent, but extend will not match them:\n\n    *.class {\n      color: blue;\n    }\n    .noStar:extend(.class) {} // this will NOT match the *.class selector\n\nOutputs\n\n    *.class {\n      color: blue;\n    }\n\nOrder of pseudo-classes does matter. Selectors `link:hover:visited` and `link:visited:hover` match the same set of elements, but extend treats them as different:\n\n    link:hover:visited {\n      color: blue;\n    }\n    .selector:extend(link:visited:hover) {}\n\nOutputs\n\n    link:hover:visited {\n      color: blue;\n    }\n\n### nth Expression\n\nNth expression form does matter. Nth-expressions `1n+3` and `n+3` are equivalent, but extend will not match them:\n\n    :nth-child(1n+3) {\n      color: blue;\n    }\n    .child:extend(:nth-child(n+3)) {}\n\nOutputs\n\n    :nth-child(1n+3) {\n      color: blue;\n    }\n\nQuote type in attribute selector does not matter. All of the following are equivalent.\n\n    [title=identifier] {\n      color: blue;\n    }\n    [title='identifier'] {\n      color: blue;\n    }\n    [title=\"identifier\"] {\n      color: blue;\n    }\n\n    .noQuote:extend([title=identifier]) {}\n    .singleQuote:extend([title='identifier']) {}\n    .doubleQuote:extend([title=\"identifier\"]) {}\n\nOutputs\n\n    [title=identifier],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n    [title='identifier'],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n    [title=\"identifier\"],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n### Extend \"all\"\n\nWhen you specify the all keyword last in an extend argument it tells Less to match that selector as part of another selector. The selector will be copied and the matched part of the selector only will then be replaced with the extend, making a new selector.\n\nExample:\n\n    .a.b.test,\n    .test.c {\n      color: orange;\n    }\n    .test {\n      &:hover {\n        color: green;\n      }\n    }\n\n    .replacement:extend(.test all) {}\n\nOutputs\n\n    .a.b.test,\n    .test.c,\n    .a.b.replacement,\n    .replacement.c {\n      color: orange;\n    }\n    .test:hover,\n    .replacement:hover {\n      color: green;\n    }\n\n*You can think of this mode of operation as essentially doing a non-destructive search and replace.*\n\n### Selector Interpolation with Extend\n\nExtend is **not** able to match selectors with variables. If selector contains variable, extend will ignore it.\n\nHowever, extend can be attached to interpolated selector.\n\nSelector with variable will not be matched:\n\n    @variable: .bucket;\n    @{variable} { // interpolated selector\n      color: blue;\n    }\n    .some-class:extend(.bucket) {} // does nothing, no match is found\n\nand extend with variable in target selector matches nothing:\n\n    .bucket {\n      color: blue;\n    }\n    .some-class:extend(@{variable}) {} // interpolated selector matches nothing\n    @variable: .bucket;\n\nBoth of the above examples compile into:\n\n    .bucket {\n      color: blue;\n    }\n\nHowever, `:extend` attached to an interpolated selector works:\n\n    .bucket {\n      color: blue;\n    }\n    @{variable}:extend(.bucket) {}\n    @variable: .selector;\n\ncompiles to:\n\n    .bucket, .selector {\n      color: blue;\n    }\n\n### Scoping / Extend Inside @media\n\nCurrently, an `:extend` inside a `@media` declaration will only match selectors inside the same media declaration:\n\n    @media print {\n      .screenClass:extend(.selector) {} // extend inside media\n      .selector { // this will be matched - it is in the same media\n        color: black;\n      }\n    }\n    .selector { // ruleset on top of style sheet - extend ignores it\n      color: red;\n    }\n    @media screen {\n      .selector {  // ruleset inside another media - extend ignores it\n        color: blue;\n      }\n    }\n\ncompiles into:\n\n    @media print {\n      .selector,\n      .screenClass { /*  ruleset inside the same media was extended */\n        color: black;\n      }\n    }\n    .selector { /* ruleset on top of style sheet was ignored */\n      color: red;\n    }\n    @media screen {\n      .selector { /* ruleset inside another media was ignored */\n        color: blue;\n      }\n    }\n\nNote: extending does not match selectors inside a nested `@media` declaration:\n\n    @media screen {\n      .screenClass:extend(.selector) {} // extend inside media\n      @media (min-width: 1023px) {\n        .selector {  // ruleset inside nested media - extend ignores it\n          color: blue;\n        }\n      }\n    }\n\nThis compiles into:\n\n    @media screen and (min-width: 1023px) {\n      .selector { /* ruleset inside another nested media was ignored */\n        color: blue;\n      }\n    }\n\nTop level extend matches everything including selectors inside nested media:\n\n    @media screen {\n      .selector {  /* ruleset inside nested media - top level extend works */\n        color: blue;\n      }\n      @media (min-width: 1023px) {\n        .selector {  /* ruleset inside nested media - top level extend works */\n          color: blue;\n        }\n      }\n    }\n\n    .topLevel:extend(.selector) {} /* top level extend matches everything */\n\ncompiles into:\n\n    @media screen {\n      .selector,\n      .topLevel { /* ruleset inside media was extended */\n        color: blue;\n      }\n    }\n    @media screen and (min-width: 1023px) {\n      .selector,\n      .topLevel { /* ruleset inside nested media was extended */\n        color: blue;\n      }\n    }\n\n### Duplication Detection\n\nCurrently there is no duplication detection.\n\nExample:\n\n    .alert-info,\n    .widget {\n      /* declarations */\n    }\n\n    .alert:extend(.alert-info, .widget) {}\n\nOutputs\n\n    .alert-info,\n    .widget,\n    .alert,\n    .alert {\n      /* declarations */\n    }\n\n### Use Cases for Extend\n\n### Classic Use Case\n\nThe classic use case is to avoid adding a base class. For example, if you have\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n\nand you want to have a subtype of animal which overrides the background color then you have two options, firstly change your HTML\n\n    <a class=\"animal bear\">Bear</a>\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n    .bear {\n      background-color: brown;\n    }\n\nor have simplified html and use extend in your less. e.g.\n\n    <a class=\"bear\">Bear</a>\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n    .bear {\n      &:extend(.animal);\n      background-color: brown;\n    }\n\n### Reducing CSS Size\n\nMixins copy all of the properties into a selector, which can lead to unnecessary duplication. Therefore you can use extends instead of mixins to move the selector up to the properties you wish to use, which leads to less CSS being generated.\n\nExample - with mixin:\n\n    .my-inline-block() {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing1 {\n      .my-inline-block;\n    }\n    .thing2 {\n      .my-inline-block;\n    }\n\nOutputs\n\n    .thing1 {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing2 {\n      display: inline-block;\n      font-size: 0;\n    }\n\nExample (with extends):\n\n    .my-inline-block {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing1 {\n      &:extend(.my-inline-block);\n    }\n    .thing2 {\n      &:extend(.my-inline-block);\n    }\n\nOutputs\n\n    .my-inline-block,\n    .thing1,\n    .thing2 {\n      display: inline-block;\n      font-size: 0;\n    }\n\n### Combining Styles / A More Advanced Mixin\n\nAnother use-case is as an alternative for a mixin - because mixins can only be used with simple selectors, if you have two different blocks of html, but need to apply the same styles to both you can use extends to relate two areas.\n\nExample:\n\n    li.list > a {\n      // list styles\n    }\n    button.list-style {\n      &:extend(li.list > a); // use the same list styles\n    }\n\n## Merge\n\nCombine properties\n\nThe `merge` feature allows for aggregating values from multiple properties into a comma or space separated list under a single property. `merge` is useful for properties such as background and transform.\n\n### Comma\n\nAppend property value with comma\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    .mixin() {\n      box-shadow+: inset 0 0 10px #555;\n    }\n    .myclass {\n      .mixin();\n      box-shadow+: 0 0 20px black;\n    }\n\nOutputs\n\n    .myclass {\n      box-shadow: inset 0 0 10px #555, 0 0 20px black;\n    }\n\n### Space\n\nAppend property value with space\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    .mixin() {\n      transform+_: scale(2);\n    }\n    .myclass {\n      .mixin();\n      transform+_: rotate(15deg);\n    }\n\nOutputs\n\n    .myclass {\n      transform: scale(2) rotate(15deg);\n    }\n\nTo avoid any unintentional joins, `merge` requires an explicit `+` or `+_` flag on each join pending declaration.\n\n## Mixins\n\n\"mix-in\" properties from existing styles\n\nYou can mix-in class selectors and id selectors, e.g.\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      .a();\n    }\n    .mixin-id {\n      #b();\n    }\n\nwhich results in:\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      color: red;\n    }\n    .mixin-id {\n      color: red;\n    }\n\nHistorically, the parentheses in a mixin call are optional, but optional parentheses are deprecated and will be required in a future release.\n\n    .a(); \n    .a;    // currently works, but deprecated; don't use\n    .a (); // white-space before parentheses is also deprecated\n\n### Mixins With Parentheses\n\nIf you want to create a mixin but you do not want that mixin to be in your CSS output, put parentheses after the mixin definition.\n\n    .my-mixin {\n      color: black;\n    }\n    .my-other-mixin() {\n      background: white;\n    }\n    .class {\n      .my-mixin();\n      .my-other-mixin();\n    }\n\noutputs\n\n    .my-mixin {\n      color: black;\n    }\n    .class {\n      color: black;\n      background: white;\n    }\n\n### Selectors in Mixins\n\nMixins can contain more than just properties, they can contain selectors too.\n\nFor example:\n\n    .my-hover-mixin() {\n      &:hover {\n        border: 1px solid red;\n      }\n    }\n    button {\n      .my-hover-mixin();\n    }\n\nOutputs\n\n    button:hover {\n      border: 1px solid red;\n    }\n\n### Namespaces\n\nIf you want to mixin properties inside a more complicated selector, you can stack up multiple ids or classes.\n\n    #outer() {\n      .inner {\n        color: red;\n      }\n    }\n\n    .c {\n      #outer.inner();\n    }\n\nNote: legacy Less syntax allows `>` and whitespace between namespaces and mixins. This syntax is deprecated and may be removed. Currently, these do the same thing.\n\n    #outer > .inner(); // deprecated\n    #outer .inner();   // deprecated\n    #outer.inner();    // preferred\n\nNamespacing your mixins like this reduces conflicts with other library mixins or user mixins, but can also be a way to \"organize\" groups of mixins.\n\nExample:\n\n    #my-library {\n      .my-mixin() {\n        color: black;\n      }\n    }\n    // which can be used like this\n    .class {\n      #my-library.my-mixin();\n    }\n\n### Guarded Namespaces\n\nIf a namespace has a guard, mixins defined by it are used only if the guard condition returns true. A namespace guard is evaluated exactly the same as a guard on a mixin, so the following two mixins work the same way:\n\n    #namespace when (@mode = huge) {\n      .mixin() { /* */ }\n    }\n\n    #namespace {\n      .mixin() when (@mode = huge) { /* */ }\n    }\n\nThe `default` function is assumed to have the same value for all nested namespaces and mixin. The following mixin is never evaluated; one of its guards is guaranteed to be false:\n\n    #sp_1 when (default()) {\n      #sp_2 when (default()) {\n        .mixin() when not(default()) { /* */ }\n      }\n    }\n\n### The `!important` keyword\n\nUse the `!important` keyword after mixin call to mark all properties inherited by it as `!important`:\n\nExample:\n\n    .foo (@bg: #f5f5f5; @color: #900) {\n      background: @bg;\n      color: @color;\n    }\n    .unimportant {\n      .foo();\n    }\n    .important {\n      .foo() !important;\n    }\n\nResults in:\n\n    .unimportant {\n      background: #f5f5f5;\n      color: #900;\n    }\n    .important {\n      background: #f5f5f5 !important;\n      color: #900 !important;\n    }\n\n### Parametric Mixins\n\nHow to pass arguments to mixins\n\nMixins can also take arguments, which are variables passed to the block of selectors when it is mixed in.\n\nFor example:\n\n    .border-radius(@radius) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nAnd here's how we can mix it into various rulesets:\n\n    #header {\n      .border-radius(4px);\n    }\n    .button {\n      .border-radius(6px);\n    }\n\nParametric mixins can also have default values for their parameters:\n\n    .border-radius(@radius: 5px) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nWe can invoke it like this now:\n\n    #header {\n      .border-radius();\n    }\n\nAnd it will include a 5px border-radius.\n\nYou can also use parametric mixins which don't take parameters. This is useful if you want to hide the ruleset from the CSS output, but want to include its properties in other rulesets:\n\n    .wrap() {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n    pre { .wrap() }\n\nWhich would output:\n\n    pre {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n### Parameter separators\n\nParameters are currently either *semicolon* or *comma* separated.\n\nOriginally, parameters were only separated by commas, but the semi-colon was later added to support passing comma-separated list values to single arguments.\n\n- two arguments and each contains comma separated list: `.name(1, 2, 3; something, else)`,\n- three arguments and each contains one number: `.name(1, 2, 3)`,\n- use dummy semicolon to create mixin call with one argument containing comma separated css list: `.name(1, 2, 3;)`,\n- comma separated default value: `.name(@param1: red, blue;)`.\n- As of Less 4.0, you can wrap a list value using a paren escape \\[`~()`\\], e.g. `.name(@param1: ~(red, blue))`. This is similar to the quote escape syntax: `~\"quote\"`\n\n### Overloading mixins\n\nIt is legal to define multiple mixins with the same name and number of parameters. Less will use properties of all that can apply. If you used the mixin with one parameter e.g. `.mixin(green);`, then properties of all mixins with exactly one mandatory parameter will be used:\n\n    .mixin(@color) {\n      color-1: @color;\n    }\n    .mixin(@color, @padding: 2) {\n      color-2: @color;\n      padding-2: @padding;\n    }\n    .mixin(@color, @padding, @margin: 2) {\n      color-3: @color;\n      padding-3: @padding;\n      margin: @margin @margin @margin @margin;\n    }\n    .some .selector div {\n      .mixin(#008000);\n    }\n\ncompiles into:\n\n    .some .selector div {\n      color-1: #008000;\n      color-2: #008000;\n      padding-2: 2;\n    }\n\n### Named Parameters\n\nA mixin reference can supply parameters values by their names instead of just positions. Any parameter can be referenced by its name and they do not have to be in any special order:\n\n    .mixin(@color: black; @margin: 10px; @padding: 20px) {\n      color: @color;\n      margin: @margin;\n      padding: @padding;\n    }\n    .class1 {\n      .mixin(@margin: 20px; @color: #33acfe);\n    }\n    .class2 {\n      .mixin(#efca44; @padding: 40px);\n    }\n\ncompiles into:\n\n    .class1 {\n      color: #33acfe;\n      margin: 20px;\n      padding: 20px;\n    }\n    .class2 {\n      color: #efca44;\n      margin: 10px;\n      padding: 40px;\n    }\n\n### The `@arguments` Variable\n\n`@arguments` has a special meaning inside mixins, it contains all the arguments passed, when the mixin was called. This is useful if you don't want to deal with individual parameters:\n\n    .box-shadow(@x: 0, @y: 0, @blur: 1px, @color: #000) {\n      -webkit-box-shadow: @arguments;\n         -moz-box-shadow: @arguments;\n              box-shadow: @arguments;\n    }\n    .big-block {\n      .box-shadow(2px, 5px);\n    }\n\nWhich results in:\n\n    .big-block {\n      -webkit-box-shadow: 2px 5px 1px #000;\n         -moz-box-shadow: 2px 5px 1px #000;\n              box-shadow: 2px 5px 1px #000;\n    }\n\n### Advanced Arguments and the `@rest` Variable\n\nYou can use `...` if you want your mixin to take a variable number of arguments. Using this after a variable name will assign those arguments to the variable.\n\n    .mixin(...) {        // matches 0-N arguments\n    .mixin() {           // matches exactly 0 arguments\n    .mixin(@a: 1) {      // matches 0-1 arguments\n    .mixin(@a: 1, ...) { // matches 0-N arguments\n    .mixin(@a, ...) {    // matches 1-N arguments\n\nFurthermore:\n\n    .mixin(@a, @rest...) {\n       // @rest is bound to arguments after @a\n       // @arguments is bound to all arguments\n    }\n\n### Pattern-matching\n\nSometimes, you may want to change the behavior of a mixin, based on the parameters you pass to it. Let's start with something basic:\n\n    .mixin(@s, @color) { ... }\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nNow let's say we want `.mixin` to behave differently, based on the value of `@switch`, we could define `.mixin` as such:\n\n    .mixin(dark, @color) {\n      color: darken(@color, 10%);\n    }\n    .mixin(light, @color) {\n      color: lighten(@color, 10%);\n    }\n    .mixin(@_, @color) {\n      display: block;\n    }\n\nNow, if we run:\n\n    @switch: light;\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nWe will get the following CSS:\n\n    .class {\n      color: #a2a2a2;\n      display: block;\n    }\n\nWhere the color passed to `.mixin` was lightened. If the value of `@switch` was `dark`, the result would be a darker color.\n\nHere's what happened:\n\n- The first mixin definition didn't match because it expected `dark` as the first argument.\n- The second mixin definition matched, because it expected `light`.\n- The third mixin definition matched because it expected any value.\n\nOnly mixin definitions which matched were used. Variables match and bind to any value. Anything other than a variable matches only with a value equal to itself.\n\nWe can also match on arity, here's an example:\n\n    .mixin(@a) {\n      color: @a;\n    }\n    .mixin(@a, @b) {\n      color: fade(@a, @b);\n    }\n\nNow if we call `.mixin` with a single argument, we will get the output of the first definition, but if we call it with *two* arguments, we will get the second definition, namely `@a` faded to `@b`.\n\n### Using Mixins as Functions\n\nSelecting properties and variables from mixin calls\n\n### Property / value accessors\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors to select a value from an evaluated mixin's rules. This can allow you to use mixins similar to functions.\n\nExample:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its \"@result\" value\n      padding: .average(16px, 50px)[@result];\n    }\n\nResults in:\n\n    div {\n      padding: 33px;\n    }\n\n### Overriding mixin values\n\nIf you have multiple matching mixins, all rules are evaluated and merged, and the last matching value with that identifier is returned. This is similar to the cascade in CSS, and it allows you to \"override\" mixin values.\n\n    // library.less\n    #library() {\n      .mixin() {\n        prop: foo;\n      }\n    }\n\n    // customize.less\n    @import \"library\";\n    #library() {\n      .mixin() {\n        prop: bar;\n      }\n    }\n\n    .box {\n      my-value: #library.mixin[prop];\n    }\n\nOutputs:\n\n    .box {\n      my-value: bar;\n    }\n\n### Unnamed lookups\n\nIf you don't specify a lookup value in `[@lookup]` and instead write `[]` after a mixin or ruleset call, *all* values will cascade and the last declared value will be selected.\n\nMeaning: the averaging mixin from the above example could be written as:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its final value\n      padding: .average(16px, 50px)[];\n    }\n\nThe output is the same:\n\n    div {\n      padding: 33px;\n    }\n\nThe same cascading behavior is true for rulesets or variables aliased to mixin calls.\n\n    @dr: {\n      value: foo;\n    }\n    .box {\n      my-value: @dr[];\n    }\n\nThis outputs:\n\n    .box {\n      my-value: foo;\n    }\n\n### Unlocking mixins & variables into caller scope\n\n***DEPRECATED - Use Property / Value Accessors***\n\nVariables and mixins defined in a mixin are visible and can be used in caller's scope. There is only one exception: a variable is not copied if the caller contains a variable with the same name (that includes variables defined by another mixin call). Only variables present in callers local scope are protected. Variables inherited from parent scopes are overridden.\n\n*Note: this behavior is deprecated, and in the future, variables and mixins will not be merged into the caller scope in this way.*\n\nExample:\n\n    .mixin() {\n      @width:  100%;\n      @height: 200px;\n    }\n\n    .caller {\n      .mixin();\n      width:  @width;\n      height: @height;\n    }\n\nResults in:\n\n    .caller {\n      width:  100%;\n      height: 200px;\n    }\n\nVariables defined directly in callers scope cannot be overridden. However, variables defined in callers parent scope is not protected and will be overridden:\n\n    .mixin() {\n      @size: in-mixin;\n      @definedOnlyInMixin: in-mixin;\n    }\n\n    .class {\n      margin: @size @definedOnlyInMixin;\n      .mixin();\n    }\n\n    @size: globaly-defined-value; // callers parent scope - no protection\n\nResults in:\n\n    .class {\n      margin: in-mixin in-mixin;\n    }\n\nFinally, mixin defined in mixin acts as return value too:\n\n    .unlock(@value) { // outer mixin\n      .doSomething() { // nested mixin\n        declaration: @value;\n      }\n    }\n\n    #namespace {\n      .unlock(5); // unlock doSomething mixin\n      .doSomething(); //nested mixin was copied here and is usable\n    }\n\nResults in:\n\n    #namespace {\n      declaration: 5;\n    }\n\n### Recursive Mixins\n\nCreating loops\n\nIn Less a mixin can call itself. Such recursive mixins, when combined with [Guard Expressions](#mixin-guards-feature) and [Pattern Matching](#mixins-parametric-feature-pattern-matching), can be used to create various iterative/loop structures.\n\nExample:\n\n    .loop(@counter) when (@counter > 0) {\n      .loop((@counter - 1));    // next iteration\n      width: (10px * @counter); // code for each iteration\n    }\n\n    div {\n      .loop(5); // launch the loop\n    }\n\nOutput:\n\n    div {\n      width: 10px;\n      width: 20px;\n      width: 30px;\n      width: 40px;\n      width: 50px;\n    }\n\nA generic example of using a recursive loop to generate CSS grid classes:\n\n    .generate-columns(4);\n\n    .generate-columns(@n, @i: 1) when (@i =< @n) {\n      .column-@{i} {\n        width: (@i * 100% / @n);\n      }\n      .generate-columns(@n, (@i + 1));\n    }\n\nOutput:\n\n    .column-1 {\n      width: 25%;\n    }\n    .column-2 {\n      width: 50%;\n    }\n    .column-3 {\n      width: 75%;\n    }\n    .column-4 {\n      width: 100%;\n    }\n\n### Mixin Guards\n\nGuards are useful when you want to match on *expressions*, as opposed to simple values or arity. If you are familiar with functional programming, you have probably encountered them already.\n\nIn trying to stay as close as possible to the declarative nature of CSS, Less has opted to implement conditional execution via **guarded mixins** instead of `if`/`else` statements, in the vein of `@media` query feature specifications.\n\nLet's start with an example:\n\n    .mixin(@a) when (lightness(@a) >= 50%) {\n      background-color: black;\n    }\n    .mixin(@a) when (lightness(@a) < 50%) {\n      background-color: white;\n    }\n    .mixin(@a) {\n      color: @a;\n    }\n\nThe key is the `when` keyword, which introduces a guard sequence (here with only one guard). Now if we run the following code:\n\n    .class1 { .mixin(#ddd) }\n    .class2 { .mixin(#555) }\n\nHere's what we'll get:\n\n    .class1 {\n      background-color: black;\n      color: #ddd;\n    }\n    .class2 {\n      background-color: white;\n      color: #555;\n    }\n\n### Guard Comparison Operators\n\nThe full list of comparison operators usable in guards are: `>`, `>=`, `=`, `=<`, `<`. Additionally, the keyword `true` is the only truthy value, making these two mixins equivalent:\n\n    .truth(@a) when (@a) { ... }\n    .truth(@a) when (@a = true) { ... }\n\nAny value other than the keyword `true` is falsy:\n\n    .class {\n      .truth(40); // Will not match any of the above definitions.\n    }\n\nNote that you can also compare arguments with each other, or with non-arguments:\n\n    @media: mobile;\n\n    .mixin(@a) when (@media = mobile) { ... }\n    .mixin(@a) when (@media = desktop) { ... }\n\n    .max(@a; @b) when (@a > @b) { width: @a }\n    .max(@a; @b) when (@a < @b) { width: @b }\n\n### Guard Logical Operators\n\nYou can use logical operators with guards. The syntax is based on CSS media queries.\n\nUse the `and` keyword to combine guards:\n\n    .mixin(@a) when (isnumber(@a)) and (@a > 0) { ... }\n\nYou can emulate the *or* operator by separating guards with a comma `,`. If any of the guards evaluate to true, it's considered a match:\n\n    .mixin(@a) when (@a > 10), (@a < -10) { ... }\n\nUse the `not` keyword to negate conditions:\n\n    .mixin(@b) when not (@b > 0) { ... }\n\n### Type Checking Functions\n\nLastly, if you want to match mixins based on value type, you can use the `is` functions:\n\n    .mixin(@a; @b: 0) when (isnumber(@b)) { ... }\n    .mixin(@a; @b: black) when (iscolor(@b)) { ... }\n\nHere are the basic type checking functions:\n\n- `iscolor`\n- `isnumber`\n- `isstring`\n- `iskeyword`\n- `isurl`\n\nIf you want to check if a value is in a specific unit in addition to being a number, you may use one of:\n\n- `ispixel`\n- `ispercentage`\n- `isem`\n- `isunit`\n\n### Aliasing Mixins\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nAssigning mixin calls to a variable\n\nMixins can be assigned to a variable to be called as a variable call, or can be used for map lookup.\n\n    #theme.dark.navbar {\n      .colors(light) {\n        primary: purple;\n      }\n      .colors(dark) {\n        primary: black;\n        secondary: grey;\n      }\n    }\n\n    .navbar {\n      @colors: #theme.dark.navbar.colors(dark);\n      background: @colors[primary];\n      border: 1px solid @colors[secondary];\n    }\n\nThis would output:\n\n    .navbar {\n      background: black;\n      border: 1px solid grey;\n    }\n\n### Variable calls\n\nEntire mixin calls can be aliased and called as variable calls. As in:\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors();\n      @alias();\n    }\n\nOutputs:\n\n    .box {\n      background: green;\n    }\n\nNote, unlike mixins used in root, mixin calls assigned to variables and *called with no arguments* always require parentheses. The following is not valid.\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors;\n      @alias();   // ERROR: Could not evaluate variable call @alias\n    }\n\nThis is because it's ambiguous if variable is assigned a list of selectors or a mixin call. For example, in Less 3.5+, this variable could be used this way.\n\n    .box {\n      @alias: #library.colors;\n      @{alias} {\n        a: b;\n      }\n    }\n\nThe above would output:\n\n    .box #library.colors {\n      a: b;\n    }\n\n## CSS Guards\n\n\"if\"'s around selectors\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nLike Mixin Guards, guards can also be applied to css selectors, which is syntactic sugar for declaring the mixin and then calling it immediately.\n\nFor instance, before 1.5.0 you would have had to do this:\n\n    .my-optional-style() when (@my-option = true) {\n      button {\n        color: white;\n      }\n    }\n    .my-optional-style();\n\nNow, you can apply the guard directly to a style.\n\n    button when (@my-option = true) {\n      color: white;\n    }\n\nYou can also achieve an `if` type statement by combining this with the `&` feature, allowing you to group multiple guards.\n\n    & when (@my-option = true) {\n      button {\n        color: white;\n      }\n      a {\n        color: blue;\n      }\n    }\n\nNote that you can also achieve a similar pattern by using the actual `if()` function and a variable call. As in:\n\n    @dr: if(@my-option = true, {\n      button {\n        color: white;\n      }\n      a {\n        color: blue;\n      }\n    });\n    @dr();\n\n## Detached Rulesets\n\nAssign a ruleset to a variable\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nA detached ruleset is a group of css properties, nested rulesets, media declarations or anything else stored in a variable. You can include it into a ruleset or another structure and all its properties are going to be copied there. You can also use it as a mixin argument and pass it around as any other variable.\n\nSimple example:\n\n    // declare detached ruleset\n    @detached-ruleset: { background: red; }; // semi-colon is optional in 3.5.0+\n\n    // use detached ruleset\n    .top {\n        @detached-ruleset(); \n    }\n\ncompiles into:\n\n    .top {\n      background: red;\n    }\n\nParentheses after a detached ruleset call are mandatory (except when followed by a [lookup value](#detached-rulesets-feature-property-variable-accessors)). The call `@detached-ruleset;` would not work.\n\nIt is useful when you want to define a mixin that abstracts out either wrapping a piece of code in a media query or a non-supported browser class name. The rulesets can be passed to mixin so that the mixin can wrap the content, e.g.\n\n    .desktop-and-old-ie(@rules) {\n      @media screen and (min-width: 1200px) { @rules(); }\n      html.lt-ie9 &                         { @rules(); }\n    }\n\n    header {\n      background-color: blue;\n\n      .desktop-and-old-ie({\n        background-color: red;\n      });\n    }\n\nHere the `desktop-and-old-ie` mixin defines the media query and root class so that you can use a mixin to wrap a piece of code. This will output\n\n    header {\n      background-color: blue;\n    }\n    @media screen and (min-width: 1200px) {\n      header {\n        background-color: red;\n      }\n    }\n    html.lt-ie9 header {\n      background-color: red;\n    }\n\nA ruleset can be now assigned to a variable or passed in to a mixin and can contain the full set of Less features, e.g.\n\n    @my-ruleset: {\n        .my-selector {\n          background-color: black;\n        }\n      };\n\nYou can even take advantage of [media query bubbling](#features-overview-feature-media-query-bubbling-and-nested-media-queries), for instance\n\n    @my-ruleset: {\n        .my-selector {\n          @media tv {\n            background-color: black;\n          }\n        }\n      };\n    @media (orientation:portrait) {\n        @my-ruleset();\n    }\n\nwhich will output\n\n    @media (orientation: portrait) and tv {\n      .my-selector {\n        background-color: black;\n      }\n    }\n\nA detached ruleset call unlocks (returns) all its mixins into caller the same way as mixin calls do. However, it does **not** return variables.\n\nReturned mixin:\n\n    // detached ruleset with a mixin\n    @detached-ruleset: { \n        .mixin() {\n            color: blue;\n        }\n    };\n    // call detached ruleset\n    .caller {\n        @detached-ruleset(); \n        .mixin();\n    }\n\nResults in:\n\n    .caller {\n      color: blue;\n    }\n\nPrivate variables:\n\n    @detached-ruleset: { \n        @color:blue; // this variable is private\n    };\n    .caller {\n        color: @color; // syntax error\n    }\n\n### Scoping\n\nA detached ruleset can use all variables and mixins accessible where it is *defined* and where it is *called*. Otherwise said, both definition and caller scopes are available to it. If both scopes contains the same variable or mixin, declaration scope value takes precedence.\n\n*Declaration scope* is the one where detached ruleset body is defined. Copying a detached ruleset from one variable into another cannot modify its scope. The ruleset does not gain access to new scopes just by being referenced there.\n\nLastly, a detached ruleset can gain access to scope by being unlocked (imported) into it.\n\n*Note: unlocking variables into scope via a called mixin is deprecated. Use [property / variable accessors](#detached-rulesets-feature-property-variable-accessors).*\n\n### Definition and Caller Scope Visibility\n\nA detached ruleset sees the caller's variables and mixins:\n\n    @detached-ruleset: {\n      caller-variable: @caller-variable; // variable is undefined here\n      .caller-mixin(); // mixin is undefined here\n    };\n\n    selector {\n      // use detached ruleset\n      @detached-ruleset(); \n\n      // define variable and mixin needed inside the detached ruleset\n      @caller-variable: value;\n      .caller-mixin() {\n        variable: declaration;\n      }\n    }\n\ncompiles into:\n\n    selector {\n      caller-variable: value;\n      variable: declaration;\n    }\n\nVariable and mixins accessible from definition win over those available in the caller:\n\n    @variable: global;\n    @detached-ruleset: {\n      // will use global variable, because it is accessible\n      // from detached-ruleset definition\n      variable: @variable; \n    };\n\n    selector {\n      @detached-ruleset();\n      @variable: value; // variable defined in caller - will be ignored\n    }\n\ncompiles into:\n\n    selector {\n      variable: global;\n    }\n\n### Referencing *Won't* Modify Detached Ruleset Scope\n\nA ruleset does not gain access to new scopes just by being referenced there:\n\n    @detached-1: { scope-detached: @one @two; };\n    .one {\n      @one: visible;\n      .two {\n        @detached-2: @detached-1; // copying/renaming ruleset \n        @two: visible; // ruleset can not see this variable\n      }\n    }\n\n    .use-place {\n      .one > .two(); \n      @detached-2();\n    }\n\nthrows an error:\n\n    ERROR 1:32 The variable \"@one\" was not declared.\n\n### Unlocking *Will* Modify Detached Ruleset Scope\n\nA detached ruleset gains access by being unlocked (imported) inside a scope:\n\n    #space {\n      .importer-1() {\n        @detached: { scope-detached: @variable; }; // define detached ruleset\n      }\n    }\n\n    .importer-2() {\n      @variable: value; // unlocked detached ruleset CAN see this variable\n      #space > .importer-1(); // unlock/import detached ruleset\n    }\n\n    .use-place {\n      .importer-2(); // unlock/import detached ruleset second time\n       @detached();\n    }\n\ncompiles into:\n\n    .use-place {\n      scope-detached: value;\n    }\n\n### Property / variable accessors\n\n### (Lookup values)\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors (also called \"lookups\") to select a value from variable (detached) rulesets.\n\n    @config: {\n      option1: true;\n      option2: false;\n    }\n\n    .mixin() when (@config[option1] = true) {\n      selected: value;\n    }\n\n    .box {\n      .mixin();\n    }\n\nOutputs:\n\n    .box {\n      selected: value;\n    }\n\nIf what is returned from a lookup is another detached ruleset, you can use a second lookup to get that value.\n\n    @config: {\n      @colors: {\n        primary: blue;\n      }\n    }\n\n    .box {\n      color: @config[@colors][primary];\n    }\n\n### Variable variables in lookups\n\nThe lookup value that is returned can itself be variable. As in, you can write:\n\n    @config: {\n      @dark: {\n        primary: darkblue;\n      }\n      @light: {\n        primary: lightblue;\n      }\n    }\n\n    .box {\n      @lookup: dark;\n      color: @config[@@lookup][primary];\n    }\n\nThis will output:\n\n    .box {\n      color: darkblue;\n    }\n\n## @import At-Rules\n\nImport styles from other style sheets\n\nIn standard CSS, `@import` at-rules must precede all other types of rules. But Less doesn't care where you put `@import` statements.\n\nExample:\n\n    .foo {\n      background: #900;\n    }\n    @import \"this-is-valid.less\";\n\n### File Extensions\n\n`@import` statements may be treated differently by Less depending on the file extension:\n\n- If the file has a `.css` extension it will be treated as CSS and the `@import` statement left as-is (see the [inline option](#import-options-inline) below).\n- If it has *any other extension* it will be treated as Less and imported.\n- If it does not have an extension, `.less` will be appended and it will be included as a imported Less file.\n\nExamples:\n\n    @import \"foo\";      // foo.less is imported\n    @import \"foo.less\"; // foo.less is imported\n    @import \"foo.php\";  // foo.php imported as a Less file\n    @import \"foo.css\";  // statement left in place, as-is\n\nThe following options can be used to override this behavior.\n\n### Import Options\n\nLess offers several extensions to the CSS `@import` CSS at-rule to provide more flexibility over what you can do with external files.\n\nSyntax: `@import (keyword) \"filename\";`\n\nThe following import options have been implemented:\n\n- `reference`: use a Less file but do not output it\n- `inline`: include the source file in the output but do not process it\n- `less`: treat the file as a Less file, no matter what the file extension\n- `css`: treat the file as a CSS file, no matter what the file extension\n- `once`: only include the file once (this is default behavior)\n- `multiple`: include the file multiple times\n- `optional`: continue compiling when file is not found\n\nMore than one keyword per `@import` is allowed, you will have to use commas to separate the keywords:\n\nExample: `@import (optional, reference) \"foo.less\";`\n\n### reference\n\nUse `@import (reference)` to import external files, but without adding the imported styles to the compiled output unless referenced.\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample: `@import (reference) \"foo.less\";`\n\nImagine that `reference` marks every at-rule and selector with a *reference flag* in the imported file, imports as normal, but when the CSS is generated, \"reference\" selectors (as well as any media queries containing only reference selectors) are not output. `reference` styles will not show up in your generated CSS unless the reference styles are used as [mixins](#mixins-feature) or [extended](#extend-feature).\n\nAdditionally, **`reference`** produces different results depending on which method was used (mixin or extend):\n\n- **[extend](#extend-feature)**: When a selector is extended, only the new selector is marked as *not referenced*, and it is pulled in at the position of the reference `@import` statement.\n- **[mixins](#mixins-feature)**: When a `reference` style is used as an [implicit mixin](#mixins-feature), its rules are mixed-in, marked \"not reference\", and appear in the referenced place as normal.\n\n### reference example\n\nThis allows you to pull in only specific, targeted styles from a library such as [Bootstrap](https://github.com/twbs/bootstrap) by doing something like this:\n\n    .navbar:extend(.navbar all) {}\n\nAnd you will pull in only `.navbar` related styles from Bootstrap.\n\n### inline\n\nUse `@import (inline)` to include external files, but not process them.\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample: `@import (inline) \"not-less-compatible.css\";`\n\nYou will use this when a CSS file may not be Less compatible; this is because although Less supports most known standards CSS, it does not support comments in some places and does not support all known CSS hacks without modifying the CSS.\n\nSo you can use this to include the file in the output so that all CSS will be in one file.\n\n### less\n\nUse `@import (less)` to treat imported files as Less, regardless of file extension.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    @import (less) \"foo.css\";\n\n### css\n\nUse `@import (css)` to treat imported files as regular CSS, regardless of file extension. This means the import statement will be left as it is.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    @import (css) \"foo.less\";\n\noutputs\n\n    @import \"foo.less\";\n\n### once\n\nThe default behavior of `@import` statements. It means the file is imported only once and subsequent import statements for that file will be ignored.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nThis is the default behavior of `@import` statements.\n\nExample:\n\n    @import (once) \"foo.less\";\n    @import (once) \"foo.less\"; // this statement will be ignored\n\n### multiple\n\nUse `@import (multiple)` to allow importing of multiple files with the same name. This is the opposite behavior to once.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    // file: foo.less\n    .a {\n      color: green;\n    }\n    // file: main.less\n    @import (multiple) \"foo.less\";\n    @import (multiple) \"foo.less\";\n\nOutputs\n\n    .a {\n      color: green;\n    }\n    .a {\n      color: green;\n    }\n\n### optional\n\nUse `@import (optional)` to allow importing of a file only when it exists. Without the `optional` keyword Less throws a FileError and stops compiling when importing a file that can not be found.\n\nReleased [v2.3.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\n## @plugin At-Rules\n\nReleased [v2.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nImport JavaScript plugins to add Less.js functions and features\n\n### Writing your first plugin\n\nUsing a `@plugin` at-rule is similar to using an `@import` for your `.less` files.\n\n    @plugin \"my-plugin\";  // automatically appends .js if no extension\n\nSince Less plugins are evaluated within the Less scope, the plugin definition can be quite simple.\n\n    registerPlugin({\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    })\n\nor you can use `module.exports` (shimmed to work in browser as well as Node.js).\n\n    module.exports = {\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    };\n\nNote that other Node.js CommonJS conventions, like `require()` are not available in the browser. Keep this in mind when writing cross-platform plugins.\n\nWhat can you do with a plugin? A lot, but let's start with the basics. We'll focus first on what you might put inside the `install` function. Let's say you write this:\n\n    // my-plugin.js\n    install: function(less, pluginManager, functions) {\n        functions.add('pi', function() {\n            return Math.PI;\n        });\n    }\n    // etc\n\nCongratulations! You've written a Less plugin!\n\nIf you were to use this in your stylesheet:\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi();\n    }\n\nYou would get:\n\n    .show-me-pi {\n      value: 3.141592653589793;\n    }\n\nHowever, you would need to return a proper Less node if you wanted to, say, multiply that against other values or do other Less operations. Otherwise the output in your stylesheet is plain text (which may be fine for your purposes).\n\nMeaning, this is more correct:\n\n    functions.add('pi', function() {\n        return new tree.Dimension(Math.PI);\n    });\n\n*Note: A dimension is a number with or without a unit, like \"10px\", which would be `less.Dimension(10, \"px\")`. For a list of units, see the [Less API](todo).*\n\nNow you can use your function in operations.\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi() * 2;\n    }\n\nYou may have noticed that there are available globals for your plugin file, namely a function registry (`functions` object), and the `less` object. These are there for convenience.\n\n### Plugin Scope\n\nFunctions added by a `@plugin` at-rule adheres to Less scoping rules. This is great for Less library authors that want to add functionality without introducing naming conflicts.\n\nFor instance, say you have 2 plugins from two third-party libraries that both have a function named \"foo\".\n\n    // lib1.js\n    // ...\n        functions.add('foo', function() {\n            return \"foo\";\n        });\n    // ...\n\n    // lib2.js\n    // ...\n        functions.add('foo', function() {\n            return \"bar\";\n        });\n    // ...\n\nThat's ok! You can choose which library's function creates which output.\n\n    .el-1 {\n        @plugin \"lib1\";\n        value: foo();\n    }\n    .el-2 {\n        @plugin \"lib2\";\n        value: foo();\n    }\n\nThis will produce:\n\n    .el-1 {\n        value: foo;\n    }\n    .el-2 {\n        value: bar;\n    }\n\nFor plugin authors sharing their plugins, that means you can also effectively make private functions by placing them in a particular scope. As in, this will cause an error:\n\n    .el {\n        @plugin \"lib1\";\n    }\n    @value: foo();\n\nAs of Less 3.0, functions can return any kind of Node type, and can be called at any level.\n\nMeaning, this would throw an error in 2.x, as functions had to be part of the value of a property or variable assignment:\n\n    .block {\n        color: blue;\n        my-function-rules();\n    }\n\nIn 3.x, that's no longer the case, and functions can return At-Rules, Rulesets, any other Less node, strings, and numbers (the latter two are converted to Anonymous nodes).\n\n### Null Functions\n\nThere are times when you may want to call a function, but you don't want anything output (such as storing a value for later use). In that case, you just need to return `false` from the function.\n\n    var collection = [];\n\n    functions.add('store', function(val) {\n        collection.push(val);  // imma store this for later\n        return false;\n    });\n\n    @plugin \"collections\";\n    @var: 32;\n    store(@var);\n\nLater you could do something like:\n\n    functions.add('retrieve', function(val) {\n        return new tree.Value(collection);\n    });\n\n    .get-my-values {\n        @plugin \"collections\";\n        values: retrieve();   \n    }\n\n### The Less.js Plugin Object\n\nA Less.js plugin should export an object that has one or more of these properties.\n\n    {\n        /* Called immediately after the plugin is \n         * first imported, only once. */\n        install: function(less, pluginManager, functions) { },\n\n        /* Called for each instance of your @plugin. */\n        use: function(context) { },\n\n        /* Called for each instance of your @plugin, \n         * when rules are being evaluated.\n         * It's just later in the evaluation lifecycle */\n        eval: function(context) { },\n\n        /* Passes an arbitrary string to your plugin \n         * e.g. @plugin (args) \"file\";\n         * This string is not parsed for you, \n         * so it can contain (almost) anything */\n        setOptions: function(argumentString) { },\n\n        /* Set a minimum Less compatibility string\n         * You can also use an array, as in [3, 0] */\n        minVersion: ['3.0'],\n\n        /* Used for lessc only, to explain \n         * options in a Terminal */\n        printUsage: function() { },\n\n    }\n\nThe PluginManager instance for the `install()` function provides methods for adding visitors, file managers, and post-processors.\n\nHere are some example repos showing the different plugin types.\n\n- post-processor: <https://github.com/less/less-plugin-clean-css>\n- visitor: <https://github.com/less/less-plugin-inline-urls>\n- file-manager: <https://github.com/less/less-plugin-npm-import>\n\n### Pre-Loaded Plugins\n\nWhile a `@plugin` call works well for most scenarios, there are times when you might want to load a plugin before parsing starts.\n\nSee: [Pre-Loaded Plugins](usage#plugins) in the \"Using Less.js\" section for how to do that.\n\n## Maps (NEW!)\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nUse rulesets and mixins as maps of values\n\nBy combining namespacing with the lookup `[]` syntax, you can turn your rulesets / mixins into maps.\n\n    @sizes: {\n      mobile: 320px;\n      tablet: 768px;\n      desktop: 1024px;\n    }\n\n    .navbar {\n      display: block;\n\n      @media (min-width: @sizes[tablet]) {\n        display: inline-block;\n      }\n    }\n\nOutputs:\n\n    .navbar {\n      display: block;\n    }\n    @media (min-width: 768px) {\n      .navbar {\n        display: inline-block;\n      }\n    }\n\nMixins are a little more versatile as maps because of namespacing and the ability to overload mixins.\n\n    #library() {\n      .colors() {\n        primary: green;\n        secondary: blue;\n      }\n    }\n\n    #library() {\n      .colors() { primary: grey; }\n    }\n\n    .button {\n      color: #library.colors[primary];\n      border-color: #library.colors[secondary];\n    }\n\nOutputs:\n\n    .button {\n      color: grey;\n      border-color: blue;\n    }\n\nYou can also make this easier by [aliasing mixins](#mixins-feature-mixin-aliasing-feature). That is:\n\n    .button {\n      @colors: #library.colors();\n      color: @colors[primary];\n      border-color: @colors[secondary];\n    }\n\nNote, if a lookup value produces another ruleset, you can append a second `[]` lookup, as in:\n\n    @config: {\n      @options: {\n        library-on: true\n      }\n    }\n\n    & when (@config[@options][library-on] = true) {\n      .produce-ruleset {\n        prop: val;\n      }\n    }\n\nIn this way, rulesets and variable calls can emulate a type of \"namespacing\", similar to mixins.\n\nAs far as whether to use mixins or rulesets assigned to variables as maps, it's up to you. You may want to replace entire maps by re-declaring a variable assigned to a rulset. Or you may want to \"merge\" individual key/value pairs, in which case mixins as maps might be more appropriate.\n\n### Using variable variables in lookups\n\nOne important thing to notice is that the value in `[@lookup]` is the key (variable) name `@lookup`, and is not evaluated as a variable. If you want the key name itself to be variable, you can use the `@@variable` syntax.\n\nE.g.\n\n    .foods() {\n      @dessert: ice cream;\n    }\n\n    @key-to-lookup: dessert;\n\n    .lunch {\n      treat: .foods[@@key-to-lookup];\n    }\n\nThis would output:\n\n    .lunch {\n      treat: ice cream;\n    }\n\n© 2009–2020 The Core Less Team  \nLicensed under the Creative Commons Attribution License 3.0.  \n[http://lesscss.org/features](http://lesscss.org/features)"
- name: '@@var'
  id: index#variables-feature-variable-names
  summary: An in-depth guide to features of the LESS language
  description: "# Less\n\n## Overview\n\nAn in-depth guide to features of the LESS language. See the [Overview](http://lesscss.org/#overview) for a quick summary of Less.\n\n*For an in-depth guide to installing and setting up a Less environment, as well as documentation on developing for Less, see: [Using Less.js](usage).*\n\n## Variables\n\nControl commonly used values in a single location.\n\n### Overview\n\nIt's not uncommon to see the same value repeated dozens *if not hundreds of times* across your stylesheets:\n\n    a,\n    .link {\n      color: #428bca;\n    }\n    .widget {\n      color: #fff;\n      background: #428bca;\n    }\n\nVariables make your code easier to maintain by giving you a way to control those values from a single location:\n\n    // Variables\n    @link-color:        #428bca; // sea blue\n    @link-color-hover:  darken(@link-color, 10%);\n\n    // Usage\n    a,\n    .link {\n      color: @link-color;\n    }\n    a:hover {\n      color: @link-color-hover;\n    }\n    .widget {\n      color: #fff;\n      background: @link-color;\n    }\n\n### Variable Interpolation\n\nThe examples above focused on using variables to control *values in CSS rules*, but they can also be used in other places as well, such as selector names, property names, URLs and `@import` statements.\n\n### Selectors\n\n*v1.4.0*\n\n    // Variables\n    @my-selector: banner;\n\n    // Usage\n    .@{my-selector} {\n      font-weight: bold;\n      line-height: 40px;\n      margin: 0 auto;\n    }\n\nCompiles to:\n\n    .banner {\n      font-weight: bold;\n      line-height: 40px;\n      margin: 0 auto;\n    }\n\n### URLs\n\n    // Variables\n    @images: \"../img\";\n\n    // Usage\n    body {\n      color: #444;\n      background: url(\"@{images}/white-sand.png\");\n    }\n\n### Import Statements\n\n*v1.4.0*\n\nSyntax: `@import \"@{themes}/tidal-wave.less\";`\n\nNote that before v2.0.0, only variables which have been declared in the root or current scope were considered and that only the current file and calling files were considered when looking for a variable.\n\nExample:\n\n    // Variables\n    @themes: \"../../src/themes\";\n\n    // Usage\n    @import \"@{themes}/tidal-wave.less\";\n\n### Properties\n\n*v1.6.0*\n\n    @property: color;\n\n    .widget {\n      @{property}: #0ee;\n      background-@{property}: #999;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #0ee;\n      background-color: #999;\n    }\n\n### Variable Variables\n\nIn Less, you can define a variable's name using another variable.\n\n    @primary:  green;\n    @secondary: blue;\n\n    .section {\n      @color: primary;\n\n      .element {\n        color: @@color;\n      }\n    }\n\nWhich compiles to:\n\n    .section .element {\n      color: green;\n    }\n\n### Lazy Evaluation\n\nVariables do not have to be declared before being used.\n\nValid Less snippet:\n\n    .lazy-eval {\n      width: @var;\n    }\n\n    @var: @a;\n    @a: 9%;\n\nthis is valid Less too:\n\n    .lazy-eval {\n      width: @var;\n      @a: 9%;\n    }\n\n    @var: @a;\n    @a: 100%;\n\nboth compile into:\n\n    .lazy-eval {\n      width: 9%;\n    }\n\nWhen defining a variable twice, the last definition of the variable is used, searching from the current scope upwards. This is similar to css itself where the last property inside a definition is used to determine the value.\n\nFor instance:\n\n    @var: 0;\n    .class {\n      @var: 1;\n      .brass {\n        @var: 2;\n        three: @var;\n        @var: 3;\n      }\n      one: @var;\n    }\n\nCompiles to:\n\n    .class {\n      one: 1;\n    }\n    .class .brass {\n      three: 3;\n    }\n\nEssentially, each scope has a \"final\" value, similar to properties in the browser, like this example using custom properties:\n\n    .header {\n      --color: white;\n      color: var(--color);  // the color is black\n      --color: black;\n    }\n\nThis means that, unlike other CSS pre-processing languages, Less variables behave very much like CSS's.\n\n### Properties as Variables **(NEW!)**\n\n*v3.0.0*\n\nYou can easily treat properties like variables using the `$prop` syntax. Sometimes this can make your code a little lighter.\n\n    .widget {\n      color: #efefef;\n      background-color: $color;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #efefef;\n      background-color: #efefef;\n    }\n\nNote that, like variables, Less will choose the last property within the current/parent scope as being the \"final\" value.\n\n    .block {\n      color: red; \n      .inner {\n        background-color: $color; \n      }\n      color: blue;  \n    } \n\nCompiles to:\n\n    .block {\n      color: red; \n      color: blue;  \n    } \n    .block .inner {\n      background-color: blue; \n    }\n\n### Default Variables\n\nWe sometimes get requests for default variables - an ability to set a variable only if it is not already set. This feature is not required because you can easily override a variable by putting the definition afterwards.\n\nFor instance:\n\n    // library\n    @base-color: green;\n    @dark-color: darken(@base-color, 10%);\n\n    // use of library\n    @import \"library.less\";\n    @base-color: red;\n\nThis works fine because of [Lazy Loading](#variables-feature-lazy-loading) - `@base-color` is overridden and `@dark-color` is a dark red.\n\n## Parent Selectors\n\nReferencing parent selectors with `&`\n\nThe `&` operator represents the parent selectors of a [nested rule](#features-overview-feature-nested-rules) and is most commonly used when applying a modifying class or pseudo-class to an existing selector:\n\n    a {\n      color: blue;\n      &:hover {\n        color: green;\n      }\n    }\n\nresults in:\n\n    a {\n      color: blue;\n    }\n\n    a:hover {\n      color: green;\n    }\n\nNotice that without the `&`, the above example would result in `a :hover` rule (a descendant selector that matches hovered elements inside of `<a>` tags) and this is not what we typically would want with the nested `:hover`.\n\nThe \"parent selectors\" operator has a variety of uses. Basically any time you need the selectors of the nested rules to be combined in other ways than the default. For example another typical use of the `&` is to produce repetitive class names:\n\n    .button {\n      &-ok {\n        background-image: url(\"ok.png\");\n      }\n      &-cancel {\n        background-image: url(\"cancel.png\");\n      }\n\n      &-custom {\n        background-image: url(\"custom.png\");\n      }\n    }\n\noutput:\n\n    .button-ok {\n      background-image: url(\"ok.png\");\n    }\n    .button-cancel {\n      background-image: url(\"cancel.png\");\n    }\n    .button-custom {\n      background-image: url(\"custom.png\");\n    }\n\n### Multiple `&`\n\n`&` may appear more than once within a selector. This makes it possible to repeatedly refer to a parent selector without repeating its name.\n\n    .link {\n      & + & {\n        color: red;\n      }\n\n      & & {\n        color: green;\n      }\n\n      && {\n        color: blue;\n      }\n\n      &, &ish {\n        color: cyan;\n      }\n    }\n\nwill output:\n\n    .link + .link {\n      color: red;\n    }\n    .link .link {\n      color: green;\n    }\n    .link.link {\n      color: blue;\n    }\n    .link, .linkish {\n      color: cyan;\n    }\n\nNote that `&` represents all parent selectors (not just the nearest ancestor) so the following example:\n\n    .grand {\n      .parent {\n        & > & {\n          color: red;\n        }\n\n        & & {\n          color: green;\n        }\n\n        && {\n          color: blue;\n        }\n\n        &, &ish {\n          color: cyan;\n        }\n      }\n    }\n\nresults in:\n\n    .grand .parent > .grand .parent {\n      color: red;\n    }\n    .grand .parent .grand .parent {\n      color: green;\n    }\n    .grand .parent.grand .parent {\n      color: blue;\n    }\n    .grand .parent,\n    .grand .parentish {\n      color: cyan;\n    }\n\n### Changing Selector Order\n\nIt can be useful to prepend a selector to the inherited (parent) selectors. This can be done by putting the `&` after current selector. For example, when using Modernizr, you might want to specify different rules based on supported features:\n\n    .header {\n      .menu {\n        border-radius: 5px;\n        .no-borderradius & {\n          background-image: url('images/button-background.png');\n        }\n      }\n    }\n\nThe selector `.no-borderradius &` will prepend `.no-borderradius` to its parent `.header .menu` to form the`.no-borderradius .header .menu` on output:\n\n    .header .menu {\n      border-radius: 5px;\n    }\n    .no-borderradius .header .menu {\n      background-image: url('images/button-background.png');\n    }\n\n### Combinatorial Explosion\n\n`&` can also be used to generate every possible permutation of selectors in a comma separated list:\n\n    p, a, ul, li {\n      border-top: 2px dotted #366;\n      & + & {\n        border-top: 0;\n      }\n    }\n\nThis expands to all possible (16) combinations of the specified elements:\n\n    p,\n    a,\n    ul,\n    li {\n      border-top: 2px dotted #366;\n    }\n    p + p,\n    p + a,\n    p + ul,\n    p + li,\n    a + p,\n    a + a,\n    a + ul,\n    a + li,\n    ul + p,\n    ul + a,\n    ul + ul,\n    ul + li,\n    li + p,\n    li + a,\n    li + ul,\n    li + li {\n      border-top: 0;\n    }\n\n## Extend\n\nExtend is a Less pseudo-class which merges the selector it is put on with ones that match what it references.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\n    nav ul {\n      &:extend(.inline);\n      background: blue;\n    }\n\nIn the rule set above, the `:extend` selector will apply the \"extending selector\" (`nav ul`) onto the `.inline` class *wherever the `.inline` class appears*. The declaration block will be kept as-is, but without any reference to the extend (because extend isn't css).\n\nSo the following:\n\n    nav ul {\n      &:extend(.inline);\n      background: blue;\n    }\n    .inline {\n      color: red;\n    }\n\nOutputs\n\n    nav ul {\n      background: blue;\n    }\n    .inline,\n    nav ul {\n      color: red;\n    }\n\nNotice how the `nav ul:extend(.inline)` selector gets output as `nav ul` - the extend gets removed before output and the selector block left as-is. If no properties are put in that block then it gets removed from the output (but the extend still may affect other selectors).\n\n### Extend Syntax\n\nThe extend is either attached to a selector or placed into a ruleset. It looks like a pseudo-class with selector parameter optionally followed by the keyword `all`:\n\nExample:\n\n    .a:extend(.b) {}\n\n    // the above block does the same thing as the below block\n    .a {\n      &:extend(.b);\n    }\n\n    .c:extend(.d all) {\n      // extends all instances of \".d\" e.g. \".x.d\" or \".d.x\"\n    }\n    .c:extend(.d) {\n      // extends only instances where the selector will be output as just \".d\"\n    }\n\nIt can contain one or more classes to extend, separated by commas.\n\nExample:\n\n    .e:extend(.f) {}\n    .e:extend(.g) {}\n\n    // the above and the below do the same thing\n    .e:extend(.f, .g) {}\n\n### Extend Attached to Selector\n\nExtend attached to a selector looks like an ordinary pseudo-class with selector as a parameter. A selector can contain multiple extend clauses, but all extends must be at the end of the selector.\n\n- Extend after the selector: `pre:hover:extend(div pre)`.\n- Space between selector and extend is allowed: `pre:hover :extend(div pre)`.\n- Multiple extends are allowed: `pre:hover:extend(div pre):extend(.bucket tr)` - Note this is the same as `pre:hover:extend(div pre, .bucket tr)`\n- This is NOT allowed: `pre:hover:extend(div pre).nth-child(odd)`. Extend must be last.\n\nIf a ruleset contains multiple selectors, any of them can have the extend keyword. Multiple selectors with extend in one ruleset:\n\n    .big-division,\n    .big-bag:extend(.bag),\n    .big-bucket:extend(.bucket) {\n      // body\n    }\n\n### Extend Inside Ruleset\n\nExtend can be placed into a ruleset's body using `&:extend(selector)` syntax. Placing extend into a body is a shortcut for placing it into every single selector of that ruleset.\n\nExtend inside a body:\n\n    pre:hover,\n    .some-class {\n      &:extend(div pre);\n    }\n\nis exactly the same as adding an extend after each selector:\n\n    pre:hover:extend(div pre),\n    .some-class:extend(div pre) {}\n\n### Extending Nested Selectors\n\nExtend is able to match nested selectors. Following less:\n\nExample:\n\n    .bucket {\n      tr { // nested ruleset with target selector\n        color: blue;\n      }\n    }\n    .some-class:extend(.bucket tr) {} // nested ruleset is recognized\n\nOutputs\n\n    .bucket tr,\n    .some-class {\n      color: blue;\n    }\n\nEssentially the extend looks at the compiled css, not the original less.\n\nExample:\n\n    .bucket {\n      tr & { // nested ruleset with target selector\n        color: blue;\n      }\n    }\n    .some-class:extend(tr .bucket) {} // nested ruleset is recognized\n\nOutputs\n\n    tr .bucket,\n    .some-class {\n      color: blue;\n    }\n\n### Exact Matching with Extend\n\nExtend by default looks for exact match between selectors. It does matter whether selector uses leading star or not. It does not matter that two nth-expressions have the same meaning, they need to have to same form in order to be matched. The only exception are quotes in attribute selector, less knows they have the same meaning and matches them.\n\nExample:\n\n    .a.class,\n    .class.a,\n    .class > .a {\n      color: blue;\n    }\n    .test:extend(.class) {} // this will NOT match the any selectors above\n\nLeading star does matter. Selectors `*.class` and `.class` are equivalent, but extend will not match them:\n\n    *.class {\n      color: blue;\n    }\n    .noStar:extend(.class) {} // this will NOT match the *.class selector\n\nOutputs\n\n    *.class {\n      color: blue;\n    }\n\nOrder of pseudo-classes does matter. Selectors `link:hover:visited` and `link:visited:hover` match the same set of elements, but extend treats them as different:\n\n    link:hover:visited {\n      color: blue;\n    }\n    .selector:extend(link:visited:hover) {}\n\nOutputs\n\n    link:hover:visited {\n      color: blue;\n    }\n\n### nth Expression\n\nNth expression form does matter. Nth-expressions `1n+3` and `n+3` are equivalent, but extend will not match them:\n\n    :nth-child(1n+3) {\n      color: blue;\n    }\n    .child:extend(:nth-child(n+3)) {}\n\nOutputs\n\n    :nth-child(1n+3) {\n      color: blue;\n    }\n\nQuote type in attribute selector does not matter. All of the following are equivalent.\n\n    [title=identifier] {\n      color: blue;\n    }\n    [title='identifier'] {\n      color: blue;\n    }\n    [title=\"identifier\"] {\n      color: blue;\n    }\n\n    .noQuote:extend([title=identifier]) {}\n    .singleQuote:extend([title='identifier']) {}\n    .doubleQuote:extend([title=\"identifier\"]) {}\n\nOutputs\n\n    [title=identifier],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n    [title='identifier'],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n    [title=\"identifier\"],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n### Extend \"all\"\n\nWhen you specify the all keyword last in an extend argument it tells Less to match that selector as part of another selector. The selector will be copied and the matched part of the selector only will then be replaced with the extend, making a new selector.\n\nExample:\n\n    .a.b.test,\n    .test.c {\n      color: orange;\n    }\n    .test {\n      &:hover {\n        color: green;\n      }\n    }\n\n    .replacement:extend(.test all) {}\n\nOutputs\n\n    .a.b.test,\n    .test.c,\n    .a.b.replacement,\n    .replacement.c {\n      color: orange;\n    }\n    .test:hover,\n    .replacement:hover {\n      color: green;\n    }\n\n*You can think of this mode of operation as essentially doing a non-destructive search and replace.*\n\n### Selector Interpolation with Extend\n\nExtend is **not** able to match selectors with variables. If selector contains variable, extend will ignore it.\n\nHowever, extend can be attached to interpolated selector.\n\nSelector with variable will not be matched:\n\n    @variable: .bucket;\n    @{variable} { // interpolated selector\n      color: blue;\n    }\n    .some-class:extend(.bucket) {} // does nothing, no match is found\n\nand extend with variable in target selector matches nothing:\n\n    .bucket {\n      color: blue;\n    }\n    .some-class:extend(@{variable}) {} // interpolated selector matches nothing\n    @variable: .bucket;\n\nBoth of the above examples compile into:\n\n    .bucket {\n      color: blue;\n    }\n\nHowever, `:extend` attached to an interpolated selector works:\n\n    .bucket {\n      color: blue;\n    }\n    @{variable}:extend(.bucket) {}\n    @variable: .selector;\n\ncompiles to:\n\n    .bucket, .selector {\n      color: blue;\n    }\n\n### Scoping / Extend Inside @media\n\nCurrently, an `:extend` inside a `@media` declaration will only match selectors inside the same media declaration:\n\n    @media print {\n      .screenClass:extend(.selector) {} // extend inside media\n      .selector { // this will be matched - it is in the same media\n        color: black;\n      }\n    }\n    .selector { // ruleset on top of style sheet - extend ignores it\n      color: red;\n    }\n    @media screen {\n      .selector {  // ruleset inside another media - extend ignores it\n        color: blue;\n      }\n    }\n\ncompiles into:\n\n    @media print {\n      .selector,\n      .screenClass { /*  ruleset inside the same media was extended */\n        color: black;\n      }\n    }\n    .selector { /* ruleset on top of style sheet was ignored */\n      color: red;\n    }\n    @media screen {\n      .selector { /* ruleset inside another media was ignored */\n        color: blue;\n      }\n    }\n\nNote: extending does not match selectors inside a nested `@media` declaration:\n\n    @media screen {\n      .screenClass:extend(.selector) {} // extend inside media\n      @media (min-width: 1023px) {\n        .selector {  // ruleset inside nested media - extend ignores it\n          color: blue;\n        }\n      }\n    }\n\nThis compiles into:\n\n    @media screen and (min-width: 1023px) {\n      .selector { /* ruleset inside another nested media was ignored */\n        color: blue;\n      }\n    }\n\nTop level extend matches everything including selectors inside nested media:\n\n    @media screen {\n      .selector {  /* ruleset inside nested media - top level extend works */\n        color: blue;\n      }\n      @media (min-width: 1023px) {\n        .selector {  /* ruleset inside nested media - top level extend works */\n          color: blue;\n        }\n      }\n    }\n\n    .topLevel:extend(.selector) {} /* top level extend matches everything */\n\ncompiles into:\n\n    @media screen {\n      .selector,\n      .topLevel { /* ruleset inside media was extended */\n        color: blue;\n      }\n    }\n    @media screen and (min-width: 1023px) {\n      .selector,\n      .topLevel { /* ruleset inside nested media was extended */\n        color: blue;\n      }\n    }\n\n### Duplication Detection\n\nCurrently there is no duplication detection.\n\nExample:\n\n    .alert-info,\n    .widget {\n      /* declarations */\n    }\n\n    .alert:extend(.alert-info, .widget) {}\n\nOutputs\n\n    .alert-info,\n    .widget,\n    .alert,\n    .alert {\n      /* declarations */\n    }\n\n### Use Cases for Extend\n\n### Classic Use Case\n\nThe classic use case is to avoid adding a base class. For example, if you have\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n\nand you want to have a subtype of animal which overrides the background color then you have two options, firstly change your HTML\n\n    <a class=\"animal bear\">Bear</a>\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n    .bear {\n      background-color: brown;\n    }\n\nor have simplified html and use extend in your less. e.g.\n\n    <a class=\"bear\">Bear</a>\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n    .bear {\n      &:extend(.animal);\n      background-color: brown;\n    }\n\n### Reducing CSS Size\n\nMixins copy all of the properties into a selector, which can lead to unnecessary duplication. Therefore you can use extends instead of mixins to move the selector up to the properties you wish to use, which leads to less CSS being generated.\n\nExample - with mixin:\n\n    .my-inline-block() {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing1 {\n      .my-inline-block;\n    }\n    .thing2 {\n      .my-inline-block;\n    }\n\nOutputs\n\n    .thing1 {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing2 {\n      display: inline-block;\n      font-size: 0;\n    }\n\nExample (with extends):\n\n    .my-inline-block {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing1 {\n      &:extend(.my-inline-block);\n    }\n    .thing2 {\n      &:extend(.my-inline-block);\n    }\n\nOutputs\n\n    .my-inline-block,\n    .thing1,\n    .thing2 {\n      display: inline-block;\n      font-size: 0;\n    }\n\n### Combining Styles / A More Advanced Mixin\n\nAnother use-case is as an alternative for a mixin - because mixins can only be used with simple selectors, if you have two different blocks of html, but need to apply the same styles to both you can use extends to relate two areas.\n\nExample:\n\n    li.list > a {\n      // list styles\n    }\n    button.list-style {\n      &:extend(li.list > a); // use the same list styles\n    }\n\n## Merge\n\nCombine properties\n\nThe `merge` feature allows for aggregating values from multiple properties into a comma or space separated list under a single property. `merge` is useful for properties such as background and transform.\n\n### Comma\n\nAppend property value with comma\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    .mixin() {\n      box-shadow+: inset 0 0 10px #555;\n    }\n    .myclass {\n      .mixin();\n      box-shadow+: 0 0 20px black;\n    }\n\nOutputs\n\n    .myclass {\n      box-shadow: inset 0 0 10px #555, 0 0 20px black;\n    }\n\n### Space\n\nAppend property value with space\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    .mixin() {\n      transform+_: scale(2);\n    }\n    .myclass {\n      .mixin();\n      transform+_: rotate(15deg);\n    }\n\nOutputs\n\n    .myclass {\n      transform: scale(2) rotate(15deg);\n    }\n\nTo avoid any unintentional joins, `merge` requires an explicit `+` or `+_` flag on each join pending declaration.\n\n## Mixins\n\n\"mix-in\" properties from existing styles\n\nYou can mix-in class selectors and id selectors, e.g.\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      .a();\n    }\n    .mixin-id {\n      #b();\n    }\n\nwhich results in:\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      color: red;\n    }\n    .mixin-id {\n      color: red;\n    }\n\nHistorically, the parentheses in a mixin call are optional, but optional parentheses are deprecated and will be required in a future release.\n\n    .a(); \n    .a;    // currently works, but deprecated; don't use\n    .a (); // white-space before parentheses is also deprecated\n\n### Mixins With Parentheses\n\nIf you want to create a mixin but you do not want that mixin to be in your CSS output, put parentheses after the mixin definition.\n\n    .my-mixin {\n      color: black;\n    }\n    .my-other-mixin() {\n      background: white;\n    }\n    .class {\n      .my-mixin();\n      .my-other-mixin();\n    }\n\noutputs\n\n    .my-mixin {\n      color: black;\n    }\n    .class {\n      color: black;\n      background: white;\n    }\n\n### Selectors in Mixins\n\nMixins can contain more than just properties, they can contain selectors too.\n\nFor example:\n\n    .my-hover-mixin() {\n      &:hover {\n        border: 1px solid red;\n      }\n    }\n    button {\n      .my-hover-mixin();\n    }\n\nOutputs\n\n    button:hover {\n      border: 1px solid red;\n    }\n\n### Namespaces\n\nIf you want to mixin properties inside a more complicated selector, you can stack up multiple ids or classes.\n\n    #outer() {\n      .inner {\n        color: red;\n      }\n    }\n\n    .c {\n      #outer.inner();\n    }\n\nNote: legacy Less syntax allows `>` and whitespace between namespaces and mixins. This syntax is deprecated and may be removed. Currently, these do the same thing.\n\n    #outer > .inner(); // deprecated\n    #outer .inner();   // deprecated\n    #outer.inner();    // preferred\n\nNamespacing your mixins like this reduces conflicts with other library mixins or user mixins, but can also be a way to \"organize\" groups of mixins.\n\nExample:\n\n    #my-library {\n      .my-mixin() {\n        color: black;\n      }\n    }\n    // which can be used like this\n    .class {\n      #my-library.my-mixin();\n    }\n\n### Guarded Namespaces\n\nIf a namespace has a guard, mixins defined by it are used only if the guard condition returns true. A namespace guard is evaluated exactly the same as a guard on a mixin, so the following two mixins work the same way:\n\n    #namespace when (@mode = huge) {\n      .mixin() { /* */ }\n    }\n\n    #namespace {\n      .mixin() when (@mode = huge) { /* */ }\n    }\n\nThe `default` function is assumed to have the same value for all nested namespaces and mixin. The following mixin is never evaluated; one of its guards is guaranteed to be false:\n\n    #sp_1 when (default()) {\n      #sp_2 when (default()) {\n        .mixin() when not(default()) { /* */ }\n      }\n    }\n\n### The `!important` keyword\n\nUse the `!important` keyword after mixin call to mark all properties inherited by it as `!important`:\n\nExample:\n\n    .foo (@bg: #f5f5f5; @color: #900) {\n      background: @bg;\n      color: @color;\n    }\n    .unimportant {\n      .foo();\n    }\n    .important {\n      .foo() !important;\n    }\n\nResults in:\n\n    .unimportant {\n      background: #f5f5f5;\n      color: #900;\n    }\n    .important {\n      background: #f5f5f5 !important;\n      color: #900 !important;\n    }\n\n### Parametric Mixins\n\nHow to pass arguments to mixins\n\nMixins can also take arguments, which are variables passed to the block of selectors when it is mixed in.\n\nFor example:\n\n    .border-radius(@radius) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nAnd here's how we can mix it into various rulesets:\n\n    #header {\n      .border-radius(4px);\n    }\n    .button {\n      .border-radius(6px);\n    }\n\nParametric mixins can also have default values for their parameters:\n\n    .border-radius(@radius: 5px) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nWe can invoke it like this now:\n\n    #header {\n      .border-radius();\n    }\n\nAnd it will include a 5px border-radius.\n\nYou can also use parametric mixins which don't take parameters. This is useful if you want to hide the ruleset from the CSS output, but want to include its properties in other rulesets:\n\n    .wrap() {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n    pre { .wrap() }\n\nWhich would output:\n\n    pre {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n### Parameter separators\n\nParameters are currently either *semicolon* or *comma* separated.\n\nOriginally, parameters were only separated by commas, but the semi-colon was later added to support passing comma-separated list values to single arguments.\n\n- two arguments and each contains comma separated list: `.name(1, 2, 3; something, else)`,\n- three arguments and each contains one number: `.name(1, 2, 3)`,\n- use dummy semicolon to create mixin call with one argument containing comma separated css list: `.name(1, 2, 3;)`,\n- comma separated default value: `.name(@param1: red, blue;)`.\n- As of Less 4.0, you can wrap a list value using a paren escape \\[`~()`\\], e.g. `.name(@param1: ~(red, blue))`. This is similar to the quote escape syntax: `~\"quote\"`\n\n### Overloading mixins\n\nIt is legal to define multiple mixins with the same name and number of parameters. Less will use properties of all that can apply. If you used the mixin with one parameter e.g. `.mixin(green);`, then properties of all mixins with exactly one mandatory parameter will be used:\n\n    .mixin(@color) {\n      color-1: @color;\n    }\n    .mixin(@color, @padding: 2) {\n      color-2: @color;\n      padding-2: @padding;\n    }\n    .mixin(@color, @padding, @margin: 2) {\n      color-3: @color;\n      padding-3: @padding;\n      margin: @margin @margin @margin @margin;\n    }\n    .some .selector div {\n      .mixin(#008000);\n    }\n\ncompiles into:\n\n    .some .selector div {\n      color-1: #008000;\n      color-2: #008000;\n      padding-2: 2;\n    }\n\n### Named Parameters\n\nA mixin reference can supply parameters values by their names instead of just positions. Any parameter can be referenced by its name and they do not have to be in any special order:\n\n    .mixin(@color: black; @margin: 10px; @padding: 20px) {\n      color: @color;\n      margin: @margin;\n      padding: @padding;\n    }\n    .class1 {\n      .mixin(@margin: 20px; @color: #33acfe);\n    }\n    .class2 {\n      .mixin(#efca44; @padding: 40px);\n    }\n\ncompiles into:\n\n    .class1 {\n      color: #33acfe;\n      margin: 20px;\n      padding: 20px;\n    }\n    .class2 {\n      color: #efca44;\n      margin: 10px;\n      padding: 40px;\n    }\n\n### The `@arguments` Variable\n\n`@arguments` has a special meaning inside mixins, it contains all the arguments passed, when the mixin was called. This is useful if you don't want to deal with individual parameters:\n\n    .box-shadow(@x: 0, @y: 0, @blur: 1px, @color: #000) {\n      -webkit-box-shadow: @arguments;\n         -moz-box-shadow: @arguments;\n              box-shadow: @arguments;\n    }\n    .big-block {\n      .box-shadow(2px, 5px);\n    }\n\nWhich results in:\n\n    .big-block {\n      -webkit-box-shadow: 2px 5px 1px #000;\n         -moz-box-shadow: 2px 5px 1px #000;\n              box-shadow: 2px 5px 1px #000;\n    }\n\n### Advanced Arguments and the `@rest` Variable\n\nYou can use `...` if you want your mixin to take a variable number of arguments. Using this after a variable name will assign those arguments to the variable.\n\n    .mixin(...) {        // matches 0-N arguments\n    .mixin() {           // matches exactly 0 arguments\n    .mixin(@a: 1) {      // matches 0-1 arguments\n    .mixin(@a: 1, ...) { // matches 0-N arguments\n    .mixin(@a, ...) {    // matches 1-N arguments\n\nFurthermore:\n\n    .mixin(@a, @rest...) {\n       // @rest is bound to arguments after @a\n       // @arguments is bound to all arguments\n    }\n\n### Pattern-matching\n\nSometimes, you may want to change the behavior of a mixin, based on the parameters you pass to it. Let's start with something basic:\n\n    .mixin(@s, @color) { ... }\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nNow let's say we want `.mixin` to behave differently, based on the value of `@switch`, we could define `.mixin` as such:\n\n    .mixin(dark, @color) {\n      color: darken(@color, 10%);\n    }\n    .mixin(light, @color) {\n      color: lighten(@color, 10%);\n    }\n    .mixin(@_, @color) {\n      display: block;\n    }\n\nNow, if we run:\n\n    @switch: light;\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nWe will get the following CSS:\n\n    .class {\n      color: #a2a2a2;\n      display: block;\n    }\n\nWhere the color passed to `.mixin` was lightened. If the value of `@switch` was `dark`, the result would be a darker color.\n\nHere's what happened:\n\n- The first mixin definition didn't match because it expected `dark` as the first argument.\n- The second mixin definition matched, because it expected `light`.\n- The third mixin definition matched because it expected any value.\n\nOnly mixin definitions which matched were used. Variables match and bind to any value. Anything other than a variable matches only with a value equal to itself.\n\nWe can also match on arity, here's an example:\n\n    .mixin(@a) {\n      color: @a;\n    }\n    .mixin(@a, @b) {\n      color: fade(@a, @b);\n    }\n\nNow if we call `.mixin` with a single argument, we will get the output of the first definition, but if we call it with *two* arguments, we will get the second definition, namely `@a` faded to `@b`.\n\n### Using Mixins as Functions\n\nSelecting properties and variables from mixin calls\n\n### Property / value accessors\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors to select a value from an evaluated mixin's rules. This can allow you to use mixins similar to functions.\n\nExample:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its \"@result\" value\n      padding: .average(16px, 50px)[@result];\n    }\n\nResults in:\n\n    div {\n      padding: 33px;\n    }\n\n### Overriding mixin values\n\nIf you have multiple matching mixins, all rules are evaluated and merged, and the last matching value with that identifier is returned. This is similar to the cascade in CSS, and it allows you to \"override\" mixin values.\n\n    // library.less\n    #library() {\n      .mixin() {\n        prop: foo;\n      }\n    }\n\n    // customize.less\n    @import \"library\";\n    #library() {\n      .mixin() {\n        prop: bar;\n      }\n    }\n\n    .box {\n      my-value: #library.mixin[prop];\n    }\n\nOutputs:\n\n    .box {\n      my-value: bar;\n    }\n\n### Unnamed lookups\n\nIf you don't specify a lookup value in `[@lookup]` and instead write `[]` after a mixin or ruleset call, *all* values will cascade and the last declared value will be selected.\n\nMeaning: the averaging mixin from the above example could be written as:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its final value\n      padding: .average(16px, 50px)[];\n    }\n\nThe output is the same:\n\n    div {\n      padding: 33px;\n    }\n\nThe same cascading behavior is true for rulesets or variables aliased to mixin calls.\n\n    @dr: {\n      value: foo;\n    }\n    .box {\n      my-value: @dr[];\n    }\n\nThis outputs:\n\n    .box {\n      my-value: foo;\n    }\n\n### Unlocking mixins & variables into caller scope\n\n***DEPRECATED - Use Property / Value Accessors***\n\nVariables and mixins defined in a mixin are visible and can be used in caller's scope. There is only one exception: a variable is not copied if the caller contains a variable with the same name (that includes variables defined by another mixin call). Only variables present in callers local scope are protected. Variables inherited from parent scopes are overridden.\n\n*Note: this behavior is deprecated, and in the future, variables and mixins will not be merged into the caller scope in this way.*\n\nExample:\n\n    .mixin() {\n      @width:  100%;\n      @height: 200px;\n    }\n\n    .caller {\n      .mixin();\n      width:  @width;\n      height: @height;\n    }\n\nResults in:\n\n    .caller {\n      width:  100%;\n      height: 200px;\n    }\n\nVariables defined directly in callers scope cannot be overridden. However, variables defined in callers parent scope is not protected and will be overridden:\n\n    .mixin() {\n      @size: in-mixin;\n      @definedOnlyInMixin: in-mixin;\n    }\n\n    .class {\n      margin: @size @definedOnlyInMixin;\n      .mixin();\n    }\n\n    @size: globaly-defined-value; // callers parent scope - no protection\n\nResults in:\n\n    .class {\n      margin: in-mixin in-mixin;\n    }\n\nFinally, mixin defined in mixin acts as return value too:\n\n    .unlock(@value) { // outer mixin\n      .doSomething() { // nested mixin\n        declaration: @value;\n      }\n    }\n\n    #namespace {\n      .unlock(5); // unlock doSomething mixin\n      .doSomething(); //nested mixin was copied here and is usable\n    }\n\nResults in:\n\n    #namespace {\n      declaration: 5;\n    }\n\n### Recursive Mixins\n\nCreating loops\n\nIn Less a mixin can call itself. Such recursive mixins, when combined with [Guard Expressions](#mixin-guards-feature) and [Pattern Matching](#mixins-parametric-feature-pattern-matching), can be used to create various iterative/loop structures.\n\nExample:\n\n    .loop(@counter) when (@counter > 0) {\n      .loop((@counter - 1));    // next iteration\n      width: (10px * @counter); // code for each iteration\n    }\n\n    div {\n      .loop(5); // launch the loop\n    }\n\nOutput:\n\n    div {\n      width: 10px;\n      width: 20px;\n      width: 30px;\n      width: 40px;\n      width: 50px;\n    }\n\nA generic example of using a recursive loop to generate CSS grid classes:\n\n    .generate-columns(4);\n\n    .generate-columns(@n, @i: 1) when (@i =< @n) {\n      .column-@{i} {\n        width: (@i * 100% / @n);\n      }\n      .generate-columns(@n, (@i + 1));\n    }\n\nOutput:\n\n    .column-1 {\n      width: 25%;\n    }\n    .column-2 {\n      width: 50%;\n    }\n    .column-3 {\n      width: 75%;\n    }\n    .column-4 {\n      width: 100%;\n    }\n\n### Mixin Guards\n\nGuards are useful when you want to match on *expressions*, as opposed to simple values or arity. If you are familiar with functional programming, you have probably encountered them already.\n\nIn trying to stay as close as possible to the declarative nature of CSS, Less has opted to implement conditional execution via **guarded mixins** instead of `if`/`else` statements, in the vein of `@media` query feature specifications.\n\nLet's start with an example:\n\n    .mixin(@a) when (lightness(@a) >= 50%) {\n      background-color: black;\n    }\n    .mixin(@a) when (lightness(@a) < 50%) {\n      background-color: white;\n    }\n    .mixin(@a) {\n      color: @a;\n    }\n\nThe key is the `when` keyword, which introduces a guard sequence (here with only one guard). Now if we run the following code:\n\n    .class1 { .mixin(#ddd) }\n    .class2 { .mixin(#555) }\n\nHere's what we'll get:\n\n    .class1 {\n      background-color: black;\n      color: #ddd;\n    }\n    .class2 {\n      background-color: white;\n      color: #555;\n    }\n\n### Guard Comparison Operators\n\nThe full list of comparison operators usable in guards are: `>`, `>=`, `=`, `=<`, `<`. Additionally, the keyword `true` is the only truthy value, making these two mixins equivalent:\n\n    .truth(@a) when (@a) { ... }\n    .truth(@a) when (@a = true) { ... }\n\nAny value other than the keyword `true` is falsy:\n\n    .class {\n      .truth(40); // Will not match any of the above definitions.\n    }\n\nNote that you can also compare arguments with each other, or with non-arguments:\n\n    @media: mobile;\n\n    .mixin(@a) when (@media = mobile) { ... }\n    .mixin(@a) when (@media = desktop) { ... }\n\n    .max(@a; @b) when (@a > @b) { width: @a }\n    .max(@a; @b) when (@a < @b) { width: @b }\n\n### Guard Logical Operators\n\nYou can use logical operators with guards. The syntax is based on CSS media queries.\n\nUse the `and` keyword to combine guards:\n\n    .mixin(@a) when (isnumber(@a)) and (@a > 0) { ... }\n\nYou can emulate the *or* operator by separating guards with a comma `,`. If any of the guards evaluate to true, it's considered a match:\n\n    .mixin(@a) when (@a > 10), (@a < -10) { ... }\n\nUse the `not` keyword to negate conditions:\n\n    .mixin(@b) when not (@b > 0) { ... }\n\n### Type Checking Functions\n\nLastly, if you want to match mixins based on value type, you can use the `is` functions:\n\n    .mixin(@a; @b: 0) when (isnumber(@b)) { ... }\n    .mixin(@a; @b: black) when (iscolor(@b)) { ... }\n\nHere are the basic type checking functions:\n\n- `iscolor`\n- `isnumber`\n- `isstring`\n- `iskeyword`\n- `isurl`\n\nIf you want to check if a value is in a specific unit in addition to being a number, you may use one of:\n\n- `ispixel`\n- `ispercentage`\n- `isem`\n- `isunit`\n\n### Aliasing Mixins\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nAssigning mixin calls to a variable\n\nMixins can be assigned to a variable to be called as a variable call, or can be used for map lookup.\n\n    #theme.dark.navbar {\n      .colors(light) {\n        primary: purple;\n      }\n      .colors(dark) {\n        primary: black;\n        secondary: grey;\n      }\n    }\n\n    .navbar {\n      @colors: #theme.dark.navbar.colors(dark);\n      background: @colors[primary];\n      border: 1px solid @colors[secondary];\n    }\n\nThis would output:\n\n    .navbar {\n      background: black;\n      border: 1px solid grey;\n    }\n\n### Variable calls\n\nEntire mixin calls can be aliased and called as variable calls. As in:\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors();\n      @alias();\n    }\n\nOutputs:\n\n    .box {\n      background: green;\n    }\n\nNote, unlike mixins used in root, mixin calls assigned to variables and *called with no arguments* always require parentheses. The following is not valid.\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors;\n      @alias();   // ERROR: Could not evaluate variable call @alias\n    }\n\nThis is because it's ambiguous if variable is assigned a list of selectors or a mixin call. For example, in Less 3.5+, this variable could be used this way.\n\n    .box {\n      @alias: #library.colors;\n      @{alias} {\n        a: b;\n      }\n    }\n\nThe above would output:\n\n    .box #library.colors {\n      a: b;\n    }\n\n## CSS Guards\n\n\"if\"'s around selectors\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nLike Mixin Guards, guards can also be applied to css selectors, which is syntactic sugar for declaring the mixin and then calling it immediately.\n\nFor instance, before 1.5.0 you would have had to do this:\n\n    .my-optional-style() when (@my-option = true) {\n      button {\n        color: white;\n      }\n    }\n    .my-optional-style();\n\nNow, you can apply the guard directly to a style.\n\n    button when (@my-option = true) {\n      color: white;\n    }\n\nYou can also achieve an `if` type statement by combining this with the `&` feature, allowing you to group multiple guards.\n\n    & when (@my-option = true) {\n      button {\n        color: white;\n      }\n      a {\n        color: blue;\n      }\n    }\n\nNote that you can also achieve a similar pattern by using the actual `if()` function and a variable call. As in:\n\n    @dr: if(@my-option = true, {\n      button {\n        color: white;\n      }\n      a {\n        color: blue;\n      }\n    });\n    @dr();\n\n## Detached Rulesets\n\nAssign a ruleset to a variable\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nA detached ruleset is a group of css properties, nested rulesets, media declarations or anything else stored in a variable. You can include it into a ruleset or another structure and all its properties are going to be copied there. You can also use it as a mixin argument and pass it around as any other variable.\n\nSimple example:\n\n    // declare detached ruleset\n    @detached-ruleset: { background: red; }; // semi-colon is optional in 3.5.0+\n\n    // use detached ruleset\n    .top {\n        @detached-ruleset(); \n    }\n\ncompiles into:\n\n    .top {\n      background: red;\n    }\n\nParentheses after a detached ruleset call are mandatory (except when followed by a [lookup value](#detached-rulesets-feature-property-variable-accessors)). The call `@detached-ruleset;` would not work.\n\nIt is useful when you want to define a mixin that abstracts out either wrapping a piece of code in a media query or a non-supported browser class name. The rulesets can be passed to mixin so that the mixin can wrap the content, e.g.\n\n    .desktop-and-old-ie(@rules) {\n      @media screen and (min-width: 1200px) { @rules(); }\n      html.lt-ie9 &                         { @rules(); }\n    }\n\n    header {\n      background-color: blue;\n\n      .desktop-and-old-ie({\n        background-color: red;\n      });\n    }\n\nHere the `desktop-and-old-ie` mixin defines the media query and root class so that you can use a mixin to wrap a piece of code. This will output\n\n    header {\n      background-color: blue;\n    }\n    @media screen and (min-width: 1200px) {\n      header {\n        background-color: red;\n      }\n    }\n    html.lt-ie9 header {\n      background-color: red;\n    }\n\nA ruleset can be now assigned to a variable or passed in to a mixin and can contain the full set of Less features, e.g.\n\n    @my-ruleset: {\n        .my-selector {\n          background-color: black;\n        }\n      };\n\nYou can even take advantage of [media query bubbling](#features-overview-feature-media-query-bubbling-and-nested-media-queries), for instance\n\n    @my-ruleset: {\n        .my-selector {\n          @media tv {\n            background-color: black;\n          }\n        }\n      };\n    @media (orientation:portrait) {\n        @my-ruleset();\n    }\n\nwhich will output\n\n    @media (orientation: portrait) and tv {\n      .my-selector {\n        background-color: black;\n      }\n    }\n\nA detached ruleset call unlocks (returns) all its mixins into caller the same way as mixin calls do. However, it does **not** return variables.\n\nReturned mixin:\n\n    // detached ruleset with a mixin\n    @detached-ruleset: { \n        .mixin() {\n            color: blue;\n        }\n    };\n    // call detached ruleset\n    .caller {\n        @detached-ruleset(); \n        .mixin();\n    }\n\nResults in:\n\n    .caller {\n      color: blue;\n    }\n\nPrivate variables:\n\n    @detached-ruleset: { \n        @color:blue; // this variable is private\n    };\n    .caller {\n        color: @color; // syntax error\n    }\n\n### Scoping\n\nA detached ruleset can use all variables and mixins accessible where it is *defined* and where it is *called*. Otherwise said, both definition and caller scopes are available to it. If both scopes contains the same variable or mixin, declaration scope value takes precedence.\n\n*Declaration scope* is the one where detached ruleset body is defined. Copying a detached ruleset from one variable into another cannot modify its scope. The ruleset does not gain access to new scopes just by being referenced there.\n\nLastly, a detached ruleset can gain access to scope by being unlocked (imported) into it.\n\n*Note: unlocking variables into scope via a called mixin is deprecated. Use [property / variable accessors](#detached-rulesets-feature-property-variable-accessors).*\n\n### Definition and Caller Scope Visibility\n\nA detached ruleset sees the caller's variables and mixins:\n\n    @detached-ruleset: {\n      caller-variable: @caller-variable; // variable is undefined here\n      .caller-mixin(); // mixin is undefined here\n    };\n\n    selector {\n      // use detached ruleset\n      @detached-ruleset(); \n\n      // define variable and mixin needed inside the detached ruleset\n      @caller-variable: value;\n      .caller-mixin() {\n        variable: declaration;\n      }\n    }\n\ncompiles into:\n\n    selector {\n      caller-variable: value;\n      variable: declaration;\n    }\n\nVariable and mixins accessible from definition win over those available in the caller:\n\n    @variable: global;\n    @detached-ruleset: {\n      // will use global variable, because it is accessible\n      // from detached-ruleset definition\n      variable: @variable; \n    };\n\n    selector {\n      @detached-ruleset();\n      @variable: value; // variable defined in caller - will be ignored\n    }\n\ncompiles into:\n\n    selector {\n      variable: global;\n    }\n\n### Referencing *Won't* Modify Detached Ruleset Scope\n\nA ruleset does not gain access to new scopes just by being referenced there:\n\n    @detached-1: { scope-detached: @one @two; };\n    .one {\n      @one: visible;\n      .two {\n        @detached-2: @detached-1; // copying/renaming ruleset \n        @two: visible; // ruleset can not see this variable\n      }\n    }\n\n    .use-place {\n      .one > .two(); \n      @detached-2();\n    }\n\nthrows an error:\n\n    ERROR 1:32 The variable \"@one\" was not declared.\n\n### Unlocking *Will* Modify Detached Ruleset Scope\n\nA detached ruleset gains access by being unlocked (imported) inside a scope:\n\n    #space {\n      .importer-1() {\n        @detached: { scope-detached: @variable; }; // define detached ruleset\n      }\n    }\n\n    .importer-2() {\n      @variable: value; // unlocked detached ruleset CAN see this variable\n      #space > .importer-1(); // unlock/import detached ruleset\n    }\n\n    .use-place {\n      .importer-2(); // unlock/import detached ruleset second time\n       @detached();\n    }\n\ncompiles into:\n\n    .use-place {\n      scope-detached: value;\n    }\n\n### Property / variable accessors\n\n### (Lookup values)\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors (also called \"lookups\") to select a value from variable (detached) rulesets.\n\n    @config: {\n      option1: true;\n      option2: false;\n    }\n\n    .mixin() when (@config[option1] = true) {\n      selected: value;\n    }\n\n    .box {\n      .mixin();\n    }\n\nOutputs:\n\n    .box {\n      selected: value;\n    }\n\nIf what is returned from a lookup is another detached ruleset, you can use a second lookup to get that value.\n\n    @config: {\n      @colors: {\n        primary: blue;\n      }\n    }\n\n    .box {\n      color: @config[@colors][primary];\n    }\n\n### Variable variables in lookups\n\nThe lookup value that is returned can itself be variable. As in, you can write:\n\n    @config: {\n      @dark: {\n        primary: darkblue;\n      }\n      @light: {\n        primary: lightblue;\n      }\n    }\n\n    .box {\n      @lookup: dark;\n      color: @config[@@lookup][primary];\n    }\n\nThis will output:\n\n    .box {\n      color: darkblue;\n    }\n\n## @import At-Rules\n\nImport styles from other style sheets\n\nIn standard CSS, `@import` at-rules must precede all other types of rules. But Less doesn't care where you put `@import` statements.\n\nExample:\n\n    .foo {\n      background: #900;\n    }\n    @import \"this-is-valid.less\";\n\n### File Extensions\n\n`@import` statements may be treated differently by Less depending on the file extension:\n\n- If the file has a `.css` extension it will be treated as CSS and the `@import` statement left as-is (see the [inline option](#import-options-inline) below).\n- If it has *any other extension* it will be treated as Less and imported.\n- If it does not have an extension, `.less` will be appended and it will be included as a imported Less file.\n\nExamples:\n\n    @import \"foo\";      // foo.less is imported\n    @import \"foo.less\"; // foo.less is imported\n    @import \"foo.php\";  // foo.php imported as a Less file\n    @import \"foo.css\";  // statement left in place, as-is\n\nThe following options can be used to override this behavior.\n\n### Import Options\n\nLess offers several extensions to the CSS `@import` CSS at-rule to provide more flexibility over what you can do with external files.\n\nSyntax: `@import (keyword) \"filename\";`\n\nThe following import options have been implemented:\n\n- `reference`: use a Less file but do not output it\n- `inline`: include the source file in the output but do not process it\n- `less`: treat the file as a Less file, no matter what the file extension\n- `css`: treat the file as a CSS file, no matter what the file extension\n- `once`: only include the file once (this is default behavior)\n- `multiple`: include the file multiple times\n- `optional`: continue compiling when file is not found\n\nMore than one keyword per `@import` is allowed, you will have to use commas to separate the keywords:\n\nExample: `@import (optional, reference) \"foo.less\";`\n\n### reference\n\nUse `@import (reference)` to import external files, but without adding the imported styles to the compiled output unless referenced.\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample: `@import (reference) \"foo.less\";`\n\nImagine that `reference` marks every at-rule and selector with a *reference flag* in the imported file, imports as normal, but when the CSS is generated, \"reference\" selectors (as well as any media queries containing only reference selectors) are not output. `reference` styles will not show up in your generated CSS unless the reference styles are used as [mixins](#mixins-feature) or [extended](#extend-feature).\n\nAdditionally, **`reference`** produces different results depending on which method was used (mixin or extend):\n\n- **[extend](#extend-feature)**: When a selector is extended, only the new selector is marked as *not referenced*, and it is pulled in at the position of the reference `@import` statement.\n- **[mixins](#mixins-feature)**: When a `reference` style is used as an [implicit mixin](#mixins-feature), its rules are mixed-in, marked \"not reference\", and appear in the referenced place as normal.\n\n### reference example\n\nThis allows you to pull in only specific, targeted styles from a library such as [Bootstrap](https://github.com/twbs/bootstrap) by doing something like this:\n\n    .navbar:extend(.navbar all) {}\n\nAnd you will pull in only `.navbar` related styles from Bootstrap.\n\n### inline\n\nUse `@import (inline)` to include external files, but not process them.\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample: `@import (inline) \"not-less-compatible.css\";`\n\nYou will use this when a CSS file may not be Less compatible; this is because although Less supports most known standards CSS, it does not support comments in some places and does not support all known CSS hacks without modifying the CSS.\n\nSo you can use this to include the file in the output so that all CSS will be in one file.\n\n### less\n\nUse `@import (less)` to treat imported files as Less, regardless of file extension.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    @import (less) \"foo.css\";\n\n### css\n\nUse `@import (css)` to treat imported files as regular CSS, regardless of file extension. This means the import statement will be left as it is.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    @import (css) \"foo.less\";\n\noutputs\n\n    @import \"foo.less\";\n\n### once\n\nThe default behavior of `@import` statements. It means the file is imported only once and subsequent import statements for that file will be ignored.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nThis is the default behavior of `@import` statements.\n\nExample:\n\n    @import (once) \"foo.less\";\n    @import (once) \"foo.less\"; // this statement will be ignored\n\n### multiple\n\nUse `@import (multiple)` to allow importing of multiple files with the same name. This is the opposite behavior to once.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    // file: foo.less\n    .a {\n      color: green;\n    }\n    // file: main.less\n    @import (multiple) \"foo.less\";\n    @import (multiple) \"foo.less\";\n\nOutputs\n\n    .a {\n      color: green;\n    }\n    .a {\n      color: green;\n    }\n\n### optional\n\nUse `@import (optional)` to allow importing of a file only when it exists. Without the `optional` keyword Less throws a FileError and stops compiling when importing a file that can not be found.\n\nReleased [v2.3.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\n## @plugin At-Rules\n\nReleased [v2.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nImport JavaScript plugins to add Less.js functions and features\n\n### Writing your first plugin\n\nUsing a `@plugin` at-rule is similar to using an `@import` for your `.less` files.\n\n    @plugin \"my-plugin\";  // automatically appends .js if no extension\n\nSince Less plugins are evaluated within the Less scope, the plugin definition can be quite simple.\n\n    registerPlugin({\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    })\n\nor you can use `module.exports` (shimmed to work in browser as well as Node.js).\n\n    module.exports = {\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    };\n\nNote that other Node.js CommonJS conventions, like `require()` are not available in the browser. Keep this in mind when writing cross-platform plugins.\n\nWhat can you do with a plugin? A lot, but let's start with the basics. We'll focus first on what you might put inside the `install` function. Let's say you write this:\n\n    // my-plugin.js\n    install: function(less, pluginManager, functions) {\n        functions.add('pi', function() {\n            return Math.PI;\n        });\n    }\n    // etc\n\nCongratulations! You've written a Less plugin!\n\nIf you were to use this in your stylesheet:\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi();\n    }\n\nYou would get:\n\n    .show-me-pi {\n      value: 3.141592653589793;\n    }\n\nHowever, you would need to return a proper Less node if you wanted to, say, multiply that against other values or do other Less operations. Otherwise the output in your stylesheet is plain text (which may be fine for your purposes).\n\nMeaning, this is more correct:\n\n    functions.add('pi', function() {\n        return new tree.Dimension(Math.PI);\n    });\n\n*Note: A dimension is a number with or without a unit, like \"10px\", which would be `less.Dimension(10, \"px\")`. For a list of units, see the [Less API](todo).*\n\nNow you can use your function in operations.\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi() * 2;\n    }\n\nYou may have noticed that there are available globals for your plugin file, namely a function registry (`functions` object), and the `less` object. These are there for convenience.\n\n### Plugin Scope\n\nFunctions added by a `@plugin` at-rule adheres to Less scoping rules. This is great for Less library authors that want to add functionality without introducing naming conflicts.\n\nFor instance, say you have 2 plugins from two third-party libraries that both have a function named \"foo\".\n\n    // lib1.js\n    // ...\n        functions.add('foo', function() {\n            return \"foo\";\n        });\n    // ...\n\n    // lib2.js\n    // ...\n        functions.add('foo', function() {\n            return \"bar\";\n        });\n    // ...\n\nThat's ok! You can choose which library's function creates which output.\n\n    .el-1 {\n        @plugin \"lib1\";\n        value: foo();\n    }\n    .el-2 {\n        @plugin \"lib2\";\n        value: foo();\n    }\n\nThis will produce:\n\n    .el-1 {\n        value: foo;\n    }\n    .el-2 {\n        value: bar;\n    }\n\nFor plugin authors sharing their plugins, that means you can also effectively make private functions by placing them in a particular scope. As in, this will cause an error:\n\n    .el {\n        @plugin \"lib1\";\n    }\n    @value: foo();\n\nAs of Less 3.0, functions can return any kind of Node type, and can be called at any level.\n\nMeaning, this would throw an error in 2.x, as functions had to be part of the value of a property or variable assignment:\n\n    .block {\n        color: blue;\n        my-function-rules();\n    }\n\nIn 3.x, that's no longer the case, and functions can return At-Rules, Rulesets, any other Less node, strings, and numbers (the latter two are converted to Anonymous nodes).\n\n### Null Functions\n\nThere are times when you may want to call a function, but you don't want anything output (such as storing a value for later use). In that case, you just need to return `false` from the function.\n\n    var collection = [];\n\n    functions.add('store', function(val) {\n        collection.push(val);  // imma store this for later\n        return false;\n    });\n\n    @plugin \"collections\";\n    @var: 32;\n    store(@var);\n\nLater you could do something like:\n\n    functions.add('retrieve', function(val) {\n        return new tree.Value(collection);\n    });\n\n    .get-my-values {\n        @plugin \"collections\";\n        values: retrieve();   \n    }\n\n### The Less.js Plugin Object\n\nA Less.js plugin should export an object that has one or more of these properties.\n\n    {\n        /* Called immediately after the plugin is \n         * first imported, only once. */\n        install: function(less, pluginManager, functions) { },\n\n        /* Called for each instance of your @plugin. */\n        use: function(context) { },\n\n        /* Called for each instance of your @plugin, \n         * when rules are being evaluated.\n         * It's just later in the evaluation lifecycle */\n        eval: function(context) { },\n\n        /* Passes an arbitrary string to your plugin \n         * e.g. @plugin (args) \"file\";\n         * This string is not parsed for you, \n         * so it can contain (almost) anything */\n        setOptions: function(argumentString) { },\n\n        /* Set a minimum Less compatibility string\n         * You can also use an array, as in [3, 0] */\n        minVersion: ['3.0'],\n\n        /* Used for lessc only, to explain \n         * options in a Terminal */\n        printUsage: function() { },\n\n    }\n\nThe PluginManager instance for the `install()` function provides methods for adding visitors, file managers, and post-processors.\n\nHere are some example repos showing the different plugin types.\n\n- post-processor: <https://github.com/less/less-plugin-clean-css>\n- visitor: <https://github.com/less/less-plugin-inline-urls>\n- file-manager: <https://github.com/less/less-plugin-npm-import>\n\n### Pre-Loaded Plugins\n\nWhile a `@plugin` call works well for most scenarios, there are times when you might want to load a plugin before parsing starts.\n\nSee: [Pre-Loaded Plugins](usage#plugins) in the \"Using Less.js\" section for how to do that.\n\n## Maps (NEW!)\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nUse rulesets and mixins as maps of values\n\nBy combining namespacing with the lookup `[]` syntax, you can turn your rulesets / mixins into maps.\n\n    @sizes: {\n      mobile: 320px;\n      tablet: 768px;\n      desktop: 1024px;\n    }\n\n    .navbar {\n      display: block;\n\n      @media (min-width: @sizes[tablet]) {\n        display: inline-block;\n      }\n    }\n\nOutputs:\n\n    .navbar {\n      display: block;\n    }\n    @media (min-width: 768px) {\n      .navbar {\n        display: inline-block;\n      }\n    }\n\nMixins are a little more versatile as maps because of namespacing and the ability to overload mixins.\n\n    #library() {\n      .colors() {\n        primary: green;\n        secondary: blue;\n      }\n    }\n\n    #library() {\n      .colors() { primary: grey; }\n    }\n\n    .button {\n      color: #library.colors[primary];\n      border-color: #library.colors[secondary];\n    }\n\nOutputs:\n\n    .button {\n      color: grey;\n      border-color: blue;\n    }\n\nYou can also make this easier by [aliasing mixins](#mixins-feature-mixin-aliasing-feature). That is:\n\n    .button {\n      @colors: #library.colors();\n      color: @colors[primary];\n      border-color: @colors[secondary];\n    }\n\nNote, if a lookup value produces another ruleset, you can append a second `[]` lookup, as in:\n\n    @config: {\n      @options: {\n        library-on: true\n      }\n    }\n\n    & when (@config[@options][library-on] = true) {\n      .produce-ruleset {\n        prop: val;\n      }\n    }\n\nIn this way, rulesets and variable calls can emulate a type of \"namespacing\", similar to mixins.\n\nAs far as whether to use mixins or rulesets assigned to variables as maps, it's up to you. You may want to replace entire maps by re-declaring a variable assigned to a rulset. Or you may want to \"merge\" individual key/value pairs, in which case mixins as maps might be more appropriate.\n\n### Using variable variables in lookups\n\nOne important thing to notice is that the value in `[@lookup]` is the key (variable) name `@lookup`, and is not evaluated as a variable. If you want the key name itself to be variable, you can use the `@@variable` syntax.\n\nE.g.\n\n    .foods() {\n      @dessert: ice cream;\n    }\n\n    @key-to-lookup: dessert;\n\n    .lunch {\n      treat: .foods[@@key-to-lookup];\n    }\n\nThis would output:\n\n    .lunch {\n      treat: ice cream;\n    }\n\n© 2009–2020 The Core Less Team  \nLicensed under the Creative Commons Attribution License 3.0.  \n[http://lesscss.org/features](http://lesscss.org/features)"
- name: '@arguments'
  id: index#mixins-parametric-feature-the-arguments-variable
  summary: An in-depth guide to features of the LESS language
  description: "# Less\n\n## Overview\n\nAn in-depth guide to features of the LESS language. See the [Overview](http://lesscss.org/#overview) for a quick summary of Less.\n\n*For an in-depth guide to installing and setting up a Less environment, as well as documentation on developing for Less, see: [Using Less.js](usage).*\n\n## Variables\n\nControl commonly used values in a single location.\n\n### Overview\n\nIt's not uncommon to see the same value repeated dozens *if not hundreds of times* across your stylesheets:\n\n    a,\n    .link {\n      color: #428bca;\n    }\n    .widget {\n      color: #fff;\n      background: #428bca;\n    }\n\nVariables make your code easier to maintain by giving you a way to control those values from a single location:\n\n    // Variables\n    @link-color:        #428bca; // sea blue\n    @link-color-hover:  darken(@link-color, 10%);\n\n    // Usage\n    a,\n    .link {\n      color: @link-color;\n    }\n    a:hover {\n      color: @link-color-hover;\n    }\n    .widget {\n      color: #fff;\n      background: @link-color;\n    }\n\n### Variable Interpolation\n\nThe examples above focused on using variables to control *values in CSS rules*, but they can also be used in other places as well, such as selector names, property names, URLs and `@import` statements.\n\n### Selectors\n\n*v1.4.0*\n\n    // Variables\n    @my-selector: banner;\n\n    // Usage\n    .@{my-selector} {\n      font-weight: bold;\n      line-height: 40px;\n      margin: 0 auto;\n    }\n\nCompiles to:\n\n    .banner {\n      font-weight: bold;\n      line-height: 40px;\n      margin: 0 auto;\n    }\n\n### URLs\n\n    // Variables\n    @images: \"../img\";\n\n    // Usage\n    body {\n      color: #444;\n      background: url(\"@{images}/white-sand.png\");\n    }\n\n### Import Statements\n\n*v1.4.0*\n\nSyntax: `@import \"@{themes}/tidal-wave.less\";`\n\nNote that before v2.0.0, only variables which have been declared in the root or current scope were considered and that only the current file and calling files were considered when looking for a variable.\n\nExample:\n\n    // Variables\n    @themes: \"../../src/themes\";\n\n    // Usage\n    @import \"@{themes}/tidal-wave.less\";\n\n### Properties\n\n*v1.6.0*\n\n    @property: color;\n\n    .widget {\n      @{property}: #0ee;\n      background-@{property}: #999;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #0ee;\n      background-color: #999;\n    }\n\n### Variable Variables\n\nIn Less, you can define a variable's name using another variable.\n\n    @primary:  green;\n    @secondary: blue;\n\n    .section {\n      @color: primary;\n\n      .element {\n        color: @@color;\n      }\n    }\n\nWhich compiles to:\n\n    .section .element {\n      color: green;\n    }\n\n### Lazy Evaluation\n\nVariables do not have to be declared before being used.\n\nValid Less snippet:\n\n    .lazy-eval {\n      width: @var;\n    }\n\n    @var: @a;\n    @a: 9%;\n\nthis is valid Less too:\n\n    .lazy-eval {\n      width: @var;\n      @a: 9%;\n    }\n\n    @var: @a;\n    @a: 100%;\n\nboth compile into:\n\n    .lazy-eval {\n      width: 9%;\n    }\n\nWhen defining a variable twice, the last definition of the variable is used, searching from the current scope upwards. This is similar to css itself where the last property inside a definition is used to determine the value.\n\nFor instance:\n\n    @var: 0;\n    .class {\n      @var: 1;\n      .brass {\n        @var: 2;\n        three: @var;\n        @var: 3;\n      }\n      one: @var;\n    }\n\nCompiles to:\n\n    .class {\n      one: 1;\n    }\n    .class .brass {\n      three: 3;\n    }\n\nEssentially, each scope has a \"final\" value, similar to properties in the browser, like this example using custom properties:\n\n    .header {\n      --color: white;\n      color: var(--color);  // the color is black\n      --color: black;\n    }\n\nThis means that, unlike other CSS pre-processing languages, Less variables behave very much like CSS's.\n\n### Properties as Variables **(NEW!)**\n\n*v3.0.0*\n\nYou can easily treat properties like variables using the `$prop` syntax. Sometimes this can make your code a little lighter.\n\n    .widget {\n      color: #efefef;\n      background-color: $color;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #efefef;\n      background-color: #efefef;\n    }\n\nNote that, like variables, Less will choose the last property within the current/parent scope as being the \"final\" value.\n\n    .block {\n      color: red; \n      .inner {\n        background-color: $color; \n      }\n      color: blue;  \n    } \n\nCompiles to:\n\n    .block {\n      color: red; \n      color: blue;  \n    } \n    .block .inner {\n      background-color: blue; \n    }\n\n### Default Variables\n\nWe sometimes get requests for default variables - an ability to set a variable only if it is not already set. This feature is not required because you can easily override a variable by putting the definition afterwards.\n\nFor instance:\n\n    // library\n    @base-color: green;\n    @dark-color: darken(@base-color, 10%);\n\n    // use of library\n    @import \"library.less\";\n    @base-color: red;\n\nThis works fine because of [Lazy Loading](#variables-feature-lazy-loading) - `@base-color` is overridden and `@dark-color` is a dark red.\n\n## Parent Selectors\n\nReferencing parent selectors with `&`\n\nThe `&` operator represents the parent selectors of a [nested rule](#features-overview-feature-nested-rules) and is most commonly used when applying a modifying class or pseudo-class to an existing selector:\n\n    a {\n      color: blue;\n      &:hover {\n        color: green;\n      }\n    }\n\nresults in:\n\n    a {\n      color: blue;\n    }\n\n    a:hover {\n      color: green;\n    }\n\nNotice that without the `&`, the above example would result in `a :hover` rule (a descendant selector that matches hovered elements inside of `<a>` tags) and this is not what we typically would want with the nested `:hover`.\n\nThe \"parent selectors\" operator has a variety of uses. Basically any time you need the selectors of the nested rules to be combined in other ways than the default. For example another typical use of the `&` is to produce repetitive class names:\n\n    .button {\n      &-ok {\n        background-image: url(\"ok.png\");\n      }\n      &-cancel {\n        background-image: url(\"cancel.png\");\n      }\n\n      &-custom {\n        background-image: url(\"custom.png\");\n      }\n    }\n\noutput:\n\n    .button-ok {\n      background-image: url(\"ok.png\");\n    }\n    .button-cancel {\n      background-image: url(\"cancel.png\");\n    }\n    .button-custom {\n      background-image: url(\"custom.png\");\n    }\n\n### Multiple `&`\n\n`&` may appear more than once within a selector. This makes it possible to repeatedly refer to a parent selector without repeating its name.\n\n    .link {\n      & + & {\n        color: red;\n      }\n\n      & & {\n        color: green;\n      }\n\n      && {\n        color: blue;\n      }\n\n      &, &ish {\n        color: cyan;\n      }\n    }\n\nwill output:\n\n    .link + .link {\n      color: red;\n    }\n    .link .link {\n      color: green;\n    }\n    .link.link {\n      color: blue;\n    }\n    .link, .linkish {\n      color: cyan;\n    }\n\nNote that `&` represents all parent selectors (not just the nearest ancestor) so the following example:\n\n    .grand {\n      .parent {\n        & > & {\n          color: red;\n        }\n\n        & & {\n          color: green;\n        }\n\n        && {\n          color: blue;\n        }\n\n        &, &ish {\n          color: cyan;\n        }\n      }\n    }\n\nresults in:\n\n    .grand .parent > .grand .parent {\n      color: red;\n    }\n    .grand .parent .grand .parent {\n      color: green;\n    }\n    .grand .parent.grand .parent {\n      color: blue;\n    }\n    .grand .parent,\n    .grand .parentish {\n      color: cyan;\n    }\n\n### Changing Selector Order\n\nIt can be useful to prepend a selector to the inherited (parent) selectors. This can be done by putting the `&` after current selector. For example, when using Modernizr, you might want to specify different rules based on supported features:\n\n    .header {\n      .menu {\n        border-radius: 5px;\n        .no-borderradius & {\n          background-image: url('images/button-background.png');\n        }\n      }\n    }\n\nThe selector `.no-borderradius &` will prepend `.no-borderradius` to its parent `.header .menu` to form the`.no-borderradius .header .menu` on output:\n\n    .header .menu {\n      border-radius: 5px;\n    }\n    .no-borderradius .header .menu {\n      background-image: url('images/button-background.png');\n    }\n\n### Combinatorial Explosion\n\n`&` can also be used to generate every possible permutation of selectors in a comma separated list:\n\n    p, a, ul, li {\n      border-top: 2px dotted #366;\n      & + & {\n        border-top: 0;\n      }\n    }\n\nThis expands to all possible (16) combinations of the specified elements:\n\n    p,\n    a,\n    ul,\n    li {\n      border-top: 2px dotted #366;\n    }\n    p + p,\n    p + a,\n    p + ul,\n    p + li,\n    a + p,\n    a + a,\n    a + ul,\n    a + li,\n    ul + p,\n    ul + a,\n    ul + ul,\n    ul + li,\n    li + p,\n    li + a,\n    li + ul,\n    li + li {\n      border-top: 0;\n    }\n\n## Extend\n\nExtend is a Less pseudo-class which merges the selector it is put on with ones that match what it references.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\n    nav ul {\n      &:extend(.inline);\n      background: blue;\n    }\n\nIn the rule set above, the `:extend` selector will apply the \"extending selector\" (`nav ul`) onto the `.inline` class *wherever the `.inline` class appears*. The declaration block will be kept as-is, but without any reference to the extend (because extend isn't css).\n\nSo the following:\n\n    nav ul {\n      &:extend(.inline);\n      background: blue;\n    }\n    .inline {\n      color: red;\n    }\n\nOutputs\n\n    nav ul {\n      background: blue;\n    }\n    .inline,\n    nav ul {\n      color: red;\n    }\n\nNotice how the `nav ul:extend(.inline)` selector gets output as `nav ul` - the extend gets removed before output and the selector block left as-is. If no properties are put in that block then it gets removed from the output (but the extend still may affect other selectors).\n\n### Extend Syntax\n\nThe extend is either attached to a selector or placed into a ruleset. It looks like a pseudo-class with selector parameter optionally followed by the keyword `all`:\n\nExample:\n\n    .a:extend(.b) {}\n\n    // the above block does the same thing as the below block\n    .a {\n      &:extend(.b);\n    }\n\n    .c:extend(.d all) {\n      // extends all instances of \".d\" e.g. \".x.d\" or \".d.x\"\n    }\n    .c:extend(.d) {\n      // extends only instances where the selector will be output as just \".d\"\n    }\n\nIt can contain one or more classes to extend, separated by commas.\n\nExample:\n\n    .e:extend(.f) {}\n    .e:extend(.g) {}\n\n    // the above and the below do the same thing\n    .e:extend(.f, .g) {}\n\n### Extend Attached to Selector\n\nExtend attached to a selector looks like an ordinary pseudo-class with selector as a parameter. A selector can contain multiple extend clauses, but all extends must be at the end of the selector.\n\n- Extend after the selector: `pre:hover:extend(div pre)`.\n- Space between selector and extend is allowed: `pre:hover :extend(div pre)`.\n- Multiple extends are allowed: `pre:hover:extend(div pre):extend(.bucket tr)` - Note this is the same as `pre:hover:extend(div pre, .bucket tr)`\n- This is NOT allowed: `pre:hover:extend(div pre).nth-child(odd)`. Extend must be last.\n\nIf a ruleset contains multiple selectors, any of them can have the extend keyword. Multiple selectors with extend in one ruleset:\n\n    .big-division,\n    .big-bag:extend(.bag),\n    .big-bucket:extend(.bucket) {\n      // body\n    }\n\n### Extend Inside Ruleset\n\nExtend can be placed into a ruleset's body using `&:extend(selector)` syntax. Placing extend into a body is a shortcut for placing it into every single selector of that ruleset.\n\nExtend inside a body:\n\n    pre:hover,\n    .some-class {\n      &:extend(div pre);\n    }\n\nis exactly the same as adding an extend after each selector:\n\n    pre:hover:extend(div pre),\n    .some-class:extend(div pre) {}\n\n### Extending Nested Selectors\n\nExtend is able to match nested selectors. Following less:\n\nExample:\n\n    .bucket {\n      tr { // nested ruleset with target selector\n        color: blue;\n      }\n    }\n    .some-class:extend(.bucket tr) {} // nested ruleset is recognized\n\nOutputs\n\n    .bucket tr,\n    .some-class {\n      color: blue;\n    }\n\nEssentially the extend looks at the compiled css, not the original less.\n\nExample:\n\n    .bucket {\n      tr & { // nested ruleset with target selector\n        color: blue;\n      }\n    }\n    .some-class:extend(tr .bucket) {} // nested ruleset is recognized\n\nOutputs\n\n    tr .bucket,\n    .some-class {\n      color: blue;\n    }\n\n### Exact Matching with Extend\n\nExtend by default looks for exact match between selectors. It does matter whether selector uses leading star or not. It does not matter that two nth-expressions have the same meaning, they need to have to same form in order to be matched. The only exception are quotes in attribute selector, less knows they have the same meaning and matches them.\n\nExample:\n\n    .a.class,\n    .class.a,\n    .class > .a {\n      color: blue;\n    }\n    .test:extend(.class) {} // this will NOT match the any selectors above\n\nLeading star does matter. Selectors `*.class` and `.class` are equivalent, but extend will not match them:\n\n    *.class {\n      color: blue;\n    }\n    .noStar:extend(.class) {} // this will NOT match the *.class selector\n\nOutputs\n\n    *.class {\n      color: blue;\n    }\n\nOrder of pseudo-classes does matter. Selectors `link:hover:visited` and `link:visited:hover` match the same set of elements, but extend treats them as different:\n\n    link:hover:visited {\n      color: blue;\n    }\n    .selector:extend(link:visited:hover) {}\n\nOutputs\n\n    link:hover:visited {\n      color: blue;\n    }\n\n### nth Expression\n\nNth expression form does matter. Nth-expressions `1n+3` and `n+3` are equivalent, but extend will not match them:\n\n    :nth-child(1n+3) {\n      color: blue;\n    }\n    .child:extend(:nth-child(n+3)) {}\n\nOutputs\n\n    :nth-child(1n+3) {\n      color: blue;\n    }\n\nQuote type in attribute selector does not matter. All of the following are equivalent.\n\n    [title=identifier] {\n      color: blue;\n    }\n    [title='identifier'] {\n      color: blue;\n    }\n    [title=\"identifier\"] {\n      color: blue;\n    }\n\n    .noQuote:extend([title=identifier]) {}\n    .singleQuote:extend([title='identifier']) {}\n    .doubleQuote:extend([title=\"identifier\"]) {}\n\nOutputs\n\n    [title=identifier],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n    [title='identifier'],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n    [title=\"identifier\"],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n### Extend \"all\"\n\nWhen you specify the all keyword last in an extend argument it tells Less to match that selector as part of another selector. The selector will be copied and the matched part of the selector only will then be replaced with the extend, making a new selector.\n\nExample:\n\n    .a.b.test,\n    .test.c {\n      color: orange;\n    }\n    .test {\n      &:hover {\n        color: green;\n      }\n    }\n\n    .replacement:extend(.test all) {}\n\nOutputs\n\n    .a.b.test,\n    .test.c,\n    .a.b.replacement,\n    .replacement.c {\n      color: orange;\n    }\n    .test:hover,\n    .replacement:hover {\n      color: green;\n    }\n\n*You can think of this mode of operation as essentially doing a non-destructive search and replace.*\n\n### Selector Interpolation with Extend\n\nExtend is **not** able to match selectors with variables. If selector contains variable, extend will ignore it.\n\nHowever, extend can be attached to interpolated selector.\n\nSelector with variable will not be matched:\n\n    @variable: .bucket;\n    @{variable} { // interpolated selector\n      color: blue;\n    }\n    .some-class:extend(.bucket) {} // does nothing, no match is found\n\nand extend with variable in target selector matches nothing:\n\n    .bucket {\n      color: blue;\n    }\n    .some-class:extend(@{variable}) {} // interpolated selector matches nothing\n    @variable: .bucket;\n\nBoth of the above examples compile into:\n\n    .bucket {\n      color: blue;\n    }\n\nHowever, `:extend` attached to an interpolated selector works:\n\n    .bucket {\n      color: blue;\n    }\n    @{variable}:extend(.bucket) {}\n    @variable: .selector;\n\ncompiles to:\n\n    .bucket, .selector {\n      color: blue;\n    }\n\n### Scoping / Extend Inside @media\n\nCurrently, an `:extend` inside a `@media` declaration will only match selectors inside the same media declaration:\n\n    @media print {\n      .screenClass:extend(.selector) {} // extend inside media\n      .selector { // this will be matched - it is in the same media\n        color: black;\n      }\n    }\n    .selector { // ruleset on top of style sheet - extend ignores it\n      color: red;\n    }\n    @media screen {\n      .selector {  // ruleset inside another media - extend ignores it\n        color: blue;\n      }\n    }\n\ncompiles into:\n\n    @media print {\n      .selector,\n      .screenClass { /*  ruleset inside the same media was extended */\n        color: black;\n      }\n    }\n    .selector { /* ruleset on top of style sheet was ignored */\n      color: red;\n    }\n    @media screen {\n      .selector { /* ruleset inside another media was ignored */\n        color: blue;\n      }\n    }\n\nNote: extending does not match selectors inside a nested `@media` declaration:\n\n    @media screen {\n      .screenClass:extend(.selector) {} // extend inside media\n      @media (min-width: 1023px) {\n        .selector {  // ruleset inside nested media - extend ignores it\n          color: blue;\n        }\n      }\n    }\n\nThis compiles into:\n\n    @media screen and (min-width: 1023px) {\n      .selector { /* ruleset inside another nested media was ignored */\n        color: blue;\n      }\n    }\n\nTop level extend matches everything including selectors inside nested media:\n\n    @media screen {\n      .selector {  /* ruleset inside nested media - top level extend works */\n        color: blue;\n      }\n      @media (min-width: 1023px) {\n        .selector {  /* ruleset inside nested media - top level extend works */\n          color: blue;\n        }\n      }\n    }\n\n    .topLevel:extend(.selector) {} /* top level extend matches everything */\n\ncompiles into:\n\n    @media screen {\n      .selector,\n      .topLevel { /* ruleset inside media was extended */\n        color: blue;\n      }\n    }\n    @media screen and (min-width: 1023px) {\n      .selector,\n      .topLevel { /* ruleset inside nested media was extended */\n        color: blue;\n      }\n    }\n\n### Duplication Detection\n\nCurrently there is no duplication detection.\n\nExample:\n\n    .alert-info,\n    .widget {\n      /* declarations */\n    }\n\n    .alert:extend(.alert-info, .widget) {}\n\nOutputs\n\n    .alert-info,\n    .widget,\n    .alert,\n    .alert {\n      /* declarations */\n    }\n\n### Use Cases for Extend\n\n### Classic Use Case\n\nThe classic use case is to avoid adding a base class. For example, if you have\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n\nand you want to have a subtype of animal which overrides the background color then you have two options, firstly change your HTML\n\n    <a class=\"animal bear\">Bear</a>\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n    .bear {\n      background-color: brown;\n    }\n\nor have simplified html and use extend in your less. e.g.\n\n    <a class=\"bear\">Bear</a>\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n    .bear {\n      &:extend(.animal);\n      background-color: brown;\n    }\n\n### Reducing CSS Size\n\nMixins copy all of the properties into a selector, which can lead to unnecessary duplication. Therefore you can use extends instead of mixins to move the selector up to the properties you wish to use, which leads to less CSS being generated.\n\nExample - with mixin:\n\n    .my-inline-block() {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing1 {\n      .my-inline-block;\n    }\n    .thing2 {\n      .my-inline-block;\n    }\n\nOutputs\n\n    .thing1 {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing2 {\n      display: inline-block;\n      font-size: 0;\n    }\n\nExample (with extends):\n\n    .my-inline-block {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing1 {\n      &:extend(.my-inline-block);\n    }\n    .thing2 {\n      &:extend(.my-inline-block);\n    }\n\nOutputs\n\n    .my-inline-block,\n    .thing1,\n    .thing2 {\n      display: inline-block;\n      font-size: 0;\n    }\n\n### Combining Styles / A More Advanced Mixin\n\nAnother use-case is as an alternative for a mixin - because mixins can only be used with simple selectors, if you have two different blocks of html, but need to apply the same styles to both you can use extends to relate two areas.\n\nExample:\n\n    li.list > a {\n      // list styles\n    }\n    button.list-style {\n      &:extend(li.list > a); // use the same list styles\n    }\n\n## Merge\n\nCombine properties\n\nThe `merge` feature allows for aggregating values from multiple properties into a comma or space separated list under a single property. `merge` is useful for properties such as background and transform.\n\n### Comma\n\nAppend property value with comma\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    .mixin() {\n      box-shadow+: inset 0 0 10px #555;\n    }\n    .myclass {\n      .mixin();\n      box-shadow+: 0 0 20px black;\n    }\n\nOutputs\n\n    .myclass {\n      box-shadow: inset 0 0 10px #555, 0 0 20px black;\n    }\n\n### Space\n\nAppend property value with space\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    .mixin() {\n      transform+_: scale(2);\n    }\n    .myclass {\n      .mixin();\n      transform+_: rotate(15deg);\n    }\n\nOutputs\n\n    .myclass {\n      transform: scale(2) rotate(15deg);\n    }\n\nTo avoid any unintentional joins, `merge` requires an explicit `+` or `+_` flag on each join pending declaration.\n\n## Mixins\n\n\"mix-in\" properties from existing styles\n\nYou can mix-in class selectors and id selectors, e.g.\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      .a();\n    }\n    .mixin-id {\n      #b();\n    }\n\nwhich results in:\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      color: red;\n    }\n    .mixin-id {\n      color: red;\n    }\n\nHistorically, the parentheses in a mixin call are optional, but optional parentheses are deprecated and will be required in a future release.\n\n    .a(); \n    .a;    // currently works, but deprecated; don't use\n    .a (); // white-space before parentheses is also deprecated\n\n### Mixins With Parentheses\n\nIf you want to create a mixin but you do not want that mixin to be in your CSS output, put parentheses after the mixin definition.\n\n    .my-mixin {\n      color: black;\n    }\n    .my-other-mixin() {\n      background: white;\n    }\n    .class {\n      .my-mixin();\n      .my-other-mixin();\n    }\n\noutputs\n\n    .my-mixin {\n      color: black;\n    }\n    .class {\n      color: black;\n      background: white;\n    }\n\n### Selectors in Mixins\n\nMixins can contain more than just properties, they can contain selectors too.\n\nFor example:\n\n    .my-hover-mixin() {\n      &:hover {\n        border: 1px solid red;\n      }\n    }\n    button {\n      .my-hover-mixin();\n    }\n\nOutputs\n\n    button:hover {\n      border: 1px solid red;\n    }\n\n### Namespaces\n\nIf you want to mixin properties inside a more complicated selector, you can stack up multiple ids or classes.\n\n    #outer() {\n      .inner {\n        color: red;\n      }\n    }\n\n    .c {\n      #outer.inner();\n    }\n\nNote: legacy Less syntax allows `>` and whitespace between namespaces and mixins. This syntax is deprecated and may be removed. Currently, these do the same thing.\n\n    #outer > .inner(); // deprecated\n    #outer .inner();   // deprecated\n    #outer.inner();    // preferred\n\nNamespacing your mixins like this reduces conflicts with other library mixins or user mixins, but can also be a way to \"organize\" groups of mixins.\n\nExample:\n\n    #my-library {\n      .my-mixin() {\n        color: black;\n      }\n    }\n    // which can be used like this\n    .class {\n      #my-library.my-mixin();\n    }\n\n### Guarded Namespaces\n\nIf a namespace has a guard, mixins defined by it are used only if the guard condition returns true. A namespace guard is evaluated exactly the same as a guard on a mixin, so the following two mixins work the same way:\n\n    #namespace when (@mode = huge) {\n      .mixin() { /* */ }\n    }\n\n    #namespace {\n      .mixin() when (@mode = huge) { /* */ }\n    }\n\nThe `default` function is assumed to have the same value for all nested namespaces and mixin. The following mixin is never evaluated; one of its guards is guaranteed to be false:\n\n    #sp_1 when (default()) {\n      #sp_2 when (default()) {\n        .mixin() when not(default()) { /* */ }\n      }\n    }\n\n### The `!important` keyword\n\nUse the `!important` keyword after mixin call to mark all properties inherited by it as `!important`:\n\nExample:\n\n    .foo (@bg: #f5f5f5; @color: #900) {\n      background: @bg;\n      color: @color;\n    }\n    .unimportant {\n      .foo();\n    }\n    .important {\n      .foo() !important;\n    }\n\nResults in:\n\n    .unimportant {\n      background: #f5f5f5;\n      color: #900;\n    }\n    .important {\n      background: #f5f5f5 !important;\n      color: #900 !important;\n    }\n\n### Parametric Mixins\n\nHow to pass arguments to mixins\n\nMixins can also take arguments, which are variables passed to the block of selectors when it is mixed in.\n\nFor example:\n\n    .border-radius(@radius) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nAnd here's how we can mix it into various rulesets:\n\n    #header {\n      .border-radius(4px);\n    }\n    .button {\n      .border-radius(6px);\n    }\n\nParametric mixins can also have default values for their parameters:\n\n    .border-radius(@radius: 5px) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nWe can invoke it like this now:\n\n    #header {\n      .border-radius();\n    }\n\nAnd it will include a 5px border-radius.\n\nYou can also use parametric mixins which don't take parameters. This is useful if you want to hide the ruleset from the CSS output, but want to include its properties in other rulesets:\n\n    .wrap() {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n    pre { .wrap() }\n\nWhich would output:\n\n    pre {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n### Parameter separators\n\nParameters are currently either *semicolon* or *comma* separated.\n\nOriginally, parameters were only separated by commas, but the semi-colon was later added to support passing comma-separated list values to single arguments.\n\n- two arguments and each contains comma separated list: `.name(1, 2, 3; something, else)`,\n- three arguments and each contains one number: `.name(1, 2, 3)`,\n- use dummy semicolon to create mixin call with one argument containing comma separated css list: `.name(1, 2, 3;)`,\n- comma separated default value: `.name(@param1: red, blue;)`.\n- As of Less 4.0, you can wrap a list value using a paren escape \\[`~()`\\], e.g. `.name(@param1: ~(red, blue))`. This is similar to the quote escape syntax: `~\"quote\"`\n\n### Overloading mixins\n\nIt is legal to define multiple mixins with the same name and number of parameters. Less will use properties of all that can apply. If you used the mixin with one parameter e.g. `.mixin(green);`, then properties of all mixins with exactly one mandatory parameter will be used:\n\n    .mixin(@color) {\n      color-1: @color;\n    }\n    .mixin(@color, @padding: 2) {\n      color-2: @color;\n      padding-2: @padding;\n    }\n    .mixin(@color, @padding, @margin: 2) {\n      color-3: @color;\n      padding-3: @padding;\n      margin: @margin @margin @margin @margin;\n    }\n    .some .selector div {\n      .mixin(#008000);\n    }\n\ncompiles into:\n\n    .some .selector div {\n      color-1: #008000;\n      color-2: #008000;\n      padding-2: 2;\n    }\n\n### Named Parameters\n\nA mixin reference can supply parameters values by their names instead of just positions. Any parameter can be referenced by its name and they do not have to be in any special order:\n\n    .mixin(@color: black; @margin: 10px; @padding: 20px) {\n      color: @color;\n      margin: @margin;\n      padding: @padding;\n    }\n    .class1 {\n      .mixin(@margin: 20px; @color: #33acfe);\n    }\n    .class2 {\n      .mixin(#efca44; @padding: 40px);\n    }\n\ncompiles into:\n\n    .class1 {\n      color: #33acfe;\n      margin: 20px;\n      padding: 20px;\n    }\n    .class2 {\n      color: #efca44;\n      margin: 10px;\n      padding: 40px;\n    }\n\n### The `@arguments` Variable\n\n`@arguments` has a special meaning inside mixins, it contains all the arguments passed, when the mixin was called. This is useful if you don't want to deal with individual parameters:\n\n    .box-shadow(@x: 0, @y: 0, @blur: 1px, @color: #000) {\n      -webkit-box-shadow: @arguments;\n         -moz-box-shadow: @arguments;\n              box-shadow: @arguments;\n    }\n    .big-block {\n      .box-shadow(2px, 5px);\n    }\n\nWhich results in:\n\n    .big-block {\n      -webkit-box-shadow: 2px 5px 1px #000;\n         -moz-box-shadow: 2px 5px 1px #000;\n              box-shadow: 2px 5px 1px #000;\n    }\n\n### Advanced Arguments and the `@rest` Variable\n\nYou can use `...` if you want your mixin to take a variable number of arguments. Using this after a variable name will assign those arguments to the variable.\n\n    .mixin(...) {        // matches 0-N arguments\n    .mixin() {           // matches exactly 0 arguments\n    .mixin(@a: 1) {      // matches 0-1 arguments\n    .mixin(@a: 1, ...) { // matches 0-N arguments\n    .mixin(@a, ...) {    // matches 1-N arguments\n\nFurthermore:\n\n    .mixin(@a, @rest...) {\n       // @rest is bound to arguments after @a\n       // @arguments is bound to all arguments\n    }\n\n### Pattern-matching\n\nSometimes, you may want to change the behavior of a mixin, based on the parameters you pass to it. Let's start with something basic:\n\n    .mixin(@s, @color) { ... }\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nNow let's say we want `.mixin` to behave differently, based on the value of `@switch`, we could define `.mixin` as such:\n\n    .mixin(dark, @color) {\n      color: darken(@color, 10%);\n    }\n    .mixin(light, @color) {\n      color: lighten(@color, 10%);\n    }\n    .mixin(@_, @color) {\n      display: block;\n    }\n\nNow, if we run:\n\n    @switch: light;\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nWe will get the following CSS:\n\n    .class {\n      color: #a2a2a2;\n      display: block;\n    }\n\nWhere the color passed to `.mixin` was lightened. If the value of `@switch` was `dark`, the result would be a darker color.\n\nHere's what happened:\n\n- The first mixin definition didn't match because it expected `dark` as the first argument.\n- The second mixin definition matched, because it expected `light`.\n- The third mixin definition matched because it expected any value.\n\nOnly mixin definitions which matched were used. Variables match and bind to any value. Anything other than a variable matches only with a value equal to itself.\n\nWe can also match on arity, here's an example:\n\n    .mixin(@a) {\n      color: @a;\n    }\n    .mixin(@a, @b) {\n      color: fade(@a, @b);\n    }\n\nNow if we call `.mixin` with a single argument, we will get the output of the first definition, but if we call it with *two* arguments, we will get the second definition, namely `@a` faded to `@b`.\n\n### Using Mixins as Functions\n\nSelecting properties and variables from mixin calls\n\n### Property / value accessors\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors to select a value from an evaluated mixin's rules. This can allow you to use mixins similar to functions.\n\nExample:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its \"@result\" value\n      padding: .average(16px, 50px)[@result];\n    }\n\nResults in:\n\n    div {\n      padding: 33px;\n    }\n\n### Overriding mixin values\n\nIf you have multiple matching mixins, all rules are evaluated and merged, and the last matching value with that identifier is returned. This is similar to the cascade in CSS, and it allows you to \"override\" mixin values.\n\n    // library.less\n    #library() {\n      .mixin() {\n        prop: foo;\n      }\n    }\n\n    // customize.less\n    @import \"library\";\n    #library() {\n      .mixin() {\n        prop: bar;\n      }\n    }\n\n    .box {\n      my-value: #library.mixin[prop];\n    }\n\nOutputs:\n\n    .box {\n      my-value: bar;\n    }\n\n### Unnamed lookups\n\nIf you don't specify a lookup value in `[@lookup]` and instead write `[]` after a mixin or ruleset call, *all* values will cascade and the last declared value will be selected.\n\nMeaning: the averaging mixin from the above example could be written as:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its final value\n      padding: .average(16px, 50px)[];\n    }\n\nThe output is the same:\n\n    div {\n      padding: 33px;\n    }\n\nThe same cascading behavior is true for rulesets or variables aliased to mixin calls.\n\n    @dr: {\n      value: foo;\n    }\n    .box {\n      my-value: @dr[];\n    }\n\nThis outputs:\n\n    .box {\n      my-value: foo;\n    }\n\n### Unlocking mixins & variables into caller scope\n\n***DEPRECATED - Use Property / Value Accessors***\n\nVariables and mixins defined in a mixin are visible and can be used in caller's scope. There is only one exception: a variable is not copied if the caller contains a variable with the same name (that includes variables defined by another mixin call). Only variables present in callers local scope are protected. Variables inherited from parent scopes are overridden.\n\n*Note: this behavior is deprecated, and in the future, variables and mixins will not be merged into the caller scope in this way.*\n\nExample:\n\n    .mixin() {\n      @width:  100%;\n      @height: 200px;\n    }\n\n    .caller {\n      .mixin();\n      width:  @width;\n      height: @height;\n    }\n\nResults in:\n\n    .caller {\n      width:  100%;\n      height: 200px;\n    }\n\nVariables defined directly in callers scope cannot be overridden. However, variables defined in callers parent scope is not protected and will be overridden:\n\n    .mixin() {\n      @size: in-mixin;\n      @definedOnlyInMixin: in-mixin;\n    }\n\n    .class {\n      margin: @size @definedOnlyInMixin;\n      .mixin();\n    }\n\n    @size: globaly-defined-value; // callers parent scope - no protection\n\nResults in:\n\n    .class {\n      margin: in-mixin in-mixin;\n    }\n\nFinally, mixin defined in mixin acts as return value too:\n\n    .unlock(@value) { // outer mixin\n      .doSomething() { // nested mixin\n        declaration: @value;\n      }\n    }\n\n    #namespace {\n      .unlock(5); // unlock doSomething mixin\n      .doSomething(); //nested mixin was copied here and is usable\n    }\n\nResults in:\n\n    #namespace {\n      declaration: 5;\n    }\n\n### Recursive Mixins\n\nCreating loops\n\nIn Less a mixin can call itself. Such recursive mixins, when combined with [Guard Expressions](#mixin-guards-feature) and [Pattern Matching](#mixins-parametric-feature-pattern-matching), can be used to create various iterative/loop structures.\n\nExample:\n\n    .loop(@counter) when (@counter > 0) {\n      .loop((@counter - 1));    // next iteration\n      width: (10px * @counter); // code for each iteration\n    }\n\n    div {\n      .loop(5); // launch the loop\n    }\n\nOutput:\n\n    div {\n      width: 10px;\n      width: 20px;\n      width: 30px;\n      width: 40px;\n      width: 50px;\n    }\n\nA generic example of using a recursive loop to generate CSS grid classes:\n\n    .generate-columns(4);\n\n    .generate-columns(@n, @i: 1) when (@i =< @n) {\n      .column-@{i} {\n        width: (@i * 100% / @n);\n      }\n      .generate-columns(@n, (@i + 1));\n    }\n\nOutput:\n\n    .column-1 {\n      width: 25%;\n    }\n    .column-2 {\n      width: 50%;\n    }\n    .column-3 {\n      width: 75%;\n    }\n    .column-4 {\n      width: 100%;\n    }\n\n### Mixin Guards\n\nGuards are useful when you want to match on *expressions*, as opposed to simple values or arity. If you are familiar with functional programming, you have probably encountered them already.\n\nIn trying to stay as close as possible to the declarative nature of CSS, Less has opted to implement conditional execution via **guarded mixins** instead of `if`/`else` statements, in the vein of `@media` query feature specifications.\n\nLet's start with an example:\n\n    .mixin(@a) when (lightness(@a) >= 50%) {\n      background-color: black;\n    }\n    .mixin(@a) when (lightness(@a) < 50%) {\n      background-color: white;\n    }\n    .mixin(@a) {\n      color: @a;\n    }\n\nThe key is the `when` keyword, which introduces a guard sequence (here with only one guard). Now if we run the following code:\n\n    .class1 { .mixin(#ddd) }\n    .class2 { .mixin(#555) }\n\nHere's what we'll get:\n\n    .class1 {\n      background-color: black;\n      color: #ddd;\n    }\n    .class2 {\n      background-color: white;\n      color: #555;\n    }\n\n### Guard Comparison Operators\n\nThe full list of comparison operators usable in guards are: `>`, `>=`, `=`, `=<`, `<`. Additionally, the keyword `true` is the only truthy value, making these two mixins equivalent:\n\n    .truth(@a) when (@a) { ... }\n    .truth(@a) when (@a = true) { ... }\n\nAny value other than the keyword `true` is falsy:\n\n    .class {\n      .truth(40); // Will not match any of the above definitions.\n    }\n\nNote that you can also compare arguments with each other, or with non-arguments:\n\n    @media: mobile;\n\n    .mixin(@a) when (@media = mobile) { ... }\n    .mixin(@a) when (@media = desktop) { ... }\n\n    .max(@a; @b) when (@a > @b) { width: @a }\n    .max(@a; @b) when (@a < @b) { width: @b }\n\n### Guard Logical Operators\n\nYou can use logical operators with guards. The syntax is based on CSS media queries.\n\nUse the `and` keyword to combine guards:\n\n    .mixin(@a) when (isnumber(@a)) and (@a > 0) { ... }\n\nYou can emulate the *or* operator by separating guards with a comma `,`. If any of the guards evaluate to true, it's considered a match:\n\n    .mixin(@a) when (@a > 10), (@a < -10) { ... }\n\nUse the `not` keyword to negate conditions:\n\n    .mixin(@b) when not (@b > 0) { ... }\n\n### Type Checking Functions\n\nLastly, if you want to match mixins based on value type, you can use the `is` functions:\n\n    .mixin(@a; @b: 0) when (isnumber(@b)) { ... }\n    .mixin(@a; @b: black) when (iscolor(@b)) { ... }\n\nHere are the basic type checking functions:\n\n- `iscolor`\n- `isnumber`\n- `isstring`\n- `iskeyword`\n- `isurl`\n\nIf you want to check if a value is in a specific unit in addition to being a number, you may use one of:\n\n- `ispixel`\n- `ispercentage`\n- `isem`\n- `isunit`\n\n### Aliasing Mixins\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nAssigning mixin calls to a variable\n\nMixins can be assigned to a variable to be called as a variable call, or can be used for map lookup.\n\n    #theme.dark.navbar {\n      .colors(light) {\n        primary: purple;\n      }\n      .colors(dark) {\n        primary: black;\n        secondary: grey;\n      }\n    }\n\n    .navbar {\n      @colors: #theme.dark.navbar.colors(dark);\n      background: @colors[primary];\n      border: 1px solid @colors[secondary];\n    }\n\nThis would output:\n\n    .navbar {\n      background: black;\n      border: 1px solid grey;\n    }\n\n### Variable calls\n\nEntire mixin calls can be aliased and called as variable calls. As in:\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors();\n      @alias();\n    }\n\nOutputs:\n\n    .box {\n      background: green;\n    }\n\nNote, unlike mixins used in root, mixin calls assigned to variables and *called with no arguments* always require parentheses. The following is not valid.\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors;\n      @alias();   // ERROR: Could not evaluate variable call @alias\n    }\n\nThis is because it's ambiguous if variable is assigned a list of selectors or a mixin call. For example, in Less 3.5+, this variable could be used this way.\n\n    .box {\n      @alias: #library.colors;\n      @{alias} {\n        a: b;\n      }\n    }\n\nThe above would output:\n\n    .box #library.colors {\n      a: b;\n    }\n\n## CSS Guards\n\n\"if\"'s around selectors\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nLike Mixin Guards, guards can also be applied to css selectors, which is syntactic sugar for declaring the mixin and then calling it immediately.\n\nFor instance, before 1.5.0 you would have had to do this:\n\n    .my-optional-style() when (@my-option = true) {\n      button {\n        color: white;\n      }\n    }\n    .my-optional-style();\n\nNow, you can apply the guard directly to a style.\n\n    button when (@my-option = true) {\n      color: white;\n    }\n\nYou can also achieve an `if` type statement by combining this with the `&` feature, allowing you to group multiple guards.\n\n    & when (@my-option = true) {\n      button {\n        color: white;\n      }\n      a {\n        color: blue;\n      }\n    }\n\nNote that you can also achieve a similar pattern by using the actual `if()` function and a variable call. As in:\n\n    @dr: if(@my-option = true, {\n      button {\n        color: white;\n      }\n      a {\n        color: blue;\n      }\n    });\n    @dr();\n\n## Detached Rulesets\n\nAssign a ruleset to a variable\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nA detached ruleset is a group of css properties, nested rulesets, media declarations or anything else stored in a variable. You can include it into a ruleset or another structure and all its properties are going to be copied there. You can also use it as a mixin argument and pass it around as any other variable.\n\nSimple example:\n\n    // declare detached ruleset\n    @detached-ruleset: { background: red; }; // semi-colon is optional in 3.5.0+\n\n    // use detached ruleset\n    .top {\n        @detached-ruleset(); \n    }\n\ncompiles into:\n\n    .top {\n      background: red;\n    }\n\nParentheses after a detached ruleset call are mandatory (except when followed by a [lookup value](#detached-rulesets-feature-property-variable-accessors)). The call `@detached-ruleset;` would not work.\n\nIt is useful when you want to define a mixin that abstracts out either wrapping a piece of code in a media query or a non-supported browser class name. The rulesets can be passed to mixin so that the mixin can wrap the content, e.g.\n\n    .desktop-and-old-ie(@rules) {\n      @media screen and (min-width: 1200px) { @rules(); }\n      html.lt-ie9 &                         { @rules(); }\n    }\n\n    header {\n      background-color: blue;\n\n      .desktop-and-old-ie({\n        background-color: red;\n      });\n    }\n\nHere the `desktop-and-old-ie` mixin defines the media query and root class so that you can use a mixin to wrap a piece of code. This will output\n\n    header {\n      background-color: blue;\n    }\n    @media screen and (min-width: 1200px) {\n      header {\n        background-color: red;\n      }\n    }\n    html.lt-ie9 header {\n      background-color: red;\n    }\n\nA ruleset can be now assigned to a variable or passed in to a mixin and can contain the full set of Less features, e.g.\n\n    @my-ruleset: {\n        .my-selector {\n          background-color: black;\n        }\n      };\n\nYou can even take advantage of [media query bubbling](#features-overview-feature-media-query-bubbling-and-nested-media-queries), for instance\n\n    @my-ruleset: {\n        .my-selector {\n          @media tv {\n            background-color: black;\n          }\n        }\n      };\n    @media (orientation:portrait) {\n        @my-ruleset();\n    }\n\nwhich will output\n\n    @media (orientation: portrait) and tv {\n      .my-selector {\n        background-color: black;\n      }\n    }\n\nA detached ruleset call unlocks (returns) all its mixins into caller the same way as mixin calls do. However, it does **not** return variables.\n\nReturned mixin:\n\n    // detached ruleset with a mixin\n    @detached-ruleset: { \n        .mixin() {\n            color: blue;\n        }\n    };\n    // call detached ruleset\n    .caller {\n        @detached-ruleset(); \n        .mixin();\n    }\n\nResults in:\n\n    .caller {\n      color: blue;\n    }\n\nPrivate variables:\n\n    @detached-ruleset: { \n        @color:blue; // this variable is private\n    };\n    .caller {\n        color: @color; // syntax error\n    }\n\n### Scoping\n\nA detached ruleset can use all variables and mixins accessible where it is *defined* and where it is *called*. Otherwise said, both definition and caller scopes are available to it. If both scopes contains the same variable or mixin, declaration scope value takes precedence.\n\n*Declaration scope* is the one where detached ruleset body is defined. Copying a detached ruleset from one variable into another cannot modify its scope. The ruleset does not gain access to new scopes just by being referenced there.\n\nLastly, a detached ruleset can gain access to scope by being unlocked (imported) into it.\n\n*Note: unlocking variables into scope via a called mixin is deprecated. Use [property / variable accessors](#detached-rulesets-feature-property-variable-accessors).*\n\n### Definition and Caller Scope Visibility\n\nA detached ruleset sees the caller's variables and mixins:\n\n    @detached-ruleset: {\n      caller-variable: @caller-variable; // variable is undefined here\n      .caller-mixin(); // mixin is undefined here\n    };\n\n    selector {\n      // use detached ruleset\n      @detached-ruleset(); \n\n      // define variable and mixin needed inside the detached ruleset\n      @caller-variable: value;\n      .caller-mixin() {\n        variable: declaration;\n      }\n    }\n\ncompiles into:\n\n    selector {\n      caller-variable: value;\n      variable: declaration;\n    }\n\nVariable and mixins accessible from definition win over those available in the caller:\n\n    @variable: global;\n    @detached-ruleset: {\n      // will use global variable, because it is accessible\n      // from detached-ruleset definition\n      variable: @variable; \n    };\n\n    selector {\n      @detached-ruleset();\n      @variable: value; // variable defined in caller - will be ignored\n    }\n\ncompiles into:\n\n    selector {\n      variable: global;\n    }\n\n### Referencing *Won't* Modify Detached Ruleset Scope\n\nA ruleset does not gain access to new scopes just by being referenced there:\n\n    @detached-1: { scope-detached: @one @two; };\n    .one {\n      @one: visible;\n      .two {\n        @detached-2: @detached-1; // copying/renaming ruleset \n        @two: visible; // ruleset can not see this variable\n      }\n    }\n\n    .use-place {\n      .one > .two(); \n      @detached-2();\n    }\n\nthrows an error:\n\n    ERROR 1:32 The variable \"@one\" was not declared.\n\n### Unlocking *Will* Modify Detached Ruleset Scope\n\nA detached ruleset gains access by being unlocked (imported) inside a scope:\n\n    #space {\n      .importer-1() {\n        @detached: { scope-detached: @variable; }; // define detached ruleset\n      }\n    }\n\n    .importer-2() {\n      @variable: value; // unlocked detached ruleset CAN see this variable\n      #space > .importer-1(); // unlock/import detached ruleset\n    }\n\n    .use-place {\n      .importer-2(); // unlock/import detached ruleset second time\n       @detached();\n    }\n\ncompiles into:\n\n    .use-place {\n      scope-detached: value;\n    }\n\n### Property / variable accessors\n\n### (Lookup values)\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors (also called \"lookups\") to select a value from variable (detached) rulesets.\n\n    @config: {\n      option1: true;\n      option2: false;\n    }\n\n    .mixin() when (@config[option1] = true) {\n      selected: value;\n    }\n\n    .box {\n      .mixin();\n    }\n\nOutputs:\n\n    .box {\n      selected: value;\n    }\n\nIf what is returned from a lookup is another detached ruleset, you can use a second lookup to get that value.\n\n    @config: {\n      @colors: {\n        primary: blue;\n      }\n    }\n\n    .box {\n      color: @config[@colors][primary];\n    }\n\n### Variable variables in lookups\n\nThe lookup value that is returned can itself be variable. As in, you can write:\n\n    @config: {\n      @dark: {\n        primary: darkblue;\n      }\n      @light: {\n        primary: lightblue;\n      }\n    }\n\n    .box {\n      @lookup: dark;\n      color: @config[@@lookup][primary];\n    }\n\nThis will output:\n\n    .box {\n      color: darkblue;\n    }\n\n## @import At-Rules\n\nImport styles from other style sheets\n\nIn standard CSS, `@import` at-rules must precede all other types of rules. But Less doesn't care where you put `@import` statements.\n\nExample:\n\n    .foo {\n      background: #900;\n    }\n    @import \"this-is-valid.less\";\n\n### File Extensions\n\n`@import` statements may be treated differently by Less depending on the file extension:\n\n- If the file has a `.css` extension it will be treated as CSS and the `@import` statement left as-is (see the [inline option](#import-options-inline) below).\n- If it has *any other extension* it will be treated as Less and imported.\n- If it does not have an extension, `.less` will be appended and it will be included as a imported Less file.\n\nExamples:\n\n    @import \"foo\";      // foo.less is imported\n    @import \"foo.less\"; // foo.less is imported\n    @import \"foo.php\";  // foo.php imported as a Less file\n    @import \"foo.css\";  // statement left in place, as-is\n\nThe following options can be used to override this behavior.\n\n### Import Options\n\nLess offers several extensions to the CSS `@import` CSS at-rule to provide more flexibility over what you can do with external files.\n\nSyntax: `@import (keyword) \"filename\";`\n\nThe following import options have been implemented:\n\n- `reference`: use a Less file but do not output it\n- `inline`: include the source file in the output but do not process it\n- `less`: treat the file as a Less file, no matter what the file extension\n- `css`: treat the file as a CSS file, no matter what the file extension\n- `once`: only include the file once (this is default behavior)\n- `multiple`: include the file multiple times\n- `optional`: continue compiling when file is not found\n\nMore than one keyword per `@import` is allowed, you will have to use commas to separate the keywords:\n\nExample: `@import (optional, reference) \"foo.less\";`\n\n### reference\n\nUse `@import (reference)` to import external files, but without adding the imported styles to the compiled output unless referenced.\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample: `@import (reference) \"foo.less\";`\n\nImagine that `reference` marks every at-rule and selector with a *reference flag* in the imported file, imports as normal, but when the CSS is generated, \"reference\" selectors (as well as any media queries containing only reference selectors) are not output. `reference` styles will not show up in your generated CSS unless the reference styles are used as [mixins](#mixins-feature) or [extended](#extend-feature).\n\nAdditionally, **`reference`** produces different results depending on which method was used (mixin or extend):\n\n- **[extend](#extend-feature)**: When a selector is extended, only the new selector is marked as *not referenced*, and it is pulled in at the position of the reference `@import` statement.\n- **[mixins](#mixins-feature)**: When a `reference` style is used as an [implicit mixin](#mixins-feature), its rules are mixed-in, marked \"not reference\", and appear in the referenced place as normal.\n\n### reference example\n\nThis allows you to pull in only specific, targeted styles from a library such as [Bootstrap](https://github.com/twbs/bootstrap) by doing something like this:\n\n    .navbar:extend(.navbar all) {}\n\nAnd you will pull in only `.navbar` related styles from Bootstrap.\n\n### inline\n\nUse `@import (inline)` to include external files, but not process them.\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample: `@import (inline) \"not-less-compatible.css\";`\n\nYou will use this when a CSS file may not be Less compatible; this is because although Less supports most known standards CSS, it does not support comments in some places and does not support all known CSS hacks without modifying the CSS.\n\nSo you can use this to include the file in the output so that all CSS will be in one file.\n\n### less\n\nUse `@import (less)` to treat imported files as Less, regardless of file extension.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    @import (less) \"foo.css\";\n\n### css\n\nUse `@import (css)` to treat imported files as regular CSS, regardless of file extension. This means the import statement will be left as it is.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    @import (css) \"foo.less\";\n\noutputs\n\n    @import \"foo.less\";\n\n### once\n\nThe default behavior of `@import` statements. It means the file is imported only once and subsequent import statements for that file will be ignored.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nThis is the default behavior of `@import` statements.\n\nExample:\n\n    @import (once) \"foo.less\";\n    @import (once) \"foo.less\"; // this statement will be ignored\n\n### multiple\n\nUse `@import (multiple)` to allow importing of multiple files with the same name. This is the opposite behavior to once.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    // file: foo.less\n    .a {\n      color: green;\n    }\n    // file: main.less\n    @import (multiple) \"foo.less\";\n    @import (multiple) \"foo.less\";\n\nOutputs\n\n    .a {\n      color: green;\n    }\n    .a {\n      color: green;\n    }\n\n### optional\n\nUse `@import (optional)` to allow importing of a file only when it exists. Without the `optional` keyword Less throws a FileError and stops compiling when importing a file that can not be found.\n\nReleased [v2.3.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\n## @plugin At-Rules\n\nReleased [v2.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nImport JavaScript plugins to add Less.js functions and features\n\n### Writing your first plugin\n\nUsing a `@plugin` at-rule is similar to using an `@import` for your `.less` files.\n\n    @plugin \"my-plugin\";  // automatically appends .js if no extension\n\nSince Less plugins are evaluated within the Less scope, the plugin definition can be quite simple.\n\n    registerPlugin({\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    })\n\nor you can use `module.exports` (shimmed to work in browser as well as Node.js).\n\n    module.exports = {\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    };\n\nNote that other Node.js CommonJS conventions, like `require()` are not available in the browser. Keep this in mind when writing cross-platform plugins.\n\nWhat can you do with a plugin? A lot, but let's start with the basics. We'll focus first on what you might put inside the `install` function. Let's say you write this:\n\n    // my-plugin.js\n    install: function(less, pluginManager, functions) {\n        functions.add('pi', function() {\n            return Math.PI;\n        });\n    }\n    // etc\n\nCongratulations! You've written a Less plugin!\n\nIf you were to use this in your stylesheet:\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi();\n    }\n\nYou would get:\n\n    .show-me-pi {\n      value: 3.141592653589793;\n    }\n\nHowever, you would need to return a proper Less node if you wanted to, say, multiply that against other values or do other Less operations. Otherwise the output in your stylesheet is plain text (which may be fine for your purposes).\n\nMeaning, this is more correct:\n\n    functions.add('pi', function() {\n        return new tree.Dimension(Math.PI);\n    });\n\n*Note: A dimension is a number with or without a unit, like \"10px\", which would be `less.Dimension(10, \"px\")`. For a list of units, see the [Less API](todo).*\n\nNow you can use your function in operations.\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi() * 2;\n    }\n\nYou may have noticed that there are available globals for your plugin file, namely a function registry (`functions` object), and the `less` object. These are there for convenience.\n\n### Plugin Scope\n\nFunctions added by a `@plugin` at-rule adheres to Less scoping rules. This is great for Less library authors that want to add functionality without introducing naming conflicts.\n\nFor instance, say you have 2 plugins from two third-party libraries that both have a function named \"foo\".\n\n    // lib1.js\n    // ...\n        functions.add('foo', function() {\n            return \"foo\";\n        });\n    // ...\n\n    // lib2.js\n    // ...\n        functions.add('foo', function() {\n            return \"bar\";\n        });\n    // ...\n\nThat's ok! You can choose which library's function creates which output.\n\n    .el-1 {\n        @plugin \"lib1\";\n        value: foo();\n    }\n    .el-2 {\n        @plugin \"lib2\";\n        value: foo();\n    }\n\nThis will produce:\n\n    .el-1 {\n        value: foo;\n    }\n    .el-2 {\n        value: bar;\n    }\n\nFor plugin authors sharing their plugins, that means you can also effectively make private functions by placing them in a particular scope. As in, this will cause an error:\n\n    .el {\n        @plugin \"lib1\";\n    }\n    @value: foo();\n\nAs of Less 3.0, functions can return any kind of Node type, and can be called at any level.\n\nMeaning, this would throw an error in 2.x, as functions had to be part of the value of a property or variable assignment:\n\n    .block {\n        color: blue;\n        my-function-rules();\n    }\n\nIn 3.x, that's no longer the case, and functions can return At-Rules, Rulesets, any other Less node, strings, and numbers (the latter two are converted to Anonymous nodes).\n\n### Null Functions\n\nThere are times when you may want to call a function, but you don't want anything output (such as storing a value for later use). In that case, you just need to return `false` from the function.\n\n    var collection = [];\n\n    functions.add('store', function(val) {\n        collection.push(val);  // imma store this for later\n        return false;\n    });\n\n    @plugin \"collections\";\n    @var: 32;\n    store(@var);\n\nLater you could do something like:\n\n    functions.add('retrieve', function(val) {\n        return new tree.Value(collection);\n    });\n\n    .get-my-values {\n        @plugin \"collections\";\n        values: retrieve();   \n    }\n\n### The Less.js Plugin Object\n\nA Less.js plugin should export an object that has one or more of these properties.\n\n    {\n        /* Called immediately after the plugin is \n         * first imported, only once. */\n        install: function(less, pluginManager, functions) { },\n\n        /* Called for each instance of your @plugin. */\n        use: function(context) { },\n\n        /* Called for each instance of your @plugin, \n         * when rules are being evaluated.\n         * It's just later in the evaluation lifecycle */\n        eval: function(context) { },\n\n        /* Passes an arbitrary string to your plugin \n         * e.g. @plugin (args) \"file\";\n         * This string is not parsed for you, \n         * so it can contain (almost) anything */\n        setOptions: function(argumentString) { },\n\n        /* Set a minimum Less compatibility string\n         * You can also use an array, as in [3, 0] */\n        minVersion: ['3.0'],\n\n        /* Used for lessc only, to explain \n         * options in a Terminal */\n        printUsage: function() { },\n\n    }\n\nThe PluginManager instance for the `install()` function provides methods for adding visitors, file managers, and post-processors.\n\nHere are some example repos showing the different plugin types.\n\n- post-processor: <https://github.com/less/less-plugin-clean-css>\n- visitor: <https://github.com/less/less-plugin-inline-urls>\n- file-manager: <https://github.com/less/less-plugin-npm-import>\n\n### Pre-Loaded Plugins\n\nWhile a `@plugin` call works well for most scenarios, there are times when you might want to load a plugin before parsing starts.\n\nSee: [Pre-Loaded Plugins](usage#plugins) in the \"Using Less.js\" section for how to do that.\n\n## Maps (NEW!)\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nUse rulesets and mixins as maps of values\n\nBy combining namespacing with the lookup `[]` syntax, you can turn your rulesets / mixins into maps.\n\n    @sizes: {\n      mobile: 320px;\n      tablet: 768px;\n      desktop: 1024px;\n    }\n\n    .navbar {\n      display: block;\n\n      @media (min-width: @sizes[tablet]) {\n        display: inline-block;\n      }\n    }\n\nOutputs:\n\n    .navbar {\n      display: block;\n    }\n    @media (min-width: 768px) {\n      .navbar {\n        display: inline-block;\n      }\n    }\n\nMixins are a little more versatile as maps because of namespacing and the ability to overload mixins.\n\n    #library() {\n      .colors() {\n        primary: green;\n        secondary: blue;\n      }\n    }\n\n    #library() {\n      .colors() { primary: grey; }\n    }\n\n    .button {\n      color: #library.colors[primary];\n      border-color: #library.colors[secondary];\n    }\n\nOutputs:\n\n    .button {\n      color: grey;\n      border-color: blue;\n    }\n\nYou can also make this easier by [aliasing mixins](#mixins-feature-mixin-aliasing-feature). That is:\n\n    .button {\n      @colors: #library.colors();\n      color: @colors[primary];\n      border-color: @colors[secondary];\n    }\n\nNote, if a lookup value produces another ruleset, you can append a second `[]` lookup, as in:\n\n    @config: {\n      @options: {\n        library-on: true\n      }\n    }\n\n    & when (@config[@options][library-on] = true) {\n      .produce-ruleset {\n        prop: val;\n      }\n    }\n\nIn this way, rulesets and variable calls can emulate a type of \"namespacing\", similar to mixins.\n\nAs far as whether to use mixins or rulesets assigned to variables as maps, it's up to you. You may want to replace entire maps by re-declaring a variable assigned to a rulset. Or you may want to \"merge\" individual key/value pairs, in which case mixins as maps might be more appropriate.\n\n### Using variable variables in lookups\n\nOne important thing to notice is that the value in `[@lookup]` is the key (variable) name `@lookup`, and is not evaluated as a variable. If you want the key name itself to be variable, you can use the `@@variable` syntax.\n\nE.g.\n\n    .foods() {\n      @dessert: ice cream;\n    }\n\n    @key-to-lookup: dessert;\n\n    .lunch {\n      treat: .foods[@@key-to-lookup];\n    }\n\nThis would output:\n\n    .lunch {\n      treat: ice cream;\n    }\n\n© 2009–2020 The Core Less Team  \nLicensed under the Creative Commons Attribution License 3.0.  \n[http://lesscss.org/features](http://lesscss.org/features)"
- name: '@import'
  id: index#import-directives-feature
  summary: An in-depth guide to features of the LESS language
  description: "# Less\n\n## Overview\n\nAn in-depth guide to features of the LESS language. See the [Overview](http://lesscss.org/#overview) for a quick summary of Less.\n\n*For an in-depth guide to installing and setting up a Less environment, as well as documentation on developing for Less, see: [Using Less.js](usage).*\n\n## Variables\n\nControl commonly used values in a single location.\n\n### Overview\n\nIt's not uncommon to see the same value repeated dozens *if not hundreds of times* across your stylesheets:\n\n    a,\n    .link {\n      color: #428bca;\n    }\n    .widget {\n      color: #fff;\n      background: #428bca;\n    }\n\nVariables make your code easier to maintain by giving you a way to control those values from a single location:\n\n    // Variables\n    @link-color:        #428bca; // sea blue\n    @link-color-hover:  darken(@link-color, 10%);\n\n    // Usage\n    a,\n    .link {\n      color: @link-color;\n    }\n    a:hover {\n      color: @link-color-hover;\n    }\n    .widget {\n      color: #fff;\n      background: @link-color;\n    }\n\n### Variable Interpolation\n\nThe examples above focused on using variables to control *values in CSS rules*, but they can also be used in other places as well, such as selector names, property names, URLs and `@import` statements.\n\n### Selectors\n\n*v1.4.0*\n\n    // Variables\n    @my-selector: banner;\n\n    // Usage\n    .@{my-selector} {\n      font-weight: bold;\n      line-height: 40px;\n      margin: 0 auto;\n    }\n\nCompiles to:\n\n    .banner {\n      font-weight: bold;\n      line-height: 40px;\n      margin: 0 auto;\n    }\n\n### URLs\n\n    // Variables\n    @images: \"../img\";\n\n    // Usage\n    body {\n      color: #444;\n      background: url(\"@{images}/white-sand.png\");\n    }\n\n### Import Statements\n\n*v1.4.0*\n\nSyntax: `@import \"@{themes}/tidal-wave.less\";`\n\nNote that before v2.0.0, only variables which have been declared in the root or current scope were considered and that only the current file and calling files were considered when looking for a variable.\n\nExample:\n\n    // Variables\n    @themes: \"../../src/themes\";\n\n    // Usage\n    @import \"@{themes}/tidal-wave.less\";\n\n### Properties\n\n*v1.6.0*\n\n    @property: color;\n\n    .widget {\n      @{property}: #0ee;\n      background-@{property}: #999;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #0ee;\n      background-color: #999;\n    }\n\n### Variable Variables\n\nIn Less, you can define a variable's name using another variable.\n\n    @primary:  green;\n    @secondary: blue;\n\n    .section {\n      @color: primary;\n\n      .element {\n        color: @@color;\n      }\n    }\n\nWhich compiles to:\n\n    .section .element {\n      color: green;\n    }\n\n### Lazy Evaluation\n\nVariables do not have to be declared before being used.\n\nValid Less snippet:\n\n    .lazy-eval {\n      width: @var;\n    }\n\n    @var: @a;\n    @a: 9%;\n\nthis is valid Less too:\n\n    .lazy-eval {\n      width: @var;\n      @a: 9%;\n    }\n\n    @var: @a;\n    @a: 100%;\n\nboth compile into:\n\n    .lazy-eval {\n      width: 9%;\n    }\n\nWhen defining a variable twice, the last definition of the variable is used, searching from the current scope upwards. This is similar to css itself where the last property inside a definition is used to determine the value.\n\nFor instance:\n\n    @var: 0;\n    .class {\n      @var: 1;\n      .brass {\n        @var: 2;\n        three: @var;\n        @var: 3;\n      }\n      one: @var;\n    }\n\nCompiles to:\n\n    .class {\n      one: 1;\n    }\n    .class .brass {\n      three: 3;\n    }\n\nEssentially, each scope has a \"final\" value, similar to properties in the browser, like this example using custom properties:\n\n    .header {\n      --color: white;\n      color: var(--color);  // the color is black\n      --color: black;\n    }\n\nThis means that, unlike other CSS pre-processing languages, Less variables behave very much like CSS's.\n\n### Properties as Variables **(NEW!)**\n\n*v3.0.0*\n\nYou can easily treat properties like variables using the `$prop` syntax. Sometimes this can make your code a little lighter.\n\n    .widget {\n      color: #efefef;\n      background-color: $color;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #efefef;\n      background-color: #efefef;\n    }\n\nNote that, like variables, Less will choose the last property within the current/parent scope as being the \"final\" value.\n\n    .block {\n      color: red; \n      .inner {\n        background-color: $color; \n      }\n      color: blue;  \n    } \n\nCompiles to:\n\n    .block {\n      color: red; \n      color: blue;  \n    } \n    .block .inner {\n      background-color: blue; \n    }\n\n### Default Variables\n\nWe sometimes get requests for default variables - an ability to set a variable only if it is not already set. This feature is not required because you can easily override a variable by putting the definition afterwards.\n\nFor instance:\n\n    // library\n    @base-color: green;\n    @dark-color: darken(@base-color, 10%);\n\n    // use of library\n    @import \"library.less\";\n    @base-color: red;\n\nThis works fine because of [Lazy Loading](#variables-feature-lazy-loading) - `@base-color` is overridden and `@dark-color` is a dark red.\n\n## Parent Selectors\n\nReferencing parent selectors with `&`\n\nThe `&` operator represents the parent selectors of a [nested rule](#features-overview-feature-nested-rules) and is most commonly used when applying a modifying class or pseudo-class to an existing selector:\n\n    a {\n      color: blue;\n      &:hover {\n        color: green;\n      }\n    }\n\nresults in:\n\n    a {\n      color: blue;\n    }\n\n    a:hover {\n      color: green;\n    }\n\nNotice that without the `&`, the above example would result in `a :hover` rule (a descendant selector that matches hovered elements inside of `<a>` tags) and this is not what we typically would want with the nested `:hover`.\n\nThe \"parent selectors\" operator has a variety of uses. Basically any time you need the selectors of the nested rules to be combined in other ways than the default. For example another typical use of the `&` is to produce repetitive class names:\n\n    .button {\n      &-ok {\n        background-image: url(\"ok.png\");\n      }\n      &-cancel {\n        background-image: url(\"cancel.png\");\n      }\n\n      &-custom {\n        background-image: url(\"custom.png\");\n      }\n    }\n\noutput:\n\n    .button-ok {\n      background-image: url(\"ok.png\");\n    }\n    .button-cancel {\n      background-image: url(\"cancel.png\");\n    }\n    .button-custom {\n      background-image: url(\"custom.png\");\n    }\n\n### Multiple `&`\n\n`&` may appear more than once within a selector. This makes it possible to repeatedly refer to a parent selector without repeating its name.\n\n    .link {\n      & + & {\n        color: red;\n      }\n\n      & & {\n        color: green;\n      }\n\n      && {\n        color: blue;\n      }\n\n      &, &ish {\n        color: cyan;\n      }\n    }\n\nwill output:\n\n    .link + .link {\n      color: red;\n    }\n    .link .link {\n      color: green;\n    }\n    .link.link {\n      color: blue;\n    }\n    .link, .linkish {\n      color: cyan;\n    }\n\nNote that `&` represents all parent selectors (not just the nearest ancestor) so the following example:\n\n    .grand {\n      .parent {\n        & > & {\n          color: red;\n        }\n\n        & & {\n          color: green;\n        }\n\n        && {\n          color: blue;\n        }\n\n        &, &ish {\n          color: cyan;\n        }\n      }\n    }\n\nresults in:\n\n    .grand .parent > .grand .parent {\n      color: red;\n    }\n    .grand .parent .grand .parent {\n      color: green;\n    }\n    .grand .parent.grand .parent {\n      color: blue;\n    }\n    .grand .parent,\n    .grand .parentish {\n      color: cyan;\n    }\n\n### Changing Selector Order\n\nIt can be useful to prepend a selector to the inherited (parent) selectors. This can be done by putting the `&` after current selector. For example, when using Modernizr, you might want to specify different rules based on supported features:\n\n    .header {\n      .menu {\n        border-radius: 5px;\n        .no-borderradius & {\n          background-image: url('images/button-background.png');\n        }\n      }\n    }\n\nThe selector `.no-borderradius &` will prepend `.no-borderradius` to its parent `.header .menu` to form the`.no-borderradius .header .menu` on output:\n\n    .header .menu {\n      border-radius: 5px;\n    }\n    .no-borderradius .header .menu {\n      background-image: url('images/button-background.png');\n    }\n\n### Combinatorial Explosion\n\n`&` can also be used to generate every possible permutation of selectors in a comma separated list:\n\n    p, a, ul, li {\n      border-top: 2px dotted #366;\n      & + & {\n        border-top: 0;\n      }\n    }\n\nThis expands to all possible (16) combinations of the specified elements:\n\n    p,\n    a,\n    ul,\n    li {\n      border-top: 2px dotted #366;\n    }\n    p + p,\n    p + a,\n    p + ul,\n    p + li,\n    a + p,\n    a + a,\n    a + ul,\n    a + li,\n    ul + p,\n    ul + a,\n    ul + ul,\n    ul + li,\n    li + p,\n    li + a,\n    li + ul,\n    li + li {\n      border-top: 0;\n    }\n\n## Extend\n\nExtend is a Less pseudo-class which merges the selector it is put on with ones that match what it references.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\n    nav ul {\n      &:extend(.inline);\n      background: blue;\n    }\n\nIn the rule set above, the `:extend` selector will apply the \"extending selector\" (`nav ul`) onto the `.inline` class *wherever the `.inline` class appears*. The declaration block will be kept as-is, but without any reference to the extend (because extend isn't css).\n\nSo the following:\n\n    nav ul {\n      &:extend(.inline);\n      background: blue;\n    }\n    .inline {\n      color: red;\n    }\n\nOutputs\n\n    nav ul {\n      background: blue;\n    }\n    .inline,\n    nav ul {\n      color: red;\n    }\n\nNotice how the `nav ul:extend(.inline)` selector gets output as `nav ul` - the extend gets removed before output and the selector block left as-is. If no properties are put in that block then it gets removed from the output (but the extend still may affect other selectors).\n\n### Extend Syntax\n\nThe extend is either attached to a selector or placed into a ruleset. It looks like a pseudo-class with selector parameter optionally followed by the keyword `all`:\n\nExample:\n\n    .a:extend(.b) {}\n\n    // the above block does the same thing as the below block\n    .a {\n      &:extend(.b);\n    }\n\n    .c:extend(.d all) {\n      // extends all instances of \".d\" e.g. \".x.d\" or \".d.x\"\n    }\n    .c:extend(.d) {\n      // extends only instances where the selector will be output as just \".d\"\n    }\n\nIt can contain one or more classes to extend, separated by commas.\n\nExample:\n\n    .e:extend(.f) {}\n    .e:extend(.g) {}\n\n    // the above and the below do the same thing\n    .e:extend(.f, .g) {}\n\n### Extend Attached to Selector\n\nExtend attached to a selector looks like an ordinary pseudo-class with selector as a parameter. A selector can contain multiple extend clauses, but all extends must be at the end of the selector.\n\n- Extend after the selector: `pre:hover:extend(div pre)`.\n- Space between selector and extend is allowed: `pre:hover :extend(div pre)`.\n- Multiple extends are allowed: `pre:hover:extend(div pre):extend(.bucket tr)` - Note this is the same as `pre:hover:extend(div pre, .bucket tr)`\n- This is NOT allowed: `pre:hover:extend(div pre).nth-child(odd)`. Extend must be last.\n\nIf a ruleset contains multiple selectors, any of them can have the extend keyword. Multiple selectors with extend in one ruleset:\n\n    .big-division,\n    .big-bag:extend(.bag),\n    .big-bucket:extend(.bucket) {\n      // body\n    }\n\n### Extend Inside Ruleset\n\nExtend can be placed into a ruleset's body using `&:extend(selector)` syntax. Placing extend into a body is a shortcut for placing it into every single selector of that ruleset.\n\nExtend inside a body:\n\n    pre:hover,\n    .some-class {\n      &:extend(div pre);\n    }\n\nis exactly the same as adding an extend after each selector:\n\n    pre:hover:extend(div pre),\n    .some-class:extend(div pre) {}\n\n### Extending Nested Selectors\n\nExtend is able to match nested selectors. Following less:\n\nExample:\n\n    .bucket {\n      tr { // nested ruleset with target selector\n        color: blue;\n      }\n    }\n    .some-class:extend(.bucket tr) {} // nested ruleset is recognized\n\nOutputs\n\n    .bucket tr,\n    .some-class {\n      color: blue;\n    }\n\nEssentially the extend looks at the compiled css, not the original less.\n\nExample:\n\n    .bucket {\n      tr & { // nested ruleset with target selector\n        color: blue;\n      }\n    }\n    .some-class:extend(tr .bucket) {} // nested ruleset is recognized\n\nOutputs\n\n    tr .bucket,\n    .some-class {\n      color: blue;\n    }\n\n### Exact Matching with Extend\n\nExtend by default looks for exact match between selectors. It does matter whether selector uses leading star or not. It does not matter that two nth-expressions have the same meaning, they need to have to same form in order to be matched. The only exception are quotes in attribute selector, less knows they have the same meaning and matches them.\n\nExample:\n\n    .a.class,\n    .class.a,\n    .class > .a {\n      color: blue;\n    }\n    .test:extend(.class) {} // this will NOT match the any selectors above\n\nLeading star does matter. Selectors `*.class` and `.class` are equivalent, but extend will not match them:\n\n    *.class {\n      color: blue;\n    }\n    .noStar:extend(.class) {} // this will NOT match the *.class selector\n\nOutputs\n\n    *.class {\n      color: blue;\n    }\n\nOrder of pseudo-classes does matter. Selectors `link:hover:visited` and `link:visited:hover` match the same set of elements, but extend treats them as different:\n\n    link:hover:visited {\n      color: blue;\n    }\n    .selector:extend(link:visited:hover) {}\n\nOutputs\n\n    link:hover:visited {\n      color: blue;\n    }\n\n### nth Expression\n\nNth expression form does matter. Nth-expressions `1n+3` and `n+3` are equivalent, but extend will not match them:\n\n    :nth-child(1n+3) {\n      color: blue;\n    }\n    .child:extend(:nth-child(n+3)) {}\n\nOutputs\n\n    :nth-child(1n+3) {\n      color: blue;\n    }\n\nQuote type in attribute selector does not matter. All of the following are equivalent.\n\n    [title=identifier] {\n      color: blue;\n    }\n    [title='identifier'] {\n      color: blue;\n    }\n    [title=\"identifier\"] {\n      color: blue;\n    }\n\n    .noQuote:extend([title=identifier]) {}\n    .singleQuote:extend([title='identifier']) {}\n    .doubleQuote:extend([title=\"identifier\"]) {}\n\nOutputs\n\n    [title=identifier],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n    [title='identifier'],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n    [title=\"identifier\"],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n### Extend \"all\"\n\nWhen you specify the all keyword last in an extend argument it tells Less to match that selector as part of another selector. The selector will be copied and the matched part of the selector only will then be replaced with the extend, making a new selector.\n\nExample:\n\n    .a.b.test,\n    .test.c {\n      color: orange;\n    }\n    .test {\n      &:hover {\n        color: green;\n      }\n    }\n\n    .replacement:extend(.test all) {}\n\nOutputs\n\n    .a.b.test,\n    .test.c,\n    .a.b.replacement,\n    .replacement.c {\n      color: orange;\n    }\n    .test:hover,\n    .replacement:hover {\n      color: green;\n    }\n\n*You can think of this mode of operation as essentially doing a non-destructive search and replace.*\n\n### Selector Interpolation with Extend\n\nExtend is **not** able to match selectors with variables. If selector contains variable, extend will ignore it.\n\nHowever, extend can be attached to interpolated selector.\n\nSelector with variable will not be matched:\n\n    @variable: .bucket;\n    @{variable} { // interpolated selector\n      color: blue;\n    }\n    .some-class:extend(.bucket) {} // does nothing, no match is found\n\nand extend with variable in target selector matches nothing:\n\n    .bucket {\n      color: blue;\n    }\n    .some-class:extend(@{variable}) {} // interpolated selector matches nothing\n    @variable: .bucket;\n\nBoth of the above examples compile into:\n\n    .bucket {\n      color: blue;\n    }\n\nHowever, `:extend` attached to an interpolated selector works:\n\n    .bucket {\n      color: blue;\n    }\n    @{variable}:extend(.bucket) {}\n    @variable: .selector;\n\ncompiles to:\n\n    .bucket, .selector {\n      color: blue;\n    }\n\n### Scoping / Extend Inside @media\n\nCurrently, an `:extend` inside a `@media` declaration will only match selectors inside the same media declaration:\n\n    @media print {\n      .screenClass:extend(.selector) {} // extend inside media\n      .selector { // this will be matched - it is in the same media\n        color: black;\n      }\n    }\n    .selector { // ruleset on top of style sheet - extend ignores it\n      color: red;\n    }\n    @media screen {\n      .selector {  // ruleset inside another media - extend ignores it\n        color: blue;\n      }\n    }\n\ncompiles into:\n\n    @media print {\n      .selector,\n      .screenClass { /*  ruleset inside the same media was extended */\n        color: black;\n      }\n    }\n    .selector { /* ruleset on top of style sheet was ignored */\n      color: red;\n    }\n    @media screen {\n      .selector { /* ruleset inside another media was ignored */\n        color: blue;\n      }\n    }\n\nNote: extending does not match selectors inside a nested `@media` declaration:\n\n    @media screen {\n      .screenClass:extend(.selector) {} // extend inside media\n      @media (min-width: 1023px) {\n        .selector {  // ruleset inside nested media - extend ignores it\n          color: blue;\n        }\n      }\n    }\n\nThis compiles into:\n\n    @media screen and (min-width: 1023px) {\n      .selector { /* ruleset inside another nested media was ignored */\n        color: blue;\n      }\n    }\n\nTop level extend matches everything including selectors inside nested media:\n\n    @media screen {\n      .selector {  /* ruleset inside nested media - top level extend works */\n        color: blue;\n      }\n      @media (min-width: 1023px) {\n        .selector {  /* ruleset inside nested media - top level extend works */\n          color: blue;\n        }\n      }\n    }\n\n    .topLevel:extend(.selector) {} /* top level extend matches everything */\n\ncompiles into:\n\n    @media screen {\n      .selector,\n      .topLevel { /* ruleset inside media was extended */\n        color: blue;\n      }\n    }\n    @media screen and (min-width: 1023px) {\n      .selector,\n      .topLevel { /* ruleset inside nested media was extended */\n        color: blue;\n      }\n    }\n\n### Duplication Detection\n\nCurrently there is no duplication detection.\n\nExample:\n\n    .alert-info,\n    .widget {\n      /* declarations */\n    }\n\n    .alert:extend(.alert-info, .widget) {}\n\nOutputs\n\n    .alert-info,\n    .widget,\n    .alert,\n    .alert {\n      /* declarations */\n    }\n\n### Use Cases for Extend\n\n### Classic Use Case\n\nThe classic use case is to avoid adding a base class. For example, if you have\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n\nand you want to have a subtype of animal which overrides the background color then you have two options, firstly change your HTML\n\n    <a class=\"animal bear\">Bear</a>\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n    .bear {\n      background-color: brown;\n    }\n\nor have simplified html and use extend in your less. e.g.\n\n    <a class=\"bear\">Bear</a>\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n    .bear {\n      &:extend(.animal);\n      background-color: brown;\n    }\n\n### Reducing CSS Size\n\nMixins copy all of the properties into a selector, which can lead to unnecessary duplication. Therefore you can use extends instead of mixins to move the selector up to the properties you wish to use, which leads to less CSS being generated.\n\nExample - with mixin:\n\n    .my-inline-block() {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing1 {\n      .my-inline-block;\n    }\n    .thing2 {\n      .my-inline-block;\n    }\n\nOutputs\n\n    .thing1 {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing2 {\n      display: inline-block;\n      font-size: 0;\n    }\n\nExample (with extends):\n\n    .my-inline-block {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing1 {\n      &:extend(.my-inline-block);\n    }\n    .thing2 {\n      &:extend(.my-inline-block);\n    }\n\nOutputs\n\n    .my-inline-block,\n    .thing1,\n    .thing2 {\n      display: inline-block;\n      font-size: 0;\n    }\n\n### Combining Styles / A More Advanced Mixin\n\nAnother use-case is as an alternative for a mixin - because mixins can only be used with simple selectors, if you have two different blocks of html, but need to apply the same styles to both you can use extends to relate two areas.\n\nExample:\n\n    li.list > a {\n      // list styles\n    }\n    button.list-style {\n      &:extend(li.list > a); // use the same list styles\n    }\n\n## Merge\n\nCombine properties\n\nThe `merge` feature allows for aggregating values from multiple properties into a comma or space separated list under a single property. `merge` is useful for properties such as background and transform.\n\n### Comma\n\nAppend property value with comma\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    .mixin() {\n      box-shadow+: inset 0 0 10px #555;\n    }\n    .myclass {\n      .mixin();\n      box-shadow+: 0 0 20px black;\n    }\n\nOutputs\n\n    .myclass {\n      box-shadow: inset 0 0 10px #555, 0 0 20px black;\n    }\n\n### Space\n\nAppend property value with space\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    .mixin() {\n      transform+_: scale(2);\n    }\n    .myclass {\n      .mixin();\n      transform+_: rotate(15deg);\n    }\n\nOutputs\n\n    .myclass {\n      transform: scale(2) rotate(15deg);\n    }\n\nTo avoid any unintentional joins, `merge` requires an explicit `+` or `+_` flag on each join pending declaration.\n\n## Mixins\n\n\"mix-in\" properties from existing styles\n\nYou can mix-in class selectors and id selectors, e.g.\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      .a();\n    }\n    .mixin-id {\n      #b();\n    }\n\nwhich results in:\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      color: red;\n    }\n    .mixin-id {\n      color: red;\n    }\n\nHistorically, the parentheses in a mixin call are optional, but optional parentheses are deprecated and will be required in a future release.\n\n    .a(); \n    .a;    // currently works, but deprecated; don't use\n    .a (); // white-space before parentheses is also deprecated\n\n### Mixins With Parentheses\n\nIf you want to create a mixin but you do not want that mixin to be in your CSS output, put parentheses after the mixin definition.\n\n    .my-mixin {\n      color: black;\n    }\n    .my-other-mixin() {\n      background: white;\n    }\n    .class {\n      .my-mixin();\n      .my-other-mixin();\n    }\n\noutputs\n\n    .my-mixin {\n      color: black;\n    }\n    .class {\n      color: black;\n      background: white;\n    }\n\n### Selectors in Mixins\n\nMixins can contain more than just properties, they can contain selectors too.\n\nFor example:\n\n    .my-hover-mixin() {\n      &:hover {\n        border: 1px solid red;\n      }\n    }\n    button {\n      .my-hover-mixin();\n    }\n\nOutputs\n\n    button:hover {\n      border: 1px solid red;\n    }\n\n### Namespaces\n\nIf you want to mixin properties inside a more complicated selector, you can stack up multiple ids or classes.\n\n    #outer() {\n      .inner {\n        color: red;\n      }\n    }\n\n    .c {\n      #outer.inner();\n    }\n\nNote: legacy Less syntax allows `>` and whitespace between namespaces and mixins. This syntax is deprecated and may be removed. Currently, these do the same thing.\n\n    #outer > .inner(); // deprecated\n    #outer .inner();   // deprecated\n    #outer.inner();    // preferred\n\nNamespacing your mixins like this reduces conflicts with other library mixins or user mixins, but can also be a way to \"organize\" groups of mixins.\n\nExample:\n\n    #my-library {\n      .my-mixin() {\n        color: black;\n      }\n    }\n    // which can be used like this\n    .class {\n      #my-library.my-mixin();\n    }\n\n### Guarded Namespaces\n\nIf a namespace has a guard, mixins defined by it are used only if the guard condition returns true. A namespace guard is evaluated exactly the same as a guard on a mixin, so the following two mixins work the same way:\n\n    #namespace when (@mode = huge) {\n      .mixin() { /* */ }\n    }\n\n    #namespace {\n      .mixin() when (@mode = huge) { /* */ }\n    }\n\nThe `default` function is assumed to have the same value for all nested namespaces and mixin. The following mixin is never evaluated; one of its guards is guaranteed to be false:\n\n    #sp_1 when (default()) {\n      #sp_2 when (default()) {\n        .mixin() when not(default()) { /* */ }\n      }\n    }\n\n### The `!important` keyword\n\nUse the `!important` keyword after mixin call to mark all properties inherited by it as `!important`:\n\nExample:\n\n    .foo (@bg: #f5f5f5; @color: #900) {\n      background: @bg;\n      color: @color;\n    }\n    .unimportant {\n      .foo();\n    }\n    .important {\n      .foo() !important;\n    }\n\nResults in:\n\n    .unimportant {\n      background: #f5f5f5;\n      color: #900;\n    }\n    .important {\n      background: #f5f5f5 !important;\n      color: #900 !important;\n    }\n\n### Parametric Mixins\n\nHow to pass arguments to mixins\n\nMixins can also take arguments, which are variables passed to the block of selectors when it is mixed in.\n\nFor example:\n\n    .border-radius(@radius) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nAnd here's how we can mix it into various rulesets:\n\n    #header {\n      .border-radius(4px);\n    }\n    .button {\n      .border-radius(6px);\n    }\n\nParametric mixins can also have default values for their parameters:\n\n    .border-radius(@radius: 5px) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nWe can invoke it like this now:\n\n    #header {\n      .border-radius();\n    }\n\nAnd it will include a 5px border-radius.\n\nYou can also use parametric mixins which don't take parameters. This is useful if you want to hide the ruleset from the CSS output, but want to include its properties in other rulesets:\n\n    .wrap() {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n    pre { .wrap() }\n\nWhich would output:\n\n    pre {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n### Parameter separators\n\nParameters are currently either *semicolon* or *comma* separated.\n\nOriginally, parameters were only separated by commas, but the semi-colon was later added to support passing comma-separated list values to single arguments.\n\n- two arguments and each contains comma separated list: `.name(1, 2, 3; something, else)`,\n- three arguments and each contains one number: `.name(1, 2, 3)`,\n- use dummy semicolon to create mixin call with one argument containing comma separated css list: `.name(1, 2, 3;)`,\n- comma separated default value: `.name(@param1: red, blue;)`.\n- As of Less 4.0, you can wrap a list value using a paren escape \\[`~()`\\], e.g. `.name(@param1: ~(red, blue))`. This is similar to the quote escape syntax: `~\"quote\"`\n\n### Overloading mixins\n\nIt is legal to define multiple mixins with the same name and number of parameters. Less will use properties of all that can apply. If you used the mixin with one parameter e.g. `.mixin(green);`, then properties of all mixins with exactly one mandatory parameter will be used:\n\n    .mixin(@color) {\n      color-1: @color;\n    }\n    .mixin(@color, @padding: 2) {\n      color-2: @color;\n      padding-2: @padding;\n    }\n    .mixin(@color, @padding, @margin: 2) {\n      color-3: @color;\n      padding-3: @padding;\n      margin: @margin @margin @margin @margin;\n    }\n    .some .selector div {\n      .mixin(#008000);\n    }\n\ncompiles into:\n\n    .some .selector div {\n      color-1: #008000;\n      color-2: #008000;\n      padding-2: 2;\n    }\n\n### Named Parameters\n\nA mixin reference can supply parameters values by their names instead of just positions. Any parameter can be referenced by its name and they do not have to be in any special order:\n\n    .mixin(@color: black; @margin: 10px; @padding: 20px) {\n      color: @color;\n      margin: @margin;\n      padding: @padding;\n    }\n    .class1 {\n      .mixin(@margin: 20px; @color: #33acfe);\n    }\n    .class2 {\n      .mixin(#efca44; @padding: 40px);\n    }\n\ncompiles into:\n\n    .class1 {\n      color: #33acfe;\n      margin: 20px;\n      padding: 20px;\n    }\n    .class2 {\n      color: #efca44;\n      margin: 10px;\n      padding: 40px;\n    }\n\n### The `@arguments` Variable\n\n`@arguments` has a special meaning inside mixins, it contains all the arguments passed, when the mixin was called. This is useful if you don't want to deal with individual parameters:\n\n    .box-shadow(@x: 0, @y: 0, @blur: 1px, @color: #000) {\n      -webkit-box-shadow: @arguments;\n         -moz-box-shadow: @arguments;\n              box-shadow: @arguments;\n    }\n    .big-block {\n      .box-shadow(2px, 5px);\n    }\n\nWhich results in:\n\n    .big-block {\n      -webkit-box-shadow: 2px 5px 1px #000;\n         -moz-box-shadow: 2px 5px 1px #000;\n              box-shadow: 2px 5px 1px #000;\n    }\n\n### Advanced Arguments and the `@rest` Variable\n\nYou can use `...` if you want your mixin to take a variable number of arguments. Using this after a variable name will assign those arguments to the variable.\n\n    .mixin(...) {        // matches 0-N arguments\n    .mixin() {           // matches exactly 0 arguments\n    .mixin(@a: 1) {      // matches 0-1 arguments\n    .mixin(@a: 1, ...) { // matches 0-N arguments\n    .mixin(@a, ...) {    // matches 1-N arguments\n\nFurthermore:\n\n    .mixin(@a, @rest...) {\n       // @rest is bound to arguments after @a\n       // @arguments is bound to all arguments\n    }\n\n### Pattern-matching\n\nSometimes, you may want to change the behavior of a mixin, based on the parameters you pass to it. Let's start with something basic:\n\n    .mixin(@s, @color) { ... }\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nNow let's say we want `.mixin` to behave differently, based on the value of `@switch`, we could define `.mixin` as such:\n\n    .mixin(dark, @color) {\n      color: darken(@color, 10%);\n    }\n    .mixin(light, @color) {\n      color: lighten(@color, 10%);\n    }\n    .mixin(@_, @color) {\n      display: block;\n    }\n\nNow, if we run:\n\n    @switch: light;\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nWe will get the following CSS:\n\n    .class {\n      color: #a2a2a2;\n      display: block;\n    }\n\nWhere the color passed to `.mixin` was lightened. If the value of `@switch` was `dark`, the result would be a darker color.\n\nHere's what happened:\n\n- The first mixin definition didn't match because it expected `dark` as the first argument.\n- The second mixin definition matched, because it expected `light`.\n- The third mixin definition matched because it expected any value.\n\nOnly mixin definitions which matched were used. Variables match and bind to any value. Anything other than a variable matches only with a value equal to itself.\n\nWe can also match on arity, here's an example:\n\n    .mixin(@a) {\n      color: @a;\n    }\n    .mixin(@a, @b) {\n      color: fade(@a, @b);\n    }\n\nNow if we call `.mixin` with a single argument, we will get the output of the first definition, but if we call it with *two* arguments, we will get the second definition, namely `@a` faded to `@b`.\n\n### Using Mixins as Functions\n\nSelecting properties and variables from mixin calls\n\n### Property / value accessors\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors to select a value from an evaluated mixin's rules. This can allow you to use mixins similar to functions.\n\nExample:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its \"@result\" value\n      padding: .average(16px, 50px)[@result];\n    }\n\nResults in:\n\n    div {\n      padding: 33px;\n    }\n\n### Overriding mixin values\n\nIf you have multiple matching mixins, all rules are evaluated and merged, and the last matching value with that identifier is returned. This is similar to the cascade in CSS, and it allows you to \"override\" mixin values.\n\n    // library.less\n    #library() {\n      .mixin() {\n        prop: foo;\n      }\n    }\n\n    // customize.less\n    @import \"library\";\n    #library() {\n      .mixin() {\n        prop: bar;\n      }\n    }\n\n    .box {\n      my-value: #library.mixin[prop];\n    }\n\nOutputs:\n\n    .box {\n      my-value: bar;\n    }\n\n### Unnamed lookups\n\nIf you don't specify a lookup value in `[@lookup]` and instead write `[]` after a mixin or ruleset call, *all* values will cascade and the last declared value will be selected.\n\nMeaning: the averaging mixin from the above example could be written as:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its final value\n      padding: .average(16px, 50px)[];\n    }\n\nThe output is the same:\n\n    div {\n      padding: 33px;\n    }\n\nThe same cascading behavior is true for rulesets or variables aliased to mixin calls.\n\n    @dr: {\n      value: foo;\n    }\n    .box {\n      my-value: @dr[];\n    }\n\nThis outputs:\n\n    .box {\n      my-value: foo;\n    }\n\n### Unlocking mixins & variables into caller scope\n\n***DEPRECATED - Use Property / Value Accessors***\n\nVariables and mixins defined in a mixin are visible and can be used in caller's scope. There is only one exception: a variable is not copied if the caller contains a variable with the same name (that includes variables defined by another mixin call). Only variables present in callers local scope are protected. Variables inherited from parent scopes are overridden.\n\n*Note: this behavior is deprecated, and in the future, variables and mixins will not be merged into the caller scope in this way.*\n\nExample:\n\n    .mixin() {\n      @width:  100%;\n      @height: 200px;\n    }\n\n    .caller {\n      .mixin();\n      width:  @width;\n      height: @height;\n    }\n\nResults in:\n\n    .caller {\n      width:  100%;\n      height: 200px;\n    }\n\nVariables defined directly in callers scope cannot be overridden. However, variables defined in callers parent scope is not protected and will be overridden:\n\n    .mixin() {\n      @size: in-mixin;\n      @definedOnlyInMixin: in-mixin;\n    }\n\n    .class {\n      margin: @size @definedOnlyInMixin;\n      .mixin();\n    }\n\n    @size: globaly-defined-value; // callers parent scope - no protection\n\nResults in:\n\n    .class {\n      margin: in-mixin in-mixin;\n    }\n\nFinally, mixin defined in mixin acts as return value too:\n\n    .unlock(@value) { // outer mixin\n      .doSomething() { // nested mixin\n        declaration: @value;\n      }\n    }\n\n    #namespace {\n      .unlock(5); // unlock doSomething mixin\n      .doSomething(); //nested mixin was copied here and is usable\n    }\n\nResults in:\n\n    #namespace {\n      declaration: 5;\n    }\n\n### Recursive Mixins\n\nCreating loops\n\nIn Less a mixin can call itself. Such recursive mixins, when combined with [Guard Expressions](#mixin-guards-feature) and [Pattern Matching](#mixins-parametric-feature-pattern-matching), can be used to create various iterative/loop structures.\n\nExample:\n\n    .loop(@counter) when (@counter > 0) {\n      .loop((@counter - 1));    // next iteration\n      width: (10px * @counter); // code for each iteration\n    }\n\n    div {\n      .loop(5); // launch the loop\n    }\n\nOutput:\n\n    div {\n      width: 10px;\n      width: 20px;\n      width: 30px;\n      width: 40px;\n      width: 50px;\n    }\n\nA generic example of using a recursive loop to generate CSS grid classes:\n\n    .generate-columns(4);\n\n    .generate-columns(@n, @i: 1) when (@i =< @n) {\n      .column-@{i} {\n        width: (@i * 100% / @n);\n      }\n      .generate-columns(@n, (@i + 1));\n    }\n\nOutput:\n\n    .column-1 {\n      width: 25%;\n    }\n    .column-2 {\n      width: 50%;\n    }\n    .column-3 {\n      width: 75%;\n    }\n    .column-4 {\n      width: 100%;\n    }\n\n### Mixin Guards\n\nGuards are useful when you want to match on *expressions*, as opposed to simple values or arity. If you are familiar with functional programming, you have probably encountered them already.\n\nIn trying to stay as close as possible to the declarative nature of CSS, Less has opted to implement conditional execution via **guarded mixins** instead of `if`/`else` statements, in the vein of `@media` query feature specifications.\n\nLet's start with an example:\n\n    .mixin(@a) when (lightness(@a) >= 50%) {\n      background-color: black;\n    }\n    .mixin(@a) when (lightness(@a) < 50%) {\n      background-color: white;\n    }\n    .mixin(@a) {\n      color: @a;\n    }\n\nThe key is the `when` keyword, which introduces a guard sequence (here with only one guard). Now if we run the following code:\n\n    .class1 { .mixin(#ddd) }\n    .class2 { .mixin(#555) }\n\nHere's what we'll get:\n\n    .class1 {\n      background-color: black;\n      color: #ddd;\n    }\n    .class2 {\n      background-color: white;\n      color: #555;\n    }\n\n### Guard Comparison Operators\n\nThe full list of comparison operators usable in guards are: `>`, `>=`, `=`, `=<`, `<`. Additionally, the keyword `true` is the only truthy value, making these two mixins equivalent:\n\n    .truth(@a) when (@a) { ... }\n    .truth(@a) when (@a = true) { ... }\n\nAny value other than the keyword `true` is falsy:\n\n    .class {\n      .truth(40); // Will not match any of the above definitions.\n    }\n\nNote that you can also compare arguments with each other, or with non-arguments:\n\n    @media: mobile;\n\n    .mixin(@a) when (@media = mobile) { ... }\n    .mixin(@a) when (@media = desktop) { ... }\n\n    .max(@a; @b) when (@a > @b) { width: @a }\n    .max(@a; @b) when (@a < @b) { width: @b }\n\n### Guard Logical Operators\n\nYou can use logical operators with guards. The syntax is based on CSS media queries.\n\nUse the `and` keyword to combine guards:\n\n    .mixin(@a) when (isnumber(@a)) and (@a > 0) { ... }\n\nYou can emulate the *or* operator by separating guards with a comma `,`. If any of the guards evaluate to true, it's considered a match:\n\n    .mixin(@a) when (@a > 10), (@a < -10) { ... }\n\nUse the `not` keyword to negate conditions:\n\n    .mixin(@b) when not (@b > 0) { ... }\n\n### Type Checking Functions\n\nLastly, if you want to match mixins based on value type, you can use the `is` functions:\n\n    .mixin(@a; @b: 0) when (isnumber(@b)) { ... }\n    .mixin(@a; @b: black) when (iscolor(@b)) { ... }\n\nHere are the basic type checking functions:\n\n- `iscolor`\n- `isnumber`\n- `isstring`\n- `iskeyword`\n- `isurl`\n\nIf you want to check if a value is in a specific unit in addition to being a number, you may use one of:\n\n- `ispixel`\n- `ispercentage`\n- `isem`\n- `isunit`\n\n### Aliasing Mixins\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nAssigning mixin calls to a variable\n\nMixins can be assigned to a variable to be called as a variable call, or can be used for map lookup.\n\n    #theme.dark.navbar {\n      .colors(light) {\n        primary: purple;\n      }\n      .colors(dark) {\n        primary: black;\n        secondary: grey;\n      }\n    }\n\n    .navbar {\n      @colors: #theme.dark.navbar.colors(dark);\n      background: @colors[primary];\n      border: 1px solid @colors[secondary];\n    }\n\nThis would output:\n\n    .navbar {\n      background: black;\n      border: 1px solid grey;\n    }\n\n### Variable calls\n\nEntire mixin calls can be aliased and called as variable calls. As in:\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors();\n      @alias();\n    }\n\nOutputs:\n\n    .box {\n      background: green;\n    }\n\nNote, unlike mixins used in root, mixin calls assigned to variables and *called with no arguments* always require parentheses. The following is not valid.\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors;\n      @alias();   // ERROR: Could not evaluate variable call @alias\n    }\n\nThis is because it's ambiguous if variable is assigned a list of selectors or a mixin call. For example, in Less 3.5+, this variable could be used this way.\n\n    .box {\n      @alias: #library.colors;\n      @{alias} {\n        a: b;\n      }\n    }\n\nThe above would output:\n\n    .box #library.colors {\n      a: b;\n    }\n\n## CSS Guards\n\n\"if\"'s around selectors\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nLike Mixin Guards, guards can also be applied to css selectors, which is syntactic sugar for declaring the mixin and then calling it immediately.\n\nFor instance, before 1.5.0 you would have had to do this:\n\n    .my-optional-style() when (@my-option = true) {\n      button {\n        color: white;\n      }\n    }\n    .my-optional-style();\n\nNow, you can apply the guard directly to a style.\n\n    button when (@my-option = true) {\n      color: white;\n    }\n\nYou can also achieve an `if` type statement by combining this with the `&` feature, allowing you to group multiple guards.\n\n    & when (@my-option = true) {\n      button {\n        color: white;\n      }\n      a {\n        color: blue;\n      }\n    }\n\nNote that you can also achieve a similar pattern by using the actual `if()` function and a variable call. As in:\n\n    @dr: if(@my-option = true, {\n      button {\n        color: white;\n      }\n      a {\n        color: blue;\n      }\n    });\n    @dr();\n\n## Detached Rulesets\n\nAssign a ruleset to a variable\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nA detached ruleset is a group of css properties, nested rulesets, media declarations or anything else stored in a variable. You can include it into a ruleset or another structure and all its properties are going to be copied there. You can also use it as a mixin argument and pass it around as any other variable.\n\nSimple example:\n\n    // declare detached ruleset\n    @detached-ruleset: { background: red; }; // semi-colon is optional in 3.5.0+\n\n    // use detached ruleset\n    .top {\n        @detached-ruleset(); \n    }\n\ncompiles into:\n\n    .top {\n      background: red;\n    }\n\nParentheses after a detached ruleset call are mandatory (except when followed by a [lookup value](#detached-rulesets-feature-property-variable-accessors)). The call `@detached-ruleset;` would not work.\n\nIt is useful when you want to define a mixin that abstracts out either wrapping a piece of code in a media query or a non-supported browser class name. The rulesets can be passed to mixin so that the mixin can wrap the content, e.g.\n\n    .desktop-and-old-ie(@rules) {\n      @media screen and (min-width: 1200px) { @rules(); }\n      html.lt-ie9 &                         { @rules(); }\n    }\n\n    header {\n      background-color: blue;\n\n      .desktop-and-old-ie({\n        background-color: red;\n      });\n    }\n\nHere the `desktop-and-old-ie` mixin defines the media query and root class so that you can use a mixin to wrap a piece of code. This will output\n\n    header {\n      background-color: blue;\n    }\n    @media screen and (min-width: 1200px) {\n      header {\n        background-color: red;\n      }\n    }\n    html.lt-ie9 header {\n      background-color: red;\n    }\n\nA ruleset can be now assigned to a variable or passed in to a mixin and can contain the full set of Less features, e.g.\n\n    @my-ruleset: {\n        .my-selector {\n          background-color: black;\n        }\n      };\n\nYou can even take advantage of [media query bubbling](#features-overview-feature-media-query-bubbling-and-nested-media-queries), for instance\n\n    @my-ruleset: {\n        .my-selector {\n          @media tv {\n            background-color: black;\n          }\n        }\n      };\n    @media (orientation:portrait) {\n        @my-ruleset();\n    }\n\nwhich will output\n\n    @media (orientation: portrait) and tv {\n      .my-selector {\n        background-color: black;\n      }\n    }\n\nA detached ruleset call unlocks (returns) all its mixins into caller the same way as mixin calls do. However, it does **not** return variables.\n\nReturned mixin:\n\n    // detached ruleset with a mixin\n    @detached-ruleset: { \n        .mixin() {\n            color: blue;\n        }\n    };\n    // call detached ruleset\n    .caller {\n        @detached-ruleset(); \n        .mixin();\n    }\n\nResults in:\n\n    .caller {\n      color: blue;\n    }\n\nPrivate variables:\n\n    @detached-ruleset: { \n        @color:blue; // this variable is private\n    };\n    .caller {\n        color: @color; // syntax error\n    }\n\n### Scoping\n\nA detached ruleset can use all variables and mixins accessible where it is *defined* and where it is *called*. Otherwise said, both definition and caller scopes are available to it. If both scopes contains the same variable or mixin, declaration scope value takes precedence.\n\n*Declaration scope* is the one where detached ruleset body is defined. Copying a detached ruleset from one variable into another cannot modify its scope. The ruleset does not gain access to new scopes just by being referenced there.\n\nLastly, a detached ruleset can gain access to scope by being unlocked (imported) into it.\n\n*Note: unlocking variables into scope via a called mixin is deprecated. Use [property / variable accessors](#detached-rulesets-feature-property-variable-accessors).*\n\n### Definition and Caller Scope Visibility\n\nA detached ruleset sees the caller's variables and mixins:\n\n    @detached-ruleset: {\n      caller-variable: @caller-variable; // variable is undefined here\n      .caller-mixin(); // mixin is undefined here\n    };\n\n    selector {\n      // use detached ruleset\n      @detached-ruleset(); \n\n      // define variable and mixin needed inside the detached ruleset\n      @caller-variable: value;\n      .caller-mixin() {\n        variable: declaration;\n      }\n    }\n\ncompiles into:\n\n    selector {\n      caller-variable: value;\n      variable: declaration;\n    }\n\nVariable and mixins accessible from definition win over those available in the caller:\n\n    @variable: global;\n    @detached-ruleset: {\n      // will use global variable, because it is accessible\n      // from detached-ruleset definition\n      variable: @variable; \n    };\n\n    selector {\n      @detached-ruleset();\n      @variable: value; // variable defined in caller - will be ignored\n    }\n\ncompiles into:\n\n    selector {\n      variable: global;\n    }\n\n### Referencing *Won't* Modify Detached Ruleset Scope\n\nA ruleset does not gain access to new scopes just by being referenced there:\n\n    @detached-1: { scope-detached: @one @two; };\n    .one {\n      @one: visible;\n      .two {\n        @detached-2: @detached-1; // copying/renaming ruleset \n        @two: visible; // ruleset can not see this variable\n      }\n    }\n\n    .use-place {\n      .one > .two(); \n      @detached-2();\n    }\n\nthrows an error:\n\n    ERROR 1:32 The variable \"@one\" was not declared.\n\n### Unlocking *Will* Modify Detached Ruleset Scope\n\nA detached ruleset gains access by being unlocked (imported) inside a scope:\n\n    #space {\n      .importer-1() {\n        @detached: { scope-detached: @variable; }; // define detached ruleset\n      }\n    }\n\n    .importer-2() {\n      @variable: value; // unlocked detached ruleset CAN see this variable\n      #space > .importer-1(); // unlock/import detached ruleset\n    }\n\n    .use-place {\n      .importer-2(); // unlock/import detached ruleset second time\n       @detached();\n    }\n\ncompiles into:\n\n    .use-place {\n      scope-detached: value;\n    }\n\n### Property / variable accessors\n\n### (Lookup values)\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors (also called \"lookups\") to select a value from variable (detached) rulesets.\n\n    @config: {\n      option1: true;\n      option2: false;\n    }\n\n    .mixin() when (@config[option1] = true) {\n      selected: value;\n    }\n\n    .box {\n      .mixin();\n    }\n\nOutputs:\n\n    .box {\n      selected: value;\n    }\n\nIf what is returned from a lookup is another detached ruleset, you can use a second lookup to get that value.\n\n    @config: {\n      @colors: {\n        primary: blue;\n      }\n    }\n\n    .box {\n      color: @config[@colors][primary];\n    }\n\n### Variable variables in lookups\n\nThe lookup value that is returned can itself be variable. As in, you can write:\n\n    @config: {\n      @dark: {\n        primary: darkblue;\n      }\n      @light: {\n        primary: lightblue;\n      }\n    }\n\n    .box {\n      @lookup: dark;\n      color: @config[@@lookup][primary];\n    }\n\nThis will output:\n\n    .box {\n      color: darkblue;\n    }\n\n## @import At-Rules\n\nImport styles from other style sheets\n\nIn standard CSS, `@import` at-rules must precede all other types of rules. But Less doesn't care where you put `@import` statements.\n\nExample:\n\n    .foo {\n      background: #900;\n    }\n    @import \"this-is-valid.less\";\n\n### File Extensions\n\n`@import` statements may be treated differently by Less depending on the file extension:\n\n- If the file has a `.css` extension it will be treated as CSS and the `@import` statement left as-is (see the [inline option](#import-options-inline) below).\n- If it has *any other extension* it will be treated as Less and imported.\n- If it does not have an extension, `.less` will be appended and it will be included as a imported Less file.\n\nExamples:\n\n    @import \"foo\";      // foo.less is imported\n    @import \"foo.less\"; // foo.less is imported\n    @import \"foo.php\";  // foo.php imported as a Less file\n    @import \"foo.css\";  // statement left in place, as-is\n\nThe following options can be used to override this behavior.\n\n### Import Options\n\nLess offers several extensions to the CSS `@import` CSS at-rule to provide more flexibility over what you can do with external files.\n\nSyntax: `@import (keyword) \"filename\";`\n\nThe following import options have been implemented:\n\n- `reference`: use a Less file but do not output it\n- `inline`: include the source file in the output but do not process it\n- `less`: treat the file as a Less file, no matter what the file extension\n- `css`: treat the file as a CSS file, no matter what the file extension\n- `once`: only include the file once (this is default behavior)\n- `multiple`: include the file multiple times\n- `optional`: continue compiling when file is not found\n\nMore than one keyword per `@import` is allowed, you will have to use commas to separate the keywords:\n\nExample: `@import (optional, reference) \"foo.less\";`\n\n### reference\n\nUse `@import (reference)` to import external files, but without adding the imported styles to the compiled output unless referenced.\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample: `@import (reference) \"foo.less\";`\n\nImagine that `reference` marks every at-rule and selector with a *reference flag* in the imported file, imports as normal, but when the CSS is generated, \"reference\" selectors (as well as any media queries containing only reference selectors) are not output. `reference` styles will not show up in your generated CSS unless the reference styles are used as [mixins](#mixins-feature) or [extended](#extend-feature).\n\nAdditionally, **`reference`** produces different results depending on which method was used (mixin or extend):\n\n- **[extend](#extend-feature)**: When a selector is extended, only the new selector is marked as *not referenced*, and it is pulled in at the position of the reference `@import` statement.\n- **[mixins](#mixins-feature)**: When a `reference` style is used as an [implicit mixin](#mixins-feature), its rules are mixed-in, marked \"not reference\", and appear in the referenced place as normal.\n\n### reference example\n\nThis allows you to pull in only specific, targeted styles from a library such as [Bootstrap](https://github.com/twbs/bootstrap) by doing something like this:\n\n    .navbar:extend(.navbar all) {}\n\nAnd you will pull in only `.navbar` related styles from Bootstrap.\n\n### inline\n\nUse `@import (inline)` to include external files, but not process them.\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample: `@import (inline) \"not-less-compatible.css\";`\n\nYou will use this when a CSS file may not be Less compatible; this is because although Less supports most known standards CSS, it does not support comments in some places and does not support all known CSS hacks without modifying the CSS.\n\nSo you can use this to include the file in the output so that all CSS will be in one file.\n\n### less\n\nUse `@import (less)` to treat imported files as Less, regardless of file extension.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    @import (less) \"foo.css\";\n\n### css\n\nUse `@import (css)` to treat imported files as regular CSS, regardless of file extension. This means the import statement will be left as it is.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    @import (css) \"foo.less\";\n\noutputs\n\n    @import \"foo.less\";\n\n### once\n\nThe default behavior of `@import` statements. It means the file is imported only once and subsequent import statements for that file will be ignored.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nThis is the default behavior of `@import` statements.\n\nExample:\n\n    @import (once) \"foo.less\";\n    @import (once) \"foo.less\"; // this statement will be ignored\n\n### multiple\n\nUse `@import (multiple)` to allow importing of multiple files with the same name. This is the opposite behavior to once.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    // file: foo.less\n    .a {\n      color: green;\n    }\n    // file: main.less\n    @import (multiple) \"foo.less\";\n    @import (multiple) \"foo.less\";\n\nOutputs\n\n    .a {\n      color: green;\n    }\n    .a {\n      color: green;\n    }\n\n### optional\n\nUse `@import (optional)` to allow importing of a file only when it exists. Without the `optional` keyword Less throws a FileError and stops compiling when importing a file that can not be found.\n\nReleased [v2.3.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\n## @plugin At-Rules\n\nReleased [v2.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nImport JavaScript plugins to add Less.js functions and features\n\n### Writing your first plugin\n\nUsing a `@plugin` at-rule is similar to using an `@import` for your `.less` files.\n\n    @plugin \"my-plugin\";  // automatically appends .js if no extension\n\nSince Less plugins are evaluated within the Less scope, the plugin definition can be quite simple.\n\n    registerPlugin({\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    })\n\nor you can use `module.exports` (shimmed to work in browser as well as Node.js).\n\n    module.exports = {\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    };\n\nNote that other Node.js CommonJS conventions, like `require()` are not available in the browser. Keep this in mind when writing cross-platform plugins.\n\nWhat can you do with a plugin? A lot, but let's start with the basics. We'll focus first on what you might put inside the `install` function. Let's say you write this:\n\n    // my-plugin.js\n    install: function(less, pluginManager, functions) {\n        functions.add('pi', function() {\n            return Math.PI;\n        });\n    }\n    // etc\n\nCongratulations! You've written a Less plugin!\n\nIf you were to use this in your stylesheet:\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi();\n    }\n\nYou would get:\n\n    .show-me-pi {\n      value: 3.141592653589793;\n    }\n\nHowever, you would need to return a proper Less node if you wanted to, say, multiply that against other values or do other Less operations. Otherwise the output in your stylesheet is plain text (which may be fine for your purposes).\n\nMeaning, this is more correct:\n\n    functions.add('pi', function() {\n        return new tree.Dimension(Math.PI);\n    });\n\n*Note: A dimension is a number with or without a unit, like \"10px\", which would be `less.Dimension(10, \"px\")`. For a list of units, see the [Less API](todo).*\n\nNow you can use your function in operations.\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi() * 2;\n    }\n\nYou may have noticed that there are available globals for your plugin file, namely a function registry (`functions` object), and the `less` object. These are there for convenience.\n\n### Plugin Scope\n\nFunctions added by a `@plugin` at-rule adheres to Less scoping rules. This is great for Less library authors that want to add functionality without introducing naming conflicts.\n\nFor instance, say you have 2 plugins from two third-party libraries that both have a function named \"foo\".\n\n    // lib1.js\n    // ...\n        functions.add('foo', function() {\n            return \"foo\";\n        });\n    // ...\n\n    // lib2.js\n    // ...\n        functions.add('foo', function() {\n            return \"bar\";\n        });\n    // ...\n\nThat's ok! You can choose which library's function creates which output.\n\n    .el-1 {\n        @plugin \"lib1\";\n        value: foo();\n    }\n    .el-2 {\n        @plugin \"lib2\";\n        value: foo();\n    }\n\nThis will produce:\n\n    .el-1 {\n        value: foo;\n    }\n    .el-2 {\n        value: bar;\n    }\n\nFor plugin authors sharing their plugins, that means you can also effectively make private functions by placing them in a particular scope. As in, this will cause an error:\n\n    .el {\n        @plugin \"lib1\";\n    }\n    @value: foo();\n\nAs of Less 3.0, functions can return any kind of Node type, and can be called at any level.\n\nMeaning, this would throw an error in 2.x, as functions had to be part of the value of a property or variable assignment:\n\n    .block {\n        color: blue;\n        my-function-rules();\n    }\n\nIn 3.x, that's no longer the case, and functions can return At-Rules, Rulesets, any other Less node, strings, and numbers (the latter two are converted to Anonymous nodes).\n\n### Null Functions\n\nThere are times when you may want to call a function, but you don't want anything output (such as storing a value for later use). In that case, you just need to return `false` from the function.\n\n    var collection = [];\n\n    functions.add('store', function(val) {\n        collection.push(val);  // imma store this for later\n        return false;\n    });\n\n    @plugin \"collections\";\n    @var: 32;\n    store(@var);\n\nLater you could do something like:\n\n    functions.add('retrieve', function(val) {\n        return new tree.Value(collection);\n    });\n\n    .get-my-values {\n        @plugin \"collections\";\n        values: retrieve();   \n    }\n\n### The Less.js Plugin Object\n\nA Less.js plugin should export an object that has one or more of these properties.\n\n    {\n        /* Called immediately after the plugin is \n         * first imported, only once. */\n        install: function(less, pluginManager, functions) { },\n\n        /* Called for each instance of your @plugin. */\n        use: function(context) { },\n\n        /* Called for each instance of your @plugin, \n         * when rules are being evaluated.\n         * It's just later in the evaluation lifecycle */\n        eval: function(context) { },\n\n        /* Passes an arbitrary string to your plugin \n         * e.g. @plugin (args) \"file\";\n         * This string is not parsed for you, \n         * so it can contain (almost) anything */\n        setOptions: function(argumentString) { },\n\n        /* Set a minimum Less compatibility string\n         * You can also use an array, as in [3, 0] */\n        minVersion: ['3.0'],\n\n        /* Used for lessc only, to explain \n         * options in a Terminal */\n        printUsage: function() { },\n\n    }\n\nThe PluginManager instance for the `install()` function provides methods for adding visitors, file managers, and post-processors.\n\nHere are some example repos showing the different plugin types.\n\n- post-processor: <https://github.com/less/less-plugin-clean-css>\n- visitor: <https://github.com/less/less-plugin-inline-urls>\n- file-manager: <https://github.com/less/less-plugin-npm-import>\n\n### Pre-Loaded Plugins\n\nWhile a `@plugin` call works well for most scenarios, there are times when you might want to load a plugin before parsing starts.\n\nSee: [Pre-Loaded Plugins](usage#plugins) in the \"Using Less.js\" section for how to do that.\n\n## Maps (NEW!)\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nUse rulesets and mixins as maps of values\n\nBy combining namespacing with the lookup `[]` syntax, you can turn your rulesets / mixins into maps.\n\n    @sizes: {\n      mobile: 320px;\n      tablet: 768px;\n      desktop: 1024px;\n    }\n\n    .navbar {\n      display: block;\n\n      @media (min-width: @sizes[tablet]) {\n        display: inline-block;\n      }\n    }\n\nOutputs:\n\n    .navbar {\n      display: block;\n    }\n    @media (min-width: 768px) {\n      .navbar {\n        display: inline-block;\n      }\n    }\n\nMixins are a little more versatile as maps because of namespacing and the ability to overload mixins.\n\n    #library() {\n      .colors() {\n        primary: green;\n        secondary: blue;\n      }\n    }\n\n    #library() {\n      .colors() { primary: grey; }\n    }\n\n    .button {\n      color: #library.colors[primary];\n      border-color: #library.colors[secondary];\n    }\n\nOutputs:\n\n    .button {\n      color: grey;\n      border-color: blue;\n    }\n\nYou can also make this easier by [aliasing mixins](#mixins-feature-mixin-aliasing-feature). That is:\n\n    .button {\n      @colors: #library.colors();\n      color: @colors[primary];\n      border-color: @colors[secondary];\n    }\n\nNote, if a lookup value produces another ruleset, you can append a second `[]` lookup, as in:\n\n    @config: {\n      @options: {\n        library-on: true\n      }\n    }\n\n    & when (@config[@options][library-on] = true) {\n      .produce-ruleset {\n        prop: val;\n      }\n    }\n\nIn this way, rulesets and variable calls can emulate a type of \"namespacing\", similar to mixins.\n\nAs far as whether to use mixins or rulesets assigned to variables as maps, it's up to you. You may want to replace entire maps by re-declaring a variable assigned to a rulset. Or you may want to \"merge\" individual key/value pairs, in which case mixins as maps might be more appropriate.\n\n### Using variable variables in lookups\n\nOne important thing to notice is that the value in `[@lookup]` is the key (variable) name `@lookup`, and is not evaluated as a variable. If you want the key name itself to be variable, you can use the `@@variable` syntax.\n\nE.g.\n\n    .foods() {\n      @dessert: ice cream;\n    }\n\n    @key-to-lookup: dessert;\n\n    .lunch {\n      treat: .foods[@@key-to-lookup];\n    }\n\nThis would output:\n\n    .lunch {\n      treat: ice cream;\n    }\n\n© 2009–2020 The Core Less Team  \nLicensed under the Creative Commons Attribution License 3.0.  \n[http://lesscss.org/features](http://lesscss.org/features)"
- name: '@import At-Rules'
  id: index#import-atrules-feature
  summary: In standard CSS, @import at-rules must precede all other types of rules
  description: |-
    ## @import At-Rules

    Import styles from other style sheets

    In standard CSS, `@import` at-rules must precede all other types of rules. But Less doesn't care where you put `@import` statements.

    Example:

        .foo {
          background: #900;
        }
        @import "this-is-valid.less";

    ### File Extensions

    `@import` statements may be treated differently by Less depending on the file extension:

    - If the file has a `.css` extension it will be treated as CSS and the `@import` statement left as-is (see the [inline option](#import-options-inline) below).
    - If it has *any other extension* it will be treated as Less and imported.
    - If it does not have an extension, `.less` will be appended and it will be included as a imported Less file.

    Examples:

        @import "foo";      // foo.less is imported
        @import "foo.less"; // foo.less is imported
        @import "foo.php";  // foo.php imported as a Less file
        @import "foo.css";  // statement left in place, as-is

    The following options can be used to override this behavior.

    ### Import Options

    Less offers several extensions to the CSS `@import` CSS at-rule to provide more flexibility over what you can do with external files.

    Syntax: `@import (keyword) "filename";`

    The following import options have been implemented:

    - `reference`: use a Less file but do not output it
    - `inline`: include the source file in the output but do not process it
    - `less`: treat the file as a Less file, no matter what the file extension
    - `css`: treat the file as a CSS file, no matter what the file extension
    - `once`: only include the file once (this is default behavior)
    - `multiple`: include the file multiple times
    - `optional`: continue compiling when file is not found

    More than one keyword per `@import` is allowed, you will have to use commas to separate the keywords:

    Example: `@import (optional, reference) "foo.less";`

    ### reference

    Use `@import (reference)` to import external files, but without adding the imported styles to the compiled output unless referenced.

    Released [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)

    Example: `@import (reference) "foo.less";`

    Imagine that `reference` marks every at-rule and selector with a *reference flag* in the imported file, imports as normal, but when the CSS is generated, "reference" selectors (as well as any media queries containing only reference selectors) are not output. `reference` styles will not show up in your generated CSS unless the reference styles are used as [mixins](#mixins-feature) or [extended](#extend-feature).

    Additionally, **`reference`** produces different results depending on which method was used (mixin or extend):

    - **[extend](#extend-feature)**: When a selector is extended, only the new selector is marked as *not referenced*, and it is pulled in at the position of the reference `@import` statement.
    - **[mixins](#mixins-feature)**: When a `reference` style is used as an [implicit mixin](#mixins-feature), its rules are mixed-in, marked "not reference", and appear in the referenced place as normal.

    ### reference example

    This allows you to pull in only specific, targeted styles from a library such as [Bootstrap](https://github.com/twbs/bootstrap) by doing something like this:

        .navbar:extend(.navbar all) {}

    And you will pull in only `.navbar` related styles from Bootstrap.

    ### inline

    Use `@import (inline)` to include external files, but not process them.

    Released [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)

    Example: `@import (inline) "not-less-compatible.css";`

    You will use this when a CSS file may not be Less compatible; this is because although Less supports most known standards CSS, it does not support comments in some places and does not support all known CSS hacks without modifying the CSS.

    So you can use this to include the file in the output so that all CSS will be in one file.

    ### less

    Use `@import (less)` to treat imported files as Less, regardless of file extension.

    Released [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)

    Example:

        @import (less) "foo.css";

    ### css

    Use `@import (css)` to treat imported files as regular CSS, regardless of file extension. This means the import statement will be left as it is.

    Released [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)

    Example:

        @import (css) "foo.less";

    outputs

        @import "foo.less";

    ### once

    The default behavior of `@import` statements. It means the file is imported only once and subsequent import statements for that file will be ignored.

    Released [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)

    This is the default behavior of `@import` statements.

    Example:

        @import (once) "foo.less";
        @import (once) "foo.less"; // this statement will be ignored

    ### multiple

    Use `@import (multiple)` to allow importing of multiple files with the same name. This is the opposite behavior to once.

    Released [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)

    Example:

        // file: foo.less
        .a {
          color: green;
        }
        // file: main.less
        @import (multiple) "foo.less";
        @import (multiple) "foo.less";

    Outputs

        .a {
          color: green;
        }
        .a {
          color: green;
        }

    ### optional

    Use `@import (optional)` to allow importing of a file only when it exists. Without the `optional` keyword Less throws a FileError and stops compiling when importing a file that can not be found.

    Released [v2.3.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)
- name: '@plugin At-Rules'
  id: index#plugin-atrules-feature
  summary: Using a @plugin at-rule is similar to using an @import for your .less files
  description: "## @plugin At-Rules\n\nReleased [v2.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nImport JavaScript plugins to add Less.js functions and features\n\n### Writing your first plugin\n\nUsing a `@plugin` at-rule is similar to using an `@import` for your `.less` files.\n\n    @plugin \"my-plugin\";  // automatically appends .js if no extension\n\nSince Less plugins are evaluated within the Less scope, the plugin definition can be quite simple.\n\n    registerPlugin({\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    })\n\nor you can use `module.exports` (shimmed to work in browser as well as Node.js).\n\n    module.exports = {\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    };\n\nNote that other Node.js CommonJS conventions, like `require()` are not available in the browser. Keep this in mind when writing cross-platform plugins.\n\nWhat can you do with a plugin? A lot, but let's start with the basics. We'll focus first on what you might put inside the `install` function. Let's say you write this:\n\n    // my-plugin.js\n    install: function(less, pluginManager, functions) {\n        functions.add('pi', function() {\n            return Math.PI;\n        });\n    }\n    // etc\n\nCongratulations! You've written a Less plugin!\n\nIf you were to use this in your stylesheet:\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi();\n    }\n\nYou would get:\n\n    .show-me-pi {\n      value: 3.141592653589793;\n    }\n\nHowever, you would need to return a proper Less node if you wanted to, say, multiply that against other values or do other Less operations. Otherwise the output in your stylesheet is plain text (which may be fine for your purposes).\n\nMeaning, this is more correct:\n\n    functions.add('pi', function() {\n        return new tree.Dimension(Math.PI);\n    });\n\n*Note: A dimension is a number with or without a unit, like \"10px\", which would be `less.Dimension(10, \"px\")`. For a list of units, see the [Less API](todo).*\n\nNow you can use your function in operations.\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi() * 2;\n    }\n\nYou may have noticed that there are available globals for your plugin file, namely a function registry (`functions` object), and the `less` object. These are there for convenience.\n\n### Plugin Scope\n\nFunctions added by a `@plugin` at-rule adheres to Less scoping rules. This is great for Less library authors that want to add functionality without introducing naming conflicts.\n\nFor instance, say you have 2 plugins from two third-party libraries that both have a function named \"foo\".\n\n    // lib1.js\n    // ...\n        functions.add('foo', function() {\n            return \"foo\";\n        });\n    // ...\n\n    // lib2.js\n    // ...\n        functions.add('foo', function() {\n            return \"bar\";\n        });\n    // ...\n\nThat's ok! You can choose which library's function creates which output.\n\n    .el-1 {\n        @plugin \"lib1\";\n        value: foo();\n    }\n    .el-2 {\n        @plugin \"lib2\";\n        value: foo();\n    }\n\nThis will produce:\n\n    .el-1 {\n        value: foo;\n    }\n    .el-2 {\n        value: bar;\n    }\n\nFor plugin authors sharing their plugins, that means you can also effectively make private functions by placing them in a particular scope. As in, this will cause an error:\n\n    .el {\n        @plugin \"lib1\";\n    }\n    @value: foo();\n\nAs of Less 3.0, functions can return any kind of Node type, and can be called at any level.\n\nMeaning, this would throw an error in 2.x, as functions had to be part of the value of a property or variable assignment:\n\n    .block {\n        color: blue;\n        my-function-rules();\n    }\n\nIn 3.x, that's no longer the case, and functions can return At-Rules, Rulesets, any other Less node, strings, and numbers (the latter two are converted to Anonymous nodes).\n\n### Null Functions\n\nThere are times when you may want to call a function, but you don't want anything output (such as storing a value for later use). In that case, you just need to return `false` from the function.\n\n    var collection = [];\n\n    functions.add('store', function(val) {\n        collection.push(val);  // imma store this for later\n        return false;\n    });\n\n    @plugin \"collections\";\n    @var: 32;\n    store(@var);\n\nLater you could do something like:\n\n    functions.add('retrieve', function(val) {\n        return new tree.Value(collection);\n    });\n\n    .get-my-values {\n        @plugin \"collections\";\n        values: retrieve();   \n    }\n\n### The Less.js Plugin Object\n\nA Less.js plugin should export an object that has one or more of these properties.\n\n    {\n        /* Called immediately after the plugin is \n         * first imported, only once. */\n        install: function(less, pluginManager, functions) { },\n\n        /* Called for each instance of your @plugin. */\n        use: function(context) { },\n\n        /* Called for each instance of your @plugin, \n         * when rules are being evaluated.\n         * It's just later in the evaluation lifecycle */\n        eval: function(context) { },\n\n        /* Passes an arbitrary string to your plugin \n         * e.g. @plugin (args) \"file\";\n         * This string is not parsed for you, \n         * so it can contain (almost) anything */\n        setOptions: function(argumentString) { },\n\n        /* Set a minimum Less compatibility string\n         * You can also use an array, as in [3, 0] */\n        minVersion: ['3.0'],\n\n        /* Used for lessc only, to explain \n         * options in a Terminal */\n        printUsage: function() { },\n\n    }\n\nThe PluginManager instance for the `install()` function provides methods for adding visitors, file managers, and post-processors.\n\nHere are some example repos showing the different plugin types.\n\n- post-processor: <https://github.com/less/less-plugin-clean-css>\n- visitor: <https://github.com/less/less-plugin-inline-urls>\n- file-manager: <https://github.com/less/less-plugin-npm-import>\n\n### Pre-Loaded Plugins\n\nWhile a `@plugin` call works well for most scenarios, there are times when you might want to load a plugin before parsing starts.\n\nSee: [Pre-Loaded Plugins](usage#plugins) in the \"Using Less.js\" section for how to do that."
- name: '@property'
  id: index#variables-feature-properties
  summary: In Less, you can define a variable's name using another variable
  description: "### Properties\n\n*v1.6.0*\n\n    @property: color;\n\n    .widget {\n      @{property}: #0ee;\n      background-@{property}: #999;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #0ee;\n      background-color: #999;\n    }\n\n### Variable Variables\n\nIn Less, you can define a variable's name using another variable.\n\n    @primary:  green;\n    @secondary: blue;\n\n    .section {\n      @color: primary;\n\n      .element {\n        color: @@color;\n      }\n    }\n\nWhich compiles to:\n\n    .section .element {\n      color: green;\n    }\n\n### Lazy Evaluation\n\nVariables do not have to be declared before being used.\n\nValid Less snippet:\n\n    .lazy-eval {\n      width: @var;\n    }\n\n    @var: @a;\n    @a: 9%;\n\nthis is valid Less too:\n\n    .lazy-eval {\n      width: @var;\n      @a: 9%;\n    }\n\n    @var: @a;\n    @a: 100%;\n\nboth compile into:\n\n    .lazy-eval {\n      width: 9%;\n    }\n\nWhen defining a variable twice, the last definition of the variable is used, searching from the current scope upwards. This is similar to css itself where the last property inside a definition is used to determine the value.\n\nFor instance:\n\n    @var: 0;\n    .class {\n      @var: 1;\n      .brass {\n        @var: 2;\n        three: @var;\n        @var: 3;\n      }\n      one: @var;\n    }\n\nCompiles to:\n\n    .class {\n      one: 1;\n    }\n    .class .brass {\n      three: 3;\n    }\n\nEssentially, each scope has a \"final\" value, similar to properties in the browser, like this example using custom properties:\n\n    .header {\n      --color: white;\n      color: var(--color);  // the color is black\n      --color: black;\n    }\n\nThis means that, unlike other CSS pre-processing languages, Less variables behave very much like CSS's.\n\n### Properties as Variables **(NEW!)**\n\n*v3.0.0*\n\nYou can easily treat properties like variables using the `$prop` syntax. Sometimes this can make your code a little lighter.\n\n    .widget {\n      color: #efefef;\n      background-color: $color;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #efefef;\n      background-color: #efefef;\n    }\n\nNote that, like variables, Less will choose the last property within the current/parent scope as being the \"final\" value.\n\n    .block {\n      color: red; \n      .inner {\n        background-color: $color; \n      }\n      color: blue;  \n    } \n\nCompiles to:\n\n    .block {\n      color: red; \n      color: blue;  \n    } \n    .block .inner {\n      background-color: blue; \n    }\n\n### Default Variables\n\nWe sometimes get requests for default variables - an ability to set a variable only if it is not already set. This feature is not required because you can easily override a variable by putting the definition afterwards.\n\nFor instance:\n\n    // library\n    @base-color: green;\n    @dark-color: darken(@base-color, 10%);\n\n    // use of library\n    @import \"library.less\";\n    @base-color: red;\n\nThis works fine because of [Lazy Loading](#variables-feature-lazy-loading) - `@base-color` is overridden and `@dark-color` is a dark red."
- name: '@rest'
  id: index#mixins-parametric-feature-advanced-arguments-and-the-rest-variable
  summary: An in-depth guide to features of the LESS language
  description: "# Less\n\n## Overview\n\nAn in-depth guide to features of the LESS language. See the [Overview](http://lesscss.org/#overview) for a quick summary of Less.\n\n*For an in-depth guide to installing and setting up a Less environment, as well as documentation on developing for Less, see: [Using Less.js](usage).*\n\n## Variables\n\nControl commonly used values in a single location.\n\n### Overview\n\nIt's not uncommon to see the same value repeated dozens *if not hundreds of times* across your stylesheets:\n\n    a,\n    .link {\n      color: #428bca;\n    }\n    .widget {\n      color: #fff;\n      background: #428bca;\n    }\n\nVariables make your code easier to maintain by giving you a way to control those values from a single location:\n\n    // Variables\n    @link-color:        #428bca; // sea blue\n    @link-color-hover:  darken(@link-color, 10%);\n\n    // Usage\n    a,\n    .link {\n      color: @link-color;\n    }\n    a:hover {\n      color: @link-color-hover;\n    }\n    .widget {\n      color: #fff;\n      background: @link-color;\n    }\n\n### Variable Interpolation\n\nThe examples above focused on using variables to control *values in CSS rules*, but they can also be used in other places as well, such as selector names, property names, URLs and `@import` statements.\n\n### Selectors\n\n*v1.4.0*\n\n    // Variables\n    @my-selector: banner;\n\n    // Usage\n    .@{my-selector} {\n      font-weight: bold;\n      line-height: 40px;\n      margin: 0 auto;\n    }\n\nCompiles to:\n\n    .banner {\n      font-weight: bold;\n      line-height: 40px;\n      margin: 0 auto;\n    }\n\n### URLs\n\n    // Variables\n    @images: \"../img\";\n\n    // Usage\n    body {\n      color: #444;\n      background: url(\"@{images}/white-sand.png\");\n    }\n\n### Import Statements\n\n*v1.4.0*\n\nSyntax: `@import \"@{themes}/tidal-wave.less\";`\n\nNote that before v2.0.0, only variables which have been declared in the root or current scope were considered and that only the current file and calling files were considered when looking for a variable.\n\nExample:\n\n    // Variables\n    @themes: \"../../src/themes\";\n\n    // Usage\n    @import \"@{themes}/tidal-wave.less\";\n\n### Properties\n\n*v1.6.0*\n\n    @property: color;\n\n    .widget {\n      @{property}: #0ee;\n      background-@{property}: #999;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #0ee;\n      background-color: #999;\n    }\n\n### Variable Variables\n\nIn Less, you can define a variable's name using another variable.\n\n    @primary:  green;\n    @secondary: blue;\n\n    .section {\n      @color: primary;\n\n      .element {\n        color: @@color;\n      }\n    }\n\nWhich compiles to:\n\n    .section .element {\n      color: green;\n    }\n\n### Lazy Evaluation\n\nVariables do not have to be declared before being used.\n\nValid Less snippet:\n\n    .lazy-eval {\n      width: @var;\n    }\n\n    @var: @a;\n    @a: 9%;\n\nthis is valid Less too:\n\n    .lazy-eval {\n      width: @var;\n      @a: 9%;\n    }\n\n    @var: @a;\n    @a: 100%;\n\nboth compile into:\n\n    .lazy-eval {\n      width: 9%;\n    }\n\nWhen defining a variable twice, the last definition of the variable is used, searching from the current scope upwards. This is similar to css itself where the last property inside a definition is used to determine the value.\n\nFor instance:\n\n    @var: 0;\n    .class {\n      @var: 1;\n      .brass {\n        @var: 2;\n        three: @var;\n        @var: 3;\n      }\n      one: @var;\n    }\n\nCompiles to:\n\n    .class {\n      one: 1;\n    }\n    .class .brass {\n      three: 3;\n    }\n\nEssentially, each scope has a \"final\" value, similar to properties in the browser, like this example using custom properties:\n\n    .header {\n      --color: white;\n      color: var(--color);  // the color is black\n      --color: black;\n    }\n\nThis means that, unlike other CSS pre-processing languages, Less variables behave very much like CSS's.\n\n### Properties as Variables **(NEW!)**\n\n*v3.0.0*\n\nYou can easily treat properties like variables using the `$prop` syntax. Sometimes this can make your code a little lighter.\n\n    .widget {\n      color: #efefef;\n      background-color: $color;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #efefef;\n      background-color: #efefef;\n    }\n\nNote that, like variables, Less will choose the last property within the current/parent scope as being the \"final\" value.\n\n    .block {\n      color: red; \n      .inner {\n        background-color: $color; \n      }\n      color: blue;  \n    } \n\nCompiles to:\n\n    .block {\n      color: red; \n      color: blue;  \n    } \n    .block .inner {\n      background-color: blue; \n    }\n\n### Default Variables\n\nWe sometimes get requests for default variables - an ability to set a variable only if it is not already set. This feature is not required because you can easily override a variable by putting the definition afterwards.\n\nFor instance:\n\n    // library\n    @base-color: green;\n    @dark-color: darken(@base-color, 10%);\n\n    // use of library\n    @import \"library.less\";\n    @base-color: red;\n\nThis works fine because of [Lazy Loading](#variables-feature-lazy-loading) - `@base-color` is overridden and `@dark-color` is a dark red.\n\n## Parent Selectors\n\nReferencing parent selectors with `&`\n\nThe `&` operator represents the parent selectors of a [nested rule](#features-overview-feature-nested-rules) and is most commonly used when applying a modifying class or pseudo-class to an existing selector:\n\n    a {\n      color: blue;\n      &:hover {\n        color: green;\n      }\n    }\n\nresults in:\n\n    a {\n      color: blue;\n    }\n\n    a:hover {\n      color: green;\n    }\n\nNotice that without the `&`, the above example would result in `a :hover` rule (a descendant selector that matches hovered elements inside of `<a>` tags) and this is not what we typically would want with the nested `:hover`.\n\nThe \"parent selectors\" operator has a variety of uses. Basically any time you need the selectors of the nested rules to be combined in other ways than the default. For example another typical use of the `&` is to produce repetitive class names:\n\n    .button {\n      &-ok {\n        background-image: url(\"ok.png\");\n      }\n      &-cancel {\n        background-image: url(\"cancel.png\");\n      }\n\n      &-custom {\n        background-image: url(\"custom.png\");\n      }\n    }\n\noutput:\n\n    .button-ok {\n      background-image: url(\"ok.png\");\n    }\n    .button-cancel {\n      background-image: url(\"cancel.png\");\n    }\n    .button-custom {\n      background-image: url(\"custom.png\");\n    }\n\n### Multiple `&`\n\n`&` may appear more than once within a selector. This makes it possible to repeatedly refer to a parent selector without repeating its name.\n\n    .link {\n      & + & {\n        color: red;\n      }\n\n      & & {\n        color: green;\n      }\n\n      && {\n        color: blue;\n      }\n\n      &, &ish {\n        color: cyan;\n      }\n    }\n\nwill output:\n\n    .link + .link {\n      color: red;\n    }\n    .link .link {\n      color: green;\n    }\n    .link.link {\n      color: blue;\n    }\n    .link, .linkish {\n      color: cyan;\n    }\n\nNote that `&` represents all parent selectors (not just the nearest ancestor) so the following example:\n\n    .grand {\n      .parent {\n        & > & {\n          color: red;\n        }\n\n        & & {\n          color: green;\n        }\n\n        && {\n          color: blue;\n        }\n\n        &, &ish {\n          color: cyan;\n        }\n      }\n    }\n\nresults in:\n\n    .grand .parent > .grand .parent {\n      color: red;\n    }\n    .grand .parent .grand .parent {\n      color: green;\n    }\n    .grand .parent.grand .parent {\n      color: blue;\n    }\n    .grand .parent,\n    .grand .parentish {\n      color: cyan;\n    }\n\n### Changing Selector Order\n\nIt can be useful to prepend a selector to the inherited (parent) selectors. This can be done by putting the `&` after current selector. For example, when using Modernizr, you might want to specify different rules based on supported features:\n\n    .header {\n      .menu {\n        border-radius: 5px;\n        .no-borderradius & {\n          background-image: url('images/button-background.png');\n        }\n      }\n    }\n\nThe selector `.no-borderradius &` will prepend `.no-borderradius` to its parent `.header .menu` to form the`.no-borderradius .header .menu` on output:\n\n    .header .menu {\n      border-radius: 5px;\n    }\n    .no-borderradius .header .menu {\n      background-image: url('images/button-background.png');\n    }\n\n### Combinatorial Explosion\n\n`&` can also be used to generate every possible permutation of selectors in a comma separated list:\n\n    p, a, ul, li {\n      border-top: 2px dotted #366;\n      & + & {\n        border-top: 0;\n      }\n    }\n\nThis expands to all possible (16) combinations of the specified elements:\n\n    p,\n    a,\n    ul,\n    li {\n      border-top: 2px dotted #366;\n    }\n    p + p,\n    p + a,\n    p + ul,\n    p + li,\n    a + p,\n    a + a,\n    a + ul,\n    a + li,\n    ul + p,\n    ul + a,\n    ul + ul,\n    ul + li,\n    li + p,\n    li + a,\n    li + ul,\n    li + li {\n      border-top: 0;\n    }\n\n## Extend\n\nExtend is a Less pseudo-class which merges the selector it is put on with ones that match what it references.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\n    nav ul {\n      &:extend(.inline);\n      background: blue;\n    }\n\nIn the rule set above, the `:extend` selector will apply the \"extending selector\" (`nav ul`) onto the `.inline` class *wherever the `.inline` class appears*. The declaration block will be kept as-is, but without any reference to the extend (because extend isn't css).\n\nSo the following:\n\n    nav ul {\n      &:extend(.inline);\n      background: blue;\n    }\n    .inline {\n      color: red;\n    }\n\nOutputs\n\n    nav ul {\n      background: blue;\n    }\n    .inline,\n    nav ul {\n      color: red;\n    }\n\nNotice how the `nav ul:extend(.inline)` selector gets output as `nav ul` - the extend gets removed before output and the selector block left as-is. If no properties are put in that block then it gets removed from the output (but the extend still may affect other selectors).\n\n### Extend Syntax\n\nThe extend is either attached to a selector or placed into a ruleset. It looks like a pseudo-class with selector parameter optionally followed by the keyword `all`:\n\nExample:\n\n    .a:extend(.b) {}\n\n    // the above block does the same thing as the below block\n    .a {\n      &:extend(.b);\n    }\n\n    .c:extend(.d all) {\n      // extends all instances of \".d\" e.g. \".x.d\" or \".d.x\"\n    }\n    .c:extend(.d) {\n      // extends only instances where the selector will be output as just \".d\"\n    }\n\nIt can contain one or more classes to extend, separated by commas.\n\nExample:\n\n    .e:extend(.f) {}\n    .e:extend(.g) {}\n\n    // the above and the below do the same thing\n    .e:extend(.f, .g) {}\n\n### Extend Attached to Selector\n\nExtend attached to a selector looks like an ordinary pseudo-class with selector as a parameter. A selector can contain multiple extend clauses, but all extends must be at the end of the selector.\n\n- Extend after the selector: `pre:hover:extend(div pre)`.\n- Space between selector and extend is allowed: `pre:hover :extend(div pre)`.\n- Multiple extends are allowed: `pre:hover:extend(div pre):extend(.bucket tr)` - Note this is the same as `pre:hover:extend(div pre, .bucket tr)`\n- This is NOT allowed: `pre:hover:extend(div pre).nth-child(odd)`. Extend must be last.\n\nIf a ruleset contains multiple selectors, any of them can have the extend keyword. Multiple selectors with extend in one ruleset:\n\n    .big-division,\n    .big-bag:extend(.bag),\n    .big-bucket:extend(.bucket) {\n      // body\n    }\n\n### Extend Inside Ruleset\n\nExtend can be placed into a ruleset's body using `&:extend(selector)` syntax. Placing extend into a body is a shortcut for placing it into every single selector of that ruleset.\n\nExtend inside a body:\n\n    pre:hover,\n    .some-class {\n      &:extend(div pre);\n    }\n\nis exactly the same as adding an extend after each selector:\n\n    pre:hover:extend(div pre),\n    .some-class:extend(div pre) {}\n\n### Extending Nested Selectors\n\nExtend is able to match nested selectors. Following less:\n\nExample:\n\n    .bucket {\n      tr { // nested ruleset with target selector\n        color: blue;\n      }\n    }\n    .some-class:extend(.bucket tr) {} // nested ruleset is recognized\n\nOutputs\n\n    .bucket tr,\n    .some-class {\n      color: blue;\n    }\n\nEssentially the extend looks at the compiled css, not the original less.\n\nExample:\n\n    .bucket {\n      tr & { // nested ruleset with target selector\n        color: blue;\n      }\n    }\n    .some-class:extend(tr .bucket) {} // nested ruleset is recognized\n\nOutputs\n\n    tr .bucket,\n    .some-class {\n      color: blue;\n    }\n\n### Exact Matching with Extend\n\nExtend by default looks for exact match between selectors. It does matter whether selector uses leading star or not. It does not matter that two nth-expressions have the same meaning, they need to have to same form in order to be matched. The only exception are quotes in attribute selector, less knows they have the same meaning and matches them.\n\nExample:\n\n    .a.class,\n    .class.a,\n    .class > .a {\n      color: blue;\n    }\n    .test:extend(.class) {} // this will NOT match the any selectors above\n\nLeading star does matter. Selectors `*.class` and `.class` are equivalent, but extend will not match them:\n\n    *.class {\n      color: blue;\n    }\n    .noStar:extend(.class) {} // this will NOT match the *.class selector\n\nOutputs\n\n    *.class {\n      color: blue;\n    }\n\nOrder of pseudo-classes does matter. Selectors `link:hover:visited` and `link:visited:hover` match the same set of elements, but extend treats them as different:\n\n    link:hover:visited {\n      color: blue;\n    }\n    .selector:extend(link:visited:hover) {}\n\nOutputs\n\n    link:hover:visited {\n      color: blue;\n    }\n\n### nth Expression\n\nNth expression form does matter. Nth-expressions `1n+3` and `n+3` are equivalent, but extend will not match them:\n\n    :nth-child(1n+3) {\n      color: blue;\n    }\n    .child:extend(:nth-child(n+3)) {}\n\nOutputs\n\n    :nth-child(1n+3) {\n      color: blue;\n    }\n\nQuote type in attribute selector does not matter. All of the following are equivalent.\n\n    [title=identifier] {\n      color: blue;\n    }\n    [title='identifier'] {\n      color: blue;\n    }\n    [title=\"identifier\"] {\n      color: blue;\n    }\n\n    .noQuote:extend([title=identifier]) {}\n    .singleQuote:extend([title='identifier']) {}\n    .doubleQuote:extend([title=\"identifier\"]) {}\n\nOutputs\n\n    [title=identifier],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n    [title='identifier'],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n    [title=\"identifier\"],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n### Extend \"all\"\n\nWhen you specify the all keyword last in an extend argument it tells Less to match that selector as part of another selector. The selector will be copied and the matched part of the selector only will then be replaced with the extend, making a new selector.\n\nExample:\n\n    .a.b.test,\n    .test.c {\n      color: orange;\n    }\n    .test {\n      &:hover {\n        color: green;\n      }\n    }\n\n    .replacement:extend(.test all) {}\n\nOutputs\n\n    .a.b.test,\n    .test.c,\n    .a.b.replacement,\n    .replacement.c {\n      color: orange;\n    }\n    .test:hover,\n    .replacement:hover {\n      color: green;\n    }\n\n*You can think of this mode of operation as essentially doing a non-destructive search and replace.*\n\n### Selector Interpolation with Extend\n\nExtend is **not** able to match selectors with variables. If selector contains variable, extend will ignore it.\n\nHowever, extend can be attached to interpolated selector.\n\nSelector with variable will not be matched:\n\n    @variable: .bucket;\n    @{variable} { // interpolated selector\n      color: blue;\n    }\n    .some-class:extend(.bucket) {} // does nothing, no match is found\n\nand extend with variable in target selector matches nothing:\n\n    .bucket {\n      color: blue;\n    }\n    .some-class:extend(@{variable}) {} // interpolated selector matches nothing\n    @variable: .bucket;\n\nBoth of the above examples compile into:\n\n    .bucket {\n      color: blue;\n    }\n\nHowever, `:extend` attached to an interpolated selector works:\n\n    .bucket {\n      color: blue;\n    }\n    @{variable}:extend(.bucket) {}\n    @variable: .selector;\n\ncompiles to:\n\n    .bucket, .selector {\n      color: blue;\n    }\n\n### Scoping / Extend Inside @media\n\nCurrently, an `:extend` inside a `@media` declaration will only match selectors inside the same media declaration:\n\n    @media print {\n      .screenClass:extend(.selector) {} // extend inside media\n      .selector { // this will be matched - it is in the same media\n        color: black;\n      }\n    }\n    .selector { // ruleset on top of style sheet - extend ignores it\n      color: red;\n    }\n    @media screen {\n      .selector {  // ruleset inside another media - extend ignores it\n        color: blue;\n      }\n    }\n\ncompiles into:\n\n    @media print {\n      .selector,\n      .screenClass { /*  ruleset inside the same media was extended */\n        color: black;\n      }\n    }\n    .selector { /* ruleset on top of style sheet was ignored */\n      color: red;\n    }\n    @media screen {\n      .selector { /* ruleset inside another media was ignored */\n        color: blue;\n      }\n    }\n\nNote: extending does not match selectors inside a nested `@media` declaration:\n\n    @media screen {\n      .screenClass:extend(.selector) {} // extend inside media\n      @media (min-width: 1023px) {\n        .selector {  // ruleset inside nested media - extend ignores it\n          color: blue;\n        }\n      }\n    }\n\nThis compiles into:\n\n    @media screen and (min-width: 1023px) {\n      .selector { /* ruleset inside another nested media was ignored */\n        color: blue;\n      }\n    }\n\nTop level extend matches everything including selectors inside nested media:\n\n    @media screen {\n      .selector {  /* ruleset inside nested media - top level extend works */\n        color: blue;\n      }\n      @media (min-width: 1023px) {\n        .selector {  /* ruleset inside nested media - top level extend works */\n          color: blue;\n        }\n      }\n    }\n\n    .topLevel:extend(.selector) {} /* top level extend matches everything */\n\ncompiles into:\n\n    @media screen {\n      .selector,\n      .topLevel { /* ruleset inside media was extended */\n        color: blue;\n      }\n    }\n    @media screen and (min-width: 1023px) {\n      .selector,\n      .topLevel { /* ruleset inside nested media was extended */\n        color: blue;\n      }\n    }\n\n### Duplication Detection\n\nCurrently there is no duplication detection.\n\nExample:\n\n    .alert-info,\n    .widget {\n      /* declarations */\n    }\n\n    .alert:extend(.alert-info, .widget) {}\n\nOutputs\n\n    .alert-info,\n    .widget,\n    .alert,\n    .alert {\n      /* declarations */\n    }\n\n### Use Cases for Extend\n\n### Classic Use Case\n\nThe classic use case is to avoid adding a base class. For example, if you have\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n\nand you want to have a subtype of animal which overrides the background color then you have two options, firstly change your HTML\n\n    <a class=\"animal bear\">Bear</a>\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n    .bear {\n      background-color: brown;\n    }\n\nor have simplified html and use extend in your less. e.g.\n\n    <a class=\"bear\">Bear</a>\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n    .bear {\n      &:extend(.animal);\n      background-color: brown;\n    }\n\n### Reducing CSS Size\n\nMixins copy all of the properties into a selector, which can lead to unnecessary duplication. Therefore you can use extends instead of mixins to move the selector up to the properties you wish to use, which leads to less CSS being generated.\n\nExample - with mixin:\n\n    .my-inline-block() {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing1 {\n      .my-inline-block;\n    }\n    .thing2 {\n      .my-inline-block;\n    }\n\nOutputs\n\n    .thing1 {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing2 {\n      display: inline-block;\n      font-size: 0;\n    }\n\nExample (with extends):\n\n    .my-inline-block {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing1 {\n      &:extend(.my-inline-block);\n    }\n    .thing2 {\n      &:extend(.my-inline-block);\n    }\n\nOutputs\n\n    .my-inline-block,\n    .thing1,\n    .thing2 {\n      display: inline-block;\n      font-size: 0;\n    }\n\n### Combining Styles / A More Advanced Mixin\n\nAnother use-case is as an alternative for a mixin - because mixins can only be used with simple selectors, if you have two different blocks of html, but need to apply the same styles to both you can use extends to relate two areas.\n\nExample:\n\n    li.list > a {\n      // list styles\n    }\n    button.list-style {\n      &:extend(li.list > a); // use the same list styles\n    }\n\n## Merge\n\nCombine properties\n\nThe `merge` feature allows for aggregating values from multiple properties into a comma or space separated list under a single property. `merge` is useful for properties such as background and transform.\n\n### Comma\n\nAppend property value with comma\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    .mixin() {\n      box-shadow+: inset 0 0 10px #555;\n    }\n    .myclass {\n      .mixin();\n      box-shadow+: 0 0 20px black;\n    }\n\nOutputs\n\n    .myclass {\n      box-shadow: inset 0 0 10px #555, 0 0 20px black;\n    }\n\n### Space\n\nAppend property value with space\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    .mixin() {\n      transform+_: scale(2);\n    }\n    .myclass {\n      .mixin();\n      transform+_: rotate(15deg);\n    }\n\nOutputs\n\n    .myclass {\n      transform: scale(2) rotate(15deg);\n    }\n\nTo avoid any unintentional joins, `merge` requires an explicit `+` or `+_` flag on each join pending declaration.\n\n## Mixins\n\n\"mix-in\" properties from existing styles\n\nYou can mix-in class selectors and id selectors, e.g.\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      .a();\n    }\n    .mixin-id {\n      #b();\n    }\n\nwhich results in:\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      color: red;\n    }\n    .mixin-id {\n      color: red;\n    }\n\nHistorically, the parentheses in a mixin call are optional, but optional parentheses are deprecated and will be required in a future release.\n\n    .a(); \n    .a;    // currently works, but deprecated; don't use\n    .a (); // white-space before parentheses is also deprecated\n\n### Mixins With Parentheses\n\nIf you want to create a mixin but you do not want that mixin to be in your CSS output, put parentheses after the mixin definition.\n\n    .my-mixin {\n      color: black;\n    }\n    .my-other-mixin() {\n      background: white;\n    }\n    .class {\n      .my-mixin();\n      .my-other-mixin();\n    }\n\noutputs\n\n    .my-mixin {\n      color: black;\n    }\n    .class {\n      color: black;\n      background: white;\n    }\n\n### Selectors in Mixins\n\nMixins can contain more than just properties, they can contain selectors too.\n\nFor example:\n\n    .my-hover-mixin() {\n      &:hover {\n        border: 1px solid red;\n      }\n    }\n    button {\n      .my-hover-mixin();\n    }\n\nOutputs\n\n    button:hover {\n      border: 1px solid red;\n    }\n\n### Namespaces\n\nIf you want to mixin properties inside a more complicated selector, you can stack up multiple ids or classes.\n\n    #outer() {\n      .inner {\n        color: red;\n      }\n    }\n\n    .c {\n      #outer.inner();\n    }\n\nNote: legacy Less syntax allows `>` and whitespace between namespaces and mixins. This syntax is deprecated and may be removed. Currently, these do the same thing.\n\n    #outer > .inner(); // deprecated\n    #outer .inner();   // deprecated\n    #outer.inner();    // preferred\n\nNamespacing your mixins like this reduces conflicts with other library mixins or user mixins, but can also be a way to \"organize\" groups of mixins.\n\nExample:\n\n    #my-library {\n      .my-mixin() {\n        color: black;\n      }\n    }\n    // which can be used like this\n    .class {\n      #my-library.my-mixin();\n    }\n\n### Guarded Namespaces\n\nIf a namespace has a guard, mixins defined by it are used only if the guard condition returns true. A namespace guard is evaluated exactly the same as a guard on a mixin, so the following two mixins work the same way:\n\n    #namespace when (@mode = huge) {\n      .mixin() { /* */ }\n    }\n\n    #namespace {\n      .mixin() when (@mode = huge) { /* */ }\n    }\n\nThe `default` function is assumed to have the same value for all nested namespaces and mixin. The following mixin is never evaluated; one of its guards is guaranteed to be false:\n\n    #sp_1 when (default()) {\n      #sp_2 when (default()) {\n        .mixin() when not(default()) { /* */ }\n      }\n    }\n\n### The `!important` keyword\n\nUse the `!important` keyword after mixin call to mark all properties inherited by it as `!important`:\n\nExample:\n\n    .foo (@bg: #f5f5f5; @color: #900) {\n      background: @bg;\n      color: @color;\n    }\n    .unimportant {\n      .foo();\n    }\n    .important {\n      .foo() !important;\n    }\n\nResults in:\n\n    .unimportant {\n      background: #f5f5f5;\n      color: #900;\n    }\n    .important {\n      background: #f5f5f5 !important;\n      color: #900 !important;\n    }\n\n### Parametric Mixins\n\nHow to pass arguments to mixins\n\nMixins can also take arguments, which are variables passed to the block of selectors when it is mixed in.\n\nFor example:\n\n    .border-radius(@radius) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nAnd here's how we can mix it into various rulesets:\n\n    #header {\n      .border-radius(4px);\n    }\n    .button {\n      .border-radius(6px);\n    }\n\nParametric mixins can also have default values for their parameters:\n\n    .border-radius(@radius: 5px) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nWe can invoke it like this now:\n\n    #header {\n      .border-radius();\n    }\n\nAnd it will include a 5px border-radius.\n\nYou can also use parametric mixins which don't take parameters. This is useful if you want to hide the ruleset from the CSS output, but want to include its properties in other rulesets:\n\n    .wrap() {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n    pre { .wrap() }\n\nWhich would output:\n\n    pre {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n### Parameter separators\n\nParameters are currently either *semicolon* or *comma* separated.\n\nOriginally, parameters were only separated by commas, but the semi-colon was later added to support passing comma-separated list values to single arguments.\n\n- two arguments and each contains comma separated list: `.name(1, 2, 3; something, else)`,\n- three arguments and each contains one number: `.name(1, 2, 3)`,\n- use dummy semicolon to create mixin call with one argument containing comma separated css list: `.name(1, 2, 3;)`,\n- comma separated default value: `.name(@param1: red, blue;)`.\n- As of Less 4.0, you can wrap a list value using a paren escape \\[`~()`\\], e.g. `.name(@param1: ~(red, blue))`. This is similar to the quote escape syntax: `~\"quote\"`\n\n### Overloading mixins\n\nIt is legal to define multiple mixins with the same name and number of parameters. Less will use properties of all that can apply. If you used the mixin with one parameter e.g. `.mixin(green);`, then properties of all mixins with exactly one mandatory parameter will be used:\n\n    .mixin(@color) {\n      color-1: @color;\n    }\n    .mixin(@color, @padding: 2) {\n      color-2: @color;\n      padding-2: @padding;\n    }\n    .mixin(@color, @padding, @margin: 2) {\n      color-3: @color;\n      padding-3: @padding;\n      margin: @margin @margin @margin @margin;\n    }\n    .some .selector div {\n      .mixin(#008000);\n    }\n\ncompiles into:\n\n    .some .selector div {\n      color-1: #008000;\n      color-2: #008000;\n      padding-2: 2;\n    }\n\n### Named Parameters\n\nA mixin reference can supply parameters values by their names instead of just positions. Any parameter can be referenced by its name and they do not have to be in any special order:\n\n    .mixin(@color: black; @margin: 10px; @padding: 20px) {\n      color: @color;\n      margin: @margin;\n      padding: @padding;\n    }\n    .class1 {\n      .mixin(@margin: 20px; @color: #33acfe);\n    }\n    .class2 {\n      .mixin(#efca44; @padding: 40px);\n    }\n\ncompiles into:\n\n    .class1 {\n      color: #33acfe;\n      margin: 20px;\n      padding: 20px;\n    }\n    .class2 {\n      color: #efca44;\n      margin: 10px;\n      padding: 40px;\n    }\n\n### The `@arguments` Variable\n\n`@arguments` has a special meaning inside mixins, it contains all the arguments passed, when the mixin was called. This is useful if you don't want to deal with individual parameters:\n\n    .box-shadow(@x: 0, @y: 0, @blur: 1px, @color: #000) {\n      -webkit-box-shadow: @arguments;\n         -moz-box-shadow: @arguments;\n              box-shadow: @arguments;\n    }\n    .big-block {\n      .box-shadow(2px, 5px);\n    }\n\nWhich results in:\n\n    .big-block {\n      -webkit-box-shadow: 2px 5px 1px #000;\n         -moz-box-shadow: 2px 5px 1px #000;\n              box-shadow: 2px 5px 1px #000;\n    }\n\n### Advanced Arguments and the `@rest` Variable\n\nYou can use `...` if you want your mixin to take a variable number of arguments. Using this after a variable name will assign those arguments to the variable.\n\n    .mixin(...) {        // matches 0-N arguments\n    .mixin() {           // matches exactly 0 arguments\n    .mixin(@a: 1) {      // matches 0-1 arguments\n    .mixin(@a: 1, ...) { // matches 0-N arguments\n    .mixin(@a, ...) {    // matches 1-N arguments\n\nFurthermore:\n\n    .mixin(@a, @rest...) {\n       // @rest is bound to arguments after @a\n       // @arguments is bound to all arguments\n    }\n\n### Pattern-matching\n\nSometimes, you may want to change the behavior of a mixin, based on the parameters you pass to it. Let's start with something basic:\n\n    .mixin(@s, @color) { ... }\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nNow let's say we want `.mixin` to behave differently, based on the value of `@switch`, we could define `.mixin` as such:\n\n    .mixin(dark, @color) {\n      color: darken(@color, 10%);\n    }\n    .mixin(light, @color) {\n      color: lighten(@color, 10%);\n    }\n    .mixin(@_, @color) {\n      display: block;\n    }\n\nNow, if we run:\n\n    @switch: light;\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nWe will get the following CSS:\n\n    .class {\n      color: #a2a2a2;\n      display: block;\n    }\n\nWhere the color passed to `.mixin` was lightened. If the value of `@switch` was `dark`, the result would be a darker color.\n\nHere's what happened:\n\n- The first mixin definition didn't match because it expected `dark` as the first argument.\n- The second mixin definition matched, because it expected `light`.\n- The third mixin definition matched because it expected any value.\n\nOnly mixin definitions which matched were used. Variables match and bind to any value. Anything other than a variable matches only with a value equal to itself.\n\nWe can also match on arity, here's an example:\n\n    .mixin(@a) {\n      color: @a;\n    }\n    .mixin(@a, @b) {\n      color: fade(@a, @b);\n    }\n\nNow if we call `.mixin` with a single argument, we will get the output of the first definition, but if we call it with *two* arguments, we will get the second definition, namely `@a` faded to `@b`.\n\n### Using Mixins as Functions\n\nSelecting properties and variables from mixin calls\n\n### Property / value accessors\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors to select a value from an evaluated mixin's rules. This can allow you to use mixins similar to functions.\n\nExample:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its \"@result\" value\n      padding: .average(16px, 50px)[@result];\n    }\n\nResults in:\n\n    div {\n      padding: 33px;\n    }\n\n### Overriding mixin values\n\nIf you have multiple matching mixins, all rules are evaluated and merged, and the last matching value with that identifier is returned. This is similar to the cascade in CSS, and it allows you to \"override\" mixin values.\n\n    // library.less\n    #library() {\n      .mixin() {\n        prop: foo;\n      }\n    }\n\n    // customize.less\n    @import \"library\";\n    #library() {\n      .mixin() {\n        prop: bar;\n      }\n    }\n\n    .box {\n      my-value: #library.mixin[prop];\n    }\n\nOutputs:\n\n    .box {\n      my-value: bar;\n    }\n\n### Unnamed lookups\n\nIf you don't specify a lookup value in `[@lookup]` and instead write `[]` after a mixin or ruleset call, *all* values will cascade and the last declared value will be selected.\n\nMeaning: the averaging mixin from the above example could be written as:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its final value\n      padding: .average(16px, 50px)[];\n    }\n\nThe output is the same:\n\n    div {\n      padding: 33px;\n    }\n\nThe same cascading behavior is true for rulesets or variables aliased to mixin calls.\n\n    @dr: {\n      value: foo;\n    }\n    .box {\n      my-value: @dr[];\n    }\n\nThis outputs:\n\n    .box {\n      my-value: foo;\n    }\n\n### Unlocking mixins & variables into caller scope\n\n***DEPRECATED - Use Property / Value Accessors***\n\nVariables and mixins defined in a mixin are visible and can be used in caller's scope. There is only one exception: a variable is not copied if the caller contains a variable with the same name (that includes variables defined by another mixin call). Only variables present in callers local scope are protected. Variables inherited from parent scopes are overridden.\n\n*Note: this behavior is deprecated, and in the future, variables and mixins will not be merged into the caller scope in this way.*\n\nExample:\n\n    .mixin() {\n      @width:  100%;\n      @height: 200px;\n    }\n\n    .caller {\n      .mixin();\n      width:  @width;\n      height: @height;\n    }\n\nResults in:\n\n    .caller {\n      width:  100%;\n      height: 200px;\n    }\n\nVariables defined directly in callers scope cannot be overridden. However, variables defined in callers parent scope is not protected and will be overridden:\n\n    .mixin() {\n      @size: in-mixin;\n      @definedOnlyInMixin: in-mixin;\n    }\n\n    .class {\n      margin: @size @definedOnlyInMixin;\n      .mixin();\n    }\n\n    @size: globaly-defined-value; // callers parent scope - no protection\n\nResults in:\n\n    .class {\n      margin: in-mixin in-mixin;\n    }\n\nFinally, mixin defined in mixin acts as return value too:\n\n    .unlock(@value) { // outer mixin\n      .doSomething() { // nested mixin\n        declaration: @value;\n      }\n    }\n\n    #namespace {\n      .unlock(5); // unlock doSomething mixin\n      .doSomething(); //nested mixin was copied here and is usable\n    }\n\nResults in:\n\n    #namespace {\n      declaration: 5;\n    }\n\n### Recursive Mixins\n\nCreating loops\n\nIn Less a mixin can call itself. Such recursive mixins, when combined with [Guard Expressions](#mixin-guards-feature) and [Pattern Matching](#mixins-parametric-feature-pattern-matching), can be used to create various iterative/loop structures.\n\nExample:\n\n    .loop(@counter) when (@counter > 0) {\n      .loop((@counter - 1));    // next iteration\n      width: (10px * @counter); // code for each iteration\n    }\n\n    div {\n      .loop(5); // launch the loop\n    }\n\nOutput:\n\n    div {\n      width: 10px;\n      width: 20px;\n      width: 30px;\n      width: 40px;\n      width: 50px;\n    }\n\nA generic example of using a recursive loop to generate CSS grid classes:\n\n    .generate-columns(4);\n\n    .generate-columns(@n, @i: 1) when (@i =< @n) {\n      .column-@{i} {\n        width: (@i * 100% / @n);\n      }\n      .generate-columns(@n, (@i + 1));\n    }\n\nOutput:\n\n    .column-1 {\n      width: 25%;\n    }\n    .column-2 {\n      width: 50%;\n    }\n    .column-3 {\n      width: 75%;\n    }\n    .column-4 {\n      width: 100%;\n    }\n\n### Mixin Guards\n\nGuards are useful when you want to match on *expressions*, as opposed to simple values or arity. If you are familiar with functional programming, you have probably encountered them already.\n\nIn trying to stay as close as possible to the declarative nature of CSS, Less has opted to implement conditional execution via **guarded mixins** instead of `if`/`else` statements, in the vein of `@media` query feature specifications.\n\nLet's start with an example:\n\n    .mixin(@a) when (lightness(@a) >= 50%) {\n      background-color: black;\n    }\n    .mixin(@a) when (lightness(@a) < 50%) {\n      background-color: white;\n    }\n    .mixin(@a) {\n      color: @a;\n    }\n\nThe key is the `when` keyword, which introduces a guard sequence (here with only one guard). Now if we run the following code:\n\n    .class1 { .mixin(#ddd) }\n    .class2 { .mixin(#555) }\n\nHere's what we'll get:\n\n    .class1 {\n      background-color: black;\n      color: #ddd;\n    }\n    .class2 {\n      background-color: white;\n      color: #555;\n    }\n\n### Guard Comparison Operators\n\nThe full list of comparison operators usable in guards are: `>`, `>=`, `=`, `=<`, `<`. Additionally, the keyword `true` is the only truthy value, making these two mixins equivalent:\n\n    .truth(@a) when (@a) { ... }\n    .truth(@a) when (@a = true) { ... }\n\nAny value other than the keyword `true` is falsy:\n\n    .class {\n      .truth(40); // Will not match any of the above definitions.\n    }\n\nNote that you can also compare arguments with each other, or with non-arguments:\n\n    @media: mobile;\n\n    .mixin(@a) when (@media = mobile) { ... }\n    .mixin(@a) when (@media = desktop) { ... }\n\n    .max(@a; @b) when (@a > @b) { width: @a }\n    .max(@a; @b) when (@a < @b) { width: @b }\n\n### Guard Logical Operators\n\nYou can use logical operators with guards. The syntax is based on CSS media queries.\n\nUse the `and` keyword to combine guards:\n\n    .mixin(@a) when (isnumber(@a)) and (@a > 0) { ... }\n\nYou can emulate the *or* operator by separating guards with a comma `,`. If any of the guards evaluate to true, it's considered a match:\n\n    .mixin(@a) when (@a > 10), (@a < -10) { ... }\n\nUse the `not` keyword to negate conditions:\n\n    .mixin(@b) when not (@b > 0) { ... }\n\n### Type Checking Functions\n\nLastly, if you want to match mixins based on value type, you can use the `is` functions:\n\n    .mixin(@a; @b: 0) when (isnumber(@b)) { ... }\n    .mixin(@a; @b: black) when (iscolor(@b)) { ... }\n\nHere are the basic type checking functions:\n\n- `iscolor`\n- `isnumber`\n- `isstring`\n- `iskeyword`\n- `isurl`\n\nIf you want to check if a value is in a specific unit in addition to being a number, you may use one of:\n\n- `ispixel`\n- `ispercentage`\n- `isem`\n- `isunit`\n\n### Aliasing Mixins\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nAssigning mixin calls to a variable\n\nMixins can be assigned to a variable to be called as a variable call, or can be used for map lookup.\n\n    #theme.dark.navbar {\n      .colors(light) {\n        primary: purple;\n      }\n      .colors(dark) {\n        primary: black;\n        secondary: grey;\n      }\n    }\n\n    .navbar {\n      @colors: #theme.dark.navbar.colors(dark);\n      background: @colors[primary];\n      border: 1px solid @colors[secondary];\n    }\n\nThis would output:\n\n    .navbar {\n      background: black;\n      border: 1px solid grey;\n    }\n\n### Variable calls\n\nEntire mixin calls can be aliased and called as variable calls. As in:\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors();\n      @alias();\n    }\n\nOutputs:\n\n    .box {\n      background: green;\n    }\n\nNote, unlike mixins used in root, mixin calls assigned to variables and *called with no arguments* always require parentheses. The following is not valid.\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors;\n      @alias();   // ERROR: Could not evaluate variable call @alias\n    }\n\nThis is because it's ambiguous if variable is assigned a list of selectors or a mixin call. For example, in Less 3.5+, this variable could be used this way.\n\n    .box {\n      @alias: #library.colors;\n      @{alias} {\n        a: b;\n      }\n    }\n\nThe above would output:\n\n    .box #library.colors {\n      a: b;\n    }\n\n## CSS Guards\n\n\"if\"'s around selectors\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nLike Mixin Guards, guards can also be applied to css selectors, which is syntactic sugar for declaring the mixin and then calling it immediately.\n\nFor instance, before 1.5.0 you would have had to do this:\n\n    .my-optional-style() when (@my-option = true) {\n      button {\n        color: white;\n      }\n    }\n    .my-optional-style();\n\nNow, you can apply the guard directly to a style.\n\n    button when (@my-option = true) {\n      color: white;\n    }\n\nYou can also achieve an `if` type statement by combining this with the `&` feature, allowing you to group multiple guards.\n\n    & when (@my-option = true) {\n      button {\n        color: white;\n      }\n      a {\n        color: blue;\n      }\n    }\n\nNote that you can also achieve a similar pattern by using the actual `if()` function and a variable call. As in:\n\n    @dr: if(@my-option = true, {\n      button {\n        color: white;\n      }\n      a {\n        color: blue;\n      }\n    });\n    @dr();\n\n## Detached Rulesets\n\nAssign a ruleset to a variable\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nA detached ruleset is a group of css properties, nested rulesets, media declarations or anything else stored in a variable. You can include it into a ruleset or another structure and all its properties are going to be copied there. You can also use it as a mixin argument and pass it around as any other variable.\n\nSimple example:\n\n    // declare detached ruleset\n    @detached-ruleset: { background: red; }; // semi-colon is optional in 3.5.0+\n\n    // use detached ruleset\n    .top {\n        @detached-ruleset(); \n    }\n\ncompiles into:\n\n    .top {\n      background: red;\n    }\n\nParentheses after a detached ruleset call are mandatory (except when followed by a [lookup value](#detached-rulesets-feature-property-variable-accessors)). The call `@detached-ruleset;` would not work.\n\nIt is useful when you want to define a mixin that abstracts out either wrapping a piece of code in a media query or a non-supported browser class name. The rulesets can be passed to mixin so that the mixin can wrap the content, e.g.\n\n    .desktop-and-old-ie(@rules) {\n      @media screen and (min-width: 1200px) { @rules(); }\n      html.lt-ie9 &                         { @rules(); }\n    }\n\n    header {\n      background-color: blue;\n\n      .desktop-and-old-ie({\n        background-color: red;\n      });\n    }\n\nHere the `desktop-and-old-ie` mixin defines the media query and root class so that you can use a mixin to wrap a piece of code. This will output\n\n    header {\n      background-color: blue;\n    }\n    @media screen and (min-width: 1200px) {\n      header {\n        background-color: red;\n      }\n    }\n    html.lt-ie9 header {\n      background-color: red;\n    }\n\nA ruleset can be now assigned to a variable or passed in to a mixin and can contain the full set of Less features, e.g.\n\n    @my-ruleset: {\n        .my-selector {\n          background-color: black;\n        }\n      };\n\nYou can even take advantage of [media query bubbling](#features-overview-feature-media-query-bubbling-and-nested-media-queries), for instance\n\n    @my-ruleset: {\n        .my-selector {\n          @media tv {\n            background-color: black;\n          }\n        }\n      };\n    @media (orientation:portrait) {\n        @my-ruleset();\n    }\n\nwhich will output\n\n    @media (orientation: portrait) and tv {\n      .my-selector {\n        background-color: black;\n      }\n    }\n\nA detached ruleset call unlocks (returns) all its mixins into caller the same way as mixin calls do. However, it does **not** return variables.\n\nReturned mixin:\n\n    // detached ruleset with a mixin\n    @detached-ruleset: { \n        .mixin() {\n            color: blue;\n        }\n    };\n    // call detached ruleset\n    .caller {\n        @detached-ruleset(); \n        .mixin();\n    }\n\nResults in:\n\n    .caller {\n      color: blue;\n    }\n\nPrivate variables:\n\n    @detached-ruleset: { \n        @color:blue; // this variable is private\n    };\n    .caller {\n        color: @color; // syntax error\n    }\n\n### Scoping\n\nA detached ruleset can use all variables and mixins accessible where it is *defined* and where it is *called*. Otherwise said, both definition and caller scopes are available to it. If both scopes contains the same variable or mixin, declaration scope value takes precedence.\n\n*Declaration scope* is the one where detached ruleset body is defined. Copying a detached ruleset from one variable into another cannot modify its scope. The ruleset does not gain access to new scopes just by being referenced there.\n\nLastly, a detached ruleset can gain access to scope by being unlocked (imported) into it.\n\n*Note: unlocking variables into scope via a called mixin is deprecated. Use [property / variable accessors](#detached-rulesets-feature-property-variable-accessors).*\n\n### Definition and Caller Scope Visibility\n\nA detached ruleset sees the caller's variables and mixins:\n\n    @detached-ruleset: {\n      caller-variable: @caller-variable; // variable is undefined here\n      .caller-mixin(); // mixin is undefined here\n    };\n\n    selector {\n      // use detached ruleset\n      @detached-ruleset(); \n\n      // define variable and mixin needed inside the detached ruleset\n      @caller-variable: value;\n      .caller-mixin() {\n        variable: declaration;\n      }\n    }\n\ncompiles into:\n\n    selector {\n      caller-variable: value;\n      variable: declaration;\n    }\n\nVariable and mixins accessible from definition win over those available in the caller:\n\n    @variable: global;\n    @detached-ruleset: {\n      // will use global variable, because it is accessible\n      // from detached-ruleset definition\n      variable: @variable; \n    };\n\n    selector {\n      @detached-ruleset();\n      @variable: value; // variable defined in caller - will be ignored\n    }\n\ncompiles into:\n\n    selector {\n      variable: global;\n    }\n\n### Referencing *Won't* Modify Detached Ruleset Scope\n\nA ruleset does not gain access to new scopes just by being referenced there:\n\n    @detached-1: { scope-detached: @one @two; };\n    .one {\n      @one: visible;\n      .two {\n        @detached-2: @detached-1; // copying/renaming ruleset \n        @two: visible; // ruleset can not see this variable\n      }\n    }\n\n    .use-place {\n      .one > .two(); \n      @detached-2();\n    }\n\nthrows an error:\n\n    ERROR 1:32 The variable \"@one\" was not declared.\n\n### Unlocking *Will* Modify Detached Ruleset Scope\n\nA detached ruleset gains access by being unlocked (imported) inside a scope:\n\n    #space {\n      .importer-1() {\n        @detached: { scope-detached: @variable; }; // define detached ruleset\n      }\n    }\n\n    .importer-2() {\n      @variable: value; // unlocked detached ruleset CAN see this variable\n      #space > .importer-1(); // unlock/import detached ruleset\n    }\n\n    .use-place {\n      .importer-2(); // unlock/import detached ruleset second time\n       @detached();\n    }\n\ncompiles into:\n\n    .use-place {\n      scope-detached: value;\n    }\n\n### Property / variable accessors\n\n### (Lookup values)\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors (also called \"lookups\") to select a value from variable (detached) rulesets.\n\n    @config: {\n      option1: true;\n      option2: false;\n    }\n\n    .mixin() when (@config[option1] = true) {\n      selected: value;\n    }\n\n    .box {\n      .mixin();\n    }\n\nOutputs:\n\n    .box {\n      selected: value;\n    }\n\nIf what is returned from a lookup is another detached ruleset, you can use a second lookup to get that value.\n\n    @config: {\n      @colors: {\n        primary: blue;\n      }\n    }\n\n    .box {\n      color: @config[@colors][primary];\n    }\n\n### Variable variables in lookups\n\nThe lookup value that is returned can itself be variable. As in, you can write:\n\n    @config: {\n      @dark: {\n        primary: darkblue;\n      }\n      @light: {\n        primary: lightblue;\n      }\n    }\n\n    .box {\n      @lookup: dark;\n      color: @config[@@lookup][primary];\n    }\n\nThis will output:\n\n    .box {\n      color: darkblue;\n    }\n\n## @import At-Rules\n\nImport styles from other style sheets\n\nIn standard CSS, `@import` at-rules must precede all other types of rules. But Less doesn't care where you put `@import` statements.\n\nExample:\n\n    .foo {\n      background: #900;\n    }\n    @import \"this-is-valid.less\";\n\n### File Extensions\n\n`@import` statements may be treated differently by Less depending on the file extension:\n\n- If the file has a `.css` extension it will be treated as CSS and the `@import` statement left as-is (see the [inline option](#import-options-inline) below).\n- If it has *any other extension* it will be treated as Less and imported.\n- If it does not have an extension, `.less` will be appended and it will be included as a imported Less file.\n\nExamples:\n\n    @import \"foo\";      // foo.less is imported\n    @import \"foo.less\"; // foo.less is imported\n    @import \"foo.php\";  // foo.php imported as a Less file\n    @import \"foo.css\";  // statement left in place, as-is\n\nThe following options can be used to override this behavior.\n\n### Import Options\n\nLess offers several extensions to the CSS `@import` CSS at-rule to provide more flexibility over what you can do with external files.\n\nSyntax: `@import (keyword) \"filename\";`\n\nThe following import options have been implemented:\n\n- `reference`: use a Less file but do not output it\n- `inline`: include the source file in the output but do not process it\n- `less`: treat the file as a Less file, no matter what the file extension\n- `css`: treat the file as a CSS file, no matter what the file extension\n- `once`: only include the file once (this is default behavior)\n- `multiple`: include the file multiple times\n- `optional`: continue compiling when file is not found\n\nMore than one keyword per `@import` is allowed, you will have to use commas to separate the keywords:\n\nExample: `@import (optional, reference) \"foo.less\";`\n\n### reference\n\nUse `@import (reference)` to import external files, but without adding the imported styles to the compiled output unless referenced.\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample: `@import (reference) \"foo.less\";`\n\nImagine that `reference` marks every at-rule and selector with a *reference flag* in the imported file, imports as normal, but when the CSS is generated, \"reference\" selectors (as well as any media queries containing only reference selectors) are not output. `reference` styles will not show up in your generated CSS unless the reference styles are used as [mixins](#mixins-feature) or [extended](#extend-feature).\n\nAdditionally, **`reference`** produces different results depending on which method was used (mixin or extend):\n\n- **[extend](#extend-feature)**: When a selector is extended, only the new selector is marked as *not referenced*, and it is pulled in at the position of the reference `@import` statement.\n- **[mixins](#mixins-feature)**: When a `reference` style is used as an [implicit mixin](#mixins-feature), its rules are mixed-in, marked \"not reference\", and appear in the referenced place as normal.\n\n### reference example\n\nThis allows you to pull in only specific, targeted styles from a library such as [Bootstrap](https://github.com/twbs/bootstrap) by doing something like this:\n\n    .navbar:extend(.navbar all) {}\n\nAnd you will pull in only `.navbar` related styles from Bootstrap.\n\n### inline\n\nUse `@import (inline)` to include external files, but not process them.\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample: `@import (inline) \"not-less-compatible.css\";`\n\nYou will use this when a CSS file may not be Less compatible; this is because although Less supports most known standards CSS, it does not support comments in some places and does not support all known CSS hacks without modifying the CSS.\n\nSo you can use this to include the file in the output so that all CSS will be in one file.\n\n### less\n\nUse `@import (less)` to treat imported files as Less, regardless of file extension.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    @import (less) \"foo.css\";\n\n### css\n\nUse `@import (css)` to treat imported files as regular CSS, regardless of file extension. This means the import statement will be left as it is.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    @import (css) \"foo.less\";\n\noutputs\n\n    @import \"foo.less\";\n\n### once\n\nThe default behavior of `@import` statements. It means the file is imported only once and subsequent import statements for that file will be ignored.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nThis is the default behavior of `@import` statements.\n\nExample:\n\n    @import (once) \"foo.less\";\n    @import (once) \"foo.less\"; // this statement will be ignored\n\n### multiple\n\nUse `@import (multiple)` to allow importing of multiple files with the same name. This is the opposite behavior to once.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    // file: foo.less\n    .a {\n      color: green;\n    }\n    // file: main.less\n    @import (multiple) \"foo.less\";\n    @import (multiple) \"foo.less\";\n\nOutputs\n\n    .a {\n      color: green;\n    }\n    .a {\n      color: green;\n    }\n\n### optional\n\nUse `@import (optional)` to allow importing of a file only when it exists. Without the `optional` keyword Less throws a FileError and stops compiling when importing a file that can not be found.\n\nReleased [v2.3.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\n## @plugin At-Rules\n\nReleased [v2.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nImport JavaScript plugins to add Less.js functions and features\n\n### Writing your first plugin\n\nUsing a `@plugin` at-rule is similar to using an `@import` for your `.less` files.\n\n    @plugin \"my-plugin\";  // automatically appends .js if no extension\n\nSince Less plugins are evaluated within the Less scope, the plugin definition can be quite simple.\n\n    registerPlugin({\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    })\n\nor you can use `module.exports` (shimmed to work in browser as well as Node.js).\n\n    module.exports = {\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    };\n\nNote that other Node.js CommonJS conventions, like `require()` are not available in the browser. Keep this in mind when writing cross-platform plugins.\n\nWhat can you do with a plugin? A lot, but let's start with the basics. We'll focus first on what you might put inside the `install` function. Let's say you write this:\n\n    // my-plugin.js\n    install: function(less, pluginManager, functions) {\n        functions.add('pi', function() {\n            return Math.PI;\n        });\n    }\n    // etc\n\nCongratulations! You've written a Less plugin!\n\nIf you were to use this in your stylesheet:\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi();\n    }\n\nYou would get:\n\n    .show-me-pi {\n      value: 3.141592653589793;\n    }\n\nHowever, you would need to return a proper Less node if you wanted to, say, multiply that against other values or do other Less operations. Otherwise the output in your stylesheet is plain text (which may be fine for your purposes).\n\nMeaning, this is more correct:\n\n    functions.add('pi', function() {\n        return new tree.Dimension(Math.PI);\n    });\n\n*Note: A dimension is a number with or without a unit, like \"10px\", which would be `less.Dimension(10, \"px\")`. For a list of units, see the [Less API](todo).*\n\nNow you can use your function in operations.\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi() * 2;\n    }\n\nYou may have noticed that there are available globals for your plugin file, namely a function registry (`functions` object), and the `less` object. These are there for convenience.\n\n### Plugin Scope\n\nFunctions added by a `@plugin` at-rule adheres to Less scoping rules. This is great for Less library authors that want to add functionality without introducing naming conflicts.\n\nFor instance, say you have 2 plugins from two third-party libraries that both have a function named \"foo\".\n\n    // lib1.js\n    // ...\n        functions.add('foo', function() {\n            return \"foo\";\n        });\n    // ...\n\n    // lib2.js\n    // ...\n        functions.add('foo', function() {\n            return \"bar\";\n        });\n    // ...\n\nThat's ok! You can choose which library's function creates which output.\n\n    .el-1 {\n        @plugin \"lib1\";\n        value: foo();\n    }\n    .el-2 {\n        @plugin \"lib2\";\n        value: foo();\n    }\n\nThis will produce:\n\n    .el-1 {\n        value: foo;\n    }\n    .el-2 {\n        value: bar;\n    }\n\nFor plugin authors sharing their plugins, that means you can also effectively make private functions by placing them in a particular scope. As in, this will cause an error:\n\n    .el {\n        @plugin \"lib1\";\n    }\n    @value: foo();\n\nAs of Less 3.0, functions can return any kind of Node type, and can be called at any level.\n\nMeaning, this would throw an error in 2.x, as functions had to be part of the value of a property or variable assignment:\n\n    .block {\n        color: blue;\n        my-function-rules();\n    }\n\nIn 3.x, that's no longer the case, and functions can return At-Rules, Rulesets, any other Less node, strings, and numbers (the latter two are converted to Anonymous nodes).\n\n### Null Functions\n\nThere are times when you may want to call a function, but you don't want anything output (such as storing a value for later use). In that case, you just need to return `false` from the function.\n\n    var collection = [];\n\n    functions.add('store', function(val) {\n        collection.push(val);  // imma store this for later\n        return false;\n    });\n\n    @plugin \"collections\";\n    @var: 32;\n    store(@var);\n\nLater you could do something like:\n\n    functions.add('retrieve', function(val) {\n        return new tree.Value(collection);\n    });\n\n    .get-my-values {\n        @plugin \"collections\";\n        values: retrieve();   \n    }\n\n### The Less.js Plugin Object\n\nA Less.js plugin should export an object that has one or more of these properties.\n\n    {\n        /* Called immediately after the plugin is \n         * first imported, only once. */\n        install: function(less, pluginManager, functions) { },\n\n        /* Called for each instance of your @plugin. */\n        use: function(context) { },\n\n        /* Called for each instance of your @plugin, \n         * when rules are being evaluated.\n         * It's just later in the evaluation lifecycle */\n        eval: function(context) { },\n\n        /* Passes an arbitrary string to your plugin \n         * e.g. @plugin (args) \"file\";\n         * This string is not parsed for you, \n         * so it can contain (almost) anything */\n        setOptions: function(argumentString) { },\n\n        /* Set a minimum Less compatibility string\n         * You can also use an array, as in [3, 0] */\n        minVersion: ['3.0'],\n\n        /* Used for lessc only, to explain \n         * options in a Terminal */\n        printUsage: function() { },\n\n    }\n\nThe PluginManager instance for the `install()` function provides methods for adding visitors, file managers, and post-processors.\n\nHere are some example repos showing the different plugin types.\n\n- post-processor: <https://github.com/less/less-plugin-clean-css>\n- visitor: <https://github.com/less/less-plugin-inline-urls>\n- file-manager: <https://github.com/less/less-plugin-npm-import>\n\n### Pre-Loaded Plugins\n\nWhile a `@plugin` call works well for most scenarios, there are times when you might want to load a plugin before parsing starts.\n\nSee: [Pre-Loaded Plugins](usage#plugins) in the \"Using Less.js\" section for how to do that.\n\n## Maps (NEW!)\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nUse rulesets and mixins as maps of values\n\nBy combining namespacing with the lookup `[]` syntax, you can turn your rulesets / mixins into maps.\n\n    @sizes: {\n      mobile: 320px;\n      tablet: 768px;\n      desktop: 1024px;\n    }\n\n    .navbar {\n      display: block;\n\n      @media (min-width: @sizes[tablet]) {\n        display: inline-block;\n      }\n    }\n\nOutputs:\n\n    .navbar {\n      display: block;\n    }\n    @media (min-width: 768px) {\n      .navbar {\n        display: inline-block;\n      }\n    }\n\nMixins are a little more versatile as maps because of namespacing and the ability to overload mixins.\n\n    #library() {\n      .colors() {\n        primary: green;\n        secondary: blue;\n      }\n    }\n\n    #library() {\n      .colors() { primary: grey; }\n    }\n\n    .button {\n      color: #library.colors[primary];\n      border-color: #library.colors[secondary];\n    }\n\nOutputs:\n\n    .button {\n      color: grey;\n      border-color: blue;\n    }\n\nYou can also make this easier by [aliasing mixins](#mixins-feature-mixin-aliasing-feature). That is:\n\n    .button {\n      @colors: #library.colors();\n      color: @colors[primary];\n      border-color: @colors[secondary];\n    }\n\nNote, if a lookup value produces another ruleset, you can append a second `[]` lookup, as in:\n\n    @config: {\n      @options: {\n        library-on: true\n      }\n    }\n\n    & when (@config[@options][library-on] = true) {\n      .produce-ruleset {\n        prop: val;\n      }\n    }\n\nIn this way, rulesets and variable calls can emulate a type of \"namespacing\", similar to mixins.\n\nAs far as whether to use mixins or rulesets assigned to variables as maps, it's up to you. You may want to replace entire maps by re-declaring a variable assigned to a rulset. Or you may want to \"merge\" individual key/value pairs, in which case mixins as maps might be more appropriate.\n\n### Using variable variables in lookups\n\nOne important thing to notice is that the value in `[@lookup]` is the key (variable) name `@lookup`, and is not evaluated as a variable. If you want the key name itself to be variable, you can use the `@@variable` syntax.\n\nE.g.\n\n    .foods() {\n      @dessert: ice cream;\n    }\n\n    @key-to-lookup: dessert;\n\n    .lunch {\n      treat: .foods[@@key-to-lookup];\n    }\n\nThis would output:\n\n    .lunch {\n      treat: ice cream;\n    }\n\n© 2009–2020 The Core Less Team  \nLicensed under the Creative Commons Attribution License 3.0.  \n[http://lesscss.org/features](http://lesscss.org/features)"
- name: '@{} interpolation'
  id: index#variables-feature-variable-interpolation
  summary: The examples above focused on using variables to control values in CSS rules, but they can also be used in other places as well, such as selector names, property names, URLs and @import statements
  description: |-
    ### Variable Interpolation

    The examples above focused on using variables to control *values in CSS rules*, but they can also be used in other places as well, such as selector names, property names, URLs and `@import` statements.

    ### Selectors

    *v1.4.0*

        // Variables
        @my-selector: banner;

        // Usage
        .@{my-selector} {
          font-weight: bold;
          line-height: 40px;
          margin: 0 auto;
        }

    Compiles to:

        .banner {
          font-weight: bold;
          line-height: 40px;
          margin: 0 auto;
        }
- name: abs
  id: functions#math-functions-abs
  summary: Calculates absolute value of a number
  belongs_to: Logical Functions
  description: |-
    ### abs

    Calculates absolute value of a number. Keeps units as they are.

    Parameters: `number` - a floating point number.

    Returns: `number`

    Example \#1: `abs(25cm)`

    Output: `25cm`

    Example \#2: `abs(-18.6%)`

    Output: `18.6%;`
- name: acos
  id: functions#math-functions-acos
  summary: Calculates arccosine (inverse of cosine) function
  belongs_to: Logical Functions
  description: |-
    ### acos

    Calculates arccosine (inverse of cosine) function.

    Returns number in radians e.g. a number between 0 and π.

    Parameters: `number` - a floating point number from \[-1, 1\] interval.

    Returns: `number`

    Example:

        acos(0.5403023058681398)
        acos(1)
        acos(2)

    Output:

        1rad
        0rad
        NaNrad
- name: alpha
  id: functions#color-channel-alpha
  summary: Extracts the alpha channel of a color object
  belongs_to: Logical Functions
  description: |-
    ### alpha

    Extracts the alpha channel of a color object.

    Parameters: `color` - a color object.

    Returns: `float` 0-1

    Example: `alpha(rgba(10, 20, 30, 0.5))`

    Output: `0.5`
- name: argb
  id: functions#color-definition-argb
  summary: 'Creates a hex representation of a color in #AARRGGBB format (NOT #RRGGBBAA!)'
  belongs_to: Logical Functions
  description: |-
    ### argb

    Creates a hex representation of a color in `#AARRGGBB` format (**NOT** `#RRGGBBAA`!).

    This format is used in Internet Explorer, and .NET and Android development.

    Parameters: `color`, color object.

    Returns: `string`

    Example: `argb(rgba(90, 23, 148, 0.5));`

    Output: `#805a1794`
- name: asin
  id: functions#math-functions-asin
  summary: Calculates arcsine (inverse of sine) function
  belongs_to: Logical Functions
  description: |-
    ### asin

    Calculates arcsine (inverse of sine) function.

    Returns number in radians e.g. a number between `-π/2` and `π/2`.

    Parameters: `number` - floating point number from `[-1, 1]` interval.

    Returns: `number`

    Example:

        asin(-0.8414709848078965)
        asin(0)
        asin(2)

    Output:

        -1rad
        0rad
        NaNrad
- name: atan
  id: functions#math-functions-atan
  summary: Calculates arctangent (inverse of tangent) function
  belongs_to: Logical Functions
  description: |-
    ### atan

    Calculates arctangent (inverse of tangent) function.

    Returns number in radians e.g. a number between `-π/2` and `π/2`.

    Parameters: `number` - a floating point number.

    Returns: `number`

    Example:

        atan(-1.5574077246549023)
        atan(0)
        round(atan(22), 6) // arctangent of 22 rounded to 6 decimal places

    Output:

        -1rad
        0rad
        1.525373rad;
- name: average
  id: functions#color-blending-average
  summary: Compute the average of two colors on a per-channel (RGB) basis
  belongs_to: Logical Functions
  description: |-
    ### average

    Compute the average of two colors on a per-channel (RGB) basis.

    Parameters:

    - `color1`: A color object.
    - `color2`: A color object.

    Returns: `color`

    Example:

        average(#ff6600, #000000);

        average(#ff6600, #333333);

        average(#ff6600, #666666);

        average(#ff6600, #999999);

        average(#ff6600, #cccccc);

        average(#ff6600, #ffffff);

        average(#ff6600, #ff0000);

        average(#ff6600, #00ff00);

        average(#ff6600, #0000ff);
- name: blue
  id: functions#color-channel-blue
  summary: Extracts the blue channel of a color object
  belongs_to: Logical Functions
  description: |-
    ### blue

    Extracts the blue channel of a color object.

    Parameters: `color` - a color object.

    Returns: `float` 0-255

    Example: `blue(rgb(10, 20, 30))`

    Output: `30`
- name: boolean
  id: functions#logical-functions-boolean
  summary: You can "store" a boolean test for later evaluation in a guard or if()
  belongs_to: Logical Functions
  description: "### boolean\n\nEvaluates to true or false\n\nYou can \"store\" a boolean test for later evaluation in a guard or `if()`.\n\nParameters:\n\n- `condition`: A boolean expression\n\nReleased: v3.0.0 Updated: v3.6.0\n\n**Examples**:\n\n    @bg: black;\n    @bg-light: boolean(luma(@bg) > 50%);\n\n    div {\n      background: @bg; \n      color: if(@bg-light, black, white);\n    }\n\nResult:\n\n    div {\n      background: black;\n      color: white;\n    }\n\n## String Functions"
- name: ceil
  id: functions#math-functions-ceil
  summary: Rounds up to the next highest integer
  belongs_to: Logical Functions
  description: |-
    ### ceil

    Rounds up to the next highest integer.

    Parameters: `number` - a floating point number.

    Returns: `integer`

    Example: `ceil(2.4)`

    Output: `3`
- name: color
  id: functions#misc-functions-color
  summary: Parses a color, so a string representing a color becomes a color
  belongs_to: Logical Functions
  description: |-
    ### color

    Parses a color, so a string representing a color becomes a color.

    Parameters: `string`: a string of the specified color.

    Returns: `color`

    Example: `color("#aaa");`

    Output: `#aaa`
- name: contrast
  id: functions#color-operations-contrast
  summary: Choose which of two colors provides the greatest contrast with another
  belongs_to: Logical Functions
  description: |-
    ### contrast

    Choose which of two colors provides the greatest contrast with another.

    This is useful for ensuring that a color is readable against a background, which is also useful for accessibility compliance. This function works the same way as the [contrast function in Compass for SASS](http://compass-style.org/reference/compass/utilities/color/contrast/). In accordance with [WCAG 2.0](http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef), colors are compared using their gamma-corrected [luma](#color-channel-luma) value, not their lightness.

    The light and dark parameters can be supplied in either order - the function will calculate their luma values and assign light and dark automatically, which means you can't use this function to select the *least* contrasting color by reversing the order.

    Parameters:

    - `color`: A color object to compare against.
    - `dark`: optional - A designated dark color (defaults to black).
    - `light`: optional - A designated light color (defaults to white).
    - `threshold`: optional - A percentage 0-100% specifying where the transition from "dark" to "light" is (defaults to 43%, matching SASS). This is used to bias the contrast one way or another, for example to allow you to decide whether a 50% grey background should result in black or white text. You would generally set this lower for 'lighter' palettes, higher for 'darker' ones.

    Returns: `color`

    Example:

        p {
            a: contrast(#bbbbbb);
            b: contrast(#222222, #101010);
            c: contrast(#222222, #101010, #dddddd);
            d: contrast(hsl(90, 100%, 50%), #000000, #ffffff, 30%);
            e: contrast(hsl(90, 100%, 50%), #000000, #ffffff, 80%);
        }

    Output:

        p {
            a: #000000 // black
            b: #ffffff // white
            c: #dddddd
            d: #000000 // black
            e: #ffffff // white
        }

    These examples use the above calculated colors for background and foreground; you can see that you never end up with white-on-white, nor black-on-black, though it's possible to use the threshold to permit lower-contrast outcomes, as in the last example:

    ## Color Blending Functions

    These operations are *similar* (though not necessarily identical) to the blend modes found in image editors like Photoshop, Fireworks, or GIMP, so you can use them to make your CSS colors match your images.
- name: convert
  id: functions#misc-functions-convert
  summary: Convert a number from one unit into another
  belongs_to: Logical Functions
  description: |-
    ### convert

    Convert a number from one unit into another.

    The first argument contains a number with units and second argument contains units. If the units are compatible, the number is converted. If they are not compatible, the first argument is returned unmodified.

    See [unit](#misc-functions-unit) for changing the unit without conversion.

    *Compatible unit groups*:

    - lengths: `m`, `cm`, `mm`, `in`, `pt` and `pc`,
    - time: `s` and `ms`,
    - angle: `rad`, `deg`, `grad` and `turn`.

    Parameters:

    - `number`: a floating point number with units.
    - `identifier`, `string` or `escaped value`: units

    Returns: `number`

    Example:

        convert(9s, "ms")
        convert(14cm, mm)
        convert(8, mm) // incompatible unit types

    Output:

        9000ms
        140mm
        8
- name: cos
  id: functions#math-functions-cos
  summary: Calculates cosine function
  belongs_to: Logical Functions
  description: |-
    ### cos

    Calculates cosine function.

    Assumes radians on numbers without units.

    Parameters: `number` - a floating point number.

    Returns: `number`

    Example:

        cos(1) // cosine of 1 radian
        cos(1deg) // cosine of 1 degree
        cos(1grad) // cosine of 1 gradian

    Output:

        0.5403023058681398 // cosine of 1 radian
        0.9998476951563913 // cosine of 1 degree
        0.9998766324816606 // cosine of 1 gradian
- name: Creating a for loop using range and each
  id: functions#list-functions-creating-a-for-loop-using-range-and-each
  summary: You can emulate a for loop simply by generating a numerical list and using each to expand it to a ruleset
  belongs_to: Logical Functions
  description: |-
    ### Creating a `for` loop using `range` and `each`

    *Requires Less v3.9.0*

    You can emulate a `for` loop simply by generating a numerical list and using `each` to expand it to a ruleset.

    Example:

        each(range(4), {
          .col-@{value} {
            height: (@value * 50px);
          }
        });

    Outputs:

        .col-1 {
          height: 50px;
        }
        .col-2 {
          height: 100px;
        }
        .col-3 {
          height: 150px;
        }
        .col-4 {
          height: 200px;
        }

    ## Math Functions
- name: CSS Guards
  id: index#css-guards-feature
  summary: Like Mixin Guards, guards can also be applied to css selectors, which is syntactic sugar for declaring the mixin and then calling it immediately
  description: |-
    ## CSS Guards

    "if"'s around selectors

    Released [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)

    Like Mixin Guards, guards can also be applied to css selectors, which is syntactic sugar for declaring the mixin and then calling it immediately.

    For instance, before 1.5.0 you would have had to do this:

        .my-optional-style() when (@my-option = true) {
          button {
            color: white;
          }
        }
        .my-optional-style();

    Now, you can apply the guard directly to a style.

        button when (@my-option = true) {
          color: white;
        }

    You can also achieve an `if` type statement by combining this with the `&` feature, allowing you to group multiple guards.

        & when (@my-option = true) {
          button {
            color: white;
          }
          a {
            color: blue;
          }
        }

    Note that you can also achieve a similar pattern by using the actual `if()` function and a variable call. As in:

        @dr: if(@my-option = true, {
          button {
            color: white;
          }
          a {
            color: blue;
          }
        });
        @dr();
- name: darken
  id: functions#color-operations-darken
  summary: Decrease the lightness of a color in the HSL color space by an absolute amount
  belongs_to: Logical Functions
  description: |-
    ### darken

    Decrease the lightness of a color in the HSL color space by an absolute amount.

    Parameters:

    - `color`: A color object.
    - `amount`: A percentage 0-100%.
    - `method`: Optional, set to `relative` for the adjustment to be relative to the current value.

    Returns: `color`

    Example: `darken(hsl(90, 80%, 50%), 20%)`

    Output: `#4d8a0f // hsl(90, 80%, 30%)`

    ➜
- name: data-uri
  id: functions#misc-functions-data-uri
  summary: Inlines a resource and falls back to url() if the ieCompat option is on and the resource is too large, or if you use the function in the browser
  belongs_to: Logical Functions
  description: |-
    ### data-uri

    Inlines a resource and falls back to `url()` if the ieCompat option is on and the resource is too large, or if you use the function in the browser. If the MIME type is not given then node uses the mime package to determine the correct mime type.

    Parameters:

    - `mimetype`: (Optional) A MIME type string.
    - `url`: The URL of the file to inline.

    If there is no mimetype, data-uri function guesses it from filename suffix. Text and svg files are encoded as utf-8 and anything else is encoded as base64.

    If user provided mimetype, the function uses base64 if mimetype argument ends with ;base64. For example, `image/jpeg;base64` is encoded into base64 while `text/html` is encoded into utf-8.

    Example: `data-uri('../data/image.jpg');`

    Output: `url('data:image/jpeg;base64,bm90IGFjdHVhbGx5IGEganBlZyBmaWxlCg==');`

    Output in browser: `url('../data/image.jpg');`

    Example: `data-uri('image/jpeg;base64', '../data/image.jpg');`

    Output: `url('data:image/jpeg;base64,bm90IGFjdHVhbGx5IGEganBlZyBmaWxlCg==');`

    Example: `data-uri('image/svg+xml;charset=UTF-8', 'image.svg');`

    Output: `url("data:image/svg+xml;charset=UTF-8,%3Csvg%3E%3Ccircle%20r%3D%229%22%2F%3E%3C%2Fsvg%3E");`
- name: default
  id: functions#misc-functions-default
  summary: Available only inside guard conditions and returns true only if no other mixin matches, false otherwise
  belongs_to: Logical Functions
  description: |-
    ### default

    Available only inside guard conditions and returns `true` only if no other mixin matches, `false` otherwise.

    Example:

        .mixin(1)                   {x: 11}
        .mixin(2)                   {y: 22}
        .mixin(@x) when (default()) {z: @x}

        div {
          .mixin(3);
        }

        div.special {
          .mixin(1);
        }

    Output:

        div {
          z: 3;
        }
        div.special {
          x: 11;
        }

    It is possible to use the value returned by `default` with guard operators. For example `.mixin() when not(default()) {}` will match only if there's at least one more mixin definition that matches`.mixin()` call:

        .mixin(@value) when (ispixel(@value)) {width: @value}
        .mixin(@value) when not(default())    {padding: (@value / 5)}

        div-1 {
          .mixin(100px);
        }

        div-2 {
          /* ... */
          .mixin(100%);
        }

    result:

        div-1 {
          width: 100px;
          padding: 20px;
        }
        div-2 {
          /* ... */
        }

    It is allowed to make multiple `default()` calls in the same guard condition or in a different conditions of a mixins with the same name:

        div {
          .m(@x) when (default()), not(default())    {always: @x}
          .m(@x) when (default()) and not(default()) {never:  @x}

          .m(1); // OK
        }

    However Less will throw a error if it detects a *potential* conflict between multiple mixin definitions using `default()`:

        div {
          .m(@x) when (default())    {}
          .m(@x) when not(default()) {}

          .m(1); // Error
        }

    In above example it is impossible to determine what value each `default()` call should return since they recursively depend on each other.

    Advanced multiple `default()` usage:

        .x {
          .m(red)                                    {case-1: darkred}
          .m(blue)                                   {case-2: darkblue}
          .m(@x) when (iscolor(@x)) and (default())  {default-color: @x}
          .m('foo')                                  {case-1: I am 'foo'}
          .m('bar')                                  {case-2: I am 'bar'}
          .m(@x) when (isstring(@x)) and (default()) {default-string: and I am the default}

          &-blue  {.m(blue)}
          &-green {.m(green)}
          &-foo   {.m('foo')}
          &-baz   {.m('baz')}
        }

    Result:

        .x-blue {
          case-2: #00008b;
        }
        .x-green {
          default-color: #008000;
        }
        .x-foo {
          case-1: I am 'foo';
        }
        .x-baz {
          default-string: and I am the default;
        }

    The `default` function is available as a Less built-in function *only inside guard expressions*. If used outside of a mixin guard condition it is interpreted as a regular CSS value:

    Example:

        div {
          foo: default();
          bar: default(42);
        }

    Result:

        div {
          foo: default();
          bar: default(42);
        }
- name: desaturate
  id: functions#color-operations-desaturate
  summary: Decrease the saturation of a color in the HSL color space by an absolute amount
  belongs_to: Logical Functions
  description: |-
    ### desaturate

    Decrease the saturation of a color in the HSL color space by an absolute amount.

    Parameters:

    - `color`: A color object.
    - `amount`: A percentage 0-100%.
    - `method`: Optional, set to `relative` for the adjustment to be relative to the current value.

    Returns: `color`

    Example: `desaturate(hsl(90, 80%, 50%), 20%)`

    Output: `#80cc33 // hsl(90, 60%, 50%)`

    ➜
- name: Detached Rulesets
  id: index#detached-rulesets-feature
  summary: A detached ruleset is a group of css properties, nested rulesets, media declarations or anything else stored in a variable
  description: "## Detached Rulesets\n\nAssign a ruleset to a variable\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nA detached ruleset is a group of css properties, nested rulesets, media declarations or anything else stored in a variable. You can include it into a ruleset or another structure and all its properties are going to be copied there. You can also use it as a mixin argument and pass it around as any other variable.\n\nSimple example:\n\n    // declare detached ruleset\n    @detached-ruleset: { background: red; }; // semi-colon is optional in 3.5.0+\n\n    // use detached ruleset\n    .top {\n        @detached-ruleset(); \n    }\n\ncompiles into:\n\n    .top {\n      background: red;\n    }\n\nParentheses after a detached ruleset call are mandatory (except when followed by a [lookup value](#detached-rulesets-feature-property-variable-accessors)). The call `@detached-ruleset;` would not work.\n\nIt is useful when you want to define a mixin that abstracts out either wrapping a piece of code in a media query or a non-supported browser class name. The rulesets can be passed to mixin so that the mixin can wrap the content, e.g.\n\n    .desktop-and-old-ie(@rules) {\n      @media screen and (min-width: 1200px) { @rules(); }\n      html.lt-ie9 &                         { @rules(); }\n    }\n\n    header {\n      background-color: blue;\n\n      .desktop-and-old-ie({\n        background-color: red;\n      });\n    }\n\nHere the `desktop-and-old-ie` mixin defines the media query and root class so that you can use a mixin to wrap a piece of code. This will output\n\n    header {\n      background-color: blue;\n    }\n    @media screen and (min-width: 1200px) {\n      header {\n        background-color: red;\n      }\n    }\n    html.lt-ie9 header {\n      background-color: red;\n    }\n\nA ruleset can be now assigned to a variable or passed in to a mixin and can contain the full set of Less features, e.g.\n\n    @my-ruleset: {\n        .my-selector {\n          background-color: black;\n        }\n      };\n\nYou can even take advantage of [media query bubbling](#features-overview-feature-media-query-bubbling-and-nested-media-queries), for instance\n\n    @my-ruleset: {\n        .my-selector {\n          @media tv {\n            background-color: black;\n          }\n        }\n      };\n    @media (orientation:portrait) {\n        @my-ruleset();\n    }\n\nwhich will output\n\n    @media (orientation: portrait) and tv {\n      .my-selector {\n        background-color: black;\n      }\n    }\n\nA detached ruleset call unlocks (returns) all its mixins into caller the same way as mixin calls do. However, it does **not** return variables.\n\nReturned mixin:\n\n    // detached ruleset with a mixin\n    @detached-ruleset: { \n        .mixin() {\n            color: blue;\n        }\n    };\n    // call detached ruleset\n    .caller {\n        @detached-ruleset(); \n        .mixin();\n    }\n\nResults in:\n\n    .caller {\n      color: blue;\n    }\n\nPrivate variables:\n\n    @detached-ruleset: { \n        @color:blue; // this variable is private\n    };\n    .caller {\n        color: @color; // syntax error\n    }\n\n### Scoping\n\nA detached ruleset can use all variables and mixins accessible where it is *defined* and where it is *called*. Otherwise said, both definition and caller scopes are available to it. If both scopes contains the same variable or mixin, declaration scope value takes precedence.\n\n*Declaration scope* is the one where detached ruleset body is defined. Copying a detached ruleset from one variable into another cannot modify its scope. The ruleset does not gain access to new scopes just by being referenced there.\n\nLastly, a detached ruleset can gain access to scope by being unlocked (imported) into it.\n\n*Note: unlocking variables into scope via a called mixin is deprecated. Use [property / variable accessors](#detached-rulesets-feature-property-variable-accessors).*\n\n### Definition and Caller Scope Visibility\n\nA detached ruleset sees the caller's variables and mixins:\n\n    @detached-ruleset: {\n      caller-variable: @caller-variable; // variable is undefined here\n      .caller-mixin(); // mixin is undefined here\n    };\n\n    selector {\n      // use detached ruleset\n      @detached-ruleset(); \n\n      // define variable and mixin needed inside the detached ruleset\n      @caller-variable: value;\n      .caller-mixin() {\n        variable: declaration;\n      }\n    }\n\ncompiles into:\n\n    selector {\n      caller-variable: value;\n      variable: declaration;\n    }\n\nVariable and mixins accessible from definition win over those available in the caller:\n\n    @variable: global;\n    @detached-ruleset: {\n      // will use global variable, because it is accessible\n      // from detached-ruleset definition\n      variable: @variable; \n    };\n\n    selector {\n      @detached-ruleset();\n      @variable: value; // variable defined in caller - will be ignored\n    }\n\ncompiles into:\n\n    selector {\n      variable: global;\n    }\n\n### Referencing *Won't* Modify Detached Ruleset Scope\n\nA ruleset does not gain access to new scopes just by being referenced there:\n\n    @detached-1: { scope-detached: @one @two; };\n    .one {\n      @one: visible;\n      .two {\n        @detached-2: @detached-1; // copying/renaming ruleset \n        @two: visible; // ruleset can not see this variable\n      }\n    }\n\n    .use-place {\n      .one > .two(); \n      @detached-2();\n    }\n\nthrows an error:\n\n    ERROR 1:32 The variable \"@one\" was not declared.\n\n### Unlocking *Will* Modify Detached Ruleset Scope\n\nA detached ruleset gains access by being unlocked (imported) inside a scope:\n\n    #space {\n      .importer-1() {\n        @detached: { scope-detached: @variable; }; // define detached ruleset\n      }\n    }\n\n    .importer-2() {\n      @variable: value; // unlocked detached ruleset CAN see this variable\n      #space > .importer-1(); // unlock/import detached ruleset\n    }\n\n    .use-place {\n      .importer-2(); // unlock/import detached ruleset second time\n       @detached();\n    }\n\ncompiles into:\n\n    .use-place {\n      scope-detached: value;\n    }\n\n### Property / variable accessors\n\n### (Lookup values)\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors (also called \"lookups\") to select a value from variable (detached) rulesets.\n\n    @config: {\n      option1: true;\n      option2: false;\n    }\n\n    .mixin() when (@config[option1] = true) {\n      selected: value;\n    }\n\n    .box {\n      .mixin();\n    }\n\nOutputs:\n\n    .box {\n      selected: value;\n    }\n\nIf what is returned from a lookup is another detached ruleset, you can use a second lookup to get that value.\n\n    @config: {\n      @colors: {\n        primary: blue;\n      }\n    }\n\n    .box {\n      color: @config[@colors][primary];\n    }\n\n### Variable variables in lookups\n\nThe lookup value that is returned can itself be variable. As in, you can write:\n\n    @config: {\n      @dark: {\n        primary: darkblue;\n      }\n      @light: {\n        primary: lightblue;\n      }\n    }\n\n    .box {\n      @lookup: dark;\n      color: @config[@@lookup][primary];\n    }\n\nThis will output:\n\n    .box {\n      color: darkblue;\n    }"
- name: difference
  id: functions#color-blending-difference
  summary: Subtracts the second color from the first color on a channel-by-channel basis
  belongs_to: Logical Functions
  description: |-
    ### difference

    Subtracts the second color from the first color on a channel-by-channel basis. Negative values are inverted. Subtracting black results in no change; subtracting white results in color inversion.

    Parameters:

    - `color1`: A color object to act as the minuend.
    - `color2`: A color object to act as the subtrahend.

    Returns: `color`

    Example:

        difference(#ff6600, #000000);

        difference(#ff6600, #333333);

        difference(#ff6600, #666666);

        difference(#ff6600, #999999);

        difference(#ff6600, #cccccc);

        difference(#ff6600, #ffffff);

        difference(#ff6600, #ff0000);

        difference(#ff6600, #00ff00);

        difference(#ff6600, #0000ff);
- name: e
  id: functions#string-functions-e
  summary: String escaping
  belongs_to: Logical Functions
  description: "### e\n\nString escaping.\n\nIt expects string as a parameter and return its content as is, but without quotes. It can be used to output CSS value which is either not valid CSS syntax, or uses proprietary syntax which Less doesn't recognize.\n\nParameters: `string` - a string to escape.\n\nReturns: `string` - the escaped string, without quotes.\n\nExample:\n\n    @mscode: \"ms:alwaysHasItsOwnSyntax.For.Stuff()\" \n    filter: e(@mscode);\n\nOutput:\n\n    filter: ms:alwaysHasItsOwnSyntax.For.Stuff();"
- name: each
  id: functions#list-functions-each
  summary: Bind the evaluation of a ruleset to each member of a list
  belongs_to: Logical Functions
  description: |-
    ### each

    *Released v3.7.0*

    Bind the evaluation of a ruleset to each member of a list.

    **Parameters**

    - `list` - a comma or space separated list of values.
    - `rules` - An anonymous ruleset/mixin

    Example:

        @selectors: blue, green, red;

        each(@selectors, {
          .sel-@{value} {
            a: b;
          }
        });

    Outputs:

        .sel-blue {
          a: b;
        }
        .sel-green {
          a: b;
        }
        .sel-red {
          a: b;
        }

    By default, each ruleset is bound, per list member, to a `@value`, `@key`, and `@index` variable. For most lists, `@key` and `@index` will be assigned the same value (numerical position, 1-based). However, you can also use rulesets *themselves* as structured lists. As in:

        @set: {
          one: blue;
          two: green;
          three: red;
        }
        .set {
          each(@set, {
            @{key}-@{index}: @value;
          });
        }

    This will output:

        .set {
          one-1: blue;
          two-2: green;
          three-3: red;
        }

    Since you can, of course, call mixins with guards for each ruleset call, this makes `each()` a very powerful function.
- name: escape
  id: functions#string-functions-escape
  summary: Applies URL-encoding to special characters found in the input string
  belongs_to: Logical Functions
  description: |-
    ### escape

    Applies [URL-encoding](http://en.wikipedia.org/wiki/Percent-encoding) to special characters found in the input string.

    - These characters are not encoded: `,`, `/`, `?`, `@`, `&`, `+`, `'`, `~`, `!` and `$`.
    - Most common encoded characters are: `\<space\>`, `#`, `^`, `(`, `)`, `{`, `}`, `|`, `:`, `>`, `<`, `;`, `]`, `[` and `=`.

    Parameters: `string`: a string to escape.

    Returns: escaped `string` content without quotes.

    Example:

        escape('a=1')

    Output:

        a%3D1

    Note: if the parameter is not a string, output is not defined. The current implementation returns `undefined` on color and unchanged input on any other kind of argument. This behavior should not be relied on and may change in the future.
- name: exclusion
  id: functions#color-blending-exclusion
  summary: A similar effect to difference with lower contrast
  belongs_to: Logical Functions
  description: |-
    ### exclusion

    A similar effect to `difference` with lower contrast.

    Parameters:

    - `color1`: A color object to act as the minuend.
    - `color2`: A color object to act as the subtrahend.

    Returns: `color`

    Example:

        exclusion(#ff6600, #000000);

        exclusion(#ff6600, #333333);

        exclusion(#ff6600, #666666);

        exclusion(#ff6600, #999999);

        exclusion(#ff6600, #cccccc);

        exclusion(#ff6600, #ffffff);

        exclusion(#ff6600, #ff0000);

        exclusion(#ff6600, #00ff00);

        exclusion(#ff6600, #0000ff);
- name: extract
  id: functions#list-functions-extract
  summary: Returns the value at a specified position in a list
  belongs_to: Logical Functions
  description: |-
    ### extract

    Returns the value at a specified position in a list.

    **Parameters**

    - `list` - a comma or space separated list of values.
    - `index` - an integer that specifies a position of a list element to return.

    Example: `extract(8px dotted red, 2);`

    Output: `dotted`

    Example:

        @list: apple, pear, coconut, orange;
        value: extract(@list, 3);

    Output:

        value: coconut;
- name: fade
  id: functions#color-operations-fade
  summary: Set the absolute opacity of a color
  belongs_to: Logical Functions
  description: |-
    ### fade

    Set the absolute opacity of a color. Can be applied to colors whether they already have an opacity value or not.

    Parameters:

    - `color`: A color object.
    - `amount`: A percentage 0-100%.

    Returns: `color`

    Example: `fade(hsl(90, 90%, 50%), 10%)`

    Output: `rgba(128, 242, 13, 0.1) //hsla(90, 90%, 50%, 0.1)`
- name: fadein
  id: functions#color-operations-fadein
  summary: Decrease the transparency (or increase the opacity) of a color, making it more opaque
  belongs_to: Logical Functions
  description: |-
    ### fadein

    Decrease the transparency (or increase the opacity) of a color, making it more opaque.

    Has no effect on opaque colors. To fade in the other direction use `fadeout`.

    Parameters:

    - `color`: A color object.
    - `amount`: A percentage 0-100%.
    - `method`: Optional, set to `relative` for the adjustment to be relative to the current value.

    Returns: `color`

    Example: `fadein(hsla(90, 90%, 50%, 0.5), 10%)`

    Output: `rgba(128, 242, 13, 0.6) // hsla(90, 90%, 50%, 0.6)`
- name: fadeout
  id: functions#color-operations-fadeout
  summary: Increase the transparency (or decrease the opacity) of a color, making it less opaque
  belongs_to: Logical Functions
  description: |-
    ### fadeout

    Increase the transparency (or decrease the opacity) of a color, making it less opaque. To fade in the other direction use `fadein`.

    Parameters:

    - `color`: A color object.
    - `amount`: A percentage 0-100%.
    - `method`: Optional, set to `relative` for the adjustment to be relative to the current value.

    Returns: `color`

    Example: `fadeout(hsla(90, 90%, 50%, 0.5), 10%)`

    Output: `rgba(128, 242, 13, 0.4) // hsla(90, 90%, 50%, 0.4)`
- name: floor
  id: functions#math-functions-floor
  summary: Rounds down to the next lowest integer
  belongs_to: Logical Functions
  description: |-
    ### floor

    Rounds down to the next lowest integer.

    Parameters: `number` - a floating point number.

    Returns: `integer`

    Example: `floor(2.6)`

    Output: `2`
- name: get-unit
  id: functions#misc-functions-get-unit
  summary: Returns units of a number
  belongs_to: Logical Functions
  description: |-
    ### get-unit

    Returns units of a number.

    If the argument contains a number with units, the function returns its units. The argument without units results in an empty return value.

    Parameters:

    - `number`: a number with or without units.

    Example: `get-unit(5px)`

    Output: `px`

    Example: `get-unit(5)`

    Output: `//nothing`
- name: green
  id: functions#color-channel-green
  summary: Extracts the green channel of a color object
  belongs_to: Logical Functions
  description: |-
    ### green

    Extracts the green channel of a color object.

    Parameters: `color` - a color object.

    Returns: `float` 0-255

    Example: `green(rgb(10, 20, 30))`

    Output: `20`
- name: greyscale
  id: functions#color-operations-greyscale
  summary: Remove all saturation from a color in the HSL color space; the same as calling desaturate(@color, 100%)
  belongs_to: Logical Functions
  description: |-
    ### greyscale

    Remove all saturation from a color in the HSL color space; the same as calling `desaturate(@color, 100%)`.

    Because the saturation is not affected by hue, the resulting color mapping may be somewhat dull or muddy; [`luma`](#color-channel-luma) may provide a better result as it extracts perceptual rather than linear brightness, for example `greyscale('#0000ff')` will return the same value as `greyscale('#00ff00')`, though they appear quite different in brightness to the human eye.

    Parameters: `color`: A color object.

    Returns: `color`

    Example: `greyscale(hsl(90, 90%, 50%))`

    Output: `#808080 // hsl(90, 0%, 50%)`

    ➜

    Notice that the generated grey looks darker than the original green, even though its lightness value is the same.

    Compare with using `luma` (usage is different because `luma` returns a single value, not a color):

        @c: luma(hsl(90, 90%, 50%));
        color: rgb(@c, @c, @c);

    Output: `#cacaca`

    ➜

    This time the grey's lightness looks about the same as the green, though its value is actually higher.
- name: hardlight
  id: functions#color-blending-hardlight
  summary: The same as overlay but with the color roles reversed
  belongs_to: Logical Functions
  description: |-
    ### hardlight

    The same as `overlay` but with the color roles reversed.

    Parameters:

    - `color1`: A color object to *overlay*.
    - `color2`: A base color object. Also the determinant color to make the result lighter or darker.

    Returns: `color`

    Example:

        hardlight(#ff6600, #000000);

        hardlight(#ff6600, #333333);

        hardlight(#ff6600, #666666);

        hardlight(#ff6600, #999999);

        hardlight(#ff6600, #cccccc);

        hardlight(#ff6600, #ffffff);

        hardlight(#ff6600, #ff0000);

        hardlight(#ff6600, #00ff00);

        hardlight(#ff6600, #0000ff);
- name: hsl
  id: functions#color-definition-hsl
  summary: Creates an opaque color object from hue, saturation and lightness (HSL) values
  belongs_to: Logical Functions
  description: |-
    ### hsl

    Creates an opaque color object from hue, saturation and lightness (HSL) values.

    Parameters:

    - `hue`: An integer 0-360 representing degrees.
    - `saturation`: A percentage 0-100% or number 0-1.
    - `lightness`: A percentage 0-100% or number 0-1.

    Returns: `color`

    Example: `hsl(90, 100%, 50%)`

    Output: `#80ff00`

    This is useful if you want to create a new color based on another color's channel, forExample: `@new: hsl(hue(@old), 45%, 90%);`

    `@new` will have `@old`'s *hue*, and its own saturation and lightness.
- name: hsla
  id: functions#color-definition-hsla
  summary: Creates a transparent color object from hue, saturation, lightness and alpha (HSLA) values
  belongs_to: Logical Functions
  description: |-
    ### hsla

    Creates a transparent color object from hue, saturation, lightness and alpha (HSLA) values.

    Parameters:

    - `hue`: An integer 0-360 representing degrees.
    - `saturation`: A percentage 0-100% or number 0-1.
    - `lightness`: A percentage 0-100% or number 0-1.
    - `alpha`: A percentage 0-100% or number 0-1.

    Returns: `color`

    Example: `hsla(90, 100%, 50%, 0.5)`

    Output: `rgba(128, 255, 0, 0.5)`
- name: hsv
  id: functions#color-definition-hsv
  summary: Creates an opaque color object from hue, saturation and value (HSV) values
  belongs_to: Logical Functions
  description: |-
    ### hsv

    Creates an opaque color object from hue, saturation and value (HSV) values.

    Note that this is a color space available in Photoshop, and is not the same as `hsl`.

    Parameters:

    - `hue`: An integer 0-360 representing degrees.
    - `saturation`: A percentage 0-100% or number 0-1.
    - `value`: A percentage 0-100% or number 0-1.

    Returns: `color`

    Example: `hsv(90, 100%, 50%)`

    Output: `#408000`
- name: hsva
  id: functions#color-definition-hsva
  summary: Creates a transparent color object from hue, saturation, value and alpha (HSVA) values
  belongs_to: Logical Functions
  description: |-
    ### hsva

    Creates a transparent color object from hue, saturation, value and alpha (HSVA) values.

    Note that this is not the same as `hsla`, and is a color space available in Photoshop.

    Parameters:

    - `hue`: An integer 0-360 representing degrees.
    - `saturation`: A percentage 0-100% or number 0-1.
    - `value`: A percentage 0-100% or number 0-1.
    - `alpha`: A percentage 0-100% or number 0-1.

    Returns: `color`

    Example: `hsva(90, 100%, 50%, 0.5)`

    Output: `rgba(64, 128, 0, 0.5)`

    ## Color Channel Functions
- name: hsvhue
  id: functions#color-channel-hsvhue
  summary: Extracts the hue channel of a color object in the HSV color space
  belongs_to: Logical Functions
  description: |-
    ### hsvhue

    Extracts the hue channel of a color object in the HSV color space.

    Parameters: `color` - a color object.

    Returns: `integer` `0-360`

    Example: `hsvhue(hsv(90, 100%, 50%))`

    Output: `90`
- name: hsvsaturation
  id: functions#color-channel-hsvsaturation
  summary: Extracts the saturation channel of a color object in the HSV color space
  belongs_to: Logical Functions
  description: |-
    ### hsvsaturation

    Extracts the saturation channel of a color object in the HSV color space.

    Parameters: `color` - a color object.

    Returns: `percentage` 0-100

    Example: `hsvsaturation(hsv(90, 100%, 50%))`

    Output: `100%`
- name: hsvvalue
  id: functions#color-channel-hsvvalue
  summary: Extracts the value channel of a color object in the HSV color space
  belongs_to: Logical Functions
  description: |-
    ### hsvvalue

    Extracts the value channel of a color object in the HSV color space.

    Parameters: `color` - a color object.

    Returns: `percentage` 0-100

    Example: `hsvvalue(hsv(90, 100%, 50%))`

    Output: `50%`
- name: hue
  id: functions#color-channel-hue
  summary: Extracts the hue channel of a color object in the HSL color space
  belongs_to: Logical Functions
  description: |-
    ### hue

    Extracts the hue channel of a color object in the HSL color space.

    Parameters: `color` - a color object.

    Returns: `integer` 0-360

    Example: `hue(hsl(90, 100%, 50%))`

    Output: `90`
- name: if
  id: functions#logical-functions-if
  summary: Returns one of two values depending on a condition
  belongs_to: Logical Functions
  description: |-
    ### if

    Returns one of two values depending on a condition.

    Parameters:

    - `condition`: A boolean expression
    - `value1`: A value returned if `condition` is true.
    - `value2`: A value returned if `condition` is not true.

    Released: v3.0.0 Updated: v3.6.0

    **Examples**:

        @some: foo;

        div {
            margin: if((2 > 1), 0, 3px);
            color:  if((iscolor(@some)), @some, black);
        }

    Result:

        div {
            margin: 0;
            color:  black;
        }

    Notes: A boolean expression supported as the `conditional` parameter are the same as of [Guard Statements](features#mixins-feature-mixin-guards-feature).

        if(not (true), foo, bar);
        if((true) and (2 > 1), foo, bar);
        if((false) or (isstring("boo!")), foo, bar);

    Note: before Less 3.6, the condition required a set of parentheses.

        if(2 > 1, blue, green);   // Causes an error in 3.0-3.5.3
        if((2 > 1), blue, green); // Ok 3.6+
- name: image-height
  id: functions#misc-functions-image-height
  summary: Gets the image height from a file
  belongs_to: Logical Functions
  description: |-
    ### image-height

    Gets the image height from a file.

    Parameters: `string`: the file to get the dimensions for.

    Returns: `dimension`

    Example: `image-height("file.png");`

    Output: `10px`

    Note: this function needs to be implemented by each environment. It is currently only available in the node environment.

    Added in: v2.2.0
- name: image-size
  id: functions#misc-functions-image-size
  summary: Gets the image dimensions from a file
  belongs_to: Logical Functions
  description: |-
    ### image-size

    Gets the image dimensions from a file.

    Parameters: `string`: the file to get the dimensions for.

    Returns: `dimension`

    Example: `image-size("file.png");`

    Output: `10px 10px`

    Note: this function needs to be implemented by each environment. It is currently only available in the node environment.

    Added in: v2.2.0
- name: image-width
  id: functions#misc-functions-image-width
  summary: Gets the image width from a file
  belongs_to: Logical Functions
  description: |-
    ### image-width

    Gets the image width from a file.

    Parameters: `string`: the file to get the dimensions for.

    Returns: `dimension`

    Example: `image-width("file.png");`

    Output: `10px`

    Note: this function needs to be implemented by each environment. It is currently only available in the node environment.

    Added in: v2.2.0
- name: iscolor
  id: functions#type-functions-iscolor
  summary: Returns true if a value is a color, false otherwise
  belongs_to: Logical Functions
  description: |-
    ### iscolor

    Returns `true` if a value is a color, `false` otherwise.

    Parameters: `value` - a value or variable being evaluated.

    Returns: `true` if value is a color, `false` otherwise.

    Example:

        iscolor(#ff0);     // true
        iscolor(blue);     // true
        iscolor("string"); // false
        iscolor(1234);     // false
        iscolor(56px);     // false
        iscolor(7.8%);     // false
        iscolor(keyword);  // false
        iscolor(url(...)); // false
- name: isdefined
  id: functions#type-functions-isdefined
  summary: Returns true if a variable is defined, false otherwise
  belongs_to: Logical Functions
  description: |-
    ### isdefined

    *Released [v4.0.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*

    Returns `true` if a variable is defined, `false` otherwise.

    Parameters: `variable` - a variable being evaluated.

    Example:

        @foo: 1;
        isdefined(@foo);     // true
        isdefined(@bar);     // false

    ## Misc Functions
- name: isem
  id: functions#type-functions-isem
  summary: Returns true if a value is an em value, false otherwise
  belongs_to: Logical Functions
  description: |-
    ### isem

    Returns `true` if a value is an em value, `false` otherwise.

    Parameters: `value` - a value or variable being evaluated.

    Returns: `true` if value is an em value, `false` otherwise.

    Example:

        isem(#ff0);     // false
        isem(blue);     // false
        isem("string"); // false
        isem(1234);     // false
        isem(56px);     // false
        isem(7.8em);    // true
        isem(keyword);  // false
        isem(url(...)); // false
- name: iskeyword
  id: functions#type-functions-iskeyword
  summary: Returns true if a value is a keyword, false otherwise
  belongs_to: Logical Functions
  description: |-
    ### iskeyword

    Returns `true` if a value is a keyword, `false` otherwise.

    Parameters: `value` - a value or variable being evaluated.

    Returns: `true` if value is a keyword, `false` otherwise.

    Example:

        iskeyword(#ff0);     // false
        iskeyword(blue);     // false
        iskeyword("string"); // false
        iskeyword(1234);     // false
        iskeyword(56px);     // false
        iskeyword(7.8%);     // false
        iskeyword(keyword);  // true
        iskeyword(url(...)); // false
- name: isnumber
  id: functions#type-functions-isnumber
  summary: Returns true if a value is a number, false otherwise
  belongs_to: Logical Functions
  description: |-
    ### isnumber

    Returns `true` if a value is a number, `false` otherwise.

    Parameters: `value` - a value or variable being evaluated.

    Returns: `true` if value is a number, `false` otherwise.

    Example:

        isnumber(#ff0);     // false
        isnumber(blue);     // false
        isnumber("string"); // false
        isnumber(1234);     // true
        isnumber(56px);     // true
        isnumber(7.8%);     // true
        isnumber(keyword);  // false
        isnumber(url(...)); // false
- name: ispercentage
  id: functions#type-functions-ispercentage
  summary: Returns true if a value is a percentage value, false otherwise
  belongs_to: Logical Functions
  description: |-
    ### ispercentage

    Returns `true` if a value is a percentage value, `false` otherwise.

    Parameters: `value` - a value or variable being evaluated.

    Returns: `true` if value is a percentage value, `false` otherwise.

    Example:

        ispercentage(#ff0);     // false
        ispercentage(blue);     // false
        ispercentage("string"); // false
        ispercentage(1234);     // false
        ispercentage(56px);     // false
        ispercentage(7.8%);     // true
        ispercentage(keyword);  // false
        ispercentage(url(...)); // false
- name: ispixel
  id: functions#type-functions-ispixel
  summary: Returns true if a value is a number in pixels, false otherwise
  belongs_to: Logical Functions
  description: |-
    ### ispixel

    Returns `true` if a value is a number in pixels, `false` otherwise.

    Parameters: `value` - a value or variable being evaluated.

    Returns: `true` if value is a pixel, `false` otherwise.

    Example:

        ispixel(#ff0);     // false
        ispixel(blue);     // false
        ispixel("string"); // false
        ispixel(1234);     // false
        ispixel(56px);     // true
        ispixel(7.8%);     // false
        ispixel(keyword);  // false
        ispixel(url(...)); // false
- name: isruleset
  id: functions#type-functions-isruleset
  summary: Returns true if a value is a ruleset, false otherwise
  belongs_to: Logical Functions
  description: |-
    ### isruleset

    Returns `true` if a value is a ruleset, `false` otherwise.

    Parameters:

    - `value` - a variable being evaluated.

    Returns: `true` if value is a ruleset, `false` otherwise.

    Example:

        @rules: {
            color: red;
        }

        isruleset(@rules);   // true
        isruleset(#ff0);     // false
        isruleset(blue);     // false
        isruleset("string"); // false
        isruleset(1234);     // false
        isruleset(56px);     // false
        isruleset(7.8%);     // false
        isruleset(keyword);  // false
        isruleset(url(...)); // false
- name: isstring
  id: functions#type-functions-isstring
  summary: Returns true if a value is a string, false otherwise
  belongs_to: Logical Functions
  description: |-
    ### isstring

    Returns `true` if a value is a string, `false` otherwise.

    Parameters: `value` - a value or variable being evaluated.

    Returns: `true` if value is a string, `false` otherwise.

    Example:

        isstring(#ff0);     // false
        isstring(blue);     // false
        isstring("string"); // true
        isstring(1234);     // false
        isstring(56px);     // false
        isstring(7.8%);     // false
        isstring(keyword);  // false
        isstring(url(...)); // false
- name: isunit
  id: functions#type-functions-isunit
  summary: Returns true if a value is a number in specified units, false otherwise
  belongs_to: Logical Functions
  description: |-
    ### isunit

    Returns `true` if a value is a number in specified units, `false` otherwise.

    Parameters:

    - `value` - a value or variable being evaluated.
    - `unit` - a unit identifier (optionally quoted) to test for.

    Returns: `true` if value is a number in specified units, `false` otherwise.

    Example:

        isunit(11px, px);  // true
        isunit(2.2%, px);  // false
        isunit(33px, rem); // false
        isunit(4rem, rem); // true
        isunit(56px, "%"); // false
        isunit(7.8%, '%'); // true
        isunit(1234, em);  // false
        isunit(#ff0, pt);  // false
        isunit("mm", mm);  // false
- name: isurl
  id: functions#type-functions-isurl
  summary: Returns true if a value is a url, false otherwise
  belongs_to: Logical Functions
  description: |-
    ### isurl

    Returns `true` if a value is a url, `false` otherwise.

    Parameters: `value` - a value or variable being evaluated.

    Returns: `true` if value is a url, `false` otherwise.

    Example:

        isurl(#ff0);     // false
        isurl(blue);     // false
        isurl("string"); // false
        isurl(1234);     // false
        isurl(56px);     // false
        isurl(7.8%);     // false
        isurl(keyword);  // false
        isurl(url(...)); // true
- name: length
  id: functions#list-functions-length
  summary: Returns the number of elements in a value list
  belongs_to: Logical Functions
  description: |-
    ### length

    Returns the number of elements in a value list.

    **Parameters**

    - `list` - a comma or space separated list of values.

    Example: `length(1px solid #0080ff);`

    Output: `3`

    Example:

        @list: "banana", "tomato", "potato", "peach";
        n: length(@list);

    Output:

        n: 4;
- name: lighten
  id: functions#color-operations-lighten
  summary: Increase the lightness of a color in the HSL color space by an absolute amount
  belongs_to: Logical Functions
  description: |-
    ### lighten

    Increase the lightness of a color in the HSL color space by an absolute amount.

    Parameters:

    - `color`: A color object.
    - `amount`: A percentage 0-100%.
    - `method`: Optional, set to `relative` for the adjustment to be relative to the current value.

    Returns: `color`

    Example: `lighten(hsl(90, 80%, 50%), 20%)`

    Output: `#b3f075 // hsl(90, 80%, 70%)`

    ➜
- name: lightness
  id: functions#color-channel-lightness
  summary: Extracts the lightness channel of a color object in the HSL color space
  belongs_to: Logical Functions
  description: |-
    ### lightness

    Extracts the lightness channel of a color object in the HSL color space.

    Parameters: `color` - a color object.

    Returns: `percentage` 0-100

    Example: `lightness(hsl(90, 100%, 50%))`

    Output: `50%`
- name: Logical Functions
  id: functions
  summary: Returns one of two values depending on a condition
  description: "# Less\n\n## Logical Functions\n\n### if\n\nReturns one of two values depending on a condition.\n\nParameters:\n\n- `condition`: A boolean expression\n- `value1`: A value returned if `condition` is true.\n- `value2`: A value returned if `condition` is not true.\n\nReleased: v3.0.0 Updated: v3.6.0\n\n**Examples**:\n\n    @some: foo;\n\n    div {\n        margin: if((2 > 1), 0, 3px);\n        color:  if((iscolor(@some)), @some, black);\n    }\n\nResult:\n\n    div {\n        margin: 0;\n        color:  black;\n    }\n\nNotes: A boolean expression supported as the `conditional` parameter are the same as of [Guard Statements](features#mixins-feature-mixin-guards-feature).\n\n    if(not (true), foo, bar);\n    if((true) and (2 > 1), foo, bar);\n    if((false) or (isstring(\"boo!\")), foo, bar);\n\nNote: before Less 3.6, the condition required a set of parentheses.\n\n    if(2 > 1, blue, green);   // Causes an error in 3.0-3.5.3\n    if((2 > 1), blue, green); // Ok 3.6+\n\n### boolean\n\nEvaluates to true or false\n\nYou can \"store\" a boolean test for later evaluation in a guard or `if()`.\n\nParameters:\n\n- `condition`: A boolean expression\n\nReleased: v3.0.0 Updated: v3.6.0\n\n**Examples**:\n\n    @bg: black;\n    @bg-light: boolean(luma(@bg) > 50%);\n\n    div {\n      background: @bg; \n      color: if(@bg-light, black, white);\n    }\n\nResult:\n\n    div {\n      background: black;\n      color: white;\n    }\n\n## String Functions\n\n### escape\n\nApplies [URL-encoding](http://en.wikipedia.org/wiki/Percent-encoding) to special characters found in the input string.\n\n- These characters are not encoded: `,`, `/`, `?`, `@`, `&`, `+`, `'`, `~`, `!` and `$`.\n- Most common encoded characters are: `\\<space\\>`, `#`, `^`, `(`, `)`, `{`, `}`, `|`, `:`, `>`, `<`, `;`, `]`, `[` and `=`.\n\nParameters: `string`: a string to escape.\n\nReturns: escaped `string` content without quotes.\n\nExample:\n\n    escape('a=1')\n\nOutput:\n\n    a%3D1\n\nNote: if the parameter is not a string, output is not defined. The current implementation returns `undefined` on color and unchanged input on any other kind of argument. This behavior should not be relied on and may change in the future.\n\n### e\n\nString escaping.\n\nIt expects string as a parameter and return its content as is, but without quotes. It can be used to output CSS value which is either not valid CSS syntax, or uses proprietary syntax which Less doesn't recognize.\n\nParameters: `string` - a string to escape.\n\nReturns: `string` - the escaped string, without quotes.\n\nExample:\n\n    @mscode: \"ms:alwaysHasItsOwnSyntax.For.Stuff()\" \n    filter: e(@mscode);\n\nOutput:\n\n    filter: ms:alwaysHasItsOwnSyntax.For.Stuff();\n\n### % format\n\nThe function `%(string, arguments ...)` formats a string.\n\nThe first argument is string with placeholders. All placeholders start with percentage symbol `%` followed by letter `s`,`S`,`d`,`D`,`a`, or `A`. Remaining arguments contain expressions to replace placeholders. If you need to print the percentage symbol, escape it by another percentage `%%`.\n\nUse uppercase placeholders if you need to escape special characters into their utf-8 escape codes. The function escapes all special characters except `()'~!`. Space is encoded as `%20`. Lowercase placeholders leave special characters as they are.\n\nPlaceholders:\n\n- `d`, `D`, `a`, `A` - can be replaced by any kind of argument (color, number, escaped value, expression, ...). If you use them in combination with string, the whole string will be used - including its quotes. However, the quotes are placed into the string as they are, they are not escaped by \"/\" nor anything similar.\n- `s`, `S` - can be replaced by any expression. If you use it with string, only the string value is used - quotes are omitted.\n\nParameters:\n\n- `string`: format string with placeholders,\n- `anything`\\* : values to replace placeholders.\n\nReturns: formatted `string`.\n\nExample:\n\n    format-a-d: %(\"repetitions: %a file: %d\", 1 + 2, \"directory/file.less\");\n    format-a-d-upper: %('repetitions: %A file: %D', 1 + 2, \"directory/file.less\");\n    format-s: %(\"repetitions: %s file: %s\", 1 + 2, \"directory/file.less\");\n    format-s-upper: %('repetitions: %S file: %S', 1 + 2, \"directory/file.less\");\n\nOutput:\n\n    format-a-d: \"repetitions: 3 file: \"directory/file.less\"\";\n    format-a-d-upper: \"repetitions: 3 file: %22directory%2Ffile.less%22\";\n    format-s: \"repetitions: 3 file: directory/file.less\";\n    format-s-upper: \"repetitions: 3 file: directory%2Ffile.less\";\n\n### replace\n\nReplaces a text within a string.\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nParameters:\n\n- `string`: The string to search and replace in.\n- `pattern`: A string or regular expression pattern to search for.\n- `replacement`: The string to replace the matched pattern with.\n- `flags`: (Optional) regular expression flags.\n\nReturns: a string with the replaced values.\n\nExample:\n\n    replace(\"Hello, Mars?\", \"Mars\\?\", \"Earth!\");\n    replace(\"One + one = 4\", \"one\", \"2\", \"gi\");\n    replace('This is a string.', \"(string)\\.$\", \"new $1.\");\n    replace(~\"bar-1\", '1', '2');\n\nResult:\n\n    \"Hello, Earth!\";\n    \"2 + 2 = 4\";\n    'This is a new string.';\n    bar-2;\n\n## List Functions\n\n### length\n\nReturns the number of elements in a value list.\n\n**Parameters**\n\n- `list` - a comma or space separated list of values.\n\nExample: `length(1px solid #0080ff);`\n\nOutput: `3`\n\nExample:\n\n    @list: \"banana\", \"tomato\", \"potato\", \"peach\";\n    n: length(@list);\n\nOutput:\n\n    n: 4;\n\n### extract\n\nReturns the value at a specified position in a list.\n\n**Parameters**\n\n- `list` - a comma or space separated list of values.\n- `index` - an integer that specifies a position of a list element to return.\n\nExample: `extract(8px dotted red, 2);`\n\nOutput: `dotted`\n\nExample:\n\n    @list: apple, pear, coconut, orange;\n    value: extract(@list, 3);\n\nOutput:\n\n    value: coconut;\n\n### range\n\n*Released v3.9.0*\n\nGenerate a list spanning a range of values\n\n**Parameters**\n\n- `start` - (optional) The start value *e.g. 1 or 1px*\n- `end` - The end value *e.g. 5px*\n- `step` - (optional) The amount to increment by\n\nExamples:\n\n    value: range(4);\n\nOutputs:\n\n    value: 1 2 3 4;\n\nThe output of each value in the range will be the same unit as the `end` value. For example:\n\n    value: range(10px, 30px, 10);\n\nOutputs:\n\n    value: 10px 20px 30px;\n\n### each\n\n*Released v3.7.0*\n\nBind the evaluation of a ruleset to each member of a list.\n\n**Parameters**\n\n- `list` - a comma or space separated list of values.\n- `rules` - An anonymous ruleset/mixin\n\nExample:\n\n    @selectors: blue, green, red;\n\n    each(@selectors, {\n      .sel-@{value} {\n        a: b;\n      }\n    });\n\nOutputs:\n\n    .sel-blue {\n      a: b;\n    }\n    .sel-green {\n      a: b;\n    }\n    .sel-red {\n      a: b;\n    }\n\nBy default, each ruleset is bound, per list member, to a `@value`, `@key`, and `@index` variable. For most lists, `@key` and `@index` will be assigned the same value (numerical position, 1-based). However, you can also use rulesets *themselves* as structured lists. As in:\n\n    @set: {\n      one: blue;\n      two: green;\n      three: red;\n    }\n    .set {\n      each(@set, {\n        @{key}-@{index}: @value;\n      });\n    }\n\nThis will output:\n\n    .set {\n      one-1: blue;\n      two-2: green;\n      three-3: red;\n    }\n\nSince you can, of course, call mixins with guards for each ruleset call, this makes `each()` a very powerful function.\n\n### Setting variable names in `each()`\n\nYou don't have to use `@value`, `@key`, and `@index` in your `each()` function. In Less 3.7, with the `each()` function, Less is introducing the concept of anonymous mixins, which may expand to other parts of the syntax at a later date.\n\nAn anonymous mixin uses the form of `#()` or `.()` starting with `.` or `#` just like a regular mixin would. In `each()`, you can use it like this:\n\n    .set-2() {\n      one: blue;\n      two: green;\n      three: red;\n    }\n    .set-2 {\n      // Call mixin and iterate each rule\n      each(.set-2(), .(@v, @k, @i) {\n        @{k}-@{i}: @v;\n      });\n    }\n\nThis outputs, as expected:\n\n    .set-2 {\n      one-1: blue;\n      two-2: green;\n      three-3: red;\n    }\n\nThe `each()` function will take the variable names defined in the anonymous mixin and bind them to the `@value`, `@key` and `@index` values, in that order. If you only write `each(@list, #(@value) {})`, then neither `@key` nor `@index` will be defined.\n\n### Creating a `for` loop using `range` and `each`\n\n*Requires Less v3.9.0*\n\nYou can emulate a `for` loop simply by generating a numerical list and using `each` to expand it to a ruleset.\n\nExample:\n\n    each(range(4), {\n      .col-@{value} {\n        height: (@value * 50px);\n      }\n    });\n\nOutputs:\n\n    .col-1 {\n      height: 50px;\n    }\n    .col-2 {\n      height: 100px;\n    }\n    .col-3 {\n      height: 150px;\n    }\n    .col-4 {\n      height: 200px;\n    }\n\n## Math Functions\n\n### ceil\n\nRounds up to the next highest integer.\n\nParameters: `number` - a floating point number.\n\nReturns: `integer`\n\nExample: `ceil(2.4)`\n\nOutput: `3`\n\n### floor\n\nRounds down to the next lowest integer.\n\nParameters: `number` - a floating point number.\n\nReturns: `integer`\n\nExample: `floor(2.6)`\n\nOutput: `2`\n\n### percentage\n\nConverts a floating point number into a percentage string.\n\nParameters: `number` - a floating point number.\n\nReturns: `number`\n\nExample: `percentage(0.5)`\n\nOutput: `50%`\n\n### round\n\nApplies rounding.\n\nParameters:\n\n- `number`: A floating point number.\n- `decimalPlaces`: Optional: The number of decimal places to round to. Defaults to 0.\n\nReturns: `number`\n\nExample: `round(1.67)`\n\nOutput: `2`\n\nExample: `round(1.67, 1)`\n\nOutput: `1.7`\n\n### sqrt\n\nCalculates square root of a number. Keeps units as they are.\n\nParameters: `number` - floating point number.\n\nReturns: `number`\n\nExample:\n\n    sqrt(25cm)\n\nOutput:\n\n    5cm\n\nExample:\n\n    sqrt(18.6%)\n\nOutput:\n\n    4.312771730569565%;\n\n### abs\n\nCalculates absolute value of a number. Keeps units as they are.\n\nParameters: `number` - a floating point number.\n\nReturns: `number`\n\nExample \\#1: `abs(25cm)`\n\nOutput: `25cm`\n\nExample \\#2: `abs(-18.6%)`\n\nOutput: `18.6%;`\n\n### sin\n\nCalculates sine function.\n\nAssumes radians on numbers without units.\n\nParameters: `number` - a floating point number.\n\nReturns: `number`\n\nExample:\n\n    sin(1); // sine of 1 radian\n    sin(1deg); // sine of 1 degree\n    sin(1grad); // sine of 1 gradian\n\nOutput:\n\n    0.8414709848078965; // sine of 1 radian\n    0.01745240643728351; // sine of 1 degree\n    0.015707317311820675; // sine of 1 gradian\n\n### asin\n\nCalculates arcsine (inverse of sine) function.\n\nReturns number in radians e.g. a number between `-π/2` and `π/2`.\n\nParameters: `number` - floating point number from `[-1, 1]` interval.\n\nReturns: `number`\n\nExample:\n\n    asin(-0.8414709848078965)\n    asin(0)\n    asin(2)\n\nOutput:\n\n    -1rad\n    0rad\n    NaNrad\n\n### cos\n\nCalculates cosine function.\n\nAssumes radians on numbers without units.\n\nParameters: `number` - a floating point number.\n\nReturns: `number`\n\nExample:\n\n    cos(1) // cosine of 1 radian\n    cos(1deg) // cosine of 1 degree\n    cos(1grad) // cosine of 1 gradian\n\nOutput:\n\n    0.5403023058681398 // cosine of 1 radian\n    0.9998476951563913 // cosine of 1 degree\n    0.9998766324816606 // cosine of 1 gradian\n\n### acos\n\nCalculates arccosine (inverse of cosine) function.\n\nReturns number in radians e.g. a number between 0 and π.\n\nParameters: `number` - a floating point number from \\[-1, 1\\] interval.\n\nReturns: `number`\n\nExample:\n\n    acos(0.5403023058681398)\n    acos(1)\n    acos(2)\n\nOutput:\n\n    1rad\n    0rad\n    NaNrad\n\n### tan\n\nCalculates tangent function.\n\nAssumes radians on numbers without units.\n\nParameters: `number` - a floating point number.\n\nReturns: `number`\n\nExample:\n\n    tan(1) // tangent of 1 radian\n    tan(1deg) // tangent of 1 degree\n    tan(1grad) // tangent of 1 gradian\n\nOutput:\n\n    1.5574077246549023   // tangent of 1 radian\n    0.017455064928217585 // tangent of 1 degree\n    0.015709255323664916 // tangent of 1 gradian\n\n### atan\n\nCalculates arctangent (inverse of tangent) function.\n\nReturns number in radians e.g. a number between `-π/2` and `π/2`.\n\nParameters: `number` - a floating point number.\n\nReturns: `number`\n\nExample:\n\n    atan(-1.5574077246549023)\n    atan(0)\n    round(atan(22), 6) // arctangent of 22 rounded to 6 decimal places\n\nOutput:\n\n    -1rad\n    0rad\n    1.525373rad;\n\n### pi\n\nReturns π (pi);\n\nParameters: `none`\n\nReturns: `number`\n\nExample:\n\n    pi()\n\nOutput:\n\n    3.141592653589793\n\n### pow\n\nReturns the value of the first argument raised to the power of the second argument.\n\nReturned value has the same dimension as the first parameter and the dimension of the second parameter is ignored.\n\nParameters:\n\n- `number`: base -a floating point number.\n- `number`: exponent - a floating point number.\n\nReturns: `number`\n\nExample:\n\n    pow(0cm, 0px)\n    pow(25, -2)\n    pow(25, 0.5)\n    pow(-25, 0.5)\n    pow(-25%, -0.5)\n\nOutput:\n\n    1cm\n    0.0016\n    5\n    NaN\n    NaN%\n\n### mod\n\nReturns the value of the first argument modulus second argument.\n\nReturned value has the same dimension as the first parameter, the dimension of the second parameter is ignored. The function is able to handle also negative and floating point numbers.\n\nParameters:\n\n- `number`: a floating point number.\n- `number`: a floating point number.\n\nReturns: `number`\n\nExample:\n\n    mod(0cm, 0px)\n    mod(11cm, 6px);\n    mod(-26%, -5);\n\nOutput:\n\n    NaNcm;\n    5cm\n    -1%;\n\n### min\n\nReturns the lowest of one or more values.\n\nParameters: `value1, ..., valueN` - one or more values to compare.\n\nReturns: the lowest value.\n\nExample: `min(5, 10);`\n\nOutput: `5`\n\nExample: `min(3px, 42px, 1px, 16px);`\n\nOutput: `1px`\n\n### max\n\nReturns the highest of one or more values.\n\nParameters: `value1, ..., valueN` - one or more values to compare.\n\nReturns: the highest value.\n\nExample: `max(5, 10);`\n\nOutput: `10`\n\nExample: `max(3%, 42%, 1%, 16%);`\n\nOutput: `42%`\n\n## Type Functions\n\n### isnumber\n\nReturns `true` if a value is a number, `false` otherwise.\n\nParameters: `value` - a value or variable being evaluated.\n\nReturns: `true` if value is a number, `false` otherwise.\n\nExample:\n\n    isnumber(#ff0);     // false\n    isnumber(blue);     // false\n    isnumber(\"string\"); // false\n    isnumber(1234);     // true\n    isnumber(56px);     // true\n    isnumber(7.8%);     // true\n    isnumber(keyword);  // false\n    isnumber(url(...)); // false\n\n### isstring\n\nReturns `true` if a value is a string, `false` otherwise.\n\nParameters: `value` - a value or variable being evaluated.\n\nReturns: `true` if value is a string, `false` otherwise.\n\nExample:\n\n    isstring(#ff0);     // false\n    isstring(blue);     // false\n    isstring(\"string\"); // true\n    isstring(1234);     // false\n    isstring(56px);     // false\n    isstring(7.8%);     // false\n    isstring(keyword);  // false\n    isstring(url(...)); // false\n\n### iscolor\n\nReturns `true` if a value is a color, `false` otherwise.\n\nParameters: `value` - a value or variable being evaluated.\n\nReturns: `true` if value is a color, `false` otherwise.\n\nExample:\n\n    iscolor(#ff0);     // true\n    iscolor(blue);     // true\n    iscolor(\"string\"); // false\n    iscolor(1234);     // false\n    iscolor(56px);     // false\n    iscolor(7.8%);     // false\n    iscolor(keyword);  // false\n    iscolor(url(...)); // false\n\n### iskeyword\n\nReturns `true` if a value is a keyword, `false` otherwise.\n\nParameters: `value` - a value or variable being evaluated.\n\nReturns: `true` if value is a keyword, `false` otherwise.\n\nExample:\n\n    iskeyword(#ff0);     // false\n    iskeyword(blue);     // false\n    iskeyword(\"string\"); // false\n    iskeyword(1234);     // false\n    iskeyword(56px);     // false\n    iskeyword(7.8%);     // false\n    iskeyword(keyword);  // true\n    iskeyword(url(...)); // false\n\n### isurl\n\nReturns `true` if a value is a url, `false` otherwise.\n\nParameters: `value` - a value or variable being evaluated.\n\nReturns: `true` if value is a url, `false` otherwise.\n\nExample:\n\n    isurl(#ff0);     // false\n    isurl(blue);     // false\n    isurl(\"string\"); // false\n    isurl(1234);     // false\n    isurl(56px);     // false\n    isurl(7.8%);     // false\n    isurl(keyword);  // false\n    isurl(url(...)); // true\n\n### ispixel\n\nReturns `true` if a value is a number in pixels, `false` otherwise.\n\nParameters: `value` - a value or variable being evaluated.\n\nReturns: `true` if value is a pixel, `false` otherwise.\n\nExample:\n\n    ispixel(#ff0);     // false\n    ispixel(blue);     // false\n    ispixel(\"string\"); // false\n    ispixel(1234);     // false\n    ispixel(56px);     // true\n    ispixel(7.8%);     // false\n    ispixel(keyword);  // false\n    ispixel(url(...)); // false\n\n### isem\n\nReturns `true` if a value is an em value, `false` otherwise.\n\nParameters: `value` - a value or variable being evaluated.\n\nReturns: `true` if value is an em value, `false` otherwise.\n\nExample:\n\n    isem(#ff0);     // false\n    isem(blue);     // false\n    isem(\"string\"); // false\n    isem(1234);     // false\n    isem(56px);     // false\n    isem(7.8em);    // true\n    isem(keyword);  // false\n    isem(url(...)); // false\n\n### ispercentage\n\nReturns `true` if a value is a percentage value, `false` otherwise.\n\nParameters: `value` - a value or variable being evaluated.\n\nReturns: `true` if value is a percentage value, `false` otherwise.\n\nExample:\n\n    ispercentage(#ff0);     // false\n    ispercentage(blue);     // false\n    ispercentage(\"string\"); // false\n    ispercentage(1234);     // false\n    ispercentage(56px);     // false\n    ispercentage(7.8%);     // true\n    ispercentage(keyword);  // false\n    ispercentage(url(...)); // false\n\n### isunit\n\nReturns `true` if a value is a number in specified units, `false` otherwise.\n\nParameters:\n\n- `value` - a value or variable being evaluated.\n- `unit` - a unit identifier (optionally quoted) to test for.\n\nReturns: `true` if value is a number in specified units, `false` otherwise.\n\nExample:\n\n    isunit(11px, px);  // true\n    isunit(2.2%, px);  // false\n    isunit(33px, rem); // false\n    isunit(4rem, rem); // true\n    isunit(56px, \"%\"); // false\n    isunit(7.8%, '%'); // true\n    isunit(1234, em);  // false\n    isunit(#ff0, pt);  // false\n    isunit(\"mm\", mm);  // false\n\n### isruleset\n\nReturns `true` if a value is a ruleset, `false` otherwise.\n\nParameters:\n\n- `value` - a variable being evaluated.\n\nReturns: `true` if value is a ruleset, `false` otherwise.\n\nExample:\n\n    @rules: {\n        color: red;\n    }\n\n    isruleset(@rules);   // true\n    isruleset(#ff0);     // false\n    isruleset(blue);     // false\n    isruleset(\"string\"); // false\n    isruleset(1234);     // false\n    isruleset(56px);     // false\n    isruleset(7.8%);     // false\n    isruleset(keyword);  // false\n    isruleset(url(...)); // false\n\n### isdefined\n\n*Released [v4.0.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nReturns `true` if a variable is defined, `false` otherwise.\n\nParameters: `variable` - a variable being evaluated.\n\nExample:\n\n    @foo: 1;\n    isdefined(@foo);     // true\n    isdefined(@bar);     // false\n\n## Misc Functions\n\n### color\n\nParses a color, so a string representing a color becomes a color.\n\nParameters: `string`: a string of the specified color.\n\nReturns: `color`\n\nExample: `color(\"#aaa\");`\n\nOutput: `#aaa`\n\n### image-size\n\nGets the image dimensions from a file.\n\nParameters: `string`: the file to get the dimensions for.\n\nReturns: `dimension`\n\nExample: `image-size(\"file.png\");`\n\nOutput: `10px 10px`\n\nNote: this function needs to be implemented by each environment. It is currently only available in the node environment.\n\nAdded in: v2.2.0\n\n### image-width\n\nGets the image width from a file.\n\nParameters: `string`: the file to get the dimensions for.\n\nReturns: `dimension`\n\nExample: `image-width(\"file.png\");`\n\nOutput: `10px`\n\nNote: this function needs to be implemented by each environment. It is currently only available in the node environment.\n\nAdded in: v2.2.0\n\n### image-height\n\nGets the image height from a file.\n\nParameters: `string`: the file to get the dimensions for.\n\nReturns: `dimension`\n\nExample: `image-height(\"file.png\");`\n\nOutput: `10px`\n\nNote: this function needs to be implemented by each environment. It is currently only available in the node environment.\n\nAdded in: v2.2.0\n\n### convert\n\nConvert a number from one unit into another.\n\nThe first argument contains a number with units and second argument contains units. If the units are compatible, the number is converted. If they are not compatible, the first argument is returned unmodified.\n\nSee [unit](#misc-functions-unit) for changing the unit without conversion.\n\n*Compatible unit groups*:\n\n- lengths: `m`, `cm`, `mm`, `in`, `pt` and `pc`,\n- time: `s` and `ms`,\n- angle: `rad`, `deg`, `grad` and `turn`.\n\nParameters:\n\n- `number`: a floating point number with units.\n- `identifier`, `string` or `escaped value`: units\n\nReturns: `number`\n\nExample:\n\n    convert(9s, \"ms\")\n    convert(14cm, mm)\n    convert(8, mm) // incompatible unit types\n\nOutput:\n\n    9000ms\n    140mm\n    8\n\n### data-uri\n\nInlines a resource and falls back to `url()` if the ieCompat option is on and the resource is too large, or if you use the function in the browser. If the MIME type is not given then node uses the mime package to determine the correct mime type.\n\nParameters:\n\n- `mimetype`: (Optional) A MIME type string.\n- `url`: The URL of the file to inline.\n\nIf there is no mimetype, data-uri function guesses it from filename suffix. Text and svg files are encoded as utf-8 and anything else is encoded as base64.\n\nIf user provided mimetype, the function uses base64 if mimetype argument ends with ;base64. For example, `image/jpeg;base64` is encoded into base64 while `text/html` is encoded into utf-8.\n\nExample: `data-uri('../data/image.jpg');`\n\nOutput: `url('data:image/jpeg;base64,bm90IGFjdHVhbGx5IGEganBlZyBmaWxlCg==');`\n\nOutput in browser: `url('../data/image.jpg');`\n\nExample: `data-uri('image/jpeg;base64', '../data/image.jpg');`\n\nOutput: `url('data:image/jpeg;base64,bm90IGFjdHVhbGx5IGEganBlZyBmaWxlCg==');`\n\nExample: `data-uri('image/svg+xml;charset=UTF-8', 'image.svg');`\n\nOutput: `url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%3E%3Ccircle%20r%3D%229%22%2F%3E%3C%2Fsvg%3E\");`\n\n### default\n\nAvailable only inside guard conditions and returns `true` only if no other mixin matches, `false` otherwise.\n\nExample:\n\n    .mixin(1)                   {x: 11}\n    .mixin(2)                   {y: 22}\n    .mixin(@x) when (default()) {z: @x}\n\n    div {\n      .mixin(3);\n    }\n\n    div.special {\n      .mixin(1);\n    }\n\nOutput:\n\n    div {\n      z: 3;\n    }\n    div.special {\n      x: 11;\n    }\n\nIt is possible to use the value returned by `default` with guard operators. For example `.mixin() when not(default()) {}` will match only if there's at least one more mixin definition that matches`.mixin()` call:\n\n    .mixin(@value) when (ispixel(@value)) {width: @value}\n    .mixin(@value) when not(default())    {padding: (@value / 5)}\n\n    div-1 {\n      .mixin(100px);\n    }\n\n    div-2 {\n      /* ... */\n      .mixin(100%);\n    }\n\nresult:\n\n    div-1 {\n      width: 100px;\n      padding: 20px;\n    }\n    div-2 {\n      /* ... */\n    }\n\nIt is allowed to make multiple `default()` calls in the same guard condition or in a different conditions of a mixins with the same name:\n\n    div {\n      .m(@x) when (default()), not(default())    {always: @x}\n      .m(@x) when (default()) and not(default()) {never:  @x}\n\n      .m(1); // OK\n    }\n\nHowever Less will throw a error if it detects a *potential* conflict between multiple mixin definitions using `default()`:\n\n    div {\n      .m(@x) when (default())    {}\n      .m(@x) when not(default()) {}\n\n      .m(1); // Error\n    }\n\nIn above example it is impossible to determine what value each `default()` call should return since they recursively depend on each other.\n\nAdvanced multiple `default()` usage:\n\n    .x {\n      .m(red)                                    {case-1: darkred}\n      .m(blue)                                   {case-2: darkblue}\n      .m(@x) when (iscolor(@x)) and (default())  {default-color: @x}\n      .m('foo')                                  {case-1: I am 'foo'}\n      .m('bar')                                  {case-2: I am 'bar'}\n      .m(@x) when (isstring(@x)) and (default()) {default-string: and I am the default}\n\n      &-blue  {.m(blue)}\n      &-green {.m(green)}\n      &-foo   {.m('foo')}\n      &-baz   {.m('baz')}\n    }\n\nResult:\n\n    .x-blue {\n      case-2: #00008b;\n    }\n    .x-green {\n      default-color: #008000;\n    }\n    .x-foo {\n      case-1: I am 'foo';\n    }\n    .x-baz {\n      default-string: and I am the default;\n    }\n\nThe `default` function is available as a Less built-in function *only inside guard expressions*. If used outside of a mixin guard condition it is interpreted as a regular CSS value:\n\nExample:\n\n    div {\n      foo: default();\n      bar: default(42);\n    }\n\nResult:\n\n    div {\n      foo: default();\n      bar: default(42);\n    }\n\n### unit\n\nRemove or change the unit of a dimension\n\nParameters:\n\n- `dimension`: A number, with or without a dimension.\n- `unit`: (Optional) the unit to change to, or if omitted it will remove the unit.\n\nSee [convert](#misc-functions-convert) for changing the unit with conversion.\n\nExample: `unit(5, px)`\n\nOutput: `5px`\n\nExample: `unit(5em)`\n\nOutput: `5`\n\n### get-unit\n\nReturns units of a number.\n\nIf the argument contains a number with units, the function returns its units. The argument without units results in an empty return value.\n\nParameters:\n\n- `number`: a number with or without units.\n\nExample: `get-unit(5px)`\n\nOutput: `px`\n\nExample: `get-unit(5)`\n\nOutput: `//nothing`\n\n### svg-gradient\n\nGenerates multi-stop svg gradients.\n\nSvg-gradient function generates multi-stop svg gradients. It must have at least three parameters. First parameter specifies gradient type and direction and remaining parameters list colors and their positions. The position of first and last specified color are optional, remaining colors must have positions specified.\n\nThe direction must be one of `to bottom`, `to right`, `to bottom right`, `to top right`, `ellipse` or `ellipse at center`. The direction can be specified as both escaped value `~'to bottom'` and space separated list of words `to bottom`.\n\nThe direction must be followed by two or more color stops. They can be supplied either inside a list or you can specify each color stops in separate argument.\n\nParameters - colors stops in list:\n\n- `escaped value` or `list of identifiers`: direction\n- `list` - all colors and their positions in list\n\nParameters - color stops in arguments:\n\n- `escaped value` or `list of identifiers`: direction\n- `color [percentage]` pair: first color and its relative position (position is optional)\n- `color percent` pair: (optional) second color and its relative position\n- ...\n- `color percent` pair: (optional) n-th color and its relative position\n- `color [percentage]` pair: last color and its relative position (position is optional)\n\nReturns: `url` with \"URI-Encoded\" svg gradient.\n\nExample - colors stops in list:\n\n    div {\n      @list: red, green 30%, blue;\n      background-image: svg-gradient(to right, @list);\n    }\n\nequivalent - color stops in arguments:\n\n    div {\n      background-image: svg-gradient(to right, red, green 30%, blue);\n    }\n\nboth result in:\n\n    div {\n      background-image: url('data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20version%3D%221.1%22%20width%3D%22100%25%22%20height%3D%22100%25%22%20viewBox%3D%220%200%201%201%22%20preserveAspectRatio%3D%22none%22%3E%3ClinearGradient%20id%3D%22gradient%22%20gradientUnits%3D%22userSpaceOnUse%22%20x1%3D%220%25%22%20y1%3D%220%25%22%20x2%3D%22100%25%22%20y2%3D%220%25%22%3E%3Cstop%20offset%3D%220%25%22%20stop-color%3D%22%23ff0000%22%2F%3E%3Cstop%20offset%3D%2230%25%22%20stop-color%3D%22%23008000%22%2F%3E%3Cstop%20offset%3D%22100%25%22%20stop-color%3D%22%230000ff%22%2F%3E%3C%2FlinearGradient%3E%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%221%22%20height%3D%221%22%20fill%3D%22url(%23gradient)%22%20%2F%3E%3C%2Fsvg%3E');\n    }\n\nNote: in versions before 2.2.0 the result is `base64` encoded .\n\nGenerated background image has red color on the left, green at 30% of its width and ends with a blue color. Base64 encoded part contains following svg-gradient:\n\n    <?xml version=\"1.0\" ?>\n    <svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"100%\" height=\"100%\" viewBox=\"0 0 1 1\" preserveAspectRatio=\"none\">\n        <linearGradient id=\"gradient\" gradientUnits=\"userSpaceOnUse\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\n            <stop offset=\"0%\" stop-color=\"#ff0000\"/>\n            <stop offset=\"30%\" stop-color=\"#008000\"/>\n            <stop offset=\"100%\" stop-color=\"#0000ff\"/>\n        </linearGradient>\n        <rect x=\"0\" y=\"0\" width=\"1\" height=\"1\" fill=\"url(#gradient)\" />\n    </svg>\n\n## Color Definition Functions\n\n### rgb\n\nCreates an opaque color object from decimal red, green and blue (RGB) values.\n\nLiteral color values in standard HTML/CSS formats may also be used to define colors, for example `#ff0000`.\n\nParameters:\n\n- `red`: An integer 0-255 or percentage 0-100%.\n- `green`: An integer 0-255 or percentage 0-100%.\n- `blue`: An integer 0-255 or percentage 0-100%.\n\nReturns: `color`\n\nExample: `rgb(90, 129, 32)`\n\nOutput: `#5a8120`\n\n### rgba\n\nCreates a transparent color object from decimal red, green, blue and alpha (RGBA) values.\n\nParameters:\n\n- `red`: An integer 0-255 or percentage 0-100%.\n- `green`: An integer 0-255 or percentage 0-100%.\n- `blue`: An integer 0-255 or percentage 0-100%.\n- `alpha`: A number 0-1 or percentage 0-100%.\n\nReturns: `color`\n\nExample: `rgba(90, 129, 32, 0.5)`\n\nOutput: `rgba(90, 129, 32, 0.5)`\n\n### argb\n\nCreates a hex representation of a color in `#AARRGGBB` format (**NOT** `#RRGGBBAA`!).\n\nThis format is used in Internet Explorer, and .NET and Android development.\n\nParameters: `color`, color object.\n\nReturns: `string`\n\nExample: `argb(rgba(90, 23, 148, 0.5));`\n\nOutput: `#805a1794`\n\n### hsl\n\nCreates an opaque color object from hue, saturation and lightness (HSL) values.\n\nParameters:\n\n- `hue`: An integer 0-360 representing degrees.\n- `saturation`: A percentage 0-100% or number 0-1.\n- `lightness`: A percentage 0-100% or number 0-1.\n\nReturns: `color`\n\nExample: `hsl(90, 100%, 50%)`\n\nOutput: `#80ff00`\n\nThis is useful if you want to create a new color based on another color's channel, forExample: `@new: hsl(hue(@old), 45%, 90%);`\n\n`@new` will have `@old`'s *hue*, and its own saturation and lightness.\n\n### hsla\n\nCreates a transparent color object from hue, saturation, lightness and alpha (HSLA) values.\n\nParameters:\n\n- `hue`: An integer 0-360 representing degrees.\n- `saturation`: A percentage 0-100% or number 0-1.\n- `lightness`: A percentage 0-100% or number 0-1.\n- `alpha`: A percentage 0-100% or number 0-1.\n\nReturns: `color`\n\nExample: `hsla(90, 100%, 50%, 0.5)`\n\nOutput: `rgba(128, 255, 0, 0.5)`\n\n### hsv\n\nCreates an opaque color object from hue, saturation and value (HSV) values.\n\nNote that this is a color space available in Photoshop, and is not the same as `hsl`.\n\nParameters:\n\n- `hue`: An integer 0-360 representing degrees.\n- `saturation`: A percentage 0-100% or number 0-1.\n- `value`: A percentage 0-100% or number 0-1.\n\nReturns: `color`\n\nExample: `hsv(90, 100%, 50%)`\n\nOutput: `#408000`\n\n### hsva\n\nCreates a transparent color object from hue, saturation, value and alpha (HSVA) values.\n\nNote that this is not the same as `hsla`, and is a color space available in Photoshop.\n\nParameters:\n\n- `hue`: An integer 0-360 representing degrees.\n- `saturation`: A percentage 0-100% or number 0-1.\n- `value`: A percentage 0-100% or number 0-1.\n- `alpha`: A percentage 0-100% or number 0-1.\n\nReturns: `color`\n\nExample: `hsva(90, 100%, 50%, 0.5)`\n\nOutput: `rgba(64, 128, 0, 0.5)`\n\n## Color Channel Functions\n\n### hue\n\nExtracts the hue channel of a color object in the HSL color space.\n\nParameters: `color` - a color object.\n\nReturns: `integer` 0-360\n\nExample: `hue(hsl(90, 100%, 50%))`\n\nOutput: `90`\n\n### saturation\n\nExtracts the saturation channel of a color object in the HSL color space.\n\nParameters: `color` - a color object.\n\nReturns: `percentage` 0-100\n\nExample: `saturation(hsl(90, 100%, 50%))`\n\nOutput: `100%`\n\n### lightness\n\nExtracts the lightness channel of a color object in the HSL color space.\n\nParameters: `color` - a color object.\n\nReturns: `percentage` 0-100\n\nExample: `lightness(hsl(90, 100%, 50%))`\n\nOutput: `50%`\n\n### hsvhue\n\nExtracts the hue channel of a color object in the HSV color space.\n\nParameters: `color` - a color object.\n\nReturns: `integer` `0-360`\n\nExample: `hsvhue(hsv(90, 100%, 50%))`\n\nOutput: `90`\n\n### hsvsaturation\n\nExtracts the saturation channel of a color object in the HSV color space.\n\nParameters: `color` - a color object.\n\nReturns: `percentage` 0-100\n\nExample: `hsvsaturation(hsv(90, 100%, 50%))`\n\nOutput: `100%`\n\n### hsvvalue\n\nExtracts the value channel of a color object in the HSV color space.\n\nParameters: `color` - a color object.\n\nReturns: `percentage` 0-100\n\nExample: `hsvvalue(hsv(90, 100%, 50%))`\n\nOutput: `50%`\n\n### red\n\nExtracts the red channel of a color object.\n\nParameters: `color` - a color object.\n\nReturns: `float` 0-255\n\nExample: `red(rgb(10, 20, 30))`\n\nOutput: `10`\n\n### green\n\nExtracts the green channel of a color object.\n\nParameters: `color` - a color object.\n\nReturns: `float` 0-255\n\nExample: `green(rgb(10, 20, 30))`\n\nOutput: `20`\n\n### blue\n\nExtracts the blue channel of a color object.\n\nParameters: `color` - a color object.\n\nReturns: `float` 0-255\n\nExample: `blue(rgb(10, 20, 30))`\n\nOutput: `30`\n\n### alpha\n\nExtracts the alpha channel of a color object.\n\nParameters: `color` - a color object.\n\nReturns: `float` 0-1\n\nExample: `alpha(rgba(10, 20, 30, 0.5))`\n\nOutput: `0.5`\n\n### luma\n\nCalculates the [luma](http://en.wikipedia.org/wiki/Luma_%28video%29) (perceptual brightness) of a color object.\n\nUses **SMPTE C / Rec. 709** coefficients, as recommended in [WCAG 2.0](http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef). This calculation is also used in the contrast function.\n\nBefore v1.7.0 the luma was calculated without gamma correction, use the luminance function to calculate these \"old\" values.\n\nParameters: `color` - a color object.\n\nReturns: `percentage` 0-100%\n\nExample: `luma(rgb(100, 200, 30))`\n\nOutput: `44%`\n\n### luminance\n\nCalculates the value of the luma without gamma correction (this function was named `luma` before v1.7.0)\n\nParameters: `color` - a color object.\n\nReturns: `percentage` 0-100%\n\nExample: `luminance(rgb(100, 200, 30))`\n\nOutput: `65%`\n\n## Color Operation Functions\n\nColor operations generally take parameters in the same units as the values they are changing, and percentages are handled as absolutes, so increasing a 10% value by 10% results in 20%. Set the option method parameter to relative for relative percentages. When using relative percentages increasing a 10% value by 10% results in 11%. Values are clamped to their allowed ranges; they do not wrap around. Where return values are shown, we've used formats that make it clear what each function has done, in addition to the hex versions that you will usually be be working with.\n\n### saturate\n\nIncrease the saturation of a color in the HSL color space by an absolute amount.\n\nParameters:\n\n- `color`: A color object.\n- `amount`: A percentage 0-100%.\n- `method`: Optional, set to `relative` for the adjustment to be relative to the current value.\n\nReturns: `color`\n\nExample: `saturate(hsl(90, 80%, 50%), 20%)`\n\nOutput: `#80ff00 // hsl(90, 100%, 50%)`\n\n➜\n\n### desaturate\n\nDecrease the saturation of a color in the HSL color space by an absolute amount.\n\nParameters:\n\n- `color`: A color object.\n- `amount`: A percentage 0-100%.\n- `method`: Optional, set to `relative` for the adjustment to be relative to the current value.\n\nReturns: `color`\n\nExample: `desaturate(hsl(90, 80%, 50%), 20%)`\n\nOutput: `#80cc33 // hsl(90, 60%, 50%)`\n\n➜\n\n### lighten\n\nIncrease the lightness of a color in the HSL color space by an absolute amount.\n\nParameters:\n\n- `color`: A color object.\n- `amount`: A percentage 0-100%.\n- `method`: Optional, set to `relative` for the adjustment to be relative to the current value.\n\nReturns: `color`\n\nExample: `lighten(hsl(90, 80%, 50%), 20%)`\n\nOutput: `#b3f075 // hsl(90, 80%, 70%)`\n\n➜\n\n### darken\n\nDecrease the lightness of a color in the HSL color space by an absolute amount.\n\nParameters:\n\n- `color`: A color object.\n- `amount`: A percentage 0-100%.\n- `method`: Optional, set to `relative` for the adjustment to be relative to the current value.\n\nReturns: `color`\n\nExample: `darken(hsl(90, 80%, 50%), 20%)`\n\nOutput: `#4d8a0f // hsl(90, 80%, 30%)`\n\n➜\n\n### fadein\n\nDecrease the transparency (or increase the opacity) of a color, making it more opaque.\n\nHas no effect on opaque colors. To fade in the other direction use `fadeout`.\n\nParameters:\n\n- `color`: A color object.\n- `amount`: A percentage 0-100%.\n- `method`: Optional, set to `relative` for the adjustment to be relative to the current value.\n\nReturns: `color`\n\nExample: `fadein(hsla(90, 90%, 50%, 0.5), 10%)`\n\nOutput: `rgba(128, 242, 13, 0.6) // hsla(90, 90%, 50%, 0.6)`\n\n### fadeout\n\nIncrease the transparency (or decrease the opacity) of a color, making it less opaque. To fade in the other direction use `fadein`.\n\nParameters:\n\n- `color`: A color object.\n- `amount`: A percentage 0-100%.\n- `method`: Optional, set to `relative` for the adjustment to be relative to the current value.\n\nReturns: `color`\n\nExample: `fadeout(hsla(90, 90%, 50%, 0.5), 10%)`\n\nOutput: `rgba(128, 242, 13, 0.4) // hsla(90, 90%, 50%, 0.4)`\n\n### fade\n\nSet the absolute opacity of a color. Can be applied to colors whether they already have an opacity value or not.\n\nParameters:\n\n- `color`: A color object.\n- `amount`: A percentage 0-100%.\n\nReturns: `color`\n\nExample: `fade(hsl(90, 90%, 50%), 10%)`\n\nOutput: `rgba(128, 242, 13, 0.1) //hsla(90, 90%, 50%, 0.1)`\n\n### spin\n\nRotate the hue angle of a color in either direction.\n\nWhile the angle range is 0-360, it applies a mod 360 operation, so you can pass in much larger (or negative) values and they will wrap around e.g. angles of 360 and 720 will produce the same result. Note that colors are passed through an RGB conversion, which doesn't retain hue value for greys (because hue has no meaning when there is no saturation), so make sure you apply functions in a way that preserves hue, for example don't do this:\n\n    @c: saturate(spin(#aaaaaa, 10), 10%);\n\nDo this instead:\n\n    @c: spin(saturate(#aaaaaa, 10%), 10);\n\nColors are always returned as RGB values, so applying `spin` to a grey value will do nothing.\n\nParameters:\n\n- `color`: A color object.\n- `angle`: A number of degrees to rotate (+ or -).\n\nReturns: `color`\n\nExample:\n\n    spin(hsl(10, 90%, 50%), 30)\n    spin(hsl(10, 90%, 50%), -30)\n\nOutput:\n\n    #f2a60d // hsl(40, 90%, 50%)\n    #f20d59 // hsl(340, 90%, 50%)\n\n➜\n\n➜\n\n### mix\n\nMix two colors together in variable proportion. Opacity is included in the calculations.\n\nParameters:\n\n- `color1`: A color object.\n- `color2`: A color object.\n- `weight`: Optional, a percentage balance point between the two colors, defaults to 50%.\n\nReturns: `color`\n\nExample:\n\n    mix(#ff0000, #0000ff, 50%)\n    mix(rgba(100,0,0,1.0), rgba(0,100,0,0.5), 50%)\n\nOutput:\n\n    #800080\n    rgba(75, 25, 0, 0.75)\n\n\\+ ➜\n\n### tint\n\nMix color with white in variable proportion. It is the same as calling `mix(#ffffff, @color, @weight)`\n\nParameters:\n\n- `color`: A color object.\n- `weight`: Optional, a percentage balance point between color and white, defaults to 50%.\n\nReturns: `color`\n\nExample:\n\n    no-alpha: tint(#007fff, 50%); \n    with-alpha: tint(rgba(00,0,255,0.5), 50%); \n\nOutput:\n\n    no-alpha: #80bfff;\n    with-alpha: rgba(191, 191, 255, 0.75);\n\n➜\n\n### shade\n\nMix color with black in variable proportion. It is the same as calling `mix(#000000, @color, @weight)`\n\nParameters:\n\n- `color`: A color object.\n- `weight`: Optional, a percentage balance point between color and black, defaults to 50%.\n\nReturns: `color`\n\nExample:\n\n    no-alpha: shade(#007fff, 50%); \n    with-alpha: shade(rgba(00,0,255,0.5), 50%); \n\nOutput:\n\n    no-alpha: #004080;\n    with-alpha: rgba(0, 0, 64, 0.75);\n\n➜\n\n### greyscale\n\nRemove all saturation from a color in the HSL color space; the same as calling `desaturate(@color, 100%)`.\n\nBecause the saturation is not affected by hue, the resulting color mapping may be somewhat dull or muddy; [`luma`](#color-channel-luma) may provide a better result as it extracts perceptual rather than linear brightness, for example `greyscale('#0000ff')` will return the same value as `greyscale('#00ff00')`, though they appear quite different in brightness to the human eye.\n\nParameters: `color`: A color object.\n\nReturns: `color`\n\nExample: `greyscale(hsl(90, 90%, 50%))`\n\nOutput: `#808080 // hsl(90, 0%, 50%)`\n\n➜\n\nNotice that the generated grey looks darker than the original green, even though its lightness value is the same.\n\nCompare with using `luma` (usage is different because `luma` returns a single value, not a color):\n\n    @c: luma(hsl(90, 90%, 50%));\n    color: rgb(@c, @c, @c);\n\nOutput: `#cacaca`\n\n➜\n\nThis time the grey's lightness looks about the same as the green, though its value is actually higher.\n\n### contrast\n\nChoose which of two colors provides the greatest contrast with another.\n\nThis is useful for ensuring that a color is readable against a background, which is also useful for accessibility compliance. This function works the same way as the [contrast function in Compass for SASS](http://compass-style.org/reference/compass/utilities/color/contrast/). In accordance with [WCAG 2.0](http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef), colors are compared using their gamma-corrected [luma](#color-channel-luma) value, not their lightness.\n\nThe light and dark parameters can be supplied in either order - the function will calculate their luma values and assign light and dark automatically, which means you can't use this function to select the *least* contrasting color by reversing the order.\n\nParameters:\n\n- `color`: A color object to compare against.\n- `dark`: optional - A designated dark color (defaults to black).\n- `light`: optional - A designated light color (defaults to white).\n- `threshold`: optional - A percentage 0-100% specifying where the transition from \"dark\" to \"light\" is (defaults to 43%, matching SASS). This is used to bias the contrast one way or another, for example to allow you to decide whether a 50% grey background should result in black or white text. You would generally set this lower for 'lighter' palettes, higher for 'darker' ones.\n\nReturns: `color`\n\nExample:\n\n    p {\n        a: contrast(#bbbbbb);\n        b: contrast(#222222, #101010);\n        c: contrast(#222222, #101010, #dddddd);\n        d: contrast(hsl(90, 100%, 50%), #000000, #ffffff, 30%);\n        e: contrast(hsl(90, 100%, 50%), #000000, #ffffff, 80%);\n    }\n\nOutput:\n\n    p {\n        a: #000000 // black\n        b: #ffffff // white\n        c: #dddddd\n        d: #000000 // black\n        e: #ffffff // white\n    }\n\nThese examples use the above calculated colors for background and foreground; you can see that you never end up with white-on-white, nor black-on-black, though it's possible to use the threshold to permit lower-contrast outcomes, as in the last example:\n\n## Color Blending Functions\n\nThese operations are *similar* (though not necessarily identical) to the blend modes found in image editors like Photoshop, Fireworks, or GIMP, so you can use them to make your CSS colors match your images.\n\n### multiply\n\nMultiply two colors. Corresponding RGB channels from each of the two colors are multiplied together then divided by 255. The result is a darker color.\n\nParameters:\n\n- `color1`: A color object.\n- `color2`: A color object.\n\nReturns: `color`\n\n**Examples**:\n\n    multiply(#ff6600, #000000);\n\n    multiply(#ff6600, #333333);\n\n    multiply(#ff6600, #666666);\n\n    multiply(#ff6600, #999999);\n\n    multiply(#ff6600, #cccccc);\n\n    multiply(#ff6600, #ffffff);\n\n    multiply(#ff6600, #ff0000);\n\n    multiply(#ff6600, #00ff00);\n\n    multiply(#ff6600, #0000ff);\n\n### screen\n\nDo the opposite of `multiply`. The result is a brighter color.\n\nParameters:\n\n- `color1`: A color object.\n- `color2`: A color object.\n\nReturns: `color`\n\nExample:\n\n    screen(#ff6600, #000000);\n\n    screen(#ff6600, #333333);\n\n    screen(#ff6600, #666666);\n\n    screen(#ff6600, #999999);\n\n    screen(#ff6600, #cccccc);\n\n    screen(#ff6600, #ffffff);\n\n    screen(#ff6600, #ff0000);\n\n    screen(#ff6600, #00ff00);\n\n    screen(#ff6600, #0000ff);\n\n### overlay\n\nCombines the effects of both `multiply` and `screen`. Conditionally make light channels lighter and dark channels darker. **Note**: The results of the conditions are determined by the first color parameter.\n\nParameters:\n\n- `color1`: A base color object. Also the determinant color to make the result lighter or darker.\n- `color2`: A color object to *overlay*.\n\nReturns: `color`\n\nExample:\n\n    overlay(#ff6600, #000000);\n\n    overlay(#ff6600, #333333);\n\n    overlay(#ff6600, #666666);\n\n    overlay(#ff6600, #999999);\n\n    overlay(#ff6600, #cccccc);\n\n    overlay(#ff6600, #ffffff);\n\n    overlay(#ff6600, #ff0000);\n\n    overlay(#ff6600, #00ff00);\n\n    overlay(#ff6600, #0000ff);\n\n### softlight\n\nSimilar to `overlay` but avoids pure black resulting in pure black, and pure white resulting in pure white.\n\nParameters:\n\n- `color1`: A color object to *soft light* another.\n- `color2`: A color object to be *soft lighten*.\n\nReturns: `color`\n\nExample:\n\n    softlight(#ff6600, #000000);\n\n    softlight(#ff6600, #333333);\n\n    softlight(#ff6600, #666666);\n\n    softlight(#ff6600, #999999);\n\n    softlight(#ff6600, #cccccc);\n\n    softlight(#ff6600, #ffffff);\n\n    softlight(#ff6600, #ff0000);\n\n    softlight(#ff6600, #00ff00);\n\n    softlight(#ff6600, #0000ff);\n\n### hardlight\n\nThe same as `overlay` but with the color roles reversed.\n\nParameters:\n\n- `color1`: A color object to *overlay*.\n- `color2`: A base color object. Also the determinant color to make the result lighter or darker.\n\nReturns: `color`\n\nExample:\n\n    hardlight(#ff6600, #000000);\n\n    hardlight(#ff6600, #333333);\n\n    hardlight(#ff6600, #666666);\n\n    hardlight(#ff6600, #999999);\n\n    hardlight(#ff6600, #cccccc);\n\n    hardlight(#ff6600, #ffffff);\n\n    hardlight(#ff6600, #ff0000);\n\n    hardlight(#ff6600, #00ff00);\n\n    hardlight(#ff6600, #0000ff);\n\n### difference\n\nSubtracts the second color from the first color on a channel-by-channel basis. Negative values are inverted. Subtracting black results in no change; subtracting white results in color inversion.\n\nParameters:\n\n- `color1`: A color object to act as the minuend.\n- `color2`: A color object to act as the subtrahend.\n\nReturns: `color`\n\nExample:\n\n    difference(#ff6600, #000000);\n\n    difference(#ff6600, #333333);\n\n    difference(#ff6600, #666666);\n\n    difference(#ff6600, #999999);\n\n    difference(#ff6600, #cccccc);\n\n    difference(#ff6600, #ffffff);\n\n    difference(#ff6600, #ff0000);\n\n    difference(#ff6600, #00ff00);\n\n    difference(#ff6600, #0000ff);\n\n### exclusion\n\nA similar effect to `difference` with lower contrast.\n\nParameters:\n\n- `color1`: A color object to act as the minuend.\n- `color2`: A color object to act as the subtrahend.\n\nReturns: `color`\n\nExample:\n\n    exclusion(#ff6600, #000000);\n\n    exclusion(#ff6600, #333333);\n\n    exclusion(#ff6600, #666666);\n\n    exclusion(#ff6600, #999999);\n\n    exclusion(#ff6600, #cccccc);\n\n    exclusion(#ff6600, #ffffff);\n\n    exclusion(#ff6600, #ff0000);\n\n    exclusion(#ff6600, #00ff00);\n\n    exclusion(#ff6600, #0000ff);\n\n### average\n\nCompute the average of two colors on a per-channel (RGB) basis.\n\nParameters:\n\n- `color1`: A color object.\n- `color2`: A color object.\n\nReturns: `color`\n\nExample:\n\n    average(#ff6600, #000000);\n\n    average(#ff6600, #333333);\n\n    average(#ff6600, #666666);\n\n    average(#ff6600, #999999);\n\n    average(#ff6600, #cccccc);\n\n    average(#ff6600, #ffffff);\n\n    average(#ff6600, #ff0000);\n\n    average(#ff6600, #00ff00);\n\n    average(#ff6600, #0000ff);\n\n### negation\n\nDo the opposite effect to `difference`.\n\nThe result is a brighter color. **Note**: The *opposite* effect doesn't mean the *inverted* effect as resulting from an *addition* operation.\n\nParameters:\n\n- `color1`: A color object to act as the minuend.\n- `color2`: A color object to act as the subtrahend.\n\nReturns: `color`\n\nExample:\n\n    negation(#ff6600, #000000);\n\n    negation(#ff6600, #333333);\n\n    negation(#ff6600, #666666);\n\n    negation(#ff6600, #999999);\n\n    negation(#ff6600, #cccccc);\n\n    negation(#ff6600, #ffffff);\n\n    negation(#ff6600, #ff0000);\n\n    negation(#ff6600, #00ff00);\n\n    negation(#ff6600, #0000ff);\n\n© 2009–2020 The Core Less Team  \nLicensed under the Creative Commons Attribution License 3.0.  \n[http://lesscss.org/functions](http://lesscss.org/functions)"
- name: luma
  id: functions#color-channel-luma
  summary: Calculates the luma (perceptual brightness) of a color object
  belongs_to: Logical Functions
  description: |-
    ### luma

    Calculates the [luma](http://en.wikipedia.org/wiki/Luma_%28video%29) (perceptual brightness) of a color object.

    Uses **SMPTE C / Rec. 709** coefficients, as recommended in [WCAG 2.0](http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef). This calculation is also used in the contrast function.

    Before v1.7.0 the luma was calculated without gamma correction, use the luminance function to calculate these "old" values.

    Parameters: `color` - a color object.

    Returns: `percentage` 0-100%

    Example: `luma(rgb(100, 200, 30))`

    Output: `44%`
- name: luminance
  id: functions#color-channel-luminance
  summary: 'Parameters: color - a color object'
  belongs_to: Logical Functions
  description: |-
    ### luminance

    Calculates the value of the luma without gamma correction (this function was named `luma` before v1.7.0)

    Parameters: `color` - a color object.

    Returns: `percentage` 0-100%

    Example: `luminance(rgb(100, 200, 30))`

    Output: `65%`

    ## Color Operation Functions

    Color operations generally take parameters in the same units as the values they are changing, and percentages are handled as absolutes, so increasing a 10% value by 10% results in 20%. Set the option method parameter to relative for relative percentages. When using relative percentages increasing a 10% value by 10% results in 11%. Values are clamped to their allowed ranges; they do not wrap around. Where return values are shown, we've used formats that make it clear what each function has done, in addition to the hex versions that you will usually be be working with.
- name: Maps (NEW!)
  id: index#maps-feature
  summary: By combining namespacing with the lookup [] syntax, you can turn your rulesets / mixins into maps
  description: "## Maps (NEW!)\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nUse rulesets and mixins as maps of values\n\nBy combining namespacing with the lookup `[]` syntax, you can turn your rulesets / mixins into maps.\n\n    @sizes: {\n      mobile: 320px;\n      tablet: 768px;\n      desktop: 1024px;\n    }\n\n    .navbar {\n      display: block;\n\n      @media (min-width: @sizes[tablet]) {\n        display: inline-block;\n      }\n    }\n\nOutputs:\n\n    .navbar {\n      display: block;\n    }\n    @media (min-width: 768px) {\n      .navbar {\n        display: inline-block;\n      }\n    }\n\nMixins are a little more versatile as maps because of namespacing and the ability to overload mixins.\n\n    #library() {\n      .colors() {\n        primary: green;\n        secondary: blue;\n      }\n    }\n\n    #library() {\n      .colors() { primary: grey; }\n    }\n\n    .button {\n      color: #library.colors[primary];\n      border-color: #library.colors[secondary];\n    }\n\nOutputs:\n\n    .button {\n      color: grey;\n      border-color: blue;\n    }\n\nYou can also make this easier by [aliasing mixins](#mixins-feature-mixin-aliasing-feature). That is:\n\n    .button {\n      @colors: #library.colors();\n      color: @colors[primary];\n      border-color: @colors[secondary];\n    }\n\nNote, if a lookup value produces another ruleset, you can append a second `[]` lookup, as in:\n\n    @config: {\n      @options: {\n        library-on: true\n      }\n    }\n\n    & when (@config[@options][library-on] = true) {\n      .produce-ruleset {\n        prop: val;\n      }\n    }\n\nIn this way, rulesets and variable calls can emulate a type of \"namespacing\", similar to mixins.\n\nAs far as whether to use mixins or rulesets assigned to variables as maps, it's up to you. You may want to replace entire maps by re-declaring a variable assigned to a rulset. Or you may want to \"merge\" individual key/value pairs, in which case mixins as maps might be more appropriate.\n\n### Using variable variables in lookups\n\nOne important thing to notice is that the value in `[@lookup]` is the key (variable) name `@lookup`, and is not evaluated as a variable. If you want the key name itself to be variable, you can use the `@@variable` syntax.\n\nE.g.\n\n    .foods() {\n      @dessert: ice cream;\n    }\n\n    @key-to-lookup: dessert;\n\n    .lunch {\n      treat: .foods[@@key-to-lookup];\n    }\n\nThis would output:\n\n    .lunch {\n      treat: ice cream;\n    }\n\n© 2009–2020 The Core Less Team  \nLicensed under the Creative Commons Attribution License 3.0.  \n[http://lesscss.org/features](http://lesscss.org/features)"
- name: max
  id: functions#math-functions-max
  summary: Returns the highest of one or more values
  belongs_to: Logical Functions
  description: |-
    ### max

    Returns the highest of one or more values.

    Parameters: `value1, ..., valueN` - one or more values to compare.

    Returns: the highest value.

    Example: `max(5, 10);`

    Output: `10`

    Example: `max(3%, 42%, 1%, 16%);`

    Output: `42%`

    ## Type Functions
- name: min
  id: functions#math-functions-min
  summary: Returns the lowest of one or more values
  belongs_to: Logical Functions
  description: |-
    ### min

    Returns the lowest of one or more values.

    Parameters: `value1, ..., valueN` - one or more values to compare.

    Returns: the lowest value.

    Example: `min(5, 10);`

    Output: `5`

    Example: `min(3px, 42px, 1px, 16px);`

    Output: `1px`
- name: mix
  id: functions#color-operations-mix
  summary: Mix two colors together in variable proportion
  belongs_to: Logical Functions
  description: |-
    ### mix

    Mix two colors together in variable proportion. Opacity is included in the calculations.

    Parameters:

    - `color1`: A color object.
    - `color2`: A color object.
    - `weight`: Optional, a percentage balance point between the two colors, defaults to 50%.

    Returns: `color`

    Example:

        mix(#ff0000, #0000ff, 50%)
        mix(rgba(100,0,0,1.0), rgba(0,100,0,0.5), 50%)

    Output:

        #800080
        rgba(75, 25, 0, 0.75)

    \+ ➜
- name: Mixins
  id: index#mixins-feature
  summary: You can mix-in class selectors and id selectors, e.g
  description: "## Mixins\n\n\"mix-in\" properties from existing styles\n\nYou can mix-in class selectors and id selectors, e.g.\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      .a();\n    }\n    .mixin-id {\n      #b();\n    }\n\nwhich results in:\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      color: red;\n    }\n    .mixin-id {\n      color: red;\n    }\n\nHistorically, the parentheses in a mixin call are optional, but optional parentheses are deprecated and will be required in a future release.\n\n    .a(); \n    .a;    // currently works, but deprecated; don't use\n    .a (); // white-space before parentheses is also deprecated\n\n### Mixins With Parentheses\n\nIf you want to create a mixin but you do not want that mixin to be in your CSS output, put parentheses after the mixin definition.\n\n    .my-mixin {\n      color: black;\n    }\n    .my-other-mixin() {\n      background: white;\n    }\n    .class {\n      .my-mixin();\n      .my-other-mixin();\n    }\n\noutputs\n\n    .my-mixin {\n      color: black;\n    }\n    .class {\n      color: black;\n      background: white;\n    }\n\n### Selectors in Mixins\n\nMixins can contain more than just properties, they can contain selectors too.\n\nFor example:\n\n    .my-hover-mixin() {\n      &:hover {\n        border: 1px solid red;\n      }\n    }\n    button {\n      .my-hover-mixin();\n    }\n\nOutputs\n\n    button:hover {\n      border: 1px solid red;\n    }\n\n### Namespaces\n\nIf you want to mixin properties inside a more complicated selector, you can stack up multiple ids or classes.\n\n    #outer() {\n      .inner {\n        color: red;\n      }\n    }\n\n    .c {\n      #outer.inner();\n    }\n\nNote: legacy Less syntax allows `>` and whitespace between namespaces and mixins. This syntax is deprecated and may be removed. Currently, these do the same thing.\n\n    #outer > .inner(); // deprecated\n    #outer .inner();   // deprecated\n    #outer.inner();    // preferred\n\nNamespacing your mixins like this reduces conflicts with other library mixins or user mixins, but can also be a way to \"organize\" groups of mixins.\n\nExample:\n\n    #my-library {\n      .my-mixin() {\n        color: black;\n      }\n    }\n    // which can be used like this\n    .class {\n      #my-library.my-mixin();\n    }\n\n### Guarded Namespaces\n\nIf a namespace has a guard, mixins defined by it are used only if the guard condition returns true. A namespace guard is evaluated exactly the same as a guard on a mixin, so the following two mixins work the same way:\n\n    #namespace when (@mode = huge) {\n      .mixin() { /* */ }\n    }\n\n    #namespace {\n      .mixin() when (@mode = huge) { /* */ }\n    }\n\nThe `default` function is assumed to have the same value for all nested namespaces and mixin. The following mixin is never evaluated; one of its guards is guaranteed to be false:\n\n    #sp_1 when (default()) {\n      #sp_2 when (default()) {\n        .mixin() when not(default()) { /* */ }\n      }\n    }\n\n### The `!important` keyword\n\nUse the `!important` keyword after mixin call to mark all properties inherited by it as `!important`:\n\nExample:\n\n    .foo (@bg: #f5f5f5; @color: #900) {\n      background: @bg;\n      color: @color;\n    }\n    .unimportant {\n      .foo();\n    }\n    .important {\n      .foo() !important;\n    }\n\nResults in:\n\n    .unimportant {\n      background: #f5f5f5;\n      color: #900;\n    }\n    .important {\n      background: #f5f5f5 !important;\n      color: #900 !important;\n    }\n\n### Parametric Mixins\n\nHow to pass arguments to mixins\n\nMixins can also take arguments, which are variables passed to the block of selectors when it is mixed in.\n\nFor example:\n\n    .border-radius(@radius) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nAnd here's how we can mix it into various rulesets:\n\n    #header {\n      .border-radius(4px);\n    }\n    .button {\n      .border-radius(6px);\n    }\n\nParametric mixins can also have default values for their parameters:\n\n    .border-radius(@radius: 5px) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nWe can invoke it like this now:\n\n    #header {\n      .border-radius();\n    }\n\nAnd it will include a 5px border-radius.\n\nYou can also use parametric mixins which don't take parameters. This is useful if you want to hide the ruleset from the CSS output, but want to include its properties in other rulesets:\n\n    .wrap() {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n    pre { .wrap() }\n\nWhich would output:\n\n    pre {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n### Parameter separators\n\nParameters are currently either *semicolon* or *comma* separated.\n\nOriginally, parameters were only separated by commas, but the semi-colon was later added to support passing comma-separated list values to single arguments.\n\n- two arguments and each contains comma separated list: `.name(1, 2, 3; something, else)`,\n- three arguments and each contains one number: `.name(1, 2, 3)`,\n- use dummy semicolon to create mixin call with one argument containing comma separated css list: `.name(1, 2, 3;)`,\n- comma separated default value: `.name(@param1: red, blue;)`.\n- As of Less 4.0, you can wrap a list value using a paren escape \\[`~()`\\], e.g. `.name(@param1: ~(red, blue))`. This is similar to the quote escape syntax: `~\"quote\"`\n\n### Overloading mixins\n\nIt is legal to define multiple mixins with the same name and number of parameters. Less will use properties of all that can apply. If you used the mixin with one parameter e.g. `.mixin(green);`, then properties of all mixins with exactly one mandatory parameter will be used:\n\n    .mixin(@color) {\n      color-1: @color;\n    }\n    .mixin(@color, @padding: 2) {\n      color-2: @color;\n      padding-2: @padding;\n    }\n    .mixin(@color, @padding, @margin: 2) {\n      color-3: @color;\n      padding-3: @padding;\n      margin: @margin @margin @margin @margin;\n    }\n    .some .selector div {\n      .mixin(#008000);\n    }\n\ncompiles into:\n\n    .some .selector div {\n      color-1: #008000;\n      color-2: #008000;\n      padding-2: 2;\n    }\n\n### Named Parameters\n\nA mixin reference can supply parameters values by their names instead of just positions. Any parameter can be referenced by its name and they do not have to be in any special order:\n\n    .mixin(@color: black; @margin: 10px; @padding: 20px) {\n      color: @color;\n      margin: @margin;\n      padding: @padding;\n    }\n    .class1 {\n      .mixin(@margin: 20px; @color: #33acfe);\n    }\n    .class2 {\n      .mixin(#efca44; @padding: 40px);\n    }\n\ncompiles into:\n\n    .class1 {\n      color: #33acfe;\n      margin: 20px;\n      padding: 20px;\n    }\n    .class2 {\n      color: #efca44;\n      margin: 10px;\n      padding: 40px;\n    }\n\n### The `@arguments` Variable\n\n`@arguments` has a special meaning inside mixins, it contains all the arguments passed, when the mixin was called. This is useful if you don't want to deal with individual parameters:\n\n    .box-shadow(@x: 0, @y: 0, @blur: 1px, @color: #000) {\n      -webkit-box-shadow: @arguments;\n         -moz-box-shadow: @arguments;\n              box-shadow: @arguments;\n    }\n    .big-block {\n      .box-shadow(2px, 5px);\n    }\n\nWhich results in:\n\n    .big-block {\n      -webkit-box-shadow: 2px 5px 1px #000;\n         -moz-box-shadow: 2px 5px 1px #000;\n              box-shadow: 2px 5px 1px #000;\n    }\n\n### Advanced Arguments and the `@rest` Variable\n\nYou can use `...` if you want your mixin to take a variable number of arguments. Using this after a variable name will assign those arguments to the variable.\n\n    .mixin(...) {        // matches 0-N arguments\n    .mixin() {           // matches exactly 0 arguments\n    .mixin(@a: 1) {      // matches 0-1 arguments\n    .mixin(@a: 1, ...) { // matches 0-N arguments\n    .mixin(@a, ...) {    // matches 1-N arguments\n\nFurthermore:\n\n    .mixin(@a, @rest...) {\n       // @rest is bound to arguments after @a\n       // @arguments is bound to all arguments\n    }\n\n### Pattern-matching\n\nSometimes, you may want to change the behavior of a mixin, based on the parameters you pass to it. Let's start with something basic:\n\n    .mixin(@s, @color) { ... }\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nNow let's say we want `.mixin` to behave differently, based on the value of `@switch`, we could define `.mixin` as such:\n\n    .mixin(dark, @color) {\n      color: darken(@color, 10%);\n    }\n    .mixin(light, @color) {\n      color: lighten(@color, 10%);\n    }\n    .mixin(@_, @color) {\n      display: block;\n    }\n\nNow, if we run:\n\n    @switch: light;\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nWe will get the following CSS:\n\n    .class {\n      color: #a2a2a2;\n      display: block;\n    }\n\nWhere the color passed to `.mixin` was lightened. If the value of `@switch` was `dark`, the result would be a darker color.\n\nHere's what happened:\n\n- The first mixin definition didn't match because it expected `dark` as the first argument.\n- The second mixin definition matched, because it expected `light`.\n- The third mixin definition matched because it expected any value.\n\nOnly mixin definitions which matched were used. Variables match and bind to any value. Anything other than a variable matches only with a value equal to itself.\n\nWe can also match on arity, here's an example:\n\n    .mixin(@a) {\n      color: @a;\n    }\n    .mixin(@a, @b) {\n      color: fade(@a, @b);\n    }\n\nNow if we call `.mixin` with a single argument, we will get the output of the first definition, but if we call it with *two* arguments, we will get the second definition, namely `@a` faded to `@b`.\n\n### Using Mixins as Functions\n\nSelecting properties and variables from mixin calls\n\n### Property / value accessors\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors to select a value from an evaluated mixin's rules. This can allow you to use mixins similar to functions.\n\nExample:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its \"@result\" value\n      padding: .average(16px, 50px)[@result];\n    }\n\nResults in:\n\n    div {\n      padding: 33px;\n    }\n\n### Overriding mixin values\n\nIf you have multiple matching mixins, all rules are evaluated and merged, and the last matching value with that identifier is returned. This is similar to the cascade in CSS, and it allows you to \"override\" mixin values.\n\n    // library.less\n    #library() {\n      .mixin() {\n        prop: foo;\n      }\n    }\n\n    // customize.less\n    @import \"library\";\n    #library() {\n      .mixin() {\n        prop: bar;\n      }\n    }\n\n    .box {\n      my-value: #library.mixin[prop];\n    }\n\nOutputs:\n\n    .box {\n      my-value: bar;\n    }\n\n### Unnamed lookups\n\nIf you don't specify a lookup value in `[@lookup]` and instead write `[]` after a mixin or ruleset call, *all* values will cascade and the last declared value will be selected.\n\nMeaning: the averaging mixin from the above example could be written as:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its final value\n      padding: .average(16px, 50px)[];\n    }\n\nThe output is the same:\n\n    div {\n      padding: 33px;\n    }\n\nThe same cascading behavior is true for rulesets or variables aliased to mixin calls.\n\n    @dr: {\n      value: foo;\n    }\n    .box {\n      my-value: @dr[];\n    }\n\nThis outputs:\n\n    .box {\n      my-value: foo;\n    }\n\n### Unlocking mixins & variables into caller scope\n\n***DEPRECATED - Use Property / Value Accessors***\n\nVariables and mixins defined in a mixin are visible and can be used in caller's scope. There is only one exception: a variable is not copied if the caller contains a variable with the same name (that includes variables defined by another mixin call). Only variables present in callers local scope are protected. Variables inherited from parent scopes are overridden.\n\n*Note: this behavior is deprecated, and in the future, variables and mixins will not be merged into the caller scope in this way.*\n\nExample:\n\n    .mixin() {\n      @width:  100%;\n      @height: 200px;\n    }\n\n    .caller {\n      .mixin();\n      width:  @width;\n      height: @height;\n    }\n\nResults in:\n\n    .caller {\n      width:  100%;\n      height: 200px;\n    }\n\nVariables defined directly in callers scope cannot be overridden. However, variables defined in callers parent scope is not protected and will be overridden:\n\n    .mixin() {\n      @size: in-mixin;\n      @definedOnlyInMixin: in-mixin;\n    }\n\n    .class {\n      margin: @size @definedOnlyInMixin;\n      .mixin();\n    }\n\n    @size: globaly-defined-value; // callers parent scope - no protection\n\nResults in:\n\n    .class {\n      margin: in-mixin in-mixin;\n    }\n\nFinally, mixin defined in mixin acts as return value too:\n\n    .unlock(@value) { // outer mixin\n      .doSomething() { // nested mixin\n        declaration: @value;\n      }\n    }\n\n    #namespace {\n      .unlock(5); // unlock doSomething mixin\n      .doSomething(); //nested mixin was copied here and is usable\n    }\n\nResults in:\n\n    #namespace {\n      declaration: 5;\n    }\n\n### Recursive Mixins\n\nCreating loops\n\nIn Less a mixin can call itself. Such recursive mixins, when combined with [Guard Expressions](#mixin-guards-feature) and [Pattern Matching](#mixins-parametric-feature-pattern-matching), can be used to create various iterative/loop structures.\n\nExample:\n\n    .loop(@counter) when (@counter > 0) {\n      .loop((@counter - 1));    // next iteration\n      width: (10px * @counter); // code for each iteration\n    }\n\n    div {\n      .loop(5); // launch the loop\n    }\n\nOutput:\n\n    div {\n      width: 10px;\n      width: 20px;\n      width: 30px;\n      width: 40px;\n      width: 50px;\n    }\n\nA generic example of using a recursive loop to generate CSS grid classes:\n\n    .generate-columns(4);\n\n    .generate-columns(@n, @i: 1) when (@i =< @n) {\n      .column-@{i} {\n        width: (@i * 100% / @n);\n      }\n      .generate-columns(@n, (@i + 1));\n    }\n\nOutput:\n\n    .column-1 {\n      width: 25%;\n    }\n    .column-2 {\n      width: 50%;\n    }\n    .column-3 {\n      width: 75%;\n    }\n    .column-4 {\n      width: 100%;\n    }\n\n### Mixin Guards\n\nGuards are useful when you want to match on *expressions*, as opposed to simple values or arity. If you are familiar with functional programming, you have probably encountered them already.\n\nIn trying to stay as close as possible to the declarative nature of CSS, Less has opted to implement conditional execution via **guarded mixins** instead of `if`/`else` statements, in the vein of `@media` query feature specifications.\n\nLet's start with an example:\n\n    .mixin(@a) when (lightness(@a) >= 50%) {\n      background-color: black;\n    }\n    .mixin(@a) when (lightness(@a) < 50%) {\n      background-color: white;\n    }\n    .mixin(@a) {\n      color: @a;\n    }\n\nThe key is the `when` keyword, which introduces a guard sequence (here with only one guard). Now if we run the following code:\n\n    .class1 { .mixin(#ddd) }\n    .class2 { .mixin(#555) }\n\nHere's what we'll get:\n\n    .class1 {\n      background-color: black;\n      color: #ddd;\n    }\n    .class2 {\n      background-color: white;\n      color: #555;\n    }\n\n### Guard Comparison Operators\n\nThe full list of comparison operators usable in guards are: `>`, `>=`, `=`, `=<`, `<`. Additionally, the keyword `true` is the only truthy value, making these two mixins equivalent:\n\n    .truth(@a) when (@a) { ... }\n    .truth(@a) when (@a = true) { ... }\n\nAny value other than the keyword `true` is falsy:\n\n    .class {\n      .truth(40); // Will not match any of the above definitions.\n    }\n\nNote that you can also compare arguments with each other, or with non-arguments:\n\n    @media: mobile;\n\n    .mixin(@a) when (@media = mobile) { ... }\n    .mixin(@a) when (@media = desktop) { ... }\n\n    .max(@a; @b) when (@a > @b) { width: @a }\n    .max(@a; @b) when (@a < @b) { width: @b }\n\n### Guard Logical Operators\n\nYou can use logical operators with guards. The syntax is based on CSS media queries.\n\nUse the `and` keyword to combine guards:\n\n    .mixin(@a) when (isnumber(@a)) and (@a > 0) { ... }\n\nYou can emulate the *or* operator by separating guards with a comma `,`. If any of the guards evaluate to true, it's considered a match:\n\n    .mixin(@a) when (@a > 10), (@a < -10) { ... }\n\nUse the `not` keyword to negate conditions:\n\n    .mixin(@b) when not (@b > 0) { ... }\n\n### Type Checking Functions\n\nLastly, if you want to match mixins based on value type, you can use the `is` functions:\n\n    .mixin(@a; @b: 0) when (isnumber(@b)) { ... }\n    .mixin(@a; @b: black) when (iscolor(@b)) { ... }\n\nHere are the basic type checking functions:\n\n- `iscolor`\n- `isnumber`\n- `isstring`\n- `iskeyword`\n- `isurl`\n\nIf you want to check if a value is in a specific unit in addition to being a number, you may use one of:\n\n- `ispixel`\n- `ispercentage`\n- `isem`\n- `isunit`\n\n### Aliasing Mixins\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nAssigning mixin calls to a variable\n\nMixins can be assigned to a variable to be called as a variable call, or can be used for map lookup.\n\n    #theme.dark.navbar {\n      .colors(light) {\n        primary: purple;\n      }\n      .colors(dark) {\n        primary: black;\n        secondary: grey;\n      }\n    }\n\n    .navbar {\n      @colors: #theme.dark.navbar.colors(dark);\n      background: @colors[primary];\n      border: 1px solid @colors[secondary];\n    }\n\nThis would output:\n\n    .navbar {\n      background: black;\n      border: 1px solid grey;\n    }\n\n### Variable calls\n\nEntire mixin calls can be aliased and called as variable calls. As in:\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors();\n      @alias();\n    }\n\nOutputs:\n\n    .box {\n      background: green;\n    }\n\nNote, unlike mixins used in root, mixin calls assigned to variables and *called with no arguments* always require parentheses. The following is not valid.\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors;\n      @alias();   // ERROR: Could not evaluate variable call @alias\n    }\n\nThis is because it's ambiguous if variable is assigned a list of selectors or a mixin call. For example, in Less 3.5+, this variable could be used this way.\n\n    .box {\n      @alias: #library.colors;\n      @{alias} {\n        a: b;\n      }\n    }\n\nThe above would output:\n\n    .box #library.colors {\n      a: b;\n    }"
- name: mod
  id: functions#math-functions-mod
  summary: Returns the value of the first argument modulus second argument
  belongs_to: Logical Functions
  description: |-
    ### mod

    Returns the value of the first argument modulus second argument.

    Returned value has the same dimension as the first parameter, the dimension of the second parameter is ignored. The function is able to handle also negative and floating point numbers.

    Parameters:

    - `number`: a floating point number.
    - `number`: a floating point number.

    Returns: `number`

    Example:

        mod(0cm, 0px)
        mod(11cm, 6px);
        mod(-26%, -5);

    Output:

        NaNcm;
        5cm
        -1%;
- name: multiply
  id: functions#color-blending-multiply
  summary: Multiply two colors
  belongs_to: Logical Functions
  description: |-
    ### multiply

    Multiply two colors. Corresponding RGB channels from each of the two colors are multiplied together then divided by 255. The result is a darker color.

    Parameters:

    - `color1`: A color object.
    - `color2`: A color object.

    Returns: `color`

    **Examples**:

        multiply(#ff6600, #000000);

        multiply(#ff6600, #333333);

        multiply(#ff6600, #666666);

        multiply(#ff6600, #999999);

        multiply(#ff6600, #cccccc);

        multiply(#ff6600, #ffffff);

        multiply(#ff6600, #ff0000);

        multiply(#ff6600, #00ff00);

        multiply(#ff6600, #0000ff);
- name: negation
  id: functions#color-blending-negation
  summary: Do the opposite effect to difference
  belongs_to: Logical Functions
  description: "### negation\n\nDo the opposite effect to `difference`.\n\nThe result is a brighter color. **Note**: The *opposite* effect doesn't mean the *inverted* effect as resulting from an *addition* operation.\n\nParameters:\n\n- `color1`: A color object to act as the minuend.\n- `color2`: A color object to act as the subtrahend.\n\nReturns: `color`\n\nExample:\n\n    negation(#ff6600, #000000);\n\n    negation(#ff6600, #333333);\n\n    negation(#ff6600, #666666);\n\n    negation(#ff6600, #999999);\n\n    negation(#ff6600, #cccccc);\n\n    negation(#ff6600, #ffffff);\n\n    negation(#ff6600, #ff0000);\n\n    negation(#ff6600, #00ff00);\n\n    negation(#ff6600, #0000ff);\n\n© 2009–2020 The Core Less Team  \nLicensed under the Creative Commons Attribution License 3.0.  \n[http://lesscss.org/functions](http://lesscss.org/functions)"
- name: overlay
  id: functions#color-blending-overlay
  summary: Combines the effects of both multiply and screen
  belongs_to: Logical Functions
  description: |-
    ### overlay

    Combines the effects of both `multiply` and `screen`. Conditionally make light channels lighter and dark channels darker. **Note**: The results of the conditions are determined by the first color parameter.

    Parameters:

    - `color1`: A base color object. Also the determinant color to make the result lighter or darker.
    - `color2`: A color object to *overlay*.

    Returns: `color`

    Example:

        overlay(#ff6600, #000000);

        overlay(#ff6600, #333333);

        overlay(#ff6600, #666666);

        overlay(#ff6600, #999999);

        overlay(#ff6600, #cccccc);

        overlay(#ff6600, #ffffff);

        overlay(#ff6600, #ff0000);

        overlay(#ff6600, #00ff00);

        overlay(#ff6600, #0000ff);
- name: Parent Selectors
  id: index#parent-selectors-feature
  summary: Notice that without the &, the above example would result in a :hover rule (a descendant selector that matches hovered elements inside of <a> tags) and this is not what we typically would want with the nested :hover
  description: |-
    ## Parent Selectors

    Referencing parent selectors with `&`

    The `&` operator represents the parent selectors of a [nested rule](#features-overview-feature-nested-rules) and is most commonly used when applying a modifying class or pseudo-class to an existing selector:

        a {
          color: blue;
          &:hover {
            color: green;
          }
        }

    results in:

        a {
          color: blue;
        }

        a:hover {
          color: green;
        }

    Notice that without the `&`, the above example would result in `a :hover` rule (a descendant selector that matches hovered elements inside of `<a>` tags) and this is not what we typically would want with the nested `:hover`.

    The "parent selectors" operator has a variety of uses. Basically any time you need the selectors of the nested rules to be combined in other ways than the default. For example another typical use of the `&` is to produce repetitive class names:

        .button {
          &-ok {
            background-image: url("ok.png");
          }
          &-cancel {
            background-image: url("cancel.png");
          }

          &-custom {
            background-image: url("custom.png");
          }
        }

    output:

        .button-ok {
          background-image: url("ok.png");
        }
        .button-cancel {
          background-image: url("cancel.png");
        }
        .button-custom {
          background-image: url("custom.png");
        }

    ### Multiple `&`

    `&` may appear more than once within a selector. This makes it possible to repeatedly refer to a parent selector without repeating its name.

        .link {
          & + & {
            color: red;
          }

          & & {
            color: green;
          }

          && {
            color: blue;
          }

          &, &ish {
            color: cyan;
          }
        }

    will output:

        .link + .link {
          color: red;
        }
        .link .link {
          color: green;
        }
        .link.link {
          color: blue;
        }
        .link, .linkish {
          color: cyan;
        }

    Note that `&` represents all parent selectors (not just the nearest ancestor) so the following example:

        .grand {
          .parent {
            & > & {
              color: red;
            }

            & & {
              color: green;
            }

            && {
              color: blue;
            }

            &, &ish {
              color: cyan;
            }
          }
        }

    results in:

        .grand .parent > .grand .parent {
          color: red;
        }
        .grand .parent .grand .parent {
          color: green;
        }
        .grand .parent.grand .parent {
          color: blue;
        }
        .grand .parent,
        .grand .parentish {
          color: cyan;
        }

    ### Changing Selector Order

    It can be useful to prepend a selector to the inherited (parent) selectors. This can be done by putting the `&` after current selector. For example, when using Modernizr, you might want to specify different rules based on supported features:

        .header {
          .menu {
            border-radius: 5px;
            .no-borderradius & {
              background-image: url('images/button-background.png');
            }
          }
        }

    The selector `.no-borderradius &` will prepend `.no-borderradius` to its parent `.header .menu` to form the`.no-borderradius .header .menu` on output:

        .header .menu {
          border-radius: 5px;
        }
        .no-borderradius .header .menu {
          background-image: url('images/button-background.png');
        }

    ### Combinatorial Explosion

    `&` can also be used to generate every possible permutation of selectors in a comma separated list:

        p, a, ul, li {
          border-top: 2px dotted #366;
          & + & {
            border-top: 0;
          }
        }

    This expands to all possible (16) combinations of the specified elements:

        p,
        a,
        ul,
        li {
          border-top: 2px dotted #366;
        }
        p + p,
        p + a,
        p + ul,
        p + li,
        a + p,
        a + a,
        a + ul,
        a + li,
        ul + p,
        ul + a,
        ul + ul,
        ul + li,
        li + p,
        li + a,
        li + ul,
        li + li {
          border-top: 0;
        }
- name: percentage
  id: functions#math-functions-percentage
  summary: Converts a floating point number into a percentage string
  belongs_to: Logical Functions
  description: |-
    ### percentage

    Converts a floating point number into a percentage string.

    Parameters: `number` - a floating point number.

    Returns: `number`

    Example: `percentage(0.5)`

    Output: `50%`
- name: pi
  id: functions#math-functions-pi
  summary: null
  belongs_to: Logical Functions
  description: |-
    ### pi

    Returns π (pi);

    Parameters: `none`

    Returns: `number`

    Example:

        pi()

    Output:

        3.141592653589793
- name: pow
  id: functions#math-functions-pow
  summary: Returns the value of the first argument raised to the power of the second argument
  belongs_to: Logical Functions
  description: |-
    ### pow

    Returns the value of the first argument raised to the power of the second argument.

    Returned value has the same dimension as the first parameter and the dimension of the second parameter is ignored.

    Parameters:

    - `number`: base -a floating point number.
    - `number`: exponent - a floating point number.

    Returns: `number`

    Example:

        pow(0cm, 0px)
        pow(25, -2)
        pow(25, 0.5)
        pow(-25, 0.5)
        pow(-25%, -0.5)

    Output:

        1cm
        0.0016
        5
        NaN
        NaN%
- name: range
  id: functions#list-functions-range
  summary: The output of each value in the range will be the same unit as the end value
  belongs_to: Logical Functions
  description: |-
    ### range

    *Released v3.9.0*

    Generate a list spanning a range of values

    **Parameters**

    - `start` - (optional) The start value *e.g. 1 or 1px*
    - `end` - The end value *e.g. 5px*
    - `step` - (optional) The amount to increment by

    Examples:

        value: range(4);

    Outputs:

        value: 1 2 3 4;

    The output of each value in the range will be the same unit as the `end` value. For example:

        value: range(10px, 30px, 10);

    Outputs:

        value: 10px 20px 30px;
- name: red
  id: functions#color-channel-red
  summary: Extracts the red channel of a color object
  belongs_to: Logical Functions
  description: |-
    ### red

    Extracts the red channel of a color object.

    Parameters: `color` - a color object.

    Returns: `float` 0-255

    Example: `red(rgb(10, 20, 30))`

    Output: `10`
- name: replace
  id: functions#string-functions-replace
  summary: Replaces a text within a string
  belongs_to: Logical Functions
  description: |-
    ### replace

    Replaces a text within a string.

    Released [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)

    Parameters:

    - `string`: The string to search and replace in.
    - `pattern`: A string or regular expression pattern to search for.
    - `replacement`: The string to replace the matched pattern with.
    - `flags`: (Optional) regular expression flags.

    Returns: a string with the replaced values.

    Example:

        replace("Hello, Mars?", "Mars\?", "Earth!");
        replace("One + one = 4", "one", "2", "gi");
        replace('This is a string.', "(string)\.$", "new $1.");
        replace(~"bar-1", '1', '2');

    Result:

        "Hello, Earth!";
        "2 + 2 = 4";
        'This is a new string.';
        bar-2;

    ## List Functions
- name: rgb
  id: functions#color-definition-rgb
  summary: Creates an opaque color object from decimal red, green and blue (RGB) values
  belongs_to: Logical Functions
  description: |-
    ### rgb

    Creates an opaque color object from decimal red, green and blue (RGB) values.

    Literal color values in standard HTML/CSS formats may also be used to define colors, for example `#ff0000`.

    Parameters:

    - `red`: An integer 0-255 or percentage 0-100%.
    - `green`: An integer 0-255 or percentage 0-100%.
    - `blue`: An integer 0-255 or percentage 0-100%.

    Returns: `color`

    Example: `rgb(90, 129, 32)`

    Output: `#5a8120`
- name: rgba
  id: functions#color-definition-rgba
  summary: Creates a transparent color object from decimal red, green, blue and alpha (RGBA) values
  belongs_to: Logical Functions
  description: |-
    ### rgba

    Creates a transparent color object from decimal red, green, blue and alpha (RGBA) values.

    Parameters:

    - `red`: An integer 0-255 or percentage 0-100%.
    - `green`: An integer 0-255 or percentage 0-100%.
    - `blue`: An integer 0-255 or percentage 0-100%.
    - `alpha`: A number 0-1 or percentage 0-100%.

    Returns: `color`

    Example: `rgba(90, 129, 32, 0.5)`

    Output: `rgba(90, 129, 32, 0.5)`
- name: round
  id: functions#math-functions-round
  summary: Applies rounding
  belongs_to: Logical Functions
  description: |-
    ### round

    Applies rounding.

    Parameters:

    - `number`: A floating point number.
    - `decimalPlaces`: Optional: The number of decimal places to round to. Defaults to 0.

    Returns: `number`

    Example: `round(1.67)`

    Output: `2`

    Example: `round(1.67, 1)`

    Output: `1.7`
- name: saturate
  id: functions#color-operations-saturate
  summary: Increase the saturation of a color in the HSL color space by an absolute amount
  belongs_to: Logical Functions
  description: |-
    ### saturate

    Increase the saturation of a color in the HSL color space by an absolute amount.

    Parameters:

    - `color`: A color object.
    - `amount`: A percentage 0-100%.
    - `method`: Optional, set to `relative` for the adjustment to be relative to the current value.

    Returns: `color`

    Example: `saturate(hsl(90, 80%, 50%), 20%)`

    Output: `#80ff00 // hsl(90, 100%, 50%)`

    ➜
- name: saturation
  id: functions#color-channel-saturation
  summary: Extracts the saturation channel of a color object in the HSL color space
  belongs_to: Logical Functions
  description: |-
    ### saturation

    Extracts the saturation channel of a color object in the HSL color space.

    Parameters: `color` - a color object.

    Returns: `percentage` 0-100

    Example: `saturation(hsl(90, 100%, 50%))`

    Output: `100%`
- name: screen
  id: functions#color-blending-screen
  summary: Do the opposite of multiply
  belongs_to: Logical Functions
  description: |-
    ### screen

    Do the opposite of `multiply`. The result is a brighter color.

    Parameters:

    - `color1`: A color object.
    - `color2`: A color object.

    Returns: `color`

    Example:

        screen(#ff6600, #000000);

        screen(#ff6600, #333333);

        screen(#ff6600, #666666);

        screen(#ff6600, #999999);

        screen(#ff6600, #cccccc);

        screen(#ff6600, #ffffff);

        screen(#ff6600, #ff0000);

        screen(#ff6600, #00ff00);

        screen(#ff6600, #0000ff);
- name: Setting variable names in each()
  id: functions#list-functions-setting-variable-names-in-each-
  summary: You don't have to use @value, @key, and @index in your each() function
  belongs_to: Logical Functions
  description: |-
    ### Setting variable names in `each()`

    You don't have to use `@value`, `@key`, and `@index` in your `each()` function. In Less 3.7, with the `each()` function, Less is introducing the concept of anonymous mixins, which may expand to other parts of the syntax at a later date.

    An anonymous mixin uses the form of `#()` or `.()` starting with `.` or `#` just like a regular mixin would. In `each()`, you can use it like this:

        .set-2() {
          one: blue;
          two: green;
          three: red;
        }
        .set-2 {
          // Call mixin and iterate each rule
          each(.set-2(), .(@v, @k, @i) {
            @{k}-@{i}: @v;
          });
        }

    This outputs, as expected:

        .set-2 {
          one-1: blue;
          two-2: green;
          three-3: red;
        }

    The `each()` function will take the variable names defined in the anonymous mixin and bind them to the `@value`, `@key` and `@index` values, in that order. If you only write `each(@list, #(@value) {})`, then neither `@key` nor `@index` will be defined.
- name: shade
  id: functions#color-operations-shade
  summary: Mix color with black in variable proportion
  belongs_to: Logical Functions
  description: "### shade\n\nMix color with black in variable proportion. It is the same as calling `mix(#000000, @color, @weight)`\n\nParameters:\n\n- `color`: A color object.\n- `weight`: Optional, a percentage balance point between color and black, defaults to 50%.\n\nReturns: `color`\n\nExample:\n\n    no-alpha: shade(#007fff, 50%); \n    with-alpha: shade(rgba(00,0,255,0.5), 50%); \n\nOutput:\n\n    no-alpha: #004080;\n    with-alpha: rgba(0, 0, 64, 0.75);\n\n➜"
- name: sin
  id: functions#math-functions-sin
  summary: Calculates sine function
  belongs_to: Logical Functions
  description: |-
    ### sin

    Calculates sine function.

    Assumes radians on numbers without units.

    Parameters: `number` - a floating point number.

    Returns: `number`

    Example:

        sin(1); // sine of 1 radian
        sin(1deg); // sine of 1 degree
        sin(1grad); // sine of 1 gradian

    Output:

        0.8414709848078965; // sine of 1 radian
        0.01745240643728351; // sine of 1 degree
        0.015707317311820675; // sine of 1 gradian
- name: softlight
  id: functions#color-blending-softlight
  summary: Similar to overlay but avoids pure black resulting in pure black, and pure white resulting in pure white
  belongs_to: Logical Functions
  description: |-
    ### softlight

    Similar to `overlay` but avoids pure black resulting in pure black, and pure white resulting in pure white.

    Parameters:

    - `color1`: A color object to *soft light* another.
    - `color2`: A color object to be *soft lighten*.

    Returns: `color`

    Example:

        softlight(#ff6600, #000000);

        softlight(#ff6600, #333333);

        softlight(#ff6600, #666666);

        softlight(#ff6600, #999999);

        softlight(#ff6600, #cccccc);

        softlight(#ff6600, #ffffff);

        softlight(#ff6600, #ff0000);

        softlight(#ff6600, #00ff00);

        softlight(#ff6600, #0000ff);
- name: spin
  id: functions#color-operations-spin
  summary: Rotate the hue angle of a color in either direction
  belongs_to: Logical Functions
  description: |-
    ### spin

    Rotate the hue angle of a color in either direction.

    While the angle range is 0-360, it applies a mod 360 operation, so you can pass in much larger (or negative) values and they will wrap around e.g. angles of 360 and 720 will produce the same result. Note that colors are passed through an RGB conversion, which doesn't retain hue value for greys (because hue has no meaning when there is no saturation), so make sure you apply functions in a way that preserves hue, for example don't do this:

        @c: saturate(spin(#aaaaaa, 10), 10%);

    Do this instead:

        @c: spin(saturate(#aaaaaa, 10%), 10);

    Colors are always returned as RGB values, so applying `spin` to a grey value will do nothing.

    Parameters:

    - `color`: A color object.
    - `angle`: A number of degrees to rotate (+ or -).

    Returns: `color`

    Example:

        spin(hsl(10, 90%, 50%), 30)
        spin(hsl(10, 90%, 50%), -30)

    Output:

        #f2a60d // hsl(40, 90%, 50%)
        #f20d59 // hsl(340, 90%, 50%)

    ➜

    ➜
- name: sqrt
  id: functions#math-functions-sqrt
  summary: Calculates square root of a number
  belongs_to: Logical Functions
  description: |-
    ### sqrt

    Calculates square root of a number. Keeps units as they are.

    Parameters: `number` - floating point number.

    Returns: `number`

    Example:

        sqrt(25cm)

    Output:

        5cm

    Example:

        sqrt(18.6%)

    Output:

        4.312771730569565%;
- name: svg-gradient
  id: functions#misc-functions-svg-gradient
  summary: Generates multi-stop svg gradients
  belongs_to: Logical Functions
  description: |-
    ### svg-gradient

    Generates multi-stop svg gradients.

    Svg-gradient function generates multi-stop svg gradients. It must have at least three parameters. First parameter specifies gradient type and direction and remaining parameters list colors and their positions. The position of first and last specified color are optional, remaining colors must have positions specified.

    The direction must be one of `to bottom`, `to right`, `to bottom right`, `to top right`, `ellipse` or `ellipse at center`. The direction can be specified as both escaped value `~'to bottom'` and space separated list of words `to bottom`.

    The direction must be followed by two or more color stops. They can be supplied either inside a list or you can specify each color stops in separate argument.

    Parameters - colors stops in list:

    - `escaped value` or `list of identifiers`: direction
    - `list` - all colors and their positions in list

    Parameters - color stops in arguments:

    - `escaped value` or `list of identifiers`: direction
    - `color [percentage]` pair: first color and its relative position (position is optional)
    - `color percent` pair: (optional) second color and its relative position
    - ...
    - `color percent` pair: (optional) n-th color and its relative position
    - `color [percentage]` pair: last color and its relative position (position is optional)

    Returns: `url` with "URI-Encoded" svg gradient.

    Example - colors stops in list:

        div {
          @list: red, green 30%, blue;
          background-image: svg-gradient(to right, @list);
        }

    equivalent - color stops in arguments:

        div {
          background-image: svg-gradient(to right, red, green 30%, blue);
        }

    both result in:

        div {
          background-image: url('data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20version%3D%221.1%22%20width%3D%22100%25%22%20height%3D%22100%25%22%20viewBox%3D%220%200%201%201%22%20preserveAspectRatio%3D%22none%22%3E%3ClinearGradient%20id%3D%22gradient%22%20gradientUnits%3D%22userSpaceOnUse%22%20x1%3D%220%25%22%20y1%3D%220%25%22%20x2%3D%22100%25%22%20y2%3D%220%25%22%3E%3Cstop%20offset%3D%220%25%22%20stop-color%3D%22%23ff0000%22%2F%3E%3Cstop%20offset%3D%2230%25%22%20stop-color%3D%22%23008000%22%2F%3E%3Cstop%20offset%3D%22100%25%22%20stop-color%3D%22%230000ff%22%2F%3E%3C%2FlinearGradient%3E%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%221%22%20height%3D%221%22%20fill%3D%22url(%23gradient)%22%20%2F%3E%3C%2Fsvg%3E');
        }

    Note: in versions before 2.2.0 the result is `base64` encoded .

    Generated background image has red color on the left, green at 30% of its width and ends with a blue color. Base64 encoded part contains following svg-gradient:

        <?xml version="1.0" ?>
        <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" viewBox="0 0 1 1" preserveAspectRatio="none">
            <linearGradient id="gradient" gradientUnits="userSpaceOnUse" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" stop-color="#ff0000"/>
                <stop offset="30%" stop-color="#008000"/>
                <stop offset="100%" stop-color="#0000ff"/>
            </linearGradient>
            <rect x="0" y="0" width="1" height="1" fill="url(#gradient)" />
        </svg>

    ## Color Definition Functions
- name: tan
  id: functions#math-functions-tan
  summary: Calculates tangent function
  belongs_to: Logical Functions
  description: |-
    ### tan

    Calculates tangent function.

    Assumes radians on numbers without units.

    Parameters: `number` - a floating point number.

    Returns: `number`

    Example:

        tan(1) // tangent of 1 radian
        tan(1deg) // tangent of 1 degree
        tan(1grad) // tangent of 1 gradian

    Output:

        1.5574077246549023   // tangent of 1 radian
        0.017455064928217585 // tangent of 1 degree
        0.015709255323664916 // tangent of 1 gradian
- name: tint
  id: functions#color-operations-tint
  summary: Mix color with white in variable proportion
  belongs_to: Logical Functions
  description: "### tint\n\nMix color with white in variable proportion. It is the same as calling `mix(#ffffff, @color, @weight)`\n\nParameters:\n\n- `color`: A color object.\n- `weight`: Optional, a percentage balance point between color and white, defaults to 50%.\n\nReturns: `color`\n\nExample:\n\n    no-alpha: tint(#007fff, 50%); \n    with-alpha: tint(rgba(00,0,255,0.5), 50%); \n\nOutput:\n\n    no-alpha: #80bfff;\n    with-alpha: rgba(191, 191, 255, 0.75);\n\n➜"
- name: unit
  id: functions#misc-functions-unit
  summary: See convert for changing the unit with conversion
  belongs_to: Logical Functions
  description: |-
    ### unit

    Remove or change the unit of a dimension

    Parameters:

    - `dimension`: A number, with or without a dimension.
    - `unit`: (Optional) the unit to change to, or if omitted it will remove the unit.

    See [convert](#misc-functions-convert) for changing the unit with conversion.

    Example: `unit(5, px)`

    Output: `5px`

    Example: `unit(5em)`

    Output: `5`
- name: url()
  id: index#variables-feature-urls
  summary: Note that before v2.0.0, only variables which have been declared in the root or current scope were considered and that only the current file and calling files were considered when looking for a variable
  description: |-
    ### URLs

        // Variables
        @images: "../img";

        // Usage
        body {
          color: #444;
          background: url("@{images}/white-sand.png");
        }

    ### Import Statements

    *v1.4.0*

    Syntax: `@import "@{themes}/tidal-wave.less";`

    Note that before v2.0.0, only variables which have been declared in the root or current scope were considered and that only the current file and calling files were considered when looking for a variable.

    Example:

        // Variables
        @themes: "../../src/themes";

        // Usage
        @import "@{themes}/tidal-wave.less";
- name: when
  id: index#mixin-guards-feature
  summary: An in-depth guide to features of the LESS language
  description: "# Less\n\n## Overview\n\nAn in-depth guide to features of the LESS language. See the [Overview](http://lesscss.org/#overview) for a quick summary of Less.\n\n*For an in-depth guide to installing and setting up a Less environment, as well as documentation on developing for Less, see: [Using Less.js](usage).*\n\n## Variables\n\nControl commonly used values in a single location.\n\n### Overview\n\nIt's not uncommon to see the same value repeated dozens *if not hundreds of times* across your stylesheets:\n\n    a,\n    .link {\n      color: #428bca;\n    }\n    .widget {\n      color: #fff;\n      background: #428bca;\n    }\n\nVariables make your code easier to maintain by giving you a way to control those values from a single location:\n\n    // Variables\n    @link-color:        #428bca; // sea blue\n    @link-color-hover:  darken(@link-color, 10%);\n\n    // Usage\n    a,\n    .link {\n      color: @link-color;\n    }\n    a:hover {\n      color: @link-color-hover;\n    }\n    .widget {\n      color: #fff;\n      background: @link-color;\n    }\n\n### Variable Interpolation\n\nThe examples above focused on using variables to control *values in CSS rules*, but they can also be used in other places as well, such as selector names, property names, URLs and `@import` statements.\n\n### Selectors\n\n*v1.4.0*\n\n    // Variables\n    @my-selector: banner;\n\n    // Usage\n    .@{my-selector} {\n      font-weight: bold;\n      line-height: 40px;\n      margin: 0 auto;\n    }\n\nCompiles to:\n\n    .banner {\n      font-weight: bold;\n      line-height: 40px;\n      margin: 0 auto;\n    }\n\n### URLs\n\n    // Variables\n    @images: \"../img\";\n\n    // Usage\n    body {\n      color: #444;\n      background: url(\"@{images}/white-sand.png\");\n    }\n\n### Import Statements\n\n*v1.4.0*\n\nSyntax: `@import \"@{themes}/tidal-wave.less\";`\n\nNote that before v2.0.0, only variables which have been declared in the root or current scope were considered and that only the current file and calling files were considered when looking for a variable.\n\nExample:\n\n    // Variables\n    @themes: \"../../src/themes\";\n\n    // Usage\n    @import \"@{themes}/tidal-wave.less\";\n\n### Properties\n\n*v1.6.0*\n\n    @property: color;\n\n    .widget {\n      @{property}: #0ee;\n      background-@{property}: #999;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #0ee;\n      background-color: #999;\n    }\n\n### Variable Variables\n\nIn Less, you can define a variable's name using another variable.\n\n    @primary:  green;\n    @secondary: blue;\n\n    .section {\n      @color: primary;\n\n      .element {\n        color: @@color;\n      }\n    }\n\nWhich compiles to:\n\n    .section .element {\n      color: green;\n    }\n\n### Lazy Evaluation\n\nVariables do not have to be declared before being used.\n\nValid Less snippet:\n\n    .lazy-eval {\n      width: @var;\n    }\n\n    @var: @a;\n    @a: 9%;\n\nthis is valid Less too:\n\n    .lazy-eval {\n      width: @var;\n      @a: 9%;\n    }\n\n    @var: @a;\n    @a: 100%;\n\nboth compile into:\n\n    .lazy-eval {\n      width: 9%;\n    }\n\nWhen defining a variable twice, the last definition of the variable is used, searching from the current scope upwards. This is similar to css itself where the last property inside a definition is used to determine the value.\n\nFor instance:\n\n    @var: 0;\n    .class {\n      @var: 1;\n      .brass {\n        @var: 2;\n        three: @var;\n        @var: 3;\n      }\n      one: @var;\n    }\n\nCompiles to:\n\n    .class {\n      one: 1;\n    }\n    .class .brass {\n      three: 3;\n    }\n\nEssentially, each scope has a \"final\" value, similar to properties in the browser, like this example using custom properties:\n\n    .header {\n      --color: white;\n      color: var(--color);  // the color is black\n      --color: black;\n    }\n\nThis means that, unlike other CSS pre-processing languages, Less variables behave very much like CSS's.\n\n### Properties as Variables **(NEW!)**\n\n*v3.0.0*\n\nYou can easily treat properties like variables using the `$prop` syntax. Sometimes this can make your code a little lighter.\n\n    .widget {\n      color: #efefef;\n      background-color: $color;\n    }\n\nCompiles to:\n\n    .widget {\n      color: #efefef;\n      background-color: #efefef;\n    }\n\nNote that, like variables, Less will choose the last property within the current/parent scope as being the \"final\" value.\n\n    .block {\n      color: red; \n      .inner {\n        background-color: $color; \n      }\n      color: blue;  \n    } \n\nCompiles to:\n\n    .block {\n      color: red; \n      color: blue;  \n    } \n    .block .inner {\n      background-color: blue; \n    }\n\n### Default Variables\n\nWe sometimes get requests for default variables - an ability to set a variable only if it is not already set. This feature is not required because you can easily override a variable by putting the definition afterwards.\n\nFor instance:\n\n    // library\n    @base-color: green;\n    @dark-color: darken(@base-color, 10%);\n\n    // use of library\n    @import \"library.less\";\n    @base-color: red;\n\nThis works fine because of [Lazy Loading](#variables-feature-lazy-loading) - `@base-color` is overridden and `@dark-color` is a dark red.\n\n## Parent Selectors\n\nReferencing parent selectors with `&`\n\nThe `&` operator represents the parent selectors of a [nested rule](#features-overview-feature-nested-rules) and is most commonly used when applying a modifying class or pseudo-class to an existing selector:\n\n    a {\n      color: blue;\n      &:hover {\n        color: green;\n      }\n    }\n\nresults in:\n\n    a {\n      color: blue;\n    }\n\n    a:hover {\n      color: green;\n    }\n\nNotice that without the `&`, the above example would result in `a :hover` rule (a descendant selector that matches hovered elements inside of `<a>` tags) and this is not what we typically would want with the nested `:hover`.\n\nThe \"parent selectors\" operator has a variety of uses. Basically any time you need the selectors of the nested rules to be combined in other ways than the default. For example another typical use of the `&` is to produce repetitive class names:\n\n    .button {\n      &-ok {\n        background-image: url(\"ok.png\");\n      }\n      &-cancel {\n        background-image: url(\"cancel.png\");\n      }\n\n      &-custom {\n        background-image: url(\"custom.png\");\n      }\n    }\n\noutput:\n\n    .button-ok {\n      background-image: url(\"ok.png\");\n    }\n    .button-cancel {\n      background-image: url(\"cancel.png\");\n    }\n    .button-custom {\n      background-image: url(\"custom.png\");\n    }\n\n### Multiple `&`\n\n`&` may appear more than once within a selector. This makes it possible to repeatedly refer to a parent selector without repeating its name.\n\n    .link {\n      & + & {\n        color: red;\n      }\n\n      & & {\n        color: green;\n      }\n\n      && {\n        color: blue;\n      }\n\n      &, &ish {\n        color: cyan;\n      }\n    }\n\nwill output:\n\n    .link + .link {\n      color: red;\n    }\n    .link .link {\n      color: green;\n    }\n    .link.link {\n      color: blue;\n    }\n    .link, .linkish {\n      color: cyan;\n    }\n\nNote that `&` represents all parent selectors (not just the nearest ancestor) so the following example:\n\n    .grand {\n      .parent {\n        & > & {\n          color: red;\n        }\n\n        & & {\n          color: green;\n        }\n\n        && {\n          color: blue;\n        }\n\n        &, &ish {\n          color: cyan;\n        }\n      }\n    }\n\nresults in:\n\n    .grand .parent > .grand .parent {\n      color: red;\n    }\n    .grand .parent .grand .parent {\n      color: green;\n    }\n    .grand .parent.grand .parent {\n      color: blue;\n    }\n    .grand .parent,\n    .grand .parentish {\n      color: cyan;\n    }\n\n### Changing Selector Order\n\nIt can be useful to prepend a selector to the inherited (parent) selectors. This can be done by putting the `&` after current selector. For example, when using Modernizr, you might want to specify different rules based on supported features:\n\n    .header {\n      .menu {\n        border-radius: 5px;\n        .no-borderradius & {\n          background-image: url('images/button-background.png');\n        }\n      }\n    }\n\nThe selector `.no-borderradius &` will prepend `.no-borderradius` to its parent `.header .menu` to form the`.no-borderradius .header .menu` on output:\n\n    .header .menu {\n      border-radius: 5px;\n    }\n    .no-borderradius .header .menu {\n      background-image: url('images/button-background.png');\n    }\n\n### Combinatorial Explosion\n\n`&` can also be used to generate every possible permutation of selectors in a comma separated list:\n\n    p, a, ul, li {\n      border-top: 2px dotted #366;\n      & + & {\n        border-top: 0;\n      }\n    }\n\nThis expands to all possible (16) combinations of the specified elements:\n\n    p,\n    a,\n    ul,\n    li {\n      border-top: 2px dotted #366;\n    }\n    p + p,\n    p + a,\n    p + ul,\n    p + li,\n    a + p,\n    a + a,\n    a + ul,\n    a + li,\n    ul + p,\n    ul + a,\n    ul + ul,\n    ul + li,\n    li + p,\n    li + a,\n    li + ul,\n    li + li {\n      border-top: 0;\n    }\n\n## Extend\n\nExtend is a Less pseudo-class which merges the selector it is put on with ones that match what it references.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\n    nav ul {\n      &:extend(.inline);\n      background: blue;\n    }\n\nIn the rule set above, the `:extend` selector will apply the \"extending selector\" (`nav ul`) onto the `.inline` class *wherever the `.inline` class appears*. The declaration block will be kept as-is, but without any reference to the extend (because extend isn't css).\n\nSo the following:\n\n    nav ul {\n      &:extend(.inline);\n      background: blue;\n    }\n    .inline {\n      color: red;\n    }\n\nOutputs\n\n    nav ul {\n      background: blue;\n    }\n    .inline,\n    nav ul {\n      color: red;\n    }\n\nNotice how the `nav ul:extend(.inline)` selector gets output as `nav ul` - the extend gets removed before output and the selector block left as-is. If no properties are put in that block then it gets removed from the output (but the extend still may affect other selectors).\n\n### Extend Syntax\n\nThe extend is either attached to a selector or placed into a ruleset. It looks like a pseudo-class with selector parameter optionally followed by the keyword `all`:\n\nExample:\n\n    .a:extend(.b) {}\n\n    // the above block does the same thing as the below block\n    .a {\n      &:extend(.b);\n    }\n\n    .c:extend(.d all) {\n      // extends all instances of \".d\" e.g. \".x.d\" or \".d.x\"\n    }\n    .c:extend(.d) {\n      // extends only instances where the selector will be output as just \".d\"\n    }\n\nIt can contain one or more classes to extend, separated by commas.\n\nExample:\n\n    .e:extend(.f) {}\n    .e:extend(.g) {}\n\n    // the above and the below do the same thing\n    .e:extend(.f, .g) {}\n\n### Extend Attached to Selector\n\nExtend attached to a selector looks like an ordinary pseudo-class with selector as a parameter. A selector can contain multiple extend clauses, but all extends must be at the end of the selector.\n\n- Extend after the selector: `pre:hover:extend(div pre)`.\n- Space between selector and extend is allowed: `pre:hover :extend(div pre)`.\n- Multiple extends are allowed: `pre:hover:extend(div pre):extend(.bucket tr)` - Note this is the same as `pre:hover:extend(div pre, .bucket tr)`\n- This is NOT allowed: `pre:hover:extend(div pre).nth-child(odd)`. Extend must be last.\n\nIf a ruleset contains multiple selectors, any of them can have the extend keyword. Multiple selectors with extend in one ruleset:\n\n    .big-division,\n    .big-bag:extend(.bag),\n    .big-bucket:extend(.bucket) {\n      // body\n    }\n\n### Extend Inside Ruleset\n\nExtend can be placed into a ruleset's body using `&:extend(selector)` syntax. Placing extend into a body is a shortcut for placing it into every single selector of that ruleset.\n\nExtend inside a body:\n\n    pre:hover,\n    .some-class {\n      &:extend(div pre);\n    }\n\nis exactly the same as adding an extend after each selector:\n\n    pre:hover:extend(div pre),\n    .some-class:extend(div pre) {}\n\n### Extending Nested Selectors\n\nExtend is able to match nested selectors. Following less:\n\nExample:\n\n    .bucket {\n      tr { // nested ruleset with target selector\n        color: blue;\n      }\n    }\n    .some-class:extend(.bucket tr) {} // nested ruleset is recognized\n\nOutputs\n\n    .bucket tr,\n    .some-class {\n      color: blue;\n    }\n\nEssentially the extend looks at the compiled css, not the original less.\n\nExample:\n\n    .bucket {\n      tr & { // nested ruleset with target selector\n        color: blue;\n      }\n    }\n    .some-class:extend(tr .bucket) {} // nested ruleset is recognized\n\nOutputs\n\n    tr .bucket,\n    .some-class {\n      color: blue;\n    }\n\n### Exact Matching with Extend\n\nExtend by default looks for exact match between selectors. It does matter whether selector uses leading star or not. It does not matter that two nth-expressions have the same meaning, they need to have to same form in order to be matched. The only exception are quotes in attribute selector, less knows they have the same meaning and matches them.\n\nExample:\n\n    .a.class,\n    .class.a,\n    .class > .a {\n      color: blue;\n    }\n    .test:extend(.class) {} // this will NOT match the any selectors above\n\nLeading star does matter. Selectors `*.class` and `.class` are equivalent, but extend will not match them:\n\n    *.class {\n      color: blue;\n    }\n    .noStar:extend(.class) {} // this will NOT match the *.class selector\n\nOutputs\n\n    *.class {\n      color: blue;\n    }\n\nOrder of pseudo-classes does matter. Selectors `link:hover:visited` and `link:visited:hover` match the same set of elements, but extend treats them as different:\n\n    link:hover:visited {\n      color: blue;\n    }\n    .selector:extend(link:visited:hover) {}\n\nOutputs\n\n    link:hover:visited {\n      color: blue;\n    }\n\n### nth Expression\n\nNth expression form does matter. Nth-expressions `1n+3` and `n+3` are equivalent, but extend will not match them:\n\n    :nth-child(1n+3) {\n      color: blue;\n    }\n    .child:extend(:nth-child(n+3)) {}\n\nOutputs\n\n    :nth-child(1n+3) {\n      color: blue;\n    }\n\nQuote type in attribute selector does not matter. All of the following are equivalent.\n\n    [title=identifier] {\n      color: blue;\n    }\n    [title='identifier'] {\n      color: blue;\n    }\n    [title=\"identifier\"] {\n      color: blue;\n    }\n\n    .noQuote:extend([title=identifier]) {}\n    .singleQuote:extend([title='identifier']) {}\n    .doubleQuote:extend([title=\"identifier\"]) {}\n\nOutputs\n\n    [title=identifier],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n    [title='identifier'],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n    [title=\"identifier\"],\n    .noQuote,\n    .singleQuote,\n    .doubleQuote {\n      color: blue;\n    }\n\n### Extend \"all\"\n\nWhen you specify the all keyword last in an extend argument it tells Less to match that selector as part of another selector. The selector will be copied and the matched part of the selector only will then be replaced with the extend, making a new selector.\n\nExample:\n\n    .a.b.test,\n    .test.c {\n      color: orange;\n    }\n    .test {\n      &:hover {\n        color: green;\n      }\n    }\n\n    .replacement:extend(.test all) {}\n\nOutputs\n\n    .a.b.test,\n    .test.c,\n    .a.b.replacement,\n    .replacement.c {\n      color: orange;\n    }\n    .test:hover,\n    .replacement:hover {\n      color: green;\n    }\n\n*You can think of this mode of operation as essentially doing a non-destructive search and replace.*\n\n### Selector Interpolation with Extend\n\nExtend is **not** able to match selectors with variables. If selector contains variable, extend will ignore it.\n\nHowever, extend can be attached to interpolated selector.\n\nSelector with variable will not be matched:\n\n    @variable: .bucket;\n    @{variable} { // interpolated selector\n      color: blue;\n    }\n    .some-class:extend(.bucket) {} // does nothing, no match is found\n\nand extend with variable in target selector matches nothing:\n\n    .bucket {\n      color: blue;\n    }\n    .some-class:extend(@{variable}) {} // interpolated selector matches nothing\n    @variable: .bucket;\n\nBoth of the above examples compile into:\n\n    .bucket {\n      color: blue;\n    }\n\nHowever, `:extend` attached to an interpolated selector works:\n\n    .bucket {\n      color: blue;\n    }\n    @{variable}:extend(.bucket) {}\n    @variable: .selector;\n\ncompiles to:\n\n    .bucket, .selector {\n      color: blue;\n    }\n\n### Scoping / Extend Inside @media\n\nCurrently, an `:extend` inside a `@media` declaration will only match selectors inside the same media declaration:\n\n    @media print {\n      .screenClass:extend(.selector) {} // extend inside media\n      .selector { // this will be matched - it is in the same media\n        color: black;\n      }\n    }\n    .selector { // ruleset on top of style sheet - extend ignores it\n      color: red;\n    }\n    @media screen {\n      .selector {  // ruleset inside another media - extend ignores it\n        color: blue;\n      }\n    }\n\ncompiles into:\n\n    @media print {\n      .selector,\n      .screenClass { /*  ruleset inside the same media was extended */\n        color: black;\n      }\n    }\n    .selector { /* ruleset on top of style sheet was ignored */\n      color: red;\n    }\n    @media screen {\n      .selector { /* ruleset inside another media was ignored */\n        color: blue;\n      }\n    }\n\nNote: extending does not match selectors inside a nested `@media` declaration:\n\n    @media screen {\n      .screenClass:extend(.selector) {} // extend inside media\n      @media (min-width: 1023px) {\n        .selector {  // ruleset inside nested media - extend ignores it\n          color: blue;\n        }\n      }\n    }\n\nThis compiles into:\n\n    @media screen and (min-width: 1023px) {\n      .selector { /* ruleset inside another nested media was ignored */\n        color: blue;\n      }\n    }\n\nTop level extend matches everything including selectors inside nested media:\n\n    @media screen {\n      .selector {  /* ruleset inside nested media - top level extend works */\n        color: blue;\n      }\n      @media (min-width: 1023px) {\n        .selector {  /* ruleset inside nested media - top level extend works */\n          color: blue;\n        }\n      }\n    }\n\n    .topLevel:extend(.selector) {} /* top level extend matches everything */\n\ncompiles into:\n\n    @media screen {\n      .selector,\n      .topLevel { /* ruleset inside media was extended */\n        color: blue;\n      }\n    }\n    @media screen and (min-width: 1023px) {\n      .selector,\n      .topLevel { /* ruleset inside nested media was extended */\n        color: blue;\n      }\n    }\n\n### Duplication Detection\n\nCurrently there is no duplication detection.\n\nExample:\n\n    .alert-info,\n    .widget {\n      /* declarations */\n    }\n\n    .alert:extend(.alert-info, .widget) {}\n\nOutputs\n\n    .alert-info,\n    .widget,\n    .alert,\n    .alert {\n      /* declarations */\n    }\n\n### Use Cases for Extend\n\n### Classic Use Case\n\nThe classic use case is to avoid adding a base class. For example, if you have\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n\nand you want to have a subtype of animal which overrides the background color then you have two options, firstly change your HTML\n\n    <a class=\"animal bear\">Bear</a>\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n    .bear {\n      background-color: brown;\n    }\n\nor have simplified html and use extend in your less. e.g.\n\n    <a class=\"bear\">Bear</a>\n\n    .animal {\n      background-color: black;\n      color: white;\n    }\n    .bear {\n      &:extend(.animal);\n      background-color: brown;\n    }\n\n### Reducing CSS Size\n\nMixins copy all of the properties into a selector, which can lead to unnecessary duplication. Therefore you can use extends instead of mixins to move the selector up to the properties you wish to use, which leads to less CSS being generated.\n\nExample - with mixin:\n\n    .my-inline-block() {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing1 {\n      .my-inline-block;\n    }\n    .thing2 {\n      .my-inline-block;\n    }\n\nOutputs\n\n    .thing1 {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing2 {\n      display: inline-block;\n      font-size: 0;\n    }\n\nExample (with extends):\n\n    .my-inline-block {\n      display: inline-block;\n      font-size: 0;\n    }\n    .thing1 {\n      &:extend(.my-inline-block);\n    }\n    .thing2 {\n      &:extend(.my-inline-block);\n    }\n\nOutputs\n\n    .my-inline-block,\n    .thing1,\n    .thing2 {\n      display: inline-block;\n      font-size: 0;\n    }\n\n### Combining Styles / A More Advanced Mixin\n\nAnother use-case is as an alternative for a mixin - because mixins can only be used with simple selectors, if you have two different blocks of html, but need to apply the same styles to both you can use extends to relate two areas.\n\nExample:\n\n    li.list > a {\n      // list styles\n    }\n    button.list-style {\n      &:extend(li.list > a); // use the same list styles\n    }\n\n## Merge\n\nCombine properties\n\nThe `merge` feature allows for aggregating values from multiple properties into a comma or space separated list under a single property. `merge` is useful for properties such as background and transform.\n\n### Comma\n\nAppend property value with comma\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    .mixin() {\n      box-shadow+: inset 0 0 10px #555;\n    }\n    .myclass {\n      .mixin();\n      box-shadow+: 0 0 20px black;\n    }\n\nOutputs\n\n    .myclass {\n      box-shadow: inset 0 0 10px #555, 0 0 20px black;\n    }\n\n### Space\n\nAppend property value with space\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    .mixin() {\n      transform+_: scale(2);\n    }\n    .myclass {\n      .mixin();\n      transform+_: rotate(15deg);\n    }\n\nOutputs\n\n    .myclass {\n      transform: scale(2) rotate(15deg);\n    }\n\nTo avoid any unintentional joins, `merge` requires an explicit `+` or `+_` flag on each join pending declaration.\n\n## Mixins\n\n\"mix-in\" properties from existing styles\n\nYou can mix-in class selectors and id selectors, e.g.\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      .a();\n    }\n    .mixin-id {\n      #b();\n    }\n\nwhich results in:\n\n    .a, #b {\n      color: red;\n    }\n    .mixin-class {\n      color: red;\n    }\n    .mixin-id {\n      color: red;\n    }\n\nHistorically, the parentheses in a mixin call are optional, but optional parentheses are deprecated and will be required in a future release.\n\n    .a(); \n    .a;    // currently works, but deprecated; don't use\n    .a (); // white-space before parentheses is also deprecated\n\n### Mixins With Parentheses\n\nIf you want to create a mixin but you do not want that mixin to be in your CSS output, put parentheses after the mixin definition.\n\n    .my-mixin {\n      color: black;\n    }\n    .my-other-mixin() {\n      background: white;\n    }\n    .class {\n      .my-mixin();\n      .my-other-mixin();\n    }\n\noutputs\n\n    .my-mixin {\n      color: black;\n    }\n    .class {\n      color: black;\n      background: white;\n    }\n\n### Selectors in Mixins\n\nMixins can contain more than just properties, they can contain selectors too.\n\nFor example:\n\n    .my-hover-mixin() {\n      &:hover {\n        border: 1px solid red;\n      }\n    }\n    button {\n      .my-hover-mixin();\n    }\n\nOutputs\n\n    button:hover {\n      border: 1px solid red;\n    }\n\n### Namespaces\n\nIf you want to mixin properties inside a more complicated selector, you can stack up multiple ids or classes.\n\n    #outer() {\n      .inner {\n        color: red;\n      }\n    }\n\n    .c {\n      #outer.inner();\n    }\n\nNote: legacy Less syntax allows `>` and whitespace between namespaces and mixins. This syntax is deprecated and may be removed. Currently, these do the same thing.\n\n    #outer > .inner(); // deprecated\n    #outer .inner();   // deprecated\n    #outer.inner();    // preferred\n\nNamespacing your mixins like this reduces conflicts with other library mixins or user mixins, but can also be a way to \"organize\" groups of mixins.\n\nExample:\n\n    #my-library {\n      .my-mixin() {\n        color: black;\n      }\n    }\n    // which can be used like this\n    .class {\n      #my-library.my-mixin();\n    }\n\n### Guarded Namespaces\n\nIf a namespace has a guard, mixins defined by it are used only if the guard condition returns true. A namespace guard is evaluated exactly the same as a guard on a mixin, so the following two mixins work the same way:\n\n    #namespace when (@mode = huge) {\n      .mixin() { /* */ }\n    }\n\n    #namespace {\n      .mixin() when (@mode = huge) { /* */ }\n    }\n\nThe `default` function is assumed to have the same value for all nested namespaces and mixin. The following mixin is never evaluated; one of its guards is guaranteed to be false:\n\n    #sp_1 when (default()) {\n      #sp_2 when (default()) {\n        .mixin() when not(default()) { /* */ }\n      }\n    }\n\n### The `!important` keyword\n\nUse the `!important` keyword after mixin call to mark all properties inherited by it as `!important`:\n\nExample:\n\n    .foo (@bg: #f5f5f5; @color: #900) {\n      background: @bg;\n      color: @color;\n    }\n    .unimportant {\n      .foo();\n    }\n    .important {\n      .foo() !important;\n    }\n\nResults in:\n\n    .unimportant {\n      background: #f5f5f5;\n      color: #900;\n    }\n    .important {\n      background: #f5f5f5 !important;\n      color: #900 !important;\n    }\n\n### Parametric Mixins\n\nHow to pass arguments to mixins\n\nMixins can also take arguments, which are variables passed to the block of selectors when it is mixed in.\n\nFor example:\n\n    .border-radius(@radius) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nAnd here's how we can mix it into various rulesets:\n\n    #header {\n      .border-radius(4px);\n    }\n    .button {\n      .border-radius(6px);\n    }\n\nParametric mixins can also have default values for their parameters:\n\n    .border-radius(@radius: 5px) {\n      -webkit-border-radius: @radius;\n         -moz-border-radius: @radius;\n              border-radius: @radius;\n    }\n\nWe can invoke it like this now:\n\n    #header {\n      .border-radius();\n    }\n\nAnd it will include a 5px border-radius.\n\nYou can also use parametric mixins which don't take parameters. This is useful if you want to hide the ruleset from the CSS output, but want to include its properties in other rulesets:\n\n    .wrap() {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n    pre { .wrap() }\n\nWhich would output:\n\n    pre {\n      text-wrap: wrap;\n      white-space: -moz-pre-wrap;\n      white-space: pre-wrap;\n      word-wrap: break-word;\n    }\n\n### Parameter separators\n\nParameters are currently either *semicolon* or *comma* separated.\n\nOriginally, parameters were only separated by commas, but the semi-colon was later added to support passing comma-separated list values to single arguments.\n\n- two arguments and each contains comma separated list: `.name(1, 2, 3; something, else)`,\n- three arguments and each contains one number: `.name(1, 2, 3)`,\n- use dummy semicolon to create mixin call with one argument containing comma separated css list: `.name(1, 2, 3;)`,\n- comma separated default value: `.name(@param1: red, blue;)`.\n- As of Less 4.0, you can wrap a list value using a paren escape \\[`~()`\\], e.g. `.name(@param1: ~(red, blue))`. This is similar to the quote escape syntax: `~\"quote\"`\n\n### Overloading mixins\n\nIt is legal to define multiple mixins with the same name and number of parameters. Less will use properties of all that can apply. If you used the mixin with one parameter e.g. `.mixin(green);`, then properties of all mixins with exactly one mandatory parameter will be used:\n\n    .mixin(@color) {\n      color-1: @color;\n    }\n    .mixin(@color, @padding: 2) {\n      color-2: @color;\n      padding-2: @padding;\n    }\n    .mixin(@color, @padding, @margin: 2) {\n      color-3: @color;\n      padding-3: @padding;\n      margin: @margin @margin @margin @margin;\n    }\n    .some .selector div {\n      .mixin(#008000);\n    }\n\ncompiles into:\n\n    .some .selector div {\n      color-1: #008000;\n      color-2: #008000;\n      padding-2: 2;\n    }\n\n### Named Parameters\n\nA mixin reference can supply parameters values by their names instead of just positions. Any parameter can be referenced by its name and they do not have to be in any special order:\n\n    .mixin(@color: black; @margin: 10px; @padding: 20px) {\n      color: @color;\n      margin: @margin;\n      padding: @padding;\n    }\n    .class1 {\n      .mixin(@margin: 20px; @color: #33acfe);\n    }\n    .class2 {\n      .mixin(#efca44; @padding: 40px);\n    }\n\ncompiles into:\n\n    .class1 {\n      color: #33acfe;\n      margin: 20px;\n      padding: 20px;\n    }\n    .class2 {\n      color: #efca44;\n      margin: 10px;\n      padding: 40px;\n    }\n\n### The `@arguments` Variable\n\n`@arguments` has a special meaning inside mixins, it contains all the arguments passed, when the mixin was called. This is useful if you don't want to deal with individual parameters:\n\n    .box-shadow(@x: 0, @y: 0, @blur: 1px, @color: #000) {\n      -webkit-box-shadow: @arguments;\n         -moz-box-shadow: @arguments;\n              box-shadow: @arguments;\n    }\n    .big-block {\n      .box-shadow(2px, 5px);\n    }\n\nWhich results in:\n\n    .big-block {\n      -webkit-box-shadow: 2px 5px 1px #000;\n         -moz-box-shadow: 2px 5px 1px #000;\n              box-shadow: 2px 5px 1px #000;\n    }\n\n### Advanced Arguments and the `@rest` Variable\n\nYou can use `...` if you want your mixin to take a variable number of arguments. Using this after a variable name will assign those arguments to the variable.\n\n    .mixin(...) {        // matches 0-N arguments\n    .mixin() {           // matches exactly 0 arguments\n    .mixin(@a: 1) {      // matches 0-1 arguments\n    .mixin(@a: 1, ...) { // matches 0-N arguments\n    .mixin(@a, ...) {    // matches 1-N arguments\n\nFurthermore:\n\n    .mixin(@a, @rest...) {\n       // @rest is bound to arguments after @a\n       // @arguments is bound to all arguments\n    }\n\n### Pattern-matching\n\nSometimes, you may want to change the behavior of a mixin, based on the parameters you pass to it. Let's start with something basic:\n\n    .mixin(@s, @color) { ... }\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nNow let's say we want `.mixin` to behave differently, based on the value of `@switch`, we could define `.mixin` as such:\n\n    .mixin(dark, @color) {\n      color: darken(@color, 10%);\n    }\n    .mixin(light, @color) {\n      color: lighten(@color, 10%);\n    }\n    .mixin(@_, @color) {\n      display: block;\n    }\n\nNow, if we run:\n\n    @switch: light;\n\n    .class {\n      .mixin(@switch, #888);\n    }\n\nWe will get the following CSS:\n\n    .class {\n      color: #a2a2a2;\n      display: block;\n    }\n\nWhere the color passed to `.mixin` was lightened. If the value of `@switch` was `dark`, the result would be a darker color.\n\nHere's what happened:\n\n- The first mixin definition didn't match because it expected `dark` as the first argument.\n- The second mixin definition matched, because it expected `light`.\n- The third mixin definition matched because it expected any value.\n\nOnly mixin definitions which matched were used. Variables match and bind to any value. Anything other than a variable matches only with a value equal to itself.\n\nWe can also match on arity, here's an example:\n\n    .mixin(@a) {\n      color: @a;\n    }\n    .mixin(@a, @b) {\n      color: fade(@a, @b);\n    }\n\nNow if we call `.mixin` with a single argument, we will get the output of the first definition, but if we call it with *two* arguments, we will get the second definition, namely `@a` faded to `@b`.\n\n### Using Mixins as Functions\n\nSelecting properties and variables from mixin calls\n\n### Property / value accessors\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors to select a value from an evaluated mixin's rules. This can allow you to use mixins similar to functions.\n\nExample:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its \"@result\" value\n      padding: .average(16px, 50px)[@result];\n    }\n\nResults in:\n\n    div {\n      padding: 33px;\n    }\n\n### Overriding mixin values\n\nIf you have multiple matching mixins, all rules are evaluated and merged, and the last matching value with that identifier is returned. This is similar to the cascade in CSS, and it allows you to \"override\" mixin values.\n\n    // library.less\n    #library() {\n      .mixin() {\n        prop: foo;\n      }\n    }\n\n    // customize.less\n    @import \"library\";\n    #library() {\n      .mixin() {\n        prop: bar;\n      }\n    }\n\n    .box {\n      my-value: #library.mixin[prop];\n    }\n\nOutputs:\n\n    .box {\n      my-value: bar;\n    }\n\n### Unnamed lookups\n\nIf you don't specify a lookup value in `[@lookup]` and instead write `[]` after a mixin or ruleset call, *all* values will cascade and the last declared value will be selected.\n\nMeaning: the averaging mixin from the above example could be written as:\n\n    .average(@x, @y) {\n      @result: ((@x + @y) / 2);\n    }\n\n    div {\n      // call a mixin and look up its final value\n      padding: .average(16px, 50px)[];\n    }\n\nThe output is the same:\n\n    div {\n      padding: 33px;\n    }\n\nThe same cascading behavior is true for rulesets or variables aliased to mixin calls.\n\n    @dr: {\n      value: foo;\n    }\n    .box {\n      my-value: @dr[];\n    }\n\nThis outputs:\n\n    .box {\n      my-value: foo;\n    }\n\n### Unlocking mixins & variables into caller scope\n\n***DEPRECATED - Use Property / Value Accessors***\n\nVariables and mixins defined in a mixin are visible and can be used in caller's scope. There is only one exception: a variable is not copied if the caller contains a variable with the same name (that includes variables defined by another mixin call). Only variables present in callers local scope are protected. Variables inherited from parent scopes are overridden.\n\n*Note: this behavior is deprecated, and in the future, variables and mixins will not be merged into the caller scope in this way.*\n\nExample:\n\n    .mixin() {\n      @width:  100%;\n      @height: 200px;\n    }\n\n    .caller {\n      .mixin();\n      width:  @width;\n      height: @height;\n    }\n\nResults in:\n\n    .caller {\n      width:  100%;\n      height: 200px;\n    }\n\nVariables defined directly in callers scope cannot be overridden. However, variables defined in callers parent scope is not protected and will be overridden:\n\n    .mixin() {\n      @size: in-mixin;\n      @definedOnlyInMixin: in-mixin;\n    }\n\n    .class {\n      margin: @size @definedOnlyInMixin;\n      .mixin();\n    }\n\n    @size: globaly-defined-value; // callers parent scope - no protection\n\nResults in:\n\n    .class {\n      margin: in-mixin in-mixin;\n    }\n\nFinally, mixin defined in mixin acts as return value too:\n\n    .unlock(@value) { // outer mixin\n      .doSomething() { // nested mixin\n        declaration: @value;\n      }\n    }\n\n    #namespace {\n      .unlock(5); // unlock doSomething mixin\n      .doSomething(); //nested mixin was copied here and is usable\n    }\n\nResults in:\n\n    #namespace {\n      declaration: 5;\n    }\n\n### Recursive Mixins\n\nCreating loops\n\nIn Less a mixin can call itself. Such recursive mixins, when combined with [Guard Expressions](#mixin-guards-feature) and [Pattern Matching](#mixins-parametric-feature-pattern-matching), can be used to create various iterative/loop structures.\n\nExample:\n\n    .loop(@counter) when (@counter > 0) {\n      .loop((@counter - 1));    // next iteration\n      width: (10px * @counter); // code for each iteration\n    }\n\n    div {\n      .loop(5); // launch the loop\n    }\n\nOutput:\n\n    div {\n      width: 10px;\n      width: 20px;\n      width: 30px;\n      width: 40px;\n      width: 50px;\n    }\n\nA generic example of using a recursive loop to generate CSS grid classes:\n\n    .generate-columns(4);\n\n    .generate-columns(@n, @i: 1) when (@i =< @n) {\n      .column-@{i} {\n        width: (@i * 100% / @n);\n      }\n      .generate-columns(@n, (@i + 1));\n    }\n\nOutput:\n\n    .column-1 {\n      width: 25%;\n    }\n    .column-2 {\n      width: 50%;\n    }\n    .column-3 {\n      width: 75%;\n    }\n    .column-4 {\n      width: 100%;\n    }\n\n### Mixin Guards\n\nGuards are useful when you want to match on *expressions*, as opposed to simple values or arity. If you are familiar with functional programming, you have probably encountered them already.\n\nIn trying to stay as close as possible to the declarative nature of CSS, Less has opted to implement conditional execution via **guarded mixins** instead of `if`/`else` statements, in the vein of `@media` query feature specifications.\n\nLet's start with an example:\n\n    .mixin(@a) when (lightness(@a) >= 50%) {\n      background-color: black;\n    }\n    .mixin(@a) when (lightness(@a) < 50%) {\n      background-color: white;\n    }\n    .mixin(@a) {\n      color: @a;\n    }\n\nThe key is the `when` keyword, which introduces a guard sequence (here with only one guard). Now if we run the following code:\n\n    .class1 { .mixin(#ddd) }\n    .class2 { .mixin(#555) }\n\nHere's what we'll get:\n\n    .class1 {\n      background-color: black;\n      color: #ddd;\n    }\n    .class2 {\n      background-color: white;\n      color: #555;\n    }\n\n### Guard Comparison Operators\n\nThe full list of comparison operators usable in guards are: `>`, `>=`, `=`, `=<`, `<`. Additionally, the keyword `true` is the only truthy value, making these two mixins equivalent:\n\n    .truth(@a) when (@a) { ... }\n    .truth(@a) when (@a = true) { ... }\n\nAny value other than the keyword `true` is falsy:\n\n    .class {\n      .truth(40); // Will not match any of the above definitions.\n    }\n\nNote that you can also compare arguments with each other, or with non-arguments:\n\n    @media: mobile;\n\n    .mixin(@a) when (@media = mobile) { ... }\n    .mixin(@a) when (@media = desktop) { ... }\n\n    .max(@a; @b) when (@a > @b) { width: @a }\n    .max(@a; @b) when (@a < @b) { width: @b }\n\n### Guard Logical Operators\n\nYou can use logical operators with guards. The syntax is based on CSS media queries.\n\nUse the `and` keyword to combine guards:\n\n    .mixin(@a) when (isnumber(@a)) and (@a > 0) { ... }\n\nYou can emulate the *or* operator by separating guards with a comma `,`. If any of the guards evaluate to true, it's considered a match:\n\n    .mixin(@a) when (@a > 10), (@a < -10) { ... }\n\nUse the `not` keyword to negate conditions:\n\n    .mixin(@b) when not (@b > 0) { ... }\n\n### Type Checking Functions\n\nLastly, if you want to match mixins based on value type, you can use the `is` functions:\n\n    .mixin(@a; @b: 0) when (isnumber(@b)) { ... }\n    .mixin(@a; @b: black) when (iscolor(@b)) { ... }\n\nHere are the basic type checking functions:\n\n- `iscolor`\n- `isnumber`\n- `isstring`\n- `iskeyword`\n- `isurl`\n\nIf you want to check if a value is in a specific unit in addition to being a number, you may use one of:\n\n- `ispixel`\n- `ispercentage`\n- `isem`\n- `isunit`\n\n### Aliasing Mixins\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nAssigning mixin calls to a variable\n\nMixins can be assigned to a variable to be called as a variable call, or can be used for map lookup.\n\n    #theme.dark.navbar {\n      .colors(light) {\n        primary: purple;\n      }\n      .colors(dark) {\n        primary: black;\n        secondary: grey;\n      }\n    }\n\n    .navbar {\n      @colors: #theme.dark.navbar.colors(dark);\n      background: @colors[primary];\n      border: 1px solid @colors[secondary];\n    }\n\nThis would output:\n\n    .navbar {\n      background: black;\n      border: 1px solid grey;\n    }\n\n### Variable calls\n\nEntire mixin calls can be aliased and called as variable calls. As in:\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors();\n      @alias();\n    }\n\nOutputs:\n\n    .box {\n      background: green;\n    }\n\nNote, unlike mixins used in root, mixin calls assigned to variables and *called with no arguments* always require parentheses. The following is not valid.\n\n    #library() {\n      .colors() {\n        background: green;\n      }\n    }\n    .box {\n      @alias: #library.colors;\n      @alias();   // ERROR: Could not evaluate variable call @alias\n    }\n\nThis is because it's ambiguous if variable is assigned a list of selectors or a mixin call. For example, in Less 3.5+, this variable could be used this way.\n\n    .box {\n      @alias: #library.colors;\n      @{alias} {\n        a: b;\n      }\n    }\n\nThe above would output:\n\n    .box #library.colors {\n      a: b;\n    }\n\n## CSS Guards\n\n\"if\"'s around selectors\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nLike Mixin Guards, guards can also be applied to css selectors, which is syntactic sugar for declaring the mixin and then calling it immediately.\n\nFor instance, before 1.5.0 you would have had to do this:\n\n    .my-optional-style() when (@my-option = true) {\n      button {\n        color: white;\n      }\n    }\n    .my-optional-style();\n\nNow, you can apply the guard directly to a style.\n\n    button when (@my-option = true) {\n      color: white;\n    }\n\nYou can also achieve an `if` type statement by combining this with the `&` feature, allowing you to group multiple guards.\n\n    & when (@my-option = true) {\n      button {\n        color: white;\n      }\n      a {\n        color: blue;\n      }\n    }\n\nNote that you can also achieve a similar pattern by using the actual `if()` function and a variable call. As in:\n\n    @dr: if(@my-option = true, {\n      button {\n        color: white;\n      }\n      a {\n        color: blue;\n      }\n    });\n    @dr();\n\n## Detached Rulesets\n\nAssign a ruleset to a variable\n\nReleased [v1.7.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nA detached ruleset is a group of css properties, nested rulesets, media declarations or anything else stored in a variable. You can include it into a ruleset or another structure and all its properties are going to be copied there. You can also use it as a mixin argument and pass it around as any other variable.\n\nSimple example:\n\n    // declare detached ruleset\n    @detached-ruleset: { background: red; }; // semi-colon is optional in 3.5.0+\n\n    // use detached ruleset\n    .top {\n        @detached-ruleset(); \n    }\n\ncompiles into:\n\n    .top {\n      background: red;\n    }\n\nParentheses after a detached ruleset call are mandatory (except when followed by a [lookup value](#detached-rulesets-feature-property-variable-accessors)). The call `@detached-ruleset;` would not work.\n\nIt is useful when you want to define a mixin that abstracts out either wrapping a piece of code in a media query or a non-supported browser class name. The rulesets can be passed to mixin so that the mixin can wrap the content, e.g.\n\n    .desktop-and-old-ie(@rules) {\n      @media screen and (min-width: 1200px) { @rules(); }\n      html.lt-ie9 &                         { @rules(); }\n    }\n\n    header {\n      background-color: blue;\n\n      .desktop-and-old-ie({\n        background-color: red;\n      });\n    }\n\nHere the `desktop-and-old-ie` mixin defines the media query and root class so that you can use a mixin to wrap a piece of code. This will output\n\n    header {\n      background-color: blue;\n    }\n    @media screen and (min-width: 1200px) {\n      header {\n        background-color: red;\n      }\n    }\n    html.lt-ie9 header {\n      background-color: red;\n    }\n\nA ruleset can be now assigned to a variable or passed in to a mixin and can contain the full set of Less features, e.g.\n\n    @my-ruleset: {\n        .my-selector {\n          background-color: black;\n        }\n      };\n\nYou can even take advantage of [media query bubbling](#features-overview-feature-media-query-bubbling-and-nested-media-queries), for instance\n\n    @my-ruleset: {\n        .my-selector {\n          @media tv {\n            background-color: black;\n          }\n        }\n      };\n    @media (orientation:portrait) {\n        @my-ruleset();\n    }\n\nwhich will output\n\n    @media (orientation: portrait) and tv {\n      .my-selector {\n        background-color: black;\n      }\n    }\n\nA detached ruleset call unlocks (returns) all its mixins into caller the same way as mixin calls do. However, it does **not** return variables.\n\nReturned mixin:\n\n    // detached ruleset with a mixin\n    @detached-ruleset: { \n        .mixin() {\n            color: blue;\n        }\n    };\n    // call detached ruleset\n    .caller {\n        @detached-ruleset(); \n        .mixin();\n    }\n\nResults in:\n\n    .caller {\n      color: blue;\n    }\n\nPrivate variables:\n\n    @detached-ruleset: { \n        @color:blue; // this variable is private\n    };\n    .caller {\n        color: @color; // syntax error\n    }\n\n### Scoping\n\nA detached ruleset can use all variables and mixins accessible where it is *defined* and where it is *called*. Otherwise said, both definition and caller scopes are available to it. If both scopes contains the same variable or mixin, declaration scope value takes precedence.\n\n*Declaration scope* is the one where detached ruleset body is defined. Copying a detached ruleset from one variable into another cannot modify its scope. The ruleset does not gain access to new scopes just by being referenced there.\n\nLastly, a detached ruleset can gain access to scope by being unlocked (imported) into it.\n\n*Note: unlocking variables into scope via a called mixin is deprecated. Use [property / variable accessors](#detached-rulesets-feature-property-variable-accessors).*\n\n### Definition and Caller Scope Visibility\n\nA detached ruleset sees the caller's variables and mixins:\n\n    @detached-ruleset: {\n      caller-variable: @caller-variable; // variable is undefined here\n      .caller-mixin(); // mixin is undefined here\n    };\n\n    selector {\n      // use detached ruleset\n      @detached-ruleset(); \n\n      // define variable and mixin needed inside the detached ruleset\n      @caller-variable: value;\n      .caller-mixin() {\n        variable: declaration;\n      }\n    }\n\ncompiles into:\n\n    selector {\n      caller-variable: value;\n      variable: declaration;\n    }\n\nVariable and mixins accessible from definition win over those available in the caller:\n\n    @variable: global;\n    @detached-ruleset: {\n      // will use global variable, because it is accessible\n      // from detached-ruleset definition\n      variable: @variable; \n    };\n\n    selector {\n      @detached-ruleset();\n      @variable: value; // variable defined in caller - will be ignored\n    }\n\ncompiles into:\n\n    selector {\n      variable: global;\n    }\n\n### Referencing *Won't* Modify Detached Ruleset Scope\n\nA ruleset does not gain access to new scopes just by being referenced there:\n\n    @detached-1: { scope-detached: @one @two; };\n    .one {\n      @one: visible;\n      .two {\n        @detached-2: @detached-1; // copying/renaming ruleset \n        @two: visible; // ruleset can not see this variable\n      }\n    }\n\n    .use-place {\n      .one > .two(); \n      @detached-2();\n    }\n\nthrows an error:\n\n    ERROR 1:32 The variable \"@one\" was not declared.\n\n### Unlocking *Will* Modify Detached Ruleset Scope\n\nA detached ruleset gains access by being unlocked (imported) inside a scope:\n\n    #space {\n      .importer-1() {\n        @detached: { scope-detached: @variable; }; // define detached ruleset\n      }\n    }\n\n    .importer-2() {\n      @variable: value; // unlocked detached ruleset CAN see this variable\n      #space > .importer-1(); // unlock/import detached ruleset\n    }\n\n    .use-place {\n      .importer-2(); // unlock/import detached ruleset second time\n       @detached();\n    }\n\ncompiles into:\n\n    .use-place {\n      scope-detached: value;\n    }\n\n### Property / variable accessors\n\n### (Lookup values)\n\n*Released [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)*\n\nStarting in Less 3.5, you can use property/variable accessors (also called \"lookups\") to select a value from variable (detached) rulesets.\n\n    @config: {\n      option1: true;\n      option2: false;\n    }\n\n    .mixin() when (@config[option1] = true) {\n      selected: value;\n    }\n\n    .box {\n      .mixin();\n    }\n\nOutputs:\n\n    .box {\n      selected: value;\n    }\n\nIf what is returned from a lookup is another detached ruleset, you can use a second lookup to get that value.\n\n    @config: {\n      @colors: {\n        primary: blue;\n      }\n    }\n\n    .box {\n      color: @config[@colors][primary];\n    }\n\n### Variable variables in lookups\n\nThe lookup value that is returned can itself be variable. As in, you can write:\n\n    @config: {\n      @dark: {\n        primary: darkblue;\n      }\n      @light: {\n        primary: lightblue;\n      }\n    }\n\n    .box {\n      @lookup: dark;\n      color: @config[@@lookup][primary];\n    }\n\nThis will output:\n\n    .box {\n      color: darkblue;\n    }\n\n## @import At-Rules\n\nImport styles from other style sheets\n\nIn standard CSS, `@import` at-rules must precede all other types of rules. But Less doesn't care where you put `@import` statements.\n\nExample:\n\n    .foo {\n      background: #900;\n    }\n    @import \"this-is-valid.less\";\n\n### File Extensions\n\n`@import` statements may be treated differently by Less depending on the file extension:\n\n- If the file has a `.css` extension it will be treated as CSS and the `@import` statement left as-is (see the [inline option](#import-options-inline) below).\n- If it has *any other extension* it will be treated as Less and imported.\n- If it does not have an extension, `.less` will be appended and it will be included as a imported Less file.\n\nExamples:\n\n    @import \"foo\";      // foo.less is imported\n    @import \"foo.less\"; // foo.less is imported\n    @import \"foo.php\";  // foo.php imported as a Less file\n    @import \"foo.css\";  // statement left in place, as-is\n\nThe following options can be used to override this behavior.\n\n### Import Options\n\nLess offers several extensions to the CSS `@import` CSS at-rule to provide more flexibility over what you can do with external files.\n\nSyntax: `@import (keyword) \"filename\";`\n\nThe following import options have been implemented:\n\n- `reference`: use a Less file but do not output it\n- `inline`: include the source file in the output but do not process it\n- `less`: treat the file as a Less file, no matter what the file extension\n- `css`: treat the file as a CSS file, no matter what the file extension\n- `once`: only include the file once (this is default behavior)\n- `multiple`: include the file multiple times\n- `optional`: continue compiling when file is not found\n\nMore than one keyword per `@import` is allowed, you will have to use commas to separate the keywords:\n\nExample: `@import (optional, reference) \"foo.less\";`\n\n### reference\n\nUse `@import (reference)` to import external files, but without adding the imported styles to the compiled output unless referenced.\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample: `@import (reference) \"foo.less\";`\n\nImagine that `reference` marks every at-rule and selector with a *reference flag* in the imported file, imports as normal, but when the CSS is generated, \"reference\" selectors (as well as any media queries containing only reference selectors) are not output. `reference` styles will not show up in your generated CSS unless the reference styles are used as [mixins](#mixins-feature) or [extended](#extend-feature).\n\nAdditionally, **`reference`** produces different results depending on which method was used (mixin or extend):\n\n- **[extend](#extend-feature)**: When a selector is extended, only the new selector is marked as *not referenced*, and it is pulled in at the position of the reference `@import` statement.\n- **[mixins](#mixins-feature)**: When a `reference` style is used as an [implicit mixin](#mixins-feature), its rules are mixed-in, marked \"not reference\", and appear in the referenced place as normal.\n\n### reference example\n\nThis allows you to pull in only specific, targeted styles from a library such as [Bootstrap](https://github.com/twbs/bootstrap) by doing something like this:\n\n    .navbar:extend(.navbar all) {}\n\nAnd you will pull in only `.navbar` related styles from Bootstrap.\n\n### inline\n\nUse `@import (inline)` to include external files, but not process them.\n\nReleased [v1.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample: `@import (inline) \"not-less-compatible.css\";`\n\nYou will use this when a CSS file may not be Less compatible; this is because although Less supports most known standards CSS, it does not support comments in some places and does not support all known CSS hacks without modifying the CSS.\n\nSo you can use this to include the file in the output so that all CSS will be in one file.\n\n### less\n\nUse `@import (less)` to treat imported files as Less, regardless of file extension.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    @import (less) \"foo.css\";\n\n### css\n\nUse `@import (css)` to treat imported files as regular CSS, regardless of file extension. This means the import statement will be left as it is.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    @import (css) \"foo.less\";\n\noutputs\n\n    @import \"foo.less\";\n\n### once\n\nThe default behavior of `@import` statements. It means the file is imported only once and subsequent import statements for that file will be ignored.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nThis is the default behavior of `@import` statements.\n\nExample:\n\n    @import (once) \"foo.less\";\n    @import (once) \"foo.less\"; // this statement will be ignored\n\n### multiple\n\nUse `@import (multiple)` to allow importing of multiple files with the same name. This is the opposite behavior to once.\n\nReleased [v1.4.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nExample:\n\n    // file: foo.less\n    .a {\n      color: green;\n    }\n    // file: main.less\n    @import (multiple) \"foo.less\";\n    @import (multiple) \"foo.less\";\n\nOutputs\n\n    .a {\n      color: green;\n    }\n    .a {\n      color: green;\n    }\n\n### optional\n\nUse `@import (optional)` to allow importing of a file only when it exists. Without the `optional` keyword Less throws a FileError and stops compiling when importing a file that can not be found.\n\nReleased [v2.3.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\n## @plugin At-Rules\n\nReleased [v2.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nImport JavaScript plugins to add Less.js functions and features\n\n### Writing your first plugin\n\nUsing a `@plugin` at-rule is similar to using an `@import` for your `.less` files.\n\n    @plugin \"my-plugin\";  // automatically appends .js if no extension\n\nSince Less plugins are evaluated within the Less scope, the plugin definition can be quite simple.\n\n    registerPlugin({\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    })\n\nor you can use `module.exports` (shimmed to work in browser as well as Node.js).\n\n    module.exports = {\n        install: function(less, pluginManager, functions) {\n            functions.add('pi', function() {\n                return Math.PI;\n            });\n        }\n    };\n\nNote that other Node.js CommonJS conventions, like `require()` are not available in the browser. Keep this in mind when writing cross-platform plugins.\n\nWhat can you do with a plugin? A lot, but let's start with the basics. We'll focus first on what you might put inside the `install` function. Let's say you write this:\n\n    // my-plugin.js\n    install: function(less, pluginManager, functions) {\n        functions.add('pi', function() {\n            return Math.PI;\n        });\n    }\n    // etc\n\nCongratulations! You've written a Less plugin!\n\nIf you were to use this in your stylesheet:\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi();\n    }\n\nYou would get:\n\n    .show-me-pi {\n      value: 3.141592653589793;\n    }\n\nHowever, you would need to return a proper Less node if you wanted to, say, multiply that against other values or do other Less operations. Otherwise the output in your stylesheet is plain text (which may be fine for your purposes).\n\nMeaning, this is more correct:\n\n    functions.add('pi', function() {\n        return new tree.Dimension(Math.PI);\n    });\n\n*Note: A dimension is a number with or without a unit, like \"10px\", which would be `less.Dimension(10, \"px\")`. For a list of units, see the [Less API](todo).*\n\nNow you can use your function in operations.\n\n    @plugin \"my-plugin\";\n    .show-me-pi {\n      value: pi() * 2;\n    }\n\nYou may have noticed that there are available globals for your plugin file, namely a function registry (`functions` object), and the `less` object. These are there for convenience.\n\n### Plugin Scope\n\nFunctions added by a `@plugin` at-rule adheres to Less scoping rules. This is great for Less library authors that want to add functionality without introducing naming conflicts.\n\nFor instance, say you have 2 plugins from two third-party libraries that both have a function named \"foo\".\n\n    // lib1.js\n    // ...\n        functions.add('foo', function() {\n            return \"foo\";\n        });\n    // ...\n\n    // lib2.js\n    // ...\n        functions.add('foo', function() {\n            return \"bar\";\n        });\n    // ...\n\nThat's ok! You can choose which library's function creates which output.\n\n    .el-1 {\n        @plugin \"lib1\";\n        value: foo();\n    }\n    .el-2 {\n        @plugin \"lib2\";\n        value: foo();\n    }\n\nThis will produce:\n\n    .el-1 {\n        value: foo;\n    }\n    .el-2 {\n        value: bar;\n    }\n\nFor plugin authors sharing their plugins, that means you can also effectively make private functions by placing them in a particular scope. As in, this will cause an error:\n\n    .el {\n        @plugin \"lib1\";\n    }\n    @value: foo();\n\nAs of Less 3.0, functions can return any kind of Node type, and can be called at any level.\n\nMeaning, this would throw an error in 2.x, as functions had to be part of the value of a property or variable assignment:\n\n    .block {\n        color: blue;\n        my-function-rules();\n    }\n\nIn 3.x, that's no longer the case, and functions can return At-Rules, Rulesets, any other Less node, strings, and numbers (the latter two are converted to Anonymous nodes).\n\n### Null Functions\n\nThere are times when you may want to call a function, but you don't want anything output (such as storing a value for later use). In that case, you just need to return `false` from the function.\n\n    var collection = [];\n\n    functions.add('store', function(val) {\n        collection.push(val);  // imma store this for later\n        return false;\n    });\n\n    @plugin \"collections\";\n    @var: 32;\n    store(@var);\n\nLater you could do something like:\n\n    functions.add('retrieve', function(val) {\n        return new tree.Value(collection);\n    });\n\n    .get-my-values {\n        @plugin \"collections\";\n        values: retrieve();   \n    }\n\n### The Less.js Plugin Object\n\nA Less.js plugin should export an object that has one or more of these properties.\n\n    {\n        /* Called immediately after the plugin is \n         * first imported, only once. */\n        install: function(less, pluginManager, functions) { },\n\n        /* Called for each instance of your @plugin. */\n        use: function(context) { },\n\n        /* Called for each instance of your @plugin, \n         * when rules are being evaluated.\n         * It's just later in the evaluation lifecycle */\n        eval: function(context) { },\n\n        /* Passes an arbitrary string to your plugin \n         * e.g. @plugin (args) \"file\";\n         * This string is not parsed for you, \n         * so it can contain (almost) anything */\n        setOptions: function(argumentString) { },\n\n        /* Set a minimum Less compatibility string\n         * You can also use an array, as in [3, 0] */\n        minVersion: ['3.0'],\n\n        /* Used for lessc only, to explain \n         * options in a Terminal */\n        printUsage: function() { },\n\n    }\n\nThe PluginManager instance for the `install()` function provides methods for adding visitors, file managers, and post-processors.\n\nHere are some example repos showing the different plugin types.\n\n- post-processor: <https://github.com/less/less-plugin-clean-css>\n- visitor: <https://github.com/less/less-plugin-inline-urls>\n- file-manager: <https://github.com/less/less-plugin-npm-import>\n\n### Pre-Loaded Plugins\n\nWhile a `@plugin` call works well for most scenarios, there are times when you might want to load a plugin before parsing starts.\n\nSee: [Pre-Loaded Plugins](usage#plugins) in the \"Using Less.js\" section for how to do that.\n\n## Maps (NEW!)\n\nReleased [v3.5.0](https://github.com/less/less.js/blob/master/CHANGELOG.md)\n\nUse rulesets and mixins as maps of values\n\nBy combining namespacing with the lookup `[]` syntax, you can turn your rulesets / mixins into maps.\n\n    @sizes: {\n      mobile: 320px;\n      tablet: 768px;\n      desktop: 1024px;\n    }\n\n    .navbar {\n      display: block;\n\n      @media (min-width: @sizes[tablet]) {\n        display: inline-block;\n      }\n    }\n\nOutputs:\n\n    .navbar {\n      display: block;\n    }\n    @media (min-width: 768px) {\n      .navbar {\n        display: inline-block;\n      }\n    }\n\nMixins are a little more versatile as maps because of namespacing and the ability to overload mixins.\n\n    #library() {\n      .colors() {\n        primary: green;\n        secondary: blue;\n      }\n    }\n\n    #library() {\n      .colors() { primary: grey; }\n    }\n\n    .button {\n      color: #library.colors[primary];\n      border-color: #library.colors[secondary];\n    }\n\nOutputs:\n\n    .button {\n      color: grey;\n      border-color: blue;\n    }\n\nYou can also make this easier by [aliasing mixins](#mixins-feature-mixin-aliasing-feature). That is:\n\n    .button {\n      @colors: #library.colors();\n      color: @colors[primary];\n      border-color: @colors[secondary];\n    }\n\nNote, if a lookup value produces another ruleset, you can append a second `[]` lookup, as in:\n\n    @config: {\n      @options: {\n        library-on: true\n      }\n    }\n\n    & when (@config[@options][library-on] = true) {\n      .produce-ruleset {\n        prop: val;\n      }\n    }\n\nIn this way, rulesets and variable calls can emulate a type of \"namespacing\", similar to mixins.\n\nAs far as whether to use mixins or rulesets assigned to variables as maps, it's up to you. You may want to replace entire maps by re-declaring a variable assigned to a rulset. Or you may want to \"merge\" individual key/value pairs, in which case mixins as maps might be more appropriate.\n\n### Using variable variables in lookups\n\nOne important thing to notice is that the value in `[@lookup]` is the key (variable) name `@lookup`, and is not evaluated as a variable. If you want the key name itself to be variable, you can use the `@@variable` syntax.\n\nE.g.\n\n    .foods() {\n      @dessert: ice cream;\n    }\n\n    @key-to-lookup: dessert;\n\n    .lunch {\n      treat: .foods[@@key-to-lookup];\n    }\n\nThis would output:\n\n    .lunch {\n      treat: ice cream;\n    }\n\n© 2009–2020 The Core Less Team  \nLicensed under the Creative Commons Attribution License 3.0.  \n[http://lesscss.org/features](http://lesscss.org/features)"
