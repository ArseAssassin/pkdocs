---
name: Underscore.js
slug: underscore
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © 2009–2021 Jeremy Ashkenas, DocumentCloud and Investigative Reporters &
  Editors
  Licensed under the MIT License.
  https://underscorejs.org/
homepage: https://underscorejs.org

---
- name: _.after
  id: index#after
  summary: after_.after(count, function) Creates a wrapper of function that does nothing at first
  description: "**after**`_.after(count, function)`  \nCreates a wrapper of **function** that does nothing at first. From the **count**-th call onwards, it starts actually calling **function**. Useful for grouping asynchronous responses, where you want to be sure that all the async calls have finished, before proceeding.\n\n``` javascript\nvar renderNotes = _.after(notes.length, render);\n_.each(notes, function(note) {\n  note.asyncSave({success: renderNotes});\n});\n// renderNotes is run once, after all notes have saved.\n```"
- name: _.allKeys
  id: index#allKeys
  summary: allKeys_.allKeys(object) Retrieve all the names of object's own and inherited properties
  description: "**allKeys**`_.allKeys(object)`  \nRetrieve *all* the names of **object**'s own and inherited properties.\n\n``` javascript\nfunction Stooge(name) {\n  this.name = name;\n}\nStooge.prototype.silly = true;\n_.allKeys(new Stooge(\"Moe\"));\n=> [\"name\", \"silly\"]\n```"
- name: _.before
  id: index#before
  summary: before_.before(count, function) Creates a wrapper of function that memoizes its return value
  description: "**before**`_.before(count, function)`  \nCreates a wrapper of **function** that memoizes its return value. From the **count**-th call onwards, the memoized result of the last invocation is returned immediately instead of invoking **function** again. So the wrapper will invoke **function** at most **count** - 1 times.\n\n``` javascript\nvar monthlyMeeting = _.before(3, askForRaise);\nmonthlyMeeting();\nmonthlyMeeting();\nmonthlyMeeting();\n// the result of any subsequent calls is the same as the second call\n```"
- name: _.bind
  id: index#bind
  summary: bind_.bind(function, object, *arguments) Bind a function to an object, meaning that whenever the function is called, the value of this will be the object
  description: "**bind**`_.bind(function, object, *arguments)`  \nBind a **function** to an **object**, meaning that whenever the function is called, the value of *this* will be the **object**. Optionally, pass **arguments** to the **function** to pre-fill them, also known as **partial application**. For partial application without context binding, use [partial](#partial).\n\n``` javascript\nvar func = function(greeting){ return greeting + ': ' + this.name };\nfunc = _.bind(func, {name: 'moe'}, 'hi');\nfunc();\n=> 'hi: moe'\n```"
- name: _.bindAll
  id: index#bindAll
  summary: bindAll_.bindAll(object, *methodNames) Binds a number of methods on the object, specified by methodNames, to be run in the context of that object whenever they are invoked
  description: "**bindAll**`_.bindAll(object, *methodNames)`  \nBinds a number of methods on the **object**, specified by **methodNames**, to be run in the context of that object whenever they are invoked. Very handy for binding functions that are going to be used as event handlers, which would otherwise be invoked with a fairly useless *this*. **methodNames** are required.\n\n``` javascript\nvar buttonView = {\n  label  : 'underscore',\n  onClick: function(){ alert('clicked: ' + this.label); },\n  onHover: function(){ console.log('hovering: ' + this.label); }\n};\n_.bindAll(buttonView, 'onClick', 'onHover');\n// When the button is clicked, this.label will have the correct value.\njQuery('#underscore_button').on('click', buttonView.onClick);\n```"
- name: _.chain
  id: index#chain
  summary: chain_.chain(obj) Returns a wrapped object
  description: "**chain**`_.chain(obj)`  \nReturns a wrapped object. Calling methods on this object will continue to return wrapped objects until `value` is called.\n\n``` javascript\nvar stooges = [{name: 'curly', age: 25}, {name: 'moe', age: 21}, {name: 'larry', age: 23}];\nvar youngest = _.chain(stooges)\n  .sortBy(function(stooge){ return stooge.age; })\n  .map(function(stooge){ return stooge.name + ' is ' + stooge.age; })\n  .first()\n  .value();\n=> \"moe is 21\"\n```"
- name: _.chunk
  id: index#chunk
  summary: chunk_.chunk(array, length) Chunks an array into multiple arrays, each containing length or fewer items
  description: "**chunk**`_.chunk(array, length)`  \nChunks an **array** into multiple arrays, each containing **length** or fewer items.\n\n``` javascript\nvar partners = _.chunk(_.shuffle(kindergarten), 2);\n=> [[\"Tyrone\", \"Elie\"], [\"Aidan\", \"Sam\"], [\"Katrina\", \"Billie\"], [\"Little Timmy\"]]\n```"
- name: _.clone
  id: index#clone
  summary: clone_.clone(object) Create a shallow-copied clone of the provided plain object
  description: "**clone**`_.clone(object)`  \nCreate a shallow-copied clone of the provided *plain* **object**. Any nested objects or arrays will be copied by reference, not duplicated.\n\n``` javascript\n_.clone({name: 'moe'});\n=> {name: 'moe'};\n```"
- name: _.compact
  id: index#compact
  summary: compact_.compact(list) Returns a copy of the list with all falsy values removed
  description: "**compact**`_.compact(list)`  \nReturns a copy of the **list** with all falsy values removed. In JavaScript, *false*, *null*, *0*, *\"\"*, *undefined* and *NaN* are all falsy.\n\n``` javascript\n_.compact([0, 1, false, 2, '', 3]);\n=> [1, 2, 3]\n```\n\n## Array Functions\n\n*Note: All array functions will also work on the **arguments** object. However, Underscore functions are not designed to work on \"sparse\" arrays.*"
- name: _.compose
  id: index#compose
  summary: compose_.compose(*functions) Returns the composition of a list of functions, where each function consumes the return value of the function that follows
  description: "**compose**`_.compose(*functions)`  \nReturns the composition of a list of **functions**, where each function consumes the return value of the function that follows. In math terms, composing the functions *f()*, *g()*, and *h()* produces *f(g(h()))*.\n\n``` javascript\nvar greet    = function(name){ return \"hi: \" + name; };\nvar exclaim  = function(statement){ return statement.toUpperCase() + \"!\"; };\nvar welcome = _.compose(greet, exclaim);\nwelcome('moe');\n=> 'hi: MOE!'\n```"
- name: _.constant
  id: index#constant
  summary: constant_.constant(value) Creates a function that returns the same value that is used as the argument of _.constant
  description: "**constant**`_.constant(value)`  \nCreates a function that returns the same value that is used as the argument of `_.constant`.\n\n``` javascript\nvar stooge = {name: 'moe'};\nstooge === _.constant(stooge)();\n=> true\n```"
- name: _.countBy
  id: index#countBy
  summary: countBy_.countBy(list, iteratee, [context]) Sorts a list into groups and returns a count for the number of objects in each group
  description: "**countBy**`_.countBy(list, iteratee, [context])`  \nSorts a list into groups and returns a count for the number of objects in each group. Similar to `groupBy`, but instead of returning a list of values, returns a count for the number of values in that group.\n\n``` javascript\n_.countBy([1, 2, 3, 4, 5], function(num) {\n  return num % 2 == 0 ? 'even': 'odd';\n});\n=> {odd: 3, even: 2}\n```"
- name: _.create
  id: index#create
  summary: create_.create(prototype, props) Creates a new object with the given prototype, optionally attaching props as own properties
  description: "**create**`_.create(prototype, props)`  \nCreates a new object with the given prototype, optionally attaching **props** as *own* properties. Basically, `Object.create`, but without all of the property descriptor jazz.\n\n``` javascript\nvar moe = _.create(Stooge.prototype, {name: \"Moe\"});\n```"
- name: _.debounce
  id: index#debounce
  summary: debounce_.debounce(function, wait, [immediate]) Creates and returns a new debounced version of the passed function which will postpone its execution until after wait milliseconds have elapsed since the last time it was invoked
  description: "**debounce**`_.debounce(function, wait, [immediate])`  \nCreates and returns a new debounced version of the passed function which will postpone its execution until after **wait** milliseconds have elapsed since the last time it was invoked. Useful for implementing behavior that should only happen *after* the input has stopped arriving. For example: rendering a preview of a Markdown comment, recalculating a layout after the window has stopped being resized, and so on.\n\nAt the end of the **wait** interval, the function will be called with the arguments that were passed *most recently* to the debounced function.\n\nPass `true` for the **immediate** argument to cause **debounce** to trigger the function on the leading instead of the trailing edge of the **wait** interval. Useful in circumstances like preventing accidental double-clicks on a \"submit\" button from firing a second time.\n\n``` javascript\nvar lazyLayout = _.debounce(calculateLayout, 300);\n$(window).resize(lazyLayout);\n```\n\nIf you need to cancel a scheduled debounce, you can call `.cancel()` on the debounced function."
- name: _.defaults
  id: index#defaults
  summary: defaults_.defaults(object, *defaults) Returns object after filling in its undefined properties with the first value present in the following list of defaults objects
  description: "**defaults**`_.defaults(object, *defaults)`  \nReturns **object** after filling in its `undefined` properties with the first value present in the following list of **defaults** objects.\n\n``` javascript\nvar iceCream = {flavor: \"chocolate\"};\n_.defaults(iceCream, {flavor: \"vanilla\", sprinkles: \"lots\"});\n=> {flavor: \"chocolate\", sprinkles: \"lots\"}\n```"
- name: _.defer
  id: index#defer
  summary: defer_.defer(function, *arguments) Defers invoking the function until the current call stack has cleared, similar to using setTimeout with a delay of 0
  description: "**defer**`_.defer(function, *arguments)`  \nDefers invoking the **function** until the current call stack has cleared, similar to using **setTimeout** with a delay of 0. Useful for performing expensive computations or HTML rendering in chunks without blocking the UI thread from updating. If you pass the optional **arguments**, they will be forwarded on to the **function** when it is invoked.\n\n``` javascript\n_.defer(function(){ alert('deferred'); });\n// Returns from the function before the alert runs.\n```"
- name: _.delay
  id: index#delay
  summary: delay_.delay(function, wait, *arguments) Much like setTimeout, invokes function after wait milliseconds
  description: "**delay**`_.delay(function, wait, *arguments)`  \nMuch like **setTimeout**, invokes **function** after **wait** milliseconds. If you pass the optional **arguments**, they will be forwarded on to the **function** when it is invoked.\n\n``` javascript\nvar log = _.bind(console.log, console);\n_.delay(log, 1000, 'logged later');\n=> 'logged later' // Appears after one second.\n```"
- name: _.difference
  id: index#difference
  summary: difference_.difference(array, *others) Similar to without, but returns the values from array that are not present in the other arrays
  description: "**difference**`_.difference(array, *others)`  \nSimilar to **without**, but returns the values from **array** that are not present in the **other** arrays.\n\n``` javascript\n_.difference([1, 2, 3, 4, 5], [5, 2, 10]);\n=> [1, 3, 4]\n```"
- name: _.escape
  id: index#escape
  summary: escape_.escape(string) Escapes a string for insertion into HTML, replacing &, <, >, ", `, and ' characters
  description: "**escape**`_.escape(string)`  \nEscapes a string for insertion into HTML, replacing `&`, `<`, `>`, `\"`, `` ` ``, and `'` characters.\n\n``` javascript\n_.escape('Curly, Larry & Moe');\n=> \"Curly, Larry &amp; Moe\"\n```"
- name: _.extend
  id: index#extend
  summary: extend_.extend(destination, *sources) Shallowly copy all of the properties in the source objects over to the destination object, and return the destination object
  description: "**extend**`_.extend(destination, *sources)`  \nShallowly copy all of the properties **in** the **source** objects over to the **destination** object, and return the **destination** object. Any nested objects or arrays will be copied by reference, not duplicated. It's in-order, so the last source will override properties of the same name in previous arguments.\n\n``` javascript\n_.extend({name: 'moe'}, {age: 50});\n=> {name: 'moe', age: 50}\n```"
- name: _.findIndex
  id: index#findIndex
  summary: findIndex_.findIndex(array, predicate, [context]) Similar to _.indexOf, returns the first index where the predicate truth test passes; otherwise returns -1
  description: "**findIndex**`_.findIndex(array, predicate, [context])`  \nSimilar to [`_.indexOf`](#indexOf), returns the first index where the **predicate** truth test passes; otherwise returns *-1*.\n\n``` javascript\n_.findIndex([4, 6, 8, 12], isPrime);\n=> -1 // not found\n_.findIndex([4, 6, 7, 12], isPrime);\n=> 2\n```"
- name: _.findKey
  id: index#findKey
  summary: findKey_.findKey(object, predicate, [context]) Similar to _.findIndex but for keys in objects
  description: "**findKey**`_.findKey(object, predicate, [context])`  \nSimilar to [`_.findIndex`](#findIndex) but for keys in objects. Returns the *key* where the **predicate** truth test passes or *undefined*. **predicate** is transformed through [**iteratee**](#iteratee) to facilitate shorthand syntaxes."
- name: _.findLastIndex
  id: index#findLastIndex
  summary: findLastIndex_.findLastIndex(array, predicate, [context]) Like _.findIndex but iterates the array in reverse, returning the index closest to the end where the predicate truth test passes
  description: "**findLastIndex**`_.findLastIndex(array, predicate, [context])`  \nLike [`_.findIndex`](#findIndex) but iterates the array in reverse, returning the index closest to the end where the **predicate** truth test passes.\n\n``` javascript\nvar users = [{'id': 1, 'name': 'Bob', 'last': 'Brown'},\n             {'id': 2, 'name': 'Ted', 'last': 'White'},\n             {'id': 3, 'name': 'Frank', 'last': 'James'},\n             {'id': 4, 'name': 'Ted', 'last': 'Jones'}];\n_.findLastIndex(users, {\n  name: 'Ted'\n});\n=> 3\n```"
- name: _.findWhere
  id: index#findWhere
  summary: findWhere_.findWhere(list, properties) Looks through the list and returns the first value that matches all of the key-value pairs listed in properties
  description: "**findWhere**`_.findWhere(list, properties)`  \nLooks through the **list** and returns the *first* value that [matches](#matches) all of the key-value pairs listed in **properties**.\n\nIf no match is found, or if **list** is empty, *undefined* will be returned.\n\n``` javascript\n_.findWhere(publicServicePulitzers, {newsroom: \"The New York Times\"});\n=> {year: 1918, newsroom: \"The New York Times\",\n  reason: \"For its public service in publishing in full so many official reports,\n  documents and speeches by European statesmen relating to the progress and\n  conduct of the war.\"}\n```"
- name: _.flatten
  id: index#flatten
  summary: flatten_.flatten(array, [depth]) Flattens a nested array
  description: "**flatten**`_.flatten(array, [depth])`  \nFlattens a nested **array**. If you pass `true` or `1` as the **depth**, the array will only be flattened a single level. Passing a greater number will cause the flattening to descend deeper into the nesting hierarchy. Omitting the **depth** argument, or passing `false` or `Infinity`, flattens the array all the way to the deepest nesting level.\n\n``` javascript\n_.flatten([1, [2], [3, [[4]]]]);\n=> [1, 2, 3, 4];\n\n_.flatten([1, [2], [3, [[4]]]], true);\n=> [1, 2, 3, [[4]]];\n\n_.flatten([1, [2], [3, [[4]]]], 2);\n=> [1, 2, 3, [4]];\n```"
- name: _.get
  id: index#get
  summary: get_.get(object, path, [default]) Returns the specified property of object
  description: "**get**`_.get(object, path, [default])`  \nReturns the specified property of **object**. **path** may be specified as a simple key, or as an array of object keys or array indexes, for deep property fetching. If the property does not exist or is `undefined`, the optional **default** is returned.\n\n``` javascript\n_.get({a: 10}, 'a');\n=> 10\n_.get({a: [{b: 2}]}, ['a', 0, 'b']);\n=> 2\n_.get({a: 10}, 'b', 100);\n=> 100\n```"
- name: _.groupBy
  id: index#groupBy
  summary: groupBy_.groupBy(list, iteratee, [context]) Splits a collection into sets, grouped by the result of running each value through iteratee
  description: "**groupBy**`_.groupBy(list, iteratee, [context])`  \nSplits a collection into sets, grouped by the result of running each value through **iteratee**. If **iteratee** is a string instead of a function, groups by the property named by **iteratee** on each of the values.\n\n``` javascript\n_.groupBy([1.3, 2.1, 2.4], function(num){ return Math.floor(num); });\n=> {1: [1.3], 2: [2.1, 2.4]}\n\n_.groupBy(['one', 'two', 'three'], 'length');\n=> {3: [\"one\", \"two\"], 5: [\"three\"]}\n```"
- name: _.has
  id: index#has
  summary: has_.has(object, key) Does the object contain the given key? Identical to object.hasOwnProperty(key), but uses a safe reference to the hasOwnProperty function, in case it's been overridden accidentally
  description: "**has**`_.has(object, key)`  \nDoes the object contain the given key? Identical to `object.hasOwnProperty(key)`, but uses a safe reference to the `hasOwnProperty` function, in case it's been [overridden accidentally](https://www.pixelstech.net/article/1326986170-An-Object-is-not-a-Hash).\n\n``` javascript\n_.has({a: 1, b: 2, c: 3}, \"b\");\n=> true\n```"
- name: _.identity
  id: index#identity
  summary: identity_.identity(value) Returns the same value that is used as the argument
  description: "**identity**`_.identity(value)`  \nReturns the same value that is used as the argument. In math: `f(x) = x`  \nThis function looks useless, but is used throughout Underscore as a default iteratee.\n\n``` javascript\nvar stooge = {name: 'moe'};\nstooge === _.identity(stooge);\n=> true\n```"
- name: _.indexBy
  id: index#indexBy
  summary: indexBy_.indexBy(list, iteratee, [context]) Given a list, and an iteratee function that returns a key for each element in the list (or a property name), returns an object with an index of each item
  description: "**indexBy**`_.indexBy(list, iteratee, [context])`  \nGiven a **list**, and an [**iteratee**](#iteratee) function that returns a key for each element in the list (or a property name), returns an object with an index of each item. Just like [groupBy](#groupBy), but for when you know your keys are unique.\n\n``` javascript\nvar stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];\n_.indexBy(stooges, 'age');\n=> {\n  \"40\": {name: 'moe', age: 40},\n  \"50\": {name: 'larry', age: 50},\n  \"60\": {name: 'curly', age: 60}\n}\n```"
- name: _.indexOf
  id: index#indexOf
  summary: indexOf_.indexOf(array, value, [isSorted]) Returns the index at which value can be found in the array, or -1 if value is not present in the array
  description: "**indexOf**`_.indexOf(array, value, [isSorted])`  \nReturns the index at which **value** can be found in the **array**, or *-1* if value is not present in the **array**. If you're working with a large array, and you know that the array is already sorted, pass `true` for **isSorted** to use a faster binary search ... or, pass a number as the third argument in order to look for the first matching value in the array after the given index. If `isSorted` is `true`, this function uses operator `<` ([note](#relational-operator-note)).\n\n``` javascript\n_.indexOf([1, 2, 3], 2);\n=> 1\n```"
- name: _.initial
  id: index#initial
  summary: initial_.initial(array, [n]) Returns everything but the last entry of the array
  description: "**initial**`_.initial(array, [n])`  \nReturns everything but the last entry of the array. Especially useful on the arguments object. Pass **n** to exclude the last **n** elements from the result.\n\n``` javascript\n_.initial([5, 4, 3, 2, 1]);\n=> [5, 4, 3, 2]\n```"
- name: _.intersection
  id: index#intersection
  summary: intersection_.intersection(*arrays) Computes the list of values that are the intersection of all the arrays
  description: "**intersection**`_.intersection(*arrays)`  \nComputes the list of values that are the intersection of all the **arrays**. Each value in the result is present in each of the **arrays**.\n\n``` javascript\n_.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);\n=> [1, 2]\n```"
- name: _.invert
  id: index#invert
  summary: invert_.invert(object) Returns a copy of the object where the keys have become the values and the values the keys
  description: "**invert**`_.invert(object)`  \nReturns a copy of the **object** where the keys have become the values and the values the keys. For this to work, all of your object's values should be unique and string serializable.\n\n``` javascript\n_.invert({Moe: \"Moses\", Larry: \"Louis\", Curly: \"Jerome\"});\n=> {Moses: \"Moe\", Louis: \"Larry\", Jerome: \"Curly\"};\n```"
- name: _.invoke
  id: index#invoke
  summary: invoke_.invoke(list, methodName, *arguments) Calls the method named by methodName on each value in the list
  description: "**invoke**`_.invoke(list, methodName, *arguments)`  \nCalls the method named by **methodName** on each value in the **list**. Any extra arguments passed to **invoke** will be forwarded on to the method invocation.\n\n``` javascript\n_.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n=> [[1, 5, 7], [1, 2, 3]]\n```"
- name: _.isArguments
  id: index#isArguments
  summary: isArguments_.isArguments(object) Returns true if object is an Arguments object
  description: "**isArguments**`_.isArguments(object)`  \nReturns *true* if **object** is an Arguments object.\n\n``` javascript\n(function(){ return _.isArguments(arguments); })(1, 2, 3);\n=> true\n_.isArguments([1,2,3]);\n=> false\n```"
- name: _.isArray
  id: index#isArray
  summary: isArray_.isArray(object) Returns true if object is an Array
  description: "**isArray**`_.isArray(object)`  \nReturns *true* if **object** is an Array.\n\n``` javascript\n(function(){ return _.isArray(arguments); })();\n=> false\n_.isArray([1,2,3]);\n=> true\n```"
- name: _.isArrayBuffer
  id: index#isArrayBuffer
  summary: isArrayBuffer_.isArrayBuffer(object) Returns true if object is an ArrayBuffer
  description: "**isArrayBuffer**`_.isArrayBuffer(object)`  \nReturns *true* if **object** is an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).\n\n``` javascript\n_.isArrayBuffer(new ArrayBuffer(8));\n=> true\n```"
- name: _.isBoolean
  id: index#isBoolean
  summary: isBoolean_.isBoolean(object) Returns true if object is either true or false
  description: "**isBoolean**`_.isBoolean(object)`  \nReturns *true* if **object** is either *true* or *false*.\n\n``` javascript\n_.isBoolean(null);\n=> false\n```"
- name: _.isDataView
  id: index#isDataView
  summary: isDataView_.isDataView(object) Returns true if object is a DataView
  description: "**isDataView**`_.isDataView(object)`  \nReturns *true* if **object** is a [DataView](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView).\n\n``` javascript\n_.isDataView(new DataView(new ArrayBuffer(8)));\n=> true\n```"
- name: _.isDate
  id: index#isDate
  summary: isDate_.isDate(object) Returns true if object is a Date
  description: "**isDate**`_.isDate(object)`  \nReturns *true* if **object** is a Date.\n\n``` javascript\n_.isDate(new Date());\n=> true\n```"
- name: _.isElement
  id: index#isElement
  summary: isElement_.isElement(object) Returns true if object is a DOM element
  description: "**isElement**`_.isElement(object)`  \nReturns *true* if **object** is a DOM element.\n\n``` javascript\n_.isElement(jQuery('body')[0]);\n=> true\n```"
- name: _.isEmpty
  id: index#isEmpty
  summary: isEmpty_.isEmpty(collection) Returns true if collection has no elements
  description: "**isEmpty**`_.isEmpty(collection)`  \nReturns *true* if **collection** has no elements. For strings and array-like objects `_.isEmpty` checks if the length property is 0. For other objects, it returns *true* if the object has no enumerable own-properties. Note that primitive numbers, booleans and symbols are always empty by this definition.\n\n``` javascript\n_.isEmpty([1, 2, 3]);\n=> false\n_.isEmpty({});\n=> true\n```"
- name: _.isEqual
  id: index#isEqual
  summary: isEqual_.isEqual(object, other) Performs an optimized deep comparison between the two objects, to determine if they should be considered equal
  description: "**isEqual**`_.isEqual(object, other)`  \nPerforms an optimized deep comparison between the two objects, to determine if they should be considered equal.\n\n``` javascript\nvar stooge = {name: 'moe', luckyNumbers: [13, 27, 34]};\nvar clone  = {name: 'moe', luckyNumbers: [13, 27, 34]};\nstooge == clone;\n=> false\n_.isEqual(stooge, clone);\n=> true\n```"
- name: _.isError
  id: index#isError
  summary: isError_.isError(object) Returns true if object inherits from an Error
  description: "**isError**`_.isError(object)`  \nReturns *true* if **object** inherits from an Error.\n\n``` javascript\ntry {\n  throw new TypeError(\"Example\");\n} catch (o_O) {\n  _.isError(o_O);\n}\n=> true\n```"
- name: _.isFinite
  id: index#isFinite
  summary: isFinite_.isFinite(object) Returns true if object is a finite Number
  description: "**isFinite**`_.isFinite(object)`  \nReturns *true* if **object** is a finite Number.\n\n``` javascript\n_.isFinite(-101);\n=> true\n\n_.isFinite(-Infinity);\n=> false\n```"
- name: _.isFunction
  id: index#isFunction
  summary: isFunction_.isFunction(object) Returns true if object is a Function
  description: "**isFunction**`_.isFunction(object)`  \nReturns *true* if **object** is a Function.\n\n``` javascript\n_.isFunction(alert);\n=> true\n```"
- name: _.isMap
  id: index#isMap
  summary: isMap_.isMap(object) Returns true if object is a Map
  description: "**isMap**`_.isMap(object)`  \nReturns *true* if **object** is a [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map).\n\n``` javascript\n_.isMap(new Map());\n=> true\n```"
- name: _.isMatch
  id: index#isMatch
  summary: isMatch_.isMatch(object, properties) Tells you if the keys and values in properties are contained in object
  description: "**isMatch**`_.isMatch(object, properties)`  \nTells you if the keys and values in **properties** are contained in **object**.\n\n``` javascript\nvar stooge = {name: 'moe', age: 32};\n_.isMatch(stooge, {age: 32});\n=> true\n```"
- name: _.isNaN
  id: index#isNaN
  summary: isNaN_.isNaN(object) Returns true if object is NaN
  description: "**isNaN**`_.isNaN(object)`  \nReturns *true* if **object** is *NaN*.  \nNote: this is not the same as the native **isNaN** function, which will also return true for many other not-number values, such as `undefined`.\n\n``` javascript\n_.isNaN(NaN);\n=> true\nisNaN(undefined);\n=> true\n_.isNaN(undefined);\n=> false\n```"
- name: _.isNull
  id: index#isNull
  summary: isNull_.isNull(object) Returns true if the value of object is null
  description: "**isNull**`_.isNull(object)`  \nReturns *true* if the value of **object** is *null*.\n\n``` javascript\n_.isNull(null);\n=> true\n_.isNull(undefined);\n=> false\n```"
- name: _.isNumber
  id: index#isNumber
  summary: isNumber_.isNumber(object) Returns true if object is a Number (including NaN)
  description: "**isNumber**`_.isNumber(object)`  \nReturns *true* if **object** is a Number (including `NaN`).\n\n``` javascript\n_.isNumber(8.4 * 5);\n=> true\n```"
- name: _.isObject
  id: index#isObject
  summary: isObject_.isObject(value) Returns true if value is an Object
  description: "**isObject**`_.isObject(value)`  \nReturns *true* if **value** is an Object. Note that JavaScript arrays and functions are objects, while (normal) strings and numbers are not.\n\n``` javascript\n_.isObject({});\n=> true\n_.isObject(1);\n=> false\n```"
- name: _.isRegExp
  id: index#isRegExp
  summary: isRegExp_.isRegExp(object) Returns true if object is a RegExp
  description: "**isRegExp**`_.isRegExp(object)`  \nReturns *true* if **object** is a RegExp.\n\n``` javascript\n_.isRegExp(/moe/);\n=> true\n```"
- name: _.isSet
  id: index#isSet
  summary: isSet_.isSet(object) Returns true if object is a Set
  description: "**isSet**`_.isSet(object)`  \nReturns *true* if **object** is a [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set).\n\n``` javascript\n_.isSet(new Set());\n=> true\n```"
- name: _.isString
  id: index#isString
  summary: isString_.isString(object) Returns true if object is a String
  description: "**isString**`_.isString(object)`  \nReturns *true* if **object** is a String.\n\n``` javascript\n_.isString(\"moe\");\n=> true\n```"
- name: _.isSymbol
  id: index#isSymbol
  summary: isSymbol_.isSymbol(object) Returns true if object is a Symbol
  description: "**isSymbol**`_.isSymbol(object)`  \nReturns *true* if **object** is a [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol).\n\n``` javascript\n_.isSymbol(Symbol());\n=> true\n```"
- name: _.isTypedArray
  id: index#isTypedArray
  summary: isTypedArray_.isTypedArray(object) Returns true if object is a TypedArray
  description: "**isTypedArray**`_.isTypedArray(object)`  \nReturns *true* if **object** is a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray).\n\n``` javascript\n_.isTypedArray(new Int8Array(8));\n=> true\n```"
- name: _.isUndefined
  id: index#isUndefined
  summary: isUndefined_.isUndefined(value) Returns true if value is undefined
  description: "**isUndefined**`_.isUndefined(value)`  \nReturns *true* if **value** is *undefined*.\n\n``` javascript\n_.isUndefined(window.missingVariable);\n=> true\n```\n\n## Utility Functions"
- name: _.isWeakMap
  id: index#isWeakMap
  summary: isWeakMap_.isWeakMap(object) Returns true if object is a WeakMap
  description: "**isWeakMap**`_.isWeakMap(object)`  \nReturns *true* if **object** is a [WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap).\n\n``` javascript\n_.isWeakMap(new WeakMap());\n=> true\n```"
- name: _.isWeakSet
  id: index#isWeakSet
  summary: isWeakSet_.isWeakSet(object) Returns true if object is a WeakSet
  description: "**isWeakSet**`_.isWeakSet(object)`  \nReturns *true* if **object** is a [WeakSet](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet).\n\n``` javascript\n_.isWeakSet(WeakSet());\n=> true\n```"
- name: _.iteratee
  id: index#iteratee
  summary: iteratee_.iteratee(value, [context]) Generates a callback that can be applied to each element in a collection
  description: "**iteratee**`_.iteratee(value, [context])`  \nGenerates a callback that can be applied to each element in a collection. `_.iteratee` supports a number of shorthand syntaxes for common callback use cases. Depending upon `value`'s type, `_.iteratee` will return:\n\n``` javascript\n// No value\n_.iteratee();\n=> _.identity()\n\n// Function\n_.iteratee(function(n) { return n * 2; });\n=> function(n) { return n * 2; }\n\n// Object\n_.iteratee({firstName: 'Chelsea'});\n=> _.matcher({firstName: 'Chelsea'});\n\n// Anything else\n_.iteratee('firstName');\n=> _.property('firstName');\n```\n\nThe following Underscore methods transform their predicates through `_.iteratee`: `countBy`, `every`, `filter`, `find`, `findIndex`, `findKey`, `findLastIndex`, `groupBy`, `indexBy`, `map`, `mapObject`, `max`, `min`, `partition`, `reject`, `some`, `sortBy`, `sortedIndex`, and `uniq`\n\nYou may overwrite `_.iteratee` with your own custom function, if you want additional or different shorthand syntaxes:\n\n``` javascript\n// Support `RegExp` predicate shorthand.\nvar builtinIteratee = _.iteratee;\n_.iteratee = function(value, context) {\n  if (_.isRegExp(value)) return function(obj) { return value.test(obj) };\n  return builtinIteratee(value, context);\n};\n```"
- name: _.keys
  id: index#keys
  summary: keys_.keys(object) Retrieve all the names of the object's own enumerable properties
  description: "**keys**`_.keys(object)`  \nRetrieve all the names of the **object**'s own enumerable properties.\n\n``` javascript\n_.keys({one: 1, two: 2, three: 3});\n=> [\"one\", \"two\", \"three\"]\n```"
- name: _.last
  id: index#last
  summary: last_.last(array, [n]) Returns the last element of an array
  description: "**last**`_.last(array, [n])`  \nReturns the last element of an **array**. Passing **n** will return the last **n** elements of the array.\n\n``` javascript\n_.last([5, 4, 3, 2, 1]);\n=> 1\n```"
- name: _.lastIndexOf
  id: index#lastIndexOf
  summary: lastIndexOf_.lastIndexOf(array, value, [fromIndex]) Returns the index of the last occurrence of value in the array, or -1 if value is not present
  description: "**lastIndexOf**`_.lastIndexOf(array, value, [fromIndex])`  \nReturns the index of the last occurrence of **value** in the **array**, or *-1* if value is not present. Pass **fromIndex** to start your search at a given index.\n\n``` javascript\n_.lastIndexOf([1, 2, 3, 1, 2, 3], 2);\n=> 4\n```"
- name: _.mapObject
  id: index#mapObject
  summary: mapObject_.mapObject(object, iteratee, [context]) Like map, but for objects
  description: "**mapObject**`_.mapObject(object, iteratee, [context])`  \nLike [map](#map), but for objects. Transform the value of each property in turn.\n\n``` javascript\n_.mapObject({start: 5, end: 12}, function(val, key) {\n  return val + 5;\n});\n=> {start: 10, end: 17}\n```"
- name: _.max
  id: index#max
  summary: max_.max(list, [iteratee], [context]) Returns the maximum value in list
  description: "**max**`_.max(list, [iteratee], [context])`  \nReturns the maximum value in **list**. If an [**iteratee**](#iteratee) function is provided, it will be used on each value to generate the criterion by which the value is ranked. *-Infinity* is returned if **list** is empty, so an [isEmpty](#isEmpty) guard may be required. This function can currently only compare numbers reliably. This function uses operator `<` ([note](#relational-operator-note)).\n\n``` javascript\nvar stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];\n_.max(stooges, function(stooge){ return stooge.age; });\n=> {name: 'curly', age: 60};\n```"
- name: _.memoize
  id: index#memoize
  summary: memoize_.memoize(function, [hashFunction]) Memoizes a given function by caching the computed result
  description: "**memoize**`_.memoize(function, [hashFunction])`  \nMemoizes a given **function** by caching the computed result. Useful for speeding up slow-running computations. If passed an optional **hashFunction**, it will be used to compute the hash key for storing the result, based on the arguments to the original function. The default **hashFunction** just uses the first argument to the memoized function as the key. The cache of memoized values is available as the `cache` property on the returned function.\n\n``` javascript\nvar fibonacci = _.memoize(function(n) {\n  return n < 2 ? n: fibonacci(n - 1) + fibonacci(n - 2);\n});\n```"
- name: _.min
  id: index#min
  summary: min_.min(list, [iteratee], [context]) Returns the minimum value in list
  description: "**min**`_.min(list, [iteratee], [context])`  \nReturns the minimum value in **list**. If an [**iteratee**](#iteratee) function is provided, it will be used on each value to generate the criterion by which the value is ranked. *Infinity* is returned if **list** is empty, so an [isEmpty](#isEmpty) guard may be required. This function can currently only compare numbers reliably. This function uses operator `<` ([note](#relational-operator-note)).\n\n``` javascript\nvar numbers = [10, 5, 100, 2, 1000];\n_.min(numbers);\n=> 2\n```"
- name: _.mixin
  id: index#mixin
  summary: mixin_.mixin(object) Allows you to extend Underscore with your own utility functions
  description: "**mixin**`_.mixin(object)`  \nAllows you to extend Underscore with your own utility functions. Pass a hash of `{name: function}` definitions to have your functions added to the Underscore object, as well as the OOP wrapper. Returns the Underscore object to facilitate chaining.\n\n``` javascript\n_.mixin({\n  capitalize: function(string) {\n    return string.charAt(0).toUpperCase() + string.substring(1).toLowerCase();\n  }\n});\n_(\"fabio\").capitalize();\n=> \"Fabio\"\n```"
- name: _.negate
  id: index#negate
  summary: negate_.negate(predicate) Returns a new negated version of the predicate function
  description: "**negate**`_.negate(predicate)`  \nReturns a new negated version of the [**predicate**](#iteratee) function.\n\n``` javascript\nvar isFalsy = _.negate(Boolean);\n_.find([-2, -1, 0, 1, 2], isFalsy);\n=> 0\n```"
- name: _.noConflict
  id: index#noConflict
  summary: noConflict_.noConflict() Give control of the global _ variable back to its previous owner
  description: "**noConflict**`_.noConflict()`  \nGive control of the global `_` variable back to its previous owner. Returns a reference to the **Underscore** object.\n\n``` javascript\nvar underscore = _.noConflict();\n```\n\nThe `_.noConflict` function is not present if you use the EcmaScript 6, AMD or CommonJS module system to import Underscore."
- name: _.noop
  id: index#noop
  summary: noop_.noop() Returns undefined irrespective of the arguments passed to it
  description: "**noop**`_.noop()`  \nReturns `undefined` irrespective of the arguments passed to it. Useful as the default for optional callback arguments.\n\n``` javascript\nobj.initialize = _.noop;\n```"
- name: _.now
  id: index#now
  summary: now_.now() Returns an integer timestamp for the current time, using the fastest method available in the runtime
  description: "**now**`_.now()`  \nReturns an integer timestamp for the current time, using the fastest method available in the runtime. Useful for implementing timing/animation functions.\n\n``` javascript\n_.now();\n=> 1392066795351\n```"
- name: _.object
  id: index#object
  summary: object_.object(list, [values]) Converts arrays into objects
  description: "**object**`_.object(list, [values])`  \nConverts arrays into objects. Pass either a single list of `[key, value]` pairs, or a list of keys, and a list of values. Passing by pairs is the reverse of [pairs](#pairs). If duplicate keys exist, the last value wins.\n\n``` javascript\n_.object(['moe', 'larry', 'curly'], [30, 40, 50]);\n=> {moe: 30, larry: 40, curly: 50}\n\n_.object([['moe', 30], ['larry', 40], ['curly', 50]]);\n=> {moe: 30, larry: 40, curly: 50}\n```"
- name: _.omit
  id: index#omit
  summary: omit_.omit(object, *keys) Return a copy of the object, filtered to omit the disallowed keys (or array of keys)
  description: "**omit**`_.omit(object, *keys)`  \nReturn a copy of the **object**, filtered to omit the disallowed **keys** (or array of keys). Alternatively accepts a predicate indicating which keys to omit.\n\n``` javascript\n_.omit({name: 'moe', age: 50, userid: 'moe1'}, 'userid');\n=> {name: 'moe', age: 50}\n_.omit({name: 'moe', age: 50, userid: 'moe1'}, function(value, key, object) {\n  return _.isNumber(value);\n});\n=> {name: 'moe', userid: 'moe1'}\n```"
- name: _.once
  id: index#once
  summary: once_.once(function) Creates a version of the function that can only be called one time
  description: "**once**`_.once(function)`  \nCreates a version of the function that can only be called one time. Repeated calls to the modified function will have no effect, returning the value from the original call. Useful for initialization functions, instead of having to set a boolean flag and then check it later.\n\n``` javascript\nvar initialize = _.once(createApplication);\ninitialize();\ninitialize();\n// Application is only created once.\n```"
- name: _.pairs
  id: index#pairs
  summary: pairs_.pairs(object) Convert an object into a list of [key, value] pairs
  description: "**pairs**`_.pairs(object)`  \nConvert an object into a list of `[key, value]` pairs. The opposite of [object](#object).\n\n``` javascript\n_.pairs({one: 1, two: 2, three: 3});\n=> [[\"one\", 1], [\"two\", 2], [\"three\", 3]]\n```"
- name: _.partial
  id: index#partial
  summary: partial_.partial(function, *arguments) Partially apply a function by filling in any number of its arguments, without changing its dynamic this value
  description: "**partial**`_.partial(function, *arguments)`  \nPartially apply a function by filling in any number of its **arguments**, *without* changing its dynamic `this` value. A close cousin of [bind](#bind). You may pass `_` in your list of **arguments** to specify an argument that should not be pre-filled, but left open to supply at call-time.\n\n``` javascript\nvar subtract = function(a, b) { return b - a; };\nsub5 = _.partial(subtract, 5);\nsub5(20);\n=> 15\n\n// Using a placeholder\nsubFrom20 = _.partial(subtract, _, 20);\nsubFrom20(5);\n=> 15\n```"
- name: _.partition
  id: index#partition
  summary: 'partition_.partition(list, predicate) Split list into two arrays: one whose elements all satisfy predicate and one whose elements all do not satisfy predicate'
  description: "**partition**`_.partition(list, predicate)`  \nSplit **list** into two arrays: one whose elements all satisfy **predicate** and one whose elements all do not satisfy **predicate**. **predicate** is transformed through [**iteratee**](#iteratee) to facilitate shorthand syntaxes.\n\n``` javascript\n_.partition([0, 1, 2, 3, 4, 5], isOdd);\n=> [[1, 3, 5], [0, 2, 4]]\n```"
- name: _.pick
  id: index#pick
  summary: pick_.pick(object, *keys) Return a copy of the object, filtered to only have values for the allowed keys (or array of valid keys)
  description: "**pick**`_.pick(object, *keys)`  \nReturn a copy of the **object**, filtered to only have values for the allowed **keys** (or array of valid keys). Alternatively accepts a predicate indicating which keys to pick.\n\n``` javascript\n_.pick({name: 'moe', age: 50, userid: 'moe1'}, 'name', 'age');\n=> {name: 'moe', age: 50}\n_.pick({name: 'moe', age: 50, userid: 'moe1'}, function(value, key, object) {\n  return _.isNumber(value);\n});\n=> {age: 50}\n```"
- name: _.pluck
  id: index#pluck
  summary: 'pluck_.pluck(list, propertyName) A convenient version of what is perhaps the most common use-case for map: extracting a list of property values'
  description: "**pluck**`_.pluck(list, propertyName)`  \nA convenient version of what is perhaps the most common use-case for **map**: extracting a list of property values.\n\n``` javascript\nvar stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];\n_.pluck(stooges, 'name');\n=> [\"moe\", \"larry\", \"curly\"]\n```"
- name: _.property
  id: index#property
  summary: property_.property(path) Returns a function that will return the specified property of any passed-in object
  description: "**property**`_.property(path)`  \nReturns a function that will return the specified property of any passed-in object. `path` may be specified as a simple key, or as an array of object keys or array indexes, for deep property fetching.\n\n``` javascript\nvar stooge = {name: 'moe'};\n'moe' === _.property('name')(stooge);\n=> true\n\nvar stooges = {moe: {fears: {worst: 'Spiders'}}, curly: {fears: {worst: 'Moe'}}};\nvar curlysWorstFear = _.property(['curly', 'fears', 'worst']);\ncurlysWorstFear(stooges);\n=> 'Moe'\n```"
- name: _.propertyOf
  id: index#propertyOf
  summary: propertyOf_.propertyOf(object) Inverse of _.property
  description: "**propertyOf**`_.propertyOf(object)`  \nInverse of `_.property`. Takes an object and returns a function which will return the value of a provided property.\n\n``` javascript\nvar stooge = {name: 'moe'};\n_.propertyOf(stooge)('name');\n=> 'moe'\n```"
- name: _.random
  id: index#random
  summary: random_.random(min, max) Returns a random integer between min and max, inclusive
  description: "**random**`_.random(min, max)`  \nReturns a random integer between **min** and **max**, inclusive. If you only pass one argument, it will return a number between `0` and that number.\n\n``` javascript\n_.random(0, 100);\n=> 42\n```"
- name: _.range
  id: index#range
  summary: range_.range([start], stop, [step]) A function to create flexibly-numbered lists of integers, handy for each and map loops
  description: "**range**`_.range([start], stop, [step])`  \nA function to create flexibly-numbered lists of integers, handy for `each` and `map` loops. **start**, if omitted, defaults to *0*; **step** defaults to *1*. Returns a list of integers from **start** (inclusive) to **stop** (exclusive), incremented (or decremented) by **step**. Note that ranges that **stop** before they **start** are considered to be zero-length instead of negative — if you'd like a negative range, use a negative **step**.\n\n``` javascript\n_.range(10);\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n_.range(1, 11);\n=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n_.range(0, 30, 5);\n=> [0, 5, 10, 15, 20, 25]\n_.range(0, -10, -1);\n=> [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n_.range(0);\n=> []\n```\n\n## Function (uh, ahem) Functions"
- name: _.reject
  id: index#reject
  summary: reject_.reject(list, predicate, [context]) Returns the values in list without the elements that the truth test (predicate) passes
  description: "**reject**`_.reject(list, predicate, [context])`  \nReturns the values in **list** without the elements that the truth test (**predicate**) passes. The opposite of **filter**. **predicate** is transformed through [**iteratee**](#iteratee) to facilitate shorthand syntaxes.\n\n``` javascript\nvar odds = _.reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });\n=> [1, 3, 5]\n```"
- name: _.restArguments
  id: index#restArguments
  summary: restArguments_.restArguments(function, [startIndex]) Returns a version of the function that, when called, receives all arguments from and beyond startIndex collected into a single array
  description: "**restArguments**`_.restArguments(function, [startIndex])`  \nReturns a version of the **function** that, when called, receives all arguments from and beyond **startIndex** collected into a single array. If you don’t pass an explicit **startIndex**, it will be determined by looking at the number of arguments to the **function** itself. Similar to ES6’s [rest parameters syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` javascript\nvar raceResults = _.restArguments(function(gold, silver, bronze, everyoneElse) {\n  _.each(everyoneElse, sendConsolations);\n});\n\nraceResults(\"Dopey\", \"Grumpy\", \"Happy\", \"Sneezy\", \"Bashful\", \"Sleepy\", \"Doc\");\n```\n\n## Object Functions"
- name: _.result
  id: index#result
  summary: result_.result(object, property, [defaultValue]) If the value of the named property is a function then invoke it with the object as context; otherwise, return it
  description: "**result**`_.result(object, property, [defaultValue])`  \nIf the value of the named **property** is a function then invoke it with the **object** as context; otherwise, return it. If a default value is provided and the property doesn't exist or is undefined then the default will be returned. If `defaultValue` is a function its result will be returned.\n\n``` javascript\nvar object = {cheese: 'crumpets', stuff: function(){ return 'nonsense'; }};\n_.result(object, 'cheese');\n=> \"crumpets\"\n_.result(object, 'stuff');\n=> \"nonsense\"\n_.result(object, 'meat', 'ham');\n=> \"ham\"\n```"
- name: _.sample
  id: index#sample
  summary: sample_.sample(list, [n]) Produce a random sample from the list
  description: "**sample**`_.sample(list, [n])`  \nProduce a random sample from the **list**. Pass a number to return **n** random elements from the list. Otherwise a single random item will be returned.\n\n``` javascript\n_.sample([1, 2, 3, 4, 5, 6]);\n=> 4\n\n_.sample([1, 2, 3, 4, 5, 6], 3);\n=> [1, 6, 2]\n```"
- name: _.shuffle
  id: index#shuffle
  summary: shuffle_.shuffle(list) Returns a shuffled copy of the list, using a version of the Fisher-Yates shuffle
  description: "**shuffle**`_.shuffle(list)`  \nReturns a shuffled copy of the **list**, using a version of the [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle).\n\n``` javascript\n_.shuffle([1, 2, 3, 4, 5, 6]);\n=> [4, 1, 6, 3, 5, 2]\n```"
- name: _.size
  id: index#size
  summary: size_.size(list) Return the number of values in the list
  description: "**size**`_.size(list)`  \nReturn the number of values in the **list**.\n\n``` javascript\n_.size([1, 2, 3, 4, 5]);\n=> 5\n\n_.size({one: 1, two: 2, three: 3});\n=> 3\n```"
- name: _.sortBy
  id: index#sortBy
  summary: sortBy_.sortBy(list, iteratee, [context]) Returns a (stably) sorted copy of list, ranked in ascending order by the results of running each value through iteratee
  description: "**sortBy**`_.sortBy(list, iteratee, [context])`  \nReturns a (stably) sorted copy of **list**, ranked in ascending order by the results of running each value through [**iteratee**](#iteratee). iteratee may also be the string name of the property to sort by (eg. `length`). This function uses operator `<` ([note](#relational-operator-note)).\n\n``` javascript\n_.sortBy([1, 2, 3, 4, 5, 6], function(num){ return Math.sin(num); });\n=> [5, 4, 6, 3, 1, 2]\n\nvar stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];\n_.sortBy(stooges, 'name');\n=> [{name: 'curly', age: 60}, {name: 'larry', age: 50}, {name: 'moe', age: 40}];\n```"
- name: _.sortedIndex
  id: index#sortedIndex
  summary: sortedIndex_.sortedIndex(array, value, [iteratee], [context]) Uses a binary search to determine the smallest index at which the value should be inserted into the array in order to maintain the array's sorted order
  description: "**sortedIndex**`_.sortedIndex(array, value, [iteratee], [context])`  \nUses a binary search to determine the smallest index at which the **value** *should* be inserted into the **array** in order to maintain the **array**'s sorted order. If an [**iteratee**](#iteratee) function is provided, it will be used to compute the sort ranking of each value, including the **value** you pass. The iteratee may also be the string name of the property to sort by (eg. `length`). This function uses operator `<` ([note](#relational-operator-note)).\n\n``` javascript\n_.sortedIndex([10, 20, 30, 40, 50], 35);\n=> 3\n\nvar stooges = [{name: 'moe', age: 40}, {name: 'curly', age: 60}];\n_.sortedIndex(stooges, {name: 'larry', age: 50}, 'age');\n=> 1\n```"
- name: _.tap
  id: index#tap
  summary: tap_.tap(object, interceptor) Invokes interceptor with the object, and then returns object
  description: "**tap**`_.tap(object, interceptor)`  \nInvokes **interceptor** with the **object**, and then returns **object**. The primary purpose of this method is to \"tap into\" a method chain, in order to perform operations on intermediate results within the chain.\n\n``` javascript\n_.chain([1,2,3,200])\n  .filter(function(num) { return num % 2 == 0; })\n  .tap(alert)\n  .map(function(num) { return num * num })\n  .value();\n=> // [2, 200] (alerted)\n=> [4, 40000]\n```"
- name: _.template
  id: index#template
  summary: template_.template(templateString, [settings]) Compiles JavaScript templates into functions that can be evaluated for rendering
  description: "**template**`_.template(templateString, [settings])`  \nCompiles JavaScript templates into functions that can be evaluated for rendering. Useful for rendering complicated bits of HTML from JSON data sources. Template functions can both interpolate values, using `<%= … %>`, as well as execute arbitrary JavaScript code, with `<% … %>`. If you wish to interpolate a value, and have it be HTML-escaped, use `<%- … %>`. When you evaluate a template function, pass in a **data** object that has properties corresponding to the template's free variables. The **settings** argument should be a hash containing any `_.templateSettings` that should be overridden.\n\n``` javascript\nvar compiled = _.template(\"hello: <%= name %>\");\ncompiled({name: 'moe'});\n=> \"hello: moe\"\n\nvar template = _.template(\"<b><%- value %></b>\");\ntemplate({value: '<script>'});\n=> \"<b>&lt;script&gt;</b>\"\n```\n\nYou can also use `print` from within JavaScript code. This is sometimes more convenient than using `<%= ... %>`.\n\n``` javascript\nvar compiled = _.template(\"<% print('Hello ' + epithet); %>\");\ncompiled({epithet: \"stooge\"});\n=> \"Hello stooge\"\n```\n\nIf ERB-style delimiters aren't your cup of tea, you can change Underscore's template settings to use different symbols to set off interpolated code. Define an **interpolate** regex to match expressions that should be interpolated verbatim, an **escape** regex to match expressions that should be inserted after being HTML-escaped, and an **evaluate** regex to match expressions that should be evaluated without insertion into the resulting string. Note that if part of your template matches more than one of these regexes, the first will be applied by the following order of priority: (1) **escape**, (2) **interpolate**, (3) **evaluate**. You may define or omit any combination of the three. For example, to perform [Mustache.js](https://github.com/janl/mustache.js#readme)-style templating:\n\n``` javascript\n_.templateSettings = {\n  interpolate: /\\{\\{(.+?)\\}\\}/g\n};\n\nvar template = _.template(\"Hello {{ name }}!\");\ntemplate({name: \"Mustache\"});\n=> \"Hello Mustache!\"\n```\n\nBy default, **template** places the values from your data in the local scope via the `with` statement. However, you can specify a single variable name with the **variable** setting. This can significantly improve the speed at which a template is able to render.\n\n``` javascript\n_.template(\"Using 'with': \", {variable: 'data'})({answer: 'no'});\n=> \"Using 'with': no\"\n```\n\nPrecompiling your templates can be a big help when debugging errors you can't reproduce. This is because precompiled templates can provide line numbers and a stack trace, something that is not possible when compiling templates on the client. The **source** property is available on the compiled template function for easy precompilation.\n\n``` javascript\n<script>\n  JST.project = ;\n</script>\n```\n\n## Object-Oriented Style\n\nYou can use Underscore in either an object-oriented or a functional style, depending on your preference. The following two lines of code are identical ways to double a list of numbers.\n\n``` javascript\n_.map([1, 2, 3], function(n){ return n * 2; });\n_([1, 2, 3]).map(function(n){ return n * 2; });\n```\n\n## Chaining\n\nCalling `chain` will cause all future method calls to return wrapped objects. When you've finished the computation, call `value` to retrieve the final value. Here's an example of chaining together a **map/flatten/reduce**, in order to get the word count of every word in a song.\n\n``` javascript\nvar lyrics = [\n  {line: 1, words: \"I'm a lumberjack and I'm okay\"},\n  {line: 2, words: \"I sleep all night and I work all day\"},\n  {line: 3, words: \"He's a lumberjack and he's okay\"},\n  {line: 4, words: \"He sleeps all night and he works all day\"}\n];\n\n_.chain(lyrics)\n  .map(function(line) { return line.words.split(' '); })\n  .flatten()\n  .reduce(function(counts, word) {\n    counts[word] = (counts[word] || 0) + 1;\n    return counts;\n  }, {})\n  .value();\n\n=> {lumberjack: 2, all: 4, night: 2 ... }\n```\n\nIn addition, the [Array prototype's methods](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/prototype) are proxied through the chained Underscore object, so you can slip a `reverse` or a `push` into your chain, and continue to modify the array."
- name: _.throttle
  id: index#throttle
  summary: throttle_.throttle(function, wait, [options]) Creates and returns a new, throttled version of the passed function, that, when invoked repeatedly, will only actually call the original function at most once per every wait milliseconds
  description: "**throttle**`_.throttle(function, wait, [options])`  \nCreates and returns a new, throttled version of the passed function, that, when invoked repeatedly, will only actually call the original function at most once per every **wait** milliseconds. Useful for rate-limiting events that occur faster than you can keep up with.\n\nBy default, **throttle** will execute the function as soon as you call it for the first time, and, if you call it again any number of times during the **wait** period, as soon as that period is over. If you'd like to disable the leading-edge call, pass `{leading: false}`, and if you'd like to disable the execution on the trailing-edge, pass  \n`{trailing: false}`.\n\n``` javascript\nvar throttled = _.throttle(updatePosition, 100);\n$(window).scroll(throttled);\n```\n\nIf you need to cancel a scheduled throttle, you can call `.cancel()` on the throttled function."
- name: _.times
  id: index#times
  summary: times_.times(n, iteratee, [context]) Invokes the given iteratee function n times
  description: "**times**`_.times(n, iteratee, [context])`  \nInvokes the given iteratee function **n** times. Each invocation of [**iteratee**](#iteratee) is called with an `index` argument. Produces an array of the returned values.\n\n``` javascript\n_.times(3, function(n){ genie.grantWishNumber(n); });\n```"
- name: _.toArray
  id: index#toArray
  summary: toArray_.toArray(list) Creates a real Array from the list (anything that can be iterated over)
  description: "**toArray**`_.toArray(list)`  \nCreates a real Array from the **list** (anything that can be iterated over). Useful for transmuting the **arguments** object.\n\n``` javascript\n(function(){ return _.toArray(arguments).slice(1); })(1, 2, 3, 4);\n=> [2, 3, 4]\n```"
- name: _.toPath
  id: index#toPath
  summary: toPath_.toPath(path) Ensures that path is an array
  description: "**toPath**`_.toPath(path)`  \nEnsures that **path** is an array. If **path** is a string, it is wrapped in a single-element array; if it is an array already, it is returned unmodified.\n\n``` javascript\n_.toPath('key');\n=> ['key']\n_.toPath(['a', 0, 'b']);\n=> ['a', 0, 'b'] // (same array)\n```\n\n`_.toPath` is used internally in `has`, `get`, `invoke`, `property`, `propertyOf` and `result`, as well as in [**iteratee**](#iteratee) and all functions that depend on it, in order to normalize deep property paths. You can override `_.toPath` if you want to customize this behavior, for example to enable Lodash-like string path shorthands. Be advised that altering `_.toPath` will unavoidably cause some keys to become unreachable; override at your own risk.\n\n``` javascript\n// Support dotted path shorthands.\nvar originalToPath = _.toPath;\n_.mixin({\n  toPath: function(path) {\n    return _.isString(path) ? path.split('.') : originalToPath(path);\n  }\n});\n_.get({a: [{b: 5}]}, 'a.0.b');\n=> 5\n```"
- name: _.unescape
  id: index#unescape
  summary: unescape_.unescape(string) The opposite of escape, replaces &amp;, &lt;, &gt;, &quot;, &#96; and &#x27; with their unescaped counterparts
  description: "**unescape**`_.unescape(string)`  \nThe opposite of [**escape**](#escape), replaces `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#96;` and `&#x27;` with their unescaped counterparts.\n\n``` javascript\n_.unescape('Curly, Larry &amp; Moe');\n=> \"Curly, Larry & Moe\"\n```"
- name: _.union
  id: index#union
  summary: 'union_.union(*arrays) Computes the union of the passed-in arrays: the list of unique items, in order, that are present in one or more of the arrays'
  description: "**union**`_.union(*arrays)`  \nComputes the union of the passed-in **arrays**: the list of unique items, in order, that are present in one or more of the **arrays**.\n\n``` javascript\n_.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);\n=> [1, 2, 3, 101, 10]\n```"
- name: _.uniqueId
  id: index#uniqueId
  summary: uniqueId_.uniqueId([prefix]) Generate a globally-unique id for client-side models or DOM elements that need one
  description: "**uniqueId**`_.uniqueId([prefix])`  \nGenerate a globally-unique id for client-side models or DOM elements that need one. If **prefix** is passed, the id will be appended to it.\n\n``` javascript\n_.uniqueId('contact_');\n=> 'contact_104'\n```"
- name: _.value
  id: index#value
  summary: value_.chain(obj).value() Extracts the value of a wrapped object
  description: "**value**`_.chain(obj).value()`  \nExtracts the value of a wrapped object.\n\n``` javascript\n_.chain([1, 2, 3]).reverse().value();\n=> [3, 2, 1]\n```\n\n© 2009–2021 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors  \nLicensed under the MIT License.  \n[https://underscorejs.org/](https://underscorejs.org/)"
- name: _.values
  id: index#values
  summary: values_.values(object) Return all of the values of the object's own properties
  description: "**values**`_.values(object)`  \nReturn all of the values of the **object**'s own properties.\n\n``` javascript\n_.values({one: 1, two: 2, three: 3});\n=> [1, 2, 3]\n```"
- name: _.where
  id: index#where
  summary: where_.where(list, properties) Looks through each value in the list, returning an array of all the values that matches the key-value pairs listed in properties
  description: "**where**`_.where(list, properties)`  \nLooks through each value in the **list**, returning an array of all the values that [matches](#matches) the key-value pairs listed in **properties**.\n\n``` javascript\n_.where(listOfPlays, {author: \"Shakespeare\", year: 1611});\n=> [{title: \"Cymbeline\", author: \"Shakespeare\", year: 1611},\n    {title: \"The Tempest\", author: \"Shakespeare\", year: 1611}]\n```"
- name: _.without
  id: index#without
  summary: without_.without(array, *values) Returns a copy of the array with all instances of the values removed
  description: "**without**`_.without(array, *values)`  \nReturns a copy of the **array** with all instances of the **values** removed.\n\n``` javascript\n_.without([1, 2, 1, 0, 3, 1, 4], 0, 1);\n=> [2, 3, 4]\n```"
- name: _.wrap
  id: index#wrap
  summary: wrap_.wrap(function, wrapper) Wraps the first function inside of the wrapper function, passing it as the first argument
  description: "**wrap**`_.wrap(function, wrapper)`  \nWraps the first **function** inside of the **wrapper** function, passing it as the first argument. This allows the **wrapper** to execute code before and after the **function** runs, adjust the arguments, and execute it conditionally.\n\n``` javascript\nvar hello = function(name) { return \"hello: \" + name; };\nhello = _.wrap(hello, function(func) {\n  return \"before, \" + func(\"moe\") + \", after\";\n});\nhello();\n=> 'before, hello: moe, after'\n```"
- name: _.zip
  id: index#zip
  summary: zip_.zip(*arrays) Merges together the values of each of the arrays with the values at the corresponding position
  description: "**zip**`_.zip(*arrays)`  \nMerges together the values of each of the **arrays** with the values at the corresponding position. Useful when you have separate data sources that are coordinated through matching array indexes.\n\n``` javascript\n_.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);\n=> [[\"moe\", 30, true], [\"larry\", 40, false], [\"curly\", 50, false]]\n```"
