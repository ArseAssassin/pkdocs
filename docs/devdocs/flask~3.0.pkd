---
name: Flask
slug: flask~3.0
text_format: markdown
generator: src:devdocs
version: '3.0'
copyright: |-
  © 2010 Pallets
  Licensed under the BSD 3-clause License.
  https://flask.palletsprojects.com/en/3.0.x/index.html
homepage: https://palletsprojects.com/p/flask/
generator_command: doc src:devdocs use flask~3.0

---
- name: _AppCtxGlobals
  id: api/index#flask.ctx._AppCtxGlobals
  summary: A plain object
  description: |-
    `class flask.ctx._AppCtxGlobals`

    A plain object. Used as a namespace for storing data during an application context.

    Creating an app context automatically creates this object, which is made available as the `g` proxy.

    'key' in g

    Check whether an attribute is present.

    Changelog

    New in version 0.10.

    iter(g)

    Return an iterator over the attribute names.

    Changelog

    New in version 0.10.
- name: _AppCtxGlobals.get()
  id: api/index#flask.ctx._AppCtxGlobals.get
  summary: Get an attribute by name, or a default value
  description: |-
    `get(name, default=None)`

    Get an attribute by name, or a default value. Like [`dict.get()`](https://docs.python.org/3/library/stdtypes.html#dict.get "(in Python v3.11)").

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – Name of attribute to get.
    - **default** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)") *\|* *None*) – Value to return if the attribute is not present.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")

    Changelog

    New in version 0.10.
- name: _AppCtxGlobals.pop()
  id: api/index#flask.ctx._AppCtxGlobals.pop
  summary: Get and remove an attribute by name
  description: |-
    `pop(name, default=<object object>)`

    Get and remove an attribute by name. Like [`dict.pop()`](https://docs.python.org/3/library/stdtypes.html#dict.pop "(in Python v3.11)").

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – Name of attribute to pop.
    - **default** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – Value to return if the attribute is not present, instead of raising a `KeyError`.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")

    Changelog

    New in version 0.11.
- name: _AppCtxGlobals.setdefault()
  id: api/index#flask.ctx._AppCtxGlobals.setdefault
  summary: Get the value of an attribute if it is present, otherwise set and return a default value
  description: |-
    `setdefault(name, default=None)`

    Get the value of an attribute if it is present, otherwise set and return a default value. Like [`dict.setdefault()`](https://docs.python.org/3/library/stdtypes.html#dict.setdefault "(in Python v3.11)").

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – Name of attribute to get.
    - **default** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)") *\|* *None*) – Value to set and return if the attribute is not present.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")

    Changelog

    New in version 0.11.

    ## Useful Functions and Classes
- name: abort()
  id: api/index#flask.abort
  summary: Raise an HTTPException for the given status code
  description: |-
    `flask.abort(code, *args, **kwargs)`

    Raise an [`HTTPException`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.HTTPException "(in Werkzeug v2.3.x)") for the given status code.

    If [`current_app`](#flask.current_app "flask.current_app") is available, it will call its [`aborter`](#flask.Flask.aborter "flask.Flask.aborter") object, otherwise it will use [`werkzeug.exceptions.abort()`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.abort "(in Werkzeug v2.3.x)").

    Parameters:

    - **code** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* *BaseResponse*) – The status code for the exception, which must be registered in `app.aborter`.
    - **args** (*t.Any*) – Passed to the exception.
    - **kwargs** (*t.Any*) – Passed to the exception.

    Return type:

    t.NoReturn

    Changelog

    New in version 2.2: Calls `current_app.aborter` if available instead of always using Werkzeug’s default `abort`.
- name: Adding a favicon
  id: patterns/favicon/index
  summary: A “favicon” is an icon used by browsers for tabs and bookmarks
  description: "# Adding a favicon\n\nA “favicon” is an icon used by browsers for tabs and bookmarks. This helps to distinguish your website and to give it a unique brand.\n\nA common question is how to add a favicon to a Flask application. First, of course, you need an icon. It should be 16 × 16 pixels and in the ICO file format. This is not a requirement but a de-facto standard supported by all relevant browsers. Put the icon in your static directory as `favicon.ico`.\n\nNow, to get browsers to find your icon, the correct way is to add a link tag in your HTML. So, for example:\n\n``` html+jinja\n<link rel=\"shortcut icon\" href=\"{{ url_for('static', filename='favicon.ico') }}\">\n```\n\nThat’s all you need for most browsers, however some really old ones do not support this standard. The old de-facto standard is to serve this file, with this name, at the website root. If your application is not mounted at the root path of the domain you either need to configure the web server to serve the icon at the root or if you can’t do that you’re out of luck. If however your application is the root you can simply route a redirect:\n\n``` python\napp.add_url_rule('/favicon.ico',\n                 redirect_to=url_for('static', filename='favicon.ico'))\n```\n\nIf you want to save the extra redirect request you can also write a view using [`send_from_directory()`](../../api/index#flask.send_from_directory \"flask.send_from_directory\"):\n\n``` python\nimport os\nfrom flask import send_from_directory\n\n@app.route('/favicon.ico')\ndef favicon():\n    return send_from_directory(os.path.join(app.root_path, 'static'),\n                               'favicon.ico', mimetype='image/vnd.microsoft.icon')\n```\n\nWe can leave out the explicit mimetype and it will be guessed, but we may as well specify it to avoid the extra guessing, as it will always be the same.\n\nThe above will serve the icon via your application and if possible it’s better to configure your dedicated web server to serve it; refer to the web server’s documentation.\n\n## See also\n\n- The [Favicon](https://en.wikipedia.org/wiki/Favicon) article on Wikipedia\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/favicon/](https://flask.palletsprojects.com/en/3.0.x/patterns/favicon/)"
- name: Adding HTTP Method Overrides
  id: patterns/methodoverrides/index
  summary: Some HTTP proxies do not support arbitrary HTTP methods or newer HTTP methods (such as PATCH)
  description: "# Adding HTTP Method Overrides\n\nSome HTTP proxies do not support arbitrary HTTP methods or newer HTTP methods (such as PATCH). In that case it’s possible to “proxy” HTTP methods through another HTTP method in total violation of the protocol.\n\nThe way this works is by letting the client do an HTTP POST request and set the `X-HTTP-Method-Override` header. Then the method is replaced with the header value before being passed to Flask.\n\nThis can be accomplished with an HTTP middleware:\n\n``` python\nclass HTTPMethodOverrideMiddleware(object):\n    allowed_methods = frozenset([\n        'GET',\n        'HEAD',\n        'POST',\n        'DELETE',\n        'PUT',\n        'PATCH',\n        'OPTIONS'\n    ])\n    bodyless_methods = frozenset(['GET', 'HEAD', 'OPTIONS', 'DELETE'])\n\n    def __init__(self, app):\n        self.app = app\n\n    def __call__(self, environ, start_response):\n        method = environ.get('HTTP_X_HTTP_METHOD_OVERRIDE', '').upper()\n        if method in self.allowed_methods:\n            environ['REQUEST_METHOD'] = method\n        if method in self.bodyless_methods:\n            environ['CONTENT_LENGTH'] = '0'\n        return self.app(environ, start_response)\n```\n\nTo use this with Flask, wrap the app object with the middleware:\n\n``` python\nfrom flask import Flask\n\napp = Flask(__name__)\napp.wsgi_app = HTTPMethodOverrideMiddleware(app.wsgi_app)\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/methodoverrides/](https://flask.palletsprojects.com/en/3.0.x/patterns/methodoverrides/)"
- name: after_this_request()
  id: api/index#flask.after_this_request
  summary: Executes a function after this request
  description: |-
    `flask.after_this_request(f)`

    Executes a function after this request. This is useful to modify response objects. The function is passed the response object and has to return the same or a new one.

    Example:

    ``` python
    @app.route('/')
    def index():
        @after_this_request
        def add_header(response):
            response.headers['X-Foo'] = 'Parachute'
            return response
        return 'Hello World!'
    ```

    This is more useful if a function other than the view function wants to modify a response. For instance think of a decorator that wants to add some headers without converting the return value into a response object.

    Changelog

    New in version 0.9.

    Parameters:

    **f** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[ResponseClass\],* *ResponseClass\]* *\|* [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[ResponseClass\],* [Awaitable](https://docs.python.org/3/library/typing.html#typing.Awaitable "(in Python v3.11)")*\[ResponseClass\]\]*) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*ResponseClass*\], *ResponseClass*\] \| [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*ResponseClass*\], [Awaitable](https://docs.python.org/3/library/typing.html#typing.Awaitable "(in Python v3.11)")\[*ResponseClass*\]\]
- name: Apache httpd
  id: deploying/apache-httpd/index
  summary: Apache httpd is a fast, production level HTTP server
  description: "# Apache httpd\n\n[Apache httpd](https://httpd.apache.org/) is a fast, production level HTTP server. When serving your application with one of the WSGI servers listed in [Deploying to Production](../index), it is often good or necessary to put a dedicated HTTP server in front of it. This “reverse proxy” can handle incoming requests, TLS, and other security and performance concerns better than the WSGI server.\n\nhttpd can be installed using your system package manager, or a pre-built executable for Windows. Installing and running httpd itself is outside the scope of this doc. This page outlines the basics of configuring httpd to proxy your application. Be sure to read its documentation to understand what features are available.\n\n## Domain Name\n\nAcquiring and configuring a domain name is outside the scope of this doc. In general, you will buy a domain name from a registrar, pay for server space with a hosting provider, and then point your registrar at the hosting provider’s name servers.\n\nTo simulate this, you can also edit your `hosts` file, located at `/etc/hosts` on Linux. Add a line that associates a name with the local IP.\n\nModern Linux systems may be configured to treat any domain name that ends with `.localhost` like this without adding it to the `hosts` file.\n\n`/etc/hosts`\n\n``` python\n127.0.0.1 hello.localhost\n```\n\n## Configuration\n\nThe httpd configuration is located at `/etc/httpd/conf/httpd.conf` on Linux. It may be different depending on your operating system. Check the docs and look for `httpd.conf`.\n\nRemove or comment out any existing `DocumentRoot` directive. Add the config lines below. We’ll assume the WSGI server is listening locally at `http://127.0.0.1:8000`.\n\n`/etc/httpd/conf/httpd.conf`\n\n``` apache\nLoadModule proxy_module modules/mod_proxy.so\nLoadModule proxy_http_module modules/mod_proxy_http.so\nProxyPass / http://127.0.0.1:8000/\nRequestHeader set X-Forwarded-Proto http\nRequestHeader set X-Forwarded-Prefix /\n```\n\nThe `LoadModule` lines might already exist. If so, make sure they are uncommented instead of adding them manually.\n\nThen [Tell Flask it is Behind a Proxy](../proxy_fix/index) so that your application uses the `X-Forwarded` headers. `X-Forwarded-For` and `X-Forwarded-Host` are automatically set by `ProxyPass`.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/deploying/apache-httpd/](https://flask.palletsprojects.com/en/3.0.x/deploying/apache-httpd/)"
- name: AppContext
  id: api/index#flask.ctx.AppContext
  summary: The app context contains application-specific information
  description: |-
    `class flask.ctx.AppContext(app)`

    The app context contains application-specific information. An app context is created and pushed at the beginning of each request if one is not already active. An app context is also pushed when running CLI commands.

    Parameters:

    **app** ([Flask](#flask.Flask "flask.Flask")) –
- name: AppContext.pop()
  id: api/index#flask.ctx.AppContext.pop
  summary: Pops the app context
  description: |-
    `pop(exc=<object object>)`

    Pops the app context.

    Parameters:

    **exc** ([BaseException](https://docs.python.org/3/library/exceptions.html#BaseException "(in Python v3.11)") *\|* *None*) –

    Return type:

    None
- name: AppContext.push()
  id: api/index#flask.ctx.AppContext.push
  summary: Binds the app context to the current context
  description: |-
    `push()`

    Binds the app context to the current context.

    Return type:

    None
- name: AppGroup
  id: api/index#flask.cli.AppGroup
  summary: This works similar to a regular click Group but it changes the behavior of the command() decorator so that it automatically wraps the functions in with_appcontext()
  description: |-
    `class flask.cli.AppGroup(name=None, commands=None, **attrs)`

    This works similar to a regular click [`Group`](https://click.palletsprojects.com/en/8.1.x/api/#click.Group "(in Click v8.1.x)") but it changes the behavior of the [`command()`](#flask.cli.AppGroup.command "flask.cli.AppGroup.command") decorator so that it automatically wraps the functions in [`with_appcontext()`](#flask.cli.with_appcontext "flask.cli.with_appcontext").

    Not to be confused with [`FlaskGroup`](#flask.cli.FlaskGroup "flask.cli.FlaskGroup").

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **commands** ([MutableMapping](https://docs.python.org/3/library/typing.html#typing.MutableMapping "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Command](https://click.palletsprojects.com/en/8.1.x/api/#click.Command "(in Click v8.1.x)")*\]* *\|* [Sequence](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.11)")*\[*[Command](https://click.palletsprojects.com/en/8.1.x/api/#click.Command "(in Click v8.1.x)")*\]* *\|* *None*) –
    - **attrs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
- name: AppGroup.command()
  id: api/index#flask.cli.AppGroup.command
  summary: This works exactly like the method of the same name on a regular click.Group but it wraps callbacks in with_appcontext() unless it’s disabled by passing with_appcontext=False
  description: |-
    `command(*args, **kwargs)`

    This works exactly like the method of the same name on a regular [`click.Group`](https://click.palletsprojects.com/en/8.1.x/api/#click.Group "(in Click v8.1.x)") but it wraps callbacks in [`with_appcontext()`](#flask.cli.with_appcontext "flask.cli.with_appcontext") unless it’s disabled by passing `with_appcontext=False`.
- name: AppGroup.group()
  id: api/index#flask.cli.AppGroup.group
  summary: This works exactly like the method of the same name on a regular click.Group but it defaults the group class to AppGroup
  description: |-
    `group(*args, **kwargs)`

    This works exactly like the method of the same name on a regular [`click.Group`](https://click.palletsprojects.com/en/8.1.x/api/#click.Group "(in Click v8.1.x)") but it defaults the group class to [`AppGroup`](#flask.cli.AppGroup "flask.cli.AppGroup").
- name: Application Dispatching
  id: patterns/appdispatch/index
  summary: Application dispatching is the process of combining multiple Flask applications on the WSGI level
  description: "# Application Dispatching\n\nApplication dispatching is the process of combining multiple Flask applications on the WSGI level. You can combine not only Flask applications but any WSGI application. This would allow you to run a Django and a Flask application in the same interpreter side by side if you want. The usefulness of this depends on how the applications work internally.\n\nThe fundamental difference from [Large Applications as Packages](../packages/index) is that in this case you are running the same or different Flask applications that are entirely isolated from each other. They run different configurations and are dispatched on the WSGI level.\n\n## Working with this Document\n\nEach of the techniques and examples below results in an `application` object that can be run with any WSGI server. For development, use the `flask run` command to start a development server. For production, see [Deploying to Production](../../deploying/index).\n\n``` python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello World!'\n```\n\n## Combining Applications\n\nIf you have entirely separated applications and you want them to work next to each other in the same Python interpreter process you can take advantage of the `werkzeug.wsgi.DispatcherMiddleware`. The idea here is that each Flask application is a valid WSGI application and they are combined by the dispatcher middleware into a larger one that is dispatched based on prefix.\n\nFor example you could have your main application run on `/` and your backend interface on `/backend`.\n\n``` python\nfrom werkzeug.middleware.dispatcher import DispatcherMiddleware\nfrom frontend_app import application as frontend\nfrom backend_app import application as backend\n\napplication = DispatcherMiddleware(frontend, {\n    '/backend': backend\n})\n```\n\n## Dispatch by Subdomain\n\nSometimes you might want to use multiple instances of the same application with different configurations. Assuming the application is created inside a function and you can call that function to instantiate it, that is really easy to implement. In order to develop your application to support creating new instances in functions have a look at the [Application Factories](../appfactories/index) pattern.\n\nA very common example would be creating applications per subdomain. For instance you configure your webserver to dispatch all requests for all subdomains to your application and you then use the subdomain information to create user-specific instances. Once you have your server set up to listen on all subdomains you can use a very simple WSGI application to do the dynamic application creation.\n\nThe perfect level for abstraction in that regard is the WSGI layer. You write your own WSGI application that looks at the request that comes and delegates it to your Flask application. If that application does not exist yet, it is dynamically created and remembered.\n\n``` python\nfrom threading import Lock\n\nclass SubdomainDispatcher:\n\n    def __init__(self, domain, create_app):\n        self.domain = domain\n        self.create_app = create_app\n        self.lock = Lock()\n        self.instances = {}\n\n    def get_application(self, host):\n        host = host.split(':')[0]\n        assert host.endswith(self.domain), 'Configuration error'\n        subdomain = host[:-len(self.domain)].rstrip('.')\n        with self.lock:\n            app = self.instances.get(subdomain)\n            if app is None:\n                app = self.create_app(subdomain)\n                self.instances[subdomain] = app\n            return app\n\n    def __call__(self, environ, start_response):\n        app = self.get_application(environ['HTTP_HOST'])\n        return app(environ, start_response)\n```\n\nThis dispatcher can then be used like this:\n\n``` python\nfrom myapplication import create_app, get_user_for_subdomain\nfrom werkzeug.exceptions import NotFound\n\ndef make_app(subdomain):\n    user = get_user_for_subdomain(subdomain)\n    if user is None:\n        # if there is no user for that subdomain we still have\n        # to return a WSGI application that handles that request.\n        # We can then just return the NotFound() exception as\n        # application which will render a default 404 page.\n        # You might also redirect the user to the main page then\n        return NotFound()\n\n    # otherwise create the application for the specific user\n    return create_app(user)\n\napplication = SubdomainDispatcher('example.com', make_app)\n```\n\n## Dispatch by Path\n\nDispatching by a path on the URL is very similar. Instead of looking at the `Host` header to figure out the subdomain one simply looks at the request path up to the first slash.\n\n``` python\nfrom threading import Lock\nfrom wsgiref.util import shift_path_info\n\nclass PathDispatcher:\n\n    def __init__(self, default_app, create_app):\n        self.default_app = default_app\n        self.create_app = create_app\n        self.lock = Lock()\n        self.instances = {}\n\n    def get_application(self, prefix):\n        with self.lock:\n            app = self.instances.get(prefix)\n            if app is None:\n                app = self.create_app(prefix)\n                if app is not None:\n                    self.instances[prefix] = app\n            return app\n\n    def __call__(self, environ, start_response):\n        app = self.get_application(_peek_path_info(environ))\n        if app is not None:\n            shift_path_info(environ)\n        else:\n            app = self.default_app\n        return app(environ, start_response)\n\ndef _peek_path_info(environ):\n    segments = environ.get(\"PATH_INFO\", \"\").lstrip(\"/\").split(\"/\", 1)\n    if segments:\n        return segments[0]\n\n    return None\n```\n\nThe big difference between this and the subdomain one is that this one falls back to another application if the creator function returns `None`.\n\n``` python\nfrom myapplication import create_app, default_app, get_user_for_prefix\n\ndef make_app(prefix):\n    user = get_user_for_prefix(prefix)\n    if user is not None:\n        return create_app(user)\n\napplication = PathDispatcher(default_app, make_app)\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/appdispatch/](https://flask.palletsprojects.com/en/3.0.x/patterns/appdispatch/)"
- name: Application Factories
  id: patterns/appfactories/index
  summary: If you are already using packages and blueprints for your application (Modular Applications with Blueprints) there are a couple of really nice ways to further improve the experience
  description: "# Application Factories\n\nIf you are already using packages and blueprints for your application ([Modular Applications with Blueprints](../../blueprints/index)) there are a couple of really nice ways to further improve the experience. A common pattern is creating the application object when the blueprint is imported. But if you move the creation of this object into a function, you can then create multiple instances of this app later.\n\nSo why would you want to do this?\n\n1.  Testing. You can have instances of the application with different settings to test every case.\n2.  Multiple instances. Imagine you want to run different versions of the same application. Of course you could have multiple instances with different configs set up in your webserver, but if you use factories, you can have multiple instances of the same application running in the same application process which can be handy.\n\nSo how would you then actually implement that?\n\n## Basic Factories\n\nThe idea is to set up the application in a function. Like this:\n\n``` python\ndef create_app(config_filename):\n    app = Flask(__name__)\n    app.config.from_pyfile(config_filename)\n\n    from yourapplication.model import db\n    db.init_app(app)\n\n    from yourapplication.views.admin import admin\n    from yourapplication.views.frontend import frontend\n    app.register_blueprint(admin)\n    app.register_blueprint(frontend)\n\n    return app\n```\n\nThe downside is that you cannot use the application object in the blueprints at import time. You can however use it from within a request. How do you get access to the application with the config? Use [`current_app`](../../api/index#flask.current_app \"flask.current_app\"):\n\n``` python\nfrom flask import current_app, Blueprint, render_template\nadmin = Blueprint('admin', __name__, url_prefix='/admin')\n\n@admin.route('/')\ndef index():\n    return render_template(current_app.config['INDEX_TEMPLATE'])\n```\n\nHere we look up the name of a template in the config.\n\n## Factories & Extensions\n\nIt’s preferable to create your extensions and app factories so that the extension object does not initially get bound to the application.\n\nUsing [Flask-SQLAlchemy](https://flask-sqlalchemy.palletsprojects.com/), as an example, you should not do something along those lines:\n\n``` python\ndef create_app(config_filename):\n    app = Flask(__name__)\n    app.config.from_pyfile(config_filename)\n\n    db = SQLAlchemy(app)\n```\n\nBut, rather, in model.py (or equivalent):\n\n``` python\ndb = SQLAlchemy()\n```\n\nand in your application.py (or equivalent):\n\n``` python\ndef create_app(config_filename):\n    app = Flask(__name__)\n    app.config.from_pyfile(config_filename)\n\n    from yourapplication.model import db\n    db.init_app(app)\n```\n\nUsing this design pattern, no application-specific state is stored on the extension object, so one extension object can be used for multiple apps. For more information about the design of extensions refer to [Flask Extension Development](https://flask.palletsprojects.com/en/3.0.x/extensiondev/).\n\n## Using Applications\n\nTo run such an application, you can use the **flask** command:\n\n``` text\n$ flask --app hello run\n```\n\nFlask will automatically detect the factory if it is named `create_app` or `make_app` in `hello`. You can also pass arguments to the factory like this:\n\n``` text\n$ flask --app hello:create_app(local_auth=True) run\n```\n\nThen the `create_app` factory in `myapp` is called with the keyword argument `local_auth=True`. See [Command Line Interface](../../cli/index) for more detail.\n\n## Factory Improvements\n\nThe factory function above is not very clever, but you can improve it. The following changes are straightforward to implement:\n\n1.  Make it possible to pass in configuration values for unit tests so that you don’t have to create config files on the filesystem.\n2.  Call a function from a blueprint when the application is setting up so that you have a place to modify attributes of the application (like hooking in before/after request handlers etc.)\n3.  Add in WSGI middlewares when the application is being created if necessary.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/appfactories/](https://flask.palletsprojects.com/en/3.0.x/patterns/appfactories/)"
- name: Application Structure and Lifecycle
  id: lifecycle/index
  summary: Flask makes it pretty easy to write a web application
  description: "# Application Structure and Lifecycle\n\nFlask makes it pretty easy to write a web application. But there are quite a few different parts to an application and to each request it handles. Knowing what happens during application setup, serving, and handling requests will help you know what’s possible in Flask and how to structure your application.\n\n## Application Setup\n\nThe first step in creating a Flask application is creating the application object. Each Flask application is an instance of the [`Flask`](../api/index#flask.Flask \"flask.Flask\") class, which collects all configuration, extensions, and views.\n\n``` python\nfrom flask import Flask\n\napp = Flask(__name__)\napp.config.from_mapping(\n    SECRET_KEY=\"dev\",\n)\napp.config.from_prefixed_env()\n\n@app.route(\"/\")\ndef index():\n    return \"Hello, World!\"\n```\n\nThis is known as the “application setup phase”, it’s the code you write that’s outside any view functions or other handlers. It can be split up between different modules and sub-packages, but all code that you want to be part of your application must be imported in order for it to be registered.\n\nAll application setup must be completed before you start serving your application and handling requests. This is because WSGI servers divide work between multiple workers, or can be distributed across multiple machines. If the configuration changed in one worker, there’s no way for Flask to ensure consistency between other workers.\n\nFlask tries to help developers catch some of these setup ordering issues by showing an error if setup-related methods are called after requests are handled. In that case you’ll see this error:\n\nThe setup method ‘route’ can no longer be called on the application. It has already handled its first request, any changes will not be applied consistently. Make sure all imports, decorators, functions, etc. needed to set up the application are done before running it.\n\nHowever, it is not possible for Flask to detect all cases of out-of-order setup. In general, don’t do anything to modify the `Flask` app object and `Blueprint` objects from within view functions that run during requests. This includes:\n\n- Adding routes, view functions, and other request handlers with `@app.route`, `@app.errorhandler`, `@app.before_request`, etc.\n- Registering blueprints.\n- Loading configuration with `app.config`.\n- Setting up the Jinja template environment with `app.jinja_env`.\n- Setting a session interface, instead of the default itsdangerous cookie.\n- Setting a JSON provider with `app.json`, instead of the default provider.\n- Creating and initializing Flask extensions.\n\n## Serving the Application\n\nFlask is a WSGI application framework. The other half of WSGI is the WSGI server. During development, Flask, through Werkzeug, provides a development WSGI server with the `flask run` CLI command. When you are done with development, use a production server to serve your application, see [Deploying to Production](../deploying/index).\n\nRegardless of what server you’re using, it will follow the [**PEP 3333**](https://peps.python.org/pep-3333/) WSGI spec. The WSGI server will be told how to access your Flask application object, which is the WSGI application. Then it will start listening for HTTP requests, translate the request data into a WSGI environ, and call the WSGI application with that data. The WSGI application will return data that is translated into an HTTP response.\n\n1.  Browser or other client makes HTTP request.\n2.  WSGI server receives request.\n3.  WSGI server converts HTTP data to WSGI `environ` dict.\n4.  WSGI server calls WSGI application with the `environ`.\n5.  Flask, the WSGI application, does all its internal processing to route the request to a view function, handle errors, etc.\n6.  Flask translates View function return into WSGI response data, passes it to WSGI server.\n7.  WSGI server creates and send an HTTP response.\n8.  Client receives the HTTP response.\n\n### Middleware\n\nThe WSGI application above is a callable that behaves in a certain way. Middleware is a WSGI application that wraps another WSGI application. It’s a similar concept to Python decorators. The outermost middleware will be called by the server. It can modify the data passed to it, then call the WSGI application (or further middleware) that it wraps, and so on. And it can take the return value of that call and modify it further.\n\nFrom the WSGI server’s perspective, there is one WSGI application, the one it calls directly. Typically, Flask is the “real” application at the end of the chain of middleware. But even Flask can call further WSGI applications, although that’s an advanced, uncommon use case.\n\nA common middleware you’ll see used with Flask is Werkzeug’s [`ProxyFix`](https://werkzeug.palletsprojects.com/en/2.3.x/middleware/proxy_fix/#werkzeug.middleware.proxy_fix.ProxyFix \"(in Werkzeug v2.3.x)\"), which modifies the request to look like it came directly from a client even if it passed through HTTP proxies on the way. There are other middleware that can handle serving static files, authentication, etc.\n\n## How a Request is Handled\n\nFor us, the interesting part of the steps above is when Flask gets called by the WSGI server (or middleware). At that point, it will do quite a lot to handle the request and generate the response. At the most basic, it will match the URL to a view function, call the view function, and pass the return value back to the server. But there are many more parts that you can use to customize its behavior.\n\n1.  WSGI server calls the Flask object, which calls [`Flask.wsgi_app()`](../api/index#flask.Flask.wsgi_app \"flask.Flask.wsgi_app\").\n2.  A [`RequestContext`](../api/index#flask.ctx.RequestContext \"flask.ctx.RequestContext\") object is created. This converts the WSGI `environ` dict into a [`Request`](../api/index#flask.Request \"flask.Request\") object. It also creates an `AppContext` object.\n3.  The [app context](../appcontext/index) is pushed, which makes [`current_app`](../api/index#flask.current_app \"flask.current_app\") and [`g`](../api/index#flask.g \"flask.g\") available.\n4.  The [`appcontext_pushed`](../api/index#flask.appcontext_pushed \"flask.appcontext_pushed\") signal is sent.\n5.  The [request context](../reqcontext/index) is pushed, which makes [`request`](../api/index#flask.request \"flask.request\") and [`session`](../api/index#flask.session \"flask.session\") available.\n6.  The session is opened, loading any existing session data using the app’s [`session_interface`](../api/index#flask.Flask.session_interface \"flask.Flask.session_interface\"), an instance of [`SessionInterface`](../api/index#flask.sessions.SessionInterface \"flask.sessions.SessionInterface\").\n7.  The URL is matched against the URL rules registered with the [`route()`](../api/index#flask.Flask.route \"flask.Flask.route\") decorator during application setup. If there is no match, the error - usually a 404, 405, or redirect - is stored to be handled later.\n8.  The [`request_started`](../api/index#flask.request_started \"flask.request_started\") signal is sent.\n9.  Any [`url_value_preprocessor()`](../api/index#flask.Flask.url_value_preprocessor \"flask.Flask.url_value_preprocessor\") decorated functions are called.\n10. Any [`before_request()`](../api/index#flask.Flask.before_request \"flask.Flask.before_request\") decorated functions are called. If any of these function returns a value it is treated as the response immediately.\n11. If the URL didn’t match a route a few steps ago, that error is raised now.\n12. The [`route()`](../api/index#flask.Flask.route \"flask.Flask.route\") decorated view function associated with the matched URL is called and returns a value to be used as the response.\n13. If any step so far raised an exception, and there is an [`errorhandler()`](../api/index#flask.Flask.errorhandler \"flask.Flask.errorhandler\") decorated function that matches the exception class or HTTP error code, it is called to handle the error and return a response.\n14. Whatever returned a response value - a before request function, the view, or an error handler, that value is converted to a [`Response`](../api/index#flask.Response \"flask.Response\") object.\n15. Any [`after_this_request()`](../api/index#flask.after_this_request \"flask.after_this_request\") decorated functions are called, then cleared.\n16. Any [`after_request()`](../api/index#flask.Flask.after_request \"flask.Flask.after_request\") decorated functions are called, which can modify the response object.\n17. The session is saved, persisting any modified session data using the app’s [`session_interface`](../api/index#flask.Flask.session_interface \"flask.Flask.session_interface\").\n18. The [`request_finished`](../api/index#flask.request_finished \"flask.request_finished\") signal is sent.\n19. If any step so far raised an exception, and it was not handled by an error handler function, it is handled now. HTTP exceptions are treated as responses with their corresponding status code, other exceptions are converted to a generic 500 response. The [`got_request_exception`](../api/index#flask.got_request_exception \"flask.got_request_exception\") signal is sent.\n20. The response object’s status, headers, and body are returned to the WSGI server.\n21. Any [`teardown_request()`](../api/index#flask.Flask.teardown_request \"flask.Flask.teardown_request\") decorated functions are called.\n22. The [`request_tearing_down`](../api/index#flask.request_tearing_down \"flask.request_tearing_down\") signal is sent.\n23. The request context is popped, [`request`](../api/index#flask.request \"flask.request\") and [`session`](../api/index#flask.session \"flask.session\") are no longer available.\n24. Any [`teardown_appcontext()`](../api/index#flask.Flask.teardown_appcontext \"flask.Flask.teardown_appcontext\") decorated functions are called.\n25. The [`appcontext_tearing_down`](../api/index#flask.appcontext_tearing_down \"flask.appcontext_tearing_down\") signal is sent.\n26. The app context is popped, [`current_app`](../api/index#flask.current_app \"flask.current_app\") and [`g`](../api/index#flask.g \"flask.g\") are no longer available.\n27. The [`appcontext_popped`](../api/index#flask.appcontext_popped \"flask.appcontext_popped\") signal is sent.\n\nThere are even more decorators and customization points than this, but that aren’t part of every request lifecycle. They’re more specific to certain things you might use during a request, such as templates, building URLs, or handling JSON data. See the rest of this documentation, as well as the [API](../api/index) to explore further.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/lifecycle/](https://flask.palletsprojects.com/en/3.0.x/lifecycle/)"
- name: APPLICATION_ROOT
  id: config/index#APPLICATION_ROOT
  summary: Inform the application what path it is mounted under by the application / web server
  belongs_to: Configuration Handling
  description: |-
    `APPLICATION_ROOT`

    Inform the application what path it is mounted under by the application / web server. This is used for generating URLs outside the context of a request (inside a request, the dispatcher is responsible for setting `SCRIPT_NAME` instead; see [Application Dispatching](../patterns/appdispatch/index) for examples of dispatch configuration).

    Will be used for the session cookie path if `SESSION_COOKIE_PATH` is not set.

    Default: `'/'`
- name: ASGI
  id: deploying/asgi/index
  summary: If you’d like to use an ASGI server you will need to utilise WSGI to ASGI middleware
  description: "# ASGI\n\nIf you’d like to use an ASGI server you will need to utilise WSGI to ASGI middleware. The asgiref [WsgiToAsgi](https://github.com/django/asgiref#wsgi-to-asgi-adapter) adapter is recommended as it integrates with the event loop used for Flask’s [Using async and await](../../async-await/index#async-await) support. You can use the adapter by wrapping the Flask app,\n\n``` python\nfrom asgiref.wsgi import WsgiToAsgi\nfrom flask import Flask\n\napp = Flask(__name__)\n\n...\n\nasgi_app = WsgiToAsgi(app)\n```\n\nand then serving the `asgi_app` with the ASGI server, e.g. using [Hypercorn](https://gitlab.com/pgjones/hypercorn),\n\n``` text\n$ hypercorn module:asgi_app\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/deploying/asgi/](https://flask.palletsprojects.com/en/3.0.x/deploying/asgi/)"
- name: Background Tasks with Celery
  id: patterns/celery/index
  summary: If your application has a long running task, such as processing some uploaded data or sending email, you don’t want to wait for it to finish during a request
  description: "# Background Tasks with Celery\n\nIf your application has a long running task, such as processing some uploaded data or sending email, you don’t want to wait for it to finish during a request. Instead, use a task queue to send the necessary data to another process that will run the task in the background while the request returns immediately.\n\n[Celery](https://celery.readthedocs.io) is a powerful task queue that can be used for simple background tasks as well as complex multi-stage programs and schedules. This guide will show you how to configure Celery using Flask. Read Celery’s [First Steps with Celery](https://celery.readthedocs.io/en/latest/getting-started/first-steps-with-celery.html) guide to learn how to use Celery itself.\n\nThe Flask repository contains [an example](https://github.com/pallets/flask/tree/main/examples/celery) based on the information on this page, which also shows how to use JavaScript to submit tasks and poll for progress and results.\n\n## Install\n\nInstall Celery from PyPI, for example using pip:\n\n``` text\n$ pip install celery\n```\n\n## Integrate Celery with Flask\n\nYou can use Celery without any integration with Flask, but it’s convenient to configure it through Flask’s config, and to let tasks access the Flask application.\n\nCelery uses similar ideas to Flask, with a `Celery` app object that has configuration and registers tasks. While creating a Flask app, use the following code to create and configure a Celery app as well.\n\n``` python\nfrom celery import Celery, Task\n\ndef celery_init_app(app: Flask) -> Celery:\n    class FlaskTask(Task):\n        def __call__(self, *args: object, **kwargs: object) -> object:\n            with app.app_context():\n                return self.run(*args, **kwargs)\n\n    celery_app = Celery(app.name, task_cls=FlaskTask)\n    celery_app.config_from_object(app.config[\"CELERY\"])\n    celery_app.set_default()\n    app.extensions[\"celery\"] = celery_app\n    return celery_app\n```\n\nThis creates and returns a `Celery` app object. Celery [configuration](https://celery.readthedocs.io/en/stable/userguide/configuration.html) is taken from the `CELERY` key in the Flask configuration. The Celery app is set as the default, so that it is seen during each request. The `Task` subclass automatically runs task functions with a Flask app context active, so that services like your database connections are available.\n\nHere’s a basic `example.py` that configures Celery to use Redis for communication. We enable a result backend, but ignore results by default. This allows us to store results only for tasks where we care about the result.\n\n``` python\nfrom flask import Flask\n\napp = Flask(__name__)\napp.config.from_mapping(\n    CELERY=dict(\n        broker_url=\"redis://localhost\",\n        result_backend=\"redis://localhost\",\n        task_ignore_result=True,\n    ),\n)\ncelery_app = celery_init_app(app)\n```\n\nPoint the `celery worker` command at this and it will find the `celery_app` object.\n\n``` text\n$ celery -A example worker --loglevel INFO\n```\n\nYou can also run the `celery beat` command to run tasks on a schedule. See Celery’s docs for more information about defining schedules.\n\n``` text\n$ celery -A example beat --loglevel INFO\n```\n\n## Application Factory\n\nWhen using the Flask application factory pattern, call the `celery_init_app` function inside the factory. It sets `app.extensions[\"celery\"]` to the Celery app object, which can be used to get the Celery app from the Flask app returned by the factory.\n\n``` python\ndef create_app() -> Flask:\n    app = Flask(__name__)\n    app.config.from_mapping(\n        CELERY=dict(\n            broker_url=\"redis://localhost\",\n            result_backend=\"redis://localhost\",\n            task_ignore_result=True,\n        ),\n    )\n    app.config.from_prefixed_env()\n    celery_init_app(app)\n    return app\n```\n\nTo use `celery` commands, Celery needs an app object, but that’s no longer directly available. Create a `make_celery.py` file that calls the Flask app factory and gets the Celery app from the returned Flask app.\n\n``` python\nfrom example import create_app\n\nflask_app = create_app()\ncelery_app = flask_app.extensions[\"celery\"]\n```\n\nPoint the `celery` command to this file.\n\n``` text\n$ celery -A make_celery worker --loglevel INFO\n$ celery -A make_celery beat --loglevel INFO\n```\n\n## Defining Tasks\n\nUsing `@celery_app.task` to decorate task functions requires access to the `celery_app` object, which won’t be available when using the factory pattern. It also means that the decorated tasks are tied to the specific Flask and Celery app instances, which could be an issue during testing if you change configuration for a test.\n\nInstead, use Celery’s `@shared_task` decorator. This creates task objects that will access whatever the “current app” is, which is a similar concept to Flask’s blueprints and app context. This is why we called `celery_app.set_default()` above.\n\nHere’s an example task that adds two numbers together and returns the result.\n\n``` python\nfrom celery import shared_task\n\n@shared_task(ignore_result=False)\ndef add_together(a: int, b: int) -> int:\n    return a + b\n```\n\nEarlier, we configured Celery to ignore task results by default. Since we want to know the return value of this task, we set `ignore_result=False`. On the other hand, a task that didn’t need a result, such as sending an email, wouldn’t set this.\n\n## Calling Tasks\n\nThe decorated function becomes a task object with methods to call it in the background. The simplest way is to use the `delay(*args, **kwargs)` method. See Celery’s docs for more methods.\n\nA Celery worker must be running to run the task. Starting a worker is shown in the previous sections.\n\n``` python\nfrom flask import request\n\n@app.post(\"/add\")\ndef start_add() -> dict[str, object]:\n    a = request.form.get(\"a\", type=int)\n    b = request.form.get(\"b\", type=int)\n    result = add_together.delay(a, b)\n    return {\"result_id\": result.id}\n```\n\nThe route doesn’t get the task’s result immediately. That would defeat the purpose by blocking the response. Instead, we return the running task’s result id, which we can use later to get the result.\n\n## Getting Results\n\nTo fetch the result of the task we started above, we’ll add another route that takes the result id we returned before. We return whether the task is finished (ready), whether it finished successfully, and what the return value (or error) was if it is finished.\n\n``` python\nfrom celery.result import AsyncResult\n\n@app.get(\"/result/<id>\")\ndef task_result(id: str) -> dict[str, object]:\n    result = AsyncResult(id)\n    return {\n        \"ready\": result.ready(),\n        \"successful\": result.successful(),\n        \"value\": result.result if result.ready() else None,\n    }\n```\n\nNow you can start the task using the first route, then poll for the result using the second route. This keeps the Flask request workers from being blocked waiting for tasks to finish.\n\nThe Flask repository contains [an example](https://github.com/pallets/flask/tree/main/examples/celery) using JavaScript to submit tasks and poll for progress and results.\n\n## Passing Data to Tasks\n\nThe “add” task above took two integers as arguments. To pass arguments to tasks, Celery has to serialize them to a format that it can pass to other processes. Therefore, passing complex objects is not recommended. For example, it would be impossible to pass a SQLAlchemy model object, since that object is probably not serializable and is tied to the session that queried it.\n\nPass the minimal amount of data necessary to fetch or recreate any complex data within the task. Consider a task that will run when the logged in user asks for an archive of their data. The Flask request knows the logged in user, and has the user object queried from the database. It got that by querying the database for a given id, so the task can do the same thing. Pass the user’s id rather than the user object.\n\n``` python\n@shared_task\ndef generate_user_archive(user_id: str) -> None:\n    user = db.session.get(User, user_id)\n    ...\n\ngenerate_user_archive.delay(current_user.id)\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/celery/](https://flask.palletsprojects.com/en/3.0.x/patterns/celery/)"
- name: Blueprint
  id: api/index#flask.Blueprint
  summary: null
  description: |-
    `class flask.Blueprint(name, import_name, static_folder=None, static_url_path=None, template_folder=None, url_prefix=None, subdomain=None, url_defaults=None, root_path=None, cli_group=<object object>)`

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **import_name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **static_folder** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [os.PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)") *\|* *None*) –
    - **static_url_path** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **template_folder** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [os.PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)") *\|* *None*) –
    - **url_prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **subdomain** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **url_defaults** ([dict](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)") *\|* *None*) –
    - **root_path** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **cli_group** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
- name: Blueprint.add_app_template_filter()
  id: api/index#flask.Blueprint.add_app_template_filter
  summary: Register a template filter, available in any template rendered by the application
  description: |-
    `add_app_template_filter(f, name=None)`

    Register a template filter, available in any template rendered by the application. Works like the [`app_template_filter()`](#flask.Blueprint.app_template_filter "flask.Blueprint.app_template_filter") decorator. Equivalent to [`Flask.add_template_filter()`](#flask.Flask.add_template_filter "flask.Flask.add_template_filter").

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the optional name of the filter, otherwise the function name will be used.
    - **f** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[...\],* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]*) –

    Return type:

    None
- name: Blueprint.add_app_template_global()
  id: api/index#flask.Blueprint.add_app_template_global
  summary: Register a template global, available in any template rendered by the application
  description: |-
    `add_app_template_global(f, name=None)`

    Register a template global, available in any template rendered by the application. Works like the [`app_template_global()`](#flask.Blueprint.app_template_global "flask.Blueprint.app_template_global") decorator. Equivalent to [`Flask.add_template_global()`](#flask.Flask.add_template_global "flask.Flask.add_template_global").

    Changelog

    New in version 0.10.

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the optional name of the global, otherwise the function name will be used.
    - **f** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[...\],* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]*) –

    Return type:

    None
- name: Blueprint.add_app_template_test()
  id: api/index#flask.Blueprint.add_app_template_test
  summary: Register a template test, available in any template rendered by the application
  description: |-
    `add_app_template_test(f, name=None)`

    Register a template test, available in any template rendered by the application. Works like the [`app_template_test()`](#flask.Blueprint.app_template_test "flask.Blueprint.app_template_test") decorator. Equivalent to [`Flask.add_template_test()`](#flask.Flask.add_template_test "flask.Flask.add_template_test").

    Changelog

    New in version 0.10.

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the optional name of the test, otherwise the function name will be used.
    - **f** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[...\],* [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")*\]*) –

    Return type:

    None
- name: Blueprint.add_url_rule()
  id: api/index#flask.Blueprint.add_url_rule
  summary: Register a URL rule with the blueprint
  description: |-
    `add_url_rule(rule, endpoint=None, view_func=None, provide_automatic_options=None, **options)`

    Register a URL rule with the blueprint. See [`Flask.add_url_rule()`](#flask.Flask.add_url_rule "flask.Flask.add_url_rule") for full documentation.

    The URL rule is prefixed with the blueprint’s URL prefix. The endpoint name, used with [`url_for()`](#flask.url_for "flask.url_for"), is prefixed with the blueprint’s name.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **endpoint** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **view_func** (*ft.RouteCallable* *\|* *None*) –
    - **provide_automatic_options** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)") *\|* *None*) –
    - **options** (*t.Any*) –

    Return type:

    None
- name: Blueprint.after_app_request()
  id: api/index#flask.Blueprint.after_app_request
  summary: Like after_request(), but after every request, not only those handled by the blueprint
  description: |-
    `after_app_request(f)`

    Like [`after_request()`](#flask.Blueprint.after_request "flask.Blueprint.after_request"), but after every request, not only those handled by the blueprint. Equivalent to [`Flask.after_request()`](#flask.Flask.after_request "flask.Flask.after_request").

    Parameters:

    **f** (*T_after_request*) –

    Return type:

    *T_after_request*
- name: Blueprint.after_request()
  id: api/index#flask.Blueprint.after_request
  summary: Register a function to run after each request to this object
  description: |-
    `after_request(f)`

    Register a function to run after each request to this object.

    The function is called with the response object, and must return a response object. This allows the functions to modify or replace the response before it is sent.

    If a function raises an exception, any remaining `after_request` functions will not be called. Therefore, this should not be used for actions that must execute, such as to close resources. Use [`teardown_request()`](#flask.Blueprint.teardown_request "flask.Blueprint.teardown_request") for that.

    This is available on both app and blueprint objects. When used on an app, this executes after every request. When used on a blueprint, this executes after every request that the blueprint handles. To register with a blueprint and execute after every request, use [`Blueprint.after_app_request()`](#flask.Blueprint.after_app_request "flask.Blueprint.after_app_request").

    Parameters:

    **f** (*T_after_request*) –

    Return type:

    *T_after_request*
- name: Blueprint.after_request_funcs
  id: api/index#flask.Blueprint.after_request_funcs
  summary: 'A data structure of functions to call at the end of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests'
  description: |-
    `after_request_funcs: dict[ft.AppOrBlueprintKey, list[ft.AfterRequestCallable]]`

    A data structure of functions to call at the end of each request, in the format `{scope: [functions]}`. The `scope` key is the name of a blueprint the functions are active for, or `None` for all requests.

    To register a function, use the [`after_request()`](#flask.Blueprint.after_request "flask.Blueprint.after_request") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Blueprint.app_context_processor()
  id: api/index#flask.Blueprint.app_context_processor
  summary: Like context_processor(), but for templates rendered by every view, not only by the blueprint
  description: |-
    `app_context_processor(f)`

    Like [`context_processor()`](#flask.Blueprint.context_processor "flask.Blueprint.context_processor"), but for templates rendered by every view, not only by the blueprint. Equivalent to [`Flask.context_processor()`](#flask.Flask.context_processor "flask.Flask.context_processor").

    Parameters:

    **f** (*T_template_context_processor*) –

    Return type:

    *T_template_context_processor*
- name: Blueprint.app_errorhandler()
  id: api/index#flask.Blueprint.app_errorhandler
  summary: Like errorhandler(), but for every request, not only those handled by the blueprint
  description: |-
    `app_errorhandler(code)`

    Like [`errorhandler()`](#flask.Blueprint.errorhandler "flask.Blueprint.errorhandler"), but for every request, not only those handled by the blueprint. Equivalent to [`Flask.errorhandler()`](#flask.Flask.errorhandler "flask.Flask.errorhandler").

    Parameters:

    **code** ([type](https://docs.python.org/3/library/functions.html#type "(in Python v3.11)")*\[*[Exception](https://docs.python.org/3/library/exceptions.html#Exception "(in Python v3.11)")*\]* *\|* [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_error_handler*\], *T_error_handler*\]
- name: Blueprint.app_template_filter()
  id: api/index#flask.Blueprint.app_template_filter
  summary: Register a template filter, available in any template rendered by the application
  description: |-
    `app_template_filter(name=None)`

    Register a template filter, available in any template rendered by the application. Equivalent to [`Flask.template_filter()`](#flask.Flask.template_filter "flask.Flask.template_filter").

    Parameters:

    **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the optional name of the filter, otherwise the function name will be used.

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_template_filter*\], *T_template_filter*\]
- name: Blueprint.app_template_global()
  id: api/index#flask.Blueprint.app_template_global
  summary: Register a template global, available in any template rendered by the application
  description: |-
    `app_template_global(name=None)`

    Register a template global, available in any template rendered by the application. Equivalent to [`Flask.template_global()`](#flask.Flask.template_global "flask.Flask.template_global").

    Changelog

    New in version 0.10.

    Parameters:

    **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the optional name of the global, otherwise the function name will be used.

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_template_global*\], *T_template_global*\]
- name: Blueprint.app_template_test()
  id: api/index#flask.Blueprint.app_template_test
  summary: Register a template test, available in any template rendered by the application
  description: |-
    `app_template_test(name=None)`

    Register a template test, available in any template rendered by the application. Equivalent to [`Flask.template_test()`](#flask.Flask.template_test "flask.Flask.template_test").

    Changelog

    New in version 0.10.

    Parameters:

    **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the optional name of the test, otherwise the function name will be used.

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_template_test*\], *T_template_test*\]
- name: Blueprint.app_url_defaults()
  id: api/index#flask.Blueprint.app_url_defaults
  summary: Like url_defaults(), but for every request, not only those handled by the blueprint
  description: |-
    `app_url_defaults(f)`

    Like [`url_defaults()`](#flask.Blueprint.url_defaults "flask.Blueprint.url_defaults"), but for every request, not only those handled by the blueprint. Equivalent to [`Flask.url_defaults()`](#flask.Flask.url_defaults "flask.Flask.url_defaults").

    Parameters:

    **f** (*T_url_defaults*) –

    Return type:

    *T_url_defaults*
- name: Blueprint.app_url_value_preprocessor()
  id: api/index#flask.Blueprint.app_url_value_preprocessor
  summary: Like url_value_preprocessor(), but for every request, not only those handled by the blueprint
  description: |-
    `app_url_value_preprocessor(f)`

    Like [`url_value_preprocessor()`](#flask.Blueprint.url_value_preprocessor "flask.Blueprint.url_value_preprocessor"), but for every request, not only those handled by the blueprint. Equivalent to [`Flask.url_value_preprocessor()`](#flask.Flask.url_value_preprocessor "flask.Flask.url_value_preprocessor").

    Parameters:

    **f** (*T_url_value_preprocessor*) –

    Return type:

    *T_url_value_preprocessor*
- name: Blueprint.before_app_request()
  id: api/index#flask.Blueprint.before_app_request
  summary: Like before_request(), but before every request, not only those handled by the blueprint
  description: |-
    `before_app_request(f)`

    Like [`before_request()`](#flask.Blueprint.before_request "flask.Blueprint.before_request"), but before every request, not only those handled by the blueprint. Equivalent to [`Flask.before_request()`](#flask.Flask.before_request "flask.Flask.before_request").

    Parameters:

    **f** (*T_before_request*) –

    Return type:

    *T_before_request*
- name: Blueprint.before_request()
  id: api/index#flask.Blueprint.before_request
  summary: Register a function to run before each request
  description: |-
    `before_request(f)`

    Register a function to run before each request.

    For example, this can be used to open a database connection, or to load the logged in user from the session.

    ``` python
    @app.before_request
    def load_user():
        if "user_id" in session:
            g.user = db.session.get(session["user_id"])
    ```

    The function will be called without any arguments. If it returns a non-`None` value, the value is handled as if it was the return value from the view, and further request handling is stopped.

    This is available on both app and blueprint objects. When used on an app, this executes before every request. When used on a blueprint, this executes before every request that the blueprint handles. To register with a blueprint and execute before every request, use [`Blueprint.before_app_request()`](#flask.Blueprint.before_app_request "flask.Blueprint.before_app_request").

    Parameters:

    **f** (*T_before_request*) –

    Return type:

    *T_before_request*
- name: Blueprint.before_request_funcs
  id: api/index#flask.Blueprint.before_request_funcs
  summary: 'A data structure of functions to call at the beginning of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests'
  description: |-
    `before_request_funcs: dict[ft.AppOrBlueprintKey, list[ft.BeforeRequestCallable]]`

    A data structure of functions to call at the beginning of each request, in the format `{scope: [functions]}`. The `scope` key is the name of a blueprint the functions are active for, or `None` for all requests.

    To register a function, use the [`before_request()`](#flask.Blueprint.before_request "flask.Blueprint.before_request") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Blueprint.cli
  id: api/index#flask.Blueprint.cli
  summary: The Click command group for registering CLI commands for this object
  description: |-
    `cli`

    The Click command group for registering CLI commands for this object. The commands are available from the `flask` command once the application has been discovered and blueprints have been registered.
- name: Blueprint.context_processor()
  id: api/index#flask.Blueprint.context_processor
  summary: Registers a template context processor function
  description: |-
    `context_processor(f)`

    Registers a template context processor function. These functions run before rendering a template. The keys of the returned dict are added as variables available in the template.

    This is available on both app and blueprint objects. When used on an app, this is called for every rendered template. When used on a blueprint, this is called for templates rendered from the blueprint’s views. To register with a blueprint and affect every template, use [`Blueprint.app_context_processor()`](#flask.Blueprint.app_context_processor "flask.Blueprint.app_context_processor").

    Parameters:

    **f** (*T_template_context_processor*) –

    Return type:

    *T_template_context_processor*
- name: Blueprint.delete()
  id: api/index#flask.Blueprint.delete
  summary: Shortcut for route() with methods=["DELETE"]
  description: |-
    `delete(rule, **options)`

    Shortcut for [`route()`](#flask.Blueprint.route "flask.Blueprint.route") with `methods=["DELETE"]`.

    Changelog

    New in version 2.0.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_route*\], *T_route*\]
- name: Blueprint.endpoint()
  id: api/index#flask.Blueprint.endpoint
  summary: Decorate a view function to register it for the given endpoint
  description: |-
    `endpoint(endpoint)`

    Decorate a view function to register it for the given endpoint. Used if a rule is added without a `view_func` with [`add_url_rule()`](#flask.Blueprint.add_url_rule "flask.Blueprint.add_url_rule").

    ``` python
    app.add_url_rule("/ex", endpoint="example")

    @app.endpoint("example")
    def example():
        ...
    ```

    Parameters:

    **endpoint** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The endpoint name to associate with the view function.

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*F*\], *F*\]
- name: Blueprint.error_handler_spec
  id: api/index#flask.Blueprint.error_handler_spec
  summary: 'A data structure of registered error handlers, in the format {scope: {code: {class: handler}}}. The scope key is the name of a blueprint the handlers are active for, or None for all requests'
  description: |-
    `error_handler_spec: dict[ft.AppOrBlueprintKey, dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]]]`

    A data structure of registered error handlers, in the format `{scope: {code: {class: handler}}}`. The `scope` key is the name of a blueprint the handlers are active for, or `None` for all requests. The `code` key is the HTTP status code for `HTTPException`, or `None` for other exceptions. The innermost dictionary maps exception classes to handler functions.

    To register an error handler, use the [`errorhandler()`](#flask.Blueprint.errorhandler "flask.Blueprint.errorhandler") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Blueprint.errorhandler()
  id: api/index#flask.Blueprint.errorhandler
  summary: Register a function to handle errors by code or exception class
  description: |-
    `errorhandler(code_or_exception)`

    Register a function to handle errors by code or exception class.

    A decorator that is used to register a function given an error code. Example:

    ``` python
    @app.errorhandler(404)
    def page_not_found(error):
        return 'This page does not exist', 404
    ```

    You can also register handlers for arbitrary exceptions:

    ``` python
    @app.errorhandler(DatabaseError)
    def special_exception_handler(error):
        return 'Database connection failed', 500
    ```

    This is available on both app and blueprint objects. When used on an app, this can handle errors from every request. When used on a blueprint, this can handle errors from requests that the blueprint handles. To register with a blueprint and affect every request, use [`Blueprint.app_errorhandler()`](#flask.Blueprint.app_errorhandler "flask.Blueprint.app_errorhandler").

    Changelog

    New in version 0.7: Use [`register_error_handler()`](#flask.Blueprint.register_error_handler "flask.Blueprint.register_error_handler") instead of modifying [`error_handler_spec`](#flask.Blueprint.error_handler_spec "flask.Blueprint.error_handler_spec") directly, for application wide error handlers.

    New in version 0.7: One can now additionally also register custom exception types that do not necessarily have to be a subclass of the [`HTTPException`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.HTTPException "(in Werkzeug v2.3.x)") class.

    Parameters:

    **code_or_exception** ([type](https://docs.python.org/3/library/functions.html#type "(in Python v3.11)")*\[*[Exception](https://docs.python.org/3/library/exceptions.html#Exception "(in Python v3.11)")*\]* *\|* [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) – the code as integer for the handler, or an arbitrary exception

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_error_handler*\], *T_error_handler*\]
- name: Blueprint.get()
  id: api/index#flask.Blueprint.get
  summary: Shortcut for route() with methods=["GET"]
  description: |-
    `get(rule, **options)`

    Shortcut for [`route()`](#flask.Blueprint.route "flask.Blueprint.route") with `methods=["GET"]`.

    Changelog

    New in version 2.0.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_route*\], *T_route*\]
- name: Blueprint.get_send_file_max_age()
  id: api/index#flask.Blueprint.get_send_file_max_age
  summary: Used by send_file() to determine the max_age cache value for a given file path if it wasn’t passed
  description: |-
    `get_send_file_max_age(filename)`

    Used by [`send_file()`](#flask.send_file "flask.send_file") to determine the `max_age` cache value for a given file path if it wasn’t passed.

    By default, this returns [`SEND_FILE_MAX_AGE_DEFAULT`](../config/index#SEND_FILE_MAX_AGE_DEFAULT "SEND_FILE_MAX_AGE_DEFAULT") from the configuration of [`current_app`](#flask.current_app "flask.current_app"). This defaults to `None`, which tells the browser to use conditional requests instead of a timed cache, which is usually preferable.

    Note this is a duplicate of the same method in the Flask class.

    Changelog

    Changed in version 2.0: The default configuration is `None` instead of 12 hours.

    New in version 0.9.

    Parameters:

    **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") \| None

    `property has_static_folder: bool`

    `True` if [`static_folder`](#flask.Blueprint.static_folder "flask.Blueprint.static_folder") is set.

    Changelog

    New in version 0.5.
- name: Blueprint.import_name
  id: api/index#flask.Blueprint.import_name
  summary: The name of the package or module that this object belongs to
  description: |-
    `import_name`

    The name of the package or module that this object belongs to. Do not change this once it is set by the constructor.

    `property jinja_loader: FileSystemLoader | None`

    The Jinja loader for this object’s templates. By default this is a class [`jinja2.loaders.FileSystemLoader`](https://jinja.palletsprojects.com/en/3.1.x/api/#jinja2.FileSystemLoader "(in Jinja v3.1.x)") to [`template_folder`](#flask.Blueprint.template_folder "flask.Blueprint.template_folder") if it is set.

    Changelog

    New in version 0.5.
- name: Blueprint.make_setup_state()
  id: api/index#flask.Blueprint.make_setup_state
  summary: Creates an instance of BlueprintSetupState() object that is later passed to the register callback functions
  description: |-
    `make_setup_state(app, options, first_registration=False)`

    Creates an instance of [`BlueprintSetupState()`](#flask.blueprints.BlueprintSetupState "flask.blueprints.BlueprintSetupState") object that is later passed to the register callback functions. Subclasses can override this to return a subclass of the setup state.

    Parameters:

    - **app** (*App*) –
    - **options** ([dict](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)")) –
    - **first_registration** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    [BlueprintSetupState](#flask.blueprints.BlueprintSetupState "flask.blueprints.BlueprintSetupState")
- name: Blueprint.open_resource()
  id: api/index#flask.Blueprint.open_resource
  summary: Open a resource file relative to root_path for reading
  description: |-
    `open_resource(resource, mode='rb')`

    Open a resource file relative to [`root_path`](#flask.Blueprint.root_path "flask.Blueprint.root_path") for reading.

    For example, if the file `schema.sql` is next to the file `app.py` where the `Flask` app is defined, it can be opened with:

    ``` python
    with app.open_resource("schema.sql") as f:
        conn.executescript(f.read())
    ```

    Parameters:

    - **resource** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – Path to the resource relative to [`root_path`](#flask.Blueprint.root_path "flask.Blueprint.root_path").
    - **mode** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – Open the file in this mode. Only reading is supported, valid values are “r” (or “rt”) and “rb”.

    Return type:

    [IO](https://docs.python.org/3/library/typing.html#typing.IO "(in Python v3.11)")

    Note this is a duplicate of the same method in the Flask class.
- name: Blueprint.patch()
  id: api/index#flask.Blueprint.patch
  summary: Shortcut for route() with methods=["PATCH"]
  description: |-
    `patch(rule, **options)`

    Shortcut for [`route()`](#flask.Blueprint.route "flask.Blueprint.route") with `methods=["PATCH"]`.

    Changelog

    New in version 2.0.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_route*\], *T_route*\]
- name: Blueprint.post()
  id: api/index#flask.Blueprint.post
  summary: Shortcut for route() with methods=["POST"]
  description: |-
    `post(rule, **options)`

    Shortcut for [`route()`](#flask.Blueprint.route "flask.Blueprint.route") with `methods=["POST"]`.

    Changelog

    New in version 2.0.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_route*\], *T_route*\]
- name: Blueprint.put()
  id: api/index#flask.Blueprint.put
  summary: Shortcut for route() with methods=["PUT"]
  description: |-
    `put(rule, **options)`

    Shortcut for [`route()`](#flask.Blueprint.route "flask.Blueprint.route") with `methods=["PUT"]`.

    Changelog

    New in version 2.0.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_route*\], *T_route*\]
- name: Blueprint.record()
  id: api/index#flask.Blueprint.record
  summary: Registers a function that is called when the blueprint is registered on the application
  description: |-
    `record(func)`

    Registers a function that is called when the blueprint is registered on the application. This function is called with the state as argument as returned by the [`make_setup_state()`](#flask.Blueprint.make_setup_state "flask.Blueprint.make_setup_state") method.

    Parameters:

    **func** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")) –

    Return type:

    None
- name: Blueprint.record_once()
  id: api/index#flask.Blueprint.record_once
  summary: Works like record() but wraps the function in another function that will ensure the function is only called once
  description: |-
    `record_once(func)`

    Works like [`record()`](#flask.Blueprint.record "flask.Blueprint.record") but wraps the function in another function that will ensure the function is only called once. If the blueprint is registered a second time on the application, the function passed is not called.

    Parameters:

    **func** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")) –

    Return type:

    None
- name: Blueprint.register()
  id: api/index#flask.Blueprint.register
  summary: Called by Flask.register_blueprint() to register all views and callbacks registered on the blueprint with the application
  description: |-
    `register(app, options)`

    Called by [`Flask.register_blueprint()`](#flask.Flask.register_blueprint "flask.Flask.register_blueprint") to register all views and callbacks registered on the blueprint with the application. Creates a [`BlueprintSetupState`](#flask.blueprints.BlueprintSetupState "flask.blueprints.BlueprintSetupState") and calls each [`record()`](#flask.Blueprint.record "flask.Blueprint.record") callback with it.

    Parameters:

    - **app** (*App*) – The application this blueprint is being registered with.
    - **options** ([dict](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)")) – Keyword arguments forwarded from [`register_blueprint()`](#flask.Flask.register_blueprint "flask.Flask.register_blueprint").

    Return type:

    None

    Changelog

    Changed in version 2.3: Nested blueprints now correctly apply subdomains.

    Changed in version 2.1: Registering the same blueprint with the same name multiple times is an error.

    Changed in version 2.0.1: Nested blueprints are registered with their dotted name. This allows different blueprints with the same name to be nested at different locations.

    Changed in version 2.0.1: The `name` option can be used to change the (pre-dotted) name the blueprint is registered with. This allows the same blueprint to be registered multiple times with unique names for `url_for`.
- name: Blueprint.register_blueprint()
  id: api/index#flask.Blueprint.register_blueprint
  summary: Register a Blueprint on this blueprint
  description: |-
    `register_blueprint(blueprint, **options)`

    Register a [`Blueprint`](#flask.Blueprint "flask.Blueprint") on this blueprint. Keyword arguments passed to this method will override the defaults set on the blueprint.

    Changelog

    Changed in version 2.0.1: The `name` option can be used to change the (pre-dotted) name the blueprint is registered with. This allows the same blueprint to be registered multiple times with unique names for `url_for`.

    New in version 2.0.

    Parameters:

    - **blueprint** (*Blueprint*) –
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    None
- name: Blueprint.register_error_handler()
  id: api/index#flask.Blueprint.register_error_handler
  summary: Alternative error attach function to the errorhandler() decorator that is more straightforward to use for non decorator usage
  description: |-
    `register_error_handler(code_or_exception, f)`

    Alternative error attach function to the [`errorhandler()`](#flask.Blueprint.errorhandler "flask.Blueprint.errorhandler") decorator that is more straightforward to use for non decorator usage.

    Changelog

    New in version 0.7.

    Parameters:

    - **code_or_exception** ([type](https://docs.python.org/3/library/functions.html#type "(in Python v3.11)")*\[*[Exception](https://docs.python.org/3/library/exceptions.html#Exception "(in Python v3.11)")*\]* *\|* [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) –
    - **f** (*ft.ErrorHandlerCallable*) –

    Return type:

    None
- name: Blueprint.root_path
  id: api/index#flask.Blueprint.root_path
  summary: Absolute path to the package on the filesystem
  description: |-
    `root_path`

    Absolute path to the package on the filesystem. Used to look up resources contained in the package.
- name: Blueprint.route()
  id: api/index#flask.Blueprint.route
  summary: Decorate a view function to register it with the given URL rule and options
  description: |-
    `route(rule, **options)`

    Decorate a view function to register it with the given URL rule and options. Calls [`add_url_rule()`](#flask.Blueprint.add_url_rule "flask.Blueprint.add_url_rule"), which has more details about the implementation.

    ``` python
    @app.route("/")
    def index():
        return "Hello, World!"
    ```

    See [URL Route Registrations](#url-route-registrations).

    The endpoint name for the route defaults to the name of the view function if the `endpoint` parameter isn’t passed.

    The `methods` parameter defaults to `["GET"]`. `HEAD` and `OPTIONS` are added automatically.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The URL rule string.
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – Extra options passed to the [`Rule`](https://werkzeug.palletsprojects.com/en/2.3.x/routing/#werkzeug.routing.Rule "(in Werkzeug v2.3.x)") object.

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_route*\], *T_route*\]
- name: Blueprint.send_static_file()
  id: api/index#flask.Blueprint.send_static_file
  summary: The view function used to serve files from static_folder
  description: |-
    `send_static_file(filename)`

    The view function used to serve files from [`static_folder`](#flask.Blueprint.static_folder "flask.Blueprint.static_folder"). A route is automatically registered for this view at [`static_url_path`](#flask.Blueprint.static_url_path "flask.Blueprint.static_url_path") if [`static_folder`](#flask.Blueprint.static_folder "flask.Blueprint.static_folder") is set.

    Note this is a duplicate of the same method in the Flask class.

    Changelog

    New in version 0.5.

    Parameters:

    **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    [Response](#flask.Response "flask.Response")

    `property static_folder: str | None`

    The absolute path to the configured static folder. `None` if no static folder is set.

    `property static_url_path: str | None`

    The URL prefix that the static route will be accessible from.

    If it was not configured during init, it is derived from [`static_folder`](#flask.Blueprint.static_folder "flask.Blueprint.static_folder").
- name: Blueprint.teardown_app_request()
  id: api/index#flask.Blueprint.teardown_app_request
  summary: Like teardown_request(), but after every request, not only those handled by the blueprint
  description: |-
    `teardown_app_request(f)`

    Like [`teardown_request()`](#flask.Blueprint.teardown_request "flask.Blueprint.teardown_request"), but after every request, not only those handled by the blueprint. Equivalent to [`Flask.teardown_request()`](#flask.Flask.teardown_request "flask.Flask.teardown_request").

    Parameters:

    **f** (*T_teardown*) –

    Return type:

    *T_teardown*
- name: Blueprint.teardown_request()
  id: api/index#flask.Blueprint.teardown_request
  summary: Register a function to be called when the request context is popped
  description: |-
    `teardown_request(f)`

    Register a function to be called when the request context is popped. Typically this happens at the end of each request, but contexts may be pushed manually as well during testing.

    ``` python
    with app.test_request_context():
        ...
    ```

    When the `with` block exits (or `ctx.pop()` is called), the teardown functions are called just before the request context is made inactive.

    When a teardown function was called because of an unhandled exception it will be passed an error object. If an [`errorhandler()`](#flask.Blueprint.errorhandler "flask.Blueprint.errorhandler") is registered, it will handle the exception and the teardown will not receive it.

    Teardown functions must avoid raising exceptions. If they execute code that might fail they must surround that code with a `try`/`except` block and log any errors.

    The return values of teardown functions are ignored.

    This is available on both app and blueprint objects. When used on an app, this executes after every request. When used on a blueprint, this executes after every request that the blueprint handles. To register with a blueprint and execute after every request, use [`Blueprint.teardown_app_request()`](#flask.Blueprint.teardown_app_request "flask.Blueprint.teardown_app_request").

    Parameters:

    **f** (*T_teardown*) –

    Return type:

    *T_teardown*
- name: Blueprint.teardown_request_funcs
  id: api/index#flask.Blueprint.teardown_request_funcs
  summary: 'A data structure of functions to call at the end of each request even if an exception is raised, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests'
  description: |-
    `teardown_request_funcs: dict[ft.AppOrBlueprintKey, list[ft.TeardownCallable]]`

    A data structure of functions to call at the end of each request even if an exception is raised, in the format `{scope: [functions]}`. The `scope` key is the name of a blueprint the functions are active for, or `None` for all requests.

    To register a function, use the [`teardown_request()`](#flask.Blueprint.teardown_request "flask.Blueprint.teardown_request") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Blueprint.template_context_processors
  id: api/index#flask.Blueprint.template_context_processors
  summary: 'A data structure of functions to call to pass extra context values when rendering templates, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests'
  description: |-
    `template_context_processors: dict[ft.AppOrBlueprintKey, list[ft.TemplateContextProcessorCallable]]`

    A data structure of functions to call to pass extra context values when rendering templates, in the format `{scope: [functions]}`. The `scope` key is the name of a blueprint the functions are active for, or `None` for all requests.

    To register a function, use the [`context_processor()`](#flask.Blueprint.context_processor "flask.Blueprint.context_processor") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Blueprint.template_folder
  id: api/index#flask.Blueprint.template_folder
  summary: The path to the templates folder, relative to root_path, to add to the template loader
  description: |-
    `template_folder`

    The path to the templates folder, relative to [`root_path`](#flask.Blueprint.root_path "flask.Blueprint.root_path"), to add to the template loader. `None` if templates should not be added.
- name: Blueprint.url_default_functions
  id: api/index#flask.Blueprint.url_default_functions
  summary: 'A data structure of functions to call to modify the keyword arguments when generating URLs, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests'
  description: |-
    `url_default_functions: dict[ft.AppOrBlueprintKey, list[ft.URLDefaultCallable]]`

    A data structure of functions to call to modify the keyword arguments when generating URLs, in the format `{scope: [functions]}`. The `scope` key is the name of a blueprint the functions are active for, or `None` for all requests.

    To register a function, use the [`url_defaults()`](#flask.Blueprint.url_defaults "flask.Blueprint.url_defaults") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Blueprint.url_defaults()
  id: api/index#flask.Blueprint.url_defaults
  summary: Callback function for URL defaults for all view functions of the application
  description: |-
    `url_defaults(f)`

    Callback function for URL defaults for all view functions of the application. It’s called with the endpoint and values and should update the values passed in place.

    This is available on both app and blueprint objects. When used on an app, this is called for every request. When used on a blueprint, this is called for requests that the blueprint handles. To register with a blueprint and affect every request, use [`Blueprint.app_url_defaults()`](#flask.Blueprint.app_url_defaults "flask.Blueprint.app_url_defaults").

    Parameters:

    **f** (*T_url_defaults*) –

    Return type:

    *T_url_defaults*
- name: Blueprint.url_value_preprocessor()
  id: api/index#flask.Blueprint.url_value_preprocessor
  summary: Register a URL value preprocessor function for all view functions in the application
  description: |-
    `url_value_preprocessor(f)`

    Register a URL value preprocessor function for all view functions in the application. These functions will be called before the [`before_request()`](#flask.Blueprint.before_request "flask.Blueprint.before_request") functions.

    The function can modify the values captured from the matched url before they are passed to the view. For example, this can be used to pop a common language code value and place it in `g` rather than pass it to every view.

    The function is passed the endpoint name and values dict. The return value is ignored.

    This is available on both app and blueprint objects. When used on an app, this is called for every request. When used on a blueprint, this is called for requests that the blueprint handles. To register with a blueprint and affect every request, use [`Blueprint.app_url_value_preprocessor()`](#flask.Blueprint.app_url_value_preprocessor "flask.Blueprint.app_url_value_preprocessor").

    Parameters:

    **f** (*T_url_value_preprocessor*) –

    Return type:

    *T_url_value_preprocessor*
- name: Blueprint.url_value_preprocessors
  id: api/index#flask.Blueprint.url_value_preprocessors
  summary: 'A data structure of functions to call to modify the keyword arguments passed to the view function, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests'
  description: |-
    `url_value_preprocessors: dict[ft.AppOrBlueprintKey, list[ft.URLValuePreprocessorCallable]]`

    A data structure of functions to call to modify the keyword arguments passed to the view function, in the format `{scope: [functions]}`. The `scope` key is the name of a blueprint the functions are active for, or `None` for all requests.

    To register a function, use the [`url_value_preprocessor()`](#flask.Blueprint.url_value_preprocessor "flask.Blueprint.url_value_preprocessor") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Blueprint.view_functions
  id: api/index#flask.Blueprint.view_functions
  summary: A dictionary mapping endpoint names to view functions
  description: |-
    `view_functions: dict[str, t.Callable]`

    A dictionary mapping endpoint names to view functions.

    To register a view function, use the [`route()`](#flask.Blueprint.route "flask.Blueprint.route") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.

    ## Incoming Request Data
- name: BlueprintSetupState
  id: api/index#flask.blueprints.BlueprintSetupState
  summary: Temporary holder object for registering a blueprint with the application
  description: |-
    `class flask.blueprints.BlueprintSetupState(blueprint, app, options, first_registration)`

    Temporary holder object for registering a blueprint with the application. An instance of this class is created by the [`make_setup_state()`](#flask.Blueprint.make_setup_state "flask.Blueprint.make_setup_state") method and later passed to all register callback functions.

    Parameters:

    - **blueprint** ([Blueprint](#flask.Blueprint "flask.blueprints.Blueprint")) –
    - **app** (*App*) –
    - **options** (*t.Any*) –
    - **first_registration** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
- name: BlueprintSetupState.add_url_rule()
  id: api/index#flask.blueprints.BlueprintSetupState.add_url_rule
  summary: A helper method to register a rule (and optionally a view function) to the application
  description: |-
    `add_url_rule(rule, endpoint=None, view_func=None, **options)`

    A helper method to register a rule (and optionally a view function) to the application. The endpoint is automatically prefixed with the blueprint’s name.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **endpoint** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **view_func** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)") *\|* *None*) –
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    None
- name: BlueprintSetupState.app
  id: api/index#flask.blueprints.BlueprintSetupState.app
  summary: null
  description: |-
    `app`

    a reference to the current application
- name: BlueprintSetupState.blueprint
  id: api/index#flask.blueprints.BlueprintSetupState.blueprint
  summary: a reference to the blueprint that created this setup state
  description: |-
    `blueprint`

    a reference to the blueprint that created this setup state.
- name: BlueprintSetupState.first_registration
  id: api/index#flask.blueprints.BlueprintSetupState.first_registration
  summary: as blueprints can be registered multiple times with the application and not everything wants to be registered multiple times on it, this attribute can be used to figure out if the blueprint was registered in the past already
  description: |-
    `first_registration`

    as blueprints can be registered multiple times with the application and not everything wants to be registered multiple times on it, this attribute can be used to figure out if the blueprint was registered in the past already.
- name: BlueprintSetupState.options
  id: api/index#flask.blueprints.BlueprintSetupState.options
  summary: a dictionary with all options that were passed to the register_blueprint() method
  description: |-
    `options`

    a dictionary with all options that were passed to the [`register_blueprint()`](#flask.Flask.register_blueprint "flask.Flask.register_blueprint") method.
- name: BlueprintSetupState.subdomain
  id: api/index#flask.blueprints.BlueprintSetupState.subdomain
  summary: The subdomain that the blueprint should be active for, None otherwise
  description: |-
    `subdomain`

    The subdomain that the blueprint should be active for, `None` otherwise.
- name: BlueprintSetupState.url_defaults
  id: api/index#flask.blueprints.BlueprintSetupState.url_defaults
  summary: A dictionary with URL defaults that is added to each and every URL that was defined with the blueprint
  description: |-
    `url_defaults`

    A dictionary with URL defaults that is added to each and every URL that was defined with the blueprint.
- name: BlueprintSetupState.url_prefix
  id: api/index#flask.blueprints.BlueprintSetupState.url_prefix
  summary: The prefix that should be used for all URLs defined on the blueprint
  description: |-
    `url_prefix`

    The prefix that should be used for all URLs defined on the blueprint.

    ## Signals

    Signals are provided by the [Blinker](https://blinker.readthedocs.io/) library. See [Signals](../signals/index) for an introduction.
- name: Caching
  id: patterns/caching/index
  summary: When your application runs slow, throw some caches in
  description: "# Caching\n\nWhen your application runs slow, throw some caches in. Well, at least it’s the easiest way to speed up things. What does a cache do? Say you have a function that takes some time to complete but the results would still be good enough if they were 5 minutes old. So then the idea is that you actually put the result of that calculation into a cache for some time.\n\nFlask itself does not provide caching for you, but [Flask-Caching](https://flask-caching.readthedocs.io/en/latest/), an extension for Flask does. Flask-Caching supports various backends, and it is even possible to develop your own caching backend.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/caching/](https://flask.palletsprojects.com/en/3.0.x/patterns/caching/)"
- name: Changes
  id: changes/index
  summary: Drop support for Python 3.7
  description: "# Changes\n\n## Version 3.0.0\n\nReleased 2023-09-30\n\n- Remove previously deprecated code. [\\#5223](https://github.com/pallets/flask/pull/5223)\n- Deprecate the `__version__` attribute. Use feature detection, or `importlib.metadata.version(\"flask\")`, instead. [\\#5230](https://github.com/pallets/flask/issues/5230)\n- Restructure the code such that the Flask (app) and Blueprint classes have Sans-IO bases. [\\#5127](https://github.com/pallets/flask/pull/5127)\n- Allow self as an argument to url_for. [\\#5264](https://github.com/pallets/flask/pull/5264)\n- Require Werkzeug \\>= 3.0.0.\n\n## Version 2.3.3\n\nReleased 2023-08-21\n\n- Python 3.12 compatibility.\n- Require Werkzeug \\>= 2.3.7.\n- Use `flit_core` instead of `setuptools` as build backend.\n- Refactor how an app’s root and instance paths are determined. [\\#5160](https://github.com/pallets/flask/issues/5160)\n\n## Version 2.3.2\n\nReleased 2023-05-01\n\n- Set `Vary: Cookie` header when the session is accessed, modified, or refreshed.\n- Update Werkzeug requirement to \\>=2.3.3 to apply recent bug fixes.\n\n## Version 2.3.1\n\nReleased 2023-04-25\n\n- Restore deprecated `from flask import Markup`. [\\#5084](https://github.com/pallets/flask/issues/5084)\n\n## Version 2.3.0\n\nReleased 2023-04-25\n\n- Drop support for Python 3.7. [\\#5072](https://github.com/pallets/flask/pull/5072)\n\n- Update minimum requirements to the latest versions: Werkzeug\\>=2.3.0, Jinja2\\>3.1.2, itsdangerous\\>=2.1.2, click\\>=8.1.3.\n\n- Remove previously deprecated code. [\\#4995](https://github.com/pallets/flask/pull/4995)\n\n  - The `push` and `pop` methods of the deprecated `_app_ctx_stack` and `_request_ctx_stack` objects are removed. `top` still exists to give extensions more time to update, but it will be removed.\n  - The `FLASK_ENV` environment variable, `ENV` config key, and `app.env` property are removed.\n  - The `session_cookie_name`, `send_file_max_age_default`, `use_x_sendfile`, `propagate_exceptions`, and `templates_auto_reload` properties on `app` are removed.\n  - The `JSON_AS_ASCII`, `JSON_SORT_KEYS`, `JSONIFY_MIMETYPE`, and `JSONIFY_PRETTYPRINT_REGULAR` config keys are removed.\n  - The `app.before_first_request` and `bp.before_app_first_request` decorators are removed.\n  - `json_encoder` and `json_decoder` attributes on app and blueprint, and the corresponding `json.JSONEncoder` and `JSONDecoder` classes, are removed.\n  - The `json.htmlsafe_dumps` and `htmlsafe_dump` functions are removed.\n  - Calling setup methods on blueprints after registration is an error instead of a warning. [\\#4997](https://github.com/pallets/flask/pull/4997)\n\n- Importing `escape` and `Markup` from `flask` is deprecated. Import them directly from `markupsafe` instead. [\\#4996](https://github.com/pallets/flask/pull/4996)\n\n- The `app.got_first_request` property is deprecated. [\\#4997](https://github.com/pallets/flask/pull/4997)\n\n- The `locked_cached_property` decorator is deprecated. Use a lock inside the decorated function if locking is needed. [\\#4993](https://github.com/pallets/flask/issues/4993)\n\n- Signals are always available. `blinker>=1.6.2` is a required dependency. The `signals_available` attribute is deprecated. [\\#5056](https://github.com/pallets/flask/issues/5056)\n\n- Signals support `async` subscriber functions. [\\#5049](https://github.com/pallets/flask/pull/5049)\n\n- Remove uses of locks that could cause requests to block each other very briefly. [\\#4993](https://github.com/pallets/flask/issues/4993)\n\n- Use modern packaging metadata with `pyproject.toml` instead of `setup.cfg`. [\\#4947](https://github.com/pallets/flask/pull/4947)\n\n- Ensure subdomains are applied with nested blueprints. [\\#4834](https://github.com/pallets/flask/issues/4834)\n\n- `config.from_file` can use `text=False` to indicate that the parser wants a binary file instead. [\\#4989](https://github.com/pallets/flask/issues/4989)\n\n- If a blueprint is created with an empty name it raises a `ValueError`. [\\#5010](https://github.com/pallets/flask/issues/5010)\n\n- `SESSION_COOKIE_DOMAIN` does not fall back to `SERVER_NAME`. The default is not to set the domain, which modern browsers interpret as an exact match rather than a subdomain match. Warnings about `localhost` and IP addresses are also removed. [\\#5051](https://github.com/pallets/flask/issues/5051)\n\n- The `routes` command shows each rule’s `subdomain` or `host` when domain matching is in use. [\\#5004](https://github.com/pallets/flask/issues/5004)\n\n- Use postponed evaluation of annotations. [\\#5071](https://github.com/pallets/flask/pull/5071)\n\n## Version 2.2.5\n\nReleased 2023-05-02\n\n- Update for compatibility with Werkzeug 2.3.3.\n- Set `Vary: Cookie` header when the session is accessed, modified, or refreshed.\n\n## Version 2.2.4\n\nReleased 2023-04-25\n\n- Update for compatibility with Werkzeug 2.3.\n\n## Version 2.2.3\n\nReleased 2023-02-15\n\n- Autoescape is enabled by default for `.svg` template files. [\\#4831](https://github.com/pallets/flask/issues/4831)\n- Fix the type of `template_folder` to accept `pathlib.Path`. [\\#4892](https://github.com/pallets/flask/issues/4892)\n- Add `--debug` option to the `flask run` command. [\\#4777](https://github.com/pallets/flask/issues/4777)\n\n## Version 2.2.2\n\nReleased 2022-08-08\n\n- Update Werkzeug dependency to \\>= 2.2.2. This includes fixes related to the new faster router, header parsing, and the development server. [\\#4754](https://github.com/pallets/flask/pull/4754)\n- Fix the default value for `app.env` to be `\"production\"`. This attribute remains deprecated. [\\#4740](https://github.com/pallets/flask/issues/4740)\n\n## Version 2.2.1\n\nReleased 2022-08-03\n\n- Setting or accessing `json_encoder` or `json_decoder` raises a deprecation warning. [\\#4732](https://github.com/pallets/flask/issues/4732)\n\n## Version 2.2.0\n\nReleased 2022-08-01\n\n- Remove previously deprecated code. [\\#4667](https://github.com/pallets/flask/pull/4667)\n\n  - Old names for some `send_file` parameters have been removed. `download_name` replaces `attachment_filename`, `max_age` replaces `cache_timeout`, and `etag` replaces `add_etags`. Additionally, `path` replaces `filename` in `send_from_directory`.\n  - The `RequestContext.g` property returning `AppContext.g` is removed.\n\n- Update Werkzeug dependency to \\>= 2.2.\n\n- The app and request contexts are managed using Python context vars directly rather than Werkzeug’s `LocalStack`. This should result in better performance and memory use. [\\#4682](https://github.com/pallets/flask/pull/4682)\n\n  - Extension maintainers, be aware that `_app_ctx_stack.top` and `_request_ctx_stack.top` are deprecated. Store data on `g` instead using a unique prefix, like `g._extension_name_attr`.\n\n- The `FLASK_ENV` environment variable and `app.env` attribute are deprecated, removing the distinction between development and debug mode. Debug mode should be controlled directly using the `--debug` option or `app.run(debug=True)`. [\\#4714](https://github.com/pallets/flask/issues/4714)\n\n- Some attributes that proxied config keys on `app` are deprecated: `session_cookie_name`, `send_file_max_age_default`, `use_x_sendfile`, `propagate_exceptions`, and `templates_auto_reload`. Use the relevant config keys instead. [\\#4716](https://github.com/pallets/flask/issues/4716)\n\n- Add new customization points to the `Flask` app object for many previously global behaviors.\n\n  - `flask.url_for` will call `app.url_for`. [\\#4568](https://github.com/pallets/flask/issues/4568)\n  - `flask.abort` will call `app.aborter`. `Flask.aborter_class` and `Flask.make_aborter` can be used to customize this aborter. [\\#4567](https://github.com/pallets/flask/issues/4567)\n  - `flask.redirect` will call `app.redirect`. [\\#4569](https://github.com/pallets/flask/issues/4569)\n  - `flask.json` is an instance of `JSONProvider`. A different provider can be set to use a different JSON library. `flask.jsonify` will call `app.json.response`, other functions in `flask.json` will call corresponding functions in `app.json`. [\\#4692](https://github.com/pallets/flask/pull/4692)\n\n- JSON configuration is moved to attributes on the default `app.json` provider. `JSON_AS_ASCII`, `JSON_SORT_KEYS`, `JSONIFY_MIMETYPE`, and `JSONIFY_PRETTYPRINT_REGULAR` are deprecated. [\\#4692](https://github.com/pallets/flask/pull/4692)\n\n- Setting custom `json_encoder` and `json_decoder` classes on the app or a blueprint, and the corresponding `json.JSONEncoder` and `JSONDecoder` classes, are deprecated. JSON behavior can now be overridden using the `app.json` provider interface. [\\#4692](https://github.com/pallets/flask/pull/4692)\n\n- `json.htmlsafe_dumps` and `json.htmlsafe_dump` are deprecated, the function is built-in to Jinja now. [\\#4692](https://github.com/pallets/flask/pull/4692)\n\n- Refactor `register_error_handler` to consolidate error checking. Rewrite some error messages to be more consistent. [\\#4559](https://github.com/pallets/flask/issues/4559)\n\n- Use Blueprint decorators and functions intended for setup after registering the blueprint will show a warning. In the next version, this will become an error just like the application setup methods. [\\#4571](https://github.com/pallets/flask/issues/4571)\n\n- `before_first_request` is deprecated. Run setup code when creating the application instead. [\\#4605](https://github.com/pallets/flask/issues/4605)\n\n- Added the `View.init_every_request` class attribute. If a view subclass sets this to `False`, the view will not create a new instance on every request. [\\#2520](https://github.com/pallets/flask/issues/2520).\n\n- A `flask.cli.FlaskGroup` Click group can be nested as a sub-command in a custom CLI. [\\#3263](https://github.com/pallets/flask/issues/3263)\n\n- Add `--app` and `--debug` options to the `flask` CLI, instead of requiring that they are set through environment variables. [\\#2836](https://github.com/pallets/flask/issues/2836)\n\n- Add `--env-file` option to the `flask` CLI. This allows specifying a dotenv file to load in addition to `.env` and `.flaskenv`. [\\#3108](https://github.com/pallets/flask/issues/3108)\n\n- It is no longer required to decorate custom CLI commands on `app.cli` or `blueprint.cli` with `@with_appcontext`, an app context will already be active at that point. [\\#2410](https://github.com/pallets/flask/issues/2410)\n\n- `SessionInterface.get_expiration_time` uses a timezone-aware value. [\\#4645](https://github.com/pallets/flask/pull/4645)\n\n- View functions can return generators directly instead of wrapping them in a `Response`. [\\#4629](https://github.com/pallets/flask/pull/4629)\n\n- Add `stream_template` and `stream_template_string` functions to render a template as a stream of pieces. [\\#4629](https://github.com/pallets/flask/pull/4629)\n\n- A new implementation of context preservation during debugging and testing. [\\#4666](https://github.com/pallets/flask/pull/4666)\n\n  - `request`, `g`, and other context-locals point to the correct data when running code in the interactive debugger console. [\\#2836](https://github.com/pallets/flask/issues/2836)\n  - Teardown functions are always run at the end of the request, even if the context is preserved. They are also run after the preserved context is popped.\n  - `stream_with_context` preserves context separately from a `with client` block. It will be cleaned up when `response.get_data()` or `response.close()` is called.\n\n- Allow returning a list from a view function, to convert it to a JSON response like a dict is. [\\#4672](https://github.com/pallets/flask/issues/4672)\n\n- When type checking, allow `TypedDict` to be returned from view functions. [\\#4695](https://github.com/pallets/flask/pull/4695)\n\n- Remove the `--eager-loading/--lazy-loading` options from the `flask run` command. The app is always eager loaded the first time, then lazily loaded in the reloader. The reloader always prints errors immediately but continues serving. Remove the internal `DispatchingApp` middleware used by the previous implementation. [\\#4715](https://github.com/pallets/flask/issues/4715)\n\n## Version 2.1.3\n\nReleased 2022-07-13\n\n- Inline some optional imports that are only used for certain CLI commands. [\\#4606](https://github.com/pallets/flask/pull/4606)\n- Relax type annotation for `after_request` functions. [\\#4600](https://github.com/pallets/flask/issues/4600)\n- `instance_path` for namespace packages uses the path closest to the imported submodule. [\\#4610](https://github.com/pallets/flask/issues/4610)\n- Clearer error message when `render_template` and `render_template_string` are used outside an application context. [\\#4693](https://github.com/pallets/flask/pull/4693)\n\n## Version 2.1.2\n\nReleased 2022-04-28\n\n- Fix type annotation for `json.loads`, it accepts str or bytes. [\\#4519](https://github.com/pallets/flask/issues/4519)\n- The `--cert` and `--key` options on `flask run` can be given in either order. [\\#4459](https://github.com/pallets/flask/issues/4459)\n\n## Version 2.1.1\n\nReleased on 2022-03-30\n\n- Set the minimum required version of importlib_metadata to 3.6.0, which is required on Python \\< 3.10. [\\#4502](https://github.com/pallets/flask/issues/4502)\n\n## Version 2.1.0\n\nReleased 2022-03-28\n\n- Drop support for Python 3.6. [\\#4335](https://github.com/pallets/flask/pull/4335)\n\n- Update Click dependency to \\>= 8.0. [\\#4008](https://github.com/pallets/flask/pull/4008)\n\n- Remove previously deprecated code. [\\#4337](https://github.com/pallets/flask/pull/4337)\n\n  - The CLI does not pass `script_info` to app factory functions.\n  - `config.from_json` is replaced by `config.from_file(name, load=json.load)`.\n  - `json` functions no longer take an `encoding` parameter.\n  - `safe_join` is removed, use `werkzeug.utils.safe_join` instead.\n  - `total_seconds` is removed, use `timedelta.total_seconds` instead.\n  - The same blueprint cannot be registered with the same name. Use `name=` when registering to specify a unique name.\n  - The test client’s `as_tuple` parameter is removed. Use `response.request.environ` instead. [\\#4417](https://github.com/pallets/flask/pull/4417)\n\n- Some parameters in `send_file` and `send_from_directory` were renamed in 2.0. The deprecation period for the old names is extended to 2.2. Be sure to test with deprecation warnings visible.\n\n  - `attachment_filename` is renamed to `download_name`.\n  - `cache_timeout` is renamed to `max_age`.\n  - `add_etags` is renamed to `etag`.\n  - `filename` is renamed to `path`.\n\n- The `RequestContext.g` property is deprecated. Use `g` directly or `AppContext.g` instead. [\\#3898](https://github.com/pallets/flask/issues/3898)\n\n- `copy_current_request_context` can decorate async functions. [\\#4303](https://github.com/pallets/flask/pull/4303)\n\n- The CLI uses `importlib.metadata` instead of `pkg_resources` to load command entry points. [\\#4419](https://github.com/pallets/flask/issues/4419)\n\n- Overriding `FlaskClient.open` will not cause an error on redirect. [\\#3396](https://github.com/pallets/flask/issues/3396)\n\n- Add an `--exclude-patterns` option to the `flask run` CLI command to specify patterns that will be ignored by the reloader. [\\#4188](https://github.com/pallets/flask/issues/4188)\n\n- When using lazy loading (the default with the debugger), the Click context from the `flask run` command remains available in the loader thread. [\\#4460](https://github.com/pallets/flask/issues/4460)\n\n- Deleting the session cookie uses the `httponly` flag. [\\#4485](https://github.com/pallets/flask/issues/4485)\n\n- Relax typing for `errorhandler` to allow the user to use more precise types and decorate the same function multiple times. [\\#4095](https://github.com/pallets/flask/issues/4095), [\\#4295](https://github.com/pallets/flask/issues/4295), [\\#4297](https://github.com/pallets/flask/issues/4297)\n\n- Fix typing for `__exit__` methods for better compatibility with `ExitStack`. [\\#4474](https://github.com/pallets/flask/issues/4474)\n\n- From Werkzeug, for redirect responses the `Location` header URL will remain relative, and exclude the scheme and domain, by default. [\\#4496](https://github.com/pallets/flask/pull/4496)\n\n- Add `Config.from_prefixed_env()` to load config values from environment variables that start with `FLASK_` or another prefix. This parses values as JSON by default, and allows setting keys in nested dicts. [\\#4479](https://github.com/pallets/flask/pull/4479)\n\n## Version 2.0.3\n\nReleased 2022-02-14\n\n- The test client’s `as_tuple` parameter is deprecated and will be removed in Werkzeug 2.1. It is now also deprecated in Flask, to be removed in Flask 2.1, while remaining compatible with both in 2.0.x. Use `response.request.environ` instead. [\\#4341](https://github.com/pallets/flask/pull/4341)\n- Fix type annotation for `errorhandler` decorator. [\\#4295](https://github.com/pallets/flask/issues/4295)\n- Revert a change to the CLI that caused it to hide `ImportError` tracebacks when importing the application. [\\#4307](https://github.com/pallets/flask/issues/4307)\n- `app.json_encoder` and `json_decoder` are only passed to `dumps` and `loads` if they have custom behavior. This improves performance, mainly on PyPy. [\\#4349](https://github.com/pallets/flask/issues/4349)\n- Clearer error message when `after_this_request` is used outside a request context. [\\#4333](https://github.com/pallets/flask/issues/4333)\n\n## Version 2.0.2\n\nReleased 2021-10-04\n\n- Fix type annotation for `teardown_*` methods. [\\#4093](https://github.com/pallets/flask/issues/4093)\n- Fix type annotation for `before_request` and `before_app_request` decorators. [\\#4104](https://github.com/pallets/flask/issues/4104)\n- Fixed the issue where typing requires template global decorators to accept functions with no arguments. [\\#4098](https://github.com/pallets/flask/issues/4098)\n- Support View and MethodView instances with async handlers. [\\#4112](https://github.com/pallets/flask/issues/4112)\n- Enhance typing of `app.errorhandler` decorator. [\\#4095](https://github.com/pallets/flask/issues/4095)\n- Fix registering a blueprint twice with differing names. [\\#4124](https://github.com/pallets/flask/issues/4124)\n- Fix the type of `static_folder` to accept `pathlib.Path`. [\\#4150](https://github.com/pallets/flask/issues/4150)\n- `jsonify` handles `decimal.Decimal` by encoding to `str`. [\\#4157](https://github.com/pallets/flask/issues/4157)\n- Correctly handle raising deferred errors in CLI lazy loading. [\\#4096](https://github.com/pallets/flask/issues/4096)\n- The CLI loader handles `**kwargs` in a `create_app` function. [\\#4170](https://github.com/pallets/flask/issues/4170)\n- Fix the order of `before_request` and other callbacks that trigger before the view returns. They are called from the app down to the closest nested blueprint. [\\#4229](https://github.com/pallets/flask/issues/4229)\n\n## Version 2.0.1\n\nReleased 2021-05-21\n\n- Re-add the `filename` parameter in `send_from_directory`. The `filename` parameter has been renamed to `path`, the old name is deprecated. [\\#4019](https://github.com/pallets/flask/pull/4019)\n- Mark top-level names as exported so type checking understands imports in user projects. [\\#4024](https://github.com/pallets/flask/issues/4024)\n- Fix type annotation for `g` and inform mypy that it is a namespace object that has arbitrary attributes. [\\#4020](https://github.com/pallets/flask/issues/4020)\n- Fix some types that weren’t available in Python 3.6.0. [\\#4040](https://github.com/pallets/flask/issues/4040)\n- Improve typing for `send_file`, `send_from_directory`, and `get_send_file_max_age`. [\\#4044](https://github.com/pallets/flask/issues/4044), [\\#4026](https://github.com/pallets/flask/pull/4026)\n- Show an error when a blueprint name contains a dot. The `.` has special meaning, it is used to separate (nested) blueprint names and the endpoint name. [\\#4041](https://github.com/pallets/flask/issues/4041)\n- Combine URL prefixes when nesting blueprints that were created with a `url_prefix` value. [\\#4037](https://github.com/pallets/flask/issues/4037)\n- Revert a change to the order that URL matching was done. The URL is again matched after the session is loaded, so the session is available in custom URL converters. [\\#4053](https://github.com/pallets/flask/issues/4053)\n- Re-add deprecated `Config.from_json`, which was accidentally removed early. [\\#4078](https://github.com/pallets/flask/issues/4078)\n- Improve typing for some functions using `Callable` in their type signatures, focusing on decorator factories. [\\#4060](https://github.com/pallets/flask/issues/4060)\n- Nested blueprints are registered with their dotted name. This allows different blueprints with the same name to be nested at different locations. [\\#4069](https://github.com/pallets/flask/issues/4069)\n- `register_blueprint` takes a `name` option to change the (pre-dotted) name the blueprint is registered with. This allows the same blueprint to be registered multiple times with unique names for `url_for`. Registering the same blueprint with the same name multiple times is deprecated. [\\#1091](https://github.com/pallets/flask/issues/1091)\n- Improve typing for `stream_with_context`. [\\#4052](https://github.com/pallets/flask/issues/4052)\n\n## Version 2.0.0\n\nReleased 2021-05-11\n\n- Drop support for Python 2 and 3.5.\n- Bump minimum versions of other Pallets projects: Werkzeug \\>= 2, Jinja2 \\>= 3, MarkupSafe \\>= 2, ItsDangerous \\>= 2, Click \\>= 8. Be sure to check the change logs for each project. For better compatibility with other applications (e.g. Celery) that still require Click 7, there is no hard dependency on Click 8 yet, but using Click 7 will trigger a DeprecationWarning and Flask 2.1 will depend on Click 8.\n- JSON support no longer uses simplejson. To use another JSON module, override `app.json_encoder` and `json_decoder`. [\\#3555](https://github.com/pallets/flask/issues/3555)\n- The `encoding` option to JSON functions is deprecated. [\\#3562](https://github.com/pallets/flask/pull/3562)\n- Passing `script_info` to app factory functions is deprecated. This was not portable outside the `flask` command. Use `click.get_current_context().obj` if it’s needed. [\\#3552](https://github.com/pallets/flask/issues/3552)\n- The CLI shows better error messages when the app failed to load when looking up commands. [\\#2741](https://github.com/pallets/flask/issues/2741)\n- Add `SessionInterface.get_cookie_name` to allow setting the session cookie name dynamically. [\\#3369](https://github.com/pallets/flask/pull/3369)\n- Add `Config.from_file` to load config using arbitrary file loaders, such as `toml.load` or `json.load`. `Config.from_json` is deprecated in favor of this. [\\#3398](https://github.com/pallets/flask/pull/3398)\n- The `flask run` command will only defer errors on reload. Errors present during the initial call will cause the server to exit with the traceback immediately. [\\#3431](https://github.com/pallets/flask/issues/3431)\n- `send_file` raises a `ValueError` when passed an `io` object in text mode. Previously, it would respond with 200 OK and an empty file. [\\#3358](https://github.com/pallets/flask/issues/3358)\n- When using ad-hoc certificates, check for the cryptography library instead of PyOpenSSL. [\\#3492](https://github.com/pallets/flask/pull/3492)\n- When specifying a factory function with `FLASK_APP`, keyword argument can be passed. [\\#3553](https://github.com/pallets/flask/issues/3553)\n- When loading a `.env` or `.flaskenv` file, the current working directory is no longer changed to the location of the file. [\\#3560](https://github.com/pallets/flask/pull/3560)\n- When returning a `(response, headers)` tuple from a view, the headers replace rather than extend existing headers on the response. For example, this allows setting the `Content-Type` for `jsonify()`. Use `response.headers.extend()` if extending is desired. [\\#3628](https://github.com/pallets/flask/issues/3628)\n- The `Scaffold` class provides a common API for the `Flask` and `Blueprint` classes. `Blueprint` information is stored in attributes just like `Flask`, rather than opaque lambda functions. This is intended to improve consistency and maintainability. [\\#3215](https://github.com/pallets/flask/issues/3215)\n- Include `samesite` and `secure` options when removing the session cookie. [\\#3726](https://github.com/pallets/flask/pull/3726)\n- Support passing a `pathlib.Path` to `static_folder`. [\\#3579](https://github.com/pallets/flask/pull/3579)\n- `send_file` and `send_from_directory` are wrappers around the implementations in `werkzeug.utils`. [\\#3828](https://github.com/pallets/flask/pull/3828)\n- Some `send_file` parameters have been renamed, the old names are deprecated. `attachment_filename` is renamed to `download_name`. `cache_timeout` is renamed to `max_age`. `add_etags` is renamed to `etag`. [\\#3828](https://github.com/pallets/flask/pull/3828), [\\#3883](https://github.com/pallets/flask/pull/3883)\n- `send_file` passes `download_name` even if `as_attachment=False` by using `Content-Disposition: inline`. [\\#3828](https://github.com/pallets/flask/pull/3828)\n- `send_file` sets `conditional=True` and `max_age=None` by default. `Cache-Control` is set to `no-cache` if `max_age` is not set, otherwise `public`. This tells browsers to validate conditional requests instead of using a timed cache. [\\#3828](https://github.com/pallets/flask/pull/3828)\n- `helpers.safe_join` is deprecated. Use `werkzeug.utils.safe_join` instead. [\\#3828](https://github.com/pallets/flask/pull/3828)\n- The request context does route matching before opening the session. This could allow a session interface to change behavior based on `request.endpoint`. [\\#3776](https://github.com/pallets/flask/issues/3776)\n- Use Jinja’s implementation of the `|tojson` filter. [\\#3881](https://github.com/pallets/flask/issues/3881)\n- Add route decorators for common HTTP methods. For example, `@app.post(\"/login\")` is a shortcut for `@app.route(\"/login\", methods=[\"POST\"])`. [\\#3907](https://github.com/pallets/flask/pull/3907)\n- Support async views, error handlers, before and after request, and teardown functions. [\\#3412](https://github.com/pallets/flask/pull/3412)\n- Support nesting blueprints. [\\#593](https://github.com/pallets/flask/issues/593), [\\#1548](https://github.com/pallets/flask/issues/1548), [\\#3923](https://github.com/pallets/flask/pull/3923)\n- Set the default encoding to “UTF-8” when loading `.env` and `.flaskenv` files to allow to use non-ASCII characters. [\\#3931](https://github.com/pallets/flask/issues/3931)\n- `flask shell` sets up tab and history completion like the default `python` shell if `readline` is installed. [\\#3941](https://github.com/pallets/flask/issues/3941)\n- `helpers.total_seconds()` is deprecated. Use `timedelta.total_seconds()` instead. [\\#3962](https://github.com/pallets/flask/pull/3962)\n- Add type hinting. [\\#3973](https://github.com/pallets/flask/pull/3973).\n\n## Version 1.1.4\n\nReleased 2021-05-13\n\n- Update `static_folder` to use `_compat.fspath` instead of `os.fspath` to continue supporting Python \\< 3.6 [\\#4050](https://github.com/pallets/flask/issues/4050)\n\n## Version 1.1.3\n\nReleased 2021-05-13\n\n- Set maximum versions of Werkzeug, Jinja, Click, and ItsDangerous. [\\#4043](https://github.com/pallets/flask/issues/4043)\n- Re-add support for passing a `pathlib.Path` for `static_folder`. [\\#3579](https://github.com/pallets/flask/pull/3579)\n\n## Version 1.1.2\n\nReleased 2020-04-03\n\n- Work around an issue when running the `flask` command with an external debugger on Windows. [\\#3297](https://github.com/pallets/flask/issues/3297)\n- The static route will not catch all URLs if the `Flask` `static_folder` argument ends with a slash. [\\#3452](https://github.com/pallets/flask/issues/3452)\n\n## Version 1.1.1\n\nReleased 2019-07-08\n\n- The `flask.json_available` flag was added back for compatibility with some extensions. It will raise a deprecation warning when used, and will be removed in version 2.0.0. [\\#3288](https://github.com/pallets/flask/issues/3288)\n\n## Version 1.1.0\n\nReleased 2019-07-04\n\n- Bump minimum Werkzeug version to \\>= 0.15.\n\n- Drop support for Python 3.4.\n\n- Error handlers for `InternalServerError` or `500` will always be passed an instance of `InternalServerError`. If they are invoked due to an unhandled exception, that original exception is now available as `e.original_exception` rather than being passed directly to the handler. The same is true if the handler is for the base `HTTPException`. This makes error handler behavior more consistent. [\\#3266](https://github.com/pallets/flask/pull/3266)\n\n  - `Flask.finalize_request` is called for all unhandled exceptions even if there is no `500` error handler.\n\n- `Flask.logger` takes the same name as `Flask.name` (the value passed as `Flask(import_name)`. This reverts 1.0’s behavior of always logging to `\"flask.app\"`, in order to support multiple apps in the same process. A warning will be shown if old configuration is detected that needs to be moved. [\\#2866](https://github.com/pallets/flask/issues/2866)\n\n- `RequestContext.copy` includes the current session object in the request context copy. This prevents `session` pointing to an out-of-date object. [\\#2935](https://github.com/pallets/flask/issues/2935)\n\n- Using built-in RequestContext, unprintable Unicode characters in Host header will result in a HTTP 400 response and not HTTP 500 as previously. [\\#2994](https://github.com/pallets/flask/pull/2994)\n\n- `send_file` supports `PathLike` objects as described in [**PEP 519**](https://peps.python.org/pep-0519/), to support `pathlib` in Python 3. [\\#3059](https://github.com/pallets/flask/pull/3059)\n\n- `send_file` supports `BytesIO` partial content. [\\#2957](https://github.com/pallets/flask/issues/2957)\n\n- `open_resource` accepts the “rt” file mode. This still does the same thing as “r”. [\\#3163](https://github.com/pallets/flask/issues/3163)\n\n- The `MethodView.methods` attribute set in a base class is used by subclasses. [\\#3138](https://github.com/pallets/flask/issues/3138)\n\n- `Flask.jinja_options` is a `dict` instead of an `ImmutableDict` to allow easier configuration. Changes must still be made before creating the environment. [\\#3190](https://github.com/pallets/flask/pull/3190)\n\n- Flask’s `JSONMixin` for the request and response wrappers was moved into Werkzeug. Use Werkzeug’s version with Flask-specific support. This bumps the Werkzeug dependency to \\>= 0.15. [\\#3125](https://github.com/pallets/flask/issues/3125)\n\n- The `flask` command entry point is simplified to take advantage of Werkzeug 0.15’s better reloader support. This bumps the Werkzeug dependency to \\>= 0.15. [\\#3022](https://github.com/pallets/flask/issues/3022)\n\n- Support `static_url_path` that ends with a forward slash. [\\#3134](https://github.com/pallets/flask/issues/3134)\n\n- Support empty `static_folder` without requiring setting an empty `static_url_path` as well. [\\#3124](https://github.com/pallets/flask/pull/3124)\n\n- `jsonify` supports `dataclass` objects. [\\#3195](https://github.com/pallets/flask/pull/3195)\n\n- Allow customizing the `Flask.url_map_class` used for routing. [\\#3069](https://github.com/pallets/flask/pull/3069)\n\n- The development server port can be set to 0, which tells the OS to pick an available port. [\\#2926](https://github.com/pallets/flask/issues/2926)\n\n- The return value from `cli.load_dotenv` is more consistent with the documentation. It will return `False` if python-dotenv is not installed, or if the given path isn’t a file. [\\#2937](https://github.com/pallets/flask/issues/2937)\n\n- Signaling support has a stub for the `connect_via` method when the Blinker library is not installed. [\\#3208](https://github.com/pallets/flask/pull/3208)\n\n- Add an `--extra-files` option to the `flask run` CLI command to specify extra files that will trigger the reloader on change. [\\#2897](https://github.com/pallets/flask/issues/2897)\n\n- Allow returning a dictionary from a view function. Similar to how returning a string will produce a `text/html` response, returning a dict will call `jsonify` to produce a `application/json` response. [\\#3111](https://github.com/pallets/flask/pull/3111)\n\n- Blueprints have a `cli` Click group like `app.cli`. CLI commands registered with a blueprint will be available as a group under the `flask` command. [\\#1357](https://github.com/pallets/flask/issues/1357).\n\n- When using the test client as a context manager (`with client:`), all preserved request contexts are popped when the block exits, ensuring nested contexts are cleaned up correctly. [\\#3157](https://github.com/pallets/flask/pull/3157)\n\n- Show a better error message when the view return type is not supported. [\\#3214](https://github.com/pallets/flask/issues/3214)\n\n- `flask.testing.make_test_environ_builder()` has been deprecated in favour of a new class `flask.testing.EnvironBuilder`. [\\#3232](https://github.com/pallets/flask/pull/3232)\n\n- The `flask run` command no longer fails if Python is not built with SSL support. Using the `--cert` option will show an appropriate error message. [\\#3211](https://github.com/pallets/flask/issues/3211)\n\n- URL matching now occurs after the request context is pushed, rather than when it’s created. This allows custom URL converters to access the app and request contexts, such as to query a database for an id. [\\#3088](https://github.com/pallets/flask/issues/3088)\n\n## Version 1.0.4\n\nReleased 2019-07-04\n\n- The key information for `BadRequestKeyError` is no longer cleared outside debug mode, so error handlers can still access it. This requires upgrading to Werkzeug 0.15.5. [\\#3249](https://github.com/pallets/flask/issues/3249)\n- `send_file` url quotes the “:” and “/” characters for more compatible UTF-8 filename support in some browsers. [\\#3074](https://github.com/pallets/flask/issues/3074)\n- Fixes for [**PEP 451**](https://peps.python.org/pep-0451/) import loaders and pytest 5.x. [\\#3275](https://github.com/pallets/flask/issues/3275)\n- Show message about dotenv on stderr instead of stdout. [\\#3285](https://github.com/pallets/flask/issues/3285)\n\n## Version 1.0.3\n\nReleased 2019-05-17\n\n- `send_file` encodes filenames as ASCII instead of Latin-1 (ISO-8859-1). This fixes compatibility with Gunicorn, which is stricter about header encodings than [**PEP 3333**](https://peps.python.org/pep-3333/). [\\#2766](https://github.com/pallets/flask/issues/2766)\n- Allow custom CLIs using `FlaskGroup` to set the debug flag without it always being overwritten based on environment variables. [\\#2765](https://github.com/pallets/flask/pull/2765)\n- `flask --version` outputs Werkzeug’s version and simplifies the Python version. [\\#2825](https://github.com/pallets/flask/pull/2825)\n- `send_file` handles an `attachment_filename` that is a native Python 2 string (bytes) with UTF-8 coded bytes. [\\#2933](https://github.com/pallets/flask/issues/2933)\n- A catch-all error handler registered for `HTTPException` will not handle `RoutingException`, which is used internally during routing. This fixes the unexpected behavior that had been introduced in 1.0. [\\#2986](https://github.com/pallets/flask/pull/2986)\n- Passing the `json` argument to `app.test_client` does not push/pop an extra app context. [\\#2900](https://github.com/pallets/flask/issues/2900)\n\n## Version 1.0.2\n\nReleased 2018-05-02\n\n- Fix more backwards compatibility issues with merging slashes between a blueprint prefix and route. [\\#2748](https://github.com/pallets/flask/pull/2748)\n- Fix error with `flask routes` command when there are no routes. [\\#2751](https://github.com/pallets/flask/issues/2751)\n\n## Version 1.0.1\n\nReleased 2018-04-29\n\n- Fix registering partials (with no `__name__`) as view functions. [\\#2730](https://github.com/pallets/flask/pull/2730)\n- Don’t treat lists returned from view functions the same as tuples. Only tuples are interpreted as response data. [\\#2736](https://github.com/pallets/flask/issues/2736)\n- Extra slashes between a blueprint’s `url_prefix` and a route URL are merged. This fixes some backwards compatibility issues with the change in 1.0. [\\#2731](https://github.com/pallets/flask/issues/2731), [\\#2742](https://github.com/pallets/flask/issues/2742)\n- Only trap `BadRequestKeyError` errors in debug mode, not all `BadRequest` errors. This allows `abort(400)` to continue working as expected. [\\#2735](https://github.com/pallets/flask/issues/2735)\n- The `FLASK_SKIP_DOTENV` environment variable can be set to `1` to skip automatically loading dotenv files. [\\#2722](https://github.com/pallets/flask/issues/2722)\n\n## Version 1.0\n\nReleased 2018-04-26\n\n- Python 2.6 and 3.3 are no longer supported.\n\n- Bump minimum dependency versions to the latest stable versions: Werkzeug \\>= 0.14, Jinja \\>= 2.10, itsdangerous \\>= 0.24, Click \\>= 5.1. [\\#2586](https://github.com/pallets/flask/issues/2586)\n\n- Skip `app.run` when a Flask application is run from the command line. This avoids some behavior that was confusing to debug.\n\n- Change the default for `JSONIFY_PRETTYPRINT_REGULAR` to `False`. `~json.jsonify` returns a compact format by default, and an indented format in debug mode. [\\#2193](https://github.com/pallets/flask/pull/2193)\n\n- `Flask.__init__` accepts the `host_matching` argument and sets it on `Flask.url_map`. [\\#1559](https://github.com/pallets/flask/issues/1559)\n\n- `Flask.__init__` accepts the `static_host` argument and passes it as the `host` argument when defining the static route. [\\#1559](https://github.com/pallets/flask/issues/1559)\n\n- `send_file` supports Unicode in `attachment_filename`. [\\#2223](https://github.com/pallets/flask/pull/2223)\n\n- Pass `_scheme` argument from `url_for` to `Flask.handle_url_build_error`. [\\#2017](https://github.com/pallets/flask/pull/2017)\n\n- `Flask.add_url_rule` accepts the `provide_automatic_options` argument to disable adding the `OPTIONS` method. [\\#1489](https://github.com/pallets/flask/pull/1489)\n\n- `MethodView` subclasses inherit method handlers from base classes. [\\#1936](https://github.com/pallets/flask/pull/1936)\n\n- Errors caused while opening the session at the beginning of the request are handled by the app’s error handlers. [\\#2254](https://github.com/pallets/flask/pull/2254)\n\n- Blueprints gained `Blueprint.json_encoder` and `Blueprint.json_decoder` attributes to override the app’s encoder and decoder. [\\#1898](https://github.com/pallets/flask/pull/1898)\n\n- `Flask.make_response` raises `TypeError` instead of `ValueError` for bad response types. The error messages have been improved to describe why the type is invalid. [\\#2256](https://github.com/pallets/flask/pull/2256)\n\n- Add `routes` CLI command to output routes registered on the application. [\\#2259](https://github.com/pallets/flask/pull/2259)\n\n- Show warning when session cookie domain is a bare hostname or an IP address, as these may not behave properly in some browsers, such as Chrome. [\\#2282](https://github.com/pallets/flask/pull/2282)\n\n- Allow IP address as exact session cookie domain. [\\#2282](https://github.com/pallets/flask/pull/2282)\n\n- `SESSION_COOKIE_DOMAIN` is set if it is detected through `SERVER_NAME`. [\\#2282](https://github.com/pallets/flask/pull/2282)\n\n- Auto-detect zero-argument app factory called `create_app` or `make_app` from `FLASK_APP`. [\\#2297](https://github.com/pallets/flask/pull/2297)\n\n- Factory functions are not required to take a `script_info` parameter to work with the `flask` command. If they take a single parameter or a parameter named `script_info`, the `ScriptInfo` object will be passed. [\\#2319](https://github.com/pallets/flask/pull/2319)\n\n- `FLASK_APP` can be set to an app factory, with arguments if needed, for example `FLASK_APP=myproject.app:create_app('dev')`. [\\#2326](https://github.com/pallets/flask/pull/2326)\n\n- `FLASK_APP` can point to local packages that are not installed in editable mode, although `pip install -e` is still preferred. [\\#2414](https://github.com/pallets/flask/pull/2414)\n\n- The `View` class attribute `View.provide_automatic_options` is set in `View.as_view`, to be detected by `Flask.add_url_rule`. [\\#2316](https://github.com/pallets/flask/pull/2316)\n\n- Error handling will try handlers registered for `blueprint, code`, `app, code`, `blueprint, exception`, `app, exception`. [\\#2314](https://github.com/pallets/flask/pull/2314)\n\n- `Cookie` is added to the response’s `Vary` header if the session is accessed at all during the request (and not deleted). [\\#2288](https://github.com/pallets/flask/pull/2288)\n\n- `Flask.test_request_context` accepts `subdomain` and `url_scheme` arguments for use when building the base URL. [\\#1621](https://github.com/pallets/flask/pull/1621)\n\n- Set `APPLICATION_ROOT` to `'/'` by default. This was already the implicit default when it was set to `None`.\n\n- `TRAP_BAD_REQUEST_ERRORS` is enabled by default in debug mode. `BadRequestKeyError` has a message with the bad key in debug mode instead of the generic bad request message. [\\#2348](https://github.com/pallets/flask/pull/2348)\n\n- Allow registering new tags with `TaggedJSONSerializer` to support storing other types in the session cookie. [\\#2352](https://github.com/pallets/flask/pull/2352)\n\n- Only open the session if the request has not been pushed onto the context stack yet. This allows `stream_with_context` generators to access the same session that the containing view uses. [\\#2354](https://github.com/pallets/flask/pull/2354)\n\n- Add `json` keyword argument for the test client request methods. This will dump the given object as JSON and set the appropriate content type. [\\#2358](https://github.com/pallets/flask/pull/2358)\n\n- Extract JSON handling to a mixin applied to both the `Request` and `Response` classes. This adds the `Response.is_json` and `Response.get_json` methods to the response to make testing JSON response much easier. [\\#2358](https://github.com/pallets/flask/pull/2358)\n\n- Removed error handler caching because it caused unexpected results for some exception inheritance hierarchies. Register handlers explicitly for each exception if you want to avoid traversing the MRO. [\\#2362](https://github.com/pallets/flask/pull/2362)\n\n- Fix incorrect JSON encoding of aware, non-UTC datetimes. [\\#2374](https://github.com/pallets/flask/pull/2374)\n\n- Template auto reloading will honor debug mode even even if `Flask.jinja_env` was already accessed. [\\#2373](https://github.com/pallets/flask/pull/2373)\n\n- The following old deprecated code was removed. [\\#2385](https://github.com/pallets/flask/issues/2385)\n\n  - `flask.ext` - import extensions directly by their name instead of through the `flask.ext` namespace. For example, `import flask.ext.sqlalchemy` becomes `import flask_sqlalchemy`.\n  - `Flask.init_jinja_globals` - extend `Flask.create_jinja_environment` instead.\n  - `Flask.error_handlers` - tracked by `Flask.error_handler_spec`, use `Flask.errorhandler` to register handlers.\n  - `Flask.request_globals_class` - use `Flask.app_ctx_globals_class` instead.\n  - `Flask.static_path` - use `Flask.static_url_path` instead.\n  - `Request.module` - use `Request.blueprint` instead.\n\n- The `Request.json` property is no longer deprecated. [\\#1421](https://github.com/pallets/flask/issues/1421)\n\n- Support passing a `EnvironBuilder` or `dict` to `test_client.open`. [\\#2412](https://github.com/pallets/flask/pull/2412)\n\n- The `flask` command and `Flask.run` will load environment variables from `.env` and `.flaskenv` files if python-dotenv is installed. [\\#2416](https://github.com/pallets/flask/pull/2416)\n\n- When passing a full URL to the test client, the scheme in the URL is used instead of `PREFERRED_URL_SCHEME`. [\\#2430](https://github.com/pallets/flask/pull/2430)\n\n- `Flask.logger` has been simplified. `LOGGER_NAME` and `LOGGER_HANDLER_POLICY` config was removed. The logger is always named `flask.app`. The level is only set on first access, it doesn’t check `Flask.debug` each time. Only one format is used, not different ones depending on `Flask.debug`. No handlers are removed, and a handler is only added if no handlers are already configured. [\\#2436](https://github.com/pallets/flask/pull/2436)\n\n- Blueprint view function names may not contain dots. [\\#2450](https://github.com/pallets/flask/pull/2450)\n\n- Fix a `ValueError` caused by invalid `Range` requests in some cases. [\\#2526](https://github.com/pallets/flask/issues/2526)\n\n- The development server uses threads by default. [\\#2529](https://github.com/pallets/flask/pull/2529)\n\n- Loading config files with `silent=True` will ignore `ENOTDIR` errors. [\\#2581](https://github.com/pallets/flask/pull/2581)\n\n- Pass `--cert` and `--key` options to `flask run` to run the development server over HTTPS. [\\#2606](https://github.com/pallets/flask/pull/2606)\n\n- Added `SESSION_COOKIE_SAMESITE` to control the `SameSite` attribute on the session cookie. [\\#2607](https://github.com/pallets/flask/pull/2607)\n\n- Added `Flask.test_cli_runner` to create a Click runner that can invoke Flask CLI commands for testing. [\\#2636](https://github.com/pallets/flask/pull/2636)\n\n- Subdomain matching is disabled by default and setting `SERVER_NAME` does not implicitly enable it. It can be enabled by passing `subdomain_matching=True` to the `Flask` constructor. [\\#2635](https://github.com/pallets/flask/pull/2635)\n\n- A single trailing slash is stripped from the blueprint `url_prefix` when it is registered with the app. [\\#2629](https://github.com/pallets/flask/pull/2629)\n\n- `Request.get_json` doesn’t cache the result if parsing fails when `silent` is true. [\\#2651](https://github.com/pallets/flask/issues/2651)\n\n- `Request.get_json` no longer accepts arbitrary encodings. Incoming JSON should be encoded using UTF-8 per [**RFC 8259**](https://datatracker.ietf.org/doc/html/rfc8259.html), but Flask will autodetect UTF-8, -16, or -32. [\\#2691](https://github.com/pallets/flask/pull/2691)\n\n- Added `MAX_COOKIE_SIZE` and `Response.max_cookie_size` to control when Werkzeug warns about large cookies that browsers may ignore. [\\#2693](https://github.com/pallets/flask/pull/2693)\n\n- Updated documentation theme to make docs look better in small windows. [\\#2709](https://github.com/pallets/flask/pull/2709)\n\n- Rewrote the tutorial docs and example project to take a more structured approach to help new users avoid common pitfalls. [\\#2676](https://github.com/pallets/flask/pull/2676)\n\n## Version 0.12.5\n\nReleased 2020-02-10\n\n- Pin Werkzeug to \\< 1.0.0. [\\#3497](https://github.com/pallets/flask/issues/3497)\n\n## Version 0.12.4\n\nReleased 2018-04-29\n\n- Repackage 0.12.3 to fix package layout issue. [\\#2728](https://github.com/pallets/flask/issues/2728)\n\n## Version 0.12.3\n\nReleased 2018-04-26\n\n- `Request.get_json` no longer accepts arbitrary encodings. Incoming JSON should be encoded using UTF-8 per [**RFC 8259**](https://datatracker.ietf.org/doc/html/rfc8259.html), but Flask will autodetect UTF-8, -16, or -32. [\\#2692](https://github.com/pallets/flask/issues/2692)\n- Fix a Python warning about imports when using `python -m flask`. [\\#2666](https://github.com/pallets/flask/issues/2666)\n- Fix a `ValueError` caused by invalid `Range` requests in some cases.\n\n## Version 0.12.2\n\nReleased 2017-05-16\n\n- Fix a bug in `safe_join` on Windows.\n\n## Version 0.12.1\n\nReleased 2017-03-31\n\n- Prevent `flask run` from showing a `NoAppException` when an `ImportError` occurs within the imported application module.\n- Fix encoding behavior of `app.config.from_pyfile` for Python 3. [\\#2118](https://github.com/pallets/flask/issues/2118)\n- Use the `SERVER_NAME` config if it is present as default values for `app.run`. [\\#2109](https://github.com/pallets/flask/issues/2109), [\\#2152](https://github.com/pallets/flask/pull/2152)\n- Call `ctx.auto_pop` with the exception object instead of `None`, in the event that a `BaseException` such as `KeyboardInterrupt` is raised in a request handler.\n\n## Version 0.12\n\nReleased 2016-12-21, codename Punsch\n\n- The cli command now responds to `--version`.\n- Mimetype guessing and ETag generation for file-like objects in `send_file` has been removed. [\\#104](https://github.com/pallets/flask/issues/104), :pr\\`1849\\`\n- Mimetype guessing in `send_file` now fails loudly and doesn’t fall back to `application/octet-stream`. [\\#1988](https://github.com/pallets/flask/pull/1988)\n- Make `flask.safe_join` able to join multiple paths like `os.path.join` [\\#1730](https://github.com/pallets/flask/pull/1730)\n- Revert a behavior change that made the dev server crash instead of returning an Internal Server Error. [\\#2006](https://github.com/pallets/flask/pull/2006)\n- Correctly invoke response handlers for both regular request dispatching as well as error handlers.\n- Disable logger propagation by default for the app logger.\n- Add support for range requests in `send_file`.\n- `app.test_client` includes preset default environment, which can now be directly set, instead of per `client.get`.\n- Fix crash when running under PyPy3. [\\#1814](https://github.com/pallets/flask/pull/1814)\n\n## Version 0.11.1\n\nReleased 2016-06-07\n\n- Fixed a bug that prevented `FLASK_APP=foobar/__init__.py` from working. [\\#1872](https://github.com/pallets/flask/pull/1872)\n\n## Version 0.11\n\nReleased 2016-05-29, codename Absinthe\n\n- Added support to serializing top-level arrays to `jsonify`. This introduces a security risk in ancient browsers.\n- Added before_render_template signal.\n- Added `**kwargs` to `Flask.test_client` to support passing additional keyword arguments to the constructor of `Flask.test_client_class`.\n- Added `SESSION_REFRESH_EACH_REQUEST` config key that controls the set-cookie behavior. If set to `True` a permanent session will be refreshed each request and get their lifetime extended, if set to `False` it will only be modified if the session actually modifies. Non permanent sessions are not affected by this and will always expire if the browser window closes.\n- Made Flask support custom JSON mimetypes for incoming data.\n- Added support for returning tuples in the form `(response, headers)` from a view function.\n- Added `Config.from_json`.\n- Added `Flask.config_class`.\n- Added `Config.get_namespace`.\n- Templates are no longer automatically reloaded outside of debug mode. This can be configured with the new `TEMPLATES_AUTO_RELOAD` config key.\n- Added a workaround for a limitation in Python 3.3’s namespace loader.\n- Added support for explicit root paths when using Python 3.3’s namespace packages.\n- Added `flask` and the `flask.cli` module to start the local debug server through the click CLI system. This is recommended over the old `flask.run()` method as it works faster and more reliable due to a different design and also replaces `Flask-Script`.\n- Error handlers that match specific classes are now checked first, thereby allowing catching exceptions that are subclasses of HTTP exceptions (in `werkzeug.exceptions`). This makes it possible for an extension author to create exceptions that will by default result in the HTTP error of their choosing, but may be caught with a custom error handler if desired.\n- Added `Config.from_mapping`.\n- Flask will now log by default even if debug is disabled. The log format is now hardcoded but the default log handling can be disabled through the `LOGGER_HANDLER_POLICY` configuration key.\n- Removed deprecated module functionality.\n- Added the `EXPLAIN_TEMPLATE_LOADING` config flag which when enabled will instruct Flask to explain how it locates templates. This should help users debug when the wrong templates are loaded.\n- Enforce blueprint handling in the order they were registered for template loading.\n- Ported test suite to py.test.\n- Deprecated `request.json` in favour of `request.get_json()`.\n- Add “pretty” and “compressed” separators definitions in jsonify() method. Reduces JSON response size when `JSONIFY_PRETTYPRINT_REGULAR=False` by removing unnecessary white space included by default after separators.\n- JSON responses are now terminated with a newline character, because it is a convention that UNIX text files end with a newline and some clients don’t deal well when this newline is missing. [\\#1262](https://github.com/pallets/flask/pull/1262)\n- The automatically provided `OPTIONS` method is now correctly disabled if the user registered an overriding rule with the lowercase-version `options`. [\\#1288](https://github.com/pallets/flask/issues/1288)\n- `flask.json.jsonify` now supports the `datetime.date` type. [\\#1326](https://github.com/pallets/flask/pull/1326)\n- Don’t leak exception info of already caught exceptions to context teardown handlers. [\\#1393](https://github.com/pallets/flask/pull/1393)\n- Allow custom Jinja environment subclasses. [\\#1422](https://github.com/pallets/flask/pull/1422)\n- Updated extension dev guidelines.\n- `flask.g` now has `pop()` and `setdefault` methods.\n- Turn on autoescape for `flask.templating.render_template_string` by default. [\\#1515](https://github.com/pallets/flask/pull/1515)\n- `flask.ext` is now deprecated. [\\#1484](https://github.com/pallets/flask/pull/1484)\n- `send_from_directory` now raises BadRequest if the filename is invalid on the server OS. [\\#1763](https://github.com/pallets/flask/pull/1763)\n- Added the `JSONIFY_MIMETYPE` configuration variable. [\\#1728](https://github.com/pallets/flask/pull/1728)\n- Exceptions during teardown handling will no longer leave bad application contexts lingering around.\n- Fixed broken `test_appcontext_signals()` test case.\n- Raise an `AttributeError` in `helpers.find_package` with a useful message explaining why it is raised when a [**PEP 302**](https://peps.python.org/pep-0302/) import hook is used without an `is_package()` method.\n- Fixed an issue causing exceptions raised before entering a request or app context to be passed to teardown handlers.\n- Fixed an issue with query parameters getting removed from requests in the test client when absolute URLs were requested.\n- Made `@before_first_request` into a decorator as intended.\n- Fixed an etags bug when sending a file streams with a name.\n- Fixed `send_from_directory` not expanding to the application root path correctly.\n- Changed logic of before first request handlers to flip the flag after invoking. This will allow some uses that are potentially dangerous but should probably be permitted.\n- Fixed Python 3 bug when a handler from `app.url_build_error_handlers` reraises the `BuildError`.\n\n## Version 0.10.1\n\nReleased 2013-06-14\n\n- Fixed an issue where `|tojson` was not quoting single quotes which made the filter not work properly in HTML attributes. Now it’s possible to use that filter in single quoted attributes. This should make using that filter with angular.js easier.\n- Added support for byte strings back to the session system. This broke compatibility with the common case of people putting binary data for token verification into the session.\n- Fixed an issue where registering the same method twice for the same endpoint would trigger an exception incorrectly.\n\n## Version 0.10\n\nReleased 2013-06-13, codename Limoncello\n\n- Changed default cookie serialization format from pickle to JSON to limit the impact an attacker can do if the secret key leaks.\n- Added `template_test` methods in addition to the already existing `template_filter` method family.\n- Added `template_global` methods in addition to the already existing `template_filter` method family.\n- Set the content-length header for x-sendfile.\n- `tojson` filter now does not escape script blocks in HTML5 parsers.\n- `tojson` used in templates is now safe by default. This was allowed due to the different escaping behavior.\n- Flask will now raise an error if you attempt to register a new function on an already used endpoint.\n- Added wrapper module around simplejson and added default serialization of datetime objects. This allows much easier customization of how JSON is handled by Flask or any Flask extension.\n- Removed deprecated internal `flask.session` module alias. Use `flask.sessions` instead to get the session module. This is not to be confused with `flask.session` the session proxy.\n- Templates can now be rendered without request context. The behavior is slightly different as the `request`, `session` and `g` objects will not be available and blueprint’s context processors are not called.\n- The config object is now available to the template as a real global and not through a context processor which makes it available even in imported templates by default.\n- Added an option to generate non-ascii encoded JSON which should result in less bytes being transmitted over the network. It’s disabled by default to not cause confusion with existing libraries that might expect `flask.json.dumps` to return bytes by default.\n- `flask.g` is now stored on the app context instead of the request context.\n- `flask.g` now gained a `get()` method for not erroring out on non existing items.\n- `flask.g` now can be used with the `in` operator to see what’s defined and it now is iterable and will yield all attributes stored.\n- `flask.Flask.request_globals_class` got renamed to `flask.Flask.app_ctx_globals_class` which is a better name to what it does since 0.10.\n- `request`, `session` and `g` are now also added as proxies to the template context which makes them available in imported templates. One has to be very careful with those though because usage outside of macros might cause caching.\n- Flask will no longer invoke the wrong error handlers if a proxy exception is passed through.\n- Added a workaround for chrome’s cookies in localhost not working as intended with domain names.\n- Changed logic for picking defaults for cookie values from sessions to work better with Google Chrome.\n- Added `message_flashed` signal that simplifies flashing testing.\n- Added support for copying of request contexts for better working with greenlets.\n- Removed custom JSON HTTP exception subclasses. If you were relying on them you can reintroduce them again yourself trivially. Using them however is strongly discouraged as the interface was flawed.\n- Python requirements changed: requiring Python 2.6 or 2.7 now to prepare for Python 3.3 port.\n- Changed how the teardown system is informed about exceptions. This is now more reliable in case something handles an exception halfway through the error handling process.\n- Request context preservation in debug mode now keeps the exception information around which means that teardown handlers are able to distinguish error from success cases.\n- Added the `JSONIFY_PRETTYPRINT_REGULAR` configuration variable.\n- Flask now orders JSON keys by default to not trash HTTP caches due to different hash seeds between different workers.\n- Added `appcontext_pushed` and `appcontext_popped` signals.\n- The builtin run method now takes the `SERVER_NAME` into account when picking the default port to run on.\n- Added `flask.request.get_json()` as a replacement for the old `flask.request.json` property.\n\n## Version 0.9\n\nReleased 2012-07-01, codename Campari\n\n- The `Request.on_json_loading_failed` now returns a JSON formatted response by default.\n- The `url_for` function now can generate anchors to the generated links.\n- The `url_for` function now can also explicitly generate URL rules specific to a given HTTP method.\n- Logger now only returns the debug log setting if it was not set explicitly.\n- Unregister a circular dependency between the WSGI environment and the request object when shutting down the request. This means that environ `werkzeug.request` will be `None` after the response was returned to the WSGI server but has the advantage that the garbage collector is not needed on CPython to tear down the request unless the user created circular dependencies themselves.\n- Session is now stored after callbacks so that if the session payload is stored in the session you can still modify it in an after request callback.\n- The `Flask` class will avoid importing the provided import name if it can (the required first parameter), to benefit tools which build Flask instances programmatically. The Flask class will fall back to using import on systems with custom module hooks, e.g. Google App Engine, or when the import name is inside a zip archive (usually an egg) prior to Python 2.7.\n- Blueprints now have a decorator to add custom template filters application wide, `Blueprint.app_template_filter`.\n- The Flask and Blueprint classes now have a non-decorator method for adding custom template filters application wide, `Flask.add_template_filter` and `Blueprint.add_app_template_filter`.\n- The `get_flashed_messages` function now allows rendering flashed message categories in separate blocks, through a `category_filter` argument.\n- The `Flask.run` method now accepts `None` for `host` and `port` arguments, using default values when `None`. This allows for calling run using configuration values, e.g. `app.run(app.config.get('MYHOST'), app.config.get('MYPORT'))`, with proper behavior whether or not a config file is provided.\n- The `render_template` method now accepts a either an iterable of template names or a single template name. Previously, it only accepted a single template name. On an iterable, the first template found is rendered.\n- Added `Flask.app_context` which works very similar to the request context but only provides access to the current application. This also adds support for URL generation without an active request context.\n- View functions can now return a tuple with the first instance being an instance of `Response`. This allows for returning `jsonify(error=\"error msg\"), 400` from a view function.\n- `Flask` and `Blueprint` now provide a `get_send_file_max_age` hook for subclasses to override behavior of serving static files from Flask when using `Flask.send_static_file` (used for the default static file handler) and `helpers.send_file`. This hook is provided a filename, which for example allows changing cache controls by file extension. The default max-age for `send_file` and static files can be configured through a new `SEND_FILE_MAX_AGE_DEFAULT` configuration variable, which is used in the default `get_send_file_max_age` implementation.\n- Fixed an assumption in sessions implementation which could break message flashing on sessions implementations which use external storage.\n- Changed the behavior of tuple return values from functions. They are no longer arguments to the response object, they now have a defined meaning.\n- Added `Flask.request_globals_class` to allow a specific class to be used on creation of the `g` instance of each request.\n- Added `required_methods` attribute to view functions to force-add methods on registration.\n- Added `flask.after_this_request`.\n- Added `flask.stream_with_context` and the ability to push contexts multiple times without producing unexpected behavior.\n\n## Version 0.8.1\n\nReleased 2012-07-01\n\n- Fixed an issue with the undocumented `flask.session` module to not work properly on Python 2.5. It should not be used but did cause some problems for package managers.\n\n## Version 0.8\n\nReleased 2011-09-29, codename Rakija\n\n- Refactored session support into a session interface so that the implementation of the sessions can be changed without having to override the Flask class.\n- Empty session cookies are now deleted properly automatically.\n- View functions can now opt out of getting the automatic OPTIONS implementation.\n- HTTP exceptions and Bad Request errors can now be trapped so that they show up normally in the traceback.\n- Flask in debug mode is now detecting some common problems and tries to warn you about them.\n- Flask in debug mode will now complain with an assertion error if a view was attached after the first request was handled. This gives earlier feedback when users forget to import view code ahead of time.\n- Added the ability to register callbacks that are only triggered once at the beginning of the first request with `Flask.before_first_request`.\n- Malformed JSON data will now trigger a bad request HTTP exception instead of a value error which usually would result in a 500 internal server error if not handled. This is a backwards incompatible change.\n- Applications now not only have a root path where the resources and modules are located but also an instance path which is the designated place to drop files that are modified at runtime (uploads etc.). Also this is conceptually only instance depending and outside version control so it’s the perfect place to put configuration files etc.\n- Added the `APPLICATION_ROOT` configuration variable.\n- Implemented `TestClient.session_transaction` to easily modify sessions from the test environment.\n- Refactored test client internally. The `APPLICATION_ROOT` configuration variable as well as `SERVER_NAME` are now properly used by the test client as defaults.\n- Added `View.decorators` to support simpler decorating of pluggable (class-based) views.\n- Fixed an issue where the test client if used with the “with” statement did not trigger the execution of the teardown handlers.\n- Added finer control over the session cookie parameters.\n- HEAD requests to a method view now automatically dispatch to the `get` method if no handler was implemented.\n- Implemented the virtual `flask.ext` package to import extensions from.\n- The context preservation on exceptions is now an integral component of Flask itself and no longer of the test client. This cleaned up some internal logic and lowers the odds of runaway request contexts in unittests.\n- Fixed the Jinja2 environment’s `list_templates` method not returning the correct names when blueprints or modules were involved.\n\n## Version 0.7.2\n\nReleased 2011-07-06\n\n- Fixed an issue with URL processors not properly working on blueprints.\n\n## Version 0.7.1\n\nReleased 2011-06-29\n\n- Added missing future import that broke 2.5 compatibility.\n- Fixed an infinite redirect issue with blueprints.\n\n## Version 0.7\n\nReleased 2011-06-28, codename Grappa\n\n- Added `Flask.make_default_options_response` which can be used by subclasses to alter the default behavior for `OPTIONS` responses.\n- Unbound locals now raise a proper `RuntimeError` instead of an `AttributeError`.\n- Mimetype guessing and etag support based on file objects is now deprecated for `send_file` because it was unreliable. Pass filenames instead or attach your own etags and provide a proper mimetype by hand.\n- Static file handling for modules now requires the name of the static folder to be supplied explicitly. The previous autodetection was not reliable and caused issues on Google’s App Engine. Until 1.0 the old behavior will continue to work but issue dependency warnings.\n- Fixed a problem for Flask to run on jython.\n- Added a `PROPAGATE_EXCEPTIONS` configuration variable that can be used to flip the setting of exception propagation which previously was linked to `DEBUG` alone and is now linked to either `DEBUG` or `TESTING`.\n- Flask no longer internally depends on rules being added through the `add_url_rule` function and can now also accept regular werkzeug rules added to the url map.\n- Added an `endpoint` method to the flask application object which allows one to register a callback to an arbitrary endpoint with a decorator.\n- Use Last-Modified for static file sending instead of Date which was incorrectly introduced in 0.6.\n- Added `create_jinja_loader` to override the loader creation process.\n- Implemented a silent flag for `config.from_pyfile`.\n- Added `teardown_request` decorator, for functions that should run at the end of a request regardless of whether an exception occurred. Also the behavior for `after_request` was changed. It’s now no longer executed when an exception is raised.\n- Implemented `has_request_context`.\n- Deprecated `init_jinja_globals`. Override the `Flask.create_jinja_environment` method instead to achieve the same functionality.\n- Added `safe_join`.\n- The automatic JSON request data unpacking now looks at the charset mimetype parameter.\n- Don’t modify the session on `get_flashed_messages` if there are no messages in the session.\n- `before_request` handlers are now able to abort requests with errors.\n- It is not possible to define user exception handlers. That way you can provide custom error messages from a central hub for certain errors that might occur during request processing (for instance database connection errors, timeouts from remote resources etc.).\n- Blueprints can provide blueprint specific error handlers.\n- Implemented generic class-based views.\n\n## Version 0.6.1\n\nReleased 2010-12-31\n\n- Fixed an issue where the default `OPTIONS` response was not exposing all valid methods in the `Allow` header.\n- Jinja2 template loading syntax now allows “./” in front of a template load path. Previously this caused issues with module setups.\n- Fixed an issue where the subdomain setting for modules was ignored for the static folder.\n- Fixed a security problem that allowed clients to download arbitrary files if the host server was a windows based operating system and the client uses backslashes to escape the directory the files where exposed from.\n\n## Version 0.6\n\nReleased 2010-07-27, codename Whisky\n\n- After request functions are now called in reverse order of registration.\n- OPTIONS is now automatically implemented by Flask unless the application explicitly adds ‘OPTIONS’ as method to the URL rule. In this case no automatic OPTIONS handling kicks in.\n- Static rules are now even in place if there is no static folder for the module. This was implemented to aid GAE which will remove the static folder if it’s part of a mapping in the .yml file.\n- `Flask.config` is now available in the templates as `config`.\n- Context processors will no longer override values passed directly to the render function.\n- Added the ability to limit the incoming request data with the new `MAX_CONTENT_LENGTH` configuration value.\n- The endpoint for the `Module.add_url_rule` method is now optional to be consistent with the function of the same name on the application object.\n- Added a `make_response` function that simplifies creating response object instances in views.\n- Added signalling support based on blinker. This feature is currently optional and supposed to be used by extensions and applications. If you want to use it, make sure to have `blinker` installed.\n- Refactored the way URL adapters are created. This process is now fully customizable with the `Flask.create_url_adapter` method.\n- Modules can now register for a subdomain instead of just an URL prefix. This makes it possible to bind a whole module to a configurable subdomain.\n\n## Version 0.5.2\n\nReleased 2010-07-15\n\n- Fixed another issue with loading templates from directories when modules were used.\n\n## Version 0.5.1\n\nReleased 2010-07-06\n\n- Fixes an issue with template loading from directories when modules where used.\n\n## Version 0.5\n\nReleased 2010-07-06, codename Calvados\n\n- Fixed a bug with subdomains that was caused by the inability to specify the server name. The server name can now be set with the `SERVER_NAME` config key. This key is now also used to set the session cookie cross-subdomain wide.\n- Autoescaping is no longer active for all templates. Instead it is only active for `.html`, `.htm`, `.xml` and `.xhtml`. Inside templates this behavior can be changed with the `autoescape` tag.\n- Refactored Flask internally. It now consists of more than a single file.\n- `send_file` now emits etags and has the ability to do conditional responses builtin.\n- (temporarily) dropped support for zipped applications. This was a rarely used feature and led to some confusing behavior.\n- Added support for per-package template and static-file directories.\n- Removed support for `create_jinja_loader` which is no longer used in 0.5 due to the improved module support.\n- Added a helper function to expose files from any directory.\n\n## Version 0.4\n\nReleased 2010-06-18, codename Rakia\n\n- Added the ability to register application wide error handlers from modules.\n- `Flask.after_request` handlers are now also invoked if the request dies with an exception and an error handling page kicks in.\n- Test client has not the ability to preserve the request context for a little longer. This can also be used to trigger custom requests that do not pop the request stack for testing.\n- Because the Python standard library caches loggers, the name of the logger is configurable now to better support unittests.\n- Added `TESTING` switch that can activate unittesting helpers.\n- The logger switches to `DEBUG` mode now if debug is enabled.\n\n## Version 0.3.1\n\nReleased 2010-05-28\n\n- Fixed a error reporting bug with `Config.from_envvar`.\n- Removed some unused code.\n- Release does no longer include development leftover files (.git folder for themes, built documentation in zip and pdf file and some .pyc files)\n\n## Version 0.3\n\nReleased 2010-05-28, codename Schnaps\n\n- Added support for categories for flashed messages.\n- The application now configures a `logging.Handler` and will log request handling exceptions to that logger when not in debug mode. This makes it possible to receive mails on server errors for example.\n- Added support for context binding that does not require the use of the with statement for playing in the console.\n- The request context is now available within the with statement making it possible to further push the request context or pop it.\n- Added support for configurations.\n\n## Version 0.2\n\nReleased 2010-05-12, codename J?germeister\n\n- Various bugfixes\n- Integrated JSON support\n- Added `get_template_attribute` helper function.\n- `Flask.add_url_rule` can now also register a view function.\n- Refactored internal request dispatching.\n- Server listens on 127.0.0.1 by default now to fix issues with chrome.\n- Added external URL support.\n- Added support for `send_file`.\n- Module support and internal request handling refactoring to better support pluggable applications.\n- Sessions can be set to be permanent now on a per-session basis.\n- Better error reporting on missing secret keys.\n- Added support for Google Appengine.\n\n## Version 0.1\n\nReleased 2010-04-16\n\n- First public preview release.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/changes/](https://flask.palletsprojects.com/en/3.0.x/changes/)"
- name: Class-based Views
  id: views/index
  summary: This page introduces using the View and MethodView classes to write class-based views
  description: "# Class-based Views\n\nThis page introduces using the [`View`](../api/index#flask.views.View \"flask.views.View\") and [`MethodView`](../api/index#flask.views.MethodView \"flask.views.MethodView\") classes to write class-based views.\n\nA class-based view is a class that acts as a view function. Because it is a class, different instances of the class can be created with different arguments, to change the behavior of the view. This is also known as generic, reusable, or pluggable views.\n\nAn example of where this is useful is defining a class that creates an API based on the database model it is initialized with.\n\nFor more complex API behavior and customization, look into the various API extensions for Flask.\n\n## Basic Reusable View\n\nLet’s walk through an example converting a view function to a view class. We start with a view function that queries a list of users then renders a template to show the list.\n\n``` python\n@app.route(\"/users/\")\ndef user_list():\n    users = User.query.all()\n    return render_template(\"users.html\", users=users)\n```\n\nThis works for the user model, but let’s say you also had more models that needed list pages. You’d need to write another view function for each model, even though the only thing that would change is the model and template name.\n\nInstead, you can write a [`View`](../api/index#flask.views.View \"flask.views.View\") subclass that will query a model and render a template. As the first step, we’ll convert the view to a class without any customization.\n\n``` python\nfrom flask.views import View\n\nclass UserList(View):\n    def dispatch_request(self):\n        users = User.query.all()\n        return render_template(\"users.html\", objects=users)\n\napp.add_url_rule(\"/users/\", view_func=UserList.as_view(\"user_list\"))\n```\n\nThe [`View.dispatch_request()`](../api/index#flask.views.View.dispatch_request \"flask.views.View.dispatch_request\") method is the equivalent of the view function. Calling [`View.as_view()`](../api/index#flask.views.View.as_view \"flask.views.View.as_view\") method will create a view function that can be registered on the app with its [`add_url_rule()`](../api/index#flask.Flask.add_url_rule \"flask.Flask.add_url_rule\") method. The first argument to `as_view` is the name to use to refer to the view with [`url_for()`](../api/index#flask.url_for \"flask.url_for\").\n\nNote\n\nYou can’t decorate the class with `@app.route()` the way you’d do with a basic view function.\n\nNext, we need to be able to register the same view class for different models and templates, to make it more useful than the original function. The class will take two arguments, the model and template, and store them on `self`. Then `dispatch_request` can reference these instead of hard-coded values.\n\n``` python\nclass ListView(View):\n    def __init__(self, model, template):\n        self.model = model\n        self.template = template\n\n    def dispatch_request(self):\n        items = self.model.query.all()\n        return render_template(self.template, items=items)\n```\n\nRemember, we create the view function with `View.as_view()` instead of creating the class directly. Any extra arguments passed to `as_view` are then passed when creating the class. Now we can register the same view to handle multiple models.\n\n``` python\napp.add_url_rule(\n    \"/users/\",\n    view_func=ListView.as_view(\"user_list\", User, \"users.html\"),\n)\napp.add_url_rule(\n    \"/stories/\",\n    view_func=ListView.as_view(\"story_list\", Story, \"stories.html\"),\n)\n```\n\n## URL Variables\n\nAny variables captured by the URL are passed as keyword arguments to the `dispatch_request` method, as they would be for a regular view function.\n\n``` python\nclass DetailView(View):\n    def __init__(self, model):\n        self.model = model\n        self.template = f\"{model.__name__.lower()}/detail.html\"\n\n    def dispatch_request(self, id)\n        item = self.model.query.get_or_404(id)\n        return render_template(self.template, item=item)\n\napp.add_url_rule(\n    \"/users/<int:id>\",\n    view_func=DetailView.as_view(\"user_detail\", User)\n)\n```\n\n## View Lifetime and `self`\n\nBy default, a new instance of the view class is created every time a request is handled. This means that it is safe to write other data to `self` during the request, since the next request will not see it, unlike other forms of global state.\n\nHowever, if your view class needs to do a lot of complex initialization, doing it for every request is unnecessary and can be inefficient. To avoid this, set [`View.init_every_request`](../api/index#flask.views.View.init_every_request \"flask.views.View.init_every_request\") to `False`, which will only create one instance of the class and use it for every request. In this case, writing to `self` is not safe. If you need to store data during the request, use [`g`](../api/index#flask.g \"flask.g\") instead.\n\nIn the `ListView` example, nothing writes to `self` during the request, so it is more efficient to create a single instance.\n\n``` python\nclass ListView(View):\n    init_every_request = False\n\n    def __init__(self, model, template):\n        self.model = model\n        self.template = template\n\n    def dispatch_request(self):\n        items = self.model.query.all()\n        return render_template(self.template, items=items)\n```\n\nDifferent instances will still be created each for each `as_view` call, but not for each request to those views.\n\n## View Decorators\n\nThe view class itself is not the view function. View decorators need to be applied to the view function returned by `as_view`, not the class itself. Set [`View.decorators`](../api/index#flask.views.View.decorators \"flask.views.View.decorators\") to a list of decorators to apply.\n\n``` python\nclass UserList(View):\n    decorators = [cache(minutes=2), login_required]\n\napp.add_url_rule('/users/', view_func=UserList.as_view())\n```\n\nIf you didn’t set `decorators`, you could apply them manually instead. This is equivalent to:\n\n``` python\nview = UserList.as_view(\"users_list\")\nview = cache(minutes=2)(view)\nview = login_required(view)\napp.add_url_rule('/users/', view_func=view)\n```\n\nKeep in mind that order matters. If you’re used to `@decorator` style, this is equivalent to:\n\n``` python\n@app.route(\"/users/\")\n@login_required\n@cache(minutes=2)\ndef user_list():\n    ...\n```\n\n## Method Hints\n\nA common pattern is to register a view with `methods=[\"GET\", \"POST\"]`, then check `request.method == \"POST\"` to decide what to do. Setting [`View.methods`](../api/index#flask.views.View.methods \"flask.views.View.methods\") is equivalent to passing the list of methods to `add_url_rule` or `route`.\n\n``` python\nclass MyView(View):\n    methods = [\"GET\", \"POST\"]\n\n    def dispatch_request(self):\n        if request.method == \"POST\":\n            ...\n        ...\n\napp.add_url_rule('/my-view', view_func=MyView.as_view('my-view'))\n```\n\nThis is equivalent to the following, except further subclasses can inherit or change the methods.\n\n``` python\napp.add_url_rule(\n    \"/my-view\",\n    view_func=MyView.as_view(\"my-view\"),\n    methods=[\"GET\", \"POST\"],\n)\n```\n\n## Method Dispatching and APIs\n\nFor APIs it can be helpful to use a different function for each HTTP method. [`MethodView`](../api/index#flask.views.MethodView \"flask.views.MethodView\") extends the basic [`View`](../api/index#flask.views.View \"flask.views.View\") to dispatch to different methods of the class based on the request method. Each HTTP method maps to a method of the class with the same (lowercase) name.\n\n[`MethodView`](../api/index#flask.views.MethodView \"flask.views.MethodView\") automatically sets [`View.methods`](../api/index#flask.views.View.methods \"flask.views.View.methods\") based on the methods defined by the class. It even knows how to handle subclasses that override or define other methods.\n\nWe can make a generic `ItemAPI` class that provides get (detail), patch (edit), and delete methods for a given model. A `GroupAPI` can provide get (list) and post (create) methods.\n\n``` python\nfrom flask.views import MethodView\n\nclass ItemAPI(MethodView):\n    init_every_request = False\n\n    def __init__(self, model):\n        self.model = model\n        self.validator = generate_validator(model)\n\n    def _get_item(self, id):\n        return self.model.query.get_or_404(id)\n\n    def get(self, id):\n        item = self._get_item(id)\n        return jsonify(item.to_json())\n\n    def patch(self, id):\n        item = self._get_item(id)\n        errors = self.validator.validate(item, request.json)\n\n        if errors:\n            return jsonify(errors), 400\n\n        item.update_from_json(request.json)\n        db.session.commit()\n        return jsonify(item.to_json())\n\n    def delete(self, id):\n        item = self._get_item(id)\n        db.session.delete(item)\n        db.session.commit()\n        return \"\", 204\n\nclass GroupAPI(MethodView):\n    init_every_request = False\n\n    def __init__(self, model):\n        self.model = model\n        self.validator = generate_validator(model, create=True)\n\n    def get(self):\n        items = self.model.query.all()\n        return jsonify([item.to_json() for item in items])\n\n    def post(self):\n        errors = self.validator.validate(request.json)\n\n        if errors:\n            return jsonify(errors), 400\n\n        db.session.add(self.model.from_json(request.json))\n        db.session.commit()\n        return jsonify(item.to_json())\n\ndef register_api(app, model, name):\n    item = ItemAPI.as_view(f\"{name}-item\", model)\n    group = GroupAPI.as_view(f\"{name}-group\", model)\n    app.add_url_rule(f\"/{name}/<int:id>\", view_func=item)\n    app.add_url_rule(f\"/{name}/\", view_func=group)\n\nregister_api(app, User, \"users\")\nregister_api(app, Story, \"stories\")\n```\n\nThis produces the following views, a standard REST API!\n\n|                 |          |                     |\n|-----------------|----------|---------------------|\n| URL             | Method   | Description         |\n| `/users/`       | `GET`    | List all users      |\n| `/users/`       | `POST`   | Create a new user   |\n| `/users/<id>`   | `GET`    | Show a single user  |\n| `/users/<id>`   | `PATCH`  | Update a user       |\n| `/users/<id>`   | `DELETE` | Delete a user       |\n| `/stories/`     | `GET`    | List all stories    |\n| `/stories/`     | `POST`   | Create a new story  |\n| `/stories/<id>` | `GET`    | Show a single story |\n| `/stories/<id>` | `PATCH`  | Update a story      |\n| `/stories/<id>` | `DELETE` | Delete a story      |\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/views/](https://flask.palletsprojects.com/en/3.0.x/views/)"
- name: Command Line Interface
  id: cli/index
  summary: Installing Flask installs the flask script, a Click command line interface, in your virtualenv
  description: "# Command Line Interface\n\nInstalling Flask installs the `flask` script, a [Click](https://click.palletsprojects.com/) command line interface, in your virtualenv. Executed from the terminal, this script gives access to built-in, extension, and application-defined commands. The `--help` option will give more information about any commands and options.\n\n## Application Discovery\n\nThe `flask` command is installed by Flask, not your application; it must be told where to find your application in order to use it. The `--app` option is used to specify how to load the application.\n\nWhile `--app` supports a variety of options for specifying your application, most use cases should be simple. Here are the typical values:\n\n(nothing)  \nThe name “app” or “wsgi” is imported (as a “.py” file, or package), automatically detecting an app (`app` or `application`) or factory (`create_app` or `make_app`).\n\n`--app hello`  \nThe given name is imported, automatically detecting an app (`app` or `application`) or factory (`create_app` or `make_app`).\n\n`--app` has three parts: an optional path that sets the current working directory, a Python file or dotted import path, and an optional variable name of the instance or factory. If the name is a factory, it can optionally be followed by arguments in parentheses. The following values demonstrate these parts:\n\n`--app src/hello`  \nSets the current working directory to `src` then imports `hello`.\n\n`--app hello.web`  \nImports the path `hello.web`.\n\n`--app hello:app2`  \nUses the `app2` Flask instance in `hello`.\n\n`--app 'hello:create_app(\"dev\")'`  \nThe `create_app` factory in `hello` is called with the string `'dev'` as the argument.\n\nIf `--app` is not set, the command will try to import “app” or “wsgi” (as a “.py” file, or package) and try to detect an application instance or factory.\n\nWithin the given import, the command looks for an application instance named `app` or `application`, then any application instance. If no instance is found, the command looks for a factory function named `create_app` or `make_app` that returns an instance.\n\nIf parentheses follow the factory name, their contents are parsed as Python literals and passed as arguments and keyword arguments to the function. This means that strings must still be in quotes.\n\n## Run the Development Server\n\nThe [`run`](../api/index#flask.cli.run_command \"flask.cli.run_command\") command will start the development server. It replaces the [`Flask.run()`](../api/index#flask.Flask.run \"flask.Flask.run\") method in most cases.\n\n``` python\n$ flask --app hello run\n * Serving Flask app \"hello\"\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n```\n\nWarning\n\nDo not use this command to run your application in production. Only use the development server during development. The development server is provided for convenience, but is not designed to be particularly secure, stable, or efficient. See [Deploying to Production](../deploying/index) for how to run in production.\n\nIf another program is already using port 5000, you’ll see `OSError: [Errno 98]` or `OSError: [WinError 10013]` when the server tries to start. See [Address already in use](../server/index#address-already-in-use) for how to handle that.\n\n### Debug Mode\n\nIn debug mode, the `flask run` command will enable the interactive debugger and the reloader by default, and make errors easier to see and debug. To enable debug mode, use the `--debug` option.\n\n``` console\n$ flask --app hello run --debug\n * Serving Flask app \"hello\"\n * Debug mode: on\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n * Restarting with inotify reloader\n * Debugger is active!\n * Debugger PIN: 223-456-919\n```\n\nThe `--debug` option can also be passed to the top level `flask` command to enable debug mode for any command. The following two `run` calls are equivalent.\n\n``` console\n$ flask --app hello --debug run\n$ flask --app hello run --debug\n```\n\n### Watch and Ignore Files with the Reloader\n\nWhen using debug mode, the reloader will trigger whenever your Python code or imported modules change. The reloader can watch additional files with the `--extra-files` option. Multiple paths are separated with `:`, or `;` on Windows.\n\n``` text\n$ flask run --extra-files file1:dirA/file2:dirB/\n * Running on http://127.0.0.1:8000/\n * Detected change in '/path/to/file1', reloading\n```\n\nThe reloader can also ignore files using [`fnmatch`](https://docs.python.org/3/library/fnmatch.html#module-fnmatch \"(in Python v3.11)\") patterns with the `--exclude-patterns` option. Multiple patterns are separated with `:`, or `;` on Windows.\n\n## Open a Shell\n\nTo explore the data in your application, you can start an interactive Python shell with the [`shell`](../api/index#flask.cli.shell_command \"flask.cli.shell_command\") command. An application context will be active, and the app instance will be imported.\n\n``` python\n$ flask shell\nPython 3.10.0 (default, Oct 27 2021, 06:59:51) [GCC 11.1.0] on linux\nApp: example [production]\nInstance: /home/david/Projects/pallets/flask/instance\n>>>\n```\n\nUse [`shell_context_processor()`](../api/index#flask.Flask.shell_context_processor \"flask.Flask.shell_context_processor\") to add other automatic imports.\n\n## Environment Variables From dotenv\n\nThe `flask` command supports setting any option for any command with environment variables. The variables are named like `FLASK_OPTION` or `FLASK_COMMAND_OPTION`, for example `FLASK_APP` or `FLASK_RUN_PORT`.\n\nRather than passing options every time you run a command, or environment variables every time you open a new terminal, you can use Flask’s dotenv support to set environment variables automatically.\n\nIf [python-dotenv](https://github.com/theskumar/python-dotenv#readme) is installed, running the `flask` command will set environment variables defined in the files `.env` and `.flaskenv`. You can also specify an extra file to load with the `--env-file` option. Dotenv files can be used to avoid having to set `--app` or `FLASK_APP` manually, and to set configuration using environment variables similar to how some deployment services work.\n\nVariables set on the command line are used over those set in `.env`, which are used over those set in `.flaskenv`. `.flaskenv` should be used for public variables, such as `FLASK_APP`, while `.env` should not be committed to your repository so that it can set private variables.\n\nDirectories are scanned upwards from the directory you call `flask` from to locate the files.\n\nThe files are only loaded by the `flask` command or calling [`run()`](../api/index#flask.Flask.run \"flask.Flask.run\"). If you would like to load these files when running in production, you should call [`load_dotenv()`](../api/index#flask.cli.load_dotenv \"flask.cli.load_dotenv\") manually.\n\n### Setting Command Options\n\nClick is configured to load default values for command options from environment variables. The variables use the pattern `FLASK_COMMAND_OPTION`. For example, to set the port for the run command, instead of `flask run --port 8000`:\n\n``` text\n$ export FLASK_RUN_PORT=8000\n$ flask run\n * Running on http://127.0.0.1:8000/\n```\n\n``` text\n$ set -x FLASK_RUN_PORT 8000\n$ flask run\n * Running on http://127.0.0.1:8000/\n```\n\n``` text\n> set FLASK_RUN_PORT=8000\n> flask run\n * Running on http://127.0.0.1:8000/\n```\n\n``` text\n> $env:FLASK_RUN_PORT = 8000\n> flask run\n * Running on http://127.0.0.1:8000/\n```\n\nThese can be added to the `.flaskenv` file just like `FLASK_APP` to control default command options.\n\n### Disable dotenv\n\nThe `flask` command will show a message if it detects dotenv files but python-dotenv is not installed.\n\n``` bash\n$ flask run\n * Tip: There are .env files present. Do \"pip install python-dotenv\" to use them.\n```\n\nYou can tell Flask not to load dotenv files even when python-dotenv is installed by setting the `FLASK_SKIP_DOTENV` environment variable. This can be useful if you want to load them manually, or if you’re using a project runner that loads them already. Keep in mind that the environment variables must be set before the app loads or it won’t configure as expected.\n\n``` text\n$ export FLASK_SKIP_DOTENV=1\n$ flask run\n```\n\n``` text\n$ set -x FLASK_SKIP_DOTENV 1\n$ flask run\n```\n\n``` text\n> set FLASK_SKIP_DOTENV=1\n> flask run\n```\n\n``` text\n> $env:FLASK_SKIP_DOTENV = 1\n> flask run\n```\n\n## Environment Variables From virtualenv\n\nIf you do not want to install dotenv support, you can still set environment variables by adding them to the end of the virtualenv’s `activate` script. Activating the virtualenv will set the variables.\n\nUnix Bash, `.venv/bin/activate`:\n\n``` python\n$ export FLASK_APP=hello\n```\n\nFish, `.venv/bin/activate.fish`:\n\n``` python\n$ set -x FLASK_APP hello\n```\n\nWindows CMD, `.venv\\Scripts\\activate.bat`:\n\n``` python\n> set FLASK_APP=hello\n```\n\nWindows Powershell, `.venv\\Scripts\\activate.ps1`:\n\n``` python\n> $env:FLASK_APP = \"hello\"\n```\n\nIt is preferred to use dotenv support over this, since `.flaskenv` can be committed to the repository so that it works automatically wherever the project is checked out.\n\n## Custom Commands\n\nThe `flask` command is implemented using [Click](https://click.palletsprojects.com/). See that project’s documentation for full information about writing commands.\n\nThis example adds the command `create-user` that takes the argument `name`.\n\n``` python\nimport click\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.cli.command(\"create-user\")\n@click.argument(\"name\")\ndef create_user(name):\n    ...\n```\n\n``` python\n$ flask create-user admin\n```\n\nThis example adds the same command, but as `user create`, a command in a group. This is useful if you want to organize multiple related commands.\n\n``` python\nimport click\nfrom flask import Flask\nfrom flask.cli import AppGroup\n\napp = Flask(__name__)\nuser_cli = AppGroup('user')\n\n@user_cli.command('create')\n@click.argument('name')\ndef create_user(name):\n    ...\n\napp.cli.add_command(user_cli)\n```\n\n``` python\n$ flask user create demo\n```\n\nSee [Running Commands with the CLI Runner](../testing/index#testing-cli) for an overview of how to test your custom commands.\n\n### Registering Commands with Blueprints\n\nIf your application uses blueprints, you can optionally register CLI commands directly onto them. When your blueprint is registered onto your application, the associated commands will be available to the `flask` command. By default, those commands will be nested in a group matching the name of the blueprint.\n\n``` python\nfrom flask import Blueprint\n\nbp = Blueprint('students', __name__)\n\n@bp.cli.command('create')\n@click.argument('name')\ndef create(name):\n    ...\n\napp.register_blueprint(bp)\n```\n\n``` text\n$ flask students create alice\n```\n\nYou can alter the group name by specifying the `cli_group` parameter when creating the [`Blueprint`](../api/index#flask.Blueprint \"flask.Blueprint\") object, or later with [`app.register_blueprint(bp, cli_group='...')`](../api/index#flask.Flask.register_blueprint \"flask.Flask.register_blueprint\"). The following are equivalent:\n\n``` python\nbp = Blueprint('students', __name__, cli_group='other')\n# or\napp.register_blueprint(bp, cli_group='other')\n```\n\n``` text\n$ flask other create alice\n```\n\nSpecifying `cli_group=None` will remove the nesting and merge the commands directly to the application’s level:\n\n``` python\nbp = Blueprint('students', __name__, cli_group=None)\n# or\napp.register_blueprint(bp, cli_group=None)\n```\n\n``` text\n$ flask create alice\n```\n\n### Application Context\n\nCommands added using the Flask app’s [`cli`](../api/index#flask.Flask.cli \"flask.Flask.cli\") or [`FlaskGroup`](../api/index#flask.cli.FlaskGroup \"flask.cli.FlaskGroup\") [`command()`](../api/index#flask.cli.AppGroup.command \"flask.cli.AppGroup.command\") decorator will be executed with an application context pushed, so your custom commands and parameters have access to the app and its configuration. The [`with_appcontext()`](../api/index#flask.cli.with_appcontext \"flask.cli.with_appcontext\") decorator can be used to get the same behavior, but is not needed in most cases.\n\n``` python\nimport click\nfrom flask.cli import with_appcontext\n\n@click.command()\n@with_appcontext\ndef do_work():\n    ...\n\napp.cli.add_command(do_work)\n```\n\n## Plugins\n\nFlask will automatically load commands specified in the `flask.commands` [entry point](https://packaging.python.org/tutorials/packaging-projects/#entry-points). This is useful for extensions that want to add commands when they are installed. Entry points are specified in `pyproject.toml`:\n\n``` toml\n[project.entry-points.\"flask.commands\"]\nmy-command = \"my_extension.commands:cli\"\n```\n\nInside `my_extension/commands.py` you can then export a Click object:\n\n``` python\nimport click\n\n@click.command()\ndef cli():\n    ...\n```\n\nOnce that package is installed in the same virtualenv as your Flask project, you can run `flask my-command` to invoke the command.\n\n## Custom Scripts\n\nWhen you are using the app factory pattern, it may be more convenient to define your own Click script. Instead of using `--app` and letting Flask load your application, you can create your own Click object and export it as a [console script](https://packaging.python.org/tutorials/packaging-projects/#console-scripts) entry point.\n\nCreate an instance of [`FlaskGroup`](../api/index#flask.cli.FlaskGroup \"flask.cli.FlaskGroup\") and pass it the factory:\n\n``` python\nimport click\nfrom flask import Flask\nfrom flask.cli import FlaskGroup\n\ndef create_app():\n    app = Flask('wiki')\n    # other setup\n    return app\n\n@click.group(cls=FlaskGroup, create_app=create_app)\ndef cli():\n    \"\"\"Management script for the Wiki application.\"\"\"\n```\n\nDefine the entry point in `pyproject.toml`:\n\n``` toml\n[project.scripts]\nwiki = \"wiki:cli\"\n```\n\nInstall the application in the virtualenv in editable mode and the custom script is available. Note that you don’t need to set `--app`.\n\n``` python\n$ pip install -e .\n$ wiki run\n```\n\nErrors in Custom Scripts\n\nWhen using a custom script, if you introduce an error in your module-level code, the reloader will fail because it can no longer load the entry point.\n\nThe `flask` command, being separate from your code, does not have this issue and is recommended in most cases.\n\n## PyCharm Integration\n\nPyCharm Professional provides a special Flask run configuration to run the development server. For the Community Edition, and for other commands besides `run`, you need to create a custom run configuration. These instructions should be similar for any other IDE you use.\n\nIn PyCharm, with your project open, click on *Run* from the menu bar and go to *Edit Configurations*. You’ll see a screen similar to this:\n\nOnce you create a configuration for the `flask run`, you can copy and change it to call any other command.\n\nClick the *+ (Add New Configuration)* button and select *Python*. Give the configuration a name such as “flask run”.\n\nClick the *Script path* dropdown and change it to *Module name*, then input `flask`.\n\nThe *Parameters* field is set to the CLI command to execute along with any arguments. This example uses `--app hello run --debug`, which will run the development server in debug mode. `--app hello` should be the import or file with your Flask app.\n\nIf you installed your project as a package in your virtualenv, you may uncheck the *PYTHONPATH* options. This will more accurately match how you deploy later.\n\nClick *OK* to save and close the configuration. Select the configuration in the main PyCharm window and click the play button next to it to run the server.\n\nNow that you have a configuration for `flask run`, you can copy that configuration and change the *Parameters* argument to run a different CLI command.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/cli/](https://flask.palletsprojects.com/en/3.0.x/cli/)"
- name: Config
  id: api/index#flask.Config
  summary: Works exactly like a dict but provides ways to fill it from files or special dictionaries
  description: |-
    `class flask.Config(root_path, defaults=None)`

    Works exactly like a dict but provides ways to fill it from files or special dictionaries. There are two common patterns to populate the config.

    Either you can fill the config from a config file:

    ``` python
    app.config.from_pyfile('yourconfig.cfg')
    ```

    Or alternatively you can define the configuration options in the module that calls [`from_object()`](#flask.Config.from_object "flask.Config.from_object") or provide an import path to a module that should be loaded. It is also possible to tell it to use the same module and with that provide the configuration values just before the call:

    ``` python
    DEBUG = True
    SECRET_KEY = 'development key'
    app.config.from_object(__name__)
    ```

    In both cases (loading from any Python file or loading from modules), only uppercase keys are added to the config. This makes it possible to use lowercase values in the config file for temporary values that are not added to the config or to define the config keys in the same file that implements the application.

    Probably the most interesting way to load configurations is from an environment variable pointing to a file:

    ``` python
    app.config.from_envvar('YOURAPPLICATION_SETTINGS')
    ```

    In this case before launching the application you have to set this environment variable to the file you want to use. On Linux and OS X use the export statement:

    ``` python
    export YOURAPPLICATION_SETTINGS='/path/to/config/file'
    ```

    On windows use `set` instead.

    Parameters:

    - **root_path** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [os.PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)")) – path to which files are read relative from. When the config object is created by the application, this is the application’s [`root_path`](#flask.Flask.root_path "flask.Flask.root_path").
    - **defaults** ([dict](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)") *\|* *None*) – an optional dictionary of default values
- name: Config.from_envvar()
  id: api/index#flask.Config.from_envvar
  summary: Loads a configuration from an environment variable pointing to a configuration file
  description: |-
    `from_envvar(variable_name, silent=False)`

    Loads a configuration from an environment variable pointing to a configuration file. This is basically just a shortcut with nicer error messages for this line of code:

    ``` python
    app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])
    ```

    Parameters:

    - **variable_name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – name of the environment variable
    - **silent** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – set to `True` if you want silent failure for missing files.

    Returns:

    `True` if the file was loaded successfully.

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: Config.from_file()
  id: api/index#flask.Config.from_file
  summary: Update the values in the config from a file that is loaded using the load parameter
  description: |-
    `from_file(filename, load, silent=False, text=True)`

    Update the values in the config from a file that is loaded using the `load` parameter. The loaded data is passed to the [`from_mapping()`](#flask.Config.from_mapping "flask.Config.from_mapping") method.

    ``` python
    import json
    app.config.from_file("config.json", load=json.load)

    import tomllib
    app.config.from_file("config.toml", load=tomllib.load, text=False)
    ```

    Parameters:

    - **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)")) – The path to the data file. This can be an absolute path or relative to the config root path.
    - **load** (`Callable[[Reader], Mapping]` where `Reader` implements a `read` method.) – A callable that takes a file handle and returns a mapping of loaded data from the file.
    - **silent** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Ignore the file if it doesn’t exist.
    - **text** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Open the file in text or binary mode.

    Returns:

    `True` if the file was loaded successfully.

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")

    Changelog

    Changed in version 2.3: The `text` parameter was added.

    New in version 2.0.
- name: Config.from_mapping()
  id: api/index#flask.Config.from_mapping
  summary: Updates the config like update() ignoring items with non-upper keys
  description: |-
    `from_mapping(mapping=None, **kwargs)`

    Updates the config like `update()` ignoring items with non-upper keys.

    Returns:

    Always returns `True`.

    Parameters:

    - **mapping** ([Mapping](https://docs.python.org/3/library/typing.html#typing.Mapping "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]* *\|* *None*) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")

    Changelog

    New in version 0.11.
- name: Config.from_object()
  id: api/index#flask.Config.from_object
  summary: Updates the values from the given object
  description: |-
    `from_object(obj)`

    Updates the values from the given object. An object can be of one of the following two types:

    - a string: in this case the object with that name will be imported
    - an actual object reference: that object is used directly

    Objects are usually either modules or classes. [`from_object()`](#flask.Config.from_object "flask.Config.from_object") loads only the uppercase attributes of the module/class. A `dict` object will not work with [`from_object()`](#flask.Config.from_object "flask.Config.from_object") because the keys of a `dict` are not attributes of the `dict` class.

    Example of module-based configuration:

    ``` python
    app.config.from_object('yourapplication.default_config')
    from yourapplication import default_config
    app.config.from_object(default_config)
    ```

    Nothing is done to the object before loading. If the object is a class and has `@property` attributes, it needs to be instantiated before being passed to this method.

    You should not use this function to load the actual configuration but rather configuration defaults. The actual config should be loaded with [`from_pyfile()`](#flask.Config.from_pyfile "flask.Config.from_pyfile") and ideally from a location not within the package because the package might be installed system wide.

    See [Development / Production](../config/index#config-dev-prod) for an example of class-based configuration using [`from_object()`](#flask.Config.from_object "flask.Config.from_object").

    Parameters:

    **obj** ([object](https://docs.python.org/3/library/functions.html#object "(in Python v3.11)") *\|* [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – an import name or object

    Return type:

    None
- name: Config.from_prefixed_env()
  id: api/index#flask.Config.from_prefixed_env
  summary: Load any environment variables that start with FLASK_, dropping the prefix from the env key for the config key
  description: |-
    `from_prefixed_env(prefix='FLASK', *, loads=<function loads>)`

    Load any environment variables that start with `FLASK_`, dropping the prefix from the env key for the config key. Values are passed through a loading function to attempt to convert them to more specific types than strings.

    Keys are loaded in [`sorted()`](https://docs.python.org/3/library/functions.html#sorted "(in Python v3.11)") order.

    The default loading function attempts to parse values as any valid JSON type, including dicts and lists.

    Specific items in nested dicts can be set by separating the keys with double underscores (`__`). If an intermediate key doesn’t exist, it will be initialized to an empty dict.

    Parameters:

    - **prefix** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – Load env vars that start with this prefix, separated with an underscore (`_`).
    - **loads** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\],* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]*) – Pass each string value to this function and use the returned value as the config value. If any error is raised it is ignored and the value remains a string. The default is [`json.loads()`](#flask.json.loads "flask.json.loads").

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")

    Changelog

    New in version 2.1.
- name: Config.from_pyfile()
  id: api/index#flask.Config.from_pyfile
  summary: Updates the values in the config from a Python file
  description: |-
    `from_pyfile(filename, silent=False)`

    Updates the values in the config from a Python file. This function behaves as if the file was imported as module with the [`from_object()`](#flask.Config.from_object "flask.Config.from_object") function.

    Parameters:

    - **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)")) – the filename of the config. This can either be an absolute filename or a filename relative to the root path.
    - **silent** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – set to `True` if you want silent failure for missing files.

    Returns:

    `True` if the file was loaded successfully.

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")

    Changelog

    New in version 0.7: `silent` parameter.
- name: Config.get_namespace()
  id: api/index#flask.Config.get_namespace
  summary: Returns a dictionary containing a subset of configuration options that match the specified namespace/prefix
  description: |-
    `get_namespace(namespace, lowercase=True, trim_namespace=True)`

    Returns a dictionary containing a subset of configuration options that match the specified namespace/prefix. Example usage:

    ``` python
    app.config['IMAGE_STORE_TYPE'] = 'fs'
    app.config['IMAGE_STORE_PATH'] = '/var/app/images'
    app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'
    image_store_config = app.config.get_namespace('IMAGE_STORE_')
    ```

    The resulting dictionary `image_store_config` would look like:

    ``` python
    {
        'type': 'fs',
        'path': '/var/app/images',
        'base_url': 'http://img.website.com'
    }
    ```

    This is often useful when configuration options map directly to keyword arguments in functions or class constructors.

    Parameters:

    - **namespace** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – a configuration namespace
    - **lowercase** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – a flag indicating if the keys of the resulting dictionary should be lowercase
    - **trim_namespace** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – a flag indicating if the keys of the resulting dictionary should not include the namespace

    Return type:

    [dict](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")\]

    Changelog

    New in version 0.11.

    ## Stream Helpers
- name: Configuration Handling
  id: config/index
  summary: Applications need some kind of configuration
  description: "# Configuration Handling\n\nApplications need some kind of configuration. There are different settings you might want to change depending on the application environment like toggling the debug mode, setting the secret key, and other such environment-specific things.\n\nThe way Flask is designed usually requires the configuration to be available when the application starts up. You can hard code the configuration in the code, which for many small applications is not actually that bad, but there are better ways.\n\nIndependent of how you load your config, there is a config object available which holds the loaded configuration values: The [`config`](../api/index#flask.Flask.config \"flask.Flask.config\") attribute of the [`Flask`](../api/index#flask.Flask \"flask.Flask\") object. This is the place where Flask itself puts certain configuration values and also where extensions can put their configuration values. But this is also where you can have your own configuration.\n\n## Configuration Basics\n\nThe [`config`](../api/index#flask.Flask.config \"flask.Flask.config\") is actually a subclass of a dictionary and can be modified just like any dictionary:\n\n``` python\napp = Flask(__name__)\napp.config['TESTING'] = True\n```\n\nCertain configuration values are also forwarded to the [`Flask`](../api/index#flask.Flask \"flask.Flask\") object so you can read and write them from there:\n\n``` python\napp.testing = True\n```\n\nTo update multiple keys at once you can use the [`dict.update()`](https://docs.python.org/3/library/stdtypes.html#dict.update \"(in Python v3.11)\") method:\n\n``` python\napp.config.update(\n    TESTING=True,\n    SECRET_KEY='192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'\n)\n```\n\n## Debug Mode\n\nThe [`DEBUG`](#DEBUG \"DEBUG\") config value is special because it may behave inconsistently if changed after the app has begun setting up. In order to set debug mode reliably, use the `--debug` option on the `flask` or `flask run` command. `flask run` will use the interactive debugger and reloader by default in debug mode.\n\n``` text\n$ flask --app hello run --debug\n```\n\nUsing the option is recommended. While it is possible to set [`DEBUG`](#DEBUG \"DEBUG\") in your config or code, this is strongly discouraged. It can’t be read early by the `flask run` command, and some systems or extensions may have already configured themselves based on a previous value.\n\n## Builtin Configuration Values\n\nThe following configuration values are used internally by Flask:\n\n`DEBUG`  \nWhether debug mode is enabled. When using `flask run` to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. The [`debug`](../api/index#flask.Flask.debug \"flask.Flask.debug\") attribute maps to this config key. This is set with the `FLASK_DEBUG` environment variable. It may not behave as expected if set in code.\n\n**Do not enable debug mode when deploying in production.**\n\nDefault: `False`\n\n`TESTING`  \nEnable testing mode. Exceptions are propagated rather than handled by the the app’s error handlers. Extensions may also change their behavior to facilitate easier testing. You should enable this in your own tests.\n\nDefault: `False`\n\n&nbsp;\n\n`PROPAGATE_EXCEPTIONS`  \nExceptions are re-raised rather than being handled by the app’s error handlers. If not set, this is implicitly true if `TESTING` or `DEBUG` is enabled.\n\nDefault: `None`\n\n&nbsp;\n\n`TRAP_HTTP_EXCEPTIONS`  \nIf there is no handler for an `HTTPException`-type exception, re-raise it to be handled by the interactive debugger instead of returning it as a simple error response.\n\nDefault: `False`\n\n&nbsp;\n\n`TRAP_BAD_REQUEST_ERRORS`  \nTrying to access a key that doesn’t exist from request dicts like `args` and `form` will return a 400 Bad Request error page. Enable this to treat the error as an unhandled exception instead so that you get the interactive debugger. This is a more specific version of `TRAP_HTTP_EXCEPTIONS`. If unset, it is enabled in debug mode.\n\nDefault: `None`\n\n&nbsp;\n\n`SECRET_KEY`  \nA secret key that will be used for securely signing the session cookie and can be used for any other security related needs by extensions or your application. It should be a long random `bytes` or `str`. For example, copy the output of this to your config:\n\n``` python\n$ python -c 'import secrets; print(secrets.token_hex())'\n'192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'\n```\n\n**Do not reveal the secret key when posting questions or committing code.**\n\nDefault: `None`\n\n&nbsp;\n\n`SESSION_COOKIE_NAME`  \nThe name of the session cookie. Can be changed in case you already have a cookie with the same name.\n\nDefault: `'session'`\n\n&nbsp;\n\n`SESSION_COOKIE_DOMAIN`  \nThe value of the `Domain` parameter on the session cookie. If not set, browsers will only send the cookie to the exact domain it was set from. Otherwise, they will send it to any subdomain of the given value as well.\n\nNot setting this value is more restricted and secure than setting it.\n\nDefault: `None`\n\nChangelog\n\nChanged in version 2.3: Not set by default, does not fall back to `SERVER_NAME`.\n\n&nbsp;\n\n`SESSION_COOKIE_PATH`  \nThe path that the session cookie will be valid for. If not set, the cookie will be valid underneath `APPLICATION_ROOT` or `/` if that is not set.\n\nDefault: `None`\n\n&nbsp;\n\n`SESSION_COOKIE_HTTPONLY`  \nBrowsers will not allow JavaScript access to cookies marked as “HTTP only” for security.\n\nDefault: `True`\n\n&nbsp;\n\n`SESSION_COOKIE_SECURE`  \nBrowsers will only send cookies with requests over HTTPS if the cookie is marked “secure”. The application must be served over HTTPS for this to make sense.\n\nDefault: `False`\n\n&nbsp;\n\n`SESSION_COOKIE_SAMESITE`  \nRestrict how cookies are sent with requests from external sites. Can be set to `'Lax'` (recommended) or `'Strict'`. See [Set-Cookie options](../security/index#security-cookie).\n\nDefault: `None`\n\nChangelog\n\nNew in version 1.0.\n\n&nbsp;\n\n`PERMANENT_SESSION_LIFETIME`  \nIf `session.permanent` is true, the cookie’s expiration will be set this number of seconds in the future. Can either be a [`datetime.timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta \"(in Python v3.11)\") or an `int`.\n\nFlask’s default cookie implementation validates that the cryptographic signature is not older than this value.\n\nDefault: `timedelta(days=31)` (`2678400` seconds)\n\n&nbsp;\n\n`SESSION_REFRESH_EACH_REQUEST`  \nControl whether the cookie is sent with every response when `session.permanent` is true. Sending the cookie every time (the default) can more reliably keep the session from expiring, but uses more bandwidth. Non-permanent sessions are not affected.\n\nDefault: `True`\n\n&nbsp;\n\n`USE_X_SENDFILE`  \nWhen serving files, set the `X-Sendfile` header instead of serving the data with Flask. Some web servers, such as Apache, recognize this and serve the data more efficiently. This only makes sense when using such a server.\n\nDefault: `False`\n\n&nbsp;\n\n`SEND_FILE_MAX_AGE_DEFAULT`  \nWhen serving files, set the cache control max age to this number of seconds. Can be a [`datetime.timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta \"(in Python v3.11)\") or an `int`. Override this value on a per-file basis using [`get_send_file_max_age()`](../api/index#flask.Flask.get_send_file_max_age \"flask.Flask.get_send_file_max_age\") on the application or blueprint.\n\nIf `None`, `send_file` tells the browser to use conditional requests will be used instead of a timed cache, which is usually preferable.\n\nDefault: `None`\n\n&nbsp;\n\n`SERVER_NAME`  \nInform the application what host and port it is bound to. Required for subdomain route matching support.\n\nIf set, `url_for` can generate external URLs with only an application context instead of a request context.\n\nDefault: `None`\n\nChangelog\n\nChanged in version 2.3: Does not affect `SESSION_COOKIE_DOMAIN`.\n\n&nbsp;\n\n`APPLICATION_ROOT`  \nInform the application what path it is mounted under by the application / web server. This is used for generating URLs outside the context of a request (inside a request, the dispatcher is responsible for setting `SCRIPT_NAME` instead; see [Application Dispatching](../patterns/appdispatch/index) for examples of dispatch configuration).\n\nWill be used for the session cookie path if `SESSION_COOKIE_PATH` is not set.\n\nDefault: `'/'`\n\n&nbsp;\n\n`PREFERRED_URL_SCHEME`  \nUse this scheme for generating external URLs when not in a request context.\n\nDefault: `'http'`\n\n&nbsp;\n\n`MAX_CONTENT_LENGTH`  \nDon’t read more than this many bytes from the incoming request data. If not set and the request does not specify a `CONTENT_LENGTH`, no data will be read for security.\n\nDefault: `None`\n\n&nbsp;\n\n`TEMPLATES_AUTO_RELOAD`  \nReload templates when they are changed. If not set, it will be enabled in debug mode.\n\nDefault: `None`\n\n&nbsp;\n\n`EXPLAIN_TEMPLATE_LOADING`  \nLog debugging information tracing how a template file was loaded. This can be useful to figure out why a template was not loaded or the wrong file appears to be loaded.\n\nDefault: `False`\n\n&nbsp;\n\n`MAX_COOKIE_SIZE`  \nWarn if cookie headers are larger than this many bytes. Defaults to `4093`. Larger cookies may be silently ignored by browsers. Set to `0` to disable the warning.\n\nChangelog\n\nChanged in version 2.3: `JSON_AS_ASCII`, `JSON_SORT_KEYS`, `JSONIFY_MIMETYPE`, and `JSONIFY_PRETTYPRINT_REGULAR` were removed. The default `app.json` provider has equivalent attributes instead.\n\nChanged in version 2.3: `ENV` was removed.\n\nChanged in version 2.2: Removed `PRESERVE_CONTEXT_ON_EXCEPTION`.\n\nChanged in version 1.0: `LOGGER_NAME` and `LOGGER_HANDLER_POLICY` were removed. See [Logging](../logging/index) for information about configuration.\n\nAdded `ENV` to reflect the `FLASK_ENV` environment variable.\n\nAdded [`SESSION_COOKIE_SAMESITE`](#SESSION_COOKIE_SAMESITE \"SESSION_COOKIE_SAMESITE\") to control the session cookie’s `SameSite` option.\n\nAdded [`MAX_COOKIE_SIZE`](#MAX_COOKIE_SIZE \"MAX_COOKIE_SIZE\") to control a warning from Werkzeug.\n\nNew in version 0.11: `SESSION_REFRESH_EACH_REQUEST`, `TEMPLATES_AUTO_RELOAD`, `LOGGER_HANDLER_POLICY`, `EXPLAIN_TEMPLATE_LOADING`\n\nNew in version 0.10: `JSON_AS_ASCII`, `JSON_SORT_KEYS`, `JSONIFY_PRETTYPRINT_REGULAR`\n\nNew in version 0.9: `PREFERRED_URL_SCHEME`\n\nNew in version 0.8: `TRAP_BAD_REQUEST_ERRORS`, `TRAP_HTTP_EXCEPTIONS`, `APPLICATION_ROOT`, `SESSION_COOKIE_DOMAIN`, `SESSION_COOKIE_PATH`, `SESSION_COOKIE_HTTPONLY`, `SESSION_COOKIE_SECURE`\n\nNew in version 0.7: `PROPAGATE_EXCEPTIONS`, `PRESERVE_CONTEXT_ON_EXCEPTION`\n\nNew in version 0.6: `MAX_CONTENT_LENGTH`\n\nNew in version 0.5: `SERVER_NAME`\n\nNew in version 0.4: `LOGGER_NAME`\n\n## Configuring from Python Files\n\nConfiguration becomes more useful if you can store it in a separate file, ideally located outside the actual application package. You can deploy your application, then separately configure it for the specific deployment.\n\nA common pattern is this:\n\n``` python\napp = Flask(__name__)\napp.config.from_object('yourapplication.default_settings')\napp.config.from_envvar('YOURAPPLICATION_SETTINGS')\n```\n\nThis first loads the configuration from the `yourapplication.default_settings` module and then overrides the values with the contents of the file the `YOURAPPLICATION_SETTINGS` environment variable points to. This environment variable can be set in the shell before starting the server:\n\n``` text\n$ export YOURAPPLICATION_SETTINGS=/path/to/settings.cfg\n$ flask run\n * Running on http://127.0.0.1:5000/\n```\n\n``` text\n$ set -x YOURAPPLICATION_SETTINGS /path/to/settings.cfg\n$ flask run\n * Running on http://127.0.0.1:5000/\n```\n\n``` text\n> set YOURAPPLICATION_SETTINGS=\\path\\to\\settings.cfg\n> flask run\n * Running on http://127.0.0.1:5000/\n```\n\n``` text\n> $env:YOURAPPLICATION_SETTINGS = \"\\path\\to\\settings.cfg\"\n> flask run\n * Running on http://127.0.0.1:5000/\n```\n\nThe configuration files themselves are actual Python files. Only values in uppercase are actually stored in the config object later on. So make sure to use uppercase letters for your config keys.\n\nHere is an example of a configuration file:\n\n``` python\n# Example configuration\nSECRET_KEY = '192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'\n```\n\nMake sure to load the configuration very early on, so that extensions have the ability to access the configuration when starting up. There are other methods on the config object as well to load from individual files. For a complete reference, read the [`Config`](../api/index#flask.Config \"flask.Config\") object’s documentation.\n\n## Configuring from Data Files\n\nIt is also possible to load configuration from a file in a format of your choice using [`from_file()`](../api/index#flask.Config.from_file \"flask.Config.from_file\"). For example to load from a TOML file:\n\n``` python\nimport tomllib\napp.config.from_file(\"config.toml\", load=tomllib.load, text=False)\n```\n\nOr from a JSON file:\n\n``` python\nimport json\napp.config.from_file(\"config.json\", load=json.load)\n```\n\n## Configuring from Environment Variables\n\nIn addition to pointing to configuration files using environment variables, you may find it useful (or necessary) to control your configuration values directly from the environment. Flask can be instructed to load all environment variables starting with a specific prefix into the config using [`from_prefixed_env()`](../api/index#flask.Config.from_prefixed_env \"flask.Config.from_prefixed_env\").\n\nEnvironment variables can be set in the shell before starting the server:\n\n``` text\n$ export FLASK_SECRET_KEY=\"5f352379324c22463451387a0aec5d2f\"\n$ export FLASK_MAIL_ENABLED=false\n$ flask run\n * Running on http://127.0.0.1:5000/\n```\n\n``` text\n$ set -x FLASK_SECRET_KEY \"5f352379324c22463451387a0aec5d2f\"\n$ set -x FLASK_MAIL_ENABLED false\n$ flask run\n * Running on http://127.0.0.1:5000/\n```\n\n``` text\n> set FLASK_SECRET_KEY=\"5f352379324c22463451387a0aec5d2f\"\n> set FLASK_MAIL_ENABLED=false\n> flask run\n * Running on http://127.0.0.1:5000/\n```\n\n``` text\n> $env:FLASK_SECRET_KEY = \"5f352379324c22463451387a0aec5d2f\"\n> $env:FLASK_MAIL_ENABLED = \"false\"\n> flask run\n * Running on http://127.0.0.1:5000/\n```\n\nThe variables can then be loaded and accessed via the config with a key equal to the environment variable name without the prefix i.e.\n\n``` python\napp.config.from_prefixed_env()\napp.config[\"SECRET_KEY\"]  # Is \"5f352379324c22463451387a0aec5d2f\"\n```\n\nThe prefix is `FLASK_` by default. This is configurable via the `prefix` argument of [`from_prefixed_env()`](../api/index#flask.Config.from_prefixed_env \"flask.Config.from_prefixed_env\").\n\nValues will be parsed to attempt to convert them to a more specific type than strings. By default [`json.loads()`](https://docs.python.org/3/library/json.html#json.loads \"(in Python v3.11)\") is used, so any valid JSON value is possible, including lists and dicts. This is configurable via the `loads` argument of [`from_prefixed_env()`](../api/index#flask.Config.from_prefixed_env \"flask.Config.from_prefixed_env\").\n\nWhen adding a boolean value with the default JSON parsing, only “true” and “false”, lowercase, are valid values. Keep in mind that any non-empty string is considered `True` by Python.\n\nIt is possible to set keys in nested dictionaries by separating the keys with double underscore (`__`). Any intermediate keys that don’t exist on the parent dict will be initialized to an empty dict.\n\n``` text\n$ export FLASK_MYAPI__credentials__username=user123\n```\n\n``` python\napp.config[\"MYAPI\"][\"credentials\"][\"username\"]  # Is \"user123\"\n```\n\nOn Windows, environment variable keys are always uppercase, therefore the above example would end up as `MYAPI__CREDENTIALS__USERNAME`.\n\nFor even more config loading features, including merging and case-insensitive Windows support, try a dedicated library such as [Dynaconf](https://www.dynaconf.com/), which includes integration with Flask.\n\n## Configuration Best Practices\n\nThe downside with the approach mentioned earlier is that it makes testing a little harder. There is no single 100% solution for this problem in general, but there are a couple of things you can keep in mind to improve that experience:\n\n1.  Create your application in a function and register blueprints on it. That way you can create multiple instances of your application with different configurations attached which makes unit testing a lot easier. You can use this to pass in configuration as needed.\n2.  Do not write code that needs the configuration at import time. If you limit yourself to request-only accesses to the configuration you can reconfigure the object later on as needed.\n3.  Make sure to load the configuration very early on, so that extensions can access the configuration when calling `init_app`.\n\n## Development / Production\n\nMost applications need more than one configuration. There should be at least separate configurations for the production server and the one used during development. The easiest way to handle this is to use a default configuration that is always loaded and part of the version control, and a separate configuration that overrides the values as necessary as mentioned in the example above:\n\n``` python\napp = Flask(__name__)\napp.config.from_object('yourapplication.default_settings')\napp.config.from_envvar('YOURAPPLICATION_SETTINGS')\n```\n\nThen you just have to add a separate `config.py` file and export `YOURAPPLICATION_SETTINGS=/path/to/config.py` and you are done. However there are alternative ways as well. For example you could use imports or subclassing.\n\nWhat is very popular in the Django world is to make the import explicit in the config file by adding `from yourapplication.default_settings import *` to the top of the file and then overriding the changes by hand. You could also inspect an environment variable like `YOURAPPLICATION_MODE` and set that to `production`, `development` etc and import different hard-coded files based on that.\n\nAn interesting pattern is also to use classes and inheritance for configuration:\n\n``` python\nclass Config(object):\n    TESTING = False\n\nclass ProductionConfig(Config):\n    DATABASE_URI = 'mysql://user@localhost/foo'\n\nclass DevelopmentConfig(Config):\n    DATABASE_URI = \"sqlite:////tmp/foo.db\"\n\nclass TestingConfig(Config):\n    DATABASE_URI = 'sqlite:///:memory:'\n    TESTING = True\n```\n\nTo enable such a config you just have to call into [`from_object()`](../api/index#flask.Config.from_object \"flask.Config.from_object\"):\n\n``` python\napp.config.from_object('configmodule.ProductionConfig')\n```\n\nNote that [`from_object()`](../api/index#flask.Config.from_object \"flask.Config.from_object\") does not instantiate the class object. If you need to instantiate the class, such as to access a property, then you must do so before calling [`from_object()`](../api/index#flask.Config.from_object \"flask.Config.from_object\"):\n\n``` python\nfrom configmodule import ProductionConfig\napp.config.from_object(ProductionConfig())\n\n# Alternatively, import via string:\nfrom werkzeug.utils import import_string\ncfg = import_string('configmodule.ProductionConfig')()\napp.config.from_object(cfg)\n```\n\nInstantiating the configuration object allows you to use `@property` in your configuration classes:\n\n``` python\nclass Config(object):\n    \"\"\"Base config, uses staging database server.\"\"\"\n    TESTING = False\n    DB_SERVER = '192.168.1.56'\n\n    @property\n    def DATABASE_URI(self):  # Note: all caps\n        return f\"mysql://user@{self.DB_SERVER}/foo\"\n\nclass ProductionConfig(Config):\n    \"\"\"Uses production database server.\"\"\"\n    DB_SERVER = '192.168.19.32'\n\nclass DevelopmentConfig(Config):\n    DB_SERVER = 'localhost'\n\nclass TestingConfig(Config):\n    DB_SERVER = 'localhost'\n    DATABASE_URI = 'sqlite:///:memory:'\n```\n\nThere are many different ways and it’s up to you how you want to manage your configuration files. However here a list of good recommendations:\n\n- Keep a default configuration in version control. Either populate the config with this default configuration or import it in your own configuration files before overriding values.\n- Use an environment variable to switch between the configurations. This can be done from outside the Python interpreter and makes development and deployment much easier because you can quickly and easily switch between different configs without having to touch the code at all. If you are working often on different projects you can even create your own script for sourcing that activates a virtualenv and exports the development configuration for you.\n- Use a tool like [fabric](https://www.fabfile.org/) to push code and configuration separately to the production server(s).\n\n## Instance Folders\n\nChangelog\n\nNew in version 0.8.\n\nFlask 0.8 introduces instance folders. Flask for a long time made it possible to refer to paths relative to the application’s folder directly (via `Flask.root_path`). This was also how many developers loaded configurations stored next to the application. Unfortunately however this only works well if applications are not packages in which case the root path refers to the contents of the package.\n\nWith Flask 0.8 a new attribute was introduced: `Flask.instance_path`. It refers to a new concept called the “instance folder”. The instance folder is designed to not be under version control and be deployment specific. It’s the perfect place to drop things that either change at runtime or configuration files.\n\nYou can either explicitly provide the path of the instance folder when creating the Flask application or you can let Flask autodetect the instance folder. For explicit configuration use the `instance_path` parameter:\n\n``` python\napp = Flask(__name__, instance_path='/path/to/instance/folder')\n```\n\nPlease keep in mind that this path *must* be absolute when provided.\n\nIf the `instance_path` parameter is not provided the following default locations are used:\n\n- Uninstalled module:\n\n  ``` python\n  /myapp.py\n  /instance\n  ```\n\n- Uninstalled package:\n\n  ``` python\n  /myapp\n      /__init__.py\n  /instance\n  ```\n\n- Installed module or package:\n\n  ``` python\n  $PREFIX/lib/pythonX.Y/site-packages/myapp\n  $PREFIX/var/myapp-instance\n  ```\n\n  `$PREFIX` is the prefix of your Python installation. This can be `/usr` or the path to your virtualenv. You can print the value of `sys.prefix` to see what the prefix is set to.\n\nSince the config object provided loading of configuration files from relative filenames we made it possible to change the loading via filenames to be relative to the instance path if wanted. The behavior of relative paths in config files can be flipped between “relative to the application root” (the default) to “relative to instance folder” via the `instance_relative_config` switch to the application constructor:\n\n``` python\napp = Flask(__name__, instance_relative_config=True)\n```\n\nHere is a full example of how to configure Flask to preload the config from a module and then override the config from a file in the instance folder if it exists:\n\n``` python\napp = Flask(__name__, instance_relative_config=True)\napp.config.from_object('yourapplication.default_settings')\napp.config.from_pyfile('application.cfg', silent=True)\n```\n\nThe path to the instance folder can be found via the `Flask.instance_path`. Flask also provides a shortcut to open a file from the instance folder with `Flask.open_instance_resource()`.\n\nExample usage for both:\n\n``` python\nfilename = os.path.join(app.instance_path, 'application.cfg')\nwith open(filename) as f:\n    config = f.read()\n\n# or via open_instance_resource:\nwith app.open_instance_resource('application.cfg') as f:\n    config = f.read()\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/config/](https://flask.palletsprojects.com/en/3.0.x/config/)"
- name: copy_current_request_context()
  id: api/index#flask.copy_current_request_context
  summary: A helper function that decorates a function to retain the current request context
  description: |-
    `flask.copy_current_request_context(f)`

    A helper function that decorates a function to retain the current request context. This is useful when working with greenlets. The moment the function is decorated a copy of the request context is created and then pushed when the function is called. The current session is also included in the copied request context.

    Example:

    ``` python
    import gevent
    from flask import copy_current_request_context

    @app.route('/')
    def index():
        @copy_current_request_context
        def do_some_work():
            # do some work here, it can access flask.request or
            # flask.session like you would otherwise in the view function.
            ...
        gevent.spawn(do_some_work)
        return 'Regular response'
    ```

    Changelog

    New in version 0.10.

    Parameters:

    **f** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")
- name: DEBUG
  id: config/index#DEBUG
  summary: Whether debug mode is enabled
  belongs_to: Configuration Handling
  description: |-
    `DEBUG`

    Whether debug mode is enabled. When using `flask run` to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. The [`debug`](../api/index#flask.Flask.debug "flask.Flask.debug") attribute maps to this config key. This is set with the `FLASK_DEBUG` environment variable. It may not behave as expected if set in code.

    **Do not enable debug mode when deploying in production.**

    Default: `False`
- name: Debugging Application Errors
  id: debugging/index
  summary: Do not run the development server, or enable the built-in debugger, in a production environment
  description: "# Debugging Application Errors\n\n## In Production\n\n**Do not run the development server, or enable the built-in debugger, in a production environment.** The debugger allows executing arbitrary Python code from the browser. It’s protected by a pin, but that should not be relied on for security.\n\nUse an error logging tool, such as Sentry, as described in [Error Logging Tools](../errorhandling/index#error-logging-tools), or enable logging and notifications as described in [Logging](../logging/index).\n\nIf you have access to the server, you could add some code to start an external debugger if `request.remote_addr` matches your IP. Some IDE debuggers also have a remote mode so breakpoints on the server can be interacted with locally. Only enable a debugger temporarily.\n\n## The Built-In Debugger\n\nThe built-in Werkzeug development server provides a debugger which shows an interactive traceback in the browser when an unhandled error occurs during a request. This debugger should only be used during development.\n\nWarning\n\nThe debugger allows executing arbitrary Python code from the browser. It is protected by a pin, but still represents a major security risk. Do not run the development server or debugger in a production environment.\n\nThe debugger is enabled by default when the development server is run in debug mode.\n\n``` text\n$ flask --app hello run --debug\n```\n\nWhen running from Python code, passing `debug=True` enables debug mode, which is mostly equivalent.\n\n``` python\napp.run(debug=True)\n```\n\n[Development Server](../server/index) and [Command Line Interface](../cli/index) have more information about running the debugger and debug mode. More information about the debugger can be found in the [Werkzeug documentation](https://werkzeug.palletsprojects.com/debug/).\n\n## External Debuggers\n\nExternal debuggers, such as those provided by IDEs, can offer a more powerful debugging experience than the built-in debugger. They can also be used to step through code during a request before an error is raised, or if no error is raised. Some even have a remote mode so you can debug code running on another machine.\n\nWhen using an external debugger, the app should still be in debug mode, otherwise Flask turns unhandled errors into generic 500 error pages. However, the built-in debugger and reloader should be disabled so they don’t interfere with the external debugger.\n\n``` text\n$ flask --app hello run --debug --no-debugger --no-reload\n```\n\nWhen running from Python:\n\n``` python\napp.run(debug=True, use_debugger=False, use_reloader=False)\n```\n\nDisabling these isn’t required, an external debugger will continue to work with the following caveats.\n\n- If the built-in debugger is not disabled, it will catch unhandled exceptions before the external debugger can.\n\n- If the reloader is not disabled, it could cause an unexpected reload if code changes during a breakpoint.\n\n- The development server will still catch unhandled exceptions if the built-in debugger is disabled, otherwise it would crash on any error. If you want that (and usually you don’t) pass `passthrough_errors=True` to `app.run`.\n\n  ``` python\n  app.run(\n      debug=True, passthrough_errors=True,\n      use_debugger=False, use_reloader=False\n  )\n  ```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/debugging/](https://flask.palletsprojects.com/en/3.0.x/debugging/)"
- name: DefaultJSONProvider
  id: api/index#flask.json.provider.DefaultJSONProvider
  summary: Provide JSON operations using Python’s built-in json library
  description: |-
    `class flask.json.provider.DefaultJSONProvider(app)`

    Provide JSON operations using Python’s built-in [`json`](https://docs.python.org/3/library/json.html#module-json "(in Python v3.11)") library. Serializes the following additional data types:

    - [`datetime.datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime "(in Python v3.11)") and [`datetime.date`](https://docs.python.org/3/library/datetime.html#datetime.date "(in Python v3.11)") are serialized to [**RFC 822**](https://datatracker.ietf.org/doc/html/rfc822.html) strings. This is the same as the HTTP date format.
    - [`uuid.UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID "(in Python v3.11)") is serialized to a string.
    - `dataclasses.dataclass` is passed to [`dataclasses.asdict()`](https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict "(in Python v3.11)").
    - `Markup` (or any object with a `__html__` method) will call the `__html__` method to get a string.

    Parameters:

    **app** (*App*) –
- name: DefaultJSONProvider.compact
  id: api/index#flask.json.provider.DefaultJSONProvider.compact
  summary: If True, or None out of debug mode, the response() output will not add indentation, newlines, or spaces
  description: |-
    `compact: bool | None = None`

    If `True`, or `None` out of debug mode, the [`response()`](#flask.json.provider.DefaultJSONProvider.response "flask.json.provider.DefaultJSONProvider.response") output will not add indentation, newlines, or spaces. If `False`, or `None` in debug mode, it will use a non-compact representation.
- name: DefaultJSONProvider.default()
  id: api/index#flask.json.provider.DefaultJSONProvider.default
  summary: Apply this function to any object that json.dumps() does not know how to serialize
  description: |-
    `static default(o)`

    Apply this function to any object that `json.dumps()` does not know how to serialize. It should return a valid JSON type or raise a `TypeError`.

    Parameters:

    **o** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: DefaultJSONProvider.dumps()
  id: api/index#flask.json.provider.DefaultJSONProvider.dumps
  summary: Serialize data as JSON to a string
  description: |-
    `dumps(obj, **kwargs)`

    Serialize data as JSON to a string.

    Keyword arguments are passed to [`json.dumps()`](https://docs.python.org/3/library/json.html#json.dumps "(in Python v3.11)"). Sets some parameter defaults from the [`default`](#flask.json.provider.DefaultJSONProvider.default "flask.json.provider.DefaultJSONProvider.default"), [`ensure_ascii`](#flask.json.provider.DefaultJSONProvider.ensure_ascii "flask.json.provider.DefaultJSONProvider.ensure_ascii"), and [`sort_keys`](#flask.json.provider.DefaultJSONProvider.sort_keys "flask.json.provider.DefaultJSONProvider.sort_keys") attributes.

    Parameters:

    - **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – The data to serialize.
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – Passed to [`json.dumps()`](https://docs.python.org/3/library/json.html#json.dumps "(in Python v3.11)").

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: DefaultJSONProvider.ensure_ascii
  id: api/index#flask.json.provider.DefaultJSONProvider.ensure_ascii
  summary: Replace non-ASCII characters with escape sequences
  description: |-
    `ensure_ascii = True`

    Replace non-ASCII characters with escape sequences. This may be more compatible with some clients, but can be disabled for better performance and size.
- name: DefaultJSONProvider.loads()
  id: api/index#flask.json.provider.DefaultJSONProvider.loads
  summary: Deserialize data as JSON from a string or bytes
  description: |-
    `loads(s, **kwargs)`

    Deserialize data as JSON from a string or bytes.

    Parameters:

    - **s** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.11)")) – Text or UTF-8 bytes.
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – Passed to [`json.loads()`](https://docs.python.org/3/library/json.html#json.loads "(in Python v3.11)").

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: DefaultJSONProvider.mimetype
  id: api/index#flask.json.provider.DefaultJSONProvider.mimetype
  summary: The mimetype set in response()
  description: |-
    `mimetype = 'application/json'`

    The mimetype set in [`response()`](#flask.json.provider.DefaultJSONProvider.response "flask.json.provider.DefaultJSONProvider.response").
- name: DefaultJSONProvider.response()
  id: api/index#flask.json.provider.DefaultJSONProvider.response
  summary: Serialize the given arguments as JSON, and return a Response object with it
  description: |-
    `response(*args, **kwargs)`

    Serialize the given arguments as JSON, and return a [`Response`](#flask.Response "flask.Response") object with it. The response mimetype will be “application/json” and can be changed with [`mimetype`](#flask.json.provider.DefaultJSONProvider.mimetype "flask.json.provider.DefaultJSONProvider.mimetype").

    If [`compact`](#flask.json.provider.DefaultJSONProvider.compact "flask.json.provider.DefaultJSONProvider.compact") is `False` or debug mode is enabled, the output will be formatted to be easier to read.

    Either positional or keyword arguments can be given, not both. If no arguments are given, `None` is serialized.

    Parameters:

    - **args** (*t.Any*) – A single value to serialize, or multiple values to treat as a list to serialize.
    - **kwargs** (*t.Any*) – Treat as a dict to serialize.

    Return type:

    [Response](#flask.Response "flask.Response")

    ### Tagged JSON

    A compact representation for lossless serialization of non-standard JSON types. [`SecureCookieSessionInterface`](#flask.sessions.SecureCookieSessionInterface "flask.sessions.SecureCookieSessionInterface") uses this to serialize the session data, but it may be useful in other places. It can be extended to support other types.
- name: DefaultJSONProvider.sort_keys
  id: api/index#flask.json.provider.DefaultJSONProvider.sort_keys
  summary: Sort the keys in any serialized dicts
  description: |-
    `sort_keys = True`

    Sort the keys in any serialized dicts. This may be useful for some caching situations, but can be disabled for better performance. When enabled, keys must all be strings, they are not converted before sorting.
- name: Deferred Request Callbacks
  id: patterns/deferredcallbacks/index
  summary: One of the design principles of Flask is that response objects are created and passed down a chain of potential callbacks that can modify them or replace them
  description: "# Deferred Request Callbacks\n\nOne of the design principles of Flask is that response objects are created and passed down a chain of potential callbacks that can modify them or replace them. When the request handling starts, there is no response object yet. It is created as necessary either by a view function or by some other component in the system.\n\nWhat happens if you want to modify the response at a point where the response does not exist yet? A common example for that would be a [`before_request()`](../../api/index#flask.Flask.before_request \"flask.Flask.before_request\") callback that wants to set a cookie on the response object.\n\nOne way is to avoid the situation. Very often that is possible. For instance you can try to move that logic into a [`after_request()`](../../api/index#flask.Flask.after_request \"flask.Flask.after_request\") callback instead. However, sometimes moving code there makes it more complicated or awkward to reason about.\n\nAs an alternative, you can use [`after_this_request()`](../../api/index#flask.after_this_request \"flask.after_this_request\") to register callbacks that will execute after only the current request. This way you can defer code execution from anywhere in the application, based on the current request.\n\nAt any time during a request, we can register a function to be called at the end of the request. For example you can remember the current language of the user in a cookie in a [`before_request()`](../../api/index#flask.Flask.before_request \"flask.Flask.before_request\") callback:\n\n``` python\nfrom flask import request, after_this_request\n\n@app.before_request\ndef detect_user_language():\n    language = request.cookies.get('user_lang')\n\n    if language is None:\n        language = guess_language_from_request()\n\n        # when the response exists, set a cookie with the language\n        @after_this_request\n        def remember_language(response):\n            response.set_cookie('user_lang', language)\n            return response\n\n    g.language = language\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/deferredcallbacks/](https://flask.palletsprojects.com/en/3.0.x/patterns/deferredcallbacks/)"
- name: Deploying to Production
  id: deploying/index
  summary: After developing your application, you’ll want to make it available publicly to other users
  description: "# Deploying to Production\n\nAfter developing your application, you’ll want to make it available publicly to other users. When you’re developing locally, you’re probably using the built-in development server, debugger, and reloader. These should not be used in production. Instead, you should use a dedicated WSGI server or hosting platform, some of which will be described here.\n\n“Production” means “not development”, which applies whether you’re serving your application publicly to millions of users or privately / locally to a single user. **Do not use the development server when deploying to production. It is intended for use only during local development. It is not designed to be particularly secure, stable, or efficient.**\n\n## Self-Hosted Options\n\nFlask is a WSGI *application*. A WSGI *server* is used to run the application, converting incoming HTTP requests to the standard WSGI environ, and converting outgoing WSGI responses to HTTP responses.\n\nThe primary goal of these docs is to familiarize you with the concepts involved in running a WSGI application using a production WSGI server and HTTP server. There are many WSGI servers and HTTP servers, with many configuration possibilities. The pages below discuss the most common servers, and show the basics of running each one. The next section discusses platforms that can manage this for you.\n\n- [Gunicorn](gunicorn/index)\n- [Waitress](waitress/index)\n- [mod_wsgi](mod_wsgi/index)\n- [uWSGI](uwsgi/index)\n- [gevent](gevent/index)\n- [eventlet](eventlet/index)\n- [ASGI](asgi/index)\n\nWSGI servers have HTTP servers built-in. However, a dedicated HTTP server may be safer, more efficient, or more capable. Putting an HTTP server in front of the WSGI server is called a “reverse proxy.”\n\n- [Tell Flask it is Behind a Proxy](proxy_fix/index)\n- [nginx](nginx/index)\n- [Apache httpd](apache-httpd/index)\n\nThis list is not exhaustive, and you should evaluate these and other servers based on your application’s needs. Different servers will have different capabilities, configuration, and support.\n\n## Hosting Platforms\n\nThere are many services available for hosting web applications without needing to maintain your own server, networking, domain, etc. Some services may have a free tier up to a certain time or bandwidth. Many of these services use one of the WSGI servers described above, or a similar interface. The links below are for some of the most common platforms, which have instructions for Flask, WSGI, or Python.\n\n- [PythonAnywhere](https://help.pythonanywhere.com/pages/Flask/)\n- [Google App Engine](https://cloud.google.com/appengine/docs/standard/python3/building-app)\n- [Google Cloud Run](https://cloud.google.com/run/docs/quickstarts/build-and-deploy/deploy-python-service)\n- [AWS Elastic Beanstalk](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create-deploy-python-flask.html)\n- [Microsoft Azure](https://docs.microsoft.com/en-us/azure/app-service/quickstart-python)\n\nThis list is not exhaustive, and you should evaluate these and other services based on your application’s needs. Different services will have different capabilities, configuration, pricing, and support.\n\nYou’ll probably need to [Tell Flask it is Behind a Proxy](proxy_fix/index) when using most hosting platforms.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/deploying/](https://flask.palletsprojects.com/en/3.0.x/deploying/)"
- name: Design Decisions in Flask
  id: design/index
  summary: If you are curious why Flask does certain things the way it does and not differently, this section is for you
  description: "# Design Decisions in Flask\n\nIf you are curious why Flask does certain things the way it does and not differently, this section is for you. This should give you an idea about some of the design decisions that may appear arbitrary and surprising at first, especially in direct comparison with other frameworks.\n\n## The Explicit Application Object\n\nA Python web application based on WSGI has to have one central callable object that implements the actual application. In Flask this is an instance of the [`Flask`](../api/index#flask.Flask \"flask.Flask\") class. Each Flask application has to create an instance of this class itself and pass it the name of the module, but why can’t Flask do that itself?\n\nWithout such an explicit application object the following code:\n\n``` python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return 'Hello World!'\n```\n\nWould look like this instead:\n\n``` python\nfrom hypothetical_flask import route\n\n@route('/')\ndef index():\n    return 'Hello World!'\n```\n\nThere are three major reasons for this. The most important one is that implicit application objects require that there may only be one instance at the time. There are ways to fake multiple applications with a single application object, like maintaining a stack of applications, but this causes some problems I won’t outline here in detail. Now the question is: when does a microframework need more than one application at the same time? A good example for this is unit testing. When you want to test something it can be very helpful to create a minimal application to test specific behavior. When the application object is deleted everything it allocated will be freed again.\n\nAnother thing that becomes possible when you have an explicit object lying around in your code is that you can subclass the base class ([`Flask`](../api/index#flask.Flask \"flask.Flask\")) to alter specific behavior. This would not be possible without hacks if the object were created ahead of time for you based on a class that is not exposed to you.\n\nBut there is another very important reason why Flask depends on an explicit instantiation of that class: the package name. Whenever you create a Flask instance you usually pass it `__name__` as package name. Flask depends on that information to properly load resources relative to your module. With Python’s outstanding support for reflection it can then access the package to figure out where the templates and static files are stored (see [`open_resource()`](../api/index#flask.Flask.open_resource \"flask.Flask.open_resource\")). Now obviously there are frameworks around that do not need any configuration and will still be able to load templates relative to your application module. But they have to use the current working directory for that, which is a very unreliable way to determine where the application is. The current working directory is process-wide and if you are running multiple applications in one process (which could happen in a webserver without you knowing) the paths will be off. Worse: many webservers do not set the working directory to the directory of your application but to the document root which does not have to be the same folder.\n\nThe third reason is “explicit is better than implicit”. That object is your WSGI application, you don’t have to remember anything else. If you want to apply a WSGI middleware, just wrap it and you’re done (though there are better ways to do that so that you do not lose the reference to the application object [`wsgi_app()`](../api/index#flask.Flask.wsgi_app \"flask.Flask.wsgi_app\")).\n\nFurthermore this design makes it possible to use a factory function to create the application which is very helpful for unit testing and similar things ([Application Factories](../patterns/appfactories/index)).\n\n## The Routing System\n\nFlask uses the Werkzeug routing system which was designed to automatically order routes by complexity. This means that you can declare routes in arbitrary order and they will still work as expected. This is a requirement if you want to properly implement decorator based routing since decorators could be fired in undefined order when the application is split into multiple modules.\n\nAnother design decision with the Werkzeug routing system is that routes in Werkzeug try to ensure that URLs are unique. Werkzeug will go quite far with that in that it will automatically redirect to a canonical URL if a route is ambiguous.\n\n## One Template Engine\n\nFlask decides on one template engine: Jinja2. Why doesn’t Flask have a pluggable template engine interface? You can obviously use a different template engine, but Flask will still configure Jinja2 for you. While that limitation that Jinja2 is *always* configured will probably go away, the decision to bundle one template engine and use that will not.\n\nTemplate engines are like programming languages and each of those engines has a certain understanding about how things work. On the surface they all work the same: you tell the engine to evaluate a template with a set of variables and take the return value as string.\n\nBut that’s about where similarities end. Jinja2 for example has an extensive filter system, a certain way to do template inheritance, support for reusable blocks (macros) that can be used from inside templates and also from Python code, supports iterative template rendering, configurable syntax and more. On the other hand an engine like Genshi is based on XML stream evaluation, template inheritance by taking the availability of XPath into account and more. Mako on the other hand treats templates similar to Python modules.\n\nWhen it comes to connecting a template engine with an application or framework there is more than just rendering templates. For instance, Flask uses Jinja2’s extensive autoescaping support. Also it provides ways to access macros from Jinja2 templates.\n\nA template abstraction layer that would not take the unique features of the template engines away is a science on its own and a too large undertaking for a microframework like Flask.\n\nFurthermore extensions can then easily depend on one template language being present. You can easily use your own templating language, but an extension could still depend on Jinja itself.\n\n## What does “micro” mean?\n\n“Micro” does not mean that your whole web application has to fit into a single Python file (although it certainly can), nor does it mean that Flask is lacking in functionality. The “micro” in microframework means Flask aims to keep the core simple but extensible. Flask won’t make many decisions for you, such as what database to use. Those decisions that it does make, such as what templating engine to use, are easy to change. Everything else is up to you, so that Flask can be everything you need and nothing you don’t.\n\nBy default, Flask does not include a database abstraction layer, form validation or anything else where different libraries already exist that can handle that. Instead, Flask supports extensions to add such functionality to your application as if it was implemented in Flask itself. Numerous extensions provide database integration, form validation, upload handling, various open authentication technologies, and more. Flask may be “micro”, but it’s ready for production use on a variety of needs.\n\nWhy does Flask call itself a microframework and yet it depends on two libraries (namely Werkzeug and Jinja2). Why shouldn’t it? If we look over to the Ruby side of web development there we have a protocol very similar to WSGI. Just that it’s called Rack there, but besides that it looks very much like a WSGI rendition for Ruby. But nearly all applications in Ruby land do not work with Rack directly, but on top of a library with the same name. This Rack library has two equivalents in Python: WebOb (formerly Paste) and Werkzeug. Paste is still around but from my understanding it’s sort of deprecated in favour of WebOb. The development of WebOb and Werkzeug started side by side with similar ideas in mind: be a good implementation of WSGI for other applications to take advantage.\n\nFlask is a framework that takes advantage of the work already done by Werkzeug to properly interface WSGI (which can be a complex task at times). Thanks to recent developments in the Python package infrastructure, packages with dependencies are no longer an issue and there are very few reasons against having libraries that depend on others.\n\n## Thread Locals\n\nFlask uses thread local objects (context local objects in fact, they support greenlet contexts as well) for request, session and an extra object you can put your own things on ([`g`](../api/index#flask.g \"flask.g\")). Why is that and isn’t that a bad idea?\n\nYes it is usually not such a bright idea to use thread locals. They cause troubles for servers that are not based on the concept of threads and make large applications harder to maintain. However Flask is just not designed for large applications or asynchronous servers. Flask wants to make it quick and easy to write a traditional web application.\n\n## Async/await and ASGI support\n\nFlask supports `async` coroutines for view functions by executing the coroutine on a separate thread instead of using an event loop on the main thread as an async-first (ASGI) framework would. This is necessary for Flask to remain backwards compatible with extensions and code built before `async` was introduced into Python. This compromise introduces a performance cost compared with the ASGI frameworks, due to the overhead of the threads.\n\nDue to how tied to WSGI Flask’s code is, it’s not clear if it’s possible to make the `Flask` class support ASGI and WSGI at the same time. Work is currently being done in Werkzeug to work with ASGI, which may eventually enable support in Flask as well.\n\nSee [Using async and await](../async-await/index) for more discussion.\n\n## What Flask is, What Flask is Not\n\nFlask will never have a database layer. It will not have a form library or anything else in that direction. Flask itself just bridges to Werkzeug to implement a proper WSGI application and to Jinja2 to handle templating. It also binds to a few common standard library packages such as logging. Everything else is up for extensions.\n\nWhy is this the case? Because people have different preferences and requirements and Flask could not meet those if it would force any of this into the core. The majority of web applications will need a template engine in some sort. However not every application needs a SQL database.\n\nAs your codebase grows, you are free to make the design decisions appropriate for your project. Flask will continue to provide a very simple glue layer to the best that Python has to offer. You can implement advanced patterns in SQLAlchemy or another database tool, introduce non-relational data persistence as appropriate, and take advantage of framework-agnostic tools built for WSGI, the Python web interface.\n\nThe idea of Flask is to build a good foundation for all applications. Everything else is up to you or extensions.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/design/](https://flask.palletsprojects.com/en/3.0.x/design/)"
- name: Development Server
  id: server/index
  summary: Flask provides a run command to run the application with a development server
  description: "# Development Server\n\nFlask provides a `run` command to run the application with a development server. In debug mode, this server provides an interactive debugger and will reload when code is changed.\n\nWarning\n\nDo not use the development server when deploying to production. It is intended for use only during local development. It is not designed to be particularly efficient, stable, or secure.\n\nSee [Deploying to Production](../deploying/index) for deployment options.\n\n## Command Line\n\nThe `flask run` CLI command is the recommended way to run the development server. Use the `--app` option to point to your application, and the `--debug` option to enable debug mode.\n\n``` text\n$ flask --app hello run --debug\n```\n\nThis enables debug mode, including the interactive debugger and reloader, and then starts the server on [http://localhost:5000/](http://localhost:5000/). Use `flask run --help` to see the available options, and [Command Line Interface](../cli/index) for detailed instructions about configuring and using the CLI.\n\n### Address already in use\n\nIf another program is already using port 5000, you’ll see an `OSError` when the server tries to start. It may have one of the following messages:\n\n- `OSError: [Errno 98] Address already in use`\n- `OSError: [WinError 10013] An attempt was made to access a socket in a way forbidden by its access permissions`\n\nEither identify and stop the other program, or use `flask run --port 5001` to pick a different port.\n\nYou can use `netstat` or `lsof` to identify what process id is using a port, then use other operating system tools stop that process. The following example shows that process id 6847 is using port 5000.\n\n``` text\n$ netstat -nlp | grep 5000\ntcp 0 0 127.0.0.1:5000 0.0.0.0:* LISTEN 6847/python\n```\n\n``` text\n$ lsof -P -i :5000\nPython 6847 IPv4 TCP localhost:5000 (LISTEN)\n```\n\n``` text\n> netstat -ano | findstr 5000\nTCP 127.0.0.1:5000 0.0.0.0:0 LISTENING 6847\n```\n\nmacOS Monterey and later automatically starts a service that uses port 5000. To disable the service, go to System Preferences, Sharing, and disable “AirPlay Receiver”.\n\n### Deferred Errors on Reload\n\nWhen using the `flask run` command with the reloader, the server will continue to run even if you introduce syntax errors or other initialization errors into the code. Accessing the site will show the interactive debugger for the error, rather than crashing the server.\n\nIf a syntax error is already present when calling `flask run`, it will fail immediately and show the traceback rather than waiting until the site is accessed. This is intended to make errors more visible initially while still allowing the server to handle errors on reload.\n\n## In Code\n\nThe development server can also be started from Python with the [`Flask.run()`](../api/index#flask.Flask.run \"flask.Flask.run\") method. This method takes arguments similar to the CLI options to control the server. The main difference from the CLI command is that the server will crash if there are errors when reloading. `debug=True` can be passed to enable debug mode.\n\nPlace the call in a main block, otherwise it will interfere when trying to import and run the application with a production server later.\n\n``` python\nif __name__ == \"__main__\":\n    app.run(debug=True)\n```\n\n``` text\n$ python hello.py\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/server/](https://flask.palletsprojects.com/en/3.0.x/server/)"
- name: dump()
  id: api/index#flask.json.dump
  summary: Serialize data as JSON and write to a file
  description: |-
    `flask.json.dump(obj, fp, **kwargs)`

    Serialize data as JSON and write to a file.

    If [`current_app`](#flask.current_app "flask.current_app") is available, it will use its [`app.json.dump()`](#flask.json.provider.JSONProvider.dump "flask.json.provider.JSONProvider.dump") method, otherwise it will use [`json.dump()`](https://docs.python.org/3/library/json.html#json.dump "(in Python v3.11)").

    Parameters:

    - **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – The data to serialize.
    - **fp** ([IO](https://docs.python.org/3/library/typing.html#typing.IO "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]*) – A file opened for writing text. Should use the UTF-8 encoding to be valid JSON.
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – Arguments passed to the `dump` implementation.

    Return type:

    None

    Changelog

    Changed in version 2.3: The `app` parameter was removed.

    Changed in version 2.2: Calls `current_app.json.dump`, allowing an app to override the behavior.

    Changed in version 2.0: Writing to a binary file, and the `encoding` argument, will be removed in Flask 2.1.
- name: dumps()
  id: api/index#flask.json.dumps
  summary: Serialize data as JSON
  description: |-
    `flask.json.dumps(obj, **kwargs)`

    Serialize data as JSON.

    If [`current_app`](#flask.current_app "flask.current_app") is available, it will use its [`app.json.dumps()`](#flask.json.provider.JSONProvider.dumps "flask.json.provider.JSONProvider.dumps") method, otherwise it will use [`json.dumps()`](https://docs.python.org/3/library/json.html#json.dumps "(in Python v3.11)").

    Parameters:

    - **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – The data to serialize.
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – Arguments passed to the `dumps` implementation.

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")

    Changelog

    Changed in version 2.3: The `app` parameter was removed.

    Changed in version 2.2: Calls `current_app.json.dumps`, allowing an app to override the behavior.

    Changed in version 2.0.2: [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal "(in Python v3.11)") is supported by converting to a string.

    Changed in version 2.0: `encoding` will be removed in Flask 2.1.

    Changed in version 1.0.3: `app` can be passed directly, rather than requiring an app context for configuration.
- name: eventlet
  id: deploying/eventlet/index
  summary: Prefer using Gunicorn with eventlet workers rather than using eventlet directly
  description: "# eventlet\n\nPrefer using [Gunicorn](../gunicorn/index) with eventlet workers rather than using [eventlet](https://eventlet.net/) directly. Gunicorn provides a much more configurable and production-tested server.\n\n[eventlet](https://eventlet.net/) allows writing asynchronous, coroutine-based code that looks like standard synchronous Python. It uses [greenlet](https://greenlet.readthedocs.io/en/latest/) to enable task switching without writing `async/await` or using `asyncio`.\n\n[gevent](../gevent/index) is another library that does the same thing. Certain dependencies you have, or other considerations, may affect which of the two you choose to use.\n\neventlet provides a WSGI server that can handle many connections at once instead of one per worker process. You must actually use eventlet in your own code to see any benefit to using the server.\n\n## Installing\n\nWhen using eventlet, greenlet\\>=1.0 is required, otherwise context locals such as `request` will not work as expected. When using PyPy, PyPy\\>=7.3.7 is required.\n\nCreate a virtualenv, install your application, then install `eventlet`.\n\n``` text\n$ cd hello-app\n$ python -m venv .venv\n$ . .venv/bin/activate\n$ pip install .  # install your application\n$ pip install eventlet\n```\n\n## Running\n\nTo use eventlet to serve your application, write a script that imports its `wsgi.server`, as well as your app or app factory.\n\n`wsgi.py`\n\n``` python\nimport eventlet\nfrom eventlet import wsgi\nfrom hello import create_app\n\napp = create_app()\nwsgi.server(eventlet.listen((\"127.0.0.1\", 8000)), app)\n```\n\n``` text\n$ python wsgi.py\n(x) wsgi starting up on http://127.0.0.1:8000\n```\n\n## Binding Externally\n\neventlet should not be run as root because it would cause your application code to run as root, which is not secure. However, this means it will not be possible to bind to port 80 or 443. Instead, a reverse proxy such as [nginx](../nginx/index) or [Apache httpd](../apache-httpd/index) should be used in front of eventlet.\n\nYou can bind to all external IPs on a non-privileged port by using `0.0.0.0` in the server arguments shown in the previous section. Don’t do this when using a reverse proxy setup, otherwise it will be possible to bypass the proxy.\n\n`0.0.0.0` is not a valid address to navigate to, you’d use a specific IP address in your browser.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/deploying/eventlet/](https://flask.palletsprojects.com/en/3.0.x/deploying/eventlet/)"
- name: EXPLAIN_TEMPLATE_LOADING
  id: config/index#EXPLAIN_TEMPLATE_LOADING
  summary: Log debugging information tracing how a template file was loaded
  belongs_to: Configuration Handling
  description: |-
    `EXPLAIN_TEMPLATE_LOADING`

    Log debugging information tracing how a template file was loaded. This can be useful to figure out why a template was not loaded or the wrong file appears to be loaded.

    Default: `False`
- name: Extensions
  id: extensions/index
  summary: Extensions are extra packages that add functionality to a Flask application
  description: "# Extensions\n\nExtensions are extra packages that add functionality to a Flask application. For example, an extension might add support for sending email or connecting to a database. Some extensions add entire new frameworks to help build certain types of applications, like a REST API.\n\n## Finding Extensions\n\nFlask extensions are usually named “Flask-Foo” or “Foo-Flask”. You can search PyPI for packages tagged with [Framework :: Flask](https://pypi.org/search/?c=Framework+%3A%3A+Flask).\n\n## Using Extensions\n\nConsult each extension’s documentation for installation, configuration, and usage instructions. Generally, extensions pull their own configuration from [`app.config`](../api/index#flask.Flask.config \"flask.Flask.config\") and are passed an application instance during initialization. For example, an extension called “Flask-Foo” might be used like this:\n\n``` python\nfrom flask_foo import Foo\n\nfoo = Foo()\n\napp = Flask(__name__)\napp.config.update(\n    FOO_BAR='baz',\n    FOO_SPAM='eggs',\n)\n\nfoo.init_app(app)\n```\n\n## Building Extensions\n\nWhile [PyPI](https://pypi.org/search/?c=Framework+%3A%3A+Flask) contains many Flask extensions, you may not find an extension that fits your need. If this is the case, you can create your own, and publish it for others to use as well. Read [Flask Extension Development](https://flask.palletsprojects.com/en/3.0.x/extensiondev/) to develop your own Flask extension.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/extensions/](https://flask.palletsprojects.com/en/3.0.x/extensions/)"
- name: flash()
  id: api/index#flask.flash
  summary: Flashes a message to the next request
  description: |-
    `flask.flash(message, category='message')`

    Flashes a message to the next request. In order to remove the flashed message from the session and to display it to the user, the template has to call [`get_flashed_messages()`](#flask.get_flashed_messages "flask.get_flashed_messages").

    Changelog

    Changed in version 0.3: `category` parameter added.

    Parameters:

    - **message** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – the message to be flashed.
    - **category** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – the category for the message. The following values are recommended: `'message'` for any kind of message, `'error'` for errors, `'info'` for information messages and `'warning'` for warnings. However any kind of string can be used as category.

    Return type:

    None
- name: Flask
  id: api/index#flask.Flask
  summary: The flask object implements a WSGI application and acts as the central object
  description: |-
    `class flask.Flask(import_name, static_url_path=None, static_folder='static', static_host=None, host_matching=False, subdomain_matching=False, template_folder='templates', instance_path=None, instance_relative_config=False, root_path=None)`

    The flask object implements a WSGI application and acts as the central object. It is passed the name of the module or package of the application. Once it is created it will act as a central registry for the view functions, the URL rules, template configuration and much more.

    The name of the package is used to resolve resources from inside the package or the folder the module is contained in depending on if the package parameter resolves to an actual python package (a folder with an `__init__.py` file inside) or a standard module (just a `.py` file).

    For more information about resource loading, see [`open_resource()`](#flask.Flask.open_resource "flask.Flask.open_resource").

    Usually you create a [`Flask`](#flask.Flask "flask.Flask") instance in your main module or in the `__init__.py` file of your package like this:

    ``` python
    from flask import Flask
    app = Flask(__name__)
    ```

    About the First Parameter

    The idea of the first parameter is to give Flask an idea of what belongs to your application. This name is used to find resources on the filesystem, can be used by extensions to improve debugging information and a lot more.

    So it’s important what you provide there. If you are using a single module, `__name__` is always the correct value. If you however are using a package, it’s usually recommended to hardcode the name of your package there.

    For example if your application is defined in `yourapplication/app.py` you should create it with one of the two versions below:

    ``` python
    app = Flask('yourapplication')
    app = Flask(__name__.split('.')[0])
    ```

    Why is that? The application will work even with `__name__`, thanks to how resources are looked up. However it will make debugging more painful. Certain extensions can make assumptions based on the import name of your application. For example the Flask-SQLAlchemy extension will look for the code in your application that triggered an SQL query in debug mode. If the import name is not properly set up, that debugging information is lost. (For example it would only pick up SQL queries in `yourapplication.app` and not `yourapplication.views.frontend`)

    Changelog

    New in version 1.0: The `host_matching` and `static_host` parameters were added.

    New in version 1.0: The `subdomain_matching` parameter was added. Subdomain matching needs to be enabled manually now. Setting [`SERVER_NAME`](../config/index#SERVER_NAME "SERVER_NAME") does not implicitly enable it.

    New in version 0.11: The `root_path` parameter was added.

    New in version 0.8: The `instance_path` and `instance_relative_config` parameters were added.

    New in version 0.7: The `static_url_path`, `static_folder`, and `template_folder` parameters were added.

    Parameters:

    - **import_name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – the name of the application package
    - **static_url_path** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – can be used to specify a different path for the static files on the web. Defaults to the name of the `static_folder` folder.
    - **static_folder** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [os.PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)") *\|* *None*) – The folder with static files that is served at `static_url_path`. Relative to the application `root_path` or an absolute path. Defaults to `'static'`.
    - **static_host** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the host to use when adding the static route. Defaults to None. Required when using `host_matching=True` with a `static_folder` configured.
    - **host_matching** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – set `url_map.host_matching` attribute. Defaults to False.
    - **subdomain_matching** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – consider the subdomain relative to [`SERVER_NAME`](../config/index#SERVER_NAME "SERVER_NAME") when matching routes. Defaults to False.
    - **template_folder** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [os.PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)") *\|* *None*) – the folder that contains the templates that should be used by the application. Defaults to `'templates'` folder in the root path of the application.
    - **instance_path** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – An alternative instance path for the application. By default the folder `'instance'` next to the package or module is assumed to be the instance path.
    - **instance_relative_config** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – if set to `True` relative filenames for loading the config are assumed to be relative to the instance path instead of the application root.
    - **root_path** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – The path to the root of the application files. This should only be set manually when it can’t be detected automatically, such as for namespace packages.
- name: Flask.aborter
  id: api/index#flask.Flask.aborter
  summary: An instance of aborter_class created by make_aborter()
  description: |-
    `aborter`

    An instance of [`aborter_class`](#flask.Flask.aborter_class "flask.Flask.aborter_class") created by [`make_aborter()`](#flask.Flask.make_aborter "flask.Flask.make_aborter"). This is called by [`flask.abort()`](#flask.abort "flask.abort") to raise HTTP errors, and can be called directly as well.

    Changelog

    New in version 2.2: Moved from `flask.abort`, which calls this object.
- name: Flask.aborter_class
  id: api/index#flask.Flask.aborter_class
  summary: null
  description: |-
    `aborter_class`

    alias of [`Aborter`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.Aborter "(in Werkzeug v2.3.x)")
- name: Flask.add_template_filter()
  id: api/index#flask.Flask.add_template_filter
  summary: Register a custom template filter
  description: |-
    `add_template_filter(f, name=None)`

    Register a custom template filter. Works exactly like the [`template_filter()`](#flask.Flask.template_filter "flask.Flask.template_filter") decorator.

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the optional name of the filter, otherwise the function name will be used.
    - **f** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[...\],* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]*) –

    Return type:

    None
- name: Flask.add_template_global()
  id: api/index#flask.Flask.add_template_global
  summary: Register a custom template global function
  description: |-
    `add_template_global(f, name=None)`

    Register a custom template global function. Works exactly like the [`template_global()`](#flask.Flask.template_global "flask.Flask.template_global") decorator.

    Changelog

    New in version 0.10.

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the optional name of the global function, otherwise the function name will be used.
    - **f** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[...\],* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]*) –

    Return type:

    None
- name: Flask.add_template_test()
  id: api/index#flask.Flask.add_template_test
  summary: Register a custom template test
  description: |-
    `add_template_test(f, name=None)`

    Register a custom template test. Works exactly like the [`template_test()`](#flask.Flask.template_test "flask.Flask.template_test") decorator.

    Changelog

    New in version 0.10.

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the optional name of the test, otherwise the function name will be used.
    - **f** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[...\],* [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")*\]*) –

    Return type:

    None
- name: Flask.add_url_rule()
  id: api/index#flask.Flask.add_url_rule
  summary: Register a rule for routing incoming requests and building URLs
  description: |-
    `add_url_rule(rule, endpoint=None, view_func=None, provide_automatic_options=None, **options)`

    Register a rule for routing incoming requests and building URLs. The [`route()`](#flask.Flask.route "flask.Flask.route") decorator is a shortcut to call this with the `view_func` argument. These are equivalent:

    ``` python
    @app.route("/")
    def index():
        ...
    ```

    ``` python
    def index():
        ...

    app.add_url_rule("/", view_func=index)
    ```

    See [URL Route Registrations](#url-route-registrations).

    The endpoint name for the route defaults to the name of the view function if the `endpoint` parameter isn’t passed. An error will be raised if a function has already been registered for the endpoint.

    The `methods` parameter defaults to `["GET"]`. `HEAD` is always added automatically, and `OPTIONS` is added automatically by default.

    `view_func` does not necessarily need to be passed, but if the rule should participate in routing an endpoint name must be associated with a view function at some point with the [`endpoint()`](#flask.Flask.endpoint "flask.Flask.endpoint") decorator.

    ``` python
    app.add_url_rule("/", endpoint="index")

    @app.endpoint("index")
    def index():
        ...
    ```

    If `view_func` has a `required_methods` attribute, those methods are added to the passed and automatic methods. If it has a `provide_automatic_methods` attribute, it is used as the default if the parameter is not passed.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The URL rule string.
    - **endpoint** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – The endpoint name to associate with the rule and view function. Used when routing and building URLs. Defaults to `view_func.__name__`.
    - **view_func** (*ft.RouteCallable* *\|* *None*) – The view function to associate with the endpoint name.
    - **provide_automatic_options** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)") *\|* *None*) – Add the `OPTIONS` method and respond to `OPTIONS` requests automatically.
    - **options** (*t.Any*) – Extra options passed to the [`Rule`](https://werkzeug.palletsprojects.com/en/2.3.x/routing/#werkzeug.routing.Rule "(in Werkzeug v2.3.x)") object.

    Return type:

    None
- name: Flask.after_request()
  id: api/index#flask.Flask.after_request
  summary: Register a function to run after each request to this object
  description: |-
    `after_request(f)`

    Register a function to run after each request to this object.

    The function is called with the response object, and must return a response object. This allows the functions to modify or replace the response before it is sent.

    If a function raises an exception, any remaining `after_request` functions will not be called. Therefore, this should not be used for actions that must execute, such as to close resources. Use [`teardown_request()`](#flask.Flask.teardown_request "flask.Flask.teardown_request") for that.

    This is available on both app and blueprint objects. When used on an app, this executes after every request. When used on a blueprint, this executes after every request that the blueprint handles. To register with a blueprint and execute after every request, use [`Blueprint.after_app_request()`](#flask.Blueprint.after_app_request "flask.Blueprint.after_app_request").

    Parameters:

    **f** (*T_after_request*) –

    Return type:

    *T_after_request*
- name: Flask.after_request_funcs
  id: api/index#flask.Flask.after_request_funcs
  summary: 'A data structure of functions to call at the end of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests'
  description: |-
    `after_request_funcs: dict[ft.AppOrBlueprintKey, list[ft.AfterRequestCallable]]`

    A data structure of functions to call at the end of each request, in the format `{scope: [functions]}`. The `scope` key is the name of a blueprint the functions are active for, or `None` for all requests.

    To register a function, use the [`after_request()`](#flask.Flask.after_request "flask.Flask.after_request") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Flask.app_context()
  id: api/index#flask.Flask.app_context
  summary: Create an AppContext
  description: |-
    `app_context()`

    Create an [`AppContext`](#flask.ctx.AppContext "flask.ctx.AppContext"). Use as a `with` block to push the context, which will make [`current_app`](#flask.current_app "flask.current_app") point at this application.

    An application context is automatically pushed by `RequestContext.push()` when handling a request, and when running a CLI command. Use this to manually create a context outside of these situations.

    ``` python
    with app.app_context():
        init_db()
    ```

    See [The Application Context](../appcontext/index).

    Changelog

    New in version 0.9.

    Return type:

    [AppContext](#flask.ctx.AppContext "flask.ctx.AppContext")
- name: Flask.app_ctx_globals_class
  id: api/index#flask.Flask.app_ctx_globals_class
  summary: null
  description: |-
    `app_ctx_globals_class`

    alias of [`_AppCtxGlobals`](#flask.ctx._AppCtxGlobals "flask.ctx._AppCtxGlobals")
- name: flask.appcontext_popped
  id: api/index#flask.appcontext_popped
  summary: This signal is sent when an application context is popped
  description: |-
    `flask.appcontext_popped`

    This signal is sent when an application context is popped. The sender is the application. This usually falls in line with the [`appcontext_tearing_down`](#flask.appcontext_tearing_down "flask.appcontext_tearing_down") signal.

    Changelog

    New in version 0.10.
- name: flask.appcontext_pushed
  id: api/index#flask.appcontext_pushed
  summary: This signal is sent when an application context is pushed
  description: |-
    `flask.appcontext_pushed`

    This signal is sent when an application context is pushed. The sender is the application. This is usually useful for unittests in order to temporarily hook in information. For instance it can be used to set a resource early onto the `g` object.

    Example usage:

    ``` python
    from contextlib import contextmanager
    from flask import appcontext_pushed

    @contextmanager
    def user_set(app, user):
        def handler(sender, **kwargs):
            g.user = user
        with appcontext_pushed.connected_to(handler, app):
            yield
    ```

    And in the testcode:

    ``` python
    def test_user_me(self):
        with user_set(app, 'john'):
            c = app.test_client()
            resp = c.get('/users/me')
            assert resp.data == 'username=john'
    ```

    Changelog

    New in version 0.10.
- name: flask.appcontext_tearing_down
  id: api/index#flask.appcontext_tearing_down
  summary: This signal is sent when the app context is tearing down
  description: |-
    `flask.appcontext_tearing_down`

    This signal is sent when the app context is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on.

    Example subscriber:

    ``` python
    def close_db_connection(sender, **extra):
        session.close()

    from flask import appcontext_tearing_down
    appcontext_tearing_down.connect(close_db_connection, app)
    ```

    This will also be passed an `exc` keyword argument that has a reference to the exception that caused the teardown if there was one.
- name: Flask.async_to_sync()
  id: api/index#flask.Flask.async_to_sync
  summary: Return a sync function that will run the coroutine function
  description: |-
    `async_to_sync(func)`

    Return a sync function that will run the coroutine function.

    ``` python
    result = app.async_to_sync(func)(*args, **kwargs)
    ```

    Override this method to change how the app converts async code to be synchronously callable.

    Changelog

    New in version 2.0.

    Parameters:

    **func** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[...\],* [Coroutine](https://docs.python.org/3/library/typing.html#typing.Coroutine "(in Python v3.11)")*\]*) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[…\], [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")\]
- name: Flask.auto_find_instance_path()
  id: api/index#flask.Flask.auto_find_instance_path
  summary: Tries to locate the instance path if it was not provided to the constructor of the application class
  description: |-
    `auto_find_instance_path()`

    Tries to locate the instance path if it was not provided to the constructor of the application class. It will basically calculate the path to a folder named `instance` next to your main file or the package.

    Changelog

    New in version 0.8.

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: Flask.before_request()
  id: api/index#flask.Flask.before_request
  summary: Register a function to run before each request
  description: |-
    `before_request(f)`

    Register a function to run before each request.

    For example, this can be used to open a database connection, or to load the logged in user from the session.

    ``` python
    @app.before_request
    def load_user():
        if "user_id" in session:
            g.user = db.session.get(session["user_id"])
    ```

    The function will be called without any arguments. If it returns a non-`None` value, the value is handled as if it was the return value from the view, and further request handling is stopped.

    This is available on both app and blueprint objects. When used on an app, this executes before every request. When used on a blueprint, this executes before every request that the blueprint handles. To register with a blueprint and execute before every request, use [`Blueprint.before_app_request()`](#flask.Blueprint.before_app_request "flask.Blueprint.before_app_request").

    Parameters:

    **f** (*T_before_request*) –

    Return type:

    *T_before_request*
- name: Flask.before_request_funcs
  id: api/index#flask.Flask.before_request_funcs
  summary: 'A data structure of functions to call at the beginning of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests'
  description: |-
    `before_request_funcs: dict[ft.AppOrBlueprintKey, list[ft.BeforeRequestCallable]]`

    A data structure of functions to call at the beginning of each request, in the format `{scope: [functions]}`. The `scope` key is the name of a blueprint the functions are active for, or `None` for all requests.

    To register a function, use the [`before_request()`](#flask.Flask.before_request "flask.Flask.before_request") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Flask.blueprints
  id: api/index#flask.Flask.blueprints
  summary: Maps registered blueprint names to blueprint objects
  description: |-
    `blueprints: dict[str, Blueprint]`

    Maps registered blueprint names to blueprint objects. The dict retains the order the blueprints were registered in. Blueprints can be registered multiple times, this dict does not track how often they were attached.

    Changelog

    New in version 0.7.
- name: Flask.cli
  id: api/index#flask.Flask.cli
  summary: The Click command group for registering CLI commands for this object
  description: |-
    `cli`

    The Click command group for registering CLI commands for this object. The commands are available from the `flask` command once the application has been discovered and blueprints have been registered.
- name: flask.cli.run_command
  id: api/index#flask.cli.run_command
  summary: Run a local development server
  description: |-
    `flask.cli.run_command = <Command run>`

    Run a local development server.

    This server is for development purposes only. It does not provide the stability, security, or performance of production WSGI servers.

    The reloader and debugger are enabled by default with the ‘–debug’ option.

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: flask.cli.shell_command
  id: api/index#flask.cli.shell_command
  summary: Run an interactive Python shell in the context of a given Flask application
  description: "`flask.cli.shell_command = <Command shell>`\n\nRun an interactive Python shell in the context of a given Flask application. The application will populate the default namespace of this shell according to its configuration.\n\nThis is useful for executing small snippets of management code without having to manually configure the application.\n\nParameters:\n\n- **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n- **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")) –\n\nReturn type:\n\n[Any](https://docs.python.org/3/library/typing.html#typing.Any \"(in Python v3.11)\")\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/api/](https://flask.palletsprojects.com/en/3.0.x/api/)"
- name: Flask.config
  id: api/index#flask.Flask.config
  summary: The configuration dictionary as Config
  description: |-
    `config`

    The configuration dictionary as [`Config`](#flask.Config "flask.Config"). This behaves exactly like a regular dictionary but supports additional methods to load a config from files.
- name: Flask.config_class
  id: api/index#flask.Flask.config_class
  summary: null
  description: |-
    `config_class`

    alias of [`Config`](#flask.Config "flask.config.Config")
- name: Flask.context_processor()
  id: api/index#flask.Flask.context_processor
  summary: Registers a template context processor function
  description: |-
    `context_processor(f)`

    Registers a template context processor function. These functions run before rendering a template. The keys of the returned dict are added as variables available in the template.

    This is available on both app and blueprint objects. When used on an app, this is called for every rendered template. When used on a blueprint, this is called for templates rendered from the blueprint’s views. To register with a blueprint and affect every template, use [`Blueprint.app_context_processor()`](#flask.Blueprint.app_context_processor "flask.Blueprint.app_context_processor").

    Parameters:

    **f** (*T_template_context_processor*) –

    Return type:

    *T_template_context_processor*
- name: Flask.create_global_jinja_loader()
  id: api/index#flask.Flask.create_global_jinja_loader
  summary: Creates the loader for the Jinja2 environment
  description: |-
    `create_global_jinja_loader()`

    Creates the loader for the Jinja2 environment. Can be used to override just the loader and keeping the rest unchanged. It’s discouraged to override this function. Instead one should override the [`jinja_loader()`](#flask.Flask.jinja_loader "flask.Flask.jinja_loader") function instead.

    The global loader dispatches between the loaders of the application and the individual blueprints.

    Changelog

    New in version 0.7.

    Return type:

    *DispatchingJinjaLoader*
- name: Flask.create_jinja_environment()
  id: api/index#flask.Flask.create_jinja_environment
  summary: Create the Jinja environment based on jinja_options and the various Jinja-related methods of the app
  description: |-
    `create_jinja_environment()`

    Create the Jinja environment based on [`jinja_options`](#flask.Flask.jinja_options "flask.Flask.jinja_options") and the various Jinja-related methods of the app. Changing [`jinja_options`](#flask.Flask.jinja_options "flask.Flask.jinja_options") after this will have no effect. Also adds Flask-related globals and filters to the environment.

    Changelog

    Changed in version 0.11: `Environment.auto_reload` set in accordance with `TEMPLATES_AUTO_RELOAD` configuration option.

    New in version 0.5.

    Return type:

    *Environment*
- name: Flask.create_url_adapter()
  id: api/index#flask.Flask.create_url_adapter
  summary: Creates a URL adapter for the given request
  description: |-
    `create_url_adapter(request)`

    Creates a URL adapter for the given request. The URL adapter is created at a point where the request context is not yet set up so the request is passed explicitly.

    Changelog

    Changed in version 1.0: [`SERVER_NAME`](../config/index#SERVER_NAME "SERVER_NAME") no longer implicitly enables subdomain matching. Use `subdomain_matching` instead.

    Changed in version 0.9: This can now also be called without a request object when the URL adapter is created for the application context.

    New in version 0.6.

    Parameters:

    **request** ([Request](#flask.Request "flask.wrappers.Request") *\|* *None*) –

    Return type:

    [MapAdapter](https://werkzeug.palletsprojects.com/en/2.3.x/routing/#werkzeug.routing.MapAdapter "(in Werkzeug v2.3.x)") \| None

    `property debug: bool`

    Whether debug mode is enabled. When using `flask run` to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. This maps to the [`DEBUG`](../config/index#DEBUG "DEBUG") config key. It may not behave as expected if set late.

    **Do not enable debug mode when deploying in production.**

    Default: `False`
- name: flask.current_app
  id: api/index#flask.current_app
  summary: A proxy to the application handling the current request
  description: |-
    `flask.current_app`

    A proxy to the application handling the current request. This is useful to access the application without needing to import it, or if it can’t be imported, such as when using the application factory pattern or in blueprints and extensions.

    This is only available when an [application context](../appcontext/index) is pushed. This happens automatically during requests and CLI commands. It can be controlled manually with [`app_context()`](#flask.Flask.app_context "flask.Flask.app_context").

    This is a proxy. See [Notes On Proxies](../reqcontext/index#notes-on-proxies) for more information.
- name: Flask.delete()
  id: api/index#flask.Flask.delete
  summary: Shortcut for route() with methods=["DELETE"]
  description: |-
    `delete(rule, **options)`

    Shortcut for [`route()`](#flask.Flask.route "flask.Flask.route") with `methods=["DELETE"]`.

    Changelog

    New in version 2.0.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_route*\], *T_route*\]
- name: Flask.dispatch_request()
  id: api/index#flask.Flask.dispatch_request
  summary: Does the request dispatching
  description: |-
    `dispatch_request()`

    Does the request dispatching. Matches the URL and returns the return value of the view or error handler. This does not have to be a response object. In order to convert the return value to a proper response object, call [`make_response()`](#flask.make_response "flask.make_response").

    Changelog

    Changed in version 0.7: This no longer does the exception handling, this code was moved to the new [`full_dispatch_request()`](#flask.Flask.full_dispatch_request "flask.Flask.full_dispatch_request").

    Return type:

    ft.ResponseReturnValue
- name: Flask.do_teardown_appcontext()
  id: api/index#flask.Flask.do_teardown_appcontext
  summary: Called right before the application context is popped
  description: |-
    `do_teardown_appcontext(exc=<object object>)`

    Called right before the application context is popped.

    When handling a request, the application context is popped after the request context. See [`do_teardown_request()`](#flask.Flask.do_teardown_request "flask.Flask.do_teardown_request").

    This calls all functions decorated with [`teardown_appcontext()`](#flask.Flask.teardown_appcontext "flask.Flask.teardown_appcontext"). Then the [`appcontext_tearing_down`](#flask.appcontext_tearing_down "flask.appcontext_tearing_down") signal is sent.

    This is called by [`AppContext.pop()`](#flask.ctx.AppContext.pop "flask.ctx.AppContext.pop").

    Changelog

    New in version 0.9.

    Parameters:

    **exc** ([BaseException](https://docs.python.org/3/library/exceptions.html#BaseException "(in Python v3.11)") *\|* *None*) –

    Return type:

    None
- name: Flask.do_teardown_request()
  id: api/index#flask.Flask.do_teardown_request
  summary: Called after the request is dispatched and the response is returned, right before the request context is popped
  description: |-
    `do_teardown_request(exc=<object object>)`

    Called after the request is dispatched and the response is returned, right before the request context is popped.

    This calls all functions decorated with [`teardown_request()`](#flask.Flask.teardown_request "flask.Flask.teardown_request"), and [`Blueprint.teardown_request()`](#flask.Blueprint.teardown_request "flask.Blueprint.teardown_request") if a blueprint handled the request. Finally, the [`request_tearing_down`](#flask.request_tearing_down "flask.request_tearing_down") signal is sent.

    This is called by [`RequestContext.pop()`](#flask.ctx.RequestContext.pop "flask.ctx.RequestContext.pop"), which may be delayed during testing to maintain access to resources.

    Parameters:

    **exc** ([BaseException](https://docs.python.org/3/library/exceptions.html#BaseException "(in Python v3.11)") *\|* *None*) – An unhandled exception raised while dispatching the request. Detected from the current exception information if not passed. Passed to each teardown function.

    Return type:

    None

    Changelog

    Changed in version 0.9: Added the `exc` argument.
- name: Flask.endpoint()
  id: api/index#flask.Flask.endpoint
  summary: Decorate a view function to register it for the given endpoint
  description: |-
    `endpoint(endpoint)`

    Decorate a view function to register it for the given endpoint. Used if a rule is added without a `view_func` with [`add_url_rule()`](#flask.Flask.add_url_rule "flask.Flask.add_url_rule").

    ``` python
    app.add_url_rule("/ex", endpoint="example")

    @app.endpoint("example")
    def example():
        ...
    ```

    Parameters:

    **endpoint** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The endpoint name to associate with the view function.

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*F*\], *F*\]
- name: Flask.ensure_sync()
  id: api/index#flask.Flask.ensure_sync
  summary: Ensure that the function is synchronous for WSGI workers
  description: |-
    `ensure_sync(func)`

    Ensure that the function is synchronous for WSGI workers. Plain `def` functions are returned as-is. `async def` functions are wrapped to run and wait for the response.

    Override this method to change how the app runs async views.

    Changelog

    New in version 2.0.

    Parameters:

    **func** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")
- name: Flask.error_handler_spec
  id: api/index#flask.Flask.error_handler_spec
  summary: 'A data structure of registered error handlers, in the format {scope: {code: {class: handler}}}. The scope key is the name of a blueprint the handlers are active for, or None for all requests'
  description: |-
    `error_handler_spec: dict[ft.AppOrBlueprintKey, dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]]]`

    A data structure of registered error handlers, in the format `{scope: {code: {class: handler}}}`. The `scope` key is the name of a blueprint the handlers are active for, or `None` for all requests. The `code` key is the HTTP status code for `HTTPException`, or `None` for other exceptions. The innermost dictionary maps exception classes to handler functions.

    To register an error handler, use the [`errorhandler()`](#flask.Flask.errorhandler "flask.Flask.errorhandler") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Flask.errorhandler()
  id: api/index#flask.Flask.errorhandler
  summary: Register a function to handle errors by code or exception class
  description: |-
    `errorhandler(code_or_exception)`

    Register a function to handle errors by code or exception class.

    A decorator that is used to register a function given an error code. Example:

    ``` python
    @app.errorhandler(404)
    def page_not_found(error):
        return 'This page does not exist', 404
    ```

    You can also register handlers for arbitrary exceptions:

    ``` python
    @app.errorhandler(DatabaseError)
    def special_exception_handler(error):
        return 'Database connection failed', 500
    ```

    This is available on both app and blueprint objects. When used on an app, this can handle errors from every request. When used on a blueprint, this can handle errors from requests that the blueprint handles. To register with a blueprint and affect every request, use [`Blueprint.app_errorhandler()`](#flask.Blueprint.app_errorhandler "flask.Blueprint.app_errorhandler").

    Changelog

    New in version 0.7: Use [`register_error_handler()`](#flask.Flask.register_error_handler "flask.Flask.register_error_handler") instead of modifying [`error_handler_spec`](#flask.Flask.error_handler_spec "flask.Flask.error_handler_spec") directly, for application wide error handlers.

    New in version 0.7: One can now additionally also register custom exception types that do not necessarily have to be a subclass of the [`HTTPException`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.HTTPException "(in Werkzeug v2.3.x)") class.

    Parameters:

    **code_or_exception** ([type](https://docs.python.org/3/library/functions.html#type "(in Python v3.11)")*\[*[Exception](https://docs.python.org/3/library/exceptions.html#Exception "(in Python v3.11)")*\]* *\|* [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) – the code as integer for the handler, or an arbitrary exception

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_error_handler*\], *T_error_handler*\]
- name: Flask.extensions
  id: api/index#flask.Flask.extensions
  summary: a place where extensions can store application specific state
  description: |-
    `extensions: dict`

    a place where extensions can store application specific state. For example this is where an extension could store database engines and similar things.

    The key must match the name of the extension module. For example in case of a “Flask-Foo” extension in `flask_foo`, the key would be `'foo'`.

    Changelog

    New in version 0.7.
- name: flask.flask.globals.app_ctx
  id: api/index#flask.flask.globals.app_ctx
  summary: The current AppContext
  description: |-
    `flask.globals.app_ctx`

    The current [`AppContext`](#flask.ctx.AppContext "flask.ctx.AppContext"). If an app context is not active, accessing attributes on this proxy will raise a `RuntimeError`.

    This is an internal object that is essential to how Flask handles requests. Accessing this should not be needed in most cases. Most likely you want [`current_app`](#flask.current_app "flask.current_app") and [`g`](#flask.g "flask.g") instead.
- name: flask.flask.globals.request_ctx
  id: api/index#flask.flask.globals.request_ctx
  summary: The current RequestContext
  description: |-
    `flask.globals.request_ctx`

    The current [`RequestContext`](#flask.ctx.RequestContext "flask.ctx.RequestContext"). If a request context is not active, accessing attributes on this proxy will raise a `RuntimeError`.

    This is an internal object that is essential to how Flask handles requests. Accessing this should not be needed in most cases. Most likely you want [`request`](#flask.request "flask.request") and [`session`](#flask.session "flask.session") instead.
- name: Flask.full_dispatch_request()
  id: api/index#flask.Flask.full_dispatch_request
  summary: Dispatches the request and on top of that performs request pre and postprocessing as well as HTTP exception catching and error handling
  description: |-
    `full_dispatch_request()`

    Dispatches the request and on top of that performs request pre and postprocessing as well as HTTP exception catching and error handling.

    Changelog

    New in version 0.7.

    Return type:

    [Response](#flask.Response "flask.wrappers.Response")
- name: flask.g
  id: api/index#flask.g
  summary: A namespace object that can store data during an application context
  description: |-
    `flask.g`

    A namespace object that can store data during an [application context](../appcontext/index). This is an instance of [`Flask.app_ctx_globals_class`](#flask.Flask.app_ctx_globals_class "flask.Flask.app_ctx_globals_class"), which defaults to [`ctx._AppCtxGlobals`](#flask.ctx._AppCtxGlobals "flask.ctx._AppCtxGlobals").

    This is a good place to store resources during a request. For example, a `before_request` function could load a user object from a session id, then set `g.user` to be used in the view function.

    This is a proxy. See [Notes On Proxies](../reqcontext/index#notes-on-proxies) for more information.

    Changelog

    Changed in version 0.10: Bound to the application context instead of the request context.
- name: Flask.get()
  id: api/index#flask.Flask.get
  summary: Shortcut for route() with methods=["GET"]
  description: |-
    `get(rule, **options)`

    Shortcut for [`route()`](#flask.Flask.route "flask.Flask.route") with `methods=["GET"]`.

    Changelog

    New in version 2.0.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_route*\], *T_route*\]
- name: Flask.get_send_file_max_age()
  id: api/index#flask.Flask.get_send_file_max_age
  summary: Used by send_file() to determine the max_age cache value for a given file path if it wasn’t passed
  description: |-
    `get_send_file_max_age(filename)`

    Used by [`send_file()`](#flask.send_file "flask.send_file") to determine the `max_age` cache value for a given file path if it wasn’t passed.

    By default, this returns [`SEND_FILE_MAX_AGE_DEFAULT`](../config/index#SEND_FILE_MAX_AGE_DEFAULT "SEND_FILE_MAX_AGE_DEFAULT") from the configuration of [`current_app`](#flask.current_app "flask.current_app"). This defaults to `None`, which tells the browser to use conditional requests instead of a timed cache, which is usually preferable.

    Note this is a duplicate of the same method in the Flask class.

    Changelog

    Changed in version 2.0: The default configuration is `None` instead of 12 hours.

    New in version 0.9.

    Parameters:

    **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –

    Return type:

    [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") \| None
- name: flask.got_request_exception
  id: api/index#flask.got_request_exception
  summary: This signal is sent when an unhandled exception happens during request processing, including when debugging
  description: |-
    `flask.got_request_exception`

    This signal is sent when an unhandled exception happens during request processing, including when debugging. The exception is passed to the subscriber as `exception`.

    This signal is not sent for [`HTTPException`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.HTTPException "(in Werkzeug v2.3.x)"), or other exceptions that have error handlers registered, unless the exception was raised from an error handler.

    This example shows how to do some extra logging if a theoretical `SecurityException` was raised:

    ``` python
    from flask import got_request_exception

    def log_security_exception(sender, exception, **extra):
        if not isinstance(exception, SecurityException):
            return

        security_logger.exception(
            f"SecurityException at {request.url!r}",
            exc_info=exception,
        )

    got_request_exception.connect(log_security_exception, app)
    ```
- name: Flask.handle_exception()
  id: api/index#flask.Flask.handle_exception
  summary: Handle an exception that did not have an error handler associated with it, or that was raised from an error handler
  description: |-
    `handle_exception(e)`

    Handle an exception that did not have an error handler associated with it, or that was raised from an error handler. This always causes a 500 `InternalServerError`.

    Always sends the [`got_request_exception`](#flask.got_request_exception "flask.got_request_exception") signal.

    If [`PROPAGATE_EXCEPTIONS`](../config/index#PROPAGATE_EXCEPTIONS "PROPAGATE_EXCEPTIONS") is `True`, such as in debug mode, the error will be re-raised so that the debugger can display it. Otherwise, the original exception is logged, and an [`InternalServerError`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.InternalServerError "(in Werkzeug v2.3.x)") is returned.

    If an error handler is registered for `InternalServerError` or `500`, it will be used. For consistency, the handler will always receive the `InternalServerError`. The original unhandled exception is available as `e.original_exception`.

    Changelog

    Changed in version 1.1.0: Always passes the `InternalServerError` instance to the handler, setting `original_exception` to the unhandled error.

    Changed in version 1.1.0: `after_request` functions and other finalization is done even for the default 500 response when there is no handler.

    New in version 0.3.

    Parameters:

    **e** ([Exception](https://docs.python.org/3/library/exceptions.html#Exception "(in Python v3.11)")) –

    Return type:

    [Response](#flask.Response "flask.wrappers.Response")
- name: Flask.handle_http_exception()
  id: api/index#flask.Flask.handle_http_exception
  summary: Handles an HTTP exception
  description: |-
    `handle_http_exception(e)`

    Handles an HTTP exception. By default this will invoke the registered error handlers and fall back to returning the exception as response.

    Changelog

    Changed in version 1.0.3: `RoutingException`, used internally for actions such as slash redirects during routing, is not passed to error handlers.

    Changed in version 1.0: Exceptions are looked up by code *and* by MRO, so `HTTPException` subclasses can be handled with a catch-all handler for the base `HTTPException`.

    New in version 0.3.

    Parameters:

    **e** (*HTTPException*) –

    Return type:

    HTTPException \| ft.ResponseReturnValue
- name: Flask.handle_url_build_error()
  id: api/index#flask.Flask.handle_url_build_error
  summary: Called by url_for() if a BuildError was raised
  description: |-
    `handle_url_build_error(error, endpoint, values)`

    Called by [`url_for()`](#flask.Flask.url_for "flask.Flask.url_for") if a `BuildError` was raised. If this returns a value, it will be returned by `url_for`, otherwise the error will be re-raised.

    Each function in [`url_build_error_handlers`](#flask.Flask.url_build_error_handlers "flask.Flask.url_build_error_handlers") is called with `error`, `endpoint` and `values`. If a function returns `None` or raises a `BuildError`, it is skipped. Otherwise, its return value is returned by `url_for`.

    Parameters:

    - **error** (*BuildError*) – The active `BuildError` being handled.
    - **endpoint** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The endpoint being built.
    - **values** ([dict](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]*) – The keyword arguments passed to `url_for`.

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: Flask.handle_user_exception()
  id: api/index#flask.Flask.handle_user_exception
  summary: This method is called whenever an exception occurs that should be handled
  description: |-
    `handle_user_exception(e)`

    This method is called whenever an exception occurs that should be handled. A special case is `HTTPException` which is forwarded to the [`handle_http_exception()`](#flask.Flask.handle_http_exception "flask.Flask.handle_http_exception") method. This function will either return a response value or reraise the exception with the same traceback.

    Changelog

    Changed in version 1.0: Key errors raised from request data like `form` show the bad key in debug mode rather than a generic bad request message.

    New in version 0.7.

    Parameters:

    **e** ([Exception](https://docs.python.org/3/library/exceptions.html#Exception "(in Python v3.11)")) –

    Return type:

    HTTPException \| ft.ResponseReturnValue

    `property has_static_folder: bool`

    `True` if [`static_folder`](#flask.Flask.static_folder "flask.Flask.static_folder") is set.

    Changelog

    New in version 0.5.
- name: Flask.import_name
  id: api/index#flask.Flask.import_name
  summary: The name of the package or module that this object belongs to
  description: |-
    `import_name`

    The name of the package or module that this object belongs to. Do not change this once it is set by the constructor.
- name: Flask.inject_url_defaults()
  id: api/index#flask.Flask.inject_url_defaults
  summary: Injects the URL defaults for the given endpoint directly into the values dictionary passed
  description: |-
    `inject_url_defaults(endpoint, values)`

    Injects the URL defaults for the given endpoint directly into the values dictionary passed. This is used internally and automatically called on URL building.

    Changelog

    New in version 0.7.

    Parameters:

    - **endpoint** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **values** ([dict](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)")) –

    Return type:

    None
- name: Flask.instance_path
  id: api/index#flask.Flask.instance_path
  summary: Holds the path to the instance folder
  description: |-
    `instance_path`

    Holds the path to the instance folder.

    Changelog

    New in version 0.8.
- name: Flask.iter_blueprints()
  id: api/index#flask.Flask.iter_blueprints
  summary: Iterates over all blueprints by the order they were registered
  description: |-
    `iter_blueprints()`

    Iterates over all blueprints by the order they were registered.

    Changelog

    New in version 0.11.

    Return type:

    t.ValuesView\[[Blueprint](#flask.Blueprint "flask.Blueprint")\]

    `property jinja_env: Environment`

    The Jinja environment used to load templates.

    The environment is created the first time this property is accessed. Changing [`jinja_options`](#flask.Flask.jinja_options "flask.Flask.jinja_options") after that will have no effect.
- name: Flask.jinja_environment
  id: api/index#flask.Flask.jinja_environment
  summary: The Jinja loader for this object’s templates
  description: |-
    `jinja_environment`

    alias of `Environment`

    `property jinja_loader: FileSystemLoader | None`

    The Jinja loader for this object’s templates. By default this is a class [`jinja2.loaders.FileSystemLoader`](https://jinja.palletsprojects.com/en/3.1.x/api/#jinja2.FileSystemLoader "(in Jinja v3.1.x)") to [`template_folder`](#flask.Flask.template_folder "flask.Flask.template_folder") if it is set.

    Changelog

    New in version 0.5.
- name: Flask.jinja_options
  id: api/index#flask.Flask.jinja_options
  summary: Options that are passed to the Jinja environment in create_jinja_environment()
  description: |-
    `jinja_options: dict = {}`

    Options that are passed to the Jinja environment in [`create_jinja_environment()`](#flask.Flask.create_jinja_environment "flask.Flask.create_jinja_environment"). Changing these options after the environment is created (accessing [`jinja_env`](#flask.Flask.jinja_env "flask.Flask.jinja_env")) will have no effect.

    Changelog

    Changed in version 1.1.0: This is a `dict` instead of an `ImmutableDict` to allow easier configuration.
- name: Flask.json
  id: api/index#flask.Flask.json
  summary: Provides access to JSON methods
  description: |-
    `json: JSONProvider`

    Provides access to JSON methods. Functions in `flask.json` will call methods on this provider when the application context is active. Used for handling JSON requests and responses.

    An instance of [`json_provider_class`](#flask.Flask.json_provider_class "flask.Flask.json_provider_class"). Can be customized by changing that attribute on a subclass, or by assigning to this attribute afterwards.

    The default, [`DefaultJSONProvider`](#flask.json.provider.DefaultJSONProvider "flask.json.provider.DefaultJSONProvider"), uses Python’s built-in [`json`](https://docs.python.org/3/library/json.html#module-json "(in Python v3.11)") library. A different provider can use a different JSON library.

    Changelog

    New in version 2.2.
- name: Flask.json_provider_class
  id: api/index#flask.Flask.json_provider_class
  summary: null
  description: |-
    `json_provider_class`

    alias of [`DefaultJSONProvider`](#flask.json.provider.DefaultJSONProvider "flask.json.provider.DefaultJSONProvider")
- name: Flask.log_exception()
  id: api/index#flask.Flask.log_exception
  summary: Logs an exception
  description: |-
    `log_exception(exc_info)`

    Logs an exception. This is called by [`handle_exception()`](#flask.Flask.handle_exception "flask.Flask.handle_exception") if debugging is disabled and right before the handler is called. The default implementation logs the exception as error on the [`logger`](#flask.Flask.logger "flask.Flask.logger").

    Changelog

    New in version 0.8.

    Parameters:

    **exc_info** ([tuple](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.11)")*\[*[type](https://docs.python.org/3/library/functions.html#type "(in Python v3.11)")*,* [BaseException](https://docs.python.org/3/library/exceptions.html#BaseException "(in Python v3.11)")*,* *traceback\]* *\|* [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.11)")*\[None,* *None,* *None\]*) –

    Return type:

    None

    `property logger: Logger`

    A standard Python [`Logger`](https://docs.python.org/3/library/logging.html#logging.Logger "(in Python v3.11)") for the app, with the same name as [`name`](#flask.Flask.name "flask.Flask.name").

    In debug mode, the logger’s `level` will be set to [`DEBUG`](https://docs.python.org/3/library/logging.html#logging.DEBUG "(in Python v3.11)").

    If there are no handlers configured, a default handler will be added. See [Logging](../logging/index) for more information.

    Changelog

    Changed in version 1.1.0: The logger takes the same name as [`name`](#flask.Flask.name "flask.Flask.name") rather than hard-coding `"flask.app"`.

    Changed in version 1.0.0: Behavior was simplified. The logger is always named `"flask.app"`. The level is only set during configuration, it doesn’t check `app.debug` each time. Only one format is used, not different ones depending on `app.debug`. No handlers are removed, and a handler is only added if no handlers are already configured.

    New in version 0.3.
- name: Flask.make_aborter()
  id: api/index#flask.Flask.make_aborter
  summary: Create the object to assign to aborter
  description: |-
    `make_aborter()`

    Create the object to assign to [`aborter`](#flask.Flask.aborter "flask.Flask.aborter"). That object is called by [`flask.abort()`](#flask.abort "flask.abort") to raise HTTP errors, and can be called directly as well.

    By default, this creates an instance of [`aborter_class`](#flask.Flask.aborter_class "flask.Flask.aborter_class"), which defaults to [`werkzeug.exceptions.Aborter`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.Aborter "(in Werkzeug v2.3.x)").

    Changelog

    New in version 2.2.

    Return type:

    [Aborter](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.Aborter "(in Werkzeug v2.3.x)")
- name: Flask.make_config()
  id: api/index#flask.Flask.make_config
  summary: Used to create the config attribute by the Flask constructor
  description: |-
    `make_config(instance_relative=False)`

    Used to create the config attribute by the Flask constructor. The `instance_relative` parameter is passed in from the constructor of Flask (there named `instance_relative_config`) and indicates if the config should be relative to the instance path or the root path of the application.

    Changelog

    New in version 0.8.

    Parameters:

    **instance_relative** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    [Config](#flask.Config "flask.config.Config")
- name: Flask.make_default_options_response()
  id: api/index#flask.Flask.make_default_options_response
  summary: This method is called to create the default OPTIONS response
  description: |-
    `make_default_options_response()`

    This method is called to create the default `OPTIONS` response. This can be changed through subclassing to change the default behavior of `OPTIONS` responses.

    Changelog

    New in version 0.7.

    Return type:

    [Response](#flask.Response "flask.wrappers.Response")
- name: Flask.make_response()
  id: api/index#flask.Flask.make_response
  summary: Convert the return value from a view function to an instance of response_class
  description: |-
    `make_response(rv)`

    Convert the return value from a view function to an instance of [`response_class`](#flask.Flask.response_class "flask.Flask.response_class").

    Parameters:

    **rv** (*ft.ResponseReturnValue*) –

    the return value from the view function. The view function must return a response. Returning `None`, or the view ending without returning, is not allowed. The following types are allowed for `view_rv`:

    `str`

    A response object is created with the string encoded to UTF-8 as the body.

    `bytes`

    A response object is created with the bytes as the body.

    `dict`

    A dictionary that will be jsonify’d before being returned.

    `list`

    A list that will be jsonify’d before being returned.

    `generator or iterator`

    A generator that returns `str` or `bytes` to be streamed as the response.

    `tuple`

    Either `(body, status, headers)`, `(body, status)`, or `(body, headers)`, where `body` is any of the other types allowed here, `status` is a string or an integer, and `headers` is a dictionary or a list of `(key, value)` tuples. If `body` is a [`response_class`](#flask.Flask.response_class "flask.Flask.response_class") instance, `status` overwrites the exiting value and `headers` are extended.

    [`response_class`](#flask.Flask.response_class "flask.Flask.response_class")

    The object is returned unchanged.

    `other Response class`

    The object is coerced to [`response_class`](#flask.Flask.response_class "flask.Flask.response_class").

    [`callable()`](https://docs.python.org/3/library/functions.html#callable "(in Python v3.11)")

    The function is called as a WSGI application. The result is used to create a response object.

    Return type:

    [Response](#flask.Response "flask.Response")

    Changelog

    Changed in version 2.2: A generator will be converted to a streaming response. A list will be converted to a JSON response.

    Changed in version 1.1: A dict will be converted to a JSON response.

    Changed in version 0.9: Previously a tuple was interpreted as the arguments for the response object.
- name: Flask.make_shell_context()
  id: api/index#flask.Flask.make_shell_context
  summary: Returns the shell context for an interactive shell for this application
  description: |-
    `make_shell_context()`

    Returns the shell context for an interactive shell for this application. This runs all the registered shell context processors.

    Changelog

    New in version 0.11.

    Return type:

    [dict](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)")

    `property name: str`

    The name of the application. This is usually the import name with the difference that it’s guessed from the run file if the import name is main. This name is used as a display name when Flask needs the name of the application. It can be set and overridden to change the value.

    Changelog

    New in version 0.8.
- name: flask.message_flashed
  id: api/index#flask.message_flashed
  summary: This signal is sent when the application is flashing a message
  description: |-
    `flask.message_flashed`

    This signal is sent when the application is flashing a message. The messages is sent as `message` keyword argument and the category as `category`.

    Example subscriber:

    ``` python
    recorded = []
    def record(sender, message, category, **extra):
        recorded.append((message, category))

    from flask import message_flashed
    message_flashed.connect(record, app)
    ```

    Changelog

    New in version 0.10.

    ## Class-Based Views

    Changelog

    New in version 0.7.
- name: Flask.open_instance_resource()
  id: api/index#flask.Flask.open_instance_resource
  summary: Opens a resource from the application’s instance folder (instance_path)
  description: |-
    `open_instance_resource(resource, mode='rb')`

    Opens a resource from the application’s instance folder ([`instance_path`](#flask.Flask.instance_path "flask.Flask.instance_path")). Otherwise works like [`open_resource()`](#flask.Flask.open_resource "flask.Flask.open_resource"). Instance resources can also be opened for writing.

    Parameters:

    - **resource** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – the name of the resource. To access resources within subfolders use forward slashes as separator.
    - **mode** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – resource file opening mode, default is ‘rb’.

    Return type:

    [IO](https://docs.python.org/3/library/typing.html#typing.IO "(in Python v3.11)")
- name: Flask.open_resource()
  id: api/index#flask.Flask.open_resource
  summary: Open a resource file relative to root_path for reading
  description: |-
    `open_resource(resource, mode='rb')`

    Open a resource file relative to [`root_path`](#flask.Flask.root_path "flask.Flask.root_path") for reading.

    For example, if the file `schema.sql` is next to the file `app.py` where the `Flask` app is defined, it can be opened with:

    ``` python
    with app.open_resource("schema.sql") as f:
        conn.executescript(f.read())
    ```

    Parameters:

    - **resource** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – Path to the resource relative to [`root_path`](#flask.Flask.root_path "flask.Flask.root_path").
    - **mode** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – Open the file in this mode. Only reading is supported, valid values are “r” (or “rt”) and “rb”.

    Return type:

    [IO](https://docs.python.org/3/library/typing.html#typing.IO "(in Python v3.11)")

    Note this is a duplicate of the same method in the Flask class.
- name: Flask.patch()
  id: api/index#flask.Flask.patch
  summary: Shortcut for route() with methods=["PATCH"]
  description: |-
    `patch(rule, **options)`

    Shortcut for [`route()`](#flask.Flask.route "flask.Flask.route") with `methods=["PATCH"]`.

    Changelog

    New in version 2.0.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_route*\], *T_route*\]
- name: Flask.permanent_session_lifetime
  id: api/index#flask.Flask.permanent_session_lifetime
  summary: A timedelta which is used to set the expiration date of a permanent session
  description: |-
    `permanent_session_lifetime`

    A [`timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta "(in Python v3.11)") which is used to set the expiration date of a permanent session. The default is 31 days which makes a permanent session survive for roughly one month.

    This attribute can also be configured from the config with the `PERMANENT_SESSION_LIFETIME` configuration key. Defaults to `timedelta(days=31)`
- name: Flask.post()
  id: api/index#flask.Flask.post
  summary: Shortcut for route() with methods=["POST"]
  description: |-
    `post(rule, **options)`

    Shortcut for [`route()`](#flask.Flask.route "flask.Flask.route") with `methods=["POST"]`.

    Changelog

    New in version 2.0.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_route*\], *T_route*\]
- name: Flask.preprocess_request()
  id: api/index#flask.Flask.preprocess_request
  summary: Called before the request is dispatched
  description: |-
    `preprocess_request()`

    Called before the request is dispatched. Calls [`url_value_preprocessors`](#flask.Flask.url_value_preprocessors "flask.Flask.url_value_preprocessors") registered with the app and the current blueprint (if any). Then calls [`before_request_funcs`](#flask.Flask.before_request_funcs "flask.Flask.before_request_funcs") registered with the app and the blueprint.

    If any [`before_request()`](#flask.Flask.before_request "flask.Flask.before_request") handler returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.

    Return type:

    ft.ResponseReturnValue \| None
- name: Flask.process_response()
  id: api/index#flask.Flask.process_response
  summary: Can be overridden in order to modify the response object before it’s sent to the WSGI server
  description: |-
    `process_response(response)`

    Can be overridden in order to modify the response object before it’s sent to the WSGI server. By default this will call all the [`after_request()`](#flask.Flask.after_request "flask.Flask.after_request") decorated functions.

    Changelog

    Changed in version 0.5: As of Flask 0.5 the functions registered for after request execution are called in reverse order of registration.

    Parameters:

    **response** ([Response](#flask.Response "flask.wrappers.Response")) – a [`response_class`](#flask.Flask.response_class "flask.Flask.response_class") object.

    Returns:

    a new response object or the same, has to be an instance of [`response_class`](#flask.Flask.response_class "flask.Flask.response_class").

    Return type:

    [Response](#flask.Response "flask.wrappers.Response")
- name: Flask.put()
  id: api/index#flask.Flask.put
  summary: Shortcut for route() with methods=["PUT"]
  description: |-
    `put(rule, **options)`

    Shortcut for [`route()`](#flask.Flask.route "flask.Flask.route") with `methods=["PUT"]`.

    Changelog

    New in version 2.0.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_route*\], *T_route*\]
- name: Flask.redirect()
  id: api/index#flask.Flask.redirect
  summary: Create a redirect response object
  description: |-
    `redirect(location, code=302)`

    Create a redirect response object.

    This is called by [`flask.redirect()`](#flask.redirect "flask.redirect"), and can be called directly as well.

    Parameters:

    - **location** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The URL to redirect to.
    - **code** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) – The status code for the redirect.

    Return type:

    BaseResponse

    Changelog

    New in version 2.2: Moved from `flask.redirect`, which calls this method.
- name: Flask.register_blueprint()
  id: api/index#flask.Flask.register_blueprint
  summary: Register a Blueprint on the application
  description: |-
    `register_blueprint(blueprint, **options)`

    Register a [`Blueprint`](#flask.Blueprint "flask.Blueprint") on the application. Keyword arguments passed to this method will override the defaults set on the blueprint.

    Calls the blueprint’s [`register()`](#flask.Blueprint.register "flask.Blueprint.register") method after recording the blueprint in the application’s [`blueprints`](#flask.Flask.blueprints "flask.Flask.blueprints").

    Parameters:

    - **blueprint** ([Blueprint](#flask.Blueprint "flask.Blueprint")) – The blueprint to register.
    - **url_prefix** – Blueprint routes will be prefixed with this.
    - **subdomain** – Blueprint routes will match on this subdomain.
    - **url_defaults** – Blueprint routes will use these default values for view arguments.
    - **options** (*t.Any*) – Additional keyword arguments are passed to [`BlueprintSetupState`](#flask.blueprints.BlueprintSetupState "flask.blueprints.BlueprintSetupState"). They can be accessed in [`record()`](#flask.Blueprint.record "flask.Blueprint.record") callbacks.

    Return type:

    None

    Changelog

    Changed in version 2.0.1: The `name` option can be used to change the (pre-dotted) name the blueprint is registered with. This allows the same blueprint to be registered multiple times with unique names for `url_for`.

    New in version 0.7.
- name: Flask.register_error_handler()
  id: api/index#flask.Flask.register_error_handler
  summary: Alternative error attach function to the errorhandler() decorator that is more straightforward to use for non decorator usage
  description: |-
    `register_error_handler(code_or_exception, f)`

    Alternative error attach function to the [`errorhandler()`](#flask.Flask.errorhandler "flask.Flask.errorhandler") decorator that is more straightforward to use for non decorator usage.

    Changelog

    New in version 0.7.

    Parameters:

    - **code_or_exception** ([type](https://docs.python.org/3/library/functions.html#type "(in Python v3.11)")*\[*[Exception](https://docs.python.org/3/library/exceptions.html#Exception "(in Python v3.11)")*\]* *\|* [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) –
    - **f** (*ft.ErrorHandlerCallable*) –

    Return type:

    None
- name: flask.request
  id: api/index#flask.request
  summary: The request object used by default in Flask
  description: |-
    `class flask.Request(environ, populate_request=True, shallow=False)`

    The request object used by default in Flask. Remembers the matched endpoint and view arguments.

    It is what ends up as [`request`](#flask.request "flask.request"). If you want to replace the request object used you can subclass this and set [`request_class`](#flask.Flask.request_class "flask.Flask.request_class") to your subclass.

    The request object is a [`Request`](https://werkzeug.palletsprojects.com/en/2.3.x/wrappers/#werkzeug.wrappers.Request "(in Werkzeug v2.3.x)") subclass and provides all of the attributes Werkzeug defines plus a few Flask specific ones.

    Parameters:

    - **environ** (*WSGIEnvironment*) –
    - **populate_request** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **shallow** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    `property accept_charsets: CharsetAccept`

    List of charsets this client supports as [`CharsetAccept`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.CharsetAccept "(in Werkzeug v2.3.x)") object.

    `property accept_encodings: Accept`

    List of encodings this client accepts. Encodings in a HTTP term are compression encodings such as gzip. For charsets have a look at `accept_charset`.

    `property accept_languages: LanguageAccept`

    List of languages this client accepts as [`LanguageAccept`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.LanguageAccept "(in Werkzeug v2.3.x)") object.

    `property accept_mimetypes: MIMEAccept`

    List of mimetypes this client supports as [`MIMEAccept`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.MIMEAccept "(in Werkzeug v2.3.x)") object.
- name: Flask.request_class
  id: api/index#flask.Flask.request_class
  summary: null
  description: |-
    `request_class`

    alias of [`Request`](#flask.Request "flask.wrappers.Request")
- name: Flask.request_context()
  id: api/index#flask.Flask.request_context
  summary: Create a RequestContext representing a WSGI environment
  description: |-
    `request_context(environ)`

    Create a [`RequestContext`](#flask.ctx.RequestContext "flask.ctx.RequestContext") representing a WSGI environment. Use a `with` block to push the context, which will make [`request`](#flask.request "flask.request") point at this request.

    See [The Request Context](../reqcontext/index).

    Typically you should not call this from your own code. A request context is automatically pushed by the [`wsgi_app()`](#flask.Flask.wsgi_app "flask.Flask.wsgi_app") when handling a request. Use [`test_request_context()`](#flask.Flask.test_request_context "flask.Flask.test_request_context") to create an environment and context instead of this method.

    Parameters:

    **environ** ([dict](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)")) – a WSGI environment

    Return type:

    [RequestContext](#flask.ctx.RequestContext "flask.ctx.RequestContext")
- name: flask.request_finished
  id: api/index#flask.request_finished
  summary: This signal is sent right before the response is sent to the client
  description: |-
    `flask.request_finished`

    This signal is sent right before the response is sent to the client. It is passed the response to be sent named `response`.

    Example subscriber:

    ``` python
    def log_response(sender, response, **extra):
        sender.logger.debug('Request context is about to close down. '
                            'Response: %s', response)

    from flask import request_finished
    request_finished.connect(log_response, app)
    ```
- name: flask.request_started
  id: api/index#flask.request_started
  summary: This signal is sent when the request context is set up, before any request processing happens
  description: |-
    `flask.request_started`

    This signal is sent when the request context is set up, before any request processing happens. Because the request context is already bound, the subscriber can access the request with the standard global proxies such as [`request`](#flask.request "flask.request").

    Example subscriber:

    ``` python
    def log_request(sender, **extra):
        sender.logger.debug('Request context is set up')

    from flask import request_started
    request_started.connect(log_request, app)
    ```
- name: flask.request_tearing_down
  id: api/index#flask.request_tearing_down
  summary: This signal is sent when the request is tearing down
  description: |-
    `flask.request_tearing_down`

    This signal is sent when the request is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on.

    Example subscriber:

    ``` python
    def close_db_connection(sender, **extra):
        session.close()

    from flask import request_tearing_down
    request_tearing_down.connect(close_db_connection, app)
    ```

    As of Flask 0.9, this will also be passed an `exc` keyword argument that has a reference to the exception that caused the teardown if there was one.
- name: Flask.response_class
  id: api/index#flask.Flask.response_class
  summary: null
  description: |-
    `response_class`

    alias of [`Response`](#flask.Response "flask.wrappers.Response")
- name: Flask.root_path
  id: api/index#flask.Flask.root_path
  summary: Absolute path to the package on the filesystem
  description: |-
    `root_path`

    Absolute path to the package on the filesystem. Used to look up resources contained in the package.
- name: Flask.route()
  id: api/index#flask.Flask.route
  summary: Decorate a view function to register it with the given URL rule and options
  description: |-
    `route(rule, **options)`

    Decorate a view function to register it with the given URL rule and options. Calls [`add_url_rule()`](#flask.Flask.add_url_rule "flask.Flask.add_url_rule"), which has more details about the implementation.

    ``` python
    @app.route("/")
    def index():
        return "Hello, World!"
    ```

    See [URL Route Registrations](#url-route-registrations).

    The endpoint name for the route defaults to the name of the view function if the `endpoint` parameter isn’t passed.

    The `methods` parameter defaults to `["GET"]`. `HEAD` and `OPTIONS` are added automatically.

    Parameters:

    - **rule** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The URL rule string.
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – Extra options passed to the [`Rule`](https://werkzeug.palletsprojects.com/en/2.3.x/routing/#werkzeug.routing.Rule "(in Werkzeug v2.3.x)") object.

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_route*\], *T_route*\]
- name: Flask.run()
  id: api/index#flask.Flask.run
  summary: Runs the application on a local development server
  description: |-
    `run(host=None, port=None, debug=None, load_dotenv=True, **options)`

    Runs the application on a local development server.

    Do not use `run()` in a production setting. It is not intended to meet security and performance requirements for a production server. Instead, see [Deploying to Production](../deploying/index) for WSGI server recommendations.

    If the [`debug`](#flask.Flask.debug "flask.Flask.debug") flag is set the server will automatically reload for code changes and show a debugger in case an exception happened.

    If you want to run the application in debug mode, but disable the code execution on the interactive debugger, you can pass `use_evalex=False` as parameter. This will keep the debugger’s traceback screen active, but disable code execution.

    It is not recommended to use this function for development with automatic reloading as this is badly supported. Instead you should be using the **flask** command line script’s `run` support.

    Keep in Mind

    Flask will suppress any server error with a generic error page unless it is in debug mode. As such to enable just the interactive debugger without the code reloading, you have to invoke [`run()`](#flask.Flask.run "flask.Flask.run") with `debug=True` and `use_reloader=False`. Setting `use_debugger` to `True` without being in debug mode won’t catch any exceptions because there won’t be any to catch.

    Parameters:

    - **host** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the hostname to listen on. Set this to `'0.0.0.0'` to have the server available externally as well. Defaults to `'127.0.0.1'` or the host in the `SERVER_NAME` config variable if present.
    - **port** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* *None*) – the port of the webserver. Defaults to `5000` or the port defined in the `SERVER_NAME` config variable if present.
    - **debug** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)") *\|* *None*) – if given, enable or disable debug mode. See [`debug`](#flask.Flask.debug "flask.Flask.debug").
    - **load_dotenv** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Load the nearest `.env` and `.flaskenv` files to set environment variables. Will also change the working directory to the directory containing the first file found.
    - **options** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – the options to be forwarded to the underlying Werkzeug server. See [`werkzeug.serving.run_simple()`](https://werkzeug.palletsprojects.com/en/2.3.x/serving/#werkzeug.serving.run_simple "(in Werkzeug v2.3.x)") for more information.

    Return type:

    None

    Changelog

    Changed in version 1.0: If installed, python-dotenv will be used to load environment variables from `.env` and `.flaskenv` files.

    The `FLASK_DEBUG` environment variable will override [`debug`](#flask.Flask.debug "flask.Flask.debug").

    Threaded mode is enabled by default.

    Changed in version 0.10: The default port is now picked from the `SERVER_NAME` variable.
- name: Flask.secret_key
  id: api/index#flask.Flask.secret_key
  summary: If a secret key is set, cryptographic components can use this to sign cookies and other things
  description: |-
    `secret_key`

    If a secret key is set, cryptographic components can use this to sign cookies and other things. Set this to a complex random value when you want to use the secure cookie for instance.

    This attribute can also be configured from the config with the [`SECRET_KEY`](../config/index#SECRET_KEY "SECRET_KEY") configuration key. Defaults to `None`.
- name: Flask.select_jinja_autoescape()
  id: api/index#flask.Flask.select_jinja_autoescape
  summary: Returns True if autoescaping should be active for the given template name
  description: |-
    `select_jinja_autoescape(filename)`

    Returns `True` if autoescaping should be active for the given template name. If no template name is given, returns `True`.

    Changelog

    Changed in version 2.2: Autoescaping is now enabled by default for `.svg` files.

    New in version 0.5.

    Parameters:

    **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: Flask.send_static_file()
  id: api/index#flask.Flask.send_static_file
  summary: The view function used to serve files from static_folder
  description: |-
    `send_static_file(filename)`

    The view function used to serve files from [`static_folder`](#flask.Flask.static_folder "flask.Flask.static_folder"). A route is automatically registered for this view at [`static_url_path`](#flask.Flask.static_url_path "flask.Flask.static_url_path") if [`static_folder`](#flask.Flask.static_folder "flask.Flask.static_folder") is set.

    Note this is a duplicate of the same method in the Flask class.

    Changelog

    New in version 0.5.

    Parameters:

    **filename** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    [Response](#flask.Response "flask.wrappers.Response")
- name: Flask.session_interface
  id: api/index#flask.Flask.session_interface
  summary: the session interface to use
  description: |-
    `session_interface: SessionInterface = <flask.sessions.SecureCookieSessionInterface object>`

    the session interface to use. By default an instance of [`SecureCookieSessionInterface`](#flask.sessions.SecureCookieSessionInterface "flask.sessions.SecureCookieSessionInterface") is used here.

    Changelog

    New in version 0.8.
- name: Flask.shell_context_processor()
  id: api/index#flask.Flask.shell_context_processor
  summary: Registers a shell context processor function
  description: |-
    `shell_context_processor(f)`

    Registers a shell context processor function.

    Changelog

    New in version 0.11.

    Parameters:

    **f** (*T_shell_context_processor*) –

    Return type:

    *T_shell_context_processor*
- name: Flask.shell_context_processors
  id: api/index#flask.Flask.shell_context_processors
  summary: A list of shell context processor functions that should be run when a shell context is created
  description: |-
    `shell_context_processors: list[ft.ShellContextProcessorCallable]`

    A list of shell context processor functions that should be run when a shell context is created.

    Changelog

    New in version 0.11.
- name: Flask.should_ignore_error()
  id: api/index#flask.Flask.should_ignore_error
  summary: This is called to figure out if an error should be ignored or not as far as the teardown system is concerned
  description: |-
    `should_ignore_error(error)`

    This is called to figure out if an error should be ignored or not as far as the teardown system is concerned. If this function returns `True` then the teardown handlers will not be passed the error.

    Changelog

    New in version 0.10.

    Parameters:

    **error** ([BaseException](https://docs.python.org/3/library/exceptions.html#BaseException "(in Python v3.11)") *\|* *None*) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")

    `property static_folder: str | None`

    The absolute path to the configured static folder. `None` if no static folder is set.

    `property static_url_path: str | None`

    The URL prefix that the static route will be accessible from.

    If it was not configured during init, it is derived from [`static_folder`](#flask.Flask.static_folder "flask.Flask.static_folder").
- name: Flask.teardown_appcontext()
  id: api/index#flask.Flask.teardown_appcontext
  summary: Registers a function to be called when the application context is popped
  description: |-
    `teardown_appcontext(f)`

    Registers a function to be called when the application context is popped. The application context is typically popped after the request context for each request, at the end of CLI commands, or after a manually pushed context ends.

    ``` python
    with app.app_context():
        ...
    ```

    When the `with` block exits (or `ctx.pop()` is called), the teardown functions are called just before the app context is made inactive. Since a request context typically also manages an application context it would also be called when you pop a request context.

    When a teardown function was called because of an unhandled exception it will be passed an error object. If an [`errorhandler()`](#flask.Flask.errorhandler "flask.Flask.errorhandler") is registered, it will handle the exception and the teardown will not receive it.

    Teardown functions must avoid raising exceptions. If they execute code that might fail they must surround that code with a `try`/`except` block and log any errors.

    The return values of teardown functions are ignored.

    Changelog

    New in version 0.9.

    Parameters:

    **f** (*T_teardown*) –

    Return type:

    *T_teardown*
- name: Flask.teardown_appcontext_funcs
  id: api/index#flask.Flask.teardown_appcontext_funcs
  summary: A list of functions that are called when the application context is destroyed
  description: |-
    `teardown_appcontext_funcs: list[ft.TeardownCallable]`

    A list of functions that are called when the application context is destroyed. Since the application context is also torn down if the request ends this is the place to store code that disconnects from databases.

    Changelog

    New in version 0.9.
- name: Flask.teardown_request()
  id: api/index#flask.Flask.teardown_request
  summary: Register a function to be called when the request context is popped
  description: |-
    `teardown_request(f)`

    Register a function to be called when the request context is popped. Typically this happens at the end of each request, but contexts may be pushed manually as well during testing.

    ``` python
    with app.test_request_context():
        ...
    ```

    When the `with` block exits (or `ctx.pop()` is called), the teardown functions are called just before the request context is made inactive.

    When a teardown function was called because of an unhandled exception it will be passed an error object. If an [`errorhandler()`](#flask.Flask.errorhandler "flask.Flask.errorhandler") is registered, it will handle the exception and the teardown will not receive it.

    Teardown functions must avoid raising exceptions. If they execute code that might fail they must surround that code with a `try`/`except` block and log any errors.

    The return values of teardown functions are ignored.

    This is available on both app and blueprint objects. When used on an app, this executes after every request. When used on a blueprint, this executes after every request that the blueprint handles. To register with a blueprint and execute after every request, use [`Blueprint.teardown_app_request()`](#flask.Blueprint.teardown_app_request "flask.Blueprint.teardown_app_request").

    Parameters:

    **f** (*T_teardown*) –

    Return type:

    *T_teardown*
- name: Flask.teardown_request_funcs
  id: api/index#flask.Flask.teardown_request_funcs
  summary: 'A data structure of functions to call at the end of each request even if an exception is raised, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests'
  description: |-
    `teardown_request_funcs: dict[ft.AppOrBlueprintKey, list[ft.TeardownCallable]]`

    A data structure of functions to call at the end of each request even if an exception is raised, in the format `{scope: [functions]}`. The `scope` key is the name of a blueprint the functions are active for, or `None` for all requests.

    To register a function, use the [`teardown_request()`](#flask.Flask.teardown_request "flask.Flask.teardown_request") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Flask.template_context_processors
  id: api/index#flask.Flask.template_context_processors
  summary: 'A data structure of functions to call to pass extra context values when rendering templates, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests'
  description: |-
    `template_context_processors: dict[ft.AppOrBlueprintKey, list[ft.TemplateContextProcessorCallable]]`

    A data structure of functions to call to pass extra context values when rendering templates, in the format `{scope: [functions]}`. The `scope` key is the name of a blueprint the functions are active for, or `None` for all requests.

    To register a function, use the [`context_processor()`](#flask.Flask.context_processor "flask.Flask.context_processor") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Flask.template_filter()
  id: api/index#flask.Flask.template_filter
  summary: A decorator that is used to register custom template filter
  description: |-
    `template_filter(name=None)`

    A decorator that is used to register custom template filter. You can specify a name for the filter, otherwise the function name will be used. Example:

    ``` python
    @app.template_filter()
    def reverse(s):
        return s[::-1]
    ```

    Parameters:

    **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the optional name of the filter, otherwise the function name will be used.

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_template_filter*\], *T_template_filter*\]
- name: Flask.template_folder
  id: api/index#flask.Flask.template_folder
  summary: The path to the templates folder, relative to root_path, to add to the template loader
  description: |-
    `template_folder`

    The path to the templates folder, relative to [`root_path`](#flask.Flask.root_path "flask.Flask.root_path"), to add to the template loader. `None` if templates should not be added.
- name: Flask.template_global()
  id: api/index#flask.Flask.template_global
  summary: A decorator that is used to register a custom template global function
  description: |-
    `template_global(name=None)`

    A decorator that is used to register a custom template global function. You can specify a name for the global function, otherwise the function name will be used. Example:

    ``` python
    @app.template_global()
    def double(n):
        return 2 * n
    ```

    Changelog

    New in version 0.10.

    Parameters:

    **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the optional name of the global function, otherwise the function name will be used.

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_template_global*\], *T_template_global*\]
- name: flask.template_rendered
  id: api/index#flask.template_rendered
  summary: This signal is sent when a template was successfully rendered
  description: |-
    `flask.template_rendered`

    This signal is sent when a template was successfully rendered. The signal is invoked with the instance of the template as `template` and the context as dictionary (named `context`).

    Example subscriber:

    ``` python
    def log_template_renders(sender, template, context, **extra):
        sender.logger.debug('Rendering template "%s" with context %s',
                            template.name or 'string template',
                            context)

    from flask import template_rendered
    template_rendered.connect(log_template_renders, app)
    ```

    flask. before_render_template

    This signal is sent before template rendering process. The signal is invoked with the instance of the template as `template` and the context as dictionary (named `context`).

    Example subscriber:

    ``` python
    def log_template_renders(sender, template, context, **extra):
        sender.logger.debug('Rendering template "%s" with context %s',
                            template.name or 'string template',
                            context)

    from flask import before_render_template
    before_render_template.connect(log_template_renders, app)
    ```
- name: Flask.template_test()
  id: api/index#flask.Flask.template_test
  summary: A decorator that is used to register custom template test
  description: |-
    `template_test(name=None)`

    A decorator that is used to register custom template test. You can specify a name for the test, otherwise the function name will be used. Example:

    ``` python
    @app.template_test()
    def is_prime(n):
        if n == 2:
            return True
        for i in range(2, int(math.ceil(math.sqrt(n))) + 1):
            if n % i == 0:
                return False
        return True
    ```

    Changelog

    New in version 0.10.

    Parameters:

    **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the optional name of the test, otherwise the function name will be used.

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[*T_template_test*\], *T_template_test*\]
- name: Flask.test_cli_runner()
  id: api/index#flask.Flask.test_cli_runner
  summary: Create a CLI runner for testing CLI commands
  description: |-
    `test_cli_runner(**kwargs)`

    Create a CLI runner for testing CLI commands. See [Running Commands with the CLI Runner](../testing/index#testing-cli).

    Returns an instance of [`test_cli_runner_class`](#flask.Flask.test_cli_runner_class "flask.Flask.test_cli_runner_class"), by default [`FlaskCliRunner`](#flask.testing.FlaskCliRunner "flask.testing.FlaskCliRunner"). The Flask app object is passed as the first argument.

    Changelog

    New in version 1.0.

    Parameters:

    **kwargs** (*t.Any*) –

    Return type:

    [FlaskCliRunner](#flask.testing.FlaskCliRunner "flask.testing.FlaskCliRunner")
- name: Flask.test_cli_runner_class
  id: api/index#flask.Flask.test_cli_runner_class
  summary: The CliRunner subclass, by default FlaskCliRunner that is used by test_cli_runner()
  description: |-
    `test_cli_runner_class: type[FlaskCliRunner] | None = None`

    The [`CliRunner`](https://click.palletsprojects.com/en/8.1.x/api/#click.testing.CliRunner "(in Click v8.1.x)") subclass, by default [`FlaskCliRunner`](#flask.testing.FlaskCliRunner "flask.testing.FlaskCliRunner") that is used by [`test_cli_runner()`](#flask.Flask.test_cli_runner "flask.Flask.test_cli_runner"). Its `__init__` method should take a Flask app object as the first argument.

    Changelog

    New in version 1.0.
- name: Flask.test_client()
  id: api/index#flask.Flask.test_client
  summary: Creates a test client for this application
  description: |-
    `test_client(use_cookies=True, **kwargs)`

    Creates a test client for this application. For information about unit testing head over to [Testing Flask Applications](../testing/index).

    Note that if you are testing for assertions or exceptions in your application code, you must set `app.testing = True` in order for the exceptions to propagate to the test client. Otherwise, the exception will be handled by the application (not visible to the test client) and the only indication of an AssertionError or other exception will be a 500 status code response to the test client. See the [`testing`](#flask.Flask.testing "flask.Flask.testing") attribute. For example:

    ``` python
    app.testing = True
    client = app.test_client()
    ```

    The test client can be used in a `with` block to defer the closing down of the context until the end of the `with` block. This is useful if you want to access the context locals for testing:

    ``` python
    with app.test_client() as c:
        rv = c.get('/?vodka=42')
        assert request.args['vodka'] == '42'
    ```

    Additionally, you may pass optional keyword arguments that will then be passed to the application’s [`test_client_class`](#flask.Flask.test_client_class "flask.Flask.test_client_class") constructor. For example:

    ``` python
    from flask.testing import FlaskClient

    class CustomClient(FlaskClient):
        def __init__(self, *args, **kwargs):
            self._authentication = kwargs.pop("authentication")
            super(CustomClient,self).__init__( *args, **kwargs)

    app.test_client_class = CustomClient
    client = app.test_client(authentication='Basic ....')
    ```

    See [`FlaskClient`](#flask.testing.FlaskClient "flask.testing.FlaskClient") for more information.

    Changelog

    Changed in version 0.11: Added `**kwargs` to support passing additional keyword arguments to the constructor of [`test_client_class`](#flask.Flask.test_client_class "flask.Flask.test_client_class").

    New in version 0.7: The `use_cookies` parameter was added as well as the ability to override the client to be used by setting the [`test_client_class`](#flask.Flask.test_client_class "flask.Flask.test_client_class") attribute.

    Changed in version 0.4: added support for `with` block usage for the client.

    Parameters:

    - **use_cookies** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **kwargs** (*t.Any*) –

    Return type:

    [FlaskClient](#flask.testing.FlaskClient "flask.testing.FlaskClient")
- name: Flask.test_client_class
  id: api/index#flask.Flask.test_client_class
  summary: The test_client() method creates an instance of this test client class
  description: |-
    `test_client_class: type[FlaskClient] | None = None`

    The [`test_client()`](#flask.Flask.test_client "flask.Flask.test_client") method creates an instance of this test client class. Defaults to [`FlaskClient`](#flask.testing.FlaskClient "flask.testing.FlaskClient").

    Changelog

    New in version 0.7.
- name: Flask.test_request_context()
  id: api/index#flask.Flask.test_request_context
  summary: Create a RequestContext for a WSGI environment created from the given values
  description: |-
    `test_request_context(*args, **kwargs)`

    Create a [`RequestContext`](#flask.ctx.RequestContext "flask.ctx.RequestContext") for a WSGI environment created from the given values. This is mostly useful during testing, where you may want to run a function that uses request data without dispatching a full request.

    See [The Request Context](../reqcontext/index).

    Use a `with` block to push the context, which will make [`request`](#flask.request "flask.request") point at the request for the created environment.

    ``` python
    with app.test_request_context(...):
        generate_report()
    ```

    When using the shell, it may be easier to push and pop the context manually to avoid indentation.

    ``` python
    ctx = app.test_request_context(...)
    ctx.push()
    ...
    ctx.pop()
    ```

    Takes the same arguments as Werkzeug’s [`EnvironBuilder`](https://werkzeug.palletsprojects.com/en/2.3.x/test/#werkzeug.test.EnvironBuilder "(in Werkzeug v2.3.x)"), with some defaults from the application. See the linked Werkzeug docs for most of the available arguments. Flask-specific behavior is listed here.

    Parameters:

    - **path** – URL path being requested.
    - **base_url** – Base URL where the app is being served, which `path` is relative to. If not given, built from [`PREFERRED_URL_SCHEME`](../config/index#PREFERRED_URL_SCHEME "PREFERRED_URL_SCHEME"), `subdomain`, [`SERVER_NAME`](../config/index#SERVER_NAME "SERVER_NAME"), and [`APPLICATION_ROOT`](../config/index#APPLICATION_ROOT "APPLICATION_ROOT").
    - **subdomain** – Subdomain name to append to [`SERVER_NAME`](../config/index#SERVER_NAME "SERVER_NAME").
    - **url_scheme** – Scheme to use instead of [`PREFERRED_URL_SCHEME`](../config/index#PREFERRED_URL_SCHEME "PREFERRED_URL_SCHEME").
    - **data** – The request body, either as a string or a dict of form keys and values.
    - **json** – If given, this is serialized as JSON and passed as `data`. Also defaults `content_type` to `application/json`.
    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – other positional arguments passed to [`EnvironBuilder`](https://werkzeug.palletsprojects.com/en/2.3.x/test/#werkzeug.test.EnvironBuilder "(in Werkzeug v2.3.x)").
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – other keyword arguments passed to [`EnvironBuilder`](https://werkzeug.palletsprojects.com/en/2.3.x/test/#werkzeug.test.EnvironBuilder "(in Werkzeug v2.3.x)").

    Return type:

    [RequestContext](#flask.ctx.RequestContext "flask.ctx.RequestContext")
- name: Flask.testing
  id: api/index#flask.Flask.testing
  summary: The testing flag
  description: |-
    `testing`

    The testing flag. Set this to `True` to enable the test mode of Flask extensions (and in the future probably also Flask itself). For example this might activate test helpers that have an additional runtime cost which should not be enabled by default.

    If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the default it’s implicitly enabled.

    This attribute can also be configured from the config with the `TESTING` configuration key. Defaults to `False`.
- name: Flask.trap_http_exception()
  id: api/index#flask.Flask.trap_http_exception
  summary: Checks if an HTTP exception should be trapped or not
  description: |-
    `trap_http_exception(e)`

    Checks if an HTTP exception should be trapped or not. By default this will return `False` for all exceptions except for a bad request key error if `TRAP_BAD_REQUEST_ERRORS` is set to `True`. It also returns `True` if `TRAP_HTTP_EXCEPTIONS` is set to `True`.

    This is called for all HTTP exceptions raised by a view function. If it returns `True` for any exception the error handler for this exception is not called and it shows up as regular exception in the traceback. This is helpful for debugging implicitly raised HTTP exceptions.

    Changelog

    Changed in version 1.0: Bad request errors are not trapped by default in debug mode.

    New in version 0.8.

    Parameters:

    **e** ([Exception](https://docs.python.org/3/library/exceptions.html#Exception "(in Python v3.11)")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: Flask.update_template_context()
  id: api/index#flask.Flask.update_template_context
  summary: Update the template context with some commonly used variables
  description: |-
    `update_template_context(context)`

    Update the template context with some commonly used variables. This injects request, session, config and g into the template context as well as everything template context processors want to inject. Note that the as of Flask 0.6, the original values in the context will not be overridden if a context processor decides to return a value with the same key.

    Parameters:

    **context** ([dict](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)")) – the context as a dictionary that is updated in place to add extra variables.

    Return type:

    None
- name: Flask.url_build_error_handlers
  id: api/index#flask.Flask.url_build_error_handlers
  summary: A list of functions that are called by handle_url_build_error() when url_for() raises a BuildError
  description: |-
    `url_build_error_handlers: list[t.Callable[[Exception, str, dict[str, t.Any]], str]]`

    A list of functions that are called by [`handle_url_build_error()`](#flask.Flask.handle_url_build_error "flask.Flask.handle_url_build_error") when [`url_for()`](#flask.Flask.url_for "flask.Flask.url_for") raises a `BuildError`. Each function is called with `error`, `endpoint` and `values`. If a function returns `None` or raises a `BuildError`, it is skipped. Otherwise, its return value is returned by `url_for`.

    Changelog

    New in version 0.9.
- name: Flask.url_default_functions
  id: api/index#flask.Flask.url_default_functions
  summary: 'A data structure of functions to call to modify the keyword arguments when generating URLs, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests'
  description: |-
    `url_default_functions: dict[ft.AppOrBlueprintKey, list[ft.URLDefaultCallable]]`

    A data structure of functions to call to modify the keyword arguments when generating URLs, in the format `{scope: [functions]}`. The `scope` key is the name of a blueprint the functions are active for, or `None` for all requests.

    To register a function, use the [`url_defaults()`](#flask.Flask.url_defaults "flask.Flask.url_defaults") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Flask.url_defaults()
  id: api/index#flask.Flask.url_defaults
  summary: Callback function for URL defaults for all view functions of the application
  description: |-
    `url_defaults(f)`

    Callback function for URL defaults for all view functions of the application. It’s called with the endpoint and values and should update the values passed in place.

    This is available on both app and blueprint objects. When used on an app, this is called for every request. When used on a blueprint, this is called for requests that the blueprint handles. To register with a blueprint and affect every request, use [`Blueprint.app_url_defaults()`](#flask.Blueprint.app_url_defaults "flask.Blueprint.app_url_defaults").

    Parameters:

    **f** (*T_url_defaults*) –

    Return type:

    *T_url_defaults*
- name: Flask.url_for()
  id: api/index#flask.Flask.url_for
  summary: Generate a URL to the given endpoint with the given values
  description: |-
    `url_for(endpoint, *, _anchor=None, _method=None, _scheme=None, _external=None, **values)`

    Generate a URL to the given endpoint with the given values.

    This is called by [`flask.url_for()`](#flask.url_for "flask.url_for"), and can be called directly as well.

    An *endpoint* is the name of a URL rule, usually added with [`@app.route()`](#flask.Flask.route "flask.Flask.route"), and usually the same name as the view function. A route defined in a [`Blueprint`](#flask.Blueprint "flask.Blueprint") will prepend the blueprint’s name separated by a `.` to the endpoint.

    In some cases, such as email messages, you want URLs to include the scheme and domain, like `https://example.com/hello`. When not in an active request, URLs will be external by default, but this requires setting [`SERVER_NAME`](../config/index#SERVER_NAME "SERVER_NAME") so Flask knows what domain to use. [`APPLICATION_ROOT`](../config/index#APPLICATION_ROOT "APPLICATION_ROOT") and [`PREFERRED_URL_SCHEME`](../config/index#PREFERRED_URL_SCHEME "PREFERRED_URL_SCHEME") should also be configured as needed. This config is only used when not in an active request.

    Functions can be decorated with [`url_defaults()`](#flask.Flask.url_defaults "flask.Flask.url_defaults") to modify keyword arguments before the URL is built.

    If building fails for some reason, such as an unknown endpoint or incorrect values, the app’s [`handle_url_build_error()`](#flask.Flask.handle_url_build_error "flask.Flask.handle_url_build_error") method is called. If that returns a string, that is returned, otherwise a `BuildError` is raised.

    Parameters:

    - **endpoint** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The endpoint name associated with the URL to generate. If this starts with a `.`, the current blueprint name (if any) will be used.
    - **\_anchor** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – If given, append this as `#anchor` to the URL.
    - **\_method** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – If given, generate the URL associated with this method for the endpoint.
    - **\_scheme** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – If given, the URL will have this scheme if it is external.
    - **\_external** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)") *\|* *None*) – If given, prefer the URL to be internal (False) or require it to be external (True). External URLs include the scheme and domain. When not in an active request, URLs are external by default.
    - **values** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – Values to use for the variable parts of the URL rule. Unknown keys are appended as query string arguments, like `?a=b&c=d`.

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")

    Changelog

    New in version 2.2: Moved from `flask.url_for`, which calls this method.
- name: Flask.url_map
  id: api/index#flask.Flask.url_map
  summary: The Map for this instance
  description: |-
    `url_map`

    The [`Map`](https://werkzeug.palletsprojects.com/en/2.3.x/routing/#werkzeug.routing.Map "(in Werkzeug v2.3.x)") for this instance. You can use this to change the routing converters after the class was created but before any routes are connected. Example:

    ``` python
    from werkzeug.routing import BaseConverter

    class ListConverter(BaseConverter):
        def to_python(self, value):
            return value.split(',')
        def to_url(self, values):
            return ','.join(super(ListConverter, self).to_url(value)
                            for value in values)

    app = Flask(__name__)
    app.url_map.converters['list'] = ListConverter
    ```
- name: Flask.url_map_class
  id: api/index#flask.Flask.url_map_class
  summary: null
  description: |-
    `url_map_class`

    alias of [`Map`](https://werkzeug.palletsprojects.com/en/2.3.x/routing/#werkzeug.routing.Map "(in Werkzeug v2.3.x)")
- name: Flask.url_rule_class
  id: api/index#flask.Flask.url_rule_class
  summary: null
  description: |-
    `url_rule_class`

    alias of [`Rule`](https://werkzeug.palletsprojects.com/en/2.3.x/routing/#werkzeug.routing.Rule "(in Werkzeug v2.3.x)")
- name: Flask.url_value_preprocessor()
  id: api/index#flask.Flask.url_value_preprocessor
  summary: Register a URL value preprocessor function for all view functions in the application
  description: |-
    `url_value_preprocessor(f)`

    Register a URL value preprocessor function for all view functions in the application. These functions will be called before the [`before_request()`](#flask.Flask.before_request "flask.Flask.before_request") functions.

    The function can modify the values captured from the matched url before they are passed to the view. For example, this can be used to pop a common language code value and place it in `g` rather than pass it to every view.

    The function is passed the endpoint name and values dict. The return value is ignored.

    This is available on both app and blueprint objects. When used on an app, this is called for every request. When used on a blueprint, this is called for requests that the blueprint handles. To register with a blueprint and affect every request, use [`Blueprint.app_url_value_preprocessor()`](#flask.Blueprint.app_url_value_preprocessor "flask.Blueprint.app_url_value_preprocessor").

    Parameters:

    **f** (*T_url_value_preprocessor*) –

    Return type:

    *T_url_value_preprocessor*
- name: Flask.url_value_preprocessors
  id: api/index#flask.Flask.url_value_preprocessors
  summary: 'A data structure of functions to call to modify the keyword arguments passed to the view function, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests'
  description: |-
    `url_value_preprocessors: dict[ft.AppOrBlueprintKey, list[ft.URLValuePreprocessorCallable]]`

    A data structure of functions to call to modify the keyword arguments passed to the view function, in the format `{scope: [functions]}`. The `scope` key is the name of a blueprint the functions are active for, or `None` for all requests.

    To register a function, use the [`url_value_preprocessor()`](#flask.Flask.url_value_preprocessor "flask.Flask.url_value_preprocessor") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Flask.view_functions
  id: api/index#flask.Flask.view_functions
  summary: A dictionary mapping endpoint names to view functions
  description: |-
    `view_functions: dict[str, t.Callable]`

    A dictionary mapping endpoint names to view functions.

    To register a view function, use the [`route()`](#flask.Flask.route "flask.Flask.route") decorator.

    This data structure is internal. It should not be modified directly and its format may change at any time.
- name: Flask.wsgi_app()
  id: api/index#flask.Flask.wsgi_app
  summary: The actual WSGI application
  description: |-
    `wsgi_app(environ, start_response)`

    The actual WSGI application. This is not implemented in `__call__()` so that middlewares can be applied without losing a reference to the app object. Instead of doing this:

    ``` python
    app = MyMiddleware(app)
    ```

    It’s a better idea to do this instead:

    ``` python
    app.wsgi_app = MyMiddleware(app.wsgi_app)
    ```

    Then you still have the original application object around and can continue to call methods on it.

    Changelog

    Changed in version 0.7: Teardown events for the request and app contexts are called even if an unhandled error occurs. Other events may not be called depending on when an error occurs during dispatch. See [Callbacks and Errors](../reqcontext/index#callbacks-and-errors).

    Parameters:

    - **environ** ([dict](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)")) – A WSGI environment.
    - **start_response** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")) – A callable accepting a status code, a list of headers, and an optional exception context to start the response.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")

    ## Blueprint Objects
- name: FlaskClient
  id: api/index#flask.testing.FlaskClient
  summary: Works like a regular Werkzeug test client but has knowledge about Flask’s contexts to defer the cleanup of the request context until the end of a with block
  description: |-
    `class flask.testing.FlaskClient(*args, **kwargs)`

    Works like a regular Werkzeug test client but has knowledge about Flask’s contexts to defer the cleanup of the request context until the end of a `with` block. For general information about how to use this class refer to [`werkzeug.test.Client`](https://werkzeug.palletsprojects.com/en/2.3.x/test/#werkzeug.test.Client "(in Werkzeug v2.3.x)").

    Changelog

    Changed in version 0.12: `app.test_client()` includes preset default environment, which can be set after instantiation of the `app.test_client()` object in `client.environ_base`.

    Basic usage is outlined in the [Testing Flask Applications](../testing/index) chapter.

    Parameters:

    - **args** (*t.Any*) –
    - **kwargs** (*t.Any*) –
- name: FlaskClient.open()
  id: api/index#flask.testing.FlaskClient.open
  summary: Generate an environ dict from the given arguments, make a request to the application using it, and return the response
  description: |-
    `open(*args, buffered=False, follow_redirects=False, **kwargs)`

    Generate an environ dict from the given arguments, make a request to the application using it, and return the response.

    Parameters:

    - **args** (*t.Any*) – Passed to `EnvironBuilder` to create the environ for the request. If a single arg is passed, it can be an existing `EnvironBuilder` or an environ dict.
    - **buffered** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Convert the iterator returned by the app into a list. If the iterator has a `close()` method, it is called automatically.
    - **follow_redirects** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Make additional requests to follow HTTP redirects until a non-redirect status is returned. `TestResponse.history` lists the intermediate responses.
    - **kwargs** (*t.Any*) –

    Return type:

    TestResponse

    Changelog

    Changed in version 2.1: Removed the `as_tuple` parameter.

    Changed in version 2.0: The request input stream is closed when calling `response.close()`. Input streams for redirects are automatically closed.

    Changed in version 0.5: If a dict is provided as file in the dict for the `data` parameter the content type has to be called `content_type` instead of `mimetype`. This change was made for consistency with `werkzeug.FileWrapper`.

    Changed in version 0.5: Added the `follow_redirects` parameter.
- name: FlaskClient.session_transaction()
  id: api/index#flask.testing.FlaskClient.session_transaction
  summary: When used in combination with a with statement this opens a session transaction
  description: |-
    `session_transaction(*args, **kwargs)`

    When used in combination with a `with` statement this opens a session transaction. This can be used to modify the session that the test client uses. Once the `with` block is left the session is stored back.

    ``` python
    with client.session_transaction() as session:
        session['value'] = 42
    ```

    Internally this is implemented by going through a temporary test request context and since session handling could depend on request variables this function accepts the same arguments as [`test_request_context()`](#flask.Flask.test_request_context "flask.Flask.test_request_context") which are directly passed through.

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Generator](https://docs.python.org/3/library/typing.html#typing.Generator "(in Python v3.11)")\[[SessionMixin](#flask.sessions.SessionMixin "flask.sessions.SessionMixin"), None, None\]

    ## Test CLI Runner
- name: FlaskCliRunner
  id: api/index#flask.testing.FlaskCliRunner
  summary: A CliRunner for testing a Flask app’s CLI commands
  description: |-
    `class flask.testing.FlaskCliRunner(app, **kwargs)`

    A [`CliRunner`](https://click.palletsprojects.com/en/8.1.x/api/#click.testing.CliRunner "(in Click v8.1.x)") for testing a Flask app’s CLI commands. Typically created using [`test_cli_runner()`](#flask.Flask.test_cli_runner "flask.Flask.test_cli_runner"). See [Running Commands with the CLI Runner](../testing/index#testing-cli).

    Parameters:

    - **app** ([Flask](#flask.Flask "flask.Flask")) –
    - **kwargs** (*t.Any*) –
- name: FlaskCliRunner.invoke()
  id: api/index#flask.testing.FlaskCliRunner.invoke
  summary: Invokes a CLI command in an isolated environment
  description: |-
    `invoke(cli=None, args=None, **kwargs)`

    Invokes a CLI command in an isolated environment. See [`CliRunner.invoke`](https://click.palletsprojects.com/en/8.1.x/api/#click.testing.CliRunner.invoke "(in Click v8.1.x)") for full method documentation. See [Running Commands with the CLI Runner](../testing/index#testing-cli) for examples.

    If the `obj` argument is not given, passes an instance of [`ScriptInfo`](#flask.cli.ScriptInfo "flask.cli.ScriptInfo") that knows how to load the Flask app being tested.

    Parameters:

    - **cli** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)") *\|* *None*) – Command object to invoke. Default is the app’s `cli` group.
    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)") *\|* *None*) – List of strings to invoke the command with.
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Returns:

    a [`Result`](https://click.palletsprojects.com/en/8.1.x/api/#click.testing.Result "(in Click v8.1.x)") object.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")

    ## Application Globals

    To share data that is valid for one request only from one function to another, a global variable is not good enough because it would break in threaded environments. Flask provides you with a special object that ensures it is only valid for the active request and that will return different values for each request. In a nutshell: it does the right thing, like it does for [`request`](#flask.request "flask.request") and [`session`](#flask.session "flask.session").
- name: FlaskGroup
  id: api/index#flask.cli.FlaskGroup
  summary: Special subclass of the AppGroup group that supports loading more commands from the configured Flask app
  description: |-
    `class flask.cli.FlaskGroup(add_default_commands=True, create_app=None, add_version_option=True, load_dotenv=True, set_debug_flag=True, **extra)`

    Special subclass of the [`AppGroup`](#flask.cli.AppGroup "flask.cli.AppGroup") group that supports loading more commands from the configured Flask app. Normally a developer does not have to interface with this class but there are some very advanced use cases for which it makes sense to create an instance of this. see [Custom Scripts](../cli/index#custom-scripts).

    Parameters:

    - **add_default_commands** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – if this is True then the default run and shell commands will be added.
    - **add_version_option** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – adds the `--version` option.
    - **create_app** (*t.Callable\[...,* [Flask](#flask.Flask "flask.Flask")*\]* *\|* *None*) – an optional callback that is passed the script info and returns the loaded app.
    - **load_dotenv** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Load the nearest `.env` and `.flaskenv` files to set environment variables. Will also change the working directory to the directory containing the first file found.
    - **set_debug_flag** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Set the app’s debug flag.
    - **extra** (*t.Any*) –

    Changelog

    Changed in version 2.2: Added the `-A/--app`, `--debug/--no-debug`, `-e/--env-file` options.

    Changed in version 2.2: An app context is pushed when running `app.cli` commands, so `@with_appcontext` is no longer required for those commands.

    Changed in version 1.0: If installed, python-dotenv will be used to load environment variables from `.env` and `.flaskenv` files.
- name: FlaskGroup.get_command()
  id: api/index#flask.cli.FlaskGroup.get_command
  summary: Given a context and a command name, this returns a Command object if it exists or returns None
  description: |-
    `get_command(ctx, name)`

    Given a context and a command name, this returns a `Command` object if it exists or returns `None`.
- name: FlaskGroup.list_commands()
  id: api/index#flask.cli.FlaskGroup.list_commands
  summary: Returns a list of subcommand names in the order they should appear
  description: |-
    `list_commands(ctx)`

    Returns a list of subcommand names in the order they should appear.
- name: FlaskGroup.make_context()
  id: api/index#flask.cli.FlaskGroup.make_context
  summary: This function when given an info name and arguments will kick off the parsing and create a new Context
  description: |-
    `make_context(info_name, args, parent=None, **extra)`

    This function when given an info name and arguments will kick off the parsing and create a new `Context`. It does not invoke the actual command callback though.

    To quickly customize the context class used without overriding this method, set the `context_class` attribute.

    Parameters:

    - **info_name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – the info name for this invocation. Generally this is the most descriptive name for the script or command. For the toplevel script it’s usually the name of the script, for commands below it’s the name of the command.
    - **args** ([list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]*) – the arguments to parse as list of strings.
    - **parent** ([Context](https://click.palletsprojects.com/en/8.1.x/api/#click.Context "(in Click v8.1.x)") *\|* *None*) – the parent context if available.
    - **extra** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – extra keyword arguments forwarded to the context constructor.

    Return type:

    [Context](https://click.palletsprojects.com/en/8.1.x/api/#click.Context "(in Click v8.1.x)")

    Changed in version 8.0: Added the `context_class` attribute.
- name: FlaskGroup.parse_args()
  id: api/index#flask.cli.FlaskGroup.parse_args
  summary: Given a context and a list of arguments this creates the parser and parses the arguments, then modifies the context as necessary
  description: |-
    `parse_args(ctx, args)`

    Given a context and a list of arguments this creates the parser and parses the arguments, then modifies the context as necessary. This is automatically invoked by [`make_context()`](#flask.cli.FlaskGroup.make_context "flask.cli.FlaskGroup.make_context").

    Parameters:

    - **ctx** ([Context](https://click.palletsprojects.com/en/8.1.x/api/#click.Context "(in Click v8.1.x)")) –
    - **args** ([list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]*) –

    Return type:

    [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")\]
- name: Form Validation with WTForms
  id: patterns/wtforms/index
  summary: When you have to work with form data submitted by a browser view, code quickly becomes very hard to read
  description: "# Form Validation with WTForms\n\nWhen you have to work with form data submitted by a browser view, code quickly becomes very hard to read. There are libraries out there designed to make this process easier to manage. One of them is [WTForms](https://wtforms.readthedocs.io/) which we will handle here. If you find yourself in the situation of having many forms, you might want to give it a try.\n\nWhen you are working with WTForms you have to define your forms as classes first. I recommend breaking up the application into multiple modules ([Large Applications as Packages](../packages/index)) for that and adding a separate module for the forms.\n\nGetting the most out of WTForms with an Extension\n\nThe [Flask-WTF](https://flask-wtf.readthedocs.io/) extension expands on this pattern and adds a few little helpers that make working with forms and Flask more fun. You can get it from [PyPI](https://pypi.org/project/Flask-WTF/).\n\n## The Forms\n\nThis is an example form for a typical registration page:\n\n``` python\nfrom wtforms import Form, BooleanField, StringField, PasswordField, validators\n\nclass RegistrationForm(Form):\n    username = StringField('Username', [validators.Length(min=4, max=25)])\n    email = StringField('Email Address', [validators.Length(min=6, max=35)])\n    password = PasswordField('New Password', [\n        validators.DataRequired(),\n        validators.EqualTo('confirm', message='Passwords must match')\n    ])\n    confirm = PasswordField('Repeat Password')\n    accept_tos = BooleanField('I accept the TOS', [validators.DataRequired()])\n```\n\n## In the View\n\nIn the view function, the usage of this form looks like this:\n\n``` python\n@app.route('/register', methods=['GET', 'POST'])\ndef register():\n    form = RegistrationForm(request.form)\n    if request.method == 'POST' and form.validate():\n        user = User(form.username.data, form.email.data,\n                    form.password.data)\n        db_session.add(user)\n        flash('Thanks for registering')\n        return redirect(url_for('login'))\n    return render_template('register.html', form=form)\n```\n\nNotice we’re implying that the view is using SQLAlchemy here ([SQLAlchemy in Flask](../sqlalchemy/index)), but that’s not a requirement, of course. Adapt the code as necessary.\n\nThings to remember:\n\n1.  create the form from the request `form` value if the data is submitted via the HTTP `POST` method and `args` if the data is submitted as `GET`.\n2.  to validate the data, call the `validate()` method, which will return `True` if the data validates, `False` otherwise.\n3.  to access individual values from the form, access `form.<NAME>.data`.\n\n## Forms in Templates\n\nNow to the template side. When you pass the form to the templates, you can easily render them there. Look at the following example template to see how easy this is. WTForms does half the form generation for us already. To make it even nicer, we can write a macro that renders a field with label and a list of errors if there are any.\n\nHere’s an example `_formhelpers.html` template with such a macro:\n\n``` html+jinja\n{% macro render_field(field) %}\n  <dt>{{ field.label }}\n  <dd>{{ field(**kwargs)|safe }}\n  {% if field.errors %}\n    <ul class=errors>\n    {% for error in field.errors %}\n      <li>{{ error }}</li>\n    {% endfor %}\n    </ul>\n  {% endif %}\n  </dd>\n{% endmacro %}\n```\n\nThis macro accepts a couple of keyword arguments that are forwarded to WTForm’s field function, which renders the field for us. The keyword arguments will be inserted as HTML attributes. So, for example, you can call `render_field(form.username, class='username')` to add a class to the input element. Note that WTForms returns standard Python strings, so we have to tell Jinja2 that this data is already HTML-escaped with the `|safe` filter.\n\nHere is the `register.html` template for the function we used above, which takes advantage of the `_formhelpers.html` template:\n\n``` html+jinja\n{% from \"_formhelpers.html\" import render_field %}\n<form method=post>\n  <dl>\n    {{ render_field(form.username) }}\n    {{ render_field(form.email) }}\n    {{ render_field(form.password) }}\n    {{ render_field(form.confirm) }}\n    {{ render_field(form.accept_tos) }}\n  </dl>\n  <p><input type=submit value=Register>\n</form>\n```\n\nFor more information about WTForms, head over to the [WTForms website](https://wtforms.readthedocs.io/).\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/wtforms/](https://flask.palletsprojects.com/en/3.0.x/patterns/wtforms/)"
- name: get_flashed_messages()
  id: api/index#flask.get_flashed_messages
  summary: Pulls all flashed messages from the session and returns them
  description: |-
    `flask.get_flashed_messages(with_categories=False, category_filter=())`

    Pulls all flashed messages from the session and returns them. Further calls in the same request to the function will return the same messages. By default just the messages are returned, but when `with_categories` is set to `True`, the return value will be a list of tuples in the form `(category, message)` instead.

    Filter the flashed messages to one or more categories by providing those categories in `category_filter`. This allows rendering categories in separate html blocks. The `with_categories` and `category_filter` arguments are distinct:

    - `with_categories` controls whether categories are returned with message text (`True` gives a tuple, where `False` gives just the message text).
    - `category_filter` filters the messages down to only those matching the provided categories.

    See [Message Flashing](../patterns/flashing/index) for examples.

    Changelog

    Changed in version 0.9: `category_filter` parameter added.

    Changed in version 0.3: `with_categories` parameter added.

    Parameters:

    - **with_categories** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – set to `True` to also receive categories.
    - **category_filter** ([Iterable](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]*) – filter of categories to limit return values. Only categories in the list will be returned.

    Return type:

    [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")\] \| [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.11)")\[[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")\]\]

    ## JSON Support

    Flask uses Python’s built-in [`json`](https://docs.python.org/3/library/json.html#module-json "(in Python v3.11)") module for handling JSON by default. The JSON implementation can be changed by assigning a different provider to [`flask.Flask.json_provider_class`](#flask.Flask.json_provider_class "flask.Flask.json_provider_class") or [`flask.Flask.json`](#flask.Flask.json "flask.Flask.json"). The functions provided by `flask.json` will use methods on `app.json` if an app context is active.

    Jinja’s `|tojson` filter is configured to use the app’s JSON provider. The filter marks the output with `|safe`. Use it to render data inside HTML `<script>` tags.

    ``` html+jinja
    <script>
        const names = {{ names|tojson }};
        renderChart(names, {{ axis_data|tojson }});
    </script>
    ```
- name: get_template_attribute()
  id: api/index#flask.get_template_attribute
  summary: Loads a macro (or variable) a template exports
  description: |-
    `flask.get_template_attribute(template_name, attribute)`

    Loads a macro (or variable) a template exports. This can be used to invoke a macro from within Python code. If you for example have a template named `_cider.html` with the following contents:

    ``` html+jinja
    {% macro hello(name) %}Hello {{ name }}!{% endmacro %}
    ```

    You can access this from Python code like this:

    ``` python
    hello = get_template_attribute('_cider.html', 'hello')
    return hello('World')
    ```

    Changelog

    New in version 0.2.

    Parameters:

    - **template_name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – the name of the template
    - **attribute** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – the name of the variable of macro to access

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")

    ## Configuration
- name: gevent
  id: deploying/gevent/index
  summary: Prefer using Gunicorn or uWSGI with gevent workers rather than using gevent directly
  description: "# gevent\n\nPrefer using [Gunicorn](../gunicorn/index) or [uWSGI](../uwsgi/index) with gevent workers rather than using [gevent](https://www.gevent.org/) directly. Gunicorn and uWSGI provide much more configurable and production-tested servers.\n\n[gevent](https://www.gevent.org/) allows writing asynchronous, coroutine-based code that looks like standard synchronous Python. It uses [greenlet](https://greenlet.readthedocs.io/en/latest/) to enable task switching without writing `async/await` or using `asyncio`.\n\n[eventlet](../eventlet/index) is another library that does the same thing. Certain dependencies you have, or other considerations, may affect which of the two you choose to use.\n\ngevent provides a WSGI server that can handle many connections at once instead of one per worker process. You must actually use gevent in your own code to see any benefit to using the server.\n\n## Installing\n\nWhen using gevent, greenlet\\>=1.0 is required, otherwise context locals such as `request` will not work as expected. When using PyPy, PyPy\\>=7.3.7 is required.\n\nCreate a virtualenv, install your application, then install `gevent`.\n\n``` text\n$ cd hello-app\n$ python -m venv .venv\n$ . .venv/bin/activate\n$ pip install .  # install your application\n$ pip install gevent\n```\n\n## Running\n\nTo use gevent to serve your application, write a script that imports its `WSGIServer`, as well as your app or app factory.\n\n`wsgi.py`\n\n``` python\nfrom gevent.pywsgi import WSGIServer\nfrom hello import create_app\n\napp = create_app()\nhttp_server = WSGIServer((\"127.0.0.1\", 8000), app)\nhttp_server.serve_forever()\n```\n\n``` text\n$ python wsgi.py\n```\n\nNo output is shown when the server starts.\n\n## Binding Externally\n\ngevent should not be run as root because it would cause your application code to run as root, which is not secure. However, this means it will not be possible to bind to port 80 or 443. Instead, a reverse proxy such as [nginx](../nginx/index) or [Apache httpd](../apache-httpd/index) should be used in front of gevent.\n\nYou can bind to all external IPs on a non-privileged port by using `0.0.0.0` in the server arguments shown in the previous section. Don’t do this when using a reverse proxy setup, otherwise it will be possible to bypass the proxy.\n\n`0.0.0.0` is not a valid address to navigate to, you’d use a specific IP address in your browser.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/deploying/gevent/](https://flask.palletsprojects.com/en/3.0.x/deploying/gevent/)"
- name: Gunicorn
  id: deploying/gunicorn/index
  summary: Gunicorn is a pure Python WSGI server with simple configuration and multiple worker implementations for performance tuning
  description: "# Gunicorn\n\n[Gunicorn](https://gunicorn.org/) is a pure Python WSGI server with simple configuration and multiple worker implementations for performance tuning.\n\n- It tends to integrate easily with hosting platforms.\n- It does not support Windows (but does run on WSL).\n- It is easy to install as it does not require additional dependencies or compilation.\n- It has built-in async worker support using gevent or eventlet.\n\nThis page outlines the basics of running Gunicorn. Be sure to read its [documentation](https://docs.gunicorn.org/) and use `gunicorn --help` to understand what features are available.\n\n## Installing\n\nGunicorn is easy to install, as it does not require external dependencies or compilation. It runs on Windows only under WSL.\n\nCreate a virtualenv, install your application, then install `gunicorn`.\n\n``` text\n$ cd hello-app\n$ python -m venv .venv\n$ . .venv/bin/activate\n$ pip install .  # install your application\n$ pip install gunicorn\n```\n\n## Running\n\nThe only required argument to Gunicorn tells it how to load your Flask application. The syntax is `{module_import}:{app_variable}`. `module_import` is the dotted import name to the module with your application. `app_variable` is the variable with the application. It can also be a function call (with any arguments) if you’re using the app factory pattern.\n\n``` text\n# equivalent to 'from hello import app'\n$ gunicorn -w 4 'hello:app'\n\n# equivalent to 'from hello import create_app; create_app()'\n$ gunicorn -w 4 'hello:create_app()'\n\nStarting gunicorn 20.1.0\nListening at: http://127.0.0.1:8000 (x)\nUsing worker: sync\nBooting worker with pid: x\nBooting worker with pid: x\nBooting worker with pid: x\nBooting worker with pid: x\n```\n\nThe `-w` option specifies the number of processes to run; a starting value could be `CPU * 2`. The default is only 1 worker, which is probably not what you want for the default worker type.\n\nLogs for each request aren’t shown by default, only worker info and errors are shown. To show access logs on stdout, use the `--access-logfile=-` option.\n\n## Binding Externally\n\nGunicorn should not be run as root because it would cause your application code to run as root, which is not secure. However, this means it will not be possible to bind to port 80 or 443. Instead, a reverse proxy such as [nginx](../nginx/index) or [Apache httpd](../apache-httpd/index) should be used in front of Gunicorn.\n\nYou can bind to all external IPs on a non-privileged port using the `-b 0.0.0.0` option. Don’t do this when using a reverse proxy setup, otherwise it will be possible to bypass the proxy.\n\n``` text\n$ gunicorn -w 4 -b 0.0.0.0 'hello:create_app()'\nListening at: http://0.0.0.0:8000 (x)\n```\n\n`0.0.0.0` is not a valid address to navigate to, you’d use a specific IP address in your browser.\n\n## Async with gevent or eventlet\n\nThe default sync worker is appropriate for many use cases. If you need asynchronous support, Gunicorn provides workers using either [gevent](https://www.gevent.org/) or [eventlet](https://eventlet.net/). This is not the same as Python’s `async/await`, or the ASGI server spec. You must actually use gevent/eventlet in your own code to see any benefit to using the workers.\n\nWhen using either gevent or eventlet, greenlet\\>=1.0 is required, otherwise context locals such as `request` will not work as expected. When using PyPy, PyPy\\>=7.3.7 is required.\n\nTo use gevent:\n\n``` text\n$ gunicorn -k gevent 'hello:create_app()'\nStarting gunicorn 20.1.0\nListening at: http://127.0.0.1:8000 (x)\nUsing worker: gevent\nBooting worker with pid: x\n```\n\nTo use eventlet:\n\n``` text\n$ gunicorn -k eventlet 'hello:create_app()'\nStarting gunicorn 20.1.0\nListening at: http://127.0.0.1:8000 (x)\nUsing worker: eventlet\nBooting worker with pid: x\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/deploying/gunicorn/](https://flask.palletsprojects.com/en/3.0.x/deploying/gunicorn/)"
- name: Handling Application Errors
  id: errorhandling/index
  summary: Applications fail, servers fail
  description: "# Handling Application Errors\n\nApplications fail, servers fail. Sooner or later you will see an exception in production. Even if your code is 100% correct, you will still see exceptions from time to time. Why? Because everything else involved will fail. Here are some situations where perfectly fine code can lead to server errors:\n\n- the client terminated the request early and the application was still reading from the incoming data\n- the database server was overloaded and could not handle the query\n- a filesystem is full\n- a harddrive crashed\n- a backend server overloaded\n- a programming error in a library you are using\n- network connection of the server to another system failed\n\nAnd that’s just a small sample of issues you could be facing. So how do we deal with that sort of problem? By default if your application runs in production mode, and an exception is raised Flask will display a very simple page for you and log the exception to the [`logger`](../api/index#flask.Flask.logger \"flask.Flask.logger\").\n\nBut there is more you can do, and we will cover some better setups to deal with errors including custom exceptions and 3rd party tools.\n\n## Error Logging Tools\n\nSending error mails, even if just for critical ones, can become overwhelming if enough users are hitting the error and log files are typically never looked at. This is why we recommend using [Sentry](https://sentry.io/) for dealing with application errors. It’s available as a source-available project [on GitHub](https://github.com/getsentry/sentry) and is also available as a [hosted version](https://sentry.io/signup/) which you can try for free. Sentry aggregates duplicate errors, captures the full stack trace and local variables for debugging, and sends you mails based on new errors or frequency thresholds.\n\nTo use Sentry you need to install the `sentry-sdk` client with extra `flask` dependencies.\n\n``` text\n$ pip install sentry-sdk[flask]\n```\n\nAnd then add this to your Flask app:\n\n``` python\nimport sentry_sdk\nfrom sentry_sdk.integrations.flask import FlaskIntegration\n\nsentry_sdk.init('YOUR_DSN_HERE', integrations=[FlaskIntegration()])\n```\n\nThe `YOUR_DSN_HERE` value needs to be replaced with the DSN value you get from your Sentry installation.\n\nAfter installation, failures leading to an Internal Server Error are automatically reported to Sentry and from there you can receive error notifications.\n\nSee also:\n\n- Sentry also supports catching errors from a worker queue (RQ, Celery, etc.) in a similar fashion. See the [Python SDK docs](https://docs.sentry.io/platforms/python/) for more information.\n- [Flask-specific documentation](https://docs.sentry.io/platforms/python/guides/flask/)\n\n## Error Handlers\n\nWhen an error occurs in Flask, an appropriate [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status) will be returned. 400-499 indicate errors with the client’s request data, or about the data requested. 500-599 indicate errors with the server or application itself.\n\nYou might want to show custom error pages to the user when an error occurs. This can be done by registering error handlers.\n\nAn error handler is a function that returns a response when a type of error is raised, similar to how a view is a function that returns a response when a request URL is matched. It is passed the instance of the error being handled, which is most likely a [`HTTPException`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.HTTPException \"(in Werkzeug v2.3.x)\").\n\nThe status code of the response will not be set to the handler’s code. Make sure to provide the appropriate HTTP status code when returning a response from a handler.\n\n### Registering\n\nRegister handlers by decorating a function with [`errorhandler()`](../api/index#flask.Flask.errorhandler \"flask.Flask.errorhandler\"). Or use [`register_error_handler()`](../api/index#flask.Flask.register_error_handler \"flask.Flask.register_error_handler\") to register the function later. Remember to set the error code when returning the response.\n\n``` python\n@app.errorhandler(werkzeug.exceptions.BadRequest)\ndef handle_bad_request(e):\n    return 'bad request!', 400\n\n# or, without the decorator\napp.register_error_handler(400, handle_bad_request)\n```\n\n[`werkzeug.exceptions.HTTPException`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.HTTPException \"(in Werkzeug v2.3.x)\") subclasses like [`BadRequest`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.BadRequest \"(in Werkzeug v2.3.x)\") and their HTTP codes are interchangeable when registering handlers. (`BadRequest.code == 400`)\n\nNon-standard HTTP codes cannot be registered by code because they are not known by Werkzeug. Instead, define a subclass of [`HTTPException`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.HTTPException \"(in Werkzeug v2.3.x)\") with the appropriate code and register and raise that exception class.\n\n``` python\nclass InsufficientStorage(werkzeug.exceptions.HTTPException):\n    code = 507\n    description = 'Not enough storage space.'\n\napp.register_error_handler(InsufficientStorage, handle_507)\n\nraise InsufficientStorage()\n```\n\nHandlers can be registered for any exception class, not just [`HTTPException`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.HTTPException \"(in Werkzeug v2.3.x)\") subclasses or HTTP status codes. Handlers can be registered for a specific class, or for all subclasses of a parent class.\n\n### Handling\n\nWhen building a Flask application you *will* run into exceptions. If some part of your code breaks while handling a request (and you have no error handlers registered), a “500 Internal Server Error” ([`InternalServerError`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.InternalServerError \"(in Werkzeug v2.3.x)\")) will be returned by default. Similarly, “404 Not Found” ([`NotFound`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.NotFound \"(in Werkzeug v2.3.x)\")) error will occur if a request is sent to an unregistered route. If a route receives an unallowed request method, a “405 Method Not Allowed” ([`MethodNotAllowed`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.MethodNotAllowed \"(in Werkzeug v2.3.x)\")) will be raised. These are all subclasses of [`HTTPException`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.HTTPException \"(in Werkzeug v2.3.x)\") and are provided by default in Flask.\n\nFlask gives you the ability to raise any HTTP exception registered by Werkzeug. However, the default HTTP exceptions return simple exception pages. You might want to show custom error pages to the user when an error occurs. This can be done by registering error handlers.\n\nWhen Flask catches an exception while handling a request, it is first looked up by code. If no handler is registered for the code, Flask looks up the error by its class hierarchy; the most specific handler is chosen. If no handler is registered, [`HTTPException`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.HTTPException \"(in Werkzeug v2.3.x)\") subclasses show a generic message about their code, while other exceptions are converted to a generic “500 Internal Server Error”.\n\nFor example, if an instance of [`ConnectionRefusedError`](https://docs.python.org/3/library/exceptions.html#ConnectionRefusedError \"(in Python v3.11)\") is raised, and a handler is registered for [`ConnectionError`](https://docs.python.org/3/library/exceptions.html#ConnectionError \"(in Python v3.11)\") and [`ConnectionRefusedError`](https://docs.python.org/3/library/exceptions.html#ConnectionRefusedError \"(in Python v3.11)\"), the more specific [`ConnectionRefusedError`](https://docs.python.org/3/library/exceptions.html#ConnectionRefusedError \"(in Python v3.11)\") handler is called with the exception instance to generate the response.\n\nHandlers registered on the blueprint take precedence over those registered globally on the application, assuming a blueprint is handling the request that raises the exception. However, the blueprint cannot handle 404 routing errors because the 404 occurs at the routing level before the blueprint can be determined.\n\n### Generic Exception Handlers\n\nIt is possible to register error handlers for very generic base classes such as `HTTPException` or even `Exception`. However, be aware that these will catch more than you might expect.\n\nFor example, an error handler for `HTTPException` might be useful for turning the default HTML errors pages into JSON. However, this handler will trigger for things you don’t cause directly, such as 404 and 405 errors during routing. Be sure to craft your handler carefully so you don’t lose information about the HTTP error.\n\n``` python\nfrom flask import json\nfrom werkzeug.exceptions import HTTPException\n\n@app.errorhandler(HTTPException)\ndef handle_exception(e):\n    \"\"\"Return JSON instead of HTML for HTTP errors.\"\"\"\n    # start with the correct headers and status code from the error\n    response = e.get_response()\n    # replace the body with JSON\n    response.data = json.dumps({\n        \"code\": e.code,\n        \"name\": e.name,\n        \"description\": e.description,\n    })\n    response.content_type = \"application/json\"\n    return response\n```\n\nAn error handler for `Exception` might seem useful for changing how all errors, even unhandled ones, are presented to the user. However, this is similar to doing `except Exception:` in Python, it will capture *all* otherwise unhandled errors, including all HTTP status codes.\n\nIn most cases it will be safer to register handlers for more specific exceptions. Since `HTTPException` instances are valid WSGI responses, you could also pass them through directly.\n\n``` python\nfrom werkzeug.exceptions import HTTPException\n\n@app.errorhandler(Exception)\ndef handle_exception(e):\n    # pass through HTTP errors\n    if isinstance(e, HTTPException):\n        return e\n\n    # now you're handling non-HTTP exceptions only\n    return render_template(\"500_generic.html\", e=e), 500\n```\n\nError handlers still respect the exception class hierarchy. If you register handlers for both `HTTPException` and `Exception`, the `Exception` handler will not handle `HTTPException` subclasses because the `HTTPException` handler is more specific.\n\n### Unhandled Exceptions\n\nWhen there is no error handler registered for an exception, a 500 Internal Server Error will be returned instead. See [`flask.Flask.handle_exception()`](../api/index#flask.Flask.handle_exception \"flask.Flask.handle_exception\") for information about this behavior.\n\nIf there is an error handler registered for `InternalServerError`, this will be invoked. As of Flask 1.1.0, this error handler will always be passed an instance of `InternalServerError`, not the original unhandled error.\n\nThe original error is available as `e.original_exception`.\n\nAn error handler for “500 Internal Server Error” will be passed uncaught exceptions in addition to explicit 500 errors. In debug mode, a handler for “500 Internal Server Error” will not be used. Instead, the interactive debugger will be shown.\n\n## Custom Error Pages\n\nSometimes when building a Flask application, you might want to raise a [`HTTPException`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.HTTPException \"(in Werkzeug v2.3.x)\") to signal to the user that something is wrong with the request. Fortunately, Flask comes with a handy [`abort()`](../api/index#flask.abort \"flask.abort\") function that aborts a request with a HTTP error from werkzeug as desired. It will also provide a plain black and white error page for you with a basic description, but nothing fancy.\n\nDepending on the error code it is less or more likely for the user to actually see such an error.\n\nConsider the code below, we might have a user profile route, and if the user fails to pass a username we can raise a “400 Bad Request”. If the user passes a username and we can’t find it, we raise a “404 Not Found”.\n\n``` python\nfrom flask import abort, render_template, request\n\n# a username needs to be supplied in the query args\n# a successful request would be like /profile?username=jack\n@app.route(\"/profile\")\ndef user_profile():\n    username = request.arg.get(\"username\")\n    # if a username isn't supplied in the request, return a 400 bad request\n    if username is None:\n        abort(400)\n\n    user = get_user(username=username)\n    # if a user can't be found by their username, return 404 not found\n    if user is None:\n        abort(404)\n\n    return render_template(\"profile.html\", user=user)\n```\n\nHere is another example implementation for a “404 Page Not Found” exception:\n\n``` python\nfrom flask import render_template\n\n@app.errorhandler(404)\ndef page_not_found(e):\n    # note that we set the 404 status explicitly\n    return render_template('404.html'), 404\n```\n\nWhen using [Application Factories](../patterns/appfactories/index):\n\n``` python\nfrom flask import Flask, render_template\n\ndef page_not_found(e):\n  return render_template('404.html'), 404\n\ndef create_app(config_filename):\n    app = Flask(__name__)\n    app.register_error_handler(404, page_not_found)\n    return app\n```\n\nAn example template might be this:\n\n``` html+jinja\n{% extends \"layout.html\" %}\n{% block title %}Page Not Found{% endblock %}\n{% block body %}\n  <h1>Page Not Found</h1>\n  <p>What you were looking for is just not there.\n  <p><a href=\"{{ url_for('index') }}\">go somewhere nice</a>\n{% endblock %}\n```\n\n### Further Examples\n\nThe above examples wouldn’t actually be an improvement on the default exception pages. We can create a custom 500.html template like this:\n\n``` html+jinja\n{% extends \"layout.html\" %}\n{% block title %}Internal Server Error{% endblock %}\n{% block body %}\n  <h1>Internal Server Error</h1>\n  <p>Oops... we seem to have made a mistake, sorry!</p>\n  <p><a href=\"{{ url_for('index') }}\">Go somewhere nice instead</a>\n{% endblock %}\n```\n\nIt can be implemented by rendering the template on “500 Internal Server Error”:\n\n``` python\nfrom flask import render_template\n\n@app.errorhandler(500)\ndef internal_server_error(e):\n    # note that we set the 500 status explicitly\n    return render_template('500.html'), 500\n```\n\nWhen using [Application Factories](../patterns/appfactories/index):\n\n``` python\nfrom flask import Flask, render_template\n\ndef internal_server_error(e):\n  return render_template('500.html'), 500\n\ndef create_app():\n    app = Flask(__name__)\n    app.register_error_handler(500, internal_server_error)\n    return app\n```\n\nWhen using [Modular Applications with Blueprints](../blueprints/index):\n\n``` python\nfrom flask import Blueprint\n\nblog = Blueprint('blog', __name__)\n\n# as a decorator\n@blog.errorhandler(500)\ndef internal_server_error(e):\n    return render_template('500.html'), 500\n\n# or with register_error_handler\nblog.register_error_handler(500, internal_server_error)\n```\n\n## Blueprint Error Handlers\n\nIn [Modular Applications with Blueprints](../blueprints/index), most error handlers will work as expected. However, there is a caveat concerning handlers for 404 and 405 exceptions. These error handlers are only invoked from an appropriate `raise` statement or a call to `abort` in another of the blueprint’s view functions; they are not invoked by, e.g., an invalid URL access.\n\nThis is because the blueprint does not “own” a certain URL space, so the application instance has no way of knowing which blueprint error handler it should run if given an invalid URL. If you would like to execute different handling strategies for these errors based on URL prefixes, they may be defined at the application level using the `request` proxy object.\n\n``` python\nfrom flask import jsonify, render_template\n\n# at the application level\n# not the blueprint level\n@app.errorhandler(404)\ndef page_not_found(e):\n    # if a request is in our blog URL space\n    if request.path.startswith('/blog/'):\n        # we return a custom blog 404 page\n        return render_template(\"blog/404.html\"), 404\n    else:\n        # otherwise we return our generic site-wide 404 page\n        return render_template(\"404.html\"), 404\n\n@app.errorhandler(405)\ndef method_not_allowed(e):\n    # if a request has the wrong method to our API\n    if request.path.startswith('/api/'):\n        # we return a json saying so\n        return jsonify(message=\"Method Not Allowed\"), 405\n    else:\n        # otherwise we return a generic site-wide 405 page\n        return render_template(\"405.html\"), 405\n```\n\n## Returning API Errors as JSON\n\nWhen building APIs in Flask, some developers realise that the built-in exceptions are not expressive enough for APIs and that the content type of *text/html* they are emitting is not very useful for API consumers.\n\nUsing the same techniques as above and [`jsonify()`](../api/index#flask.json.jsonify \"flask.json.jsonify\") we can return JSON responses to API errors. [`abort()`](../api/index#flask.abort \"flask.abort\") is called with a `description` parameter. The error handler will use that as the JSON error message, and set the status code to 404.\n\n``` python\nfrom flask import abort, jsonify\n\n@app.errorhandler(404)\ndef resource_not_found(e):\n    return jsonify(error=str(e)), 404\n\n@app.route(\"/cheese\")\ndef get_one_cheese():\n    resource = get_resource()\n\n    if resource is None:\n        abort(404, description=\"Resource not found\")\n\n    return jsonify(resource)\n```\n\nWe can also create custom exception classes. For instance, we can introduce a new custom exception for an API that can take a proper human readable message, a status code for the error and some optional payload to give more context for the error.\n\nThis is a simple example:\n\n``` python\nfrom flask import jsonify, request\n\nclass InvalidAPIUsage(Exception):\n    status_code = 400\n\n    def __init__(self, message, status_code=None, payload=None):\n        super().__init__()\n        self.message = message\n        if status_code is not None:\n            self.status_code = status_code\n        self.payload = payload\n\n    def to_dict(self):\n        rv = dict(self.payload or ())\n        rv['message'] = self.message\n        return rv\n\n@app.errorhandler(InvalidAPIUsage)\ndef invalid_api_usage(e):\n    return jsonify(e.to_dict()), e.status_code\n\n# an API app route for getting user information\n# a correct request might be /api/user?user_id=420\n@app.route(\"/api/user\")\ndef user_api(user_id):\n    user_id = request.arg.get(\"user_id\")\n    if not user_id:\n        raise InvalidAPIUsage(\"No user id provided!\")\n\n    user = get_user(user_id=user_id)\n    if not user:\n        raise InvalidAPIUsage(\"No such user!\", status_code=404)\n\n    return jsonify(user.to_dict())\n```\n\nA view can now raise that exception with an error message. Additionally some extra payload can be provided as a dictionary through the `payload` parameter.\n\n## Logging\n\nSee [Logging](../logging/index) for information about how to log exceptions, such as by emailing them to admins.\n\n## Debugging\n\nSee [Debugging Application Errors](../debugging/index) for information about how to debug errors in development and production.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/errorhandling/](https://flask.palletsprojects.com/en/3.0.x/errorhandling/)"
- name: has_app_context()
  id: api/index#flask.has_app_context
  summary: Works like has_request_context() but for the application context
  description: |-
    `flask.has_app_context()`

    Works like [`has_request_context()`](#flask.has_request_context "flask.has_request_context") but for the application context. You can also just do a boolean check on the [`current_app`](#flask.current_app "flask.current_app") object instead.

    Changelog

    New in version 0.9.

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: has_request_context()
  id: api/index#flask.has_request_context
  summary: If you have code that wants to test if a request context is there or not this function can be used
  description: |-
    `flask.has_request_context()`

    If you have code that wants to test if a request context is there or not this function can be used. For instance, you may want to take advantage of request information if the request object is available, but fail silently if it is unavailable.

    ``` python
    class User(db.Model):

        def __init__(self, username, remote_addr=None):
            self.username = username
            if remote_addr is None and has_request_context():
                remote_addr = request.remote_addr
            self.remote_addr = remote_addr
    ```

    Alternatively you can also just test any of the context bound objects (such as [`request`](#flask.request "flask.request") or [`g`](#flask.g "flask.g")) for truthness:

    ``` python
    class User(db.Model):

        def __init__(self, username, remote_addr=None):
            self.username = username
            if remote_addr is None and request:
                remote_addr = request.remote_addr
            self.remote_addr = remote_addr
    ```

    Changelog

    New in version 0.7.

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: Installation
  id: installation/index
  summary: We recommend using the latest version of Python
  description: "# Installation\n\n## Python Version\n\nWe recommend using the latest version of Python. Flask supports Python 3.8 and newer.\n\n## Dependencies\n\nThese distributions will be installed automatically when installing Flask.\n\n- [Werkzeug](https://palletsprojects.com/p/werkzeug/) implements WSGI, the standard Python interface between applications and servers.\n- [Jinja](https://palletsprojects.com/p/jinja/) is a template language that renders the pages your application serves.\n- [MarkupSafe](https://palletsprojects.com/p/markupsafe/) comes with Jinja. It escapes untrusted input when rendering templates to avoid injection attacks.\n- [ItsDangerous](https://palletsprojects.com/p/itsdangerous/) securely signs data to ensure its integrity. This is used to protect Flask’s session cookie.\n- [Click](https://palletsprojects.com/p/click/) is a framework for writing command line applications. It provides the `flask` command and allows adding custom management commands.\n- [Blinker](https://blinker.readthedocs.io/) provides support for [Signals](../signals/index).\n\n### Optional dependencies\n\nThese distributions will not be installed automatically. Flask will detect and use them if you install them.\n\n- [python-dotenv](https://github.com/theskumar/python-dotenv#readme) enables support for [Environment Variables From dotenv](../cli/index#dotenv) when running `flask` commands.\n- [Watchdog](https://pythonhosted.org/watchdog/) provides a faster, more efficient reloader for the development server.\n\n### greenlet\n\nYou may choose to use gevent or eventlet with your application. In this case, greenlet\\>=1.0 is required. When using PyPy, PyPy\\>=7.3.7 is required.\n\nThese are not minimum supported versions, they only indicate the first versions that added necessary features. You should use the latest versions of each.\n\n## Virtual environments\n\nUse a virtual environment to manage the dependencies for your project, both in development and in production.\n\nWhat problem does a virtual environment solve? The more Python projects you have, the more likely it is that you need to work with different versions of Python libraries, or even Python itself. Newer versions of libraries for one project can break compatibility in another project.\n\nVirtual environments are independent groups of Python libraries, one for each project. Packages installed for one project will not affect other projects or the operating system’s packages.\n\nPython comes bundled with the [`venv`](https://docs.python.org/3/library/venv.html#module-venv \"(in Python v3.11)\") module to create virtual environments.\n\n### Create an environment\n\nCreate a project folder and a `.venv` folder within:\n\n``` text\n$ mkdir myproject\n$ cd myproject\n$ python3 -m venv .venv\n```\n\n``` text\n> mkdir myproject\n> cd myproject\n> py -3 -m venv .venv\n```\n\n### Activate the environment\n\nBefore you work on your project, activate the corresponding environment:\n\n``` text\n$ . .venv/bin/activate\n```\n\n``` text\n> .venv\\Scripts\\activate\n```\n\nYour shell prompt will change to show the name of the activated environment.\n\n## Install Flask\n\nWithin the activated environment, use the following command to install Flask:\n\n``` sh\n$ pip install Flask\n```\n\nFlask is now installed. Check out the [Quickstart](../quickstart/index) or go to the [Documentation Overview](https://flask.palletsprojects.com/en/3.0.x/).\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/installation/](https://flask.palletsprojects.com/en/3.0.x/installation/)"
- name: JavaScript, fetch, and JSON
  id: patterns/javascript/index
  summary: You may want to make your HTML page dynamic, by changing data without reloading the entire page
  description: "# JavaScript, fetch, and JSON\n\nYou may want to make your HTML page dynamic, by changing data without reloading the entire page. Instead of submitting an HTML `<form>` and performing a redirect to re-render the template, you can add [JavaScript](https://developer.mozilla.org/Web/JavaScript) that calls [`fetch()`](https://developer.mozilla.org/Web/API/Fetch_API) and replaces content on the page.\n\n[`fetch()`](https://developer.mozilla.org/Web/API/Fetch_API) is the modern, built-in JavaScript solution to making requests from a page. You may have heard of other “AJAX” methods and libraries, such as [`XMLHttpRequest()`](https://developer.mozilla.org/Web/API/XMLHttpRequest) or [jQuery](https://jquery.com/). These are no longer needed in modern browsers, although you may choose to use them or another library depending on your application’s requirements. These docs will only focus on built-in JavaScript features.\n\n## Rendering Templates\n\nIt is important to understand the difference between templates and JavaScript. Templates are rendered on the server, before the response is sent to the user’s browser. JavaScript runs in the user’s browser, after the template is rendered and sent. Therefore, it is impossible to use JavaScript to affect how the Jinja template is rendered, but it is possible to render data into the JavaScript that will run.\n\nTo provide data to JavaScript when rendering the template, use the [`tojson()`](https://jinja.palletsprojects.com/en/3.1.x/templates/#jinja-filters.tojson \"(in Jinja v3.1.x)\") filter in a `<script>` block. This will convert the data to a valid JavaScript object, and ensure that any unsafe HTML characters are rendered safely. If you do not use the `tojson` filter, you will get a `SyntaxError` in the browser console.\n\n``` python\ndata = generate_report()\nreturn render_template(\"report.html\", chart_data=data)\n```\n\n``` jinja\n<script>\n    const chart_data = {{ chart_data|tojson }}\n    chartLib.makeChart(chart_data)\n</script>\n```\n\nA less common pattern is to add the data to a `data-` attribute on an HTML tag. In this case, you must use single quotes around the value, not double quotes, otherwise you will produce invalid or unsafe HTML.\n\n``` jinja\n<div data-chart='{{ chart_data|tojson }}'></div>\n```\n\n## Generating URLs\n\nThe other way to get data from the server to JavaScript is to make a request for it. First, you need to know the URL to request.\n\nThe simplest way to generate URLs is to continue to use [`url_for()`](../../api/index#flask.url_for \"flask.url_for\") when rendering the template. For example:\n\n``` javascript\nconst user_url = {{ url_for(\"user\", id=current_user.id)|tojson }}\nfetch(user_url).then(...)\n```\n\nHowever, you might need to generate a URL based on information you only know in JavaScript. As discussed above, JavaScript runs in the user’s browser, not as part of the template rendering, so you can’t use `url_for` at that point.\n\nIn this case, you need to know the “root URL” under which your application is served. In simple setups, this is `/`, but it might also be something else, like `https://example.com/myapp/`.\n\nA simple way to tell your JavaScript code about this root is to set it as a global variable when rendering the template. Then you can use it when generating URLs from JavaScript.\n\n``` javascript\nconst SCRIPT_ROOT = {{ request.script_root|tojson }}\nlet user_id = ...  // do something to get a user id from the page\nlet user_url = `${SCRIPT_ROOT}/user/${user_id}`\nfetch(user_url).then(...)\n```\n\n## Making a Request with `fetch`\n\n[`fetch()`](https://developer.mozilla.org/Web/API/Fetch_API) takes two arguments, a URL and an object with other options, and returns a [`Promise`](https://developer.mozilla.org/Web/JavaScript/Reference/Global_Objects/Promise). We won’t cover all the available options, and will only use `then()` on the promise, not other callbacks or `await` syntax. Read the linked MDN docs for more information about those features.\n\nBy default, the GET method is used. If the response contains JSON, it can be used with a `then()` callback chain.\n\n``` javascript\nconst room_url = {{ url_for(\"room_detail\", id=room.id)|tojson }}\nfetch(room_url)\n    .then(response => response.json())\n    .then(data => {\n        // data is a parsed JSON object\n    })\n```\n\nTo send data, use a data method such as POST, and pass the `body` option. The most common types for data are form data or JSON data.\n\nTo send form data, pass a populated [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object. This uses the same format as an HTML form, and would be accessed with `request.form` in a Flask view.\n\n``` javascript\nlet data = new FormData()\ndata.append(\"name\", \"Flask Room\")\ndata.append(\"description\", \"Talk about Flask here.\")\nfetch(room_url, {\n    \"method\": \"POST\",\n    \"body\": data,\n}).then(...)\n```\n\nIn general, prefer sending request data as form data, as would be used when submitting an HTML form. JSON can represent more complex data, but unless you need that it’s better to stick with the simpler format. When sending JSON data, the `Content-Type: application/json` header must be sent as well, otherwise Flask will return a 400 error.\n\n``` javascript\nlet data = {\n    \"name\": \"Flask Room\",\n    \"description\": \"Talk about Flask here.\",\n}\nfetch(room_url, {\n    \"method\": \"POST\",\n    \"headers\": {\"Content-Type\": \"application/json\"},\n    \"body\": JSON.stringify(data),\n}).then(...)\n```\n\n## Following Redirects\n\nA response might be a redirect, for example if you logged in with JavaScript instead of a traditional HTML form, and your view returned a redirect instead of JSON. JavaScript requests do follow redirects, but they don’t change the page. If you want to make the page change you can inspect the response and apply the redirect manually.\n\n``` javascript\nfetch(\"/login\", {\"body\": ...}).then(\n    response => {\n        if (response.redirected) {\n            window.location = response.url\n        } else {\n            showLoginError()\n        }\n    }\n)\n```\n\n## Replacing Content\n\nA response might be new HTML, either a new section of the page to add or replace, or an entirely new page. In general, if you’re returning the entire page, it would be better to handle that with a redirect as shown in the previous section. The following example shows how to replace a `<div>` with the HTML returned by a request.\n\n``` html\n<div id=\"geology-fact\">\n    {{ include \"geology_fact.html\" }}\n</div>\n<script>\n    const geology_url = {{ url_for(\"geology_fact\")|tojson }}\n    const geology_div = getElementById(\"geology-fact\")\n    fetch(geology_url)\n        .then(response => response.text)\n        .then(text => geology_div.innerHTML = text)\n</script>\n```\n\n## Return JSON from Views\n\nTo return a JSON object from your API view, you can directly return a dict from the view. It will be serialized to JSON automatically.\n\n``` python\n@app.route(\"/user/<int:id>\")\ndef user_detail(id):\n    user = User.query.get_or_404(id)\n    return {\n        \"username\": User.username,\n        \"email\": User.email,\n        \"picture\": url_for(\"static\", filename=f\"users/{id}/profile.png\"),\n    }\n```\n\nIf you want to return another JSON type, use the [`jsonify()`](../../api/index#flask.json.jsonify \"flask.json.jsonify\") function, which creates a response object with the given data serialized to JSON.\n\n``` python\nfrom flask import jsonify\n\n@app.route(\"/users\")\ndef user_list():\n    users = User.query.order_by(User.name).all()\n    return jsonify([u.to_json() for u in users])\n```\n\nIt is usually not a good idea to return file data in a JSON response. JSON cannot represent binary data directly, so it must be base64 encoded, which can be slow, takes more bandwidth to send, and is not as easy to cache. Instead, serve files using one view, and generate a URL to the desired file to include in the JSON. Then the client can make a separate request to get the linked resource after getting the JSON.\n\n## Receiving JSON in Views\n\nUse the [`json`](../../api/index#flask.Request.json \"flask.Request.json\") property of the [`request`](../../api/index#flask.request \"flask.request\") object to decode the request’s body as JSON. If the body is not valid JSON, or the `Content-Type` header is not set to `application/json`, a 400 Bad Request error will be raised.\n\n``` python\nfrom flask import request\n\n@app.post(\"/user/<int:id>\")\ndef user_update(id):\n    user = User.query.get_or_404(id)\n    user.update_from_json(request.json)\n    db.session.commit()\n    return user.to_json()\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/javascript/](https://flask.palletsprojects.com/en/3.0.x/patterns/javascript/)"
- name: jsonify()
  id: api/index#flask.json.jsonify
  summary: Serialize the given arguments as JSON, and return a Response object with the application/json mimetype
  description: |-
    `flask.json.jsonify(*args, **kwargs)`

    Serialize the given arguments as JSON, and return a [`Response`](#flask.Response "flask.Response") object with the `application/json` mimetype. A dict or list returned from a view will be converted to a JSON response automatically without needing to call this.

    This requires an active request or application context, and calls [`app.json.response()`](#flask.json.provider.JSONProvider.response "flask.json.provider.JSONProvider.response").

    In debug mode, the output is formatted with indentation to make it easier to read. This may also be controlled by the provider.

    Either positional or keyword arguments can be given, not both. If no arguments are given, `None` is serialized.

    Parameters:

    - **args** (*t.Any*) – A single value to serialize, or multiple values to treat as a list to serialize.
    - **kwargs** (*t.Any*) – Treat as a dict to serialize.

    Return type:

    [Response](#flask.Response "flask.Response")

    Changelog

    Changed in version 2.2: Calls `current_app.json.response`, allowing an app to override the behavior.

    Changed in version 2.0.2: [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal "(in Python v3.11)") is supported by converting to a string.

    Changed in version 0.11: Added support for serializing top-level arrays. This was a security risk in ancient browsers. See [JSON Security](../security/index#security-json).

    New in version 0.2.
- name: JSONProvider
  id: api/index#flask.json.provider.JSONProvider
  summary: A standard set of JSON operations for an application
  description: |-
    `class flask.json.provider.JSONProvider(app)`

    A standard set of JSON operations for an application. Subclasses of this can be used to customize JSON behavior or use different JSON libraries.

    To implement a provider for a specific library, subclass this base class and implement at least [`dumps()`](#flask.json.provider.JSONProvider.dumps "flask.json.provider.JSONProvider.dumps") and [`loads()`](#flask.json.provider.JSONProvider.loads "flask.json.provider.JSONProvider.loads"). All other methods have default implementations.

    To use a different provider, either subclass `Flask` and set [`json_provider_class`](#flask.Flask.json_provider_class "flask.Flask.json_provider_class") to a provider class, or set [`app.json`](#flask.Flask.json "flask.Flask.json") to an instance of the class.

    Parameters:

    **app** (*App*) – An application instance. This will be stored as a `weakref.proxy` on the `_app` attribute.

    Changelog

    New in version 2.2.
- name: JSONProvider.dump()
  id: api/index#flask.json.provider.JSONProvider.dump
  summary: Serialize data as JSON and write to a file
  description: |-
    `dump(obj, fp, **kwargs)`

    Serialize data as JSON and write to a file.

    Parameters:

    - **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – The data to serialize.
    - **fp** ([IO](https://docs.python.org/3/library/typing.html#typing.IO "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]*) – A file opened for writing text. Should use the UTF-8 encoding to be valid JSON.
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – May be passed to the underlying JSON library.

    Return type:

    None
- name: JSONProvider.dumps()
  id: api/index#flask.json.provider.JSONProvider.dumps
  summary: Serialize data as JSON
  description: |-
    `dumps(obj, **kwargs)`

    Serialize data as JSON.

    Parameters:

    - **obj** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – The data to serialize.
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – May be passed to the underlying JSON library.

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: JSONProvider.load()
  id: api/index#flask.json.provider.JSONProvider.load
  summary: Deserialize data as JSON read from a file
  description: |-
    `load(fp, **kwargs)`

    Deserialize data as JSON read from a file.

    Parameters:

    - **fp** ([IO](https://docs.python.org/3/library/typing.html#typing.IO "(in Python v3.11)")) – A file opened for reading text or UTF-8 bytes.
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – May be passed to the underlying JSON library.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: JSONProvider.loads()
  id: api/index#flask.json.provider.JSONProvider.loads
  summary: Deserialize data as JSON
  description: |-
    `loads(s, **kwargs)`

    Deserialize data as JSON.

    Parameters:

    - **s** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.11)")) – Text or UTF-8 bytes.
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – May be passed to the underlying JSON library.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: JSONProvider.response()
  id: api/index#flask.json.provider.JSONProvider.response
  summary: Serialize the given arguments as JSON, and return a Response object with the application/json mimetype
  description: |-
    `response(*args, **kwargs)`

    Serialize the given arguments as JSON, and return a [`Response`](#flask.Response "flask.Response") object with the `application/json` mimetype.

    The [`jsonify()`](#flask.json.jsonify "flask.json.jsonify") function calls this method for the current application.

    Either positional or keyword arguments can be given, not both. If no arguments are given, `None` is serialized.

    Parameters:

    - **args** (*t.Any*) – A single value to serialize, or multiple values to treat as a list to serialize.
    - **kwargs** (*t.Any*) – Treat as a dict to serialize.

    Return type:

    [Response](#flask.Response "flask.Response")
- name: JSONTag
  id: api/index#flask.json.tag.JSONTag
  summary: Base class for defining type tags for TaggedJSONSerializer
  description: |-
    `class flask.json.tag.JSONTag(serializer)`

    Base class for defining type tags for [`TaggedJSONSerializer`](#flask.json.tag.TaggedJSONSerializer "flask.json.tag.TaggedJSONSerializer").

    Parameters:

    **serializer** ([TaggedJSONSerializer](#flask.json.tag.TaggedJSONSerializer "flask.json.tag.TaggedJSONSerializer")) –
- name: JSONTag.check()
  id: api/index#flask.json.tag.JSONTag.check
  summary: Check if the given value should be tagged by this tag
  description: |-
    `check(value)`

    Check if the given value should be tagged by this tag.

    Parameters:

    **value** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: JSONTag.key
  id: api/index#flask.json.tag.JSONTag.key
  summary: The tag to mark the serialized object with
  description: |-
    `key: str | None = None`

    The tag to mark the serialized object with. If `None`, this tag is only used as an intermediate step during tagging.
- name: JSONTag.tag()
  id: api/index#flask.json.tag.JSONTag.tag
  summary: Convert the value to a valid JSON type and add the tag structure around it
  description: |-
    `tag(value)`

    Convert the value to a valid JSON type and add the tag structure around it.

    Parameters:

    **value** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: JSONTag.to_json()
  id: api/index#flask.json.tag.JSONTag.to_json
  summary: Convert the Python object to an object that is a valid JSON type
  description: |-
    `to_json(value)`

    Convert the Python object to an object that is a valid JSON type. The tag will be added later.

    Parameters:

    **value** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: JSONTag.to_python()
  id: api/index#flask.json.tag.JSONTag.to_python
  summary: Convert the JSON representation back to the correct type
  description: |-
    `to_python(value)`

    Convert the JSON representation back to the correct type. The tag will already be removed.

    Parameters:

    **value** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")

    Let’s see an example that adds support for [`OrderedDict`](https://docs.python.org/3/library/collections.html#collections.OrderedDict "(in Python v3.11)"). Dicts don’t have an order in JSON, so to handle this we will dump the items as a list of `[key, value]` pairs. Subclass [`JSONTag`](#flask.json.tag.JSONTag "flask.json.tag.JSONTag") and give it the new key `' od'` to identify the type. The session serializer processes dicts first, so insert the new tag at the front of the order since `OrderedDict` must be processed before `dict`.

    ``` python
    from flask.json.tag import JSONTag

    class TagOrderedDict(JSONTag):
        __slots__ = ('serializer',)
        key = ' od'

        def check(self, value):
            return isinstance(value, OrderedDict)

        def to_json(self, value):
            return [[k, self.serializer.tag(v)] for k, v in iteritems(value)]

        def to_python(self, value):
            return OrderedDict(value)

    app.session_interface.serializer.register(TagOrderedDict, index=0)
    ```

    ## Template Rendering
- name: Large Applications as Packages
  id: patterns/packages/index
  summary: While this is fine for small applications, for larger applications it’s a good idea to use a package instead of a module
  description: "# Large Applications as Packages\n\nImagine a simple flask application structure that looks like this:\n\n``` python\n/yourapplication\n    yourapplication.py\n    /static\n        style.css\n    /templates\n        layout.html\n        index.html\n        login.html\n        ...\n```\n\nWhile this is fine for small applications, for larger applications it’s a good idea to use a package instead of a module. The [Tutorial](https://flask.palletsprojects.com/en/3.0.x/tutorial/) is structured to use the package pattern, see the [example code](https://github.com/pallets/flask/tree/3.0.0/examples/tutorial).\n\n## Simple Packages\n\nTo convert that into a larger one, just create a new folder `yourapplication` inside the existing one and move everything below it. Then rename `yourapplication.py` to `__init__.py`. (Make sure to delete all `.pyc` files first, otherwise things would most likely break)\n\nYou should then end up with something like that:\n\n``` python\n/yourapplication\n    /yourapplication\n        __init__.py\n        /static\n            style.css\n        /templates\n            layout.html\n            index.html\n            login.html\n            ...\n```\n\nBut how do you run your application now? The naive `python yourapplication/__init__.py` will not work. Let’s just say that Python does not want modules in packages to be the startup file. But that is not a big problem, just add a new file called `pyproject.toml` next to the inner `yourapplication` folder with the following contents:\n\n``` toml\n[project]\nname = \"yourapplication\"\ndependencies = [\n    \"flask\",\n]\n\n[build-system]\nrequires = [\"flit_core<4\"]\nbuild-backend = \"flit_core.buildapi\"\n```\n\nInstall your application so it is importable:\n\n``` text\n$ pip install -e .\n```\n\nTo use the `flask` command and run your application you need to set the `--app` option that tells Flask where to find the application instance:\n\n``` text\n$ flask --app yourapplication run\n```\n\nWhat did we gain from this? Now we can restructure the application a bit into multiple modules. The only thing you have to remember is the following quick checklist:\n\n1.  the `Flask` application object creation has to be in the `__init__.py` file. That way each module can import it safely and the `__name__` variable will resolve to the correct package.\n2.  all the view functions (the ones with a [`route()`](../../api/index#flask.Flask.route \"flask.Flask.route\") decorator on top) have to be imported in the `__init__.py` file. Not the object itself, but the module it is in. Import the view module **after the application object is created**.\n\nHere’s an example `__init__.py`:\n\n``` python\nfrom flask import Flask\napp = Flask(__name__)\n\nimport yourapplication.views\n```\n\nAnd this is what `views.py` would look like:\n\n``` python\nfrom yourapplication import app\n\n@app.route('/')\ndef index():\n    return 'Hello World!'\n```\n\nYou should then end up with something like that:\n\n``` python\n/yourapplication\n    pyproject.toml\n    /yourapplication\n        __init__.py\n        views.py\n        /static\n            style.css\n        /templates\n            layout.html\n            index.html\n            login.html\n            ...\n```\n\nCircular Imports\n\nEvery Python programmer hates them, and yet we just added some: circular imports (That’s when two modules depend on each other. In this case `views.py` depends on `__init__.py`). Be advised that this is a bad idea in general but here it is actually fine. The reason for this is that we are not actually using the views in `__init__.py` and just ensuring the module is imported and we are doing that at the bottom of the file.\n\n## Working with Blueprints\n\nIf you have larger applications it’s recommended to divide them into smaller groups where each group is implemented with the help of a blueprint. For a gentle introduction into this topic refer to the [Modular Applications with Blueprints](../../blueprints/index) chapter of the documentation.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/packages/](https://flask.palletsprojects.com/en/3.0.x/patterns/packages/)"
- name: Lazily Loading Views
  id: patterns/lazyloading/index
  summary: Flask is usually used with the decorators
  description: "# Lazily Loading Views\n\nFlask is usually used with the decorators. Decorators are simple and you have the URL right next to the function that is called for that specific URL. However there is a downside to this approach: it means all your code that uses decorators has to be imported upfront or Flask will never actually find your function.\n\nThis can be a problem if your application has to import quick. It might have to do that on systems like Google’s App Engine or other systems. So if you suddenly notice that your application outgrows this approach you can fall back to a centralized URL mapping.\n\nThe system that enables having a central URL map is the [`add_url_rule()`](../../api/index#flask.Flask.add_url_rule \"flask.Flask.add_url_rule\") function. Instead of using decorators, you have a file that sets up the application with all URLs.\n\n## Converting to Centralized URL Map\n\nImagine the current application looks somewhat like this:\n\n``` python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    pass\n\n@app.route('/user/<username>')\ndef user(username):\n    pass\n```\n\nThen, with the centralized approach you would have one file with the views (`views.py`) but without any decorator:\n\n``` python\ndef index():\n    pass\n\ndef user(username):\n    pass\n```\n\nAnd then a file that sets up an application which maps the functions to URLs:\n\n``` python\nfrom flask import Flask\nfrom yourapplication import views\napp = Flask(__name__)\napp.add_url_rule('/', view_func=views.index)\napp.add_url_rule('/user/<username>', view_func=views.user)\n```\n\n## Loading Late\n\nSo far we only split up the views and the routing, but the module is still loaded upfront. The trick is to actually load the view function as needed. This can be accomplished with a helper class that behaves just like a function but internally imports the real function on first use:\n\n``` python\nfrom werkzeug.utils import import_string, cached_property\n\nclass LazyView(object):\n\n    def __init__(self, import_name):\n        self.__module__, self.__name__ = import_name.rsplit('.', 1)\n        self.import_name = import_name\n\n    @cached_property\n    def view(self):\n        return import_string(self.import_name)\n\n    def __call__(self, *args, **kwargs):\n        return self.view(*args, **kwargs)\n```\n\nWhat’s important here is is that `__module__` and `__name__` are properly set. This is used by Flask internally to figure out how to name the URL rules in case you don’t provide a name for the rule yourself.\n\nThen you can define your central place to combine the views like this:\n\n``` python\nfrom flask import Flask\nfrom yourapplication.helpers import LazyView\napp = Flask(__name__)\napp.add_url_rule('/',\n                 view_func=LazyView('yourapplication.views.index'))\napp.add_url_rule('/user/<username>',\n                 view_func=LazyView('yourapplication.views.user'))\n```\n\nYou can further optimize this in terms of amount of keystrokes needed to write this by having a function that calls into [`add_url_rule()`](../../api/index#flask.Flask.add_url_rule \"flask.Flask.add_url_rule\") by prefixing a string with the project name and a dot, and by wrapping `view_func` in a `LazyView` as needed.\n\n``` python\ndef url(import_name, url_rules=[], **options):\n    view = LazyView(f\"yourapplication.{import_name}\")\n    for url_rule in url_rules:\n        app.add_url_rule(url_rule, view_func=view, **options)\n\n# add a single route to the index view\nurl('views.index', ['/'])\n\n# add two routes to a single function endpoint\nurl_rules = ['/user/','/user/<username>']\nurl('views.user', url_rules)\n```\n\nOne thing to keep in mind is that before and after request handlers have to be in a file that is imported upfront to work properly on the first request. The same goes for any kind of remaining decorator.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/lazyloading/](https://flask.palletsprojects.com/en/3.0.x/patterns/lazyloading/)"
- name: load()
  id: api/index#flask.json.load
  summary: Deserialize data as JSON read from a file
  description: |-
    `flask.json.load(fp, **kwargs)`

    Deserialize data as JSON read from a file.

    If [`current_app`](#flask.current_app "flask.current_app") is available, it will use its [`app.json.load()`](#flask.json.provider.JSONProvider.load "flask.json.provider.JSONProvider.load") method, otherwise it will use [`json.load()`](https://docs.python.org/3/library/json.html#json.load "(in Python v3.11)").

    Parameters:

    - **fp** ([IO](https://docs.python.org/3/library/typing.html#typing.IO "(in Python v3.11)")) – A file opened for reading text or UTF-8 bytes.
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – Arguments passed to the `load` implementation.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")

    Changelog

    Changed in version 2.3: The `app` parameter was removed.

    Changed in version 2.2: Calls `current_app.json.load`, allowing an app to override the behavior.

    Changed in version 2.2: The `app` parameter will be removed in Flask 2.3.

    Changed in version 2.0: `encoding` will be removed in Flask 2.1. The file must be text mode, or binary mode with UTF-8 bytes.
- name: load_dotenv()
  id: api/index#flask.cli.load_dotenv
  summary: Load “dotenv” files in order of precedence to set environment variables
  description: |-
    `flask.cli.load_dotenv(path=None)`

    Load “dotenv” files in order of precedence to set environment variables.

    If an env var is already set it is not overwritten, so earlier files in the list are preferred over later files.

    This is a no-op if [python-dotenv](https://github.com/theskumar/python-dotenv#readme) is not installed.

    Parameters:

    **path** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)") *\|* *None*) – Load the file at this location instead of searching.

    Returns:

    `True` if a file was loaded.

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")

    Changelog

    Changed in version 2.0: The current directory is not changed to the location of the loaded file.

    Changed in version 2.0: When loading the env files, set the default encoding to UTF-8.

    Changed in version 1.1.0: Returns `False` when python-dotenv is not installed, or when the given path isn’t a file.

    New in version 1.0.
- name: loads()
  id: api/index#flask.json.loads
  summary: Deserialize data as JSON
  description: |-
    `flask.json.loads(s, **kwargs)`

    Deserialize data as JSON.

    If [`current_app`](#flask.current_app "flask.current_app") is available, it will use its [`app.json.loads()`](#flask.json.provider.JSONProvider.loads "flask.json.provider.JSONProvider.loads") method, otherwise it will use [`json.loads()`](https://docs.python.org/3/library/json.html#json.loads "(in Python v3.11)").

    Parameters:

    - **s** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.11)")) – Text or UTF-8 bytes.
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – Arguments passed to the `loads` implementation.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")

    Changelog

    Changed in version 2.3: The `app` parameter was removed.

    Changed in version 2.2: Calls `current_app.json.loads`, allowing an app to override the behavior.

    Changed in version 2.0: `encoding` will be removed in Flask 2.1. The data must be a string or UTF-8 bytes.

    Changed in version 1.0.3: `app` can be passed directly, rather than requiring an app context for configuration.
- name: Logging
  id: logging/index
  summary: Flask uses standard Python logging
  description: "# Logging\n\nFlask uses standard Python [`logging`](https://docs.python.org/3/library/logging.html#module-logging \"(in Python v3.11)\"). Messages about your Flask application are logged with [`app.logger`](../api/index#flask.Flask.logger \"flask.Flask.logger\"), which takes the same name as [`app.name`](../api/index#flask.Flask.name \"flask.Flask.name\"). This logger can also be used to log your own messages.\n\n``` python\n@app.route('/login', methods=['POST'])\ndef login():\n    user = get_user(request.form['username'])\n\n    if user.check_password(request.form['password']):\n        login_user(user)\n        app.logger.info('%s logged in successfully', user.username)\n        return redirect(url_for('index'))\n    else:\n        app.logger.info('%s failed to log in', user.username)\n        abort(401)\n```\n\nIf you don’t configure logging, Python’s default log level is usually ‘warning’. Nothing below the configured level will be visible.\n\n## Basic Configuration\n\nWhen you want to configure logging for your project, you should do it as soon as possible when the program starts. If [`app.logger`](../api/index#flask.Flask.logger \"flask.Flask.logger\") is accessed before logging is configured, it will add a default handler. If possible, configure logging before creating the application object.\n\nThis example uses [`dictConfig()`](https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig \"(in Python v3.11)\") to create a logging configuration similar to Flask’s default, except for all logs:\n\n``` python\nfrom logging.config import dictConfig\n\ndictConfig({\n    'version': 1,\n    'formatters': {'default': {\n        'format': '[%(asctime)s] %(levelname)s in %(module)s: %(message)s',\n    }},\n    'handlers': {'wsgi': {\n        'class': 'logging.StreamHandler',\n        'stream': 'ext://flask.logging.wsgi_errors_stream',\n        'formatter': 'default'\n    }},\n    'root': {\n        'level': 'INFO',\n        'handlers': ['wsgi']\n    }\n})\n\napp = Flask(__name__)\n```\n\n### Default Configuration\n\nIf you do not configure logging yourself, Flask will add a [`StreamHandler`](https://docs.python.org/3/library/logging.handlers.html#logging.StreamHandler \"(in Python v3.11)\") to [`app.logger`](../api/index#flask.Flask.logger \"flask.Flask.logger\") automatically. During requests, it will write to the stream specified by the WSGI server in `environ['wsgi.errors']` (which is usually [`sys.stderr`](https://docs.python.org/3/library/sys.html#sys.stderr \"(in Python v3.11)\")). Outside a request, it will log to [`sys.stderr`](https://docs.python.org/3/library/sys.html#sys.stderr \"(in Python v3.11)\").\n\n### Removing the Default Handler\n\nIf you configured logging after accessing [`app.logger`](../api/index#flask.Flask.logger \"flask.Flask.logger\"), and need to remove the default handler, you can import and remove it:\n\n``` python\nfrom flask.logging import default_handler\n\napp.logger.removeHandler(default_handler)\n```\n\n## Email Errors to Admins\n\nWhen running the application on a remote server for production, you probably won’t be looking at the log messages very often. The WSGI server will probably send log messages to a file, and you’ll only check that file if a user tells you something went wrong.\n\nTo be proactive about discovering and fixing bugs, you can configure a [`logging.handlers.SMTPHandler`](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SMTPHandler \"(in Python v3.11)\") to send an email when errors and higher are logged.\n\n``` python\nimport logging\nfrom logging.handlers import SMTPHandler\n\nmail_handler = SMTPHandler(\n    mailhost='127.0.0.1',\n    fromaddr='server-error@example.com',\n    toaddrs=['admin@example.com'],\n    subject='Application Error'\n)\nmail_handler.setLevel(logging.ERROR)\nmail_handler.setFormatter(logging.Formatter(\n    '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n))\n\nif not app.debug:\n    app.logger.addHandler(mail_handler)\n```\n\nThis requires that you have an SMTP server set up on the same server. See the Python docs for more information about configuring the handler.\n\n## Injecting Request Information\n\nSeeing more information about the request, such as the IP address, may help debugging some errors. You can subclass [`logging.Formatter`](https://docs.python.org/3/library/logging.html#logging.Formatter \"(in Python v3.11)\") to inject your own fields that can be used in messages. You can change the formatter for Flask’s default handler, the mail handler defined above, or any other handler.\n\n``` python\nfrom flask import has_request_context, request\nfrom flask.logging import default_handler\n\nclass RequestFormatter(logging.Formatter):\n    def format(self, record):\n        if has_request_context():\n            record.url = request.url\n            record.remote_addr = request.remote_addr\n        else:\n            record.url = None\n            record.remote_addr = None\n\n        return super().format(record)\n\nformatter = RequestFormatter(\n    '[%(asctime)s] %(remote_addr)s requested %(url)s\\n'\n    '%(levelname)s in %(module)s: %(message)s'\n)\ndefault_handler.setFormatter(formatter)\nmail_handler.setFormatter(formatter)\n```\n\n## Other Libraries\n\nOther libraries may use logging extensively, and you want to see relevant messages from those logs too. The simplest way to do this is to add handlers to the root logger instead of only the app logger.\n\n``` python\nfrom flask.logging import default_handler\n\nroot = logging.getLogger()\nroot.addHandler(default_handler)\nroot.addHandler(mail_handler)\n```\n\nDepending on your project, it may be more useful to configure each logger you care about separately, instead of configuring only the root logger.\n\n``` python\nfor logger in (\n    app.logger,\n    logging.getLogger('sqlalchemy'),\n    logging.getLogger('other_package'),\n):\n    logger.addHandler(default_handler)\n    logger.addHandler(mail_handler)\n```\n\n### Werkzeug\n\nWerkzeug logs basic request/response information to the `'werkzeug'` logger. If the root logger has no handlers configured, Werkzeug adds a [`StreamHandler`](https://docs.python.org/3/library/logging.handlers.html#logging.StreamHandler \"(in Python v3.11)\") to its logger.\n\n### Flask Extensions\n\nDepending on the situation, an extension may choose to log to [`app.logger`](../api/index#flask.Flask.logger \"flask.Flask.logger\") or its own named logger. Consult each extension’s documentation for details.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/logging/](https://flask.palletsprojects.com/en/3.0.x/logging/)"
- name: make_response()
  id: api/index#flask.make_response
  summary: Sometimes it is necessary to set additional headers in a view
  description: |-
    `flask.make_response(*args)`

    Sometimes it is necessary to set additional headers in a view. Because views do not have to return response objects but can return a value that is converted into a response object by Flask itself, it becomes tricky to add headers to it. This function can be called instead of using a return and you will get a response object which you can use to attach headers.

    If view looked like this and you want to add a new header:

    ``` python
    def index():
        return render_template('index.html', foo=42)
    ```

    You can now do something like this:

    ``` python
    def index():
        response = make_response(render_template('index.html', foo=42))
        response.headers['X-Parachutes'] = 'parachutes are cool'
        return response
    ```

    This function accepts the very same arguments you can return from a view function. This for example creates a response with a 404 error code:

    ``` python
    response = make_response(render_template('not_found.html'), 404)
    ```

    The other use case of this function is to force the return value of a view function into a response which is helpful with view decorators:

    ``` python
    response = make_response(view_function())
    response.headers['X-Parachutes'] = 'parachutes are cool'
    ```

    Internally this function does the following things:

    - if no arguments are passed, it creates a new response argument
    - if one argument is passed, [`flask.Flask.make_response()`](#flask.Flask.make_response "flask.Flask.make_response") is invoked with it.
    - if more than one argument is passed, the arguments are passed to the [`flask.Flask.make_response()`](#flask.Flask.make_response "flask.Flask.make_response") function as tuple.

    Changelog

    New in version 0.6.

    Parameters:

    **args** (*t.Any*) –

    Return type:

    [Response](#flask.Response "flask.Response")
- name: MAX_CONTENT_LENGTH
  id: config/index#MAX_CONTENT_LENGTH
  summary: Don’t read more than this many bytes from the incoming request data
  belongs_to: Configuration Handling
  description: |-
    `MAX_CONTENT_LENGTH`

    Don’t read more than this many bytes from the incoming request data. If not set and the request does not specify a `CONTENT_LENGTH`, no data will be read for security.

    Default: `None`
- name: MAX_COOKIE_SIZE
  id: config/index#MAX_COOKIE_SIZE
  summary: Warn if cookie headers are larger than this many bytes
  belongs_to: Configuration Handling
  description: "`MAX_COOKIE_SIZE`\n\nWarn if cookie headers are larger than this many bytes. Defaults to `4093`. Larger cookies may be silently ignored by browsers. Set to `0` to disable the warning.\n\nChangelog\n\nChanged in version 2.3: `JSON_AS_ASCII`, `JSON_SORT_KEYS`, `JSONIFY_MIMETYPE`, and `JSONIFY_PRETTYPRINT_REGULAR` were removed. The default `app.json` provider has equivalent attributes instead.\n\nChanged in version 2.3: `ENV` was removed.\n\nChanged in version 2.2: Removed `PRESERVE_CONTEXT_ON_EXCEPTION`.\n\nChanged in version 1.0: `LOGGER_NAME` and `LOGGER_HANDLER_POLICY` were removed. See [Logging](../logging/index) for information about configuration.\n\nAdded `ENV` to reflect the `FLASK_ENV` environment variable.\n\nAdded [`SESSION_COOKIE_SAMESITE`](#SESSION_COOKIE_SAMESITE \"SESSION_COOKIE_SAMESITE\") to control the session cookie’s `SameSite` option.\n\nAdded [`MAX_COOKIE_SIZE`](#MAX_COOKIE_SIZE \"MAX_COOKIE_SIZE\") to control a warning from Werkzeug.\n\nNew in version 0.11: `SESSION_REFRESH_EACH_REQUEST`, `TEMPLATES_AUTO_RELOAD`, `LOGGER_HANDLER_POLICY`, `EXPLAIN_TEMPLATE_LOADING`\n\nNew in version 0.10: `JSON_AS_ASCII`, `JSON_SORT_KEYS`, `JSONIFY_PRETTYPRINT_REGULAR`\n\nNew in version 0.9: `PREFERRED_URL_SCHEME`\n\nNew in version 0.8: `TRAP_BAD_REQUEST_ERRORS`, `TRAP_HTTP_EXCEPTIONS`, `APPLICATION_ROOT`, `SESSION_COOKIE_DOMAIN`, `SESSION_COOKIE_PATH`, `SESSION_COOKIE_HTTPONLY`, `SESSION_COOKIE_SECURE`\n\nNew in version 0.7: `PROPAGATE_EXCEPTIONS`, `PRESERVE_CONTEXT_ON_EXCEPTION`\n\nNew in version 0.6: `MAX_CONTENT_LENGTH`\n\nNew in version 0.5: `SERVER_NAME`\n\nNew in version 0.4: `LOGGER_NAME`\n\n## Configuring from Python Files\n\nConfiguration becomes more useful if you can store it in a separate file, ideally located outside the actual application package. You can deploy your application, then separately configure it for the specific deployment.\n\nA common pattern is this:\n\n``` python\napp = Flask(__name__)\napp.config.from_object('yourapplication.default_settings')\napp.config.from_envvar('YOURAPPLICATION_SETTINGS')\n```\n\nThis first loads the configuration from the `yourapplication.default_settings` module and then overrides the values with the contents of the file the `YOURAPPLICATION_SETTINGS` environment variable points to. This environment variable can be set in the shell before starting the server:\n\n``` text\n$ export YOURAPPLICATION_SETTINGS=/path/to/settings.cfg\n$ flask run\n * Running on http://127.0.0.1:5000/\n```\n\n``` text\n$ set -x YOURAPPLICATION_SETTINGS /path/to/settings.cfg\n$ flask run\n * Running on http://127.0.0.1:5000/\n```\n\n``` text\n> set YOURAPPLICATION_SETTINGS=\\path\\to\\settings.cfg\n> flask run\n * Running on http://127.0.0.1:5000/\n```\n\n``` text\n> $env:YOURAPPLICATION_SETTINGS = \"\\path\\to\\settings.cfg\"\n> flask run\n * Running on http://127.0.0.1:5000/\n```\n\nThe configuration files themselves are actual Python files. Only values in uppercase are actually stored in the config object later on. So make sure to use uppercase letters for your config keys.\n\nHere is an example of a configuration file:\n\n``` python\n# Example configuration\nSECRET_KEY = '192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'\n```\n\nMake sure to load the configuration very early on, so that extensions have the ability to access the configuration when starting up. There are other methods on the config object as well to load from individual files. For a complete reference, read the [`Config`](../api/index#flask.Config \"flask.Config\") object’s documentation.\n\n## Configuring from Data Files\n\nIt is also possible to load configuration from a file in a format of your choice using [`from_file()`](../api/index#flask.Config.from_file \"flask.Config.from_file\"). For example to load from a TOML file:\n\n``` python\nimport tomllib\napp.config.from_file(\"config.toml\", load=tomllib.load, text=False)\n```\n\nOr from a JSON file:\n\n``` python\nimport json\napp.config.from_file(\"config.json\", load=json.load)\n```\n\n## Configuring from Environment Variables\n\nIn addition to pointing to configuration files using environment variables, you may find it useful (or necessary) to control your configuration values directly from the environment. Flask can be instructed to load all environment variables starting with a specific prefix into the config using [`from_prefixed_env()`](../api/index#flask.Config.from_prefixed_env \"flask.Config.from_prefixed_env\").\n\nEnvironment variables can be set in the shell before starting the server:\n\n``` text\n$ export FLASK_SECRET_KEY=\"5f352379324c22463451387a0aec5d2f\"\n$ export FLASK_MAIL_ENABLED=false\n$ flask run\n * Running on http://127.0.0.1:5000/\n```\n\n``` text\n$ set -x FLASK_SECRET_KEY \"5f352379324c22463451387a0aec5d2f\"\n$ set -x FLASK_MAIL_ENABLED false\n$ flask run\n * Running on http://127.0.0.1:5000/\n```\n\n``` text\n> set FLASK_SECRET_KEY=\"5f352379324c22463451387a0aec5d2f\"\n> set FLASK_MAIL_ENABLED=false\n> flask run\n * Running on http://127.0.0.1:5000/\n```\n\n``` text\n> $env:FLASK_SECRET_KEY = \"5f352379324c22463451387a0aec5d2f\"\n> $env:FLASK_MAIL_ENABLED = \"false\"\n> flask run\n * Running on http://127.0.0.1:5000/\n```\n\nThe variables can then be loaded and accessed via the config with a key equal to the environment variable name without the prefix i.e.\n\n``` python\napp.config.from_prefixed_env()\napp.config[\"SECRET_KEY\"]  # Is \"5f352379324c22463451387a0aec5d2f\"\n```\n\nThe prefix is `FLASK_` by default. This is configurable via the `prefix` argument of [`from_prefixed_env()`](../api/index#flask.Config.from_prefixed_env \"flask.Config.from_prefixed_env\").\n\nValues will be parsed to attempt to convert them to a more specific type than strings. By default [`json.loads()`](https://docs.python.org/3/library/json.html#json.loads \"(in Python v3.11)\") is used, so any valid JSON value is possible, including lists and dicts. This is configurable via the `loads` argument of [`from_prefixed_env()`](../api/index#flask.Config.from_prefixed_env \"flask.Config.from_prefixed_env\").\n\nWhen adding a boolean value with the default JSON parsing, only “true” and “false”, lowercase, are valid values. Keep in mind that any non-empty string is considered `True` by Python.\n\nIt is possible to set keys in nested dictionaries by separating the keys with double underscore (`__`). Any intermediate keys that don’t exist on the parent dict will be initialized to an empty dict.\n\n``` text\n$ export FLASK_MYAPI__credentials__username=user123\n```\n\n``` python\napp.config[\"MYAPI\"][\"credentials\"][\"username\"]  # Is \"user123\"\n```\n\nOn Windows, environment variable keys are always uppercase, therefore the above example would end up as `MYAPI__CREDENTIALS__USERNAME`.\n\nFor even more config loading features, including merging and case-insensitive Windows support, try a dedicated library such as [Dynaconf](https://www.dynaconf.com/), which includes integration with Flask.\n\n## Configuration Best Practices\n\nThe downside with the approach mentioned earlier is that it makes testing a little harder. There is no single 100% solution for this problem in general, but there are a couple of things you can keep in mind to improve that experience:\n\n1.  Create your application in a function and register blueprints on it. That way you can create multiple instances of your application with different configurations attached which makes unit testing a lot easier. You can use this to pass in configuration as needed.\n2.  Do not write code that needs the configuration at import time. If you limit yourself to request-only accesses to the configuration you can reconfigure the object later on as needed.\n3.  Make sure to load the configuration very early on, so that extensions can access the configuration when calling `init_app`.\n\n## Development / Production\n\nMost applications need more than one configuration. There should be at least separate configurations for the production server and the one used during development. The easiest way to handle this is to use a default configuration that is always loaded and part of the version control, and a separate configuration that overrides the values as necessary as mentioned in the example above:\n\n``` python\napp = Flask(__name__)\napp.config.from_object('yourapplication.default_settings')\napp.config.from_envvar('YOURAPPLICATION_SETTINGS')\n```\n\nThen you just have to add a separate `config.py` file and export `YOURAPPLICATION_SETTINGS=/path/to/config.py` and you are done. However there are alternative ways as well. For example you could use imports or subclassing.\n\nWhat is very popular in the Django world is to make the import explicit in the config file by adding `from yourapplication.default_settings import *` to the top of the file and then overriding the changes by hand. You could also inspect an environment variable like `YOURAPPLICATION_MODE` and set that to `production`, `development` etc and import different hard-coded files based on that.\n\nAn interesting pattern is also to use classes and inheritance for configuration:\n\n``` python\nclass Config(object):\n    TESTING = False\n\nclass ProductionConfig(Config):\n    DATABASE_URI = 'mysql://user@localhost/foo'\n\nclass DevelopmentConfig(Config):\n    DATABASE_URI = \"sqlite:////tmp/foo.db\"\n\nclass TestingConfig(Config):\n    DATABASE_URI = 'sqlite:///:memory:'\n    TESTING = True\n```\n\nTo enable such a config you just have to call into [`from_object()`](../api/index#flask.Config.from_object \"flask.Config.from_object\"):\n\n``` python\napp.config.from_object('configmodule.ProductionConfig')\n```\n\nNote that [`from_object()`](../api/index#flask.Config.from_object \"flask.Config.from_object\") does not instantiate the class object. If you need to instantiate the class, such as to access a property, then you must do so before calling [`from_object()`](../api/index#flask.Config.from_object \"flask.Config.from_object\"):\n\n``` python\nfrom configmodule import ProductionConfig\napp.config.from_object(ProductionConfig())\n\n# Alternatively, import via string:\nfrom werkzeug.utils import import_string\ncfg = import_string('configmodule.ProductionConfig')()\napp.config.from_object(cfg)\n```\n\nInstantiating the configuration object allows you to use `@property` in your configuration classes:\n\n``` python\nclass Config(object):\n    \"\"\"Base config, uses staging database server.\"\"\"\n    TESTING = False\n    DB_SERVER = '192.168.1.56'\n\n    @property\n    def DATABASE_URI(self):  # Note: all caps\n        return f\"mysql://user@{self.DB_SERVER}/foo\"\n\nclass ProductionConfig(Config):\n    \"\"\"Uses production database server.\"\"\"\n    DB_SERVER = '192.168.19.32'\n\nclass DevelopmentConfig(Config):\n    DB_SERVER = 'localhost'\n\nclass TestingConfig(Config):\n    DB_SERVER = 'localhost'\n    DATABASE_URI = 'sqlite:///:memory:'\n```\n\nThere are many different ways and it’s up to you how you want to manage your configuration files. However here a list of good recommendations:\n\n- Keep a default configuration in version control. Either populate the config with this default configuration or import it in your own configuration files before overriding values.\n- Use an environment variable to switch between the configurations. This can be done from outside the Python interpreter and makes development and deployment much easier because you can quickly and easily switch between different configs without having to touch the code at all. If you are working often on different projects you can even create your own script for sourcing that activates a virtualenv and exports the development configuration for you.\n- Use a tool like [fabric](https://www.fabfile.org/) to push code and configuration separately to the production server(s).\n\n## Instance Folders\n\nChangelog\n\nNew in version 0.8.\n\nFlask 0.8 introduces instance folders. Flask for a long time made it possible to refer to paths relative to the application’s folder directly (via `Flask.root_path`). This was also how many developers loaded configurations stored next to the application. Unfortunately however this only works well if applications are not packages in which case the root path refers to the contents of the package.\n\nWith Flask 0.8 a new attribute was introduced: `Flask.instance_path`. It refers to a new concept called the “instance folder”. The instance folder is designed to not be under version control and be deployment specific. It’s the perfect place to drop things that either change at runtime or configuration files.\n\nYou can either explicitly provide the path of the instance folder when creating the Flask application or you can let Flask autodetect the instance folder. For explicit configuration use the `instance_path` parameter:\n\n``` python\napp = Flask(__name__, instance_path='/path/to/instance/folder')\n```\n\nPlease keep in mind that this path *must* be absolute when provided.\n\nIf the `instance_path` parameter is not provided the following default locations are used:\n\n- Uninstalled module:\n\n  ``` python\n  /myapp.py\n  /instance\n  ```\n\n- Uninstalled package:\n\n  ``` python\n  /myapp\n      /__init__.py\n  /instance\n  ```\n\n- Installed module or package:\n\n  ``` python\n  $PREFIX/lib/pythonX.Y/site-packages/myapp\n  $PREFIX/var/myapp-instance\n  ```\n\n  `$PREFIX` is the prefix of your Python installation. This can be `/usr` or the path to your virtualenv. You can print the value of `sys.prefix` to see what the prefix is set to.\n\nSince the config object provided loading of configuration files from relative filenames we made it possible to change the loading via filenames to be relative to the instance path if wanted. The behavior of relative paths in config files can be flipped between “relative to the application root” (the default) to “relative to instance folder” via the `instance_relative_config` switch to the application constructor:\n\n``` python\napp = Flask(__name__, instance_relative_config=True)\n```\n\nHere is a full example of how to configure Flask to preload the config from a module and then override the config from a file in the instance folder if it exists:\n\n``` python\napp = Flask(__name__, instance_relative_config=True)\napp.config.from_object('yourapplication.default_settings')\napp.config.from_pyfile('application.cfg', silent=True)\n```\n\nThe path to the instance folder can be found via the `Flask.instance_path`. Flask also provides a shortcut to open a file from the instance folder with `Flask.open_instance_resource()`.\n\nExample usage for both:\n\n``` python\nfilename = os.path.join(app.instance_path, 'application.cfg')\nwith open(filename) as f:\n    config = f.read()\n\n# or via open_instance_resource:\nwith app.open_instance_resource('application.cfg') as f:\n    config = f.read()\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/config/](https://flask.palletsprojects.com/en/3.0.x/config/)"
- name: Message Flashing
  id: patterns/flashing/index
  summary: Good applications and user interfaces are all about feedback
  description: "# Message Flashing\n\nGood applications and user interfaces are all about feedback. If the user does not get enough feedback they will probably end up hating the application. Flask provides a really simple way to give feedback to a user with the flashing system. The flashing system basically makes it possible to record a message at the end of a request and access it next request and only next request. This is usually combined with a layout template that does this. Note that browsers and sometimes web servers enforce a limit on cookie sizes. This means that flashing messages that are too large for session cookies causes message flashing to fail silently.\n\n## Simple Flashing\n\nSo here is a full example:\n\n``` python\nfrom flask import Flask, flash, redirect, render_template, \\\n     request, url_for\n\napp = Flask(__name__)\napp.secret_key = b'_5#y2L\"F4Q8z\\n\\xec]/'\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != 'admin' or \\\n                request.form['password'] != 'secret':\n            error = 'Invalid credentials'\n        else:\n            flash('You were successfully logged in')\n            return redirect(url_for('index'))\n    return render_template('login.html', error=error)\n```\n\nAnd here is the `layout.html` template which does the magic:\n\n``` html+jinja\n<!doctype html>\n<title>My Application</title>\n{% with messages = get_flashed_messages() %}\n  {% if messages %}\n    <ul class=flashes>\n    {% for message in messages %}\n      <li>{{ message }}</li>\n    {% endfor %}\n    </ul>\n  {% endif %}\n{% endwith %}\n{% block body %}{% endblock %}\n```\n\nHere is the `index.html` template which inherits from `layout.html`:\n\n``` html+jinja\n{% extends \"layout.html\" %}\n{% block body %}\n  <h1>Overview</h1>\n  <p>Do you want to <a href=\"{{ url_for('login') }}\">log in?</a>\n{% endblock %}\n```\n\nAnd here is the `login.html` template which also inherits from `layout.html`:\n\n``` html+jinja\n{% extends \"layout.html\" %}\n{% block body %}\n  <h1>Login</h1>\n  {% if error %}\n    <p class=error><strong>Error:</strong> {{ error }}\n  {% endif %}\n  <form method=post>\n    <dl>\n      <dt>Username:\n      <dd><input type=text name=username value=\"{{\n          request.form.username }}\">\n      <dt>Password:\n      <dd><input type=password name=password>\n    </dl>\n    <p><input type=submit value=Login>\n  </form>\n{% endblock %}\n```\n\n## Flashing With Categories\n\nChangelog\n\nNew in version 0.3.\n\nIt is also possible to provide categories when flashing a message. The default category if nothing is provided is `'message'`. Alternative categories can be used to give the user better feedback. For example error messages could be displayed with a red background.\n\nTo flash a message with a different category, just use the second argument to the [`flash()`](../../api/index#flask.flash \"flask.flash\") function:\n\n``` python\nflash('Invalid password provided', 'error')\n```\n\nInside the template you then have to tell the [`get_flashed_messages()`](../../api/index#flask.get_flashed_messages \"flask.get_flashed_messages\") function to also return the categories. The loop looks slightly different in that situation then:\n\n``` html+jinja\n{% with messages = get_flashed_messages(with_categories=true) %}\n  {% if messages %}\n    <ul class=flashes>\n    {% for category, message in messages %}\n      <li class=\"{{ category }}\">{{ message }}</li>\n    {% endfor %}\n    </ul>\n  {% endif %}\n{% endwith %}\n```\n\nThis is just one example of how to render these flashed messages. One might also use the category to add a prefix such as `<strong>Error:</strong>` to the message.\n\n## Filtering Flash Messages\n\nChangelog\n\nNew in version 0.9.\n\nOptionally you can pass a list of categories which filters the results of [`get_flashed_messages()`](../../api/index#flask.get_flashed_messages \"flask.get_flashed_messages\"). This is useful if you wish to render each category in a separate block.\n\n``` html+jinja\n{% with errors = get_flashed_messages(category_filter=[\"error\"]) %}\n{% if errors %}\n<div class=\"alert-message block-message error\">\n  <a class=\"close\" href=\"#\">×</a>\n  <ul>\n    {%- for msg in errors %}\n    <li>{{ msg }}</li>\n    {% endfor -%}\n  </ul>\n</div>\n{% endif %}\n{% endwith %}\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/flashing/](https://flask.palletsprojects.com/en/3.0.x/patterns/flashing/)"
- name: MethodView
  id: api/index#flask.views.MethodView
  summary: Dispatches request methods to the corresponding instance methods
  description: |-
    `class flask.views.MethodView`

    Dispatches request methods to the corresponding instance methods. For example, if you implement a `get` method, it will be used to handle `GET` requests.

    This can be useful for defining a REST API.

    `methods` is automatically set based on the methods defined on the class.

    See [Class-based Views](../views/index) for a detailed guide.

    ``` python
    class CounterAPI(MethodView):
        def get(self):
            return str(session.get("counter", 0))

        def post(self):
            session["counter"] = session.get("counter", 0) + 1
            return redirect(url_for("counter"))

    app.add_url_rule(
        "/counter", view_func=CounterAPI.as_view("counter")
    )
    ```
- name: MethodView.dispatch_request()
  id: api/index#flask.views.MethodView.dispatch_request
  summary: The actual view function behavior
  description: |-
    `dispatch_request(**kwargs)`

    The actual view function behavior. Subclasses must override this and return a valid response. Any variables from the URL rule are passed as keyword arguments.

    Parameters:

    **kwargs** (*t.Any*) –

    Return type:

    ft.ResponseReturnValue

    ## URL Route Registrations

    Generally there are three ways to define rules for the routing system:

    1.  You can use the [`flask.Flask.route()`](#flask.Flask.route "flask.Flask.route") decorator.
    2.  You can use the [`flask.Flask.add_url_rule()`](#flask.Flask.add_url_rule "flask.Flask.add_url_rule") function.
    3.  You can directly access the underlying Werkzeug routing system which is exposed as [`flask.Flask.url_map`](#flask.Flask.url_map "flask.Flask.url_map").

    Variable parts in the route can be specified with angular brackets (`/user/<username>`). By default a variable part in the URL accepts any string without a slash however a different converter can be specified as well by using `<converter:name>`.

    Variable parts are passed to the view function as keyword arguments.

    The following converters are available:

    |          |                                                |
    |----------|------------------------------------------------|
    | `string` | accepts any text without a slash (the default) |
    | `int`    | accepts integers                               |
    | `float`  | like `int` but for floating point values       |
    | `path`   | like the default but also accepts slashes      |
    | `any`    | matches one of the items provided              |
    | `uuid`   | accepts UUID strings                           |

    Custom converters can be defined using [`flask.Flask.url_map`](#flask.Flask.url_map "flask.Flask.url_map").

    Here are some examples:

    ``` python
    @app.route('/')
    def index():
        pass

    @app.route('/<username>')
    def show_user(username):
        pass

    @app.route('/post/<int:post_id>')
    def show_post(post_id):
        pass
    ```

    An important detail to keep in mind is how Flask deals with trailing slashes. The idea is to keep each URL unique so the following rules apply:

    1.  If a rule ends with a slash and is requested without a slash by the user, the user is automatically redirected to the same page with a trailing slash attached.
    2.  If a rule does not end with a trailing slash and the user requests the page with a trailing slash, a 404 not found is raised.

    This is consistent with how web servers deal with static files. This also makes it possible to use relative link targets safely.

    You can also define multiple rules for the same function. They have to be unique however. Defaults can also be specified. Here for example is a definition for a URL that accepts an optional page:

    ``` python
    @app.route('/users/', defaults={'page': 1})
    @app.route('/users/page/<int:page>')
    def show_users(page):
        pass
    ```

    This specifies that `/users/` will be the URL for page one and `/users/page/N` will be the URL for page `N`.

    If a URL contains a default value, it will be redirected to its simpler form with a 301 redirect. In the above example, `/users/page/1` will be redirected to `/users/`. If your route handles `GET` and `POST` requests, make sure the default route only handles `GET`, as redirects can’t preserve form data.

    ``` python
    @app.route('/region/', defaults={'id': 1})
    @app.route('/region/<int:id>', methods=['GET', 'POST'])
    def region(id):
       pass
    ```

    Here are the parameters that [`route()`](#flask.Flask.route "flask.Flask.route") and [`add_url_rule()`](#flask.Flask.add_url_rule "flask.Flask.add_url_rule") accept. The only difference is that with the route parameter the view function is defined with the decorator instead of the `view_func` parameter.

    |             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
    |-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | `rule`      | the URL rule as string                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
    | `endpoint`  | the endpoint for the registered URL rule. Flask itself assumes that the name of the view function is the name of the endpoint if not explicitly stated.                                                                                                                                                                                                                                                                                                                                                                          |
    | `view_func` | the function to call when serving a request to the provided endpoint. If this is not provided one can specify the function later by storing it in the [`view_functions`](#flask.Flask.view_functions "flask.Flask.view_functions") dictionary with the endpoint as key.                                                                                                                                                                                                                                                          |
    | `defaults`  | A dictionary with defaults for this rule. See the example above for how defaults work.                                                                                                                                                                                                                                                                                                                                                                                                                                           |
    | `subdomain` | specifies the rule for the subdomain in case subdomain matching is in use. If not specified the default subdomain is assumed.                                                                                                                                                                                                                                                                                                                                                                                                    |
    | `**options` | the options to be forwarded to the underlying [`Rule`](https://werkzeug.palletsprojects.com/en/2.3.x/routing/#werkzeug.routing.Rule "(in Werkzeug v2.3.x)") object. A change to Werkzeug is handling of method options. methods is a list of methods this rule should be limited to (`GET`, `POST` etc.). By default a rule just listens for `GET` (and implicitly `HEAD`). Starting with Flask 0.6, `OPTIONS` is implicitly added and handled by the standard request handling. They have to be specified as keyword arguments. |

    ## View Function Options

    For internal usage the view functions can have some attributes attached to customize behavior the view function would normally not have control over. The following attributes can be provided optionally to either override some defaults to [`add_url_rule()`](#flask.Flask.add_url_rule "flask.Flask.add_url_rule") or general behavior:

    - `__name__`: The name of a function is by default used as endpoint. If endpoint is provided explicitly this value is used. Additionally this will be prefixed with the name of the blueprint by default which cannot be customized from the function itself.
    - `methods`: If methods are not provided when the URL rule is added, Flask will look on the view function object itself if a `methods` attribute exists. If it does, it will pull the information for the methods from there.
    - `provide_automatic_options`: if this attribute is set Flask will either force enable or disable the automatic implementation of the HTTP `OPTIONS` response. This can be useful when working with decorators that want to customize the `OPTIONS` response on a per-view basis.
    - `required_methods`: if this attribute is set, Flask will always add these methods when registering a URL rule even if the methods were explicitly overridden in the `route()` call.

    Full example:

    ``` python
    def index():
        if request.method == 'OPTIONS':
            # custom options handling here
            ...
        return 'Hello World!'
    index.provide_automatic_options = False
    index.methods = ['GET', 'OPTIONS']

    app.add_url_rule('/', index)
    ```

    Changelog

    New in version 0.8: The `provide_automatic_options` functionality was added.

    ## Command Line Interface
- name: mod_wsgi
  id: deploying/mod_wsgi/index
  summary: mod_wsgi is a WSGI server integrated with the Apache httpd server
  description: "# mod_wsgi\n\n[mod_wsgi](https://modwsgi.readthedocs.io/) is a WSGI server integrated with the [Apache httpd](https://httpd.apache.org/) server. The modern [mod_wsgi-express](https://pypi.org/project/mod-wsgi/) command makes it easy to configure and start the server without needing to write Apache httpd configuration.\n\n- Tightly integrated with Apache httpd.\n- Supports Windows directly.\n- Requires a compiler and the Apache development headers to install.\n- Does not require a reverse proxy setup.\n\nThis page outlines the basics of running mod_wsgi-express, not the more complex installation and configuration with httpd. Be sure to read the [mod_wsgi-express](https://pypi.org/project/mod-wsgi/), [mod_wsgi](https://modwsgi.readthedocs.io/), and [Apache httpd](https://httpd.apache.org/) documentation to understand what features are available.\n\n## Installing\n\nInstalling mod_wsgi requires a compiler and the Apache server and development headers installed. You will get an error if they are not. How to install them depends on the OS and package manager that you use.\n\nCreate a virtualenv, install your application, then install `mod_wsgi`.\n\n``` text\n$ cd hello-app\n$ python -m venv .venv\n$ . .venv/bin/activate\n$ pip install .  # install your application\n$ pip install mod_wsgi\n```\n\n## Running\n\nThe only argument to `mod_wsgi-express` specifies a script containing your Flask application, which must be called `application`. You can write a small script to import your app with this name, or to create it if using the app factory pattern.\n\n`wsgi.py`\n\n``` python\nfrom hello import app\n\napplication = app\n```\n\n`wsgi.py`\n\n``` python\nfrom hello import create_app\n\napplication = create_app()\n```\n\nNow run the `mod_wsgi-express start-server` command.\n\n``` text\n$ mod_wsgi-express start-server wsgi.py --processes 4\n```\n\nThe `--processes` option specifies the number of worker processes to run; a starting value could be `CPU * 2`.\n\nLogs for each request aren’t show in the terminal. If an error occurs, its information is written to the error log file shown when starting the server.\n\n## Binding Externally\n\nUnlike the other WSGI servers in these docs, mod_wsgi can be run as root to bind to privileged ports like 80 and 443. However, it must be configured to drop permissions to a different user and group for the worker processes.\n\nFor example, if you created a `hello` user and group, you should install your virtualenv and application as that user, then tell mod_wsgi to drop to that user after starting.\n\n``` text\n$ sudo /home/hello/.venv/bin/mod_wsgi-express start-server \\\n    /home/hello/wsgi.py \\\n    --user hello --group hello --port 80 --processes 4\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/deploying/mod_wsgi/](https://flask.palletsprojects.com/en/3.0.x/deploying/mod_wsgi/)"
- name: Modular Applications with Blueprints
  id: blueprints/index
  summary: New in version 0.7
  description: "# Modular Applications with Blueprints\n\nChangelog\n\nNew in version 0.7.\n\nFlask uses a concept of *blueprints* for making application components and supporting common patterns within an application or across applications. Blueprints can greatly simplify how large applications work and provide a central means for Flask extensions to register operations on applications. A [`Blueprint`](../api/index#flask.Blueprint \"flask.Blueprint\") object works similarly to a [`Flask`](../api/index#flask.Flask \"flask.Flask\") application object, but it is not actually an application. Rather it is a *blueprint* of how to construct or extend an application.\n\n## Why Blueprints?\n\nBlueprints in Flask are intended for these cases:\n\n- Factor an application into a set of blueprints. This is ideal for larger applications; a project could instantiate an application object, initialize several extensions, and register a collection of blueprints.\n- Register a blueprint on an application at a URL prefix and/or subdomain. Parameters in the URL prefix/subdomain become common view arguments (with defaults) across all view functions in the blueprint.\n- Register a blueprint multiple times on an application with different URL rules.\n- Provide template filters, static files, templates, and other utilities through blueprints. A blueprint does not have to implement applications or view functions.\n- Register a blueprint on an application for any of these cases when initializing a Flask extension.\n\nA blueprint in Flask is not a pluggable app because it is not actually an application – it’s a set of operations which can be registered on an application, even multiple times. Why not have multiple application objects? You can do that (see [Application Dispatching](../patterns/appdispatch/index)), but your applications will have separate configs and will be managed at the WSGI layer.\n\nBlueprints instead provide separation at the Flask level, share application config, and can change an application object as necessary with being registered. The downside is that you cannot unregister a blueprint once an application was created without having to destroy the whole application object.\n\n## The Concept of Blueprints\n\nThe basic concept of blueprints is that they record operations to execute when registered on an application. Flask associates view functions with blueprints when dispatching requests and generating URLs from one endpoint to another.\n\n## My First Blueprint\n\nThis is what a very basic blueprint looks like. In this case we want to implement a blueprint that does simple rendering of static templates:\n\n``` python\nfrom flask import Blueprint, render_template, abort\nfrom jinja2 import TemplateNotFound\n\nsimple_page = Blueprint('simple_page', __name__,\n                        template_folder='templates')\n\n@simple_page.route('/', defaults={'page': 'index'})\n@simple_page.route('/<page>')\ndef show(page):\n    try:\n        return render_template(f'pages/{page}.html')\n    except TemplateNotFound:\n        abort(404)\n```\n\nWhen you bind a function with the help of the `@simple_page.route` decorator, the blueprint will record the intention of registering the function `show` on the application when it’s later registered. Additionally it will prefix the endpoint of the function with the name of the blueprint which was given to the [`Blueprint`](../api/index#flask.Blueprint \"flask.Blueprint\") constructor (in this case also `simple_page`). The blueprint’s name does not modify the URL, only the endpoint.\n\n## Registering Blueprints\n\nSo how do you register that blueprint? Like this:\n\n``` python\nfrom flask import Flask\nfrom yourapplication.simple_page import simple_page\n\napp = Flask(__name__)\napp.register_blueprint(simple_page)\n```\n\nIf you check the rules registered on the application, you will find these:\n\n``` python\n>>> app.url_map\nMap([<Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>,\n <Rule '/<page>' (HEAD, OPTIONS, GET) -> simple_page.show>,\n <Rule '/' (HEAD, OPTIONS, GET) -> simple_page.show>])\n```\n\nThe first one is obviously from the application itself for the static files. The other two are for the `show` function of the `simple_page` blueprint. As you can see, they are also prefixed with the name of the blueprint and separated by a dot (`.`).\n\nBlueprints however can also be mounted at different locations:\n\n``` python\napp.register_blueprint(simple_page, url_prefix='/pages')\n```\n\nAnd sure enough, these are the generated rules:\n\n``` python\n>>> app.url_map\nMap([<Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>,\n <Rule '/pages/<page>' (HEAD, OPTIONS, GET) -> simple_page.show>,\n <Rule '/pages/' (HEAD, OPTIONS, GET) -> simple_page.show>])\n```\n\nOn top of that you can register blueprints multiple times though not every blueprint might respond properly to that. In fact it depends on how the blueprint is implemented if it can be mounted more than once.\n\n## Nesting Blueprints\n\nIt is possible to register a blueprint on another blueprint.\n\n``` python\nparent = Blueprint('parent', __name__, url_prefix='/parent')\nchild = Blueprint('child', __name__, url_prefix='/child')\nparent.register_blueprint(child)\napp.register_blueprint(parent)\n```\n\nThe child blueprint will gain the parent’s name as a prefix to its name, and child URLs will be prefixed with the parent’s URL prefix.\n\n``` python\nurl_for('parent.child.create')\n/parent/child/create\n```\n\nIn addition a child blueprint’s will gain their parent’s subdomain, with their subdomain as prefix if present i.e.\n\n``` python\nparent = Blueprint('parent', __name__, subdomain='parent')\nchild = Blueprint('child', __name__, subdomain='child')\nparent.register_blueprint(child)\napp.register_blueprint(parent)\n\nurl_for('parent.child.create', _external=True)\n\"child.parent.domain.tld\"\n```\n\nBlueprint-specific before request functions, etc. registered with the parent will trigger for the child. If a child does not have an error handler that can handle a given exception, the parent’s will be tried.\n\n## Blueprint Resources\n\nBlueprints can provide resources as well. Sometimes you might want to introduce a blueprint only for the resources it provides.\n\n### Blueprint Resource Folder\n\nLike for regular applications, blueprints are considered to be contained in a folder. While multiple blueprints can originate from the same folder, it does not have to be the case and it’s usually not recommended.\n\nThe folder is inferred from the second argument to [`Blueprint`](../api/index#flask.Blueprint \"flask.Blueprint\") which is usually `__name__`. This argument specifies what logical Python module or package corresponds to the blueprint. If it points to an actual Python package that package (which is a folder on the filesystem) is the resource folder. If it’s a module, the package the module is contained in will be the resource folder. You can access the [`Blueprint.root_path`](../api/index#flask.Blueprint.root_path \"flask.Blueprint.root_path\") property to see what the resource folder is:\n\n``` python\n>>> simple_page.root_path\n'/Users/username/TestProject/yourapplication'\n```\n\nTo quickly open sources from this folder you can use the [`open_resource()`](../api/index#flask.Blueprint.open_resource \"flask.Blueprint.open_resource\") function:\n\n``` python\nwith simple_page.open_resource('static/style.css') as f:\n    code = f.read()\n```\n\n### Static Files\n\nA blueprint can expose a folder with static files by providing the path to the folder on the filesystem with the `static_folder` argument. It is either an absolute path or relative to the blueprint’s location:\n\n``` python\nadmin = Blueprint('admin', __name__, static_folder='static')\n```\n\nBy default the rightmost part of the path is where it is exposed on the web. This can be changed with the `static_url_path` argument. Because the folder is called `static` here it will be available at the `url_prefix` of the blueprint + `/static`. If the blueprint has the prefix `/admin`, the static URL will be `/admin/static`.\n\nThe endpoint is named `blueprint_name.static`. You can generate URLs to it with [`url_for()`](../api/index#flask.url_for \"flask.url_for\") like you would with the static folder of the application:\n\n``` python\nurl_for('admin.static', filename='style.css')\n```\n\nHowever, if the blueprint does not have a `url_prefix`, it is not possible to access the blueprint’s static folder. This is because the URL would be `/static` in this case, and the application’s `/static` route takes precedence. Unlike template folders, blueprint static folders are not searched if the file does not exist in the application static folder.\n\n### Templates\n\nIf you want the blueprint to expose templates you can do that by providing the `template_folder` parameter to the [`Blueprint`](../api/index#flask.Blueprint \"flask.Blueprint\") constructor:\n\n``` python\nadmin = Blueprint('admin', __name__, template_folder='templates')\n```\n\nFor static files, the path can be absolute or relative to the blueprint resource folder.\n\nThe template folder is added to the search path of templates but with a lower priority than the actual application’s template folder. That way you can easily override templates that a blueprint provides in the actual application. This also means that if you don’t want a blueprint template to be accidentally overridden, make sure that no other blueprint or actual application template has the same relative path. When multiple blueprints provide the same relative template path the first blueprint registered takes precedence over the others.\n\nSo if you have a blueprint in the folder `yourapplication/admin` and you want to render the template `'admin/index.html'` and you have provided `templates` as a `template_folder` you will have to create a file like this: `yourapplication/admin/templates/admin/index.html`. The reason for the extra `admin` folder is to avoid getting our template overridden by a template named `index.html` in the actual application template folder.\n\nTo further reiterate this: if you have a blueprint named `admin` and you want to render a template called `index.html` which is specific to this blueprint, the best idea is to lay out your templates like this:\n\n``` python\nyourpackage/\n    blueprints/\n        admin/\n            templates/\n                admin/\n                    index.html\n            __init__.py\n```\n\nAnd then when you want to render the template, use `admin/index.html` as the name to look up the template by. If you encounter problems loading the correct templates enable the `EXPLAIN_TEMPLATE_LOADING` config variable which will instruct Flask to print out the steps it goes through to locate templates on every `render_template` call.\n\n## Building URLs\n\nIf you want to link from one page to another you can use the [`url_for()`](../api/index#flask.url_for \"flask.url_for\") function just like you normally would do just that you prefix the URL endpoint with the name of the blueprint and a dot (`.`):\n\n``` python\nurl_for('admin.index')\n```\n\nAdditionally if you are in a view function of a blueprint or a rendered template and you want to link to another endpoint of the same blueprint, you can use relative redirects by prefixing the endpoint with a dot only:\n\n``` python\nurl_for('.index')\n```\n\nThis will link to `admin.index` for instance in case the current request was dispatched to any other admin blueprint endpoint.\n\n## Blueprint Error Handlers\n\nBlueprints support the `errorhandler` decorator just like the [`Flask`](../api/index#flask.Flask \"flask.Flask\") application object, so it is easy to make Blueprint-specific custom error pages.\n\nHere is an example for a “404 Page Not Found” exception:\n\n``` python\n@simple_page.errorhandler(404)\ndef page_not_found(e):\n    return render_template('pages/404.html')\n```\n\nMost errorhandlers will simply work as expected; however, there is a caveat concerning handlers for 404 and 405 exceptions. These errorhandlers are only invoked from an appropriate `raise` statement or a call to `abort` in another of the blueprint’s view functions; they are not invoked by, e.g., an invalid URL access. This is because the blueprint does not “own” a certain URL space, so the application instance has no way of knowing which blueprint error handler it should run if given an invalid URL. If you would like to execute different handling strategies for these errors based on URL prefixes, they may be defined at the application level using the `request` proxy object:\n\n``` python\n@app.errorhandler(404)\n@app.errorhandler(405)\ndef _handle_api_error(ex):\n    if request.path.startswith('/api/'):\n        return jsonify(error=str(ex)), ex.code\n    else:\n        return ex\n```\n\nSee [Handling Application Errors](../errorhandling/index).\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/blueprints/](https://flask.palletsprojects.com/en/3.0.x/blueprints/)"
- name: MongoDB with MongoEngine
  id: patterns/mongoengine/index
  summary: Using a document database like MongoDB is a common alternative to relational SQL databases
  description: "# MongoDB with MongoEngine\n\nUsing a document database like MongoDB is a common alternative to relational SQL databases. This pattern shows how to use [MongoEngine](http://mongoengine.org), a document mapper library, to integrate with MongoDB.\n\nA running MongoDB server and [Flask-MongoEngine](https://flask-mongoengine.readthedocs.io) are required.\n\n``` python\npip install flask-mongoengine\n```\n\n## Configuration\n\nBasic setup can be done by defining `MONGODB_SETTINGS` on `app.config` and creating a `MongoEngine` instance.\n\n``` python\nfrom flask import Flask\nfrom flask_mongoengine import MongoEngine\n\napp = Flask(__name__)\napp.config['MONGODB_SETTINGS'] = {\n    \"db\": \"myapp\",\n}\ndb = MongoEngine(app)\n```\n\n## Mapping Documents\n\nTo declare a model that represents a Mongo document, create a class that inherits from `Document` and declare each of the fields.\n\n``` python\nimport mongoengine as me\n\nclass Movie(me.Document):\n    title = me.StringField(required=True)\n    year = me.IntField()\n    rated = me.StringField()\n    director = me.StringField()\n    actors = me.ListField()\n```\n\nIf the document has nested fields, use `EmbeddedDocument` to defined the fields of the embedded document and `EmbeddedDocumentField` to declare it on the parent document.\n\n``` python\nclass Imdb(me.EmbeddedDocument):\n    imdb_id = me.StringField()\n    rating = me.DecimalField()\n    votes = me.IntField()\n\nclass Movie(me.Document):\n    ...\n    imdb = me.EmbeddedDocumentField(Imdb)\n```\n\n## Creating Data\n\nInstantiate your document class with keyword arguments for the fields. You can also assign values to the field attributes after instantiation. Then call `doc.save()`.\n\n``` python\nbttf = Movie(title=\"Back To The Future\", year=1985)\nbttf.actors = [\n    \"Michael J. Fox\",\n    \"Christopher Lloyd\"\n]\nbttf.imdb = Imdb(imdb_id=\"tt0088763\", rating=8.5)\nbttf.save()\n```\n\n## Queries\n\nUse the class `objects` attribute to make queries. A keyword argument looks for an equal value on the field.\n\n``` python\nbttf = Movies.objects(title=\"Back To The Future\").get_or_404()\n```\n\nQuery operators may be used by concatenating them with the field name using a double-underscore. `objects`, and queries returned by calling it, are iterable.\n\n``` python\nsome_theron_movie = Movie.objects(actors__in=[\"Charlize Theron\"]).first()\n\nfor recents in Movie.objects(year__gte=2017):\n    print(recents.title)\n```\n\n## Documentation\n\nThere are many more ways to define and query documents with MongoEngine. For more information, check out the [official documentation](http://mongoengine.org).\n\nFlask-MongoEngine adds helpful utilities on top of MongoEngine. Check out their [documentation](https://flask-mongoengine.readthedocs.io) as well.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/mongoengine/](https://flask.palletsprojects.com/en/3.0.x/patterns/mongoengine/)"
- name: nginx
  id: deploying/nginx/index
  summary: nginx is a fast, production level HTTP server
  description: "# nginx\n\n[nginx](https://nginx.org/) is a fast, production level HTTP server. When serving your application with one of the WSGI servers listed in [Deploying to Production](../index), it is often good or necessary to put a dedicated HTTP server in front of it. This “reverse proxy” can handle incoming requests, TLS, and other security and performance concerns better than the WSGI server.\n\nNginx can be installed using your system package manager, or a pre-built executable for Windows. Installing and running Nginx itself is outside the scope of this doc. This page outlines the basics of configuring Nginx to proxy your application. Be sure to read its documentation to understand what features are available.\n\n## Domain Name\n\nAcquiring and configuring a domain name is outside the scope of this doc. In general, you will buy a domain name from a registrar, pay for server space with a hosting provider, and then point your registrar at the hosting provider’s name servers.\n\nTo simulate this, you can also edit your `hosts` file, located at `/etc/hosts` on Linux. Add a line that associates a name with the local IP.\n\nModern Linux systems may be configured to treat any domain name that ends with `.localhost` like this without adding it to the `hosts` file.\n\n`/etc/hosts`\n\n``` python\n127.0.0.1 hello.localhost\n```\n\n## Configuration\n\nThe nginx configuration is located at `/etc/nginx/nginx.conf` on Linux. It may be different depending on your operating system. Check the docs and look for `nginx.conf`.\n\nRemove or comment out any existing `server` section. Add a `server` section and use the `proxy_pass` directive to point to the address the WSGI server is listening on. We’ll assume the WSGI server is listening locally at `http://127.0.0.1:8000`.\n\n`/etc/nginx.conf`\n\n``` nginx\nserver {\n    listen 80;\n    server_name _;\n\n    location / {\n        proxy_pass http://127.0.0.1:8000/;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        proxy_set_header X-Forwarded-Host $host;\n        proxy_set_header X-Forwarded-Prefix /;\n    }\n}\n```\n\nThen [Tell Flask it is Behind a Proxy](../proxy_fix/index) so that your application uses these headers.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/deploying/nginx/](https://flask.palletsprojects.com/en/3.0.x/deploying/nginx/)"
- name: NullSession
  id: api/index#flask.sessions.NullSession
  summary: Class used to generate nicer error messages if sessions are not available
  description: |-
    `class flask.sessions.NullSession(initial=None)`

    Class used to generate nicer error messages if sessions are not available. Will still allow read-only access to the empty session but fail on setting.

    Parameters:

    **initial** (*t.Any*) –
- name: NullSession.clear()
  id: api/index#flask.sessions.NullSession.clear
  summary: clear() → None
  description: |-
    `clear() → None. Remove all items from D.`

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [NoReturn](https://docs.python.org/3/library/typing.html#typing.NoReturn "(in Python v3.11)")
- name: NullSession.pop()
  id: api/index#flask.sessions.NullSession.pop
  summary: pop(k[, d]) → v, remove specified key and return the corresponding value
  description: |-
    `pop(k[, d]) → v, remove specified key and return the corresponding value.`

    If the key is not found, return the default if given; otherwise, raise a KeyError.

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [NoReturn](https://docs.python.org/3/library/typing.html#typing.NoReturn "(in Python v3.11)")
- name: NullSession.popitem()
  id: api/index#flask.sessions.NullSession.popitem
  summary: Remove and return a (key, value) pair as a 2-tuple
  description: |-
    `popitem(*args, **kwargs)`

    Remove and return a (key, value) pair as a 2-tuple.

    Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [NoReturn](https://docs.python.org/3/library/typing.html#typing.NoReturn "(in Python v3.11)")
- name: NullSession.setdefault()
  id: api/index#flask.sessions.NullSession.setdefault
  summary: Insert key with a value of default if key is not in the dictionary
  description: |-
    `setdefault(*args, **kwargs)`

    Insert key with a value of default if key is not in the dictionary.

    Return the value for key if key is in the dictionary, else default.

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [NoReturn](https://docs.python.org/3/library/typing.html#typing.NoReturn "(in Python v3.11)")
- name: NullSession.update()
  id: api/index#flask.sessions.NullSession.update
  summary: update([E, ]**F) → None
  description: |-
    `update([E, ]**F) → None. Update D from dict/iterable E and F.`

    If E is present and has a .keys() method, then does: for k in E: D\[k\] = E\[k\] If E is present and lacks a .keys() method, then does: for k, v in E: D\[k\] = v In either case, this is followed by: for k in F: D\[k\] = F\[k\]

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [NoReturn](https://docs.python.org/3/library/typing.html#typing.NoReturn "(in Python v3.11)")
- name: pass_script_info()
  id: api/index#flask.cli.pass_script_info
  summary: Marks a function so that an instance of ScriptInfo is passed as first argument to the click callback
  description: |-
    `flask.cli.pass_script_info(f)`

    Marks a function so that an instance of [`ScriptInfo`](#flask.cli.ScriptInfo "flask.cli.ScriptInfo") is passed as first argument to the click callback.

    Parameters:

    **f** (*t.Callable\[te.Concatenate\[T,* *P\],* *R\]*) –

    Return type:

    t.Callable\[P, R\]
- name: Patterns for Flask
  id: patterns/index
  summary: Certain features and interactions are common enough that you will find them in most web applications
  description: "# Patterns for Flask\n\nCertain features and interactions are common enough that you will find them in most web applications. For example, many applications use a relational database and user authentication. They will open a database connection at the beginning of the request and get the information for the logged in user. At the end of the request, the database connection is closed.\n\nThese types of patterns may be a bit outside the scope of Flask itself, but Flask makes it easy to implement them. Some common patterns are collected in the following pages.\n\n- [Large Applications as Packages](packages/index)\n  - [Simple Packages](packages/index#simple-packages)\n  - [Working with Blueprints](packages/index#working-with-blueprints)\n- [Application Factories](appfactories/index)\n  - [Basic Factories](appfactories/index#basic-factories)\n  - [Factories & Extensions](appfactories/index#factories-extensions)\n  - [Using Applications](appfactories/index#using-applications)\n  - [Factory Improvements](appfactories/index#factory-improvements)\n- [Application Dispatching](appdispatch/index)\n  - [Working with this Document](appdispatch/index#working-with-this-document)\n  - [Combining Applications](appdispatch/index#combining-applications)\n  - [Dispatch by Subdomain](appdispatch/index#dispatch-by-subdomain)\n  - [Dispatch by Path](appdispatch/index#dispatch-by-path)\n- [Using URL Processors](urlprocessors/index)\n  - [Internationalized Application URLs](urlprocessors/index#internationalized-application-urls)\n  - [Internationalized Blueprint URLs](urlprocessors/index#internationalized-blueprint-urls)\n- [Using SQLite 3 with Flask](sqlite3/index)\n  - [Connect on Demand](sqlite3/index#connect-on-demand)\n  - [Easy Querying](sqlite3/index#easy-querying)\n  - [Initial Schemas](sqlite3/index#initial-schemas)\n- [SQLAlchemy in Flask](sqlalchemy/index)\n  - [Flask-SQLAlchemy Extension](sqlalchemy/index#flask-sqlalchemy-extension)\n  - [Declarative](sqlalchemy/index#declarative)\n  - [Manual Object Relational Mapping](sqlalchemy/index#manual-object-relational-mapping)\n  - [SQL Abstraction Layer](sqlalchemy/index#sql-abstraction-layer)\n- [Uploading Files](fileuploads/index)\n  - [A Gentle Introduction](fileuploads/index#a-gentle-introduction)\n  - [Improving Uploads](fileuploads/index#improving-uploads)\n  - [Upload Progress Bars](fileuploads/index#upload-progress-bars)\n  - [An Easier Solution](fileuploads/index#an-easier-solution)\n- [Caching](caching/index)\n- [View Decorators](viewdecorators/index)\n  - [Login Required Decorator](viewdecorators/index#login-required-decorator)\n  - [Caching Decorator](viewdecorators/index#caching-decorator)\n  - [Templating Decorator](viewdecorators/index#templating-decorator)\n  - [Endpoint Decorator](viewdecorators/index#endpoint-decorator)\n- [Form Validation with WTForms](wtforms/index)\n  - [The Forms](wtforms/index#the-forms)\n  - [In the View](wtforms/index#in-the-view)\n  - [Forms in Templates](wtforms/index#forms-in-templates)\n- [Template Inheritance](templateinheritance/index)\n  - [Base Template](templateinheritance/index#base-template)\n  - [Child Template](templateinheritance/index#child-template)\n- [Message Flashing](flashing/index)\n  - [Simple Flashing](flashing/index#simple-flashing)\n  - [Flashing With Categories](flashing/index#flashing-with-categories)\n  - [Filtering Flash Messages](flashing/index#filtering-flash-messages)\n- [JavaScript, `fetch`, and JSON](javascript/index)\n  - [Rendering Templates](javascript/index#rendering-templates)\n  - [Generating URLs](javascript/index#generating-urls)\n  - [Making a Request with `fetch`](javascript/index#making-a-request-with-fetch)\n  - [Following Redirects](javascript/index#following-redirects)\n  - [Replacing Content](javascript/index#replacing-content)\n  - [Return JSON from Views](javascript/index#return-json-from-views)\n  - [Receiving JSON in Views](javascript/index#receiving-json-in-views)\n- [Lazily Loading Views](lazyloading/index)\n  - [Converting to Centralized URL Map](lazyloading/index#converting-to-centralized-url-map)\n  - [Loading Late](lazyloading/index#loading-late)\n- [MongoDB with MongoEngine](mongoengine/index)\n  - [Configuration](mongoengine/index#configuration)\n  - [Mapping Documents](mongoengine/index#mapping-documents)\n  - [Creating Data](mongoengine/index#creating-data)\n  - [Queries](mongoengine/index#queries)\n  - [Documentation](mongoengine/index#documentation)\n- [Adding a favicon](favicon/index)\n  - [See also](favicon/index#see-also)\n- [Streaming Contents](streaming/index)\n  - [Basic Usage](streaming/index#basic-usage)\n  - [Streaming from Templates](streaming/index#streaming-from-templates)\n  - [Streaming with Context](streaming/index#streaming-with-context)\n- [Deferred Request Callbacks](deferredcallbacks/index)\n- [Adding HTTP Method Overrides](methodoverrides/index)\n- [Request Content Checksums](requestchecksum/index)\n- [Background Tasks with Celery](celery/index)\n  - [Install](celery/index#install)\n  - [Integrate Celery with Flask](celery/index#integrate-celery-with-flask)\n  - [Application Factory](celery/index#application-factory)\n  - [Defining Tasks](celery/index#defining-tasks)\n  - [Calling Tasks](celery/index#calling-tasks)\n  - [Getting Results](celery/index#getting-results)\n  - [Passing Data to Tasks](celery/index#passing-data-to-tasks)\n- [Subclassing Flask](subclassing/index)\n- [Single-Page Applications](singlepageapplications/index)\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/](https://flask.palletsprojects.com/en/3.0.x/patterns/)"
- name: PERMANENT_SESSION_LIFETIME
  id: config/index#PERMANENT_SESSION_LIFETIME
  summary: If session.permanent is true, the cookie’s expiration will be set this number of seconds in the future
  belongs_to: Configuration Handling
  description: |-
    `PERMANENT_SESSION_LIFETIME`

    If `session.permanent` is true, the cookie’s expiration will be set this number of seconds in the future. Can either be a [`datetime.timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta "(in Python v3.11)") or an `int`.

    Flask’s default cookie implementation validates that the cryptographic signature is not older than this value.

    Default: `timedelta(days=31)` (`2678400` seconds)
- name: PREFERRED_URL_SCHEME
  id: config/index#PREFERRED_URL_SCHEME
  summary: Use this scheme for generating external URLs when not in a request context
  belongs_to: Configuration Handling
  description: |-
    `PREFERRED_URL_SCHEME`

    Use this scheme for generating external URLs when not in a request context.

    Default: `'http'`
- name: PROPAGATE_EXCEPTIONS
  id: config/index#PROPAGATE_EXCEPTIONS
  summary: Exceptions are re-raised rather than being handled by the app’s error handlers
  belongs_to: Configuration Handling
  description: |-
    `PROPAGATE_EXCEPTIONS`

    Exceptions are re-raised rather than being handled by the app’s error handlers. If not set, this is implicitly true if `TESTING` or `DEBUG` is enabled.

    Default: `None`
- name: Quickstart
  id: quickstart/index
  summary: Eager to get started? This page gives a good introduction to Flask
  description: "# Quickstart\n\nEager to get started? This page gives a good introduction to Flask. Follow [Installation](../installation/index) to set up a project and install Flask first.\n\n## A Minimal Application\n\nA minimal Flask application looks something like this:\n\n``` python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello_world():\n    return \"<p>Hello, World!</p>\"\n```\n\nSo what did that code do?\n\n1.  First we imported the [`Flask`](../api/index#flask.Flask \"flask.Flask\") class. An instance of this class will be our WSGI application.\n2.  Next we create an instance of this class. The first argument is the name of the application’s module or package. `__name__` is a convenient shortcut for this that is appropriate for most cases. This is needed so that Flask knows where to look for resources such as templates and static files.\n3.  We then use the [`route()`](../api/index#flask.Flask.route \"flask.Flask.route\") decorator to tell Flask what URL should trigger our function.\n4.  The function returns the message we want to display in the user’s browser. The default content type is HTML, so HTML in the string will be rendered by the browser.\n\nSave it as `hello.py` or something similar. Make sure to not call your application `flask.py` because this would conflict with Flask itself.\n\nTo run the application, use the `flask` command or `python -m flask`. You need to tell the Flask where your application is with the `--app` option.\n\n``` text\n$ flask --app hello run\n * Serving Flask app 'hello'\n * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)\n```\n\nApplication Discovery Behavior\n\nAs a shortcut, if the file is named `app.py` or `wsgi.py`, you don’t have to use `--app`. See [Command Line Interface](../cli/index) for more details.\n\nThis launches a very simple builtin server, which is good enough for testing but probably not what you want to use in production. For deployment options see [Deploying to Production](../deploying/index).\n\nNow head over to [http://127.0.0.1:5000/](http://127.0.0.1:5000/), and you should see your hello world greeting.\n\nIf another program is already using port 5000, you’ll see `OSError: [Errno 98]` or `OSError: [WinError 10013]` when the server tries to start. See [Address already in use](../server/index#address-already-in-use) for how to handle that.\n\nExternally Visible Server\n\nIf you run the server you will notice that the server is only accessible from your own computer, not from any other in the network. This is the default because in debugging mode a user of the application can execute arbitrary Python code on your computer.\n\nIf you have the debugger disabled or trust the users on your network, you can make the server publicly available simply by adding `--host=0.0.0.0` to the command line:\n\n``` python\n$ flask run --host=0.0.0.0\n```\n\nThis tells your operating system to listen on all public IPs.\n\n## Debug Mode\n\nThe `flask run` command can do more than just start the development server. By enabling debug mode, the server will automatically reload if code changes, and will show an interactive debugger in the browser if an error occurs during a request.\n\nWarning\n\nThe debugger allows executing arbitrary Python code from the browser. It is protected by a pin, but still represents a major security risk. Do not run the development server or debugger in a production environment.\n\nTo enable debug mode, use the `--debug` option.\n\n``` text\n$ flask --app hello run --debug\n * Serving Flask app 'hello'\n * Debug mode: on\n * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)\n * Restarting with stat\n * Debugger is active!\n * Debugger PIN: nnn-nnn-nnn\n```\n\nSee also:\n\n- [Development Server](../server/index) and [Command Line Interface](../cli/index) for information about running in debug mode.\n- [Debugging Application Errors](../debugging/index) for information about using the built-in debugger and other debuggers.\n- [Logging](../logging/index) and [Handling Application Errors](../errorhandling/index) to log errors and display nice error pages.\n\n## HTML Escaping\n\nWhen returning HTML (the default response type in Flask), any user-provided values rendered in the output must be escaped to protect from injection attacks. HTML templates rendered with Jinja, introduced later, will do this automatically.\n\n`escape()`, shown here, can be used manually. It is omitted in most examples for brevity, but you should always be aware of how you’re using untrusted data.\n\n``` python\nfrom markupsafe import escape\n\n@app.route(\"/<name>\")\ndef hello(name):\n    return f\"Hello, {escape(name)}!\"\n```\n\nIf a user managed to submit the name `<script>alert(\"bad\")</script>`, escaping causes it to be rendered as text, rather than running the script in the user’s browser.\n\n`<name>` in the route captures a value from the URL and passes it to the view function. These variable rules are explained below.\n\n## Routing\n\nModern web applications use meaningful URLs to help users. Users are more likely to like a page and come back if the page uses a meaningful URL they can remember and use to directly visit a page.\n\nUse the [`route()`](../api/index#flask.Flask.route \"flask.Flask.route\") decorator to bind a function to a URL.\n\n``` python\n@app.route('/')\ndef index():\n    return 'Index Page'\n\n@app.route('/hello')\ndef hello():\n    return 'Hello, World'\n```\n\nYou can do more! You can make parts of the URL dynamic and attach multiple rules to a function.\n\n### Variable Rules\n\nYou can add variable sections to a URL by marking sections with `<variable_name>`. Your function then receives the `<variable_name>` as a keyword argument. Optionally, you can use a converter to specify the type of the argument like `<converter:variable_name>`.\n\n``` python\nfrom markupsafe import escape\n\n@app.route('/user/<username>')\ndef show_user_profile(username):\n    # show the user profile for that user\n    return f'User {escape(username)}'\n\n@app.route('/post/<int:post_id>')\ndef show_post(post_id):\n    # show the post with the given id, the id is an integer\n    return f'Post {post_id}'\n\n@app.route('/path/<path:subpath>')\ndef show_subpath(subpath):\n    # show the subpath after /path/\n    return f'Subpath {escape(subpath)}'\n```\n\nConverter types:\n\n|          |                                            |\n|----------|--------------------------------------------|\n| `string` | (default) accepts any text without a slash |\n| `int`    | accepts positive integers                  |\n| `float`  | accepts positive floating point values     |\n| `path`   | like `string` but also accepts slashes     |\n| `uuid`   | accepts UUID strings                       |\n\n### Unique URLs / Redirection Behavior\n\nThe following two rules differ in their use of a trailing slash.\n\n``` python\n@app.route('/projects/')\ndef projects():\n    return 'The project page'\n\n@app.route('/about')\ndef about():\n    return 'The about page'\n```\n\nThe canonical URL for the `projects` endpoint has a trailing slash. It’s similar to a folder in a file system. If you access the URL without a trailing slash (`/projects`), Flask redirects you to the canonical URL with the trailing slash (`/projects/`).\n\nThe canonical URL for the `about` endpoint does not have a trailing slash. It’s similar to the pathname of a file. Accessing the URL with a trailing slash (`/about/`) produces a 404 “Not Found” error. This helps keep URLs unique for these resources, which helps search engines avoid indexing the same page twice.\n\n### URL Building\n\nTo build a URL to a specific function, use the [`url_for()`](../api/index#flask.url_for \"flask.url_for\") function. It accepts the name of the function as its first argument and any number of keyword arguments, each corresponding to a variable part of the URL rule. Unknown variable parts are appended to the URL as query parameters.\n\nWhy would you want to build URLs using the URL reversing function [`url_for()`](../api/index#flask.url_for \"flask.url_for\") instead of hard-coding them into your templates?\n\n1.  Reversing is often more descriptive than hard-coding the URLs.\n2.  You can change your URLs in one go instead of needing to remember to manually change hard-coded URLs.\n3.  URL building handles escaping of special characters transparently.\n4.  The generated paths are always absolute, avoiding unexpected behavior of relative paths in browsers.\n5.  If your application is placed outside the URL root, for example, in `/myapplication` instead of `/`, [`url_for()`](../api/index#flask.url_for \"flask.url_for\") properly handles that for you.\n\nFor example, here we use the [`test_request_context()`](../api/index#flask.Flask.test_request_context \"flask.Flask.test_request_context\") method to try out [`url_for()`](../api/index#flask.url_for \"flask.url_for\"). [`test_request_context()`](../api/index#flask.Flask.test_request_context \"flask.Flask.test_request_context\") tells Flask to behave as though it’s handling a request even while we use a Python shell. See [Context Locals](#context-locals).\n\n``` python\nfrom flask import url_for\n\n@app.route('/')\ndef index():\n    return 'index'\n\n@app.route('/login')\ndef login():\n    return 'login'\n\n@app.route('/user/<username>')\ndef profile(username):\n    return f'{username}\\'s profile'\n\nwith app.test_request_context():\n    print(url_for('index'))\n    print(url_for('login'))\n    print(url_for('login', next='/'))\n    print(url_for('profile', username='John Doe'))\n```\n\n``` text\n/\n/login\n/login?next=/\n/user/John%20Doe\n```\n\n### HTTP Methods\n\nWeb applications use different HTTP methods when accessing URLs. You should familiarize yourself with the HTTP methods as you work with Flask. By default, a route only answers to `GET` requests. You can use the `methods` argument of the [`route()`](../api/index#flask.Flask.route \"flask.Flask.route\") decorator to handle different HTTP methods.\n\n``` python\nfrom flask import request\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        return do_the_login()\n    else:\n        return show_the_login_form()\n```\n\nThe example above keeps all methods for the route within one function, which can be useful if each part uses some common data.\n\nYou can also separate views for different methods into different functions. Flask provides a shortcut for decorating such routes with [`get()`](../api/index#flask.Flask.get \"flask.Flask.get\"), [`post()`](../api/index#flask.Flask.post \"flask.Flask.post\"), etc. for each common HTTP method.\n\n``` python\n@app.get('/login')\ndef login_get():\n    return show_the_login_form()\n\n@app.post('/login')\ndef login_post():\n    return do_the_login()\n```\n\nIf `GET` is present, Flask automatically adds support for the `HEAD` method and handles `HEAD` requests according to the [HTTP RFC](https://www.ietf.org/rfc/rfc2068.txt). Likewise, `OPTIONS` is automatically implemented for you.\n\n## Static Files\n\nDynamic web applications also need static files. That’s usually where the CSS and JavaScript files are coming from. Ideally your web server is configured to serve them for you, but during development Flask can do that as well. Just create a folder called `static` in your package or next to your module and it will be available at `/static` on the application.\n\nTo generate URLs for static files, use the special `'static'` endpoint name:\n\n``` python\nurl_for('static', filename='style.css')\n```\n\nThe file has to be stored on the filesystem as `static/style.css`.\n\n## Rendering Templates\n\nGenerating HTML from within Python is not fun, and actually pretty cumbersome because you have to do the HTML escaping on your own to keep the application secure. Because of that Flask configures the [Jinja2](https://palletsprojects.com/p/jinja/) template engine for you automatically.\n\nTemplates can be used to generate any type of text file. For web applications, you’ll primarily be generating HTML pages, but you can also generate markdown, plain text for emails, and anything else.\n\nFor a reference to HTML, CSS, and other web APIs, use the [MDN Web Docs](https://developer.mozilla.org/).\n\nTo render a template you can use the [`render_template()`](../api/index#flask.render_template \"flask.render_template\") method. All you have to do is provide the name of the template and the variables you want to pass to the template engine as keyword arguments. Here’s a simple example of how to render a template:\n\n``` python\nfrom flask import render_template\n\n@app.route('/hello/')\n@app.route('/hello/<name>')\ndef hello(name=None):\n    return render_template('hello.html', name=name)\n```\n\nFlask will look for templates in the `templates` folder. So if your application is a module, this folder is next to that module, if it’s a package it’s actually inside your package:\n\n**Case 1**: a module:\n\n``` python\n/application.py\n/templates\n    /hello.html\n```\n\n**Case 2**: a package:\n\n``` python\n/application\n    /__init__.py\n    /templates\n        /hello.html\n```\n\nFor templates you can use the full power of Jinja2 templates. Head over to the official [Jinja2 Template Documentation](https://jinja.palletsprojects.com/templates/) for more information.\n\nHere is an example template:\n\n``` html+jinja\n<!doctype html>\n<title>Hello from Flask</title>\n{% if name %}\n  <h1>Hello {{ name }}!</h1>\n{% else %}\n  <h1>Hello, World!</h1>\n{% endif %}\n```\n\nInside templates you also have access to the [`config`](../api/index#flask.Flask.config \"flask.Flask.config\"), [`request`](../api/index#flask.request \"flask.request\"), [`session`](../api/index#flask.session \"flask.session\") and [`g`](../api/index#flask.g \"flask.g\") [\\[1\\]](#id3) objects as well as the [`url_for()`](../api/index#flask.url_for \"flask.url_for\") and [`get_flashed_messages()`](../api/index#flask.get_flashed_messages \"flask.get_flashed_messages\") functions.\n\nTemplates are especially useful if inheritance is used. If you want to know how that works, see [Template Inheritance](../patterns/templateinheritance/index). Basically template inheritance makes it possible to keep certain elements on each page (like header, navigation and footer).\n\nAutomatic escaping is enabled, so if `name` contains HTML it will be escaped automatically. If you can trust a variable and you know that it will be safe HTML (for example because it came from a module that converts wiki markup to HTML) you can mark it as safe by using the `Markup` class or by using the `|safe` filter in the template. Head over to the Jinja 2 documentation for more examples.\n\nHere is a basic introduction to how the `Markup` class works:\n\n``` python\n>>> from markupsafe import Markup\n>>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'\nMarkup('<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')\n>>> Markup.escape('<blink>hacker</blink>')\nMarkup('&lt;blink&gt;hacker&lt;/blink&gt;')\n>>> Markup('<em>Marked up</em> &raquo; HTML').striptags()\n'Marked up » HTML'\n```\n\nChangelog\n\nChanged in version 0.5: Autoescaping is no longer enabled for all templates. The following extensions for templates trigger autoescaping: `.html`, `.htm`, `.xml`, `.xhtml`. Templates loaded from a string will have autoescaping disabled.\n\n\\[[1](#id2)\\]\n\nUnsure what that [`g`](../api/index#flask.g \"flask.g\") object is? It’s something in which you can store information for your own needs. See the documentation for [`flask.g`](../api/index#flask.g \"flask.g\") and [Using SQLite 3 with Flask](../patterns/sqlite3/index).\n\n## Accessing Request Data\n\nFor web applications it’s crucial to react to the data a client sends to the server. In Flask this information is provided by the global [`request`](../api/index#flask.request \"flask.request\") object. If you have some experience with Python you might be wondering how that object can be global and how Flask manages to still be threadsafe. The answer is context locals:\n\n### Context Locals\n\nInsider Information\n\nIf you want to understand how that works and how you can implement tests with context locals, read this section, otherwise just skip it.\n\nCertain objects in Flask are global objects, but not of the usual kind. These objects are actually proxies to objects that are local to a specific context. What a mouthful. But that is actually quite easy to understand.\n\nImagine the context being the handling thread. A request comes in and the web server decides to spawn a new thread (or something else, the underlying object is capable of dealing with concurrency systems other than threads). When Flask starts its internal request handling it figures out that the current thread is the active context and binds the current application and the WSGI environments to that context (thread). It does that in an intelligent way so that one application can invoke another application without breaking.\n\nSo what does this mean to you? Basically you can completely ignore that this is the case unless you are doing something like unit testing. You will notice that code which depends on a request object will suddenly break because there is no request object. The solution is creating a request object yourself and binding it to the context. The easiest solution for unit testing is to use the [`test_request_context()`](../api/index#flask.Flask.test_request_context \"flask.Flask.test_request_context\") context manager. In combination with the `with` statement it will bind a test request so that you can interact with it. Here is an example:\n\n``` python\nfrom flask import request\n\nwith app.test_request_context('/hello', method='POST'):\n    # now you can do something with the request until the\n    # end of the with block, such as basic assertions:\n    assert request.path == '/hello'\n    assert request.method == 'POST'\n```\n\nThe other possibility is passing a whole WSGI environment to the [`request_context()`](../api/index#flask.Flask.request_context \"flask.Flask.request_context\") method:\n\n``` python\nwith app.request_context(environ):\n    assert request.method == 'POST'\n```\n\n### The Request Object\n\nThe request object is documented in the API section and we will not cover it here in detail (see [`Request`](../api/index#flask.Request \"flask.Request\")). Here is a broad overview of some of the most common operations. First of all you have to import it from the `flask` module:\n\n``` python\nfrom flask import request\n```\n\nThe current request method is available by using the [`method`](../api/index#flask.Request.method \"flask.Request.method\") attribute. To access form data (data transmitted in a `POST` or `PUT` request) you can use the [`form`](../api/index#flask.Request.form \"flask.Request.form\") attribute. Here is a full example of the two attributes mentioned above:\n\n``` python\n@app.route('/login', methods=['POST', 'GET'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if valid_login(request.form['username'],\n                       request.form['password']):\n            return log_the_user_in(request.form['username'])\n        else:\n            error = 'Invalid username/password'\n    # the code below is executed if the request method\n    # was GET or the credentials were invalid\n    return render_template('login.html', error=error)\n```\n\nWhat happens if the key does not exist in the `form` attribute? In that case a special [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError \"(in Python v3.11)\") is raised. You can catch it like a standard [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError \"(in Python v3.11)\") but if you don’t do that, a HTTP 400 Bad Request error page is shown instead. So for many situations you don’t have to deal with that problem.\n\nTo access parameters submitted in the URL (`?key=value`) you can use the [`args`](../api/index#flask.Request.args \"flask.Request.args\") attribute:\n\n``` python\nsearchword = request.args.get('key', '')\n```\n\nWe recommend accessing URL parameters with `get` or by catching the [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError \"(in Python v3.11)\") because users might change the URL and presenting them a 400 bad request page in that case is not user friendly.\n\nFor a full list of methods and attributes of the request object, head over to the [`Request`](../api/index#flask.Request \"flask.Request\") documentation.\n\n### File Uploads\n\nYou can handle uploaded files with Flask easily. Just make sure not to forget to set the `enctype=\"multipart/form-data\"` attribute on your HTML form, otherwise the browser will not transmit your files at all.\n\nUploaded files are stored in memory or at a temporary location on the filesystem. You can access those files by looking at the `files` attribute on the request object. Each uploaded file is stored in that dictionary. It behaves just like a standard Python `file` object, but it also has a [`save()`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.FileStorage.save \"(in Werkzeug v2.3.x)\") method that allows you to store that file on the filesystem of the server. Here is a simple example showing how that works:\n\n``` python\nfrom flask import request\n\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        f = request.files['the_file']\n        f.save('/var/www/uploads/uploaded_file.txt')\n    ...\n```\n\nIf you want to know how the file was named on the client before it was uploaded to your application, you can access the [`filename`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.FileStorage.filename \"(in Werkzeug v2.3.x)\") attribute. However please keep in mind that this value can be forged so never ever trust that value. If you want to use the filename of the client to store the file on the server, pass it through the [`secure_filename()`](https://werkzeug.palletsprojects.com/en/2.3.x/utils/#werkzeug.utils.secure_filename \"(in Werkzeug v2.3.x)\") function that Werkzeug provides for you:\n\n``` python\nfrom werkzeug.utils import secure_filename\n\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        file = request.files['the_file']\n        file.save(f\"/var/www/uploads/{secure_filename(file.filename)}\")\n    ...\n```\n\nFor some better examples, see [Uploading Files](../patterns/fileuploads/index).\n\n### Cookies\n\nTo access cookies you can use the [`cookies`](../api/index#flask.Request.cookies \"flask.Request.cookies\") attribute. To set cookies you can use the [`set_cookie`](../api/index#flask.Response.set_cookie \"flask.Response.set_cookie\") method of response objects. The [`cookies`](../api/index#flask.Request.cookies \"flask.Request.cookies\") attribute of request objects is a dictionary with all the cookies the client transmits. If you want to use sessions, do not use the cookies directly but instead use the [Sessions](#sessions) in Flask that add some security on top of cookies for you.\n\nReading cookies:\n\n``` python\nfrom flask import request\n\n@app.route('/')\ndef index():\n    username = request.cookies.get('username')\n    # use cookies.get(key) instead of cookies[key] to not get a\n    # KeyError if the cookie is missing.\n```\n\nStoring cookies:\n\n``` python\nfrom flask import make_response\n\n@app.route('/')\ndef index():\n    resp = make_response(render_template(...))\n    resp.set_cookie('username', 'the username')\n    return resp\n```\n\nNote that cookies are set on response objects. Since you normally just return strings from the view functions Flask will convert them into response objects for you. If you explicitly want to do that you can use the [`make_response()`](../api/index#flask.make_response \"flask.make_response\") function and then modify it.\n\nSometimes you might want to set a cookie at a point where the response object does not exist yet. This is possible by utilizing the [Deferred Request Callbacks](../patterns/deferredcallbacks/index) pattern.\n\nFor this also see [About Responses](#about-responses).\n\n## Redirects and Errors\n\nTo redirect a user to another endpoint, use the [`redirect()`](../api/index#flask.redirect \"flask.redirect\") function; to abort a request early with an error code, use the [`abort()`](../api/index#flask.abort \"flask.abort\") function:\n\n``` python\nfrom flask import abort, redirect, url_for\n\n@app.route('/')\ndef index():\n    return redirect(url_for('login'))\n\n@app.route('/login')\ndef login():\n    abort(401)\n    this_is_never_executed()\n```\n\nThis is a rather pointless example because a user will be redirected from the index to a page they cannot access (401 means access denied) but it shows how that works.\n\nBy default a black and white error page is shown for each error code. If you want to customize the error page, you can use the [`errorhandler()`](../api/index#flask.Flask.errorhandler \"flask.Flask.errorhandler\") decorator:\n\n``` python\nfrom flask import render_template\n\n@app.errorhandler(404)\ndef page_not_found(error):\n    return render_template('page_not_found.html'), 404\n```\n\nNote the `404` after the [`render_template()`](../api/index#flask.render_template \"flask.render_template\") call. This tells Flask that the status code of that page should be 404 which means not found. By default 200 is assumed which translates to: all went well.\n\nSee [Handling Application Errors](../errorhandling/index) for more details.\n\n## About Responses\n\nThe return value from a view function is automatically converted into a response object for you. If the return value is a string it’s converted into a response object with the string as response body, a `200 OK` status code and a *text/html* mimetype. If the return value is a dict or list, `jsonify()` is called to produce a response. The logic that Flask applies to converting return values into response objects is as follows:\n\n1.  If a response object of the correct type is returned it’s directly returned from the view.\n2.  If it’s a string, a response object is created with that data and the default parameters.\n3.  If it’s an iterator or generator returning strings or bytes, it is treated as a streaming response.\n4.  If it’s a dict or list, a response object is created using [`jsonify()`](../api/index#flask.json.jsonify \"flask.json.jsonify\").\n5.  If a tuple is returned the items in the tuple can provide extra information. Such tuples have to be in the form `(response, status)`, `(response, headers)`, or `(response, status, headers)`. The `status` value will override the status code and `headers` can be a list or dictionary of additional header values.\n6.  If none of that works, Flask will assume the return value is a valid WSGI application and convert that into a response object.\n\nIf you want to get hold of the resulting response object inside the view you can use the [`make_response()`](../api/index#flask.make_response \"flask.make_response\") function.\n\nImagine you have a view like this:\n\n``` python\nfrom flask import render_template\n\n@app.errorhandler(404)\ndef not_found(error):\n    return render_template('error.html'), 404\n```\n\nYou just need to wrap the return expression with [`make_response()`](../api/index#flask.make_response \"flask.make_response\") and get the response object to modify it, then return it:\n\n``` python\nfrom flask import make_response\n\n@app.errorhandler(404)\ndef not_found(error):\n    resp = make_response(render_template('error.html'), 404)\n    resp.headers['X-Something'] = 'A value'\n    return resp\n```\n\n### APIs with JSON\n\nA common response format when writing an API is JSON. It’s easy to get started writing such an API with Flask. If you return a `dict` or `list` from a view, it will be converted to a JSON response.\n\n``` python\n@app.route(\"/me\")\ndef me_api():\n    user = get_current_user()\n    return {\n        \"username\": user.username,\n        \"theme\": user.theme,\n        \"image\": url_for(\"user_image\", filename=user.image),\n    }\n\n@app.route(\"/users\")\ndef users_api():\n    users = get_all_users()\n    return [user.to_json() for user in users]\n```\n\nThis is a shortcut to passing the data to the [`jsonify()`](../api/index#flask.json.jsonify \"flask.json.jsonify\") function, which will serialize any supported JSON data type. That means that all the data in the dict or list must be JSON serializable.\n\nFor complex types such as database models, you’ll want to use a serialization library to convert the data to valid JSON types first. There are many serialization libraries and Flask API extensions maintained by the community that support more complex applications.\n\n## Sessions\n\nIn addition to the request object there is also a second object called [`session`](../api/index#flask.session \"flask.session\") which allows you to store information specific to a user from one request to the next. This is implemented on top of cookies for you and signs the cookies cryptographically. What this means is that the user could look at the contents of your cookie but not modify it, unless they know the secret key used for signing.\n\nIn order to use sessions you have to set a secret key. Here is how sessions work:\n\n``` python\nfrom flask import session\n\n# Set the secret key to some random bytes. Keep this really secret!\napp.secret_key = b'_5#y2L\"F4Q8z\\n\\xec]/'\n\n@app.route('/')\ndef index():\n    if 'username' in session:\n        return f'Logged in as {session[\"username\"]}'\n    return 'You are not logged in'\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        session['username'] = request.form['username']\n        return redirect(url_for('index'))\n    return '''\n        <form method=\"post\">\n            <p><input type=text name=username>\n            <p><input type=submit value=Login>\n        </form>\n    '''\n\n@app.route('/logout')\ndef logout():\n    # remove the username from the session if it's there\n    session.pop('username', None)\n    return redirect(url_for('index'))\n```\n\nHow to generate good secret keys\n\nA secret key should be as random as possible. Your operating system has ways to generate pretty random data based on a cryptographic random generator. Use the following command to quickly generate a value for `Flask.secret_key` (or [`SECRET_KEY`](../config/index#SECRET_KEY \"SECRET_KEY\")):\n\n``` python\n$ python -c 'import secrets; print(secrets.token_hex())'\n'192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'\n```\n\nA note on cookie-based sessions: Flask will take the values you put into the session object and serialize them into a cookie. If you are finding some values do not persist across requests, cookies are indeed enabled, and you are not getting a clear error message, check the size of the cookie in your page responses compared to the size supported by web browsers.\n\nBesides the default client-side based sessions, if you want to handle sessions on the server-side instead, there are several Flask extensions that support this.\n\n## Message Flashing\n\nGood applications and user interfaces are all about feedback. If the user does not get enough feedback they will probably end up hating the application. Flask provides a really simple way to give feedback to a user with the flashing system. The flashing system basically makes it possible to record a message at the end of a request and access it on the next (and only the next) request. This is usually combined with a layout template to expose the message.\n\nTo flash a message use the [`flash()`](../api/index#flask.flash \"flask.flash\") method, to get hold of the messages you can use [`get_flashed_messages()`](../api/index#flask.get_flashed_messages \"flask.get_flashed_messages\") which is also available in the templates. See [Message Flashing](../patterns/flashing/index) for a full example.\n\n## Logging\n\nChangelog\n\nNew in version 0.3.\n\nSometimes you might be in a situation where you deal with data that should be correct, but actually is not. For example you may have some client-side code that sends an HTTP request to the server but it’s obviously malformed. This might be caused by a user tampering with the data, or the client code failing. Most of the time it’s okay to reply with `400 Bad Request` in that situation, but sometimes that won’t do and the code has to continue working.\n\nYou may still want to log that something fishy happened. This is where loggers come in handy. As of Flask 0.3 a logger is preconfigured for you to use.\n\nHere are some example log calls:\n\n``` python\napp.logger.debug('A value for debugging')\napp.logger.warning('A warning occurred (%d apples)', 42)\napp.logger.error('An error occurred')\n```\n\nThe attached [`logger`](../api/index#flask.Flask.logger \"flask.Flask.logger\") is a standard logging [`Logger`](https://docs.python.org/3/library/logging.html#logging.Logger \"(in Python v3.11)\"), so head over to the official [`logging`](https://docs.python.org/3/library/logging.html#module-logging \"(in Python v3.11)\") docs for more information.\n\nSee [Handling Application Errors](../errorhandling/index).\n\n## Hooking in WSGI Middleware\n\nTo add WSGI middleware to your Flask application, wrap the application’s `wsgi_app` attribute. For example, to apply Werkzeug’s [`ProxyFix`](https://werkzeug.palletsprojects.com/en/2.3.x/middleware/proxy_fix/#werkzeug.middleware.proxy_fix.ProxyFix \"(in Werkzeug v2.3.x)\") middleware for running behind Nginx:\n\n``` python\nfrom werkzeug.middleware.proxy_fix import ProxyFix\napp.wsgi_app = ProxyFix(app.wsgi_app)\n```\n\nWrapping `app.wsgi_app` instead of `app` means that `app` still points at your Flask application, not at the middleware, so you can continue to use and configure `app` directly.\n\n## Using Flask Extensions\n\nExtensions are packages that help you accomplish common tasks. For example, Flask-SQLAlchemy provides SQLAlchemy support that makes it simple and easy to use with Flask.\n\nFor more on Flask extensions, see [Extensions](../extensions/index).\n\n## Deploying to a Web Server\n\nReady to deploy your new Flask app? See [Deploying to Production](../deploying/index).\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/quickstart/](https://flask.palletsprojects.com/en/3.0.x/quickstart/)"
- name: redirect()
  id: api/index#flask.redirect
  summary: Create a redirect response object
  description: |-
    `flask.redirect(location, code=302, Response=None)`

    Create a redirect response object.

    If [`current_app`](#flask.current_app "flask.current_app") is available, it will use its [`redirect()`](#flask.Flask.redirect "flask.Flask.redirect") method, otherwise it will use [`werkzeug.utils.redirect()`](https://werkzeug.palletsprojects.com/en/2.3.x/utils/#werkzeug.utils.redirect "(in Werkzeug v2.3.x)").

    Parameters:

    - **location** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The URL to redirect to.
    - **code** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)")) – The status code for the redirect.
    - **Response** ([type](https://docs.python.org/3/library/functions.html#type "(in Python v3.11)")*\[BaseResponse\]* *\|* *None*) – The response class to use. Not used when `current_app` is active, which uses `app.response_class`.

    Return type:

    BaseResponse

    Changelog

    New in version 2.2: Calls `current_app.redirect` if available instead of always using Werkzeug’s default `redirect`.
- name: render_template()
  id: api/index#flask.render_template
  summary: Render a template by name with the given context
  description: |-
    `flask.render_template(template_name_or_list, **context)`

    Render a template by name with the given context.

    Parameters:

    - **template_name_or_list** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Template](https://jinja.palletsprojects.com/en/3.1.x/api/#jinja2.Template "(in Jinja v3.1.x)") *\|* [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [jinja2.environment.Template](https://jinja.palletsprojects.com/en/3.1.x/api/#jinja2.Template "(in Jinja v3.1.x)")*\]*) – The name of the template to render. If a list is given, the first name to exist will be rendered.
    - **context** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – The variables to make available in the template.

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: render_template_string()
  id: api/index#flask.render_template_string
  summary: Render a template from the given source string with the given context
  description: |-
    `flask.render_template_string(source, **context)`

    Render a template from the given source string with the given context.

    Parameters:

    - **source** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The source code of the template to render.
    - **context** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – The variables to make available in the template.

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: Request
  id: api/index#flask.Request
  summary: The request object used by default in Flask
  description: |-
    `class flask.Request(environ, populate_request=True, shallow=False)`

    The request object used by default in Flask. Remembers the matched endpoint and view arguments.

    It is what ends up as [`request`](#flask.request "flask.request"). If you want to replace the request object used you can subclass this and set [`request_class`](#flask.Flask.request_class "flask.Flask.request_class") to your subclass.

    The request object is a [`Request`](https://werkzeug.palletsprojects.com/en/2.3.x/wrappers/#werkzeug.wrappers.Request "(in Werkzeug v2.3.x)") subclass and provides all of the attributes Werkzeug defines plus a few Flask specific ones.

    Parameters:

    - **environ** (*WSGIEnvironment*) –
    - **populate_request** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **shallow** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    `property accept_charsets: CharsetAccept`

    List of charsets this client supports as [`CharsetAccept`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.CharsetAccept "(in Werkzeug v2.3.x)") object.

    `property accept_encodings: Accept`

    List of encodings this client accepts. Encodings in a HTTP term are compression encodings such as gzip. For charsets have a look at `accept_charset`.

    `property accept_languages: LanguageAccept`

    List of languages this client accepts as [`LanguageAccept`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.LanguageAccept "(in Werkzeug v2.3.x)") object.

    `property accept_mimetypes: MIMEAccept`

    List of mimetypes this client supports as [`MIMEAccept`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.MIMEAccept "(in Werkzeug v2.3.x)") object.
- name: Request Content Checksums
  id: patterns/requestchecksum/index
  summary: Various pieces of code can consume the request data and preprocess it
  description: "# Request Content Checksums\n\nVarious pieces of code can consume the request data and preprocess it. For instance JSON data ends up on the request object already read and processed, form data ends up there as well but goes through a different code path. This seems inconvenient when you want to calculate the checksum of the incoming request data. This is necessary sometimes for some APIs.\n\nFortunately this is however very simple to change by wrapping the input stream.\n\nThe following example calculates the SHA1 checksum of the incoming data as it gets read and stores it in the WSGI environment:\n\n``` python\nimport hashlib\n\nclass ChecksumCalcStream(object):\n\n    def __init__(self, stream):\n        self._stream = stream\n        self._hash = hashlib.sha1()\n\n    def read(self, bytes):\n        rv = self._stream.read(bytes)\n        self._hash.update(rv)\n        return rv\n\n    def readline(self, size_hint):\n        rv = self._stream.readline(size_hint)\n        self._hash.update(rv)\n        return rv\n\ndef generate_checksum(request):\n    env = request.environ\n    stream = ChecksumCalcStream(env['wsgi.input'])\n    env['wsgi.input'] = stream\n    return stream._hash\n```\n\nTo use this, all you need to do is to hook the calculating stream in before the request starts consuming data. (Eg: be careful accessing `request.form` or anything of that nature. `before_request_handlers` for instance should be careful not to access it).\n\nExample usage:\n\n``` python\n@app.route('/special-api', methods=['POST'])\ndef special_api():\n    hash = generate_checksum(request)\n    # Accessing this parses the input stream\n    files = request.files\n    # At this point the hash is fully constructed.\n    checksum = hash.hexdigest()\n    return f\"Hash was: {checksum}\"\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/requestchecksum/](https://flask.palletsprojects.com/en/3.0.x/patterns/requestchecksum/)"
- name: Request.access_control_request_headers
  id: api/index#flask.Request.access_control_request_headers
  summary: Sent with a preflight request to indicate which headers will be sent with the cross origin request
  description: |-
    `access_control_request_headers`

    Sent with a preflight request to indicate which headers will be sent with the cross origin request. Set `access_control_allow_headers` on the response to indicate which headers are allowed.
- name: Request.access_control_request_method
  id: api/index#flask.Request.access_control_request_method
  summary: Sent with a preflight request to indicate which method will be used for the cross origin request
  description: |-
    `access_control_request_method`

    Sent with a preflight request to indicate which method will be used for the cross origin request. Set `access_control_allow_methods` on the response to indicate which methods are allowed.

    `property access_route: list[str]`

    If a forwarded header exists this is a list of all ip addresses from the client ip to the last proxy server.
- name: Request.application()
  id: api/index#flask.Request.application
  summary: Decorate a function as responder that accepts the request as the last argument
  description: |-
    `classmethod application(f)`

    Decorate a function as responder that accepts the request as the last argument. This works like the `responder()` decorator but the function is passed the request object as the last argument and the request object will be closed automatically:

    ``` python
    @Request.application
    def my_wsgi_app(request):
        return Response('Hello World!')
    ```

    As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing.

    Parameters:

    **f** (*t.Callable\[\[*[Request](#flask.Request "flask.Request")*\],* *WSGIApplication\]*) – the WSGI callable to decorate

    Returns:

    a new WSGI callable

    Return type:

    WSGIApplication

    `property args: MultiDict[str, str]`

    The parsed URL parameters (the part in the URL after the question mark).

    By default an [`ImmutableMultiDict`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict "(in Werkzeug v2.3.x)") is returned from this function. This can be changed by setting [`parameter_storage_class`](#flask.Request.parameter_storage_class "flask.Request.parameter_storage_class") to a different type. This might be necessary if the order of the form data is important.

    Changelog

    Changed in version 2.3: Invalid bytes remain percent encoded.

    `property authorization: Authorization | None`

    The `Authorization` header parsed into an `Authorization` object. `None` if the header is not present.

    Changelog

    Changed in version 2.3: `Authorization` is no longer a `dict`. The `token` attribute was added for auth schemes that use a token instead of parameters.

    `property base_url: str`

    Like [`url`](#flask.Request.url "flask.Request.url") but without the query string.

    `property blueprint: str | None`

    The registered name of the current blueprint.

    This will be `None` if the endpoint is not part of a blueprint, or if URL matching failed or has not been performed yet.

    This does not necessarily match the name the blueprint was created with. It may have been nested, or registered with a different name.

    `property blueprints: list[str]`

    The registered names of the current blueprint upwards through parent blueprints.

    This will be an empty list if there is no current blueprint, or if URL matching failed.

    Changelog

    New in version 2.0.1.

    `property cache_control: RequestCacheControl`

    A [`RequestCacheControl`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.RequestCacheControl "(in Werkzeug v2.3.x)") object for the incoming cache control headers.
- name: Request.close()
  id: api/index#flask.Request.close
  summary: Closes associated resources of this request object
  description: |-
    `close()`

    Closes associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it.

    Changelog

    New in version 0.9.

    Return type:

    None
- name: Request.content_encoding
  id: api/index#flask.Request.content_encoding
  summary: The Content-Encoding entity-header field is used as a modifier to the media-type
  description: |-
    `content_encoding`

    The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.

    Changelog

    New in version 0.9.

    `property content_length: int | None`

    The Content-Length entity-header field indicates the size of the entity-body in bytes or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.
- name: Request.content_md5
  id: api/index#flask.Request.content_md5
  summary: The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body
  description: |-
    `content_md5`

    The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)

    Changelog

    New in version 0.9.
- name: Request.content_type
  id: api/index#flask.Request.content_type
  summary: The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET
  description: |-
    `content_type`

    The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.

    `property cookies: ImmutableMultiDict[str, str]`

    A [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)") with the contents of all cookies transmitted with the request.

    `property data: bytes`

    The raw data read from [`stream`](#flask.Request.stream "flask.Request.stream"). Will be empty if the request represents form data.

    To get the raw data even if it represents form data, use [`get_data()`](#flask.Request.get_data "flask.Request.get_data").
- name: Request.date
  id: api/index#flask.Request.date
  summary: The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822
  description: |-
    `date`

    The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.

    Changelog

    Changed in version 2.0: The datetime object is timezone-aware.
- name: Request.dict_storage_class
  id: api/index#flask.Request.dict_storage_class
  summary: The endpoint that matched the request URL
  description: |-
    `dict_storage_class`

    alias of [`ImmutableMultiDict`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict "(in Werkzeug v2.3.x)")

    `property endpoint: str | None`

    The endpoint that matched the request URL.

    This will be `None` if matching failed or has not been performed yet.

    This in combination with [`view_args`](#flask.Request.view_args "flask.Request.view_args") can be used to reconstruct the same URL or a modified URL.
- name: Request.environ
  id: api/index#flask.Request.environ
  summary: The WSGI environment containing HTTP headers and information from the WSGI server
  description: |-
    `environ: WSGIEnvironment`

    The WSGI environment containing HTTP headers and information from the WSGI server.

    `property files: ImmutableMultiDict[str, FileStorage]`

    [`MultiDict`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.MultiDict "(in Werkzeug v2.3.x)") object containing all uploaded files. Each key in [`files`](#flask.Request.files "flask.Request.files") is the name from the `<input type="file" name="">`. Each value in [`files`](#flask.Request.files "flask.Request.files") is a Werkzeug [`FileStorage`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.FileStorage "(in Werkzeug v2.3.x)") object.

    It basically behaves like a standard file object you know from Python, with the difference that it also has a [`save()`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.FileStorage.save "(in Werkzeug v2.3.x)") function that can store the file on the filesystem.

    Note that [`files`](#flask.Request.files "flask.Request.files") will only contain data if the request method was POST, PUT or PATCH and the `<form>` that posted to the request had `enctype="multipart/form-data"`. It will be empty otherwise.

    See the [`MultiDict`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.MultiDict "(in Werkzeug v2.3.x)") / [`FileStorage`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.FileStorage "(in Werkzeug v2.3.x)") documentation for more details about the used data structure.

    `property form: ImmutableMultiDict[str, str]`

    The form parameters. By default an [`ImmutableMultiDict`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict "(in Werkzeug v2.3.x)") is returned from this function. This can be changed by setting [`parameter_storage_class`](#flask.Request.parameter_storage_class "flask.Request.parameter_storage_class") to a different type. This might be necessary if the order of the form data is important.

    Please keep in mind that file uploads will not end up here, but instead in the [`files`](#flask.Request.files "flask.Request.files") attribute.

    Changelog

    Changed in version 0.9: Previous to Werkzeug 0.9 this would only contain form data for POST and PUT requests.
- name: Request.form_data_parser_class
  id: api/index#flask.Request.form_data_parser_class
  summary: null
  description: |-
    `form_data_parser_class`

    alias of [`FormDataParser`](https://werkzeug.palletsprojects.com/en/2.3.x/http/#werkzeug.formparser.FormDataParser "(in Werkzeug v2.3.x)")
- name: Request.from_values()
  id: api/index#flask.Request.from_values
  summary: Create a new request object based on the values provided
  description: |-
    `classmethod from_values(*args, **kwargs)`

    Create a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (`Client`) that allows to create multipart requests, support for cookies etc.

    This accepts the same options as the [`EnvironBuilder`](https://werkzeug.palletsprojects.com/en/2.3.x/test/#werkzeug.test.EnvironBuilder "(in Werkzeug v2.3.x)").

    Changelog

    Changed in version 0.5: This method now accepts the same arguments as [`EnvironBuilder`](https://werkzeug.palletsprojects.com/en/2.3.x/test/#werkzeug.test.EnvironBuilder "(in Werkzeug v2.3.x)"). Because of this the `environ` parameter is now called `environ_overrides`.

    Returns:

    request object

    Parameters:

    - **args** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –
    - **kwargs** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [Request](https://werkzeug.palletsprojects.com/en/2.3.x/wrappers/#werkzeug.wrappers.Request "(in Werkzeug v2.3.x)")

    `property full_path: str`

    Requested path, including the query string.
- name: Request.get_data()
  id: api/index#flask.Request.get_data
  summary: This reads the buffered incoming data from the client into one bytes object
  description: |-
    `get_data(cache=True, as_text=False, parse_form_data=False)`

    This reads the buffered incoming data from the client into one bytes object. By default this is cached but that behavior can be changed by setting `cache` to `False`.

    Usually it’s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server.

    Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set `parse_form_data` to `True`. When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory.

    If `as_text` is set to `True` the return value will be a decoded string.

    Changelog

    New in version 0.9.

    Parameters:

    - **cache** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **as_text** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **parse_form_data** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    [bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.11)") \| [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: Request.get_json()
  id: api/index#flask.Request.get_json
  summary: Parse data as JSON
  description: |-
    `get_json(force=False, silent=False, cache=True)`

    Parse [`data`](#flask.Request.data "flask.Request.data") as JSON.

    If the mimetype does not indicate JSON (*application/json*, see [`is_json`](#flask.Request.is_json "flask.Request.is_json")), or parsing fails, [`on_json_loading_failed()`](#flask.Request.on_json_loading_failed "flask.Request.on_json_loading_failed") is called and its return value is used as the return value. By default this raises a 415 Unsupported Media Type resp.

    Parameters:

    - **force** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Ignore the mimetype and always try to parse JSON.
    - **silent** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Silence mimetype and parsing errors, and return `None` instead.
    - **cache** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Store the parsed JSON to return for subsequent calls.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)") \| None

    Changelog

    Changed in version 2.3: Raise a 415 error instead of 400.

    Changed in version 2.1: Raise a 400 error if the content type is incorrect.
- name: Request.headers
  id: api/index#flask.Request.headers
  summary: The headers received with the request
  description: |-
    `headers`

    The headers received with the request.

    `property host: str`

    The host name the request was made to, including the port if it’s non-standard. Validated with [`trusted_hosts`](#flask.Request.trusted_hosts "flask.Request.trusted_hosts").

    `property host_url: str`

    The request URL scheme and host only.

    `property if_match: ETags`

    An object containing all the etags in the `If-Match` header.

    Return type:

    [`ETags`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.ETags "(in Werkzeug v2.3.x)")

    `property if_modified_since: datetime | None`

    The parsed `If-Modified-Since` header as a datetime object.

    Changelog

    Changed in version 2.0: The datetime object is timezone-aware.

    `property if_none_match: ETags`

    An object containing all the etags in the `If-None-Match` header.

    Return type:

    [`ETags`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.ETags "(in Werkzeug v2.3.x)")

    `property if_range: IfRange`

    The parsed `If-Range` header.

    Changelog

    Changed in version 2.0: `IfRange.date` is timezone-aware.

    New in version 0.7.

    `property if_unmodified_since: datetime | None`

    The parsed `If-Unmodified-Since` header as a datetime object.

    Changelog

    Changed in version 2.0: The datetime object is timezone-aware.
- name: Request.input_stream
  id: api/index#flask.Request.input_stream
  summary: The raw WSGI input stream, without any safety checks
  description: |-
    `input_stream`

    The raw WSGI input stream, without any safety checks.

    This is dangerous to use. It does not guard against infinite streams or reading past [`content_length`](#flask.Request.content_length "flask.Request.content_length") or [`max_content_length`](#flask.Request.max_content_length "flask.Request.max_content_length").

    Use [`stream`](#flask.Request.stream "flask.Request.stream") instead.

    `property is_json: bool`

    Check if the mimetype indicates JSON data, either *application/json* or *application/\*+json*.
- name: Request.is_multiprocess
  id: api/index#flask.Request.is_multiprocess
  summary: boolean that is True if the application is served by a WSGI server that spawns multiple processes
  description: |-
    `is_multiprocess`

    boolean that is `True` if the application is served by a WSGI server that spawns multiple processes.
- name: Request.is_multithread
  id: api/index#flask.Request.is_multithread
  summary: boolean that is True if the application is served by a multithreaded WSGI server
  description: |-
    `is_multithread`

    boolean that is `True` if the application is served by a multithreaded WSGI server.
- name: Request.is_run_once
  id: api/index#flask.Request.is_run_once
  summary: boolean that is True if the application will be executed only once in a process lifetime
  description: |-
    `is_run_once`

    boolean that is `True` if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it’s not guaranteed that the execution only happens one time.

    `property is_secure: bool`

    `True` if the request was made with a secure protocol (HTTPS or WSS).

    `property json: Any | None`

    The parsed JSON data if [`mimetype`](#flask.Request.mimetype "flask.Request.mimetype") indicates JSON (*application/json*, see [`is_json`](#flask.Request.is_json "flask.Request.is_json")).

    Calls [`get_json()`](#flask.Request.get_json "flask.Request.get_json") with default arguments.

    If the request content type is not `application/json`, this will raise a 415 Unsupported Media Type error.

    Changelog

    Changed in version 2.3: Raise a 415 error instead of 400.

    Changed in version 2.1: Raise a 400 error if the content type is incorrect.
- name: Request.list_storage_class
  id: api/index#flask.Request.list_storage_class
  summary: null
  description: |-
    `list_storage_class`

    alias of [`ImmutableList`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.ImmutableList "(in Werkzeug v2.3.x)")
- name: Request.make_form_data_parser()
  id: api/index#flask.Request.make_form_data_parser
  summary: Creates the form data parser
  description: |-
    `make_form_data_parser()`

    Creates the form data parser. Instantiates the [`form_data_parser_class`](#flask.Request.form_data_parser_class "flask.Request.form_data_parser_class") with some parameters.

    Changelog

    New in version 0.8.

    Return type:

    [FormDataParser](https://werkzeug.palletsprojects.com/en/2.3.x/http/#werkzeug.formparser.FormDataParser "(in Werkzeug v2.3.x)")

    `property max_content_length: int | None`

    Read-only view of the `MAX_CONTENT_LENGTH` config key.
- name: Request.max_form_memory_size
  id: api/index#flask.Request.max_form_memory_size
  summary: the maximum form field size
  description: |-
    `max_form_memory_size: int | None = None`

    the maximum form field size. This is forwarded to the form data parsing function (`parse_form_data()`). When set and the [`form`](#flask.Request.form "flask.Request.form") or [`files`](#flask.Request.files "flask.Request.files") attribute is accessed and the data in memory for post data is longer than the specified value a [`RequestEntityTooLarge`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.RequestEntityTooLarge "(in Werkzeug v2.3.x)") exception is raised.

    Changelog

    New in version 0.5.
- name: Request.max_form_parts
  id: api/index#flask.Request.max_form_parts
  summary: The maximum number of multipart parts to parse, passed to form_data_parser_class
  description: |-
    `max_form_parts = 1000`

    The maximum number of multipart parts to parse, passed to [`form_data_parser_class`](#flask.Request.form_data_parser_class "flask.Request.form_data_parser_class"). Parsing form data with more than this many parts will raise `RequestEntityTooLarge`.

    Changelog

    New in version 2.2.3.
- name: Request.max_forwards
  id: api/index#flask.Request.max_forwards
  summary: The Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server
  description: |-
    `max_forwards`

    The Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server.
- name: Request.method
  id: api/index#flask.Request.method
  summary: The method the request was made with, such as GET
  description: |-
    `method`

    The method the request was made with, such as `GET`.

    `property mimetype: str`

    Like [`content_type`](#flask.Request.content_type "flask.Request.content_type"), but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is `text/HTML; charset=utf-8` the mimetype would be `'text/html'`.

    `property mimetype_params: dict[str, str]`

    The mimetype parameters as dict. For example if the content type is `text/html; charset=utf-8` the params would be `{'charset': 'utf-8'}`.
- name: Request.on_json_loading_failed()
  id: api/index#flask.Request.on_json_loading_failed
  summary: Called if get_json() fails and isn’t silenced
  description: |-
    `on_json_loading_failed(e)`

    Called if [`get_json()`](#flask.Request.get_json "flask.Request.get_json") fails and isn’t silenced.

    If this method returns a value, it is used as the return value for [`get_json()`](#flask.Request.get_json "flask.Request.get_json"). The default implementation raises [`BadRequest`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.BadRequest "(in Werkzeug v2.3.x)").

    Parameters:

    **e** ([ValueError](https://docs.python.org/3/library/exceptions.html#ValueError "(in Python v3.11)") *\|* *None*) – If parsing failed, this is the exception. It will be `None` if the content type wasn’t `application/json`.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")

    Changelog

    Changed in version 2.3: Raise a 415 error instead of 400.
- name: Request.origin
  id: api/index#flask.Request.origin
  summary: The host that the request originated from
  description: |-
    `origin`

    The host that the request originated from. Set `access_control_allow_origin` on the response to indicate which origins are allowed.
- name: Request.parameter_storage_class
  id: api/index#flask.Request.parameter_storage_class
  summary: null
  description: |-
    `parameter_storage_class`

    alias of [`ImmutableMultiDict`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict "(in Werkzeug v2.3.x)")
- name: Request.path
  id: api/index#flask.Request.path
  summary: The path part of the URL after root_path
  description: |-
    `path`

    The path part of the URL after [`root_path`](#flask.Request.root_path "flask.Request.root_path"). This is the path used for routing within the application.

    `property pragma: HeaderSet`

    The Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives.
- name: Request.query_string
  id: api/index#flask.Request.query_string
  summary: The part of the URL after the “?”. This is the raw value, use args for the parsed values
  description: |-
    `query_string`

    The part of the URL after the “?”. This is the raw value, use [`args`](#flask.Request.args "flask.Request.args") for the parsed values.

    `property range: Range | None`

    The parsed `Range` header.

    Changelog

    New in version 0.7.

    Return type:

    [`Range`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.Range "(in Werkzeug v2.3.x)")
- name: Request.referrer
  id: api/index#flask.Request.referrer
  summary: The Referer[sic] request-header field allows the client to specify, for the server’s benefit, the address (URI) of the resource from which the Request-URI was obtained (the “referrer”, although the header field is misspelled)
  description: |-
    `referrer`

    The Referer\[sic\] request-header field allows the client to specify, for the server’s benefit, the address (URI) of the resource from which the Request-URI was obtained (the “referrer”, although the header field is misspelled).
- name: Request.remote_addr
  id: api/index#flask.Request.remote_addr
  summary: The address of the client sending the request
  description: |-
    `remote_addr`

    The address of the client sending the request.
- name: Request.remote_user
  id: api/index#flask.Request.remote_user
  summary: If the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as
  description: |-
    `remote_user`

    If the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as.
- name: Request.root_path
  id: api/index#flask.Request.root_path
  summary: The prefix that the application is mounted under, without a trailing slash
  description: |-
    `root_path`

    The prefix that the application is mounted under, without a trailing slash. [`path`](#flask.Request.path "flask.Request.path") comes after this.

    `property root_url: str`

    The request URL scheme, host, and root path. This is the root that the application is accessed from.
- name: Request.routing_exception
  id: api/index#flask.Request.routing_exception
  summary: If matching the URL failed, this is the exception that will be raised / was raised as part of the request handling
  description: |-
    `routing_exception: Exception | None = None`

    If matching the URL failed, this is the exception that will be raised / was raised as part of the request handling. This is usually a [`NotFound`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.NotFound "(in Werkzeug v2.3.x)") exception or something similar.
- name: Request.scheme
  id: api/index#flask.Request.scheme
  summary: The URL scheme of the protocol the request used, such as https or wss
  description: |-
    `scheme`

    The URL scheme of the protocol the request used, such as `https` or `wss`.

    `property script_root: str`

    Alias for `self.root_path`. `environ["SCRIPT_ROOT"]` without a trailing slash.
- name: Request.server
  id: api/index#flask.Request.server
  summary: The address of the server
  description: |-
    `server`

    The address of the server. `(host, port)`, `(path, None)` for unix sockets, or `None` if not known.
- name: Request.shallow
  id: api/index#flask.Request.shallow
  summary: Set when creating the request object
  description: |-
    `shallow: bool`

    Set when creating the request object. If `True`, reading from the request body will cause a `RuntimeException`. Useful to prevent modifying the stream from middleware.

    `property stream: IO[bytes]`

    The WSGI input stream, with safety checks. This stream can only be consumed once.

    Use [`get_data()`](#flask.Request.get_data "flask.Request.get_data") to get the full data as bytes or text. The [`data`](#flask.Request.data "flask.Request.data") attribute will contain the full bytes only if they do not represent form data. The [`form`](#flask.Request.form "flask.Request.form") attribute will contain the parsed form data in that case.

    Unlike [`input_stream`](#flask.Request.input_stream "flask.Request.input_stream"), this stream guards against infinite streams or reading past [`content_length`](#flask.Request.content_length "flask.Request.content_length") or [`max_content_length`](#flask.Request.max_content_length "flask.Request.max_content_length").

    If `max_content_length` is set, it can be enforced on streams if `wsgi.input_terminated` is set. Otherwise, an empty stream is returned.

    If the limit is reached before the underlying stream is exhausted (such as a file that is too large, or an infinite stream), the remaining contents of the stream cannot be read safely. Depending on how the server handles this, clients may show a “connection reset” failure instead of seeing the 413 response.

    Changelog

    Changed in version 2.3: Check `max_content_length` preemptively and while reading.

    Changed in version 0.9: The stream is always set (but may be consumed) even if form parsing was accessed first.
- name: Request.trusted_hosts
  id: api/index#flask.Request.trusted_hosts
  summary: Valid host names when handling requests
  description: |-
    `trusted_hosts: list[str] | None = None`

    Valid host names when handling requests. By default all hosts are trusted, which means that whatever the client says the host is will be accepted.

    Because `Host` and `X-Forwarded-Host` headers can be set to any value by a malicious client, it is recommended to either set this property or implement similar validation in the proxy (if the application is being run behind one).

    Changelog

    New in version 0.9.

    `property url: str`

    The full request URL with the scheme, host, root path, path, and query string.

    `property url_root: str`

    Alias for [`root_url`](#flask.Request.root_url "flask.Request.root_url"). The URL with scheme, host, and root path. For example, `https://example.com/app/`.
- name: Request.url_rule
  id: api/index#flask.Request.url_rule
  summary: The internal URL rule that matched the request
  description: |-
    `url_rule: Rule | None = None`

    The internal URL rule that matched the request. This can be useful to inspect which methods are allowed for the URL from a before/after handler (`request.url_rule.methods`) etc. Though if the request’s method was invalid for the URL rule, the valid list is available in `routing_exception.valid_methods` instead (an attribute of the Werkzeug exception [`MethodNotAllowed`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.MethodNotAllowed "(in Werkzeug v2.3.x)")) because the request was never internally bound.

    Changelog

    New in version 0.6.

    `property user_agent: UserAgent`

    The user agent. Use `user_agent.string` to get the header value. Set [`user_agent_class`](#flask.Request.user_agent_class "flask.Request.user_agent_class") to a subclass of [`UserAgent`](https://werkzeug.palletsprojects.com/en/2.3.x/utils/#werkzeug.user_agent.UserAgent "(in Werkzeug v2.3.x)") to provide parsing for the other properties or other extended data.

    Changelog

    Changed in version 2.1: The built-in parser was removed. Set `user_agent_class` to a `UserAgent` subclass to parse data from the string.
- name: Request.user_agent_class
  id: api/index#flask.Request.user_agent_class
  summary: A werkzeug.datastructures.CombinedMultiDict that combines args and form
  description: |-
    `user_agent_class`

    alias of [`UserAgent`](https://werkzeug.palletsprojects.com/en/2.3.x/utils/#werkzeug.user_agent.UserAgent "(in Werkzeug v2.3.x)")

    `property values: CombinedMultiDict[str, str]`

    A [`werkzeug.datastructures.CombinedMultiDict`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.CombinedMultiDict "(in Werkzeug v2.3.x)") that combines [`args`](#flask.Request.args "flask.Request.args") and [`form`](#flask.Request.form "flask.Request.form").

    For GET requests, only `args` are present, not `form`.

    Changelog

    Changed in version 2.0: For GET requests, only `args` are present, not `form`.
- name: Request.view_args
  id: api/index#flask.Request.view_args
  summary: A dict of view arguments that matched the request
  description: |-
    `view_args: dict[str, t.Any] | None = None`

    A dict of view arguments that matched the request. If an exception happened when matching, this will be `None`.

    `property want_form_data_parsed: bool`

    `True` if the request method carries content. By default this is true if a `Content-Type` is sent.

    Changelog

    New in version 0.8.
- name: RequestContext
  id: api/index#flask.ctx.RequestContext
  summary: The request context contains per-request information
  description: |-
    `class flask.ctx.RequestContext(app, environ, request=None, session=None)`

    The request context contains per-request information. The Flask app creates and pushes it at the beginning of the request, then pops it at the end of the request. It will create the URL adapter and request object for the WSGI environment provided.

    Do not attempt to use this class directly, instead use [`test_request_context()`](#flask.Flask.test_request_context "flask.Flask.test_request_context") and [`request_context()`](#flask.Flask.request_context "flask.Flask.request_context") to create this object.

    When the request context is popped, it will evaluate all the functions registered on the application for teardown execution ([`teardown_request()`](#flask.Flask.teardown_request "flask.Flask.teardown_request")).

    The request context is automatically popped at the end of the request. When using the interactive debugger, the context will be restored so `request` is still accessible. Similarly, the test client can preserve the context after the request ends. However, teardown functions may already have closed some resources such as database connections.

    Parameters:

    - **app** ([Flask](#flask.Flask "flask.Flask")) –
    - **environ** ([dict](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)")) –
    - **request** ([Request](#flask.Request "flask.Request") *\|* *None*) –
    - **session** ([SessionMixin](#flask.sessions.SessionMixin "flask.sessions.SessionMixin") *\|* *None*) –
- name: RequestContext.copy()
  id: api/index#flask.ctx.RequestContext.copy
  summary: Creates a copy of this request context with the same request object
  description: |-
    `copy()`

    Creates a copy of this request context with the same request object. This can be used to move a request context to a different greenlet. Because the actual request object is the same this cannot be used to move a request context to a different thread unless access to the request object is locked.

    Changelog

    Changed in version 1.1: The current session object is used instead of reloading the original data. This prevents `flask.session` pointing to an out-of-date object.

    New in version 0.10.

    Return type:

    [RequestContext](#flask.ctx.RequestContext "flask.ctx.RequestContext")
- name: RequestContext.match_request()
  id: api/index#flask.ctx.RequestContext.match_request
  summary: Can be overridden by a subclass to hook into the matching of the request
  description: |-
    `match_request()`

    Can be overridden by a subclass to hook into the matching of the request.

    Return type:

    None
- name: RequestContext.pop()
  id: api/index#flask.ctx.RequestContext.pop
  summary: Pops the request context and unbinds it by doing that
  description: |-
    `pop(exc=<object object>)`

    Pops the request context and unbinds it by doing that. This will also trigger the execution of functions registered by the [`teardown_request()`](#flask.Flask.teardown_request "flask.Flask.teardown_request") decorator.

    Changelog

    Changed in version 0.9: Added the `exc` argument.

    Parameters:

    **exc** ([BaseException](https://docs.python.org/3/library/exceptions.html#BaseException "(in Python v3.11)") *\|* *None*) –

    Return type:

    None
- name: Response
  id: api/index#flask.Response
  summary: The response object that is used by default in Flask
  description: |-
    `class flask.Response(response=None, status=None, headers=None, mimetype=None, content_type=None, direct_passthrough=False)`

    The response object that is used by default in Flask. Works like the response object from Werkzeug but is set to have an HTML mimetype by default. Quite often you don’t have to create this object yourself because [`make_response()`](#flask.Flask.make_response "flask.Flask.make_response") will take care of that for you.

    If you want to replace the response object used you can subclass this and set [`response_class`](#flask.Flask.response_class "flask.Flask.response_class") to your subclass.

    Changelog

    Changed in version 1.0: JSON support is added to the response, like the request. This is useful when testing to get the test client response data as JSON.

    Changed in version 1.0: Added [`max_cookie_size`](#flask.Response.max_cookie_size "flask.Response.max_cookie_size").

    Parameters:

    - **response** ([Iterable](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*\]* *\|* [Iterable](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.11)")*\[*[bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.11)")*\]*) –
    - **status** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *HTTPStatus* *\|* *None*) –
    - **headers** ([Headers](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.Headers "(in Werkzeug v2.3.x)")) –
    - **mimetype** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **content_type** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **direct_passthrough** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
- name: Response.accept_ranges
  id: api/index#flask.Response.accept_ranges
  summary: The Accept-Ranges header
  description: |-
    `accept_ranges`

    The `Accept-Ranges` header. Even though the name would indicate that multiple values are supported, it must be one string token only.

    The values `'bytes'` and `'none'` are common.

    Changelog

    New in version 0.7.

    `property access_control_allow_credentials: bool`

    Whether credentials can be shared by the browser to JavaScript code. As part of the preflight request it indicates whether credentials can be used on the cross origin request.
- name: Response.access_control_allow_headers
  id: api/index#flask.Response.access_control_allow_headers
  summary: Which headers can be sent with the cross origin request
  description: |-
    `access_control_allow_headers`

    Which headers can be sent with the cross origin request.
- name: Response.access_control_allow_methods
  id: api/index#flask.Response.access_control_allow_methods
  summary: Which methods can be used for the cross origin request
  description: |-
    `access_control_allow_methods`

    Which methods can be used for the cross origin request.
- name: Response.access_control_allow_origin
  id: api/index#flask.Response.access_control_allow_origin
  summary: The origin or ‘*’ for any origin that may make cross origin requests
  description: |-
    `access_control_allow_origin`

    The origin or ‘\*’ for any origin that may make cross origin requests.
- name: Response.access_control_expose_headers
  id: api/index#flask.Response.access_control_expose_headers
  summary: Which headers can be shared by the browser to JavaScript code
  description: |-
    `access_control_expose_headers`

    Which headers can be shared by the browser to JavaScript code.
- name: Response.access_control_max_age
  id: api/index#flask.Response.access_control_max_age
  summary: The maximum age in seconds the access control settings can be cached for
  description: |-
    `access_control_max_age`

    The maximum age in seconds the access control settings can be cached for.
- name: Response.add_etag()
  id: api/index#flask.Response.add_etag
  summary: Add an etag for the current response if there is none yet
  description: |-
    `add_etag(overwrite=False, weak=False)`

    Add an etag for the current response if there is none yet.

    Changelog

    Changed in version 2.0: SHA-1 is used to generate the value. MD5 may not be available in some environments.

    Parameters:

    - **overwrite** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
    - **weak** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    None
- name: Response.age
  id: api/index#flask.Response.age
  summary: The Age response-header field conveys the sender’s estimate of the amount of time since the response (or its revalidation) was generated at the origin server
  description: |-
    `age`

    The Age response-header field conveys the sender’s estimate of the amount of time since the response (or its revalidation) was generated at the origin server.

    Age values are non-negative decimal integers, representing time in seconds.

    `property allow: HeaderSet`

    The Allow entity-header field lists the set of methods supported by the resource identified by the Request-URI. The purpose of this field is strictly to inform the recipient of valid methods associated with the resource. An Allow header field MUST be present in a 405 (Method Not Allowed) response.
- name: Response.autocorrect_location_header
  id: api/index#flask.Response.autocorrect_location_header
  summary: If a redirect Location header is a relative URL, make it an absolute URL, including scheme and domain
  description: |-
    `autocorrect_location_header = False`

    If a redirect `Location` header is a relative URL, make it an absolute URL, including scheme and domain.

    Changelog

    Changed in version 2.1: This is disabled by default, so responses will send relative redirects.

    New in version 0.8.
- name: Response.automatically_set_content_length
  id: api/index#flask.Response.automatically_set_content_length
  summary: Should this response object automatically set the content-length header if possible? This is true by default
  description: |-
    `automatically_set_content_length = True`

    Should this response object automatically set the content-length header if possible? This is true by default.

    Changelog

    New in version 0.8.

    `property cache_control: ResponseCacheControl`

    The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain.
- name: Response.calculate_content_length()
  id: api/index#flask.Response.calculate_content_length
  summary: Returns the content length if available or None otherwise
  description: |-
    `calculate_content_length()`

    Returns the content length if available or `None` otherwise.

    Return type:

    [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") \| None
- name: Response.call_on_close()
  id: api/index#flask.Response.call_on_close
  summary: Adds a function to the internal list of functions that should be called as part of closing down the response
  description: |-
    `call_on_close(func)`

    Adds a function to the internal list of functions that should be called as part of closing down the response. Since 0.7 this function also returns the function that was passed so that this can be used as a decorator.

    Changelog

    New in version 0.6.

    Parameters:

    **func** ([Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[\],* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]*) –

    Return type:

    [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")\[\[\], [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")\]
- name: Response.close()
  id: api/index#flask.Response.close
  summary: Close the wrapped response if possible
  description: |-
    `close()`

    Close the wrapped response if possible. You can also use the object in a with statement which will automatically close it.

    Changelog

    New in version 0.9: Can now be used in a with statement.

    Return type:

    None
- name: Response.content_encoding
  id: api/index#flask.Response.content_encoding
  summary: The Content-Encoding entity-header field is used as a modifier to the media-type
  description: |-
    `content_encoding`

    The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.

    `property content_language: HeaderSet`

    The Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity. Note that this might not be equivalent to all the languages used within the entity-body.
- name: Response.content_length
  id: api/index#flask.Response.content_length
  summary: The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET
  description: |-
    `content_length`

    The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.
- name: Response.content_location
  id: api/index#flask.Response.content_location
  summary: The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource’s URI
  description: |-
    `content_location`

    The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource’s URI.
- name: Response.content_md5
  id: api/index#flask.Response.content_md5
  summary: The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body
  description: |-
    `content_md5`

    The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)

    `property content_range: ContentRange`

    The `Content-Range` header as a [`ContentRange`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.ContentRange "(in Werkzeug v2.3.x)") object. Available even if the header is not set.

    Changelog

    New in version 0.7.

    `property content_security_policy: ContentSecurityPolicy`

    The `Content-Security-Policy` header as a `ContentSecurityPolicy` object. Available even if the header is not set.

    The Content-Security-Policy header adds an additional layer of security to help detect and mitigate certain types of attacks.

    `property content_security_policy_report_only: ContentSecurityPolicy`

    The `Content-Security-policy-report-only` header as a `ContentSecurityPolicy` object. Available even if the header is not set.

    The Content-Security-Policy-Report-Only header adds a csp policy that is not enforced but is reported thereby helping detect certain types of attacks.
- name: Response.content_type
  id: api/index#flask.Response.content_type
  summary: The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET
  description: |-
    `content_type`

    The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.
- name: Response.cross_origin_embedder_policy
  id: api/index#flask.Response.cross_origin_embedder_policy
  summary: Prevents a document from loading any cross-origin resources that do not explicitly grant the document permission
  description: |-
    `cross_origin_embedder_policy`

    Prevents a document from loading any cross-origin resources that do not explicitly grant the document permission. Values must be a member of the `werkzeug.http.COEP` enum.
- name: Response.cross_origin_opener_policy
  id: api/index#flask.Response.cross_origin_opener_policy
  summary: Allows control over sharing of browsing context group with cross-origin documents
  description: |-
    `cross_origin_opener_policy`

    Allows control over sharing of browsing context group with cross-origin documents. Values must be a member of the `werkzeug.http.COOP` enum.

    `property data: bytes | str`

    A descriptor that calls [`get_data()`](#flask.Response.get_data "flask.Response.get_data") and [`set_data()`](#flask.Response.set_data "flask.Response.set_data").
- name: Response.date
  id: api/index#flask.Response.date
  summary: The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822
  description: |-
    `date`

    The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.

    Changelog

    Changed in version 2.0: The datetime object is timezone-aware.
- name: Response.default_mimetype
  id: api/index#flask.Response.default_mimetype
  summary: the default mimetype if none is provided
  description: |-
    `default_mimetype: str | None = 'text/html'`

    the default mimetype if none is provided.
- name: Response.default_status
  id: api/index#flask.Response.default_status
  summary: the default status if none is provided
  description: |-
    `default_status = 200`

    the default status if none is provided.
- name: Response.delete_cookie()
  id: api/index#flask.Response.delete_cookie
  summary: Delete a cookie
  description: |-
    `delete_cookie(key, path='/', domain=None, secure=False, httponly=False, samesite=None)`

    Delete a cookie. Fails silently if key doesn’t exist.

    Parameters:

    - **key** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – the key (name) of the cookie to be deleted.
    - **path** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – if the cookie that should be deleted was limited to a path, the path has to be defined here.
    - **domain** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – if the cookie that should be deleted was limited to a domain, that domain has to be defined here.
    - **secure** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – If `True`, the cookie will only be available via HTTPS.
    - **httponly** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Disallow JavaScript access to the cookie.
    - **samesite** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – Limit the scope of the cookie to only be attached to requests that are “same-site”.

    Return type:

    None
- name: Response.direct_passthrough
  id: api/index#flask.Response.direct_passthrough
  summary: Pass the response body directly through as the WSGI iterable
  description: |-
    `direct_passthrough`

    Pass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use [`send_file()`](https://werkzeug.palletsprojects.com/en/2.3.x/utils/#werkzeug.utils.send_file "(in Werkzeug v2.3.x)") instead of setting this manually.
- name: Response.expires
  id: api/index#flask.Response.expires
  summary: The Expires entity-header field gives the date/time after which the response is considered stale
  description: |-
    `expires`

    The Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache.

    Changelog

    Changed in version 2.0: The datetime object is timezone-aware.
- name: Response.force_type()
  id: api/index#flask.Response.force_type
  summary: Enforce that the WSGI response is a response object of the current type
  description: |-
    `classmethod force_type(response, environ=None)`

    Enforce that the WSGI response is a response object of the current type. Werkzeug will use the [`Response`](#flask.Response "flask.Response") internally in many situations like the exceptions. If you call `get_response()` on an exception you will get back a regular [`Response`](#flask.Response "flask.Response") object, even if you are using a custom subclass.

    This method can enforce a given response type, and it will also convert arbitrary WSGI callables into response objects if an environ is provided:

    ``` python
    # convert a Werkzeug response object into an instance of the
    # MyResponseClass subclass.
    response = MyResponseClass.force_type(response)

    # convert any WSGI application into a response object
    response = MyResponseClass.force_type(response, environ)
    ```

    This is especially useful if you want to post-process responses in the main dispatcher and use functionality provided by your subclass.

    Keep in mind that this will modify response objects in place if possible!

    Parameters:

    - **response** ([Response](#flask.Response "flask.Response")) – a response object or wsgi application.
    - **environ** (*WSGIEnvironment* *\|* *None*) – a WSGI environment object.

    Returns:

    a response object.

    Return type:

    [Response](#flask.Response "flask.Response")
- name: Response.freeze()
  id: api/index#flask.Response.freeze
  summary: Make the response object ready to be pickled
  description: |-
    `freeze()`

    Make the response object ready to be pickled. Does the following:

    - Buffer the response into a list, ignoring `implicity_sequence_conversion` and [`direct_passthrough`](#flask.Response.direct_passthrough "flask.Response.direct_passthrough").
    - Set the `Content-Length` header.
    - Generate an `ETag` header if one is not already set.

    Changelog

    Changed in version 2.1: Removed the `no_etag` parameter.

    Changed in version 2.0: An `ETag` header is always added.

    Changed in version 0.6: The `Content-Length` header is set.

    Return type:

    None
- name: Response.from_app()
  id: api/index#flask.Response.from_app
  summary: Create a new response object from an application output
  description: |-
    `classmethod from_app(app, environ, buffered=False)`

    Create a new response object from an application output. This works best if you pass it an application that returns a generator all the time. Sometimes applications may use the `write()` callable returned by the `start_response` function. This tries to resolve such edge cases automatically. But if you don’t get the expected output you should set `buffered` to `True` which enforces buffering.

    Parameters:

    - **app** (*WSGIApplication*) – the WSGI application to execute.
    - **environ** (*WSGIEnvironment*) – the WSGI environment to execute against.
    - **buffered** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – set to `True` to enforce buffering.

    Returns:

    a response object.

    Return type:

    [Response](#flask.Response "flask.Response")
- name: Response.get_app_iter()
  id: api/index#flask.Response.get_app_iter
  summary: Returns the application iterator for the given environ
  description: |-
    `get_app_iter(environ)`

    Returns the application iterator for the given environ. Depending on the request method and the current status code the return value might be an empty response rather than the one from the response.

    If the request method is `HEAD` or the status code is in a range where the HTTP specification requires an empty response, an empty iterable is returned.

    Changelog

    New in version 0.6.

    Parameters:

    **environ** (*WSGIEnvironment*) – the WSGI environment of the request.

    Returns:

    a response iterable.

    Return type:

    t.Iterable\[[bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.11)")\]
- name: Response.get_data()
  id: api/index#flask.Response.get_data
  summary: The string representation of the response body
  description: |-
    `get_data(as_text=False)`

    The string representation of the response body. Whenever you call this property the response iterable is encoded and flattened. This can lead to unwanted behavior if you stream big data.

    This behavior can be disabled by setting [`implicit_sequence_conversion`](#flask.Response.implicit_sequence_conversion "flask.Response.implicit_sequence_conversion") to `False`.

    If `as_text` is set to `True` the return value will be a decoded string.

    Changelog

    New in version 0.9.

    Parameters:

    **as_text** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    [bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.11)") \| [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: Response.get_etag()
  id: api/index#flask.Response.get_etag
  summary: Return a tuple in the form (etag, is_weak)
  description: |-
    `get_etag()`

    Return a tuple in the form `(etag, is_weak)`. If there is no ETag the return value is `(None, None)`.

    Return type:

    [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)"), [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")\] \| [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.11)")\[None, None\]
- name: Response.get_json()
  id: api/index#flask.Response.get_json
  summary: Parse data as JSON
  description: |-
    `get_json(force=False, silent=False)`

    Parse [`data`](#flask.Response.data "flask.Response.data") as JSON. Useful during testing.

    If the mimetype does not indicate JSON (*application/json*, see [`is_json`](#flask.Response.is_json "flask.Response.is_json")), this returns `None`.

    Unlike [`Request.get_json()`](#flask.Request.get_json "flask.Request.get_json"), the result is not cached.

    Parameters:

    - **force** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Ignore the mimetype and always try to parse JSON.
    - **silent** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Silence parsing errors and return `None` instead.

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)") \| None
- name: Response.get_wsgi_headers()
  id: api/index#flask.Response.get_wsgi_headers
  summary: This is automatically called right before the response is started and returns headers modified for the given environment
  description: |-
    `get_wsgi_headers(environ)`

    This is automatically called right before the response is started and returns headers modified for the given environment. It returns a copy of the headers from the response with some modifications applied if necessary.

    For example the location header (if present) is joined with the root URL of the environment. Also the content length is automatically set to zero here for certain status codes.

    Changelog

    Changed in version 0.6: Previously that function was called `fix_headers` and modified the response object in place. Also since 0.6, IRIs in location and content-location headers are handled properly.

    Also starting with 0.6, Werkzeug will attempt to set the content length if it is able to figure it out on its own. This is the case if all the strings in the response iterable are already encoded and the iterable is buffered.

    Parameters:

    **environ** (*WSGIEnvironment*) – the WSGI environment of the request.

    Returns:

    returns a new [`Headers`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.Headers "(in Werkzeug v2.3.x)") object.

    Return type:

    Headers
- name: Response.get_wsgi_response()
  id: api/index#flask.Response.get_wsgi_response
  summary: Returns the final WSGI response as tuple
  description: |-
    `get_wsgi_response(environ)`

    Returns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is `'HEAD'` the response will be empty and only the headers and status code will be present.

    Changelog

    New in version 0.6.

    Parameters:

    **environ** (*WSGIEnvironment*) – the WSGI environment of the request.

    Returns:

    an `(app_iter, status, headers)` tuple.

    Return type:

    [tuple](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.11)")\[t.Iterable\[[bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.11)")\], [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)"), [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.11)")\[[tuple](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)"), [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")\]\]\]
- name: Response.implicit_sequence_conversion
  id: api/index#flask.Response.implicit_sequence_conversion
  summary: if set to False accessing properties on the response object will not try to consume the response iterator and convert it into a list
  description: |-
    `implicit_sequence_conversion = True`

    if set to `False` accessing properties on the response object will not try to consume the response iterator and convert it into a list.

    Changelog

    New in version 0.6.2: That attribute was previously called `implicit_seqence_conversion`. (Notice the typo). If you did use this feature, you have to adapt your code to the name change.

    `property is_json: bool`

    Check if the mimetype indicates JSON data, either *application/json* or *application/\*+json*.

    `property is_sequence: bool`

    If the iterator is buffered, this property will be `True`. A response object will consider an iterator to be buffered if the response attribute is a list or tuple.

    Changelog

    New in version 0.6.

    `property is_streamed: bool`

    If the response is streamed (the response is not an iterable with a length information) this property is `True`. In this case streamed means that there is no information about the number of iterations. This is usually `True` if a generator is passed to the response object.

    This is useful for checking before applying some sort of post filtering that should not take place for streamed responses.
- name: Response.iter_encoded()
  id: api/index#flask.Response.iter_encoded
  summary: Iter the response encoded with the encoding of the response
  description: |-
    `iter_encoded()`

    Iter the response encoded with the encoding of the response. If the response object is invoked as WSGI application the return value of this method is used as application iterator unless [`direct_passthrough`](#flask.Response.direct_passthrough "flask.Response.direct_passthrough") was activated.

    Return type:

    [Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator "(in Python v3.11)")\[[bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.11)")\]

    `property json: Any | None`

    The parsed JSON data if [`mimetype`](#flask.Response.mimetype "flask.Response.mimetype") indicates JSON (*application/json*, see [`is_json`](#flask.Response.is_json "flask.Response.is_json")).

    Calls [`get_json()`](#flask.Response.get_json "flask.Response.get_json") with default arguments.
- name: Response.last_modified
  id: api/index#flask.Response.last_modified
  summary: The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified
  description: |-
    `last_modified`

    The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.

    Changelog

    Changed in version 2.0: The datetime object is timezone-aware.
- name: Response.location
  id: api/index#flask.Response.location
  summary: The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource
  description: |-
    `location`

    The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource.
- name: Response.make_conditional()
  id: api/index#flask.Response.make_conditional
  summary: Make the response conditional to the request
  description: |-
    `make_conditional(request_or_environ, accept_ranges=False, complete_length=None)`

    Make the response conditional to the request. This method works best if an etag was defined for the response already. The `add_etag` method can be used to do that. If called without etag just the date header is set.

    This does nothing if the request method in the request or environ is anything but GET or HEAD.

    For optimal performance when handling range requests, it’s recommended that your response data object implements `seekable`, `seek` and `tell` methods as described by [`io.IOBase`](https://docs.python.org/3/library/io.html#io.IOBase "(in Python v3.11)"). Objects returned by `wrap_file()` automatically implement those methods.

    It does not remove the body of the response because that’s something the `__call__()` function does for us automatically.

    Returns self so that you can do `return resp.make_conditional(req)` but modifies the object in-place.

    Parameters:

    - **request_or_environ** (*WSGIEnvironment* *\|* [Request](#flask.Request "flask.Request")) – a request object or WSGI environment to be used to make the response conditional against.
    - **accept_ranges** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)") *\|* [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – This parameter dictates the value of `Accept-Ranges` header. If `False` (default), the header is not set. If `True`, it will be set to `"bytes"`. If it’s a string, it will use this value.
    - **complete_length** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* *None*) – Will be used only in valid Range Requests. It will set `Content-Range` complete length value and compute `Content-Length` real value. This parameter is mandatory for successful Range Requests completion.

    Raises:

    [`RequestedRangeNotSatisfiable`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.RequestedRangeNotSatisfiable "(in Werkzeug v2.3.x)") if `Range` header could not be parsed or satisfied.

    Return type:

    [Response](#flask.Response "flask.Response")

    Changelog

    Changed in version 2.0: Range processing is skipped if length is 0 instead of raising a 416 Range Not Satisfiable error.
- name: Response.make_sequence()
  id: api/index#flask.Response.make_sequence
  summary: Converts the response iterator in a list
  description: |-
    `make_sequence()`

    Converts the response iterator in a list. By default this happens automatically if required. If `implicit_sequence_conversion` is disabled, this method is not automatically called and some properties might raise exceptions. This also encodes all the items.

    Changelog

    New in version 0.6.

    Return type:

    None

    `property max_cookie_size: int`

    Read-only view of the [`MAX_COOKIE_SIZE`](../config/index#MAX_COOKIE_SIZE "MAX_COOKIE_SIZE") config key.

    See [`max_cookie_size`](https://werkzeug.palletsprojects.com/en/2.3.x/wrappers/#werkzeug.wrappers.Response.max_cookie_size "(in Werkzeug v2.3.x)") in Werkzeug’s docs.

    `property mimetype: str | None`

    The mimetype (content type without charset etc.)

    `property mimetype_params: dict[str, str]`

    The mimetype parameters as dict. For example if the content type is `text/html; charset=utf-8` the params would be `{'charset': 'utf-8'}`.

    Changelog

    New in version 0.5.
- name: Response.response
  id: api/index#flask.Response.response
  summary: The response body to send as the WSGI iterable
  description: |-
    `response: t.Iterable[str] | t.Iterable[bytes]`

    The response body to send as the WSGI iterable. A list of strings or bytes represents a fixed-length response, any other iterable is a streaming response. Strings are encoded to bytes as UTF-8.

    Do not set to a plain string or bytes, that will cause sending the response to be very inefficient as it will iterate one byte at a time.

    `property retry_after: datetime | None`

    The Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client.

    Time in seconds until expiration or date.

    Changelog

    Changed in version 2.0: The datetime object is timezone-aware.
- name: Response.set_cookie()
  id: api/index#flask.Response.set_cookie
  summary: Sets a cookie
  description: |-
    `set_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None)`

    Sets a cookie.

    A warning is raised if the size of the cookie header exceeds [`max_cookie_size`](#flask.Response.max_cookie_size "flask.Response.max_cookie_size"), but the header will still be set.

    Parameters:

    - **key** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – the key (name) of the cookie to be set.
    - **value** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – the value of the cookie.
    - **max_age** ([timedelta](https://docs.python.org/3/library/datetime.html#datetime.timedelta "(in Python v3.11)") *\|* [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* *None*) – should be a number of seconds, or `None` (default) if the cookie should last only as long as the client’s browser session.
    - **expires** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [datetime](https://docs.python.org/3/library/datetime.html#datetime.datetime "(in Python v3.11)") *\|* [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.11)") *\|* *None*) – should be a `datetime` object or UNIX timestamp.
    - **path** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – limits the cookie to a given path, per default it will span the whole domain.
    - **domain** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – if you want to set a cross-domain cookie. For example, `domain="example.com"` will set a cookie that is readable by the domain `www.example.com`, `foo.example.com` etc. Otherwise, a cookie will only be readable by the domain that set it.
    - **secure** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – If `True`, the cookie will only be available via HTTPS.
    - **httponly** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Disallow JavaScript access to the cookie.
    - **samesite** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – Limit the scope of the cookie to only be attached to requests that are “same-site”.

    Return type:

    None
- name: Response.set_data()
  id: api/index#flask.Response.set_data
  summary: Sets a new string as response
  description: |-
    `set_data(value)`

    Sets a new string as response. The value must be a string or bytes. If a string is set it’s encoded to the charset of the response (utf-8 by default).

    Changelog

    New in version 0.9.

    Parameters:

    **value** ([bytes](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.11)") *\|* [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    None
- name: Response.set_etag()
  id: api/index#flask.Response.set_etag
  summary: Set the etag, and override the old one if there was one
  description: |-
    `set_etag(etag, weak=False)`

    Set the etag, and override the old one if there was one.

    Parameters:

    - **etag** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **weak** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –

    Return type:

    None

    `property status: str`

    The HTTP status code as a string.

    `property status_code: int`

    The HTTP status code as a number.

    `property stream: ResponseStream`

    The response iterable as write-only stream.

    `property vary: HeaderSet`

    The Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation.

    `property www_authenticate: WWWAuthenticate`

    The `WWW-Authenticate` header parsed into a `WWWAuthenticate` object. Modifying the object will modify the header value.

    This header is not set by default. To set this header, assign an instance of `WWWAuthenticate` to this attribute.

    ``` python
    response.www_authenticate = WWWAuthenticate(
        "basic", {"realm": "Authentication Required"}
    )
    ```

    Multiple values for this header can be sent to give the client multiple options. Assign a list to set multiple headers. However, modifying the items in the list will not automatically update the header values, and accessing this attribute will only ever return the first value.

    To unset this header, assign `None` or use `del`.

    Changelog

    Changed in version 2.3: This attribute can be assigned to to set the header. A list can be assigned to set multiple header values. Use `del` to unset the header.

    Changed in version 2.3: `WWWAuthenticate` is no longer a `dict`. The `token` attribute was added for auth challenges that use a token instead of parameters.

    ## Sessions

    If you have set [`Flask.secret_key`](#flask.Flask.secret_key "flask.Flask.secret_key") (or configured it from [`SECRET_KEY`](../config/index#SECRET_KEY "SECRET_KEY")) you can use sessions in Flask applications. A session makes it possible to remember information from one request to another. The way Flask does this is by using a signed cookie. The user can look at the session contents, but can’t modify it unless they know the secret key, so make sure to set that to something complex and unguessable.

    To access the current session you can use the [`session`](#flask.session "flask.session") object:
- name: ScriptInfo
  id: api/index#flask.cli.ScriptInfo
  summary: Helper object to deal with Flask applications
  description: |-
    `class flask.cli.ScriptInfo(app_import_path=None, create_app=None, set_debug_flag=True)`

    Helper object to deal with Flask applications. This is usually not necessary to interface with as it’s used internally in the dispatching to click. In future versions of Flask this object will most likely play a bigger role. Typically it’s created automatically by the [`FlaskGroup`](#flask.cli.FlaskGroup "flask.cli.FlaskGroup") but you can also manually create it and pass it onwards as click object.

    Parameters:

    - **app_import_path** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) –
    - **create_app** (*t.Callable\[...,* [Flask](#flask.Flask "flask.Flask")*\]* *\|* *None*) –
    - **set_debug_flag** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) –
- name: ScriptInfo.app_import_path
  id: api/index#flask.cli.ScriptInfo.app_import_path
  summary: Optionally the import path for the Flask application
  description: |-
    `app_import_path`

    Optionally the import path for the Flask application.
- name: ScriptInfo.create_app
  id: api/index#flask.cli.ScriptInfo.create_app
  summary: Optionally a function that is passed the script info to create the instance of the application
  description: |-
    `create_app`

    Optionally a function that is passed the script info to create the instance of the application.
- name: ScriptInfo.data
  id: api/index#flask.cli.ScriptInfo.data
  summary: A dictionary with arbitrary data that can be associated with this script info
  description: |-
    `data: dict[t.Any, t.Any]`

    A dictionary with arbitrary data that can be associated with this script info.
- name: ScriptInfo.load_app()
  id: api/index#flask.cli.ScriptInfo.load_app
  summary: Loads the Flask app (if not yet loaded) and returns it
  description: |-
    `load_app()`

    Loads the Flask app (if not yet loaded) and returns it. Calling this multiple times will just result in the already loaded app to be returned.

    Return type:

    [Flask](#flask.Flask "flask.Flask")
- name: SECRET_KEY
  id: config/index#SECRET_KEY
  summary: A secret key that will be used for securely signing the session cookie and can be used for any other security related needs by extensions or your application
  belongs_to: Configuration Handling
  description: |-
    `SECRET_KEY`

    A secret key that will be used for securely signing the session cookie and can be used for any other security related needs by extensions or your application. It should be a long random `bytes` or `str`. For example, copy the output of this to your config:

    ``` python
    $ python -c 'import secrets; print(secrets.token_hex())'
    '192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'
    ```

    **Do not reveal the secret key when posting questions or committing code.**

    Default: `None`
- name: SecureCookieSession
  id: api/index#flask.sessions.SecureCookieSession
  summary: Base class for sessions based on signed cookies
  description: |-
    `class flask.sessions.SecureCookieSession(initial=None)`

    Base class for sessions based on signed cookies.

    This session backend will set the [`modified`](#flask.sessions.SecureCookieSession.modified "flask.sessions.SecureCookieSession.modified") and [`accessed`](#flask.sessions.SecureCookieSession.accessed "flask.sessions.SecureCookieSession.accessed") attributes. It cannot reliably track whether a session is new (vs. empty), so `new` remains hard coded to `False`.

    Parameters:

    **initial** (*t.Any*) –
- name: SecureCookieSession.accessed
  id: api/index#flask.sessions.SecureCookieSession.accessed
  summary: header, which allows caching proxies to cache different pages for different users
  description: |-
    `accessed = False`

    header, which allows caching proxies to cache different pages for different users.
- name: SecureCookieSession.get()
  id: api/index#flask.sessions.SecureCookieSession.get
  summary: Return the value for key if key is in the dictionary, else default
  description: |-
    `get(key, default=None)`

    Return the value for key if key is in the dictionary, else default.

    Parameters:

    - **key** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **default** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)") *\|* *None*) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: SecureCookieSession.modified
  id: api/index#flask.sessions.SecureCookieSession.modified
  summary: When data is changed, this is set to True
  description: |-
    `modified = False`

    When data is changed, this is set to `True`. Only the session dictionary itself is tracked; if the session contains mutable data (for example a nested dict) then this must be set to `True` manually when modifying that data. The session cookie will only be written to the response if this is `True`.
- name: SecureCookieSession.setdefault()
  id: api/index#flask.sessions.SecureCookieSession.setdefault
  summary: Insert key with a value of default if key is not in the dictionary
  description: |-
    `setdefault(key, default=None)`

    Insert key with a value of default if key is not in the dictionary.

    Return the value for key if key is in the dictionary, else default.

    Parameters:

    - **key** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **default** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)") *\|* *None*) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: SecureCookieSessionInterface
  id: api/index#flask.sessions.SecureCookieSessionInterface
  summary: The default session interface that stores sessions in signed cookies through the itsdangerous module
  description: |-
    `class flask.sessions.SecureCookieSessionInterface`

    The default session interface that stores sessions in signed cookies through the `itsdangerous` module.
- name: SecureCookieSessionInterface.digest_method()
  id: api/index#flask.sessions.SecureCookieSessionInterface.digest_method
  summary: the hash function to use for the signature
  description: |-
    `static digest_method(string=b'', *, usedforsecurity=True)`

    the hash function to use for the signature. The default is sha1
- name: SecureCookieSessionInterface.key_derivation
  id: api/index#flask.sessions.SecureCookieSessionInterface.key_derivation
  summary: the name of the itsdangerous supported key derivation
  description: |-
    `key_derivation = 'hmac'`

    the name of the itsdangerous supported key derivation. The default is hmac.
- name: SecureCookieSessionInterface.open_session()
  id: api/index#flask.sessions.SecureCookieSessionInterface.open_session
  summary: This is called at the beginning of each request, after pushing the request context, before matching the URL
  description: |-
    `open_session(app, request)`

    This is called at the beginning of each request, after pushing the request context, before matching the URL.

    This must return an object which implements a dictionary-like interface as well as the [`SessionMixin`](#flask.sessions.SessionMixin "flask.sessions.SessionMixin") interface.

    This will return `None` to indicate that loading failed in some way that is not immediately an error. The request context will fall back to using `make_null_session()` in this case.

    Parameters:

    - **app** ([Flask](#flask.Flask "flask.Flask")) –
    - **request** ([Request](#flask.Request "flask.Request")) –

    Return type:

    [SecureCookieSession](#flask.sessions.SecureCookieSession "flask.sessions.SecureCookieSession") \| None
- name: SecureCookieSessionInterface.salt
  id: api/index#flask.sessions.SecureCookieSessionInterface.salt
  summary: the salt that should be applied on top of the secret key for the signing of cookie based sessions
  description: |-
    `salt = 'cookie-session'`

    the salt that should be applied on top of the secret key for the signing of cookie based sessions.
- name: SecureCookieSessionInterface.save_session()
  id: api/index#flask.sessions.SecureCookieSessionInterface.save_session
  summary: This is called at the end of each request, after generating a response, before removing the request context
  description: |-
    `save_session(app, session, response)`

    This is called at the end of each request, after generating a response, before removing the request context. It is skipped if `is_null_session()` returns `True`.

    Parameters:

    - **app** ([Flask](#flask.Flask "flask.Flask")) –
    - **session** ([SessionMixin](#flask.sessions.SessionMixin "flask.sessions.SessionMixin")) –
    - **response** ([Response](#flask.Response "flask.Response")) –

    Return type:

    None
- name: SecureCookieSessionInterface.serializer
  id: api/index#flask.sessions.SecureCookieSessionInterface.serializer
  summary: A python serializer for the payload
  description: |-
    `serializer = <flask.json.tag.TaggedJSONSerializer object>`

    A python serializer for the payload. The default is a compact JSON derived serializer with support for some extra Python types such as datetime objects or tuples.
- name: SecureCookieSessionInterface.session_class
  id: api/index#flask.sessions.SecureCookieSessionInterface.session_class
  summary: null
  description: |-
    `session_class`

    alias of [`SecureCookieSession`](#flask.sessions.SecureCookieSession "flask.sessions.SecureCookieSession")
- name: Security Considerations
  id: security/index
  summary: Web applications usually face all kinds of security problems and it’s very hard to get everything right
  description: "# Security Considerations\n\nWeb applications usually face all kinds of security problems and it’s very hard to get everything right. Flask tries to solve a few of these things for you, but there are a couple more you have to take care of yourself.\n\n## Cross-Site Scripting (XSS)\n\nCross site scripting is the concept of injecting arbitrary HTML (and with it JavaScript) into the context of a website. To remedy this, developers have to properly escape text so that it cannot include arbitrary HTML tags. For more information on that have a look at the Wikipedia article on [Cross-Site Scripting](https://en.wikipedia.org/wiki/Cross-site_scripting).\n\nFlask configures Jinja2 to automatically escape all values unless explicitly told otherwise. This should rule out all XSS problems caused in templates, but there are still other places where you have to be careful:\n\n- generating HTML without the help of Jinja2\n- calling `Markup` on data submitted by users\n- sending out HTML from uploaded files, never do that, use the `Content-Disposition: attachment` header to prevent that problem.\n- sending out textfiles from uploaded files. Some browsers are using content-type guessing based on the first few bytes so users could trick a browser to execute HTML.\n\nAnother thing that is very important are unquoted attributes. While Jinja2 can protect you from XSS issues by escaping HTML, there is one thing it cannot protect you from: XSS by attribute injection. To counter this possible attack vector, be sure to always quote your attributes with either double or single quotes when using Jinja expressions in them:\n\n``` html+jinja\n<input value=\"{{ value }}\">\n```\n\nWhy is this necessary? Because if you would not be doing that, an attacker could easily inject custom JavaScript handlers. For example an attacker could inject this piece of HTML+JavaScript:\n\n``` html\nonmouseover=alert(document.cookie)\n```\n\nWhen the user would then move with the mouse over the input, the cookie would be presented to the user in an alert window. But instead of showing the cookie to the user, a good attacker might also execute any other JavaScript code. In combination with CSS injections the attacker might even make the element fill out the entire page so that the user would just have to have the mouse anywhere on the page to trigger the attack.\n\nThere is one class of XSS issues that Jinja’s escaping does not protect against. The `a` tag’s `href` attribute can contain a `javascript:` URI, which the browser will execute when clicked if not secured properly.\n\n``` html\n<a href=\"{{ value }}\">click here</a>\n<a href=\"javascript:alert('unsafe');\">click here</a>\n```\n\nTo prevent this, you’ll need to set the [Content Security Policy (CSP)](#security-csp) response header.\n\n## Cross-Site Request Forgery (CSRF)\n\nAnother big problem is CSRF. This is a very complex topic and I won’t outline it here in detail just mention what it is and how to theoretically prevent it.\n\nIf your authentication information is stored in cookies, you have implicit state management. The state of “being logged in” is controlled by a cookie, and that cookie is sent with each request to a page. Unfortunately that includes requests triggered by 3rd party sites. If you don’t keep that in mind, some people might be able to trick your application’s users with social engineering to do stupid things without them knowing.\n\nSay you have a specific URL that, when you sent `POST` requests to will delete a user’s profile (say `http://example.com/user/delete`). If an attacker now creates a page that sends a post request to that page with some JavaScript they just have to trick some users to load that page and their profiles will end up being deleted.\n\nImagine you were to run Facebook with millions of concurrent users and someone would send out links to images of little kittens. When users would go to that page, their profiles would get deleted while they are looking at images of fluffy cats.\n\nHow can you prevent that? Basically for each request that modifies content on the server you would have to either use a one-time token and store that in the cookie **and** also transmit it with the form data. After receiving the data on the server again, you would then have to compare the two tokens and ensure they are equal.\n\nWhy does Flask not do that for you? The ideal place for this to happen is the form validation framework, which does not exist in Flask.\n\n## JSON Security\n\nIn Flask 0.10 and lower, `jsonify()` did not serialize top-level arrays to JSON. This was because of a security vulnerability in ECMAScript 4.\n\nECMAScript 5 closed this vulnerability, so only extremely old browsers are still vulnerable. All of these browsers have [other more serious vulnerabilities](https://github.com/pallets/flask/issues/248#issuecomment-59934857), so this behavior was changed and `jsonify()` now supports serializing arrays.\n\n## Security Headers\n\nBrowsers recognize various response headers in order to control security. We recommend reviewing each of the headers below for use in your application. The [Flask-Talisman](https://github.com/GoogleCloudPlatform/flask-talisman) extension can be used to manage HTTPS and the security headers for you.\n\n### HTTP Strict Transport Security (HSTS)\n\nTells the browser to convert all HTTP requests to HTTPS, preventing man-in-the-middle (MITM) attacks.\n\n``` python\nresponse.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\n```\n\n- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security)\n\n### Content Security Policy (CSP)\n\nTell the browser where it can load various types of resource from. This header should be used whenever possible, but requires some work to define the correct policy for your site. A very strict policy would be:\n\n``` python\nresponse.headers['Content-Security-Policy'] = \"default-src 'self'\"\n```\n\n- [https://csp.withgoogle.com/docs/index.html](https://csp.withgoogle.com/docs/index.html)\n- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)\n\n### X-Content-Type-Options\n\nForces the browser to honor the response content type instead of trying to detect it, which can be abused to generate a cross-site scripting (XSS) attack.\n\n``` python\nresponse.headers['X-Content-Type-Options'] = 'nosniff'\n```\n\n- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options)\n\n### X-Frame-Options\n\nPrevents external sites from embedding your site in an `iframe`. This prevents a class of attacks where clicks in the outer frame can be translated invisibly to clicks on your page’s elements. This is also known as “clickjacking”.\n\n``` python\nresponse.headers['X-Frame-Options'] = 'SAMEORIGIN'\n```\n\n- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options)\n\n### Set-Cookie options\n\nThese options can be added to a `Set-Cookie` header to improve their security. Flask has configuration options to set these on the session cookie. They can be set on other cookies too.\n\n- `Secure` limits cookies to HTTPS traffic only.\n- `HttpOnly` protects the contents of cookies from being read with JavaScript.\n- `SameSite` restricts how cookies are sent with requests from external sites. Can be set to `'Lax'` (recommended) or `'Strict'`. `Lax` prevents sending cookies with CSRF-prone requests from external sites, such as submitting a form. `Strict` prevents sending cookies with all external requests, including following regular links.\n\n``` python\napp.config.update(\n    SESSION_COOKIE_SECURE=True,\n    SESSION_COOKIE_HTTPONLY=True,\n    SESSION_COOKIE_SAMESITE='Lax',\n)\n\nresponse.set_cookie('username', 'flask', secure=True, httponly=True, samesite='Lax')\n```\n\nSpecifying `Expires` or `Max-Age` options, will remove the cookie after the given time, or the current time plus the age, respectively. If neither option is set, the cookie will be removed when the browser is closed.\n\n``` python\n# cookie expires after 10 minutes\nresponse.set_cookie('snakes', '3', max_age=600)\n```\n\nFor the session cookie, if [`session.permanent`](../api/index#flask.session.permanent \"flask.session.permanent\") is set, then [`PERMANENT_SESSION_LIFETIME`](../config/index#PERMANENT_SESSION_LIFETIME \"PERMANENT_SESSION_LIFETIME\") is used to set the expiration. Flask’s default cookie implementation validates that the cryptographic signature is not older than this value. Lowering this value may help mitigate replay attacks, where intercepted cookies can be sent at a later time.\n\n``` python\napp.config.update(\n    PERMANENT_SESSION_LIFETIME=600\n)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    ...\n    session.clear()\n    session['user_id'] = user.id\n    session.permanent = True\n    ...\n```\n\nUse `itsdangerous.TimedSerializer` to sign and validate other cookie values (or any values that need secure signatures).\n\n- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)\n- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie)\n\n### HTTP Public Key Pinning (HPKP)\n\nThis tells the browser to authenticate with the server using only the specific certificate key to prevent MITM attacks.\n\nWarning\n\nBe careful when enabling this, as it is very difficult to undo if you set up or upgrade your key incorrectly.\n\n- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning](https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning)\n\n## Copy/Paste to Terminal\n\nHidden characters such as the backspace character (`\\b`, `^H`) can cause text to render differently in HTML than how it is interpreted if [pasted into a terminal](https://security.stackexchange.com/q/39118).\n\nFor example, `import y\\bose\\bm\\bi\\bt\\be\\b` renders as `import yosemite` in HTML, but the backspaces are applied when pasted into a terminal, and it becomes `import os`.\n\nIf you expect users to copy and paste untrusted code from your site, such as from comments posted by users on a technical blog, consider applying extra filtering, such as replacing all `\\b` characters.\n\n``` python\nbody = body.replace(\"\\b\", \"\")\n```\n\nMost modern terminals will warn about and remove hidden characters when pasting, so this isn’t strictly necessary. It’s also possible to craft dangerous commands in other ways that aren’t possible to filter. Depending on your site’s use case, it may be good to show a warning about copying code in general.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/security/](https://flask.palletsprojects.com/en/3.0.x/security/)"
- name: send_file()
  id: api/index#flask.send_file
  summary: Send the contents of a file to the client
  description: |-
    `flask.send_file(path_or_file, mimetype=None, as_attachment=False, download_name=None, conditional=True, etag=True, last_modified=None, max_age=None)`

    Send the contents of a file to the client.

    The first argument can be a file path or a file-like object. Paths are preferred in most cases because Werkzeug can manage the file and get extra information from the path. Passing a file-like object requires that the file is opened in binary mode, and is mostly useful when building a file in memory with [`io.BytesIO`](https://docs.python.org/3/library/io.html#io.BytesIO "(in Python v3.11)").

    Never pass file paths provided by a user. The path is assumed to be trusted, so a user could craft a path to access a file you didn’t intend. Use [`send_from_directory()`](#flask.send_from_directory "flask.send_from_directory") to safely serve user-requested paths from within a directory.

    If the WSGI server sets a `file_wrapper` in `environ`, it is used, otherwise Werkzeug’s built-in wrapper is used. Alternatively, if the HTTP server supports `X-Sendfile`, configuring Flask with `USE_X_SENDFILE = True` will tell the server to send the given path, which is much more efficient than reading it in Python.

    Parameters:

    - **path_or_file** ([os.PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)") *\|* [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *t.BinaryIO*) – The path to the file to send, relative to the current working directory if a relative path is given. Alternatively, a file-like object opened in binary mode. Make sure the file pointer is seeked to the start of the data.
    - **mimetype** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – The MIME type to send for the file. If not provided, it will try to detect it from the file name.
    - **as_attachment** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Indicate to a browser that it should offer to save the file instead of displaying it.
    - **download_name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – The default name browsers will use when saving the file. Defaults to the passed file name.
    - **conditional** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – Enable conditional and range responses based on request headers. Requires passing a file path and `environ`.
    - **etag** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)") *\|* [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – Calculate an ETag for the file, which requires passing a file path. Can also be a string to use instead.
    - **last_modified** (*datetime* *\|* [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.11)") *\|* *None*) – The last modified time to send for the file, in seconds. If not provided, it will try to detect it from the file path.
    - **max_age** (*None* *\|* *(*[int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* *t.Callable\[\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None\],* [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* *None\])*) – How long the client should cache the file, in seconds. If set, `Cache-Control` will be `public`, otherwise it will be `no-cache` to prefer conditional caching.

    Return type:

    [Response](#flask.Response "flask.Response")

    Changelog

    Changed in version 2.0: `download_name` replaces the `attachment_filename` parameter. If `as_attachment=False`, it is passed with `Content-Disposition: inline` instead.

    Changed in version 2.0: `max_age` replaces the `cache_timeout` parameter. `conditional` is enabled and `max_age` is not set by default.

    Changed in version 2.0: `etag` replaces the `add_etags` parameter. It can be a string to use instead of generating one.

    Changed in version 2.0: Passing a file-like object that inherits from [`TextIOBase`](https://docs.python.org/3/library/io.html#io.TextIOBase "(in Python v3.11)") will raise a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError "(in Python v3.11)") rather than sending an empty file.

    New in version 2.0: Moved the implementation to Werkzeug. This is now a wrapper to pass some Flask-specific arguments.

    Changed in version 1.1: `filename` may be a [`PathLike`](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)") object.

    Changed in version 1.1: Passing a [`BytesIO`](https://docs.python.org/3/library/io.html#io.BytesIO "(in Python v3.11)") object supports range requests.

    Changed in version 1.0.3: Filenames are encoded with ASCII instead of Latin-1 for broader compatibility with WSGI servers.

    Changed in version 1.0: UTF-8 filenames as specified in [**RFC 2231**](https://datatracker.ietf.org/doc/html/rfc2231.html) are supported.

    Changed in version 0.12: The filename is no longer automatically inferred from file objects. If you want to use automatic MIME and etag support, pass a filename via `filename_or_fp` or `attachment_filename`.

    Changed in version 0.12: `attachment_filename` is preferred over `filename` for MIME detection.

    Changed in version 0.9: `cache_timeout` defaults to [`Flask.get_send_file_max_age()`](#flask.Flask.get_send_file_max_age "flask.Flask.get_send_file_max_age").

    Changed in version 0.7: MIME guessing and etag support for file-like objects was removed because it was unreliable. Pass a filename if you are able to, otherwise attach an etag yourself.

    Changed in version 0.5: The `add_etags`, `cache_timeout` and `conditional` parameters were added. The default behavior is to add etags.

    New in version 0.2.
- name: SEND_FILE_MAX_AGE_DEFAULT
  id: config/index#SEND_FILE_MAX_AGE_DEFAULT
  summary: When serving files, set the cache control max age to this number of seconds
  belongs_to: Configuration Handling
  description: |-
    `SEND_FILE_MAX_AGE_DEFAULT`

    When serving files, set the cache control max age to this number of seconds. Can be a [`datetime.timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta "(in Python v3.11)") or an `int`. Override this value on a per-file basis using [`get_send_file_max_age()`](../api/index#flask.Flask.get_send_file_max_age "flask.Flask.get_send_file_max_age") on the application or blueprint.

    If `None`, `send_file` tells the browser to use conditional requests will be used instead of a timed cache, which is usually preferable.

    Default: `None`
- name: send_from_directory()
  id: api/index#flask.send_from_directory
  summary: Send a file from within a directory using send_file()
  description: |-
    `flask.send_from_directory(directory, path, **kwargs)`

    Send a file from within a directory using [`send_file()`](#flask.send_file "flask.send_file").

    ``` python
    @app.route("/uploads/<path:name>")
    def download_file(name):
        return send_from_directory(
            app.config['UPLOAD_FOLDER'], name, as_attachment=True
        )
    ```

    This is a secure way to serve files from a folder, such as static files or uploads. Uses [`safe_join()`](https://werkzeug.palletsprojects.com/en/2.3.x/utils/#werkzeug.security.safe_join "(in Werkzeug v2.3.x)") to ensure the path coming from the client is not maliciously crafted to point outside the specified directory.

    If the final path does not point to an existing regular file, raises a 404 [`NotFound`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.NotFound "(in Werkzeug v2.3.x)") error.

    Parameters:

    - **directory** ([os.PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)") *\|* [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The directory that `path` must be located under, relative to the current application’s root path.
    - **path** ([os.PathLike](https://docs.python.org/3/library/os.html#os.PathLike "(in Python v3.11)") *\|* [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The path to the file to send, relative to `directory`.
    - **kwargs** (*t.Any*) – Arguments to pass to [`send_file()`](#flask.send_file "flask.send_file").

    Return type:

    [Response](#flask.Response "flask.Response")

    Changelog

    Changed in version 2.0: `path` replaces the `filename` parameter.

    New in version 2.0: Moved the implementation to Werkzeug. This is now a wrapper to pass some Flask-specific arguments.

    New in version 0.5.

    ## Message Flashing
- name: SERVER_NAME
  id: config/index#SERVER_NAME
  summary: Inform the application what host and port it is bound to
  belongs_to: Configuration Handling
  description: |-
    `SERVER_NAME`

    Inform the application what host and port it is bound to. Required for subdomain route matching support.

    If set, `url_for` can generate external URLs with only an application context instead of a request context.

    Default: `None`

    Changelog

    Changed in version 2.3: Does not affect `SESSION_COOKIE_DOMAIN`.
- name: session
  id: api/index#flask.session
  summary: The session object works pretty much like an ordinary dict, with the difference that it keeps track of modifications
  description: |-
    `class flask.session`

    The session object works pretty much like an ordinary dict, with the difference that it keeps track of modifications.

    This is a proxy. See [Notes On Proxies](../reqcontext/index#notes-on-proxies) for more information.

    The following attributes are interesting:
- name: session.modified
  id: api/index#flask.session.modified
  summary: True if the session object detected a modification
  description: |-
    `modified`

    `True` if the session object detected a modification. Be advised that modifications on mutable structures are not picked up automatically, in that situation you have to explicitly set the attribute to `True` yourself. Here an example:

    ``` python
    # this change is not picked up because a mutable object (here
    # a list) is changed.
    session['objects'].append(42)
    # so mark it as modified yourself
    session.modified = True
    ```
- name: session.new
  id: api/index#flask.session.new
  summary: True if the session is new, False otherwise
  description: |-
    `new`

    `True` if the session is new, `False` otherwise.
- name: session.permanent
  id: api/index#flask.session.permanent
  summary: If set to True the session lives for permanent_session_lifetime seconds
  description: |-
    `permanent`

    If set to `True` the session lives for [`permanent_session_lifetime`](#flask.Flask.permanent_session_lifetime "flask.Flask.permanent_session_lifetime") seconds. The default is 31 days. If set to `False` (which is the default) the session will be deleted when the user closes the browser.

    ## Session Interface

    Changelog

    New in version 0.8.

    The session interface provides a simple way to replace the session implementation that Flask is using.
- name: SESSION_COOKIE_DOMAIN
  id: config/index#SESSION_COOKIE_DOMAIN
  summary: The value of the Domain parameter on the session cookie
  belongs_to: Configuration Handling
  description: |-
    `SESSION_COOKIE_DOMAIN`

    The value of the `Domain` parameter on the session cookie. If not set, browsers will only send the cookie to the exact domain it was set from. Otherwise, they will send it to any subdomain of the given value as well.

    Not setting this value is more restricted and secure than setting it.

    Default: `None`

    Changelog

    Changed in version 2.3: Not set by default, does not fall back to `SERVER_NAME`.
- name: SESSION_COOKIE_HTTPONLY
  id: config/index#SESSION_COOKIE_HTTPONLY
  summary: Browsers will not allow JavaScript access to cookies marked as “HTTP only” for security
  belongs_to: Configuration Handling
  description: |-
    `SESSION_COOKIE_HTTPONLY`

    Browsers will not allow JavaScript access to cookies marked as “HTTP only” for security.

    Default: `True`
- name: SESSION_COOKIE_NAME
  id: config/index#SESSION_COOKIE_NAME
  summary: The name of the session cookie
  belongs_to: Configuration Handling
  description: |-
    `SESSION_COOKIE_NAME`

    The name of the session cookie. Can be changed in case you already have a cookie with the same name.

    Default: `'session'`
- name: SESSION_COOKIE_PATH
  id: config/index#SESSION_COOKIE_PATH
  summary: The path that the session cookie will be valid for
  belongs_to: Configuration Handling
  description: |-
    `SESSION_COOKIE_PATH`

    The path that the session cookie will be valid for. If not set, the cookie will be valid underneath `APPLICATION_ROOT` or `/` if that is not set.

    Default: `None`
- name: SESSION_COOKIE_SAMESITE
  id: config/index#SESSION_COOKIE_SAMESITE
  summary: Restrict how cookies are sent with requests from external sites
  belongs_to: Configuration Handling
  description: |-
    `SESSION_COOKIE_SAMESITE`

    Restrict how cookies are sent with requests from external sites. Can be set to `'Lax'` (recommended) or `'Strict'`. See [Set-Cookie options](../security/index#security-cookie).

    Default: `None`

    Changelog

    New in version 1.0.
- name: SESSION_COOKIE_SECURE
  id: config/index#SESSION_COOKIE_SECURE
  summary: Browsers will only send cookies with requests over HTTPS if the cookie is marked “secure”. The application must be served over HTTPS for this to make sense
  belongs_to: Configuration Handling
  description: |-
    `SESSION_COOKIE_SECURE`

    Browsers will only send cookies with requests over HTTPS if the cookie is marked “secure”. The application must be served over HTTPS for this to make sense.

    Default: `False`
- name: SESSION_REFRESH_EACH_REQUEST
  id: config/index#SESSION_REFRESH_EACH_REQUEST
  summary: Control whether the cookie is sent with every response when session.permanent is true
  belongs_to: Configuration Handling
  description: |-
    `SESSION_REFRESH_EACH_REQUEST`

    Control whether the cookie is sent with every response when `session.permanent` is true. Sending the cookie every time (the default) can more reliably keep the session from expiring, but uses more bandwidth. Non-permanent sessions are not affected.

    Default: `True`
- name: SessionInterface
  id: api/index#flask.sessions.SessionInterface
  summary: The basic interface you have to implement in order to replace the default session interface which uses werkzeug’s securecookie implementation
  description: |-
    `class flask.sessions.SessionInterface`

    The basic interface you have to implement in order to replace the default session interface which uses werkzeug’s securecookie implementation. The only methods you have to implement are [`open_session()`](#flask.sessions.SessionInterface.open_session "flask.sessions.SessionInterface.open_session") and [`save_session()`](#flask.sessions.SessionInterface.save_session "flask.sessions.SessionInterface.save_session"), the others have useful defaults which you don’t need to change.

    The session object returned by the [`open_session()`](#flask.sessions.SessionInterface.open_session "flask.sessions.SessionInterface.open_session") method has to provide a dictionary like interface plus the properties and methods from the [`SessionMixin`](#flask.sessions.SessionMixin "flask.sessions.SessionMixin"). We recommend just subclassing a dict and adding that mixin:

    ``` python
    class Session(dict, SessionMixin):
        pass
    ```

    If [`open_session()`](#flask.sessions.SessionInterface.open_session "flask.sessions.SessionInterface.open_session") returns `None` Flask will call into [`make_null_session()`](#flask.sessions.SessionInterface.make_null_session "flask.sessions.SessionInterface.make_null_session") to create a session that acts as replacement if the session support cannot work because some requirement is not fulfilled. The default [`NullSession`](#flask.sessions.NullSession "flask.sessions.NullSession") class that is created will complain that the secret key was not set.

    To replace the session interface on an application all you have to do is to assign [`flask.Flask.session_interface`](#flask.Flask.session_interface "flask.Flask.session_interface"):

    ``` python
    app = Flask(__name__)
    app.session_interface = MySessionInterface()
    ```

    Multiple requests with the same session may be sent and handled concurrently. When implementing a new session interface, consider whether reads or writes to the backing store must be synchronized. There is no guarantee on the order in which the session for each request is opened or saved, it will occur in the order that requests begin and end processing.

    Changelog

    New in version 0.8.
- name: SessionInterface.get_cookie_domain()
  id: api/index#flask.sessions.SessionInterface.get_cookie_domain
  summary: The value of the Domain parameter on the session cookie
  description: |-
    `get_cookie_domain(app)`

    The value of the `Domain` parameter on the session cookie. If not set, browsers will only send the cookie to the exact domain it was set from. Otherwise, they will send it to any subdomain of the given value as well.

    Uses the [`SESSION_COOKIE_DOMAIN`](../config/index#SESSION_COOKIE_DOMAIN "SESSION_COOKIE_DOMAIN") config.

    Changelog

    Changed in version 2.3: Not set by default, does not fall back to `SERVER_NAME`.

    Parameters:

    **app** ([Flask](#flask.Flask "flask.Flask")) –

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") \| None
- name: SessionInterface.get_cookie_httponly()
  id: api/index#flask.sessions.SessionInterface.get_cookie_httponly
  summary: Returns True if the session cookie should be httponly
  description: |-
    `get_cookie_httponly(app)`

    Returns True if the session cookie should be httponly. This currently just returns the value of the `SESSION_COOKIE_HTTPONLY` config var.

    Parameters:

    **app** ([Flask](#flask.Flask "flask.Flask")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: SessionInterface.get_cookie_name()
  id: api/index#flask.sessions.SessionInterface.get_cookie_name
  summary: The name of the session cookie
  description: |-
    `get_cookie_name(app)`

    The name of the session cookie. Uses\`\`app.config\[“SESSION_COOKIE_NAME”\]\`\`.

    Parameters:

    **app** ([Flask](#flask.Flask "flask.Flask")) –

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: SessionInterface.get_cookie_path()
  id: api/index#flask.sessions.SessionInterface.get_cookie_path
  summary: Returns the path for which the cookie should be valid
  description: |-
    `get_cookie_path(app)`

    Returns the path for which the cookie should be valid. The default implementation uses the value from the `SESSION_COOKIE_PATH` config var if it’s set, and falls back to `APPLICATION_ROOT` or uses `/` if it’s `None`.

    Parameters:

    **app** ([Flask](#flask.Flask "flask.Flask")) –

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: SessionInterface.get_cookie_samesite()
  id: api/index#flask.sessions.SessionInterface.get_cookie_samesite
  summary: Return 'Strict' or 'Lax' if the cookie should use the SameSite attribute
  description: |-
    `get_cookie_samesite(app)`

    Return `'Strict'` or `'Lax'` if the cookie should use the `SameSite` attribute. This currently just returns the value of the [`SESSION_COOKIE_SAMESITE`](../config/index#SESSION_COOKIE_SAMESITE "SESSION_COOKIE_SAMESITE") setting.

    Parameters:

    **app** ([Flask](#flask.Flask "flask.Flask")) –

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: SessionInterface.get_cookie_secure()
  id: api/index#flask.sessions.SessionInterface.get_cookie_secure
  summary: Returns True if the cookie should be secure
  description: |-
    `get_cookie_secure(app)`

    Returns True if the cookie should be secure. This currently just returns the value of the `SESSION_COOKIE_SECURE` setting.

    Parameters:

    **app** ([Flask](#flask.Flask "flask.Flask")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: SessionInterface.get_expiration_time()
  id: api/index#flask.sessions.SessionInterface.get_expiration_time
  summary: A helper method that returns an expiration date for the session or None if the session is linked to the browser session
  description: |-
    `get_expiration_time(app, session)`

    A helper method that returns an expiration date for the session or `None` if the session is linked to the browser session. The default implementation returns now + the permanent session lifetime configured on the application.

    Parameters:

    - **app** ([Flask](#flask.Flask "flask.Flask")) –
    - **session** ([SessionMixin](#flask.sessions.SessionMixin "flask.sessions.SessionMixin")) –

    Return type:

    datetime \| None
- name: SessionInterface.is_null_session()
  id: api/index#flask.sessions.SessionInterface.is_null_session
  summary: Checks if a given object is a null session
  description: |-
    `is_null_session(obj)`

    Checks if a given object is a null session. Null sessions are not asked to be saved.

    This checks if the object is an instance of [`null_session_class`](#flask.sessions.SessionInterface.null_session_class "flask.sessions.SessionInterface.null_session_class") by default.

    Parameters:

    **obj** ([object](https://docs.python.org/3/library/functions.html#object "(in Python v3.11)")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: SessionInterface.make_null_session()
  id: api/index#flask.sessions.SessionInterface.make_null_session
  summary: Creates a null session which acts as a replacement object if the real session support could not be loaded due to a configuration error
  description: |-
    `make_null_session(app)`

    Creates a null session which acts as a replacement object if the real session support could not be loaded due to a configuration error. This mainly aids the user experience because the job of the null session is to still support lookup without complaining but modifications are answered with a helpful error message of what failed.

    This creates an instance of [`null_session_class`](#flask.sessions.SessionInterface.null_session_class "flask.sessions.SessionInterface.null_session_class") by default.

    Parameters:

    **app** ([Flask](#flask.Flask "flask.Flask")) –

    Return type:

    [NullSession](#flask.sessions.NullSession "flask.sessions.NullSession")
- name: SessionInterface.null_session_class
  id: api/index#flask.sessions.SessionInterface.null_session_class
  summary: make_null_session() will look here for the class that should be created when a null session is requested
  description: |-
    `null_session_class`

    [`make_null_session()`](#flask.sessions.SessionInterface.make_null_session "flask.sessions.SessionInterface.make_null_session") will look here for the class that should be created when a null session is requested. Likewise the [`is_null_session()`](#flask.sessions.SessionInterface.is_null_session "flask.sessions.SessionInterface.is_null_session") method will perform a typecheck against this type.

    alias of [`NullSession`](#flask.sessions.NullSession "flask.sessions.NullSession")
- name: SessionInterface.open_session()
  id: api/index#flask.sessions.SessionInterface.open_session
  summary: This is called at the beginning of each request, after pushing the request context, before matching the URL
  description: |-
    `open_session(app, request)`

    This is called at the beginning of each request, after pushing the request context, before matching the URL.

    This must return an object which implements a dictionary-like interface as well as the [`SessionMixin`](#flask.sessions.SessionMixin "flask.sessions.SessionMixin") interface.

    This will return `None` to indicate that loading failed in some way that is not immediately an error. The request context will fall back to using [`make_null_session()`](#flask.sessions.SessionInterface.make_null_session "flask.sessions.SessionInterface.make_null_session") in this case.

    Parameters:

    - **app** ([Flask](#flask.Flask "flask.Flask")) –
    - **request** ([Request](#flask.Request "flask.Request")) –

    Return type:

    [SessionMixin](#flask.sessions.SessionMixin "flask.sessions.SessionMixin") \| None
- name: SessionInterface.pickle_based
  id: api/index#flask.sessions.SessionInterface.pickle_based
  summary: A flag that indicates if the session interface is pickle based
  description: |-
    `pickle_based = False`

    A flag that indicates if the session interface is pickle based. This can be used by Flask extensions to make a decision in regards to how to deal with the session object.

    Changelog

    New in version 0.10.
- name: SessionInterface.save_session()
  id: api/index#flask.sessions.SessionInterface.save_session
  summary: This is called at the end of each request, after generating a response, before removing the request context
  description: |-
    `save_session(app, session, response)`

    This is called at the end of each request, after generating a response, before removing the request context. It is skipped if [`is_null_session()`](#flask.sessions.SessionInterface.is_null_session "flask.sessions.SessionInterface.is_null_session") returns `True`.

    Parameters:

    - **app** ([Flask](#flask.Flask "flask.Flask")) –
    - **session** ([SessionMixin](#flask.sessions.SessionMixin "flask.sessions.SessionMixin")) –
    - **response** ([Response](#flask.Response "flask.Response")) –

    Return type:

    None
- name: SessionInterface.should_set_cookie()
  id: api/index#flask.sessions.SessionInterface.should_set_cookie
  summary: Used by session backends to determine if a Set-Cookie header should be set for this session cookie for this response
  description: |-
    `should_set_cookie(app, session)`

    Used by session backends to determine if a `Set-Cookie` header should be set for this session cookie for this response. If the session has been modified, the cookie is set. If the session is permanent and the `SESSION_REFRESH_EACH_REQUEST` config is true, the cookie is always set.

    This check is usually skipped if the session was deleted.

    Changelog

    New in version 0.11.

    Parameters:

    - **app** ([Flask](#flask.Flask "flask.Flask")) –
    - **session** ([SessionMixin](#flask.sessions.SessionMixin "flask.sessions.SessionMixin")) –

    Return type:

    [bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
- name: SessionMixin
  id: api/index#flask.sessions.SessionMixin
  summary: Expands a basic dictionary with session attributes
  description: |-
    `class flask.sessions.SessionMixin`

    Expands a basic dictionary with session attributes.
- name: SessionMixin.accessed
  id: api/index#flask.sessions.SessionMixin.accessed
  summary: Some implementations can detect when session data is read or written and set this when that happens
  description: |-
    `accessed = True`

    Some implementations can detect when session data is read or written and set this when that happens. The mixin default is hard coded to `True`.
- name: SessionMixin.modified
  id: api/index#flask.sessions.SessionMixin.modified
  summary: Some implementations can detect changes to the session and set this when that happens
  description: |-
    `modified = True`

    Some implementations can detect changes to the session and set this when that happens. The mixin default is hard coded to `True`.

    `property permanent: bool`

    This reflects the `'_permanent'` key in the dict.

    Notice

    The [`PERMANENT_SESSION_LIFETIME`](../config/index#PERMANENT_SESSION_LIFETIME "PERMANENT_SESSION_LIFETIME") config can be an integer or `timedelta`. The [`permanent_session_lifetime`](#flask.Flask.permanent_session_lifetime "flask.Flask.permanent_session_lifetime") attribute is always a `timedelta`.

    ## Test Client
- name: Signals
  id: signals/index
  summary: Signals are a lightweight way to notify subscribers of certain events during the lifecycle of the application and each request
  description: "# Signals\n\nSignals are a lightweight way to notify subscribers of certain events during the lifecycle of the application and each request. When an event occurs, it emits the signal, which calls each subscriber.\n\nSignals are implemented by the [Blinker](https://pypi.org/project/blinker/) library. See its documentation for detailed information. Flask provides some built-in signals. Extensions may provide their own.\n\nMany signals mirror Flask’s decorator-based callbacks with similar names. For example, the [`request_started`](../api/index#flask.request_started \"flask.request_started\") signal is similar to the [`before_request()`](../api/index#flask.Flask.before_request \"flask.Flask.before_request\") decorator. The advantage of signals over handlers is that they can be subscribed to temporarily, and can’t directly affect the application. This is useful for testing, metrics, auditing, and more. For example, if you want to know what templates were rendered at what parts of what requests, there is a signal that will notify you of that information.\n\n## Core Signals\n\nSee [Signals](../api/index#core-signals-list) for a list of all built-in signals. The [Application Structure and Lifecycle](../lifecycle/index) page also describes the order that signals and decorators execute.\n\n## Subscribing to Signals\n\nTo subscribe to a signal, you can use the [`connect()`](https://blinker.readthedocs.io/en/stable/#blinker.base.Signal.connect \"(in Blinker v1.6)\") method of a signal. The first argument is the function that should be called when the signal is emitted, the optional second argument specifies a sender. To unsubscribe from a signal, you can use the [`disconnect()`](https://blinker.readthedocs.io/en/stable/#blinker.base.Signal.disconnect \"(in Blinker v1.6)\") method.\n\nFor all core Flask signals, the sender is the application that issued the signal. When you subscribe to a signal, be sure to also provide a sender unless you really want to listen for signals from all applications. This is especially true if you are developing an extension.\n\nFor example, here is a helper context manager that can be used in a unit test to determine which templates were rendered and what variables were passed to the template:\n\n``` python\nfrom flask import template_rendered\nfrom contextlib import contextmanager\n\n@contextmanager\ndef captured_templates(app):\n    recorded = []\n    def record(sender, template, context, **extra):\n        recorded.append((template, context))\n    template_rendered.connect(record, app)\n    try:\n        yield recorded\n    finally:\n        template_rendered.disconnect(record, app)\n```\n\nThis can now easily be paired with a test client:\n\n``` python\nwith captured_templates(app) as templates:\n    rv = app.test_client().get('/')\n    assert rv.status_code == 200\n    assert len(templates) == 1\n    template, context = templates[0]\n    assert template.name == 'index.html'\n    assert len(context['items']) == 10\n```\n\nMake sure to subscribe with an extra `**extra` argument so that your calls don’t fail if Flask introduces new arguments to the signals.\n\nAll the template rendering in the code issued by the application `app` in the body of the `with` block will now be recorded in the `templates` variable. Whenever a template is rendered, the template object as well as context are appended to it.\n\nAdditionally there is a convenient helper method ([`connected_to()`](https://blinker.readthedocs.io/en/stable/#blinker.base.Signal.connected_to \"(in Blinker v1.6)\")) that allows you to temporarily subscribe a function to a signal with a context manager on its own. Because the return value of the context manager cannot be specified that way, you have to pass the list in as an argument:\n\n``` python\nfrom flask import template_rendered\n\ndef captured_templates(app, recorded, **extra):\n    def record(sender, template, context):\n        recorded.append((template, context))\n    return template_rendered.connected_to(record, app)\n```\n\nThe example above would then look like this:\n\n``` python\ntemplates = []\nwith captured_templates(app, templates, **extra):\n    ...\n    template, context = templates[0]\n```\n\n## Creating Signals\n\nIf you want to use signals in your own application, you can use the blinker library directly. The most common use case are named signals in a custom [`Namespace`](https://blinker.readthedocs.io/en/stable/#blinker.base.Namespace \"(in Blinker v1.6)\"). This is what is recommended most of the time:\n\n``` python\nfrom blinker import Namespace\nmy_signals = Namespace()\n```\n\nNow you can create new signals like this:\n\n``` python\nmodel_saved = my_signals.signal('model-saved')\n```\n\nThe name for the signal here makes it unique and also simplifies debugging. You can access the name of the signal with the [`name`](https://blinker.readthedocs.io/en/stable/#blinker.base.NamedSignal.name \"(in Blinker v1.6)\") attribute.\n\n## Sending Signals\n\nIf you want to emit a signal, you can do so by calling the [`send()`](https://blinker.readthedocs.io/en/stable/#blinker.base.Signal.send \"(in Blinker v1.6)\") method. It accepts a sender as first argument and optionally some keyword arguments that are forwarded to the signal subscribers:\n\n``` python\nclass Model(object):\n    ...\n\n    def save(self):\n        model_saved.send(self)\n```\n\nTry to always pick a good sender. If you have a class that is emitting a signal, pass `self` as sender. If you are emitting a signal from a random function, you can pass `current_app._get_current_object()` as sender.\n\nPassing Proxies as Senders\n\nNever pass [`current_app`](../api/index#flask.current_app \"flask.current_app\") as sender to a signal. Use `current_app._get_current_object()` instead. The reason for this is that [`current_app`](../api/index#flask.current_app \"flask.current_app\") is a proxy and not the real application object.\n\n## Signals and Flask’s Request Context\n\nSignals fully support [The Request Context](../reqcontext/index) when receiving signals. Context-local variables are consistently available between [`request_started`](../api/index#flask.request_started \"flask.request_started\") and [`request_finished`](../api/index#flask.request_finished \"flask.request_finished\"), so you can rely on [`flask.g`](../api/index#flask.g \"flask.g\") and others as needed. Note the limitations described in [Sending Signals](#signals-sending) and the [`request_tearing_down`](../api/index#flask.request_tearing_down \"flask.request_tearing_down\") signal.\n\n## Decorator Based Signal Subscriptions\n\nYou can also easily subscribe to signals by using the `connect_via()` decorator:\n\n``` python\nfrom flask import template_rendered\n\n@template_rendered.connect_via(app)\ndef when_template_rendered(sender, template, context, **extra):\n    print(f'Template {template.name} is rendered with {context}')\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/signals/](https://flask.palletsprojects.com/en/3.0.x/signals/)"
- name: Single-Page Applications
  id: patterns/singlepageapplications/index
  summary: Flask can be used to serve Single-Page Applications (SPA) by placing static files produced by your frontend framework in a subfolder inside of your project
  description: "# Single-Page Applications\n\nFlask can be used to serve Single-Page Applications (SPA) by placing static files produced by your frontend framework in a subfolder inside of your project. You will also need to create a catch-all endpoint that routes all requests to your SPA.\n\nThe following example demonstrates how to serve an SPA along with an API:\n\n``` python\nfrom flask import Flask, jsonify\n\napp = Flask(__name__, static_folder='app', static_url_path=\"/app\")\n\n\n@app.route(\"/heartbeat\")\ndef heartbeat():\n    return jsonify({\"status\": \"healthy\"})\n\n\n@app.route('/', defaults={'path': ''})\n@app.route('/<path:path>')\ndef catch_all(path):\n    return app.send_static_file(\"index.html\")\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/singlepageapplications/](https://flask.palletsprojects.com/en/3.0.x/patterns/singlepageapplications/)"
- name: SQLAlchemy in Flask
  id: patterns/sqlalchemy/index
  summary: Many people prefer SQLAlchemy for database access
  description: "# SQLAlchemy in Flask\n\nMany people prefer [SQLAlchemy](https://www.sqlalchemy.org/) for database access. In this case it’s encouraged to use a package instead of a module for your flask application and drop the models into a separate module ([Large Applications as Packages](../packages/index)). While that is not necessary, it makes a lot of sense.\n\nThere are four very common ways to use SQLAlchemy. I will outline each of them here:\n\n## Flask-SQLAlchemy Extension\n\nBecause SQLAlchemy is a common database abstraction layer and object relational mapper that requires a little bit of configuration effort, there is a Flask extension that handles that for you. This is recommended if you want to get started quickly.\n\nYou can download [Flask-SQLAlchemy](https://flask-sqlalchemy.palletsprojects.com/) from [PyPI](https://pypi.org/project/Flask-SQLAlchemy/).\n\n## Declarative\n\nThe declarative extension in SQLAlchemy is the most recent method of using SQLAlchemy. It allows you to define tables and models in one go, similar to how Django works. In addition to the following text I recommend the official documentation on the [declarative](https://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/) extension.\n\nHere’s the example `database.py` module for your application:\n\n``` python\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import scoped_session, sessionmaker, declarative_base\n\nengine = create_engine('sqlite:////tmp/test.db')\ndb_session = scoped_session(sessionmaker(autocommit=False,\n                                         autoflush=False,\n                                         bind=engine))\nBase = declarative_base()\nBase.query = db_session.query_property()\n\ndef init_db():\n    # import all modules here that might define models so that\n    # they will be registered properly on the metadata.  Otherwise\n    # you will have to import them first before calling init_db()\n    import yourapplication.models\n    Base.metadata.create_all(bind=engine)\n```\n\nTo define your models, just subclass the `Base` class that was created by the code above. If you are wondering why we don’t have to care about threads here (like we did in the SQLite3 example above with the [`g`](../../api/index#flask.g \"flask.g\") object): that’s because SQLAlchemy does that for us already with the [`scoped_session`](https://docs.sqlalchemy.org/en/20/orm/contextual.html#sqlalchemy.orm.scoped_session \"(in SQLAlchemy v2.0)\").\n\nTo use SQLAlchemy in a declarative way with your application, you just have to put the following code into your application module. Flask will automatically remove database sessions at the end of the request or when the application shuts down:\n\n``` python\nfrom yourapplication.database import db_session\n\n@app.teardown_appcontext\ndef shutdown_session(exception=None):\n    db_session.remove()\n```\n\nHere is an example model (put this into `models.py`, e.g.):\n\n``` python\nfrom sqlalchemy import Column, Integer, String\nfrom yourapplication.database import Base\n\nclass User(Base):\n    __tablename__ = 'users'\n    id = Column(Integer, primary_key=True)\n    name = Column(String(50), unique=True)\n    email = Column(String(120), unique=True)\n\n    def __init__(self, name=None, email=None):\n        self.name = name\n        self.email = email\n\n    def __repr__(self):\n        return f'<User {self.name!r}>'\n```\n\nTo create the database you can use the `init_db` function:\n\n``` python\n>>> from yourapplication.database import init_db\n>>> init_db()\n```\n\nYou can insert entries into the database like this:\n\n``` python\n>>> from yourapplication.database import db_session\n>>> from yourapplication.models import User\n>>> u = User('admin', 'admin@localhost')\n>>> db_session.add(u)\n>>> db_session.commit()\n```\n\nQuerying is simple as well:\n\n``` python\n>>> User.query.all()\n[<User 'admin'>]\n>>> User.query.filter(User.name == 'admin').first()\n<User 'admin'>\n```\n\n## Manual Object Relational Mapping\n\nManual object relational mapping has a few upsides and a few downsides versus the declarative approach from above. The main difference is that you define tables and classes separately and map them together. It’s more flexible but a little more to type. In general it works like the declarative approach, so make sure to also split up your application into multiple modules in a package.\n\nHere is an example `database.py` module for your application:\n\n``` python\nfrom sqlalchemy import create_engine, MetaData\nfrom sqlalchemy.orm import scoped_session, sessionmaker\n\nengine = create_engine('sqlite:////tmp/test.db')\nmetadata = MetaData()\ndb_session = scoped_session(sessionmaker(autocommit=False,\n                                         autoflush=False,\n                                         bind=engine))\ndef init_db():\n    metadata.create_all(bind=engine)\n```\n\nAs in the declarative approach, you need to close the session after each request or application context shutdown. Put this into your application module:\n\n``` python\nfrom yourapplication.database import db_session\n\n@app.teardown_appcontext\ndef shutdown_session(exception=None):\n    db_session.remove()\n```\n\nHere is an example table and model (put this into `models.py`):\n\n``` python\nfrom sqlalchemy import Table, Column, Integer, String\nfrom sqlalchemy.orm import mapper\nfrom yourapplication.database import metadata, db_session\n\nclass User(object):\n    query = db_session.query_property()\n\n    def __init__(self, name=None, email=None):\n        self.name = name\n        self.email = email\n\n    def __repr__(self):\n        return f'<User {self.name!r}>'\n\nusers = Table('users', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('name', String(50), unique=True),\n    Column('email', String(120), unique=True)\n)\nmapper(User, users)\n```\n\nQuerying and inserting works exactly the same as in the example above.\n\n## SQL Abstraction Layer\n\nIf you just want to use the database system (and SQL) abstraction layer you basically only need the engine:\n\n``` python\nfrom sqlalchemy import create_engine, MetaData, Table\n\nengine = create_engine('sqlite:////tmp/test.db')\nmetadata = MetaData(bind=engine)\n```\n\nThen you can either declare the tables in your code like in the examples above, or automatically load them:\n\n``` python\nfrom sqlalchemy import Table\n\nusers = Table('users', metadata, autoload=True)\n```\n\nTo insert data you can use the `insert` method. We have to get a connection first so that we can use a transaction:\n\n``` python\n>>> con = engine.connect()\n>>> con.execute(users.insert(), name='admin', email='admin@localhost')\n```\n\nSQLAlchemy will automatically commit for us.\n\nTo query your database, you use the engine directly or use a connection:\n\n``` python\n>>> users.select(users.c.id == 1).execute().first()\n(1, 'admin', 'admin@localhost')\n```\n\nThese results are also dict-like tuples:\n\n``` python\n>>> r = users.select(users.c.id == 1).execute().first()\n>>> r['name']\n'admin'\n```\n\nYou can also pass strings of SQL statements to the `execute()` method:\n\n``` python\n>>> engine.execute('select * from users where id = :1', [1]).first()\n(1, 'admin', 'admin@localhost')\n```\n\nFor more information about SQLAlchemy, head over to the [website](https://www.sqlalchemy.org/).\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/sqlalchemy/](https://flask.palletsprojects.com/en/3.0.x/patterns/sqlalchemy/)"
- name: stream_template()
  id: api/index#flask.stream_template
  summary: Render a template by name with the given context as a stream
  description: |-
    `flask.stream_template(template_name_or_list, **context)`

    Render a template by name with the given context as a stream. This returns an iterator of strings, which can be used as a streaming response from a view.

    Parameters:

    - **template_name_or_list** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [Template](https://jinja.palletsprojects.com/en/3.1.x/api/#jinja2.Template "(in Jinja v3.1.x)") *\|* [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* [jinja2.environment.Template](https://jinja.palletsprojects.com/en/3.1.x/api/#jinja2.Template "(in Jinja v3.1.x)")*\]*) – The name of the template to render. If a list is given, the first name to exist will be rendered.
    - **context** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – The variables to make available in the template.

    Return type:

    [Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")\]

    Changelog

    New in version 2.2.
- name: stream_template_string()
  id: api/index#flask.stream_template_string
  summary: Render a template from the given source string with the given context as a stream
  description: |-
    `flask.stream_template_string(source, **context)`

    Render a template from the given source string with the given context as a stream. This returns an iterator of strings, which can be used as a streaming response from a view.

    Parameters:

    - **source** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The source code of the template to render.
    - **context** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – The variables to make available in the template.

    Return type:

    [Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")\]

    Changelog

    New in version 2.2.
- name: stream_with_context()
  id: api/index#flask.stream_with_context
  summary: Request contexts disappear when the response is started on the server
  description: |-
    `flask.stream_with_context(generator_or_function)`

    Request contexts disappear when the response is started on the server. This is done for efficiency reasons and to make it less likely to encounter memory leaks with badly written WSGI middlewares. The downside is that if you are using streamed responses, the generator cannot access request bound information any more.

    This function however can help you keep the context around for longer:

    ``` python
    from flask import stream_with_context, request, Response

    @app.route('/stream')
    def streamed_response():
        @stream_with_context
        def generate():
            yield 'Hello '
            yield request.args['name']
            yield '!'
        return Response(generate())
    ```

    Alternatively it can also be used around a specific generator:

    ``` python
    from flask import stream_with_context, request, Response

    @app.route('/stream')
    def streamed_response():
        def generate():
            yield 'Hello '
            yield request.args['name']
            yield '!'
        return Response(stream_with_context(generate()))
    ```

    Changelog

    New in version 0.9.

    Parameters:

    **generator_or_function** ([Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator "(in Python v3.11)") *\|* [Callable](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.11)")*\[\[...\],* [Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator "(in Python v3.11)")*\]*) –

    Return type:

    [Iterator](https://docs.python.org/3/library/typing.html#typing.Iterator "(in Python v3.11)")

    ## Useful Internals
- name: Streaming Contents
  id: patterns/streaming/index
  summary: Sometimes you want to send an enormous amount of data to the client, much more than you want to keep in memory
  description: "# Streaming Contents\n\nSometimes you want to send an enormous amount of data to the client, much more than you want to keep in memory. When you are generating the data on the fly though, how do you send that back to the client without the roundtrip to the filesystem?\n\nThe answer is by using generators and direct responses.\n\n## Basic Usage\n\nThis is a basic view function that generates a lot of CSV data on the fly. The trick is to have an inner function that uses a generator to generate data and to then invoke that function and pass it to a response object:\n\n``` python\n@app.route('/large.csv')\ndef generate_large_csv():\n    def generate():\n        for row in iter_all_rows():\n            yield f\"{','.join(row)}\\n\"\n    return generate(), {\"Content-Type\": \"text/csv\"}\n```\n\nEach `yield` expression is directly sent to the browser. Note though that some WSGI middlewares might break streaming, so be careful there in debug environments with profilers and other things you might have enabled.\n\n## Streaming from Templates\n\nThe Jinja2 template engine supports rendering a template piece by piece, returning an iterator of strings. Flask provides the [`stream_template()`](../../api/index#flask.stream_template \"flask.stream_template\") and [`stream_template_string()`](../../api/index#flask.stream_template_string \"flask.stream_template_string\") functions to make this easier to use.\n\n``` python\nfrom flask import stream_template\n\n@app.get(\"/timeline\")\ndef timeline():\n    return stream_template(\"timeline.html\")\n```\n\nThe parts yielded by the render stream tend to match statement blocks in the template.\n\n## Streaming with Context\n\nThe [`request`](../../api/index#flask.request \"flask.request\") will not be active while the generator is running, because the view has already returned at that point. If you try to access `request`, you’ll get a `RuntimeError`.\n\nIf your generator function relies on data in `request`, use the [`stream_with_context()`](../../api/index#flask.stream_with_context \"flask.stream_with_context\") wrapper. This will keep the request context active during the generator.\n\n``` python\nfrom flask import stream_with_context, request\nfrom markupsafe import escape\n\n@app.route('/stream')\ndef streamed_response():\n    def generate():\n        yield '<p>Hello '\n        yield escape(request.args['name'])\n        yield '!</p>'\n    return stream_with_context(generate())\n```\n\nIt can also be used as a decorator.\n\n``` python\n@stream_with_context\ndef generate():\n    ...\n\nreturn generate()\n```\n\nThe [`stream_template()`](../../api/index#flask.stream_template \"flask.stream_template\") and [`stream_template_string()`](../../api/index#flask.stream_template_string \"flask.stream_template_string\") functions automatically use [`stream_with_context()`](../../api/index#flask.stream_with_context \"flask.stream_with_context\") if a request is active.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/streaming/](https://flask.palletsprojects.com/en/3.0.x/patterns/streaming/)"
- name: Subclassing Flask
  id: patterns/subclassing/index
  summary: The Flask class is designed for subclassing
  description: "# Subclassing Flask\n\nThe [`Flask`](../../api/index#flask.Flask \"flask.Flask\") class is designed for subclassing.\n\nFor example, you may want to override how request parameters are handled to preserve their order:\n\n``` python\nfrom flask import Flask, Request\nfrom werkzeug.datastructures import ImmutableOrderedMultiDict\nclass MyRequest(Request):\n    \"\"\"Request subclass to override request parameter storage\"\"\"\n    parameter_storage_class = ImmutableOrderedMultiDict\nclass MyFlask(Flask):\n    \"\"\"Flask subclass using the custom request class\"\"\"\n    request_class = MyRequest\n```\n\nThis is the recommended approach for overriding or augmenting Flask’s internal functionality.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/subclassing/](https://flask.palletsprojects.com/en/3.0.x/patterns/subclassing/)"
- name: TaggedJSONSerializer
  id: api/index#flask.json.tag.TaggedJSONSerializer
  summary: Serializer that uses a tag system to compactly represent objects that are not JSON types
  description: |-
    `class flask.json.tag.TaggedJSONSerializer`

    Serializer that uses a tag system to compactly represent objects that are not JSON types. Passed as the intermediate serializer to `itsdangerous.Serializer`.

    The following extra types are supported:

    - [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)")
    - [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.11)")
    - [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "(in Python v3.11)")
    - `Markup`
    - [`UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID "(in Python v3.11)")
    - [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime "(in Python v3.11)")
- name: TaggedJSONSerializer.default_tags
  id: api/index#flask.json.tag.TaggedJSONSerializer.default_tags
  summary: Tag classes to bind when creating the serializer
  description: |-
    `default_tags = [<class 'flask.json.tag.TagDict'>, <class 'flask.json.tag.PassDict'>, <class 'flask.json.tag.TagTuple'>, <class 'flask.json.tag.PassList'>, <class 'flask.json.tag.TagBytes'>, <class 'flask.json.tag.TagMarkup'>, <class 'flask.json.tag.TagUUID'>, <class 'flask.json.tag.TagDateTime'>]`

    Tag classes to bind when creating the serializer. Other tags can be added later using [`register()`](#flask.json.tag.TaggedJSONSerializer.register "flask.json.tag.TaggedJSONSerializer.register").
- name: TaggedJSONSerializer.dumps()
  id: api/index#flask.json.tag.TaggedJSONSerializer.dumps
  summary: Tag the value and dump it to a compact JSON string
  description: |-
    `dumps(value)`

    Tag the value and dump it to a compact JSON string.

    Parameters:

    **value** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")
- name: TaggedJSONSerializer.loads()
  id: api/index#flask.json.tag.TaggedJSONSerializer.loads
  summary: Load data from a JSON string and deserialized any tagged objects
  description: |-
    `loads(value)`

    Load data from a JSON string and deserialized any tagged objects.

    Parameters:

    **value** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: TaggedJSONSerializer.register()
  id: api/index#flask.json.tag.TaggedJSONSerializer.register
  summary: Register a new tag with this serializer
  description: |-
    `register(tag_class, force=False, index=None)`

    Register a new tag with this serializer.

    Parameters:

    - **tag_class** ([type](https://docs.python.org/3/library/functions.html#type "(in Python v3.11)")*\[*[flask.json.tag.JSONTag](#flask.json.tag.JSONTag "flask.json.tag.JSONTag")*\]*) – tag class to register. Will be instantiated with this serializer instance.
    - **force** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")) – overwrite an existing tag. If false (default), a [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError "(in Python v3.11)") is raised.
    - **index** ([int](https://docs.python.org/3/library/functions.html#int "(in Python v3.11)") *\|* *None*) – index to insert the new tag in the tag order. Useful when the new tag is a special case of an existing tag. If `None` (default), the tag is appended to the end of the order.

    Raises:

    [**KeyError**](https://docs.python.org/3/library/exceptions.html#KeyError "(in Python v3.11)") – if the tag key is already registered and `force` is not true.

    Return type:

    None
- name: TaggedJSONSerializer.tag()
  id: api/index#flask.json.tag.TaggedJSONSerializer.tag
  summary: Convert a value to a tagged representation if necessary
  description: |-
    `tag(value)`

    Convert a value to a tagged representation if necessary.

    Parameters:

    **value** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) –

    Return type:

    [dict](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)")\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)"), [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")\]
- name: TaggedJSONSerializer.untag()
  id: api/index#flask.json.tag.TaggedJSONSerializer.untag
  summary: Convert a tagged representation back to the original type
  description: |-
    `untag(value)`

    Convert a tagged representation back to the original type.

    Parameters:

    **value** ([dict](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.11)")*\[*[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")*,* [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")*\]*) –

    Return type:

    [Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")
- name: Tell Flask it is Behind a Proxy
  id: deploying/proxy_fix/index
  summary: When using a reverse proxy, or many Python hosting platforms, the proxy will intercept and forward all external requests to the local WSGI server
  description: "# Tell Flask it is Behind a Proxy\n\nWhen using a reverse proxy, or many Python hosting platforms, the proxy will intercept and forward all external requests to the local WSGI server.\n\nFrom the WSGI server and Flask application’s perspectives, requests are now coming from the HTTP server to the local address, rather than from the remote address to the external server address.\n\nHTTP servers should set `X-Forwarded-` headers to pass on the real values to the application. The application can then be told to trust and use those values by wrapping it with the [X-Forwarded-For Proxy Fix](https://werkzeug.palletsprojects.com/en/2.3.x/middleware/proxy_fix/ \"(in Werkzeug v2.3.x)\") middleware provided by Werkzeug.\n\nThis middleware should only be used if the application is actually behind a proxy, and should be configured with the number of proxies that are chained in front of it. Not all proxies set all the headers. Since incoming headers can be faked, you must set how many proxies are setting each header so the middleware knows what to trust.\n\n``` python\nfrom werkzeug.middleware.proxy_fix import ProxyFix\n\napp.wsgi_app = ProxyFix(\n    app.wsgi_app, x_for=1, x_proto=1, x_host=1, x_prefix=1\n)\n```\n\nRemember, only apply this middleware if you are behind a proxy, and set the correct number of proxies that set each header. It can be a security issue if you get this configuration wrong.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/deploying/proxy_fix/](https://flask.palletsprojects.com/en/3.0.x/deploying/proxy_fix/)"
- name: Template Inheritance
  id: patterns/templateinheritance/index
  summary: The most powerful part of Jinja is template inheritance
  description: "# Template Inheritance\n\nThe most powerful part of Jinja is template inheritance. Template inheritance allows you to build a base “skeleton” template that contains all the common elements of your site and defines **blocks** that child templates can override.\n\nSounds complicated but is very basic. It’s easiest to understand it by starting with an example.\n\n## Base Template\n\nThis template, which we’ll call `layout.html`, defines a simple HTML skeleton document that you might use for a simple two-column page. It’s the job of “child” templates to fill the empty blocks with content:\n\n``` html+jinja\n<!doctype html>\n<html>\n  <head>\n    {% block head %}\n    <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='style.css') }}\">\n    <title>{% block title %}{% endblock %} - My Webpage</title>\n    {% endblock %}\n  </head>\n  <body>\n    <div id=\"content\">{% block content %}{% endblock %}</div>\n    <div id=\"footer\">\n      {% block footer %}\n      &copy; Copyright 2010 by <a href=\"http://domain.invalid/\">you</a>.\n      {% endblock %}\n    </div>\n  </body>\n</html>\n```\n\nIn this example, the `{% block %}` tags define four blocks that child templates can fill in. All the `block` tag does is tell the template engine that a child template may override those portions of the template.\n\n## Child Template\n\nA child template might look like this:\n\n``` html+jinja\n{% extends \"layout.html\" %}\n{% block title %}Index{% endblock %}\n{% block head %}\n  {{ super() }}\n  <style type=\"text/css\">\n    .important { color: #336699; }\n  </style>\n{% endblock %}\n{% block content %}\n  <h1>Index</h1>\n  <p class=\"important\">\n    Welcome on my awesome homepage.\n{% endblock %}\n```\n\nThe `{% extends %}` tag is the key here. It tells the template engine that this template “extends” another template. When the template system evaluates this template, first it locates the parent. The extends tag must be the first tag in the template. To render the contents of a block defined in the parent template, use `{{ super() }}`.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/templateinheritance/](https://flask.palletsprojects.com/en/3.0.x/patterns/templateinheritance/)"
- name: Templates
  id: templating/index
  summary: Flask leverages Jinja2 as its template engine
  description: "# Templates\n\nFlask leverages Jinja2 as its template engine. You are obviously free to use a different template engine, but you still have to install Jinja2 to run Flask itself. This requirement is necessary to enable rich extensions. An extension can depend on Jinja2 being present.\n\nThis section only gives a very quick introduction into how Jinja2 is integrated into Flask. If you want information on the template engine’s syntax itself, head over to the official [Jinja2 Template Documentation](https://jinja.palletsprojects.com/templates/) for more information.\n\n## Jinja Setup\n\nUnless customized, Jinja2 is configured by Flask as follows:\n\n- autoescaping is enabled for all templates ending in `.html`, `.htm`, `.xml`, `.xhtml`, as well as `.svg` when using `render_template()`.\n- autoescaping is enabled for all strings when using `render_template_string()`.\n- a template has the ability to opt in/out autoescaping with the `{% autoescape %}` tag.\n- Flask inserts a couple of global functions and helpers into the Jinja2 context, additionally to the values that are present by default.\n\n## Standard Context\n\nThe following global variables are available within Jinja2 templates by default:\n\nconfig  \nThe current configuration object ([`flask.Flask.config`](../api/index#flask.Flask.config \"flask.Flask.config\"))\n\nChangelog\n\nChanged in version 0.10: This is now always available, even in imported templates.\n\nNew in version 0.6.\n\nrequest  \nThe current request object ([`flask.request`](../api/index#flask.request \"flask.request\")). This variable is unavailable if the template was rendered without an active request context.\n\n&nbsp;\n\nsession  \nThe current session object ([`flask.session`](../api/index#flask.session \"flask.session\")). This variable is unavailable if the template was rendered without an active request context.\n\n&nbsp;\n\ng  \nThe request-bound object for global variables ([`flask.g`](../api/index#flask.g \"flask.g\")). This variable is unavailable if the template was rendered without an active request context.\n\n&nbsp;\n\nurl_for()  \nThe [`flask.url_for()`](../api/index#flask.url_for \"flask.url_for\") function.\n\n&nbsp;\n\nget_flashed_messages()  \nThe [`flask.get_flashed_messages()`](../api/index#flask.get_flashed_messages \"flask.get_flashed_messages\") function.\n\nThe Jinja Context Behavior\n\nThese variables are added to the context of variables, they are not global variables. The difference is that by default these will not show up in the context of imported templates. This is partially caused by performance considerations, partially to keep things explicit.\n\nWhat does this mean for you? If you have a macro you want to import, that needs to access the request object you have two possibilities:\n\n1.  you explicitly pass the request to the macro as parameter, or the attribute of the request object you are interested in.\n2.  you import the macro “with context”.\n\nImporting with context looks like this:\n\n``` jinja\n{% from '_helpers.html' import my_macro with context %}\n```\n\n## Controlling Autoescaping\n\nAutoescaping is the concept of automatically escaping special characters for you. Special characters in the sense of HTML (or XML, and thus XHTML) are `&`, `>`, `<`, `\"` as well as `'`. Because these characters carry specific meanings in documents on their own you have to replace them by so called “entities” if you want to use them for text. Not doing so would not only cause user frustration by the inability to use these characters in text, but can also lead to security problems. (see [Cross-Site Scripting (XSS)](../security/index#security-xss))\n\nSometimes however you will need to disable autoescaping in templates. This can be the case if you want to explicitly inject HTML into pages, for example if they come from a system that generates secure HTML like a markdown to HTML converter.\n\nThere are three ways to accomplish that:\n\n- In the Python code, wrap the HTML string in a `Markup` object before passing it to the template. This is in general the recommended way.\n- Inside the template, use the `|safe` filter to explicitly mark a string as safe HTML (`{{ myvariable|safe }}`)\n- Temporarily disable the autoescape system altogether.\n\nTo disable the autoescape system in templates, you can use the `{% autoescape %}` block:\n\n``` html+jinja\n{% autoescape false %}\n    <p>autoescaping is disabled here\n    <p>{{ will_not_be_escaped }}\n{% endautoescape %}\n```\n\nWhenever you do this, please be very cautious about the variables you are using in this block.\n\n## Registering Filters\n\nIf you want to register your own filters in Jinja2 you have two ways to do that. You can either put them by hand into the [`jinja_env`](../api/index#flask.Flask.jinja_env \"flask.Flask.jinja_env\") of the application or use the [`template_filter()`](../api/index#flask.Flask.template_filter \"flask.Flask.template_filter\") decorator.\n\nThe two following examples work the same and both reverse an object:\n\n``` python\n@app.template_filter('reverse')\ndef reverse_filter(s):\n    return s[::-1]\n\ndef reverse_filter(s):\n    return s[::-1]\napp.jinja_env.filters['reverse'] = reverse_filter\n```\n\nIn case of the decorator the argument is optional if you want to use the function name as name of the filter. Once registered, you can use the filter in your templates in the same way as Jinja2’s builtin filters, for example if you have a Python list in context called `mylist`:\n\n``` python\n{% for x in mylist | reverse %}\n{% endfor %}\n```\n\n## Context Processors\n\nTo inject new variables automatically into the context of a template, context processors exist in Flask. Context processors run before the template is rendered and have the ability to inject new values into the template context. A context processor is a function that returns a dictionary. The keys and values of this dictionary are then merged with the template context, for all templates in the app:\n\n``` python\n@app.context_processor\ndef inject_user():\n    return dict(user=g.user)\n```\n\nThe context processor above makes a variable called `user` available in the template with the value of `g.user`. This example is not very interesting because `g` is available in templates anyways, but it gives an idea how this works.\n\nVariables are not limited to values; a context processor can also make functions available to templates (since Python allows passing around functions):\n\n``` python\n@app.context_processor\ndef utility_processor():\n    def format_price(amount, currency=\"€\"):\n        return f\"{amount:.2f}{currency}\"\n    return dict(format_price=format_price)\n```\n\nThe context processor above makes the `format_price` function available to all templates:\n\n``` python\n{{ format_price(0.33) }}\n```\n\nYou could also build `format_price` as a template filter (see [Registering Filters](#registering-filters)), but this demonstrates how to pass functions in a context processor.\n\n## Streaming\n\nIt can be useful to not render the whole template as one complete string, instead render it as a stream, yielding smaller incremental strings. This can be used for streaming HTML in chunks to speed up initial page load, or to save memory when rendering a very large template.\n\nThe Jinja2 template engine supports rendering a template piece by piece, returning an iterator of strings. Flask provides the [`stream_template()`](../api/index#flask.stream_template \"flask.stream_template\") and [`stream_template_string()`](../api/index#flask.stream_template_string \"flask.stream_template_string\") functions to make this easier to use.\n\n``` python\nfrom flask import stream_template\n\n@app.get(\"/timeline\")\ndef timeline():\n    return stream_template(\"timeline.html\")\n```\n\nThese functions automatically apply the [`stream_with_context()`](../api/index#flask.stream_with_context \"flask.stream_with_context\") wrapper if a request is active, so that it remains available in the template.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/templating/](https://flask.palletsprojects.com/en/3.0.x/templating/)"
- name: TEMPLATES_AUTO_RELOAD
  id: config/index#TEMPLATES_AUTO_RELOAD
  summary: Reload templates when they are changed
  belongs_to: Configuration Handling
  description: |-
    `TEMPLATES_AUTO_RELOAD`

    Reload templates when they are changed. If not set, it will be enabled in debug mode.

    Default: `None`
- name: TESTING
  id: config/index#TESTING
  summary: Enable testing mode
  belongs_to: Configuration Handling
  description: |-
    `TESTING`

    Enable testing mode. Exceptions are propagated rather than handled by the the app’s error handlers. Extensions may also change their behavior to facilitate easier testing. You should enable this in your own tests.

    Default: `False`
- name: Testing Flask Applications
  id: testing/index
  summary: Flask provides utilities for testing an application
  description: "# Testing Flask Applications\n\nFlask provides utilities for testing an application. This documentation goes over techniques for working with different parts of the application in tests.\n\nWe will use the [pytest](https://docs.pytest.org/) framework to set up and run our tests.\n\n``` text\n$ pip install pytest\n```\n\nThe [tutorial](https://flask.palletsprojects.com/en/3.0.x/tutorial/) goes over how to write tests for 100% coverage of the sample Flaskr blog application. See [the tutorial on tests](https://flask.palletsprojects.com/en/3.0.x/tutorial/tests/) for a detailed explanation of specific tests for an application.\n\n## Identifying Tests\n\nTests are typically located in the `tests` folder. Tests are functions that start with `test_`, in Python modules that start with `test_`. Tests can also be further grouped in classes that start with `Test`.\n\nIt can be difficult to know what to test. Generally, try to test the code that you write, not the code of libraries that you use, since they are already tested. Try to extract complex behaviors as separate functions to test individually.\n\n## Fixtures\n\nPytest *fixtures* allow writing pieces of code that are reusable across tests. A simple fixture returns a value, but a fixture can also do setup, yield a value, then do teardown. Fixtures for the application, test client, and CLI runner are shown below, they can be placed in `tests/conftest.py`.\n\nIf you’re using an [application factory](../patterns/appfactories/index), define an `app` fixture to create and configure an app instance. You can add code before and after the `yield` to set up and tear down other resources, such as creating and clearing a database.\n\nIf you’re not using a factory, you already have an app object you can import and configure directly. You can still use an `app` fixture to set up and tear down resources.\n\n``` python\nimport pytest\nfrom my_project import create_app\n\n@pytest.fixture()\ndef app():\n    app = create_app()\n    app.config.update({\n        \"TESTING\": True,\n    })\n\n    # other setup can go here\n\n    yield app\n\n    # clean up / reset resources here\n\n\n@pytest.fixture()\ndef client(app):\n    return app.test_client()\n\n\n@pytest.fixture()\ndef runner(app):\n    return app.test_cli_runner()\n```\n\n## Sending Requests with the Test Client\n\nThe test client makes requests to the application without running a live server. Flask’s client extends [Werkzeug’s client](https://werkzeug.palletsprojects.com/en/2.3.x/test/ \"(in Werkzeug v2.3.x)\"), see those docs for additional information.\n\nThe `client` has methods that match the common HTTP request methods, such as `client.get()` and `client.post()`. They take many arguments for building the request; you can find the full documentation in [`EnvironBuilder`](https://werkzeug.palletsprojects.com/en/2.3.x/test/#werkzeug.test.EnvironBuilder \"(in Werkzeug v2.3.x)\"). Typically you’ll use `path`, `query_string`, `headers`, and `data` or `json`.\n\nTo make a request, call the method the request should use with the path to the route to test. A [`TestResponse`](https://werkzeug.palletsprojects.com/en/2.3.x/test/#werkzeug.test.TestResponse \"(in Werkzeug v2.3.x)\") is returned to examine the response data. It has all the usual properties of a response object. You’ll usually look at `response.data`, which is the bytes returned by the view. If you want to use text, Werkzeug 2.1 provides `response.text`, or use `response.get_data(as_text=True)`.\n\n``` python\ndef test_request_example(client):\n    response = client.get(\"/posts\")\n    assert b\"<h2>Hello, World!</h2>\" in response.data\n```\n\nPass a dict `query_string={\"key\": \"value\", ...}` to set arguments in the query string (after the `?` in the URL). Pass a dict `headers={}` to set request headers.\n\nTo send a request body in a POST or PUT request, pass a value to `data`. If raw bytes are passed, that exact body is used. Usually, you’ll pass a dict to set form data.\n\n### Form Data\n\nTo send form data, pass a dict to `data`. The `Content-Type` header will be set to `multipart/form-data` or `application/x-www-form-urlencoded` automatically.\n\nIf a value is a file object opened for reading bytes (`\"rb\"` mode), it will be treated as an uploaded file. To change the detected filename and content type, pass a `(file, filename, content_type)` tuple. File objects will be closed after making the request, so they do not need to use the usual `with open() as f:` pattern.\n\nIt can be useful to store files in a `tests/resources` folder, then use `pathlib.Path` to get files relative to the current test file.\n\n``` python\nfrom pathlib import Path\n\n# get the resources folder in the tests folder\nresources = Path(__file__).parent / \"resources\"\n\ndef test_edit_user(client):\n    response = client.post(\"/user/2/edit\", data={\n        \"name\": \"Flask\",\n        \"theme\": \"dark\",\n        \"picture\": (resources / \"picture.png\").open(\"rb\"),\n    })\n    assert response.status_code == 200\n```\n\n### JSON Data\n\nTo send JSON data, pass an object to `json`. The `Content-Type` header will be set to `application/json` automatically.\n\nSimilarly, if the response contains JSON data, the `response.json` attribute will contain the deserialized object.\n\n``` python\ndef test_json_data(client):\n    response = client.post(\"/graphql\", json={\n        \"query\": \"\"\"\n            query User($id: String!) {\n                user(id: $id) {\n                    name\n                    theme\n                    picture_url\n                }\n            }\n        \"\"\",\n        variables={\"id\": 2},\n    })\n    assert response.json[\"data\"][\"user\"][\"name\"] == \"Flask\"\n```\n\n## Following Redirects\n\nBy default, the client does not make additional requests if the response is a redirect. By passing `follow_redirects=True` to a request method, the client will continue to make requests until a non-redirect response is returned.\n\n[`TestResponse.history`](https://werkzeug.palletsprojects.com/en/2.3.x/test/#werkzeug.test.TestResponse.history \"(in Werkzeug v2.3.x)\") is a tuple of the responses that led up to the final response. Each response has a [`request`](https://werkzeug.palletsprojects.com/en/2.3.x/test/#werkzeug.test.TestResponse.request \"(in Werkzeug v2.3.x)\") attribute which records the request that produced that response.\n\n``` python\ndef test_logout_redirect(client):\n    response = client.get(\"/logout\")\n    # Check that there was one redirect response.\n    assert len(response.history) == 1\n    # Check that the second request was to the index page.\n    assert response.request.path == \"/index\"\n```\n\n## Accessing and Modifying the Session\n\nTo access Flask’s context variables, mainly [`session`](../api/index#flask.session \"flask.session\"), use the client in a `with` statement. The app and request context will remain active *after* making a request, until the `with` block ends.\n\n``` python\nfrom flask import session\n\ndef test_access_session(client):\n    with client:\n        client.post(\"/auth/login\", data={\"username\": \"flask\"})\n        # session is still accessible\n        assert session[\"user_id\"] == 1\n\n    # session is no longer accessible\n```\n\nIf you want to access or set a value in the session *before* making a request, use the client’s [`session_transaction()`](../api/index#flask.testing.FlaskClient.session_transaction \"flask.testing.FlaskClient.session_transaction\") method in a `with` statement. It returns a session object, and will save the session once the block ends.\n\n``` python\nfrom flask import session\n\ndef test_modify_session(client):\n    with client.session_transaction() as session:\n        # set a user id without going through the login route\n        session[\"user_id\"] = 1\n\n    # session is saved now\n\n    response = client.get(\"/users/me\")\n    assert response.json[\"username\"] == \"flask\"\n```\n\n## Running Commands with the CLI Runner\n\nFlask provides [`test_cli_runner()`](../api/index#flask.Flask.test_cli_runner \"flask.Flask.test_cli_runner\") to create a [`FlaskCliRunner`](../api/index#flask.testing.FlaskCliRunner \"flask.testing.FlaskCliRunner\"), which runs CLI commands in isolation and captures the output in a [`Result`](https://click.palletsprojects.com/en/8.1.x/api/#click.testing.Result \"(in Click v8.1.x)\") object. Flask’s runner extends [Click’s runner](https://click.palletsprojects.com/en/8.1.x/testing/ \"(in Click v8.1.x)\"), see those docs for additional information.\n\nUse the runner’s [`invoke()`](../api/index#flask.testing.FlaskCliRunner.invoke \"flask.testing.FlaskCliRunner.invoke\") method to call commands in the same way they would be called with the `flask` command from the command line.\n\n``` python\nimport click\n\n@app.cli.command(\"hello\")\n@click.option(\"--name\", default=\"World\")\ndef hello_command(name):\n    click.echo(f\"Hello, {name}!\")\n\ndef test_hello_command(runner):\n    result = runner.invoke(args=\"hello\")\n    assert \"World\" in result.output\n\n    result = runner.invoke(args=[\"hello\", \"--name\", \"Flask\"])\n    assert \"Flask\" in result.output\n```\n\n## Tests that depend on an Active Context\n\nYou may have functions that are called from views or commands, that expect an active [application context](../appcontext/index) or [request context](../reqcontext/index) because they access `request`, `session`, or `current_app`. Rather than testing them by making a request or invoking the command, you can create and activate a context directly.\n\nUse `with app.app_context()` to push an application context. For example, database extensions usually require an active app context to make queries.\n\n``` python\ndef test_db_post_model(app):\n    with app.app_context():\n        post = db.session.query(Post).get(1)\n```\n\nUse `with app.test_request_context()` to push a request context. It takes the same arguments as the test client’s request methods.\n\n``` python\ndef test_validate_user_edit(app):\n    with app.test_request_context(\n        \"/user/2/edit\", method=\"POST\", data={\"name\": \"\"}\n    ):\n        # call a function that accesses `request`\n        messages = validate_edit_user()\n\n    assert messages[\"name\"][0] == \"Name cannot be empty.\"\n```\n\nCreating a test request context doesn’t run any of the Flask dispatching code, so `before_request` functions are not called. If you need to call these, usually it’s better to make a full request instead. However, it’s possible to call them manually.\n\n``` python\ndef test_auth_token(app):\n    with app.test_request_context(\"/user/2/edit\", headers={\"X-Auth-Token\": \"1\"}):\n        app.preprocess_request()\n        assert g.user.name == \"Flask\"\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/testing/](https://flask.palletsprojects.com/en/3.0.x/testing/)"
- name: The Application Context
  id: appcontext/index
  summary: The application context keeps track of the application-level data during a request, CLI command, or other activity
  description: "# The Application Context\n\nThe application context keeps track of the application-level data during a request, CLI command, or other activity. Rather than passing the application around to each function, the [`current_app`](../api/index#flask.current_app \"flask.current_app\") and [`g`](../api/index#flask.g \"flask.g\") proxies are accessed instead.\n\nThis is similar to [The Request Context](../reqcontext/index), which keeps track of request-level data during a request. A corresponding application context is pushed when a request context is pushed.\n\n## Purpose of the Context\n\nThe [`Flask`](../api/index#flask.Flask \"flask.Flask\") application object has attributes, such as [`config`](../api/index#flask.Flask.config \"flask.Flask.config\"), that are useful to access within views and [CLI commands](../cli/index). However, importing the `app` instance within the modules in your project is prone to circular import issues. When using the [app factory pattern](../patterns/appfactories/index) or writing reusable [blueprints](../blueprints/index) or [extensions](../extensions/index) there won’t be an `app` instance to import at all.\n\nFlask solves this issue with the *application context*. Rather than referring to an `app` directly, you use the [`current_app`](../api/index#flask.current_app \"flask.current_app\") proxy, which points to the application handling the current activity.\n\nFlask automatically *pushes* an application context when handling a request. View functions, error handlers, and other functions that run during a request will have access to [`current_app`](../api/index#flask.current_app \"flask.current_app\").\n\nFlask will also automatically push an app context when running CLI commands registered with [`Flask.cli`](../api/index#flask.Flask.cli \"flask.Flask.cli\") using `@app.cli.command()`.\n\n## Lifetime of the Context\n\nThe application context is created and destroyed as necessary. When a Flask application begins handling a request, it pushes an application context and a [request context](../reqcontext/index). When the request ends it pops the request context then the application context. Typically, an application context will have the same lifetime as a request.\n\nSee [The Request Context](../reqcontext/index) for more information about how the contexts work and the full life cycle of a request.\n\n## Manually Push a Context\n\nIf you try to access [`current_app`](../api/index#flask.current_app \"flask.current_app\"), or anything that uses it, outside an application context, you’ll get this error message:\n\n``` pytb\nRuntimeError: Working outside of application context.\n\nThis typically means that you attempted to use functionality that\nneeded to interface with the current application object in some way.\nTo solve this, set up an application context with app.app_context().\n```\n\nIf you see that error while configuring your application, such as when initializing an extension, you can push a context manually since you have direct access to the `app`. Use [`app_context()`](../api/index#flask.Flask.app_context \"flask.Flask.app_context\") in a `with` block, and everything that runs in the block will have access to [`current_app`](../api/index#flask.current_app \"flask.current_app\").\n\n``` python\ndef create_app():\n    app = Flask(__name__)\n\n    with app.app_context():\n        init_db()\n\n    return app\n```\n\nIf you see that error somewhere else in your code not related to configuring the application, it most likely indicates that you should move that code into a view function or CLI command.\n\n## Storing Data\n\nThe application context is a good place to store common data during a request or CLI command. Flask provides the [`g object`](../api/index#flask.g \"flask.g\") for this purpose. It is a simple namespace object that has the same lifetime as an application context.\n\nNote\n\nThe `g` name stands for “global”, but that is referring to the data being global *within a context*. The data on `g` is lost after the context ends, and it is not an appropriate place to store data between requests. Use the [`session`](../api/index#flask.session \"flask.session\") or a database to store data across requests.\n\nA common use for [`g`](../api/index#flask.g \"flask.g\") is to manage resources during a request.\n\n1.  `get_X()` creates resource `X` if it does not exist, caching it as `g.X`.\n2.  `teardown_X()` closes or otherwise deallocates the resource if it exists. It is registered as a [`teardown_appcontext()`](../api/index#flask.Flask.teardown_appcontext \"flask.Flask.teardown_appcontext\") handler.\n\nFor example, you can manage a database connection using this pattern:\n\n``` python\nfrom flask import g\n\ndef get_db():\n    if 'db' not in g:\n        g.db = connect_to_database()\n\n    return g.db\n\n@app.teardown_appcontext\ndef teardown_db(exception):\n    db = g.pop('db', None)\n\n    if db is not None:\n        db.close()\n```\n\nDuring a request, every call to `get_db()` will return the same connection, and it will be closed automatically at the end of the request.\n\nYou can use [`LocalProxy`](https://werkzeug.palletsprojects.com/en/2.3.x/local/#werkzeug.local.LocalProxy \"(in Werkzeug v2.3.x)\") to make a new context local from `get_db()`:\n\n``` python\nfrom werkzeug.local import LocalProxy\ndb = LocalProxy(get_db)\n```\n\nAccessing `db` will call `get_db` internally, in the same way that [`current_app`](../api/index#flask.current_app \"flask.current_app\") works.\n\n## Events and Signals\n\nThe application will call functions registered with [`teardown_appcontext()`](../api/index#flask.Flask.teardown_appcontext \"flask.Flask.teardown_appcontext\") when the application context is popped.\n\nThe following signals are sent: [`appcontext_pushed`](../api/index#flask.appcontext_pushed \"flask.appcontext_pushed\"), [`appcontext_tearing_down`](../api/index#flask.appcontext_tearing_down \"flask.appcontext_tearing_down\"), and [`appcontext_popped`](../api/index#flask.appcontext_popped \"flask.appcontext_popped\").\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/appcontext/](https://flask.palletsprojects.com/en/3.0.x/appcontext/)"
- name: The Request Context
  id: reqcontext/index
  summary: The request context keeps track of the request-level data during a request
  description: "# The Request Context\n\nThe request context keeps track of the request-level data during a request. Rather than passing the request object to each function that runs during a request, the [`request`](../api/index#flask.request \"flask.request\") and [`session`](../api/index#flask.session \"flask.session\") proxies are accessed instead.\n\nThis is similar to [The Application Context](../appcontext/index), which keeps track of the application-level data independent of a request. A corresponding application context is pushed when a request context is pushed.\n\n## Purpose of the Context\n\nWhen the [`Flask`](../api/index#flask.Flask \"flask.Flask\") application handles a request, it creates a [`Request`](../api/index#flask.Request \"flask.Request\") object based on the environment it received from the WSGI server. Because a *worker* (thread, process, or coroutine depending on the server) handles only one request at a time, the request data can be considered global to that worker during that request. Flask uses the term *context local* for this.\n\nFlask automatically *pushes* a request context when handling a request. View functions, error handlers, and other functions that run during a request will have access to the [`request`](../api/index#flask.request \"flask.request\") proxy, which points to the request object for the current request.\n\n## Lifetime of the Context\n\nWhen a Flask application begins handling a request, it pushes a request context, which also pushes an [app context](../appcontext/index). When the request ends it pops the request context then the application context.\n\nThe context is unique to each thread (or other worker type). [`request`](../api/index#flask.request \"flask.request\") cannot be passed to another thread, the other thread has a different context space and will not know about the request the parent thread was pointing to.\n\nContext locals are implemented using Python’s [`contextvars`](https://docs.python.org/3/library/contextvars.html#module-contextvars \"(in Python v3.11)\") and Werkzeug’s [`LocalProxy`](https://werkzeug.palletsprojects.com/en/2.3.x/local/#werkzeug.local.LocalProxy \"(in Werkzeug v2.3.x)\"). Python manages the lifetime of context vars automatically, and local proxy wraps that low-level interface to make the data easier to work with.\n\n## Manually Push a Context\n\nIf you try to access [`request`](../api/index#flask.request \"flask.request\"), or anything that uses it, outside a request context, you’ll get this error message:\n\n``` pytb\nRuntimeError: Working outside of request context.\n\nThis typically means that you attempted to use functionality that\nneeded an active HTTP request. Consult the documentation on testing\nfor information about how to avoid this problem.\n```\n\nThis should typically only happen when testing code that expects an active request. One option is to use the [`test client`](../api/index#flask.Flask.test_client \"flask.Flask.test_client\") to simulate a full request. Or you can use [`test_request_context()`](../api/index#flask.Flask.test_request_context \"flask.Flask.test_request_context\") in a `with` block, and everything that runs in the block will have access to [`request`](../api/index#flask.request \"flask.request\"), populated with your test data.\n\n``` python\ndef generate_report(year):\n    format = request.args.get(\"format\")\n    ...\n\nwith app.test_request_context(\n    \"/make_report/2017\", query_string={\"format\": \"short\"}\n):\n    generate_report()\n```\n\nIf you see that error somewhere else in your code not related to testing, it most likely indicates that you should move that code into a view function.\n\nFor information on how to use the request context from the interactive Python shell, see [Working with the Shell](../shell/index).\n\n## How the Context Works\n\nThe [`Flask.wsgi_app()`](../api/index#flask.Flask.wsgi_app \"flask.Flask.wsgi_app\") method is called to handle each request. It manages the contexts during the request. Internally, the request and application contexts work like stacks. When contexts are pushed, the proxies that depend on them are available and point at information from the top item.\n\nWhen the request starts, a [`RequestContext`](../api/index#flask.ctx.RequestContext \"flask.ctx.RequestContext\") is created and pushed, which creates and pushes an [`AppContext`](../api/index#flask.ctx.AppContext \"flask.ctx.AppContext\") first if a context for that application is not already the top context. While these contexts are pushed, the [`current_app`](../api/index#flask.current_app \"flask.current_app\"), [`g`](../api/index#flask.g \"flask.g\"), [`request`](../api/index#flask.request \"flask.request\"), and [`session`](../api/index#flask.session \"flask.session\") proxies are available to the original thread handling the request.\n\nOther contexts may be pushed to change the proxies during a request. While this is not a common pattern, it can be used in advanced applications to, for example, do internal redirects or chain different applications together.\n\nAfter the request is dispatched and a response is generated and sent, the request context is popped, which then pops the application context. Immediately before they are popped, the [`teardown_request()`](../api/index#flask.Flask.teardown_request \"flask.Flask.teardown_request\") and [`teardown_appcontext()`](../api/index#flask.Flask.teardown_appcontext \"flask.Flask.teardown_appcontext\") functions are executed. These execute even if an unhandled exception occurred during dispatch.\n\n## Callbacks and Errors\n\nFlask dispatches a request in multiple stages which can affect the request, response, and how errors are handled. The contexts are active during all of these stages.\n\nA [`Blueprint`](../api/index#flask.Blueprint \"flask.Blueprint\") can add handlers for these events that are specific to the blueprint. The handlers for a blueprint will run if the blueprint owns the route that matches the request.\n\n1.  Before each request, [`before_request()`](../api/index#flask.Flask.before_request \"flask.Flask.before_request\") functions are called. If one of these functions return a value, the other functions are skipped. The return value is treated as the response and the view function is not called.\n2.  If the [`before_request()`](../api/index#flask.Flask.before_request \"flask.Flask.before_request\") functions did not return a response, the view function for the matched route is called and returns a response.\n3.  The return value of the view is converted into an actual response object and passed to the [`after_request()`](../api/index#flask.Flask.after_request \"flask.Flask.after_request\") functions. Each function returns a modified or new response object.\n4.  After the response is returned, the contexts are popped, which calls the [`teardown_request()`](../api/index#flask.Flask.teardown_request \"flask.Flask.teardown_request\") and [`teardown_appcontext()`](../api/index#flask.Flask.teardown_appcontext \"flask.Flask.teardown_appcontext\") functions. These functions are called even if an unhandled exception was raised at any point above.\n\nIf an exception is raised before the teardown functions, Flask tries to match it with an [`errorhandler()`](../api/index#flask.Flask.errorhandler \"flask.Flask.errorhandler\") function to handle the exception and return a response. If no error handler is found, or the handler itself raises an exception, Flask returns a generic `500 Internal Server Error` response. The teardown functions are still called, and are passed the exception object.\n\nIf debug mode is enabled, unhandled exceptions are not converted to a `500` response and instead are propagated to the WSGI server. This allows the development server to present the interactive debugger with the traceback.\n\n### Teardown Callbacks\n\nThe teardown callbacks are independent of the request dispatch, and are instead called by the contexts when they are popped. The functions are called even if there is an unhandled exception during dispatch, and for manually pushed contexts. This means there is no guarantee that any other parts of the request dispatch have run first. Be sure to write these functions in a way that does not depend on other callbacks and will not fail.\n\nDuring testing, it can be useful to defer popping the contexts after the request ends, so that their data can be accessed in the test function. Use the [`test_client()`](../api/index#flask.Flask.test_client \"flask.Flask.test_client\") as a `with` block to preserve the contexts until the `with` block exits.\n\n``` python\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    print('during view')\n    return 'Hello, World!'\n\n@app.teardown_request\ndef show_teardown(exception):\n    print('after with block')\n\nwith app.test_request_context():\n    print('during with block')\n\n# teardown functions are called after the context with block exits\n\nwith app.test_client() as client:\n    client.get('/')\n    # the contexts are not popped even though the request ended\n    print(request.path)\n\n# the contexts are popped and teardown functions are called after\n# the client with block exits\n```\n\n### Signals\n\nThe following signals are sent:\n\n1.  [`request_started`](../api/index#flask.request_started \"flask.request_started\") is sent before the [`before_request()`](../api/index#flask.Flask.before_request \"flask.Flask.before_request\") functions are called.\n2.  [`request_finished`](../api/index#flask.request_finished \"flask.request_finished\") is sent after the [`after_request()`](../api/index#flask.Flask.after_request \"flask.Flask.after_request\") functions are called.\n3.  [`got_request_exception`](../api/index#flask.got_request_exception \"flask.got_request_exception\") is sent when an exception begins to be handled, but before an [`errorhandler()`](../api/index#flask.Flask.errorhandler \"flask.Flask.errorhandler\") is looked up or called.\n4.  [`request_tearing_down`](../api/index#flask.request_tearing_down \"flask.request_tearing_down\") is sent after the [`teardown_request()`](../api/index#flask.Flask.teardown_request \"flask.Flask.teardown_request\") functions are called.\n\n## Notes On Proxies\n\nSome of the objects provided by Flask are proxies to other objects. The proxies are accessed in the same way for each worker thread, but point to the unique object bound to each worker behind the scenes as described on this page.\n\nMost of the time you don’t have to care about that, but there are some exceptions where it is good to know that this object is actually a proxy:\n\n- The proxy objects cannot fake their type as the actual object types. If you want to perform instance checks, you have to do that on the object being proxied.\n- The reference to the proxied object is needed in some situations, such as sending [Signals](../signals/index) or passing data to a background thread.\n\nIf you need to access the underlying object that is proxied, use the `_get_current_object()` method:\n\n``` python\napp = current_app._get_current_object()\nmy_signal.send(app)\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/reqcontext/](https://flask.palletsprojects.com/en/3.0.x/reqcontext/)"
- name: TRAP_BAD_REQUEST_ERRORS
  id: config/index#TRAP_BAD_REQUEST_ERRORS
  summary: Trying to access a key that doesn’t exist from request dicts like args and form will return a 400 Bad Request error page
  belongs_to: Configuration Handling
  description: |-
    `TRAP_BAD_REQUEST_ERRORS`

    Trying to access a key that doesn’t exist from request dicts like `args` and `form` will return a 400 Bad Request error page. Enable this to treat the error as an unhandled exception instead so that you get the interactive debugger. This is a more specific version of `TRAP_HTTP_EXCEPTIONS`. If unset, it is enabled in debug mode.

    Default: `None`
- name: TRAP_HTTP_EXCEPTIONS
  id: config/index#TRAP_HTTP_EXCEPTIONS
  summary: If there is no handler for an HTTPException-type exception, re-raise it to be handled by the interactive debugger instead of returning it as a simple error response
  belongs_to: Configuration Handling
  description: |-
    `TRAP_HTTP_EXCEPTIONS`

    If there is no handler for an `HTTPException`-type exception, re-raise it to be handled by the interactive debugger instead of returning it as a simple error response.

    Default: `False`
- name: Uploading Files
  id: patterns/fileuploads/index
  summary: Ah yes, the good old problem of file uploads
  description: "# Uploading Files\n\nAh yes, the good old problem of file uploads. The basic idea of file uploads is actually quite simple. It basically works like this:\n\n1.  A `<form>` tag is marked with `enctype=multipart/form-data` and an `<input type=file>` is placed in that form.\n2.  The application accesses the file from the `files` dictionary on the request object.\n3.  use the [`save()`](https://werkzeug.palletsprojects.com/en/2.3.x/datastructures/#werkzeug.datastructures.FileStorage.save \"(in Werkzeug v2.3.x)\") method of the file to save the file permanently somewhere on the filesystem.\n\n## A Gentle Introduction\n\nLet’s start with a very basic application that uploads a file to a specific upload folder and displays a file to the user. Let’s look at the bootstrapping code for our application:\n\n``` python\nimport os\nfrom flask import Flask, flash, request, redirect, url_for\nfrom werkzeug.utils import secure_filename\n\nUPLOAD_FOLDER = '/path/to/the/uploads'\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n```\n\nSo first we need a couple of imports. Most should be straightforward, the `werkzeug.secure_filename()` is explained a little bit later. The `UPLOAD_FOLDER` is where we will store the uploaded files and the `ALLOWED_EXTENSIONS` is the set of allowed file extensions.\n\nWhy do we limit the extensions that are allowed? You probably don’t want your users to be able to upload everything there if the server is directly sending out the data to the client. That way you can make sure that users are not able to upload HTML files that would cause XSS problems (see [Cross-Site Scripting (XSS)](../../security/index#security-xss)). Also make sure to disallow `.php` files if the server executes them, but who has PHP installed on their server, right? :)\n\nNext the functions that check if an extension is valid and that uploads the file and redirects the user to the URL for the uploaded file:\n\n``` python\ndef allowed_file(filename):\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n@app.route('/', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        # check if the post request has the file part\n        if 'file' not in request.files:\n            flash('No file part')\n            return redirect(request.url)\n        file = request.files['file']\n        # If the user does not select a file, the browser submits an\n        # empty file without a filename.\n        if file.filename == '':\n            flash('No selected file')\n            return redirect(request.url)\n        if file and allowed_file(file.filename):\n            filename = secure_filename(file.filename)\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n            return redirect(url_for('download_file', name=filename))\n    return '''\n    <!doctype html>\n    <title>Upload new File</title>\n    <h1>Upload new File</h1>\n    <form method=post enctype=multipart/form-data>\n      <input type=file name=file>\n      <input type=submit value=Upload>\n    </form>\n    '''\n```\n\nSo what does that [`secure_filename()`](https://werkzeug.palletsprojects.com/en/2.3.x/utils/#werkzeug.utils.secure_filename \"(in Werkzeug v2.3.x)\") function actually do? Now the problem is that there is that principle called “never trust user input”. This is also true for the filename of an uploaded file. All submitted form data can be forged, and filenames can be dangerous. For the moment just remember: always use that function to secure a filename before storing it directly on the filesystem.\n\nInformation for the Pros\n\nSo you’re interested in what that [`secure_filename()`](https://werkzeug.palletsprojects.com/en/2.3.x/utils/#werkzeug.utils.secure_filename \"(in Werkzeug v2.3.x)\") function does and what the problem is if you’re not using it? So just imagine someone would send the following information as `filename` to your application:\n\n``` python\nfilename = \"../../../../home/username/.bashrc\"\n```\n\nAssuming the number of `../` is correct and you would join this with the `UPLOAD_FOLDER` the user might have the ability to modify a file on the server’s filesystem he or she should not modify. This does require some knowledge about how the application looks like, but trust me, hackers are patient :)\n\nNow let’s look how that function works:\n\n``` python\n>>> secure_filename('../../../../home/username/.bashrc')\n'home_username_.bashrc'\n```\n\nWe want to be able to serve the uploaded files so they can be downloaded by users. We’ll define a `download_file` view to serve files in the upload folder by name. `url_for(\"download_file\", name=name)` generates download URLs.\n\n``` python\nfrom flask import send_from_directory\n\n@app.route('/uploads/<name>')\ndef download_file(name):\n    return send_from_directory(app.config[\"UPLOAD_FOLDER\"], name)\n```\n\nIf you’re using middleware or the HTTP server to serve files, you can register the `download_file` endpoint as `build_only` so `url_for` will work without a view function.\n\n``` python\napp.add_url_rule(\n    \"/uploads/<name>\", endpoint=\"download_file\", build_only=True\n)\n```\n\n## Improving Uploads\n\nChangelog\n\nNew in version 0.6.\n\nSo how exactly does Flask handle uploads? Well it will store them in the webserver’s memory if the files are reasonably small, otherwise in a temporary location (as returned by [`tempfile.gettempdir()`](https://docs.python.org/3/library/tempfile.html#tempfile.gettempdir \"(in Python v3.11)\")). But how do you specify the maximum file size after which an upload is aborted? By default Flask will happily accept file uploads with an unlimited amount of memory, but you can limit that by setting the `MAX_CONTENT_LENGTH` config key:\n\n``` python\nfrom flask import Flask, Request\n\napp = Flask(__name__)\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1000 * 1000\n```\n\nThe code above will limit the maximum allowed payload to 16 megabytes. If a larger file is transmitted, Flask will raise a [`RequestEntityTooLarge`](https://werkzeug.palletsprojects.com/en/2.3.x/exceptions/#werkzeug.exceptions.RequestEntityTooLarge \"(in Werkzeug v2.3.x)\") exception.\n\nConnection Reset Issue\n\nWhen using the local development server, you may get a connection reset error instead of a 413 response. You will get the correct status response when running the app with a production WSGI server.\n\nThis feature was added in Flask 0.6 but can be achieved in older versions as well by subclassing the request object. For more information on that consult the Werkzeug documentation on file handling.\n\n## Upload Progress Bars\n\nA while ago many developers had the idea to read the incoming file in small chunks and store the upload progress in the database to be able to poll the progress with JavaScript from the client. The client asks the server every 5 seconds how much it has transmitted, but this is something it should already know.\n\n## An Easier Solution\n\nNow there are better solutions that work faster and are more reliable. There are JavaScript libraries like [jQuery](https://jquery.com/) that have form plugins to ease the construction of progress bar.\n\nBecause the common pattern for file uploads exists almost unchanged in all applications dealing with uploads, there are also some Flask extensions that implement a full fledged upload mechanism that allows controlling which file extensions are allowed to be uploaded.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/fileuploads/](https://flask.palletsprojects.com/en/3.0.x/patterns/fileuploads/)"
- name: url_for()
  id: api/index#flask.url_for
  summary: Generate a URL to the given endpoint with the given values
  description: |-
    `flask.url_for(endpoint, *, _anchor=None, _method=None, _scheme=None, _external=None, **values)`

    Generate a URL to the given endpoint with the given values.

    This requires an active request or application context, and calls [`current_app.url_for()`](#flask.Flask.url_for "flask.Flask.url_for"). See that method for full documentation.

    Parameters:

    - **endpoint** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) – The endpoint name associated with the URL to generate. If this starts with a `.`, the current blueprint name (if any) will be used.
    - **\_anchor** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – If given, append this as `#anchor` to the URL.
    - **\_method** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – If given, generate the URL associated with this method for the endpoint.
    - **\_scheme** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)") *\|* *None*) – If given, the URL will have this scheme if it is external.
    - **\_external** ([bool](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)") *\|* *None*) – If given, prefer the URL to be internal (False) or require it to be external (True). External URLs include the scheme and domain. When not in an active request, URLs are external by default.
    - **values** ([Any](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.11)")) – Values to use for the variable parts of the URL rule. Unknown keys are appended as query string arguments, like `?a=b&c=d`.

    Return type:

    [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")

    Changelog

    Changed in version 2.2: Calls `current_app.url_for`, allowing an app to override the behavior.

    Changed in version 0.10: The `_scheme` parameter was added.

    Changed in version 0.9: The `_anchor` and `_method` parameters were added.

    Changed in version 0.9: Calls `app.handle_url_build_error` on build errors.
- name: USE_X_SENDFILE
  id: config/index#USE_X_SENDFILE
  summary: When serving files, set the X-Sendfile header instead of serving the data with Flask
  belongs_to: Configuration Handling
  description: |-
    `USE_X_SENDFILE`

    When serving files, set the `X-Sendfile` header instead of serving the data with Flask. Some web servers, such as Apache, recognize this and serve the data more efficiently. This only makes sense when using such a server.

    Default: `False`
- name: Using async and await
  id: async-await/index
  summary: New in version 2.0
  description: "# Using async and await\n\nChangelog\n\nNew in version 2.0.\n\nRoutes, error handlers, before request, after request, and teardown functions can all be coroutine functions if Flask is installed with the `async` extra (`pip install flask[async]`). This allows views to be defined with `async def` and use `await`.\n\n``` python\n@app.route(\"/get-data\")\nasync def get_data():\n    data = await async_db_query(...)\n    return jsonify(data)\n```\n\nPluggable class-based views also support handlers that are implemented as coroutines. This applies to the [`dispatch_request()`](../api/index#flask.views.View.dispatch_request \"flask.views.View.dispatch_request\") method in views that inherit from the [`flask.views.View`](../api/index#flask.views.View \"flask.views.View\") class, as well as all the HTTP method handlers in views that inherit from the [`flask.views.MethodView`](../api/index#flask.views.MethodView \"flask.views.MethodView\") class.\n\nUsing `async` on Windows on Python 3.8\n\nPython 3.8 has a bug related to asyncio on Windows. If you encounter something like `ValueError: set_wakeup_fd only works in main thread`, please upgrade to Python 3.9.\n\nUsing `async` with greenlet\n\nWhen using gevent or eventlet to serve an application or patch the runtime, greenlet\\>=1.0 is required. When using PyPy, PyPy\\>=7.3.7 is required.\n\n## Performance\n\nAsync functions require an event loop to run. Flask, as a WSGI application, uses one worker to handle one request/response cycle. When a request comes in to an async view, Flask will start an event loop in a thread, run the view function there, then return the result.\n\nEach request still ties up one worker, even for async views. The upside is that you can run async code within a view, for example to make multiple concurrent database queries, HTTP requests to an external API, etc. However, the number of requests your application can handle at one time will remain the same.\n\n**Async is not inherently faster than sync code.** Async is beneficial when performing concurrent IO-bound tasks, but will probably not improve CPU-bound tasks. Traditional Flask views will still be appropriate for most use cases, but Flask’s async support enables writing and using code that wasn’t possible natively before.\n\n## Background tasks\n\nAsync functions will run in an event loop until they complete, at which stage the event loop will stop. This means any additional spawned tasks that haven’t completed when the async function completes will be cancelled. Therefore you cannot spawn background tasks, for example via `asyncio.create_task`.\n\nIf you wish to use background tasks it is best to use a task queue to trigger background work, rather than spawn tasks in a view function. With that in mind you can spawn asyncio tasks by serving Flask with an ASGI server and utilising the asgiref WsgiToAsgi adapter as described in [ASGI](../deploying/asgi/index). This works as the adapter creates an event loop that runs continually.\n\n## When to use Quart instead\n\nFlask’s async support is less performant than async-first frameworks due to the way it is implemented. If you have a mainly async codebase it would make sense to consider [Quart](https://github.com/pallets/quart). Quart is a reimplementation of Flask based on the [ASGI](https://asgi.readthedocs.io/en/latest/) standard instead of WSGI. This allows it to handle many concurrent requests, long running requests, and websockets without requiring multiple worker processes or threads.\n\nIt has also already been possible to run Flask with Gevent or Eventlet to get many of the benefits of async request handling. These libraries patch low-level Python functions to accomplish this, whereas `async`/ `await` and ASGI use standard, modern Python capabilities. Deciding whether you should use Flask, Quart, or something else is ultimately up to understanding the specific needs of your project.\n\n## Extensions\n\nFlask extensions predating Flask’s async support do not expect async views. If they provide decorators to add functionality to views, those will probably not work with async views because they will not await the function or be awaitable. Other functions they provide will not be awaitable either and will probably be blocking if called within an async view.\n\nExtension authors can support async functions by utilising the [`flask.Flask.ensure_sync()`](../api/index#flask.Flask.ensure_sync \"flask.Flask.ensure_sync\") method. For example, if the extension provides a view function decorator add `ensure_sync` before calling the decorated function,\n\n``` python\ndef extension(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        ...  # Extension logic\n        return current_app.ensure_sync(func)(*args, **kwargs)\n\n    return wrapper\n```\n\nCheck the changelog of the extension you want to use to see if they’ve implemented async support, or make a feature request or PR to them.\n\n## Other event loops\n\nAt the moment Flask only supports [`asyncio`](https://docs.python.org/3/library/asyncio.html#module-asyncio \"(in Python v3.11)\"). It’s possible to override [`flask.Flask.ensure_sync()`](../api/index#flask.Flask.ensure_sync \"flask.Flask.ensure_sync\") to change how async functions are wrapped to use a different library.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/async-await/](https://flask.palletsprojects.com/en/3.0.x/async-await/)"
- name: Using SQLite 3 with Flask
  id: patterns/sqlite3/index
  summary: In Flask you can easily implement the opening of database connections on demand and closing them when the context dies (usually at the end of the request)
  description: "# Using SQLite 3 with Flask\n\nIn Flask you can easily implement the opening of database connections on demand and closing them when the context dies (usually at the end of the request).\n\nHere is a simple example of how you can use SQLite 3 with Flask:\n\n``` python\nimport sqlite3\nfrom flask import g\n\nDATABASE = '/path/to/database.db'\n\ndef get_db():\n    db = getattr(g, '_database', None)\n    if db is None:\n        db = g._database = sqlite3.connect(DATABASE)\n    return db\n\n@app.teardown_appcontext\ndef close_connection(exception):\n    db = getattr(g, '_database', None)\n    if db is not None:\n        db.close()\n```\n\nNow, to use the database, the application must either have an active application context (which is always true if there is a request in flight) or create an application context itself. At that point the `get_db` function can be used to get the current database connection. Whenever the context is destroyed the database connection will be terminated.\n\nExample:\n\n``` python\n@app.route('/')\ndef index():\n    cur = get_db().cursor()\n    ...\n```\n\nNote\n\nPlease keep in mind that the teardown request and appcontext functions are always executed, even if a before-request handler failed or was never executed. Because of this we have to make sure here that the database is there before we close it.\n\n## Connect on Demand\n\nThe upside of this approach (connecting on first use) is that this will only open the connection if truly necessary. If you want to use this code outside a request context you can use it in a Python shell by opening the application context by hand:\n\n``` python\nwith app.app_context():\n    # now you can use get_db()\n```\n\n## Easy Querying\n\nNow in each request handling function you can access `get_db()` to get the current open database connection. To simplify working with SQLite, a row factory function is useful. It is executed for every result returned from the database to convert the result. For instance, in order to get dictionaries instead of tuples, this could be inserted into the `get_db` function we created above:\n\n``` python\ndef make_dicts(cursor, row):\n    return dict((cursor.description[idx][0], value)\n                for idx, value in enumerate(row))\n\ndb.row_factory = make_dicts\n```\n\nThis will make the sqlite3 module return dicts for this database connection, which are much nicer to deal with. Even more simply, we could place this in `get_db` instead:\n\n``` python\ndb.row_factory = sqlite3.Row\n```\n\nThis would use Row objects rather than dicts to return the results of queries. These are `namedtuple` s, so we can access them either by index or by key. For example, assuming we have a `sqlite3.Row` called `r` for the rows `id`, `FirstName`, `LastName`, and `MiddleInitial`:\n\n``` python\n>>> # You can get values based on the row's name\n>>> r['FirstName']\nJohn\n>>> # Or, you can get them based on index\n>>> r[1]\nJohn\n# Row objects are also iterable:\n>>> for value in r:\n...     print(value)\n1\nJohn\nDoe\nM\n```\n\nAdditionally, it is a good idea to provide a query function that combines getting the cursor, executing and fetching the results:\n\n``` python\ndef query_db(query, args=(), one=False):\n    cur = get_db().execute(query, args)\n    rv = cur.fetchall()\n    cur.close()\n    return (rv[0] if rv else None) if one else rv\n```\n\nThis handy little function, in combination with a row factory, makes working with the database much more pleasant than it is by just using the raw cursor and connection objects.\n\nHere is how you can use it:\n\n``` python\nfor user in query_db('select * from users'):\n    print(user['username'], 'has the id', user['user_id'])\n```\n\nOr if you just want a single result:\n\n``` python\nuser = query_db('select * from users where username = ?',\n                [the_username], one=True)\nif user is None:\n    print('No such user')\nelse:\n    print(the_username, 'has the id', user['user_id'])\n```\n\nTo pass variable parts to the SQL statement, use a question mark in the statement and pass in the arguments as a list. Never directly add them to the SQL statement with string formatting because this makes it possible to attack the application using [SQL Injections](https://en.wikipedia.org/wiki/SQL_injection).\n\n## Initial Schemas\n\nRelational databases need schemas, so applications often ship a `schema.sql` file that creates the database. It’s a good idea to provide a function that creates the database based on that schema. This function can do that for you:\n\n``` python\ndef init_db():\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n```\n\nYou can then create such a database from the Python shell:\n\n``` python\n>>> from yourapplication import init_db\n>>> init_db()\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/sqlite3/](https://flask.palletsprojects.com/en/3.0.x/patterns/sqlite3/)"
- name: Using URL Processors
  id: patterns/urlprocessors/index
  summary: New in version 0.7
  description: "# Using URL Processors\n\nChangelog\n\nNew in version 0.7.\n\nFlask 0.7 introduces the concept of URL processors. The idea is that you might have a bunch of resources with common parts in the URL that you don’t always explicitly want to provide. For instance you might have a bunch of URLs that have the language code in it but you don’t want to have to handle it in every single function yourself.\n\nURL processors are especially helpful when combined with blueprints. We will handle both application specific URL processors here as well as blueprint specifics.\n\n## Internationalized Application URLs\n\nConsider an application like this:\n\n``` python\nfrom flask import Flask, g\n\napp = Flask(__name__)\n\n@app.route('/<lang_code>/')\ndef index(lang_code):\n    g.lang_code = lang_code\n    ...\n\n@app.route('/<lang_code>/about')\ndef about(lang_code):\n    g.lang_code = lang_code\n    ...\n```\n\nThis is an awful lot of repetition as you have to handle the language code setting on the [`g`](../../api/index#flask.g \"flask.g\") object yourself in every single function. Sure, a decorator could be used to simplify this, but if you want to generate URLs from one function to another you would have to still provide the language code explicitly which can be annoying.\n\nFor the latter, this is where [`url_defaults()`](../../api/index#flask.Flask.url_defaults \"flask.Flask.url_defaults\") functions come in. They can automatically inject values into a call to [`url_for()`](../../api/index#flask.url_for \"flask.url_for\"). The code below checks if the language code is not yet in the dictionary of URL values and if the endpoint wants a value named `'lang_code'`:\n\n``` python\n@app.url_defaults\ndef add_language_code(endpoint, values):\n    if 'lang_code' in values or not g.lang_code:\n        return\n    if app.url_map.is_endpoint_expecting(endpoint, 'lang_code'):\n        values['lang_code'] = g.lang_code\n```\n\nThe method [`is_endpoint_expecting()`](https://werkzeug.palletsprojects.com/en/2.3.x/routing/#werkzeug.routing.Map.is_endpoint_expecting \"(in Werkzeug v2.3.x)\") of the URL map can be used to figure out if it would make sense to provide a language code for the given endpoint.\n\nThe reverse of that function are [`url_value_preprocessor()`](../../api/index#flask.Flask.url_value_preprocessor \"flask.Flask.url_value_preprocessor\")s. They are executed right after the request was matched and can execute code based on the URL values. The idea is that they pull information out of the values dictionary and put it somewhere else:\n\n``` python\n@app.url_value_preprocessor\ndef pull_lang_code(endpoint, values):\n    g.lang_code = values.pop('lang_code', None)\n```\n\nThat way you no longer have to do the `lang_code` assignment to [`g`](../../api/index#flask.g \"flask.g\") in every function. You can further improve that by writing your own decorator that prefixes URLs with the language code, but the more beautiful solution is using a blueprint. Once the `'lang_code'` is popped from the values dictionary and it will no longer be forwarded to the view function reducing the code to this:\n\n``` python\nfrom flask import Flask, g\n\napp = Flask(__name__)\n\n@app.url_defaults\ndef add_language_code(endpoint, values):\n    if 'lang_code' in values or not g.lang_code:\n        return\n    if app.url_map.is_endpoint_expecting(endpoint, 'lang_code'):\n        values['lang_code'] = g.lang_code\n\n@app.url_value_preprocessor\ndef pull_lang_code(endpoint, values):\n    g.lang_code = values.pop('lang_code', None)\n\n@app.route('/<lang_code>/')\ndef index():\n    ...\n\n@app.route('/<lang_code>/about')\ndef about():\n    ...\n```\n\n## Internationalized Blueprint URLs\n\nBecause blueprints can automatically prefix all URLs with a common string it’s easy to automatically do that for every function. Furthermore blueprints can have per-blueprint URL processors which removes a whole lot of logic from the [`url_defaults()`](../../api/index#flask.Flask.url_defaults \"flask.Flask.url_defaults\") function because it no longer has to check if the URL is really interested in a `'lang_code'` parameter:\n\n``` python\nfrom flask import Blueprint, g\n\nbp = Blueprint('frontend', __name__, url_prefix='/<lang_code>')\n\n@bp.url_defaults\ndef add_language_code(endpoint, values):\n    values.setdefault('lang_code', g.lang_code)\n\n@bp.url_value_preprocessor\ndef pull_lang_code(endpoint, values):\n    g.lang_code = values.pop('lang_code')\n\n@bp.route('/')\ndef index():\n    ...\n\n@bp.route('/about')\ndef about():\n    ...\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/urlprocessors/](https://flask.palletsprojects.com/en/3.0.x/patterns/urlprocessors/)"
- name: uWSGI
  id: deploying/uwsgi/index
  summary: uWSGI is a fast, compiled server suite with extensive configuration and capabilities beyond a basic server
  description: "# uWSGI\n\n[uWSGI](https://uwsgi-docs.readthedocs.io/en/latest/) is a fast, compiled server suite with extensive configuration and capabilities beyond a basic server.\n\n- It can be very performant due to being a compiled program.\n- It is complex to configure beyond the basic application, and has so many options that it can be difficult for beginners to understand.\n- It does not support Windows (but does run on WSL).\n- It requires a compiler to install in some cases.\n\nThis page outlines the basics of running uWSGI. Be sure to read its documentation to understand what features are available.\n\n## Installing\n\nuWSGI has multiple ways to install it. The most straightforward is to install the `pyuwsgi` package, which provides precompiled wheels for common platforms. However, it does not provide SSL support, which can be provided with a reverse proxy instead.\n\nCreate a virtualenv, install your application, then install `pyuwsgi`.\n\n``` text\n$ cd hello-app\n$ python -m venv .venv\n$ . .venv/bin/activate\n$ pip install .  # install your application\n$ pip install pyuwsgi\n```\n\nIf you have a compiler available, you can install the `uwsgi` package instead. Or install the `pyuwsgi` package from sdist instead of wheel. Either method will include SSL support.\n\n``` text\n$ pip install uwsgi\n\n# or\n$ pip install --no-binary pyuwsgi pyuwsgi\n```\n\n## Running\n\nThe most basic way to run uWSGI is to tell it to start an HTTP server and import your application.\n\n``` text\n$ uwsgi --http 127.0.0.1:8000 --master -p 4 -w hello:app\n\n*** Starting uWSGI 2.0.20 (64bit) on [x] ***\n*** Operational MODE: preforking ***\nmounting hello:app on /\nspawned uWSGI master process (pid: x)\nspawned uWSGI worker 1 (pid: x, cores: 1)\nspawned uWSGI worker 2 (pid: x, cores: 1)\nspawned uWSGI worker 3 (pid: x, cores: 1)\nspawned uWSGI worker 4 (pid: x, cores: 1)\nspawned uWSGI http 1 (pid: x)\n```\n\nIf you’re using the app factory pattern, you’ll need to create a small Python file to create the app, then point uWSGI at that.\n\n`wsgi.py`\n\n``` python\nfrom hello import create_app\n\napp = create_app()\n```\n\n``` text\n$ uwsgi --http 127.0.0.1:8000 --master -p 4 -w wsgi:app\n```\n\nThe `--http` option starts an HTTP server at 127.0.0.1 port 8000. The `--master` option specifies the standard worker manager. The `-p` option starts 4 worker processes; a starting value could be `CPU * 2`. The `-w` option tells uWSGI how to import your application\n\n## Binding Externally\n\nuWSGI should not be run as root with the configuration shown in this doc because it would cause your application code to run as root, which is not secure. However, this means it will not be possible to bind to port 80 or 443. Instead, a reverse proxy such as [nginx](../nginx/index) or [Apache httpd](../apache-httpd/index) should be used in front of uWSGI. It is possible to run uWSGI as root securely, but that is beyond the scope of this doc.\n\nuWSGI has optimized integration with [Nginx uWSGI](https://uwsgi-docs.readthedocs.io/en/latest/Nginx.html) and [Apache mod_proxy_uwsgi](https://uwsgi-docs.readthedocs.io/en/latest/Apache.html#mod-proxy-uwsgi), and possibly other servers, instead of using a standard HTTP proxy. That configuration is beyond the scope of this doc, see the links for more information.\n\nYou can bind to all external IPs on a non-privileged port using the `--http 0.0.0.0:8000` option. Don’t do this when using a reverse proxy setup, otherwise it will be possible to bypass the proxy.\n\n``` text\n$ uwsgi --http 0.0.0.0:8000 --master -p 4 -w wsgi:app\n```\n\n`0.0.0.0` is not a valid address to navigate to, you’d use a specific IP address in your browser.\n\n## Async with gevent\n\nThe default sync worker is appropriate for many use cases. If you need asynchronous support, uWSGI provides a [gevent](https://www.gevent.org/) worker. This is not the same as Python’s `async/await`, or the ASGI server spec. You must actually use gevent in your own code to see any benefit to using the worker.\n\nWhen using gevent, greenlet\\>=1.0 is required, otherwise context locals such as `request` will not work as expected. When using PyPy, PyPy\\>=7.3.7 is required.\n\n``` text\n$ uwsgi --http 127.0.0.1:8000 --master --gevent 100 -w wsgi:app\n\n*** Starting uWSGI 2.0.20 (64bit) on [x] ***\n*** Operational MODE: async ***\nmounting hello:app on /\nspawned uWSGI master process (pid: x)\nspawned uWSGI worker 1 (pid: x, cores: 100)\nspawned uWSGI http 1 (pid: x)\n*** running gevent loop engine [addr:x] ***\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/deploying/uwsgi/](https://flask.palletsprojects.com/en/3.0.x/deploying/uwsgi/)"
- name: View
  id: api/index#flask.views.View
  summary: Subclass this class and override dispatch_request() to create a generic class-based view
  description: |-
    `class flask.views.View`

    Subclass this class and override [`dispatch_request()`](#flask.views.View.dispatch_request "flask.views.View.dispatch_request") to create a generic class-based view. Call [`as_view()`](#flask.views.View.as_view "flask.views.View.as_view") to create a view function that creates an instance of the class with the given arguments and calls its `dispatch_request` method with any URL variables.

    See [Class-based Views](../views/index) for a detailed guide.

    ``` python
    class Hello(View):
        init_every_request = False

        def dispatch_request(self, name):
            return f"Hello, {name}!"

    app.add_url_rule(
        "/hello/<name>", view_func=Hello.as_view("hello")
    )
    ```

    Set [`methods`](#flask.views.View.methods "flask.views.View.methods") on the class to change what methods the view accepts.

    Set [`decorators`](#flask.views.View.decorators "flask.views.View.decorators") on the class to apply a list of decorators to the generated view function. Decorators applied to the class itself will not be applied to the generated view function!

    Set [`init_every_request`](#flask.views.View.init_every_request "flask.views.View.init_every_request") to `False` for efficiency, unless you need to store request-global data on `self`.
- name: View Decorators
  id: patterns/viewdecorators/index
  summary: Python has a really interesting feature called function decorators
  description: "# View Decorators\n\nPython has a really interesting feature called function decorators. This allows some really neat things for web applications. Because each view in Flask is a function, decorators can be used to inject additional functionality to one or more functions. The [`route()`](../../api/index#flask.Flask.route \"flask.Flask.route\") decorator is the one you probably used already. But there are use cases for implementing your own decorator. For instance, imagine you have a view that should only be used by people that are logged in. If a user goes to the site and is not logged in, they should be redirected to the login page. This is a good example of a use case where a decorator is an excellent solution.\n\n## Login Required Decorator\n\nSo let’s implement such a decorator. A decorator is a function that wraps and replaces another function. Since the original function is replaced, you need to remember to copy the original function’s information to the new function. Use [`functools.wraps()`](https://docs.python.org/3/library/functools.html#functools.wraps \"(in Python v3.11)\") to handle this for you.\n\nThis example assumes that the login page is called `'login'` and that the current user is stored in `g.user` and is `None` if there is no-one logged in.\n\n``` python\nfrom functools import wraps\nfrom flask import g, request, redirect, url_for\n\ndef login_required(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if g.user is None:\n            return redirect(url_for('login', next=request.url))\n        return f(*args, **kwargs)\n    return decorated_function\n```\n\nTo use the decorator, apply it as innermost decorator to a view function. When applying further decorators, always remember that the [`route()`](../../api/index#flask.Flask.route \"flask.Flask.route\") decorator is the outermost.\n\n``` python\n@app.route('/secret_page')\n@login_required\ndef secret_page():\n    pass\n```\n\nNote\n\nThe `next` value will exist in `request.args` after a `GET` request for the login page. You’ll have to pass it along when sending the `POST` request from the login form. You can do this with a hidden input tag, then retrieve it from `request.form` when logging the user in.\n\n``` python\n<input type=\"hidden\" value=\"{{ request.args.get('next', '') }}\"/>\n```\n\n## Caching Decorator\n\nImagine you have a view function that does an expensive calculation and because of that you would like to cache the generated results for a certain amount of time. A decorator would be nice for that. We’re assuming you have set up a cache like mentioned in [Caching](../caching/index).\n\nHere is an example cache function. It generates the cache key from a specific prefix (actually a format string) and the current path of the request. Notice that we are using a function that first creates the decorator that then decorates the function. Sounds awful? Unfortunately it is a little bit more complex, but the code should still be straightforward to read.\n\nThe decorated function will then work as follows\n\n1.  get the unique cache key for the current request based on the current path.\n2.  get the value for that key from the cache. If the cache returned something we will return that value.\n3.  otherwise the original function is called and the return value is stored in the cache for the timeout provided (by default 5 minutes).\n\nHere the code:\n\n``` python\nfrom functools import wraps\nfrom flask import request\n\ndef cached(timeout=5 * 60, key='view/{}'):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            cache_key = key.format(request.path)\n            rv = cache.get(cache_key)\n            if rv is not None:\n                return rv\n            rv = f(*args, **kwargs)\n            cache.set(cache_key, rv, timeout=timeout)\n            return rv\n        return decorated_function\n    return decorator\n```\n\nNotice that this assumes an instantiated `cache` object is available, see [Caching](../caching/index).\n\n## Templating Decorator\n\nA common pattern invented by the TurboGears guys a while back is a templating decorator. The idea of that decorator is that you return a dictionary with the values passed to the template from the view function and the template is automatically rendered. With that, the following three examples do exactly the same:\n\n``` python\n@app.route('/')\ndef index():\n    return render_template('index.html', value=42)\n\n@app.route('/')\n@templated('index.html')\ndef index():\n    return dict(value=42)\n\n@app.route('/')\n@templated()\ndef index():\n    return dict(value=42)\n```\n\nAs you can see, if no template name is provided it will use the endpoint of the URL map with dots converted to slashes + `'.html'`. Otherwise the provided template name is used. When the decorated function returns, the dictionary returned is passed to the template rendering function. If `None` is returned, an empty dictionary is assumed, if something else than a dictionary is returned we return it from the function unchanged. That way you can still use the redirect function or return simple strings.\n\nHere is the code for that decorator:\n\n``` python\nfrom functools import wraps\nfrom flask import request, render_template\n\ndef templated(template=None):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            template_name = template\n            if template_name is None:\n                template_name = f\"{request.endpoint.replace('.', '/')}.html\"\n            ctx = f(*args, **kwargs)\n            if ctx is None:\n                ctx = {}\n            elif not isinstance(ctx, dict):\n                return ctx\n            return render_template(template_name, **ctx)\n        return decorated_function\n    return decorator\n```\n\n## Endpoint Decorator\n\nWhen you want to use the werkzeug routing system for more flexibility you need to map the endpoint as defined in the [`Rule`](https://werkzeug.palletsprojects.com/en/2.3.x/routing/#werkzeug.routing.Rule \"(in Werkzeug v2.3.x)\") to a view function. This is possible with this decorator. For example:\n\n``` python\nfrom flask import Flask\nfrom werkzeug.routing import Rule\n\napp = Flask(__name__)\napp.url_map.add(Rule('/', endpoint='index'))\n\n@app.endpoint('index')\ndef my_index():\n    return \"Hello world\"\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/patterns/viewdecorators/](https://flask.palletsprojects.com/en/3.0.x/patterns/viewdecorators/)"
- name: View.as_view()
  id: api/index#flask.views.View.as_view
  summary: Convert the class into a view function that can be registered for a route
  description: |-
    `classmethod as_view(name, *class_args, **class_kwargs)`

    Convert the class into a view function that can be registered for a route.

    By default, the generated view will create a new instance of the view class for every request and call its [`dispatch_request()`](#flask.views.View.dispatch_request "flask.views.View.dispatch_request") method. If the view class sets [`init_every_request`](#flask.views.View.init_every_request "flask.views.View.init_every_request") to `False`, the same instance will be used for every request.

    Except for `name`, all other arguments passed to this method are forwarded to the view class `__init__` method.

    Changelog

    Changed in version 2.2: Added the `init_every_request` class attribute.

    Parameters:

    - **name** ([str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.11)")) –
    - **class_args** (*t.Any*) –
    - **class_kwargs** (*t.Any*) –

    Return type:

    ft.RouteCallable
- name: View.decorators
  id: api/index#flask.views.View.decorators
  summary: A list of decorators to apply, in order, to the generated view function
  description: |-
    `decorators: ClassVar[list[Callable]] = []`

    A list of decorators to apply, in order, to the generated view function. Remember that `@decorator` syntax is applied bottom to top, so the first decorator in the list would be the bottom decorator.

    Changelog

    New in version 0.8.
- name: View.dispatch_request()
  id: api/index#flask.views.View.dispatch_request
  summary: The actual view function behavior
  description: |-
    `dispatch_request()`

    The actual view function behavior. Subclasses must override this and return a valid response. Any variables from the URL rule are passed as keyword arguments.

    Return type:

    ft.ResponseReturnValue
- name: View.init_every_request
  id: api/index#flask.views.View.init_every_request
  summary: Create a new instance of this view class for every request by default
  description: |-
    `init_every_request: ClassVar[bool] = True`

    Create a new instance of this view class for every request by default. If a view subclass sets this to `False`, the same instance is used for every request.

    A single instance is more efficient, especially if complex setup is done during init. However, storing data on `self` is no longer safe across requests, and [`g`](#flask.g "flask.g") should be used instead.

    Changelog

    New in version 2.2.
- name: View.methods
  id: api/index#flask.views.View.methods
  summary: The methods this view is registered for
  description: |-
    `methods: ClassVar[Collection[str] | None] = None`

    The methods this view is registered for. Uses the same default (`["GET", "HEAD", "OPTIONS"]`) as `route` and `add_url_rule` by default.
- name: View.provide_automatic_options
  id: api/index#flask.views.View.provide_automatic_options
  summary: Control whether the OPTIONS method is handled automatically
  description: |-
    `provide_automatic_options: ClassVar[bool | None] = None`

    Control whether the `OPTIONS` method is handled automatically. Uses the same default (`True`) as `route` and `add_url_rule` by default.
- name: Waitress
  id: deploying/waitress/index
  summary: Waitress is a pure Python WSGI server
  description: "# Waitress\n\n[Waitress](https://docs.pylonsproject.org/projects/waitress/) is a pure Python WSGI server.\n\n- It is easy to configure.\n- It supports Windows directly.\n- It is easy to install as it does not require additional dependencies or compilation.\n- It does not support streaming requests, full request data is always buffered.\n- It uses a single process with multiple thread workers.\n\nThis page outlines the basics of running Waitress. Be sure to read its documentation and `waitress-serve --help` to understand what features are available.\n\n## Installing\n\nCreate a virtualenv, install your application, then install `waitress`.\n\n``` text\n$ cd hello-app\n$ python -m venv .venv\n$ . .venv/bin/activate\n$ pip install .  # install your application\n$ pip install waitress\n```\n\n## Running\n\nThe only required argument to `waitress-serve` tells it how to load your Flask application. The syntax is `{module}:{app}`. `module` is the dotted import name to the module with your application. `app` is the variable with the application. If you’re using the app factory pattern, use `--call {module}:{factory}` instead.\n\n``` text\n# equivalent to 'from hello import app'\n$ waitress-serve --host 127.0.0.1 hello:app\n\n# equivalent to 'from hello import create_app; create_app()'\n$ waitress-serve --host 127.0.0.1 --call hello:create_app\n\nServing on http://127.0.0.1:8080\n```\n\nThe `--host` option binds the server to local `127.0.0.1` only.\n\nLogs for each request aren’t shown, only errors are shown. Logging can be configured through the Python interface instead of the command line.\n\n## Binding Externally\n\nWaitress should not be run as root because it would cause your application code to run as root, which is not secure. However, this means it will not be possible to bind to port 80 or 443. Instead, a reverse proxy such as [nginx](../nginx/index) or [Apache httpd](../apache-httpd/index) should be used in front of Waitress.\n\nYou can bind to all external IPs on a non-privileged port by not specifying the `--host` option. Don’t do this when using a revers proxy setup, otherwise it will be possible to bypass the proxy.\n\n`0.0.0.0` is not a valid address to navigate to, you’d use a specific IP address in your browser.\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/deploying/waitress/](https://flask.palletsprojects.com/en/3.0.x/deploying/waitress/)"
- name: with_appcontext()
  id: api/index#flask.cli.with_appcontext
  summary: Wraps a callback so that it’s guaranteed to be executed with the script’s application context
  description: |-
    `flask.cli.with_appcontext(f)`

    Wraps a callback so that it’s guaranteed to be executed with the script’s application context.

    Custom commands (and their options) registered under `app.cli` or `blueprint.cli` will always have an app context available, this decorator is not required in that case.

    Changelog

    Changed in version 2.2: The app context is active for subcommands as well as the decorated callback. The app context is always available to `app.cli` command and parameter callbacks.
- name: Working with the Shell
  id: shell/index
  summary: New in version 0.3
  description: "# Working with the Shell\n\nChangelog\n\nNew in version 0.3.\n\nOne of the reasons everybody loves Python is the interactive shell. It basically allows you to execute Python commands in real time and immediately get results back. Flask itself does not come with an interactive shell, because it does not require any specific setup upfront, just import your application and start playing around.\n\nThere are however some handy helpers to make playing around in the shell a more pleasant experience. The main issue with interactive console sessions is that you’re not triggering a request like a browser does which means that [`g`](../api/index#flask.g \"flask.g\"), [`request`](../api/index#flask.request \"flask.request\") and others are not available. But the code you want to test might depend on them, so what can you do?\n\nThis is where some helper functions come in handy. Keep in mind however that these functions are not only there for interactive shell usage, but also for unit testing and other situations that require a faked request context.\n\nGenerally it’s recommended that you read [The Request Context](../reqcontext/index) first.\n\n## Command Line Interface\n\nStarting with Flask 0.11 the recommended way to work with the shell is the `flask shell` command which does a lot of this automatically for you. For instance the shell is automatically initialized with a loaded application context.\n\nFor more information see [Command Line Interface](../cli/index).\n\n## Creating a Request Context\n\nThe easiest way to create a proper request context from the shell is by using the [`test_request_context`](../api/index#flask.Flask.test_request_context \"flask.Flask.test_request_context\") method which creates us a [`RequestContext`](../api/index#flask.ctx.RequestContext \"flask.ctx.RequestContext\"):\n\n``` python\n>>> ctx = app.test_request_context()\n```\n\nNormally you would use the `with` statement to make this request object active, but in the shell it’s easier to use the `push()` and [`pop()`](../api/index#flask.ctx.RequestContext.pop \"flask.ctx.RequestContext.pop\") methods by hand:\n\n``` python\n>>> ctx.push()\n```\n\nFrom that point onwards you can work with the request object until you call `pop`:\n\n``` python\n>>> ctx.pop()\n```\n\n## Firing Before/After Request\n\nBy just creating a request context, you still don’t have run the code that is normally run before a request. This might result in your database being unavailable if you are connecting to the database in a before-request callback or the current user not being stored on the [`g`](../api/index#flask.g \"flask.g\") object etc.\n\nThis however can easily be done yourself. Just call [`preprocess_request()`](../api/index#flask.Flask.preprocess_request \"flask.Flask.preprocess_request\"):\n\n``` python\n>>> ctx = app.test_request_context()\n>>> ctx.push()\n>>> app.preprocess_request()\n```\n\nKeep in mind that the [`preprocess_request()`](../api/index#flask.Flask.preprocess_request \"flask.Flask.preprocess_request\") function might return a response object, in that case just ignore it.\n\nTo shutdown a request, you need to trick a bit before the after request functions (triggered by [`process_response()`](../api/index#flask.Flask.process_response \"flask.Flask.process_response\")) operate on a response object:\n\n``` python\n>>> app.process_response(app.response_class())\n<Response 0 bytes [200 OK]>\n>>> ctx.pop()\n```\n\nThe functions registered as [`teardown_request()`](../api/index#flask.Flask.teardown_request \"flask.Flask.teardown_request\") are automatically called when the context is popped. So this is the perfect place to automatically tear down resources that were needed by the request context (such as database connections).\n\n## Further Improving the Shell Experience\n\nIf you like the idea of experimenting in a shell, create yourself a module with stuff you want to star import into your interactive session. There you could also define some more helper methods for common things such as initializing the database, dropping tables etc.\n\nJust put them into a module (like `shelltools`) and import from there:\n\n``` python\n>>> from shelltools import *\n```\n\n© 2010 Pallets  \nLicensed under the BSD 3-clause License.  \n[https://flask.palletsprojects.com/en/3.0.x/shell/](https://flask.palletsprojects.com/en/3.0.x/shell/)"
