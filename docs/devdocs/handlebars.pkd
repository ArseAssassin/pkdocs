---
name: Handlebars.js
slug: handlebars
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © 2011–2017 by Yehuda Katz
  Licensed under the MIT License.
  https://handlebarsjs.com/
homepage: https://handlebarsjs.com/

---
- name: '@data Variables'
  id: reference#data
  summary: The following @data variables are implemented by Handlebars and its builtin helpers
  belongs_to: Reference
  description: |-
    ## @data Variables

    The following `@data` variables are implemented by Handlebars and its builtin helpers.
- name: '@first'
  id: reference#data-first
  summary: Set to true by the each helper for the first step of iteration
  belongs_to: Reference
  description: |-
    ### `@first`

    Set to true by the `each` helper for the first step of iteration.

    ``` html
    {{#each array}}
      {{#if @first}}
        First!
      {{/if}}
    {{/each}}
    ```
- name: '@index'
  id: reference#data-index
  summary: Zero-based index for the current iteration step
  belongs_to: Reference
  description: |-
    ### `@index`

    Zero-based index for the current iteration step. Set by the `each` helper.

    ``` html
    {{#each array}}
      {{@index}}
    {{/each}}
    ```
- name: '@key'
  id: reference#data-key
  summary: Key name for the current iteration step
  belongs_to: Reference
  description: |-
    ### `@key`

    Key name for the current iteration step. Set by the `each` helper when iterating over objects.

    ``` html
    {{#each array}}
      {{@key}}
    {{/each}}
    ```
- name: '@last'
  id: reference#data-last
  summary: Set to true by the each helper for the last step of iteration
  belongs_to: Reference
  description: |-
    ### `@last`

    Set to true by the `each` helper for the last step of iteration.

    ``` html
    {{#each array}}
      {{#if @last}}
        Last :(
      {{/if}}
    {{/each}}
    ```
- name: '@level'
  id: reference#data-level
  summary: Assigned log level
  belongs_to: Reference
  description: "### `@level`\n\nAssigned log level.\n\n``` html\ntemplate({}, {data: {level: Handlebars.logger.WARN}})\n```\n\nMay be set to one of `Handlebars.logger.DEBUG` , `Handlebars.logger.INFO` , `Handlebars.logger.WARN` , or `Handlebars.logger.ERROR`\n\nWhen set, the logger will include in its output only messages with a log level of `Handlebars.logger.level` or higher. The default value is `Handlebars.logger.ERROR`.\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/reference.html](https://handlebarsjs.com/reference.html)"
- name: '@root'
  id: reference#data-root
  summary: Initial context with which the template was executed
  belongs_to: Reference
  description: |-
    ### `@root`

    Initial context with which the template was executed.

    ``` html
    {{#each array}}
      {{@root.foo}}
    {{/each}}
    ```

    Unless explicitly modified, this value is consistent across all portions of the page rendering, meaning it can be used within partials where depthed parameters are unable to reference their parent templates.
- name: API Reference
  id: index#Utilities
  summary: Handlebars offers a variety of APIs and utility methods for applications and helpers
  description: "## API Reference\n\nHandlebars offers a variety of APIs and utility methods for applications and helpers.\n\n[Learn More: API Reference](reference)\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/](https://handlebarsjs.com/)"
- name: Base
  id: reference#base
  summary: null
  belongs_to: Reference
  description: '## Base'
- name: Basic Partials
  id: partials#basic-partials
  summary: In order to use a partial, it must be registered via Handlebars.registerPartial
  belongs_to: Partials
  description: |-
    ## Basic Partials

    In order to use a partial, it must be registered via `Handlebars.registerPartial`.

    ``` html
    Handlebars.registerPartial('myPartial', '{{name}}')
    ```

    This call will register the `myPartial` partial. Partials may be precompiled and the precompiled template passed into the second parameter.

    Calling the partial is done through the partial call syntax:

    ``` html
    {{> myPartial }}
    ```

    Will render the partial named `myPartial`. When the partial executes, it will be run under the current execution context.
- name: Basic Usage
  id: expressions#basic-blocks
  summary: This expression means "look up the title property in the current context". Block helpers may manipulate the current context, but they do not change the basic meaning of an expression
  belongs_to: Expressions
  description: |-
    ## Basic Usage

    The simplest Handlebars expression is a simple identifier:

    ``` html
    <h1>{{title}}</h1>
    ```

    This expression means "look up the `title` property in the current context". Block helpers may manipulate the current context, but they do not change the basic meaning of an expression.

    Actually, it means "look for a helper named `title`, then do the above", but we'll get to that soon enough.

    Handlebars expressions can also be dot-separated paths.

    ``` html
    <h1>{{article.title}}</h1>
    ```

    This expression means "look up the `article` property in the current context. Then look up the `title` property in the result".

    Handlebars also supports a deprecated `/` syntax, so you could write the above template as:

    ``` html
    <h1>{{article/title}}</h1>
    ```

    Identifiers may be any unicode character except for the following:

    Whitespace `!` `"` `#` `%` `&` `'` `(` `)` `*` `+` `,` `.` `/` `;` `<` `=` `>` `@` `[` `\` `]` `^` `` ` `` `{` `|` `}` `~`

    To reference a property that is not a valid identifier, you can use segment-literal notation, `[`:

    ``` html
    {{#each articles.[10].[#comments]}}
      <h1>{{subject}}</h1>
      <div>
        {{body}}
      </div>
    {{/each}}
    ```

    In the example above, the template will treat the `each` parameter roughly equivalent to this javascript: `articles[10]['#comments']`

    You may not include a closing `]` in a path-literal, but all other characters are fair game.

    JavaScript-style strings, `"` and `'`, may also be used vs. `[` pairs.

    Handlebars HTML-escapes values returned by a `{{expression}}`. If you don't want Handlebars to escape a value, use the "triple-stash", `{{{`

    ``` html
    {{{foo}}}
    ```
- name: Block Expressions
  id: index#block-expressions
  summary: Block expressions allow you to define helpers that will invoke a section of your template with a different context than the current
  description: |-
    ## Block Expressions

    Block expressions allow you to define helpers that will invoke a section of your template with a different context than the current. These block helpers are identified by a `#` preceeding the helper name and require a matching closing mustache, `/`, of the same name.

    Let's consider a helper that will generate an HTML list:

    ``` html
    {{#list people}}{{firstName}} {{lastName}}{{/list}}
    ```

    If we have the following context:

    ``` html
    {
      people: [
        {firstName: "Yehuda", lastName: "Katz"},
        {firstName: "Carl", lastName: "Lerche"},
        {firstName: "Alan", lastName: "Johnson"}
      ]
    }
    ```

    we would create a helper named `list` to generate our HTML list. The helper receives the `people` as its first parameter, and an options hash as its second parameter. The options hash contains a property named `fn`, which you can invoke with a context just as you would invoke a normal Handlebars template.

    ``` html
    Handlebars.registerHelper('list', function(items, options) {
      var out = "<ul>";

      for(var i=0, l=items.length; i<l; i++) {
        out = out + "<li>" + options.fn(items[i]) + "</li>";
      }

      return out + "</ul>";
    });
    ```

    When executed, the template will render:

    ``` html
    <ul>
      <li>Yehuda Katz</li>
      <li>Carl Lerche</li>
      <li>Alan Johnson</li>
    </ul>
    ```

    Block helpers have more features, such as the ability to create an `else` section (used, for instance, by the built-in `if` helper).

    Since the contents of a block helper are escaped when you call `options.fn(context)`, Handlebars does not escape the results of a block helper. If it did, inner content would be double-escaped!

    [Learn More: Block Helpers](block_helpers)
- name: Block Helpers
  id: block_helpers
  summary: Block helpers make it possible to define custom iterators and other functionality that can invoke the passed block with a new context
  description: "# Block Helpers\n\nBlock helpers make it possible to define custom iterators and other functionality that can invoke the passed block with a new context.\n\n## Basic Blocks\n\nFor demonstration purposes, let's define a block helper that invokes the block as though no helper existed.\n\n``` html\n<div class=\"entry\">\n  <h1>{{title}}</h1>\n  <div class=\"body\">\n    {{#noop}}{{body}}{{/noop}}\n  </div>\n</div>\n```\n\nThe `noop` helper (short for \"no operation\") will receive an options hash. This options hash contains a function (`options.fn`) that behaves like a normal compiled Handlebars template. Specifically, the function will take a context and return a String.\n\n``` html\nHandlebars.registerHelper('noop', function(options) {\n  return options.fn(this);\n});\n```\n\nHandlebars always invokes helpers with the current context as `this`, so you can invoke the block with `this` to evaluate the block in the current context.\n\nAny helpers defined in this manner will take precedence over fields defined in the context. To access a field that is masked by a helper, a path reference may be used. In the example above a field named `noop` on the context object would be referenced using:\n\n``` html\n{{./noop}}\n```\n\n## Basic Block Variation\n\nTo better illustrate the syntax, let's define another block helper that adds some markup to the wrapped text.\n\n``` html\n<div class=\"entry\">\n  <h1>{{title}}</h1>\n  <div class=\"body\">\n    {{#bold}}{{body}}{{/bold}}\n  </div>\n</div>\n```\n\nThe `bold` helper will add markup to make its text bold. As before, the function will take a context as input and return a String.\n\n``` html\nHandlebars.registerHelper('bold', function(options) {\n  return new Handlebars.SafeString(\n      '<div class=\"mybold\">'\n      + options.fn(this)\n      + '</div>');\n});\n```\n\n## The `with` helper\n\nThe `with` helper demonstrates how to pass a parameter to your helper. When a helper is called with a parameter, it is invoked with whatever context the template passed in.\n\n``` html\n<div class=\"entry\">\n  <h1>{{title}}</h1>\n  {{#with story}}\n    <div class=\"intro\">{{{intro}}}</div>\n    <div class=\"body\">{{{body}}}</div>\n  {{/with}}\n</div>\n```\n\nYou might find a helper like this useful if a section of your JSON object contains deeply nested properties, and you want to avoid repeating the parent name. The above template could be useful with a JSON like:\n\n``` html\n{\n  title: \"First Post\",\n  story: {\n    intro: \"Before the jump\",\n    body: \"After the jump\"\n  }\n}\n```\n\nImplementing a helper like this is a lot like implementing the `noop` helper. Helpers can take parameters, and parameters are evaluated just like expressions used directly inside `{{mustache}}` blocks.\n\n``` html\nHandlebars.registerHelper('with', function(context, options) {\n  return options.fn(context);\n});\n```\n\nParameters are passed to helpers in the order that they are passed, followed by the options hash.\n\n## Simple Iterators\n\nA common use-case for block helpers is using them to define custom iterators. In fact, all Handlebars built-in helpers are defined as regular Handlebars block helpers. Let's take a look at how the built-in `each` helper works.\n\n``` html\n<div class=\"entry\">\n  <h1>{{title}}</h1>\n  {{#with story}}\n    <div class=\"intro\">{{{intro}}}</div>\n    <div class=\"body\">{{{body}}}</div>\n  {{/with}}\n</div>\n<div class=\"comments\">\n  {{#each comments}}\n    <div class=\"comment\">\n      <h2>{{subject}}</h2>\n      {{{body}}}\n    </div>\n  {{/each}}\n</div>\n```\n\nIn this case, we want to invoke the block passed to `each` once for each element in the comments Array.\n\n``` html\nHandlebars.registerHelper('each', function(context, options) {\n  var ret = \"\";\n\n  for(var i=0, j=context.length; i<j; i++) {\n    ret = ret + options.fn(context[i]);\n  }\n\n  return ret;\n});\n```\n\nIn this case, we iterate over the items in the passed parameter, invoking the block once with each item. As we iterate, we build up a String result, and then return it.\n\nThis pattern can be used to implement more advanced iterators. For instance, let's create an iterator that creates a `<ul>` wrapper, and wraps each resulting element in an `<li>`.\n\n``` html\n{{#list nav}}\n  <a href=\"{{url}}\">{{title}}</a>\n{{/list}}\n```\n\nYou would evaluate this template using something like this as the context:\n\n``` html\n{\n  nav: [\n    { url: \"http://www.yehudakatz.com\", title: \"Katz Got Your Tongue\" },\n    { url: \"http://www.sproutcore.com/block\", title: \"SproutCore Blog\" },\n  ]\n}\n```\n\nThe helper is similar to the original `each` helper.\n\n``` html\nHandlebars.registerHelper('list', function(context, options) {\n  var ret = \"<ul>\";\n\n  for(var i=0, j=context.length; i<j; i++) {\n    ret = ret + \"<li>\" + options.fn(context[i]) + \"</li>\";\n  }\n\n  return ret + \"</ul>\";\n});\n```\n\nUsing a library like underscore.js or SproutCore's runtime library could make this a bit prettier. For example, here's what it might look like using SproutCore's runtime library:\n\n``` html\nHandlebars.registerHelper('list', function(context, options) {\n  return \"<ul>\" + context.map(function(item) {\n    return \"<li>\" + options.fn(item) + \"</li>\";\n  }).join(\"\\n\") + \"</ul>\";\n});\n```\n\n## Conditionals\n\nAnother common use-case for block helpers is to evaluate conditional statements. As with the iterators, Handlebars' built-in `if` and `unless` control structures are implemented as regular Handlebars helpers.\n\n``` html\n{{#if isActive}}\n  <img src=\"star.gif\" alt=\"Active\">\n{{/if}}\n```\n\nControl structures typically do not change the current context, instead they decide whether or not to invoke the block based upon some variable.\n\n``` html\nHandlebars.registerHelper('if', function(conditional, options) {\n  if(conditional) {\n    return options.fn(this);\n  }\n});\n```\n\nWhen writing a conditional, you will often want to make it possible for templates to provide a block of HTML that your helper should insert if the conditional evaluates to false. Handlebars handles this problem by providing generic `else` functionality to block helpers.\n\n``` html\n{{#if isActive}}\n  <img src=\"star.gif\" alt=\"Active\">\n{{else}}\n  <img src=\"cry.gif\" alt=\"Inactive\">\n{{/if}}\n```\n\nHandlebars provides the block for the `else` fragment as `options.inverse`. You do not need to check for the existence of the `else` fragment: Handlebars will detect it automatically and register a \"noop\" function.\n\n``` html\nHandlebars.registerHelper('if', function(conditional, options) {\n  if(conditional) {\n    return options.fn(this);\n  } else {\n    return options.inverse(this);\n  }\n});\n```\n\nHandlebars provides additional metadata to block helpers by attaching them as properties of the options hash. Keep reading for more examples.\n\nConditionals may also be chained by including the subsequent helper call within the else mustache.\n\n``` html\n{{#if isActive}}\n  <img src=\"star.gif\" alt=\"Active\">\n{{else if isInactive}}\n  <img src=\"cry.gif\" alt=\"Inactive\">\n{{/if}}\n```\n\nIt is not necessary to use the same helper in subsequent calls, the `unless` helper could be used in the else portion as with any other helper. When the helper values are different, the closing mustache should match the opening helper name.\n\n## Hash Arguments\n\nLike regular helpers, block helpers can accept an optional Hash as its final argument. Let's revisit the `list` helper and make it possible for us to add any number of optional attributes to the `<ul>` element we will create.\n\n``` html\n{{#list nav id=\"nav-bar\" class=\"top\"}}\n  <a href=\"{{url}}\">{{title}}</a>\n{{/list}}\n```\n\nHandlebars provides the final hash as `options.hash`. This makes it easier to accept a variable number of parameters, while also accepting an optional Hash. If the template provides no hash arguments, Handlebars will automatically pass an empty object (`{}`), so you don't need to check for the existence of hash arguments.\n\n``` html\nHandlebars.registerHelper('list', function(context, options) {\n  var attrs = Object.keys(options.hash).map(function(key) {\n    return key + '=\"' + options.hash[key] + '\"';\n  }).join(\" \");\n\n  return \"<ul \" + attrs + \">\" + context.map(function(item) {\n    return \"<li>\" + options.fn(item) + \"</li>\";\n  }).join(\"\\n\") + \"</ul>\";\n});\n```\n\nHash arguments provide a powerful way to offer a number of optional parameters to a block helper without the complexity caused by positional arguments.\n\nBlock helpers can also inject private variables into their child templates. This can be useful to add extra information that is not in the original context data.\n\nFor example, when iterating over a list, you may provide the current index as a private variable.\n\n``` html\n{{#list array}}\n  {{@index}}. {{title}}\n{{/list}}\n```\n\n``` html\nHandlebars.registerHelper('list', function(context, options) {\n  var out = \"<ul>\", data;\n\n  if (options.data) {\n    data = Handlebars.createFrame(options.data);\n  }\n\n  for (var i=0; i<context.length; i++) {\n    if (data) {\n      data.index = i;\n    }\n\n    out += \"<li>\" + options.fn(context[i], { data: data }) + \"</li>\";\n  }\n\n  out += \"</ul>\";\n  return out;\n});\n```\n\nPrivate variables provided via the `data` option are available in all descendent scopes.\n\nPrivate variables defined in parent scopes may be accessed via pathed queries. To access the `index` field of the parent iterator, `@../index` may be used.\n\nMake sure you create a new data frame in each helper that assigns its own data. Otherwise, downstream helpers might unexpectedly mutate upstream variables.\n\nAlso ensure that the `data` field is defined prior to attempting to interact with an existing data object. The private variable behavior is condtionally compiled and some templates might not create this field.\n\n## Block Parameters\n\nNew in Handlebars 3.0, it's possible to receive named parameters from supporting helpers.\n\n``` html\n{{#each users as |user userId|}}\n  Id: {{userId}} Name: {{user.name}}\n{{/each}}\n```\n\nIn this particular example, `user` will have the same value as the current context and `userId` will have the index value for the iteration.\n\nThis allows for nested helpers to avoid name conflicts that can occur with private variables.\n\n``` html\n{{#each users as |user userId|}}\n  {{#each user.book as |book bookId|}}\n    User Id: {{userId}} Book Id: {{bookId}}\n  {{/each}}\n{{/each}}\n```\n\nA number of [builtin helpers](builtin_helpers) support block parameters and any custom helper may provide them through the `blockParams` options field.\n\n``` html\nHandlebars.registerHelper('block-params', function() {\n  var args = [],\n      options = arguments[arguments.length - 1];\n  for (var i = 0; i < arguments.length - 1; i++) {\n    args.push(arguments[i]);\n  }\n\n  return options.fn(this, {data: options.data, blockParams: args});\n});\n```\n\n``` html\n{{#block-params 1 2 3 as |foo bar baz|}}\n  {{foo}} {{bar}} {{baz}}\n{{/block-params}}\n```\n\nImplements a helper that allows for named variable declarations within a given block. This example would output `1 2 3` on render.\n\nHelpers can determine the number of block parameters referenced by the template via the `options.fn.blockParams` field, which is an integer count. This value represents the number of block parameters that could be referenced by the child template. Parameters beyond this count will never be referenced and can safely be omitted by the helper if desired. This is optional and any additional parameters passed to the template will be silently ignored.\n\n## Raw Blocks\n\nRaw blocks are available for templates needing to handle unprocessed mustache blocks.\n\n``` html\n{{{{raw-helper}}}}\n  {{bar}}\n{{{{/raw-helper}}}}\n```\n\nwill execute the helper `raw-helper` without interpreting the content.\n\n``` html\nHandlebars.registerHelper('raw-helper', function(options) {\n  return options.fn();\n});\n```\n\nwill render\n\n``` html\n{{bar}}\n```\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/block_helpers.html](https://handlebarsjs.com/block_helpers.html)"
- name: Block Parameters
  id: block_helpers#block-params
  summary: New in Handlebars 3.0, it's possible to receive named parameters from supporting helpers
  belongs_to: Block Helpers
  description: |-
    ## Block Parameters

    New in Handlebars 3.0, it's possible to receive named parameters from supporting helpers.

    ``` html
    {{#each users as |user userId|}}
      Id: {{userId}} Name: {{user.name}}
    {{/each}}
    ```

    In this particular example, `user` will have the same value as the current context and `userId` will have the index value for the iteration.

    This allows for nested helpers to avoid name conflicts that can occur with private variables.

    ``` html
    {{#each users as |user userId|}}
      {{#each user.book as |book bookId|}}
        User Id: {{userId}} Book Id: {{bookId}}
      {{/each}}
    {{/each}}
    ```

    A number of [builtin helpers](builtin_helpers) support block parameters and any custom helper may provide them through the `blockParams` options field.

    ``` html
    Handlebars.registerHelper('block-params', function() {
      var args = [],
          options = arguments[arguments.length - 1];
      for (var i = 0; i < arguments.length - 1; i++) {
        args.push(arguments[i]);
      }

      return options.fn(this, {data: options.data, blockParams: args});
    });
    ```

    ``` html
    {{#block-params 1 2 3 as |foo bar baz|}}
      {{foo}} {{bar}} {{baz}}
    {{/block-params}}
    ```

    Implements a helper that allows for named variable declarations within a given block. This example would output `1 2 3` on render.

    Helpers can determine the number of block parameters referenced by the template via the `options.fn.blockParams` field, which is an integer count. This value represents the number of block parameters that could be referenced by the child template. Parameters beyond this count will never be referenced and can safely be omitted by the helper if desired. This is optional and any additional parameters passed to the template will be silently ignored.
- name: Bower
  id: installation#bower
  summary: Handlebars maintains a bower component as well that is available for bower users
  belongs_to: Installation
  description: |-
    ## Bower

    Handlebars maintains a [bower component](https://github.com/components/handlebars.js) as well that is available for [bower](http://bower.io/) users. This can be installed in a project like so.

    ``` html
    bower install --save handlebars
    ```

    The default bower library is UMD-style so this should work properly with global, CJS, and AMD module systems. `handlebars.js` and `handlebars.runtime.js` are the primary source files but a number of other options exist in this component. We recommend looking at them and selecting the best one for your needs.

    This component should also work with other packagers such as [component](https://github.com/componentjs/component) but these have not been tested as throughly.
- name: Built-In Helpers
  id: index#builtins
  summary: Handlebars offers a variety of built-in helpers such as the if conditional and each iterator
  description: |-
    ## Built-In Helpers

    Handlebars offers a variety of built-in helpers such as the `if` conditional and `each` iterator.

    [Learn More: Built-In Helpers](builtin_helpers)
- name: Builtin Helpers
  id: builtin_helpers
  summary: You can use the if helper to conditionally render a block
  description: "# Builtin Helpers\n\n## The `if` block helper\n\nYou can use the `if` helper to conditionally render a block. If its argument returns `false`, `undefined`, `null`, `\"\"`, `0`, or `[]`, Handlebars will not render the block.\n\n``` html\n<div class=\"entry\">\n  {{#if author}}\n    <h1>{{firstName}} {{lastName}}</h1>\n  {{/if}}\n</div>\n```\n\nwhen used with an empty (`{}`) context, `author` will be `undefined`, resulting in:\n\n``` html\n<div class=\"entry\">\n</div>\n```\n\nWhen using a block expression, you can specify a template section to run if the expression returns a falsy value. The section, marked by `{{else}}` is called an \"else section\".\n\n``` html\n<div class=\"entry\">\n  {{#if author}}\n    <h1>{{firstName}} {{lastName}}</h1>\n  {{else}}\n    <h1>Unknown Author</h1>\n  {{/if}}\n</div>\n```\n\n## The `unless` block helper\n\nYou can use the `unless` helper as the inverse of the `if` helper. Its block will be rendered if the expression returns a falsy value.\n\n``` html\n<div class=\"entry\">\n  {{#unless license}}\n  <h3 class=\"warning\">WARNING: This entry does not have a license!</h3>\n  {{/unless}}\n</div>\n```\n\nIf looking up `license` under the current context returns a falsy value, Handlebars will render the warning. Otherwise, it will render nothing.\n\n## The `each` block helper\n\nYou can iterate over a list using the built-in `each` helper. Inside the block, you can use `this` to reference the element being iterated over.\n\n``` html\n<ul class=\"people_list\">\n  {{#each people}}\n    <li>{{this}}</li>\n  {{/each}}\n</ul>\n```\n\nwhen used with this context:\n\n``` html\n{\n  people: [\n    \"Yehuda Katz\",\n    \"Alan Johnson\",\n    \"Charles Jolley\"\n  ]\n}\n```\n\nwill result in:\n\n``` html\n<ul class=\"people_list\">\n  <li>Yehuda Katz</li>\n  <li>Alan Johnson</li>\n  <li>Charles Jolley</li>\n</ul>\n```\n\nYou can use the `this` expression in any context to reference the current context.\n\nYou can optionally provide an `{{else}}` section which will display only when the list is empty.\n\n``` html\n{{#each paragraphs}}\n  <p>{{this}}</p>\n{{else}}\n  <p class=\"empty\">No content</p>\n{{/each}}\n```\n\nWhen looping through items in `each`, you can optionally reference the current loop index via `{{@index}}`\n\n``` html\n{{#each array}}\n  {{@index}}: {{this}}\n{{/each}}\n```\n\nAdditionally for object iteration, `{{@key}}` references the current key name:\n\n``` html\n{{#each object}}\n  {{@key}}: {{this}}\n{{/each}}\n```\n\nThe first and last steps of iteration are noted via the `@first` and `@last` variables when iterating over an array. When iterating over an object only the `@first` is available.\n\nNested `each` blocks may access the iteration variables via depth based paths. To access the parent index, for example, `{{@../index}}` can be used.\n\nThe `each` helper also supports [block parameters](block_helpers#block-params), allowing for named references anywhere in the block.\n\n``` html\n{{#each array as |value key|}}\n  {{#each child as |childValue childKey|}}\n    {{key}} - {{childKey}}. {{childValue}}\n  {{/each}}\n{{/each}}\n```\n\nWill create a `key` and `value` variable that children may access without the need for depthed variable references. In the example above, `{{key}}` is identical to `{{@../key}}` but in many cases is more readable.\n\n## The `with` Block Helper\n\nNormally, Handlebars templates are evaluated against the context passed into the compiled method.\n\n``` html\nvar source   = \"<p>{{lastName}}, {{firstName}}</p>\";\nvar template = Handlebars.compile(source);\ntemplate({firstName: \"Alan\", lastName: \"Johnson\"});\n```\n\nresults in\n\n``` html\n<p>Johnson, Alan</p>\n```\n\nYou can shift the context for a section of a template by using the built-in `with` block helper.\n\n``` html\n<div class=\"entry\">\n  <h1>{{title}}</h1>\n\n  {{#with author}}\n  <h2>By {{firstName}} {{lastName}}</h2>\n  {{/with}}\n</div>\n```\n\nwhen used with this context:\n\n``` html\n{\n  title: \"My first post!\",\n  author: {\n    firstName: \"Charles\",\n    lastName: \"Jolley\"\n  }\n}\n```\n\nwill result in:\n\n``` html\n<div class=\"entry\">\n  <h1>My first post!</h1>\n\n  <h2>By Charles Jolley</h2>\n</div>\n```\n\n`with` can also be used with block parameters to define known references in the current block. The example above can be converted to\n\n``` html\n<div class=\"entry\">\n  <h1>{{title}}</h1>\n\n  {{#with author as |myAuthor|}}\n  <h2>By {{myAuthor.firstName}} {{myAuthor.lastName}}</h2>\n  {{/with}}\n</div>\n```\n\nWhich allows for complex templates to potentially provide clearer code than `../` depthed references allow for.\n\nYou can optionally provide an `{{else}}` section which will display only when the passed value is empty.\n\n``` html\n{{#with author}}\n  <p>{{name}}</p>\n{{else}}\n  <p class=\"empty\">No content</p>\n{{/with}}\n```\n\n## The `lookup` helper\n\nThe `lookup` helper allows for dynamic parameter resolution using Handlebars variables. This is useful for resolving values for array indexes.\n\n``` html\n{{#each bar}}\n  {{lookup ../foo @index}}\n{{/each}}\n```\n\n## The `log` block helper\n\nThe `log` helper allows for logging of context state while executing a template.\n\n``` html\n{{log \"Look at me!\"}}\n```\n\nDelegates to `Handlebars.logger.log` which may be overriden to perform custom logging.\n\nAny number of arguments may be passed to this method and all will be forwarded to the logger.\n\n``` html\n{{log \"This is logged\" foo \"And so is this\"}}\n```\n\nThe log level may be set using the `level` hash parameter. Supported values are `debug`, `info`, `warn`, and `error`. When omitted, `info` is the default value,\n\n``` html\n{{log \"Log!\" level=\"error\"}}\n```\n\nLogging is conditional based on the level and to value set in `Handlebars.logger.level`, which defaults to `info`. All log statements at or above the current level will be output.\n\n## The `blockHelperMissing` helper\n\nImplicitly called when a helper can not be directly resolved in the environment's helpers hash.\n\n``` html\n{{#foo}}{{/foo}}\n```\n\nwill call this helper with the resolved value of `foo` on the current context and the `options.name` field set to `\"foo\"`. For instances where there is no registered helper named `foo`.\n\nThis may be overriden by users that wish to change the behavior of block evaluation. For example\n\n``` html\nHandlebars.registerHelper('blockHelperMissing', function(context, options) {\n  throw new Handlebars.Exception('Only if or each is allowed');\n});\n```\n\ncould be used to prevent the use of mustache-style block evaluation in favor of the more efficent `if` and `each` helpers.\n\n## The `helperMissing` helper\n\nInternal helper that is called when a potential helper expression was not found in either the environment helpers or the current context. For cases where both are run, this is run prior to the `blockHelperMissing` helper.\n\n``` html\n{{foo}}\n{{foo bar}}\n{{#foo}}{{/foo}}\n```\n\nWill each call this helper, passing any arguments that would have been otherwise passed to a helper of the same name. This helper is not called when using `knownHelpersOnly` mode.\n\nThis may be overriden by applications. To force the existence of the field, the following may be used:\n\n``` html\nHandlebars.registerHelper('helperMissing', function(/* [args, ] options */) {\n  var options = arguments[arguments.length - 1];\n  throw new Handlebars.Exception('Unknown field: ' + options.name);\n});\n```\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/builtin_helpers.html](https://handlebarsjs.com/builtin_helpers.html)"
- name: CDNs
  id: installation#cdn
  summary: Handlebars is hosted on a number of free CDNs as well
  belongs_to: Installation
  description: "## CDNs\n\nHandlebars is hosted on a number of free CDNs as well.\n\n- [cdnjs](https://cdnjs.com/libraries/handlebars.js)\n- [jsDelivr](http://www.jsdelivr.com/#!handlebarsjs). Advanced usage, such as [version aliasing & concocting](https://github.com/jsdelivr/jsdelivr#usage), is available.\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/installation.html](https://handlebarsjs.com/installation.html)"
- name: Conditionals
  id: block_helpers#conditionals
  summary: Another common use-case for block helpers is to evaluate conditional statements
  belongs_to: Block Helpers
  description: |-
    ## Conditionals

    Another common use-case for block helpers is to evaluate conditional statements. As with the iterators, Handlebars' built-in `if` and `unless` control structures are implemented as regular Handlebars helpers.

    ``` html
    {{#if isActive}}
      <img src="star.gif" alt="Active">
    {{/if}}
    ```

    Control structures typically do not change the current context, instead they decide whether or not to invoke the block based upon some variable.

    ``` html
    Handlebars.registerHelper('if', function(conditional, options) {
      if(conditional) {
        return options.fn(this);
      }
    });
    ```

    When writing a conditional, you will often want to make it possible for templates to provide a block of HTML that your helper should insert if the conditional evaluates to false. Handlebars handles this problem by providing generic `else` functionality to block helpers.

    ``` html
    {{#if isActive}}
      <img src="star.gif" alt="Active">
    {{else}}
      <img src="cry.gif" alt="Inactive">
    {{/if}}
    ```

    Handlebars provides the block for the `else` fragment as `options.inverse`. You do not need to check for the existence of the `else` fragment: Handlebars will detect it automatically and register a "noop" function.

    ``` html
    Handlebars.registerHelper('if', function(conditional, options) {
      if(conditional) {
        return options.fn(this);
      } else {
        return options.inverse(this);
      }
    });
    ```

    Handlebars provides additional metadata to block helpers by attaching them as properties of the options hash. Keep reading for more examples.

    Conditionals may also be chained by including the subsequent helper call within the else mustache.

    ``` html
    {{#if isActive}}
      <img src="star.gif" alt="Active">
    {{else if isInactive}}
      <img src="cry.gif" alt="Inactive">
    {{/if}}
    ```

    It is not necessary to use the same helper in subsequent calls, the `unless` helper could be used in the else portion as with any other helper. When the helper values are different, the closing mustache should match the opening helper name.
- name: Dynamic Partials
  id: partials#dynamic-partials
  summary: It's possible to dynamically select the partial to be executed by using sub expression syntax
  belongs_to: Partials
  description: |-
    ## Dynamic Partials

    It's possible to dynamically select the partial to be executed by using sub expression syntax.

    ``` html
    {{> (whichPartial) }}
    ```

    Will evaluate `whichPartial` and then render the partial whose name is returned by this function.

    Subexpressions do not resolve variables so `whichPartial` must be a function. If a simple variable has the partial name, it's possible to resolve it via the `lookup` helper.

    ``` html
    {{> (lookup . 'myVariable') }}
    ```
- name: Escaping
  id: expressions#escaping
  summary: Handlebars content may be escaped in one of two ways, inline escapes or raw block helpers
  belongs_to: Expressions
  description: "## Escaping\n\nHandlebars content may be escaped in one of two ways, inline escapes or raw block helpers. Inline escapes created by prefixing a mustache block with `\\`. Raw blocks are created using `{{{{` mustache braces.\n\n``` html\n\\{{escaped}}\n{{{{raw}}}}\n  {{escaped}}\n{{{{/raw}}}}\n```\n\nRaw blocks operate in the same manner as other [block helpers](block_helpers) with the distinction of the child content is treated as a literal string.\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/expressions.html](https://handlebarsjs.com/expressions.html)"
- name: Execution
  id: execution
  summary: Get the HTML result of evaluating a Handlebars template by executing the template with a context
  description: "# Execution\n\nGet the HTML result of evaluating a Handlebars template by executing the template with a context.\n\n``` html\nvar context = {title: \"My New Post\", body: \"This is my first post!\"}\nvar html    = template(context);\n```\n\nresults in\n\n``` html\n<div class=\"entry\">\n  <h1>My New Post</h1>\n  <div class=\"body\">\n    This is my first post!\n  </div>\n</div>\n```\n\n## Options\n\nThe template function can be passed an options object as the second parameter which allows for customization:\n\n- `data` Pass in an object to define custom `@variable` private variables.\n- `helpers` Pass in to provide custom helpers in addition to the globally defined helpers.  \n  Values defined in this object will replace any values defined in the global object for the duration of the template execution.\n- `partials` Pass in to provide custom partials in addition to the globally defined partials.  \n  Values defined in this object will replace any values defined in the global object for the duration of the template execution.\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/execution.html](https://handlebarsjs.com/execution.html)"
- name: Expressions
  id: expressions
  summary: Handlebars expressions are the basic unit of a Handlebars template
  description: "# Expressions\n\nHandlebars expressions are the basic unit of a Handlebars template. You can use them alone in a `{{mustache}}`, pass them to a Handlebars helper, or use them as values in hash arguments.\n\n## Basic Usage\n\nThe simplest Handlebars expression is a simple identifier:\n\n``` html\n<h1>{{title}}</h1>\n```\n\nThis expression means \"look up the `title` property in the current context\". Block helpers may manipulate the current context, but they do not change the basic meaning of an expression.\n\nActually, it means \"look for a helper named `title`, then do the above\", but we'll get to that soon enough.\n\nHandlebars expressions can also be dot-separated paths.\n\n``` html\n<h1>{{article.title}}</h1>\n```\n\nThis expression means \"look up the `article` property in the current context. Then look up the `title` property in the result\".\n\nHandlebars also supports a deprecated `/` syntax, so you could write the above template as:\n\n``` html\n<h1>{{article/title}}</h1>\n```\n\nIdentifiers may be any unicode character except for the following:\n\nWhitespace `!` `\"` `#` `%` `&` `'` `(` `)` `*` `+` `,` `.` `/` `;` `<` `=` `>` `@` `[` `\\` `]` `^` `` ` `` `{` `|` `}` `~`\n\nTo reference a property that is not a valid identifier, you can use segment-literal notation, `[`:\n\n``` html\n{{#each articles.[10].[#comments]}}\n  <h1>{{subject}}</h1>\n  <div>\n    {{body}}\n  </div>\n{{/each}}\n```\n\nIn the example above, the template will treat the `each` parameter roughly equivalent to this javascript: `articles[10]['#comments']`\n\nYou may not include a closing `]` in a path-literal, but all other characters are fair game.\n\nJavaScript-style strings, `\"` and `'`, may also be used vs. `[` pairs.\n\nHandlebars HTML-escapes values returned by a `{{expression}}`. If you don't want Handlebars to escape a value, use the \"triple-stash\", `{{{`\n\n``` html\n{{{foo}}}\n```\n\n## Helpers\n\nA Handlebars helper call is a simple identifier, followed by zero or more parameters (separated by space). Each parameter is a Handlebars expression.\n\n``` html\n{{{link story}}}\n```\n\nIn this case, `link` is the name of a Handlebars helper, and story is a parameter to the helper. Handlebars evaluates parameters in exactly the same way described above in \"Basic Usage\".\n\n``` html\nHandlebars.registerHelper('link', function(object) {\n  var url = Handlebars.escapeExpression(object.url),\n      text = Handlebars.escapeExpression(object.text);\n\n  return new Handlebars.SafeString(\n    \"<a href='\" + url + \"'>\" + text + \"</a>\"\n  );\n});\n```\n\nWhen returning HTML from a helper, you should return a Handlebars SafeString if you don't want it to be escaped by default. When using SafeString all unknown or unsafe data should be manually escaped with the `escapeExpression` method.\n\nYou can also pass a simple String, number, or boolean as a parameter to Handlebars helpers.\n\n``` html\n{{{link \"See more...\" story.url}}}\n```\n\nIn this case, Handlebars will pass the link helper two parameters: the String `\"See more...\"` and the result of evaluating `story.url` in the current context.\n\n``` html\nHandlebars.registerHelper('link', function(text, url) {\n  url = Handlebars.escapeExpression(url);\n  text = Handlebars.escapeExpression(text);\n\n  return new Handlebars.SafeString(\n    \"<a href='\" + url + \"'>\" + text + \"</a>\"\n  );\n});\n```\n\nYou could use the exact same helper with dynamic text based on the value of `story.text`:\n\n``` html\n{{{link story.text story.url}}}\n```\n\nHandlebars helpers can also receive an optional sequence of key-value pairs as their final parameter (referred to as hash arguments in the documentation):\n\n``` html\n{{{link \"See more...\" href=story.url class=\"story\"}}}\n```\n\nThe keys in hash arguments must each be simple identifiers, and the values are Handlebars expressions. This means that values can be simple identifiers, paths, or Strings.\n\n``` html\nHandlebars.registerHelper('link', function(text, options) {\n  var attrs = [];\n\n  for (var prop in options.hash) {\n    attrs.push(\n        Handlebars.escapeExpression(prop) + '=\"'\n        + Handlebars.escapeExpression(options.hash[prop]) + '\"');\n  }\n\n  return new Handlebars.SafeString(\n    \"<a \" + attrs.join(\" \") + \">\" + Handlebars.escapeExpression(text) + \"</a>\"\n  );\n});\n```\n\nHandlebars provides additional metadata, such as Hash arguments, to helpers as a final parameter.\n\nHandlebars also offers a mechanism for invoking a helper with a block of the template. Block helpers can then invoke that block zero or more times with any context it chooses.\n\n[Learn More: Block Helpers](block_helpers)\n\n## Subexpressions\n\nHandlebars offers support for subexpressions, which allows you to invoke multiple helpers within a single mustache, and pass in the results of inner helper invocations as arguments to outer helpers. Subexpressions are delimited by parentheses.\n\n``` html\n{{outer-helper (inner-helper 'abc') 'def'}}\n```\n\nIn this case, `inner-helper` will get invoked with the string argument `'abc'`, and whatever the `inner-helper` function returns will get passed in as the first argument to `outer-helper` (and `'def'` will get passed in as the second argument to `outer-helper`).\n\n## Whitespace Control\n\nTemplate whitespace may be omitted from either side of any mustache statement by adding a `~` character by the braces. When applied all whitespace on that side will be removed up to the first handlebars expression or non-whitespace character on that side.\n\n``` html\n{{#each nav ~}}\n  <a href=\"{{url}}\">\n    {{~#if test}}\n      {{~title}}\n    {{~^~}}\n      Empty\n    {{~/if~}}\n  </a>\n{{~/each}}\n```\n\nwith this context:\n\n``` html\n{\n  nav: [\n    {url: 'foo', test: true, title: 'bar'},\n    {url: 'bar'}\n  ]\n}\n```\n\nresults in output sans newlines and formatting whitespace:\n\n``` html\n<a href=\"foo\">bar</a><a href=\"bar\">Empty</a>\n```\n\nThis expands the default behavior of stripping lines that are \"standalone\" helpers (only a block helper, comment, or partial and whitespace).\n\n``` html\n{{#each nav}}\n  <a href=\"{{url}}\">\n    {{#if test}}\n      {{title}}\n    {{^}}\n      Empty\n    {{/if}}\n  </a>\n{{~/each}}\n```\n\nwill render\n\n``` html\n<a href=\"foo\">\n    bar\n</a>\n<a href=\"bar\">\n    Empty\n</a>\n```\n\n## Escaping\n\nHandlebars content may be escaped in one of two ways, inline escapes or raw block helpers. Inline escapes created by prefixing a mustache block with `\\`. Raw blocks are created using `{{{{` mustache braces.\n\n``` html\n\\{{escaped}}\n{{{{raw}}}}\n  {{escaped}}\n{{{{/raw}}}}\n```\n\nRaw blocks operate in the same manner as other [block helpers](block_helpers) with the distinction of the child content is treated as a literal string.\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/expressions.html](https://handlebarsjs.com/expressions.html)"
- name: Getting Started
  id: index#getting-started
  summary: Handlebars templates look like regular HTML, with embedded handlebars expressions
  description: |-
    ## Getting Started

    ### Expressions

    Handlebars templates look like regular HTML, with embedded handlebars expressions.

    ``` html
    <div class="entry">
      <h1>{{title}}</h1>
      <div class="body">
        {{body}}
      </div>
    </div>
    ```

    A handlebars expression is a `{{`, some contents, followed by a `}}`

    [Learn More: Expressions](expressions)

    You can deliver a template to the browser by including it in a `<script>` tag.

    ``` html
    <script id="entry-template" type="text/x-handlebars-template">
      <div class="entry">
        <h1>{{title}}</h1>
        <div class="body">
          {{body}}
        </div>
      </div>
    </script>
    ```

    It is important that you put the template inside a `<script>` tag. Do not put it into the HTML directly or the HTML-parser might modify it (for example, if it [contains a table](https://html.spec.whatwg.org/multipage/parsing.html#unexpected-markup-in-tables)).

    ### Precompilation

    Compile a template in JavaScript by using `Handlebars.compile`

    ``` html
    var source   = document.getElementById("entry-template").innerHTML;
    var template = Handlebars.compile(source);
    ```

    Please note that this approach is not recommended for production applications. A better way is to precompile your templates. This will result in a smaller required runtime library and significant savings from not having to compile the template in the browser. This can be especially important when working with mobile devices.

    [Learn More: Precompilation](precompilation)

    ### Execution

    Get the HTML result of evaluating a Handlebars template by executing the template with a context.

    ``` html
    var context = {title: "My New Post", body: "This is my first post!"};
    var html    = template(context);
    ```

    results in

    ``` html
    <div class="entry">
      <h1>My New Post</h1>
      <div class="body">
        This is my first post!
      </div>
    </div>
    ```

    [Learn More: Execution](execution)
- name: Getting Started
  id: precompilation#getting-started
  summary: First, you will need to install node and npm
  belongs_to: Precompilation
  description: |-
    ## Getting Started

    First, you will need to install node and npm. On OS X:

    ``` html
    $ brew install node
    ```

    This assumes you already have Homebrew installed. If not, [install it](http://brew.sh/) first.

    Next, install the Handlebars npm package.

    ``` html
    $ npm install handlebars -g
    ```

    Using the `-g` flag installs the package globally, so it can be used in any project.

    Now, you're ready to use the precompiler:

    ``` html
    $ handlebars <input> -f <output>
    ```

    The compiler will insert templates in `Handlebars.templates`. If your input file is `person.handlebars`, the compiler will insert it at `Handlebars.templates.person`. This template will be a function that may be directly executed in the same manner as templates compiled locally. I.e.

    ``` html
    Handlebars.templates.person(context, options);
    ```

    If you're working with precompiled templates, you don't need to ship the compiler with your deployed application. Instead, you can use the smaller "runtime" build.

    ``` html
    <script src="/libs/handlebars.runtime.js"></script>
    ```

    In addition to reducing the download size, eliminating client-side compilation will significantly speed up boot time, as compilation is the most expensive part of Handlebars.
- name: Handlebars Paths
  id: index#paths
  summary: Handlebars supports simple paths, just like Mustache
  description: |-
    ## Handlebars Paths

    Handlebars supports simple paths, just like Mustache.

    ``` html
    <p>{{name}}</p>
    ```

    Handlebars also supports nested paths, making it possible to look up properties nested below the current context.

    ``` html
    <div class="entry">
      <h1>{{title}}</h1>
      <h2>By {{author.name}}</h2>

      <div class="body">
        {{body}}
      </div>
    </div>
    ```

    That template works with this context

    ``` html
    var context = {
      title: "My First Blog Post!",
      author: {
        id: 47,
        name: "Yehuda Katz"
      },
      body: "My first post. Wheeeee!"
    };
    ```

    This makes it possible to use Handlebars templates with more raw JSON objects.

    Nested handlebars paths can also include `../` segments, which evaluate their paths against a parent context.

    ``` html
    <h1>Comments</h1>

    <div id="comments">
      {{#each comments}}
      <h2><a href="/posts/{{../permalink}}#{{id}}">{{title}}</a></h2>
      <div>{{body}}</div>
      {{/each}}
    </div>
    ```

    Even though the link is printed while in the context of a comment, it can still go back to the main context (the post) to retrieve its permalink.

    The exact value that `../` will resolve to varies based on the helper that is calling the block. Using `../` is only necessary when context changes, so children of helpers such as `each` would require the use of `../` while children of helpers such as `if` do not.

    ``` html
    {{permalink}}
    {{#each comments}}
      {{../permalink}}

      {{#if title}}
        {{../permalink}}
      {{/if}}
    {{/each}}
    ```

    In this example all of the above reference the same `permalink` value even though they are located within different blocks. This behavior is new as of Handlebars 4, the [release notes](https://github.com/wycats/handlebars.js/blob/master/release-notes.md) discuss the prior behavior as well as the migration plan.

    Handlebars also allows for name conflict resolution between helpers and data fields via a `this` reference:

    ``` html
    <p>{{./name}} or {{this/name}} or {{this.name}}</p>
    ```

    Any of the above would cause the `name` field on the current context to be used rather than a helper of the same name.
- name: Handlebars.compile(template, options)
  id: reference#base-compile
  summary: Compiles a template so it can be executed immediately
  belongs_to: Reference
  description: |-
    ### `Handlebars.compile(template, options)`

    Compiles a template so it can be executed immediately.

    ``` html
    var template = Handlebars.compile('{{foo}}');
    template({});
    ```

    Supports a variety of options that alter how the template executes.

    - `data`: Set to false to disable `@data` tracking.
    - `compat`: Set to true to enable recursive field lookup.
    - `knownHelpers`: Hash containing list of helpers that are known to exist (truthy) at template execution time. Passing this allows the compiler to optimize a number of cases. Builtin helpers are automatically included in this list and may be omitted by setting that value to `false`.
    - `knownHelpersOnly`: Set to true to allow further optimzations based on the known helpers list.
    - `noEscape`: Set to true to not HTML escape any content.
    - `strict`: Run in strict mode. In this mode, templates will throw rather than silently ignore missing fields. This has the side effect of disabling inverse operations such as `{{^foo}}{{/foo}}` unless fields are explicitly included in the source object.
    - `assumeObjects`: Removes object existence checks when traversing paths. This is a subset of `strict` mode that generates optimized templates when the data inputs are known to be safe.
    - `preventIndent`: By default, an indented partial-call causes the output of the whole partial being indented by the same amount. This can lead to unexpected behavior when the partial writes `pre`-tags. Setting this option to `true` will disable the auto-indent feature.
    - `ignoreStandalone`: Disables standalone tag removal when set to `true`. When set, blocks and partials that are on their own line will not remove the whitespace on that line.
    - `explicitPartialContext`: Disables implicit context for partials. When enabled, partials that are not passed a context value will execute against an empty object.
- name: Handlebars.create()
  id: reference#base-create
  summary: Creates an isolated Handlebars environment
  belongs_to: Reference
  description: |-
    ### `Handlebars.create()`

    Creates an isolated Handlebars environment.

    ``` html
    var OtherHandlebars = Handlebars.create();
    ```

    Each environment has its own helpers and partials. This is only necessary for use cases that demand distinct helpers or partials. Most use cases can use the root `Handlebars` environment directly.

    Templates created for a given environment are bound to that environment. This means that templates that need to run in multiple environments will need to be recompiled or reconstructed via `Handlebars.template` for each environment. This applies to partials as well.
- name: Handlebars.createFrame(data)
  id: reference#base-createFrame
  summary: Used by block helpers to create child data objects
  belongs_to: Reference
  description: |-
    ### `Handlebars.createFrame(data)`

    Used by block helpers to create child data objects.

    ``` html
    if (options.data) {
      var data = Handlebars.createFrame(options.data);
      data.foo = 'bar';
      options.data = data;
    }
    ```

    Helpers that modify the data state should create a new frame when doing so, to isolate themselves and avoid corrupting the state of any parents. Generally, only one frame needs to be created per helper execution. For example, the `each` iterator creates a single frame which is reused for all child execution.
- name: Handlebars.escapeExpression(string)
  id: reference#base-escapeExpression
  summary: HTML escapes the passed string, making it safe for rendering as text within HTML content
  belongs_to: Reference
  description: |-
    ### `Handlebars.escapeExpression(string)`

    HTML escapes the passed string, making it safe for rendering as text within HTML content.

    ``` html
    Handlebars.Utils.escapeExpression(string)
    ```

    Replaces `&`, `<`, `>`, `"`, `'`, `` ` ``, `=` with the HTML entity equivalent value for string values. `SafeString` values are left untouched.

    The output of all expressions except for triple-braced expressions are passed through this method. Helpers should also use this method when returning HTML content via a `SafeString` instance, to prevent possible code injection.

    This method is aliased at `Handlebars.Utils.escapeExpression`.
- name: Handlebars.log(level, message)
  id: reference#base-log
  summary: Logger used by the log helper
  belongs_to: Reference
  description: |-
    ### `Handlebars.log(level, message)`

    Logger used by the `log` helper.

    May be overriden if desired.
- name: Handlebars.noConflict()
  id: reference#base-noConflict
  summary: Removes this Handlebars instance from the global namespace, restoring the global `Handlebars` variable to its previous value
  belongs_to: Reference
  description: |-
    ### `Handlebars.noConflict()`

    Removes this Handlebars instance from the global namespace, restoring the global \`Handlebars\` variable to its previous value.

    ``` html
    var myHandlebars = Handlebars.noConflict();
    ```

    This allows for distinct versions of the library to be used simultaneously without concern for version conflicts.
- name: Handlebars.precompile(template, options)
  id: reference#base-precompile
  summary: Precompiles a given template so it can be sent to the client and executed without compilation
  belongs_to: Reference
  description: |-
    ### `Handlebars.precompile(template, options)`

    Precompiles a given template so it can be sent to the client and executed without compilation.

    ``` html
    var templateSpec = Handlebars.precompile('{{foo}}');
    ```

    Supports all of the same options parameters as the `Handlebars.compile` method. Additionally may pass:

    - `srcName`: Passed to generate the source map for the input file. When run in this manner, the return structure is `{code, map}` with `code` containing the template definition and `map` containing the source map.
    - `destName`: Optional parameter used in conjunction with `srcName` to provide a destination file name when generating source maps.
- name: Handlebars.registerDecorator(name, helper)
  id: reference#base-registerDecorator
  summary: Registers a decorator accessible by any template in the environment
  belongs_to: Reference
  description: |-
    ### `Handlebars.registerDecorator(name, helper)`

    Registers a decorator accessible by any template in the environment.

    ``` html
    Handlebars.registerDecorator('foo', function() {
    });
    ```

    Also supports registering multiple decorators at once.

    ``` html
    Handlebars.registerDecorator({
      foo: function() {
      },
      bar: function() {
      }
    });
    ```
- name: Handlebars.registerHelper(name, helper)
  id: reference#base-registerHelper
  summary: Registers helpers accessible by any template in the environment
  belongs_to: Reference
  description: |-
    ### `Handlebars.registerHelper(name, helper)`

    Registers helpers accessible by any template in the environment.

    ``` html
    Handlebars.registerHelper('foo', function() {
    });
    ```

    Also supports registering multiple helpers at once.

    ``` html
    Handlebars.registerHelper({
      foo: function() {
      },
      bar: function() {
      }
    });
    ```
- name: Handlebars.registerPartial(name, partial)
  id: reference#base-registerPartial
  summary: Registers partials accessible by any template in the environment
  belongs_to: Reference
  description: |-
    ### `Handlebars.registerPartial(name, partial)`

    Registers partials accessible by any template in the environment.

    ``` html
    Handlebars.registerPartial('foo', partial);
    ```

    Also supports registering multiple partials at once.

    ``` html
    Handlebars.registerPartial({
      foo: partial,
      bar: partial
    });
    ```

    If loading the whole library, the partials may be string values which will be compiled on demand. If only loading the runtime, the partials must be a precompiled template that has been set up properly using the `Handlebars.template` method.
- name: Handlebars.SafeString(string)
  id: reference#base-SafeString
  summary: Prevents string from being escaped when the template is rendered
  belongs_to: Reference
  description: |-
    ### `Handlebars.SafeString(string)`

    Prevents `string` from being escaped when the template is rendered.

    ``` html
    new Handlebars.SafeString('<div>HTML Content!</div>')
    ```

    When constructing the string that will be marked as safe, any external content should be properly escaped using the `Handlebars.escapeExpression` method to avoid potential security concerns.
- name: Handlebars.template(templateSpec)
  id: reference#base-template
  summary: Sets up a template that was precompiled with Handlebars.precompile
  belongs_to: Reference
  description: |-
    ### `Handlebars.template(templateSpec)`

    Sets up a template that was precompiled with `Handlebars.precompile`.

    ``` html
    var template = Handlebars.template(templateSpec);
    template({});
    ```
- name: Handlebars.unregisterDecorator(name)
  id: reference#base-unregisterDecorator
  summary: Unregisters a previously registered decorator
  belongs_to: Reference
  description: |-
    ### `Handlebars.unregisterDecorator(name)`

    Unregisters a previously registered decorator.

    ``` html
    Handlebars.unregisterDecorator('foo');
    ```
- name: Handlebars.unregisterHelper(name)
  id: reference#base-unregisterHelper
  summary: Unregisters a previously registered helper
  belongs_to: Reference
  description: |-
    ### `Handlebars.unregisterHelper(name)`

    Unregisters a previously registered helper.

    ``` html
    Handlebars.unregisterHelper('foo');
    ```
- name: Handlebars.unregisterPartial(name)
  id: reference#base-unregisterPartial
  summary: Unregisters a previously registered partial
  belongs_to: Reference
  description: |-
    ### `Handlebars.unregisterPartial(name)`

    Unregisters a previously registered partial.

    ``` html
    Handlebars.unregisterPartial('foo');
    ```
- name: Handlebars.Utils.extend(obj, value)
  id: reference#utils-extend
  summary: Simple utility method to augment obj with all keys defined on value
  belongs_to: Reference
  description: |-
    ### `Handlebars.Utils.extend(obj, value)`

    Simple utility method to augment `obj` with all keys defined on `value`.

    ``` html
    Handlebars.Utils.extend(foo, {bar: true})
    ```

    Will set the key `bar` on object `foo` with the value `true`.
- name: Handlebars.Utils.isArray(obj)
  id: reference#utils-isArray
  summary: Determines if an object is an array
  belongs_to: Reference
  description: |-
    ### `Handlebars.Utils.isArray(obj)`

    Determines if an object is an array.
- name: Handlebars.Utils.isEmpty(value)
  id: reference#utils-isEmpty
  summary: Determines if a given value is empty
  belongs_to: Reference
  description: |-
    ### `Handlebars.Utils.isEmpty(value)`

    Determines if a given value is empty.

    ``` html
    Handlebars.Utils.isEmpty(value)
    ```

    This is used by the built-in `if` and `with` helpers to control their execution flow. The Handlebars definition of empty is any of:

    - Array with length 0
    - falsy values other than 0

    This is intended to match the [Mustache behavior](http://mustache.github.io/mustache.5.html#Sections).
- name: Handlebars.Utils.isFunction(obj)
  id: reference#utils-isFunction
  summary: Determines if an object is a function
  belongs_to: Reference
  description: |-
    ### `Handlebars.Utils.isFunction(obj)`

    Determines if an object is a function.
- name: Handlebars.Utils.toString(obj)
  id: reference#utils-toString
  summary: Generic toString method
  belongs_to: Reference
  description: |-
    ### `Handlebars.Utils.toString(obj)`

    Generic `toString` method.
- name: Hash Arguments
  id: block_helpers#hash-arguments
  summary: Like regular helpers, block helpers can accept an optional Hash as its final argument
  belongs_to: Block Helpers
  description: |-
    ## Hash Arguments

    Like regular helpers, block helpers can accept an optional Hash as its final argument. Let's revisit the `list` helper and make it possible for us to add any number of optional attributes to the `<ul>` element we will create.

    ``` html
    {{#list nav id="nav-bar" class="top"}}
      <a href="{{url}}">{{title}}</a>
    {{/list}}
    ```

    Handlebars provides the final hash as `options.hash`. This makes it easier to accept a variable number of parameters, while also accepting an optional Hash. If the template provides no hash arguments, Handlebars will automatically pass an empty object (`{}`), so you don't need to check for the existence of hash arguments.

    ``` html
    Handlebars.registerHelper('list', function(context, options) {
      var attrs = Object.keys(options.hash).map(function(key) {
        return key + '="' + options.hash[key] + '"';
      }).join(" ");

      return "<ul " + attrs + ">" + context.map(function(item) {
        return "<li>" + options.fn(item) + "</li>";
      }).join("\n") + "</ul>";
    });
    ```

    Hash arguments provide a powerful way to offer a number of optional parameters to a block helper without the complexity caused by positional arguments.

    Block helpers can also inject private variables into their child templates. This can be useful to add extra information that is not in the original context data.

    For example, when iterating over a list, you may provide the current index as a private variable.

    ``` html
    {{#list array}}
      {{@index}}. {{title}}
    {{/list}}
    ```

    ``` html
    Handlebars.registerHelper('list', function(context, options) {
      var out = "<ul>", data;

      if (options.data) {
        data = Handlebars.createFrame(options.data);
      }

      for (var i=0; i<context.length; i++) {
        if (data) {
          data.index = i;
        }

        out += "<li>" + options.fn(context[i], { data: data }) + "</li>";
      }

      out += "</ul>";
      return out;
    });
    ```

    Private variables provided via the `data` option are available in all descendent scopes.

    Private variables defined in parent scopes may be accessed via pathed queries. To access the `index` field of the parent iterator, `@../index` may be used.

    Make sure you create a new data frame in each helper that assigns its own data. Otherwise, downstream helpers might unexpectedly mutate upstream variables.

    Also ensure that the `data` field is defined prior to attempting to interact with an existing data object. The private variable behavior is condtionally compiled and some templates might not create this field.
- name: Helpers
  id: expressions#helpers
  summary: A Handlebars helper call is a simple identifier, followed by zero or more parameters (separated by space)
  belongs_to: Expressions
  description: |-
    ## Helpers

    A Handlebars helper call is a simple identifier, followed by zero or more parameters (separated by space). Each parameter is a Handlebars expression.

    ``` html
    {{{link story}}}
    ```

    In this case, `link` is the name of a Handlebars helper, and story is a parameter to the helper. Handlebars evaluates parameters in exactly the same way described above in "Basic Usage".

    ``` html
    Handlebars.registerHelper('link', function(object) {
      var url = Handlebars.escapeExpression(object.url),
          text = Handlebars.escapeExpression(object.text);

      return new Handlebars.SafeString(
        "<a href='" + url + "'>" + text + "</a>"
      );
    });
    ```

    When returning HTML from a helper, you should return a Handlebars SafeString if you don't want it to be escaped by default. When using SafeString all unknown or unsafe data should be manually escaped with the `escapeExpression` method.

    You can also pass a simple String, number, or boolean as a parameter to Handlebars helpers.

    ``` html
    {{{link "See more..." story.url}}}
    ```

    In this case, Handlebars will pass the link helper two parameters: the String `"See more..."` and the result of evaluating `story.url` in the current context.

    ``` html
    Handlebars.registerHelper('link', function(text, url) {
      url = Handlebars.escapeExpression(url);
      text = Handlebars.escapeExpression(text);

      return new Handlebars.SafeString(
        "<a href='" + url + "'>" + text + "</a>"
      );
    });
    ```

    You could use the exact same helper with dynamic text based on the value of `story.text`:

    ``` html
    {{{link story.text story.url}}}
    ```

    Handlebars helpers can also receive an optional sequence of key-value pairs as their final parameter (referred to as hash arguments in the documentation):

    ``` html
    {{{link "See more..." href=story.url class="story"}}}
    ```

    The keys in hash arguments must each be simple identifiers, and the values are Handlebars expressions. This means that values can be simple identifiers, paths, or Strings.

    ``` html
    Handlebars.registerHelper('link', function(text, options) {
      var attrs = [];

      for (var prop in options.hash) {
        attrs.push(
            Handlebars.escapeExpression(prop) + '="'
            + Handlebars.escapeExpression(options.hash[prop]) + '"');
      }

      return new Handlebars.SafeString(
        "<a " + attrs.join(" ") + ">" + Handlebars.escapeExpression(text) + "</a>"
      );
    });
    ```

    Handlebars provides additional metadata, such as Hash arguments, to helpers as a final parameter.

    Handlebars also offers a mechanism for invoking a helper with a block of the template. Block helpers can then invoke that block zero or more times with any context it chooses.

    [Learn More: Block Helpers](block_helpers)
- name: Helpers
  id: index#helpers
  summary: Handlebars helpers can be accessed from any context in a template
  description: |-
    ## Helpers

    Handlebars helpers can be accessed from any context in a template. You can register a helper with the `Handlebars.registerHelper` method.

    ``` html
    <div class="post">
      <h1>By {{fullName author}}</h1>
      <div class="body">{{body}}</div>

      <h1>Comments</h1>

      {{#each comments}}
      <h2>By {{fullName author}}</h2>
      <div class="body">{{body}}</div>
      {{/each}}
    </div>
    ```

    when using this context and helpers:

    ``` html
    var context = {
      author: {firstName: "Alan", lastName: "Johnson"},
      body: "I Love Handlebars",
      comments: [{
        author: {firstName: "Yehuda", lastName: "Katz"},
        body: "Me too!"
      }]
    };

    Handlebars.registerHelper('fullName', function(person) {
      return person.firstName + " " + person.lastName;
    });
    ```

    results in:

    ``` html
    <div class="post">
      <h1>By Alan Johnson</h1>
      <div class="body">I Love Handlebars</div>

      <h1>Comments</h1>

      <h2>By Yehuda Katz</h2>
      <div class="body">Me Too!</div>
    </div>
    ```

    Helpers receive the current context as the `this` context of the function.

    ``` html
    <ul>
      {{#each items}}
      <li>{{agree_button}}</li>
      {{/each}}
    </ul>
    ```

    when using this context and helpers:

    ``` html
    var context = {
      items: [
        {name: "Handlebars", emotion: "love"},
        {name: "Mustache", emotion: "enjoy"},
        {name: "Ember", emotion: "want to learn"}
      ]
    };

    Handlebars.registerHelper('agree_button', function() {
      var emotion = Handlebars.escapeExpression(this.emotion),
          name = Handlebars.escapeExpression(this.name);

      return new Handlebars.SafeString(
        "<button>I agree. I " + emotion + " " + name + "</button>"
      );
    });
    ```

    results in:

    ``` html
    <ul>
      <li><button>I agree. I love Handlebars</button></li>
      <li><button>I agree. I enjoy Mustache</button></li>
      <li><button>I agree. I want to learn Ember</button></li>
    </ul>
    ```

    If your helper returns HTML that you do not want escaped, make sure to return a new `Handlebars.SafeString`.
- name: HTML Escaping
  id: index#html-escaping
  summary: Handlebars will not escape a Handlebars.SafeString
  description: |-
    ## HTML Escaping

    Handlebars HTML-escapes values returned by a `{{expression}}`. If you don't want Handlebars to escape a value, use the "triple-stash", `{{{`.

    ``` html
    <div class="entry">
      <h1>{{title}}</h1>
      <div class="body">
        {{{body}}}
      </div>
    </div>
    ```

    with this context:

    ``` html
    {
      title: "All about <p> Tags",
      body: "<p>This is a post about &lt;p&gt; tags</p>"
    }
    ```

    results in:

    ``` html
    <div class="entry">
      <h1>All About &lt;p&gt; Tags</h1>
      <div class="body">
        <p>This is a post about &lt;p&gt; tags</p>
      </div>
    </div>
    ```

    Handlebars will not escape a `Handlebars.SafeString`. If you write a helper that generates its own HTML, you will usually want to return a `new Handlebars.SafeString(result)`. In such a circumstance, you will want to manually escape parameters.

    ``` html
    Handlebars.registerHelper('link', function(text, url) {
      text = Handlebars.Utils.escapeExpression(text);
      url  = Handlebars.Utils.escapeExpression(url);

      var result = '<a href="' + url + '">' + text + '</a>';

      return new Handlebars.SafeString(result);
    });
    ```

    This will escape the passed in parameters, but mark the response as safe, so Handlebars will not try to escape it even if the "triple-stash" is not used.
- name: Inline Partials
  id: partials#inline-partials
  summary: Templates may define block scoped partials via the inline decorator
  belongs_to: Partials
  description: "## Inline Partials\n\nTemplates may define block scoped partials via the `inline` decorator.\n\n``` html\n{{#*inline \"myPartial\"}}\n  My Content\n{{/inline}}\n{{#each children}}\n  {{> myPartial}}\n{{/each}}\n```\n\nWhich will render the `myPartial` partial for each child.\n\nEach inline partial is available to the current block and all children, including execution of other partials. This allows for layout templates and similar functionality:\n\n``` html\n{{#> layout}}\n  {{#*inline \"nav\"}}\n    My Nav\n  {{/inline}}\n  {{#*inline \"content\"}}\n    My Content\n  {{/inline}}\n{{/layout}}\n```\n\nWhere the `layout` partial may be:\n\n``` html\n<div class=\"nav\">\n  {{> nav}}\n</div>\n<div class=\"content\">\n  {{> content}}\n</div>\n```\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/partials.html](https://handlebarsjs.com/partials.html)"
- name: Installation
  id: installation
  summary: There are many different ways to install and use Handlebars, the following are some of the more popular
  description: "# Installation\n\nThere are many different ways to install and use Handlebars, the following are some of the more popular. Please send [pull requests](https://github.com/wycats/handlebars-site/blob/master/src/pages/installation.haml) if we are missing one!\n\nThe fastest route is to manually download the package and copy into your project but a number of other systems are available. [Download: 4.0.12](http://builds.handlebarsjs.com.s3.amazonaws.com/handlebars-v4.0.12.js) [Download: runtime-4.0.12](http://builds.handlebarsjs.com.s3.amazonaws.com/handlebars.runtime-v4.0.12.js)\n\n## NPM\n\nHandlebar's npm package includes both libraries suitable for CommonJS aware systems and built browser libraries that can be consumed direct browser mechanisms.\n\n``` html\nnpm install --save handlebars\n```\n\nRequire-aware systems such as Node and Webpack can then load via:\n\n``` html\nrequire('handlebars');\n```\n\nor for the runtime only:\n\n``` html\nrequire('handlebars/runtime');\n```\n\nThe browser builds are located in the `node_modules/handlebars/dist/` directory. Making these accessible to the browser will depend on what build system you are using but this may be as simple as copying the files to an acessible place.\n\nThis is the preferred method of installation when using the precompiler as it ensures that your precompiled templates always run against the same version of the runtime.\n\n## Bower\n\nHandlebars maintains a [bower component](https://github.com/components/handlebars.js) as well that is available for [bower](http://bower.io/) users. This can be installed in a project like so.\n\n``` html\nbower install --save handlebars\n```\n\nThe default bower library is UMD-style so this should work properly with global, CJS, and AMD module systems. `handlebars.js` and `handlebars.runtime.js` are the primary source files but a number of other options exist in this component. We recommend looking at them and selecting the best one for your needs.\n\nThis component should also work with other packagers such as [component](https://github.com/componentjs/component) but these have not been tested as throughly.\n\n## Manual Download\n\nAll of Handlebar's released versions and CI builds are available for download on S3 in our [builds page](http://builds.handlebarsjs.com.s3.amazonaws.com/bucket-listing.html?sort=lastmod&sortdir=desc).\n\nThe latest passing master build is named `handlebars-latest.js` and each passing SHA on master will create a `handlebars-gitSHA.js` file. While these all pass the CI, it's preferrable to use one of the tagged releases.\n\n\\*\\*Note\\*\\*: The S3 builds page is provided as a convenience for the community, but you should not use it for hosting Handlebars in production.\n\n## CDNs\n\nHandlebars is hosted on a number of free CDNs as well.\n\n- [cdnjs](https://cdnjs.com/libraries/handlebars.js)\n- [jsDelivr](http://www.jsdelivr.com/#!handlebarsjs). Advanced usage, such as [version aliasing & concocting](https://github.com/jsdelivr/jsdelivr#usage), is available.\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/installation.html](https://handlebarsjs.com/installation.html)"
- name: Literals
  id: index#literals
  summary: Helper calls may also have literal values passed to them either as parameter arguments or hash arguments
  description: |-
    ## Literals

    Helper calls may also have literal values passed to them either as parameter arguments or hash arguments. Supported literals include numbers, strings, `true`, `false`, `null` and `undefined`.

    ``` html
    {{agree_button "My Text" class="my-class" visible=true counter=4}}
    ```
- name: Manual Download
  id: installation#download
  summary: All of Handlebar's released versions and CI builds are available for download on S3 in our builds page
  belongs_to: Installation
  description: |-
    ## Manual Download

    All of Handlebar's released versions and CI builds are available for download on S3 in our [builds page](http://builds.handlebarsjs.com.s3.amazonaws.com/bucket-listing.html?sort=lastmod&sortdir=desc).

    The latest passing master build is named `handlebars-latest.js` and each passing SHA on master will create a `handlebars-gitSHA.js` file. While these all pass the CI, it's preferrable to use one of the tagged releases.

    \*\*Note\*\*: The S3 builds page is provided as a convenience for the community, but you should not use it for hosting Handlebars in production.
- name: NPM
  id: installation#npm
  summary: Handlebar's npm package includes both libraries suitable for CommonJS aware systems and built browser libraries that can be consumed direct browser mechanisms
  belongs_to: Installation
  description: |-
    ## NPM

    Handlebar's npm package includes both libraries suitable for CommonJS aware systems and built browser libraries that can be consumed direct browser mechanisms.

    ``` html
    npm install --save handlebars
    ```

    Require-aware systems such as Node and Webpack can then load via:

    ``` html
    require('handlebars');
    ```

    or for the runtime only:

    ``` html
    require('handlebars/runtime');
    ```

    The browser builds are located in the `node_modules/handlebars/dist/` directory. Making these accessible to the browser will depend on what build system you are using but this may be as simple as copying the files to an acessible place.

    This is the preferred method of installation when using the precompiler as it ensures that your precompiled templates always run against the same version of the runtime.
- name: Optimizations
  id: precompilation#optimizations
  summary: Because you are precompiling templates, you can also apply several optimization to the compiler
  belongs_to: Precompilation
  description: |-
    ## Optimizations

    Because you are precompiling templates, you can also apply several optimization to the compiler. The first allows you to specify a list of the known helpers to the compiler

    ``` html
    handlebars <input> -f <output> -k each -k if -k unless
    ```

    The Handlebars compiler will optimize accesses to those helpers for performance.

    When all helpers are known at compile time, the `--knownOnly` option provides the smallest generated code that also provides the fastest execution.
- name: Options
  id: execution#Options
  summary: © 2011–2017 by Yehuda Katz Licensed under the MIT License
  belongs_to: Execution
  description: "## Options\n\nThe template function can be passed an options object as the second parameter which allows for customization:\n\n- `data` Pass in an object to define custom `@variable` private variables.\n- `helpers` Pass in to provide custom helpers in addition to the globally defined helpers.  \n  Values defined in this object will replace any values defined in the global object for the duration of the template execution.\n- `partials` Pass in to provide custom partials in addition to the globally defined partials.  \n  Values defined in this object will replace any values defined in the global object for the duration of the template execution.\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/execution.html](https://handlebarsjs.com/execution.html)"
- name: Partial Blocks
  id: partials#partial-block
  summary: The normal behavior when attempting to render a partial that is not found is for the implementation to throw an error
  belongs_to: Partials
  description: |-
    ## Partial Blocks

    The normal behavior when attempting to render a partial that is not found is for the implementation to throw an error. If failover is desired instead, partials may be called using the block syntax.

    ``` html
    {{#> myPartial }}
      Failover content
    {{/myPartial}}
    ```

    Which will render `Failover content` if the `myPartial` partial is not registered.

    This block syntax may also be used to pass templates to the partial, which can be executed by the specially named partial, `@partial-block`. A template of

    ``` html
    {{#> layout }}
      My Content
    {{/layout}}
    ```

    with the `layout` partial containing

    ``` html
    Site Content
    {{> @partial-block }}
    ```

    Would render

    ``` html
    Site Content
    My Content
    ```

    When called in this manner, the block will execute under the context of the partial at the time of the call. Depthed paths and block parameters operate relative to the partial block rather than the partial template.

    ``` html
    {{#each children as |child|}}
      {{#> childEntry}}
        {{child.value}}
      {{/childEntry}}
    {{/each}}
    ```

    Will render `child.value` from this template, not the partial.
- name: Partial Contexts
  id: partials#partial-context
  summary: It's possible to execute partials on a custom context by passing in the context to the partial call
  belongs_to: Partials
  description: |-
    ## Partial Contexts

    It's possible to execute partials on a custom context by passing in the context to the partial call.

    ``` html
    {{> myPartial myOtherContext }}
    ```
- name: Partial Parameters
  id: partials#partial-parameters
  summary: Custom data can be passed to partials through hash parameters
  belongs_to: Partials
  description: |-
    ## Partial Parameters

    Custom data can be passed to partials through hash parameters.

    ``` html
    {{> myPartial parameter=value }}
    ```

    Will set `parameter` to `value` when the partial runs.

    This is particularly useful for exposing data from parent contexts to the partial:

    ``` html
    {{> myPartial name=../name }}
    ```
- name: Partials
  id: index#partials
  summary: Handlebars partials allow for code reuse by creating shared templates
  description: |-
    ## Partials

    Handlebars partials allow for code reuse by creating shared templates. Rendering this template

    ``` html
    <div class="post">
      {{> userMessage tagName="h1" }}

      <h1>Comments</h1>

      {{#each comments}}
        {{> userMessage tagName="h2" }}
      {{/each}}
    </div>
    ```

    when using this partial and context:

    ``` html
    Handlebars.registerPartial('userMessage',
        '<{{tagName}}>By {{author.firstName}} {{author.lastName}}</{{tagName}}>'
        + '<div class="body">{{body}}</div>');
    ```

    ``` html
    var context = {
      author: {firstName: "Alan", lastName: "Johnson"},
      body: "I Love Handlebars",
      comments: [{
        author: {firstName: "Yehuda", lastName: "Katz"},
        body: "Me too!"
      }]
    };
    ```

    results in:

    ``` html
    <div class="post">
      <h1>By Alan Johnson</h1>
      <div class="body">I Love Handlebars</div>

      <h1>Comments</h1>

      <h2>By Yehuda Katz</h2>
      <div class="body">Me Too!</div>
    </div>
    ```

    [Learn More: Partials](partials)
- name: Partials
  id: partials
  summary: Handlebars allows for template reuse through partials
  description: "# Partials\n\nHandlebars allows for template reuse through partials. Partials are normal Handlebars templates that may be called directly by other templates.\n\n## Basic Partials\n\nIn order to use a partial, it must be registered via `Handlebars.registerPartial`.\n\n``` html\nHandlebars.registerPartial('myPartial', '{{name}}')\n```\n\nThis call will register the `myPartial` partial. Partials may be precompiled and the precompiled template passed into the second parameter.\n\nCalling the partial is done through the partial call syntax:\n\n``` html\n{{> myPartial }}\n```\n\nWill render the partial named `myPartial`. When the partial executes, it will be run under the current execution context.\n\n## Dynamic Partials\n\nIt's possible to dynamically select the partial to be executed by using sub expression syntax.\n\n``` html\n{{> (whichPartial) }}\n```\n\nWill evaluate `whichPartial` and then render the partial whose name is returned by this function.\n\nSubexpressions do not resolve variables so `whichPartial` must be a function. If a simple variable has the partial name, it's possible to resolve it via the `lookup` helper.\n\n``` html\n{{> (lookup . 'myVariable') }}\n```\n\n## Partial Contexts\n\nIt's possible to execute partials on a custom context by passing in the context to the partial call.\n\n``` html\n{{> myPartial myOtherContext }}\n```\n\n## Partial Parameters\n\nCustom data can be passed to partials through hash parameters.\n\n``` html\n{{> myPartial parameter=value }}\n```\n\nWill set `parameter` to `value` when the partial runs.\n\nThis is particularly useful for exposing data from parent contexts to the partial:\n\n``` html\n{{> myPartial name=../name }}\n```\n\n## Partial Blocks\n\nThe normal behavior when attempting to render a partial that is not found is for the implementation to throw an error. If failover is desired instead, partials may be called using the block syntax.\n\n``` html\n{{#> myPartial }}\n  Failover content\n{{/myPartial}}\n```\n\nWhich will render `Failover content` if the `myPartial` partial is not registered.\n\nThis block syntax may also be used to pass templates to the partial, which can be executed by the specially named partial, `@partial-block`. A template of\n\n``` html\n{{#> layout }}\n  My Content\n{{/layout}}\n```\n\nwith the `layout` partial containing\n\n``` html\nSite Content\n{{> @partial-block }}\n```\n\nWould render\n\n``` html\nSite Content\nMy Content\n```\n\nWhen called in this manner, the block will execute under the context of the partial at the time of the call. Depthed paths and block parameters operate relative to the partial block rather than the partial template.\n\n``` html\n{{#each children as |child|}}\n  {{#> childEntry}}\n    {{child.value}}\n  {{/childEntry}}\n{{/each}}\n```\n\nWill render `child.value` from this template, not the partial.\n\n## Inline Partials\n\nTemplates may define block scoped partials via the `inline` decorator.\n\n``` html\n{{#*inline \"myPartial\"}}\n  My Content\n{{/inline}}\n{{#each children}}\n  {{> myPartial}}\n{{/each}}\n```\n\nWhich will render the `myPartial` partial for each child.\n\nEach inline partial is available to the current block and all children, including execution of other partials. This allows for layout templates and similar functionality:\n\n``` html\n{{#> layout}}\n  {{#*inline \"nav\"}}\n    My Nav\n  {{/inline}}\n  {{#*inline \"content\"}}\n    My Content\n  {{/inline}}\n{{/layout}}\n```\n\nWhere the `layout` partial may be:\n\n``` html\n<div class=\"nav\">\n  {{> nav}}\n</div>\n<div class=\"content\">\n  {{> content}}\n</div>\n```\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/partials.html](https://handlebarsjs.com/partials.html)"
- name: Precompilation
  id: precompilation
  summary: Using the Handlebars precompiler, you can precompile your Handlebars templates to save time on the client and reduce the required runtime size of the handlebars library
  description: "# Precompilation\n\nUsing the Handlebars precompiler, you can precompile your Handlebars templates to save time on the client and reduce the required runtime size of the handlebars library.\n\n## Getting Started\n\nFirst, you will need to install node and npm. On OS X:\n\n``` html\n$ brew install node\n```\n\nThis assumes you already have Homebrew installed. If not, [install it](http://brew.sh/) first.\n\nNext, install the Handlebars npm package.\n\n``` html\n$ npm install handlebars -g\n```\n\nUsing the `-g` flag installs the package globally, so it can be used in any project.\n\nNow, you're ready to use the precompiler:\n\n``` html\n$ handlebars <input> -f <output>\n```\n\nThe compiler will insert templates in `Handlebars.templates`. If your input file is `person.handlebars`, the compiler will insert it at `Handlebars.templates.person`. This template will be a function that may be directly executed in the same manner as templates compiled locally. I.e.\n\n``` html\nHandlebars.templates.person(context, options);\n```\n\nIf you're working with precompiled templates, you don't need to ship the compiler with your deployed application. Instead, you can use the smaller \"runtime\" build.\n\n``` html\n<script src=\"/libs/handlebars.runtime.js\"></script>\n```\n\nIn addition to reducing the download size, eliminating client-side compilation will significantly speed up boot time, as compilation is the most expensive part of Handlebars.\n\n## Optimizations\n\nBecause you are precompiling templates, you can also apply several optimization to the compiler. The first allows you to specify a list of the known helpers to the compiler\n\n``` html\nhandlebars <input> -f <output> -k each -k if -k unless\n```\n\nThe Handlebars compiler will optimize accesses to those helpers for performance.\n\nWhen all helpers are known at compile time, the `--knownOnly` option provides the smallest generated code that also provides the fastest execution.\n\n## Usage\n\n``` html\nUsage: node ./bin/handlebars [template|directory]...\n\nOptions:\n  -f, --output         Output File\n  --map                Source Map File                                                    [string]  [default: undefined]\n  -a, --amd            Exports amd style (require.js)\n  -c, --commonjs       Exports CommonJS style, path to Handlebars module                                 [default: null]\n  -h, --handlebarPath  Path to handlebar.js (only valid for amd-style)                                     [default: \"\"]\n  -k, --known          Known helpers\n  -o, --knownOnly      Known helpers only\n  -m, --min            Minimize output\n  -n, --namespace      Template namespace                                              [default: \"Handlebars.templates\"]\n  -s, --simple         Output template function only.\n  -N, --name           Name of passed string templates. Optional if running in a simple mode. Required when operating\n                       on multiple templates.\n  -i, --string         Generates a template from the passed CLI argument.\n                       \"-\" is treated as a special value and causes stdin to be read for the template value.\n  -r, --root           Template root. Base value that will be stripped from template names.\n  -p, --partial        Compiling a partial template\n  -d, --data           Include data when compiling\n  -e, --extension      Template extension.                                                       [default: \"handlebars\"]\n  -b, --bom            Removes the BOM (Byte Order Mark) from the beginning of the templates.\n  -v, --version        Prints the current compiler version\n  --help               Outputs this message\n```\n\nIf using the precompiler's normal mode, the resulting templates will be stored to the `Handlebars.templates` object using the relative template name sans the extension. These templates may be executed in the same manner as templates.\n\nIf using the simple mode the precompiler will generate a single javascript method. To execute this method it must be passed to the `Handlebars.template` method and the resulting object may be used as normal.\n\n## Precompiling Templates Inside NodeJS\n\nIf you wish to precompile templates from inside NodeJS--without invoking \"handlebars\" from the command line--that can be done with Handlebars.precompile. Transmit the string result of this function to your clients, and they can in turn parse that with Handlebars.template.\n\n``` html\nvar template = \"<div>whatever {{ name }}</div>\";\nvar Handlebars = require(\"handlebars\");\nvar compiled = Handlebars.precompile(template);\n```\n\nOn the client side you have Javascript along the lines of the following.\n\n``` html\nvar template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\n\nHandlebars.partials[\"test1\"] = template({\"compiler\":[7,\">= 4.0.0\"],\"main\":function(container,depth0,helpers,partials,data) {\n  var helper;\n\n  return \"<div>whatever \"\n  + container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === \"function\" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{\"name\":\"name\",\"hash\":{},\"data\":data}) : helper)))\n  + \"</div>\";\n},\"useData\":true});\n```\n\nFinally, you can reference these templates dynamically in your Javascript.\n\n``` html\nvar result = Handlebars.partials[\"test1\"]({name : \"yourname\"});\n//do whatever you want with the result\n```\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/precompilation.html](https://handlebarsjs.com/precompilation.html)"
- name: Precompiling Templates Inside NodeJS
  id: precompilation#precompiling_templates_inside_nodejs
  summary: If you wish to precompile templates from inside NodeJS--without invoking "handlebars" from the command line--that can be done with Handlebars.precompile
  belongs_to: Precompilation
  description: "## Precompiling Templates Inside NodeJS\n\nIf you wish to precompile templates from inside NodeJS--without invoking \"handlebars\" from the command line--that can be done with Handlebars.precompile. Transmit the string result of this function to your clients, and they can in turn parse that with Handlebars.template.\n\n``` html\nvar template = \"<div>whatever {{ name }}</div>\";\nvar Handlebars = require(\"handlebars\");\nvar compiled = Handlebars.precompile(template);\n```\n\nOn the client side you have Javascript along the lines of the following.\n\n``` html\nvar template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};\n\nHandlebars.partials[\"test1\"] = template({\"compiler\":[7,\">= 4.0.0\"],\"main\":function(container,depth0,helpers,partials,data) {\n  var helper;\n\n  return \"<div>whatever \"\n  + container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === \"function\" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{\"name\":\"name\",\"hash\":{},\"data\":data}) : helper)))\n  + \"</div>\";\n},\"useData\":true});\n```\n\nFinally, you can reference these templates dynamically in your Javascript.\n\n``` html\nvar result = Handlebars.partials[\"test1\"]({name : \"yourname\"});\n//do whatever you want with the result\n```\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/precompilation.html](https://handlebarsjs.com/precompilation.html)"
- name: Raw Blocks
  id: block_helpers#raw-blocks
  summary: Raw blocks are available for templates needing to handle unprocessed mustache blocks
  belongs_to: Block Helpers
  description: "## Raw Blocks\n\nRaw blocks are available for templates needing to handle unprocessed mustache blocks.\n\n``` html\n{{{{raw-helper}}}}\n  {{bar}}\n{{{{/raw-helper}}}}\n```\n\nwill execute the helper `raw-helper` without interpreting the content.\n\n``` html\nHandlebars.registerHelper('raw-helper', function(options) {\n  return options.fn();\n});\n```\n\nwill render\n\n``` html\n{{bar}}\n```\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/block_helpers.html](https://handlebarsjs.com/block_helpers.html)"
- name: Reference
  id: reference
  summary: Compiles a template so it can be executed immediately
  description: "# Reference\n\n## Base\n\n### `Handlebars.compile(template, options)`\n\nCompiles a template so it can be executed immediately.\n\n``` html\nvar template = Handlebars.compile('{{foo}}');\ntemplate({});\n```\n\nSupports a variety of options that alter how the template executes.\n\n- `data`: Set to false to disable `@data` tracking.\n- `compat`: Set to true to enable recursive field lookup.\n- `knownHelpers`: Hash containing list of helpers that are known to exist (truthy) at template execution time. Passing this allows the compiler to optimize a number of cases. Builtin helpers are automatically included in this list and may be omitted by setting that value to `false`.\n- `knownHelpersOnly`: Set to true to allow further optimzations based on the known helpers list.\n- `noEscape`: Set to true to not HTML escape any content.\n- `strict`: Run in strict mode. In this mode, templates will throw rather than silently ignore missing fields. This has the side effect of disabling inverse operations such as `{{^foo}}{{/foo}}` unless fields are explicitly included in the source object.\n- `assumeObjects`: Removes object existence checks when traversing paths. This is a subset of `strict` mode that generates optimized templates when the data inputs are known to be safe.\n- `preventIndent`: By default, an indented partial-call causes the output of the whole partial being indented by the same amount. This can lead to unexpected behavior when the partial writes `pre`-tags. Setting this option to `true` will disable the auto-indent feature.\n- `ignoreStandalone`: Disables standalone tag removal when set to `true`. When set, blocks and partials that are on their own line will not remove the whitespace on that line.\n- `explicitPartialContext`: Disables implicit context for partials. When enabled, partials that are not passed a context value will execute against an empty object.\n\n### `Handlebars.precompile(template, options)`\n\nPrecompiles a given template so it can be sent to the client and executed without compilation.\n\n``` html\nvar templateSpec = Handlebars.precompile('{{foo}}');\n```\n\nSupports all of the same options parameters as the `Handlebars.compile` method. Additionally may pass:\n\n- `srcName`: Passed to generate the source map for the input file. When run in this manner, the return structure is `{code, map}` with `code` containing the template definition and `map` containing the source map.\n- `destName`: Optional parameter used in conjunction with `srcName` to provide a destination file name when generating source maps.\n\n### `Handlebars.template(templateSpec)`\n\nSets up a template that was precompiled with `Handlebars.precompile`.\n\n``` html\nvar template = Handlebars.template(templateSpec);\ntemplate({});\n```\n\n### `Handlebars.registerPartial(name, partial)`\n\nRegisters partials accessible by any template in the environment.\n\n``` html\nHandlebars.registerPartial('foo', partial);\n```\n\nAlso supports registering multiple partials at once.\n\n``` html\nHandlebars.registerPartial({\n  foo: partial,\n  bar: partial\n});\n```\n\nIf loading the whole library, the partials may be string values which will be compiled on demand. If only loading the runtime, the partials must be a precompiled template that has been set up properly using the `Handlebars.template` method.\n\n### `Handlebars.unregisterPartial(name)`\n\nUnregisters a previously registered partial.\n\n``` html\nHandlebars.unregisterPartial('foo');\n```\n\n### `Handlebars.registerHelper(name, helper)`\n\nRegisters helpers accessible by any template in the environment.\n\n``` html\nHandlebars.registerHelper('foo', function() {\n});\n```\n\nAlso supports registering multiple helpers at once.\n\n``` html\nHandlebars.registerHelper({\n  foo: function() {\n  },\n  bar: function() {\n  }\n});\n```\n\n### `Handlebars.unregisterHelper(name)`\n\nUnregisters a previously registered helper.\n\n``` html\nHandlebars.unregisterHelper('foo');\n```\n\n### `Handlebars.registerDecorator(name, helper)`\n\nRegisters a decorator accessible by any template in the environment.\n\n``` html\nHandlebars.registerDecorator('foo', function() {\n});\n```\n\nAlso supports registering multiple decorators at once.\n\n``` html\nHandlebars.registerDecorator({\n  foo: function() {\n  },\n  bar: function() {\n  }\n});\n```\n\n### `Handlebars.unregisterDecorator(name)`\n\nUnregisters a previously registered decorator.\n\n``` html\nHandlebars.unregisterDecorator('foo');\n```\n\n### `Handlebars.SafeString(string)`\n\nPrevents `string` from being escaped when the template is rendered.\n\n``` html\nnew Handlebars.SafeString('<div>HTML Content!</div>')\n```\n\nWhen constructing the string that will be marked as safe, any external content should be properly escaped using the `Handlebars.escapeExpression` method to avoid potential security concerns.\n\n### `Handlebars.escapeExpression(string)`\n\nHTML escapes the passed string, making it safe for rendering as text within HTML content.\n\n``` html\nHandlebars.Utils.escapeExpression(string)\n```\n\nReplaces `&`, `<`, `>`, `\"`, `'`, `` ` ``, `=` with the HTML entity equivalent value for string values. `SafeString` values are left untouched.\n\nThe output of all expressions except for triple-braced expressions are passed through this method. Helpers should also use this method when returning HTML content via a `SafeString` instance, to prevent possible code injection.\n\nThis method is aliased at `Handlebars.Utils.escapeExpression`.\n\n### `Handlebars.createFrame(data)`\n\nUsed by block helpers to create child data objects.\n\n``` html\nif (options.data) {\n  var data = Handlebars.createFrame(options.data);\n  data.foo = 'bar';\n  options.data = data;\n}\n```\n\nHelpers that modify the data state should create a new frame when doing so, to isolate themselves and avoid corrupting the state of any parents. Generally, only one frame needs to be created per helper execution. For example, the `each` iterator creates a single frame which is reused for all child execution.\n\n### `Handlebars.create()`\n\nCreates an isolated Handlebars environment.\n\n``` html\nvar OtherHandlebars = Handlebars.create();\n```\n\nEach environment has its own helpers and partials. This is only necessary for use cases that demand distinct helpers or partials. Most use cases can use the root `Handlebars` environment directly.\n\nTemplates created for a given environment are bound to that environment. This means that templates that need to run in multiple environments will need to be recompiled or reconstructed via `Handlebars.template` for each environment. This applies to partials as well.\n\n### `Handlebars.noConflict()`\n\nRemoves this Handlebars instance from the global namespace, restoring the global \\`Handlebars\\` variable to its previous value.\n\n``` html\nvar myHandlebars = Handlebars.noConflict();\n```\n\nThis allows for distinct versions of the library to be used simultaneously without concern for version conflicts.\n\n### `Handlebars.log(level, message)`\n\nLogger used by the `log` helper.\n\nMay be overriden if desired.\n\n## Utilities\n\nHandlebars offers a variety of utility methods that are exposed through the `Handlebars.Utils` object.\n\n### `Handlebars.Utils.isEmpty(value)`\n\nDetermines if a given value is empty.\n\n``` html\nHandlebars.Utils.isEmpty(value)\n```\n\nThis is used by the built-in `if` and `with` helpers to control their execution flow. The Handlebars definition of empty is any of:\n\n- Array with length 0\n- falsy values other than 0\n\nThis is intended to match the [Mustache behavior](http://mustache.github.io/mustache.5.html#Sections).\n\n### `Handlebars.Utils.extend(obj, value)`\n\nSimple utility method to augment `obj` with all keys defined on `value`.\n\n``` html\nHandlebars.Utils.extend(foo, {bar: true})\n```\n\nWill set the key `bar` on object `foo` with the value `true`.\n\n### `Handlebars.Utils.toString(obj)`\n\nGeneric `toString` method.\n\n### `Handlebars.Utils.isArray(obj)`\n\nDetermines if an object is an array.\n\n### `Handlebars.Utils.isFunction(obj)`\n\nDetermines if an object is a function.\n\n## @data Variables\n\nThe following `@data` variables are implemented by Handlebars and its builtin helpers.\n\n### `@root`\n\nInitial context with which the template was executed.\n\n``` html\n{{#each array}}\n  {{@root.foo}}\n{{/each}}\n```\n\nUnless explicitly modified, this value is consistent across all portions of the page rendering, meaning it can be used within partials where depthed parameters are unable to reference their parent templates.\n\n### `@first`\n\nSet to true by the `each` helper for the first step of iteration.\n\n``` html\n{{#each array}}\n  {{#if @first}}\n    First!\n  {{/if}}\n{{/each}}\n```\n\n### `@index`\n\nZero-based index for the current iteration step. Set by the `each` helper.\n\n``` html\n{{#each array}}\n  {{@index}}\n{{/each}}\n```\n\n### `@key`\n\nKey name for the current iteration step. Set by the `each` helper when iterating over objects.\n\n``` html\n{{#each array}}\n  {{@key}}\n{{/each}}\n```\n\n### `@last`\n\nSet to true by the `each` helper for the last step of iteration.\n\n``` html\n{{#each array}}\n  {{#if @last}}\n    Last :(\n  {{/if}}\n{{/each}}\n```\n\n### `@level`\n\nAssigned log level.\n\n``` html\ntemplate({}, {data: {level: Handlebars.logger.WARN}})\n```\n\nMay be set to one of `Handlebars.logger.DEBUG` , `Handlebars.logger.INFO` , `Handlebars.logger.WARN` , or `Handlebars.logger.ERROR`\n\nWhen set, the logger will include in its output only messages with a log level of `Handlebars.logger.level` or higher. The default value is `Handlebars.logger.ERROR`.\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/reference.html](https://handlebarsjs.com/reference.html)"
- name: Simple Iterators
  id: block_helpers#iterators
  summary: A common use-case for block helpers is using them to define custom iterators
  belongs_to: Block Helpers
  description: |-
    ## Simple Iterators

    A common use-case for block helpers is using them to define custom iterators. In fact, all Handlebars built-in helpers are defined as regular Handlebars block helpers. Let's take a look at how the built-in `each` helper works.

    ``` html
    <div class="entry">
      <h1>{{title}}</h1>
      {{#with story}}
        <div class="intro">{{{intro}}}</div>
        <div class="body">{{{body}}}</div>
      {{/with}}
    </div>
    <div class="comments">
      {{#each comments}}
        <div class="comment">
          <h2>{{subject}}</h2>
          {{{body}}}
        </div>
      {{/each}}
    </div>
    ```

    In this case, we want to invoke the block passed to `each` once for each element in the comments Array.

    ``` html
    Handlebars.registerHelper('each', function(context, options) {
      var ret = "";

      for(var i=0, j=context.length; i<j; i++) {
        ret = ret + options.fn(context[i]);
      }

      return ret;
    });
    ```

    In this case, we iterate over the items in the passed parameter, invoking the block once with each item. As we iterate, we build up a String result, and then return it.

    This pattern can be used to implement more advanced iterators. For instance, let's create an iterator that creates a `<ul>` wrapper, and wraps each resulting element in an `<li>`.

    ``` html
    {{#list nav}}
      <a href="{{url}}">{{title}}</a>
    {{/list}}
    ```

    You would evaluate this template using something like this as the context:

    ``` html
    {
      nav: [
        { url: "http://www.yehudakatz.com", title: "Katz Got Your Tongue" },
        { url: "http://www.sproutcore.com/block", title: "SproutCore Blog" },
      ]
    }
    ```

    The helper is similar to the original `each` helper.

    ``` html
    Handlebars.registerHelper('list', function(context, options) {
      var ret = "<ul>";

      for(var i=0, j=context.length; i<j; i++) {
        ret = ret + "<li>" + options.fn(context[i]) + "</li>";
      }

      return ret + "</ul>";
    });
    ```

    Using a library like underscore.js or SproutCore's runtime library could make this a bit prettier. For example, here's what it might look like using SproutCore's runtime library:

    ``` html
    Handlebars.registerHelper('list', function(context, options) {
      return "<ul>" + context.map(function(item) {
        return "<li>" + options.fn(item) + "</li>";
      }).join("\n") + "</ul>";
    });
    ```
- name: Subexpressions
  id: expressions#subexpressions
  summary: Handlebars offers support for subexpressions, which allows you to invoke multiple helpers within a single mustache, and pass in the results of inner helper invocations as arguments to outer helpers
  belongs_to: Expressions
  description: |-
    ## Subexpressions

    Handlebars offers support for subexpressions, which allows you to invoke multiple helpers within a single mustache, and pass in the results of inner helper invocations as arguments to outer helpers. Subexpressions are delimited by parentheses.

    ``` html
    {{outer-helper (inner-helper 'abc') 'def'}}
    ```

    In this case, `inner-helper` will get invoked with the string argument `'abc'`, and whatever the `inner-helper` function returns will get passed in as the first argument to `outer-helper` (and `'def'` will get passed in as the second argument to `outer-helper`).
- name: Template comments with {{!-- --}} or {{! }}.
  id: index#comments
  summary: You can use comments in your handlebars code just as you would in your code
  description: |-
    ## Template comments with `{{!-- --}}` or `{{! }}`.

    You can use comments in your handlebars code just as you would in your code. Since there is generally some level of logic, this is a good practice.

    ``` html
    <div class="entry">
      {{!-- only output author name if an author exists --}}
      {{#if author}}
        <h1>{{author.firstName}} {{author.lastName}}</h1>
      {{/if}}
    </div>
    ```

    The comments will not be in the resulting output. If you'd like the comments to show up. Just use html comments, and they will be output.

    ``` html
    <div class="entry">
      {{! This comment will not be in the output }}
      <!-- This comment will be in the output -->
    </div>
    ```

    Any comments that must contain `}}` or other handlebars tokens should use the `{{!-- --}}` syntax.
- name: The blockHelperMissing helper
  id: builtin_helpers#blockHelperMissing
  summary: Implicitly called when a helper can not be directly resolved in the environment's helpers hash
  belongs_to: Builtin Helpers
  description: |-
    ## The `blockHelperMissing` helper

    Implicitly called when a helper can not be directly resolved in the environment's helpers hash.

    ``` html
    {{#foo}}{{/foo}}
    ```

    will call this helper with the resolved value of `foo` on the current context and the `options.name` field set to `"foo"`. For instances where there is no registered helper named `foo`.

    This may be overriden by users that wish to change the behavior of block evaluation. For example

    ``` html
    Handlebars.registerHelper('blockHelperMissing', function(context, options) {
      throw new Handlebars.Exception('Only if or each is allowed');
    });
    ```

    could be used to prevent the use of mustache-style block evaluation in favor of the more efficent `if` and `each` helpers.
- name: The each block helper
  id: builtin_helpers#iteration
  summary: You can iterate over a list using the built-in each helper
  belongs_to: Builtin Helpers
  description: |-
    ## The `each` block helper

    You can iterate over a list using the built-in `each` helper. Inside the block, you can use `this` to reference the element being iterated over.

    ``` html
    <ul class="people_list">
      {{#each people}}
        <li>{{this}}</li>
      {{/each}}
    </ul>
    ```

    when used with this context:

    ``` html
    {
      people: [
        "Yehuda Katz",
        "Alan Johnson",
        "Charles Jolley"
      ]
    }
    ```

    will result in:

    ``` html
    <ul class="people_list">
      <li>Yehuda Katz</li>
      <li>Alan Johnson</li>
      <li>Charles Jolley</li>
    </ul>
    ```

    You can use the `this` expression in any context to reference the current context.

    You can optionally provide an `{{else}}` section which will display only when the list is empty.

    ``` html
    {{#each paragraphs}}
      <p>{{this}}</p>
    {{else}}
      <p class="empty">No content</p>
    {{/each}}
    ```

    When looping through items in `each`, you can optionally reference the current loop index via `{{@index}}`

    ``` html
    {{#each array}}
      {{@index}}: {{this}}
    {{/each}}
    ```

    Additionally for object iteration, `{{@key}}` references the current key name:

    ``` html
    {{#each object}}
      {{@key}}: {{this}}
    {{/each}}
    ```

    The first and last steps of iteration are noted via the `@first` and `@last` variables when iterating over an array. When iterating over an object only the `@first` is available.

    Nested `each` blocks may access the iteration variables via depth based paths. To access the parent index, for example, `{{@../index}}` can be used.

    The `each` helper also supports [block parameters](block_helpers#block-params), allowing for named references anywhere in the block.

    ``` html
    {{#each array as |value key|}}
      {{#each child as |childValue childKey|}}
        {{key}} - {{childKey}}. {{childValue}}
      {{/each}}
    {{/each}}
    ```

    Will create a `key` and `value` variable that children may access without the need for depthed variable references. In the example above, `{{key}}` is identical to `{{@../key}}` but in many cases is more readable.
- name: The helperMissing helper
  id: builtin_helpers#helperMissing
  summary: Internal helper that is called when a potential helper expression was not found in either the environment helpers or the current context
  belongs_to: Builtin Helpers
  description: "## The `helperMissing` helper\n\nInternal helper that is called when a potential helper expression was not found in either the environment helpers or the current context. For cases where both are run, this is run prior to the `blockHelperMissing` helper.\n\n``` html\n{{foo}}\n{{foo bar}}\n{{#foo}}{{/foo}}\n```\n\nWill each call this helper, passing any arguments that would have been otherwise passed to a helper of the same name. This helper is not called when using `knownHelpersOnly` mode.\n\nThis may be overriden by applications. To force the existence of the field, the following may be used:\n\n``` html\nHandlebars.registerHelper('helperMissing', function(/* [args, ] options */) {\n  var options = arguments[arguments.length - 1];\n  throw new Handlebars.Exception('Unknown field: ' + options.name);\n});\n```\n\n© 2011–2017 by Yehuda Katz  \nLicensed under the MIT License.  \n[https://handlebarsjs.com/builtin_helpers.html](https://handlebarsjs.com/builtin_helpers.html)"
- name: The if block helper
  id: builtin_helpers#conditionals
  summary: You can use the if helper to conditionally render a block
  belongs_to: Builtin Helpers
  description: |-
    ## The `if` block helper

    You can use the `if` helper to conditionally render a block. If its argument returns `false`, `undefined`, `null`, `""`, `0`, or `[]`, Handlebars will not render the block.

    ``` html
    <div class="entry">
      {{#if author}}
        <h1>{{firstName}} {{lastName}}</h1>
      {{/if}}
    </div>
    ```

    when used with an empty (`{}`) context, `author` will be `undefined`, resulting in:

    ``` html
    <div class="entry">
    </div>
    ```

    When using a block expression, you can specify a template section to run if the expression returns a falsy value. The section, marked by `{{else}}` is called an "else section".

    ``` html
    <div class="entry">
      {{#if author}}
        <h1>{{firstName}} {{lastName}}</h1>
      {{else}}
        <h1>Unknown Author</h1>
      {{/if}}
    </div>
    ```
- name: The log block helper
  id: builtin_helpers#log
  summary: The log helper allows for logging of context state while executing a template
  belongs_to: Builtin Helpers
  description: |-
    ## The `log` block helper

    The `log` helper allows for logging of context state while executing a template.

    ``` html
    {{log "Look at me!"}}
    ```

    Delegates to `Handlebars.logger.log` which may be overriden to perform custom logging.

    Any number of arguments may be passed to this method and all will be forwarded to the logger.

    ``` html
    {{log "This is logged" foo "And so is this"}}
    ```

    The log level may be set using the `level` hash parameter. Supported values are `debug`, `info`, `warn`, and `error`. When omitted, `info` is the default value,

    ``` html
    {{log "Log!" level="error"}}
    ```

    Logging is conditional based on the level and to value set in `Handlebars.logger.level`, which defaults to `info`. All log statements at or above the current level will be output.
- name: The lookup helper
  id: builtin_helpers#lookup
  summary: The lookup helper allows for dynamic parameter resolution using Handlebars variables
  belongs_to: Builtin Helpers
  description: |-
    ## The `lookup` helper

    The `lookup` helper allows for dynamic parameter resolution using Handlebars variables. This is useful for resolving values for array indexes.

    ``` html
    {{#each bar}}
      {{lookup ../foo @index}}
    {{/each}}
    ```
- name: The unless block helper
  id: builtin_helpers#unless
  summary: You can use the unless helper as the inverse of the if helper
  belongs_to: Builtin Helpers
  description: |-
    ## The `unless` block helper

    You can use the `unless` helper as the inverse of the `if` helper. Its block will be rendered if the expression returns a falsy value.

    ``` html
    <div class="entry">
      {{#unless license}}
      <h3 class="warning">WARNING: This entry does not have a license!</h3>
      {{/unless}}
    </div>
    ```

    If looking up `license` under the current context returns a falsy value, Handlebars will render the warning. Otherwise, it will render nothing.
- name: The with Block Helper
  id: builtin_helpers#with
  summary: Normally, Handlebars templates are evaluated against the context passed into the compiled method
  belongs_to: Builtin Helpers
  description: |-
    ## The `with` Block Helper

    Normally, Handlebars templates are evaluated against the context passed into the compiled method.

    ``` html
    var source   = "<p>{{lastName}}, {{firstName}}</p>";
    var template = Handlebars.compile(source);
    template({firstName: "Alan", lastName: "Johnson"});
    ```

    results in

    ``` html
    <p>Johnson, Alan</p>
    ```

    You can shift the context for a section of a template by using the built-in `with` block helper.

    ``` html
    <div class="entry">
      <h1>{{title}}</h1>

      {{#with author}}
      <h2>By {{firstName}} {{lastName}}</h2>
      {{/with}}
    </div>
    ```

    when used with this context:

    ``` html
    {
      title: "My first post!",
      author: {
        firstName: "Charles",
        lastName: "Jolley"
      }
    }
    ```

    will result in:

    ``` html
    <div class="entry">
      <h1>My first post!</h1>

      <h2>By Charles Jolley</h2>
    </div>
    ```

    `with` can also be used with block parameters to define known references in the current block. The example above can be converted to

    ``` html
    <div class="entry">
      <h1>{{title}}</h1>

      {{#with author as |myAuthor|}}
      <h2>By {{myAuthor.firstName}} {{myAuthor.lastName}}</h2>
      {{/with}}
    </div>
    ```

    Which allows for complex templates to potentially provide clearer code than `../` depthed references allow for.

    You can optionally provide an `{{else}}` section which will display only when the passed value is empty.

    ``` html
    {{#with author}}
      <p>{{name}}</p>
    {{else}}
      <p class="empty">No content</p>
    {{/with}}
    ```
- name: The with helper
  id: block_helpers#with-helper
  summary: The with helper demonstrates how to pass a parameter to your helper
  belongs_to: Block Helpers
  description: |-
    ## The `with` helper

    The `with` helper demonstrates how to pass a parameter to your helper. When a helper is called with a parameter, it is invoked with whatever context the template passed in.

    ``` html
    <div class="entry">
      <h1>{{title}}</h1>
      {{#with story}}
        <div class="intro">{{{intro}}}</div>
        <div class="body">{{{body}}}</div>
      {{/with}}
    </div>
    ```

    You might find a helper like this useful if a section of your JSON object contains deeply nested properties, and you want to avoid repeating the parent name. The above template could be useful with a JSON like:

    ``` html
    {
      title: "First Post",
      story: {
        intro: "Before the jump",
        body: "After the jump"
      }
    }
    ```

    Implementing a helper like this is a lot like implementing the `noop` helper. Helpers can take parameters, and parameters are evaluated just like expressions used directly inside `{{mustache}}` blocks.

    ``` html
    Handlebars.registerHelper('with', function(context, options) {
      return options.fn(context);
    });
    ```

    Parameters are passed to helpers in the order that they are passed, followed by the options hash.
- name: Usage
  id: precompilation#usage
  summary: If using the precompiler's normal mode, the resulting templates will be stored to the Handlebars.templates object using the relative template name sans the extension
  belongs_to: Precompilation
  description: |-
    ## Usage

    ``` html
    Usage: node ./bin/handlebars [template|directory]...

    Options:
      -f, --output         Output File
      --map                Source Map File                                                    [string]  [default: undefined]
      -a, --amd            Exports amd style (require.js)
      -c, --commonjs       Exports CommonJS style, path to Handlebars module                                 [default: null]
      -h, --handlebarPath  Path to handlebar.js (only valid for amd-style)                                     [default: ""]
      -k, --known          Known helpers
      -o, --knownOnly      Known helpers only
      -m, --min            Minimize output
      -n, --namespace      Template namespace                                              [default: "Handlebars.templates"]
      -s, --simple         Output template function only.
      -N, --name           Name of passed string templates. Optional if running in a simple mode. Required when operating
                           on multiple templates.
      -i, --string         Generates a template from the passed CLI argument.
                           "-" is treated as a special value and causes stdin to be read for the template value.
      -r, --root           Template root. Base value that will be stripped from template names.
      -p, --partial        Compiling a partial template
      -d, --data           Include data when compiling
      -e, --extension      Template extension.                                                       [default: "handlebars"]
      -b, --bom            Removes the BOM (Byte Order Mark) from the beginning of the templates.
      -v, --version        Prints the current compiler version
      --help               Outputs this message
    ```

    If using the precompiler's normal mode, the resulting templates will be stored to the `Handlebars.templates` object using the relative template name sans the extension. These templates may be executed in the same manner as templates.

    If using the simple mode the precompiler will generate a single javascript method. To execute this method it must be passed to the `Handlebars.template` method and the resulting object may be used as normal.
- name: Utilities
  id: reference#hutils
  summary: Handlebars offers a variety of utility methods that are exposed through the Handlebars.Utils object
  belongs_to: Reference
  description: |-
    ## Utilities

    Handlebars offers a variety of utility methods that are exposed through the `Handlebars.Utils` object.
- name: Whitespace Control
  id: expressions#whitespace-control
  summary: Template whitespace may be omitted from either side of any mustache statement by adding a ~ character by the braces
  belongs_to: Expressions
  description: |-
    ## Whitespace Control

    Template whitespace may be omitted from either side of any mustache statement by adding a `~` character by the braces. When applied all whitespace on that side will be removed up to the first handlebars expression or non-whitespace character on that side.

    ``` html
    {{#each nav ~}}
      <a href="{{url}}">
        {{~#if test}}
          {{~title}}
        {{~^~}}
          Empty
        {{~/if~}}
      </a>
    {{~/each}}
    ```

    with this context:

    ``` html
    {
      nav: [
        {url: 'foo', test: true, title: 'bar'},
        {url: 'bar'}
      ]
    }
    ```

    results in output sans newlines and formatting whitespace:

    ``` html
    <a href="foo">bar</a><a href="bar">Empty</a>
    ```

    This expands the default behavior of stripping lines that are "standalone" helpers (only a block helper, comment, or partial and whitespace).

    ``` html
    {{#each nav}}
      <a href="{{url}}">
        {{#if test}}
          {{title}}
        {{^}}
          Empty
        {{/if}}
      </a>
    {{~/each}}
    ```

    will render

    ``` html
    <a href="foo">
        bar
    </a>
    <a href="bar">
        Empty
    </a>
    ```
